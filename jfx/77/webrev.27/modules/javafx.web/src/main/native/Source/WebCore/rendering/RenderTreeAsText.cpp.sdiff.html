<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderThemeWin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeAsText.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;

 38 #include &quot;Logging.h&quot;
 39 #include &quot;PrintContext.h&quot;
 40 #include &quot;PseudoElement.h&quot;
 41 #include &quot;RenderBlockFlow.h&quot;
 42 #include &quot;RenderCounter.h&quot;
 43 #include &quot;RenderDetailsMarker.h&quot;
 44 #include &quot;RenderFileUploadControl.h&quot;
 45 #include &quot;RenderFragmentContainer.h&quot;
 46 #include &quot;RenderInline.h&quot;
 47 #include &quot;RenderIterator.h&quot;
 48 #include &quot;RenderLayer.h&quot;
 49 #include &quot;RenderLayerBacking.h&quot;
 50 #include &quot;RenderLineBreak.h&quot;
 51 #include &quot;RenderListItem.h&quot;
 52 #include &quot;RenderListMarker.h&quot;
 53 #include &quot;RenderSVGContainer.h&quot;
 54 #include &quot;RenderSVGGradientStop.h&quot;
 55 #include &quot;RenderSVGImage.h&quot;
 56 #include &quot;RenderSVGInlineText.h&quot;
 57 #include &quot;RenderSVGPath.h&quot;
 58 #include &quot;RenderSVGResourceContainer.h&quot;
 59 #include &quot;RenderSVGRoot.h&quot;
 60 #include &quot;RenderSVGText.h&quot;
 61 #include &quot;RenderTableCell.h&quot;
 62 #include &quot;RenderView.h&quot;
 63 #include &quot;RenderWidget.h&quot;
 64 #include &quot;SVGRenderTreeAsText.h&quot;
 65 #include &quot;ShadowRoot.h&quot;
<span class="line-removed"> 66 #include &quot;SimpleLineLayoutResolver.h&quot;</span>
 67 #include &quot;StyleProperties.h&quot;
 68 #include &lt;wtf/HexNumber.h&gt;
 69 #include &lt;wtf/Vector.h&gt;
 70 #include &lt;wtf/text/TextStream.h&gt;
 71 #include &lt;wtf/unicode/CharacterNames.h&gt;
 72 
 73 #if PLATFORM(MAC)
 74 #include &quot;ScrollbarThemeMac.h&quot;
 75 #endif
 76 
 77 namespace WebCore {
 78 
 79 using namespace HTMLNames;
 80 
<span class="line-modified"> 81 static void writeLayers(TextStream&amp;, const RenderLayer&amp; rootLayer, RenderLayer&amp;, const LayoutRect&amp; paintDirtyRect, RenderAsTextBehavior = RenderAsTextBehaviorNormal);</span>
 82 
 83 static void printBorderStyle(TextStream&amp; ts, const BorderStyle borderStyle)
 84 {
 85     switch (borderStyle) {
 86     case BorderStyle::None:
 87         ts &lt;&lt; &quot;none&quot;;
 88         break;
 89     case BorderStyle::Hidden:
 90         ts &lt;&lt; &quot;hidden&quot;;
 91         break;
 92     case BorderStyle::Inset:
 93         ts &lt;&lt; &quot;inset&quot;;
 94         break;
 95     case BorderStyle::Groove:
 96         ts &lt;&lt; &quot;groove&quot;;
 97         break;
 98     case BorderStyle::Ridge:
 99         ts &lt;&lt; &quot;ridge&quot;;
100         break;
101     case BorderStyle::Outset:
</pre>
<hr />
<pre>
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
163                 appendUnsignedAsHex(c, result);
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
<span class="line-modified">172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, RenderAsTextBehavior behavior)</span>
173 {
174     ts &lt;&lt; o.renderName();
175 
<span class="line-modified">176     if (behavior &amp; RenderAsTextShowAddresses)</span>
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
179     if (o.style().zIndex())
180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().zIndex();
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<span class="line-modified">205         if (!text.firstTextBox() &amp;&amp; !text.simpleLineLayout())</span>

206             adjustForTableCells = false;
207     } else if (o.isBR()) {
208         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
209         IntRect linesBox = br.linesBoundingBox();
210         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
211         if (!br.inlineBoxWrapper())
212             adjustForTableCells = false;
213     } else if (is&lt;RenderInline&gt;(o)) {
214         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
215         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
216         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
217         adjustForTableCells = false;
218     } else if (is&lt;RenderTableCell&gt;(o)) {
219         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
220         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
221         // captured by the results.
222         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
223         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
224     } else if (is&lt;RenderBox&gt;(o))
225         r = downcast&lt;RenderBox&gt;(o).frameRect();
</pre>
<hr />
<pre>
392                     case bullet:
393                         text = &quot;bullet&quot;;
394                         break;
395                     case blackSquare:
396                         text = &quot;black square&quot;;
397                         break;
398                     case whiteBullet:
399                         text = &quot;white bullet&quot;;
400                         break;
401                     default:
402                         text = quoteAndEscapeNonPrintables(text);
403                 }
404             }
405             ts &lt;&lt; &quot;: &quot; &lt;&lt; text;
406         }
407     }
408 
409     writeDebugInfo(ts, o, behavior);
410 }
411 
<span class="line-modified">412 void writeDebugInfo(TextStream&amp; ts, const RenderObject&amp; object, RenderAsTextBehavior behavior)</span>
413 {
<span class="line-modified">414     if (behavior &amp; RenderAsTextShowIDAndClass) {</span>
415         if (Element* element = is&lt;Element&gt;(object.node()) ? downcast&lt;Element&gt;(object.node()) : nullptr) {
416             if (element-&gt;hasID())
417                 ts &lt;&lt; &quot; id=\&quot;&quot; + element-&gt;getIdAttribute() + &quot;\&quot;&quot;;
418 
419             if (element-&gt;hasClass()) {
420                 ts &lt;&lt; &quot; class=\&quot;&quot;;
421                 for (size_t i = 0; i &lt; element-&gt;classNames().size(); ++i) {
422                     if (i &gt; 0)
423                         ts &lt;&lt; &quot; &quot;;
424                     ts &lt;&lt; element-&gt;classNames()[i];
425                 }
426                 ts &lt;&lt; &quot;\&quot;&quot;;
427             }
428         }
429     }
430 
<span class="line-modified">431     if (behavior &amp; RenderAsTextShowLayoutState) {</span>
432         bool needsLayout = object.selfNeedsLayout() || object.needsPositionedMovementLayout() || object.posChildNeedsLayout() || object.normalChildNeedsLayout();
433         if (needsLayout)
434             ts &lt;&lt; &quot; (needs layout:&quot;;
435 
436         bool havePrevious = false;
437         if (object.selfNeedsLayout()) {
438             ts &lt;&lt; &quot; self&quot;;
439             havePrevious = true;
440         }
441 
442         if (object.needsPositionedMovementLayout()) {
443             if (havePrevious)
444                 ts &lt;&lt; &quot;,&quot;;
445             havePrevious = true;
446             ts &lt;&lt; &quot; positioned movement&quot;;
447         }
448 
449         if (object.normalChildNeedsLayout()) {
450             if (havePrevious)
451                 ts &lt;&lt; &quot;,&quot;;
452             havePrevious = true;
453             ts &lt;&lt; &quot; child&quot;;
454         }
455 
456         if (object.posChildNeedsLayout()) {
457             if (havePrevious)
458                 ts &lt;&lt; &quot;,&quot;;
459             ts &lt;&lt; &quot; positioned child&quot;;
460         }
461 
462         if (needsLayout)
463             ts &lt;&lt; &quot;)&quot;;
464     }
465 
<span class="line-modified">466     if (behavior &amp; RenderAsTextShowOverflow &amp;&amp; is&lt;RenderBox&gt;(object)) {</span>
467         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
468         if (box.hasRenderOverflow()) {
469             LayoutRect layoutOverflow = box.layoutOverflowRect();
470             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
471 
472             if (box.hasVisualOverflow()) {
473                 LayoutRect visualOverflow = box.visualOverflowRect();
474                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
475             }
476         }
477     }
478 }
479 
<span class="line-modified">480 static void writeTextRun(TextStream&amp; ts, const RenderText&amp; o, const InlineTextBox&amp; run)</span>
481 {
<span class="line-modified">482     // FIXME: For now use an &quot;enclosingIntRect&quot; model for x, y and logicalWidth, although this makes it harder</span>
<span class="line-modified">483     // to detect any changes caused by the conversion to floating point. :(</span>
<span class="line-modified">484     int x = run.x();</span>
<span class="line-modified">485     int y = run.y();</span>
<span class="line-modified">486     int logicalWidth = ceilf(run.left() + run.logicalWidth()) - x;</span>



487 
488     // FIXME: Table cell adjustment is temporary until results can be updated.
489     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
490         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
491 
492     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
<span class="line-modified">493     if (!run.isLeftToRightDirection() || run.dirOverride()) {</span>
<span class="line-modified">494         ts &lt;&lt; (!run.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);</span>
<span class="line-modified">495         if (run.dirOverride())</span>
496             ts &lt;&lt; &quot; override&quot;;
497     }
498     ts &lt;&lt; &quot;: &quot;
<span class="line-modified">499         &lt;&lt; quoteAndEscapeNonPrintables(String(o.text()).substring(run.start(), run.len()));</span>
<span class="line-modified">500     if (run.hasHyphen())</span>
501         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
502     ts &lt;&lt; &quot;\n&quot;;
503 }
504 
<span class="line-modified">505 static void writeSimpleLine(TextStream&amp; ts, const RenderText&amp; renderText, const SimpleLineLayout::RunResolver::Run&amp; run)</span>
<span class="line-removed">506 {</span>
<span class="line-removed">507     auto rect = run.rect();</span>
<span class="line-removed">508     int x = rect.x();</span>
<span class="line-removed">509     int y = rect.y();</span>
<span class="line-removed">510     int logicalWidth = ceilf(rect.x() + rect.width()) - x;</span>
<span class="line-removed">511 </span>
<span class="line-removed">512     if (is&lt;RenderTableCell&gt;(*renderText.containingBlock()))</span>
<span class="line-removed">513         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*renderText.containingBlock()).intrinsicPaddingBefore());</span>
<span class="line-removed">514 </span>
<span class="line-removed">515     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;</span>
<span class="line-removed">516     ts &lt;&lt; &quot;: &quot; &lt;&lt; quoteAndEscapeNonPrintables(run.text());</span>
<span class="line-removed">517     if (run.hasHyphen())</span>
<span class="line-removed">518         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(renderText.style().hyphenString().string());</span>
<span class="line-removed">519     ts &lt;&lt; &quot;\n&quot;;</span>
<span class="line-removed">520 }</span>
<span class="line-removed">521 </span>
<span class="line-removed">522 void write(TextStream&amp; ts, const RenderObject&amp; o, RenderAsTextBehavior behavior)</span>
523 {
524     if (is&lt;RenderSVGShape&gt;(o)) {
525         write(ts, downcast&lt;RenderSVGShape&gt;(o), behavior);
526         return;
527     }
528     if (is&lt;RenderSVGGradientStop&gt;(o)) {
529         writeSVGGradientStop(ts, downcast&lt;RenderSVGGradientStop&gt;(o), behavior);
530         return;
531     }
532     if (is&lt;RenderSVGResourceContainer&gt;(o)) {
533         writeSVGResourceContainer(ts, downcast&lt;RenderSVGResourceContainer&gt;(o), behavior);
534         return;
535     }
536     if (is&lt;RenderSVGContainer&gt;(o)) {
537         writeSVGContainer(ts, downcast&lt;RenderSVGContainer&gt;(o), behavior);
538         return;
539     }
540     if (is&lt;RenderSVGRoot&gt;(o)) {
541         write(ts, downcast&lt;RenderSVGRoot&gt;(o), behavior);
542         return;
</pre>
<hr />
<pre>
546         return;
547     }
548     if (is&lt;RenderSVGInlineText&gt;(o)) {
549         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
550         return;
551     }
552     if (is&lt;RenderSVGImage&gt;(o)) {
553         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
554         return;
555     }
556 
557     ts &lt;&lt; indent;
558 
559     RenderTreeAsText::writeRenderObject(ts, o, behavior);
560     ts &lt;&lt; &quot;\n&quot;;
561 
562     TextStream::IndentScope indentScope(ts);
563 
564     if (is&lt;RenderText&gt;(o)) {
565         auto&amp; text = downcast&lt;RenderText&gt;(o);
<span class="line-modified">566         if (auto layout = text.simpleLineLayout()) {</span>
<span class="line-modified">567             ASSERT(!text.firstTextBox());</span>
<span class="line-modified">568             auto resolver = runResolver(downcast&lt;RenderBlockFlow&gt;(*text.parent()), *layout);</span>
<span class="line-removed">569             for (auto run : resolver.rangeForRenderer(text)) {</span>
<span class="line-removed">570                 ts &lt;&lt; indent;</span>
<span class="line-removed">571                 writeSimpleLine(ts, text, run);</span>
<span class="line-removed">572             }</span>
<span class="line-removed">573         } else {</span>
<span class="line-removed">574             for (auto* box = text.firstTextBox(); box; box = box-&gt;nextTextBox()) {</span>
<span class="line-removed">575                 ts &lt;&lt; indent;</span>
<span class="line-removed">576                 writeTextRun(ts, text, *box);</span>
<span class="line-removed">577             }</span>
578         }
<span class="line-removed">579 </span>
580     } else {
581         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
582             if (child.hasLayer())
583                 continue;
584             write(ts, child, behavior);
585         }
586     }
587 
588     if (is&lt;RenderWidget&gt;(o)) {
589         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
590         if (is&lt;FrameView&gt;(widget)) {
591             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
592             if (RenderView* root = view.frame().contentRenderer()) {
<span class="line-modified">593                 if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
594                     view.layoutContext().layout();
595                 if (RenderLayer* layer = root-&gt;layer())
596                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
597             }
598         }
599     }
600 }
601 
602 enum LayerPaintPhase {
603     LayerPaintPhaseAll = 0,
604     LayerPaintPhaseBackground = -1,
605     LayerPaintPhaseForeground = 1
606 };
607 
608 static void writeLayer(TextStream&amp; ts, const RenderLayer&amp; layer, const LayoutRect&amp; layerBounds, const LayoutRect&amp; backgroundClipRect, const LayoutRect&amp; clipRect,
<span class="line-modified">609     LayerPaintPhase paintPhase = LayerPaintPhaseAll, RenderAsTextBehavior behavior = RenderAsTextBehaviorNormal)</span>
610 {
611     IntRect adjustedLayoutBounds = snappedIntRect(layerBounds);
612     IntRect adjustedBackgroundClipRect = snappedIntRect(backgroundClipRect);
613     IntRect adjustedClipRect = snappedIntRect(clipRect);
614 
615     ts &lt;&lt; indent &lt;&lt; &quot;layer &quot;;
616 
<span class="line-modified">617     if (behavior &amp; RenderAsTextShowAddresses)</span>
618         ts &lt;&lt; static_cast&lt;const void*&gt;(&amp;layer) &lt;&lt; &quot; &quot;;
619 
620     ts &lt;&lt; adjustedLayoutBounds;
621 
622     if (!adjustedLayoutBounds.isEmpty()) {
623         if (!adjustedBackgroundClipRect.contains(adjustedLayoutBounds))
624             ts &lt;&lt; &quot; backgroundClip &quot; &lt;&lt; adjustedBackgroundClipRect;
625         if (!adjustedClipRect.contains(adjustedLayoutBounds))
626             ts &lt;&lt; &quot; clip &quot; &lt;&lt; adjustedClipRect;
627     }
628 
629     if (layer.renderer().hasOverflowClip()) {
630         if (layer.scrollOffset().x())
631             ts &lt;&lt; &quot; scrollX &quot; &lt;&lt; layer.scrollOffset().x();
632         if (layer.scrollOffset().y())
633             ts &lt;&lt; &quot; scrollY &quot; &lt;&lt; layer.scrollOffset().y();
634         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientWidth()) != layer.scrollWidth())
635             ts &lt;&lt; &quot; scrollWidth &quot; &lt;&lt; layer.scrollWidth();
636         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientHeight()) != layer.scrollHeight())
637             ts &lt;&lt; &quot; scrollHeight &quot; &lt;&lt; layer.scrollHeight();
638 #if PLATFORM(MAC)
639         ScrollbarTheme&amp; scrollbarTheme = ScrollbarTheme::theme();
640         if (!scrollbarTheme.isMockTheme() &amp;&amp; layer.hasVerticalScrollbar()) {
641             ScrollbarThemeMac&amp; macTheme = *static_cast&lt;ScrollbarThemeMac*&gt;(&amp;scrollbarTheme);
642             if (macTheme.isLayoutDirectionRTL(*layer.verticalScrollbar()))
643                 ts &lt;&lt; &quot; scrollbarHasRTLLayoutDirection&quot;;
644         }
645 #endif
646     }
647 
648     if (paintPhase == LayerPaintPhaseBackground)
649         ts &lt;&lt; &quot; layerType: background only&quot;;
650     else if (paintPhase == LayerPaintPhaseForeground)
651         ts &lt;&lt; &quot; layerType: foreground only&quot;;
652 
<span class="line-modified">653     if (behavior &amp; RenderAsTextShowCompositedLayers) {</span>
654         if (layer.isComposited()) {
655             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
656                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
<span class="line-modified">657         }</span>

658     }
659 
660 #if ENABLE(CSS_COMPOSITING)
661     if (layer.isolatesBlending())
662         ts &lt;&lt; &quot; isolatesBlending&quot;;
663     if (layer.hasBlendMode())
664         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, layer.blendMode());
665 #endif
666 
667     ts &lt;&lt; &quot;\n&quot;;
668 }
669 
<span class="line-modified">670 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, RenderAsTextBehavior behavior)</span>
671 {
672     if (paintPhase != LayerPaintPhaseBackground) {
673         TextStream::IndentScope indentScope(ts);
674         write(ts, layer.renderer(), behavior);
675     }
676 }
677 
678 static LayoutSize maxLayoutOverflow(const RenderBox* box)
679 {
680     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
681     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
682 }
683 
<span class="line-modified">684 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, RenderAsTextBehavior behavior)</span>
685 {
686     // FIXME: Apply overflow to the root layer to not break every test. Complete hack. Sigh.
687     LayoutRect paintDirtyRect(paintRect);
688     if (&amp;rootLayer == &amp;layer) {
689         paintDirtyRect.setWidth(std::max&lt;LayoutUnit&gt;(paintDirtyRect.width(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxX()));
690         paintDirtyRect.setHeight(std::max&lt;LayoutUnit&gt;(paintDirtyRect.height(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxY()));
691         layer.setSize(layer.size().expandedTo(snappedIntSize(maxLayoutOverflow(layer.renderBox()), LayoutPoint(0, 0))));
692     }
693 
694     // Calculate the clip rects we should use.
695     LayoutRect layerBounds;
696     ClipRect damageRect;
697     ClipRect clipRectToApply;
698     LayoutSize offsetFromRoot = layer.offsetFromAncestor(&amp;rootLayer);
699     layer.calculateRects(RenderLayer::ClipRectsContext(&amp;rootLayer, TemporaryClipRects), paintDirtyRect, layerBounds, damageRect, clipRectToApply, offsetFromRoot);
700 
701     // Ensure our lists are up-to-date.
702     layer.updateLayerListsIfNeeded();
703     layer.updateDescendantDependentFlags();
704 
<span class="line-modified">705     bool shouldPaint = (behavior &amp; RenderAsTextShowAllLayers) ? true : layer.intersectsDamageRect(layerBounds, damageRect.rect(), &amp;rootLayer, layer.offsetFromAncestor(&amp;rootLayer));</span>
706     auto negativeZOrderLayers = layer.negativeZOrderLayers();
707     bool paintsBackgroundSeparately = negativeZOrderLayers.size() &gt; 0;
708     if (shouldPaint &amp;&amp; paintsBackgroundSeparately) {
709         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), LayerPaintPhaseBackground, behavior);
710         writeLayerRenderers(ts, layer, LayerPaintPhaseBackground, behavior);
711     }
712 
713     if (negativeZOrderLayers.size()) {
<span class="line-modified">714         if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">715             ts &lt;&lt; indent &lt;&lt; &quot; negative z-order list(&quot; &lt;&lt; negativeZOrderLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
716             ts.increaseIndent();
717         }
718 
719         for (auto* currLayer : negativeZOrderLayers)
720             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
721 
<span class="line-modified">722         if (behavior &amp; RenderAsTextShowLayerNesting)</span>
723             ts.decreaseIndent();
724     }
725 
726     if (shouldPaint) {
727         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
728 
<span class="line-modified">729         if (behavior &amp; RenderAsTextShowLayerFragments) {</span>
730             LayerFragments layerFragments;
731             layer.collectFragments(layerFragments, &amp;rootLayer, paintDirtyRect, RenderLayer::PaginationInclusionMode::ExcludeCompositedPaginatedLayers, TemporaryClipRects, IgnoreOverlayScrollbarSize, RespectOverflowClip, offsetFromRoot);
732 
733             if (layerFragments.size() &gt; 1) {
734                 TextStream::IndentScope indentScope(ts, 2);
735                 for (unsigned i = 0; i &lt; layerFragments.size(); ++i) {
736                     const auto&amp; fragment = layerFragments[i];
737                     ts &lt;&lt; indent &lt;&lt; &quot; fragment &quot; &lt;&lt; i &lt;&lt; &quot;: bounds in layer &quot; &lt;&lt; fragment.layerBounds &lt;&lt; &quot; fragment bounds &quot; &lt;&lt; fragment.boundingBox &lt;&lt; &quot;\n&quot;;
738                 }
739             }
740         }
741 
742         writeLayerRenderers(ts, layer, paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
743     }
744 
745     auto normalFlowLayers = layer.normalFlowLayers();
746     if (normalFlowLayers.size()) {
<span class="line-modified">747         if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">748             ts &lt;&lt; indent &lt;&lt; &quot; normal flow list(&quot; &lt;&lt; normalFlowLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
749             ts.increaseIndent();
750         }
751 
752         for (auto* currLayer : normalFlowLayers)
753             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
754 
<span class="line-modified">755         if (behavior &amp; RenderAsTextShowLayerNesting)</span>
756             ts.decreaseIndent();
757     }
758 
759     auto positiveZOrderLayers = layer.positiveZOrderLayers();
760     if (positiveZOrderLayers.size()) {
761         size_t layerCount = positiveZOrderLayers.size();
762 
763         if (layerCount) {
<span class="line-modified">764             if (behavior &amp; RenderAsTextShowLayerNesting) {</span>
<span class="line-modified">765                 ts &lt;&lt; indent &lt;&lt; &quot; positive z-order list(&quot; &lt;&lt; layerCount &lt;&lt; &quot;)\n&quot;;</span>
766                 ts.increaseIndent();
767             }
768 
769             for (auto* currLayer : positiveZOrderLayers)
770                 writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
771 
<span class="line-modified">772             if (behavior &amp; RenderAsTextShowLayerNesting)</span>
773                 ts.decreaseIndent();
774         }
775     }
776 }
777 
778 static String nodePosition(Node* node)
779 {
780     StringBuilder result;
781 
782     auto* body = node-&gt;document().bodyOrFrameset();
783     Node* parent;
784     for (Node* n = node; n; n = parent) {
785         parent = n-&gt;parentOrShadowHostNode();
786         if (n != node)
787             result.appendLiteral(&quot; of &quot;);
788         if (parent) {
789             if (body &amp;&amp; n == body) {
790                 // We don&#39;t care what offset body may be in the document.
791                 result.appendLiteral(&quot;body&quot;);
792                 break;
</pre>
<hr />
<pre>
812 static void writeSelection(TextStream&amp; ts, const RenderBox&amp; renderer)
813 {
814     if (!renderer.isRenderView())
815         return;
816 
817     Frame* frame = renderer.document().frame();
818     if (!frame)
819         return;
820 
821     VisibleSelection selection = frame-&gt;selection().selection();
822     if (selection.isCaret()) {
823         ts &lt;&lt; &quot;caret: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode());
824         if (selection.affinity() == UPSTREAM)
825             ts &lt;&lt; &quot; (upstream affinity)&quot;;
826         ts &lt;&lt; &quot;\n&quot;;
827     } else if (selection.isRange())
828         ts &lt;&lt; &quot;selection start: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode()) &lt;&lt; &quot;\n&quot;
829            &lt;&lt; &quot;selection end:   position &quot; &lt;&lt; selection.end().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.end().deprecatedNode()) &lt;&lt; &quot;\n&quot;;
830 }
831 
<span class="line-modified">832 static String externalRepresentation(RenderBox&amp; renderer, RenderAsTextBehavior behavior)</span>
833 {
834     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
835     if (!renderer.hasLayer())
836         return ts.release();
837 
838     LOG(Layout, &quot;externalRepresentation: dumping layer tree&quot;);
839 
840     RenderLayer&amp; layer = *renderer.layer();
841     writeLayers(ts, layer, layer, layer.rect(), behavior);
842     writeSelection(ts, renderer);
843     return ts.release();
844 }
845 
846 static void updateLayoutIgnoringPendingStylesheetsIncludingSubframes(Document&amp; document)
847 {
848     document.updateLayoutIgnorePendingStylesheets();
849     auto* frame = document.frame();
850     for (auto* subframe = frame; subframe; subframe = subframe-&gt;tree().traverseNext(frame)) {
851         if (auto* document = subframe-&gt;document())
852             document-&gt;updateLayoutIgnorePendingStylesheets();
853     }
854 }
855 
<span class="line-modified">856 String externalRepresentation(Frame* frame, RenderAsTextBehavior behavior)</span>
857 {
858     ASSERT(frame);
859     ASSERT(frame-&gt;document());
860 
<span class="line-modified">861     if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
862         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(*frame-&gt;document());
863 
864     auto* renderer = frame-&gt;contentRenderer();
865     if (!renderer)
866         return String();
867 
868     PrintContext printContext(frame);
<span class="line-modified">869     if (behavior &amp; RenderAsTextPrintingMode)</span>
870         printContext.begin(renderer-&gt;width());
871 
872     return externalRepresentation(*renderer, behavior);
873 }
874 
<span class="line-modified">875 String externalRepresentation(Element* element, RenderAsTextBehavior behavior)</span>
876 {
877     ASSERT(element);
878 
879     // This function doesn&#39;t support printing mode.
<span class="line-modified">880     ASSERT(!(behavior &amp; RenderAsTextPrintingMode));</span>
881 
<span class="line-modified">882     if (!(behavior &amp; RenderAsTextDontUpdateLayout))</span>
883         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(element-&gt;document());
884 
885     auto* renderer = element-&gt;renderer();
886     if (!is&lt;RenderBox&gt;(renderer))
887         return String();
888 
<span class="line-modified">889     return externalRepresentation(downcast&lt;RenderBox&gt;(*renderer), behavior | RenderAsTextShowAllLayers);</span>
890 }
891 
892 static void writeCounterValuesFromChildren(TextStream&amp; stream, const RenderElement* parent, bool&amp; isFirstCounter)
893 {
894     if (!parent)
895         return;
896     for (auto&amp; counter : childrenOfType&lt;RenderCounter&gt;(*parent)) {
897         if (!isFirstCounter)
898             stream &lt;&lt; &quot; &quot;;
899         isFirstCounter = false;
900         String str(counter.text());
901         stream &lt;&lt; str;
902     }
903 }
904 
905 String counterValueForElement(Element* element)
906 {
907     // Make sure the element is not freed during the layout.
908     RefPtr&lt;Element&gt; elementRef(element);
909     element-&gt;document().updateLayout();
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
<span class="line-added"> 38 #include &quot;LineLayoutInterfaceTextBoxes.h&quot;</span>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;PrintContext.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderCounter.h&quot;
 44 #include &quot;RenderDetailsMarker.h&quot;
 45 #include &quot;RenderFileUploadControl.h&quot;
 46 #include &quot;RenderFragmentContainer.h&quot;
 47 #include &quot;RenderInline.h&quot;
 48 #include &quot;RenderIterator.h&quot;
 49 #include &quot;RenderLayer.h&quot;
 50 #include &quot;RenderLayerBacking.h&quot;
 51 #include &quot;RenderLineBreak.h&quot;
 52 #include &quot;RenderListItem.h&quot;
 53 #include &quot;RenderListMarker.h&quot;
 54 #include &quot;RenderSVGContainer.h&quot;
 55 #include &quot;RenderSVGGradientStop.h&quot;
 56 #include &quot;RenderSVGImage.h&quot;
 57 #include &quot;RenderSVGInlineText.h&quot;
 58 #include &quot;RenderSVGPath.h&quot;
 59 #include &quot;RenderSVGResourceContainer.h&quot;
 60 #include &quot;RenderSVGRoot.h&quot;
 61 #include &quot;RenderSVGText.h&quot;
 62 #include &quot;RenderTableCell.h&quot;
 63 #include &quot;RenderView.h&quot;
 64 #include &quot;RenderWidget.h&quot;
 65 #include &quot;SVGRenderTreeAsText.h&quot;
 66 #include &quot;ShadowRoot.h&quot;

 67 #include &quot;StyleProperties.h&quot;
 68 #include &lt;wtf/HexNumber.h&gt;
 69 #include &lt;wtf/Vector.h&gt;
 70 #include &lt;wtf/text/TextStream.h&gt;
 71 #include &lt;wtf/unicode/CharacterNames.h&gt;
 72 
 73 #if PLATFORM(MAC)
 74 #include &quot;ScrollbarThemeMac.h&quot;
 75 #endif
 76 
 77 namespace WebCore {
 78 
 79 using namespace HTMLNames;
 80 
<span class="line-modified"> 81 static void writeLayers(TextStream&amp;, const RenderLayer&amp; rootLayer, RenderLayer&amp;, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;RenderAsTextFlag&gt;);</span>
 82 
 83 static void printBorderStyle(TextStream&amp; ts, const BorderStyle borderStyle)
 84 {
 85     switch (borderStyle) {
 86     case BorderStyle::None:
 87         ts &lt;&lt; &quot;none&quot;;
 88         break;
 89     case BorderStyle::Hidden:
 90         ts &lt;&lt; &quot;hidden&quot;;
 91         break;
 92     case BorderStyle::Inset:
 93         ts &lt;&lt; &quot;inset&quot;;
 94         break;
 95     case BorderStyle::Groove:
 96         ts &lt;&lt; &quot;groove&quot;;
 97         break;
 98     case BorderStyle::Ridge:
 99         ts &lt;&lt; &quot;ridge&quot;;
100         break;
101     case BorderStyle::Outset:
</pre>
<hr />
<pre>
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
163                 appendUnsignedAsHex(c, result);
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
<span class="line-modified">172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
173 {
174     ts &lt;&lt; o.renderName();
175 
<span class="line-modified">176     if (behavior.contains(RenderAsTextFlag::ShowAddresses))</span>
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
179     if (o.style().zIndex())
180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().zIndex();
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<span class="line-modified">205         auto textBoxes = LineLayoutInterface::textBoxes(text);</span>
<span class="line-added">206         if (textBoxes.begin() == textBoxes.end())</span>
207             adjustForTableCells = false;
208     } else if (o.isBR()) {
209         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
210         IntRect linesBox = br.linesBoundingBox();
211         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
212         if (!br.inlineBoxWrapper())
213             adjustForTableCells = false;
214     } else if (is&lt;RenderInline&gt;(o)) {
215         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
216         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
217         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
218         adjustForTableCells = false;
219     } else if (is&lt;RenderTableCell&gt;(o)) {
220         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
221         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
222         // captured by the results.
223         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
224         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
225     } else if (is&lt;RenderBox&gt;(o))
226         r = downcast&lt;RenderBox&gt;(o).frameRect();
</pre>
<hr />
<pre>
393                     case bullet:
394                         text = &quot;bullet&quot;;
395                         break;
396                     case blackSquare:
397                         text = &quot;black square&quot;;
398                         break;
399                     case whiteBullet:
400                         text = &quot;white bullet&quot;;
401                         break;
402                     default:
403                         text = quoteAndEscapeNonPrintables(text);
404                 }
405             }
406             ts &lt;&lt; &quot;: &quot; &lt;&lt; text;
407         }
408     }
409 
410     writeDebugInfo(ts, o, behavior);
411 }
412 
<span class="line-modified">413 void writeDebugInfo(TextStream&amp; ts, const RenderObject&amp; object, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
414 {
<span class="line-modified">415     if (behavior.contains(RenderAsTextFlag::ShowIDAndClass)) {</span>
416         if (Element* element = is&lt;Element&gt;(object.node()) ? downcast&lt;Element&gt;(object.node()) : nullptr) {
417             if (element-&gt;hasID())
418                 ts &lt;&lt; &quot; id=\&quot;&quot; + element-&gt;getIdAttribute() + &quot;\&quot;&quot;;
419 
420             if (element-&gt;hasClass()) {
421                 ts &lt;&lt; &quot; class=\&quot;&quot;;
422                 for (size_t i = 0; i &lt; element-&gt;classNames().size(); ++i) {
423                     if (i &gt; 0)
424                         ts &lt;&lt; &quot; &quot;;
425                     ts &lt;&lt; element-&gt;classNames()[i];
426                 }
427                 ts &lt;&lt; &quot;\&quot;&quot;;
428             }
429         }
430     }
431 
<span class="line-modified">432     if (behavior.contains(RenderAsTextFlag::ShowLayoutState)) {</span>
433         bool needsLayout = object.selfNeedsLayout() || object.needsPositionedMovementLayout() || object.posChildNeedsLayout() || object.normalChildNeedsLayout();
434         if (needsLayout)
435             ts &lt;&lt; &quot; (needs layout:&quot;;
436 
437         bool havePrevious = false;
438         if (object.selfNeedsLayout()) {
439             ts &lt;&lt; &quot; self&quot;;
440             havePrevious = true;
441         }
442 
443         if (object.needsPositionedMovementLayout()) {
444             if (havePrevious)
445                 ts &lt;&lt; &quot;,&quot;;
446             havePrevious = true;
447             ts &lt;&lt; &quot; positioned movement&quot;;
448         }
449 
450         if (object.normalChildNeedsLayout()) {
451             if (havePrevious)
452                 ts &lt;&lt; &quot;,&quot;;
453             havePrevious = true;
454             ts &lt;&lt; &quot; child&quot;;
455         }
456 
457         if (object.posChildNeedsLayout()) {
458             if (havePrevious)
459                 ts &lt;&lt; &quot;,&quot;;
460             ts &lt;&lt; &quot; positioned child&quot;;
461         }
462 
463         if (needsLayout)
464             ts &lt;&lt; &quot;)&quot;;
465     }
466 
<span class="line-modified">467     if (behavior.contains(RenderAsTextFlag::ShowOverflow) &amp;&amp; is&lt;RenderBox&gt;(object)) {</span>
468         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
469         if (box.hasRenderOverflow()) {
470             LayoutRect layoutOverflow = box.layoutOverflowRect();
471             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
472 
473             if (box.hasVisualOverflow()) {
474                 LayoutRect visualOverflow = box.visualOverflowRect();
475                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
476             }
477         }
478     }
479 }
480 
<span class="line-modified">481 static void writeTextBox(TextStream&amp; ts, const RenderText&amp; o, const LineLayoutInterface::TextBox&amp; textBox)</span>
482 {
<span class="line-modified">483     auto rect = textBox.rect();</span>
<span class="line-modified">484     auto logicalRect = textBox.logicalRect();</span>
<span class="line-modified">485 </span>
<span class="line-modified">486     int x = rect.x();</span>
<span class="line-modified">487     int y = rect.y();</span>
<span class="line-added">488 </span>
<span class="line-added">489     // FIXME: Mixing logical and physical here doesn&#39;t make sense.</span>
<span class="line-added">490     int logicalWidth = ceilf(rect.x() + logicalRect.width()) - x;</span>
491 
492     // FIXME: Table cell adjustment is temporary until results can be updated.
493     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
494         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
495 
496     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
<span class="line-modified">497     if (!textBox.isLeftToRightDirection() || textBox.dirOverride()) {</span>
<span class="line-modified">498         ts &lt;&lt; (!textBox.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);</span>
<span class="line-modified">499         if (textBox.dirOverride())</span>
500             ts &lt;&lt; &quot; override&quot;;
501     }
502     ts &lt;&lt; &quot;: &quot;
<span class="line-modified">503         &lt;&lt; quoteAndEscapeNonPrintables(textBox.text());</span>
<span class="line-modified">504     if (textBox.hasHyphen())</span>
505         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
506     ts &lt;&lt; &quot;\n&quot;;
507 }
508 
<span class="line-modified">509 void write(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>

















510 {
511     if (is&lt;RenderSVGShape&gt;(o)) {
512         write(ts, downcast&lt;RenderSVGShape&gt;(o), behavior);
513         return;
514     }
515     if (is&lt;RenderSVGGradientStop&gt;(o)) {
516         writeSVGGradientStop(ts, downcast&lt;RenderSVGGradientStop&gt;(o), behavior);
517         return;
518     }
519     if (is&lt;RenderSVGResourceContainer&gt;(o)) {
520         writeSVGResourceContainer(ts, downcast&lt;RenderSVGResourceContainer&gt;(o), behavior);
521         return;
522     }
523     if (is&lt;RenderSVGContainer&gt;(o)) {
524         writeSVGContainer(ts, downcast&lt;RenderSVGContainer&gt;(o), behavior);
525         return;
526     }
527     if (is&lt;RenderSVGRoot&gt;(o)) {
528         write(ts, downcast&lt;RenderSVGRoot&gt;(o), behavior);
529         return;
</pre>
<hr />
<pre>
533         return;
534     }
535     if (is&lt;RenderSVGInlineText&gt;(o)) {
536         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
537         return;
538     }
539     if (is&lt;RenderSVGImage&gt;(o)) {
540         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
541         return;
542     }
543 
544     ts &lt;&lt; indent;
545 
546     RenderTreeAsText::writeRenderObject(ts, o, behavior);
547     ts &lt;&lt; &quot;\n&quot;;
548 
549     TextStream::IndentScope indentScope(ts);
550 
551     if (is&lt;RenderText&gt;(o)) {
552         auto&amp; text = downcast&lt;RenderText&gt;(o);
<span class="line-modified">553         for (auto textBox : LineLayoutInterface::textBoxes(text)) {</span>
<span class="line-modified">554             ts &lt;&lt; indent;</span>
<span class="line-modified">555             writeTextBox(ts, text, textBox);</span>









556         }

557     } else {
558         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
559             if (child.hasLayer())
560                 continue;
561             write(ts, child, behavior);
562         }
563     }
564 
565     if (is&lt;RenderWidget&gt;(o)) {
566         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
567         if (is&lt;FrameView&gt;(widget)) {
568             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
569             if (RenderView* root = view.frame().contentRenderer()) {
<span class="line-modified">570                 if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))</span>
571                     view.layoutContext().layout();
572                 if (RenderLayer* layer = root-&gt;layer())
573                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
574             }
575         }
576     }
577 }
578 
579 enum LayerPaintPhase {
580     LayerPaintPhaseAll = 0,
581     LayerPaintPhaseBackground = -1,
582     LayerPaintPhaseForeground = 1
583 };
584 
585 static void writeLayer(TextStream&amp; ts, const RenderLayer&amp; layer, const LayoutRect&amp; layerBounds, const LayoutRect&amp; backgroundClipRect, const LayoutRect&amp; clipRect,
<span class="line-modified">586     LayerPaintPhase paintPhase = LayerPaintPhaseAll, OptionSet&lt;RenderAsTextFlag&gt; behavior = { })</span>
587 {
588     IntRect adjustedLayoutBounds = snappedIntRect(layerBounds);
589     IntRect adjustedBackgroundClipRect = snappedIntRect(backgroundClipRect);
590     IntRect adjustedClipRect = snappedIntRect(clipRect);
591 
592     ts &lt;&lt; indent &lt;&lt; &quot;layer &quot;;
593 
<span class="line-modified">594     if (behavior.contains(RenderAsTextFlag::ShowAddresses))</span>
595         ts &lt;&lt; static_cast&lt;const void*&gt;(&amp;layer) &lt;&lt; &quot; &quot;;
596 
597     ts &lt;&lt; adjustedLayoutBounds;
598 
599     if (!adjustedLayoutBounds.isEmpty()) {
600         if (!adjustedBackgroundClipRect.contains(adjustedLayoutBounds))
601             ts &lt;&lt; &quot; backgroundClip &quot; &lt;&lt; adjustedBackgroundClipRect;
602         if (!adjustedClipRect.contains(adjustedLayoutBounds))
603             ts &lt;&lt; &quot; clip &quot; &lt;&lt; adjustedClipRect;
604     }
605 
606     if (layer.renderer().hasOverflowClip()) {
607         if (layer.scrollOffset().x())
608             ts &lt;&lt; &quot; scrollX &quot; &lt;&lt; layer.scrollOffset().x();
609         if (layer.scrollOffset().y())
610             ts &lt;&lt; &quot; scrollY &quot; &lt;&lt; layer.scrollOffset().y();
611         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientWidth()) != layer.scrollWidth())
612             ts &lt;&lt; &quot; scrollWidth &quot; &lt;&lt; layer.scrollWidth();
613         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientHeight()) != layer.scrollHeight())
614             ts &lt;&lt; &quot; scrollHeight &quot; &lt;&lt; layer.scrollHeight();
615 #if PLATFORM(MAC)
616         ScrollbarTheme&amp; scrollbarTheme = ScrollbarTheme::theme();
617         if (!scrollbarTheme.isMockTheme() &amp;&amp; layer.hasVerticalScrollbar()) {
618             ScrollbarThemeMac&amp; macTheme = *static_cast&lt;ScrollbarThemeMac*&gt;(&amp;scrollbarTheme);
619             if (macTheme.isLayoutDirectionRTL(*layer.verticalScrollbar()))
620                 ts &lt;&lt; &quot; scrollbarHasRTLLayoutDirection&quot;;
621         }
622 #endif
623     }
624 
625     if (paintPhase == LayerPaintPhaseBackground)
626         ts &lt;&lt; &quot; layerType: background only&quot;;
627     else if (paintPhase == LayerPaintPhaseForeground)
628         ts &lt;&lt; &quot; layerType: foreground only&quot;;
629 
<span class="line-modified">630     if (behavior.contains(RenderAsTextFlag::ShowCompositedLayers)) {</span>
631         if (layer.isComposited()) {
632             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
633                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
<span class="line-modified">634         } else if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">635             ts &lt;&lt; &quot; (shared backing of &quot; &lt;&lt; layer.backingProviderLayer() &lt;&lt; &quot;)&quot;;</span>
636     }
637 
638 #if ENABLE(CSS_COMPOSITING)
639     if (layer.isolatesBlending())
640         ts &lt;&lt; &quot; isolatesBlending&quot;;
641     if (layer.hasBlendMode())
642         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, layer.blendMode());
643 #endif
644 
645     ts &lt;&lt; &quot;\n&quot;;
646 }
647 
<span class="line-modified">648 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
649 {
650     if (paintPhase != LayerPaintPhaseBackground) {
651         TextStream::IndentScope indentScope(ts);
652         write(ts, layer.renderer(), behavior);
653     }
654 }
655 
656 static LayoutSize maxLayoutOverflow(const RenderBox* box)
657 {
658     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
659     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
660 }
661 
<span class="line-modified">662 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
663 {
664     // FIXME: Apply overflow to the root layer to not break every test. Complete hack. Sigh.
665     LayoutRect paintDirtyRect(paintRect);
666     if (&amp;rootLayer == &amp;layer) {
667         paintDirtyRect.setWidth(std::max&lt;LayoutUnit&gt;(paintDirtyRect.width(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxX()));
668         paintDirtyRect.setHeight(std::max&lt;LayoutUnit&gt;(paintDirtyRect.height(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxY()));
669         layer.setSize(layer.size().expandedTo(snappedIntSize(maxLayoutOverflow(layer.renderBox()), LayoutPoint(0, 0))));
670     }
671 
672     // Calculate the clip rects we should use.
673     LayoutRect layerBounds;
674     ClipRect damageRect;
675     ClipRect clipRectToApply;
676     LayoutSize offsetFromRoot = layer.offsetFromAncestor(&amp;rootLayer);
677     layer.calculateRects(RenderLayer::ClipRectsContext(&amp;rootLayer, TemporaryClipRects), paintDirtyRect, layerBounds, damageRect, clipRectToApply, offsetFromRoot);
678 
679     // Ensure our lists are up-to-date.
680     layer.updateLayerListsIfNeeded();
681     layer.updateDescendantDependentFlags();
682 
<span class="line-modified">683     bool shouldPaint = (behavior.contains(RenderAsTextFlag::ShowAllLayers)) ? true : layer.intersectsDamageRect(layerBounds, damageRect.rect(), &amp;rootLayer, layer.offsetFromAncestor(&amp;rootLayer));</span>
684     auto negativeZOrderLayers = layer.negativeZOrderLayers();
685     bool paintsBackgroundSeparately = negativeZOrderLayers.size() &gt; 0;
686     if (shouldPaint &amp;&amp; paintsBackgroundSeparately) {
687         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), LayerPaintPhaseBackground, behavior);
688         writeLayerRenderers(ts, layer, LayerPaintPhaseBackground, behavior);
689     }
690 
691     if (negativeZOrderLayers.size()) {
<span class="line-modified">692         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {</span>
<span class="line-modified">693             ts &lt;&lt; indent &lt;&lt; &quot; negative z-order list (&quot; &lt;&lt; negativeZOrderLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
694             ts.increaseIndent();
695         }
696 
697         for (auto* currLayer : negativeZOrderLayers)
698             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
699 
<span class="line-modified">700         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))</span>
701             ts.decreaseIndent();
702     }
703 
704     if (shouldPaint) {
705         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
706 
<span class="line-modified">707         if (behavior.contains(RenderAsTextFlag::ShowLayerFragments)) {</span>
708             LayerFragments layerFragments;
709             layer.collectFragments(layerFragments, &amp;rootLayer, paintDirtyRect, RenderLayer::PaginationInclusionMode::ExcludeCompositedPaginatedLayers, TemporaryClipRects, IgnoreOverlayScrollbarSize, RespectOverflowClip, offsetFromRoot);
710 
711             if (layerFragments.size() &gt; 1) {
712                 TextStream::IndentScope indentScope(ts, 2);
713                 for (unsigned i = 0; i &lt; layerFragments.size(); ++i) {
714                     const auto&amp; fragment = layerFragments[i];
715                     ts &lt;&lt; indent &lt;&lt; &quot; fragment &quot; &lt;&lt; i &lt;&lt; &quot;: bounds in layer &quot; &lt;&lt; fragment.layerBounds &lt;&lt; &quot; fragment bounds &quot; &lt;&lt; fragment.boundingBox &lt;&lt; &quot;\n&quot;;
716                 }
717             }
718         }
719 
720         writeLayerRenderers(ts, layer, paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
721     }
722 
723     auto normalFlowLayers = layer.normalFlowLayers();
724     if (normalFlowLayers.size()) {
<span class="line-modified">725         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {</span>
<span class="line-modified">726             ts &lt;&lt; indent &lt;&lt; &quot; normal flow list (&quot; &lt;&lt; normalFlowLayers.size() &lt;&lt; &quot;)\n&quot;;</span>
727             ts.increaseIndent();
728         }
729 
730         for (auto* currLayer : normalFlowLayers)
731             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
732 
<span class="line-modified">733         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))</span>
734             ts.decreaseIndent();
735     }
736 
737     auto positiveZOrderLayers = layer.positiveZOrderLayers();
738     if (positiveZOrderLayers.size()) {
739         size_t layerCount = positiveZOrderLayers.size();
740 
741         if (layerCount) {
<span class="line-modified">742             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {</span>
<span class="line-modified">743                 ts &lt;&lt; indent &lt;&lt; &quot; positive z-order list (&quot; &lt;&lt; layerCount &lt;&lt; &quot;)\n&quot;;</span>
744                 ts.increaseIndent();
745             }
746 
747             for (auto* currLayer : positiveZOrderLayers)
748                 writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
749 
<span class="line-modified">750             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))</span>
751                 ts.decreaseIndent();
752         }
753     }
754 }
755 
756 static String nodePosition(Node* node)
757 {
758     StringBuilder result;
759 
760     auto* body = node-&gt;document().bodyOrFrameset();
761     Node* parent;
762     for (Node* n = node; n; n = parent) {
763         parent = n-&gt;parentOrShadowHostNode();
764         if (n != node)
765             result.appendLiteral(&quot; of &quot;);
766         if (parent) {
767             if (body &amp;&amp; n == body) {
768                 // We don&#39;t care what offset body may be in the document.
769                 result.appendLiteral(&quot;body&quot;);
770                 break;
</pre>
<hr />
<pre>
790 static void writeSelection(TextStream&amp; ts, const RenderBox&amp; renderer)
791 {
792     if (!renderer.isRenderView())
793         return;
794 
795     Frame* frame = renderer.document().frame();
796     if (!frame)
797         return;
798 
799     VisibleSelection selection = frame-&gt;selection().selection();
800     if (selection.isCaret()) {
801         ts &lt;&lt; &quot;caret: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode());
802         if (selection.affinity() == UPSTREAM)
803             ts &lt;&lt; &quot; (upstream affinity)&quot;;
804         ts &lt;&lt; &quot;\n&quot;;
805     } else if (selection.isRange())
806         ts &lt;&lt; &quot;selection start: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode()) &lt;&lt; &quot;\n&quot;
807            &lt;&lt; &quot;selection end:   position &quot; &lt;&lt; selection.end().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.end().deprecatedNode()) &lt;&lt; &quot;\n&quot;;
808 }
809 
<span class="line-modified">810 static String externalRepresentation(RenderBox&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
811 {
812     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
813     if (!renderer.hasLayer())
814         return ts.release();
815 
816     LOG(Layout, &quot;externalRepresentation: dumping layer tree&quot;);
817 
818     RenderLayer&amp; layer = *renderer.layer();
819     writeLayers(ts, layer, layer, layer.rect(), behavior);
820     writeSelection(ts, renderer);
821     return ts.release();
822 }
823 
824 static void updateLayoutIgnoringPendingStylesheetsIncludingSubframes(Document&amp; document)
825 {
826     document.updateLayoutIgnorePendingStylesheets();
827     auto* frame = document.frame();
828     for (auto* subframe = frame; subframe; subframe = subframe-&gt;tree().traverseNext(frame)) {
829         if (auto* document = subframe-&gt;document())
830             document-&gt;updateLayoutIgnorePendingStylesheets();
831     }
832 }
833 
<span class="line-modified">834 String externalRepresentation(Frame* frame, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
835 {
836     ASSERT(frame);
837     ASSERT(frame-&gt;document());
838 
<span class="line-modified">839     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))</span>
840         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(*frame-&gt;document());
841 
842     auto* renderer = frame-&gt;contentRenderer();
843     if (!renderer)
844         return String();
845 
846     PrintContext printContext(frame);
<span class="line-modified">847     if (behavior.contains(RenderAsTextFlag::PrintingMode))</span>
848         printContext.begin(renderer-&gt;width());
849 
850     return externalRepresentation(*renderer, behavior);
851 }
852 
<span class="line-modified">853 String externalRepresentation(Element* element, OptionSet&lt;RenderAsTextFlag&gt; behavior)</span>
854 {
855     ASSERT(element);
856 
857     // This function doesn&#39;t support printing mode.
<span class="line-modified">858     ASSERT(!(behavior.contains(RenderAsTextFlag::PrintingMode)));</span>
859 
<span class="line-modified">860     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))</span>
861         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(element-&gt;document());
862 
863     auto* renderer = element-&gt;renderer();
864     if (!is&lt;RenderBox&gt;(renderer))
865         return String();
866 
<span class="line-modified">867     return externalRepresentation(downcast&lt;RenderBox&gt;(*renderer), behavior | RenderAsTextFlag::ShowAllLayers);</span>
868 }
869 
870 static void writeCounterValuesFromChildren(TextStream&amp; stream, const RenderElement* parent, bool&amp; isFirstCounter)
871 {
872     if (!parent)
873         return;
874     for (auto&amp; counter : childrenOfType&lt;RenderCounter&gt;(*parent)) {
875         if (!isFirstCounter)
876             stream &lt;&lt; &quot; &quot;;
877         isFirstCounter = false;
878         String str(counter.text());
879         stream &lt;&lt; str;
880     }
881 }
882 
883 String counterValueForElement(Element* element)
884 {
885     // Make sure the element is not freed during the layout.
886     RefPtr&lt;Element&gt; elementRef(element);
887     element-&gt;document().updateLayout();
</pre>
</td>
</tr>
</table>
<center><a href="RenderThemeWin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeAsText.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>