<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityMenuListOption.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 161 void AccessibilityNodeObject::updateAccessibilityRole()
 162 {
 163     bool ignoredStatus = accessibilityIsIgnored();
 164     m_role = determineAccessibilityRole();
 165 
 166     // The AX hierarchy only needs to be updated if the ignored status of an element has changed.
 167     if (ignoredStatus != accessibilityIsIgnored())
 168         childrenChanged();
 169 }
 170 
 171 AccessibilityObject* AccessibilityNodeObject::firstChild() const
 172 {
 173     if (!node())
 174         return nullptr;
 175 
 176     Node* firstChild = node()-&gt;firstChild();
 177 
 178     if (!firstChild)
 179         return nullptr;
 180 
<span class="line-modified"> 181     return axObjectCache()-&gt;getOrCreate(firstChild);</span>

 182 }
 183 
 184 AccessibilityObject* AccessibilityNodeObject::lastChild() const
 185 {
 186     if (!node())
 187         return nullptr;
 188 
 189     Node* lastChild = node()-&gt;lastChild();
 190     if (!lastChild)
 191         return nullptr;
 192 
<span class="line-modified"> 193     return axObjectCache()-&gt;getOrCreate(lastChild);</span>

 194 }
 195 
 196 AccessibilityObject* AccessibilityNodeObject::previousSibling() const
 197 {
 198     if (!node())
 199         return nullptr;
 200 
 201     Node* previousSibling = node()-&gt;previousSibling();
 202     if (!previousSibling)
 203         return nullptr;
 204 
<span class="line-modified"> 205     return axObjectCache()-&gt;getOrCreate(previousSibling);</span>

 206 }
 207 
 208 AccessibilityObject* AccessibilityNodeObject::nextSibling() const
 209 {
 210     if (!node())
 211         return nullptr;
 212 
 213     Node* nextSibling = node()-&gt;nextSibling();
 214     if (!nextSibling)
 215         return nullptr;
 216 
<span class="line-modified"> 217     return axObjectCache()-&gt;getOrCreate(nextSibling);</span>

 218 }
 219 
 220 AccessibilityObject* AccessibilityNodeObject::parentObjectIfExists() const
 221 {
 222     return parentObject();
 223 }
 224 
 225 AccessibilityObject* AccessibilityNodeObject::parentObject() const
 226 {
 227     if (!node())
 228         return nullptr;
 229 
 230     Node* parentObj = node()-&gt;parentNode();
 231     if (!parentObj)
 232         return nullptr;
 233 
 234     if (AXObjectCache* cache = axObjectCache())
 235         return cache-&gt;getOrCreate(parentObj);
 236 
 237     return nullptr;
</pre>
<hr />
<pre>
 328         return AccessibilityRole::Group;
 329 
 330     return AccessibilityRole::Unknown;
 331 }
 332 
 333 void AccessibilityNodeObject::addChildren()
 334 {
 335     // If the need to add more children in addition to existing children arises,
 336     // childrenChanged should have been called, leaving the object with no children.
 337     ASSERT(!m_haveChildren);
 338 
 339     if (!m_node)
 340         return;
 341 
 342     m_haveChildren = true;
 343 
 344     // The only time we add children from the DOM tree to a node with a renderer is when it&#39;s a canvas.
 345     if (renderer() &amp;&amp; !m_node-&gt;hasTagName(canvasTag))
 346         return;
 347 




 348     for (Node* child = m_node-&gt;firstChild(); child; child = child-&gt;nextSibling())
<span class="line-modified"> 349         addChild(axObjectCache()-&gt;getOrCreate(child));</span>
 350 
 351     m_subtreeDirty = false;
 352 }
 353 
 354 bool AccessibilityNodeObject::canHaveChildren() const
 355 {
 356     // If this is an AccessibilityRenderObject, then it&#39;s okay if this object
 357     // doesn&#39;t have a node - there are some renderers that don&#39;t have associated
 358     // nodes, like scroll areas and css-generated text.
 359     if (!node() &amp;&amp; !isAccessibilityRenderObject())
 360         return false;
 361 
 362     // When &lt;noscript&gt; is not being used (its renderer() == 0), ignore its children.
 363     if (node() &amp;&amp; !renderer() &amp;&amp; node()-&gt;hasTagName(noscriptTag))
 364         return false;
 365 
 366     // Elements that should not have children
 367     switch (roleValue()) {
 368     case AccessibilityRole::Image:
 369     case AccessibilityRole::Button:
 370     case AccessibilityRole::PopUpButton:
 371     case AccessibilityRole::CheckBox:
 372     case AccessibilityRole::RadioButton:
 373     case AccessibilityRole::Tab:
 374     case AccessibilityRole::ToggleButton:
 375     case AccessibilityRole::StaticText:
 376     case AccessibilityRole::ListBoxOption:
 377     case AccessibilityRole::ScrollBar:
 378     case AccessibilityRole::ProgressIndicator:
 379     case AccessibilityRole::Switch:
 380     case AccessibilityRole::MenuItemCheckbox:
 381     case AccessibilityRole::MenuItemRadio:
 382     case AccessibilityRole::Splitter:

 383         return false;
 384     case AccessibilityRole::DocumentMath:
 385 #if ENABLE(MATHML)
 386         return node()-&gt;isMathMLElement();
 387 #endif
 388         return false;
 389     default:
 390         return true;
 391     }
 392 }
 393 
 394 bool AccessibilityNodeObject::computeAccessibilityIsIgnored() const
 395 {
 396 #ifndef NDEBUG
 397     // Double-check that an AccessibilityObject is never accessed before
 398     // it&#39;s been initialized.
 399     ASSERT(m_initialized);
 400 #endif
 401 
 402     // Handle non-rendered text that is exposed through aria-hidden=false.
</pre>
<hr />
<pre>
 462 
 463 bool AccessibilityNodeObject::isSearchField() const
 464 {
 465     Node* node = this-&gt;node();
 466     if (!node)
 467         return false;
 468 
 469     if (roleValue() == AccessibilityRole::SearchField)
 470         return true;
 471 
 472     if (!is&lt;HTMLInputElement&gt;(*node))
 473         return false;
 474 
 475     auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(*node);
 476 
 477     // Some websites don&#39;t label their search fields as such. However, they will
 478     // use the word &quot;search&quot; in either the form or input type. This won&#39;t catch every case,
 479     // but it will catch google.com for example.
 480 
 481     // Check the node name of the input type, sometimes it&#39;s &quot;search&quot;.
<span class="line-modified"> 482     const AtomicString&amp; nameAttribute = getAttribute(nameAttr);</span>
 483     if (nameAttribute.containsIgnoringASCIICase(&quot;search&quot;))
 484         return true;
 485 
 486     // Check the form action and the name, which will sometimes be &quot;search&quot;.
 487     auto* form = inputElement.form();
 488     if (form &amp;&amp; (form-&gt;name().containsIgnoringASCIICase(&quot;search&quot;) || form-&gt;action().containsIgnoringASCIICase(&quot;search&quot;)))
 489         return true;
 490 
 491     return false;
 492 }
 493 
 494 bool AccessibilityNodeObject::isNativeImage() const
 495 {
 496     Node* node = this-&gt;node();
 497     if (!node)
 498         return false;
 499 
 500     if (is&lt;HTMLImageElement&gt;(*node))
 501         return true;
 502 
</pre>
<hr />
<pre>
 543 
 544     if (auto* cache = axObjectCache())
 545         return cache-&gt;getOrCreate(element);
 546 
 547     return nullptr;
 548 }
 549 
 550 bool AccessibilityNodeObject::isInputImage() const
 551 {
 552     Node* node = this-&gt;node();
 553     if (is&lt;HTMLInputElement&gt;(node) &amp;&amp; roleValue() == AccessibilityRole::Button) {
 554         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 555         return input.isImageButton();
 556     }
 557 
 558     return false;
 559 }
 560 
 561 bool AccessibilityNodeObject::isProgressIndicator() const
 562 {
<span class="line-modified"> 563     return roleValue() == AccessibilityRole::ProgressIndicator;</span>
 564 }
 565 
 566 bool AccessibilityNodeObject::isSlider() const
 567 {
 568     return roleValue() == AccessibilityRole::Slider;
 569 }
 570 
 571 bool AccessibilityNodeObject::isMenuRelated() const
 572 {
 573     switch (roleValue()) {
 574     case AccessibilityRole::Menu:
 575     case AccessibilityRole::MenuBar:
 576     case AccessibilityRole::MenuButton:
 577     case AccessibilityRole::MenuItem:
 578     case AccessibilityRole::MenuItemCheckbox:
 579     case AccessibilityRole::MenuItemRadio:
 580         return true;
 581     default:
 582         return false;
 583     }
</pre>
<hr />
<pre>
 607         return true;
 608     default:
 609         return false;
 610     }
 611 }
 612 
 613 bool AccessibilityNodeObject::isNativeCheckboxOrRadio() const
 614 {
 615     Node* node = this-&gt;node();
 616     if (!is&lt;HTMLInputElement&gt;(node))
 617         return false;
 618 
 619     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 620     return input.isCheckbox() || input.isRadioButton();
 621 }
 622 
 623 bool AccessibilityNodeObject::isEnabled() const
 624 {
 625     // ARIA says that the disabled status applies to the current element and all descendant elements.
 626     for (AccessibilityObject* object = const_cast&lt;AccessibilityNodeObject*&gt;(this); object; object = object-&gt;parentObject()) {
<span class="line-modified"> 627         const AtomicString&amp; disabledStatus = object-&gt;getAttribute(aria_disabledAttr);</span>
 628         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;true&quot;))
 629             return false;
 630         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;false&quot;))
 631             break;
 632     }
 633 
 634     if (roleValue() == AccessibilityRole::HorizontalRule)
 635         return false;
 636 
 637     Node* node = this-&gt;node();
 638     if (!is&lt;Element&gt;(node))
 639         return true;
 640 
 641     return !downcast&lt;Element&gt;(*node).isDisabledFormControl();
 642 }
 643 
 644 bool AccessibilityNodeObject::isIndeterminate() const
 645 {
 646     return equalLettersIgnoringASCIICase(getAttribute(indeterminateAttr), &quot;true&quot;);
 647 }
</pre>
<hr />
<pre>
 686         validRole = true;
 687         break;
 688     default:
 689         break;
 690     }
 691 
 692     if (validRole &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(aria_checkedAttr), &quot;true&quot;))
 693         return true;
 694 
 695     return false;
 696 }
 697 
 698 bool AccessibilityNodeObject::isHovered() const
 699 {
 700     Node* node = this-&gt;node();
 701     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hovered();
 702 }
 703 
 704 bool AccessibilityNodeObject::isMultiSelectable() const
 705 {
<span class="line-modified"> 706     const AtomicString&amp; ariaMultiSelectable = getAttribute(aria_multiselectableAttr);</span>
 707     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;true&quot;))
 708         return true;
 709     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;false&quot;))
 710         return false;
 711 
 712     return node() &amp;&amp; node()-&gt;hasTagName(selectTag) &amp;&amp; downcast&lt;HTMLSelectElement&gt;(*node()).multiple();
 713 }
 714 
 715 bool AccessibilityNodeObject::isRequired() const
 716 {
 717     // Explicit aria-required values should trump native required attributes.
<span class="line-modified"> 718     const AtomicString&amp; requiredValue = getAttribute(aria_requiredAttr);</span>
 719     if (equalLettersIgnoringASCIICase(requiredValue, &quot;true&quot;))
 720         return true;
 721     if (equalLettersIgnoringASCIICase(requiredValue, &quot;false&quot;))
 722         return false;
 723 
 724     Node* n = this-&gt;node();
 725     if (is&lt;HTMLFormControlElement&gt;(n))
 726         return downcast&lt;HTMLFormControlElement&gt;(*n).isRequired();
 727 
 728     return false;
 729 }
 730 
 731 bool AccessibilityNodeObject::supportsRequiredAttribute() const
 732 {
 733     switch (roleValue()) {
 734     case AccessibilityRole::Button:
 735         return isFileUploadButton();
 736     case AccessibilityRole::Cell:
 737     case AccessibilityRole::ColumnHeader:
 738     case AccessibilityRole::CheckBox:
</pre>
<hr />
<pre>
 868 {
 869     return getAttribute(stepAttr).toFloat();
 870 }
 871 
 872 bool AccessibilityNodeObject::isHeading() const
 873 {
 874     return roleValue() == AccessibilityRole::Heading;
 875 }
 876 
 877 bool AccessibilityNodeObject::isLink() const
 878 {
 879     return roleValue() == AccessibilityRole::WebCoreLink;
 880 }
 881 
 882 bool AccessibilityNodeObject::isControl() const
 883 {
 884     Node* node = this-&gt;node();
 885     if (!node)
 886         return false;
 887 
<span class="line-modified"> 888     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute());</span>
 889 }
 890 
 891 bool AccessibilityNodeObject::isFieldset() const
 892 {
 893     Node* node = this-&gt;node();
 894     if (!node)
 895         return false;
 896 
 897     return node-&gt;hasTagName(fieldsetTag);
 898 }
 899 
 900 bool AccessibilityNodeObject::isGroup() const
 901 {
 902     AccessibilityRole role = roleValue();
 903     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 904 }
 905 
 906 AccessibilityObject* AccessibilityNodeObject::selectedRadioButton()
 907 {
 908     if (!isRadioGroup())
</pre>
<hr />
<pre>
 931             return child.get();
 932     }
 933     return nullptr;
 934 }
 935 
 936 AccessibilityButtonState AccessibilityNodeObject::checkboxOrRadioValue() const
 937 {
 938     if (isNativeCheckboxOrRadio())
 939         return isIndeterminate() ? AccessibilityButtonState::Mixed : isChecked() ? AccessibilityButtonState::On : AccessibilityButtonState::Off;
 940 
 941     return AccessibilityObject::checkboxOrRadioValue();
 942 }
 943 
 944 Element* AccessibilityNodeObject::anchorElement() const
 945 {
 946     Node* node = this-&gt;node();
 947     if (!node)
 948         return nullptr;
 949 
 950     AXObjectCache* cache = axObjectCache();


 951 
 952     // search up the DOM tree for an anchor element
 953     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 954     for ( ; node; node = node-&gt;parentNode()) {
 955         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 956             return downcast&lt;Element&gt;(node);
 957     }
 958 
 959     return nullptr;
 960 }
 961 
 962 static bool isNodeActionElement(Node* node)
 963 {
 964     if (is&lt;HTMLInputElement&gt;(*node)) {
 965         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 966         if (!input.isDisabledFormControl() &amp;&amp; (input.isRadioButton() || input.isCheckbox() || input.isTextButton() || input.isFileUpload() || input.isImageButton()))
 967             return true;
 968     } else if (node-&gt;hasTagName(buttonTag) || node-&gt;hasTagName(selectTag))
 969         return true;
 970 
</pre>
<hr />
<pre>
1059     return false;
1060 }
1061 
1062 void AccessibilityNodeObject::alterSliderValue(bool increase)
1063 {
1064     if (roleValue() != AccessibilityRole::Slider)
1065         return;
1066 
1067     auto element = this-&gt;element();
1068     if (!element || element-&gt;isDisabledFormControl())
1069         return;
1070 
1071     if (!getAttribute(stepAttr).isEmpty())
1072         changeValueByStep(increase);
1073     else
1074         changeValueByPercent(increase ? 5 : -5);
1075 }
1076 
1077 void AccessibilityNodeObject::increment()
1078 {
<span class="line-removed">1079     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Increment))</span>
<span class="line-removed">1080         return;</span>
1081     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1082     alterSliderValue(true);
1083 }
1084 
1085 void AccessibilityNodeObject::decrement()
1086 {
<span class="line-removed">1087     if (dispatchAccessibilityEventWithType(AccessibilityEventType::Decrement))</span>
<span class="line-removed">1088         return;</span>
1089     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1090     alterSliderValue(false);
1091 }
1092 
1093 void AccessibilityNodeObject::changeValueByStep(bool increase)
1094 {
1095     float step = stepValueForRange();
1096     float value = valueForRange();
1097 
1098     value += increase ? step : -step;
1099 
<span class="line-modified">1100     setValue(String::number(value));</span>
1101 
<span class="line-modified">1102     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>


1103 }
1104 
1105 void AccessibilityNodeObject::changeValueByPercent(float percentChange)
1106 {
1107     float range = maxValueForRange() - minValueForRange();
1108     float step = range * (percentChange / 100);
1109     float value = valueForRange();
1110 
1111     // Make sure the specified percent will cause a change of one integer step or larger.
<span class="line-modified">1112     if (fabs(step) &lt; 1)</span>
<span class="line-modified">1113         step = fabs(percentChange) * (1 / percentChange);</span>
1114 
1115     value += step;
<span class="line-modified">1116     setValue(String::number(value));</span>
1117 
<span class="line-modified">1118     axObjectCache()-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>


1119 }
1120 
1121 bool AccessibilityNodeObject::isGenericFocusableElement() const
1122 {
1123     if (!canSetFocusAttribute())
1124         return false;
1125 
1126     // If it&#39;s a control, it&#39;s not generic.
1127     if (isControl())
1128         return false;
1129 
1130     AccessibilityRole role = roleValue();
1131     if (role == AccessibilityRole::Video || role == AccessibilityRole::Audio)
1132         return false;
1133 
1134     // If it has an aria role, it&#39;s not generic.
1135     if (m_ariaRole != AccessibilityRole::Unknown)
1136         return false;
1137 
1138     // If the content editable attribute is set on this element, that&#39;s the reason
</pre>
<hr />
<pre>
1145     // The web area and body element are both focusable, but existing logic handles these
1146     // cases already, so we don&#39;t need to include them here.
1147     if (role == AccessibilityRole::WebArea)
1148         return false;
1149     if (node() &amp;&amp; node()-&gt;hasTagName(bodyTag))
1150         return false;
1151 
1152     // An SVG root is focusable by default, but it&#39;s probably not interactive, so don&#39;t
1153     // include it. It can still be made accessible by giving it an ARIA role.
1154     if (role == AccessibilityRole::SVGRoot)
1155         return false;
1156 
1157     return true;
1158 }
1159 
1160 HTMLLabelElement* AccessibilityNodeObject::labelForElement(Element* element) const
1161 {
1162     if (!is&lt;HTMLElement&gt;(*element) || !downcast&lt;HTMLElement&gt;(*element).isLabelable())
1163         return nullptr;
1164 
<span class="line-modified">1165     const AtomicString&amp; id = element-&gt;getIdAttribute();</span>
1166     if (!id.isEmpty()) {
1167         if (HTMLLabelElement* label = element-&gt;treeScope().labelElementForId(id))
1168             return label;
1169     }
1170 
1171     return ancestorsOfType&lt;HTMLLabelElement&gt;(*element).first();
1172 }
1173 
1174 String AccessibilityNodeObject::ariaAccessibilityDescription() const
1175 {
1176     String ariaLabeledBy = ariaLabeledByAttribute();
1177     if (!ariaLabeledBy.isEmpty())
1178         return ariaLabeledBy;
1179 
<span class="line-modified">1180     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1181     if (!ariaLabel.isEmpty())
1182         return ariaLabel;
1183 
1184     return String();
1185 }
1186 
1187 static Element* siblingWithAriaRole(Node* node, const char* role)
1188 {
1189     // FIXME: Either we should add a null check here or change the function to take a reference instead of a pointer.
1190     ContainerNode* parent = node-&gt;parentNode();
1191     if (!parent)
1192         return nullptr;
1193 
1194     for (auto&amp; sibling : childrenOfType&lt;Element&gt;(*parent)) {
1195         // FIXME: Should skip sibling that is the same as the node.
1196         if (equalIgnoringASCIICase(sibling.attributeWithoutSynchronization(roleAttr), role))
1197             return &amp;sibling;
1198     }
1199 
1200     return nullptr;
</pre>
<hr />
<pre>
1260 bool AccessibilityNodeObject::usesAltTagForTextComputation() const
1261 {
1262     return isImage() || isInputImage() || isNativeImage() || isCanvas() || (node() &amp;&amp; node()-&gt;hasTagName(imgTag));
1263 }
1264 
1265 bool AccessibilityNodeObject::isLabelable() const
1266 {
1267     Node* node = this-&gt;node();
1268     if (!node)
1269         return false;
1270 
1271     return is&lt;HTMLInputElement&gt;(*node) || AccessibilityObject::isARIAInput(ariaRoleAttribute()) || isControl() || isProgressIndicator() || isMeter();
1272 }
1273 
1274 String AccessibilityNodeObject::textForLabelElement(Element* element) const
1275 {
1276     String result = String();
1277     if (!is&lt;HTMLLabelElement&gt;(*element))
1278         return result;
1279 




1280     HTMLLabelElement* label = downcast&lt;HTMLLabelElement&gt;(element);
1281     // Check to see if there&#39;s aria-labelledby attribute on the label element.
<span class="line-modified">1282     if (AccessibilityObject* labelObject = axObjectCache()-&gt;getOrCreate(label))</span>
1283         result = labelObject-&gt;ariaLabeledByAttribute();
1284 
1285     return !result.isEmpty() ? result : accessibleNameForNode(label);
1286 }
1287 
1288 void AccessibilityNodeObject::titleElementText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1289 {
1290     Node* node = this-&gt;node();
1291     if (!node)
1292         return;
1293 
1294     if (isLabelable()) {
1295         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node))) {
1296             String innerText = textForLabelElement(label);
1297 

1298             // Only use the &lt;label&gt; text if there&#39;s no ARIA override.
<span class="line-modified">1299             if (!innerText.isEmpty() &amp;&amp; !ariaAccessibilityDescription())</span>
<span class="line-modified">1300                 textOrder.append(AccessibilityText(innerText, isMeter() ? AccessibilityTextSource::Alternative : AccessibilityTextSource::LabelByElement, axObjectCache()-&gt;getOrCreate(label)));</span>
1301             return;
1302         }
1303     }
1304 
1305     AccessibilityObject* titleUIElement = this-&gt;titleUIElement();
1306     if (titleUIElement)
1307         textOrder.append(AccessibilityText(String(), AccessibilityTextSource::LabelByElement, titleUIElement));
1308 }
1309 
1310 void AccessibilityNodeObject::alternativeText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1311 {
1312     if (isWebArea()) {
1313         String webAreaText = alternativeTextForWebArea();
1314         if (!webAreaText.isEmpty())
1315             textOrder.append(AccessibilityText(webAreaText, AccessibilityTextSource::Alternative));
1316         return;
1317     }
1318 
1319     ariaLabeledByText(textOrder);
1320 
<span class="line-modified">1321     const AtomicString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1322     if (!ariaLabel.isEmpty())
1323         textOrder.append(AccessibilityText(ariaLabel, AccessibilityTextSource::Alternative));
1324 
1325     if (usesAltTagForTextComputation()) {
1326         if (is&lt;RenderImage&gt;(renderer())) {
1327             String renderAltText = downcast&lt;RenderImage&gt;(*renderer()).altText();
1328 
1329             // RenderImage will return title as a fallback from altText, but we don&#39;t want title here because we consider that in helpText.
1330             if (!renderAltText.isEmpty() &amp;&amp; renderAltText != getAttribute(titleAttr)) {
1331                 textOrder.append(AccessibilityText(renderAltText, AccessibilityTextSource::Alternative));
1332                 return;
1333             }
1334         }
1335         // Images should use alt as long as the attribute is present, even if empty.
1336         // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">1337         const AtomicString&amp; alt = getAttribute(altAttr);</span>
1338         if (!alt.isEmpty())
1339             textOrder.append(AccessibilityText(alt, AccessibilityTextSource::Alternative));
1340     }
1341 
1342     Node* node = this-&gt;node();
1343     if (!node)
1344         return;
1345 

1346     // The fieldset element derives its alternative text from the first associated legend element if one is available.
<span class="line-modified">1347     if (is&lt;HTMLFieldSetElement&gt;(*node)) {</span>
<span class="line-modified">1348         AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(downcast&lt;HTMLFieldSetElement&gt;(*node).legend());</span>
1349         if (object &amp;&amp; !object-&gt;isHidden())
1350             textOrder.append(AccessibilityText(accessibleNameForNode(object-&gt;node()), AccessibilityTextSource::Alternative));
1351     }
1352 
1353     // The figure element derives its alternative text from the first associated figcaption element if one is available.
1354     if (isFigureElement()) {
1355         AccessibilityObject* captionForFigure = this-&gt;captionForFigure();
1356         if (captionForFigure &amp;&amp; !captionForFigure-&gt;isHidden())
1357             textOrder.append(AccessibilityText(accessibleNameForNode(captionForFigure-&gt;node()), AccessibilityTextSource::Alternative));
1358     }
1359 
1360     // Tree items missing a label are labeled by all child elements.
1361     if (isTreeItem() &amp;&amp; ariaLabel.isEmpty() &amp;&amp; ariaLabeledByAttribute().isEmpty())
1362         textOrder.append(AccessibilityText(accessibleNameForNode(node), AccessibilityTextSource::Alternative));
1363 
1364 #if ENABLE(MATHML)
1365     if (node-&gt;isMathMLElement())
1366         textOrder.append(AccessibilityText(getAttribute(MathMLNames::alttextAttr), AccessibilityTextSource::Alternative));
1367 #endif
1368 }
</pre>
<hr />
<pre>
1421         useTextUnderElement = true;
1422 
1423     if (isOutput())
1424         useTextUnderElement = true;
1425 
1426     if (useTextUnderElement) {
1427         AccessibilityTextUnderElementMode mode;
1428 
1429         // Headings often include links as direct children. Those links need to be included in text under element.
1430         if (isHeading())
1431             mode.includeFocusableContent = true;
1432 
1433         String text = textUnderElement(mode);
1434         if (!text.isEmpty())
1435             textOrder.append(AccessibilityText(text, AccessibilityTextSource::Children));
1436     }
1437 }
1438 
1439 void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1440 {
<span class="line-modified">1441     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1442     if (!ariaHelp.isEmpty())
1443         textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
1444 
1445     String describedBy = ariaDescribedByAttribute();
1446     if (!describedBy.isEmpty())
1447         textOrder.append(AccessibilityText(describedBy, AccessibilityTextSource::Summary));
1448     else if (isControl()) {
1449         // For controls, use their fieldset parent&#39;s described-by text if available.
1450         auto matchFunc = [] (const AccessibilityObject&amp; object) {
1451             return object.isFieldset() &amp;&amp; !object.ariaDescribedByAttribute().isEmpty();
1452         };
1453         if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
1454             textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
1455     }
1456 
1457     // Summary attribute used as help text on tables.
<span class="line-modified">1458     const AtomicString&amp; summary = getAttribute(summaryAttr);</span>
1459     if (!summary.isEmpty())
1460         textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
1461 
1462     // The title attribute should be used as help text unless it is already being used as descriptive text.
1463     // However, when the title attribute is the only text alternative provided, it may be exposed as the
1464     // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
1465     // can expose units through this attribute. Therefore, if the element is a meter, change its source
1466     // type to AccessibilityTextSource::Help.
<span class="line-modified">1467     const AtomicString&amp; title = getAttribute(titleAttr);</span>
1468     if (!title.isEmpty()) {
1469         if (!isMeter() &amp;&amp; !roleIgnoresTitle())
1470             textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
1471         else
1472             textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
1473     }
1474 }
1475 
<span class="line-modified">1476 void AccessibilityNodeObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; textOrder)</span>
1477 {
1478     titleElementText(textOrder);
1479     alternativeText(textOrder);
1480     visibleText(textOrder);
1481     helpText(textOrder);
1482 
1483     String placeholder = placeholderValue();
1484     if (!placeholder.isEmpty())
1485         textOrder.append(AccessibilityText(placeholder, AccessibilityTextSource::Placeholder));
1486 }
1487 
1488 void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1489 {
1490     String ariaLabeledBy = ariaLabeledByAttribute();
1491     if (!ariaLabeledBy.isEmpty()) {




1492         Vector&lt;Element*&gt; elements;
1493         ariaLabeledByElements(elements);
1494 
1495         Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;
1496         for (const auto&amp; element : elements)
<span class="line-modified">1497             axElements.append(axObjectCache()-&gt;getOrCreate(element));</span>
1498 
1499         textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
1500     }
1501 }
1502 
1503 String AccessibilityNodeObject::alternativeTextForWebArea() const
1504 {
1505     // The WebArea description should follow this order:
1506     //     aria-label on the &lt;html&gt;
1507     //     title on the &lt;html&gt;
1508     //     &lt;title&gt; inside the &lt;head&gt; (of it was set through JS)
1509     //     name on the &lt;html&gt;
1510     // For iframes:
1511     //     aria-label on the &lt;iframe&gt;
1512     //     title on the &lt;iframe&gt;
1513     //     name on the &lt;iframe&gt;
1514 
1515     Document* document = this-&gt;document();
1516     if (!document)
1517         return String();
1518 
1519     // Check if the HTML element has an aria-label for the webpage.
1520     if (Element* documentElement = document-&gt;documentElement()) {
<span class="line-modified">1521         const AtomicString&amp; ariaLabel = documentElement-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1522         if (!ariaLabel.isEmpty())
1523             return ariaLabel;
1524     }
1525 
1526     if (auto* owner = document-&gt;ownerElement()) {
1527         if (owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag)) {
<span class="line-modified">1528             const AtomicString&amp; title = owner-&gt;attributeWithoutSynchronization(titleAttr);</span>
1529             if (!title.isEmpty())
1530                 return title;
1531         }
1532         return owner-&gt;getNameAttribute();
1533     }
1534 
1535     String documentTitle = document-&gt;title();
1536     if (!documentTitle.isEmpty())
1537         return documentTitle;
1538 
1539     if (auto* body = document-&gt;bodyOrFrameset())
1540         return body-&gt;getNameAttribute();
1541 
1542     return String();
1543 }
1544 
1545 String AccessibilityNodeObject::accessibilityDescription() const
1546 {
1547     // Static text should not have a description, it should only have a stringValue.
1548     if (roleValue() == AccessibilityRole::StaticText)
1549         return String();
1550 
1551     String ariaDescription = ariaAccessibilityDescription();
1552     if (!ariaDescription.isEmpty())
1553         return ariaDescription;
1554 
1555     if (usesAltTagForTextComputation()) {
1556         // Images should use alt as long as the attribute is present, even if empty.
1557         // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">1558         const AtomicString&amp; alt = getAttribute(altAttr);</span>
1559         if (!alt.isNull())
1560             return alt;
1561     }
1562 
1563 #if ENABLE(MATHML)
1564     if (is&lt;MathMLElement&gt;(m_node))
1565         return getAttribute(MathMLNames::alttextAttr);
1566 #endif
1567 
1568     // An element&#39;s descriptive text is comprised of title() (what&#39;s visible on the screen) and accessibilityDescription() (other descriptive text).
1569     // Both are used to generate what a screen reader speaks.
1570     // If this point is reached (i.e. there&#39;s no accessibilityDescription) and there&#39;s no title(), we should fallback to using the title attribute.
1571     // The title attribute is normally used as help text (because it is a tooltip), but if there is nothing else available, this should be used (according to ARIA).
1572     // https://bugs.webkit.org/show_bug.cgi?id=170475: An exception is when the element is semantically unimportant. In those cases, title text should remain as help text.
1573     if (title().isEmpty() &amp;&amp; !roleIgnoresTitle())
1574         return getAttribute(titleAttr);
1575 
1576     return String();
1577 }
1578 
</pre>
<hr />
<pre>
1581 bool AccessibilityNodeObject::roleIgnoresTitle() const
1582 {
1583     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1584         return false;
1585 
1586     switch (roleValue()) {
1587     case AccessibilityRole::Div:
1588     case AccessibilityRole::Unknown:
1589         return true;
1590     default:
1591         return false;
1592     }
1593 }
1594 
1595 String AccessibilityNodeObject::helpText() const
1596 {
1597     Node* node = this-&gt;node();
1598     if (!node)
1599         return String();
1600 
<span class="line-modified">1601     const AtomicString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1602     if (!ariaHelp.isEmpty())
1603         return ariaHelp;
1604 
1605     String describedBy = ariaDescribedByAttribute();
1606     if (!describedBy.isEmpty())
1607         return describedBy;
1608 
1609     String description = accessibilityDescription();
1610     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1611         if (is&lt;HTMLElement&gt;(*ancestor)) {
1612             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor);
<span class="line-modified">1613             const AtomicString&amp; summary = element.getAttribute(summaryAttr);</span>
1614             if (!summary.isEmpty())
1615                 return summary;
1616 
1617             // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified">1618             const AtomicString&amp; title = element.getAttribute(titleAttr);</span>
1619             if (!title.isEmpty() &amp;&amp; description != title)
1620                 return title;
1621         }
1622 




1623         // Only take help text from an ancestor element if its a group or an unknown role. If help was
1624         // added to those kinds of elements, it is likely it was meant for a child element.
<span class="line-modified">1625         if (AccessibilityObject* axObj = axObjectCache()-&gt;getOrCreate(ancestor)) {</span>
1626             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
1627                 break;
1628         }
1629     }
1630 
1631     return String();
1632 }
1633 
1634 unsigned AccessibilityNodeObject::hierarchicalLevel() const
1635 {
1636     Node* node = this-&gt;node();
1637     if (!is&lt;Element&gt;(node))
1638         return 0;
1639     Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1640     const AtomicString&amp; ariaLevel = element.attributeWithoutSynchronization(aria_levelAttr);</span>
1641     if (!ariaLevel.isEmpty())
1642         return ariaLevel.toInt();
1643 
1644     // Only tree item will calculate its level through the DOM currently.
1645     if (roleValue() != AccessibilityRole::TreeItem)
1646         return 0;
1647 
1648     // Hierarchy leveling starts at 1, to match the aria-level spec.
1649     // We measure tree hierarchy by the number of groups that the item is within.
1650     unsigned level = 1;
1651     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1652         AccessibilityRole parentRole = parent-&gt;ariaRoleAttribute();
1653         if (parentRole == AccessibilityRole::ApplicationGroup)
1654             level++;
1655         else if (parentRole == AccessibilityRole::Tree)
1656             break;
1657     }
1658 
1659     return level;
1660 }
</pre>
<hr />
<pre>
1888 {
1889     Node* node = this-&gt;node();
1890     if (!node)
1891         return String();
1892 
1893     if (isARIAStaticText()) {
1894         String staticText = text();
1895         if (!staticText.length())
1896             staticText = textUnderElement();
1897         return staticText;
1898     }
1899 
1900     if (node-&gt;isTextNode())
1901         return textUnderElement();
1902 
1903     if (node-&gt;hasTagName(selectTag)) {
1904         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node);
1905         int selectedIndex = selectElement.selectedIndex();
1906         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
1907         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified">1908             const AtomicString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1909             if (!overriddenDescription.isNull())
1910                 return overriddenDescription;
1911         }
1912         if (!selectElement.multiple())
1913             return selectElement.value();
1914         return String();
1915     }
1916 
1917     if (isTextControl())
1918         return text();
1919 
1920     // FIXME: We might need to implement a value here for more types
1921     // FIXME: It would be better not to advertise a value at all for the types for which we don&#39;t implement one;
1922     // this would require subclassing or making accessibilityAttributeNames do something other than return a
1923     // single static array.
1924     return String();
1925 }
1926 
1927 void AccessibilityNodeObject::colorValue(int&amp; r, int&amp; g, int&amp; b) const
1928 {
</pre>
<hr />
<pre>
1936 
1937     if (!is&lt;HTMLInputElement&gt;(node()))
1938         return;
1939 
1940     auto color = downcast&lt;HTMLInputElement&gt;(*node()).valueAsColor();
1941     r = color.red();
1942     g = color.green();
1943     b = color.blue();
1944 #endif
1945 }
1946 
1947 // This function implements the ARIA accessible name as described by the Mozilla
1948 // ARIA Implementer&#39;s Guide.
1949 static String accessibleNameForNode(Node* node, Node* labelledbyNode)
1950 {
1951     ASSERT(node);
1952     if (!is&lt;Element&gt;(node))
1953         return String();
1954 
1955     Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1956     const AtomicString&amp; ariaLabel = element.attributeWithoutSynchronization(aria_labelAttr);</span>
1957     if (!ariaLabel.isEmpty())
1958         return ariaLabel;
1959 
<span class="line-modified">1960     const AtomicString&amp; alt = element.attributeWithoutSynchronization(altAttr);</span>
1961     if (!alt.isEmpty())
1962         return alt;
1963 
1964     // If the node can be turned into an AX object, we can use standard name computation rules.
1965     // If however, the node cannot (because there&#39;s no renderer e.g.) fallback to using the basic text underneath.
1966     AccessibilityObject* axObject = node-&gt;document().axObjectCache()-&gt;getOrCreate(node);
1967     if (axObject) {
1968         String valueDescription = axObject-&gt;valueDescription();
1969         if (!valueDescription.isEmpty())
1970             return valueDescription;
1971 
1972         // The Accname specification states that if the name is being calculated for a combobox
1973         // or listbox inside a labeling element, return the text alternative of the chosen option.
1974         AccessibilityObject::AccessibilityChildrenVector children;
1975         if (axObject-&gt;isListBox())
1976             axObject-&gt;selectedChildren(children);
1977         else if (axObject-&gt;isComboBox()) {
1978             for (const auto&amp; child : axObject-&gt;children()) {
1979                 if (child-&gt;isListBox()) {
1980                     child-&gt;selectedChildren(children);
</pre>
<hr />
<pre>
1989             appendNameToStringBuilder(builder, accessibleNameForNode(child-&gt;node()));
1990 
1991         childText = builder.toString();
1992         if (!childText.isEmpty())
1993             return childText;
1994     }
1995 
1996     if (is&lt;HTMLInputElement&gt;(*node))
1997         return downcast&lt;HTMLInputElement&gt;(*node).value();
1998 
1999     String text;
2000     if (axObject) {
2001         if (axObject-&gt;accessibleNameDerivesFromContent())
2002             text = axObject-&gt;textUnderElement(AccessibilityTextUnderElementMode(AccessibilityTextUnderElementMode::TextUnderElementModeIncludeNameFromContentsChildren, true, labelledbyNode));
2003     } else
2004         text = element.innerText().simplifyWhiteSpace();
2005 
2006     if (!text.isEmpty())
2007         return text;
2008 
<span class="line-modified">2009     const AtomicString&amp; title = element.attributeWithoutSynchronization(titleAttr);</span>
2010     if (!title.isEmpty())
2011         return title;
2012 
2013     return String();
2014 }
2015 
2016 String AccessibilityNodeObject::accessibilityDescriptionForChildren() const
2017 {
2018     Node* node = this-&gt;node();
2019     if (!node)
2020         return String();
2021 
2022     AXObjectCache* cache = axObjectCache();
2023     if (!cache)
2024         return String();
2025 
2026     StringBuilder builder;
2027     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
2028         if (!is&lt;Element&gt;(child))
2029             continue;
</pre>
<hr />
<pre>
2119         return !downcast&lt;HTMLTextAreaElement&gt;(*node).isReadOnly();
2120     if (is&lt;HTMLInputElement&gt;(*node)) {
2121         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2122         if (input.isTextField())
2123             return !input.isReadOnly();
2124     }
2125 
2126     String readOnly = readOnlyValue();
2127     if (!readOnly.isEmpty())
2128         return readOnly == &quot;true&quot; ? false : true;
2129 
2130     if (isNonNativeTextControl())
2131         return true;
2132 
2133     if (isMeter())
2134         return false;
2135 
2136     if (isProgressIndicator() || isSlider() || isScrollbar())
2137         return true;
2138 
<span class="line-modified">2139 #if PLATFORM(GTK)</span>
2140     // In ATK, input types which support aria-readonly are treated as having a
2141     // settable value if the user can modify the widget&#39;s value or its state.
2142     if (supportsReadOnly())
2143         return true;
2144 
2145     if (isRadioButton()) {
2146         auto radioGroup = radioGroupAncestor();
2147         return radioGroup ? radioGroup-&gt;readOnlyValue() != &quot;true&quot; : true;
2148     }
2149 #endif
2150 
2151     if (isWebArea()) {
2152         Document* document = this-&gt;document();
2153         if (!document)
2154             return false;
2155 
2156         if (HTMLElement* body = document-&gt;bodyOrFrameset()) {
2157             if (body-&gt;hasEditableStyle())
2158                 return true;
2159         }
2160 
2161         return document-&gt;hasEditableStyle();
2162     }
2163 
2164     return node-&gt;hasEditableStyle();
2165 }
2166 
2167 AccessibilityRole AccessibilityNodeObject::determineAriaRoleAttribute() const
2168 {
<span class="line-modified">2169     const AtomicString&amp; ariaRole = getAttribute(roleAttr);</span>
2170     if (ariaRole.isNull() || ariaRole.isEmpty())
2171         return AccessibilityRole::Unknown;
2172 
2173     AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);
2174 
2175     // ARIA states if an item can get focus, it should not be presentational.
2176     if (role == AccessibilityRole::Presentational &amp;&amp; canSetFocusAttribute())
2177         return AccessibilityRole::Unknown;
2178 
2179     if (role == AccessibilityRole::Button)
2180         role = buttonRoleType();
2181 
2182     if (role == AccessibilityRole::TextArea &amp;&amp; !ariaIsMultiline())
2183         role = AccessibilityRole::TextField;
2184 
2185     role = remapAriaRoleDueToParent(role);
2186 
2187     // Presentational roles are invalidated by the presence of ARIA attributes.
2188     if (role == AccessibilityRole::Presentational &amp;&amp; supportsARIAAttributes())
2189         role = AccessibilityRole::Unknown;
</pre>
</td>
<td>
<hr />
<pre>
 161 void AccessibilityNodeObject::updateAccessibilityRole()
 162 {
 163     bool ignoredStatus = accessibilityIsIgnored();
 164     m_role = determineAccessibilityRole();
 165 
 166     // The AX hierarchy only needs to be updated if the ignored status of an element has changed.
 167     if (ignoredStatus != accessibilityIsIgnored())
 168         childrenChanged();
 169 }
 170 
 171 AccessibilityObject* AccessibilityNodeObject::firstChild() const
 172 {
 173     if (!node())
 174         return nullptr;
 175 
 176     Node* firstChild = node()-&gt;firstChild();
 177 
 178     if (!firstChild)
 179         return nullptr;
 180 
<span class="line-modified"> 181     auto objectCache = axObjectCache();</span>
<span class="line-added"> 182     return objectCache ? objectCache-&gt;getOrCreate(firstChild) : nullptr;</span>
 183 }
 184 
 185 AccessibilityObject* AccessibilityNodeObject::lastChild() const
 186 {
 187     if (!node())
 188         return nullptr;
 189 
 190     Node* lastChild = node()-&gt;lastChild();
 191     if (!lastChild)
 192         return nullptr;
 193 
<span class="line-modified"> 194     auto objectCache = axObjectCache();</span>
<span class="line-added"> 195     return objectCache ? objectCache-&gt;getOrCreate(lastChild) : nullptr;</span>
 196 }
 197 
 198 AccessibilityObject* AccessibilityNodeObject::previousSibling() const
 199 {
 200     if (!node())
 201         return nullptr;
 202 
 203     Node* previousSibling = node()-&gt;previousSibling();
 204     if (!previousSibling)
 205         return nullptr;
 206 
<span class="line-modified"> 207     auto objectCache = axObjectCache();</span>
<span class="line-added"> 208     return objectCache ? objectCache-&gt;getOrCreate(previousSibling) : nullptr;</span>
 209 }
 210 
 211 AccessibilityObject* AccessibilityNodeObject::nextSibling() const
 212 {
 213     if (!node())
 214         return nullptr;
 215 
 216     Node* nextSibling = node()-&gt;nextSibling();
 217     if (!nextSibling)
 218         return nullptr;
 219 
<span class="line-modified"> 220     auto objectCache = axObjectCache();</span>
<span class="line-added"> 221     return objectCache ? objectCache-&gt;getOrCreate(nextSibling) : nullptr;</span>
 222 }
 223 
 224 AccessibilityObject* AccessibilityNodeObject::parentObjectIfExists() const
 225 {
 226     return parentObject();
 227 }
 228 
 229 AccessibilityObject* AccessibilityNodeObject::parentObject() const
 230 {
 231     if (!node())
 232         return nullptr;
 233 
 234     Node* parentObj = node()-&gt;parentNode();
 235     if (!parentObj)
 236         return nullptr;
 237 
 238     if (AXObjectCache* cache = axObjectCache())
 239         return cache-&gt;getOrCreate(parentObj);
 240 
 241     return nullptr;
</pre>
<hr />
<pre>
 332         return AccessibilityRole::Group;
 333 
 334     return AccessibilityRole::Unknown;
 335 }
 336 
 337 void AccessibilityNodeObject::addChildren()
 338 {
 339     // If the need to add more children in addition to existing children arises,
 340     // childrenChanged should have been called, leaving the object with no children.
 341     ASSERT(!m_haveChildren);
 342 
 343     if (!m_node)
 344         return;
 345 
 346     m_haveChildren = true;
 347 
 348     // The only time we add children from the DOM tree to a node with a renderer is when it&#39;s a canvas.
 349     if (renderer() &amp;&amp; !m_node-&gt;hasTagName(canvasTag))
 350         return;
 351 
<span class="line-added"> 352     auto objectCache = axObjectCache();</span>
<span class="line-added"> 353     if (!objectCache)</span>
<span class="line-added"> 354         return;</span>
<span class="line-added"> 355 </span>
 356     for (Node* child = m_node-&gt;firstChild(); child; child = child-&gt;nextSibling())
<span class="line-modified"> 357         addChild(objectCache-&gt;getOrCreate(child));</span>
 358 
 359     m_subtreeDirty = false;
 360 }
 361 
 362 bool AccessibilityNodeObject::canHaveChildren() const
 363 {
 364     // If this is an AccessibilityRenderObject, then it&#39;s okay if this object
 365     // doesn&#39;t have a node - there are some renderers that don&#39;t have associated
 366     // nodes, like scroll areas and css-generated text.
 367     if (!node() &amp;&amp; !isAccessibilityRenderObject())
 368         return false;
 369 
 370     // When &lt;noscript&gt; is not being used (its renderer() == 0), ignore its children.
 371     if (node() &amp;&amp; !renderer() &amp;&amp; node()-&gt;hasTagName(noscriptTag))
 372         return false;
 373 
 374     // Elements that should not have children
 375     switch (roleValue()) {
 376     case AccessibilityRole::Image:
 377     case AccessibilityRole::Button:
 378     case AccessibilityRole::PopUpButton:
 379     case AccessibilityRole::CheckBox:
 380     case AccessibilityRole::RadioButton:
 381     case AccessibilityRole::Tab:
 382     case AccessibilityRole::ToggleButton:
 383     case AccessibilityRole::StaticText:
 384     case AccessibilityRole::ListBoxOption:
 385     case AccessibilityRole::ScrollBar:
 386     case AccessibilityRole::ProgressIndicator:
 387     case AccessibilityRole::Switch:
 388     case AccessibilityRole::MenuItemCheckbox:
 389     case AccessibilityRole::MenuItemRadio:
 390     case AccessibilityRole::Splitter:
<span class="line-added"> 391     case AccessibilityRole::Meter:</span>
 392         return false;
 393     case AccessibilityRole::DocumentMath:
 394 #if ENABLE(MATHML)
 395         return node()-&gt;isMathMLElement();
 396 #endif
 397         return false;
 398     default:
 399         return true;
 400     }
 401 }
 402 
 403 bool AccessibilityNodeObject::computeAccessibilityIsIgnored() const
 404 {
 405 #ifndef NDEBUG
 406     // Double-check that an AccessibilityObject is never accessed before
 407     // it&#39;s been initialized.
 408     ASSERT(m_initialized);
 409 #endif
 410 
 411     // Handle non-rendered text that is exposed through aria-hidden=false.
</pre>
<hr />
<pre>
 471 
 472 bool AccessibilityNodeObject::isSearchField() const
 473 {
 474     Node* node = this-&gt;node();
 475     if (!node)
 476         return false;
 477 
 478     if (roleValue() == AccessibilityRole::SearchField)
 479         return true;
 480 
 481     if (!is&lt;HTMLInputElement&gt;(*node))
 482         return false;
 483 
 484     auto&amp; inputElement = downcast&lt;HTMLInputElement&gt;(*node);
 485 
 486     // Some websites don&#39;t label their search fields as such. However, they will
 487     // use the word &quot;search&quot; in either the form or input type. This won&#39;t catch every case,
 488     // but it will catch google.com for example.
 489 
 490     // Check the node name of the input type, sometimes it&#39;s &quot;search&quot;.
<span class="line-modified"> 491     const AtomString&amp; nameAttribute = getAttribute(nameAttr);</span>
 492     if (nameAttribute.containsIgnoringASCIICase(&quot;search&quot;))
 493         return true;
 494 
 495     // Check the form action and the name, which will sometimes be &quot;search&quot;.
 496     auto* form = inputElement.form();
 497     if (form &amp;&amp; (form-&gt;name().containsIgnoringASCIICase(&quot;search&quot;) || form-&gt;action().containsIgnoringASCIICase(&quot;search&quot;)))
 498         return true;
 499 
 500     return false;
 501 }
 502 
 503 bool AccessibilityNodeObject::isNativeImage() const
 504 {
 505     Node* node = this-&gt;node();
 506     if (!node)
 507         return false;
 508 
 509     if (is&lt;HTMLImageElement&gt;(*node))
 510         return true;
 511 
</pre>
<hr />
<pre>
 552 
 553     if (auto* cache = axObjectCache())
 554         return cache-&gt;getOrCreate(element);
 555 
 556     return nullptr;
 557 }
 558 
 559 bool AccessibilityNodeObject::isInputImage() const
 560 {
 561     Node* node = this-&gt;node();
 562     if (is&lt;HTMLInputElement&gt;(node) &amp;&amp; roleValue() == AccessibilityRole::Button) {
 563         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 564         return input.isImageButton();
 565     }
 566 
 567     return false;
 568 }
 569 
 570 bool AccessibilityNodeObject::isProgressIndicator() const
 571 {
<span class="line-modified"> 572     return roleValue() == AccessibilityRole::ProgressIndicator || roleValue() == AccessibilityRole::Meter;</span>
 573 }
 574 
 575 bool AccessibilityNodeObject::isSlider() const
 576 {
 577     return roleValue() == AccessibilityRole::Slider;
 578 }
 579 
 580 bool AccessibilityNodeObject::isMenuRelated() const
 581 {
 582     switch (roleValue()) {
 583     case AccessibilityRole::Menu:
 584     case AccessibilityRole::MenuBar:
 585     case AccessibilityRole::MenuButton:
 586     case AccessibilityRole::MenuItem:
 587     case AccessibilityRole::MenuItemCheckbox:
 588     case AccessibilityRole::MenuItemRadio:
 589         return true;
 590     default:
 591         return false;
 592     }
</pre>
<hr />
<pre>
 616         return true;
 617     default:
 618         return false;
 619     }
 620 }
 621 
 622 bool AccessibilityNodeObject::isNativeCheckboxOrRadio() const
 623 {
 624     Node* node = this-&gt;node();
 625     if (!is&lt;HTMLInputElement&gt;(node))
 626         return false;
 627 
 628     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 629     return input.isCheckbox() || input.isRadioButton();
 630 }
 631 
 632 bool AccessibilityNodeObject::isEnabled() const
 633 {
 634     // ARIA says that the disabled status applies to the current element and all descendant elements.
 635     for (AccessibilityObject* object = const_cast&lt;AccessibilityNodeObject*&gt;(this); object; object = object-&gt;parentObject()) {
<span class="line-modified"> 636         const AtomString&amp; disabledStatus = object-&gt;getAttribute(aria_disabledAttr);</span>
 637         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;true&quot;))
 638             return false;
 639         if (equalLettersIgnoringASCIICase(disabledStatus, &quot;false&quot;))
 640             break;
 641     }
 642 
 643     if (roleValue() == AccessibilityRole::HorizontalRule)
 644         return false;
 645 
 646     Node* node = this-&gt;node();
 647     if (!is&lt;Element&gt;(node))
 648         return true;
 649 
 650     return !downcast&lt;Element&gt;(*node).isDisabledFormControl();
 651 }
 652 
 653 bool AccessibilityNodeObject::isIndeterminate() const
 654 {
 655     return equalLettersIgnoringASCIICase(getAttribute(indeterminateAttr), &quot;true&quot;);
 656 }
</pre>
<hr />
<pre>
 695         validRole = true;
 696         break;
 697     default:
 698         break;
 699     }
 700 
 701     if (validRole &amp;&amp; equalLettersIgnoringASCIICase(getAttribute(aria_checkedAttr), &quot;true&quot;))
 702         return true;
 703 
 704     return false;
 705 }
 706 
 707 bool AccessibilityNodeObject::isHovered() const
 708 {
 709     Node* node = this-&gt;node();
 710     return is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(*node).hovered();
 711 }
 712 
 713 bool AccessibilityNodeObject::isMultiSelectable() const
 714 {
<span class="line-modified"> 715     const AtomString&amp; ariaMultiSelectable = getAttribute(aria_multiselectableAttr);</span>
 716     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;true&quot;))
 717         return true;
 718     if (equalLettersIgnoringASCIICase(ariaMultiSelectable, &quot;false&quot;))
 719         return false;
 720 
 721     return node() &amp;&amp; node()-&gt;hasTagName(selectTag) &amp;&amp; downcast&lt;HTMLSelectElement&gt;(*node()).multiple();
 722 }
 723 
 724 bool AccessibilityNodeObject::isRequired() const
 725 {
 726     // Explicit aria-required values should trump native required attributes.
<span class="line-modified"> 727     const AtomString&amp; requiredValue = getAttribute(aria_requiredAttr);</span>
 728     if (equalLettersIgnoringASCIICase(requiredValue, &quot;true&quot;))
 729         return true;
 730     if (equalLettersIgnoringASCIICase(requiredValue, &quot;false&quot;))
 731         return false;
 732 
 733     Node* n = this-&gt;node();
 734     if (is&lt;HTMLFormControlElement&gt;(n))
 735         return downcast&lt;HTMLFormControlElement&gt;(*n).isRequired();
 736 
 737     return false;
 738 }
 739 
 740 bool AccessibilityNodeObject::supportsRequiredAttribute() const
 741 {
 742     switch (roleValue()) {
 743     case AccessibilityRole::Button:
 744         return isFileUploadButton();
 745     case AccessibilityRole::Cell:
 746     case AccessibilityRole::ColumnHeader:
 747     case AccessibilityRole::CheckBox:
</pre>
<hr />
<pre>
 877 {
 878     return getAttribute(stepAttr).toFloat();
 879 }
 880 
 881 bool AccessibilityNodeObject::isHeading() const
 882 {
 883     return roleValue() == AccessibilityRole::Heading;
 884 }
 885 
 886 bool AccessibilityNodeObject::isLink() const
 887 {
 888     return roleValue() == AccessibilityRole::WebCoreLink;
 889 }
 890 
 891 bool AccessibilityNodeObject::isControl() const
 892 {
 893     Node* node = this-&gt;node();
 894     if (!node)
 895         return false;
 896 
<span class="line-modified"> 897     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute()) || roleValue() == AccessibilityRole::Button;</span>
 898 }
 899 
 900 bool AccessibilityNodeObject::isFieldset() const
 901 {
 902     Node* node = this-&gt;node();
 903     if (!node)
 904         return false;
 905 
 906     return node-&gt;hasTagName(fieldsetTag);
 907 }
 908 
 909 bool AccessibilityNodeObject::isGroup() const
 910 {
 911     AccessibilityRole role = roleValue();
 912     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 913 }
 914 
 915 AccessibilityObject* AccessibilityNodeObject::selectedRadioButton()
 916 {
 917     if (!isRadioGroup())
</pre>
<hr />
<pre>
 940             return child.get();
 941     }
 942     return nullptr;
 943 }
 944 
 945 AccessibilityButtonState AccessibilityNodeObject::checkboxOrRadioValue() const
 946 {
 947     if (isNativeCheckboxOrRadio())
 948         return isIndeterminate() ? AccessibilityButtonState::Mixed : isChecked() ? AccessibilityButtonState::On : AccessibilityButtonState::Off;
 949 
 950     return AccessibilityObject::checkboxOrRadioValue();
 951 }
 952 
 953 Element* AccessibilityNodeObject::anchorElement() const
 954 {
 955     Node* node = this-&gt;node();
 956     if (!node)
 957         return nullptr;
 958 
 959     AXObjectCache* cache = axObjectCache();
<span class="line-added"> 960     if (!cache)</span>
<span class="line-added"> 961         return nullptr;</span>
 962 
 963     // search up the DOM tree for an anchor element
 964     // NOTE: this assumes that any non-image with an anchor is an HTMLAnchorElement
 965     for ( ; node; node = node-&gt;parentNode()) {
 966         if (is&lt;HTMLAnchorElement&gt;(*node) || (node-&gt;renderer() &amp;&amp; cache-&gt;getOrCreate(node-&gt;renderer())-&gt;isLink()))
 967             return downcast&lt;Element&gt;(node);
 968     }
 969 
 970     return nullptr;
 971 }
 972 
 973 static bool isNodeActionElement(Node* node)
 974 {
 975     if (is&lt;HTMLInputElement&gt;(*node)) {
 976         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 977         if (!input.isDisabledFormControl() &amp;&amp; (input.isRadioButton() || input.isCheckbox() || input.isTextButton() || input.isFileUpload() || input.isImageButton()))
 978             return true;
 979     } else if (node-&gt;hasTagName(buttonTag) || node-&gt;hasTagName(selectTag))
 980         return true;
 981 
</pre>
<hr />
<pre>
1070     return false;
1071 }
1072 
1073 void AccessibilityNodeObject::alterSliderValue(bool increase)
1074 {
1075     if (roleValue() != AccessibilityRole::Slider)
1076         return;
1077 
1078     auto element = this-&gt;element();
1079     if (!element || element-&gt;isDisabledFormControl())
1080         return;
1081 
1082     if (!getAttribute(stepAttr).isEmpty())
1083         changeValueByStep(increase);
1084     else
1085         changeValueByPercent(increase ? 5 : -5);
1086 }
1087 
1088 void AccessibilityNodeObject::increment()
1089 {


1090     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1091     alterSliderValue(true);
1092 }
1093 
1094 void AccessibilityNodeObject::decrement()
1095 {


1096     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1097     alterSliderValue(false);
1098 }
1099 
1100 void AccessibilityNodeObject::changeValueByStep(bool increase)
1101 {
1102     float step = stepValueForRange();
1103     float value = valueForRange();
1104 
1105     value += increase ? step : -step;
1106 
<span class="line-modified">1107     setValue(String::numberToStringFixedPrecision(value));</span>
1108 
<span class="line-modified">1109     auto objectCache = axObjectCache();</span>
<span class="line-added">1110     if (objectCache)</span>
<span class="line-added">1111         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
1112 }
1113 
1114 void AccessibilityNodeObject::changeValueByPercent(float percentChange)
1115 {
1116     float range = maxValueForRange() - minValueForRange();
1117     float step = range * (percentChange / 100);
1118     float value = valueForRange();
1119 
1120     // Make sure the specified percent will cause a change of one integer step or larger.
<span class="line-modified">1121     if (std::abs(step) &lt; 1)</span>
<span class="line-modified">1122         step = std::abs(percentChange) * (1 / percentChange);</span>
1123 
1124     value += step;
<span class="line-modified">1125     setValue(String::numberToStringFixedPrecision(value));</span>
1126 
<span class="line-modified">1127     auto objectCache = axObjectCache();</span>
<span class="line-added">1128     if (objectCache)</span>
<span class="line-added">1129         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);</span>
1130 }
1131 
1132 bool AccessibilityNodeObject::isGenericFocusableElement() const
1133 {
1134     if (!canSetFocusAttribute())
1135         return false;
1136 
1137     // If it&#39;s a control, it&#39;s not generic.
1138     if (isControl())
1139         return false;
1140 
1141     AccessibilityRole role = roleValue();
1142     if (role == AccessibilityRole::Video || role == AccessibilityRole::Audio)
1143         return false;
1144 
1145     // If it has an aria role, it&#39;s not generic.
1146     if (m_ariaRole != AccessibilityRole::Unknown)
1147         return false;
1148 
1149     // If the content editable attribute is set on this element, that&#39;s the reason
</pre>
<hr />
<pre>
1156     // The web area and body element are both focusable, but existing logic handles these
1157     // cases already, so we don&#39;t need to include them here.
1158     if (role == AccessibilityRole::WebArea)
1159         return false;
1160     if (node() &amp;&amp; node()-&gt;hasTagName(bodyTag))
1161         return false;
1162 
1163     // An SVG root is focusable by default, but it&#39;s probably not interactive, so don&#39;t
1164     // include it. It can still be made accessible by giving it an ARIA role.
1165     if (role == AccessibilityRole::SVGRoot)
1166         return false;
1167 
1168     return true;
1169 }
1170 
1171 HTMLLabelElement* AccessibilityNodeObject::labelForElement(Element* element) const
1172 {
1173     if (!is&lt;HTMLElement&gt;(*element) || !downcast&lt;HTMLElement&gt;(*element).isLabelable())
1174         return nullptr;
1175 
<span class="line-modified">1176     const AtomString&amp; id = element-&gt;getIdAttribute();</span>
1177     if (!id.isEmpty()) {
1178         if (HTMLLabelElement* label = element-&gt;treeScope().labelElementForId(id))
1179             return label;
1180     }
1181 
1182     return ancestorsOfType&lt;HTMLLabelElement&gt;(*element).first();
1183 }
1184 
1185 String AccessibilityNodeObject::ariaAccessibilityDescription() const
1186 {
1187     String ariaLabeledBy = ariaLabeledByAttribute();
1188     if (!ariaLabeledBy.isEmpty())
1189         return ariaLabeledBy;
1190 
<span class="line-modified">1191     const AtomString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1192     if (!ariaLabel.isEmpty())
1193         return ariaLabel;
1194 
1195     return String();
1196 }
1197 
1198 static Element* siblingWithAriaRole(Node* node, const char* role)
1199 {
1200     // FIXME: Either we should add a null check here or change the function to take a reference instead of a pointer.
1201     ContainerNode* parent = node-&gt;parentNode();
1202     if (!parent)
1203         return nullptr;
1204 
1205     for (auto&amp; sibling : childrenOfType&lt;Element&gt;(*parent)) {
1206         // FIXME: Should skip sibling that is the same as the node.
1207         if (equalIgnoringASCIICase(sibling.attributeWithoutSynchronization(roleAttr), role))
1208             return &amp;sibling;
1209     }
1210 
1211     return nullptr;
</pre>
<hr />
<pre>
1271 bool AccessibilityNodeObject::usesAltTagForTextComputation() const
1272 {
1273     return isImage() || isInputImage() || isNativeImage() || isCanvas() || (node() &amp;&amp; node()-&gt;hasTagName(imgTag));
1274 }
1275 
1276 bool AccessibilityNodeObject::isLabelable() const
1277 {
1278     Node* node = this-&gt;node();
1279     if (!node)
1280         return false;
1281 
1282     return is&lt;HTMLInputElement&gt;(*node) || AccessibilityObject::isARIAInput(ariaRoleAttribute()) || isControl() || isProgressIndicator() || isMeter();
1283 }
1284 
1285 String AccessibilityNodeObject::textForLabelElement(Element* element) const
1286 {
1287     String result = String();
1288     if (!is&lt;HTMLLabelElement&gt;(*element))
1289         return result;
1290 
<span class="line-added">1291     auto objectCache = axObjectCache();</span>
<span class="line-added">1292     if (!objectCache)</span>
<span class="line-added">1293         return result;</span>
<span class="line-added">1294 </span>
1295     HTMLLabelElement* label = downcast&lt;HTMLLabelElement&gt;(element);
1296     // Check to see if there&#39;s aria-labelledby attribute on the label element.
<span class="line-modified">1297     if (AccessibilityObject* labelObject = objectCache-&gt;getOrCreate(label))</span>
1298         result = labelObject-&gt;ariaLabeledByAttribute();
1299 
1300     return !result.isEmpty() ? result : accessibleNameForNode(label);
1301 }
1302 
1303 void AccessibilityNodeObject::titleElementText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1304 {
1305     Node* node = this-&gt;node();
1306     if (!node)
1307         return;
1308 
1309     if (isLabelable()) {
1310         if (HTMLLabelElement* label = labelForElement(downcast&lt;Element&gt;(node))) {
1311             String innerText = textForLabelElement(label);
1312 
<span class="line-added">1313             auto objectCache = axObjectCache();</span>
1314             // Only use the &lt;label&gt; text if there&#39;s no ARIA override.
<span class="line-modified">1315             if (objectCache &amp;&amp; !innerText.isEmpty() &amp;&amp; !ariaAccessibilityDescription())</span>
<span class="line-modified">1316                 textOrder.append(AccessibilityText(innerText, isMeter() ? AccessibilityTextSource::Alternative : AccessibilityTextSource::LabelByElement, objectCache-&gt;getOrCreate(label)));</span>
1317             return;
1318         }
1319     }
1320 
1321     AccessibilityObject* titleUIElement = this-&gt;titleUIElement();
1322     if (titleUIElement)
1323         textOrder.append(AccessibilityText(String(), AccessibilityTextSource::LabelByElement, titleUIElement));
1324 }
1325 
1326 void AccessibilityNodeObject::alternativeText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1327 {
1328     if (isWebArea()) {
1329         String webAreaText = alternativeTextForWebArea();
1330         if (!webAreaText.isEmpty())
1331             textOrder.append(AccessibilityText(webAreaText, AccessibilityTextSource::Alternative));
1332         return;
1333     }
1334 
1335     ariaLabeledByText(textOrder);
1336 
<span class="line-modified">1337     const AtomString&amp; ariaLabel = getAttribute(aria_labelAttr);</span>
1338     if (!ariaLabel.isEmpty())
1339         textOrder.append(AccessibilityText(ariaLabel, AccessibilityTextSource::Alternative));
1340 
1341     if (usesAltTagForTextComputation()) {
1342         if (is&lt;RenderImage&gt;(renderer())) {
1343             String renderAltText = downcast&lt;RenderImage&gt;(*renderer()).altText();
1344 
1345             // RenderImage will return title as a fallback from altText, but we don&#39;t want title here because we consider that in helpText.
1346             if (!renderAltText.isEmpty() &amp;&amp; renderAltText != getAttribute(titleAttr)) {
1347                 textOrder.append(AccessibilityText(renderAltText, AccessibilityTextSource::Alternative));
1348                 return;
1349             }
1350         }
1351         // Images should use alt as long as the attribute is present, even if empty.
1352         // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">1353         const AtomString&amp; alt = getAttribute(altAttr);</span>
1354         if (!alt.isEmpty())
1355             textOrder.append(AccessibilityText(alt, AccessibilityTextSource::Alternative));
1356     }
1357 
1358     Node* node = this-&gt;node();
1359     if (!node)
1360         return;
1361 
<span class="line-added">1362     auto objectCache = axObjectCache();</span>
1363     // The fieldset element derives its alternative text from the first associated legend element if one is available.
<span class="line-modified">1364     if (objectCache &amp;&amp; is&lt;HTMLFieldSetElement&gt;(*node)) {</span>
<span class="line-modified">1365         AccessibilityObject* object = objectCache-&gt;getOrCreate(downcast&lt;HTMLFieldSetElement&gt;(*node).legend());</span>
1366         if (object &amp;&amp; !object-&gt;isHidden())
1367             textOrder.append(AccessibilityText(accessibleNameForNode(object-&gt;node()), AccessibilityTextSource::Alternative));
1368     }
1369 
1370     // The figure element derives its alternative text from the first associated figcaption element if one is available.
1371     if (isFigureElement()) {
1372         AccessibilityObject* captionForFigure = this-&gt;captionForFigure();
1373         if (captionForFigure &amp;&amp; !captionForFigure-&gt;isHidden())
1374             textOrder.append(AccessibilityText(accessibleNameForNode(captionForFigure-&gt;node()), AccessibilityTextSource::Alternative));
1375     }
1376 
1377     // Tree items missing a label are labeled by all child elements.
1378     if (isTreeItem() &amp;&amp; ariaLabel.isEmpty() &amp;&amp; ariaLabeledByAttribute().isEmpty())
1379         textOrder.append(AccessibilityText(accessibleNameForNode(node), AccessibilityTextSource::Alternative));
1380 
1381 #if ENABLE(MATHML)
1382     if (node-&gt;isMathMLElement())
1383         textOrder.append(AccessibilityText(getAttribute(MathMLNames::alttextAttr), AccessibilityTextSource::Alternative));
1384 #endif
1385 }
</pre>
<hr />
<pre>
1438         useTextUnderElement = true;
1439 
1440     if (isOutput())
1441         useTextUnderElement = true;
1442 
1443     if (useTextUnderElement) {
1444         AccessibilityTextUnderElementMode mode;
1445 
1446         // Headings often include links as direct children. Those links need to be included in text under element.
1447         if (isHeading())
1448             mode.includeFocusableContent = true;
1449 
1450         String text = textUnderElement(mode);
1451         if (!text.isEmpty())
1452             textOrder.append(AccessibilityText(text, AccessibilityTextSource::Children));
1453     }
1454 }
1455 
1456 void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1457 {
<span class="line-modified">1458     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1459     if (!ariaHelp.isEmpty())
1460         textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
1461 
1462     String describedBy = ariaDescribedByAttribute();
1463     if (!describedBy.isEmpty())
1464         textOrder.append(AccessibilityText(describedBy, AccessibilityTextSource::Summary));
1465     else if (isControl()) {
1466         // For controls, use their fieldset parent&#39;s described-by text if available.
1467         auto matchFunc = [] (const AccessibilityObject&amp; object) {
1468             return object.isFieldset() &amp;&amp; !object.ariaDescribedByAttribute().isEmpty();
1469         };
1470         if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))
1471             textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
1472     }
1473 
1474     // Summary attribute used as help text on tables.
<span class="line-modified">1475     const AtomString&amp; summary = getAttribute(summaryAttr);</span>
1476     if (!summary.isEmpty())
1477         textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
1478 
1479     // The title attribute should be used as help text unless it is already being used as descriptive text.
1480     // However, when the title attribute is the only text alternative provided, it may be exposed as the
1481     // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
1482     // can expose units through this attribute. Therefore, if the element is a meter, change its source
1483     // type to AccessibilityTextSource::Help.
<span class="line-modified">1484     const AtomString&amp; title = getAttribute(titleAttr);</span>
1485     if (!title.isEmpty()) {
1486         if (!isMeter() &amp;&amp; !roleIgnoresTitle())
1487             textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
1488         else
1489             textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
1490     }
1491 }
1492 
<span class="line-modified">1493 void AccessibilityNodeObject::accessibilityText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const</span>
1494 {
1495     titleElementText(textOrder);
1496     alternativeText(textOrder);
1497     visibleText(textOrder);
1498     helpText(textOrder);
1499 
1500     String placeholder = placeholderValue();
1501     if (!placeholder.isEmpty())
1502         textOrder.append(AccessibilityText(placeholder, AccessibilityTextSource::Placeholder));
1503 }
1504 
1505 void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1506 {
1507     String ariaLabeledBy = ariaLabeledByAttribute();
1508     if (!ariaLabeledBy.isEmpty()) {
<span class="line-added">1509         auto objectCache = axObjectCache();</span>
<span class="line-added">1510         if (!objectCache)</span>
<span class="line-added">1511             return;</span>
<span class="line-added">1512 </span>
1513         Vector&lt;Element*&gt; elements;
1514         ariaLabeledByElements(elements);
1515 
1516         Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;
1517         for (const auto&amp; element : elements)
<span class="line-modified">1518             axElements.append(objectCache-&gt;getOrCreate(element));</span>
1519 
1520         textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));
1521     }
1522 }
1523 
1524 String AccessibilityNodeObject::alternativeTextForWebArea() const
1525 {
1526     // The WebArea description should follow this order:
1527     //     aria-label on the &lt;html&gt;
1528     //     title on the &lt;html&gt;
1529     //     &lt;title&gt; inside the &lt;head&gt; (of it was set through JS)
1530     //     name on the &lt;html&gt;
1531     // For iframes:
1532     //     aria-label on the &lt;iframe&gt;
1533     //     title on the &lt;iframe&gt;
1534     //     name on the &lt;iframe&gt;
1535 
1536     Document* document = this-&gt;document();
1537     if (!document)
1538         return String();
1539 
1540     // Check if the HTML element has an aria-label for the webpage.
1541     if (Element* documentElement = document-&gt;documentElement()) {
<span class="line-modified">1542         const AtomString&amp; ariaLabel = documentElement-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1543         if (!ariaLabel.isEmpty())
1544             return ariaLabel;
1545     }
1546 
1547     if (auto* owner = document-&gt;ownerElement()) {
1548         if (owner-&gt;hasTagName(frameTag) || owner-&gt;hasTagName(iframeTag)) {
<span class="line-modified">1549             const AtomString&amp; title = owner-&gt;attributeWithoutSynchronization(titleAttr);</span>
1550             if (!title.isEmpty())
1551                 return title;
1552         }
1553         return owner-&gt;getNameAttribute();
1554     }
1555 
1556     String documentTitle = document-&gt;title();
1557     if (!documentTitle.isEmpty())
1558         return documentTitle;
1559 
1560     if (auto* body = document-&gt;bodyOrFrameset())
1561         return body-&gt;getNameAttribute();
1562 
1563     return String();
1564 }
1565 
1566 String AccessibilityNodeObject::accessibilityDescription() const
1567 {
1568     // Static text should not have a description, it should only have a stringValue.
1569     if (roleValue() == AccessibilityRole::StaticText)
1570         return String();
1571 
1572     String ariaDescription = ariaAccessibilityDescription();
1573     if (!ariaDescription.isEmpty())
1574         return ariaDescription;
1575 
1576     if (usesAltTagForTextComputation()) {
1577         // Images should use alt as long as the attribute is present, even if empty.
1578         // Otherwise, it should fallback to other methods, like the title attribute.
<span class="line-modified">1579         const AtomString&amp; alt = getAttribute(altAttr);</span>
1580         if (!alt.isNull())
1581             return alt;
1582     }
1583 
1584 #if ENABLE(MATHML)
1585     if (is&lt;MathMLElement&gt;(m_node))
1586         return getAttribute(MathMLNames::alttextAttr);
1587 #endif
1588 
1589     // An element&#39;s descriptive text is comprised of title() (what&#39;s visible on the screen) and accessibilityDescription() (other descriptive text).
1590     // Both are used to generate what a screen reader speaks.
1591     // If this point is reached (i.e. there&#39;s no accessibilityDescription) and there&#39;s no title(), we should fallback to using the title attribute.
1592     // The title attribute is normally used as help text (because it is a tooltip), but if there is nothing else available, this should be used (according to ARIA).
1593     // https://bugs.webkit.org/show_bug.cgi?id=170475: An exception is when the element is semantically unimportant. In those cases, title text should remain as help text.
1594     if (title().isEmpty() &amp;&amp; !roleIgnoresTitle())
1595         return getAttribute(titleAttr);
1596 
1597     return String();
1598 }
1599 
</pre>
<hr />
<pre>
1602 bool AccessibilityNodeObject::roleIgnoresTitle() const
1603 {
1604     if (ariaRoleAttribute() != AccessibilityRole::Unknown)
1605         return false;
1606 
1607     switch (roleValue()) {
1608     case AccessibilityRole::Div:
1609     case AccessibilityRole::Unknown:
1610         return true;
1611     default:
1612         return false;
1613     }
1614 }
1615 
1616 String AccessibilityNodeObject::helpText() const
1617 {
1618     Node* node = this-&gt;node();
1619     if (!node)
1620         return String();
1621 
<span class="line-modified">1622     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);</span>
1623     if (!ariaHelp.isEmpty())
1624         return ariaHelp;
1625 
1626     String describedBy = ariaDescribedByAttribute();
1627     if (!describedBy.isEmpty())
1628         return describedBy;
1629 
1630     String description = accessibilityDescription();
1631     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
1632         if (is&lt;HTMLElement&gt;(*ancestor)) {
1633             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*ancestor);
<span class="line-modified">1634             const AtomString&amp; summary = element.getAttribute(summaryAttr);</span>
1635             if (!summary.isEmpty())
1636                 return summary;
1637 
1638             // The title attribute should be used as help text unless it is already being used as descriptive text.
<span class="line-modified">1639             const AtomString&amp; title = element.getAttribute(titleAttr);</span>
1640             if (!title.isEmpty() &amp;&amp; description != title)
1641                 return title;
1642         }
1643 
<span class="line-added">1644         auto objectCache = axObjectCache();</span>
<span class="line-added">1645         if (!objectCache)</span>
<span class="line-added">1646             return String();</span>
<span class="line-added">1647 </span>
1648         // Only take help text from an ancestor element if its a group or an unknown role. If help was
1649         // added to those kinds of elements, it is likely it was meant for a child element.
<span class="line-modified">1650         if (AccessibilityObject* axObj = objectCache-&gt;getOrCreate(ancestor)) {</span>
1651             if (!axObj-&gt;isGroup() &amp;&amp; axObj-&gt;roleValue() != AccessibilityRole::Unknown)
1652                 break;
1653         }
1654     }
1655 
1656     return String();
1657 }
1658 
1659 unsigned AccessibilityNodeObject::hierarchicalLevel() const
1660 {
1661     Node* node = this-&gt;node();
1662     if (!is&lt;Element&gt;(node))
1663         return 0;
1664     Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1665     const AtomString&amp; ariaLevel = element.attributeWithoutSynchronization(aria_levelAttr);</span>
1666     if (!ariaLevel.isEmpty())
1667         return ariaLevel.toInt();
1668 
1669     // Only tree item will calculate its level through the DOM currently.
1670     if (roleValue() != AccessibilityRole::TreeItem)
1671         return 0;
1672 
1673     // Hierarchy leveling starts at 1, to match the aria-level spec.
1674     // We measure tree hierarchy by the number of groups that the item is within.
1675     unsigned level = 1;
1676     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1677         AccessibilityRole parentRole = parent-&gt;ariaRoleAttribute();
1678         if (parentRole == AccessibilityRole::ApplicationGroup)
1679             level++;
1680         else if (parentRole == AccessibilityRole::Tree)
1681             break;
1682     }
1683 
1684     return level;
1685 }
</pre>
<hr />
<pre>
1913 {
1914     Node* node = this-&gt;node();
1915     if (!node)
1916         return String();
1917 
1918     if (isARIAStaticText()) {
1919         String staticText = text();
1920         if (!staticText.length())
1921             staticText = textUnderElement();
1922         return staticText;
1923     }
1924 
1925     if (node-&gt;isTextNode())
1926         return textUnderElement();
1927 
1928     if (node-&gt;hasTagName(selectTag)) {
1929         HTMLSelectElement&amp; selectElement = downcast&lt;HTMLSelectElement&gt;(*node);
1930         int selectedIndex = selectElement.selectedIndex();
1931         const Vector&lt;HTMLElement*&gt;&amp; listItems = selectElement.listItems();
1932         if (selectedIndex &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(selectedIndex) &lt; listItems.size()) {
<span class="line-modified">1933             const AtomString&amp; overriddenDescription = listItems[selectedIndex]-&gt;attributeWithoutSynchronization(aria_labelAttr);</span>
1934             if (!overriddenDescription.isNull())
1935                 return overriddenDescription;
1936         }
1937         if (!selectElement.multiple())
1938             return selectElement.value();
1939         return String();
1940     }
1941 
1942     if (isTextControl())
1943         return text();
1944 
1945     // FIXME: We might need to implement a value here for more types
1946     // FIXME: It would be better not to advertise a value at all for the types for which we don&#39;t implement one;
1947     // this would require subclassing or making accessibilityAttributeNames do something other than return a
1948     // single static array.
1949     return String();
1950 }
1951 
1952 void AccessibilityNodeObject::colorValue(int&amp; r, int&amp; g, int&amp; b) const
1953 {
</pre>
<hr />
<pre>
1961 
1962     if (!is&lt;HTMLInputElement&gt;(node()))
1963         return;
1964 
1965     auto color = downcast&lt;HTMLInputElement&gt;(*node()).valueAsColor();
1966     r = color.red();
1967     g = color.green();
1968     b = color.blue();
1969 #endif
1970 }
1971 
1972 // This function implements the ARIA accessible name as described by the Mozilla
1973 // ARIA Implementer&#39;s Guide.
1974 static String accessibleNameForNode(Node* node, Node* labelledbyNode)
1975 {
1976     ASSERT(node);
1977     if (!is&lt;Element&gt;(node))
1978         return String();
1979 
1980     Element&amp; element = downcast&lt;Element&gt;(*node);
<span class="line-modified">1981     const AtomString&amp; ariaLabel = element.attributeWithoutSynchronization(aria_labelAttr);</span>
1982     if (!ariaLabel.isEmpty())
1983         return ariaLabel;
1984 
<span class="line-modified">1985     const AtomString&amp; alt = element.attributeWithoutSynchronization(altAttr);</span>
1986     if (!alt.isEmpty())
1987         return alt;
1988 
1989     // If the node can be turned into an AX object, we can use standard name computation rules.
1990     // If however, the node cannot (because there&#39;s no renderer e.g.) fallback to using the basic text underneath.
1991     AccessibilityObject* axObject = node-&gt;document().axObjectCache()-&gt;getOrCreate(node);
1992     if (axObject) {
1993         String valueDescription = axObject-&gt;valueDescription();
1994         if (!valueDescription.isEmpty())
1995             return valueDescription;
1996 
1997         // The Accname specification states that if the name is being calculated for a combobox
1998         // or listbox inside a labeling element, return the text alternative of the chosen option.
1999         AccessibilityObject::AccessibilityChildrenVector children;
2000         if (axObject-&gt;isListBox())
2001             axObject-&gt;selectedChildren(children);
2002         else if (axObject-&gt;isComboBox()) {
2003             for (const auto&amp; child : axObject-&gt;children()) {
2004                 if (child-&gt;isListBox()) {
2005                     child-&gt;selectedChildren(children);
</pre>
<hr />
<pre>
2014             appendNameToStringBuilder(builder, accessibleNameForNode(child-&gt;node()));
2015 
2016         childText = builder.toString();
2017         if (!childText.isEmpty())
2018             return childText;
2019     }
2020 
2021     if (is&lt;HTMLInputElement&gt;(*node))
2022         return downcast&lt;HTMLInputElement&gt;(*node).value();
2023 
2024     String text;
2025     if (axObject) {
2026         if (axObject-&gt;accessibleNameDerivesFromContent())
2027             text = axObject-&gt;textUnderElement(AccessibilityTextUnderElementMode(AccessibilityTextUnderElementMode::TextUnderElementModeIncludeNameFromContentsChildren, true, labelledbyNode));
2028     } else
2029         text = element.innerText().simplifyWhiteSpace();
2030 
2031     if (!text.isEmpty())
2032         return text;
2033 
<span class="line-modified">2034     const AtomString&amp; title = element.attributeWithoutSynchronization(titleAttr);</span>
2035     if (!title.isEmpty())
2036         return title;
2037 
2038     return String();
2039 }
2040 
2041 String AccessibilityNodeObject::accessibilityDescriptionForChildren() const
2042 {
2043     Node* node = this-&gt;node();
2044     if (!node)
2045         return String();
2046 
2047     AXObjectCache* cache = axObjectCache();
2048     if (!cache)
2049         return String();
2050 
2051     StringBuilder builder;
2052     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
2053         if (!is&lt;Element&gt;(child))
2054             continue;
</pre>
<hr />
<pre>
2144         return !downcast&lt;HTMLTextAreaElement&gt;(*node).isReadOnly();
2145     if (is&lt;HTMLInputElement&gt;(*node)) {
2146         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
2147         if (input.isTextField())
2148             return !input.isReadOnly();
2149     }
2150 
2151     String readOnly = readOnlyValue();
2152     if (!readOnly.isEmpty())
2153         return readOnly == &quot;true&quot; ? false : true;
2154 
2155     if (isNonNativeTextControl())
2156         return true;
2157 
2158     if (isMeter())
2159         return false;
2160 
2161     if (isProgressIndicator() || isSlider() || isScrollbar())
2162         return true;
2163 
<span class="line-modified">2164 #if USE(ATK)</span>
2165     // In ATK, input types which support aria-readonly are treated as having a
2166     // settable value if the user can modify the widget&#39;s value or its state.
2167     if (supportsReadOnly())
2168         return true;
2169 
2170     if (isRadioButton()) {
2171         auto radioGroup = radioGroupAncestor();
2172         return radioGroup ? radioGroup-&gt;readOnlyValue() != &quot;true&quot; : true;
2173     }
2174 #endif
2175 
2176     if (isWebArea()) {
2177         Document* document = this-&gt;document();
2178         if (!document)
2179             return false;
2180 
2181         if (HTMLElement* body = document-&gt;bodyOrFrameset()) {
2182             if (body-&gt;hasEditableStyle())
2183                 return true;
2184         }
2185 
2186         return document-&gt;hasEditableStyle();
2187     }
2188 
2189     return node-&gt;hasEditableStyle();
2190 }
2191 
2192 AccessibilityRole AccessibilityNodeObject::determineAriaRoleAttribute() const
2193 {
<span class="line-modified">2194     const AtomString&amp; ariaRole = getAttribute(roleAttr);</span>
2195     if (ariaRole.isNull() || ariaRole.isEmpty())
2196         return AccessibilityRole::Unknown;
2197 
2198     AccessibilityRole role = ariaRoleToWebCoreRole(ariaRole);
2199 
2200     // ARIA states if an item can get focus, it should not be presentational.
2201     if (role == AccessibilityRole::Presentational &amp;&amp; canSetFocusAttribute())
2202         return AccessibilityRole::Unknown;
2203 
2204     if (role == AccessibilityRole::Button)
2205         role = buttonRoleType();
2206 
2207     if (role == AccessibilityRole::TextArea &amp;&amp; !ariaIsMultiline())
2208         role = AccessibilityRole::TextField;
2209 
2210     role = remapAriaRoleDueToParent(role);
2211 
2212     // Presentational roles are invalidated by the presence of ARIA attributes.
2213     if (role == AccessibilityRole::Presentational &amp;&amp; supportsARIAAttributes())
2214         role = AccessibilityRole::Unknown;
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityMenuListOption.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>