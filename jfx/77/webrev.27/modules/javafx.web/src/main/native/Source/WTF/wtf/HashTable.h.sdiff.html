<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HashSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  88         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  89 
  90     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  91     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  92 
  93 #if !CHECK_HASHTABLE_ITERATORS
  94 
  95     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  96     inline void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  97         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
  98 
  99     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 100     inline void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 101 
 102 #endif
 103 
 104     typedef enum { HashItemKnownGood } HashItemKnownGoodTag;
 105 
 106     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 107     class HashTableConstIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, const Value*, const Value&amp;&gt; {

 108     private:
 109         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 110         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 111         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 112         typedef Value ValueType;
 113         typedef const ValueType&amp; ReferenceType;
 114         typedef const ValueType* PointerType;
 115 
 116         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 117         friend class HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 118 
 119         void skipEmptyBuckets()
 120         {
 121             while (m_position != m_endPosition &amp;&amp; HashTableType::isEmptyOrDeletedBucket(*m_position))
 122                 ++m_position;
 123         }
 124 
 125         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
 126             : m_position(position), m_endPosition(endPosition)
 127         {
</pre>
<hr />
<pre>
 224         }
 225 #else
 226         void checkValidity(const const_iterator&amp;) const { }
 227 #endif
 228 
 229         PointerType m_position { nullptr };
 230         PointerType m_endPosition { nullptr };
 231 
 232 #if CHECK_HASHTABLE_ITERATORS
 233     public:
 234         // Any modifications of the m_next or m_previous of an iterator that is in a linked list of a HashTable::m_iterator,
 235         // should be guarded with m_table-&gt;m_mutex.
 236         mutable const HashTableType* m_table;
 237         mutable const_iterator* m_next;
 238         mutable const_iterator* m_previous;
 239 #endif
 240     };
 241 
 242     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 243     class HashTableIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, Value*, Value&amp;&gt; {

 244     private:
 245         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 246         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 247         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 248         typedef Value ValueType;
 249         typedef ValueType&amp; ReferenceType;
 250         typedef ValueType* PointerType;
 251 
 252         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 253 
 254         HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
 255         HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }
 256 
 257     public:
 258         HashTableIterator() { }
 259 
 260         // default copy, assignment and destructor are OK
 261 
 262         PointerType get() const { return const_cast&lt;PointerType&gt;(m_iterator.get()); }
 263         ReferenceType operator*() const { return *get(); }
</pre>
<hr />
<pre>
 294         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 295         IteratorType iterator;
 296         bool isNewEntry;
 297 
 298         explicit operator bool() const { return isNewEntry; }
 299     };
 300 
 301     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 302     class HashTable {
 303     public:
 304         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 305         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 306         typedef Traits ValueTraits;
 307         typedef Key KeyType;
 308         typedef Value ValueType;
 309         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 310         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 311 
 312 #if DUMP_HASHTABLE_STATS_PER_TABLE
 313         struct Stats {


 314             Stats()
 315                 : numAccesses(0)
 316                 , numRehashes(0)
 317                 , numRemoves(0)
 318                 , numReinserts(0)
 319                 , maxCollisions(0)
 320                 , numCollisions(0)
 321                 , collisionGraph()
 322             {
 323             }
 324 
 325             unsigned numAccesses;
 326             unsigned numRehashes;
 327             unsigned numRemoves;
 328             unsigned numReinserts;
 329 
 330             unsigned maxCollisions;
 331             unsigned numCollisions;
 332             unsigned collisionGraph[4096];
 333 
</pre>
<hr />
<pre>
 399         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }
 400 
 401         iterator random()
 402         {
 403             if (isEmpty())
 404                 return end();
 405 
 406             while (1) {
 407                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];
 408                 if (!isEmptyOrDeletedBucket(bucket))
 409                     return makeKnownGoodIterator(&amp;bucket);
 410             };
 411         }
 412 
 413         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 414 
 415         unsigned size() const { return m_keyCount; }
 416         unsigned capacity() const { return m_tableSize; }
 417         bool isEmpty() const { return !m_keyCount; }
 418 














 419         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 420         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 421 
 422         // A special version of add() that finds the object by hashing and comparing
 423         // with some other type, to avoid the cost of type conversion if the object is already
 424         // in the table.
 425         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 426         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 427 
 428         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 429         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 430         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 431 
 432         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 433         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 434         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 435 
 436         void remove(const KeyType&amp;);
 437         void remove(iterator);
 438         void removeWithoutEntryConsistencyCheck(iterator);
 439         void removeWithoutEntryConsistencyCheck(const_iterator);
 440         template&lt;typename Functor&gt;
 441         bool removeIf(const Functor&amp;);
 442         void clear();
 443 
 444         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }

 445         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 446         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 447 
 448         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 449         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 450         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 451 
 452 #if !ASSERT_DISABLED
 453         void checkTableConsistency() const;
 454 #else
 455         static void checkTableConsistency() { }
 456 #endif
 457 #if CHECK_HASHTABLE_CONSISTENCY
 458         void internalCheckTableConsistency() const { checkTableConsistency(); }
 459         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 460 #else
 461         static void internalCheckTableConsistencyExceptSize() { }
 462         static void internalCheckTableConsistency() { }
 463 #endif
 464 
 465     private:
 466         static ValueType* allocateTable(unsigned size);
 467         static void deallocateTable(ValueType* table, unsigned size);
 468 
 469         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 470         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 471 
 472         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 473         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 474         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 475 
 476         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 477 
 478         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 479 
 480         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 481         void removeAndInvalidate(ValueType*);
 482         void remove(ValueType*);
 483 

 484         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }
 485         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }
 486         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }
 487         ValueType* expand(ValueType* entry = nullptr);
 488         void shrink() { rehash(m_tableSize / 2, nullptr); }



 489 
 490         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 491         ValueType* reinsert(ValueType&amp;&amp;);
 492 
 493         static void initializeBucket(ValueType&amp; bucket);
 494         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 495 
 496         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 497             { return FullLookupType(LookupType(position, found), hash); }
 498 
 499         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }
 500         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }
 501         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 502         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 503 
 504 #if !ASSERT_DISABLED
 505         void checkTableConsistencyExceptSize() const;
 506 #else
 507         static void checkTableConsistencyExceptSize() { }
 508 #endif
</pre>
<hr />
<pre>
 566 
 567     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.
 568     // This is done at compile time to initialize the HashTraits.
 569     template&lt;unsigned size&gt;
 570     struct HashTableCapacityForSize {
 571         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;
 572         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);
 573         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);
 574         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);
 575     };
 576 
 577     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 578     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
 579         : m_table(0)
 580         , m_tableSize(0)
 581         , m_tableSizeMask(0)
 582         , m_keyCount(0)
 583         , m_deletedCount(0)
 584 #if CHECK_HASHTABLE_ITERATORS
 585         , m_iterators(0)
<span class="line-modified"> 586         , m_mutex(std::make_unique&lt;Lock&gt;())</span>
 587 #endif
 588 #if DUMP_HASHTABLE_STATS_PER_TABLE
<span class="line-modified"> 589         , m_stats(std::make_unique&lt;Stats&gt;())</span>
 590 #endif
 591     {
 592     }
 593 
 594     inline unsigned doubleHash(unsigned key)
 595     {
 596         key = ~key + (key &gt;&gt; 23);
 597         key ^= (key &lt;&lt; 12);
 598         key ^= (key &gt;&gt; 7);
 599         key ^= (key &lt;&lt; 2);
 600         key ^= (key &gt;&gt; 20);
 601         return key;
 602     }
 603 
 604 #if ASSERT_DISABLED
 605 
 606     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 607     template&lt;typename HashTranslator, typename T&gt;
 608     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 609     {
</pre>
<hr />
<pre>
1147         // make a function call, which prevents the compiler from keeping
1148         // the values in register.
1149         unsigned removedBucketCount = 0;
1150         ValueType* table = m_table;
1151 
1152         for (unsigned i = m_tableSize; i--;) {
1153             ValueType&amp; bucket = table[i];
1154             if (isEmptyOrDeletedBucket(bucket))
1155                 continue;
1156 
1157             if (!functor(bucket))
1158                 continue;
1159 
1160             deleteBucket(bucket);
1161             ++removedBucketCount;
1162         }
1163         m_deletedCount += removedBucketCount;
1164         m_keyCount -= removedBucketCount;
1165 
1166         if (shouldShrink())
<span class="line-modified">1167             shrink();</span>
1168 
1169         internalCheckTableConsistency();
1170         return removedBucketCount;
1171     }
1172 
1173     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1174     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1175     {
1176         // would use a template member function with explicit specializations here, but
1177         // gcc doesn&#39;t appear to support that
1178         if (Traits::emptyValueIsZero)
1179             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));
1180         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));
1181         for (unsigned i = 0; i &lt; size; i++)
1182             initializeBucket(result[i]);
1183         return result;
1184     }
1185 
1186     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1187     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)
1188     {
1189         for (unsigned i = 0; i &lt; size; ++i) {
1190             if (!isDeletedBucket(table[i]))
1191                 table[i].~ValueType();
1192         }
1193         fastFree(table);
1194     }
1195 
1196     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1197     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1198     {



1199         unsigned newSize;
1200         if (m_tableSize == 0)
1201             newSize = KeyTraits::minimumTableSize;
1202         else if (mustRehashInPlace())
1203             newSize = m_tableSize;
1204         else
1205             newSize = m_tableSize * 2;
1206 
1207         return rehash(newSize, entry);
1208     }
1209 




































1210     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1211     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1212     {
1213         internalCheckTableConsistencyExceptSize();
1214 
1215         unsigned oldTableSize = m_tableSize;
1216         ValueType* oldTable = m_table;
1217 
1218 #if DUMP_HASHTABLE_STATS
1219         if (oldTableSize != 0)
1220             ++HashTableStats::numRehashes;
1221 #endif
1222 
1223 #if DUMP_HASHTABLE_STATS_PER_TABLE
1224         if (oldTableSize != 0)
1225             ++m_stats-&gt;numRehashes;
1226 #endif
1227 
1228         m_tableSize = newTableSize;
1229         m_tableSizeMask = newTableSize - 1;
1230         m_table = allocateTable(newTableSize);
1231 
1232         Value* newEntry = nullptr;
1233         for (unsigned i = 0; i != oldTableSize; ++i) {
<span class="line-modified">1234             if (isDeletedBucket(oldTable[i])) {</span>
<span class="line-modified">1235                 ASSERT(std::addressof(oldTable[i]) != entry);</span>

1236                 continue;
1237             }
1238 
<span class="line-modified">1239             if (isEmptyBucket(oldTable[i])) {</span>
<span class="line-modified">1240                 ASSERT(std::addressof(oldTable[i]) != entry);</span>
1241                 oldTable[i].~ValueType();
1242                 continue;
1243             }
1244 
<span class="line-modified">1245             Value* reinsertedEntry = reinsert(WTFMove(oldTable[i]));</span>
<span class="line-modified">1246             oldTable[i].~ValueType();</span>
<span class="line-modified">1247             if (std::addressof(oldTable[i]) == entry) {</span>







1248                 ASSERT(!newEntry);
1249                 newEntry = reinsertedEntry;
1250             }
1251         }
1252 
1253         m_deletedCount = 0;
1254 
1255         fastFree(oldTable);
1256 
1257         internalCheckTableConsistency();
1258         return newEntry;
1259     }
1260 
1261     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1262     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1263     {
1264         invalidateIterators();
1265         if (!m_table)
1266             return;
1267 
1268         deallocateTable(m_table, m_tableSize);
1269         m_table = 0;
1270         m_tableSize = 0;
1271         m_tableSizeMask = 0;
1272         m_keyCount = 0;
1273         m_deletedCount = 0;
1274     }
1275 
1276     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1277     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1278         : m_table(nullptr)
1279         , m_tableSize(0)
1280         , m_tableSizeMask(0)
1281         , m_keyCount(0)
1282         , m_deletedCount(0)
1283 #if CHECK_HASHTABLE_ITERATORS
1284         , m_iterators(nullptr)
<span class="line-modified">1285         , m_mutex(std::make_unique&lt;Lock&gt;())</span>
1286 #endif
1287 #if DUMP_HASHTABLE_STATS_PER_TABLE
<span class="line-modified">1288         , m_stats(std::make_unique&lt;Stats&gt;(*other.m_stats))</span>
1289 #endif
1290     {
1291         unsigned otherKeyCount = other.size();
1292         if (!otherKeyCount)
1293             return;
1294 
<span class="line-modified">1295         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(otherKeyCount) * 2;</span>
<span class="line-removed">1296 </span>
<span class="line-removed">1297         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.</span>
<span class="line-removed">1298         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to</span>
<span class="line-removed">1299         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).</span>
<span class="line-removed">1300         bool aboveThreeQuarterLoad = otherKeyCount * 12 &gt;= bestTableSize * 5;</span>
<span class="line-removed">1301         if (aboveThreeQuarterLoad)</span>
<span class="line-removed">1302             bestTableSize *= 2;</span>
<span class="line-removed">1303 </span>
<span class="line-removed">1304         unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-removed">1305         m_tableSize = std::max&lt;unsigned&gt;(bestTableSize, minimumTableSize);</span>
1306         m_tableSizeMask = m_tableSize - 1;
1307         m_keyCount = otherKeyCount;
1308         m_table = allocateTable(m_tableSize);
1309 
1310         for (const auto&amp; otherValue : other)
1311             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1312     }
1313 
1314     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1315     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1316     {
1317         invalidateIterators();
1318         other.invalidateIterators();
1319 
1320         std::swap(m_table, other.m_table);
1321         std::swap(m_tableSize, other.m_tableSize);
1322         std::swap(m_tableSizeMask, other.m_tableSizeMask);
1323         std::swap(m_keyCount, other.m_keyCount);
1324         std::swap(m_deletedCount, other.m_deletedCount);
1325 
1326 #if DUMP_HASHTABLE_STATS_PER_TABLE
1327         m_stats.swap(other.m_stats);
1328 #endif
1329     }
1330 
1331     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1332     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1333     {
1334         HashTable tmp(other);
1335         swap(tmp);
1336         return *this;
1337     }
1338 
1339     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1340     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1341 #if CHECK_HASHTABLE_ITERATORS
1342         : m_iterators(nullptr)
<span class="line-modified">1343         , m_mutex(std::make_unique&lt;Lock&gt;())</span>
1344 #endif
1345     {
1346         other.invalidateIterators();
1347 
1348         m_table = other.m_table;
1349         m_tableSize = other.m_tableSize;
1350         m_tableSizeMask = other.m_tableSizeMask;
1351         m_keyCount = other.m_keyCount;
1352         m_deletedCount = other.m_deletedCount;
1353 
1354         other.m_table = nullptr;
1355         other.m_tableSize = 0;
1356         other.m_tableSizeMask = 0;
1357         other.m_keyCount = 0;
1358         other.m_deletedCount = 0;
1359 
1360 #if DUMP_HASHTABLE_STATS_PER_TABLE
1361         m_stats = WTFMove(other.m_stats);
1362         other.m_stats = nullptr;
1363 #endif
</pre>
<hr />
<pre>
1382     }
1383 
1384     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1385     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1386     {
1387         if (!m_table)
1388             return;
1389 
1390         unsigned count = 0;
1391         unsigned deletedCount = 0;
1392         for (unsigned j = 0; j &lt; m_tableSize; ++j) {
1393             ValueType* entry = m_table + j;
1394             if (isEmptyBucket(*entry))
1395                 continue;
1396 
1397             if (isDeletedBucket(*entry)) {
1398                 ++deletedCount;
1399                 continue;
1400             }
1401 
<span class="line-modified">1402             const_iterator it = find(Extractor::extract(*entry));</span>

1403             ASSERT(entry == it.m_position);
1404             ++count;
1405 
<span class="line-modified">1406             ValueCheck&lt;Key&gt;::checkConsistency(it-&gt;key);</span>
1407         }
1408 
1409         ASSERT(count == m_keyCount);
1410         ASSERT(deletedCount == m_deletedCount);
1411         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);
1412         ASSERT(m_tableSizeMask);
1413         ASSERT(m_tableSize == m_tableSizeMask + 1);
1414     }
1415 
1416 #endif // ASSERT_DISABLED
1417 
1418 #if CHECK_HASHTABLE_ITERATORS
1419 
1420     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1421     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1422     {
1423         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1424         const_iterator* next;
1425         for (const_iterator* p = m_iterators; p; p = next) {
1426             next = p-&gt;m_next;
</pre>
</td>
<td>
<hr />
<pre>
  88         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  89 
  90     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  91     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  92 
  93 #if !CHECK_HASHTABLE_ITERATORS
  94 
  95     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  96     inline void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  97         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
  98 
  99     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 100     inline void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 101 
 102 #endif
 103 
 104     typedef enum { HashItemKnownGood } HashItemKnownGoodTag;
 105 
 106     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 107     class HashTableConstIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, const Value*, const Value&amp;&gt; {
<span class="line-added"> 108         WTF_MAKE_FAST_ALLOCATED;</span>
 109     private:
 110         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 111         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 112         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 113         typedef Value ValueType;
 114         typedef const ValueType&amp; ReferenceType;
 115         typedef const ValueType* PointerType;
 116 
 117         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 118         friend class HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 119 
 120         void skipEmptyBuckets()
 121         {
 122             while (m_position != m_endPosition &amp;&amp; HashTableType::isEmptyOrDeletedBucket(*m_position))
 123                 ++m_position;
 124         }
 125 
 126         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
 127             : m_position(position), m_endPosition(endPosition)
 128         {
</pre>
<hr />
<pre>
 225         }
 226 #else
 227         void checkValidity(const const_iterator&amp;) const { }
 228 #endif
 229 
 230         PointerType m_position { nullptr };
 231         PointerType m_endPosition { nullptr };
 232 
 233 #if CHECK_HASHTABLE_ITERATORS
 234     public:
 235         // Any modifications of the m_next or m_previous of an iterator that is in a linked list of a HashTable::m_iterator,
 236         // should be guarded with m_table-&gt;m_mutex.
 237         mutable const HashTableType* m_table;
 238         mutable const_iterator* m_next;
 239         mutable const_iterator* m_previous;
 240 #endif
 241     };
 242 
 243     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 244     class HashTableIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, Value*, Value&amp;&gt; {
<span class="line-added"> 245         WTF_MAKE_FAST_ALLOCATED;</span>
 246     private:
 247         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 248         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 249         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 250         typedef Value ValueType;
 251         typedef ValueType&amp; ReferenceType;
 252         typedef ValueType* PointerType;
 253 
 254         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 255 
 256         HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
 257         HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }
 258 
 259     public:
 260         HashTableIterator() { }
 261 
 262         // default copy, assignment and destructor are OK
 263 
 264         PointerType get() const { return const_cast&lt;PointerType&gt;(m_iterator.get()); }
 265         ReferenceType operator*() const { return *get(); }
</pre>
<hr />
<pre>
 296         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 297         IteratorType iterator;
 298         bool isNewEntry;
 299 
 300         explicit operator bool() const { return isNewEntry; }
 301     };
 302 
 303     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 304     class HashTable {
 305     public:
 306         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 307         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 308         typedef Traits ValueTraits;
 309         typedef Key KeyType;
 310         typedef Value ValueType;
 311         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 312         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 313 
 314 #if DUMP_HASHTABLE_STATS_PER_TABLE
 315         struct Stats {
<span class="line-added"> 316             WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
<span class="line-added"> 317 </span>
 318             Stats()
 319                 : numAccesses(0)
 320                 , numRehashes(0)
 321                 , numRemoves(0)
 322                 , numReinserts(0)
 323                 , maxCollisions(0)
 324                 , numCollisions(0)
 325                 , collisionGraph()
 326             {
 327             }
 328 
 329             unsigned numAccesses;
 330             unsigned numRehashes;
 331             unsigned numRemoves;
 332             unsigned numReinserts;
 333 
 334             unsigned maxCollisions;
 335             unsigned numCollisions;
 336             unsigned collisionGraph[4096];
 337 
</pre>
<hr />
<pre>
 403         const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); }
 404 
 405         iterator random()
 406         {
 407             if (isEmpty())
 408                 return end();
 409 
 410             while (1) {
 411                 auto&amp; bucket = m_table[weakRandomUint32() &amp; m_tableSizeMask];
 412                 if (!isEmptyOrDeletedBucket(bucket))
 413                     return makeKnownGoodIterator(&amp;bucket);
 414             };
 415         }
 416 
 417         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 418 
 419         unsigned size() const { return m_keyCount; }
 420         unsigned capacity() const { return m_tableSize; }
 421         bool isEmpty() const { return !m_keyCount; }
 422 
<span class="line-added"> 423         void reserveInitialCapacity(unsigned keyCount)</span>
<span class="line-added"> 424         {</span>
<span class="line-added"> 425             ASSERT(!m_table);</span>
<span class="line-added"> 426             ASSERT(!m_tableSize);</span>
<span class="line-added"> 427             ASSERT(!m_deletedCount);</span>
<span class="line-added"> 428 </span>
<span class="line-added"> 429             unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added"> 430             unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));</span>
<span class="line-added"> 431 </span>
<span class="line-added"> 432             m_tableSize = newTableSize;</span>
<span class="line-added"> 433             m_tableSizeMask = newTableSize - 1;</span>
<span class="line-added"> 434             m_table = allocateTable(newTableSize);</span>
<span class="line-added"> 435         }</span>
<span class="line-added"> 436 </span>
 437         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 438         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 439 
 440         // A special version of add() that finds the object by hashing and comparing
 441         // with some other type, to avoid the cost of type conversion if the object is already
 442         // in the table.
 443         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 444         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 445 
 446         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 447         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 448         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 449 
 450         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 451         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 452         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 453 
 454         void remove(const KeyType&amp;);
 455         void remove(iterator);
 456         void removeWithoutEntryConsistencyCheck(iterator);
 457         void removeWithoutEntryConsistencyCheck(const_iterator);
 458         template&lt;typename Functor&gt;
 459         bool removeIf(const Functor&amp;);
 460         void clear();
 461 
 462         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
<span class="line-added"> 463         static bool isReleasedWeakBucket(const ValueType&amp; value) { return isHashTraitsReleasedWeakValue&lt;KeyTraits&gt;(Extractor::extract(value)); }</span>
 464         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 465         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 466 
 467         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 468         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 469         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 470 
 471 #if !ASSERT_DISABLED
 472         void checkTableConsistency() const;
 473 #else
 474         static void checkTableConsistency() { }
 475 #endif
 476 #if CHECK_HASHTABLE_CONSISTENCY
 477         void internalCheckTableConsistency() const { checkTableConsistency(); }
 478         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 479 #else
 480         static void internalCheckTableConsistencyExceptSize() { }
 481         static void internalCheckTableConsistency() { }
 482 #endif
 483 
 484     private:
 485         static ValueType* allocateTable(unsigned size);
 486         static void deallocateTable(ValueType* table, unsigned size);
 487 
 488         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 489         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 490 
 491         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 492         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 493         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 494 
 495         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 496 
 497         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 498 
 499         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 500         void removeAndInvalidate(ValueType*);
 501         void remove(ValueType*);
 502 
<span class="line-added"> 503         static constexpr unsigned computeBestTableSize(unsigned keyCount);</span>
 504         bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; }
 505         bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; }
 506         bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; }
 507         ValueType* expand(ValueType* entry = nullptr);
 508         void shrink() { rehash(m_tableSize / 2, nullptr); }
<span class="line-added"> 509         void shrinkToBestSize();</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511         void deleteReleasedWeakBuckets();</span>
 512 
 513         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 514         ValueType* reinsert(ValueType&amp;&amp;);
 515 
 516         static void initializeBucket(ValueType&amp; bucket);
 517         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 518 
 519         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 520             { return FullLookupType(LookupType(position, found), hash); }
 521 
 522         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); }
 523         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); }
 524         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 525         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }
 526 
 527 #if !ASSERT_DISABLED
 528         void checkTableConsistencyExceptSize() const;
 529 #else
 530         static void checkTableConsistencyExceptSize() { }
 531 #endif
</pre>
<hr />
<pre>
 589 
 590     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.
 591     // This is done at compile time to initialize the HashTraits.
 592     template&lt;unsigned size&gt;
 593     struct HashTableCapacityForSize {
 594         static const unsigned value = HashTableCapacityForSizeSplitter&lt;size, !(size &amp; (size - 1))&gt;::value;
 595         COMPILE_ASSERT(size &gt; 0, HashTableNonZeroMinimumCapacity);
 596         COMPILE_ASSERT(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), HashTableNoCapacityOverflow);
 597         COMPILE_ASSERT(value &gt; (2 * size), HashTableCapacityHoldsContentSize);
 598     };
 599 
 600     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 601     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
 602         : m_table(0)
 603         , m_tableSize(0)
 604         , m_tableSizeMask(0)
 605         , m_keyCount(0)
 606         , m_deletedCount(0)
 607 #if CHECK_HASHTABLE_ITERATORS
 608         , m_iterators(0)
<span class="line-modified"> 609         , m_mutex(makeUnique&lt;Lock&gt;())</span>
 610 #endif
 611 #if DUMP_HASHTABLE_STATS_PER_TABLE
<span class="line-modified"> 612         , m_stats(makeUnique&lt;Stats&gt;())</span>
 613 #endif
 614     {
 615     }
 616 
 617     inline unsigned doubleHash(unsigned key)
 618     {
 619         key = ~key + (key &gt;&gt; 23);
 620         key ^= (key &lt;&lt; 12);
 621         key ^= (key &gt;&gt; 7);
 622         key ^= (key &lt;&lt; 2);
 623         key ^= (key &gt;&gt; 20);
 624         return key;
 625     }
 626 
 627 #if ASSERT_DISABLED
 628 
 629     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 630     template&lt;typename HashTranslator, typename T&gt;
 631     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 632     {
</pre>
<hr />
<pre>
1170         // make a function call, which prevents the compiler from keeping
1171         // the values in register.
1172         unsigned removedBucketCount = 0;
1173         ValueType* table = m_table;
1174 
1175         for (unsigned i = m_tableSize; i--;) {
1176             ValueType&amp; bucket = table[i];
1177             if (isEmptyOrDeletedBucket(bucket))
1178                 continue;
1179 
1180             if (!functor(bucket))
1181                 continue;
1182 
1183             deleteBucket(bucket);
1184             ++removedBucketCount;
1185         }
1186         m_deletedCount += removedBucketCount;
1187         m_keyCount -= removedBucketCount;
1188 
1189         if (shouldShrink())
<span class="line-modified">1190             shrinkToBestSize();</span>
1191 
1192         internalCheckTableConsistency();
1193         return removedBucketCount;
1194     }
1195 
1196     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1197     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1198     {
1199         // would use a template member function with explicit specializations here, but
1200         // gcc doesn&#39;t appear to support that
1201         if (Traits::emptyValueIsZero)
1202             return static_cast&lt;ValueType*&gt;(fastZeroedMalloc(size * sizeof(ValueType)));
1203         ValueType* result = static_cast&lt;ValueType*&gt;(fastMalloc(size * sizeof(ValueType)));
1204         for (unsigned i = 0; i &lt; size; i++)
1205             initializeBucket(result[i]);
1206         return result;
1207     }
1208 
1209     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1210     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table, unsigned size)
1211     {
1212         for (unsigned i = 0; i &lt; size; ++i) {
1213             if (!isDeletedBucket(table[i]))
1214                 table[i].~ValueType();
1215         }
1216         fastFree(table);
1217     }
1218 
1219     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1220     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1221     {
<span class="line-added">1222         if (KeyTraits::hasIsReleasedWeakValueFunction)</span>
<span class="line-added">1223             deleteReleasedWeakBuckets();</span>
<span class="line-added">1224 </span>
1225         unsigned newSize;
1226         if (m_tableSize == 0)
1227             newSize = KeyTraits::minimumTableSize;
1228         else if (mustRehashInPlace())
1229             newSize = m_tableSize;
1230         else
1231             newSize = m_tableSize * 2;
1232 
1233         return rehash(newSize, entry);
1234     }
1235 
<span class="line-added">1236     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1237     constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)</span>
<span class="line-added">1238     {</span>
<span class="line-added">1239         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount) * 2;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241         // With maxLoad at 1/2 and minLoad at 1/6, our average load is 2/6.</span>
<span class="line-added">1242         // If we are getting halfway between 2/6 and 1/2 (past 5/12), we double the size to avoid being too close to</span>
<span class="line-added">1243         // loadMax and bring the ratio close to 2/6. This give us a load in the bounds [3/12, 5/12).</span>
<span class="line-added">1244         bool aboveThreeQuarterLoad = keyCount * 12 &gt;= bestTableSize * 5;</span>
<span class="line-added">1245         if (aboveThreeQuarterLoad)</span>
<span class="line-added">1246             bestTableSize *= 2;</span>
<span class="line-added">1247 </span>
<span class="line-added">1248         unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added">1249         return std::max(bestTableSize, minimumTableSize);</span>
<span class="line-added">1250     }</span>
<span class="line-added">1251 </span>
<span class="line-added">1252     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1253     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()</span>
<span class="line-added">1254     {</span>
<span class="line-added">1255         unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
<span class="line-added">1256         rehash(std::max(minimumTableSize, computeBestTableSize(m_keyCount)), nullptr);</span>
<span class="line-added">1257     }</span>
<span class="line-added">1258 </span>
<span class="line-added">1259     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span>
<span class="line-added">1260     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()</span>
<span class="line-added">1261     {</span>
<span class="line-added">1262         for (unsigned i = 0; i &lt; m_tableSize; ++i) {</span>
<span class="line-added">1263             auto&amp; entry = m_table[i];</span>
<span class="line-added">1264             if (isReleasedWeakBucket(entry)) {</span>
<span class="line-added">1265                 deleteBucket(entry);</span>
<span class="line-added">1266                 ++m_deletedCount;</span>
<span class="line-added">1267                 --m_keyCount;</span>
<span class="line-added">1268             }</span>
<span class="line-added">1269         }</span>
<span class="line-added">1270     }</span>
<span class="line-added">1271 </span>
1272     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1273     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1274     {
1275         internalCheckTableConsistencyExceptSize();
1276 
1277         unsigned oldTableSize = m_tableSize;
1278         ValueType* oldTable = m_table;
1279 
1280 #if DUMP_HASHTABLE_STATS
1281         if (oldTableSize != 0)
1282             ++HashTableStats::numRehashes;
1283 #endif
1284 
1285 #if DUMP_HASHTABLE_STATS_PER_TABLE
1286         if (oldTableSize != 0)
1287             ++m_stats-&gt;numRehashes;
1288 #endif
1289 
1290         m_tableSize = newTableSize;
1291         m_tableSizeMask = newTableSize - 1;
1292         m_table = allocateTable(newTableSize);
1293 
1294         Value* newEntry = nullptr;
1295         for (unsigned i = 0; i != oldTableSize; ++i) {
<span class="line-modified">1296             auto&amp; oldEntry = oldTable[i];</span>
<span class="line-modified">1297             if (isDeletedBucket(oldEntry)) {</span>
<span class="line-added">1298                 ASSERT(std::addressof(oldEntry) != entry);</span>
1299                 continue;
1300             }
1301 
<span class="line-modified">1302             if (isEmptyBucket(oldEntry)) {</span>
<span class="line-modified">1303                 ASSERT(std::addressof(oldEntry) != entry);</span>
1304                 oldTable[i].~ValueType();
1305                 continue;
1306             }
1307 
<span class="line-modified">1308             if (isReleasedWeakBucket(oldEntry)) {</span>
<span class="line-modified">1309                 ASSERT(std::addressof(oldEntry) != entry);</span>
<span class="line-modified">1310                 oldEntry.~ValueType();</span>
<span class="line-added">1311                 --m_keyCount;</span>
<span class="line-added">1312                 continue;</span>
<span class="line-added">1313             }</span>
<span class="line-added">1314 </span>
<span class="line-added">1315             Value* reinsertedEntry = reinsert(WTFMove(oldEntry));</span>
<span class="line-added">1316             oldEntry.~ValueType();</span>
<span class="line-added">1317             if (std::addressof(oldEntry) == entry) {</span>
1318                 ASSERT(!newEntry);
1319                 newEntry = reinsertedEntry;
1320             }
1321         }
1322 
1323         m_deletedCount = 0;
1324 
1325         fastFree(oldTable);
1326 
1327         internalCheckTableConsistency();
1328         return newEntry;
1329     }
1330 
1331     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1332     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1333     {
1334         invalidateIterators();
1335         if (!m_table)
1336             return;
1337 
1338         deallocateTable(m_table, m_tableSize);
1339         m_table = 0;
1340         m_tableSize = 0;
1341         m_tableSizeMask = 0;
1342         m_keyCount = 0;
1343         m_deletedCount = 0;
1344     }
1345 
1346     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1347     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1348         : m_table(nullptr)
1349         , m_tableSize(0)
1350         , m_tableSizeMask(0)
1351         , m_keyCount(0)
1352         , m_deletedCount(0)
1353 #if CHECK_HASHTABLE_ITERATORS
1354         , m_iterators(nullptr)
<span class="line-modified">1355         , m_mutex(makeUnique&lt;Lock&gt;())</span>
1356 #endif
1357 #if DUMP_HASHTABLE_STATS_PER_TABLE
<span class="line-modified">1358         , m_stats(makeUnique&lt;Stats&gt;(*other.m_stats))</span>
1359 #endif
1360     {
1361         unsigned otherKeyCount = other.size();
1362         if (!otherKeyCount)
1363             return;
1364 
<span class="line-modified">1365         m_tableSize = computeBestTableSize(otherKeyCount);</span>










1366         m_tableSizeMask = m_tableSize - 1;
1367         m_keyCount = otherKeyCount;
1368         m_table = allocateTable(m_tableSize);
1369 
1370         for (const auto&amp; otherValue : other)
1371             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1372     }
1373 
1374     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1375     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1376     {
1377         invalidateIterators();
1378         other.invalidateIterators();
1379 
1380         std::swap(m_table, other.m_table);
1381         std::swap(m_tableSize, other.m_tableSize);
1382         std::swap(m_tableSizeMask, other.m_tableSizeMask);
1383         std::swap(m_keyCount, other.m_keyCount);
1384         std::swap(m_deletedCount, other.m_deletedCount);
1385 
1386 #if DUMP_HASHTABLE_STATS_PER_TABLE
1387         m_stats.swap(other.m_stats);
1388 #endif
1389     }
1390 
1391     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1392     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1393     {
1394         HashTable tmp(other);
1395         swap(tmp);
1396         return *this;
1397     }
1398 
1399     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1400     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1401 #if CHECK_HASHTABLE_ITERATORS
1402         : m_iterators(nullptr)
<span class="line-modified">1403         , m_mutex(makeUnique&lt;Lock&gt;())</span>
1404 #endif
1405     {
1406         other.invalidateIterators();
1407 
1408         m_table = other.m_table;
1409         m_tableSize = other.m_tableSize;
1410         m_tableSizeMask = other.m_tableSizeMask;
1411         m_keyCount = other.m_keyCount;
1412         m_deletedCount = other.m_deletedCount;
1413 
1414         other.m_table = nullptr;
1415         other.m_tableSize = 0;
1416         other.m_tableSizeMask = 0;
1417         other.m_keyCount = 0;
1418         other.m_deletedCount = 0;
1419 
1420 #if DUMP_HASHTABLE_STATS_PER_TABLE
1421         m_stats = WTFMove(other.m_stats);
1422         other.m_stats = nullptr;
1423 #endif
</pre>
<hr />
<pre>
1442     }
1443 
1444     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1445     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1446     {
1447         if (!m_table)
1448             return;
1449 
1450         unsigned count = 0;
1451         unsigned deletedCount = 0;
1452         for (unsigned j = 0; j &lt; m_tableSize; ++j) {
1453             ValueType* entry = m_table + j;
1454             if (isEmptyBucket(*entry))
1455                 continue;
1456 
1457             if (isDeletedBucket(*entry)) {
1458                 ++deletedCount;
1459                 continue;
1460             }
1461 
<span class="line-modified">1462             auto&amp; key = Extractor::extract(*entry);</span>
<span class="line-added">1463             const_iterator it = find(key);</span>
1464             ASSERT(entry == it.m_position);
1465             ++count;
1466 
<span class="line-modified">1467             ValueCheck&lt;Key&gt;::checkConsistency(key);</span>
1468         }
1469 
1470         ASSERT(count == m_keyCount);
1471         ASSERT(deletedCount == m_deletedCount);
1472         ASSERT(m_tableSize &gt;= KeyTraits::minimumTableSize);
1473         ASSERT(m_tableSizeMask);
1474         ASSERT(m_tableSize == m_tableSizeMask + 1);
1475     }
1476 
1477 #endif // ASSERT_DISABLED
1478 
1479 #if CHECK_HASHTABLE_ITERATORS
1480 
1481     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1482     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1483     {
1484         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1485         const_iterator* next;
1486         for (const_iterator* p = m_iterators; p; p = next) {
1487             next = p-&gt;m_next;
</pre>
</td>
</tr>
</table>
<center><a href="HashSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HashTraits.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>