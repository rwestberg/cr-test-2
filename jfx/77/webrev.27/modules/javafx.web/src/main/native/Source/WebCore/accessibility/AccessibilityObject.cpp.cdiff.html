<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityNodeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,29 ***</span>
  
  #include &quot;AXObjectCache.h&quot;
  #include &quot;AccessibilityRenderObject.h&quot;
  #include &quot;AccessibilityScrollView.h&quot;
  #include &quot;AccessibilityTable.h&quot;
<span class="line-modified">! #include &quot;AccessibleSetValueEvent.h&quot;</span>
  #include &quot;DOMTokenList.h&quot;
  #include &quot;Editing.h&quot;
  #include &quot;Editor.h&quot;
  #include &quot;ElementIterator.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;EventDispatcher.h&quot;
  #include &quot;EventHandler.h&quot;
  #include &quot;FloatRect.h&quot;
  #include &quot;FocusController.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameSelection.h&quot;
  #include &quot;HTMLDetailsElement.h&quot;
  #include &quot;HTMLFormControlElement.h&quot;
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;HTMLMediaElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HTMLParserIdioms.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;LocalizedStrings.h&quot;
  #include &quot;MathMLNames.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;NodeTraversal.h&quot;
<span class="line-new-header">--- 31,33 ---</span>
  
  #include &quot;AXObjectCache.h&quot;
  #include &quot;AccessibilityRenderObject.h&quot;
  #include &quot;AccessibilityScrollView.h&quot;
  #include &quot;AccessibilityTable.h&quot;
<span class="line-modified">! #include &quot;Chrome.h&quot;</span>
<span class="line-added">+ #include &quot;ChromeClient.h&quot;</span>
  #include &quot;DOMTokenList.h&quot;
  #include &quot;Editing.h&quot;
  #include &quot;Editor.h&quot;
  #include &quot;ElementIterator.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;EventDispatcher.h&quot;
  #include &quot;EventHandler.h&quot;
<span class="line-added">+ #include &quot;EventNames.h&quot;</span>
  #include &quot;FloatRect.h&quot;
  #include &quot;FocusController.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameSelection.h&quot;
<span class="line-added">+ #include &quot;HTMLDataListElement.h&quot;</span>
  #include &quot;HTMLDetailsElement.h&quot;
  #include &quot;HTMLFormControlElement.h&quot;
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;HTMLMediaElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HTMLParserIdioms.h&quot;
<span class="line-added">+ #include &quot;HTMLTextAreaElement.h&quot;</span>
  #include &quot;HitTestResult.h&quot;
  #include &quot;LocalizedStrings.h&quot;
  #include &quot;MathMLNames.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;NodeTraversal.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,18 ***</span>
  
      // Clear any children and call detachFromParent on them so that
      // no children are left with dangling pointers to their parent.
      clearChildren();
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
      setWrapper(nullptr);
  #endif
  }
  
  bool AccessibilityObject::isDetached() const
  {
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
      return !wrapper();
  #else
      return true;
  #endif
  }
<span class="line-new-header">--- 104,18 ---</span>
  
      // Clear any children and call detachFromParent on them so that
      // no children are left with dangling pointers to their parent.
      clearChildren();
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
      setWrapper(nullptr);
  #endif
  }
  
  bool AccessibilityObject::isDetached() const
  {
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
      return !wrapper();
  #else
      return true;
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,10 ***</span>
<span class="line-new-header">--- 195,13 ---</span>
          return axObject-&gt;isHeading();
  
      case AccessibilitySearchKey::Highlighted:
          return axObject-&gt;hasHighlighting();
  
<span class="line-added">+     case AccessibilitySearchKey::KeyboardFocusable:</span>
<span class="line-added">+         return axObject-&gt;isKeyboardFocusable();</span>
<span class="line-added">+ </span>
      case AccessibilitySearchKey::ItalicFont:
          return axObject-&gt;hasItalicFont();
  
      case AccessibilitySearchKey::Landmark:
          return axObject-&gt;isLandmark();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,10 ***</span>
<span class="line-new-header">--- 337,11 ---</span>
      case AccessibilityRole::LandmarkMain:
      case AccessibilityRole::LandmarkSearch:
      case AccessibilityRole::Menu:
      case AccessibilityRole::MenuBar:
      case AccessibilityRole::ProgressIndicator:
<span class="line-added">+     case AccessibilityRole::Meter:</span>
      case AccessibilityRole::RadioGroup:
      case AccessibilityRole::ScrollBar:
      case AccessibilityRole::Slider:
      case AccessibilityRole::SpinButton:
      case AccessibilityRole::Splitter:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 404,20 ***</span>
      return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
  }
  
  bool AccessibilityObject::isLandmark() const
  {
<span class="line-modified">!     AccessibilityRole role = roleValue();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return role == AccessibilityRole::LandmarkBanner</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkComplementary</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkContentInfo</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkDocRegion</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkMain</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkNavigation</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkRegion</span>
<span class="line-modified">!         || role == AccessibilityRole::LandmarkSearch;</span>
  }
  
  bool AccessibilityObject::hasMisspelling() const
  {
      if (!node())
<span class="line-new-header">--- 412,23 ---</span>
      return (isARIATextControl() || hasContentEditableAttributeSet()) &amp;&amp; !isNativeTextControl();
  }
  
  bool AccessibilityObject::isLandmark() const
  {
<span class="line-modified">!     switch (roleValue()) {</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkBanner:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkComplementary:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkContentInfo:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkDocRegion:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkMain:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkNavigation:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkRegion:</span>
<span class="line-modified">!     case AccessibilityRole::LandmarkSearch:</span>
<span class="line-modified">!         return true;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
  }
  
  bool AccessibilityObject::hasMisspelling() const
  {
      if (!node())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,10 ***</span>
<span class="line-new-header">--- 491,43 ---</span>
              break;
      }
      return previous;
  }
  
<span class="line-added">+ FloatRect AccessibilityObject::convertFrameToSpace(const FloatRect&amp; frameRect, AccessibilityConversionSpace conversionSpace) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Find the appropriate scroll view to use to convert the contents to the window.</span>
<span class="line-added">+     const auto parentAccessibilityScrollView = ancestorAccessibilityScrollView(false /* includeSelf */);</span>
<span class="line-added">+     auto* parentScrollView = parentAccessibilityScrollView ? parentAccessibilityScrollView-&gt;scrollView() : nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto snappedFrameRect = snappedIntRect(IntRect(frameRect));</span>
<span class="line-added">+     if (parentScrollView)</span>
<span class="line-added">+         snappedFrameRect = parentScrollView-&gt;contentsToRootView(snappedFrameRect);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (conversionSpace == AccessibilityConversionSpace::Screen) {</span>
<span class="line-added">+         auto page = this-&gt;page();</span>
<span class="line-added">+         if (!page)</span>
<span class="line-added">+             return snappedFrameRect;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // If we have an empty chrome client (like SVG) then we should use the page</span>
<span class="line-added">+         // of the scroll view parent to help us get to the screen rect.</span>
<span class="line-added">+         if (parentAccessibilityScrollView &amp;&amp; page-&gt;chrome().client().isEmptyChromeClient())</span>
<span class="line-added">+             page = parentAccessibilityScrollView-&gt;page();</span>
<span class="line-added">+ </span>
<span class="line-added">+         snappedFrameRect = page-&gt;chrome().rootViewToAccessibilityScreen(snappedFrameRect);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return snappedFrameRect;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FloatRect AccessibilityObject::relativeFrame() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return convertFrameToSpace(elementRect(), AccessibilityConversionSpace::Page);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  AccessibilityObject* AccessibilityObject::nextSiblingUnignored(int limit) const
  {
      AccessibilityObject* next;
      ASSERT(limit &gt;= 0);
      for (next = nextSibling(); next &amp;&amp; next-&gt;accessibilityIsIgnored(); next = next-&gt;nextSibling()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,20 ***</span>
      }
      return next;
  }
  
  AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
  {
      if (!node)
          return nullptr;
  
      AXObjectCache* cache = node-&gt;document().axObjectCache();
      if (!cache)
          return nullptr;
  
      AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
<span class="line-modified">!     while (accessibleObject &amp;&amp; accessibleObject-&gt;accessibilityIsIgnored()) {</span>
          node = NodeTraversal::next(*node);
  
          while (node &amp;&amp; !node-&gt;renderer())
              node = NodeTraversal::nextSkippingChildren(*node);
  
<span class="line-new-header">--- 537,27 ---</span>
      }
      return next;
  }
  
  AccessibilityObject* AccessibilityObject::firstAccessibleObjectFromNode(const Node* node)
<span class="line-added">+ {</span>
<span class="line-added">+     return WebCore::firstAccessibleObjectFromNode(node, [] (const AccessibilityObject&amp; accessible) {</span>
<span class="line-added">+         return !accessible.accessibilityIsIgnored();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ AccessibilityObject* firstAccessibleObjectFromNode(const Node* node, const WTF::Function&lt;bool(const AccessibilityObject&amp;)&gt;&amp; isAccessible)</span>
  {
      if (!node)
          return nullptr;
  
      AXObjectCache* cache = node-&gt;document().axObjectCache();
      if (!cache)
          return nullptr;
  
      AccessibilityObject* accessibleObject = cache-&gt;getOrCreate(node-&gt;renderer());
<span class="line-modified">!     while (accessibleObject &amp;&amp; !isAccessible(*accessibleObject)) {</span>
          node = NodeTraversal::next(*node);
  
          while (node &amp;&amp; !node-&gt;renderer())
              node = NodeTraversal::nextSkippingChildren(*node);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,24 ***</span>
  }
  
  // Returns the range that is fewer positions away from the reference range.
  // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
  // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<span class="line-modified">! static RefPtr&lt;Range&gt; rangeClosestToRange(Range* referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)</span>
  {
      if (!referenceRange)
          return nullptr;
  
      // The treeScope for shadow nodes may not be the same scope as another element in a document.
      // Comparisons may fail in that case, which are expected behavior and should not assert.
      if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
          return nullptr;
<span class="line-modified">!     ASSERT(!afterRange || afterRange-&gt;startPosition() &gt;= referenceRange-&gt;endPosition());</span>
  
      if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
          return nullptr;
<span class="line-modified">!     ASSERT(!beforeRange || beforeRange-&gt;endPosition() &lt;= referenceRange-&gt;startPosition());</span>
  
      if (!afterRange &amp;&amp; !beforeRange)
          return nullptr;
      if (afterRange &amp;&amp; !beforeRange)
          return WTFMove(afterRange);
<span class="line-new-header">--- 762,24 ---</span>
  }
  
  // Returns the range that is fewer positions away from the reference range.
  // NOTE: The after range is expected to ACTUALLY be after the reference range and the before
  // range is expected to ACTUALLY be before. These are not checked for performance reasons.
<span class="line-modified">! static RefPtr&lt;Range&gt; rangeClosestToRange(RefPtr&lt;Range&gt; const&amp; referenceRange, RefPtr&lt;Range&gt;&amp;&amp; afterRange, RefPtr&lt;Range&gt;&amp;&amp; beforeRange)</span>
  {
      if (!referenceRange)
          return nullptr;
  
      // The treeScope for shadow nodes may not be the same scope as another element in a document.
      // Comparisons may fail in that case, which are expected behavior and should not assert.
      if (afterRange &amp;&amp; (referenceRange-&gt;endPosition().isNull() || ((afterRange-&gt;startPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;endPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
          return nullptr;
<span class="line-modified">!     ASSERT(!afterRange || afterRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &gt;= 0);</span>
  
      if (beforeRange &amp;&amp; (referenceRange-&gt;startPosition().isNull() || ((beforeRange-&gt;endPosition().anchorNode()-&gt;compareDocumentPosition(*referenceRange-&gt;startPosition().anchorNode()) &amp; Node::DOCUMENT_POSITION_DISCONNECTED) == Node::DOCUMENT_POSITION_DISCONNECTED)))
          return nullptr;
<span class="line-modified">!     ASSERT(!beforeRange || beforeRange-&gt;compareBoundaryPoints(Range::START_TO_START, *referenceRange).releaseReturnValue() &lt;= 0);</span>
  
      if (!afterRange &amp;&amp; !beforeRange)
          return nullptr;
      if (afterRange &amp;&amp; !beforeRange)
          return WTFMove(afterRange);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 739,11 ***</span>
      unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
  
      return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
  }
  
<span class="line-modified">! RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt;&amp; searchStrings) const</span>
  {
      Frame* frame = this-&gt;frame();
      if (!frame)
          return nullptr;
  
<span class="line-new-header">--- 790,11 ---</span>
      unsigned positionsToBeforeRange = Position::positionCountBetweenPositions(beforeRange-&gt;endPosition(), referenceRange-&gt;startPosition());
  
      return positionsToAfterRange &lt; positionsToBeforeRange ? afterRange : beforeRange;
  }
  
<span class="line-modified">! RefPtr&lt;Range&gt; AccessibilityObject::rangeOfStringClosestToRangeInDirection(Range* referenceRange, AccessibilitySearchDirection searchDirection, Vector&lt;String&gt; const&amp; searchStrings) const</span>
  {
      Frame* frame = this-&gt;frame();
      if (!frame)
          return nullptr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 751,11 ***</span>
          return nullptr;
  
      bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
      FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
      if (isBackwardSearch)
<span class="line-modified">!         findOptions.add(Backwards);</span>
  
      RefPtr&lt;Range&gt; closestStringRange = nullptr;
      for (const auto&amp; searchString : searchStrings) {
          if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
              if (!closestStringRange)
<span class="line-new-header">--- 802,11 ---</span>
          return nullptr;
  
      bool isBackwardSearch = searchDirection == AccessibilitySearchDirection::Previous;
      FindOptions findOptions { AtWordStarts, AtWordEnds, CaseInsensitive, StartInSelection };
      if (isBackwardSearch)
<span class="line-modified">!         findOptions.add(FindOptionFlag::Backwards);</span>
  
      RefPtr&lt;Range&gt; closestStringRange = nullptr;
      for (const auto&amp; searchString : searchStrings) {
          if (RefPtr&lt;Range&gt; searchStringRange = frame-&gt;editor().rangeOfString(searchString, referenceRange, findOptions)) {
              if (!closestStringRange)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,91 ***</span>
  RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
  {
      return AXObjectCache::rangeForNodeContents(node());
  }
  
<span class="line-modified">! String AccessibilityObject::selectText(AccessibilitySelectTextCriteria* criteria)</span>
  {
<span class="line-modified">!     ASSERT(criteria);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!criteria)</span>
<span class="line-modified">!         return String();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Frame* frame = this-&gt;frame();</span>
<span class="line-modified">!     if (!frame)</span>
<span class="line-modified">!         return String();</span>
  
<span class="line-modified">!     AccessibilitySelectTextActivity&amp; activity = criteria-&gt;activity;</span>
<span class="line-removed">-     AccessibilitySelectTextAmbiguityResolution&amp; ambiguityResolution = criteria-&gt;ambiguityResolution;</span>
<span class="line-removed">-     String&amp; replacementString = criteria-&gt;replacementString;</span>
<span class="line-removed">-     Vector&lt;String&gt;&amp; searchStrings = criteria-&gt;searchStrings;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;Range&gt; selectedStringRange = selectionRange();</span>
<span class="line-removed">-     // When starting our search again, make this a zero length range so that search forwards will find this selected range if its appropriate.</span>
<span class="line-removed">-     selectedStringRange-&gt;setEnd(selectedStringRange-&gt;startContainer(), selectedStringRange-&gt;startOffset());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;Range&gt; closestAfterStringRange = nullptr;</span>
<span class="line-removed">-     RefPtr&lt;Range&gt; closestBeforeStringRange = nullptr;</span>
<span class="line-removed">-     // Search forward if necessary.</span>
<span class="line-removed">-     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestAfter || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)</span>
<span class="line-removed">-         closestAfterStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-removed">-     // Search backward if necessary.</span>
<span class="line-removed">-     if (ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestBefore || ambiguityResolution == AccessibilitySelectTextAmbiguityResolution::ClosestTo)</span>
<span class="line-removed">-         closestBeforeStringRange = rangeOfStringClosestToRangeInDirection(selectedStringRange.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Determine which candidate is closest to the selection and perform the activity.</span>
<span class="line-removed">-     if (RefPtr&lt;Range&gt; closestStringRange = rangeClosestToRange(selectedStringRange.get(), WTFMove(closestAfterStringRange), WTFMove(closestBeforeStringRange))) {</span>
          // If the search started within a text control, ensure that the result is inside that element.
          if (element() &amp;&amp; element()-&gt;isTextField()) {
<span class="line-modified">!             if (!closestStringRange-&gt;startContainer().isDescendantOrShadowDescendantOf(element()) || !closestStringRange-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))</span>
<span class="line-modified">!                 return String();</span>
          }
  
<span class="line-modified">!         String closestString = closestStringRange-&gt;text();</span>
<span class="line-modified">!         bool replaceSelection = false;</span>
<span class="line-modified">!         if (frame-&gt;selection().setSelectedRange(closestStringRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes)) {</span>
<span class="line-removed">-             switch (activity) {</span>
<span class="line-removed">-             case AccessibilitySelectTextActivity::FindAndCapitalize:</span>
<span class="line-removed">-                 replacementString = capitalize(closestString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-removed">-                 replaceSelection = true;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case AccessibilitySelectTextActivity::FindAndUppercase:</span>
<span class="line-removed">-                 replacementString = closestString.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed">-                 replaceSelection = true;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case AccessibilitySelectTextActivity::FindAndLowercase:</span>
<span class="line-removed">-                 replacementString = closestString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed">-                 replaceSelection = true;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case AccessibilitySelectTextActivity::FindAndReplace: {</span>
<span class="line-removed">-                 replaceSelection = true;</span>
<span class="line-removed">-                 // When applying find and replace activities, we want to match the capitalization of the replaced text,</span>
<span class="line-removed">-                 // (unless we&#39;re replacing with an abbreviation.)</span>
<span class="line-removed">-                 if (closestString.length() &gt; 0 &amp;&amp; replacementString.length() &gt; 2 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {</span>
<span class="line-removed">-                     if (closestString[0] == u_toupper(closestString[0]))</span>
<span class="line-removed">-                         replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             case AccessibilitySelectTextActivity::FindAndSelect:</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // A bit obvious, but worth noting the API contract for this method is that we should</span>
<span class="line-modified">!             // return the replacement string when replacing, but the selected string if not.</span>
<span class="line-modified">!             if (replaceSelection) {</span>
<span class="line-modified">!                 frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);</span>
<span class="line-modified">!                 return replacementString;</span>
              }
  
<span class="line-modified">!             return closestString;</span>
          }
      }
  
<span class="line-modified">!     return String();</span>
  }
  
  bool AccessibilityObject::hasAttributesRequiredForInclusion() const
  {
      // These checks are simplified in the interest of execution speed.
<span class="line-new-header">--- 848,141 ---</span>
  RefPtr&lt;Range&gt; AccessibilityObject::elementRange() const
  {
      return AXObjectCache::rangeForNodeContents(node());
  }
  
<span class="line-modified">! RefPtr&lt;Range&gt; AccessibilityObject::findTextRange(Vector&lt;String&gt; const&amp; searchStrings, RefPtr&lt;Range&gt; const&amp; start, AccessibilitySearchTextDirection direction) const</span>
  {
<span class="line-modified">!     RefPtr&lt;Range&gt; found;</span>
<span class="line-modified">!     if (direction == AccessibilitySearchTextDirection::Forward)</span>
<span class="line-modified">!         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified">!     else if (direction == AccessibilitySearchTextDirection::Backward)</span>
<span class="line-modified">!         found = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-modified">!     else if (direction == AccessibilitySearchTextDirection::Closest) {</span>
<span class="line-modified">!         auto foundAfter = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Next, searchStrings);</span>
<span class="line-modified">!         auto foundBefore = rangeOfStringClosestToRangeInDirection(start.get(), AccessibilitySearchDirection::Previous, searchStrings);</span>
<span class="line-added">+         found = rangeClosestToRange(start.get(), WTFMove(foundAfter), WTFMove(foundBefore));</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (found) {</span>
          // If the search started within a text control, ensure that the result is inside that element.
          if (element() &amp;&amp; element()-&gt;isTextField()) {
<span class="line-modified">!             if (!found-&gt;startContainer().isDescendantOrShadowDescendantOf(element())</span>
<span class="line-modified">!                 || !found-&gt;endContainer().isDescendantOrShadowDescendantOf(element()))</span>
<span class="line-added">+                 return nullptr;</span>
          }
<span class="line-added">+     }</span>
<span class="line-added">+     return found;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! Vector&lt;RefPtr&lt;Range&gt;&gt; AccessibilityObject::findTextRanges(AccessibilitySearchTextCriteria const&amp; criteria) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     Vector&lt;RefPtr&lt;Range&gt;&gt; result;</span>
  
<span class="line-modified">!     // Determine start range.</span>
<span class="line-modified">!     RefPtr&lt;Range&gt; startRange;</span>
<span class="line-modified">!     if (criteria.start == AccessibilitySearchTextStartFrom::Selection)</span>
<span class="line-modified">!         startRange = selectionRange();</span>
<span class="line-modified">!     else</span>
<span class="line-added">+         startRange = elementRange();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (startRange) {</span>
<span class="line-added">+         // Collapse the range to the start unless searching from the end of the doc or searching backwards.</span>
<span class="line-added">+         if (criteria.start == AccessibilitySearchTextStartFrom::Begin)</span>
<span class="line-added">+             startRange-&gt;collapse(true);</span>
<span class="line-added">+         else if (criteria.start == AccessibilitySearchTextStartFrom::End)</span>
<span class="line-added">+             startRange-&gt;collapse(false);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             startRange-&gt;collapse(criteria.direction != AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;Range&gt; found;</span>
<span class="line-added">+     switch (criteria.direction) {</span>
<span class="line-added">+     case AccessibilitySearchTextDirection::Forward:</span>
<span class="line-added">+     case AccessibilitySearchTextDirection::Backward:</span>
<span class="line-added">+     case AccessibilitySearchTextDirection::Closest:</span>
<span class="line-added">+         found = findTextRange(criteria.searchStrings, startRange, criteria.direction);</span>
<span class="line-added">+         if (found)</span>
<span class="line-added">+             result.append(found);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case AccessibilitySearchTextDirection::All: {</span>
<span class="line-added">+         auto findAll = [&amp;](AccessibilitySearchTextDirection dir) {</span>
<span class="line-added">+             found = findTextRange(criteria.searchStrings, startRange, dir);</span>
<span class="line-added">+             while (found) {</span>
<span class="line-added">+                 result.append(found);</span>
<span class="line-added">+                 found = findTextRange(criteria.searchStrings, found, dir);</span>
              }
<span class="line-added">+         };</span>
<span class="line-added">+         findAll(AccessibilitySearchTextDirection::Forward);</span>
<span class="line-added">+         findAll(AccessibilitySearchTextDirection::Backward);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Vector&lt;String&gt; AccessibilityObject::performTextOperation(AccessibilityTextOperation const&amp; operation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;String&gt; result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (operation.textRanges.isEmpty())</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Frame* frame = this-&gt;frame();</span>
<span class="line-added">+     if (!frame)</span>
<span class="line-added">+         return result;</span>
  
<span class="line-modified">!     for (auto textRange : operation.textRanges) {</span>
<span class="line-added">+         if (!frame-&gt;selection().setSelectedRange(textRange.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         String text = textRange-&gt;text();</span>
<span class="line-added">+         String replacementString = operation.replacementText;</span>
<span class="line-added">+         bool replaceSelection = false;</span>
<span class="line-added">+         switch (operation.type) {</span>
<span class="line-added">+         case AccessibilityTextOperationType::Capitalize:</span>
<span class="line-added">+             replacementString = capitalize(text, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added">+             replaceSelection = true;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case AccessibilityTextOperationType::Uppercase:</span>
<span class="line-added">+             replacementString = text.convertToUppercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added">+             replaceSelection = true;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case AccessibilityTextOperationType::Lowercase:</span>
<span class="line-added">+             replacementString = text.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added">+             replaceSelection = true;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case AccessibilityTextOperationType::Replace: {</span>
<span class="line-added">+             replaceSelection = true;</span>
<span class="line-added">+             // When applying find and replace activities, we want to match the capitalization of the replaced text,</span>
<span class="line-added">+             // (unless we&#39;re replacing with an abbreviation.)</span>
<span class="line-added">+             if (text.length() &gt; 0</span>
<span class="line-added">+                 &amp;&amp; replacementString.length() &gt; 2</span>
<span class="line-added">+                 &amp;&amp; replacementString != replacementString.convertToUppercaseWithoutLocale()) {</span>
<span class="line-added">+                 if (text[0] == u_toupper(text[0]))</span>
<span class="line-added">+                     replacementString = capitalize(replacementString, &#39; &#39;); // FIXME: Needs to take locale into account to work correctly.</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     replacementString = replacementString.convertToLowercaseWithoutLocale(); // FIXME: Needs locale to work correctly.</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
          }
<span class="line-added">+         case AccessibilityTextOperationType::Select:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // A bit obvious, but worth noting the API contract for this method is that we should</span>
<span class="line-added">+         // return the replacement string when replacing, but the selected string if not.</span>
<span class="line-added">+         if (replaceSelection) {</span>
<span class="line-added">+             frame-&gt;editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::Yes, Editor::SmartReplace::Yes);</span>
<span class="line-added">+             result.append(replacementString);</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             result.append(text);</span>
      }
  
<span class="line-modified">!     return result;</span>
  }
  
  bool AccessibilityObject::hasAttributesRequiredForInclusion() const
  {
      // These checks are simplified in the interest of execution speed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,10 ***</span>
<span class="line-new-header">--- 1011,11 ---</span>
  }
  
  bool AccessibilityObject::isRangeControl() const
  {
      switch (roleValue()) {
<span class="line-added">+     case AccessibilityRole::Meter:</span>
      case AccessibilityRole::ProgressIndicator:
      case AccessibilityRole::Slider:
      case AccessibilityRole::ScrollBar:
      case AccessibilityRole::SpinButton:
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,10 ***</span>
<span class="line-new-header">--- 1026,13 ---</span>
      }
  }
  
  bool AccessibilityObject::isMeter() const
  {
<span class="line-added">+     if (ariaRoleAttribute() == AccessibilityRole::Meter)</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
  #if ENABLE(METER_ELEMENT)
      RenderObject* renderer = this-&gt;renderer();
      return renderer &amp;&amp; renderer-&gt;isMeter();
  #else
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,18 ***</span>
      ASSERT(pressElement);
      // Prefer the hit test element, if it is inside the target element.
      if (hitTestElement &amp;&amp; hitTestElement-&gt;isDescendantOf(*pressElement))
          pressElement = hitTestElement;
  
<span class="line-removed">-     // dispatch accessibleclick event</span>
<span class="line-removed">-     if (auto* cache = axObjectCache()) {</span>
<span class="line-removed">-         if (auto* pressObject = cache-&gt;getOrCreate(pressElement)) {</span>
<span class="line-removed">-             if (pressObject-&gt;dispatchAccessibilityEventWithType(AccessibilityEventType::Click))</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      UserGestureIndicator gestureIndicator(ProcessingUserGesture, document);
  
      bool dispatchedTouchEvent = false;
  #if PLATFORM(IOS_FAMILY)
      if (hasTouchEventListener())
<span class="line-new-header">--- 1098,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,14 ***</span>
  }
  
  Frame* AccessibilityObject::frame() const
  {
      Node* node = this-&gt;node();
<span class="line-modified">!     if (!node)</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return node-&gt;document().frame();</span>
  }
  
  Frame* AccessibilityObject::mainFrame() const
  {
      Document* document = topDocument();
<span class="line-new-header">--- 1123,11 ---</span>
  }
  
  Frame* AccessibilityObject::frame() const
  {
      Node* node = this-&gt;node();
<span class="line-modified">!     return node ? node-&gt;document().frame() : nullptr;</span>
  }
  
  Frame* AccessibilityObject::mainFrame() const
  {
      Document* document = topDocument();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1054,11 ***</span>
      return &amp;document()-&gt;topDocument();
  }
  
  String AccessibilityObject::language() const
  {
<span class="line-modified">!     const AtomicString&amp; lang = getAttribute(langAttr);</span>
      if (!lang.isEmpty())
          return lang;
  
      AccessibilityObject* parent = parentObject();
  
<span class="line-new-header">--- 1148,11 ---</span>
      return &amp;document()-&gt;topDocument();
  }
  
  String AccessibilityObject::language() const
  {
<span class="line-modified">!     const AtomString&amp; lang = getAttribute(langAttr);</span>
      if (!lang.isEmpty())
          return lang;
  
      AccessibilityObject* parent = parentObject();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1680,11 ***</span>
      return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
  }
  
  String AccessibilityObject::autoCompleteValue() const
  {
<span class="line-modified">!     const AtomicString&amp; autoComplete = getAttribute(aria_autocompleteAttr);</span>
      if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
          || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
          || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
          return autoComplete;
  
<span class="line-new-header">--- 1774,11 ---</span>
      return (isComboBox() || isARIATextControl()) &amp;&amp; hasAttribute(aria_autocompleteAttr);
  }
  
  String AccessibilityObject::autoCompleteValue() const
  {
<span class="line-modified">!     const AtomString&amp; autoComplete = getAttribute(aria_autocompleteAttr);</span>
      if (equalLettersIgnoringASCIICase(autoComplete, &quot;inline&quot;)
          || equalLettersIgnoringASCIICase(autoComplete, &quot;list&quot;)
          || equalLettersIgnoringASCIICase(autoComplete, &quot;both&quot;))
          return autoComplete;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1694,19 ***</span>
  bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
  {
      if (!element)
          return false;
  
<span class="line-modified">!     const AtomicString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);</span>
      if (contentEditableValue.isNull())
          return false;
  
      // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
      return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
  }
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
  int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
  {
      if (visiblePos.isNull() || !node())
          return -1;
  
<span class="line-new-header">--- 1788,19 ---</span>
  bool AccessibilityObject::contentEditableAttributeIsEnabled(Element* element)
  {
      if (!element)
          return false;
  
<span class="line-modified">!     const AtomString&amp; contentEditableValue = element-&gt;attributeWithoutSynchronization(contenteditableAttr);</span>
      if (contentEditableValue.isNull())
          return false;
  
      // Both &quot;true&quot; (case-insensitive) and the empty string count as true.
      return contentEditableValue.isEmpty() || equalLettersIgnoringASCIICase(contentEditableValue, &quot;true&quot;);
  }
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
  int AccessibilityObject::lineForPosition(const VisiblePosition&amp; visiblePos) const
  {
      if (visiblePos.isNull() || !node())
          return -1;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,11 ***</span>
  unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
  {
      return lineForPosition(visiblePositionForIndex(index, false));
  }
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
  void AccessibilityObject::updateBackingStore()
  {
      if (!axObjectCache())
          return;
  
<span class="line-new-header">--- 1866,11 ---</span>
  unsigned AccessibilityObject::doAXLineForIndex(unsigned index)
  {
      return lineForPosition(visiblePositionForIndex(index, false));
  }
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
  void AccessibilityObject::updateBackingStore()
  {
      if (!axObjectCache())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1792,16 ***</span>
  
      updateChildrenIfNecessary();
  }
  #endif
  
<span class="line-modified">! ScrollView* AccessibilityObject::scrollViewAncestor() const</span>
  {
<span class="line-modified">!     if (const AccessibilityObject* scrollParent = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
          return is&lt;AccessibilityScrollView&gt;(object);
<span class="line-modified">!     }))</span>
<span class="line-modified">!         return downcast&lt;AccessibilityScrollView&gt;(*scrollParent).scrollView();</span>
  
      return nullptr;
  }
  
  Document* AccessibilityObject::document() const
<span class="line-new-header">--- 1886,21 ---</span>
  
      updateChildrenIfNecessary();
  }
  #endif
  
<span class="line-modified">! const AccessibilityScrollView* AccessibilityObject::ancestorAccessibilityScrollView(bool includeSelf) const</span>
  {
<span class="line-modified">!     return downcast&lt;AccessibilityScrollView&gt;(AccessibilityObject::matchedParent(*this, includeSelf, [] (const auto&amp; object) {</span>
          return is&lt;AccessibilityScrollView&gt;(object);
<span class="line-modified">!     }));</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ ScrollView* AccessibilityObject::scrollViewAncestor() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto parentScrollView = ancestorAccessibilityScrollView(true/* includeSelf */))</span>
<span class="line-added">+         return parentScrollView-&gt;scrollView();</span>
  
      return nullptr;
  }
  
  Document* AccessibilityObject::document() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,11 ***</span>
          return nullptr;
  
      return object-&gt;documentFrameView();
  }
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
  const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
  {
      if (updateChildrenIfNeeded)
          updateChildrenIfNecessary();
  
<span class="line-new-header">--- 1930,11 ---</span>
          return nullptr;
  
      return object-&gt;documentFrameView();
  }
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
  const AccessibilityObject::AccessibilityChildrenVector&amp; AccessibilityObject::children(bool updateChildrenIfNeeded)
  {
      if (updateChildrenIfNeeded)
          updateChildrenIfNecessary();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1844,14 ***</span>
  #endif
  
  void AccessibilityObject::updateChildrenIfNecessary()
  {
      if (!hasChildren()) {
<span class="line-removed">- #if HAVE(ACCESSIBILITY)</span>
          // Enable the cache in case we end up adding a lot of children, we don&#39;t want to recompute axIsIgnored each time.
          AXAttributeCacheEnabler enableCache(axObjectCache());
<span class="line-removed">- #endif</span>
          addChildren();
      }
  }
  
  void AccessibilityObject::clearChildren()
<span class="line-new-header">--- 1943,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1956,11 ***</span>
      default:
          return nullAtom();
      }
  }
  
<span class="line-modified">! #if HAVE(ACCESSIBILITY)</span>
  const String&amp; AccessibilityObject::actionVerb() const
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
<span class="line-new-header">--- 2053,11 ---</span>
      default:
          return nullAtom();
      }
  }
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY)</span>
  const String&amp; AccessibilityObject::actionVerb() const
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2150,90 ***</span>
          return false;
  
      return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
  }
  
<span class="line-modified">! const AtomicString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const</span>
  {
      if (auto* element = this-&gt;element())
          return element-&gt;attributeWithoutSynchronization(attribute);
      return nullAtom();
  }
  
<span class="line-modified">! bool AccessibilityObject::shouldDispatchAccessibilityEvent() const</span>
  {
<span class="line-modified">!     bool shouldDispatch = RuntimeEnabledFeatures::sharedFeatures().accessibilityObjectModelEnabled();</span>
<span class="line-removed">- #if ENABLE(ACCESSIBILITY_EVENTS)</span>
<span class="line-removed">-     return shouldDispatch &amp;= this-&gt;page()-&gt;settings().accessibilityEventsEnabled();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     return shouldDispatch;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool AccessibilityObject::dispatchAccessibilityEvent(Event&amp; event) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!shouldDispatchAccessibilityEvent())</span>
          return false;
  
<span class="line-modified">!     Vector&lt;Element*&gt; eventPath;</span>
<span class="line-removed">-     for (auto* parentObject = this; parentObject; parentObject = parentObject-&gt;parentObject()) {</span>
<span class="line-removed">-         if (parentObject-&gt;isWebArea())</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         if (auto* parentElement = parentObject-&gt;element())</span>
<span class="line-removed">-             eventPath.append(parentElement);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (!eventPath.size())</span>
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     EventDispatcher::dispatchEvent(eventPath, event);</span>
  
<span class="line-modified">!     // return true if preventDefault() was called, so that we don&#39;t execute the fallback behavior.</span>
<span class="line-removed">-     return event.defaultPrevented();</span>
  }
  
<span class="line-modified">! bool AccessibilityObject::dispatchAccessibilityEventWithType(AccessibilityEventType type) const</span>
  {
<span class="line-modified">!     AtomicString eventName;</span>
<span class="line-removed">-     switch (type) {</span>
<span class="line-removed">-     case AccessibilityEventType::ContextMenu:</span>
<span class="line-removed">-         eventName = eventNames().accessiblecontextmenuEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Click:</span>
<span class="line-removed">-         eventName = eventNames().accessibleclickEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Decrement:</span>
<span class="line-removed">-         eventName = eventNames().accessibledecrementEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Dismiss:</span>
<span class="line-removed">-         eventName = eventNames().accessibledismissEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Focus:</span>
<span class="line-removed">-         eventName = eventNames().accessiblefocusEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Increment:</span>
<span class="line-removed">-         eventName = eventNames().accessibleincrementEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::ScrollIntoView:</span>
<span class="line-removed">-         eventName = eventNames().accessiblescrollintoviewEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case AccessibilityEventType::Select:</span>
<span class="line-removed">-         eventName = eventNames().accessibleselectEvent;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
          return false;
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     auto event = Event::create(eventName, Event::CanBubble::Yes, Event::IsCancelable::Yes);</span>
<span class="line-removed">-     return dispatchAccessibilityEvent(event);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool AccessibilityObject::dispatchAccessibleSetValueEvent(const String&amp; value) const</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     if (!canSetValueAttribute())</span>
          return false;
<span class="line-modified">!     auto event = AccessibleSetValueEvent::create(eventNames().accessiblesetvalueEvent, value);</span>
<span class="line-modified">!     return dispatchAccessibilityEvent(event);</span>
  }
  
  // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
  AccessibilityOrientation AccessibilityObject::orientation() const
  {
<span class="line-new-header">--- 2247,59 ---</span>
          return false;
  
      return downcast&lt;Element&gt;(*node).hasAttributeWithoutSynchronization(attribute);
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::getAttribute(const QualifiedName&amp; attribute) const</span>
  {
      if (auto* element = this-&gt;element())
          return element-&gt;attributeWithoutSynchronization(attribute);
      return nullAtom();
  }
  
<span class="line-modified">! bool AccessibilityObject::replaceTextInRange(const String&amp; replacementString, const PlainTextRange&amp; range)</span>
  {
<span class="line-modified">!     if (!renderer() || !is&lt;Element&gt;(node()))</span>
          return false;
  
<span class="line-modified">!     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>
  
<span class="line-modified">!     // We should use the editor&#39;s insertText to mimic typing into the field.</span>
<span class="line-modified">!     // Also only do this when the field is in editing mode.</span>
<span class="line-added">+     auto&amp; frame = renderer()-&gt;frame();</span>
<span class="line-added">+     if (element.shouldUseInputMethod()) {</span>
<span class="line-added">+         frame.selection().setSelectedRange(rangeForPlainTextRange(range).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);</span>
<span class="line-added">+         frame.editor().replaceSelectionWithText(replacementString, Editor::SelectReplacement::No, Editor::SmartReplace::No);</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (is&lt;HTMLInputElement&gt;(element)) {</span>
<span class="line-added">+         downcast&lt;HTMLInputElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (is&lt;HTMLTextAreaElement&gt;(element)) {</span>
<span class="line-added">+         downcast&lt;HTMLTextAreaElement&gt;(element).setRangeText(replacementString, range.start, range.length, &quot;&quot;);</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return false;</span>
  }
  
<span class="line-modified">! bool AccessibilityObject::insertText(const String&amp; text)</span>
  {
<span class="line-modified">!     if (!renderer() || !is&lt;Element&gt;(node()))</span>
          return false;
  
<span class="line-modified">!     auto&amp; element = downcast&lt;Element&gt;(*renderer()-&gt;node());</span>
  
<span class="line-modified">!     // Only try to insert text if the field is in editing mode.</span>
<span class="line-modified">!     if (!element.shouldUseInputMethod())</span>
          return false;
<span class="line-modified">! </span>
<span class="line-modified">!     // Use Editor::insertText to mimic typing into the field.</span>
<span class="line-added">+     auto&amp; editor = renderer()-&gt;frame().editor();</span>
<span class="line-added">+     return editor.insertText(text, nullptr);</span>
  }
  
  // Lacking concrete evidence of orientation, horizontal means width &gt; height. vertical is height &gt; width;
  AccessibilityOrientation AccessibilityObject::orientation() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2300,10 ***</span>
<span class="line-new-header">--- 2366,11 ---</span>
          { &quot;button&quot;, AccessibilityRole::Button },
          { &quot;caption&quot;, AccessibilityRole::Caption },
          { &quot;checkbox&quot;, AccessibilityRole::CheckBox },
          { &quot;complementary&quot;, AccessibilityRole::LandmarkComplementary },
          { &quot;contentinfo&quot;, AccessibilityRole::LandmarkContentInfo },
<span class="line-added">+         { &quot;deletion&quot;, AccessibilityRole::Deletion },</span>
          { &quot;dialog&quot;, AccessibilityRole::ApplicationDialog },
          { &quot;directory&quot;, AccessibilityRole::Directory },
          // The &#39;doc-*&#39; roles are defined the ARIA DPUB mobile: https://www.w3.org/TR/dpub-aam-1.0/
          // Editor&#39;s draft is currently at https://rawgit.com/w3c/aria/master/dpub-aam/dpub-aam.html
          { &quot;doc-abstract&quot;, AccessibilityRole::ApplicationTextGroup },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2362,10 ***</span>
<span class="line-new-header">--- 2429,11 ---</span>
          { &quot;form&quot;, AccessibilityRole::Form },
          { &quot;rowheader&quot;, AccessibilityRole::RowHeader },
          { &quot;group&quot;, AccessibilityRole::ApplicationGroup },
          { &quot;heading&quot;, AccessibilityRole::Heading },
          { &quot;img&quot;, AccessibilityRole::Image },
<span class="line-added">+         { &quot;insertion&quot;, AccessibilityRole::Insertion },</span>
          { &quot;link&quot;, AccessibilityRole::WebCoreLink },
          { &quot;list&quot;, AccessibilityRole::List },
          { &quot;listitem&quot;, AccessibilityRole::ListItem },
          { &quot;listbox&quot;, AccessibilityRole::ListBox },
          { &quot;log&quot;, AccessibilityRole::ApplicationLog },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2375,10 ***</span>
<span class="line-new-header">--- 2443,11 ---</span>
          { &quot;menu&quot;, AccessibilityRole::Menu },
          { &quot;menubar&quot;, AccessibilityRole::MenuBar },
          { &quot;menuitem&quot;, AccessibilityRole::MenuItem },
          { &quot;menuitemcheckbox&quot;, AccessibilityRole::MenuItemCheckbox },
          { &quot;menuitemradio&quot;, AccessibilityRole::MenuItemRadio },
<span class="line-added">+         { &quot;meter&quot;, AccessibilityRole::Meter },</span>
          { &quot;none&quot;, AccessibilityRole::Presentational },
          { &quot;note&quot;, AccessibilityRole::DocumentNote },
          { &quot;navigation&quot;, AccessibilityRole::LandmarkNavigation },
          { &quot;option&quot;, AccessibilityRole::ListBoxOption },
          { &quot;paragraph&quot;, AccessibilityRole::Paragraph },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2394,17 ***</span>
<span class="line-new-header">--- 2463,20 ---</span>
          { &quot;searchbox&quot;, AccessibilityRole::SearchField },
          { &quot;separator&quot;, AccessibilityRole::Splitter },
          { &quot;slider&quot;, AccessibilityRole::Slider },
          { &quot;spinbutton&quot;, AccessibilityRole::SpinButton },
          { &quot;status&quot;, AccessibilityRole::ApplicationStatus },
<span class="line-added">+         { &quot;subscript&quot;, AccessibilityRole::Subscript },</span>
<span class="line-added">+         { &quot;superscript&quot;, AccessibilityRole::Superscript },</span>
          { &quot;switch&quot;, AccessibilityRole::Switch },
          { &quot;tab&quot;, AccessibilityRole::Tab },
          { &quot;tablist&quot;, AccessibilityRole::TabList },
          { &quot;tabpanel&quot;, AccessibilityRole::TabPanel },
          { &quot;text&quot;, AccessibilityRole::StaticText },
          { &quot;textbox&quot;, AccessibilityRole::TextArea },
          { &quot;term&quot;, AccessibilityRole::Term },
<span class="line-added">+         { &quot;time&quot;, AccessibilityRole::Time },</span>
          { &quot;timer&quot;, AccessibilityRole::ApplicationTimer },
          { &quot;toolbar&quot;, AccessibilityRole::Toolbar },
          { &quot;tooltip&quot;, AccessibilityRole::UserInterfaceTooltip },
          { &quot;tree&quot;, AccessibilityRole::Tree },
          { &quot;treegrid&quot;, AccessibilityRole::TreeGrid },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2432,11 ***</span>
      return *gAriaReverseRoleMap;
  }
  
  AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
  {
<span class="line-modified">!     ASSERT(!value.isEmpty());</span>
      for (auto roleName : StringView(value).split(&#39; &#39;)) {
          AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
          if (static_cast&lt;int&gt;(role))
              return role;
      }
<span class="line-new-header">--- 2504,13 ---</span>
      return *gAriaReverseRoleMap;
  }
  
  AccessibilityRole AccessibilityObject::ariaRoleToWebCoreRole(const String&amp; value)
  {
<span class="line-modified">!     if (value.isNull() || value.isEmpty())</span>
<span class="line-added">+         return AccessibilityRole::Unknown;</span>
<span class="line-added">+ </span>
      for (auto roleName : StringView(value).split(&#39; &#39;)) {
          AccessibilityRole role = ariaRoleMap().get&lt;ASCIICaseInsensitiveStringViewHashTranslator&gt;(roleName);
          if (static_cast&lt;int&gt;(role))
              return role;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2446,10 ***</span>
<span class="line-new-header">--- 2520,13 ---</span>
  String AccessibilityObject::computedRoleString() const
  {
      // FIXME: Need a few special cases that aren&#39;t in the RoleMap: option, etc. http://webkit.org/b/128296
      AccessibilityRole role = roleValue();
  
<span class="line-added">+     if (role == AccessibilityRole::Image &amp;&amp; accessibilityIsIgnored())</span>
<span class="line-added">+         return reverseAriaRoleMap().get(static_cast&lt;int&gt;(AccessibilityRole::Presentational));</span>
<span class="line-added">+ </span>
      // We do not compute a role string for generic block elements with user-agent assigned roles.
      if (role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup)
          return &quot;&quot;;
  
      // We do compute a role string for block elements with author-provided roles.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,16 ***</span>
  bool AccessibilityObject::supportsDatetimeAttribute() const
  {
      return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
  }
  
<span class="line-modified">! const AtomicString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
  {
      return getAttribute(datetimeAttr);
  }
  
<span class="line-modified">! const AtomicString&amp; AccessibilityObject::linkRelValue() const</span>
  {
      return getAttribute(relAttr);
  }
  
  const String AccessibilityObject::keyShortcutsValue() const
<span class="line-new-header">--- 2606,16 ---</span>
  bool AccessibilityObject::supportsDatetimeAttribute() const
  {
      return hasTagName(insTag) || hasTagName(delTag) || hasTagName(timeTag);
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::datetimeAttributeValue() const</span>
  {
      return getAttribute(datetimeAttr);
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::linkRelValue() const</span>
  {
      return getAttribute(relAttr);
  }
  
  const String AccessibilityObject::keyShortcutsValue() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2586,15 ***</span>
      return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
  }
  
  const String AccessibilityObject::placeholderValue() const
  {
<span class="line-modified">!     const AtomicString&amp; placeholder = getAttribute(placeholderAttr);</span>
      if (!placeholder.isEmpty())
          return placeholder;
  
<span class="line-modified">!     const AtomicString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);</span>
      if (!ariaPlaceholder.isEmpty())
          return ariaPlaceholder;
  
      return nullAtom();
  }
<span class="line-new-header">--- 2663,15 ---</span>
      return downcast&lt;HTMLInputElement&gt;(*node).isAutoFilled();
  }
  
  const String AccessibilityObject::placeholderValue() const
  {
<span class="line-modified">!     const AtomString&amp; placeholder = getAttribute(placeholderAttr);</span>
      if (!placeholder.isEmpty())
          return placeholder;
  
<span class="line-modified">!     const AtomString&amp; ariaPlaceholder = getAttribute(aria_placeholderAttr);</span>
      if (!ariaPlaceholder.isEmpty())
          return ariaPlaceholder;
  
      return nullAtom();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2632,22 ***</span>
          || hasAttribute(aria_labelAttr)
          || hasAttribute(aria_labelledbyAttr)
          || hasAttribute(aria_relevantAttr);
  }
  
<span class="line-modified">! bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomicString&amp; liveRegionStatus)</span>
  {
      return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
  }
  
  bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
  {
<span class="line-modified">!     const AtomicString&amp; liveRegionStatusValue = liveRegionStatus();</span>
      return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
  }
  
<span class="line-modified">! AccessibilityObject* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      // Send the hit test back into the sub-frame if necessary.
      if (isAttachment()) {
          Widget* widget = widgetForAttachmentView();
          // Normalize the point for the widget&#39;s bounds.
<span class="line-new-header">--- 2709,22 ---</span>
          || hasAttribute(aria_labelAttr)
          || hasAttribute(aria_labelledbyAttr)
          || hasAttribute(aria_relevantAttr);
  }
  
<span class="line-modified">! bool AccessibilityObject::liveRegionStatusIsEnabled(const AtomString&amp; liveRegionStatus)</span>
  {
      return equalLettersIgnoringASCIICase(liveRegionStatus, &quot;polite&quot;) || equalLettersIgnoringASCIICase(liveRegionStatus, &quot;assertive&quot;);
  }
  
  bool AccessibilityObject::supportsLiveRegion(bool excludeIfOff) const
  {
<span class="line-modified">!     const AtomString&amp; liveRegionStatusValue = liveRegionStatus();</span>
      return excludeIfOff ? liveRegionStatusIsEnabled(liveRegionStatusValue) : !liveRegionStatusValue.isEmpty();
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      // Send the hit test back into the sub-frame if necessary.
      if (isAttachment()) {
          Widget* widget = widgetForAttachmentView();
          // Normalize the point for the widget&#39;s bounds.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2670,11 ***</span>
  {
      auto* document = this-&gt;document();
      return document ? document-&gt;axObjectCache() : nullptr;
  }
  
<span class="line-modified">! AccessibilityObject* AccessibilityObject::focusedUIElement() const</span>
  {
      auto* page = this-&gt;page();
      return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
  }
  
<span class="line-new-header">--- 2747,11 ---</span>
  {
      auto* document = this-&gt;document();
      return document ? document-&gt;axObjectCache() : nullptr;
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityObject::focusedUIElement() const</span>
  {
      auto* page = this-&gt;page();
      return page ? AXObjectCache::focusedUIElementForPage(page) : nullptr;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2682,11 ***</span>
  {
      AccessibilityRole role = roleValue();
      if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
          return AccessibilitySortDirection::Invalid;
  
<span class="line-modified">!     const AtomicString&amp; sortAttribute = getAttribute(aria_sortAttr);</span>
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
          return AccessibilitySortDirection::Ascending;
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
          return AccessibilitySortDirection::Descending;
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
<span class="line-new-header">--- 2759,11 ---</span>
  {
      AccessibilityRole role = roleValue();
      if (role != AccessibilityRole::RowHeader &amp;&amp; role != AccessibilityRole::ColumnHeader)
          return AccessibilitySortDirection::Invalid;
  
<span class="line-modified">!     const AtomString&amp; sortAttribute = getAttribute(aria_sortAttr);</span>
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;ascending&quot;))
          return AccessibilitySortDirection::Ascending;
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;descending&quot;))
          return AccessibilitySortDirection::Descending;
      if (equalLettersIgnoringASCIICase(sortAttribute, &quot;other&quot;))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2708,31 ***</span>
  bool AccessibilityObject::supportsHasPopup() const
  {
      return hasAttribute(aria_haspopupAttr) || isComboBox();
  }
  
<span class="line-modified">! String AccessibilityObject::hasPopupValue() const</span>
  {
<span class="line-modified">!     const AtomicString&amp; hasPopup = getAttribute(aria_haspopupAttr);</span>
<span class="line-modified">!     if (equalLettersIgnoringASCIICase(hasPopup, &quot;true&quot;)</span>
<span class="line-modified">!         || equalLettersIgnoringASCIICase(hasPopup, &quot;dialog&quot;)</span>
<span class="line-modified">!         || equalLettersIgnoringASCIICase(hasPopup, &quot;grid&quot;)</span>
<span class="line-modified">!         || equalLettersIgnoringASCIICase(hasPopup, &quot;listbox&quot;)</span>
<span class="line-modified">!         || equalLettersIgnoringASCIICase(hasPopup, &quot;menu&quot;)</span>
<span class="line-modified">!         || equalLettersIgnoringASCIICase(hasPopup, &quot;tree&quot;))</span>
          return hasPopup;
  
<span class="line-modified">!     // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;</span>
<span class="line-modified">!     if (isComboBox() &amp;&amp; hasPopup.isEmpty())</span>
<span class="line-modified">!         return &quot;listbox&quot;;</span>
  
      // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
      // included in the list of allowed values, including an empty string, as if the value
      // false had been provided.&quot;
      return &quot;false&quot;;
  }
  
  bool AccessibilityObject::supportsSetSize() const
  {
      return hasAttribute(aria_setsizeAttr);
  }
  
<span class="line-new-header">--- 2785,55 ---</span>
  bool AccessibilityObject::supportsHasPopup() const
  {
      return hasAttribute(aria_haspopupAttr) || isComboBox();
  }
  
<span class="line-modified">! String AccessibilityObject::popupValue() const</span>
  {
<span class="line-modified">!     static const NeverDestroyed&lt;HashSet&lt;String&gt;&gt; allowedPopupValues(std::initializer_list&lt;String&gt; {</span>
<span class="line-modified">!         &quot;menu&quot;, &quot;listbox&quot;, &quot;tree&quot;, &quot;grid&quot;, &quot;dialog&quot;</span>
<span class="line-modified">!     });</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto hasPopup = getAttribute(aria_haspopupAttr).convertToASCIILowercase();</span>
<span class="line-modified">!     if (hasPopup.isNull() || hasPopup.isEmpty()) {</span>
<span class="line-modified">!         // In ARIA 1.1, the implicit value for combobox became &quot;listbox.&quot;</span>
<span class="line-added">+         if (isComboBox() || hasDatalist())</span>
<span class="line-added">+             return &quot;listbox&quot;;</span>
<span class="line-added">+         return &quot;false&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (allowedPopupValues-&gt;contains(hasPopup))</span>
          return hasPopup;
  
<span class="line-modified">!     // aria-haspopup specification states that true must be treated as menu.</span>
<span class="line-modified">!     if (hasPopup == &quot;true&quot;)</span>
<span class="line-modified">!         return &quot;menu&quot;;</span>
  
      // The spec states that &quot;User agents must treat any value of aria-haspopup that is not
      // included in the list of allowed values, including an empty string, as if the value
      // false had been provided.&quot;
      return &quot;false&quot;;
  }
  
<span class="line-added">+ bool AccessibilityObject::hasDatalist() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ENABLE(DATALIST_ELEMENT)</span>
<span class="line-added">+     auto datalistId = getAttribute(listAttr);</span>
<span class="line-added">+     if (datalistId.isNull() || datalistId.isEmpty())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto element = this-&gt;element();</span>
<span class="line-added">+     if (!element)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto datalist = element-&gt;treeScope().getElementById(datalistId);</span>
<span class="line-added">+     return is&lt;HTMLDataListElement&gt;(datalist);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool AccessibilityObject::supportsSetSize() const
  {
      return hasAttribute(aria_setsizeAttr);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2749,11 ***</span>
  int AccessibilityObject::posInSet() const
  {
      return getAttribute(aria_posinsetAttr).toInt();
  }
  
<span class="line-modified">! const AtomicString&amp; AccessibilityObject::identifierAttribute() const</span>
  {
      return getAttribute(idAttr);
  }
  
  void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
<span class="line-new-header">--- 2850,11 ---</span>
  int AccessibilityObject::posInSet() const
  {
      return getAttribute(aria_posinsetAttr).toInt();
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityObject::identifierAttribute() const</span>
  {
      return getAttribute(idAttr);
  }
  
  void AccessibilityObject::classList(Vector&lt;String&gt;&amp; classList) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2769,18 ***</span>
          classList.append(list.item(k).string());
  }
  
  bool AccessibilityObject::supportsPressed() const
  {
<span class="line-modified">!     const AtomicString&amp; expanded = getAttribute(aria_pressedAttr);</span>
      return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
  }
  
  bool AccessibilityObject::supportsExpanded() const
  {
      // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
<span class="line-modified">!     const AtomicString&amp; expanded = getAttribute(aria_expandedAttr);</span>
      if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
          return true;
      switch (roleValue()) {
      case AccessibilityRole::ComboBox:
      case AccessibilityRole::DisclosureTriangle:
<span class="line-new-header">--- 2870,18 ---</span>
          classList.append(list.item(k).string());
  }
  
  bool AccessibilityObject::supportsPressed() const
  {
<span class="line-modified">!     const AtomString&amp; expanded = getAttribute(aria_pressedAttr);</span>
      return equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;);
  }
  
  bool AccessibilityObject::supportsExpanded() const
  {
      // Undefined values should not result in this attribute being exposed to ATs according to ARIA.
<span class="line-modified">!     const AtomString&amp; expanded = getAttribute(aria_expandedAttr);</span>
      if (equalLettersIgnoringASCIICase(expanded, &quot;true&quot;) || equalLettersIgnoringASCIICase(expanded, &quot;false&quot;))
          return true;
      switch (roleValue()) {
      case AccessibilityRole::ComboBox:
      case AccessibilityRole::DisclosureTriangle:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2829,19 ***</span>
      // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
      // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
      // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
  
      if (isToggleButton()) {
<span class="line-modified">!         const AtomicString&amp; ariaPressed = getAttribute(aria_pressedAttr);</span>
          if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
              return AccessibilityButtonState::On;
          if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
              return AccessibilityButtonState::Mixed;
          return AccessibilityButtonState::Off;
      }
  
<span class="line-modified">!     const AtomicString&amp; result = getAttribute(aria_checkedAttr);</span>
      if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
          return AccessibilityButtonState::On;
      if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
          // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
          AccessibilityRole ariaRole = ariaRoleAttribute();
<span class="line-new-header">--- 2930,19 ---</span>
      // If this is a real checkbox or radio button, AccessibilityRenderObject will handle.
      // If it&#39;s an ARIA checkbox, radio, or switch the aria-checked attribute should be used.
      // If it&#39;s a toggle button, the aria-pressed attribute is consulted.
  
      if (isToggleButton()) {
<span class="line-modified">!         const AtomString&amp; ariaPressed = getAttribute(aria_pressedAttr);</span>
          if (equalLettersIgnoringASCIICase(ariaPressed, &quot;true&quot;))
              return AccessibilityButtonState::On;
          if (equalLettersIgnoringASCIICase(ariaPressed, &quot;mixed&quot;))
              return AccessibilityButtonState::Mixed;
          return AccessibilityButtonState::Off;
      }
  
<span class="line-modified">!     const AtomString&amp; result = getAttribute(aria_checkedAttr);</span>
      if (equalLettersIgnoringASCIICase(result, &quot;true&quot;))
          return AccessibilityButtonState::On;
      if (equalLettersIgnoringASCIICase(result, &quot;mixed&quot;)) {
          // ARIA says that radio, menuitemradio, and switch elements must NOT expose button state mixed.
          AccessibilityRole ariaRole = ariaRoleAttribute();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2980,18 ***</span>
      return isOnscreen;
  }
  
  void AccessibilityObject::scrollToMakeVisible() const
  {
<span class="line-modified">!     if (dispatchAccessibilityEventWithType(AccessibilityEventType::ScrollIntoView))</span>
<span class="line-modified">!         return;</span>
  
      if (isScrollView() &amp;&amp; parentObject())
          parentObject()-&gt;scrollToMakeVisible();
  
      if (auto* renderer = this-&gt;renderer())
<span class="line-modified">!         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });</span>
  }
  
  void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
  {
      // Search up the parent chain until we find the first one that&#39;s scrollable.
<span class="line-new-header">--- 3081,20 ---</span>
      return isOnscreen;
  }
  
  void AccessibilityObject::scrollToMakeVisible() const
  {
<span class="line-modified">!     scrollToMakeVisible({ SelectionRevealMode::Reveal, ScrollAlignment::alignCenterIfNeeded, ScrollAlignment::alignCenterIfNeeded, ShouldAllowCrossOriginScrolling::Yes });</span>
<span class="line-modified">! }</span>
  
<span class="line-added">+ void AccessibilityObject::scrollToMakeVisible(const ScrollRectToVisibleOptions&amp; options) const</span>
<span class="line-added">+ {</span>
      if (isScrollView() &amp;&amp; parentObject())
          parentObject()-&gt;scrollToMakeVisible();
  
      if (auto* renderer = this-&gt;renderer())
<span class="line-modified">!         renderer-&gt;scrollRectToVisible(boundingBoxRect(), false, options);</span>
  }
  
  void AccessibilityObject::scrollToMakeVisibleWithSubFocus(const IntRect&amp; subfocus) const
  {
      // Search up the parent chain until we find the first one that&#39;s scrollable.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3225,11 ***</span>
  
  TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
  {
      TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
  
<span class="line-modified">! #if PLATFORM(GTK)</span>
      // We need to emit replaced elements for GTK, and present
      // them with the &#39;object replacement character&#39; (0xFFFC).
      behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
  #endif
  
<span class="line-new-header">--- 3328,11 ---</span>
  
  TextIteratorBehavior AccessibilityObject::textIteratorBehaviorForTextRange() const
  {
      TextIteratorBehavior behavior = TextIteratorIgnoresStyleVisibility;
  
<span class="line-modified">! #if USE(ATK)</span>
      // We need to emit replaced elements for GTK, and present
      // them with the &#39;object replacement character&#39; (0xFFFC).
      behavior = static_cast&lt;TextIteratorBehavior&gt;(behavior | TextIteratorEmitsObjectReplacementCharacters);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3347,11 ***</span>
      if (!node || !node-&gt;isElementNode())
          return;
  
      TreeScope&amp; treeScope = node-&gt;treeScope();
  
<span class="line-modified">!     const AtomicString&amp; idList = getAttribute(attribute);</span>
      if (idList.isEmpty())
          return;
  
      auto spaceSplitString = SpaceSplitString(idList, false);
      size_t length = spaceSplitString.size();
<span class="line-new-header">--- 3450,11 ---</span>
      if (!node || !node-&gt;isElementNode())
          return;
  
      TreeScope&amp; treeScope = node-&gt;treeScope();
  
<span class="line-modified">!     const AtomString&amp; idList = getAttribute(attribute);</span>
      if (idList.isEmpty())
          return;
  
      auto spaceSplitString = SpaceSplitString(idList, false);
      size_t length = spaceSplitString.size();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3427,26 ***</span>
      || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
      || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
      || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
  }
  
<span class="line-modified">! bool AccessibilityObject::isSubscriptStyleGroup() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Node* node = this-&gt;node();</span>
<span class="line-removed">-     return node &amp;&amp; node-&gt;hasTagName(subTag);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool AccessibilityObject::isSuperscriptStyleGroup() const</span>
  {
      Node* node = this-&gt;node();
<span class="line-modified">!     return node &amp;&amp; node-&gt;hasTagName(supTag);</span>
  }
  
<span class="line-modified">! bool AccessibilityObject::isFigureElement() const</span>
  {
<span class="line-modified">!     Node* node = this-&gt;node();</span>
<span class="line-modified">!     return node &amp;&amp; node-&gt;hasTagName(figureTag);</span>
  }
  
  bool AccessibilityObject::isOutput() const
  {
      Node* node = this-&gt;node();
<span class="line-new-header">--- 3530,21 ---</span>
      || node-&gt;hasTagName(varTag) || node-&gt;hasTagName(citeTag)
      || node-&gt;hasTagName(insTag) || node-&gt;hasTagName(delTag)
      || node-&gt;hasTagName(supTag) || node-&gt;hasTagName(subTag);
  }
  
<span class="line-modified">! bool AccessibilityObject::isFigureElement() const</span>
  {
      Node* node = this-&gt;node();
<span class="line-modified">!     return node &amp;&amp; node-&gt;hasTagName(figureTag);</span>
  }
  
<span class="line-modified">! bool AccessibilityObject::isKeyboardFocusable() const</span>
  {
<span class="line-modified">!     if (auto element = this-&gt;element())</span>
<span class="line-modified">!         return element-&gt;isFocusable();</span>
<span class="line-added">+     return false;</span>
  }
  
  bool AccessibilityObject::isOutput() const
  {
      Node* node = this-&gt;node();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3496,11 ***</span>
      AXObjectCache* cache = axObjectCache();
      if (!cache)
          return;
  
      for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
<span class="line-modified">!         const AtomicString&amp; idList = element.attributeWithoutSynchronization(attribute);</span>
          if (!SpaceSplitString(idList, false).contains(id))
              continue;
  
          if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
              elements.append(axObject);
<span class="line-new-header">--- 3594,11 ---</span>
      AXObjectCache* cache = axObjectCache();
      if (!cache)
          return;
  
      for (auto&amp; element : descendantsOfType&lt;Element&gt;(node()-&gt;treeScope().rootNode())) {
<span class="line-modified">!         const AtomString&amp; idList = element.attributeWithoutSynchronization(attribute);</span>
          if (!SpaceSplitString(idList, false).contains(id))
              continue;
  
          if (AccessibilityObject* axObject = cache-&gt;getOrCreate(&amp;element))
              elements.append(axObject);
</pre>
<center><a href="AccessibilityNodeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>