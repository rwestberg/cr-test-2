<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineElementBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineFlowBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 248 
 249 void InlineFlowBox::attachLine()
 250 {
 251     if (extracted())
 252         attachLineBoxToRenderObject();
 253     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine())
 254         child-&gt;attachLine();
 255 }
 256 
 257 void InlineFlowBox::attachLineBoxToRenderObject()
 258 {
 259     downcast&lt;RenderInline&gt;(renderer()).lineBoxes().attachLineBox(this);
 260 }
 261 
 262 void InlineFlowBox::adjustPosition(float dx, float dy)
 263 {
 264     InlineBox::adjustPosition(dx, dy);
 265     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine())
 266         child-&gt;adjustPosition(dx, dy);
 267     if (m_overflow)
<span class="line-modified"> 268         m_overflow-&gt;move(dx, dy); // FIXME: Rounding error here since overflow was pixel snapped, but nobody other than list markers passes non-integral values here.</span>
 269 }
 270 
 271 static inline bool isLastChildForRenderer(const RenderElement&amp; ancestor, const RenderObject* child)
 272 {
 273     if (!child)
 274         return false;
 275 
 276     if (child == &amp;ancestor)
 277         return true;
 278 
 279     const RenderObject* curr = child;
 280     const RenderElement* parent = curr-&gt;parent();
 281     while (parent &amp;&amp; (!parent-&gt;isRenderBlock() || parent-&gt;isInline())) {
 282         if (parent-&gt;lastChild() != curr)
 283             return false;
 284         if (parent == &amp;ancestor)
 285             return true;
 286 
 287         curr = parent;
 288         parent = curr-&gt;parent();
</pre>
<hr />
<pre>
 641         if (descendantsHaveSameLineHeightAndBaseline()) {
 642             child-&gt;adjustBlockDirectionPosition(adjustmentForChildrenWithSameLineHeightAndBaseline);
 643             continue;
 644         }
 645 
 646         InlineFlowBox* inlineFlowBox = is&lt;InlineFlowBox&gt;(*child) ? downcast&lt;InlineFlowBox&gt;(child) : nullptr;
 647         bool childAffectsTopBottomPos = true;
 648 
 649         if (child-&gt;verticalAlign() == VerticalAlign::Top &amp;&amp; verticalAlignApplies(child-&gt;renderer()))
 650             child-&gt;setLogicalTop(top);
 651         else if (child-&gt;verticalAlign() == VerticalAlign::Bottom &amp;&amp; verticalAlignApplies(child-&gt;renderer()))
 652             child-&gt;setLogicalTop(top + maxHeight - child-&gt;lineHeight());
 653         else {
 654             if (!strictMode &amp;&amp; inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;hasTextChildren() &amp;&amp; !inlineFlowBox-&gt;renderer().hasInlineDirectionBordersOrPadding()
 655                 &amp;&amp; !(inlineFlowBox-&gt;descendantsHaveSameLineHeightAndBaseline() &amp;&amp; inlineFlowBox-&gt;hasTextDescendants()))
 656                 childAffectsTopBottomPos = false;
 657             LayoutUnit posAdjust = maxAscent - child-&gt;baselinePosition(baselineType);
 658             child-&gt;setLogicalTop(child-&gt;logicalTop() + top + posAdjust);
 659         }
 660 
<span class="line-modified"> 661         LayoutUnit newLogicalTop = child-&gt;logicalTop();</span>
 662         LayoutUnit newLogicalTopIncludingMargins = newLogicalTop;
<span class="line-modified"> 663         LayoutUnit boxHeight = child-&gt;logicalHeight();</span>
 664         LayoutUnit boxHeightIncludingMargins = boxHeight;
 665 
 666         const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
 667         if (child-&gt;behavesLikeText() || is&lt;InlineFlowBox&gt;(*child)) {
 668             const FontMetrics&amp; fontMetrics = childLineStyle.fontMetrics();
 669             newLogicalTop += child-&gt;baselinePosition(baselineType) - fontMetrics.ascent(baselineType);
 670             if (is&lt;InlineFlowBox&gt;(*child)) {
 671                 RenderBoxModelObject&amp; boxObject = downcast&lt;InlineFlowBox&gt;(*child).renderer();
 672                 newLogicalTop -= childLineStyle.isHorizontalWritingMode()
 673                     ? boxObject.borderTop() + boxObject.paddingTop()
 674                     : boxObject.borderRight() + boxObject.paddingRight();
 675             }
 676             newLogicalTopIncludingMargins = newLogicalTop;
 677         } else if (!child-&gt;renderer().isBR()) {
 678             const auto&amp; box = downcast&lt;RenderBox&gt;(child-&gt;renderer());
 679             newLogicalTopIncludingMargins = newLogicalTop;
 680             // We may flip lines in case of verticalLR mode, so we can assume verticalRL for now.
 681             LayoutUnit overSideMargin = child-&gt;isHorizontal() ? box.marginTop() : box.marginRight();
 682             LayoutUnit underSideMargin = child-&gt;isHorizontal() ? box.marginBottom() : box.marginLeft();
 683             newLogicalTop += overSideMargin;
 684             boxHeightIncludingMargins += overSideMargin + underSideMargin;
 685         }
 686 
 687         child-&gt;setLogicalTop(newLogicalTop);
 688 
 689         if (childAffectsTopBottomPos) {
 690             if (is&lt;RenderRubyRun&gt;(child-&gt;renderer())) {
 691                 // Treat the leading on the first and last lines of ruby runs as not being part of the overall lineTop/lineBottom.
 692                 // Really this is a workaround hack for the fact that ruby should have been done as line layout and not done using
 693                 // inline-block.
 694                 if (renderer().style().isFlippedLinesWritingMode() == (child-&gt;renderer().style().rubyPosition() == RubyPosition::After))
 695                     hasAnnotationsBefore = true;
 696                 else
 697                     hasAnnotationsAfter = true;
 698 
 699                 auto&amp; rubyRun = downcast&lt;RenderRubyRun&gt;(child-&gt;renderer());
 700                 if (RenderRubyBase* rubyBase = rubyRun.rubyBase()) {
<span class="line-modified"> 701                     LayoutUnit bottomRubyBaseLeading = (child-&gt;logicalHeight() - rubyBase-&gt;logicalBottom()) + rubyBase-&gt;logicalHeight() - (rubyBase-&gt;lastRootBox() ? rubyBase-&gt;lastRootBox()-&gt;lineBottom() : 0_lu);</span>
 702                     LayoutUnit topRubyBaseLeading = rubyBase-&gt;logicalTop() + (rubyBase-&gt;firstRootBox() ? rubyBase-&gt;firstRootBox()-&gt;lineTop() : 0_lu);
 703                     newLogicalTop += !renderer().style().isFlippedLinesWritingMode() ? topRubyBaseLeading : bottomRubyBaseLeading;
 704                     boxHeight -= (topRubyBaseLeading + bottomRubyBaseLeading);
 705                 }
 706             }
 707             if (is&lt;InlineTextBox&gt;(*child)) {
 708                 if (Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle)) {
 709                     if (*markExistsAndIsAbove != childLineStyle.isFlippedLinesWritingMode())
 710                         hasAnnotationsBefore = true;
 711                     else
 712                         hasAnnotationsAfter = true;
 713                 }
 714             }
 715 
 716             if (!setLineTop) {
 717                 setLineTop = true;
 718                 lineTop = newLogicalTop;
 719                 lineTopIncludingMargins = std::min(lineTop, newLogicalTopIncludingMargins);
 720             } else {
 721                 lineTop = std::min(lineTop, newLogicalTop);
 722                 lineTopIncludingMargins = std::min(lineTop, std::min(lineTopIncludingMargins, newLogicalTopIncludingMargins));
 723             }
 724             lineBottom = std::max(lineBottom, newLogicalTop + boxHeight);
 725             lineBottomIncludingMargins = std::max(lineBottom, std::max(lineBottomIncludingMargins, newLogicalTopIncludingMargins + boxHeightIncludingMargins));
 726         }
 727 
 728         // Adjust boxes to use their real box y/height and not the logical height (as dictated by
 729         // line-height).
 730         if (inlineFlowBox)
 731             inlineFlowBox-&gt;placeBoxesInBlockDirection(top, maxHeight, maxAscent, strictMode, lineTop, lineBottom, setLineTop,
 732                                                       lineTopIncludingMargins, lineBottomIncludingMargins, hasAnnotationsBefore, hasAnnotationsAfter, baselineType);
 733     }
 734 
 735     if (isRootBox) {
 736         if (strictMode || hasTextChildren() || (descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
 737             if (!setLineTop) {
 738                 setLineTop = true;
 739                 lineTop = logicalTop();
 740                 lineTopIncludingMargins = lineTop;
 741             } else {
<span class="line-modified"> 742                 lineTop = std::min&lt;LayoutUnit&gt;(lineTop, logicalTop());</span>
 743                 lineTopIncludingMargins = std::min(lineTop, lineTopIncludingMargins);
 744             }
<span class="line-modified"> 745             lineBottom = std::max&lt;LayoutUnit&gt;(lineBottom, logicalBottom());</span>
 746             lineBottomIncludingMargins = std::max(lineBottom, lineBottomIncludingMargins);
 747         }
 748 
 749         if (renderer().style().isFlippedLinesWritingMode())
 750             flipLinesInBlockDirection(lineTopIncludingMargins, lineBottomIncludingMargins);
 751     }
 752 }
 753 
 754 void InlineFlowBox::maxLogicalBottomForTextDecorationLine(float&amp; maxLogicalBottom, const RenderElement* decorationRenderer, OptionSet&lt;TextDecoration&gt; textDecoration) const
 755 {
 756     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
 757         if (child-&gt;renderer().isOutOfFlowPositioned())
 758             continue; // Positioned placeholders don&#39;t affect calculations.
 759 
 760         if (!(child-&gt;lineStyle().textDecorationsInEffect() &amp; textDecoration))
 761             continue; // If the text decoration isn&#39;t in effect on the child, then it must be outside of |decorationRenderer|&#39;s hierarchy.
 762 
 763         if (decorationRenderer &amp;&amp; decorationRenderer-&gt;isRenderInline() &amp;&amp; !isAncestorAndWithinBlock(downcast&lt;RenderInline&gt;(*decorationRenderer), &amp;child-&gt;renderer()))
 764             continue;
 765 
</pre>
<hr />
<pre>
 811 
 812 inline void InlineFlowBox::addBoxShadowVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 813 {
 814     // box-shadow on root line boxes is applying to the block and not to the lines.
 815     if (!parent())
 816         return;
 817 
 818     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 819     if (!lineStyle.boxShadow())
 820         return;
 821 
 822     LayoutUnit boxShadowLogicalTop;
 823     LayoutUnit boxShadowLogicalBottom;
 824     lineStyle.getBoxShadowBlockDirectionExtent(boxShadowLogicalTop, boxShadowLogicalBottom);
 825 
 826     // Similar to how glyph overflow works, if our lines are flipped, then it&#39;s actually the opposite shadow that applies, since
 827     // the line is &quot;upside down&quot; in terms of block coordinates.
 828     LayoutUnit shadowLogicalTop = lineStyle.isFlippedLinesWritingMode() ? -boxShadowLogicalBottom : boxShadowLogicalTop;
 829     LayoutUnit shadowLogicalBottom = lineStyle.isFlippedLinesWritingMode() ? -boxShadowLogicalTop : boxShadowLogicalBottom;
 830 
<span class="line-modified"> 831     LayoutUnit logicalTopVisualOverflow = std::min&lt;LayoutUnit&gt;(logicalTop() + shadowLogicalTop, logicalVisualOverflow.y());</span>
<span class="line-modified"> 832     LayoutUnit logicalBottomVisualOverflow = std::max&lt;LayoutUnit&gt;(logicalBottom() + shadowLogicalBottom, logicalVisualOverflow.maxY());</span>
 833 
 834     LayoutUnit boxShadowLogicalLeft;
 835     LayoutUnit boxShadowLogicalRight;
 836     lineStyle.getBoxShadowInlineDirectionExtent(boxShadowLogicalLeft, boxShadowLogicalRight);
 837 
<span class="line-modified"> 838     LayoutUnit logicalLeftVisualOverflow = std::min&lt;LayoutUnit&gt;(logicalLeft() + boxShadowLogicalLeft, logicalVisualOverflow.x());</span>
<span class="line-modified"> 839     LayoutUnit logicalRightVisualOverflow = std::max&lt;LayoutUnit&gt;(logicalRight() + boxShadowLogicalRight, logicalVisualOverflow.maxX());</span>
 840 
 841     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 842                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 843 }
 844 
 845 inline void InlineFlowBox::addBorderOutsetVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 846 {
 847     // border-image-outset on root line boxes is applying to the block and not to the lines.
 848     if (!parent())
 849         return;
 850 
 851     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 852     if (!lineStyle.hasBorderImageOutsets())
 853         return;
 854 
 855     LayoutBoxExtent borderOutsets = lineStyle.borderImageOutsets();
 856 
 857     LayoutUnit borderOutsetLogicalTop = borderOutsets.before(lineStyle.writingMode());
 858     LayoutUnit borderOutsetLogicalBottom = borderOutsets.after(lineStyle.writingMode());
 859     LayoutUnit borderOutsetLogicalLeft = borderOutsets.start(lineStyle.writingMode());
 860     LayoutUnit borderOutsetLogicalRight = borderOutsets.end(lineStyle.writingMode());
 861 
 862     // Similar to how glyph overflow works, if our lines are flipped, then it&#39;s actually the opposite border that applies, since
 863     // the line is &quot;upside down&quot; in terms of block coordinates. vertical-rl and horizontal-bt are the flipped line modes.
 864     LayoutUnit outsetLogicalTop = lineStyle.isFlippedLinesWritingMode() ? borderOutsetLogicalBottom : borderOutsetLogicalTop;
 865     LayoutUnit outsetLogicalBottom = lineStyle.isFlippedLinesWritingMode() ? borderOutsetLogicalTop : borderOutsetLogicalBottom;
 866 
<span class="line-modified"> 867     LayoutUnit logicalTopVisualOverflow = std::min&lt;LayoutUnit&gt;(logicalTop() - outsetLogicalTop, logicalVisualOverflow.y());</span>
<span class="line-modified"> 868     LayoutUnit logicalBottomVisualOverflow = std::max&lt;LayoutUnit&gt;(logicalBottom() + outsetLogicalBottom, logicalVisualOverflow.maxY());</span>
 869 
 870     LayoutUnit outsetLogicalLeft = includeLogicalLeftEdge() ? borderOutsetLogicalLeft : 0_lu;
 871     LayoutUnit outsetLogicalRight = includeLogicalRightEdge() ? borderOutsetLogicalRight : 0_lu;
 872 
<span class="line-modified"> 873     LayoutUnit logicalLeftVisualOverflow = std::min&lt;LayoutUnit&gt;(logicalLeft() - outsetLogicalLeft, logicalVisualOverflow.x());</span>
<span class="line-modified"> 874     LayoutUnit logicalRightVisualOverflow = std::max&lt;LayoutUnit&gt;(logicalRight() + outsetLogicalRight, logicalVisualOverflow.maxX());</span>
 875 
 876     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 877                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 878 }
 879 
 880 inline void InlineFlowBox::addTextBoxVisualOverflow(InlineTextBox&amp; textBox, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, LayoutRect&amp; logicalVisualOverflow)
 881 {
 882     if (textBox.knownToHaveNoOverflow())
 883         return;
 884 
 885     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 886 
 887     GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.find(&amp;textBox);
 888     GlyphOverflow* glyphOverflow = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.second;
 889     bool isFlippedLine = lineStyle.isFlippedLinesWritingMode();
 890 
 891     int topGlyphEdge = glyphOverflow ? (isFlippedLine ? glyphOverflow-&gt;bottom : glyphOverflow-&gt;top) : 0;
 892     int bottomGlyphEdge = glyphOverflow ? (isFlippedLine ? glyphOverflow-&gt;top : glyphOverflow-&gt;bottom) : 0;
 893     int leftGlyphEdge = glyphOverflow ? glyphOverflow-&gt;left : 0;
 894     int rightGlyphEdge = glyphOverflow ? glyphOverflow-&gt;right : 0;
</pre>
<hr />
<pre>
 909     }
 910 
 911     // If letter-spacing is negative, we should factor that into right layout overflow. (Even in RTL, letter-spacing is
 912     // applied to the right, so this is not an issue with left overflow.
 913     rightGlyphOverflow -= std::min(0, (int)lineStyle.fontCascade().letterSpacing());
 914 
 915     LayoutUnit textShadowLogicalTop;
 916     LayoutUnit textShadowLogicalBottom;
 917     lineStyle.getTextShadowBlockDirectionExtent(textShadowLogicalTop, textShadowLogicalBottom);
 918 
 919     LayoutUnit childOverflowLogicalTop = std::min&lt;LayoutUnit&gt;(textShadowLogicalTop + topGlyphOverflow, topGlyphOverflow);
 920     LayoutUnit childOverflowLogicalBottom = std::max&lt;LayoutUnit&gt;(textShadowLogicalBottom + bottomGlyphOverflow, bottomGlyphOverflow);
 921 
 922     LayoutUnit textShadowLogicalLeft;
 923     LayoutUnit textShadowLogicalRight;
 924     lineStyle.getTextShadowInlineDirectionExtent(textShadowLogicalLeft, textShadowLogicalRight);
 925 
 926     LayoutUnit childOverflowLogicalLeft = std::min&lt;LayoutUnit&gt;(textShadowLogicalLeft + leftGlyphOverflow, leftGlyphOverflow);
 927     LayoutUnit childOverflowLogicalRight = std::max&lt;LayoutUnit&gt;(textShadowLogicalRight + rightGlyphOverflow, rightGlyphOverflow);
 928 
<span class="line-modified"> 929     LayoutUnit logicalTopVisualOverflow = std::min&lt;LayoutUnit&gt;(textBox.logicalTop() + childOverflowLogicalTop, logicalVisualOverflow.y());</span>
<span class="line-modified"> 930     LayoutUnit logicalBottomVisualOverflow = std::max&lt;LayoutUnit&gt;(textBox.logicalBottom() + childOverflowLogicalBottom, logicalVisualOverflow.maxY());</span>
<span class="line-modified"> 931     LayoutUnit logicalLeftVisualOverflow = std::min&lt;LayoutUnit&gt;(textBox.logicalLeft() + childOverflowLogicalLeft, logicalVisualOverflow.x());</span>
<span class="line-modified"> 932     LayoutUnit logicalRightVisualOverflow = std::max&lt;LayoutUnit&gt;(textBox.logicalRight() + childOverflowLogicalRight, logicalVisualOverflow.maxX());</span>
 933 
 934     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 935                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 936 
 937     auto documentMarkerBounds = textBox.calculateUnionOfAllDocumentMarkerBounds();
 938     documentMarkerBounds.move(textBox.logicalLeft(), textBox.logicalTop());
 939     logicalVisualOverflow = unionRect(logicalVisualOverflow, LayoutRect(documentMarkerBounds));
 940 
 941     textBox.setLogicalOverflowRect(logicalVisualOverflow);
 942 }
 943 
 944 inline void InlineFlowBox::addOutlineVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 945 {
 946     const auto&amp; lineStyle = this-&gt;lineStyle();
 947     if (!lineStyle.hasOutlineInVisualOverflow())
 948         return;
<span class="line-modified"> 949     LayoutUnit outlineSize = lineStyle.outlineSize();</span>
 950     LayoutUnit logicalTopVisualOverflow = std::min(LayoutUnit(logicalTop() - outlineSize), logicalVisualOverflow.y());
 951     LayoutUnit logicalBottomVisualOverflow = std::max(LayoutUnit(logicalBottom() + outlineSize), logicalVisualOverflow.maxY());
 952     LayoutUnit logicalLeftVisualOverflow = std::min(LayoutUnit(logicalLeft() - outlineSize), logicalVisualOverflow.x());
 953     LayoutUnit logicalRightVisualOverflow = std::max(LayoutUnit(logicalRight() + outlineSize), logicalVisualOverflow.maxX());
 954     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 955         logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 956 }
 957 
 958 inline void InlineFlowBox::addReplacedChildOverflow(const InlineBox* inlineBox, LayoutRect&amp; logicalLayoutOverflow, LayoutRect&amp; logicalVisualOverflow)
 959 {
 960     const RenderBox&amp; box = downcast&lt;RenderBox&gt;(inlineBox-&gt;renderer());
 961 
 962     // Visual overflow only propagates if the box doesn&#39;t have a self-painting layer.  This rectangle does not include
 963     // transforms or relative positioning (since those objects always have self-painting layers), but it does need to be adjusted
 964     // for writing-mode differences.
 965     if (!box.hasSelfPaintingLayer()) {
 966         LayoutRect childLogicalVisualOverflow = box.logicalVisualOverflowRectForPropagation(&amp;renderer().style());
 967         childLogicalVisualOverflow.move(inlineBox-&gt;logicalLeft(), inlineBox-&gt;logicalTop());
 968         logicalVisualOverflow.unite(childLogicalVisualOverflow);
 969     }
</pre>
<hr />
<pre>
1110     if (isRootInlineBox() &amp;&amp; hasEllipsisBox()) {
1111         const EllipsisBox* ellipsisBox = root().ellipsisBox();
1112         FloatRect boundsRect(frameRect());
1113 
1114         if (isHorizontal())
1115             renderer().style().isLeftToRightDirection() ? boundsRect.shiftXEdgeTo(ellipsisBox-&gt;right()) : boundsRect.setWidth(ellipsisBox-&gt;left() - left());
1116         else
1117             boundsRect.shiftYEdgeTo(ellipsisBox-&gt;right());
1118 
1119         flipForWritingMode(boundsRect);
1120         boundsRect.moveBy(accumulatedOffset);
1121         // We are beyond the ellipsis box.
1122         if (locationInContainer.intersects(boundsRect))
1123             return false;
1124     }
1125 
1126     // Constrain our hit testing to the line top and bottom if necessary.
1127     bool noQuirksMode = renderer().document().inNoQuirksMode();
1128     if (!noQuirksMode &amp;&amp; !hasTextChildren() &amp;&amp; !(descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
1129         RootInlineBox&amp; rootBox = root();
<span class="line-modified">1130         LayoutUnit top = isHorizontal() ? y() : x();</span>
<span class="line-modified">1131         LayoutUnit logicalHeight = isHorizontal() ? height() : width();</span>
1132         LayoutUnit bottom = std::min(rootBox.lineBottom(), top + logicalHeight);
1133         top = std::max(rootBox.lineTop(), top);
1134         logicalHeight = bottom - top;
1135     }
1136 
1137     // Move x/y to our coordinates.
1138     FloatRect rect(frameRect());
1139     flipForWritingMode(rect);
1140     rect.moveBy(accumulatedOffset);
1141 
1142     if (locationInContainer.intersects(rect)) {
1143         renderer().updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - toLayoutSize(accumulatedOffset))); // Don&#39;t add in m_x or m_y here, we want coords in the containing block&#39;s space.
1144         if (result.addNodeToListBasedTestResult(renderer().element(), request, locationInContainer, rect) == HitTestProgress::Stop)
1145             return true;
1146     }
1147 
1148     return false;
1149 }
1150 
1151 void InlineFlowBox::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit lineTop, LayoutUnit lineBottom)
1152 {
<span class="line-modified">1153     if (paintInfo.phase != PaintPhase::Foreground &amp;&amp; paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::Outline &amp;&amp; paintInfo.phase != PaintPhase::SelfOutline &amp;&amp; paintInfo.phase != PaintPhase::ChildOutlines &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; paintInfo.phase != PaintPhase::Mask)</span>
1154         return;
1155 
1156     LayoutRect overflowRect(visualOverflowRect(lineTop, lineBottom));
1157     flipForWritingMode(overflowRect);
1158     overflowRect.moveBy(paintOffset);
1159 
1160     if (!paintInfo.rect.intersects(snappedIntRect(overflowRect)))
1161         return;
1162 
1163     if (paintInfo.phase != PaintPhase::ChildOutlines) {
1164         if (paintInfo.phase == PaintPhase::Outline || paintInfo.phase == PaintPhase::SelfOutline) {
1165             // Add ourselves to the paint info struct&#39;s list of inlines that need to paint their
1166             // outlines.
1167             if (renderer().style().visibility() == Visibility::Visible &amp;&amp; renderer().hasOutline() &amp;&amp; !isRootInlineBox()) {
1168                 RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1169 
1170                 RenderBlock* containingBlock = nullptr;
1171                 bool containingBlockPaintsContinuationOutline = inlineFlow.continuation() || inlineFlow.isContinuation();
1172                 if (containingBlockPaintsContinuationOutline) {
1173                     // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=54690. We currently don&#39;t reconnect inline continuations
</pre>
<hr />
<pre>
1230 }
1231 
1232 bool InlineFlowBox::boxShadowCanBeAppliedToBackground(const FillLayer&amp; lastBackgroundLayer) const
1233 {
1234     // The checks here match how paintFillLayer() decides whether to clip (if it does, the shadow
1235     // would be clipped out, so it has to be drawn separately).
1236     StyleImage* image = lastBackgroundLayer.image();
1237     bool hasFillImage = image &amp;&amp; image-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1238     return (!hasFillImage &amp;&amp; !renderer().style().hasBorderRadius()) || (!prevLineBox() &amp;&amp; !nextLineBox()) || !parent();
1239 }
1240 
1241 void InlineFlowBox::paintFillLayer(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect, CompositeOperator op)
1242 {
1243     auto* image = fillLayer.image();
1244     bool hasFillImage = image &amp;&amp; image-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1245     if ((!hasFillImage &amp;&amp; !renderer().style().hasBorderRadius()) || (!prevLineBox() &amp;&amp; !nextLineBox()) || !parent())
1246         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, rect, BackgroundBleedNone, this, rect.size(), op);
1247 #if ENABLE(CSS_BOX_DECORATION_BREAK)
1248     else if (renderer().style().boxDecorationBreak() == BoxDecorationBreak::Clone) {
1249         GraphicsContextStateSaver stateSaver(paintInfo.context());
<span class="line-modified">1250         paintInfo.context().clip(LayoutRect(rect.x(), rect.y(), width(), height()));</span>
1251         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, rect, BackgroundBleedNone, this, rect.size(), op);
1252     }
1253 #endif
1254     else {
1255         // We have a fill image that spans multiple lines.
1256         // We need to adjust tx and ty by the width of all previous lines.
1257         // Think of background painting on inlines as though you had one long line, a single continuous
1258         // strip.  Even though that strip has been broken up across multiple lines, you still paint it
1259         // as though you had one single line.  This means each line has to pick up the background where
1260         // the previous line left off.
1261         LayoutUnit logicalOffsetOnLine;
1262         LayoutUnit totalLogicalWidth;
1263         if (renderer().style().direction() == TextDirection::LTR) {
1264             for (InlineFlowBox* curr = prevLineBox(); curr; curr = curr-&gt;prevLineBox())
1265                 logicalOffsetOnLine += curr-&gt;logicalWidth();
1266             totalLogicalWidth = logicalOffsetOnLine;
1267             for (InlineFlowBox* curr = this; curr; curr = curr-&gt;nextLineBox())
1268                 totalLogicalWidth += curr-&gt;logicalWidth();
1269         } else {
1270             for (InlineFlowBox* curr = nextLineBox(); curr; curr = curr-&gt;nextLineBox())
1271                 logicalOffsetOnLine += curr-&gt;logicalWidth();
1272             totalLogicalWidth = logicalOffsetOnLine;
1273             for (InlineFlowBox* curr = this; curr; curr = curr-&gt;prevLineBox())
1274                 totalLogicalWidth += curr-&gt;logicalWidth();
1275         }
1276         LayoutUnit stripX = rect.x() - (isHorizontal() ? logicalOffsetOnLine : 0_lu);
1277         LayoutUnit stripY = rect.y() - (isHorizontal() ? 0_lu : logicalOffsetOnLine);
1278         LayoutUnit stripWidth = isHorizontal() ? totalLogicalWidth : LayoutUnit(width());
1279         LayoutUnit stripHeight = isHorizontal() ? LayoutUnit(height()) : totalLogicalWidth;
1280 
1281         GraphicsContextStateSaver stateSaver(paintInfo.context());
<span class="line-modified">1282         paintInfo.context().clip(LayoutRect(rect.x(), rect.y(), width(), height()));</span>
1283         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, LayoutRect(stripX, stripY, stripWidth, stripHeight), BackgroundBleedNone, this, rect.size(), op);
1284     }
1285 }
1286 
1287 void InlineFlowBox::paintBoxShadow(const PaintInfo&amp; info, const RenderStyle&amp; style, ShadowStyle shadowStyle, const LayoutRect&amp; paintRect)
1288 {
1289     if ((!prevLineBox() &amp;&amp; !nextLineBox()) || !parent())
1290         renderer().paintBoxShadow(info, paintRect, style, shadowStyle);
1291     else {
1292         // FIXME: We can do better here in the multi-line case. We want to push a clip so that the shadow doesn&#39;t
1293         // protrude incorrectly at the edges, and we want to possibly include shadows cast from the previous/following lines
1294         renderer().paintBoxShadow(info, paintRect, style, shadowStyle, includeLogicalLeftEdge(), includeLogicalRightEdge());
1295     }
1296 }
1297 
1298 void InlineFlowBox::constrainToLineTopAndBottomIfNeeded(LayoutRect&amp; rect) const
1299 {
1300     bool noQuirksMode = renderer().document().inNoQuirksMode();
1301     if (!noQuirksMode &amp;&amp; !hasTextChildren() &amp;&amp; !(descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
1302         const RootInlineBox&amp; rootBox = root();
</pre>
<hr />
<pre>
1330         if (box-&gt;includeLogicalRightEdge())
1331             clipRect.setWidth(clipRect.width() + outsets.right());
1332     } else {
1333         clipRect.setX(paintRect.x() - outsets.left());
1334         clipRect.setWidth(paintRect.width() + outsets.left() + outsets.right());
1335         if (box-&gt;includeLogicalLeftEdge()) {
1336             clipRect.setY(paintRect.y() - outsets.top());
1337             clipRect.setHeight(paintRect.height() + outsets.top());
1338         }
1339         if (box-&gt;includeLogicalRightEdge())
1340             clipRect.setHeight(clipRect.height() + outsets.bottom());
1341     }
1342     return clipRect;
1343 }
1344 
1345 void InlineFlowBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1346 {
1347     if (!paintInfo.shouldPaintWithinRoot(renderer()) || renderer().style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Foreground)
1348         return;
1349 
<span class="line-removed">1350     LayoutRect frameRect(this-&gt;frameRect());</span>
<span class="line-removed">1351     constrainToLineTopAndBottomIfNeeded(frameRect);</span>
<span class="line-removed">1352 </span>
<span class="line-removed">1353     // Move x/y to our coordinates.</span>
<span class="line-removed">1354     LayoutRect localRect(frameRect);</span>
<span class="line-removed">1355     flipForWritingMode(localRect);</span>
<span class="line-removed">1356 </span>
1357     // You can use p::first-line to specify a background. If so, the root line boxes for
1358     // a line may actually have to paint a background.
1359     if (parent() &amp;&amp; !renderer().hasVisibleBoxDecorations())
1360         return;
1361     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
1362     if (!parent() &amp;&amp; (!isFirstLine() || &amp;lineStyle == &amp;renderer().style()))
1363         return;
1364 







1365     LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
1366     GraphicsContext&amp; context = paintInfo.context();
1367     LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
1368     // Shadow comes first and is behind the background and border.
1369     if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
1370         paintBoxShadow(paintInfo, lineStyle, Normal, paintRect);
1371 
<span class="line-modified">1372     Color color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);</span>
<span class="line-modified">1373 </span>
<span class="line-removed">1374     CompositeOperator compositeOp = CompositeSourceOver;</span>
<span class="line-removed">1375     if (renderer().document().settings().punchOutWhiteBackgroundsInDarkMode() &amp;&amp; Color::isWhiteColor(color) &amp;&amp; renderer().useDarkAppearance())</span>
<span class="line-removed">1376         compositeOp = CompositeDestinationOut;</span>
1377 
1378     color = lineStyle.colorByApplyingColorFilter(color);
1379 
1380     paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
1381     paintBoxShadow(paintInfo, lineStyle, Inset, paintRect);
1382 
1383     // :first-line cannot be used to put borders on a line. Always paint borders with our
1384     // non-first-line style.
1385     if (!parent() || !renderer().style().hasVisibleBorderDecoration())
1386         return;
1387     const NinePieceImage&amp; borderImage = renderer().style().borderImage();
1388     StyleImage* borderImageSource = borderImage.image();
1389     bool hasBorderImage = borderImageSource &amp;&amp; borderImageSource-&gt;canRender(&amp;renderer(), lineStyle.effectiveZoom());
1390     if (hasBorderImage &amp;&amp; !borderImageSource-&gt;isLoaded())
1391         return; // Don&#39;t paint anything while we wait for the image to load.
1392 
1393     // The simple case is where we either have no border image or we are the only box for this object. In those
1394     // cases only a single call to draw is required.
1395     if (!hasBorderImage || (!prevLineBox() &amp;&amp; !nextLineBox()))
1396         renderer().paintBorder(paintInfo, paintRect, lineStyle, BackgroundBleedNone, includeLogicalLeftEdge(), includeLogicalRightEdge());
</pre>
<hr />
<pre>
1625             if (rubyRun.style().isFlippedLinesWritingMode()) {
1626                 LayoutUnit topOfFirstRubyTextLine = rubyText-&gt;logicalTop() + (rubyText-&gt;firstRootBox() ? rubyText-&gt;firstRootBox()-&gt;lineTop() : 0_lu);
1627                 if (topOfFirstRubyTextLine &gt;= 0)
1628                     continue;
1629                 topOfFirstRubyTextLine += child-&gt;logicalTop();
1630                 result = std::max(result, allowedPosition - topOfFirstRubyTextLine);
1631             } else {
1632                 LayoutUnit bottomOfLastRubyTextLine = rubyText-&gt;logicalTop() + (rubyText-&gt;lastRootBox() ? rubyText-&gt;lastRootBox()-&gt;lineBottom() : rubyText-&gt;logicalHeight());
1633                 if (bottomOfLastRubyTextLine &lt;= child-&gt;logicalHeight())
1634                     continue;
1635                 bottomOfLastRubyTextLine += child-&gt;logicalTop();
1636                 result = std::max(result, bottomOfLastRubyTextLine - allowedPosition);
1637             }
1638         }
1639 
1640         if (is&lt;InlineTextBox&gt;(*child)) {
1641             const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
1642             Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle);
1643             if (markExistsAndIsAbove &amp;&amp; !*markExistsAndIsAbove) {
1644                 if (!childLineStyle.isFlippedLinesWritingMode()) {
<span class="line-modified">1645                     LayoutUnit bottomOfEmphasisMark = child-&gt;logicalBottom() + childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString());</span>
1646                     result = std::max(result, bottomOfEmphasisMark - allowedPosition);
1647                 } else {
<span class="line-modified">1648                     LayoutUnit topOfEmphasisMark = child-&gt;logicalTop() - childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString());</span>
1649                     result = std::max(result, allowedPosition - topOfEmphasisMark);
1650                 }
1651             }
1652         }
1653     }
1654     return result;
1655 }
1656 
1657 void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
1658 {
1659     InlineBox* leaf = firstLeafChild();
1660 
1661     // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
1662     // Investigate on how this code could possibly be shared.
1663     unsigned char minLevel = 128;
1664     unsigned char maxLevel = 0;
1665 
1666     // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
1667     for (; leaf; leaf = leaf-&gt;nextLeafChild()) {
1668         minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
</pre>
</td>
<td>
<hr />
<pre>
 248 
 249 void InlineFlowBox::attachLine()
 250 {
 251     if (extracted())
 252         attachLineBoxToRenderObject();
 253     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine())
 254         child-&gt;attachLine();
 255 }
 256 
 257 void InlineFlowBox::attachLineBoxToRenderObject()
 258 {
 259     downcast&lt;RenderInline&gt;(renderer()).lineBoxes().attachLineBox(this);
 260 }
 261 
 262 void InlineFlowBox::adjustPosition(float dx, float dy)
 263 {
 264     InlineBox::adjustPosition(dx, dy);
 265     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine())
 266         child-&gt;adjustPosition(dx, dy);
 267     if (m_overflow)
<span class="line-modified"> 268         m_overflow-&gt;move(LayoutUnit(dx), LayoutUnit(dy)); // FIXME: Rounding error here since overflow was pixel snapped, but nobody other than list markers passes non-integral values here.</span>
 269 }
 270 
 271 static inline bool isLastChildForRenderer(const RenderElement&amp; ancestor, const RenderObject* child)
 272 {
 273     if (!child)
 274         return false;
 275 
 276     if (child == &amp;ancestor)
 277         return true;
 278 
 279     const RenderObject* curr = child;
 280     const RenderElement* parent = curr-&gt;parent();
 281     while (parent &amp;&amp; (!parent-&gt;isRenderBlock() || parent-&gt;isInline())) {
 282         if (parent-&gt;lastChild() != curr)
 283             return false;
 284         if (parent == &amp;ancestor)
 285             return true;
 286 
 287         curr = parent;
 288         parent = curr-&gt;parent();
</pre>
<hr />
<pre>
 641         if (descendantsHaveSameLineHeightAndBaseline()) {
 642             child-&gt;adjustBlockDirectionPosition(adjustmentForChildrenWithSameLineHeightAndBaseline);
 643             continue;
 644         }
 645 
 646         InlineFlowBox* inlineFlowBox = is&lt;InlineFlowBox&gt;(*child) ? downcast&lt;InlineFlowBox&gt;(child) : nullptr;
 647         bool childAffectsTopBottomPos = true;
 648 
 649         if (child-&gt;verticalAlign() == VerticalAlign::Top &amp;&amp; verticalAlignApplies(child-&gt;renderer()))
 650             child-&gt;setLogicalTop(top);
 651         else if (child-&gt;verticalAlign() == VerticalAlign::Bottom &amp;&amp; verticalAlignApplies(child-&gt;renderer()))
 652             child-&gt;setLogicalTop(top + maxHeight - child-&gt;lineHeight());
 653         else {
 654             if (!strictMode &amp;&amp; inlineFlowBox &amp;&amp; !inlineFlowBox-&gt;hasTextChildren() &amp;&amp; !inlineFlowBox-&gt;renderer().hasInlineDirectionBordersOrPadding()
 655                 &amp;&amp; !(inlineFlowBox-&gt;descendantsHaveSameLineHeightAndBaseline() &amp;&amp; inlineFlowBox-&gt;hasTextDescendants()))
 656                 childAffectsTopBottomPos = false;
 657             LayoutUnit posAdjust = maxAscent - child-&gt;baselinePosition(baselineType);
 658             child-&gt;setLogicalTop(child-&gt;logicalTop() + top + posAdjust);
 659         }
 660 
<span class="line-modified"> 661         LayoutUnit newLogicalTop { child-&gt;logicalTop() };</span>
 662         LayoutUnit newLogicalTopIncludingMargins = newLogicalTop;
<span class="line-modified"> 663         LayoutUnit boxHeight { child-&gt;logicalHeight() };</span>
 664         LayoutUnit boxHeightIncludingMargins = boxHeight;
 665 
 666         const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
 667         if (child-&gt;behavesLikeText() || is&lt;InlineFlowBox&gt;(*child)) {
 668             const FontMetrics&amp; fontMetrics = childLineStyle.fontMetrics();
 669             newLogicalTop += child-&gt;baselinePosition(baselineType) - fontMetrics.ascent(baselineType);
 670             if (is&lt;InlineFlowBox&gt;(*child)) {
 671                 RenderBoxModelObject&amp; boxObject = downcast&lt;InlineFlowBox&gt;(*child).renderer();
 672                 newLogicalTop -= childLineStyle.isHorizontalWritingMode()
 673                     ? boxObject.borderTop() + boxObject.paddingTop()
 674                     : boxObject.borderRight() + boxObject.paddingRight();
 675             }
 676             newLogicalTopIncludingMargins = newLogicalTop;
 677         } else if (!child-&gt;renderer().isBR()) {
 678             const auto&amp; box = downcast&lt;RenderBox&gt;(child-&gt;renderer());
 679             newLogicalTopIncludingMargins = newLogicalTop;
 680             // We may flip lines in case of verticalLR mode, so we can assume verticalRL for now.
 681             LayoutUnit overSideMargin = child-&gt;isHorizontal() ? box.marginTop() : box.marginRight();
 682             LayoutUnit underSideMargin = child-&gt;isHorizontal() ? box.marginBottom() : box.marginLeft();
 683             newLogicalTop += overSideMargin;
 684             boxHeightIncludingMargins += overSideMargin + underSideMargin;
 685         }
 686 
 687         child-&gt;setLogicalTop(newLogicalTop);
 688 
 689         if (childAffectsTopBottomPos) {
 690             if (is&lt;RenderRubyRun&gt;(child-&gt;renderer())) {
 691                 // Treat the leading on the first and last lines of ruby runs as not being part of the overall lineTop/lineBottom.
 692                 // Really this is a workaround hack for the fact that ruby should have been done as line layout and not done using
 693                 // inline-block.
 694                 if (renderer().style().isFlippedLinesWritingMode() == (child-&gt;renderer().style().rubyPosition() == RubyPosition::After))
 695                     hasAnnotationsBefore = true;
 696                 else
 697                     hasAnnotationsAfter = true;
 698 
 699                 auto&amp; rubyRun = downcast&lt;RenderRubyRun&gt;(child-&gt;renderer());
 700                 if (RenderRubyBase* rubyBase = rubyRun.rubyBase()) {
<span class="line-modified"> 701                     LayoutUnit bottomRubyBaseLeading { (child-&gt;logicalHeight() - rubyBase-&gt;logicalBottom()) + rubyBase-&gt;logicalHeight() - (rubyBase-&gt;lastRootBox() ? rubyBase-&gt;lastRootBox()-&gt;lineBottom() : 0_lu) };</span>
 702                     LayoutUnit topRubyBaseLeading = rubyBase-&gt;logicalTop() + (rubyBase-&gt;firstRootBox() ? rubyBase-&gt;firstRootBox()-&gt;lineTop() : 0_lu);
 703                     newLogicalTop += !renderer().style().isFlippedLinesWritingMode() ? topRubyBaseLeading : bottomRubyBaseLeading;
 704                     boxHeight -= (topRubyBaseLeading + bottomRubyBaseLeading);
 705                 }
 706             }
 707             if (is&lt;InlineTextBox&gt;(*child)) {
 708                 if (Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle)) {
 709                     if (*markExistsAndIsAbove != childLineStyle.isFlippedLinesWritingMode())
 710                         hasAnnotationsBefore = true;
 711                     else
 712                         hasAnnotationsAfter = true;
 713                 }
 714             }
 715 
 716             if (!setLineTop) {
 717                 setLineTop = true;
 718                 lineTop = newLogicalTop;
 719                 lineTopIncludingMargins = std::min(lineTop, newLogicalTopIncludingMargins);
 720             } else {
 721                 lineTop = std::min(lineTop, newLogicalTop);
 722                 lineTopIncludingMargins = std::min(lineTop, std::min(lineTopIncludingMargins, newLogicalTopIncludingMargins));
 723             }
 724             lineBottom = std::max(lineBottom, newLogicalTop + boxHeight);
 725             lineBottomIncludingMargins = std::max(lineBottom, std::max(lineBottomIncludingMargins, newLogicalTopIncludingMargins + boxHeightIncludingMargins));
 726         }
 727 
 728         // Adjust boxes to use their real box y/height and not the logical height (as dictated by
 729         // line-height).
 730         if (inlineFlowBox)
 731             inlineFlowBox-&gt;placeBoxesInBlockDirection(top, maxHeight, maxAscent, strictMode, lineTop, lineBottom, setLineTop,
 732                                                       lineTopIncludingMargins, lineBottomIncludingMargins, hasAnnotationsBefore, hasAnnotationsAfter, baselineType);
 733     }
 734 
 735     if (isRootBox) {
 736         if (strictMode || hasTextChildren() || (descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
 737             if (!setLineTop) {
 738                 setLineTop = true;
 739                 lineTop = logicalTop();
 740                 lineTopIncludingMargins = lineTop;
 741             } else {
<span class="line-modified"> 742                 lineTop = std::min(lineTop, LayoutUnit(logicalTop()));</span>
 743                 lineTopIncludingMargins = std::min(lineTop, lineTopIncludingMargins);
 744             }
<span class="line-modified"> 745             lineBottom = std::max(lineBottom, LayoutUnit(logicalBottom()));</span>
 746             lineBottomIncludingMargins = std::max(lineBottom, lineBottomIncludingMargins);
 747         }
 748 
 749         if (renderer().style().isFlippedLinesWritingMode())
 750             flipLinesInBlockDirection(lineTopIncludingMargins, lineBottomIncludingMargins);
 751     }
 752 }
 753 
 754 void InlineFlowBox::maxLogicalBottomForTextDecorationLine(float&amp; maxLogicalBottom, const RenderElement* decorationRenderer, OptionSet&lt;TextDecoration&gt; textDecoration) const
 755 {
 756     for (InlineBox* child = firstChild(); child; child = child-&gt;nextOnLine()) {
 757         if (child-&gt;renderer().isOutOfFlowPositioned())
 758             continue; // Positioned placeholders don&#39;t affect calculations.
 759 
 760         if (!(child-&gt;lineStyle().textDecorationsInEffect() &amp; textDecoration))
 761             continue; // If the text decoration isn&#39;t in effect on the child, then it must be outside of |decorationRenderer|&#39;s hierarchy.
 762 
 763         if (decorationRenderer &amp;&amp; decorationRenderer-&gt;isRenderInline() &amp;&amp; !isAncestorAndWithinBlock(downcast&lt;RenderInline&gt;(*decorationRenderer), &amp;child-&gt;renderer()))
 764             continue;
 765 
</pre>
<hr />
<pre>
 811 
 812 inline void InlineFlowBox::addBoxShadowVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 813 {
 814     // box-shadow on root line boxes is applying to the block and not to the lines.
 815     if (!parent())
 816         return;
 817 
 818     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 819     if (!lineStyle.boxShadow())
 820         return;
 821 
 822     LayoutUnit boxShadowLogicalTop;
 823     LayoutUnit boxShadowLogicalBottom;
 824     lineStyle.getBoxShadowBlockDirectionExtent(boxShadowLogicalTop, boxShadowLogicalBottom);
 825 
 826     // Similar to how glyph overflow works, if our lines are flipped, then it&#39;s actually the opposite shadow that applies, since
 827     // the line is &quot;upside down&quot; in terms of block coordinates.
 828     LayoutUnit shadowLogicalTop = lineStyle.isFlippedLinesWritingMode() ? -boxShadowLogicalBottom : boxShadowLogicalTop;
 829     LayoutUnit shadowLogicalBottom = lineStyle.isFlippedLinesWritingMode() ? -boxShadowLogicalTop : boxShadowLogicalBottom;
 830 
<span class="line-modified"> 831     LayoutUnit logicalTopVisualOverflow = std::min(LayoutUnit(logicalTop() + shadowLogicalTop), logicalVisualOverflow.y());</span>
<span class="line-modified"> 832     LayoutUnit logicalBottomVisualOverflow = std::max(LayoutUnit(logicalBottom() + shadowLogicalBottom), logicalVisualOverflow.maxY());</span>
 833 
 834     LayoutUnit boxShadowLogicalLeft;
 835     LayoutUnit boxShadowLogicalRight;
 836     lineStyle.getBoxShadowInlineDirectionExtent(boxShadowLogicalLeft, boxShadowLogicalRight);
 837 
<span class="line-modified"> 838     LayoutUnit logicalLeftVisualOverflow = std::min(LayoutUnit(logicalLeft() + boxShadowLogicalLeft), logicalVisualOverflow.x());</span>
<span class="line-modified"> 839     LayoutUnit logicalRightVisualOverflow = std::max(LayoutUnit(logicalRight() + boxShadowLogicalRight), logicalVisualOverflow.maxX());</span>
 840 
 841     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 842                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 843 }
 844 
 845 inline void InlineFlowBox::addBorderOutsetVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 846 {
 847     // border-image-outset on root line boxes is applying to the block and not to the lines.
 848     if (!parent())
 849         return;
 850 
 851     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 852     if (!lineStyle.hasBorderImageOutsets())
 853         return;
 854 
 855     LayoutBoxExtent borderOutsets = lineStyle.borderImageOutsets();
 856 
 857     LayoutUnit borderOutsetLogicalTop = borderOutsets.before(lineStyle.writingMode());
 858     LayoutUnit borderOutsetLogicalBottom = borderOutsets.after(lineStyle.writingMode());
 859     LayoutUnit borderOutsetLogicalLeft = borderOutsets.start(lineStyle.writingMode());
 860     LayoutUnit borderOutsetLogicalRight = borderOutsets.end(lineStyle.writingMode());
 861 
 862     // Similar to how glyph overflow works, if our lines are flipped, then it&#39;s actually the opposite border that applies, since
 863     // the line is &quot;upside down&quot; in terms of block coordinates. vertical-rl and horizontal-bt are the flipped line modes.
 864     LayoutUnit outsetLogicalTop = lineStyle.isFlippedLinesWritingMode() ? borderOutsetLogicalBottom : borderOutsetLogicalTop;
 865     LayoutUnit outsetLogicalBottom = lineStyle.isFlippedLinesWritingMode() ? borderOutsetLogicalTop : borderOutsetLogicalBottom;
 866 
<span class="line-modified"> 867     LayoutUnit logicalTopVisualOverflow = std::min(LayoutUnit(logicalTop() - outsetLogicalTop), logicalVisualOverflow.y());</span>
<span class="line-modified"> 868     LayoutUnit logicalBottomVisualOverflow = std::max(LayoutUnit(logicalBottom() + outsetLogicalBottom), logicalVisualOverflow.maxY());</span>
 869 
 870     LayoutUnit outsetLogicalLeft = includeLogicalLeftEdge() ? borderOutsetLogicalLeft : 0_lu;
 871     LayoutUnit outsetLogicalRight = includeLogicalRightEdge() ? borderOutsetLogicalRight : 0_lu;
 872 
<span class="line-modified"> 873     LayoutUnit logicalLeftVisualOverflow = std::min(LayoutUnit(logicalLeft() - outsetLogicalLeft), logicalVisualOverflow.x());</span>
<span class="line-modified"> 874     LayoutUnit logicalRightVisualOverflow = std::max(LayoutUnit(logicalRight() + outsetLogicalRight), logicalVisualOverflow.maxX());</span>
 875 
 876     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 877                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 878 }
 879 
 880 inline void InlineFlowBox::addTextBoxVisualOverflow(InlineTextBox&amp; textBox, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, LayoutRect&amp; logicalVisualOverflow)
 881 {
 882     if (textBox.knownToHaveNoOverflow())
 883         return;
 884 
 885     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
 886 
 887     GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.find(&amp;textBox);
 888     GlyphOverflow* glyphOverflow = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.second;
 889     bool isFlippedLine = lineStyle.isFlippedLinesWritingMode();
 890 
 891     int topGlyphEdge = glyphOverflow ? (isFlippedLine ? glyphOverflow-&gt;bottom : glyphOverflow-&gt;top) : 0;
 892     int bottomGlyphEdge = glyphOverflow ? (isFlippedLine ? glyphOverflow-&gt;top : glyphOverflow-&gt;bottom) : 0;
 893     int leftGlyphEdge = glyphOverflow ? glyphOverflow-&gt;left : 0;
 894     int rightGlyphEdge = glyphOverflow ? glyphOverflow-&gt;right : 0;
</pre>
<hr />
<pre>
 909     }
 910 
 911     // If letter-spacing is negative, we should factor that into right layout overflow. (Even in RTL, letter-spacing is
 912     // applied to the right, so this is not an issue with left overflow.
 913     rightGlyphOverflow -= std::min(0, (int)lineStyle.fontCascade().letterSpacing());
 914 
 915     LayoutUnit textShadowLogicalTop;
 916     LayoutUnit textShadowLogicalBottom;
 917     lineStyle.getTextShadowBlockDirectionExtent(textShadowLogicalTop, textShadowLogicalBottom);
 918 
 919     LayoutUnit childOverflowLogicalTop = std::min&lt;LayoutUnit&gt;(textShadowLogicalTop + topGlyphOverflow, topGlyphOverflow);
 920     LayoutUnit childOverflowLogicalBottom = std::max&lt;LayoutUnit&gt;(textShadowLogicalBottom + bottomGlyphOverflow, bottomGlyphOverflow);
 921 
 922     LayoutUnit textShadowLogicalLeft;
 923     LayoutUnit textShadowLogicalRight;
 924     lineStyle.getTextShadowInlineDirectionExtent(textShadowLogicalLeft, textShadowLogicalRight);
 925 
 926     LayoutUnit childOverflowLogicalLeft = std::min&lt;LayoutUnit&gt;(textShadowLogicalLeft + leftGlyphOverflow, leftGlyphOverflow);
 927     LayoutUnit childOverflowLogicalRight = std::max&lt;LayoutUnit&gt;(textShadowLogicalRight + rightGlyphOverflow, rightGlyphOverflow);
 928 
<span class="line-modified"> 929     LayoutUnit logicalTopVisualOverflow = std::min(LayoutUnit(textBox.logicalTop() + childOverflowLogicalTop), logicalVisualOverflow.y());</span>
<span class="line-modified"> 930     LayoutUnit logicalBottomVisualOverflow = std::max(LayoutUnit(textBox.logicalBottom() + childOverflowLogicalBottom), logicalVisualOverflow.maxY());</span>
<span class="line-modified"> 931     LayoutUnit logicalLeftVisualOverflow = std::min(LayoutUnit(textBox.logicalLeft() + childOverflowLogicalLeft), logicalVisualOverflow.x());</span>
<span class="line-modified"> 932     LayoutUnit logicalRightVisualOverflow = std::max(LayoutUnit(textBox.logicalRight() + childOverflowLogicalRight), logicalVisualOverflow.maxX());</span>
 933 
 934     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 935                                        logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 936 
 937     auto documentMarkerBounds = textBox.calculateUnionOfAllDocumentMarkerBounds();
 938     documentMarkerBounds.move(textBox.logicalLeft(), textBox.logicalTop());
 939     logicalVisualOverflow = unionRect(logicalVisualOverflow, LayoutRect(documentMarkerBounds));
 940 
 941     textBox.setLogicalOverflowRect(logicalVisualOverflow);
 942 }
 943 
 944 inline void InlineFlowBox::addOutlineVisualOverflow(LayoutRect&amp; logicalVisualOverflow)
 945 {
 946     const auto&amp; lineStyle = this-&gt;lineStyle();
 947     if (!lineStyle.hasOutlineInVisualOverflow())
 948         return;
<span class="line-modified"> 949     LayoutUnit outlineSize { lineStyle.outlineSize() };</span>
 950     LayoutUnit logicalTopVisualOverflow = std::min(LayoutUnit(logicalTop() - outlineSize), logicalVisualOverflow.y());
 951     LayoutUnit logicalBottomVisualOverflow = std::max(LayoutUnit(logicalBottom() + outlineSize), logicalVisualOverflow.maxY());
 952     LayoutUnit logicalLeftVisualOverflow = std::min(LayoutUnit(logicalLeft() - outlineSize), logicalVisualOverflow.x());
 953     LayoutUnit logicalRightVisualOverflow = std::max(LayoutUnit(logicalRight() + outlineSize), logicalVisualOverflow.maxX());
 954     logicalVisualOverflow = LayoutRect(logicalLeftVisualOverflow, logicalTopVisualOverflow,
 955         logicalRightVisualOverflow - logicalLeftVisualOverflow, logicalBottomVisualOverflow - logicalTopVisualOverflow);
 956 }
 957 
 958 inline void InlineFlowBox::addReplacedChildOverflow(const InlineBox* inlineBox, LayoutRect&amp; logicalLayoutOverflow, LayoutRect&amp; logicalVisualOverflow)
 959 {
 960     const RenderBox&amp; box = downcast&lt;RenderBox&gt;(inlineBox-&gt;renderer());
 961 
 962     // Visual overflow only propagates if the box doesn&#39;t have a self-painting layer.  This rectangle does not include
 963     // transforms or relative positioning (since those objects always have self-painting layers), but it does need to be adjusted
 964     // for writing-mode differences.
 965     if (!box.hasSelfPaintingLayer()) {
 966         LayoutRect childLogicalVisualOverflow = box.logicalVisualOverflowRectForPropagation(&amp;renderer().style());
 967         childLogicalVisualOverflow.move(inlineBox-&gt;logicalLeft(), inlineBox-&gt;logicalTop());
 968         logicalVisualOverflow.unite(childLogicalVisualOverflow);
 969     }
</pre>
<hr />
<pre>
1110     if (isRootInlineBox() &amp;&amp; hasEllipsisBox()) {
1111         const EllipsisBox* ellipsisBox = root().ellipsisBox();
1112         FloatRect boundsRect(frameRect());
1113 
1114         if (isHorizontal())
1115             renderer().style().isLeftToRightDirection() ? boundsRect.shiftXEdgeTo(ellipsisBox-&gt;right()) : boundsRect.setWidth(ellipsisBox-&gt;left() - left());
1116         else
1117             boundsRect.shiftYEdgeTo(ellipsisBox-&gt;right());
1118 
1119         flipForWritingMode(boundsRect);
1120         boundsRect.moveBy(accumulatedOffset);
1121         // We are beyond the ellipsis box.
1122         if (locationInContainer.intersects(boundsRect))
1123             return false;
1124     }
1125 
1126     // Constrain our hit testing to the line top and bottom if necessary.
1127     bool noQuirksMode = renderer().document().inNoQuirksMode();
1128     if (!noQuirksMode &amp;&amp; !hasTextChildren() &amp;&amp; !(descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
1129         RootInlineBox&amp; rootBox = root();
<span class="line-modified">1130         LayoutUnit top { isHorizontal() ? y() : x()};</span>
<span class="line-modified">1131         LayoutUnit logicalHeight { isHorizontal() ? height() : width() };</span>
1132         LayoutUnit bottom = std::min(rootBox.lineBottom(), top + logicalHeight);
1133         top = std::max(rootBox.lineTop(), top);
1134         logicalHeight = bottom - top;
1135     }
1136 
1137     // Move x/y to our coordinates.
1138     FloatRect rect(frameRect());
1139     flipForWritingMode(rect);
1140     rect.moveBy(accumulatedOffset);
1141 
1142     if (locationInContainer.intersects(rect)) {
1143         renderer().updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - toLayoutSize(accumulatedOffset))); // Don&#39;t add in m_x or m_y here, we want coords in the containing block&#39;s space.
1144         if (result.addNodeToListBasedTestResult(renderer().element(), request, locationInContainer, rect) == HitTestProgress::Stop)
1145             return true;
1146     }
1147 
1148     return false;
1149 }
1150 
1151 void InlineFlowBox::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit lineTop, LayoutUnit lineBottom)
1152 {
<span class="line-modified">1153     if (paintInfo.phase != PaintPhase::Foreground &amp;&amp; paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::Outline &amp;&amp; paintInfo.phase != PaintPhase::SelfOutline &amp;&amp; paintInfo.phase != PaintPhase::ChildOutlines &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; paintInfo.phase != PaintPhase::Mask &amp;&amp; paintInfo.phase != PaintPhase::EventRegion)</span>
1154         return;
1155 
1156     LayoutRect overflowRect(visualOverflowRect(lineTop, lineBottom));
1157     flipForWritingMode(overflowRect);
1158     overflowRect.moveBy(paintOffset);
1159 
1160     if (!paintInfo.rect.intersects(snappedIntRect(overflowRect)))
1161         return;
1162 
1163     if (paintInfo.phase != PaintPhase::ChildOutlines) {
1164         if (paintInfo.phase == PaintPhase::Outline || paintInfo.phase == PaintPhase::SelfOutline) {
1165             // Add ourselves to the paint info struct&#39;s list of inlines that need to paint their
1166             // outlines.
1167             if (renderer().style().visibility() == Visibility::Visible &amp;&amp; renderer().hasOutline() &amp;&amp; !isRootInlineBox()) {
1168                 RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1169 
1170                 RenderBlock* containingBlock = nullptr;
1171                 bool containingBlockPaintsContinuationOutline = inlineFlow.continuation() || inlineFlow.isContinuation();
1172                 if (containingBlockPaintsContinuationOutline) {
1173                     // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=54690. We currently don&#39;t reconnect inline continuations
</pre>
<hr />
<pre>
1230 }
1231 
1232 bool InlineFlowBox::boxShadowCanBeAppliedToBackground(const FillLayer&amp; lastBackgroundLayer) const
1233 {
1234     // The checks here match how paintFillLayer() decides whether to clip (if it does, the shadow
1235     // would be clipped out, so it has to be drawn separately).
1236     StyleImage* image = lastBackgroundLayer.image();
1237     bool hasFillImage = image &amp;&amp; image-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1238     return (!hasFillImage &amp;&amp; !renderer().style().hasBorderRadius()) || (!prevLineBox() &amp;&amp; !nextLineBox()) || !parent();
1239 }
1240 
1241 void InlineFlowBox::paintFillLayer(const PaintInfo&amp; paintInfo, const Color&amp; color, const FillLayer&amp; fillLayer, const LayoutRect&amp; rect, CompositeOperator op)
1242 {
1243     auto* image = fillLayer.image();
1244     bool hasFillImage = image &amp;&amp; image-&gt;canRender(&amp;renderer(), renderer().style().effectiveZoom());
1245     if ((!hasFillImage &amp;&amp; !renderer().style().hasBorderRadius()) || (!prevLineBox() &amp;&amp; !nextLineBox()) || !parent())
1246         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, rect, BackgroundBleedNone, this, rect.size(), op);
1247 #if ENABLE(CSS_BOX_DECORATION_BREAK)
1248     else if (renderer().style().boxDecorationBreak() == BoxDecorationBreak::Clone) {
1249         GraphicsContextStateSaver stateSaver(paintInfo.context());
<span class="line-modified">1250         paintInfo.context().clip({ rect.x(), rect.y(), LayoutUnit(width()), LayoutUnit(height()) });</span>
1251         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, rect, BackgroundBleedNone, this, rect.size(), op);
1252     }
1253 #endif
1254     else {
1255         // We have a fill image that spans multiple lines.
1256         // We need to adjust tx and ty by the width of all previous lines.
1257         // Think of background painting on inlines as though you had one long line, a single continuous
1258         // strip.  Even though that strip has been broken up across multiple lines, you still paint it
1259         // as though you had one single line.  This means each line has to pick up the background where
1260         // the previous line left off.
1261         LayoutUnit logicalOffsetOnLine;
1262         LayoutUnit totalLogicalWidth;
1263         if (renderer().style().direction() == TextDirection::LTR) {
1264             for (InlineFlowBox* curr = prevLineBox(); curr; curr = curr-&gt;prevLineBox())
1265                 logicalOffsetOnLine += curr-&gt;logicalWidth();
1266             totalLogicalWidth = logicalOffsetOnLine;
1267             for (InlineFlowBox* curr = this; curr; curr = curr-&gt;nextLineBox())
1268                 totalLogicalWidth += curr-&gt;logicalWidth();
1269         } else {
1270             for (InlineFlowBox* curr = nextLineBox(); curr; curr = curr-&gt;nextLineBox())
1271                 logicalOffsetOnLine += curr-&gt;logicalWidth();
1272             totalLogicalWidth = logicalOffsetOnLine;
1273             for (InlineFlowBox* curr = this; curr; curr = curr-&gt;prevLineBox())
1274                 totalLogicalWidth += curr-&gt;logicalWidth();
1275         }
1276         LayoutUnit stripX = rect.x() - (isHorizontal() ? logicalOffsetOnLine : 0_lu);
1277         LayoutUnit stripY = rect.y() - (isHorizontal() ? 0_lu : logicalOffsetOnLine);
1278         LayoutUnit stripWidth = isHorizontal() ? totalLogicalWidth : LayoutUnit(width());
1279         LayoutUnit stripHeight = isHorizontal() ? LayoutUnit(height()) : totalLogicalWidth;
1280 
1281         GraphicsContextStateSaver stateSaver(paintInfo.context());
<span class="line-modified">1282         paintInfo.context().clip({ rect.x(), rect.y(), LayoutUnit(width()), LayoutUnit(height()) });</span>
1283         renderer().paintFillLayerExtended(paintInfo, color, fillLayer, LayoutRect(stripX, stripY, stripWidth, stripHeight), BackgroundBleedNone, this, rect.size(), op);
1284     }
1285 }
1286 
1287 void InlineFlowBox::paintBoxShadow(const PaintInfo&amp; info, const RenderStyle&amp; style, ShadowStyle shadowStyle, const LayoutRect&amp; paintRect)
1288 {
1289     if ((!prevLineBox() &amp;&amp; !nextLineBox()) || !parent())
1290         renderer().paintBoxShadow(info, paintRect, style, shadowStyle);
1291     else {
1292         // FIXME: We can do better here in the multi-line case. We want to push a clip so that the shadow doesn&#39;t
1293         // protrude incorrectly at the edges, and we want to possibly include shadows cast from the previous/following lines
1294         renderer().paintBoxShadow(info, paintRect, style, shadowStyle, includeLogicalLeftEdge(), includeLogicalRightEdge());
1295     }
1296 }
1297 
1298 void InlineFlowBox::constrainToLineTopAndBottomIfNeeded(LayoutRect&amp; rect) const
1299 {
1300     bool noQuirksMode = renderer().document().inNoQuirksMode();
1301     if (!noQuirksMode &amp;&amp; !hasTextChildren() &amp;&amp; !(descendantsHaveSameLineHeightAndBaseline() &amp;&amp; hasTextDescendants())) {
1302         const RootInlineBox&amp; rootBox = root();
</pre>
<hr />
<pre>
1330         if (box-&gt;includeLogicalRightEdge())
1331             clipRect.setWidth(clipRect.width() + outsets.right());
1332     } else {
1333         clipRect.setX(paintRect.x() - outsets.left());
1334         clipRect.setWidth(paintRect.width() + outsets.left() + outsets.right());
1335         if (box-&gt;includeLogicalLeftEdge()) {
1336             clipRect.setY(paintRect.y() - outsets.top());
1337             clipRect.setHeight(paintRect.height() + outsets.top());
1338         }
1339         if (box-&gt;includeLogicalRightEdge())
1340             clipRect.setHeight(clipRect.height() + outsets.bottom());
1341     }
1342     return clipRect;
1343 }
1344 
1345 void InlineFlowBox::paintBoxDecorations(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1346 {
1347     if (!paintInfo.shouldPaintWithinRoot(renderer()) || renderer().style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::Foreground)
1348         return;
1349 







1350     // You can use p::first-line to specify a background. If so, the root line boxes for
1351     // a line may actually have to paint a background.
1352     if (parent() &amp;&amp; !renderer().hasVisibleBoxDecorations())
1353         return;
1354     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
1355     if (!parent() &amp;&amp; (!isFirstLine() || &amp;lineStyle == &amp;renderer().style()))
1356         return;
1357 
<span class="line-added">1358     LayoutRect frameRect(this-&gt;frameRect());</span>
<span class="line-added">1359     constrainToLineTopAndBottomIfNeeded(frameRect);</span>
<span class="line-added">1360 </span>
<span class="line-added">1361     // Move x/y to our coordinates.</span>
<span class="line-added">1362     LayoutRect localRect(frameRect);</span>
<span class="line-added">1363     flipForWritingMode(localRect);</span>
<span class="line-added">1364 </span>
1365     LayoutPoint adjustedPaintoffset = paintOffset + localRect.location();
1366     GraphicsContext&amp; context = paintInfo.context();
1367     LayoutRect paintRect = LayoutRect(adjustedPaintoffset, frameRect.size());
1368     // Shadow comes first and is behind the background and border.
1369     if (!renderer().boxShadowShouldBeAppliedToBackground(adjustedPaintoffset, BackgroundBleedNone, this))
1370         paintBoxShadow(paintInfo, lineStyle, Normal, paintRect);
1371 
<span class="line-modified">1372     auto color = lineStyle.visitedDependentColor(CSSPropertyBackgroundColor);</span>
<span class="line-modified">1373     auto compositeOp = renderer().document().compositeOperatorForBackgroundColor(color, renderer());</span>



1374 
1375     color = lineStyle.colorByApplyingColorFilter(color);
1376 
1377     paintFillLayers(paintInfo, color, lineStyle.backgroundLayers(), paintRect, compositeOp);
1378     paintBoxShadow(paintInfo, lineStyle, Inset, paintRect);
1379 
1380     // :first-line cannot be used to put borders on a line. Always paint borders with our
1381     // non-first-line style.
1382     if (!parent() || !renderer().style().hasVisibleBorderDecoration())
1383         return;
1384     const NinePieceImage&amp; borderImage = renderer().style().borderImage();
1385     StyleImage* borderImageSource = borderImage.image();
1386     bool hasBorderImage = borderImageSource &amp;&amp; borderImageSource-&gt;canRender(&amp;renderer(), lineStyle.effectiveZoom());
1387     if (hasBorderImage &amp;&amp; !borderImageSource-&gt;isLoaded())
1388         return; // Don&#39;t paint anything while we wait for the image to load.
1389 
1390     // The simple case is where we either have no border image or we are the only box for this object. In those
1391     // cases only a single call to draw is required.
1392     if (!hasBorderImage || (!prevLineBox() &amp;&amp; !nextLineBox()))
1393         renderer().paintBorder(paintInfo, paintRect, lineStyle, BackgroundBleedNone, includeLogicalLeftEdge(), includeLogicalRightEdge());
</pre>
<hr />
<pre>
1622             if (rubyRun.style().isFlippedLinesWritingMode()) {
1623                 LayoutUnit topOfFirstRubyTextLine = rubyText-&gt;logicalTop() + (rubyText-&gt;firstRootBox() ? rubyText-&gt;firstRootBox()-&gt;lineTop() : 0_lu);
1624                 if (topOfFirstRubyTextLine &gt;= 0)
1625                     continue;
1626                 topOfFirstRubyTextLine += child-&gt;logicalTop();
1627                 result = std::max(result, allowedPosition - topOfFirstRubyTextLine);
1628             } else {
1629                 LayoutUnit bottomOfLastRubyTextLine = rubyText-&gt;logicalTop() + (rubyText-&gt;lastRootBox() ? rubyText-&gt;lastRootBox()-&gt;lineBottom() : rubyText-&gt;logicalHeight());
1630                 if (bottomOfLastRubyTextLine &lt;= child-&gt;logicalHeight())
1631                     continue;
1632                 bottomOfLastRubyTextLine += child-&gt;logicalTop();
1633                 result = std::max(result, bottomOfLastRubyTextLine - allowedPosition);
1634             }
1635         }
1636 
1637         if (is&lt;InlineTextBox&gt;(*child)) {
1638             const RenderStyle&amp; childLineStyle = child-&gt;lineStyle();
1639             Optional&lt;bool&gt; markExistsAndIsAbove = downcast&lt;InlineTextBox&gt;(*child).emphasisMarkExistsAndIsAbove(childLineStyle);
1640             if (markExistsAndIsAbove &amp;&amp; !*markExistsAndIsAbove) {
1641                 if (!childLineStyle.isFlippedLinesWritingMode()) {
<span class="line-modified">1642                     LayoutUnit bottomOfEmphasisMark { child-&gt;logicalBottom() + childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };</span>
1643                     result = std::max(result, bottomOfEmphasisMark - allowedPosition);
1644                 } else {
<span class="line-modified">1645                     LayoutUnit topOfEmphasisMark { child-&gt;logicalTop() - childLineStyle.fontCascade().emphasisMarkHeight(childLineStyle.textEmphasisMarkString()) };</span>
1646                     result = std::max(result, allowedPosition - topOfEmphasisMark);
1647                 }
1648             }
1649         }
1650     }
1651     return result;
1652 }
1653 
1654 void InlineFlowBox::collectLeafBoxesInLogicalOrder(Vector&lt;InlineBox*&gt;&amp; leafBoxesInLogicalOrder, CustomInlineBoxRangeReverse customReverseImplementation, void* userData) const
1655 {
1656     InlineBox* leaf = firstLeafChild();
1657 
1658     // FIXME: The reordering code is a copy of parts from BidiResolver::createBidiRunsForLine, operating directly on InlineBoxes, instead of BidiRuns.
1659     // Investigate on how this code could possibly be shared.
1660     unsigned char minLevel = 128;
1661     unsigned char maxLevel = 0;
1662 
1663     // First find highest and lowest levels, and initialize leafBoxesInLogicalOrder with the leaf boxes in visual order.
1664     for (; leaf; leaf = leaf-&gt;nextLeafChild()) {
1665         minLevel = std::min(minLevel, leaf-&gt;bidiLevel());
</pre>
</td>
</tr>
</table>
<center><a href="InlineElementBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>