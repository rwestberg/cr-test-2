<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmAirIRGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30 
  31 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3CCallValue.h&quot;
  34 #include &quot;B3Compile.h&quot;
  35 #include &quot;B3ConstPtrValue.h&quot;
  36 #include &quot;B3FixSSA.h&quot;
  37 #include &quot;B3Generate.h&quot;
  38 #include &quot;B3InsertionSet.h&quot;
  39 #include &quot;B3SlotBaseValue.h&quot;
  40 #include &quot;B3StackmapGenerationParams.h&quot;
  41 #include &quot;B3SwitchValue.h&quot;
  42 #include &quot;B3UpsilonValue.h&quot;
  43 #include &quot;B3Validate.h&quot;
  44 #include &quot;B3ValueInlines.h&quot;
  45 #include &quot;B3ValueKey.h&quot;
  46 #include &quot;B3Variable.h&quot;
  47 #include &quot;B3VariableValue.h&quot;
  48 #include &quot;B3WasmAddressValue.h&quot;
  49 #include &quot;B3WasmBoundsCheckValue.h&quot;

  50 #include &quot;JSCInlines.h&quot;

  51 #include &quot;ScratchRegisterAllocator.h&quot;
  52 #include &quot;VirtualRegister.h&quot;
  53 #include &quot;WasmCallingConvention.h&quot;
  54 #include &quot;WasmContextInlines.h&quot;
  55 #include &quot;WasmExceptionType.h&quot;
  56 #include &quot;WasmFunctionParser.h&quot;
  57 #include &quot;WasmInstance.h&quot;
  58 #include &quot;WasmMemory.h&quot;
  59 #include &quot;WasmOMGPlan.h&quot;

  60 #include &quot;WasmOpcodeOrigin.h&quot;

  61 #include &quot;WasmSignatureInlines.h&quot;
  62 #include &quot;WasmThunks.h&quot;
  63 #include &lt;limits&gt;
  64 #include &lt;wtf/Optional.h&gt;
  65 #include &lt;wtf/StdLibExtras.h&gt;
  66 
  67 void dumpProcedure(void* ptr)
  68 {
  69     JSC::B3::Procedure* proc = static_cast&lt;JSC::B3::Procedure*&gt;(ptr);
  70     proc-&gt;dump(WTF::dataFile());
  71 }
  72 
  73 namespace JSC { namespace Wasm {
  74 
  75 using namespace B3;
  76 
  77 namespace {
  78 namespace WasmB3IRGeneratorInternal {
  79 static const bool verbose = false;
  80 }
</pre>
<hr />
<pre>
 138         }
 139 
 140         using ResultList = Vector&lt;Value*, 1&gt;; // Value must be a Phi
 141 
 142         ResultList resultForBranch() const
 143         {
 144             if (type() == BlockType::Loop)
 145                 return ResultList();
 146             return result;
 147         }
 148 
 149     private:
 150         friend class B3IRGenerator;
 151         BlockType blockType;
 152         BasicBlock* continuation;
 153         BasicBlock* special;
 154         ResultList result;
 155     };
 156 
 157     typedef Value* ExpressionType;
<span class="line-removed"> 158     typedef ControlData ControlType;</span>
 159     typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;
<span class="line-modified"> 160     typedef ControlData::ResultList ResultList;</span>
<span class="line-modified"> 161     typedef FunctionParser&lt;B3IRGenerator&gt;::ControlEntry ControlEntry;</span>








































































































 162 
 163     static constexpr ExpressionType emptyExpression() { return nullptr; }
 164 
 165     typedef String ErrorType;
 166     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 167     typedef Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt; Result;
 168     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 169     template &lt;typename ...Args&gt;
 170     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 171     {
 172         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 173         return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
 174     }
 175 #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
 176         if (UNLIKELY(condition))                  \
 177             return fail(__VA_ARGS__);             \
 178     } while (0)
 179 
<span class="line-modified"> 180     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, MemoryMode, CompilationMode, unsigned functionIndex, TierUpCount*, ThrowWasmException);</span>
 181 
 182     PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
 183     PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
 184     ExpressionType addConstant(Type, uint64_t);
 185 










 186     // Locals
 187     PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
 188     PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
 189 
 190     // Globals
 191     PartialResult WARN_UNUSED_RETURN getGlobal(uint32_t index, ExpressionType&amp; result);
 192     PartialResult WARN_UNUSED_RETURN setGlobal(uint32_t index, ExpressionType value);
 193 
 194     // Memory
 195     PartialResult WARN_UNUSED_RETURN load(LoadOpType, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset);
 196     PartialResult WARN_UNUSED_RETURN store(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 197     PartialResult WARN_UNUSED_RETURN addGrowMemory(ExpressionType delta, ExpressionType&amp; result);
 198     PartialResult WARN_UNUSED_RETURN addCurrentMemory(ExpressionType&amp; result);
 199 
 200     // Basic operators
 201     template&lt;OpType&gt;
 202     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
 203     template&lt;OpType&gt;
 204     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
 205     PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
 206 
 207     // Control flow
 208     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
 209     ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="line-modified"> 210     ControlData WARN_UNUSED_RETURN addLoop(Type signature);</span>
 211     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="line-modified"> 212     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const ExpressionList&amp;);</span>
 213     PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
 214 
 215     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);
<span class="line-modified"> 216     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const ExpressionList&amp; returnValues);</span>
<span class="line-modified"> 217     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const ExpressionList&amp; expressionStack);</span>
<span class="line-modified"> 218     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, ExpressionList&amp; expressionStack);</span>
 219     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
 220 
 221     // Calls
 222     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="line-modified"> 223     PartialResult WARN_UNUSED_RETURN addCallIndirect(const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
 224     PartialResult WARN_UNUSED_RETURN addUnreachable();
 225 
<span class="line-modified"> 226     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack);</span>
 227     void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
 228 
 229     Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
 230     void insertConstants();
 231 
 232     ALWAYS_INLINE void didKill(ExpressionType) { }
 233 
 234 private:
 235     void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
 236 
<span class="line-modified"> 237     void emitTierUpCheck(uint32_t decrementCount, Origin);</span>

 238 

 239     ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
 240     B3::Kind memoryKind(B3::Opcode memoryOp);
 241     ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
 242     void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 243 
 244     void unify(const ExpressionType phi, const ExpressionType source);
<span class="line-modified"> 245     void unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; stack);</span>
 246 
 247     void emitChecksForModOrDiv(B3::Opcode, ExpressionType left, ExpressionType right);
 248 
 249     int32_t WARN_UNUSED_RETURN fixupPointerPlusOffset(ExpressionType&amp;, uint32_t);
 250 
 251     void restoreWasmContextInstance(Procedure&amp;, BasicBlock*, Value*);
 252     enum class RestoreCachedStackLimit { No, Yes };
 253     void restoreWebAssemblyGlobalState(RestoreCachedStackLimit, const MemoryInformation&amp;, Value* instance, Procedure&amp;, BasicBlock*);
 254 
 255     Origin origin();
 256 







 257     FunctionParser&lt;B3IRGenerator&gt;* m_parser { nullptr };
 258     const ModuleInformation&amp; m_info;
 259     const MemoryMode m_mode { MemoryMode::BoundsChecking };
 260     const CompilationMode m_compilationMode { CompilationMode::BBQMode };
 261     const unsigned m_functionIndex { UINT_MAX };
<span class="line-modified"> 262     const TierUpCount* m_tierUp { nullptr };</span>

 263 
 264     Procedure&amp; m_proc;

 265     BasicBlock* m_currentBlock { nullptr };

 266     Vector&lt;Variable*&gt; m_locals;
 267     Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.

 268     HashMap&lt;ValueKey, Value*&gt; m_constantPool;
 269     InsertionSet m_constantInsertionValues;
 270     GPRReg m_memoryBaseGPR { InvalidGPRReg };
 271     GPRReg m_memorySizeGPR { InvalidGPRReg };
 272     GPRReg m_wasmContextInstanceGPR { InvalidGPRReg };
 273     bool m_makesCalls { false };
 274 
 275     Value* m_instanceValue { nullptr }; // Always use the accessor below to ensure the instance value is materialized when used.
 276     bool m_usesInstanceValue { false };
 277     Value* instanceValue()
 278     {
 279         m_usesInstanceValue = true;
 280         return m_instanceValue;
 281     }
 282 
 283     uint32_t m_maxNumJSCallArguments { 0 };

 284 };
 285 
 286 // Memory accesses in WebAssembly have unsigned 32-bit offsets, whereas they have signed 32-bit offsets in B3.
 287 int32_t B3IRGenerator::fixupPointerPlusOffset(ExpressionType&amp; ptr, uint32_t offset)
 288 {
 289     if (static_cast&lt;uint64_t&gt;(offset) &gt; static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max())) {
 290         ptr = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), ptr, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), offset));
 291         return 0;
 292     }
 293     return offset;
 294 }
 295 
 296 void B3IRGenerator::restoreWasmContextInstance(Procedure&amp; proc, BasicBlock* block, Value* arg)
 297 {
 298     if (Context::useFastTLS()) {
 299         PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 300         if (CCallHelpers::storeWasmContextInstanceNeedsMacroScratchRegister())
 301             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 302         patchpoint-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
 303         patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
 306                 jit.storeWasmContextInstance(params[0].gpr());
 307             });
 308         return;
 309     }
 310 
 311     // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 312     // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 313     PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 314     Effects effects = Effects::none();
 315     effects.writesPinned = true;
 316     effects.reads = B3::HeapRange::top();
 317     patchpoint-&gt;effects = effects;
 318     patchpoint-&gt;clobberLate(RegisterSet(m_wasmContextInstanceGPR));
 319     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
 320     GPRReg wasmContextInstanceGPR = m_wasmContextInstanceGPR;
 321     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
 322         jit.move(param[0].gpr(), wasmContextInstanceGPR);
 323     });
 324 }
 325 
<span class="line-modified"> 326 B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
 327     : m_info(info)
 328     , m_mode(mode)
 329     , m_compilationMode(compilationMode)
 330     , m_functionIndex(functionIndex)

 331     , m_tierUp(tierUp)
 332     , m_proc(procedure)
 333     , m_unlinkedWasmToWasmCalls(unlinkedWasmToWasmCalls)

 334     , m_constantInsertionValues(m_proc)

 335 {
<span class="line-modified"> 336     m_currentBlock = m_proc.addBlock();</span>

 337 
 338     // FIXME we don&#39;t really need to pin registers here if there&#39;s no memory. It makes wasm -&gt; wasm thunks simpler for now. https://bugs.webkit.org/show_bug.cgi?id=166623
 339     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
 340 
 341     m_memoryBaseGPR = pinnedRegs.baseMemoryPointer;
 342     m_proc.pinRegister(m_memoryBaseGPR);
 343 
 344     m_wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
 345     if (!Context::useFastTLS())
 346         m_proc.pinRegister(m_wasmContextInstanceGPR);
 347 
 348     if (mode != MemoryMode::Signaling) {
<span class="line-modified"> 349         ASSERT(!pinnedRegs.sizeRegisters[0].sizeOffset);</span>
<span class="line-modified"> 350         m_memorySizeGPR = pinnedRegs.sizeRegisters[0].sizeRegister;</span>
<span class="line-removed"> 351         for (const PinnedSizeRegisterInfo&amp; regInfo : pinnedRegs.sizeRegisters)</span>
<span class="line-removed"> 352             m_proc.pinRegister(regInfo.sizeRegister);</span>
 353     }
 354 
 355     if (throwWasmException)
 356         Thunks::singleton().setThrowWasmException(throwWasmException);
 357 
 358     if (info.memory) {
 359         m_proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
 360             AllowMacroScratchRegisterUsage allowScratch(jit);
 361             switch (m_mode) {
 362             case MemoryMode::BoundsChecking:
 363                 ASSERT_UNUSED(pinnedGPR, m_memorySizeGPR == pinnedGPR);
 364                 break;
 365             case MemoryMode::Signaling:
 366                 ASSERT_UNUSED(pinnedGPR, InvalidGPRReg == pinnedGPR);
 367                 break;
 368             }
 369             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
 370         });
 371 
 372         switch (m_mode) {
</pre>
<hr />
<pre>
 379             // thunk to exist so that it can jump to that thunk.
 380             if (UNLIKELY(!Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator)))
 381                 CRASH();
 382             break;
 383         }
 384     }
 385 
 386     wasmCallingConvention().setupFrameInPrologue(&amp;compilation-&gt;calleeMoveLocation, m_proc, Origin(), m_currentBlock);
 387 
 388     {
 389         B3::Value* framePointer = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, Origin());
 390         B3::PatchpointValue* stackOverflowCheck = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, pointerType(), Origin());
 391         m_instanceValue = stackOverflowCheck;
 392         stackOverflowCheck-&gt;appendSomeRegister(framePointer);
 393         stackOverflowCheck-&gt;clobber(RegisterSet::macroScratchRegisters());
 394         if (!Context::useFastTLS()) {
 395             // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 396             // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 397             stackOverflowCheck-&gt;effects.writesPinned = false;
 398             stackOverflowCheck-&gt;effects.readsPinned = true;
<span class="line-modified"> 399             stackOverflowCheck-&gt;resultConstraint = ValueRep::reg(m_wasmContextInstanceGPR);</span>
 400         }
 401         stackOverflowCheck-&gt;numGPScratchRegisters = 2;
 402         stackOverflowCheck-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
 403             const Checked&lt;int32_t&gt; wasmFrameSize = params.proc().frameSize();
 404             const unsigned minimumParentCheckSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), 1024);
 405             const unsigned extraFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), std::max&lt;uint32_t&gt;(
 406                 // This allows us to elide stack checks for functions that are terminal nodes in the call
 407                 // tree, (e.g they don&#39;t make any calls) and have a small enough frame size. This works by
 408                 // having any such terminal node have its parent caller include some extra size in its
 409                 // own check for it. The goal here is twofold:
 410                 // 1. Emit less code.
 411                 // 2. Try to speed things up by skipping stack checks.
 412                 minimumParentCheckSize,
 413                 // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
 414                 // spill all arguments to the stack, we ensure that a stack check here covers the
 415                 // stack that such a stub would use.
 416                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jscCallingConvention().headerSizeInBytes()).unsafeGet()
 417             ));
 418             const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
 419             bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
</pre>
<hr />
<pre>
 434 
 435                 jit.loadPtr(CCallHelpers::Address(contextInstance, Instance::offsetOfCachedStackLimit()), scratch2);
 436                 jit.addPtr(CCallHelpers::TrustedImm32(-checkSize), fp, scratch1);
 437                 MacroAssembler::JumpList overflow;
 438                 if (UNLIKELY(needUnderflowCheck))
 439                     overflow.append(jit.branchPtr(CCallHelpers::Above, scratch1, fp));
 440                 overflow.append(jit.branchPtr(CCallHelpers::Below, scratch1, scratch2));
 441                 jit.addLinkTask([overflow] (LinkBuffer&amp; linkBuffer) {
 442                     linkBuffer.link(overflow, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwStackOverflowFromWasmThunkGenerator).code()));
 443                 });
 444             } else if (m_usesInstanceValue &amp;&amp; Context::useFastTLS()) {
 445                 // No overflow check is needed, but the instance values still needs to be correct.
 446                 AllowMacroScratchRegisterUsageIf allowScratch(jit, CCallHelpers::loadWasmContextInstanceNeedsMacroScratchRegister());
 447                 jit.loadWasmContextInstance(contextInstance);
 448             } else {
 449                 // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
 450             }
 451         });
 452     }
 453 
<span class="line-modified"> 454     emitTierUpCheck(TierUpCount::functionEntryDecrement(), Origin());</span>



 455 }
 456 
 457 void B3IRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, Value* instance, Procedure&amp; proc, BasicBlock* block)
 458 {
 459     restoreWasmContextInstance(proc, block, instance);
 460 
 461     if (restoreCachedStackLimit == RestoreCachedStackLimit::Yes) {
 462         // The Instance caches the stack limit, but also knows where its canonical location is.
 463         Value* pointerToActualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfPointerToActualStackLimit()));
 464         Value* actualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), pointerToActualStackLimit);
 465         block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), actualStackLimit, instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfCachedStackLimit()));
 466     }
 467 
 468     if (!!memory) {
 469         const PinnedRegisterInfo* pinnedRegs = &amp;PinnedRegisterInfo::get();
 470         RegisterSet clobbers;
 471         clobbers.set(pinnedRegs-&gt;baseMemoryPointer);
<span class="line-modified"> 472         for (auto info : pinnedRegs-&gt;sizeRegisters)</span>
<span class="line-modified"> 473             clobbers.set(info.sizeRegister);</span>

 474 
 475         B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Void, origin());
 476         Effects effects = Effects::none();
 477         effects.writesPinned = true;
 478         effects.reads = B3::HeapRange::top();
 479         patchpoint-&gt;effects = effects;
 480         patchpoint-&gt;clobber(clobbers);

 481 
 482         patchpoint-&gt;append(instance, ValueRep::SomeRegister);
<span class="line-removed"> 483 </span>
 484         patchpoint-&gt;setGenerator([pinnedRegs] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {

 485             GPRReg baseMemory = pinnedRegs-&gt;baseMemoryPointer;
<span class="line-modified"> 486             const auto&amp; sizeRegs = pinnedRegs-&gt;sizeRegisters;</span>
<span class="line-modified"> 487             ASSERT(sizeRegs.size() &gt;= 1);</span>
<span class="line-modified"> 488             ASSERT(!sizeRegs[0].sizeOffset); // The following code assumes we start at 0, and calculates subsequent size registers relative to 0.</span>
<span class="line-removed"> 489             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister);</span>
 490             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemory()), baseMemory);
<span class="line-modified"> 491             for (unsigned i = 1; i &lt; sizeRegs.size(); ++i)</span>
<span class="line-modified"> 492                 jit.add64(CCallHelpers::TrustedImm32(-sizeRegs[i].sizeOffset), sizeRegs[0].sizeRegister, sizeRegs[i].sizeRegister);</span>
 493         });
 494     }
 495 }
 496 
 497 void B3IRGenerator::emitExceptionCheck(CCallHelpers&amp; jit, ExceptionType type)
 498 {
 499     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;uint32_t&gt;(type)), GPRInfo::argumentGPR1);
 500     auto jumpToExceptionStub = jit.jump();
 501 
 502     jit.addLinkTask([jumpToExceptionStub] (LinkBuffer&amp; linkBuffer) {
 503         linkBuffer.link(jumpToExceptionStub, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator).code()));
 504     });
 505 }
 506 
 507 Value* B3IRGenerator::constant(B3::Type type, uint64_t bits, Optional&lt;Origin&gt; maybeOrigin)
 508 {
 509     auto result = m_constantPool.ensure(ValueKey(opcodeForConstant(type), type, static_cast&lt;int64_t&gt;(bits)), [&amp;] {
 510         Value* result = m_proc.addConstant(maybeOrigin ? *maybeOrigin : origin(), type, bits);
 511         m_constantInsertionValues.insertValue(0, result);
 512         return result;
 513     });
 514     return result.iterator-&gt;value;
 515 }
 516 
 517 void B3IRGenerator::insertConstants()
 518 {
 519     m_constantInsertionValues.execute(m_proc.at(0));
 520 }
 521 
 522 auto B3IRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
 523 {
<span class="line-modified"> 524     Checked&lt;uint32_t, RecordOverflow&gt; totalBytesChecked = count;</span>
<span class="line-modified"> 525     totalBytesChecked += m_locals.size();</span>
<span class="line-modified"> 526     uint32_t totalBytes;</span>
<span class="line-modified"> 527     WASM_COMPILE_FAIL_IF((totalBytesChecked.safeGet(totalBytes) == CheckedState::DidOverflow) || !m_locals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; locals&quot;);</span>
 528 
 529     for (uint32_t i = 0; i &lt; count; ++i) {
 530         Variable* local = m_proc.addVariable(toB3Type(type));
 531         m_locals.uncheckedAppend(local);
<span class="line-modified"> 532         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, constant(toB3Type(type), 0, Origin()));</span>

 533     }
 534     return { };
 535 }
 536 
 537 auto B3IRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
 538 {
 539     ASSERT(!m_locals.size());
 540     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(signature.argumentCount()), &quot;can&#39;t allocate memory for &quot;, signature.argumentCount(), &quot; arguments&quot;);
 541 
 542     m_locals.grow(signature.argumentCount());
 543     wasmCallingConvention().loadArguments(signature, m_proc, m_currentBlock, Origin(),
 544         [=] (ExpressionType argument, unsigned i) {
 545             Variable* argumentVariable = m_proc.addVariable(argument-&gt;type());
 546             m_locals[i] = argumentVariable;
 547             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);
 548         });
 549     return { };
 550 }
 551 
































































































 552 auto B3IRGenerator::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 553 {
 554     ASSERT(m_locals[index]);
 555     result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin(), m_locals[index]);
 556     return { };
 557 }
 558 
 559 auto B3IRGenerator::addUnreachable() -&gt; PartialResult
 560 {
 561     B3::PatchpointValue* unreachable = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());
 562     unreachable-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 563         this-&gt;emitExceptionCheck(jit, ExceptionType::Unreachable);
 564     });
 565     unreachable-&gt;effects.terminal = true;
 566     return { };
 567 }
 568 
 569 auto B3IRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
 570 {
 571     int32_t (*growMemory)(void*, Instance*, int32_t) = [] (void* callFrame, Instance* instance, int32_t delta) -&gt; int32_t {
</pre>
<hr />
<pre>
 615 
 616 auto B3IRGenerator::setLocal(uint32_t index, ExpressionType value) -&gt; PartialResult
 617 {
 618     ASSERT(m_locals[index]);
 619     m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Set, origin(), m_locals[index], value);
 620     return { };
 621 }
 622 
 623 auto B3IRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 624 {
 625     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 626     result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(m_info.globals[index].type), origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
 627     return { };
 628 }
 629 
 630 auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
 631 {
 632     ASSERT(toB3Type(m_info.globals[index].type) == value-&gt;type());
 633     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 634     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));




 635     return { };
 636 }
 637 




















































 638 inline Value* B3IRGenerator::emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOperation)
 639 {
 640     ASSERT(m_memoryBaseGPR);
 641 
 642     switch (m_mode) {
 643     case MemoryMode::BoundsChecking: {
 644         // We&#39;re not using signal handling at all, we must therefore check that no memory access exceeds the current memory size.
 645         ASSERT(m_memorySizeGPR);
 646         ASSERT(sizeOfOperation + offset &gt; offset);
 647         m_currentBlock-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(m_proc, origin(), m_memorySizeGPR, pointer, sizeOfOperation + offset - 1);
 648         break;
 649     }
 650 
 651     case MemoryMode::Signaling: {
 652         // We&#39;ve virtually mapped 4GiB+redzone for this memory. Only the user-allocated pages are addressable, contiguously in range [0, current],
 653         // and everything above is mapped PROT_NONE. We don&#39;t need to perform any explicit bounds check in the 4GiB range because WebAssembly register
 654         // memory accesses are 32-bit. However WebAssembly register + offset accesses perform the addition in 64-bit which can push an access above
 655         // the 32-bit limit (the offset is unsigned 32-bit). The redzone will catch most small offsets, and we&#39;ll explicitly bounds check any
 656         // register + large offset access. We don&#39;t think this will be generated frequently.
 657         //
</pre>
<hr />
<pre>
 883         throwException-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 884             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
 885         });
 886     } else
 887         emitStoreOp(op, emitCheckAndPreparePointer(pointer, offset, sizeOfStoreOp(op)), value, offset);
 888 
 889     return { };
 890 }
 891 
 892 auto B3IRGenerator::addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result) -&gt; PartialResult
 893 {
 894     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Select, origin(), condition, nonZero, zero);
 895     return { };
 896 }
 897 
 898 B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
 899 {
 900     return constant(toB3Type(type), value);
 901 }
 902 
<span class="line-modified"> 903 void B3IRGenerator::emitTierUpCheck(uint32_t decrementCount, Origin origin)</span>
 904 {
 905     if (!m_tierUp)
 906         return;
 907 
 908     ASSERT(m_tierUp);
<span class="line-modified"> 909     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(m_tierUp), origin);</span>
<span class="line-removed"> 910     Value* oldCountDown = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin, countDownLocation);</span>
<span class="line-removed"> 911     Value* newCountDown = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Sub, origin, oldCountDown, constant(Int32, decrementCount, origin));</span>
<span class="line-removed"> 912     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin, newCountDown, countDownLocation);</span>
 913 
 914     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
 915     Effects effects = Effects::none();
 916     // FIXME: we should have a more precise heap range for the tier up count.
 917     effects.reads = B3::HeapRange::top();
 918     effects.writes = B3::HeapRange::top();
 919     patch-&gt;effects = effects;

 920 
<span class="line-modified"> 921     patch-&gt;append(newCountDown, ValueRep::SomeRegister);</span>
<span class="line-removed"> 922     patch-&gt;append(oldCountDown, ValueRep::SomeRegister);</span>
 923     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<span class="line-modified"> 924         MacroAssembler::Jump tierUp = jit.branch32(MacroAssembler::Above, params[0].gpr(), params[1].gpr());</span>
<span class="line-modified"> 925         MacroAssembler::Label tierUpResume = jit.label();</span>

 926 
 927         params.addLatePath([=] (CCallHelpers&amp; jit) {
 928             tierUp.link(&amp;jit);
 929 
 930             const unsigned extraPaddingBytes = 0;
 931             RegisterSet registersToSpill = { };
 932             registersToSpill.add(GPRInfo::argumentGPR1);
 933             unsigned numberOfStackBytesUsedForRegisterPreservation = ScratchRegisterAllocator::preserveRegistersToStackForCall(jit, registersToSpill, extraPaddingBytes);
 934 
 935             jit.move(MacroAssembler::TrustedImm32(m_functionIndex), GPRInfo::argumentGPR1);
 936             MacroAssembler::Call call = jit.nearCall();
 937 
 938             ScratchRegisterAllocator::restoreRegistersFromStackForCall(jit, registersToSpill, RegisterSet(), numberOfStackBytesUsedForRegisterPreservation, extraPaddingBytes);
 939             jit.jump(tierUpResume);
 940 
 941             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified"> 942                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGTierUpThunkGenerator).code()));</span>
<span class="line-removed"> 943 </span>
 944             });
 945         });
 946     });
 947 }
 948 
<span class="line-modified"> 949 B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature)</span>




































































 950 {
 951     BasicBlock* body = m_proc.addBlock();
 952     BasicBlock* continuation = m_proc.addBlock();
 953 
 954     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
































 955 


 956     m_currentBlock = body;
<span class="line-modified"> 957     emitTierUpCheck(TierUpCount::loopDecrement(), origin());</span>
 958 
 959     return ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);
 960 }
 961 
 962 B3IRGenerator::ControlData B3IRGenerator::addTopLevel(Type signature)
 963 {
 964     return ControlData(m_proc, Origin(), signature, BlockType::TopLevel, m_proc.addBlock());
 965 }
 966 
 967 B3IRGenerator::ControlData B3IRGenerator::addBlock(Type signature)
 968 {
 969     return ControlData(m_proc, origin(), signature, BlockType::Block, m_proc.addBlock());
 970 }
 971 
 972 auto B3IRGenerator::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; PartialResult
 973 {
 974     // FIXME: This needs to do some kind of stack passing.
 975 
 976     BasicBlock* taken = m_proc.addBlock();
 977     BasicBlock* notTaken = m_proc.addBlock();
 978     BasicBlock* continuation = m_proc.addBlock();
 979 
 980     m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
 981     m_currentBlock-&gt;setSuccessors(FrequentedBlock(taken), FrequentedBlock(notTaken));
 982     taken-&gt;addPredecessor(m_currentBlock);
 983     notTaken-&gt;addPredecessor(m_currentBlock);
 984 
 985     m_currentBlock = taken;
 986     result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
 987     return { };
 988 }
 989 
<span class="line-modified"> 990 auto B3IRGenerator::addElse(ControlData&amp; data, const ExpressionList&amp; currentStack) -&gt; PartialResult</span>
 991 {
 992     unifyValuesWithBlock(currentStack, data.result);
 993     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
 994     return addElseToUnreachable(data);
 995 }
 996 
 997 auto B3IRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
 998 {
 999     ASSERT(data.type() == BlockType::If);
1000     m_currentBlock = data.special;
1001     data.convertIfToBlock();
1002     return { };
1003 }
1004 
1005 auto B3IRGenerator::addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues) -&gt; PartialResult
1006 {
1007     ASSERT(returnValues.size() &lt;= 1);
1008     if (returnValues.size())
1009         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin(), returnValues[0]);
1010     else
1011         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin());
1012     return { };
1013 }
1014 
<span class="line-modified">1015 auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const ExpressionList&amp; returnValues) -&gt; PartialResult</span>
1016 {
1017     unifyValuesWithBlock(returnValues, data.resultForBranch());
1018 
1019     BasicBlock* target = data.targetBlockForBranch();
1020     if (condition) {
1021         BasicBlock* continuation = m_proc.addBlock();
1022         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
1023         m_currentBlock-&gt;setSuccessors(FrequentedBlock(target), FrequentedBlock(continuation));
1024         target-&gt;addPredecessor(m_currentBlock);
1025         continuation-&gt;addPredecessor(m_currentBlock);
1026         m_currentBlock = continuation;
1027     } else {
1028         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), FrequentedBlock(target));
1029         target-&gt;addPredecessor(m_currentBlock);
1030     }
1031 
1032     return { };
1033 }
1034 
<span class="line-modified">1035 auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
1036 {
1037     for (size_t i = 0; i &lt; targets.size(); ++i)
1038         unifyValuesWithBlock(expressionStack, targets[i]-&gt;resultForBranch());
1039     unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());
1040 
1041     SwitchValue* switchValue = m_currentBlock-&gt;appendNew&lt;SwitchValue&gt;(m_proc, origin(), condition);
1042     switchValue-&gt;setFallThrough(FrequentedBlock(defaultTarget.targetBlockForBranch()));
1043     for (size_t i = 0; i &lt; targets.size(); ++i)
1044         switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
1045 
1046     return { };
1047 }
1048 
<span class="line-modified">1049 auto B3IRGenerator::endBlock(ControlEntry&amp; entry, ExpressionList&amp; expressionStack) -&gt; PartialResult</span>
1050 {
1051     ControlData&amp; data = entry.controlData;
1052 
1053     unifyValuesWithBlock(expressionStack, data.result);
1054     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
1055     data.continuation-&gt;addPredecessor(m_currentBlock);
1056 



1057     return addEndToUnreachable(entry);
1058 }
1059 
1060 
1061 auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult
1062 {
1063     ControlData&amp; data = entry.controlData;
1064     m_currentBlock = data.continuation;
1065 
1066     if (data.type() == BlockType::If) {
1067         data.special-&gt;appendNewControlValue(m_proc, Jump, origin(), m_currentBlock);
1068         m_currentBlock-&gt;addPredecessor(data.special);
1069     }
1070 
1071     for (Value* result : data.result) {
1072         m_currentBlock-&gt;append(result);
1073         entry.enclosedExpressionStack.append(result);
1074     }
1075 
1076     // TopLevel does not have any code after this so we need to make sure we emit a return here.
1077     if (data.type() == BlockType::TopLevel)
<span class="line-modified">1078         return addReturn(entry.controlData, entry.enclosedExpressionStack);</span>
1079 
1080     return { };
1081 }
1082 
1083 auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult
1084 {
1085     ASSERT(signature.argumentCount() == args.size());
1086 
1087     m_makesCalls = true;
1088 
1089     Type returnType = signature.returnType();
1090     Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
1091 
1092     if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
1093         m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1094 
1095         // FIXME imports can be linked here, instead of generating a patchpoint, because all import stubs are generated before B3 compilation starts. https://bugs.webkit.org/show_bug.cgi?id=166462
1096         Value* targetInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTargetInstance(functionIndex)));
1097         // The target instance is 0 unless the call is wasm-&gt;wasm.
1098         Value* isWasmCall = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), targetInstance, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0));
</pre>
<hr />
<pre>
1159         restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, continuation);
1160     } else {
1161         result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1162             [=] (PatchpointValue* patchpoint) {
1163                 patchpoint-&gt;effects.writesPinned = true;
1164                 patchpoint-&gt;effects.readsPinned = true;
1165 
1166                 patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1167                     AllowMacroScratchRegisterUsage allowScratch(jit);
1168                     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
1169                     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
1170                         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
1171                     });
1172                 });
1173             });
1174     }
1175 
1176     return { };
1177 }
1178 
<span class="line-modified">1179 auto B3IRGenerator::addCallIndirect(const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
1180 {
1181     ExpressionType calleeIndex = args.takeLast();
1182     ASSERT(signature.argumentCount() == args.size());
1183 
1184     m_makesCalls = true;
1185     // Note: call indirect can call either WebAssemblyFunction or WebAssemblyWrapperFunction. Because
1186     // WebAssemblyWrapperFunction is like calling into the embedder, we conservatively assume all call indirects
1187     // can be to the embedder for our stack check calculation.
1188     m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1189 
1190     ExpressionType callableFunctionBuffer;
1191     ExpressionType instancesBuffer;
1192     ExpressionType callableFunctionBufferLength;
1193     ExpressionType mask;
1194     {
1195         ExpressionType table = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1196             instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTable()));</span>
1197         callableFunctionBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1198             table, safeCast&lt;int32_t&gt;(Table::offsetOfFunctions()));</span>
1199         instancesBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1200             table, safeCast&lt;int32_t&gt;(Table::offsetOfInstances()));</span>
1201         callableFunctionBufferLength = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1202             table, safeCast&lt;int32_t&gt;(Table::offsetOfLength()));
1203         mask = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(),
1204             m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1205                 table, safeCast&lt;int32_t&gt;(Table::offsetOfMask())));
1206     }
1207 
1208     // Check the index we are looking for is valid.
1209     {
1210         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1211             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, AboveEqual, origin(), calleeIndex, callableFunctionBufferLength));
1212 
1213         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1214             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsCallIndirect);
1215         });
1216     }
1217 
1218     calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), calleeIndex);
1219 
1220     if (Options::enableSpectreMitigations())
</pre>
<hr />
<pre>
1260             calleeIndex, constant(pointerType(), sizeof(Instance*)));
1261         Value* newContextInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1262             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), instancesBuffer, offset));
1263 
1264         BasicBlock* continuation = m_proc.addBlock();
1265         BasicBlock* doContextSwitch = m_proc.addBlock();
1266 
1267         Value* isSameContextInstance = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(),
1268             newContextInstance, instanceValue());
1269         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),
1270             isSameContextInstance, FrequentedBlock(continuation), FrequentedBlock(doContextSwitch));
1271 
1272         PatchpointValue* patchpoint = doContextSwitch-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin());
1273         patchpoint-&gt;effects.writesPinned = true;
1274         // We pessimistically assume we&#39;re calling something with BoundsChecking memory.
1275         // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
1276         patchpoint-&gt;clobber(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1277         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1278         patchpoint-&gt;append(newContextInstance, ValueRep::SomeRegister);
1279         patchpoint-&gt;append(instanceValue(), ValueRep::SomeRegister);


1280         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1281             AllowMacroScratchRegisterUsage allowScratch(jit);
1282             GPRReg newContextInstance = params[0].gpr();
1283             GPRReg oldContextInstance = params[1].gpr();
1284             const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
<span class="line-removed">1285             const auto&amp; sizeRegs = pinnedRegs.sizeRegisters;</span>
1286             GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
1287             ASSERT(newContextInstance != baseMemory);
1288             jit.loadPtr(CCallHelpers::Address(oldContextInstance, Instance::offsetOfCachedStackLimit()), baseMemory);
1289             jit.storePtr(baseMemory, CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedStackLimit()));
1290             jit.storeWasmContextInstance(newContextInstance);
<span class="line-modified">1291             ASSERT(sizeRegs[0].sizeRegister != baseMemory);</span>
1292             // FIXME: We should support more than one memory size register
1293             //   see: https://bugs.webkit.org/show_bug.cgi?id=162952
<span class="line-modified">1294             ASSERT(sizeRegs.size() == 1);</span>
<span class="line-modified">1295             ASSERT(sizeRegs[0].sizeRegister != newContextInstance);</span>
<span class="line-modified">1296             ASSERT(!sizeRegs[0].sizeOffset);</span>
<span class="line-modified">1297             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), sizeRegs[0].sizeRegister); // Memory size.</span>
1298             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemory()), baseMemory); // Memory::void*.


1299         });
1300         doContextSwitch-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
1301 
1302         m_currentBlock = continuation;
1303     }
1304 
1305     ExpressionType calleeCode = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1306         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), callableFunction,
1307             safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfEntrypointLoadLocation())));
1308 
1309     Type returnType = signature.returnType();
1310     result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1311         [=] (PatchpointValue* patchpoint) {
1312             patchpoint-&gt;effects.writesPinned = true;
1313             patchpoint-&gt;effects.readsPinned = true;
1314             // We need to clobber all potential pinned registers since we might be leaving the instance.
1315             // We pessimistically assume we&#39;re always calling something that is bounds checking so
1316             // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
1317             // FIXME: We should not have to do this, but the wasm-&gt;wasm stub assumes it can
1318             // use all the pinned registers as scratch: https://bugs.webkit.org/show_bug.cgi?id=172181
1319             patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1320 
1321             patchpoint-&gt;append(calleeCode, ValueRep::SomeRegister);
1322             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1323                 AllowMacroScratchRegisterUsage allowScratch(jit);
1324                 jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);
1325             });
1326         });
1327 
1328     // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
1329     restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, m_currentBlock);
1330 
1331     return { };
1332 }
1333 
1334 void B3IRGenerator::unify(const ExpressionType phi, const ExpressionType source)
1335 {
1336     m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), source, phi);
1337 }
1338 
<span class="line-modified">1339 void B3IRGenerator::unifyValuesWithBlock(const ExpressionList&amp; resultStack, const ResultList&amp; result)</span>
1340 {
1341     ASSERT(result.size() &lt;= resultStack.size());
1342 
1343     for (size_t i = 0; i &lt; result.size(); ++i)
<span class="line-modified">1344         unify(result[result.size() - 1 - i], resultStack[resultStack.size() - 1 - i]);</span>
<span class="line-removed">1345 }</span>
<span class="line-removed">1346 </span>
<span class="line-removed">1347 static void dumpExpressionStack(const CommaPrinter&amp; comma, const B3IRGenerator::ExpressionList&amp; expressionStack)</span>
<span class="line-removed">1348 {</span>
<span class="line-removed">1349     dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-removed">1350     for (const auto&amp; expression : expressionStack)</span>
<span class="line-removed">1351         dataLog(comma, *expression);</span>
1352 }
1353 
<span class="line-modified">1354 void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const ExpressionList* expressionStack)</span>
1355 {
1356     dataLogLn(&quot;Constants:&quot;);
1357     for (const auto&amp; constant : m_constantPool)
1358         dataLogLn(deepDump(m_proc, constant.value));
1359 
1360     dataLogLn(&quot;Processing Graph:&quot;);
1361     dataLog(m_proc);
1362     dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
1363     dataLogLn(&quot;Control stack:&quot;);
1364     ASSERT(controlStack.size());
1365     for (size_t i = controlStack.size(); i--;) {
1366         dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<span class="line-modified">1367         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-removed">1368         dumpExpressionStack(comma, *expressionStack);</span>
1369         expressionStack = &amp;controlStack[i].enclosedExpressionStack;
1370         dataLogLn();
1371     }
1372     dataLogLn();
1373 }
1374 
1375 auto B3IRGenerator::origin() -&gt; Origin
1376 {
1377     OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
1378     ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
1379     return bitwise_cast&lt;Origin&gt;(origin);
1380 }
1381 
<span class="line-modified">1382 Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
1383 {
<span class="line-modified">1384     auto result = std::make_unique&lt;InternalFunction&gt;();</span>
1385 
<span class="line-modified">1386     compilationContext.embedderEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
<span class="line-modified">1387     compilationContext.wasmEntrypointJIT = std::make_unique&lt;CCallHelpers&gt;();</span>
1388 
1389     Procedure procedure;
1390 
1391     procedure.setOriginPrinter([] (PrintStream&amp; out, Origin origin) {
1392         if (origin.data())
1393             out.print(&quot;Wasm: &quot;, bitwise_cast&lt;OpcodeOrigin&gt;(origin));
1394     });
1395 
1396     // This means we cannot use either StackmapGenerationParams::usedRegisters() or
1397     // StackmapGenerationParams::unavailableRegisters(). In exchange for this concession, we
1398     // don&#39;t strictly need to run Air::reportUsedRegisters(), which saves a bit of CPU time at
1399     // optLevel=1.
1400     procedure.setNeedsUsedRegisters(false);
1401 
1402     procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
<span class="line-modified">1403         ? Options::webAssemblyBBQOptimizationLevel()</span>
1404         : Options::webAssemblyOMGOptimizationLevel());
1405 
<span class="line-modified">1406     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, mode, compilationMode, functionIndex, tierUp, throwWasmException);</span>
1407     FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);
1408     WASM_FAIL_IF_HELPER_FAILS(parser.parse());
1409 
1410     irGenerator.insertConstants();
1411 
1412     procedure.resetReachability();
1413     if (!ASSERT_DISABLED)
1414         validate(procedure, &quot;After parsing:\n&quot;);
1415 
1416     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Pre SSA: &quot;, procedure);
1417     fixSSA(procedure);
1418     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Post SSA: &quot;, procedure);
1419 
1420     {
1421         B3::prepareForGeneration(procedure);
1422         B3::generate(procedure, *compilationContext.wasmEntrypointJIT);
1423         compilationContext.wasmEntrypointByproducts = procedure.releaseByproducts();
1424         result-&gt;entrypoint.calleeSaveRegisters = procedure.calleeSaveRegisterAtOffsetList();
1425     }
1426 
<span class="line-modified">1427     return WTFMove(result);</span>
1428 }
1429 
1430 // Custom wasm ops. These are the ones too messy to do in wasm.json.
1431 
1432 void B3IRGenerator::emitChecksForModOrDiv(B3::Opcode operation, ExpressionType left, ExpressionType right)
1433 {
1434     ASSERT(operation == Div || operation == Mod || operation == UDiv || operation == UMod);
1435     const B3::Type type = left-&gt;type();
1436 
1437     {
1438         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1439             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), right, constant(type, 0)));
1440 
1441         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1442             this-&gt;emitExceptionCheck(jit, ExceptionType::DivisionByZero);
1443         });
1444     }
1445 
1446     if (operation == Div) {
1447         int64_t min = type == Int32 ? std::numeric_limits&lt;int32_t&gt;::min() : std::numeric_limits&lt;int64_t&gt;::min();
</pre>
</td>
<td>
<hr />
<pre>
  30 
  31 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
  32 #include &quot;B3BasicBlockInlines.h&quot;
  33 #include &quot;B3CCallValue.h&quot;
  34 #include &quot;B3Compile.h&quot;
  35 #include &quot;B3ConstPtrValue.h&quot;
  36 #include &quot;B3FixSSA.h&quot;
  37 #include &quot;B3Generate.h&quot;
  38 #include &quot;B3InsertionSet.h&quot;
  39 #include &quot;B3SlotBaseValue.h&quot;
  40 #include &quot;B3StackmapGenerationParams.h&quot;
  41 #include &quot;B3SwitchValue.h&quot;
  42 #include &quot;B3UpsilonValue.h&quot;
  43 #include &quot;B3Validate.h&quot;
  44 #include &quot;B3ValueInlines.h&quot;
  45 #include &quot;B3ValueKey.h&quot;
  46 #include &quot;B3Variable.h&quot;
  47 #include &quot;B3VariableValue.h&quot;
  48 #include &quot;B3WasmAddressValue.h&quot;
  49 #include &quot;B3WasmBoundsCheckValue.h&quot;
<span class="line-added">  50 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;</span>
  51 #include &quot;JSCInlines.h&quot;
<span class="line-added">  52 #include &quot;JSWebAssemblyInstance.h&quot;</span>
  53 #include &quot;ScratchRegisterAllocator.h&quot;
  54 #include &quot;VirtualRegister.h&quot;
  55 #include &quot;WasmCallingConvention.h&quot;
  56 #include &quot;WasmContextInlines.h&quot;
  57 #include &quot;WasmExceptionType.h&quot;
  58 #include &quot;WasmFunctionParser.h&quot;
  59 #include &quot;WasmInstance.h&quot;
  60 #include &quot;WasmMemory.h&quot;
  61 #include &quot;WasmOMGPlan.h&quot;
<span class="line-added">  62 #include &quot;WasmOSREntryData.h&quot;</span>
  63 #include &quot;WasmOpcodeOrigin.h&quot;
<span class="line-added">  64 #include &quot;WasmOperations.h&quot;</span>
  65 #include &quot;WasmSignatureInlines.h&quot;
  66 #include &quot;WasmThunks.h&quot;
  67 #include &lt;limits&gt;
  68 #include &lt;wtf/Optional.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 
  71 void dumpProcedure(void* ptr)
  72 {
  73     JSC::B3::Procedure* proc = static_cast&lt;JSC::B3::Procedure*&gt;(ptr);
  74     proc-&gt;dump(WTF::dataFile());
  75 }
  76 
  77 namespace JSC { namespace Wasm {
  78 
  79 using namespace B3;
  80 
  81 namespace {
  82 namespace WasmB3IRGeneratorInternal {
  83 static const bool verbose = false;
  84 }
</pre>
<hr />
<pre>
 142         }
 143 
 144         using ResultList = Vector&lt;Value*, 1&gt;; // Value must be a Phi
 145 
 146         ResultList resultForBranch() const
 147         {
 148             if (type() == BlockType::Loop)
 149                 return ResultList();
 150             return result;
 151         }
 152 
 153     private:
 154         friend class B3IRGenerator;
 155         BlockType blockType;
 156         BasicBlock* continuation;
 157         BasicBlock* special;
 158         ResultList result;
 159     };
 160 
 161     typedef Value* ExpressionType;

 162     typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;
<span class="line-modified"> 163 </span>
<span class="line-modified"> 164     friend class Stack;</span>
<span class="line-added"> 165     class Stack {</span>
<span class="line-added"> 166     public:</span>
<span class="line-added"> 167         Stack(B3IRGenerator* generator)</span>
<span class="line-added"> 168             : m_generator(generator)</span>
<span class="line-added"> 169         {</span>
<span class="line-added"> 170         }</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172         void append(ExpressionType expression)</span>
<span class="line-added"> 173         {</span>
<span class="line-added"> 174             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 175                 Variable* variable = m_generator-&gt;m_proc.addVariable(expression-&gt;type());</span>
<span class="line-added"> 176                 m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, Set, m_generator-&gt;origin(), variable, expression);</span>
<span class="line-added"> 177                 m_stack.append(variable);</span>
<span class="line-added"> 178                 return;</span>
<span class="line-added"> 179             }</span>
<span class="line-added"> 180             m_data.append(expression);</span>
<span class="line-added"> 181         }</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183         ExpressionType takeLast()</span>
<span class="line-added"> 184         {</span>
<span class="line-added"> 185             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 186                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.takeLast());</span>
<span class="line-added"> 187             return m_data.takeLast();</span>
<span class="line-added"> 188         }</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190         ExpressionType last()</span>
<span class="line-added"> 191         {</span>
<span class="line-added"> 192             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 193                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.last());</span>
<span class="line-added"> 194             return m_data.last();</span>
<span class="line-added"> 195         }</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197         unsigned size() const</span>
<span class="line-added"> 198         {</span>
<span class="line-added"> 199             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 200                 return m_stack.size();</span>
<span class="line-added"> 201             return m_data.size();</span>
<span class="line-added"> 202         }</span>
<span class="line-added"> 203         bool isEmpty() const { return size() == 0; }</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205         ExpressionList convertToExpressionList()</span>
<span class="line-added"> 206         {</span>
<span class="line-added"> 207             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 208                 ExpressionList results;</span>
<span class="line-added"> 209                 for (unsigned i = 0; i &lt; m_stack.size(); ++i)</span>
<span class="line-added"> 210                     results.append(at(i));</span>
<span class="line-added"> 211                 return results;</span>
<span class="line-added"> 212             }</span>
<span class="line-added"> 213             return m_data;</span>
<span class="line-added"> 214         }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216         ExpressionType at(unsigned i) const</span>
<span class="line-added"> 217         {</span>
<span class="line-added"> 218             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 219                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.at(i));</span>
<span class="line-added"> 220             return m_data.at(i);</span>
<span class="line-added"> 221         }</span>
<span class="line-added"> 222 </span>
<span class="line-added"> 223         Variable* variableAt(unsigned i) const</span>
<span class="line-added"> 224         {</span>
<span class="line-added"> 225             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 226                 return m_stack.at(i);</span>
<span class="line-added"> 227             return nullptr;</span>
<span class="line-added"> 228         }</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230         void shrink(unsigned i)</span>
<span class="line-added"> 231         {</span>
<span class="line-added"> 232             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 233                 m_stack.shrink(i);</span>
<span class="line-added"> 234                 return;</span>
<span class="line-added"> 235             }</span>
<span class="line-added"> 236             m_data.shrink(i);</span>
<span class="line-added"> 237         }</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239         void swap(Stack&amp; stack)</span>
<span class="line-added"> 240         {</span>
<span class="line-added"> 241             std::swap(m_generator, stack.m_generator);</span>
<span class="line-added"> 242             m_data.swap(stack.m_data);</span>
<span class="line-added"> 243             m_stack.swap(stack.m_stack);</span>
<span class="line-added"> 244         }</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246         void dump() const</span>
<span class="line-added"> 247         {</span>
<span class="line-added"> 248             CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-added"> 249             dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-added"> 250             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-added"> 251                 for (const auto&amp; variable : m_stack)</span>
<span class="line-added"> 252                     dataLog(comma, *variable);</span>
<span class="line-added"> 253                 return;</span>
<span class="line-added"> 254             }</span>
<span class="line-added"> 255             for (const auto&amp; expression : m_data)</span>
<span class="line-added"> 256                 dataLog(comma, *expression);</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258 </span>
<span class="line-added"> 259     private:</span>
<span class="line-added"> 260         B3IRGenerator* m_generator { nullptr };</span>
<span class="line-added"> 261         ExpressionList m_data;</span>
<span class="line-added"> 262         Vector&lt;Variable*&gt; m_stack;</span>
<span class="line-added"> 263     };</span>
<span class="line-added"> 264     Stack createStack() { return Stack(this); }</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266     using ControlType = ControlData;</span>
<span class="line-added"> 267     using ResultList = ControlData::ResultList;</span>
<span class="line-added"> 268     using ControlEntry = FunctionParser&lt;B3IRGenerator&gt;::ControlEntry;</span>
 269 
 270     static constexpr ExpressionType emptyExpression() { return nullptr; }
 271 
 272     typedef String ErrorType;
 273     typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
 274     typedef Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt; Result;
 275     typedef Expected&lt;void, ErrorType&gt; PartialResult;
 276     template &lt;typename ...Args&gt;
 277     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
 278     {
 279         using namespace FailureHelper; // See ADL comment in WasmParser.h.
 280         return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
 281     }
 282 #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
 283         if (UNLIKELY(condition))                  \
 284             return fail(__VA_ARGS__);             \
 285     } while (0)
 286 
<span class="line-modified"> 287     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, unsigned&amp; osrEntryScratchBufferSize, MemoryMode, CompilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount*, ThrowWasmException);</span>
 288 
 289     PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
 290     PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
 291     ExpressionType addConstant(Type, uint64_t);
 292 
<span class="line-added"> 293     // References</span>
<span class="line-added"> 294     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
<span class="line-added"> 295     PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297     // Tables</span>
<span class="line-added"> 298     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="line-added"> 299     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
<span class="line-added"> 300     PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);</span>
<span class="line-added"> 301     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="line-added"> 302     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
 303     // Locals
 304     PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
 305     PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
 306 
 307     // Globals
 308     PartialResult WARN_UNUSED_RETURN getGlobal(uint32_t index, ExpressionType&amp; result);
 309     PartialResult WARN_UNUSED_RETURN setGlobal(uint32_t index, ExpressionType value);
 310 
 311     // Memory
 312     PartialResult WARN_UNUSED_RETURN load(LoadOpType, ExpressionType pointer, ExpressionType&amp; result, uint32_t offset);
 313     PartialResult WARN_UNUSED_RETURN store(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 314     PartialResult WARN_UNUSED_RETURN addGrowMemory(ExpressionType delta, ExpressionType&amp; result);
 315     PartialResult WARN_UNUSED_RETURN addCurrentMemory(ExpressionType&amp; result);
 316 
 317     // Basic operators
 318     template&lt;OpType&gt;
 319     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
 320     template&lt;OpType&gt;
 321     PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
 322     PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
 323 
 324     // Control flow
 325     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);
 326     ControlData WARN_UNUSED_RETURN addBlock(Type signature);
<span class="line-modified"> 327     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t);</span>
 328     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);
<span class="line-modified"> 329     PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);</span>
 330     PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
 331 
 332     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);
<span class="line-modified"> 333     PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);</span>
<span class="line-modified"> 334     PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);</span>
<span class="line-modified"> 335     PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);</span>
 336     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);
 337 
 338     // Calls
 339     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);
<span class="line-modified"> 340     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
 341     PartialResult WARN_UNUSED_RETURN addUnreachable();
 342 
<span class="line-modified"> 343     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
 344     void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
 345 
 346     Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
 347     void insertConstants();
 348 
 349     ALWAYS_INLINE void didKill(ExpressionType) { }
 350 
 351 private:
 352     void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
 353 
<span class="line-modified"> 354     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="line-added"> 355     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
 356 
<span class="line-added"> 357     void emitWriteBarrierForJSWrapper();</span>
 358     ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
 359     B3::Kind memoryKind(B3::Opcode memoryOp);
 360     ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
 361     void emitStoreOp(StoreOpType, ExpressionType pointer, ExpressionType value, uint32_t offset);
 362 
 363     void unify(const ExpressionType phi, const ExpressionType source);
<span class="line-modified"> 364     void unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; stack);</span>
 365 
 366     void emitChecksForModOrDiv(B3::Opcode, ExpressionType left, ExpressionType right);
 367 
 368     int32_t WARN_UNUSED_RETURN fixupPointerPlusOffset(ExpressionType&amp;, uint32_t);
 369 
 370     void restoreWasmContextInstance(Procedure&amp;, BasicBlock*, Value*);
 371     enum class RestoreCachedStackLimit { No, Yes };
 372     void restoreWebAssemblyGlobalState(RestoreCachedStackLimit, const MemoryInformation&amp;, Value* instance, Procedure&amp;, BasicBlock*);
 373 
 374     Origin origin();
 375 
<span class="line-added"> 376     uint32_t outerLoopIndex() const</span>
<span class="line-added"> 377     {</span>
<span class="line-added"> 378         if (m_outerLoops.isEmpty())</span>
<span class="line-added"> 379             return UINT32_MAX;</span>
<span class="line-added"> 380         return m_outerLoops.last();</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382 </span>
 383     FunctionParser&lt;B3IRGenerator&gt;* m_parser { nullptr };
 384     const ModuleInformation&amp; m_info;
 385     const MemoryMode m_mode { MemoryMode::BoundsChecking };
 386     const CompilationMode m_compilationMode { CompilationMode::BBQMode };
 387     const unsigned m_functionIndex { UINT_MAX };
<span class="line-modified"> 388     const unsigned m_loopIndexForOSREntry { UINT_MAX };</span>
<span class="line-added"> 389     TierUpCount* m_tierUp { nullptr };</span>
 390 
 391     Procedure&amp; m_proc;
<span class="line-added"> 392     BasicBlock* m_rootBlock { nullptr };</span>
 393     BasicBlock* m_currentBlock { nullptr };
<span class="line-added"> 394     Vector&lt;uint32_t&gt; m_outerLoops;</span>
 395     Vector&lt;Variable*&gt; m_locals;
 396     Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.
<span class="line-added"> 397     unsigned&amp; m_osrEntryScratchBufferSize;</span>
 398     HashMap&lt;ValueKey, Value*&gt; m_constantPool;
 399     InsertionSet m_constantInsertionValues;
 400     GPRReg m_memoryBaseGPR { InvalidGPRReg };
 401     GPRReg m_memorySizeGPR { InvalidGPRReg };
 402     GPRReg m_wasmContextInstanceGPR { InvalidGPRReg };
 403     bool m_makesCalls { false };
 404 
 405     Value* m_instanceValue { nullptr }; // Always use the accessor below to ensure the instance value is materialized when used.
 406     bool m_usesInstanceValue { false };
 407     Value* instanceValue()
 408     {
 409         m_usesInstanceValue = true;
 410         return m_instanceValue;
 411     }
 412 
 413     uint32_t m_maxNumJSCallArguments { 0 };
<span class="line-added"> 414     unsigned m_numImportFunctions;</span>
 415 };
 416 
 417 // Memory accesses in WebAssembly have unsigned 32-bit offsets, whereas they have signed 32-bit offsets in B3.
 418 int32_t B3IRGenerator::fixupPointerPlusOffset(ExpressionType&amp; ptr, uint32_t offset)
 419 {
 420     if (static_cast&lt;uint64_t&gt;(offset) &gt; static_cast&lt;uint64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max())) {
 421         ptr = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), ptr, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), offset));
 422         return 0;
 423     }
 424     return offset;
 425 }
 426 
 427 void B3IRGenerator::restoreWasmContextInstance(Procedure&amp; proc, BasicBlock* block, Value* arg)
 428 {
 429     if (Context::useFastTLS()) {
 430         PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 431         if (CCallHelpers::storeWasmContextInstanceNeedsMacroScratchRegister())
 432             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 433         patchpoint-&gt;append(ConstrainedValue(arg, ValueRep::SomeRegister));
 434         patchpoint-&gt;setGenerator(
</pre>
<hr />
<pre>
 437                 jit.storeWasmContextInstance(params[0].gpr());
 438             });
 439         return;
 440     }
 441 
 442     // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 443     // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 444     PatchpointValue* patchpoint = block-&gt;appendNew&lt;PatchpointValue&gt;(proc, B3::Void, Origin());
 445     Effects effects = Effects::none();
 446     effects.writesPinned = true;
 447     effects.reads = B3::HeapRange::top();
 448     patchpoint-&gt;effects = effects;
 449     patchpoint-&gt;clobberLate(RegisterSet(m_wasmContextInstanceGPR));
 450     patchpoint-&gt;append(arg, ValueRep::SomeRegister);
 451     GPRReg wasmContextInstanceGPR = m_wasmContextInstanceGPR;
 452     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
 453         jit.move(param[0].gpr(), wasmContextInstanceGPR);
 454     });
 455 }
 456 
<span class="line-modified"> 457 B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
 458     : m_info(info)
 459     , m_mode(mode)
 460     , m_compilationMode(compilationMode)
 461     , m_functionIndex(functionIndex)
<span class="line-added"> 462     , m_loopIndexForOSREntry(loopIndexForOSREntry)</span>
 463     , m_tierUp(tierUp)
 464     , m_proc(procedure)
 465     , m_unlinkedWasmToWasmCalls(unlinkedWasmToWasmCalls)
<span class="line-added"> 466     , m_osrEntryScratchBufferSize(osrEntryScratchBufferSize)</span>
 467     , m_constantInsertionValues(m_proc)
<span class="line-added"> 468     , m_numImportFunctions(info.importFunctionCount())</span>
 469 {
<span class="line-modified"> 470     m_rootBlock = m_proc.addBlock();</span>
<span class="line-added"> 471     m_currentBlock = m_rootBlock;</span>
 472 
 473     // FIXME we don&#39;t really need to pin registers here if there&#39;s no memory. It makes wasm -&gt; wasm thunks simpler for now. https://bugs.webkit.org/show_bug.cgi?id=166623
 474     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
 475 
 476     m_memoryBaseGPR = pinnedRegs.baseMemoryPointer;
 477     m_proc.pinRegister(m_memoryBaseGPR);
 478 
 479     m_wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
 480     if (!Context::useFastTLS())
 481         m_proc.pinRegister(m_wasmContextInstanceGPR);
 482 
 483     if (mode != MemoryMode::Signaling) {
<span class="line-modified"> 484         m_memorySizeGPR = pinnedRegs.sizeRegister;</span>
<span class="line-modified"> 485         m_proc.pinRegister(m_memorySizeGPR);</span>


 486     }
 487 
 488     if (throwWasmException)
 489         Thunks::singleton().setThrowWasmException(throwWasmException);
 490 
 491     if (info.memory) {
 492         m_proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
 493             AllowMacroScratchRegisterUsage allowScratch(jit);
 494             switch (m_mode) {
 495             case MemoryMode::BoundsChecking:
 496                 ASSERT_UNUSED(pinnedGPR, m_memorySizeGPR == pinnedGPR);
 497                 break;
 498             case MemoryMode::Signaling:
 499                 ASSERT_UNUSED(pinnedGPR, InvalidGPRReg == pinnedGPR);
 500                 break;
 501             }
 502             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
 503         });
 504 
 505         switch (m_mode) {
</pre>
<hr />
<pre>
 512             // thunk to exist so that it can jump to that thunk.
 513             if (UNLIKELY(!Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator)))
 514                 CRASH();
 515             break;
 516         }
 517     }
 518 
 519     wasmCallingConvention().setupFrameInPrologue(&amp;compilation-&gt;calleeMoveLocation, m_proc, Origin(), m_currentBlock);
 520 
 521     {
 522         B3::Value* framePointer = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, Origin());
 523         B3::PatchpointValue* stackOverflowCheck = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, pointerType(), Origin());
 524         m_instanceValue = stackOverflowCheck;
 525         stackOverflowCheck-&gt;appendSomeRegister(framePointer);
 526         stackOverflowCheck-&gt;clobber(RegisterSet::macroScratchRegisters());
 527         if (!Context::useFastTLS()) {
 528             // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
 529             // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
 530             stackOverflowCheck-&gt;effects.writesPinned = false;
 531             stackOverflowCheck-&gt;effects.readsPinned = true;
<span class="line-modified"> 532             stackOverflowCheck-&gt;resultConstraints = { ValueRep::reg(m_wasmContextInstanceGPR) };</span>
 533         }
 534         stackOverflowCheck-&gt;numGPScratchRegisters = 2;
 535         stackOverflowCheck-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
 536             const Checked&lt;int32_t&gt; wasmFrameSize = params.proc().frameSize();
 537             const unsigned minimumParentCheckSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), 1024);
 538             const unsigned extraFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), std::max&lt;uint32_t&gt;(
 539                 // This allows us to elide stack checks for functions that are terminal nodes in the call
 540                 // tree, (e.g they don&#39;t make any calls) and have a small enough frame size. This works by
 541                 // having any such terminal node have its parent caller include some extra size in its
 542                 // own check for it. The goal here is twofold:
 543                 // 1. Emit less code.
 544                 // 2. Try to speed things up by skipping stack checks.
 545                 minimumParentCheckSize,
 546                 // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
 547                 // spill all arguments to the stack, we ensure that a stack check here covers the
 548                 // stack that such a stub would use.
 549                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jscCallingConvention().headerSizeInBytes()).unsafeGet()
 550             ));
 551             const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
 552             bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
</pre>
<hr />
<pre>
 567 
 568                 jit.loadPtr(CCallHelpers::Address(contextInstance, Instance::offsetOfCachedStackLimit()), scratch2);
 569                 jit.addPtr(CCallHelpers::TrustedImm32(-checkSize), fp, scratch1);
 570                 MacroAssembler::JumpList overflow;
 571                 if (UNLIKELY(needUnderflowCheck))
 572                     overflow.append(jit.branchPtr(CCallHelpers::Above, scratch1, fp));
 573                 overflow.append(jit.branchPtr(CCallHelpers::Below, scratch1, scratch2));
 574                 jit.addLinkTask([overflow] (LinkBuffer&amp; linkBuffer) {
 575                     linkBuffer.link(overflow, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwStackOverflowFromWasmThunkGenerator).code()));
 576                 });
 577             } else if (m_usesInstanceValue &amp;&amp; Context::useFastTLS()) {
 578                 // No overflow check is needed, but the instance values still needs to be correct.
 579                 AllowMacroScratchRegisterUsageIf allowScratch(jit, CCallHelpers::loadWasmContextInstanceNeedsMacroScratchRegister());
 580                 jit.loadWasmContextInstance(contextInstance);
 581             } else {
 582                 // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
 583             }
 584         });
 585     }
 586 
<span class="line-modified"> 587     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), Origin());</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     if (m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-added"> 590         m_currentBlock = m_proc.addBlock();</span>
 591 }
 592 
 593 void B3IRGenerator::restoreWebAssemblyGlobalState(RestoreCachedStackLimit restoreCachedStackLimit, const MemoryInformation&amp; memory, Value* instance, Procedure&amp; proc, BasicBlock* block)
 594 {
 595     restoreWasmContextInstance(proc, block, instance);
 596 
 597     if (restoreCachedStackLimit == RestoreCachedStackLimit::Yes) {
 598         // The Instance caches the stack limit, but also knows where its canonical location is.
 599         Value* pointerToActualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfPointerToActualStackLimit()));
 600         Value* actualStackLimit = block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), pointerToActualStackLimit);
 601         block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), actualStackLimit, instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfCachedStackLimit()));
 602     }
 603 
 604     if (!!memory) {
 605         const PinnedRegisterInfo* pinnedRegs = &amp;PinnedRegisterInfo::get();
 606         RegisterSet clobbers;
 607         clobbers.set(pinnedRegs-&gt;baseMemoryPointer);
<span class="line-modified"> 608         clobbers.set(pinnedRegs-&gt;sizeRegister);</span>
<span class="line-modified"> 609         if (!isARM64())</span>
<span class="line-added"> 610             clobbers.set(RegisterSet::macroScratchRegisters());</span>
 611 
 612         B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Void, origin());
 613         Effects effects = Effects::none();
 614         effects.writesPinned = true;
 615         effects.reads = B3::HeapRange::top();
 616         patchpoint-&gt;effects = effects;
 617         patchpoint-&gt;clobber(clobbers);
<span class="line-added"> 618         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
 619 
 620         patchpoint-&gt;append(instance, ValueRep::SomeRegister);

 621         patchpoint-&gt;setGenerator([pinnedRegs] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
<span class="line-added"> 622             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
 623             GPRReg baseMemory = pinnedRegs-&gt;baseMemoryPointer;
<span class="line-modified"> 624             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs-&gt;sizeRegister;</span>
<span class="line-modified"> 625 </span>
<span class="line-modified"> 626             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemorySize()), pinnedRegs-&gt;sizeRegister);</span>

 627             jit.loadPtr(CCallHelpers::Address(params[0].gpr(), Instance::offsetOfCachedMemory()), baseMemory);
<span class="line-modified"> 628 </span>
<span class="line-modified"> 629             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs-&gt;sizeRegister, scratchOrSize);</span>
 630         });
 631     }
 632 }
 633 
 634 void B3IRGenerator::emitExceptionCheck(CCallHelpers&amp; jit, ExceptionType type)
 635 {
 636     jit.move(CCallHelpers::TrustedImm32(static_cast&lt;uint32_t&gt;(type)), GPRInfo::argumentGPR1);
 637     auto jumpToExceptionStub = jit.jump();
 638 
 639     jit.addLinkTask([jumpToExceptionStub] (LinkBuffer&amp; linkBuffer) {
 640         linkBuffer.link(jumpToExceptionStub, CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(throwExceptionFromWasmThunkGenerator).code()));
 641     });
 642 }
 643 
 644 Value* B3IRGenerator::constant(B3::Type type, uint64_t bits, Optional&lt;Origin&gt; maybeOrigin)
 645 {
 646     auto result = m_constantPool.ensure(ValueKey(opcodeForConstant(type), type, static_cast&lt;int64_t&gt;(bits)), [&amp;] {
 647         Value* result = m_proc.addConstant(maybeOrigin ? *maybeOrigin : origin(), type, bits);
 648         m_constantInsertionValues.insertValue(0, result);
 649         return result;
 650     });
 651     return result.iterator-&gt;value;
 652 }
 653 
 654 void B3IRGenerator::insertConstants()
 655 {
 656     m_constantInsertionValues.execute(m_proc.at(0));
 657 }
 658 
 659 auto B3IRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
 660 {
<span class="line-modified"> 661     size_t newSize = m_locals.size() + count;</span>
<span class="line-modified"> 662     ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());</span>
<span class="line-modified"> 663     ASSERT(newSize &lt;= maxFunctionLocals);</span>
<span class="line-modified"> 664     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(newSize), &quot;can&#39;t allocate memory for &quot;, newSize, &quot; locals&quot;);</span>
 665 
 666     for (uint32_t i = 0; i &lt; count; ++i) {
 667         Variable* local = m_proc.addVariable(toB3Type(type));
 668         m_locals.uncheckedAppend(local);
<span class="line-modified"> 669         auto val = isSubtype(type, Anyref) ? JSValue::encode(jsNull()) : 0;</span>
<span class="line-added"> 670         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, constant(toB3Type(type), val, Origin()));</span>
 671     }
 672     return { };
 673 }
 674 
 675 auto B3IRGenerator::addArguments(const Signature&amp; signature) -&gt; PartialResult
 676 {
 677     ASSERT(!m_locals.size());
 678     WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(signature.argumentCount()), &quot;can&#39;t allocate memory for &quot;, signature.argumentCount(), &quot; arguments&quot;);
 679 
 680     m_locals.grow(signature.argumentCount());
 681     wasmCallingConvention().loadArguments(signature, m_proc, m_currentBlock, Origin(),
 682         [=] (ExpressionType argument, unsigned i) {
 683             Variable* argumentVariable = m_proc.addVariable(argument-&gt;type());
 684             m_locals[i] = argumentVariable;
 685             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);
 686         });
 687     return { };
 688 }
 689 
<span class="line-added"> 690 auto B3IRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 691 {</span>
<span class="line-added"> 692     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Equal, origin(), value, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), JSValue::encode(jsNull())));</span>
<span class="line-added"> 693     return { };</span>
<span class="line-added"> 694 }</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696 auto B3IRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 697 {</span>
<span class="line-added"> 698     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 699     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(Anyref), origin(),</span>
<span class="line-added"> 700         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;getWasmTableElement, B3CCallPtrTag)),</span>
<span class="line-added"> 701         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index);</span>
<span class="line-added"> 702 </span>
<span class="line-added"> 703     {</span>
<span class="line-added"> 704         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 705             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 708             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 709         });</span>
<span class="line-added"> 710     }</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712     return { };</span>
<span class="line-added"> 713 }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715 auto B3IRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
<span class="line-added"> 716 {</span>
<span class="line-added"> 717     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 718     auto shouldThrow = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int32, origin(),</span>
<span class="line-added"> 719         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;setWasmTableElement, B3CCallPtrTag)),</span>
<span class="line-added"> 720         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index, value);</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722     {</span>
<span class="line-added"> 723         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 724             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), shouldThrow, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 727             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 728         });</span>
<span class="line-added"> 729     }</span>
<span class="line-added"> 730 </span>
<span class="line-added"> 731     return { };</span>
<span class="line-added"> 732 }</span>
<span class="line-added"> 733 </span>
<span class="line-added"> 734 auto B3IRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 735 {</span>
<span class="line-added"> 736     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int64, origin(),</span>
<span class="line-added"> 739         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmRefFunc, B3CCallPtrTag)),</span>
<span class="line-added"> 740         instanceValue(), addConstant(Type::I32, index));</span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742     return { };</span>
<span class="line-added"> 743 }</span>
<span class="line-added"> 744 </span>
<span class="line-added"> 745 auto B3IRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 746 {</span>
<span class="line-added"> 747     // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.</span>
<span class="line-added"> 748     uint32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; uint32_t {</span>
<span class="line-added"> 749         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added"> 750     };</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 753         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(doSize, B3CCallPtrTag)),</span>
<span class="line-added"> 754         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex));</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     return { };</span>
<span class="line-added"> 757 }</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759 auto B3IRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
<span class="line-added"> 760 {</span>
<span class="line-added"> 761     result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 762         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableGrow, B3CCallPtrTag)),</span>
<span class="line-added"> 763         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), fill, delta);</span>
<span class="line-added"> 764 </span>
<span class="line-added"> 765     return { };</span>
<span class="line-added"> 766 }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768 auto B3IRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
<span class="line-added"> 769 {</span>
<span class="line-added"> 770     auto result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),</span>
<span class="line-added"> 771         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableFill, B3CCallPtrTag)),</span>
<span class="line-added"> 772         instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), offset, fill, count);</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     {</span>
<span class="line-added"> 775         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),</span>
<span class="line-added"> 776             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 779             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsTableAccess);</span>
<span class="line-added"> 780         });</span>
<span class="line-added"> 781     }</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783     return { };</span>
<span class="line-added"> 784 }</span>
<span class="line-added"> 785 </span>
 786 auto B3IRGenerator::getLocal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 787 {
 788     ASSERT(m_locals[index]);
 789     result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin(), m_locals[index]);
 790     return { };
 791 }
 792 
 793 auto B3IRGenerator::addUnreachable() -&gt; PartialResult
 794 {
 795     B3::PatchpointValue* unreachable = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());
 796     unreachable-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
 797         this-&gt;emitExceptionCheck(jit, ExceptionType::Unreachable);
 798     });
 799     unreachable-&gt;effects.terminal = true;
 800     return { };
 801 }
 802 
 803 auto B3IRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
 804 {
 805     int32_t (*growMemory)(void*, Instance*, int32_t) = [] (void* callFrame, Instance* instance, int32_t delta) -&gt; int32_t {
</pre>
<hr />
<pre>
 849 
 850 auto B3IRGenerator::setLocal(uint32_t index, ExpressionType value) -&gt; PartialResult
 851 {
 852     ASSERT(m_locals[index]);
 853     m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Set, origin(), m_locals[index], value);
 854     return { };
 855 }
 856 
 857 auto B3IRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
 858 {
 859     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 860     result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(m_info.globals[index].type), origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
 861     return { };
 862 }
 863 
 864 auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
 865 {
 866     ASSERT(toB3Type(m_info.globals[index].type) == value-&gt;type());
 867     Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
 868     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));
<span class="line-added"> 869 </span>
<span class="line-added"> 870     if (isSubtype(m_info.globals[index].type, Anyref))</span>
<span class="line-added"> 871         emitWriteBarrierForJSWrapper();</span>
<span class="line-added"> 872 </span>
 873     return { };
 874 }
 875 
<span class="line-added"> 876 inline void B3IRGenerator::emitWriteBarrierForJSWrapper()</span>
<span class="line-added"> 877 {</span>
<span class="line-added"> 878     Value* cell = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfOwner()));</span>
<span class="line-added"> 879     Value* cellState = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added"> 880     Value* vm = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), cell, safeCast&lt;int32_t&gt;(JSWebAssemblyInstance::offsetOfVM()));</span>
<span class="line-added"> 881     Value* threshold = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapBarrierThreshold()));</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883     BasicBlock* fenceCheckPath = m_proc.addBlock();</span>
<span class="line-added"> 884     BasicBlock* fencePath = m_proc.addBlock();</span>
<span class="line-added"> 885     BasicBlock* doSlowPath = m_proc.addBlock();</span>
<span class="line-added"> 886     BasicBlock* continuation = m_proc.addBlock();</span>
<span class="line-added"> 887 </span>
<span class="line-added"> 888     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 889         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellState, threshold),</span>
<span class="line-added"> 890         FrequentedBlock(continuation), FrequentedBlock(fenceCheckPath, FrequencyClass::Rare));</span>
<span class="line-added"> 891     fenceCheckPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 892     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 893     m_currentBlock = fenceCheckPath;</span>
<span class="line-added"> 894 </span>
<span class="line-added"> 895     Value* shouldFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapMutatorShouldBeFenced()));</span>
<span class="line-added"> 896     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 897         shouldFence,</span>
<span class="line-added"> 898         FrequentedBlock(fencePath), FrequentedBlock(doSlowPath));</span>
<span class="line-added"> 899     fencePath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 900     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 901     m_currentBlock = fencePath;</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903     B3::PatchpointValue* doFence = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());</span>
<span class="line-added"> 904     doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added"> 905         jit.memoryFence();</span>
<span class="line-added"> 906     });</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908     Value* cellStateLoadAfterFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added"> 909     m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added"> 910         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellStateLoadAfterFence, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), blackThreshold)),</span>
<span class="line-added"> 911         FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));</span>
<span class="line-added"> 912     doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 913     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 914     m_currentBlock = doSlowPath;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="line-added"> 917         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="line-added"> 918     };</span>
<span class="line-added"> 919 </span>
<span class="line-added"> 920     Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(writeBarrier, B3CCallPtrTag));</span>
<span class="line-added"> 921     m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);</span>
<span class="line-added"> 922     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924     continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added"> 925     m_currentBlock = continuation;</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
 928 inline Value* B3IRGenerator::emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOperation)
 929 {
 930     ASSERT(m_memoryBaseGPR);
 931 
 932     switch (m_mode) {
 933     case MemoryMode::BoundsChecking: {
 934         // We&#39;re not using signal handling at all, we must therefore check that no memory access exceeds the current memory size.
 935         ASSERT(m_memorySizeGPR);
 936         ASSERT(sizeOfOperation + offset &gt; offset);
 937         m_currentBlock-&gt;appendNew&lt;WasmBoundsCheckValue&gt;(m_proc, origin(), m_memorySizeGPR, pointer, sizeOfOperation + offset - 1);
 938         break;
 939     }
 940 
 941     case MemoryMode::Signaling: {
 942         // We&#39;ve virtually mapped 4GiB+redzone for this memory. Only the user-allocated pages are addressable, contiguously in range [0, current],
 943         // and everything above is mapped PROT_NONE. We don&#39;t need to perform any explicit bounds check in the 4GiB range because WebAssembly register
 944         // memory accesses are 32-bit. However WebAssembly register + offset accesses perform the addition in 64-bit which can push an access above
 945         // the 32-bit limit (the offset is unsigned 32-bit). The redzone will catch most small offsets, and we&#39;ll explicitly bounds check any
 946         // register + large offset access. We don&#39;t think this will be generated frequently.
 947         //
</pre>
<hr />
<pre>
1173         throwException-&gt;setGenerator([this] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1174             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsMemoryAccess);
1175         });
1176     } else
1177         emitStoreOp(op, emitCheckAndPreparePointer(pointer, offset, sizeOfStoreOp(op)), value, offset);
1178 
1179     return { };
1180 }
1181 
1182 auto B3IRGenerator::addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result) -&gt; PartialResult
1183 {
1184     result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Select, origin(), condition, nonZero, zero);
1185     return { };
1186 }
1187 
1188 B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
1189 {
1190     return constant(toB3Type(type), value);
1191 }
1192 
<span class="line-modified">1193 void B3IRGenerator::emitEntryTierUpCheck(int32_t incrementCount, Origin origin)</span>
1194 {
1195     if (!m_tierUp)
1196         return;
1197 
1198     ASSERT(m_tierUp);
<span class="line-modified">1199     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>



1200 
1201     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
1202     Effects effects = Effects::none();
1203     // FIXME: we should have a more precise heap range for the tier up count.
1204     effects.reads = B3::HeapRange::top();
1205     effects.writes = B3::HeapRange::top();
1206     patch-&gt;effects = effects;
<span class="line-added">1207     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
1208 
<span class="line-modified">1209     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>

1210     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
<span class="line-modified">1211         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-modified">1212         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="line-added">1213         CCallHelpers::Label tierUpResume = jit.label();</span>
1214 
1215         params.addLatePath([=] (CCallHelpers&amp; jit) {
1216             tierUp.link(&amp;jit);
1217 
1218             const unsigned extraPaddingBytes = 0;
1219             RegisterSet registersToSpill = { };
1220             registersToSpill.add(GPRInfo::argumentGPR1);
1221             unsigned numberOfStackBytesUsedForRegisterPreservation = ScratchRegisterAllocator::preserveRegistersToStackForCall(jit, registersToSpill, extraPaddingBytes);
1222 
1223             jit.move(MacroAssembler::TrustedImm32(m_functionIndex), GPRInfo::argumentGPR1);
1224             MacroAssembler::Call call = jit.nearCall();
1225 
1226             ScratchRegisterAllocator::restoreRegistersFromStackForCall(jit, registersToSpill, RegisterSet(), numberOfStackBytesUsedForRegisterPreservation, extraPaddingBytes);
1227             jit.jump(tierUpResume);
1228 
1229             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">1230                 MacroAssembler::repatchNearCall(linkBuffer.locationOfNearCall&lt;NoPtrTag&gt;(call), CodeLocationLabel&lt;JITThunkPtrTag&gt;(Thunks::singleton().stub(triggerOMGEntryTierUpThunkGenerator).code()));</span>

1231             });
1232         });
1233     });
1234 }
1235 
<span class="line-modified">1236 void B3IRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
<span class="line-added">1237 {</span>
<span class="line-added">1238     if (!m_tierUp)</span>
<span class="line-added">1239         return;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241     ASSERT(m_tierUp);</span>
<span class="line-added">1242 </span>
<span class="line-added">1243     ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);</span>
<span class="line-added">1244     m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);</span>
<span class="line-added">1245     m_tierUp-&gt;outerLoops().append(outerLoopIndex);</span>
<span class="line-added">1246 </span>
<span class="line-added">1247     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     Vector&lt;ExpressionType&gt; stackmap;</span>
<span class="line-added">1250     Vector&lt;B3::Type&gt; types;</span>
<span class="line-added">1251     for (auto&amp; local : m_locals) {</span>
<span class="line-added">1252         ExpressionType result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin, local);</span>
<span class="line-added">1253         stackmap.append(result);</span>
<span class="line-added">1254         types.append(result-&gt;type());</span>
<span class="line-added">1255     }</span>
<span class="line-added">1256     for (unsigned i = 0; i &lt; expressionStack.size(); ++i) {</span>
<span class="line-added">1257         ExpressionType result = expressionStack.at(i);</span>
<span class="line-added">1258         stackmap.append(result);</span>
<span class="line-added">1259         types.append(result-&gt;type());</span>
<span class="line-added">1260     }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);</span>
<span class="line-added">1263     Effects effects = Effects::none();</span>
<span class="line-added">1264     // FIXME: we should have a more precise heap range for the tier up count.</span>
<span class="line-added">1265     effects.reads = B3::HeapRange::top();</span>
<span class="line-added">1266     effects.writes = B3::HeapRange::top();</span>
<span class="line-added">1267     effects.exitsSideways = true;</span>
<span class="line-added">1268     patch-&gt;effects = effects;</span>
<span class="line-added">1269 </span>
<span class="line-added">1270     patch-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="line-added">1271     RegisterSet clobberLate;</span>
<span class="line-added">1272     clobberLate.add(GPRInfo::argumentGPR0);</span>
<span class="line-added">1273     patch-&gt;clobberLate(clobberLate);</span>
<span class="line-added">1274 </span>
<span class="line-added">1275     patch-&gt;append(countDownLocation, ValueRep::SomeRegister);</span>
<span class="line-added">1276     patch-&gt;appendVectorWithRep(stackmap, ValueRep::ColdAny);</span>
<span class="line-added">1277 </span>
<span class="line-added">1278     TierUpCount::TriggerReason* forceEntryTrigger = &amp;(m_tierUp-&gt;osrEntryTriggers().last());</span>
<span class="line-added">1279     static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);</span>
<span class="line-added">1280     static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);</span>
<span class="line-added">1281     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added">1282         AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">1283         CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));</span>
<span class="line-added">1284         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
<span class="line-added">1285         MacroAssembler::Label tierUpResume = jit.label();</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);</span>
<span class="line-added">1288         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="line-added">1289             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
<span class="line-added">1290         OSREntryData* osrEntryDataPtr = &amp;osrEntryData;</span>
<span class="line-added">1291 </span>
<span class="line-added">1292         params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1293             AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added">1294             forceOSREntry.link(&amp;jit);</span>
<span class="line-added">1295             tierUp.link(&amp;jit);</span>
<span class="line-added">1296 </span>
<span class="line-added">1297             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
<span class="line-added">1298             jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);</span>
<span class="line-added">1299             jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);</span>
<span class="line-added">1300         });</span>
<span class="line-added">1301     });</span>
<span class="line-added">1302 }</span>
<span class="line-added">1303 </span>
<span class="line-added">1304 B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature, const Stack&amp; stack, uint32_t loopIndex)</span>
1305 {
1306     BasicBlock* body = m_proc.addBlock();
1307     BasicBlock* continuation = m_proc.addBlock();
1308 
1309     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
<span class="line-added">1310     if (loopIndex == m_loopIndexForOSREntry) {</span>
<span class="line-added">1311         m_currentBlock = m_rootBlock;</span>
<span class="line-added">1312         m_osrEntryScratchBufferSize = m_locals.size() + stack.size();</span>
<span class="line-added">1313         Value* pointer = m_rootBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(m_proc, Origin(), GPRInfo::argumentGPR0);</span>
<span class="line-added">1314 </span>
<span class="line-added">1315         auto loadFromScratchBuffer = [&amp;] (B3::Type type, unsigned index) {</span>
<span class="line-added">1316             size_t offset = sizeof(uint64_t) * index;</span>
<span class="line-added">1317             switch (type.kind()) {</span>
<span class="line-added">1318             case B3::Int32:</span>
<span class="line-added">1319                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), pointer, offset);</span>
<span class="line-added">1320             case B3::Int64:</span>
<span class="line-added">1321                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), pointer, offset);</span>
<span class="line-added">1322             case B3::Float:</span>
<span class="line-added">1323                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Float, origin(), pointer, offset);</span>
<span class="line-added">1324             case B3::Double:</span>
<span class="line-added">1325                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Double, origin(), pointer, offset);</span>
<span class="line-added">1326             default:</span>
<span class="line-added">1327                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1328                 break;</span>
<span class="line-added">1329             }</span>
<span class="line-added">1330         };</span>
<span class="line-added">1331 </span>
<span class="line-added">1332         unsigned indexInBuffer = 0;</span>
<span class="line-added">1333         for (auto&amp; local : m_locals)</span>
<span class="line-added">1334             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, loadFromScratchBuffer(local-&gt;type(), indexInBuffer++));</span>
<span class="line-added">1335         for (unsigned i = 0; i &lt; stack.size(); ++i) {</span>
<span class="line-added">1336             auto* variable = stack.variableAt(i);</span>
<span class="line-added">1337             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), variable, loadFromScratchBuffer(variable-&gt;type(), indexInBuffer++));</span>
<span class="line-added">1338         }</span>
<span class="line-added">1339         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);</span>
<span class="line-added">1340         body-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">1341     }</span>
1342 
<span class="line-added">1343     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-added">1344     m_outerLoops.append(loopIndex);</span>
1345     m_currentBlock = body;
<span class="line-modified">1346     emitLoopTierUpCheck(TierUpCount::loopIncrement(), stack, loopIndex, outerLoopIndex, origin());</span>
1347 
1348     return ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);
1349 }
1350 
1351 B3IRGenerator::ControlData B3IRGenerator::addTopLevel(Type signature)
1352 {
1353     return ControlData(m_proc, Origin(), signature, BlockType::TopLevel, m_proc.addBlock());
1354 }
1355 
1356 B3IRGenerator::ControlData B3IRGenerator::addBlock(Type signature)
1357 {
1358     return ControlData(m_proc, origin(), signature, BlockType::Block, m_proc.addBlock());
1359 }
1360 
1361 auto B3IRGenerator::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; PartialResult
1362 {
1363     // FIXME: This needs to do some kind of stack passing.
1364 
1365     BasicBlock* taken = m_proc.addBlock();
1366     BasicBlock* notTaken = m_proc.addBlock();
1367     BasicBlock* continuation = m_proc.addBlock();
1368 
1369     m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
1370     m_currentBlock-&gt;setSuccessors(FrequentedBlock(taken), FrequentedBlock(notTaken));
1371     taken-&gt;addPredecessor(m_currentBlock);
1372     notTaken-&gt;addPredecessor(m_currentBlock);
1373 
1374     m_currentBlock = taken;
1375     result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
1376     return { };
1377 }
1378 
<span class="line-modified">1379 auto B3IRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult</span>
1380 {
1381     unifyValuesWithBlock(currentStack, data.result);
1382     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
1383     return addElseToUnreachable(data);
1384 }
1385 
1386 auto B3IRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
1387 {
1388     ASSERT(data.type() == BlockType::If);
1389     m_currentBlock = data.special;
1390     data.convertIfToBlock();
1391     return { };
1392 }
1393 
1394 auto B3IRGenerator::addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues) -&gt; PartialResult
1395 {
1396     ASSERT(returnValues.size() &lt;= 1);
1397     if (returnValues.size())
1398         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin(), returnValues[0]);
1399     else
1400         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin());
1401     return { };
1402 }
1403 
<span class="line-modified">1404 auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult</span>
1405 {
1406     unifyValuesWithBlock(returnValues, data.resultForBranch());
1407 
1408     BasicBlock* target = data.targetBlockForBranch();
1409     if (condition) {
1410         BasicBlock* continuation = m_proc.addBlock();
1411         m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
1412         m_currentBlock-&gt;setSuccessors(FrequentedBlock(target), FrequentedBlock(continuation));
1413         target-&gt;addPredecessor(m_currentBlock);
1414         continuation-&gt;addPredecessor(m_currentBlock);
1415         m_currentBlock = continuation;
1416     } else {
1417         m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), FrequentedBlock(target));
1418         target-&gt;addPredecessor(m_currentBlock);
1419     }
1420 
1421     return { };
1422 }
1423 
<span class="line-modified">1424 auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult</span>
1425 {
1426     for (size_t i = 0; i &lt; targets.size(); ++i)
1427         unifyValuesWithBlock(expressionStack, targets[i]-&gt;resultForBranch());
1428     unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());
1429 
1430     SwitchValue* switchValue = m_currentBlock-&gt;appendNew&lt;SwitchValue&gt;(m_proc, origin(), condition);
1431     switchValue-&gt;setFallThrough(FrequentedBlock(defaultTarget.targetBlockForBranch()));
1432     for (size_t i = 0; i &lt; targets.size(); ++i)
1433         switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
1434 
1435     return { };
1436 }
1437 
<span class="line-modified">1438 auto B3IRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult</span>
1439 {
1440     ControlData&amp; data = entry.controlData;
1441 
1442     unifyValuesWithBlock(expressionStack, data.result);
1443     m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
1444     data.continuation-&gt;addPredecessor(m_currentBlock);
1445 
<span class="line-added">1446     if (data.type() == BlockType::Loop)</span>
<span class="line-added">1447         m_outerLoops.removeLast();</span>
<span class="line-added">1448 </span>
1449     return addEndToUnreachable(entry);
1450 }
1451 
1452 
1453 auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult
1454 {
1455     ControlData&amp; data = entry.controlData;
1456     m_currentBlock = data.continuation;
1457 
1458     if (data.type() == BlockType::If) {
1459         data.special-&gt;appendNewControlValue(m_proc, Jump, origin(), m_currentBlock);
1460         m_currentBlock-&gt;addPredecessor(data.special);
1461     }
1462 
1463     for (Value* result : data.result) {
1464         m_currentBlock-&gt;append(result);
1465         entry.enclosedExpressionStack.append(result);
1466     }
1467 
1468     // TopLevel does not have any code after this so we need to make sure we emit a return here.
1469     if (data.type() == BlockType::TopLevel)
<span class="line-modified">1470         return addReturn(entry.controlData, entry.enclosedExpressionStack.convertToExpressionList());</span>
1471 
1472     return { };
1473 }
1474 
1475 auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult
1476 {
1477     ASSERT(signature.argumentCount() == args.size());
1478 
1479     m_makesCalls = true;
1480 
1481     Type returnType = signature.returnType();
1482     Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
1483 
1484     if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
1485         m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1486 
1487         // FIXME imports can be linked here, instead of generating a patchpoint, because all import stubs are generated before B3 compilation starts. https://bugs.webkit.org/show_bug.cgi?id=166462
1488         Value* targetInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTargetInstance(functionIndex)));
1489         // The target instance is 0 unless the call is wasm-&gt;wasm.
1490         Value* isWasmCall = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), targetInstance, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0));
</pre>
<hr />
<pre>
1551         restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, continuation);
1552     } else {
1553         result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1554             [=] (PatchpointValue* patchpoint) {
1555                 patchpoint-&gt;effects.writesPinned = true;
1556                 patchpoint-&gt;effects.readsPinned = true;
1557 
1558                 patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1559                     AllowMacroScratchRegisterUsage allowScratch(jit);
1560                     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
1561                     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
1562                         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
1563                     });
1564                 });
1565             });
1566     }
1567 
1568     return { };
1569 }
1570 
<span class="line-modified">1571 auto B3IRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
1572 {
1573     ExpressionType calleeIndex = args.takeLast();
1574     ASSERT(signature.argumentCount() == args.size());
1575 
1576     m_makesCalls = true;
1577     // Note: call indirect can call either WebAssemblyFunction or WebAssemblyWrapperFunction. Because
1578     // WebAssemblyWrapperFunction is like calling into the embedder, we conservatively assume all call indirects
1579     // can be to the embedder for our stack check calculation.
1580     m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
1581 
1582     ExpressionType callableFunctionBuffer;
1583     ExpressionType instancesBuffer;
1584     ExpressionType callableFunctionBufferLength;
1585     ExpressionType mask;
1586     {
1587         ExpressionType table = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1588             instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)));</span>
1589         callableFunctionBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1590             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfFunctions()));</span>
1591         instancesBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
<span class="line-modified">1592             table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfInstances()));</span>
1593         callableFunctionBufferLength = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1594             table, safeCast&lt;int32_t&gt;(Table::offsetOfLength()));
1595         mask = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(),
1596             m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
1597                 table, safeCast&lt;int32_t&gt;(Table::offsetOfMask())));
1598     }
1599 
1600     // Check the index we are looking for is valid.
1601     {
1602         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1603             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, AboveEqual, origin(), calleeIndex, callableFunctionBufferLength));
1604 
1605         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1606             this-&gt;emitExceptionCheck(jit, ExceptionType::OutOfBoundsCallIndirect);
1607         });
1608     }
1609 
1610     calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), calleeIndex);
1611 
1612     if (Options::enableSpectreMitigations())
</pre>
<hr />
<pre>
1652             calleeIndex, constant(pointerType(), sizeof(Instance*)));
1653         Value* newContextInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1654             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Add, origin(), instancesBuffer, offset));
1655 
1656         BasicBlock* continuation = m_proc.addBlock();
1657         BasicBlock* doContextSwitch = m_proc.addBlock();
1658 
1659         Value* isSameContextInstance = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(),
1660             newContextInstance, instanceValue());
1661         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),
1662             isSameContextInstance, FrequentedBlock(continuation), FrequentedBlock(doContextSwitch));
1663 
1664         PatchpointValue* patchpoint = doContextSwitch-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin());
1665         patchpoint-&gt;effects.writesPinned = true;
1666         // We pessimistically assume we&#39;re calling something with BoundsChecking memory.
1667         // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
1668         patchpoint-&gt;clobber(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1669         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
1670         patchpoint-&gt;append(newContextInstance, ValueRep::SomeRegister);
1671         patchpoint-&gt;append(instanceValue(), ValueRep::SomeRegister);
<span class="line-added">1672         patchpoint-&gt;numGPScratchRegisters = Gigacage::isEnabled(Gigacage::Primitive) ? 1 : 0;</span>
<span class="line-added">1673 </span>
1674         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1675             AllowMacroScratchRegisterUsage allowScratch(jit);
1676             GPRReg newContextInstance = params[0].gpr();
1677             GPRReg oldContextInstance = params[1].gpr();
1678             const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();

1679             GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
1680             ASSERT(newContextInstance != baseMemory);
1681             jit.loadPtr(CCallHelpers::Address(oldContextInstance, Instance::offsetOfCachedStackLimit()), baseMemory);
1682             jit.storePtr(baseMemory, CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedStackLimit()));
1683             jit.storeWasmContextInstance(newContextInstance);
<span class="line-modified">1684             ASSERT(pinnedRegs.sizeRegister != baseMemory);</span>
1685             // FIXME: We should support more than one memory size register
1686             //   see: https://bugs.webkit.org/show_bug.cgi?id=162952
<span class="line-modified">1687             ASSERT(pinnedRegs.sizeRegister != newContextInstance);</span>
<span class="line-modified">1688             GPRReg scratchOrSize = Gigacage::isEnabled(Gigacage::Primitive) ? params.gpScratch(0) : pinnedRegs.sizeRegister;</span>
<span class="line-modified">1689 </span>
<span class="line-modified">1690             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister); // Memory size.</span>
1691             jit.loadPtr(CCallHelpers::Address(newContextInstance, Instance::offsetOfCachedMemory()), baseMemory); // Memory::void*.
<span class="line-added">1692 </span>
<span class="line-added">1693             jit.cageConditionally(Gigacage::Primitive, baseMemory, pinnedRegs.sizeRegister, scratchOrSize);</span>
1694         });
1695         doContextSwitch-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
1696 
1697         m_currentBlock = continuation;
1698     }
1699 
1700     ExpressionType calleeCode = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
1701         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), callableFunction,
1702             safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfEntrypointLoadLocation())));
1703 
1704     Type returnType = signature.returnType();
1705     result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),
1706         [=] (PatchpointValue* patchpoint) {
1707             patchpoint-&gt;effects.writesPinned = true;
1708             patchpoint-&gt;effects.readsPinned = true;
1709             // We need to clobber all potential pinned registers since we might be leaving the instance.
1710             // We pessimistically assume we&#39;re always calling something that is bounds checking so
1711             // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
1712             // FIXME: We should not have to do this, but the wasm-&gt;wasm stub assumes it can
1713             // use all the pinned registers as scratch: https://bugs.webkit.org/show_bug.cgi?id=172181
1714             patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
1715 
1716             patchpoint-&gt;append(calleeCode, ValueRep::SomeRegister);
1717             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
1718                 AllowMacroScratchRegisterUsage allowScratch(jit);
1719                 jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);
1720             });
1721         });
1722 
1723     // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
1724     restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, m_currentBlock);
1725 
1726     return { };
1727 }
1728 
1729 void B3IRGenerator::unify(const ExpressionType phi, const ExpressionType source)
1730 {
1731     m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), source, phi);
1732 }
1733 
<span class="line-modified">1734 void B3IRGenerator::unifyValuesWithBlock(const Stack&amp; resultStack, const ResultList&amp; result)</span>
1735 {
1736     ASSERT(result.size() &lt;= resultStack.size());
1737 
1738     for (size_t i = 0; i &lt; result.size(); ++i)
<span class="line-modified">1739         unify(result[result.size() - 1 - i], resultStack.at(resultStack.size() - 1 - i));</span>







1740 }
1741 
<span class="line-modified">1742 void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack)</span>
1743 {
1744     dataLogLn(&quot;Constants:&quot;);
1745     for (const auto&amp; constant : m_constantPool)
1746         dataLogLn(deepDump(m_proc, constant.value));
1747 
1748     dataLogLn(&quot;Processing Graph:&quot;);
1749     dataLog(m_proc);
1750     dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
1751     dataLogLn(&quot;Control stack:&quot;);
1752     ASSERT(controlStack.size());
1753     for (size_t i = controlStack.size(); i--;) {
1754         dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<span class="line-modified">1755         expressionStack-&gt;dump();</span>

1756         expressionStack = &amp;controlStack[i].enclosedExpressionStack;
1757         dataLogLn();
1758     }
1759     dataLogLn();
1760 }
1761 
1762 auto B3IRGenerator::origin() -&gt; Origin
1763 {
1764     OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
1765     ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
1766     return bitwise_cast&lt;Origin&gt;(origin);
1767 }
1768 
<span class="line-modified">1769 Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, uint32_t loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
1770 {
<span class="line-modified">1771     auto result = makeUnique&lt;InternalFunction&gt;();</span>
1772 
<span class="line-modified">1773     compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
<span class="line-modified">1774     compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();</span>
1775 
1776     Procedure procedure;
1777 
1778     procedure.setOriginPrinter([] (PrintStream&amp; out, Origin origin) {
1779         if (origin.data())
1780             out.print(&quot;Wasm: &quot;, bitwise_cast&lt;OpcodeOrigin&gt;(origin));
1781     });
1782 
1783     // This means we cannot use either StackmapGenerationParams::usedRegisters() or
1784     // StackmapGenerationParams::unavailableRegisters(). In exchange for this concession, we
1785     // don&#39;t strictly need to run Air::reportUsedRegisters(), which saves a bit of CPU time at
1786     // optLevel=1.
1787     procedure.setNeedsUsedRegisters(false);
1788 
1789     procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
<span class="line-modified">1790         ? Options::webAssemblyBBQB3OptimizationLevel()</span>
1791         : Options::webAssemblyOMGOptimizationLevel());
1792 
<span class="line-modified">1793     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, mode, compilationMode, functionIndex, loopIndexForOSREntry, tierUp, throwWasmException);</span>
1794     FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);
1795     WASM_FAIL_IF_HELPER_FAILS(parser.parse());
1796 
1797     irGenerator.insertConstants();
1798 
1799     procedure.resetReachability();
1800     if (!ASSERT_DISABLED)
1801         validate(procedure, &quot;After parsing:\n&quot;);
1802 
1803     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Pre SSA: &quot;, procedure);
1804     fixSSA(procedure);
1805     dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Post SSA: &quot;, procedure);
1806 
1807     {
1808         B3::prepareForGeneration(procedure);
1809         B3::generate(procedure, *compilationContext.wasmEntrypointJIT);
1810         compilationContext.wasmEntrypointByproducts = procedure.releaseByproducts();
1811         result-&gt;entrypoint.calleeSaveRegisters = procedure.calleeSaveRegisterAtOffsetList();
1812     }
1813 
<span class="line-modified">1814     return result;</span>
1815 }
1816 
1817 // Custom wasm ops. These are the ones too messy to do in wasm.json.
1818 
1819 void B3IRGenerator::emitChecksForModOrDiv(B3::Opcode operation, ExpressionType left, ExpressionType right)
1820 {
1821     ASSERT(operation == Div || operation == Mod || operation == UDiv || operation == UMod);
1822     const B3::Type type = left-&gt;type();
1823 
1824     {
1825         CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
1826             m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), right, constant(type, 0)));
1827 
1828         check-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
1829             this-&gt;emitExceptionCheck(jit, ExceptionType::DivisionByZero);
1830         });
1831     }
1832 
1833     if (operation == Div) {
1834         int64_t min = type == Int32 ? std::numeric_limits&lt;int32_t&gt;::min() : std::numeric_limits&lt;int64_t&gt;::min();
</pre>
</td>
</tr>
</table>
<center><a href="WasmAirIRGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>