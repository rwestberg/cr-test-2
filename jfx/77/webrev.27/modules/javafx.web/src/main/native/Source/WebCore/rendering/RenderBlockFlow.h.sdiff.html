<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5  * Copyright (C) 2003-2013,  Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 

 25 #include &quot;FloatingObjects.h&quot;
 26 #include &quot;LineWidth.h&quot;
 27 #include &quot;RenderBlock.h&quot;
 28 #include &quot;RenderLineBoxList.h&quot;
 29 #include &quot;SimpleLineLayout.h&quot;
 30 #include &quot;TrailingObjects.h&quot;
 31 #include &lt;memory&gt;
 32 
 33 namespace WebCore {
 34 
<span class="line-removed"> 35 class FloatWithRect;</span>
 36 class LineBreaker;
<span class="line-removed"> 37 class LineInfo;</span>
 38 class RenderMultiColumnFlow;
 39 class RenderRubyRun;
 40 
<span class="line-removed"> 41 struct WordMeasurement;</span>
<span class="line-removed"> 42 </span>
<span class="line-removed"> 43 template &lt;class Run&gt; class BidiRunList;</span>
<span class="line-removed"> 44 typedef Vector&lt;WordMeasurement, 64&gt; WordMeasurements;</span>
<span class="line-removed"> 45 </span>
 46 #if ENABLE(TEXT_AUTOSIZING)
 47 enum LineCount {
 48     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 49 };
 50 #endif
 51 
 52 class RenderBlockFlow : public RenderBlock {
 53     WTF_MAKE_ISO_ALLOCATED(RenderBlockFlow);
 54 public:
 55     RenderBlockFlow(Element&amp;, RenderStyle&amp;&amp;);
 56     RenderBlockFlow(Document&amp;, RenderStyle&amp;&amp;);
 57     virtual ~RenderBlockFlow();
 58 
 59     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 60 
 61 protected:
 62     void willBeDestroyed() override;
 63 
 64     // This method is called at the start of layout to wipe away all of the floats in our floating objects list. It also
 65     // repopulates the list with any floats that intrude from previous siblings or parents. Floats that were added by
 66     // descendants are gone when this call completes and will get added back later on after the children have gotten
 67     // a relayout.
 68     void rebuildFloatingObjectSetFromIntrudingFloats();
 69 
 70     // RenderBlockFlow always contains either lines or paragraphs. When the children are all blocks (e.g. paragraphs), we call layoutBlockChildren.
 71     // When the children are all inline (e.g., lines), we call layoutInlineChildren.
 72     void layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom);
 73     void layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 74 
 75     // RenderBlockFlows override these methods, since they are the only class that supports margin collapsing.
 76     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
 77     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 78 
<span class="line-modified"> 79     void dirtyLinesFromChangedChild(RenderObject&amp; child) final { lineBoxes().dirtyLinesFromChangedChild(*this, child); }</span>




 80 
 81     void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
 82 
 83 public:
 84     class MarginValues {
 85     public:
 86         MarginValues(LayoutUnit beforePos, LayoutUnit beforeNeg, LayoutUnit afterPos, LayoutUnit afterNeg)
 87             : m_positiveMarginBefore(beforePos)
 88             , m_negativeMarginBefore(beforeNeg)
 89             , m_positiveMarginAfter(afterPos)
 90             , m_negativeMarginAfter(afterNeg)
 91         {
 92         }
 93 
 94         LayoutUnit positiveMarginBefore() const { return m_positiveMarginBefore; }
 95         LayoutUnit negativeMarginBefore() const { return m_negativeMarginBefore; }
 96         LayoutUnit positiveMarginAfter() const { return m_positiveMarginAfter; }
 97         LayoutUnit negativeMarginAfter() const { return m_negativeMarginAfter; }
 98 
 99         void setPositiveMarginBefore(LayoutUnit pos) { m_positiveMarginBefore = pos; }
</pre>
<hr />
<pre>
220         bool canCollapseMarginBeforeWithChildren() const { return m_canCollapseMarginBeforeWithChildren; }
221         bool canCollapseMarginAfterWithChildren() const { return m_canCollapseMarginAfterWithChildren; }
222         bool quirkContainer() const { return m_quirkContainer; }
223         bool determinedMarginBeforeQuirk() const { return m_determinedMarginBeforeQuirk; }
224         bool hasMarginBeforeQuirk() const { return m_hasMarginBeforeQuirk; }
225         bool hasMarginAfterQuirk() const { return m_hasMarginAfterQuirk; }
226         LayoutUnit positiveMargin() const { return m_positiveMargin; }
227         LayoutUnit negativeMargin() const { return m_negativeMargin; }
228         bool discardMargin() const { return m_discardMargin; }
229         LayoutUnit margin() const { return m_positiveMargin - m_negativeMargin; }
230     };
231     LayoutUnit marginOffsetForSelfCollapsingBlock();
232 
233     void layoutBlockChild(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom);
234     void adjustPositionedBlock(RenderBox&amp; child, const MarginInfo&amp;);
235     void adjustFloatingBlock(const MarginInfo&amp;);
236 
237     void setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition);
238     void updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText);
239 


240     LayoutUnit collapseMargins(RenderBox&amp; child, MarginInfo&amp;);
241     LayoutUnit collapseMarginsWithChildInfo(RenderBox* child, RenderObject* prevSibling, MarginInfo&amp;);
242 
243     LayoutUnit clearFloatsIfNeeded(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit oldTopPosMargin, LayoutUnit oldTopNegMargin, LayoutUnit yPos);
244     LayoutUnit estimateLogicalTopPosition(RenderBox&amp; child, const MarginInfo&amp;, LayoutUnit&amp; estimateWithoutPagination);
245     void marginBeforeEstimateForChild(RenderBox&amp;, LayoutUnit&amp;, LayoutUnit&amp;, bool&amp;) const;
246     void handleAfterSideOfBlock(LayoutUnit top, LayoutUnit bottom, MarginInfo&amp;);
247     void setCollapsedBottomMargin(const MarginInfo&amp;);
248 
249     bool childrenPreventSelfCollapsing() const final;
250 
251     bool shouldBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow &gt;= 0; }
252     void clearShouldBreakAtLineToAvoidWidow() const;
253     int lineBreakToAvoidWidow() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow : -1; }
254     void setBreakAtLineToAvoidWidow(int);
255     void clearDidBreakAtLineToAvoidWidow();
256     void setDidBreakAtLineToAvoidWidow();
257     bool didBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow; }
258     bool relayoutToAvoidWidows();
259 
260     RootInlineBox* lineGridBox() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineGridBox.get() : nullptr; }
261     void setLineGridBox(std::unique_ptr&lt;RootInlineBox&gt; box)
262     {
263         ensureRareBlockFlowData().m_lineGridBox = WTFMove(box);
264     }
265     void layoutLineGridBox();
266 
<span class="line-modified">267     RenderMultiColumnFlow* multiColumnFlow() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_multiColumnFlow.get() : nullptr; }</span>

268     void setMultiColumnFlow(RenderMultiColumnFlow&amp;);
269     void clearMultiColumnFlow();
270     bool willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount = WTF::nullopt) const;
271     virtual bool requiresColumns(int) const;
272 
273     bool containsFloats() const override { return m_floatingObjects &amp;&amp; !m_floatingObjects-&gt;set().isEmpty(); }
274     bool containsFloat(RenderBox&amp;) const;
275 
276     void deleteLines() override;
277     void computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats = false) override;
278     Position positionForPoint(const LayoutPoint&amp;) override;
279     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
280 
281     LayoutUnit lowestFloatLogicalBottom(FloatingObject::Type = FloatingObject::FloatLeftRight) const;
282 
283     void removeFloatingObjects();
284     void markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove = nullptr, bool inLayout = true);
285     void markSiblingsWithFloatsForLayout(RenderBox* floatToRemove = nullptr);
286 
287     const FloatingObjectSet* floatingObjectSet() const { return m_floatingObjects ? &amp;m_floatingObjects-&gt;set() : nullptr; }
</pre>
<hr />
<pre>
314         else
315             floatingObject.setWidth(logicalHeight);
316     }
317     void setLogicalWidthForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalWidth)
318     {
319         if (isHorizontalWritingMode())
320             floatingObject.setWidth(logicalWidth);
321         else
322             floatingObject.setHeight(logicalWidth);
323     }
324     void setLogicalMarginsForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeftMargin, LayoutUnit logicalBeforeMargin)
325     {
326         if (isHorizontalWritingMode())
327             floatingObject.setMarginOffset(LayoutSize(logicalLeftMargin, logicalBeforeMargin));
328         else
329             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
330     }
331 
332     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
333 
<span class="line-modified">334     RenderLineBoxList&amp; lineBoxes() { return m_lineBoxes; }</span>
<span class="line-modified">335     const RenderLineBoxList&amp; lineBoxes() const { return m_lineBoxes; }</span>
<span class="line-removed">336 </span>
<span class="line-removed">337     RootInlineBox* firstRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.firstLineBox()); }</span>
<span class="line-removed">338     RootInlineBox* lastRootBox() const { return downcast&lt;RootInlineBox&gt;(m_lineBoxes.lastLineBox()); }</span>
339 
340     bool hasLines() const;
341     void invalidateLineLayoutPath() final;
342 
343     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, ForceLineBoxesPath };
344     LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
345     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
346 
347     // Helper methods for computing line counts and heights for line counts.
348     RootInlineBox* lineAtIndex(int) const;
349     int lineCount(const RootInlineBox* = nullptr, bool* = nullptr) const;
350     int heightForLineCount(int);
351     void clearTruncation();
352 
353     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
354     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
355 
356     bool containsNonZeroBidiLevel() const;
357 
358     const SimpleLineLayout::Layout* simpleLineLayout() const;
</pre>
<hr />
<pre>
466     LayoutUnit columnGap() const;
467 
468     RenderBlockFlow* previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const;
469 
470     void checkForPaginationLogicalHeightChange(bool&amp; relayoutChildren, LayoutUnit&amp; pageLogicalHeight, bool&amp; pageLogicalHeightChanged);
471 
472     void paintInlineChildren(PaintInfo&amp;, const LayoutPoint&amp;) override;
473     void paintFloats(PaintInfo&amp;, const LayoutPoint&amp;, bool preservePhase = false) override;
474 
475     void repaintOverhangingFloats(bool paintAllDescendants) final;
476     void clipOutFloatingObjects(RenderBlock&amp;, const PaintInfo*, const LayoutPoint&amp;, const LayoutSize&amp;) override;
477 
478     FloatingObject* insertFloatingObject(RenderBox&amp;);
479     void removeFloatingObject(RenderBox&amp;);
480     void removeFloatingObjectsBelow(FloatingObject*, int logicalOffset);
481     void computeLogicalLocationForFloat(FloatingObject&amp;, LayoutUnit&amp; logicalTopOffset);
482 
483     // Called from lineWidth, to position the floats added in the last line.
484     // Returns true if and only if it has positioned any floats.
485     bool positionNewFloats();
<span class="line-removed">486 </span>
487     void clearFloats(Clear);

488 
489     LayoutUnit logicalRightFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
490     LayoutUnit logicalLeftFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
491 
492     LayoutUnit logicalRightOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
493     LayoutUnit logicalLeftOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
494 
495     LayoutUnit lowestInitialLetterLogicalBottom() const;
496 
497     LayoutUnit nextFloatLogicalBottomBelow(LayoutUnit) const;
498     LayoutUnit nextFloatLogicalBottomBelowForBlock(LayoutUnit) const;
499 
500     LayoutUnit addOverhangingFloats(RenderBlockFlow&amp; child, bool makeChildPaintOtherFloats);
501     bool hasOverhangingFloat(RenderBox&amp;);
502     void addIntrudingFloats(RenderBlockFlow* prev, RenderBlockFlow* container, LayoutUnit xoffset, LayoutUnit yoffset);
503     bool hasOverhangingFloats() { return parent() &amp;&amp; containsFloats() &amp;&amp; lowestFloatLogicalBottom() &gt; logicalHeight(); }
504     LayoutUnit getClearDelta(RenderBox&amp; child, LayoutUnit yPos);
505 
506     void determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
507 
508     bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset) override;
509     bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
510 
511     void addOverflowFromInlineChildren() override;
512 
513     void fitBorderToLinesIfNeeded(); // Shrink the box in which the border paints if border-fit is set.
514     void adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
515 
516     void markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest = 0);
517 
518     GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
519         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*) override;
520 
521     Position positionForBox(InlineBox*, bool start = true) const;
522     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
523     void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
524 
<span class="line-removed">525 // FIXME-BLOCKFLOW: These methods have implementations in</span>
<span class="line-removed">526 // RenderBlockLineLayout. They should be moved to the proper header once the</span>
<span class="line-removed">527 // line layout code is separated from RenderBlock and RenderBlockFlow.</span>
<span class="line-removed">528 // START METHODS DEFINED IN RenderBlockLineLayout</span>
529 public:
<span class="line-modified">530     static void appendRunsForObject(BidiRunList&lt;BidiRun&gt;*, int start, int end, RenderObject&amp;, InlineBidiResolver&amp;);</span>
<span class="line-removed">531     RootInlineBox* createAndAppendRootInlineBox();</span>
532 
<span class="line-modified">533     LayoutUnit startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText);</span>
<span class="line-removed">534     virtual TextAlignMode textAlignmentForLine(bool endsWithSoftBreak) const;</span>
535     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
<span class="line-removed">536     RootInlineBox* constructLine(BidiRunList&lt;BidiRun&gt;&amp;, const LineInfo&amp;);</span>
537 
538 private:
<span class="line-removed">539     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;</span>
<span class="line-removed">540 </span>
<span class="line-removed">541     void layoutLineBoxes(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);</span>
542     void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
543 
<span class="line-modified">544     virtual std::unique_ptr&lt;RootInlineBox&gt; createRootInlineBox(); // Subclassed by RenderSVGText.</span>
<span class="line-removed">545     InlineFlowBox* createLineBoxes(RenderObject*, const LineInfo&amp;, InlineBox* childBox);</span>
<span class="line-removed">546     void setMarginsForRubyRun(BidiRun*, RenderRubyRun&amp;, RenderObject*, const LineInfo&amp;);</span>
<span class="line-removed">547     void computeInlineDirectionPositionsForLine(RootInlineBox*, const LineInfo&amp;, BidiRun* firstRun, BidiRun* trailingSpaceRun, bool reachedEnd, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;, WordMeasurements&amp;);</span>
<span class="line-removed">548     void updateRubyForJustifiedText(RenderRubyRun&amp;, BidiRun&amp;, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned&amp; expansionOpportunityCount, float&amp; totalLogicalWidth, float availableLogicalWidth, size_t&amp; expansionIndex);</span>
<span class="line-removed">549     void computeExpansionForJustifiedText(BidiRun* firstRun, BidiRun* trailingSpaceRun, const Vector&lt;unsigned, 16&gt;&amp; expansionOpportunities, unsigned expansionOpportunityCount, float totalLogicalWidth, float availableLogicalWidth);</span>
<span class="line-removed">550     BidiRun* computeInlineDirectionPositionsForSegment(RootInlineBox*, const LineInfo&amp;, TextAlignMode, float&amp; logicalLeft,</span>
<span class="line-removed">551         float&amp; availableLogicalWidth, BidiRun* firstRun, BidiRun* trailingSpaceRun, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp;, WordMeasurements&amp;);</span>
<span class="line-removed">552     void computeBlockDirectionPositionsForLine(RootInlineBox*, BidiRun*, GlyphOverflowAndFallbackFontsMap&amp;, VerticalPositionCache&amp;);</span>
<span class="line-removed">553     BidiRun* handleTrailingSpaces(BidiRunList&lt;BidiRun&gt;&amp;, BidiContext*);</span>
<span class="line-removed">554     void appendFloatingObjectToLastLine(FloatingObject&amp;);</span>
<span class="line-removed">555     // Helper function for layoutInlineChildren()</span>
<span class="line-removed">556     RootInlineBox* createLineBoxesFromBidiRuns(unsigned bidiLevel, BidiRunList&lt;BidiRun&gt;&amp;, const InlineIterator&amp; end, LineInfo&amp;, VerticalPositionCache&amp;, BidiRun* trailingSpaceRun, WordMeasurements&amp;);</span>
<span class="line-removed">557     void layoutRunsAndFloats(LineLayoutState&amp;, bool hasInlineChild);</span>
<span class="line-removed">558     const InlineIterator&amp; restartLayoutRunsAndFloatsInRange(LayoutUnit oldLogicalHeight, LayoutUnit newLogicalHeight,  FloatingObject* lastFloatFromPreviousLine, InlineBidiResolver&amp;,  const InlineIterator&amp;);</span>
<span class="line-removed">559     void layoutRunsAndFloatsInRange(LineLayoutState&amp;, InlineBidiResolver&amp;, const InlineIterator&amp; cleanLineStart, const BidiStatus&amp; cleanLineBidiStatus, unsigned consecutiveHyphenatedLines);</span>
<span class="line-removed">560     void reattachCleanLineFloats(RootInlineBox&amp; cleanLine, LayoutUnit delta, bool isFirstCleanLine);</span>
<span class="line-removed">561     void linkToEndLineIfNeeded(LineLayoutState&amp;);</span>
<span class="line-removed">562     void checkFloatInCleanLine(RootInlineBox&amp; cleanLine, RenderBox&amp; floatBoxOnCleanLine, FloatWithRect&amp; matchingFloatWithRect,</span>
<span class="line-removed">563         bool&amp; encounteredNewFloat, bool&amp; dirtiedByFloat);</span>
<span class="line-removed">564     RootInlineBox* determineStartPosition(LineLayoutState&amp;, InlineBidiResolver&amp;);</span>
<span class="line-removed">565     void determineEndPosition(LineLayoutState&amp;, RootInlineBox* startBox, InlineIterator&amp; cleanLineStart, BidiStatus&amp; cleanLineBidiStatus);</span>
<span class="line-removed">566     bool checkPaginationAndFloatsAtEndLine(LineLayoutState&amp;);</span>
<span class="line-removed">567     bool matchedEndLine(LineLayoutState&amp;, const InlineBidiResolver&amp;, const InlineIterator&amp; endLineStart, const BidiStatus&amp; endLineStatus);</span>
<span class="line-removed">568     void deleteEllipsisLineBoxes();</span>
<span class="line-removed">569     void checkLinesForTextOverflow();</span>
<span class="line-removed">570     // Positions new floats and also adjust all floats encountered on the line if any of them</span>
<span class="line-removed">571     // have to move to the next page/column.</span>
<span class="line-removed">572     bool positionNewFloatOnLine(const FloatingObject&amp; newFloat, FloatingObject* lastFloatFromPreviousLine, LineInfo&amp;, LineWidth&amp;);</span>
<span class="line-removed">573     // This function is called to test a line box that has moved in the block direction to see if it has ended up in a new</span>
<span class="line-removed">574     // page/column that has a different available line width than the old one. Used to know when you have to dirty a</span>
<span class="line-removed">575     // line, i.e., that it can&#39;t be re-used.</span>
<span class="line-removed">576     bool lineWidthForPaginatedLineChanged(RootInlineBox*, LayoutUnit lineDelta, RenderFragmentedFlow*) const;</span>
<span class="line-removed">577     void updateLogicalWidthForAlignment(const TextAlignMode&amp;, const RootInlineBox*, BidiRun* trailingSpaceRun, float&amp; logicalLeft, float&amp; totalLogicalWidth, float&amp; availableLogicalWidth, int expansionOpportunityCount);</span>
<span class="line-removed">578 // END METHODS DEFINED IN RenderBlockLineLayout</span>
<span class="line-removed">579 </span>
580     void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
<span class="line-removed">581 </span>
582     void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
583 
584 #if ENABLE(TEXT_AUTOSIZING)
585     int m_widthForTextAutosizing;
586     unsigned m_lineCountForTextAutosizing : 2;
587 #endif
588     void setSelectionState(SelectionState) final;
589 
<span class="line-removed">590     void removeInlineBox(BidiRun&amp;, const RootInlineBox&amp;) const;</span>
<span class="line-removed">591 </span>
592 public:
593     // FIXME-BLOCKFLOW: These can be made protected again once all callers have been moved here.
594     void adjustLinePositionForPagination(RootInlineBox*, LayoutUnit&amp; deltaOffset, bool&amp; overflowsFragment, RenderFragmentedFlow*); // Computes a deltaOffset value that put a line at the top of the next page if it doesn&#39;t fit on the current page.
<span class="line-removed">595     void updateFragmentForLine(RootInlineBox*) const;</span>
596 
597     // Pagination routines.
598     bool relayoutForPagination();
599 
600     bool hasRareBlockFlowData() const { return m_rareBlockFlowData.get(); }
601     RenderBlockFlowRareData* rareBlockFlowData() const { ASSERT_WITH_SECURITY_IMPLICATION(hasRareBlockFlowData()); return m_rareBlockFlowData.get(); }
602     RenderBlockFlowRareData&amp; ensureRareBlockFlowData();
603     void materializeRareBlockFlowData();
604 
605 #if ENABLE(TEXT_AUTOSIZING)
606     int lineCountForTextAutosizing();
607     void adjustComputedFontSizes(float size, float visibleWidth);
608     void resetComputedFontSize()
609     {
610         m_widthForTextAutosizing = -1;
611         m_lineCountForTextAutosizing = NOT_SET;
612     }
613 #endif
614 
615 protected:
616     std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
617     std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
<span class="line-modified">618     RenderLineBoxList m_lineBoxes;</span>


619     std::unique_ptr&lt;SimpleLineLayout::Layout&gt; m_simpleLineLayout;
620 
621     friend class LineBreaker;
622     friend class LineWidth; // Needs to know FloatingObject

623 };
624 
625 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
626 {
627     ASSERT(lineLayoutPath() == SimpleLinesPath || !m_simpleLineLayout);
628     return m_simpleLineLayout.get();
629 }
630 
631 } // namespace WebCore
632 
633 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
</pre>
</td>
<td>
<hr />
<pre>
  5  * Copyright (C) 2003-2013,  Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
<span class="line-added"> 25 #include &quot;ComplexLineLayout.h&quot;</span>
 26 #include &quot;FloatingObjects.h&quot;
 27 #include &quot;LineWidth.h&quot;
 28 #include &quot;RenderBlock.h&quot;
 29 #include &quot;RenderLineBoxList.h&quot;
 30 #include &quot;SimpleLineLayout.h&quot;
 31 #include &quot;TrailingObjects.h&quot;
 32 #include &lt;memory&gt;
 33 
 34 namespace WebCore {
 35 

 36 class LineBreaker;

 37 class RenderMultiColumnFlow;
 38 class RenderRubyRun;
 39 





 40 #if ENABLE(TEXT_AUTOSIZING)
 41 enum LineCount {
 42     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 43 };
 44 #endif
 45 
 46 class RenderBlockFlow : public RenderBlock {
 47     WTF_MAKE_ISO_ALLOCATED(RenderBlockFlow);
 48 public:
 49     RenderBlockFlow(Element&amp;, RenderStyle&amp;&amp;);
 50     RenderBlockFlow(Document&amp;, RenderStyle&amp;&amp;);
 51     virtual ~RenderBlockFlow();
 52 
 53     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 54 
 55 protected:
 56     void willBeDestroyed() override;
 57 
 58     // This method is called at the start of layout to wipe away all of the floats in our floating objects list. It also
 59     // repopulates the list with any floats that intrude from previous siblings or parents. Floats that were added by
 60     // descendants are gone when this call completes and will get added back later on after the children have gotten
 61     // a relayout.
 62     void rebuildFloatingObjectSetFromIntrudingFloats();
 63 
 64     // RenderBlockFlow always contains either lines or paragraphs. When the children are all blocks (e.g. paragraphs), we call layoutBlockChildren.
 65     // When the children are all inline (e.g., lines), we call layoutInlineChildren.
 66     void layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom);
 67     void layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 68 
 69     // RenderBlockFlows override these methods, since they are the only class that supports margin collapsing.
 70     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
 71     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 72 
<span class="line-modified"> 73     void dirtyLinesFromChangedChild(RenderObject&amp; child) final</span>
<span class="line-added"> 74     {</span>
<span class="line-added"> 75         if (m_complexLineLayout)</span>
<span class="line-added"> 76             m_complexLineLayout-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
<span class="line-added"> 77     }</span>
 78 
 79     void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
 80 
 81 public:
 82     class MarginValues {
 83     public:
 84         MarginValues(LayoutUnit beforePos, LayoutUnit beforeNeg, LayoutUnit afterPos, LayoutUnit afterNeg)
 85             : m_positiveMarginBefore(beforePos)
 86             , m_negativeMarginBefore(beforeNeg)
 87             , m_positiveMarginAfter(afterPos)
 88             , m_negativeMarginAfter(afterNeg)
 89         {
 90         }
 91 
 92         LayoutUnit positiveMarginBefore() const { return m_positiveMarginBefore; }
 93         LayoutUnit negativeMarginBefore() const { return m_negativeMarginBefore; }
 94         LayoutUnit positiveMarginAfter() const { return m_positiveMarginAfter; }
 95         LayoutUnit negativeMarginAfter() const { return m_negativeMarginAfter; }
 96 
 97         void setPositiveMarginBefore(LayoutUnit pos) { m_positiveMarginBefore = pos; }
</pre>
<hr />
<pre>
218         bool canCollapseMarginBeforeWithChildren() const { return m_canCollapseMarginBeforeWithChildren; }
219         bool canCollapseMarginAfterWithChildren() const { return m_canCollapseMarginAfterWithChildren; }
220         bool quirkContainer() const { return m_quirkContainer; }
221         bool determinedMarginBeforeQuirk() const { return m_determinedMarginBeforeQuirk; }
222         bool hasMarginBeforeQuirk() const { return m_hasMarginBeforeQuirk; }
223         bool hasMarginAfterQuirk() const { return m_hasMarginAfterQuirk; }
224         LayoutUnit positiveMargin() const { return m_positiveMargin; }
225         LayoutUnit negativeMargin() const { return m_negativeMargin; }
226         bool discardMargin() const { return m_discardMargin; }
227         LayoutUnit margin() const { return m_positiveMargin - m_negativeMargin; }
228     };
229     LayoutUnit marginOffsetForSelfCollapsingBlock();
230 
231     void layoutBlockChild(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom);
232     void adjustPositionedBlock(RenderBox&amp; child, const MarginInfo&amp;);
233     void adjustFloatingBlock(const MarginInfo&amp;);
234 
235     void setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition);
236     void updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText);
237 
<span class="line-added">238     LayoutUnit startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot);</span>
<span class="line-added">239 </span>
240     LayoutUnit collapseMargins(RenderBox&amp; child, MarginInfo&amp;);
241     LayoutUnit collapseMarginsWithChildInfo(RenderBox* child, RenderObject* prevSibling, MarginInfo&amp;);
242 
243     LayoutUnit clearFloatsIfNeeded(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit oldTopPosMargin, LayoutUnit oldTopNegMargin, LayoutUnit yPos);
244     LayoutUnit estimateLogicalTopPosition(RenderBox&amp; child, const MarginInfo&amp;, LayoutUnit&amp; estimateWithoutPagination);
245     void marginBeforeEstimateForChild(RenderBox&amp;, LayoutUnit&amp;, LayoutUnit&amp;, bool&amp;) const;
246     void handleAfterSideOfBlock(LayoutUnit top, LayoutUnit bottom, MarginInfo&amp;);
247     void setCollapsedBottomMargin(const MarginInfo&amp;);
248 
249     bool childrenPreventSelfCollapsing() const final;
250 
251     bool shouldBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow &gt;= 0; }
252     void clearShouldBreakAtLineToAvoidWidow() const;
253     int lineBreakToAvoidWidow() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow : -1; }
254     void setBreakAtLineToAvoidWidow(int);
255     void clearDidBreakAtLineToAvoidWidow();
256     void setDidBreakAtLineToAvoidWidow();
257     bool didBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow; }
258     bool relayoutToAvoidWidows();
259 
260     RootInlineBox* lineGridBox() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineGridBox.get() : nullptr; }
261     void setLineGridBox(std::unique_ptr&lt;RootInlineBox&gt; box)
262     {
263         ensureRareBlockFlowData().m_lineGridBox = WTFMove(box);
264     }
265     void layoutLineGridBox();
266 
<span class="line-modified">267     RenderMultiColumnFlow* multiColumnFlow() const { return hasRareBlockFlowData() ? multiColumnFlowSlowCase() : nullptr; }</span>
<span class="line-added">268     RenderMultiColumnFlow* multiColumnFlowSlowCase() const;</span>
269     void setMultiColumnFlow(RenderMultiColumnFlow&amp;);
270     void clearMultiColumnFlow();
271     bool willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount = WTF::nullopt) const;
272     virtual bool requiresColumns(int) const;
273 
274     bool containsFloats() const override { return m_floatingObjects &amp;&amp; !m_floatingObjects-&gt;set().isEmpty(); }
275     bool containsFloat(RenderBox&amp;) const;
276 
277     void deleteLines() override;
278     void computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats = false) override;
279     Position positionForPoint(const LayoutPoint&amp;) override;
280     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
281 
282     LayoutUnit lowestFloatLogicalBottom(FloatingObject::Type = FloatingObject::FloatLeftRight) const;
283 
284     void removeFloatingObjects();
285     void markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove = nullptr, bool inLayout = true);
286     void markSiblingsWithFloatsForLayout(RenderBox* floatToRemove = nullptr);
287 
288     const FloatingObjectSet* floatingObjectSet() const { return m_floatingObjects ? &amp;m_floatingObjects-&gt;set() : nullptr; }
</pre>
<hr />
<pre>
315         else
316             floatingObject.setWidth(logicalHeight);
317     }
318     void setLogicalWidthForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalWidth)
319     {
320         if (isHorizontalWritingMode())
321             floatingObject.setWidth(logicalWidth);
322         else
323             floatingObject.setHeight(logicalWidth);
324     }
325     void setLogicalMarginsForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeftMargin, LayoutUnit logicalBeforeMargin)
326     {
327         if (isHorizontalWritingMode())
328             floatingObject.setMarginOffset(LayoutSize(logicalLeftMargin, logicalBeforeMargin));
329         else
330             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
331     }
332 
333     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
334 
<span class="line-modified">335     RootInlineBox* firstRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">336     RootInlineBox* lastRootBox() const { return m_complexLineLayout ? m_complexLineLayout-&gt;lastRootBox() : nullptr; }</span>



337 
338     bool hasLines() const;
339     void invalidateLineLayoutPath() final;
340 
341     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, ForceLineBoxesPath };
342     LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
343     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
344 
345     // Helper methods for computing line counts and heights for line counts.
346     RootInlineBox* lineAtIndex(int) const;
347     int lineCount(const RootInlineBox* = nullptr, bool* = nullptr) const;
348     int heightForLineCount(int);
349     void clearTruncation();
350 
351     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
352     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
353 
354     bool containsNonZeroBidiLevel() const;
355 
356     const SimpleLineLayout::Layout* simpleLineLayout() const;
</pre>
<hr />
<pre>
464     LayoutUnit columnGap() const;
465 
466     RenderBlockFlow* previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const;
467 
468     void checkForPaginationLogicalHeightChange(bool&amp; relayoutChildren, LayoutUnit&amp; pageLogicalHeight, bool&amp; pageLogicalHeightChanged);
469 
470     void paintInlineChildren(PaintInfo&amp;, const LayoutPoint&amp;) override;
471     void paintFloats(PaintInfo&amp;, const LayoutPoint&amp;, bool preservePhase = false) override;
472 
473     void repaintOverhangingFloats(bool paintAllDescendants) final;
474     void clipOutFloatingObjects(RenderBlock&amp;, const PaintInfo*, const LayoutPoint&amp;, const LayoutSize&amp;) override;
475 
476     FloatingObject* insertFloatingObject(RenderBox&amp;);
477     void removeFloatingObject(RenderBox&amp;);
478     void removeFloatingObjectsBelow(FloatingObject*, int logicalOffset);
479     void computeLogicalLocationForFloat(FloatingObject&amp;, LayoutUnit&amp; logicalTopOffset);
480 
481     // Called from lineWidth, to position the floats added in the last line.
482     // Returns true if and only if it has positioned any floats.
483     bool positionNewFloats();

484     void clearFloats(Clear);
<span class="line-added">485     FloatingObjects* floatingObjects() { return m_floatingObjects.get(); }</span>
486 
487     LayoutUnit logicalRightFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
488     LayoutUnit logicalLeftFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
489 
490     LayoutUnit logicalRightOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
491     LayoutUnit logicalLeftOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
492 
493     LayoutUnit lowestInitialLetterLogicalBottom() const;
494 
495     LayoutUnit nextFloatLogicalBottomBelow(LayoutUnit) const;
496     LayoutUnit nextFloatLogicalBottomBelowForBlock(LayoutUnit) const;
497 
498     LayoutUnit addOverhangingFloats(RenderBlockFlow&amp; child, bool makeChildPaintOtherFloats);
499     bool hasOverhangingFloat(RenderBox&amp;);
500     void addIntrudingFloats(RenderBlockFlow* prev, RenderBlockFlow* container, LayoutUnit xoffset, LayoutUnit yoffset);
501     bool hasOverhangingFloats() { return parent() &amp;&amp; containsFloats() &amp;&amp; lowestFloatLogicalBottom() &gt; logicalHeight(); }
502     LayoutUnit getClearDelta(RenderBox&amp; child, LayoutUnit yPos);
503 
504     void determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
505 
506     bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset) override;
507     bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
508 
509     void addOverflowFromInlineChildren() override;
510 
511     void fitBorderToLinesIfNeeded(); // Shrink the box in which the border paints if border-fit is set.
512     void adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
513 
514     void markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest = 0);
515 
516     GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
517         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*) override;
518 
519     Position positionForBox(InlineBox*, bool start = true) const;
520     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
521     void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
522 




523 public:
<span class="line-modified">524     ComplexLineLayout* complexLineLayout() { return m_complexLineLayout.get(); }</span>

525 
<span class="line-modified">526     virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }</span>

527     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }

528 
529 private:



530     void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
531 
<span class="line-modified">532     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;</span>



































533     void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;

534     void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
535 
536 #if ENABLE(TEXT_AUTOSIZING)
537     int m_widthForTextAutosizing;
538     unsigned m_lineCountForTextAutosizing : 2;
539 #endif
540     void setSelectionState(SelectionState) final;
541 


542 public:
543     // FIXME-BLOCKFLOW: These can be made protected again once all callers have been moved here.
544     void adjustLinePositionForPagination(RootInlineBox*, LayoutUnit&amp; deltaOffset, bool&amp; overflowsFragment, RenderFragmentedFlow*); // Computes a deltaOffset value that put a line at the top of the next page if it doesn&#39;t fit on the current page.

545 
546     // Pagination routines.
547     bool relayoutForPagination();
548 
549     bool hasRareBlockFlowData() const { return m_rareBlockFlowData.get(); }
550     RenderBlockFlowRareData* rareBlockFlowData() const { ASSERT_WITH_SECURITY_IMPLICATION(hasRareBlockFlowData()); return m_rareBlockFlowData.get(); }
551     RenderBlockFlowRareData&amp; ensureRareBlockFlowData();
552     void materializeRareBlockFlowData();
553 
554 #if ENABLE(TEXT_AUTOSIZING)
555     int lineCountForTextAutosizing();
556     void adjustComputedFontSizes(float size, float visibleWidth);
557     void resetComputedFontSize()
558     {
559         m_widthForTextAutosizing = -1;
560         m_lineCountForTextAutosizing = NOT_SET;
561     }
562 #endif
563 
564 protected:
565     std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
566     std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
<span class="line-modified">567 </span>
<span class="line-added">568     // FIXME: Only one of these should be needed at any given time.</span>
<span class="line-added">569     std::unique_ptr&lt;ComplexLineLayout&gt; m_complexLineLayout;</span>
570     std::unique_ptr&lt;SimpleLineLayout::Layout&gt; m_simpleLineLayout;
571 
572     friend class LineBreaker;
573     friend class LineWidth; // Needs to know FloatingObject
<span class="line-added">574     friend class ComplexLineLayout;</span>
575 };
576 
577 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
578 {
579     ASSERT(lineLayoutPath() == SimpleLinesPath || !m_simpleLineLayout);
580     return m_simpleLineLayout.get();
581 }
582 
583 } // namespace WebCore
584 
585 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlockFlow.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>