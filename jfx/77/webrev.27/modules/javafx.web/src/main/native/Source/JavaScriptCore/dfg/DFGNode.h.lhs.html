<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;B3SparseCollection.h&quot;
  31 #include &quot;BasicBlockLocation.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;DFGAdjacencyList.h&quot;
  34 #include &quot;DFGArithMode.h&quot;
  35 #include &quot;DFGArrayMode.h&quot;
  36 #include &quot;DFGCommon.h&quot;
  37 #include &quot;DFGEpoch.h&quot;
  38 #include &quot;DFGLazyJSValue.h&quot;
  39 #include &quot;DFGMultiGetByOffsetData.h&quot;
  40 #include &quot;DFGNodeFlags.h&quot;
  41 #include &quot;DFGNodeOrigin.h&quot;
  42 #include &quot;DFGNodeType.h&quot;
  43 #include &quot;DFGObjectMaterializationData.h&quot;
  44 #include &quot;DFGOpInfo.h&quot;
  45 #include &quot;DFGRegisteredStructure.h&quot;
  46 #include &quot;DFGRegisteredStructureSet.h&quot;
  47 #include &quot;DFGTransition.h&quot;
  48 #include &quot;DFGUseKind.h&quot;
  49 #include &quot;DFGVariableAccessData.h&quot;
  50 #include &quot;GetByIdVariant.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;Operands.h&quot;
  53 #include &quot;PutByIdVariant.h&quot;
  54 #include &quot;SpeculatedType.h&quot;
  55 #include &quot;TypeLocation.h&quot;
  56 #include &quot;ValueProfile.h&quot;
  57 #include &lt;type_traits&gt;
  58 #include &lt;wtf/ListDump.h&gt;
  59 #include &lt;wtf/LoggingHashSet.h&gt;
  60 
  61 namespace JSC {
  62 
  63 namespace DOMJIT {
  64 class GetterSetter;
  65 class CallDOMGetterSnippet;
  66 class Signature;
  67 }
  68 
  69 namespace Profiler {
  70 class ExecutionCounter;
  71 }
  72 
  73 class Snippet;
  74 
  75 namespace DFG {
  76 
  77 class Graph;
  78 class PromotedLocationDescriptor;
  79 struct BasicBlock;
  80 
  81 struct StorageAccessData {
  82     PropertyOffset offset;
  83     unsigned identifierNumber;
  84 };
  85 
  86 struct MultiPutByOffsetData {
  87     unsigned identifierNumber;
  88     Vector&lt;PutByIdVariant, 2&gt; variants;
  89 
  90     bool writesStructures() const;
  91     bool reallocatesStorage() const;
  92 };
  93 
  94 struct MatchStructureVariant {
  95     RegisteredStructure structure;
  96     bool result;
  97 };
  98 
  99 struct MatchStructureData {
 100     Vector&lt;MatchStructureVariant, 2&gt; variants;
 101 };
 102 
 103 struct NewArrayBufferData {
 104     union {
 105         struct {
 106             unsigned vectorLengthHint;
 107             unsigned indexingMode;
 108         };
 109         uint64_t asQuadWord;
 110     };
 111 };
 112 static_assert(sizeof(IndexingType) &lt;= sizeof(unsigned), &quot;&quot;);
 113 static_assert(sizeof(NewArrayBufferData) == sizeof(uint64_t), &quot;&quot;);
 114 
 115 struct DataViewData {
 116     union {
 117         struct {
 118             uint8_t byteSize;
 119             bool isSigned;
 120             bool isFloatingPoint; // Used for the DataViewSet node.
 121             TriState isLittleEndian;
 122         };
 123         uint64_t asQuadWord;
 124     };
 125 };
 126 static_assert(sizeof(DataViewData) == sizeof(uint64_t), &quot;&quot;);
 127 
 128 struct BranchTarget {
 129     BranchTarget()
 130         : block(0)
 131         , count(PNaN)
 132     {
 133     }
 134 
 135     explicit BranchTarget(BasicBlock* block)
 136         : block(block)
 137         , count(PNaN)
 138     {
 139     }
 140 
 141     void setBytecodeIndex(unsigned bytecodeIndex)
 142     {
 143         block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(bytecodeIndex));
 144     }
 145     unsigned bytecodeIndex() const { return bitwise_cast&lt;uintptr_t&gt;(block); }
 146 
 147     void dump(PrintStream&amp;) const;
 148 
 149     BasicBlock* block;
 150     float count;
 151 };
 152 
 153 struct BranchData {
 154     static BranchData withBytecodeIndices(
 155         unsigned takenBytecodeIndex, unsigned notTakenBytecodeIndex)
 156     {
 157         BranchData result;
 158         result.taken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(takenBytecodeIndex));
 159         result.notTaken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(notTakenBytecodeIndex));
 160         return result;
 161     }
 162 
 163     unsigned takenBytecodeIndex() const { return taken.bytecodeIndex(); }
 164     unsigned notTakenBytecodeIndex() const { return notTaken.bytecodeIndex(); }
 165 
 166     BasicBlock*&amp; forCondition(bool condition)
 167     {
 168         if (condition)
 169             return taken.block;
 170         return notTaken.block;
 171     }
 172 
 173     BranchTarget taken;
 174     BranchTarget notTaken;
 175 };
 176 
 177 // The SwitchData and associated data structures duplicate the information in
 178 // JumpTable. The DFG may ultimately end up using the JumpTable, though it may
 179 // instead decide to do something different - this is entirely up to the DFG.
 180 // These data structures give the DFG a higher-level semantic description of
 181 // what is going on, which will allow it to make the right decision.
 182 //
 183 // Note that there will never be multiple SwitchCases in SwitchData::cases that
 184 // have the same SwitchCase::value, since the bytecode&#39;s JumpTables never have
 185 // duplicates - since the JumpTable maps a value to a target. It&#39;s a
 186 // one-to-many mapping. So we may have duplicate targets, but never duplicate
 187 // values.
 188 struct SwitchCase {
 189     SwitchCase()
 190     {
 191     }
 192 
 193     SwitchCase(LazyJSValue value, BasicBlock* target)
 194         : value(value)
 195         , target(target)
 196     {
 197     }
 198 
 199     static SwitchCase withBytecodeIndex(LazyJSValue value, unsigned bytecodeIndex)
 200     {
 201         SwitchCase result;
 202         result.value = value;
 203         result.target.setBytecodeIndex(bytecodeIndex);
 204         return result;
 205     }
 206 
 207     LazyJSValue value;
 208     BranchTarget target;
 209 };
 210 
 211 struct SwitchData {
 212     // Initializes most fields to obviously invalid values. Anyone
 213     // constructing this should make sure to initialize everything they
 214     // care about manually.
 215     SwitchData()
<a name="1" id="anc1"></a><span class="line-modified"> 216         : kind(static_cast&lt;SwitchKind&gt;(-1))</span>
<span class="line-modified"> 217         , switchTableIndex(UINT_MAX)</span>
 218         , didUseJumpTable(false)
 219     {
 220     }
 221 
 222     Vector&lt;SwitchCase&gt; cases;
 223     BranchTarget fallThrough;
<a name="2" id="anc2"></a><span class="line-removed"> 224     SwitchKind kind;</span>
 225     size_t switchTableIndex;
<a name="3" id="anc3"></a>
 226     bool didUseJumpTable;
 227 };
 228 
 229 struct EntrySwitchData {
 230     Vector&lt;BasicBlock*&gt; cases;
 231 };
 232 
 233 struct CallVarargsData {
 234     int firstVarArgOffset;
 235 };
 236 
 237 struct LoadVarargsData {
 238     VirtualRegister start; // Local for the first element. This is the first actual argument, not this.
 239     VirtualRegister count; // Local for the count.
 240     VirtualRegister machineStart;
 241     VirtualRegister machineCount;
 242     unsigned offset; // Which array element to start with. Usually this is 0.
 243     unsigned mandatoryMinimum; // The number of elements on the stack that must be initialized; if the array is too short then the missing elements must get undefined. Does not include &quot;this&quot;.
 244     unsigned limit; // Maximum number of elements to load. Includes &quot;this&quot;.
 245 };
 246 
 247 struct StackAccessData {
 248     StackAccessData()
 249         : format(DeadFlush)
 250     {
 251     }
 252 
 253     StackAccessData(VirtualRegister local, FlushFormat format)
 254         : local(local)
 255         , format(format)
 256     {
 257     }
 258 
 259     VirtualRegister local;
 260     VirtualRegister machineLocal;
 261     FlushFormat format;
 262 
 263     FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
 264 };
 265 
 266 struct CallDOMGetterData {
 267     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
 268     const DOMJIT::GetterSetter* domJIT { nullptr };
 269     DOMJIT::CallDOMGetterSnippet* snippet { nullptr };
 270     unsigned identifierNumber { 0 };
 271 };
 272 
 273 enum class BucketOwnerType : uint32_t {
 274     Map,
 275     Set
 276 };
 277 
 278 // === Node ===
 279 //
 280 // Node represents a single operation in the data flow graph.
 281 struct Node {
 282     WTF_MAKE_FAST_ALLOCATED;
 283 public:
 284     static const char HashSetTemplateInstantiationString[];
 285 
 286     enum VarArgTag { VarArg };
 287 
 288     Node() { }
 289 
 290     Node(NodeType op, NodeOrigin nodeOrigin, const AdjacencyList&amp; children)
 291         : origin(nodeOrigin)
 292         , children(children)
 293         , m_virtualRegister(VirtualRegister())
 294         , m_refCount(1)
 295         , m_prediction(SpecNone)
 296         , owner(nullptr)
 297     {
 298         m_misc.replacement = nullptr;
 299         setOpAndDefaultFlags(op);
 300     }
 301 
 302     // Construct a node with up to 3 children, no immediate value.
 303     Node(NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 304         : origin(nodeOrigin)
 305         , children(AdjacencyList::Fixed, child1, child2, child3)
 306         , m_virtualRegister(VirtualRegister())
 307         , m_refCount(1)
 308         , m_prediction(SpecNone)
 309         , owner(nullptr)
 310     {
 311         m_misc.replacement = nullptr;
 312         setOpAndDefaultFlags(op);
 313         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 314     }
 315 
 316     // Construct a node with up to 3 children, no immediate value.
 317     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 318         : origin(nodeOrigin)
 319         , children(AdjacencyList::Fixed, child1, child2, child3)
 320         , m_virtualRegister(VirtualRegister())
 321         , m_refCount(1)
 322         , m_prediction(SpecNone)
 323         , owner(nullptr)
 324     {
 325         m_misc.replacement = nullptr;
 326         setOpAndDefaultFlags(op);
 327         setResult(result);
 328         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 329     }
 330 
 331     // Construct a node with up to 3 children and an immediate value.
 332     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 333         : origin(nodeOrigin)
 334         , children(AdjacencyList::Fixed, child1, child2, child3)
 335         , m_virtualRegister(VirtualRegister())
 336         , m_refCount(1)
 337         , m_prediction(SpecNone)
 338         , m_opInfo(imm.m_value)
 339         , owner(nullptr)
 340     {
 341         m_misc.replacement = nullptr;
 342         setOpAndDefaultFlags(op);
 343         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 344     }
 345 
 346     // Construct a node with up to 3 children and an immediate value.
 347     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 348         : origin(nodeOrigin)
 349         , children(AdjacencyList::Fixed, child1, child2, child3)
 350         , m_virtualRegister(VirtualRegister())
 351         , m_refCount(1)
 352         , m_prediction(SpecNone)
 353         , m_opInfo(imm.m_value)
 354         , owner(nullptr)
 355     {
 356         m_misc.replacement = nullptr;
 357         setOpAndDefaultFlags(op);
 358         setResult(result);
 359         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 360     }
 361 
 362     // Construct a node with up to 3 children and two immediate values.
 363     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 364         : origin(nodeOrigin)
 365         , children(AdjacencyList::Fixed, child1, child2, child3)
 366         , m_virtualRegister(VirtualRegister())
 367         , m_refCount(1)
 368         , m_prediction(SpecNone)
 369         , m_opInfo(imm1.m_value)
 370         , m_opInfo2(imm2.m_value)
 371         , owner(nullptr)
 372     {
 373         m_misc.replacement = nullptr;
 374         setOpAndDefaultFlags(op);
 375         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 376     }
 377 
 378     // Construct a node with a variable number of children and two immediate values.
 379     Node(VarArgTag, NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, unsigned firstChild, unsigned numChildren)
 380         : origin(nodeOrigin)
 381         , children(AdjacencyList::Variable, firstChild, numChildren)
 382         , m_virtualRegister(VirtualRegister())
 383         , m_refCount(1)
 384         , m_prediction(SpecNone)
 385         , m_opInfo(imm1.m_value)
 386         , m_opInfo2(imm2.m_value)
 387         , owner(nullptr)
 388     {
 389         m_misc.replacement = nullptr;
 390         setOpAndDefaultFlags(op);
 391         ASSERT(m_flags &amp; NodeHasVarArgs);
 392     }
 393 
 394     NodeType op() const { return static_cast&lt;NodeType&gt;(m_op); }
 395     NodeFlags flags() const { return m_flags; }
 396 
 397     unsigned index() const { return m_index; }
 398 
 399     void setOp(NodeType op)
 400     {
 401         m_op = op;
 402     }
 403 
 404     void setFlags(NodeFlags flags)
 405     {
 406         m_flags = flags;
 407     }
 408 
 409     bool mergeFlags(NodeFlags flags)
 410     {
 411         NodeFlags newFlags = m_flags | flags;
 412         if (newFlags == m_flags)
 413             return false;
 414         m_flags = newFlags;
 415         return true;
 416     }
 417 
 418     bool filterFlags(NodeFlags flags)
 419     {
 420         NodeFlags newFlags = m_flags &amp; flags;
 421         if (newFlags == m_flags)
 422             return false;
 423         m_flags = newFlags;
 424         return true;
 425     }
 426 
 427     bool clearFlags(NodeFlags flags)
 428     {
 429         return filterFlags(~flags);
 430     }
 431 
 432     void setResult(NodeFlags result)
 433     {
 434         ASSERT(!(result &amp; ~NodeResultMask));
 435         clearFlags(NodeResultMask);
 436         mergeFlags(result);
 437     }
 438 
 439     NodeFlags result() const
 440     {
 441         return flags() &amp; NodeResultMask;
 442     }
 443 
 444     void setOpAndDefaultFlags(NodeType op)
 445     {
 446         m_op = op;
 447         m_flags = defaultFlags(op);
 448     }
 449 
 450     void remove(Graph&amp;);
 451     void removeWithoutChecks();
 452 
 453     void convertToCheckStructure(RegisteredStructureSet* set)
 454     {
 455         setOpAndDefaultFlags(CheckStructure);
 456         m_opInfo = set;
 457     }
 458 
 459     void convertToCheckStructureOrEmpty(RegisteredStructureSet* set)
 460     {
 461         if (SpecCellCheck &amp; SpecEmpty)
 462             setOpAndDefaultFlags(CheckStructureOrEmpty);
 463         else
 464             setOpAndDefaultFlags(CheckStructure);
 465         m_opInfo = set;
 466     }
 467 
 468     void convertCheckStructureOrEmptyToCheckStructure()
 469     {
 470         ASSERT(op() == CheckStructureOrEmpty);
 471         setOpAndDefaultFlags(CheckStructure);
 472     }
 473 
 474     void convertToCheckStructureImmediate(Node* structure)
 475     {
 476         ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
 477         m_op = CheckStructureImmediate;
 478         children.setChild1(Edge(structure, CellUse));
 479     }
 480 
 481     void replaceWith(Graph&amp;, Node* other);
 482     void replaceWithWithoutChecks(Node* other);
 483 
 484     void convertToIdentity();
 485     void convertToIdentityOn(Node*);
 486 
 487     bool mustGenerate()
 488     {
 489         return m_flags &amp; NodeMustGenerate;
 490     }
 491 
 492     bool isConstant()
 493     {
 494         switch (op()) {
 495         case JSConstant:
 496         case DoubleConstant:
 497         case Int52Constant:
 498             return true;
 499         default:
 500             return false;
 501         }
 502     }
 503 
 504     bool hasConstant()
 505     {
 506         switch (op()) {
 507         case JSConstant:
 508         case DoubleConstant:
 509         case Int52Constant:
 510             return true;
 511 
 512         case PhantomDirectArguments:
 513         case PhantomClonedArguments:
 514             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 515             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 516             return true;
 517 
 518         default:
 519             return false;
 520         }
 521     }
 522 
 523     FrozenValue* constant()
 524     {
 525         ASSERT(hasConstant());
 526 
 527         if (op() == PhantomDirectArguments || op() == PhantomClonedArguments) {
 528             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 529             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 530             return FrozenValue::emptySingleton();
 531         }
 532 
 533         return m_opInfo.as&lt;FrozenValue*&gt;();
 534     }
 535 
 536     // Don&#39;t call this directly - use Graph::convertToConstant() instead!
 537     void convertToConstant(FrozenValue* value)
 538     {
 539         if (hasDoubleResult())
 540             m_op = DoubleConstant;
 541         else if (hasInt52Result())
 542             m_op = Int52Constant;
 543         else
 544             m_op = JSConstant;
 545         m_flags &amp;= ~(NodeMustGenerate | NodeHasVarArgs);
 546         m_opInfo = value;
 547         children.reset();
 548     }
 549 
 550     void convertToLazyJSConstant(Graph&amp;, LazyJSValue);
 551 
 552     void convertToConstantStoragePointer(void* pointer)
 553     {
 554         ASSERT(op() == GetIndexedPropertyStorage);
 555         m_op = ConstantStoragePointer;
 556         m_opInfo = pointer;
 557         children.reset();
 558     }
 559 
 560     void convertToPutStack(StackAccessData* data)
 561     {
 562         m_op = PutStack;
 563         m_flags |= NodeMustGenerate;
 564         m_opInfo = data;
 565         m_opInfo2 = OpInfoWrapper();
 566     }
 567 
 568     void convertToGetStack(StackAccessData* data)
 569     {
 570         m_op = GetStack;
 571         m_flags &amp;= ~NodeMustGenerate;
 572         m_opInfo = data;
 573         m_opInfo2 = OpInfoWrapper();
 574         children.reset();
 575     }
 576 
 577     void convertToGetByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 578     {
 579         ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush || m_op == MultiGetByOffset);
 580         m_opInfo = &amp;data;
 581         children.setChild1(storage);
 582         children.setChild2(base);
 583         m_op = GetByOffset;
 584         m_flags &amp;= ~NodeMustGenerate;
 585     }
 586 
 587     void convertToMultiGetByOffset(MultiGetByOffsetData* data)
 588     {
 589         RELEASE_ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush);
 590         m_opInfo = data;
 591         child1().setUseKind(CellUse);
 592         m_op = MultiGetByOffset;
 593         RELEASE_ASSERT(m_flags &amp; NodeMustGenerate);
 594     }
 595 
 596     void convertToPutByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 597     {
 598         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush || m_op == MultiPutByOffset);
 599         m_opInfo = &amp;data;
 600         children.setChild3(children.child2());
 601         children.setChild2(base);
 602         children.setChild1(storage);
 603         m_op = PutByOffset;
 604     }
 605 
 606     void convertToMultiPutByOffset(MultiPutByOffsetData* data)
 607     {
 608         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush);
 609         m_opInfo = data;
 610         m_op = MultiPutByOffset;
 611     }
 612 
 613     void convertToPhantomNewObject()
 614     {
 615         ASSERT(m_op == NewObject || m_op == MaterializeNewObject);
 616         m_op = PhantomNewObject;
 617         m_flags &amp;= ~NodeHasVarArgs;
 618         m_flags |= NodeMustGenerate;
 619         m_opInfo = OpInfoWrapper();
 620         m_opInfo2 = OpInfoWrapper();
 621         children = AdjacencyList();
 622     }
 623 
 624     void convertToPhantomNewFunction()
 625     {
 626         ASSERT(m_op == NewFunction || m_op == NewGeneratorFunction || m_op == NewAsyncFunction || m_op == NewAsyncGeneratorFunction);
 627         m_op = PhantomNewFunction;
 628         m_flags |= NodeMustGenerate;
 629         m_opInfo = OpInfoWrapper();
 630         m_opInfo2 = OpInfoWrapper();
 631         children = AdjacencyList();
 632     }
 633 
 634     void convertToPhantomNewGeneratorFunction()
 635     {
 636         ASSERT(m_op == NewGeneratorFunction);
 637         m_op = PhantomNewGeneratorFunction;
 638         m_flags |= NodeMustGenerate;
 639         m_opInfo = OpInfoWrapper();
 640         m_opInfo2 = OpInfoWrapper();
 641         children = AdjacencyList();
 642     }
 643 
 644     void convertToPhantomNewAsyncFunction()
 645     {
 646         ASSERT(m_op == NewAsyncFunction);
 647         m_op = PhantomNewAsyncFunction;
 648         m_flags |= NodeMustGenerate;
 649         m_opInfo = OpInfoWrapper();
 650         m_opInfo2 = OpInfoWrapper();
 651         children = AdjacencyList();
 652     }
 653 
 654     void convertToPhantomNewAsyncGeneratorFunction()
 655     {
 656         ASSERT(m_op == NewAsyncGeneratorFunction);
 657         m_op = PhantomNewAsyncGeneratorFunction;
 658         m_flags |= NodeMustGenerate;
 659         m_opInfo = OpInfoWrapper();
 660         m_opInfo2 = OpInfoWrapper();
 661         children = AdjacencyList();
 662     }
 663 
 664     void convertToPhantomCreateActivation()
 665     {
 666         ASSERT(m_op == CreateActivation || m_op == MaterializeCreateActivation);
 667         m_op = PhantomCreateActivation;
 668         m_flags &amp;= ~NodeHasVarArgs;
 669         m_flags |= NodeMustGenerate;
 670         m_opInfo = OpInfoWrapper();
 671         m_opInfo2 = OpInfoWrapper();
 672         children = AdjacencyList();
 673     }
 674 
 675     void convertToPhantomNewRegexp()
 676     {
 677         ASSERT(m_op == NewRegexp);
 678         setOpAndDefaultFlags(PhantomNewRegexp);
 679         m_opInfo = OpInfoWrapper();
 680         m_opInfo2 = OpInfoWrapper();
 681         children = AdjacencyList();
 682     }
 683 
 684     void convertPhantomToPhantomLocal()
 685     {
<a name="4" id="anc4"></a><span class="line-modified"> 686         ASSERT(m_op == Phantom &amp;&amp; (child1()-&gt;op() == Phi || child1()-&gt;op() == SetLocal || child1()-&gt;op() == SetArgument));</span>
 687         m_op = PhantomLocal;
 688         m_opInfo = child1()-&gt;m_opInfo; // Copy the variableAccessData.
 689         children.setChild1(Edge());
 690     }
 691 
 692     void convertFlushToPhantomLocal()
 693     {
 694         ASSERT(m_op == Flush);
 695         m_op = PhantomLocal;
 696         children = AdjacencyList();
 697     }
 698 
 699     void convertToToString()
 700     {
 701         ASSERT(m_op == ToPrimitive || m_op == StringValueOf);
 702         m_op = ToString;
 703     }
 704 
 705     void convertToArithNegate()
 706     {
 707         ASSERT(m_op == ArithAbs &amp;&amp; child1().useKind() == Int32Use);
 708         m_op = ArithNegate;
 709     }
 710 
 711     void convertToCompareEqPtr(FrozenValue* cell, Edge node)
 712     {
<a name="5" id="anc5"></a><span class="line-modified"> 713         ASSERT(m_op == CompareStrictEq);</span>
 714         setOpAndDefaultFlags(CompareEqPtr);
 715         children.setChild1(node);
 716         children.setChild2(Edge());
 717         m_opInfo = cell;
 718     }
 719 
 720     void convertToNumberToStringWithValidRadixConstant(int32_t radix)
 721     {
 722         ASSERT(m_op == NumberToStringWithRadix);
 723         ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
 724         setOpAndDefaultFlags(NumberToStringWithValidRadixConstant);
 725         children.setChild2(Edge());
 726         m_opInfo = radix;
 727     }
 728 
 729     void convertToGetGlobalThis()
 730     {
 731         ASSERT(m_op == ToThis);
 732         setOpAndDefaultFlags(GetGlobalThis);
 733         children.setChild1(Edge());
 734     }
 735 
 736     void convertToCallObjectConstructor(FrozenValue* globalObject)
 737     {
 738         ASSERT(m_op == ToObject);
 739         setOpAndDefaultFlags(CallObjectConstructor);
 740         m_opInfo = globalObject;
 741     }
 742 
 743     void convertToNewStringObject(RegisteredStructure structure)
 744     {
 745         ASSERT(m_op == CallObjectConstructor || m_op == ToObject);
 746         setOpAndDefaultFlags(NewStringObject);
 747         m_opInfo = structure;
 748         m_opInfo2 = OpInfoWrapper();
 749     }
 750 
 751     void convertToNewObject(RegisteredStructure structure)
 752     {
 753         ASSERT(m_op == CallObjectConstructor || m_op == CreateThis || m_op == ObjectCreate);
 754         setOpAndDefaultFlags(NewObject);
 755         children.reset();
 756         m_opInfo = structure;
 757         m_opInfo2 = OpInfoWrapper();
 758     }
 759 
 760     void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
 761 
 762     void convertToDirectCall(FrozenValue*);
 763 
 764     void convertToCallDOM(Graph&amp;);
 765 
 766     void convertToRegExpExecNonGlobalOrStickyWithoutChecks(FrozenValue* regExp);
 767     void convertToRegExpMatchFastGlobalWithoutChecks(FrozenValue* regExp);
 768 
 769     void convertToSetRegExpObjectLastIndex()
 770     {
 771         setOp(SetRegExpObjectLastIndex);
 772         m_opInfo = false;
 773     }
 774 
 775     void convertToInById(unsigned identifierNumber)
 776     {
 777         ASSERT(m_op == InByVal);
 778         setOpAndDefaultFlags(InById);
 779         children.setChild2(Edge());
 780         m_opInfo = identifierNumber;
 781         m_opInfo2 = OpInfoWrapper();
 782     }
 783 
 784     JSValue asJSValue()
 785     {
 786         return constant()-&gt;value();
 787     }
 788 
 789     bool isInt32Constant()
 790     {
 791         return isConstant() &amp;&amp; constant()-&gt;value().isInt32();
 792     }
 793 
 794     int32_t asInt32()
 795     {
 796         return asJSValue().asInt32();
 797     }
 798 
 799     uint32_t asUInt32()
 800     {
 801         return asInt32();
 802     }
 803 
 804     bool isDoubleConstant()
 805     {
 806         return isConstant() &amp;&amp; constant()-&gt;value().isDouble();
 807     }
 808 
 809     bool isNumberConstant()
 810     {
 811         return isConstant() &amp;&amp; constant()-&gt;value().isNumber();
 812     }
 813 
 814     double asNumber()
 815     {
 816         return asJSValue().asNumber();
 817     }
 818 
 819     bool isAnyIntConstant()
 820     {
 821         return isConstant() &amp;&amp; constant()-&gt;value().isAnyInt();
 822     }
 823 
 824     int64_t asAnyInt()
 825     {
 826         return asJSValue().asAnyInt();
 827     }
 828 
 829     bool isBooleanConstant()
 830     {
 831         return isConstant() &amp;&amp; constant()-&gt;value().isBoolean();
 832     }
 833 
 834     bool asBoolean()
 835     {
 836         return constant()-&gt;value().asBoolean();
 837     }
 838 
 839     bool isUndefinedOrNullConstant()
 840     {
 841         return isConstant() &amp;&amp; constant()-&gt;value().isUndefinedOrNull();
 842     }
 843 
 844     bool isCellConstant()
 845     {
 846         return isConstant() &amp;&amp; constant()-&gt;value() &amp;&amp; constant()-&gt;value().isCell();
 847     }
 848 
 849     JSCell* asCell()
 850     {
 851         return constant()-&gt;value().asCell();
 852     }
 853 
 854     template&lt;typename T&gt;
 855     T dynamicCastConstant(VM&amp; vm)
 856     {
 857         if (!isCellConstant())
 858             return nullptr;
 859         return jsDynamicCast&lt;T&gt;(vm, asCell());
 860     }
 861 
<a name="6" id="anc6"></a><span class="line-removed"> 862     template&lt;typename T&gt;</span>
<span class="line-removed"> 863     T castConstant(VM&amp; vm)</span>
<span class="line-removed"> 864     {</span>
<span class="line-removed"> 865         T result = dynamicCastConstant&lt;T&gt;(vm);</span>
<span class="line-removed"> 866         RELEASE_ASSERT(result);</span>
<span class="line-removed"> 867         return result;</span>
<span class="line-removed"> 868     }</span>
<span class="line-removed"> 869 </span>
 870     bool hasLazyJSValue()
 871     {
 872         return op() == LazyJSConstant;
 873     }
 874 
 875     LazyJSValue lazyJSValue()
 876     {
 877         ASSERT(hasLazyJSValue());
 878         return *m_opInfo.as&lt;LazyJSValue*&gt;();
 879     }
 880 
 881     String tryGetString(Graph&amp;);
 882 
 883     JSValue initializationValueForActivation() const
 884     {
 885         ASSERT(op() == CreateActivation);
 886         return m_opInfo2.as&lt;FrozenValue*&gt;()-&gt;value();
 887     }
 888 
 889     bool hasArgumentsChild()
 890     {
 891         switch (op()) {
 892         case GetMyArgumentByVal:
 893         case GetMyArgumentByValOutOfBounds:
 894         case LoadVarargs:
 895         case ForwardVarargs:
 896         case CallVarargs:
 897         case CallForwardVarargs:
 898         case ConstructVarargs:
 899         case ConstructForwardVarargs:
 900         case TailCallVarargs:
 901         case TailCallForwardVarargs:
 902         case TailCallVarargsInlinedCaller:
 903         case TailCallForwardVarargsInlinedCaller:
 904             return true;
 905         default:
 906             return false;
 907         }
 908     }
 909 
 910     Edge&amp; argumentsChild()
 911     {
 912         switch (op()) {
 913         case GetMyArgumentByVal:
 914         case GetMyArgumentByValOutOfBounds:
 915         case LoadVarargs:
 916         case ForwardVarargs:
 917             return child1();
 918         case CallVarargs:
 919         case CallForwardVarargs:
 920         case ConstructVarargs:
 921         case ConstructForwardVarargs:
 922         case TailCallVarargs:
 923         case TailCallForwardVarargs:
 924         case TailCallVarargsInlinedCaller:
 925         case TailCallForwardVarargsInlinedCaller:
 926             return child3();
 927         default:
 928             RELEASE_ASSERT_NOT_REACHED();
 929             return child1();
 930         }
 931     }
 932 
 933     bool containsMovHint()
 934     {
 935         switch (op()) {
 936         case MovHint:
 937         case ZombieHint:
 938             return true;
 939         default:
 940             return false;
 941         }
 942     }
 943 
 944     bool hasVariableAccessData(Graph&amp;);
 945     bool accessesStack(Graph&amp; graph)
 946     {
 947         return hasVariableAccessData(graph);
 948     }
 949 
 950     // This is useful for debugging code, where a node that should have a variable
 951     // access data doesn&#39;t have one because it hasn&#39;t been initialized yet.
 952     VariableAccessData* tryGetVariableAccessData()
 953     {
 954         VariableAccessData* result = m_opInfo.as&lt;VariableAccessData*&gt;();
 955         if (!result)
 956             return 0;
 957         return result-&gt;find();
 958     }
 959 
 960     VariableAccessData* variableAccessData()
 961     {
 962         return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
 963     }
 964 
 965     VirtualRegister local()
 966     {
 967         return variableAccessData()-&gt;local();
 968     }
 969 
 970     VirtualRegister machineLocal()
 971     {
 972         return variableAccessData()-&gt;machineLocal();
 973     }
 974 
 975     bool hasUnlinkedLocal()
 976     {
 977         switch (op()) {
 978         case ExtractOSREntryLocal:
 979         case MovHint:
 980         case ZombieHint:
 981         case KillStack:
 982             return true;
 983         default:
 984             return false;
 985         }
 986     }
 987 
 988     VirtualRegister unlinkedLocal()
 989     {
 990         ASSERT(hasUnlinkedLocal());
 991         return VirtualRegister(m_opInfo.as&lt;int32_t&gt;());
 992     }
 993 
 994     bool hasStackAccessData()
 995     {
 996         switch (op()) {
 997         case PutStack:
 998         case GetStack:
 999             return true;
1000         default:
1001             return false;
1002         }
1003     }
1004 
1005     StackAccessData* stackAccessData()
1006     {
1007         ASSERT(hasStackAccessData());
1008         return m_opInfo.as&lt;StackAccessData*&gt;();
1009     }
1010 
1011     unsigned argumentCountIncludingThis()
1012     {
1013         ASSERT(op() == SetArgumentCountIncludingThis);
1014         return m_opInfo.as&lt;unsigned&gt;();
1015     }
1016 
1017     bool hasPhi()
1018     {
1019         return op() == Upsilon;
1020     }
1021 
1022     Node* phi()
1023     {
1024         ASSERT(hasPhi());
1025         return m_opInfo.as&lt;Node*&gt;();
1026     }
1027 
1028     bool isStoreBarrier()
1029     {
1030         return op() == StoreBarrier || op() == FencedStoreBarrier;
1031     }
1032 
1033     bool hasIdentifier()
1034     {
1035         switch (op()) {
1036         case TryGetById:
1037         case GetById:
1038         case GetByIdFlush:
1039         case GetByIdWithThis:
1040         case GetByIdDirect:
1041         case GetByIdDirectFlush:
1042         case PutById:
1043         case PutByIdFlush:
1044         case PutByIdDirect:
1045         case PutByIdWithThis:
1046         case PutGetterById:
1047         case PutSetterById:
1048         case PutGetterSetterById:
1049         case DeleteById:
1050         case InById:
1051         case GetDynamicVar:
1052         case PutDynamicVar:
1053         case ResolveScopeForHoistingFuncDeclInEval:
1054         case ResolveScope:
1055         case ToObject:
1056             return true;
1057         default:
1058             return false;
1059         }
1060     }
1061 
1062     unsigned identifierNumber()
1063     {
1064         ASSERT(hasIdentifier());
1065         return m_opInfo.as&lt;unsigned&gt;();
1066     }
1067 
1068     bool hasGetPutInfo()
1069     {
1070         switch (op()) {
1071         case GetDynamicVar:
1072         case PutDynamicVar:
1073             return true;
1074         default:
1075             return false;
1076         }
1077     }
1078 
1079     unsigned getPutInfo()
1080     {
1081         ASSERT(hasGetPutInfo());
1082         return static_cast&lt;unsigned&gt;(m_opInfo.as&lt;uint64_t&gt;() &gt;&gt; 32);
1083     }
1084 
1085     bool hasAccessorAttributes()
1086     {
1087         switch (op()) {
1088         case PutGetterById:
1089         case PutSetterById:
1090         case PutGetterSetterById:
1091         case PutGetterByVal:
1092         case PutSetterByVal:
1093             return true;
1094         default:
1095             return false;
1096         }
1097     }
1098 
1099     int32_t accessorAttributes()
1100     {
1101         ASSERT(hasAccessorAttributes());
1102         switch (op()) {
1103         case PutGetterById:
1104         case PutSetterById:
1105         case PutGetterSetterById:
1106             return m_opInfo2.as&lt;int32_t&gt;();
1107         case PutGetterByVal:
1108         case PutSetterByVal:
1109             return m_opInfo.as&lt;int32_t&gt;();
1110         default:
1111             RELEASE_ASSERT_NOT_REACHED();
1112             return 0;
1113         }
1114     }
1115 
1116     bool hasPromotedLocationDescriptor()
1117     {
1118         return op() == PutHint;
1119     }
1120 
1121     PromotedLocationDescriptor promotedLocationDescriptor();
1122 
1123     // This corrects the arithmetic node flags, so that irrelevant bits are
1124     // ignored. In particular, anything other than ArithMul or ValueMul does not need
1125     // to know if it can speculate on negative zero.
1126     NodeFlags arithNodeFlags()
1127     {
1128         NodeFlags result = m_flags &amp; NodeArithFlagsMask;
1129         if (op() == ArithMul || op() == ArithDiv || op() == ValueDiv || op() == ArithMod || op() == ArithNegate || op() == ArithPow || op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc || op() == DoubleAsInt32 || op() == ValueNegate || op() == ValueMul || op() == ValueDiv)
1130             return result;
1131         return result &amp; ~NodeBytecodeNeedsNegZero;
1132     }
1133 
1134     bool mayHaveNonIntResult()
1135     {
1136         return m_flags &amp; NodeMayHaveNonIntResult;
1137     }
1138 
1139     bool mayHaveDoubleResult()
1140     {
1141         return m_flags &amp; NodeMayHaveDoubleResult;
1142     }
1143 
1144     bool mayHaveNonNumericResult()
1145     {
1146         return m_flags &amp; NodeMayHaveNonNumericResult;
1147     }
1148 
1149     bool mayHaveBigIntResult()
1150     {
1151         return m_flags &amp; NodeMayHaveBigIntResult;
1152     }
1153 
1154     bool hasNewArrayBufferData()
1155     {
1156         return op() == NewArrayBuffer || op() == PhantomNewArrayBuffer;
1157     }
1158 
1159     NewArrayBufferData newArrayBufferData()
1160     {
1161         ASSERT(hasNewArrayBufferData());
1162         return m_opInfo2.asNewArrayBufferData();
1163     }
1164 
1165     unsigned hasVectorLengthHint()
1166     {
1167         switch (op()) {
1168         case NewArray:
1169         case NewArrayBuffer:
1170         case PhantomNewArrayBuffer:
1171             return true;
1172         default:
1173             return false;
1174         }
1175     }
1176 
1177     unsigned vectorLengthHint()
1178     {
1179         ASSERT(hasVectorLengthHint());
1180         if (op() == NewArray)
1181             return m_opInfo2.as&lt;unsigned&gt;();
1182         return newArrayBufferData().vectorLengthHint;
1183     }
1184 
1185     bool hasIndexingType()
1186     {
1187         switch (op()) {
1188         case NewArray:
1189         case NewArrayWithSize:
1190         case NewArrayBuffer:
1191         case PhantomNewArrayBuffer:
1192             return true;
1193         default:
1194             return false;
1195         }
1196     }
1197 
1198     BitVector* bitVector()
1199     {
1200         ASSERT(op() == NewArrayWithSpread || op() == PhantomNewArrayWithSpread);
1201         return m_opInfo.as&lt;BitVector*&gt;();
1202     }
1203 
1204     // Return the indexing type that an array allocation *wants* to use. It may end up using a different
1205     // type if we&#39;re having a bad time. You can determine the actual indexing type by asking the global
1206     // object:
1207     //
1208     //     m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())
1209     //
1210     // This will give you a Structure*, and that will have some indexing type that may be different from
1211     // the this one.
1212     IndexingType indexingType()
1213     {
1214         ASSERT(hasIndexingType());
1215         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1216             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode) &amp; IndexingTypeMask;
1217         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1218     }
1219 
1220     IndexingType indexingMode()
1221     {
1222         ASSERT(hasIndexingType());
1223         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1224             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode);
1225         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1226     }
1227 
1228     bool hasTypedArrayType()
1229     {
1230         switch (op()) {
1231         case NewTypedArray:
1232             return true;
1233         default:
1234             return false;
1235         }
1236     }
1237 
1238     TypedArrayType typedArrayType()
1239     {
1240         ASSERT(hasTypedArrayType());
1241         TypedArrayType result = static_cast&lt;TypedArrayType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1242         ASSERT(isTypedView(result));
1243         return result;
1244     }
1245 
1246     bool hasInlineCapacity()
1247     {
1248         return op() == CreateThis;
1249     }
1250 
1251     unsigned inlineCapacity()
1252     {
1253         ASSERT(hasInlineCapacity());
1254         return m_opInfo.as&lt;unsigned&gt;();
1255     }
1256 
1257     void setIndexingType(IndexingType indexingType)
1258     {
1259         ASSERT(hasIndexingType());
1260         m_opInfo = indexingType;
1261     }
1262 
1263     bool hasScopeOffset()
1264     {
1265         return op() == GetClosureVar || op() == PutClosureVar;
1266     }
1267 
1268     ScopeOffset scopeOffset()
1269     {
1270         ASSERT(hasScopeOffset());
1271         return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
1272     }
1273 
1274     bool hasDirectArgumentsOffset()
1275     {
1276         return op() == GetFromArguments || op() == PutToArguments;
1277     }
1278 
1279     DirectArgumentsOffset capturedArgumentsOffset()
1280     {
1281         ASSERT(hasDirectArgumentsOffset());
1282         return DirectArgumentsOffset(m_opInfo.as&lt;uint32_t&gt;());
1283     }
1284 
1285     bool hasRegisterPointer()
1286     {
1287         return op() == GetGlobalVar || op() == GetGlobalLexicalVariable || op() == PutGlobalVariable;
1288     }
1289 
1290     WriteBarrier&lt;Unknown&gt;* variablePointer()
1291     {
1292         return m_opInfo.as&lt;WriteBarrier&lt;Unknown&gt;*&gt;();
1293     }
1294 
1295     bool hasCallVarargsData()
1296     {
1297         switch (op()) {
1298         case CallVarargs:
1299         case CallForwardVarargs:
1300         case TailCallVarargs:
1301         case TailCallForwardVarargs:
1302         case TailCallVarargsInlinedCaller:
1303         case TailCallForwardVarargsInlinedCaller:
1304         case ConstructVarargs:
1305         case ConstructForwardVarargs:
1306             return true;
1307         default:
1308             return false;
1309         }
1310     }
1311 
1312     CallVarargsData* callVarargsData()
1313     {
1314         ASSERT(hasCallVarargsData());
1315         return m_opInfo.as&lt;CallVarargsData*&gt;();
1316     }
1317 
1318     bool hasLoadVarargsData()
1319     {
1320         return op() == LoadVarargs || op() == ForwardVarargs;
1321     }
1322 
1323     LoadVarargsData* loadVarargsData()
1324     {
1325         ASSERT(hasLoadVarargsData());
1326         return m_opInfo.as&lt;LoadVarargsData*&gt;();
1327     }
1328 
1329     InlineCallFrame* argumentsInlineCallFrame()
1330     {
1331         ASSERT(op() == GetArgumentCountIncludingThis);
1332         return m_opInfo.as&lt;InlineCallFrame*&gt;();
1333     }
1334 
1335     bool hasQueriedType()
1336     {
1337         return op() == IsCellWithType;
1338     }
1339 
1340     JSType queriedType()
1341     {
1342         static_assert(std::is_same&lt;uint8_t, std::underlying_type&lt;JSType&gt;::type&gt;::value, &quot;Ensure that uint8_t is the underlying type for JSType.&quot;);
1343         return static_cast&lt;JSType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1344     }
1345 
1346     bool hasSpeculatedTypeForQuery()
1347     {
1348         return op() == IsCellWithType;
1349     }
1350 
1351     SpeculatedType speculatedTypeForQuery()
1352     {
1353         return speculationFromJSType(queriedType());
1354     }
1355 
1356     bool hasResult()
1357     {
1358         return !!result();
1359     }
1360 
1361     bool hasInt32Result()
1362     {
1363         return result() == NodeResultInt32;
1364     }
1365 
1366     bool hasInt52Result()
1367     {
1368         return result() == NodeResultInt52;
1369     }
1370 
1371     bool hasNumberResult()
1372     {
1373         return result() == NodeResultNumber;
1374     }
1375 
1376     bool hasNumberOrAnyIntResult()
1377     {
1378         return hasNumberResult() || hasInt32Result() || hasInt52Result();
1379     }
1380 
1381     bool hasNumericResult()
1382     {
1383         switch (op()) {
1384         case ValueSub:
1385         case ValueMul:
1386         case ValueBitAnd:
1387         case ValueBitOr:
1388         case ValueBitXor:
1389         case ValueNegate:
1390             return true;
1391         default:
1392             return false;
1393         }
1394     }
1395 
1396     bool hasDoubleResult()
1397     {
1398         return result() == NodeResultDouble;
1399     }
1400 
1401     bool hasJSResult()
1402     {
1403         return result() == NodeResultJS;
1404     }
1405 
1406     bool hasBooleanResult()
1407     {
1408         return result() == NodeResultBoolean;
1409     }
1410 
1411     bool hasStorageResult()
1412     {
1413         return result() == NodeResultStorage;
1414     }
1415 
1416     UseKind defaultUseKind()
1417     {
1418         return useKindForResult(result());
1419     }
1420 
1421     Edge defaultEdge()
1422     {
1423         return Edge(this, defaultUseKind());
1424     }
1425 
1426     bool isJump()
1427     {
1428         return op() == Jump;
1429     }
1430 
1431     bool isBranch()
1432     {
1433         return op() == Branch;
1434     }
1435 
1436     bool isSwitch() const
1437     {
1438         return op() == Switch;
1439     }
1440 
1441     bool isEntrySwitch() const
1442     {
1443         return op() == EntrySwitch;
1444     }
1445 
1446     bool isTerminal()
1447     {
1448         switch (op()) {
1449         case Jump:
1450         case Branch:
1451         case Switch:
1452         case EntrySwitch:
1453         case Return:
1454         case TailCall:
1455         case DirectTailCall:
1456         case TailCallVarargs:
1457         case TailCallForwardVarargs:
1458         case Unreachable:
1459         case Throw:
1460         case ThrowStaticError:
1461             return true;
1462         default:
1463             return false;
1464         }
1465     }
1466 
1467     bool isFunctionTerminal()
1468     {
1469         if (isTerminal() &amp;&amp; !numSuccessors())
1470             return true;
1471 
1472         return false;
1473     }
1474 
1475     // As is described in DFGNodeType.h&#39;s ForceOSRExit, this is a pseudo-terminal.
1476     // It means that execution should fall out of DFG at this point, but execution
1477     // does continue in the basic block - just in a different compiler.
1478     // FIXME: This is used for lightweight reachability decision. But this should
1479     // be replaced with AI-based reachability ideally.
1480     bool isPseudoTerminal()
1481     {
1482         switch (op()) {
1483         case ForceOSRExit:
1484         case CheckBadCell:
1485             return true;
1486         default:
1487             return false;
1488         }
1489     }
1490 
1491     unsigned targetBytecodeOffsetDuringParsing()
1492     {
1493         ASSERT(isJump());
1494         return m_opInfo.as&lt;unsigned&gt;();
1495     }
1496 
1497     BasicBlock*&amp; targetBlock()
1498     {
1499         ASSERT(isJump());
1500         return *bitwise_cast&lt;BasicBlock**&gt;(&amp;m_opInfo.u.pointer);
1501     }
1502 
1503     BranchData* branchData()
1504     {
1505         ASSERT(isBranch());
1506         return m_opInfo.as&lt;BranchData*&gt;();
1507     }
1508 
1509     SwitchData* switchData()
1510     {
1511         ASSERT(isSwitch());
1512         return m_opInfo.as&lt;SwitchData*&gt;();
1513     }
1514 
1515     EntrySwitchData* entrySwitchData()
1516     {
1517         ASSERT(isEntrySwitch());
1518         return m_opInfo.as&lt;EntrySwitchData*&gt;();
1519     }
1520 
1521     Intrinsic intrinsic()
1522     {
1523         RELEASE_ASSERT(op() == CPUIntrinsic);
1524         return m_opInfo.as&lt;Intrinsic&gt;();
1525     }
1526 
1527     unsigned numSuccessors()
1528     {
1529         switch (op()) {
1530         case Jump:
1531             return 1;
1532         case Branch:
1533             return 2;
1534         case Switch:
1535             return switchData()-&gt;cases.size() + 1;
1536         case EntrySwitch:
1537             return entrySwitchData()-&gt;cases.size();
1538         default:
1539             return 0;
1540         }
1541     }
1542 
1543     BasicBlock*&amp; successor(unsigned index)
1544     {
1545         if (isSwitch()) {
1546             if (index &lt; switchData()-&gt;cases.size())
1547                 return switchData()-&gt;cases[index].target.block;
1548             RELEASE_ASSERT(index == switchData()-&gt;cases.size());
1549             return switchData()-&gt;fallThrough.block;
1550         } else if (isEntrySwitch())
1551             return entrySwitchData()-&gt;cases[index];
1552 
1553         switch (index) {
1554         case 0:
1555             if (isJump())
1556                 return targetBlock();
1557             return branchData()-&gt;taken.block;
1558         case 1:
1559             return branchData()-&gt;notTaken.block;
1560         default:
1561             RELEASE_ASSERT_NOT_REACHED();
1562             return targetBlock();
1563         }
1564     }
1565 
1566     class SuccessorsIterable {
1567     public:
1568         SuccessorsIterable()
1569             : m_terminal(nullptr)
1570         {
1571         }
1572 
1573         SuccessorsIterable(Node* terminal)
1574             : m_terminal(terminal)
1575         {
1576         }
1577 
1578         class iterator {
1579         public:
1580             iterator()
1581                 : m_terminal(nullptr)
1582                 , m_index(UINT_MAX)
1583             {
1584             }
1585 
1586             iterator(Node* terminal, unsigned index)
1587                 : m_terminal(terminal)
1588                 , m_index(index)
1589             {
1590             }
1591 
1592             BasicBlock* operator*()
1593             {
1594                 return m_terminal-&gt;successor(m_index);
1595             }
1596 
1597             iterator&amp; operator++()
1598             {
1599                 m_index++;
1600                 return *this;
1601             }
1602 
1603             bool operator==(const iterator&amp; other) const
1604             {
1605                 return m_index == other.m_index;
1606             }
1607 
1608             bool operator!=(const iterator&amp; other) const
1609             {
1610                 return !(*this == other);
1611             }
1612         private:
1613             Node* m_terminal;
1614             unsigned m_index;
1615         };
1616 
1617         iterator begin()
1618         {
1619             return iterator(m_terminal, 0);
1620         }
1621 
1622         iterator end()
1623         {
1624             return iterator(m_terminal, m_terminal-&gt;numSuccessors());
1625         }
1626 
1627         size_t size() const { return m_terminal-&gt;numSuccessors(); }
1628         BasicBlock* at(size_t index) const { return m_terminal-&gt;successor(index); }
1629         BasicBlock* operator[](size_t index) const { return at(index); }
1630 
1631     private:
1632         Node* m_terminal;
1633     };
1634 
1635     SuccessorsIterable successors()
1636     {
1637         return SuccessorsIterable(this);
1638     }
1639 
1640     BasicBlock*&amp; successorForCondition(bool condition)
1641     {
1642         return branchData()-&gt;forCondition(condition);
1643     }
1644 
1645     bool hasHeapPrediction()
1646     {
1647         switch (op()) {
1648         case ArithAbs:
1649         case ArithRound:
1650         case ArithFloor:
1651         case ArithCeil:
1652         case ArithTrunc:
1653         case GetDirectPname:
1654         case GetById:
1655         case GetByIdFlush:
1656         case GetByIdWithThis:
1657         case GetByIdDirect:
1658         case GetByIdDirectFlush:
1659         case GetPrototypeOf:
1660         case TryGetById:
1661         case GetByVal:
1662         case GetByValWithThis:
1663         case Call:
1664         case DirectCall:
1665         case TailCallInlinedCaller:
1666         case DirectTailCallInlinedCaller:
1667         case Construct:
1668         case DirectConstruct:
1669         case CallVarargs:
1670         case CallEval:
1671         case TailCallVarargsInlinedCaller:
1672         case ConstructVarargs:
1673         case CallForwardVarargs:
1674         case TailCallForwardVarargsInlinedCaller:
1675         case GetByOffset:
1676         case MultiGetByOffset:
1677         case GetClosureVar:
1678         case GetFromArguments:
1679         case GetArgument:
1680         case ArrayPop:
1681         case ArrayPush:
1682         case RegExpExec:
1683         case RegExpExecNonGlobalOrSticky:
1684         case RegExpTest:
1685         case RegExpMatchFast:
1686         case RegExpMatchFastGlobal:
1687         case GetGlobalVar:
1688         case GetGlobalLexicalVariable:
1689         case StringReplace:
1690         case StringReplaceRegExp:
1691         case ToNumber:
1692         case ToObject:
1693         case ValueBitAnd:
1694         case ValueBitOr:
1695         case ValueBitXor:
<a name="7" id="anc7"></a>

1696         case CallObjectConstructor:
1697         case LoadKeyFromMapBucket:
1698         case LoadValueFromMapBucket:
1699         case CallDOMGetter:
1700         case CallDOM:
1701         case ParseInt:
1702         case AtomicsAdd:
1703         case AtomicsAnd:
1704         case AtomicsCompareExchange:
1705         case AtomicsExchange:
1706         case AtomicsLoad:
1707         case AtomicsOr:
1708         case AtomicsStore:
1709         case AtomicsSub:
1710         case AtomicsXor:
1711         case GetDynamicVar:
1712         case ExtractValueFromWeakMapGet:
1713         case ToThis:
1714         case DataViewGetInt:
1715         case DataViewGetFloat:
1716             return true;
1717         default:
1718             return false;
1719         }
1720     }
1721 
1722     SpeculatedType getHeapPrediction()
1723     {
1724         ASSERT(hasHeapPrediction());
1725         return m_opInfo2.as&lt;SpeculatedType&gt;();
1726     }
1727 
1728     void setHeapPrediction(SpeculatedType prediction)
1729     {
1730         ASSERT(hasHeapPrediction());
1731         m_opInfo2 = prediction;
1732     }
1733 
1734     SpeculatedType getForcedPrediction()
1735     {
1736         ASSERT(op() == IdentityWithProfile);
1737         return m_opInfo.as&lt;SpeculatedType&gt;();
1738     }
1739 
1740     uint32_t catchOSREntryIndex() const
1741     {
1742         ASSERT(op() == ExtractCatchLocal);
1743         return m_opInfo.as&lt;uint32_t&gt;();
1744     }
1745 
1746     SpeculatedType catchLocalPrediction()
1747     {
1748         ASSERT(op() == ExtractCatchLocal);
1749         return m_opInfo2.as&lt;SpeculatedType&gt;();
1750     }
1751 
1752     bool hasCellOperand()
1753     {
1754         switch (op()) {
1755         case CheckCell:
1756         case OverridesHasInstance:
1757         case NewFunction:
1758         case NewGeneratorFunction:
1759         case NewAsyncFunction:
1760         case NewAsyncGeneratorFunction:
1761         case CreateActivation:
1762         case MaterializeCreateActivation:
1763         case NewRegexp:
1764         case NewArrayBuffer:
1765         case PhantomNewArrayBuffer:
1766         case CompareEqPtr:
1767         case CallObjectConstructor:
1768         case DirectCall:
1769         case DirectTailCall:
1770         case DirectConstruct:
1771         case DirectTailCallInlinedCaller:
1772         case RegExpExecNonGlobalOrSticky:
1773         case RegExpMatchFastGlobal:
1774             return true;
1775         default:
1776             return false;
1777         }
1778     }
1779 
1780     FrozenValue* cellOperand()
1781     {
1782         ASSERT(hasCellOperand());
1783         return m_opInfo.as&lt;FrozenValue*&gt;();
1784     }
1785 
1786     template&lt;typename T&gt;
1787     T castOperand()
1788     {
1789         return cellOperand()-&gt;cast&lt;T&gt;();
1790     }
1791 
1792     void setCellOperand(FrozenValue* value)
1793     {
1794         ASSERT(hasCellOperand());
1795         m_opInfo = value;
1796     }
1797 
1798     bool hasWatchpointSet()
1799     {
1800         return op() == NotifyWrite;
1801     }
1802 
1803     WatchpointSet* watchpointSet()
1804     {
1805         ASSERT(hasWatchpointSet());
1806         return m_opInfo.as&lt;WatchpointSet*&gt;();
1807     }
1808 
1809     bool hasStoragePointer()
1810     {
1811         return op() == ConstantStoragePointer;
1812     }
1813 
1814     void* storagePointer()
1815     {
1816         ASSERT(hasStoragePointer());
1817         return m_opInfo.as&lt;void*&gt;();
1818     }
1819 
1820     bool hasUidOperand()
1821     {
1822         return op() == CheckStringIdent;
1823     }
1824 
1825     UniquedStringImpl* uidOperand()
1826     {
1827         ASSERT(hasUidOperand());
1828         return m_opInfo.as&lt;UniquedStringImpl*&gt;();
1829     }
1830 
1831     bool hasTypeInfoOperand()
1832     {
1833         return op() == CheckTypeInfoFlags;
1834     }
1835 
1836     unsigned typeInfoOperand()
1837     {
1838         ASSERT(hasTypeInfoOperand() &amp;&amp; m_opInfo.as&lt;uint32_t&gt;() &lt;= static_cast&lt;uint32_t&gt;(UCHAR_MAX));
1839         return m_opInfo.as&lt;uint32_t&gt;();
1840     }
1841 
1842     bool hasTransition()
1843     {
1844         switch (op()) {
1845         case PutStructure:
1846         case AllocatePropertyStorage:
1847         case ReallocatePropertyStorage:
1848             return true;
1849         default:
1850             return false;
1851         }
1852     }
1853 
1854     Transition* transition()
1855     {
1856         ASSERT(hasTransition());
1857         return m_opInfo.as&lt;Transition*&gt;();
1858     }
1859 
1860     bool hasStructureSet()
1861     {
1862         switch (op()) {
1863         case CheckStructure:
1864         case CheckStructureOrEmpty:
1865         case CheckStructureImmediate:
1866         case MaterializeNewObject:
1867             return true;
1868         default:
1869             return false;
1870         }
1871     }
1872 
1873     const RegisteredStructureSet&amp; structureSet()
1874     {
1875         ASSERT(hasStructureSet());
1876         return *m_opInfo.as&lt;RegisteredStructureSet*&gt;();
1877     }
1878 
1879     bool hasStructure()
1880     {
1881         switch (op()) {
1882         case ArrayifyToStructure:
1883         case NewObject:
1884         case NewStringObject:
1885             return true;
1886         default:
1887             return false;
1888         }
1889     }
1890 
1891     RegisteredStructure structure()
1892     {
1893         ASSERT(hasStructure());
1894         return m_opInfo.asRegisteredStructure();
1895     }
1896 
1897     bool hasStorageAccessData()
1898     {
1899         switch (op()) {
1900         case GetByOffset:
1901         case PutByOffset:
1902         case GetGetterSetterByOffset:
1903             return true;
1904         default:
1905             return false;
1906         }
1907     }
1908 
1909     StorageAccessData&amp; storageAccessData()
1910     {
1911         ASSERT(hasStorageAccessData());
1912         return *m_opInfo.as&lt;StorageAccessData*&gt;();
1913     }
1914 
1915     bool hasMultiGetByOffsetData()
1916     {
1917         return op() == MultiGetByOffset;
1918     }
1919 
1920     MultiGetByOffsetData&amp; multiGetByOffsetData()
1921     {
1922         ASSERT(hasMultiGetByOffsetData());
1923         return *m_opInfo.as&lt;MultiGetByOffsetData*&gt;();
1924     }
1925 
1926     bool hasMultiPutByOffsetData()
1927     {
1928         return op() == MultiPutByOffset;
1929     }
1930 
1931     MultiPutByOffsetData&amp; multiPutByOffsetData()
1932     {
1933         ASSERT(hasMultiPutByOffsetData());
1934         return *m_opInfo.as&lt;MultiPutByOffsetData*&gt;();
1935     }
1936 
1937     bool hasMatchStructureData()
1938     {
1939         return op() == MatchStructure;
1940     }
1941 
1942     MatchStructureData&amp; matchStructureData()
1943     {
1944         ASSERT(hasMatchStructureData());
1945         return *m_opInfo.as&lt;MatchStructureData*&gt;();
1946     }
1947 
1948     bool hasObjectMaterializationData()
1949     {
1950         switch (op()) {
1951         case MaterializeNewObject:
1952         case MaterializeCreateActivation:
1953             return true;
1954 
1955         default:
1956             return false;
1957         }
1958     }
1959 
1960     ObjectMaterializationData&amp; objectMaterializationData()
1961     {
1962         ASSERT(hasObjectMaterializationData());
1963         return *m_opInfo2.as&lt;ObjectMaterializationData*&gt;();
1964     }
1965 
1966     bool isObjectAllocation()
1967     {
1968         switch (op()) {
1969         case NewObject:
1970         case MaterializeNewObject:
1971             return true;
1972         default:
1973             return false;
1974         }
1975     }
1976 
1977     bool isPhantomObjectAllocation()
1978     {
1979         switch (op()) {
1980         case PhantomNewObject:
1981             return true;
1982         default:
1983             return false;
1984         }
1985     }
1986 
1987     bool isActivationAllocation()
1988     {
1989         switch (op()) {
1990         case CreateActivation:
1991         case MaterializeCreateActivation:
1992             return true;
1993         default:
1994             return false;
1995         }
1996     }
1997 
1998     bool isPhantomActivationAllocation()
1999     {
2000         switch (op()) {
2001         case PhantomCreateActivation:
2002             return true;
2003         default:
2004             return false;
2005         }
2006     }
2007 
2008     bool isFunctionAllocation()
2009     {
2010         switch (op()) {
2011         case NewFunction:
2012         case NewGeneratorFunction:
2013         case NewAsyncGeneratorFunction:
2014         case NewAsyncFunction:
2015             return true;
2016         default:
2017             return false;
2018         }
2019     }
2020 
2021     bool isPhantomFunctionAllocation()
2022     {
2023         switch (op()) {
2024         case PhantomNewFunction:
2025         case PhantomNewGeneratorFunction:
2026         case PhantomNewAsyncFunction:
2027         case PhantomNewAsyncGeneratorFunction:
2028             return true;
2029         default:
2030             return false;
2031         }
2032     }
2033 
2034     bool isPhantomAllocation()
2035     {
2036         switch (op()) {
2037         case PhantomNewObject:
2038         case PhantomDirectArguments:
2039         case PhantomCreateRest:
2040         case PhantomSpread:
2041         case PhantomNewArrayWithSpread:
2042         case PhantomNewArrayBuffer:
2043         case PhantomClonedArguments:
2044         case PhantomNewFunction:
2045         case PhantomNewGeneratorFunction:
2046         case PhantomNewAsyncFunction:
2047         case PhantomNewAsyncGeneratorFunction:
2048         case PhantomCreateActivation:
2049         case PhantomNewRegexp:
2050             return true;
2051         default:
2052             return false;
2053         }
2054     }
2055 
2056     bool hasArrayMode()
2057     {
2058         switch (op()) {
2059         case GetIndexedPropertyStorage:
2060         case GetArrayLength:
2061         case GetVectorLength:
2062         case InByVal:
2063         case PutByValDirect:
2064         case PutByVal:
2065         case PutByValAlias:
2066         case GetByVal:
2067         case StringCharAt:
2068         case StringCharCodeAt:
2069         case CheckArray:
2070         case Arrayify:
2071         case ArrayifyToStructure:
2072         case ArrayPush:
2073         case ArrayPop:
2074         case ArrayIndexOf:
2075         case HasIndexedProperty:
2076         case AtomicsAdd:
2077         case AtomicsAnd:
2078         case AtomicsCompareExchange:
2079         case AtomicsExchange:
2080         case AtomicsLoad:
2081         case AtomicsOr:
2082         case AtomicsStore:
2083         case AtomicsSub:
2084         case AtomicsXor:
2085             return true;
2086         default:
2087             return false;
2088         }
2089     }
2090 
2091     ArrayMode arrayMode()
2092     {
2093         ASSERT(hasArrayMode());
2094         if (op() == ArrayifyToStructure)
2095             return ArrayMode::fromWord(m_opInfo2.as&lt;uint32_t&gt;());
2096         return ArrayMode::fromWord(m_opInfo.as&lt;uint32_t&gt;());
2097     }
2098 
2099     bool setArrayMode(ArrayMode arrayMode)
2100     {
2101         ASSERT(hasArrayMode());
2102         if (this-&gt;arrayMode() == arrayMode)
2103             return false;
2104         m_opInfo = arrayMode.asWord();
2105         return true;
2106     }
2107 
2108     bool hasArithMode()
2109     {
2110         switch (op()) {
2111         case ArithAbs:
2112         case ArithAdd:
2113         case ArithSub:
2114         case ArithNegate:
2115         case ArithMul:
2116         case ArithDiv:
2117         case ArithMod:
2118         case UInt32ToNumber:
2119         case DoubleAsInt32:
2120             return true;
2121         default:
2122             return false;
2123         }
2124     }
2125 
2126     Arith::Mode arithMode()
2127     {
2128         ASSERT(hasArithMode());
2129         return static_cast&lt;Arith::Mode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2130     }
2131 
2132     void setArithMode(Arith::Mode mode)
2133     {
2134         m_opInfo = mode;
2135     }
2136 
2137     bool hasArithRoundingMode()
2138     {
2139         return op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc;
2140     }
2141 
2142     Arith::RoundingMode arithRoundingMode()
2143     {
2144         ASSERT(hasArithRoundingMode());
2145         return static_cast&lt;Arith::RoundingMode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2146     }
2147 
2148     void setArithRoundingMode(Arith::RoundingMode mode)
2149     {
2150         ASSERT(hasArithRoundingMode());
2151         m_opInfo = static_cast&lt;uint32_t&gt;(mode);
2152     }
2153 
2154     bool hasArithUnaryType()
2155     {
2156         return op() == ArithUnary;
2157     }
2158 
2159     Arith::UnaryType arithUnaryType()
2160     {
2161         ASSERT(hasArithUnaryType());
2162         return static_cast&lt;Arith::UnaryType&gt;(m_opInfo.as&lt;uint32_t&gt;());
2163     }
2164 
2165     bool hasVirtualRegister()
2166     {
2167         return m_virtualRegister.isValid();
2168     }
2169 
2170     VirtualRegister virtualRegister()
2171     {
2172         ASSERT(hasResult());
2173         ASSERT(m_virtualRegister.isValid());
2174         return m_virtualRegister;
2175     }
2176 
2177     void setVirtualRegister(VirtualRegister virtualRegister)
2178     {
2179         ASSERT(hasResult());
2180         ASSERT(!m_virtualRegister.isValid());
2181         m_virtualRegister = virtualRegister;
2182     }
2183 
2184     bool hasExecutionCounter()
2185     {
2186         return op() == CountExecution;
2187     }
2188 
2189     Profiler::ExecutionCounter* executionCounter()
2190     {
2191         return m_opInfo.as&lt;Profiler::ExecutionCounter*&gt;();
2192     }
2193 
2194     unsigned entrypointIndex()
2195     {
2196         ASSERT(op() == InitializeEntrypointArguments);
2197         return m_opInfo.as&lt;unsigned&gt;();
2198     }
2199 
2200     DataViewData dataViewData()
2201     {
2202         ASSERT(op() == DataViewGetInt || op() == DataViewGetFloat || op() == DataViewSet);
2203         return bitwise_cast&lt;DataViewData&gt;(m_opInfo.as&lt;uint64_t&gt;());
2204     }
2205 
2206     bool shouldGenerate()
2207     {
2208         return m_refCount;
2209     }
2210 
2211     // Return true if the execution of this Node does not affect our ability to OSR to the FTL.
2212     // FIXME: Isn&#39;t this just like checking if the node has effects?
2213     bool isSemanticallySkippable()
2214     {
2215         return op() == CountExecution || op() == InvalidationPoint;
2216     }
2217 
2218     unsigned refCount()
2219     {
2220         return m_refCount;
2221     }
2222 
2223     unsigned postfixRef()
2224     {
2225         return m_refCount++;
2226     }
2227 
2228     unsigned adjustedRefCount()
2229     {
2230         return mustGenerate() ? m_refCount - 1 : m_refCount;
2231     }
2232 
2233     void setRefCount(unsigned refCount)
2234     {
2235         m_refCount = refCount;
2236     }
2237 
2238     Edge&amp; child1()
2239     {
2240         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2241         return children.child1();
2242     }
2243 
2244     // This is useful if you want to do a fast check on the first child
2245     // before also doing a check on the opcode. Use this with care and
2246     // avoid it if possible.
2247     Edge child1Unchecked()
2248     {
2249         return children.child1Unchecked();
2250     }
2251 
2252     Edge&amp; child2()
2253     {
2254         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2255         return children.child2();
2256     }
2257 
2258     Edge&amp; child3()
2259     {
2260         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2261         return children.child3();
2262     }
2263 
2264     unsigned firstChild()
2265     {
2266         ASSERT(m_flags &amp; NodeHasVarArgs);
2267         return children.firstChild();
2268     }
2269 
2270     unsigned numChildren()
2271     {
2272         ASSERT(m_flags &amp; NodeHasVarArgs);
2273         return children.numChildren();
2274     }
2275 
2276     UseKind binaryUseKind()
2277     {
2278         ASSERT(child1().useKind() == child2().useKind());
2279         return child1().useKind();
2280     }
2281 
2282     bool isBinaryUseKind(UseKind left, UseKind right)
2283     {
2284         return child1().useKind() == left &amp;&amp; child2().useKind() == right;
2285     }
2286 
2287     bool isBinaryUseKind(UseKind useKind)
2288     {
2289         return isBinaryUseKind(useKind, useKind);
2290     }
2291 
2292     Edge childFor(UseKind useKind)
2293     {
2294         if (child1().useKind() == useKind)
2295             return child1();
2296         if (child2().useKind() == useKind)
2297             return child2();
2298         if (child3().useKind() == useKind)
2299             return child3();
2300         return Edge();
2301     }
2302 
2303     SpeculatedType prediction()
2304     {
2305         return m_prediction;
2306     }
2307 
2308     bool predict(SpeculatedType prediction)
2309     {
2310         return mergeSpeculation(m_prediction, prediction);
2311     }
2312 
2313     bool shouldSpeculateInt32()
2314     {
2315         return isInt32Speculation(prediction());
2316     }
2317 
2318     bool shouldSpeculateNotInt32()
2319     {
2320         return isNotInt32Speculation(prediction());
2321     }
2322 
2323     bool sawBooleans()
2324     {
2325         return !!(prediction() &amp; SpecBoolean);
2326     }
2327 
2328     bool shouldSpeculateInt32OrBoolean()
2329     {
2330         return isInt32OrBooleanSpeculation(prediction());
2331     }
2332 
2333     bool shouldSpeculateInt32ForArithmetic()
2334     {
2335         return isInt32SpeculationForArithmetic(prediction());
2336     }
2337 
2338     bool shouldSpeculateInt32OrBooleanForArithmetic()
2339     {
2340         return isInt32OrBooleanSpeculationForArithmetic(prediction());
2341     }
2342 
2343     bool shouldSpeculateInt32OrBooleanExpectingDefined()
2344     {
2345         return isInt32OrBooleanSpeculationExpectingDefined(prediction());
2346     }
2347 
<a name="8" id="anc8"></a><span class="line-modified">2348     bool shouldSpeculateAnyInt()</span>
<span class="line-modified">2349     {</span>
<span class="line-modified">2350         return isAnyIntSpeculation(prediction());</span>

















2351     }
2352 
2353     bool shouldSpeculateDouble()
2354     {
2355         return isDoubleSpeculation(prediction());
2356     }
2357 
2358     bool shouldSpeculateDoubleReal()
2359     {
2360         return isDoubleRealSpeculation(prediction());
2361     }
2362 
2363     bool shouldSpeculateNumber()
2364     {
2365         return isFullNumberSpeculation(prediction());
2366     }
2367 
2368     bool shouldSpeculateNumberOrBoolean()
2369     {
2370         return isFullNumberOrBooleanSpeculation(prediction());
2371     }
2372 
2373     bool shouldSpeculateNumberOrBooleanExpectingDefined()
2374     {
2375         return isFullNumberOrBooleanSpeculationExpectingDefined(prediction());
2376     }
2377 
2378     bool shouldSpeculateBoolean()
2379     {
2380         return isBooleanSpeculation(prediction());
2381     }
2382 
2383     bool shouldSpeculateNotBoolean()
2384     {
2385         return isNotBooleanSpeculation(prediction());
2386     }
2387 
2388     bool shouldSpeculateOther()
2389     {
2390         return isOtherSpeculation(prediction());
2391     }
2392 
2393     bool shouldSpeculateMisc()
2394     {
2395         return isMiscSpeculation(prediction());
2396     }
2397 
2398     bool shouldSpeculateStringIdent()
2399     {
2400         return isStringIdentSpeculation(prediction());
2401     }
2402 
2403     bool shouldSpeculateNotStringVar()
2404     {
2405         return isNotStringVarSpeculation(prediction());
2406     }
2407 
2408     bool shouldSpeculateString()
2409     {
2410         return isStringSpeculation(prediction());
2411     }
2412 
2413     bool shouldSpeculateNotString()
2414     {
2415         return isNotStringSpeculation(prediction());
2416     }
2417 
2418     bool shouldSpeculateStringOrOther()
2419     {
2420         return isStringOrOtherSpeculation(prediction());
2421     }
2422 
2423     bool shouldSpeculateStringObject()
2424     {
2425         return isStringObjectSpeculation(prediction());
2426     }
2427 
2428     bool shouldSpeculateStringOrStringObject()
2429     {
2430         return isStringOrStringObjectSpeculation(prediction());
2431     }
2432 
2433     bool shouldSpeculateRegExpObject()
2434     {
2435         return isRegExpObjectSpeculation(prediction());
2436     }
2437 
2438     bool shouldSpeculateSymbol()
2439     {
2440         return isSymbolSpeculation(prediction());
2441     }
2442 
2443     bool shouldSpeculateBigInt()
2444     {
2445         return isBigIntSpeculation(prediction());
2446     }
2447 
2448     bool shouldSpeculateFinalObject()
2449     {
2450         return isFinalObjectSpeculation(prediction());
2451     }
2452 
2453     bool shouldSpeculateFinalObjectOrOther()
2454     {
2455         return isFinalObjectOrOtherSpeculation(prediction());
2456     }
2457 
2458     bool shouldSpeculateArray()
2459     {
2460         return isArraySpeculation(prediction());
2461     }
2462 
2463     bool shouldSpeculateFunction()
2464     {
2465         return isFunctionSpeculation(prediction());
2466     }
2467 
2468     bool shouldSpeculateProxyObject()
2469     {
2470         return isProxyObjectSpeculation(prediction());
2471     }
2472 
2473     bool shouldSpeculateDerivedArray()
2474     {
2475         return isDerivedArraySpeculation(prediction());
2476     }
2477 
2478     bool shouldSpeculateDirectArguments()
2479     {
2480         return isDirectArgumentsSpeculation(prediction());
2481     }
2482 
2483     bool shouldSpeculateScopedArguments()
2484     {
2485         return isScopedArgumentsSpeculation(prediction());
2486     }
2487 
2488     bool shouldSpeculateInt8Array()
2489     {
2490         return isInt8ArraySpeculation(prediction());
2491     }
2492 
2493     bool shouldSpeculateInt16Array()
2494     {
2495         return isInt16ArraySpeculation(prediction());
2496     }
2497 
2498     bool shouldSpeculateInt32Array()
2499     {
2500         return isInt32ArraySpeculation(prediction());
2501     }
2502 
2503     bool shouldSpeculateUint8Array()
2504     {
2505         return isUint8ArraySpeculation(prediction());
2506     }
2507 
2508     bool shouldSpeculateUint8ClampedArray()
2509     {
2510         return isUint8ClampedArraySpeculation(prediction());
2511     }
2512 
2513     bool shouldSpeculateUint16Array()
2514     {
2515         return isUint16ArraySpeculation(prediction());
2516     }
2517 
2518     bool shouldSpeculateUint32Array()
2519     {
2520         return isUint32ArraySpeculation(prediction());
2521     }
2522 
2523     bool shouldSpeculateFloat32Array()
2524     {
2525         return isFloat32ArraySpeculation(prediction());
2526     }
2527 
2528     bool shouldSpeculateFloat64Array()
2529     {
2530         return isFloat64ArraySpeculation(prediction());
2531     }
2532 
2533     bool shouldSpeculateArrayOrOther()
2534     {
2535         return isArrayOrOtherSpeculation(prediction());
2536     }
2537 
2538     bool shouldSpeculateObject()
2539     {
2540         return isObjectSpeculation(prediction());
2541     }
2542 
2543     bool shouldSpeculateObjectOrOther()
2544     {
2545         return isObjectOrOtherSpeculation(prediction());
2546     }
2547 
2548     bool shouldSpeculateCell()
2549     {
2550         return isCellSpeculation(prediction());
2551     }
2552 
2553     bool shouldSpeculateCellOrOther()
2554     {
2555         return isCellOrOtherSpeculation(prediction());
2556     }
2557 
2558     bool shouldSpeculateNotCell()
2559     {
2560         return isNotCellSpeculation(prediction());
2561     }
2562 
2563     bool shouldSpeculateUntypedForArithmetic()
2564     {
2565         return isUntypedSpeculationForArithmetic(prediction());
2566     }
2567 
2568     static bool shouldSpeculateUntypedForArithmetic(Node* op1, Node* op2)
2569     {
2570         return op1-&gt;shouldSpeculateUntypedForArithmetic() || op2-&gt;shouldSpeculateUntypedForArithmetic();
2571     }
2572 
2573     bool shouldSpeculateUntypedForBitOps()
2574     {
2575         return isUntypedSpeculationForBitOps(prediction());
2576     }
2577 
2578     static bool shouldSpeculateUntypedForBitOps(Node* op1, Node* op2)
2579     {
2580         return op1-&gt;shouldSpeculateUntypedForBitOps() || op2-&gt;shouldSpeculateUntypedForBitOps();
2581     }
2582 
2583     static bool shouldSpeculateBoolean(Node* op1, Node* op2)
2584     {
2585         return op1-&gt;shouldSpeculateBoolean() &amp;&amp; op2-&gt;shouldSpeculateBoolean();
2586     }
2587 
2588     static bool shouldSpeculateInt32(Node* op1, Node* op2)
2589     {
2590         return op1-&gt;shouldSpeculateInt32() &amp;&amp; op2-&gt;shouldSpeculateInt32();
2591     }
2592 
2593     static bool shouldSpeculateInt32OrBoolean(Node* op1, Node* op2)
2594     {
2595         return op1-&gt;shouldSpeculateInt32OrBoolean()
2596             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBoolean();
2597     }
2598 
2599     static bool shouldSpeculateInt32OrBooleanForArithmetic(Node* op1, Node* op2)
2600     {
2601         return op1-&gt;shouldSpeculateInt32OrBooleanForArithmetic()
2602             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanForArithmetic();
2603     }
2604 
2605     static bool shouldSpeculateInt32OrBooleanExpectingDefined(Node* op1, Node* op2)
2606     {
2607         return op1-&gt;shouldSpeculateInt32OrBooleanExpectingDefined()
2608             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanExpectingDefined();
2609     }
2610 
<a name="9" id="anc9"></a><span class="line-modified">2611     static bool shouldSpeculateAnyInt(Node* op1, Node* op2)</span>
2612     {
<a name="10" id="anc10"></a><span class="line-modified">2613         return op1-&gt;shouldSpeculateAnyInt() &amp;&amp; op2-&gt;shouldSpeculateAnyInt();</span>
2614     }
2615 
2616     static bool shouldSpeculateNumber(Node* op1, Node* op2)
2617     {
2618         return op1-&gt;shouldSpeculateNumber() &amp;&amp; op2-&gt;shouldSpeculateNumber();
2619     }
2620 
2621     static bool shouldSpeculateNumberOrBoolean(Node* op1, Node* op2)
2622     {
2623         return op1-&gt;shouldSpeculateNumberOrBoolean()
2624             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBoolean();
2625     }
2626 
2627     static bool shouldSpeculateNumberOrBooleanExpectingDefined(Node* op1, Node* op2)
2628     {
2629         return op1-&gt;shouldSpeculateNumberOrBooleanExpectingDefined()
2630             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBooleanExpectingDefined();
2631     }
2632 
2633     static bool shouldSpeculateSymbol(Node* op1, Node* op2)
2634     {
2635         return op1-&gt;shouldSpeculateSymbol() &amp;&amp; op2-&gt;shouldSpeculateSymbol();
2636     }
2637 
2638     static bool shouldSpeculateBigInt(Node* op1, Node* op2)
2639     {
2640         return op1-&gt;shouldSpeculateBigInt() &amp;&amp; op2-&gt;shouldSpeculateBigInt();
2641     }
2642 
2643     static bool shouldSpeculateFinalObject(Node* op1, Node* op2)
2644     {
2645         return op1-&gt;shouldSpeculateFinalObject() &amp;&amp; op2-&gt;shouldSpeculateFinalObject();
2646     }
2647 
2648     static bool shouldSpeculateArray(Node* op1, Node* op2)
2649     {
2650         return op1-&gt;shouldSpeculateArray() &amp;&amp; op2-&gt;shouldSpeculateArray();
2651     }
2652 
2653     bool canSpeculateInt32(RareCaseProfilingSource source)
2654     {
2655         return nodeCanSpeculateInt32(arithNodeFlags(), source);
2656     }
2657 
2658     bool canSpeculateInt52(RareCaseProfilingSource source)
2659     {
2660         return nodeCanSpeculateInt52(arithNodeFlags(), source);
2661     }
2662 
2663     RareCaseProfilingSource sourceFor(PredictionPass pass)
2664     {
2665         if (pass == PrimaryPass || child1()-&gt;sawBooleans() || (child2() &amp;&amp; child2()-&gt;sawBooleans()))
2666             return DFGRareCase;
2667         return AllRareCases;
2668     }
2669 
2670     bool canSpeculateInt32(PredictionPass pass)
2671     {
2672         return canSpeculateInt32(sourceFor(pass));
2673     }
2674 
2675     bool canSpeculateInt52(PredictionPass pass)
2676     {
2677         return canSpeculateInt52(sourceFor(pass));
2678     }
2679 
2680     bool hasTypeLocation()
2681     {
2682         return op() == ProfileType;
2683     }
2684 
2685     TypeLocation* typeLocation()
2686     {
2687         ASSERT(hasTypeLocation());
2688         return m_opInfo.as&lt;TypeLocation*&gt;();
2689     }
2690 
2691     bool hasBasicBlockLocation()
2692     {
2693         return op() == ProfileControlFlow;
2694     }
2695 
2696     BasicBlockLocation* basicBlockLocation()
2697     {
2698         ASSERT(hasBasicBlockLocation());
2699         return m_opInfo.as&lt;BasicBlockLocation*&gt;();
2700     }
2701 
2702     bool hasCallDOMGetterData() const
2703     {
2704         return op() == CallDOMGetter;
2705     }
2706 
2707     CallDOMGetterData* callDOMGetterData()
2708     {
2709         ASSERT(hasCallDOMGetterData());
2710         return m_opInfo.as&lt;CallDOMGetterData*&gt;();
2711     }
2712 
2713     bool hasClassInfo() const
2714     {
2715         return op() == CheckSubClass;
2716     }
2717 
2718     const ClassInfo* classInfo()
2719     {
2720         return m_opInfo.as&lt;const ClassInfo*&gt;();
2721     }
2722 
2723     bool hasSignature() const
2724     {
2725         // Note that this does not include TailCall node types intentionally.
2726         // CallDOM node types are always converted from Call.
2727         return op() == Call || op() == CallDOM;
2728     }
2729 
2730     const DOMJIT::Signature* signature()
2731     {
2732         return m_opInfo.as&lt;const DOMJIT::Signature*&gt;();
2733     }
2734 
2735     bool hasInternalMethodType() const
2736     {
2737         return op() == HasIndexedProperty;
2738     }
2739 
2740     PropertySlot::InternalMethodType internalMethodType() const
2741     {
2742         ASSERT(hasInternalMethodType());
2743         return static_cast&lt;PropertySlot::InternalMethodType&gt;(m_opInfo2.as&lt;uint32_t&gt;());
2744     }
2745 
2746     void setInternalMethodType(PropertySlot::InternalMethodType type)
2747     {
2748         ASSERT(hasInternalMethodType());
2749         m_opInfo2 = static_cast&lt;uint32_t&gt;(type);
2750     }
2751 
2752     Node* replacement() const
2753     {
2754         return m_misc.replacement;
2755     }
2756 
2757     void setReplacement(Node* replacement)
2758     {
2759         m_misc.replacement = replacement;
2760     }
2761 
2762     Epoch epoch() const
2763     {
2764         return Epoch::fromUnsigned(m_misc.epoch);
2765     }
2766 
2767     void setEpoch(Epoch epoch)
2768     {
2769         m_misc.epoch = epoch.toUnsigned();
2770     }
2771 
2772     bool hasNumberOfArgumentsToSkip()
2773     {
2774         return op() == CreateRest || op() == PhantomCreateRest || op() == GetRestLength || op() == GetMyArgumentByVal || op() == GetMyArgumentByValOutOfBounds;
2775     }
2776 
2777     unsigned numberOfArgumentsToSkip()
2778     {
2779         ASSERT(hasNumberOfArgumentsToSkip());
2780         return m_opInfo.as&lt;unsigned&gt;();
2781     }
2782 
2783     bool hasArgumentIndex()
2784     {
2785         return op() == GetArgument;
2786     }
2787 
2788     unsigned argumentIndex()
2789     {
2790         ASSERT(hasArgumentIndex());
2791         return m_opInfo.as&lt;unsigned&gt;();
2792     }
2793 
2794     bool hasBucketOwnerType()
2795     {
2796         return op() == GetMapBucketNext || op() == LoadKeyFromMapBucket || op() == LoadValueFromMapBucket;
2797     }
2798 
2799     BucketOwnerType bucketOwnerType()
2800     {
2801         ASSERT(hasBucketOwnerType());
2802         return m_opInfo.as&lt;BucketOwnerType&gt;();
2803     }
2804 
2805     bool hasValidRadixConstant()
2806     {
2807         return op() == NumberToStringWithValidRadixConstant;
2808     }
2809 
2810     int32_t validRadixConstant()
2811     {
2812         ASSERT(hasValidRadixConstant());
2813         return m_opInfo.as&lt;int32_t&gt;();
2814     }
2815 
2816     bool hasIgnoreLastIndexIsWritable()
2817     {
2818         return op() == SetRegExpObjectLastIndex;
2819     }
2820 
2821     bool ignoreLastIndexIsWritable()
2822     {
2823         ASSERT(hasIgnoreLastIndexIsWritable());
2824         return m_opInfo.as&lt;uint32_t&gt;();
2825     }
2826 
2827     uint32_t errorType()
2828     {
2829         ASSERT(op() == ThrowStaticError);
2830         return m_opInfo.as&lt;uint32_t&gt;();
2831     }
2832 
2833     bool hasCallLinkStatus()
2834     {
2835         return op() == FilterCallLinkStatus;
2836     }
2837 
2838     CallLinkStatus* callLinkStatus()
2839     {
2840         ASSERT(hasCallLinkStatus());
2841         return m_opInfo.as&lt;CallLinkStatus*&gt;();
2842     }
2843 
2844     bool hasGetByIdStatus()
2845     {
2846         return op() == FilterGetByIdStatus;
2847     }
2848 
2849     GetByIdStatus* getByIdStatus()
2850     {
2851         ASSERT(hasGetByIdStatus());
2852         return m_opInfo.as&lt;GetByIdStatus*&gt;();
2853     }
2854 
2855     bool hasInByIdStatus()
2856     {
2857         return op() == FilterInByIdStatus;
2858     }
2859 
2860     InByIdStatus* inByIdStatus()
2861     {
2862         ASSERT(hasInByIdStatus());
2863         return m_opInfo.as&lt;InByIdStatus*&gt;();
2864     }
2865 
2866     bool hasPutByIdStatus()
2867     {
2868         return op() == FilterPutByIdStatus;
2869     }
2870 
2871     PutByIdStatus* putByIdStatus()
2872     {
2873         ASSERT(hasPutByIdStatus());
2874         return m_opInfo.as&lt;PutByIdStatus*&gt;();
2875     }
2876 
2877     void dumpChildren(PrintStream&amp; out)
2878     {
2879         if (!child1())
2880             return;
2881         out.printf(&quot;@%u&quot;, child1()-&gt;index());
2882         if (!child2())
2883             return;
2884         out.printf(&quot;, @%u&quot;, child2()-&gt;index());
2885         if (!child3())
2886             return;
2887         out.printf(&quot;, @%u&quot;, child3()-&gt;index());
2888     }
2889 
<a name="11" id="anc11"></a><span class="line-removed">2890     // NB. This class must have a trivial destructor.</span>
<span class="line-removed">2891 </span>
2892     NodeOrigin origin;
2893 
2894     // References to up to 3 children, or links to a variable length set of children.
2895     AdjacencyList children;
2896 
2897 private:
2898     friend class B3::SparseCollection&lt;Node&gt;;
2899 
2900     unsigned m_index { std::numeric_limits&lt;unsigned&gt;::max() };
2901     unsigned m_op : 10; // real type is NodeType
2902     unsigned m_flags : 21;
2903     // The virtual register number (spill location) associated with this .
2904     VirtualRegister m_virtualRegister;
2905     // The number of uses of the result of this operation (+1 for &#39;must generate&#39; nodes, which have side-effects).
2906     unsigned m_refCount;
2907     // The prediction ascribed to this node after propagation.
2908     SpeculatedType m_prediction { SpecNone };
2909     // Immediate values, accesses type-checked via accessors above.
2910     struct OpInfoWrapper {
2911         OpInfoWrapper()
2912         {
2913             u.int64 = 0;
2914         }
2915         OpInfoWrapper(uint32_t intValue)
2916         {
2917             u.int64 = 0;
2918             u.int32 = intValue;
2919         }
2920         OpInfoWrapper(uint64_t intValue)
2921         {
2922             u.int64 = intValue;
2923         }
2924         OpInfoWrapper(void* pointer)
2925         {
2926             u.int64 = 0;
2927             u.pointer = pointer;
2928         }
2929         OpInfoWrapper(const void* constPointer)
2930         {
2931             u.int64 = 0;
2932             u.constPointer = constPointer;
2933         }
2934         OpInfoWrapper(RegisteredStructure structure)
2935         {
2936             u.int64 = 0;
2937             u.pointer = bitwise_cast&lt;void*&gt;(structure);
2938         }
2939         OpInfoWrapper&amp; operator=(uint32_t int32)
2940         {
2941             u.int64 = 0;
2942             u.int32 = int32;
2943             return *this;
2944         }
2945         OpInfoWrapper&amp; operator=(int32_t int32)
2946         {
2947             u.int64 = 0;
2948             u.int32 = int32;
2949             return *this;
2950         }
2951         OpInfoWrapper&amp; operator=(uint64_t int64)
2952         {
2953             u.int64 = int64;
2954             return *this;
2955         }
2956         OpInfoWrapper&amp; operator=(void* pointer)
2957         {
2958             u.int64 = 0;
2959             u.pointer = pointer;
2960             return *this;
2961         }
2962         OpInfoWrapper&amp; operator=(const void* constPointer)
2963         {
2964             u.int64 = 0;
2965             u.constPointer = constPointer;
2966             return *this;
2967         }
2968         OpInfoWrapper&amp; operator=(RegisteredStructure structure)
2969         {
2970             u.int64 = 0;
2971             u.pointer = bitwise_cast&lt;void*&gt;(structure);
2972             return *this;
2973         }
2974         OpInfoWrapper&amp; operator=(NewArrayBufferData newArrayBufferData)
2975         {
2976             u.int64 = bitwise_cast&lt;uint64_t&gt;(newArrayBufferData);
2977             return *this;
2978         }
2979         template &lt;typename T&gt;
2980         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; !std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
2981         {
2982             return static_cast&lt;T&gt;(u.pointer);
2983         }
2984         template &lt;typename T&gt;
2985         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
2986         {
2987             return static_cast&lt;T&gt;(u.constPointer);
2988         }
2989         template &lt;typename T&gt;
2990         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) &lt;= 4, T&gt;::type
2991         {
2992             return static_cast&lt;T&gt;(u.int32);
2993         }
2994         template &lt;typename T&gt;
2995         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) == 8, T&gt;::type
2996         {
2997             return static_cast&lt;T&gt;(u.int64);
2998         }
2999         ALWAYS_INLINE RegisteredStructure asRegisteredStructure() const
3000         {
3001             return bitwise_cast&lt;RegisteredStructure&gt;(u.pointer);
3002         }
3003         ALWAYS_INLINE NewArrayBufferData asNewArrayBufferData() const
3004         {
3005             return bitwise_cast&lt;NewArrayBufferData&gt;(u.int64);
3006         }
3007 
3008         union {
3009             uint32_t int32;
3010             uint64_t int64;
3011             void* pointer;
3012             const void* constPointer;
3013         } u;
3014     };
3015     OpInfoWrapper m_opInfo;
3016     OpInfoWrapper m_opInfo2;
3017 
3018     // Miscellaneous data that is usually meaningless, but can hold some analysis results
3019     // if you ask right. For example, if you do Graph::initializeNodeOwners(), Node::owner
3020     // will tell you which basic block a node belongs to. You cannot rely on this persisting
3021     // across transformations unless you do the maintenance work yourself. Other phases use
3022     // Node::replacement, but they do so manually: first you do Graph::clearReplacements()
3023     // and then you set, and use, replacement&#39;s yourself. Same thing for epoch.
3024     //
3025     // Bottom line: don&#39;t use these fields unless you initialize them yourself, or by
3026     // calling some appropriate methods that initialize them the way you want. Otherwise,
3027     // these fields are meaningless.
3028 private:
3029     union {
3030         Node* replacement;
3031         unsigned epoch;
3032     } m_misc;
3033 public:
3034     BasicBlock* owner;
3035 };
3036 
3037 // Uncomment this to log NodeSet operations.
3038 // typedef LoggingHashSet&lt;Node::HashSetTemplateInstantiationString, Node*&gt; NodeSet;
3039 typedef HashSet&lt;Node*&gt; NodeSet;
3040 
3041 struct NodeComparator {
3042     template&lt;typename NodePtrType&gt;
3043     bool operator()(NodePtrType a, NodePtrType b) const
3044     {
3045         return a-&gt;index() &lt; b-&gt;index();
3046     }
3047 };
3048 
3049 template&lt;typename T&gt;
3050 CString nodeListDump(const T&amp; nodeList)
3051 {
3052     return sortedListDump(nodeList, NodeComparator());
3053 }
3054 
3055 template&lt;typename T&gt;
3056 CString nodeMapDump(const T&amp; nodeMap, DumpContext* context = 0)
3057 {
3058     Vector&lt;typename T::KeyType&gt; keys;
3059     for (
3060         typename T::const_iterator iter = nodeMap.begin();
3061         iter != nodeMap.end(); ++iter)
3062         keys.append(iter-&gt;key);
3063     std::sort(keys.begin(), keys.end(), NodeComparator());
3064     StringPrintStream out;
3065     CommaPrinter comma;
3066     for(unsigned i = 0; i &lt; keys.size(); ++i)
3067         out.print(comma, keys[i], &quot;=&gt;&quot;, inContext(nodeMap.get(keys[i]), context));
3068     return out.toCString();
3069 }
3070 
3071 template&lt;typename T&gt;
3072 CString nodeValuePairListDump(const T&amp; nodeValuePairList, DumpContext* context = 0)
3073 {
3074     using V = typename T::ValueType;
3075     T sortedList = nodeValuePairList;
3076     std::sort(sortedList.begin(), sortedList.end(), [](const V&amp; a, const V&amp; b) {
3077         return NodeComparator()(a.node, b.node);
3078     });
3079 
3080     StringPrintStream out;
3081     CommaPrinter comma;
3082     for (const auto&amp; pair : sortedList)
3083         out.print(comma, pair.node, &quot;=&gt;&quot;, inContext(pair.value, context));
3084     return out.toCString();
3085 }
3086 
3087 } } // namespace JSC::DFG
3088 
3089 namespace WTF {
3090 
3091 void printInternal(PrintStream&amp;, JSC::DFG::SwitchKind);
3092 void printInternal(PrintStream&amp;, JSC::DFG::Node*);
3093 
3094 inline JSC::DFG::Node* inContext(JSC::DFG::Node* node, JSC::DumpContext*) { return node; }
3095 
3096 template&lt;&gt;
3097 struct LoggingHashKeyTraits&lt;JSC::DFG::Node*&gt; {
3098     static void print(PrintStream&amp; out, JSC::DFG::Node* key)
3099     {
3100         out.print(&quot;bitwise_cast&lt;::JSC::DFG::Node*&gt;(&quot;, RawPointer(key), &quot;lu)&quot;);
3101     }
3102 };
3103 
3104 } // namespace WTF
3105 
3106 using WTF::inContext;
3107 
3108 #endif
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>