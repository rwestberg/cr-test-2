<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
</pre>
<hr />
<pre>
  51 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState*);
  52 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState*);
  53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState*);
  54 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState*);
  55 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState*);
  56 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState*);
  57 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState*);
  58 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState*);
  59 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState*);
  60 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState*);
  61 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState*);
  62 
  63 // ------------------------------ ArrayPrototype ----------------------------
  64 
  65 const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  66 
  67 ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  68 {
  69     ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
  70     prototype-&gt;finishCreation(vm, globalObject);
<span class="line-removed">  71     vm.heap.addFinalizer(prototype, destroy);</span>
  72     return prototype;
  73 }
  74 
  75 // ECMA 15.4.4
  76 ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
  77     : JSArray(vm, structure, 0)
  78 {
  79 }
  80 
  81 void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  82 {
  83     Base::finishCreation(vm);
  84     ASSERT(inherits(vm, info()));
<span class="line-removed">  85     didBecomePrototype();</span>
  86 
  87     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;arrayProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  88     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPublicName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  89     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  90 
  91     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toLocaleString, arrayProtoFuncToLocaleString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<span class="line-modified">  92     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;concat&quot;, arrayPrototypeConcatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">  93     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;fill&quot;, arrayPrototypeFillCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  94     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;join, arrayProtoFuncJoin, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
  95     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;pop&quot;, arrayProtoFuncPop, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayPopIntrinsic);
  96     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
  97     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
  98     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  99     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 100     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
 101     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
<span class="line-modified"> 102     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;sort&quot;, arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 103     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 104     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified"> 105     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;every&quot;, arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 106     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;forEach&quot;, arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 107     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;some&quot;, arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 108     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
 109     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified"> 110     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;filter&quot;, arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 111     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flat&quot;, arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 112     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;flatMap&quot;, arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 113     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduce&quot;, arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 114     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;reduceRight&quot;, arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 115     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;map&quot;, arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 116     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 117     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 118     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;find&quot;, arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 119     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;findIndex&quot;, arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 120     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;includes&quot;, arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 121     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;copyWithin&quot;, arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 122 
 123     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 124     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 125     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 126     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 127 
 128     JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());
<span class="line-modified"> 129     const char* unscopableNames[] = {</span>
<span class="line-modified"> 130         &quot;copyWithin&quot;,</span>
<span class="line-modified"> 131         &quot;entries&quot;,</span>
<span class="line-modified"> 132         &quot;fill&quot;,</span>
<span class="line-modified"> 133         &quot;find&quot;,</span>
<span class="line-modified"> 134         &quot;findIndex&quot;,</span>
<span class="line-modified"> 135         &quot;includes&quot;,</span>
<span class="line-modified"> 136         &quot;keys&quot;,</span>
<span class="line-modified"> 137         &quot;values&quot;</span>



 138     };
<span class="line-modified"> 139     for (const char* unscopableName : unscopableNames)</span>
<span class="line-modified"> 140         unscopables-&gt;putDirect(vm, Identifier::fromString(&amp;vm, unscopableName), jsBoolean(true));</span>
 141     putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 142 }
 143 
<span class="line-removed"> 144 void ArrayPrototype::destroy(JSC::JSCell* cell)</span>
<span class="line-removed"> 145 {</span>
<span class="line-removed"> 146     ArrayPrototype* thisObject = static_cast&lt;ArrayPrototype*&gt;(cell);</span>
<span class="line-removed"> 147     thisObject-&gt;ArrayPrototype::~ArrayPrototype();</span>
<span class="line-removed"> 148 }</span>
<span class="line-removed"> 149 </span>
 150 // ------------------------------ Array Functions ----------------------------
 151 
 152 static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)
 153 {
 154     VM&amp; vm = exec-&gt;vm();
 155     auto scope = DECLARE_THROW_SCOPE(vm);
 156 
 157     if (JSValue result = object-&gt;tryGetIndexQuickly(index))
 158         return result;
 159     // We want to perform get and has in the same operation.
 160     // We can only do so when this behavior is not observable. The
 161     // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
 162     // somewhere in the prototype chain.
 163     PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
 164     bool hasProperty = object-&gt;getPropertySlot(exec, index, slot);
 165     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 166     if (!hasProperty)
 167         return { };
 168     if (UNLIKELY(slot.isTaintedByOpaqueObject()))
 169         RELEASE_AND_RETURN(scope, object-&gt;get(exec, index));
</pre>
<hr />
<pre>
 174 static ALWAYS_INLINE bool putLength(ExecState* exec, VM&amp; vm, JSObject* obj, JSValue value)
 175 {
 176     PutPropertySlot slot(obj);
 177     return obj-&gt;methodTable(vm)-&gt;put(obj, exec, vm.propertyNames-&gt;length, value, slot);
 178 }
 179 
 180 static ALWAYS_INLINE void setLength(ExecState* exec, VM&amp; vm, JSObject* obj, unsigned value)
 181 {
 182     auto scope = DECLARE_THROW_SCOPE(vm);
 183     static const bool throwException = true;
 184     if (isJSArray(obj)) {
 185         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(exec, value, throwException);
 186         RETURN_IF_EXCEPTION(scope, void());
 187     }
 188     bool success = putLength(exec, vm, obj, jsNumber(value));
 189     RETURN_IF_EXCEPTION(scope, void());
 190     if (UNLIKELY(!success))
 191         throwTypeError(exec, scope, ReadonlyPropertyWriteError);
 192 }
 193 




 194 ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)
 195 {
 196     VM&amp; vm = exec-&gt;vm();
 197     JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
 198     ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
 199 
<span class="line-modified"> 200     if (globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == ClearWatchpoint) {</span>
<span class="line-modified"> 201         arrayPrototype-&gt;tryInitializeSpeciesWatchpoint(exec);</span>
<span class="line-modified"> 202         ASSERT(globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() != ClearWatchpoint);</span>

 203     }
 204 
 205     return !thisObject-&gt;hasCustomProperties(vm)
 206         &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<span class="line-modified"> 207         &amp;&amp; globalObject-&gt;arraySpeciesWatchpoint().stateOnJSThread() == IsWatched;</span>
 208 }
 209 
 210 enum class SpeciesConstructResult {
 211     FastPath,
 212     Exception,
 213     CreatedObject
 214 };
 215 
<span class="line-modified"> 216 static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, unsigned length)</span>
 217 {
 218     VM&amp; vm = exec-&gt;vm();
 219     auto scope = DECLARE_THROW_SCOPE(vm);
 220 
 221     auto exceptionResult = [] () {
 222         return std::make_pair(SpeciesConstructResult::Exception, nullptr);
 223     };
 224 
 225     // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
 226     JSValue constructor = jsUndefined();
 227     bool thisIsArray = isArray(exec, thisObject);
 228     RETURN_IF_EXCEPTION(scope, exceptionResult());
 229     if (LIKELY(thisIsArray)) {
 230         // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
 231         // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
 232         bool isValid = speciesWatchpointIsValid(exec, thisObject);
 233         scope.assertNoException();
 234         if (LIKELY(isValid))
 235             return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 236 
 237         constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);
 238         RETURN_IF_EXCEPTION(scope, exceptionResult());
 239         if (constructor.isConstructor(vm)) {
 240             JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified"> 241             if (exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm))</span>
<span class="line-modified"> 242                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>


 243         }
 244         if (constructor.isObject()) {
 245             constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);
 246             RETURN_IF_EXCEPTION(scope, exceptionResult());
 247             if (constructor.isNull())
<span class="line-modified"> 248                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);;</span>
 249         }
 250     } else {
 251         // If isArray is false, return ? ArrayCreate(length).
 252         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 253     }
 254 
 255     if (constructor.isUndefined())
 256         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 257 
 258     MarkedArgumentBuffer args;
 259     args.append(jsNumber(length));
 260     ASSERT(!args.hasOverflowed());
 261     JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);
 262     RETURN_IF_EXCEPTION(scope, exceptionResult());
 263     return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
 264 }
 265 






















 266 static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)
 267 {
 268     JSValue value = exec-&gt;argument(argument);
 269     if (value.isUndefined())
 270         return undefinedValue;
 271 
 272     double indexDouble = value.toInteger(exec);
 273     if (indexDouble &lt; 0) {
 274         indexDouble += length;
 275         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 276     }
 277     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
 278 }
 279 
 280 // The shift/unshift function implement the shift/unshift behaviour required
 281 // by the corresponding array prototype methods, and by splice. In both cases,
 282 // the methods are operating an an array or array like object.
 283 //
 284 //  header  currentCount  (remainder)
 285 // [------][------------][-----------]
</pre>
<hr />
<pre>
 492             if (LIKELY(!isHole(value)))
 493                 joiner.appendNumber(vm, value);
 494             else {
 495                 if (sawHoles)
 496                     *sawHoles = true;
 497                 if (!holesKnownToBeOK) {
 498                     if (holesMustForwardToPrototype(vm, thisObject))
 499                         goto generalCase;
 500                     holesKnownToBeOK = true;
 501                 }
 502                 joiner.appendEmptyString();
 503             }
 504         }
 505         RELEASE_AND_RETURN(scope, joiner.join(state));
 506     }
 507     case ALL_UNDECIDED_INDEXING_TYPES: {
 508         if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 509             goto generalCase;
 510         switch (separator.length()) {
 511         case 0:
<span class="line-modified"> 512             RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
 513         case 1: {
 514             if (length &lt;= 1)
<span class="line-modified"> 515                 RELEASE_AND_RETURN(scope, jsEmptyString(&amp;state));</span>
 516             if (separator.is8Bit())
 517                 RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));
 518             RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));



















 519         }
 520         }
 521     }
 522     }
 523 
 524 generalCase:
 525     JSStringJoiner joiner(state, separator, length);
 526     RETURN_IF_EXCEPTION(scope, { });
 527     for (unsigned i = 0; i &lt; length; ++i) {
 528         JSValue element = thisObject-&gt;getIndex(&amp;state, i);
 529         RETURN_IF_EXCEPTION(scope, { });
 530         joiner.append(state, element);
 531         RETURN_IF_EXCEPTION(scope, { });
 532     }
 533     RELEASE_AND_RETURN(scope, joiner.join(state));
 534 }
 535 















 536 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)
 537 {
 538     VM&amp; vm = exec-&gt;vm();
 539     auto scope = DECLARE_THROW_SCOPE(vm);
 540     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 541 
 542     // 1. Let array be the result of calling ToObject on the this value.
 543     JSObject* thisObject = thisValue.toObject(exec);
 544     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 545 
<span class="line-modified"> 546     // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.</span>
<span class="line-modified"> 547     JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
<span class="line-modified"> 548     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>

 549 
<span class="line-modified"> 550     // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).</span>
<span class="line-modified"> 551     bool customJoinCase = false;</span>
<span class="line-modified"> 552     if (!function.isCell())</span>
<span class="line-modified"> 553         customJoinCase = true;</span>
<span class="line-modified"> 554     CallData callData;</span>
<span class="line-modified"> 555     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified"> 556     if (callType == CallType::None)</span>
<span class="line-modified"> 557         customJoinCase = true;</span>
 558 
<span class="line-modified"> 559     if (UNLIKELY(customJoinCase))</span>
<span class="line-modified"> 560         RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
 561 
<span class="line-modified"> 562     // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.</span>
<span class="line-modified"> 563     if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)</span>
<span class="line-modified"> 564         RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>

 565 
 566     ASSERT(isJSArray(thisValue));
 567     JSArray* thisArray = asArray(thisValue);
 568 
 569     unsigned length = thisArray-&gt;length();
 570 
 571     StringRecursionChecker checker(exec, thisArray);
 572     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 573     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 574         return JSValue::encode(earlyReturnValue);
 575 
 576     if (LIKELY(canUseFastJoin(thisArray))) {
 577         const LChar comma = &#39;,&#39;;
 578         scope.release();
 579 
 580         bool isCoW = isCopyOnWrite(thisArray-&gt;indexingMode());
 581         JSImmutableButterfly* immutableButterfly = nullptr;
 582         if (isCoW) {
 583             immutableButterfly = JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly());
 584             auto iter = vm.heap.immutableButterflyToStringCache.find(immutableButterfly);
</pre>
<hr />
<pre>
 622     JSObject* thisObject = thisValue.toObject(exec);
 623     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 624     unsigned length = toLength(exec, thisObject);
 625     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 626 
 627     StringRecursionChecker checker(exec, thisObject);
 628     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 629     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 630         return JSValue::encode(earlyReturnValue);
 631 
 632     JSStringJoiner stringJoiner(*exec, &#39;,&#39;, length);
 633     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 634 
 635 #if ENABLE(INTL)
 636     ArgList arguments(exec);
 637 #endif
 638     for (unsigned i = 0; i &lt; length; ++i) {
 639         JSValue element = thisObject-&gt;getIndex(exec, i);
 640         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 641         if (element.isUndefinedOrNull())
<span class="line-modified"> 642             element = jsEmptyString(exec);</span>
 643         else {
 644             JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);
 645             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 646             CallData callData;
 647             CallType callType = getCallData(vm, conversionFunction, callData);
 648             if (callType != CallType::None) {
 649 #if ENABLE(INTL)
 650                 element = call(exec, conversionFunction, callType, callData, element, arguments);
 651 #else
 652                 element = call(exec, conversionFunction, callType, callData, element, *vm.emptyList);
 653 #endif
 654                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
 655             }
 656         }
 657         stringJoiner.append(*exec, element);
 658         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 659     }
 660 
 661     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(*exec)));
 662 }
 663 
 664 static JSValue slowJoin(ExecState&amp; exec, JSObject* thisObject, JSString* separator, uint64_t length)
 665 {
 666     VM&amp; vm = exec.vm();
 667     auto scope = DECLARE_THROW_SCOPE(vm);
 668 
 669     // 5. If len is zero, return the empty String.
 670     if (!length)
<span class="line-modified"> 671         return jsEmptyString(&amp;exec);</span>
 672 
 673     // 6. Let element0 be Get(O, &quot;0&quot;).
 674     JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);
 675     RETURN_IF_EXCEPTION(scope, { });
 676 
 677     // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
 678     JSString* r = nullptr;
 679     if (element0.isUndefinedOrNull())
<span class="line-modified"> 680         r = jsEmptyString(&amp;exec);</span>
 681     else
 682         r = element0.toString(&amp;exec);
 683     RETURN_IF_EXCEPTION(scope, { });
 684 
 685     // 8. Let k be 1.
 686     // 9. Repeat, while k &lt; len
 687     // 9.e Increase k by 1..
 688     for (uint64_t k = 1; k &lt; length; ++k) {
 689         // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified"> 690         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(&amp;exec, AtomicString::number(k)));</span>
 691         RETURN_IF_EXCEPTION(scope, { });
 692 
 693         // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
 694         JSString* next = nullptr;
 695         if (element.isUndefinedOrNull()) {
 696             if (!separator-&gt;length())
 697                 continue;
<span class="line-modified"> 698             next = jsEmptyString(&amp;exec);</span>
 699         } else
 700             next = element.toString(&amp;exec);
 701         RETURN_IF_EXCEPTION(scope, { });
 702 
 703         // a. Let S be the String value produced by concatenating R and sep.
 704         // d. Let R be a String value produced by concatenating S and next.
 705         r = jsString(&amp;exec, r, separator, next);
 706         RETURN_IF_EXCEPTION(scope, { });
 707     }
 708     // 10. Return R.
 709     return r;
 710 }
 711 
 712 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState* exec)
 713 {
 714     VM&amp; vm = exec-&gt;vm();
 715     auto scope = DECLARE_THROW_SCOPE(vm);
 716 
 717     // 1. Let O be ? ToObject(this value).
 718     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
</pre>
<hr />
<pre>
 720     if (UNLIKELY(!thisObject))
 721         return encodedJSValue();
 722 
 723     StringRecursionChecker checker(exec, thisObject);
 724     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 725     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 726         return JSValue::encode(earlyReturnValue);
 727 
 728     // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
 729     double length = toLength(exec, thisObject);
 730     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 731 
 732     // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
 733     JSValue separatorValue = exec-&gt;argument(0);
 734     if (separatorValue.isUndefined()) {
 735         const LChar comma = &#39;,&#39;;
 736 
 737         if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 738             uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 739             ASSERT(static_cast&lt;double&gt;(length64) == length);
<span class="line-modified"> 740             JSString* jsSeparator = jsSingleCharacterString(exec, comma);</span>
 741             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 742 
 743             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
 744         }
 745 
 746         unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
 747         ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
 748 
 749         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, { &amp;comma, 1 }, unsignedLength)));
 750     }
 751 
 752     // 4. Let sep be ? ToString(separator).
 753     JSString* jsSeparator = separatorValue.toString(exec);
 754     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 755 
 756     if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 757         uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 758         ASSERT(static_cast&lt;double&gt;(length64) == length);
 759 
 760         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
</pre>
<hr />
<pre>
 811     if (LIKELY(isJSArray(thisValue) &amp;&amp; exec-&gt;argumentCount() == 1)) {
 812         JSArray* array = asArray(thisValue);
 813         scope.release();
 814         array-&gt;pushInline(exec, exec-&gt;uncheckedArgument(0));
 815         return JSValue::encode(jsNumber(array-&gt;length()));
 816     }
 817 
 818     JSObject* thisObj = thisValue.toObject(exec);
 819     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 820     if (UNLIKELY(!thisObj))
 821         return encodedJSValue();
 822     unsigned length = toLength(exec, thisObj);
 823     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 824 
 825     for (unsigned n = 0; n &lt; exec-&gt;argumentCount(); n++) {
 826         // Check for integer overflow; where safe we can do a fast put by index.
 827         if (length + n &gt;= length)
 828             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);
 829         else {
 830             PutPropertySlot slot(thisObj);
<span class="line-modified"> 831             Identifier propertyName = Identifier::fromString(exec, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
 832             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);
 833         }
 834         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 835     }
 836 
 837     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(exec-&gt;argumentCount()));
 838     scope.release();
 839     putLength(exec, vm, thisObj, newLength);
 840     return JSValue::encode(newLength);
 841 }
 842 
 843 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState* exec)
 844 {
 845     VM&amp; vm = exec-&gt;vm();
 846     auto scope = DECLARE_THROW_SCOPE(vm);
 847 
 848     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 849     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 850     if (UNLIKELY(!thisObject))
 851         return encodedJSValue();
</pre>
<hr />
<pre>
1518 
1519     } else if (type != ArrayWithUndecided) {
1520         WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
1521         copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
1522         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
1523     }
1524 
1525     result-&gt;butterfly()-&gt;setPublicLength(resultSize);
1526     return JSValue::encode(result);
1527 }
1528 
1529 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)
1530 {
1531     ASSERT(exec-&gt;argumentCount() == 3);
1532 
1533     VM&amp; vm = exec-&gt;vm();
1534     auto scope = DECLARE_THROW_SCOPE(vm);
1535     JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
1536     JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));
1537     JSValue startValue = exec-&gt;uncheckedArgument(2);
<span class="line-modified">1538     ASSERT(startValue.isAnyInt() &amp;&amp; startValue.asAnyInt() &gt;= 0 &amp;&amp; startValue.asAnyInt() &lt;= std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified">1539     unsigned startIndex = static_cast&lt;unsigned&gt;(startValue.asAnyInt());</span>
1540     bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);
1541     EXCEPTION_ASSERT(!scope.exception() || !success);
1542     if (success)
1543         return JSValue::encode(jsUndefined());
1544     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1545     scope.release();
1546     moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());
1547     return JSValue::encode(jsUndefined());
1548 }
1549 
<span class="line-removed">1550 </span>
<span class="line-removed">1551 // -------------------- ArrayPrototype.constructor Watchpoint ------------------</span>
<span class="line-removed">1552 </span>
<span class="line-removed">1553 namespace ArrayPrototypeInternal {</span>
<span class="line-removed">1554 static bool verbose = false;</span>
<span class="line-removed">1555 }</span>
<span class="line-removed">1556 </span>
<span class="line-removed">1557 class ArrayPrototypeAdaptiveInferredPropertyWatchpoint : public AdaptiveInferredPropertyValueWatchpointBase {</span>
<span class="line-removed">1558 public:</span>
<span class="line-removed">1559     typedef AdaptiveInferredPropertyValueWatchpointBase Base;</span>
<span class="line-removed">1560     ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp;, ArrayPrototype*);</span>
<span class="line-removed">1561 </span>
<span class="line-removed">1562 private:</span>
<span class="line-removed">1563     void handleFire(VM&amp;, const FireDetail&amp;) override;</span>
<span class="line-removed">1564 </span>
<span class="line-removed">1565     ArrayPrototype* m_arrayPrototype;</span>
<span class="line-removed">1566 };</span>
<span class="line-removed">1567 </span>
<span class="line-removed">1568 void ArrayPrototype::tryInitializeSpeciesWatchpoint(ExecState* exec)</span>
<span class="line-removed">1569 {</span>
<span class="line-removed">1570     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1571 </span>
<span class="line-removed">1572     RELEASE_ASSERT(!m_constructorWatchpoint);</span>
<span class="line-removed">1573     RELEASE_ASSERT(!m_constructorSpeciesWatchpoint);</span>
<span class="line-removed">1574 </span>
<span class="line-removed">1575     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1576 </span>
<span class="line-removed">1577     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">1578         dataLog(&quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(this), &quot; with structure: &quot;, pointerDump(this-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(this-&gt;globalObject(vm)-&gt;arrayConstructor()-&gt;structure(vm)), &quot;\n&quot;);</span>
<span class="line-removed">1579     // First we need to make sure that the Array.prototype.constructor property points to Array</span>
<span class="line-removed">1580     // and that Array[Symbol.species] is the primordial GetterSetter.</span>
<span class="line-removed">1581 </span>
<span class="line-removed">1582     // We only initialize once so flattening the structures does not have any real cost.</span>
<span class="line-removed">1583     Structure* prototypeStructure = this-&gt;structure(vm);</span>
<span class="line-removed">1584     if (prototypeStructure-&gt;isDictionary())</span>
<span class="line-removed">1585         prototypeStructure = prototypeStructure-&gt;flattenDictionaryStructure(vm, this);</span>
<span class="line-removed">1586     RELEASE_ASSERT(!prototypeStructure-&gt;isDictionary());</span>
<span class="line-removed">1587 </span>
<span class="line-removed">1588     JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
<span class="line-removed">1589     ArrayConstructor* arrayConstructor = globalObject-&gt;arrayConstructor();</span>
<span class="line-removed">1590 </span>
<span class="line-removed">1591     auto invalidateWatchpoint = [&amp;] {</span>
<span class="line-removed">1592         globalObject-&gt;arraySpeciesWatchpoint().invalidate(vm, StringFireDetail(&quot;Was not able to set up array species watchpoint.&quot;));</span>
<span class="line-removed">1593     };</span>
<span class="line-removed">1594 </span>
<span class="line-removed">1595     PropertySlot constructorSlot(this, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">1596     this-&gt;getOwnPropertySlot(this, exec, vm.propertyNames-&gt;constructor, constructorSlot);</span>
<span class="line-removed">1597     scope.assertNoException();</span>
<span class="line-removed">1598     if (constructorSlot.slotBase() != this</span>
<span class="line-removed">1599         || !constructorSlot.isCacheableValue()</span>
<span class="line-removed">1600         || constructorSlot.getValue(exec, vm.propertyNames-&gt;constructor) != arrayConstructor) {</span>
<span class="line-removed">1601         invalidateWatchpoint();</span>
<span class="line-removed">1602         return;</span>
<span class="line-removed">1603     }</span>
<span class="line-removed">1604 </span>
<span class="line-removed">1605     Structure* constructorStructure = arrayConstructor-&gt;structure(vm);</span>
<span class="line-removed">1606     if (constructorStructure-&gt;isDictionary())</span>
<span class="line-removed">1607         constructorStructure = constructorStructure-&gt;flattenDictionaryStructure(vm, arrayConstructor);</span>
<span class="line-removed">1608 </span>
<span class="line-removed">1609     PropertySlot speciesSlot(arrayConstructor, PropertySlot::InternalMethodType::VMInquiry);</span>
<span class="line-removed">1610     arrayConstructor-&gt;getOwnPropertySlot(arrayConstructor, exec, vm.propertyNames-&gt;speciesSymbol, speciesSlot);</span>
<span class="line-removed">1611     scope.assertNoException();</span>
<span class="line-removed">1612     if (speciesSlot.slotBase() != arrayConstructor</span>
<span class="line-removed">1613         || !speciesSlot.isCacheableGetter()</span>
<span class="line-removed">1614         || speciesSlot.getterSetter() != globalObject-&gt;speciesGetterSetter()) {</span>
<span class="line-removed">1615         invalidateWatchpoint();</span>
<span class="line-removed">1616         return;</span>
<span class="line-removed">1617     }</span>
<span class="line-removed">1618 </span>
<span class="line-removed">1619     // Now we need to setup the watchpoints to make sure these conditions remain valid.</span>
<span class="line-removed">1620     prototypeStructure-&gt;startWatchingPropertyForReplacements(vm, constructorSlot.cachedOffset());</span>
<span class="line-removed">1621     constructorStructure-&gt;startWatchingPropertyForReplacements(vm, speciesSlot.cachedOffset());</span>
<span class="line-removed">1622 </span>
<span class="line-removed">1623     ObjectPropertyCondition constructorCondition = ObjectPropertyCondition::equivalence(vm, this, this, vm.propertyNames-&gt;constructor.impl(), arrayConstructor);</span>
<span class="line-removed">1624     ObjectPropertyCondition speciesCondition = ObjectPropertyCondition::equivalence(vm, this, arrayConstructor, vm.propertyNames-&gt;speciesSymbol.impl(), globalObject-&gt;speciesGetterSetter());</span>
<span class="line-removed">1625 </span>
<span class="line-removed">1626     if (!constructorCondition.isWatchable() || !speciesCondition.isWatchable()) {</span>
<span class="line-removed">1627         invalidateWatchpoint();</span>
<span class="line-removed">1628         return;</span>
<span class="line-removed">1629     }</span>
<span class="line-removed">1630 </span>
<span class="line-removed">1631     m_constructorWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(constructorCondition, this);</span>
<span class="line-removed">1632     m_constructorWatchpoint-&gt;install(vm);</span>
<span class="line-removed">1633 </span>
<span class="line-removed">1634     m_constructorSpeciesWatchpoint = std::make_unique&lt;ArrayPrototypeAdaptiveInferredPropertyWatchpoint&gt;(speciesCondition, this);</span>
<span class="line-removed">1635     m_constructorSpeciesWatchpoint-&gt;install(vm);</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637     // We only watch this from the DFG, and the DFG makes sure to only start watching if the watchpoint is in the IsWatched state.</span>
<span class="line-removed">1638     RELEASE_ASSERT(!globalObject-&gt;arraySpeciesWatchpoint().isBeingWatched());</span>
<span class="line-removed">1639     globalObject-&gt;arraySpeciesWatchpoint().touch(vm, &quot;Set up array species watchpoint.&quot;);</span>
<span class="line-removed">1640 }</span>
<span class="line-removed">1641 </span>
<span class="line-removed">1642 ArrayPrototypeAdaptiveInferredPropertyWatchpoint::ArrayPrototypeAdaptiveInferredPropertyWatchpoint(const ObjectPropertyCondition&amp; key, ArrayPrototype* prototype)</span>
<span class="line-removed">1643     : Base(key)</span>
<span class="line-removed">1644     , m_arrayPrototype(prototype)</span>
<span class="line-removed">1645 {</span>
<span class="line-removed">1646 }</span>
<span class="line-removed">1647 </span>
<span class="line-removed">1648 void ArrayPrototypeAdaptiveInferredPropertyWatchpoint::handleFire(VM&amp; vm, const FireDetail&amp; detail)</span>
<span class="line-removed">1649 {</span>
<span class="line-removed">1650     auto lazyDetail = createLazyFireDetail(&quot;ArrayPrototype adaption of &quot;, key(), &quot; failed: &quot;, detail);</span>
<span class="line-removed">1651 </span>
<span class="line-removed">1652     if (ArrayPrototypeInternal::verbose)</span>
<span class="line-removed">1653         WTF::dataLog(lazyDetail, &quot;\n&quot;);</span>
<span class="line-removed">1654 </span>
<span class="line-removed">1655     JSGlobalObject* globalObject = m_arrayPrototype-&gt;globalObject(vm);</span>
<span class="line-removed">1656     globalObject-&gt;arraySpeciesWatchpoint().fireAll(vm, lazyDetail);</span>
<span class="line-removed">1657 }</span>
<span class="line-removed">1658 </span>
1659 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">   3  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   4  *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
</pre>
<hr />
<pre>
  51 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState*);
  52 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState*);
  53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState*);
  54 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState*);
  55 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState*);
  56 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState*);
  57 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState*);
  58 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState*);
  59 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState*);
  60 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState*);
  61 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState*);
  62 
  63 // ------------------------------ ArrayPrototype ----------------------------
  64 
  65 const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  66 
  67 ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  68 {
  69     ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
  70     prototype-&gt;finishCreation(vm, globalObject);

  71     return prototype;
  72 }
  73 
  74 // ECMA 15.4.4
  75 ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
  76     : JSArray(vm, structure, 0)
  77 {
  78 }
  79 
  80 void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  81 {
  82     Base::finishCreation(vm);
  83     ASSERT(inherits(vm, info()));

  84 
  85     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;arrayProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  86     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPublicName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  87     putDirectWithoutTransition(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  88 
  89     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toLocaleString, arrayProtoFuncToLocaleString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
<span class="line-modified">  90     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().concatPublicName(), arrayPrototypeConcatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">  91     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().fillPublicName(), arrayPrototypeFillCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
  92     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;join, arrayProtoFuncJoin, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
  93     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;pop&quot;, arrayProtoFuncPop, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayPopIntrinsic);
  94     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
  95     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
  96     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  97     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  98     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
  99     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
<span class="line-modified"> 100     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().sortPublicName(), arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 101     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 102     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified"> 103     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().everyPublicName(), arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 104     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().forEachPublicName(), arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 105     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().somePublicName(), arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 106     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
 107     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
<span class="line-modified"> 108     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().filterPublicName(), arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 109     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 110     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 111     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 112     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 113     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 114     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 115     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 116     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 117     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 118     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 119     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 120 
 121     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 122     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 123     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 124     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 125 
 126     JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());
<span class="line-modified"> 127     unscopables-&gt;convertToDictionary(vm);</span>
<span class="line-modified"> 128     const Identifier* const unscopableNames[] = {</span>
<span class="line-modified"> 129         &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),</span>
<span class="line-modified"> 130         &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),</span>
<span class="line-modified"> 131         &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),</span>
<span class="line-modified"> 132         &amp;vm.propertyNames-&gt;builtinNames().findPublicName(),</span>
<span class="line-modified"> 133         &amp;vm.propertyNames-&gt;builtinNames().findIndexPublicName(),</span>
<span class="line-modified"> 134         &amp;vm.propertyNames-&gt;builtinNames().flatPublicName(),</span>
<span class="line-modified"> 135         &amp;vm.propertyNames-&gt;builtinNames().flatMapPublicName(),</span>
<span class="line-added"> 136         &amp;vm.propertyNames-&gt;builtinNames().includesPublicName(),</span>
<span class="line-added"> 137         &amp;vm.propertyNames-&gt;builtinNames().keysPublicName(),</span>
<span class="line-added"> 138         &amp;vm.propertyNames-&gt;builtinNames().valuesPublicName()</span>
 139     };
<span class="line-modified"> 140     for (const auto* unscopableName : unscopableNames)</span>
<span class="line-modified"> 141         unscopables-&gt;putDirect(vm, *unscopableName, jsBoolean(true));</span>
 142     putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 143 }
 144 






 145 // ------------------------------ Array Functions ----------------------------
 146 
 147 static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)
 148 {
 149     VM&amp; vm = exec-&gt;vm();
 150     auto scope = DECLARE_THROW_SCOPE(vm);
 151 
 152     if (JSValue result = object-&gt;tryGetIndexQuickly(index))
 153         return result;
 154     // We want to perform get and has in the same operation.
 155     // We can only do so when this behavior is not observable. The
 156     // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
 157     // somewhere in the prototype chain.
 158     PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
 159     bool hasProperty = object-&gt;getPropertySlot(exec, index, slot);
 160     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 161     if (!hasProperty)
 162         return { };
 163     if (UNLIKELY(slot.isTaintedByOpaqueObject()))
 164         RELEASE_AND_RETURN(scope, object-&gt;get(exec, index));
</pre>
<hr />
<pre>
 169 static ALWAYS_INLINE bool putLength(ExecState* exec, VM&amp; vm, JSObject* obj, JSValue value)
 170 {
 171     PutPropertySlot slot(obj);
 172     return obj-&gt;methodTable(vm)-&gt;put(obj, exec, vm.propertyNames-&gt;length, value, slot);
 173 }
 174 
 175 static ALWAYS_INLINE void setLength(ExecState* exec, VM&amp; vm, JSObject* obj, unsigned value)
 176 {
 177     auto scope = DECLARE_THROW_SCOPE(vm);
 178     static const bool throwException = true;
 179     if (isJSArray(obj)) {
 180         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(exec, value, throwException);
 181         RETURN_IF_EXCEPTION(scope, void());
 182     }
 183     bool success = putLength(exec, vm, obj, jsNumber(value));
 184     RETURN_IF_EXCEPTION(scope, void());
 185     if (UNLIKELY(!success))
 186         throwTypeError(exec, scope, ReadonlyPropertyWriteError);
 187 }
 188 
<span class="line-added"> 189 namespace ArrayPrototypeInternal {</span>
<span class="line-added"> 190 static bool verbose = false;</span>
<span class="line-added"> 191 }</span>
<span class="line-added"> 192 </span>
 193 ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)
 194 {
 195     VM&amp; vm = exec-&gt;vm();
 196     JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
 197     ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
 198 
<span class="line-modified"> 199     if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {</span>
<span class="line-modified"> 200         dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));</span>
<span class="line-modified"> 201         globalObject-&gt;tryInstallArraySpeciesWatchpoint(exec);</span>
<span class="line-added"> 202         ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);</span>
 203     }
 204 
 205     return !thisObject-&gt;hasCustomProperties(vm)
 206         &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<span class="line-modified"> 207         &amp;&amp; globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == IsWatched;</span>
 208 }
 209 
 210 enum class SpeciesConstructResult {
 211     FastPath,
 212     Exception,
 213     CreatedObject
 214 };
 215 
<span class="line-modified"> 216 static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, uint64_t length)</span>
 217 {
 218     VM&amp; vm = exec-&gt;vm();
 219     auto scope = DECLARE_THROW_SCOPE(vm);
 220 
 221     auto exceptionResult = [] () {
 222         return std::make_pair(SpeciesConstructResult::Exception, nullptr);
 223     };
 224 
 225     // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
 226     JSValue constructor = jsUndefined();
 227     bool thisIsArray = isArray(exec, thisObject);
 228     RETURN_IF_EXCEPTION(scope, exceptionResult());
 229     if (LIKELY(thisIsArray)) {
 230         // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
 231         // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
 232         bool isValid = speciesWatchpointIsValid(exec, thisObject);
 233         scope.assertNoException();
 234         if (LIKELY(isValid))
 235             return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 236 
 237         constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);
 238         RETURN_IF_EXCEPTION(scope, exceptionResult());
 239         if (constructor.isConstructor(vm)) {
 240             JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified"> 241             bool isArrayConstructorFromAnotherRealm = exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm)</span>
<span class="line-modified"> 242                 &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);</span>
<span class="line-added"> 243             if (isArrayConstructorFromAnotherRealm)</span>
<span class="line-added"> 244                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);</span>
 245         }
 246         if (constructor.isObject()) {
 247             constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);
 248             RETURN_IF_EXCEPTION(scope, exceptionResult());
 249             if (constructor.isNull())
<span class="line-modified"> 250                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);</span>
 251         }
 252     } else {
 253         // If isArray is false, return ? ArrayCreate(length).
 254         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 255     }
 256 
 257     if (constructor.isUndefined())
 258         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 259 
 260     MarkedArgumentBuffer args;
 261     args.append(jsNumber(length));
 262     ASSERT(!args.hasOverflowed());
 263     JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);
 264     RETURN_IF_EXCEPTION(scope, exceptionResult());
 265     return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
 266 }
 267 
<span class="line-added"> 268 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(ExecState* exec)</span>
<span class="line-added"> 269 {</span>
<span class="line-added"> 270     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-added"> 271     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 272     JSObject* object = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-added"> 273     uint64_t length = static_cast&lt;uint64_t&gt;(exec-&gt;uncheckedArgument(1).asNumber());</span>
<span class="line-added"> 274 </span>
<span class="line-added"> 275     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, object, length);</span>
<span class="line-added"> 276     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));</span>
<span class="line-added"> 277     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))</span>
<span class="line-added"> 278         return { };</span>
<span class="line-added"> 279     if (speciesResult.first == SpeciesConstructResult::CreatedObject)</span>
<span class="line-added"> 280         return JSValue::encode(speciesResult.second);</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282     if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {</span>
<span class="line-added"> 283         throwRangeError(exec, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
<span class="line-added"> 284         return { };</span>
<span class="line-added"> 285     }</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
<span class="line-added"> 288 }</span>
<span class="line-added"> 289 </span>
 290 static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)
 291 {
 292     JSValue value = exec-&gt;argument(argument);
 293     if (value.isUndefined())
 294         return undefinedValue;
 295 
 296     double indexDouble = value.toInteger(exec);
 297     if (indexDouble &lt; 0) {
 298         indexDouble += length;
 299         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 300     }
 301     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
 302 }
 303 
 304 // The shift/unshift function implement the shift/unshift behaviour required
 305 // by the corresponding array prototype methods, and by splice. In both cases,
 306 // the methods are operating an an array or array like object.
 307 //
 308 //  header  currentCount  (remainder)
 309 // [------][------------][-----------]
</pre>
<hr />
<pre>
 516             if (LIKELY(!isHole(value)))
 517                 joiner.appendNumber(vm, value);
 518             else {
 519                 if (sawHoles)
 520                     *sawHoles = true;
 521                 if (!holesKnownToBeOK) {
 522                     if (holesMustForwardToPrototype(vm, thisObject))
 523                         goto generalCase;
 524                     holesKnownToBeOK = true;
 525                 }
 526                 joiner.appendEmptyString();
 527             }
 528         }
 529         RELEASE_AND_RETURN(scope, joiner.join(state));
 530     }
 531     case ALL_UNDECIDED_INDEXING_TYPES: {
 532         if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 533             goto generalCase;
 534         switch (separator.length()) {
 535         case 0:
<span class="line-modified"> 536             RELEASE_AND_RETURN(scope, jsEmptyString(vm));</span>
 537         case 1: {
 538             if (length &lt;= 1)
<span class="line-modified"> 539                 RELEASE_AND_RETURN(scope, jsEmptyString(vm));</span>
 540             if (separator.is8Bit())
 541                 RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));
 542             RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));
<span class="line-added"> 543         default:</span>
<span class="line-added"> 544             JSString* result = jsEmptyString(vm);</span>
<span class="line-added"> 545             if (length &lt;= 1)</span>
<span class="line-added"> 546                 return result;</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548             JSString* operand = jsString(vm, separator.toString());</span>
<span class="line-added"> 549             RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 550             unsigned count = length - 1;</span>
<span class="line-added"> 551             for (;;) {</span>
<span class="line-added"> 552                 if (count &amp; 1) {</span>
<span class="line-added"> 553                     result = jsString(&amp;state, result, operand);</span>
<span class="line-added"> 554                     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 555                 }</span>
<span class="line-added"> 556                 count &gt;&gt;= 1;</span>
<span class="line-added"> 557                 if (!count)</span>
<span class="line-added"> 558                     return result;</span>
<span class="line-added"> 559                 operand = jsString(&amp;state, operand, operand);</span>
<span class="line-added"> 560                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added"> 561             }</span>
 562         }
 563         }
 564     }
 565     }
 566 
 567 generalCase:
 568     JSStringJoiner joiner(state, separator, length);
 569     RETURN_IF_EXCEPTION(scope, { });
 570     for (unsigned i = 0; i &lt; length; ++i) {
 571         JSValue element = thisObject-&gt;getIndex(&amp;state, i);
 572         RETURN_IF_EXCEPTION(scope, { });
 573         joiner.append(state, element);
 574         RETURN_IF_EXCEPTION(scope, { });
 575     }
 576     RELEASE_AND_RETURN(scope, joiner.join(state));
 577 }
 578 
<span class="line-added"> 579 inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)</span>
<span class="line-added"> 580 {</span>
<span class="line-added"> 581     JSGlobalObject* globalObject = thisObject-&gt;globalObject();</span>
<span class="line-added"> 582 </span>
<span class="line-added"> 583     if (globalObject-&gt;arrayJoinWatchpointSet().stateOnJSThread() != IsWatched)</span>
<span class="line-added"> 584         return false;</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586     Structure* structure = thisObject-&gt;structure(vm);</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588     // This is the fast case. Many arrays will be an original array.</span>
<span class="line-added"> 589     // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,</span>
<span class="line-added"> 590     // it would be possible that just looking into &quot;join&quot; function will show the same performance.</span>
<span class="line-added"> 591     return globalObject-&gt;isOriginalArrayStructure(structure);</span>
<span class="line-added"> 592 }</span>
<span class="line-added"> 593 </span>
 594 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)
 595 {
 596     VM&amp; vm = exec-&gt;vm();
 597     auto scope = DECLARE_THROW_SCOPE(vm);
 598     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);
 599 
 600     // 1. Let array be the result of calling ToObject on the this value.
 601     JSObject* thisObject = thisValue.toObject(exec);
 602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 603 
<span class="line-modified"> 604     if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {</span>
<span class="line-modified"> 605         // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.</span>
<span class="line-modified"> 606         JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
<span class="line-added"> 607         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
 608 
<span class="line-modified"> 609         // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).</span>
<span class="line-modified"> 610         bool customJoinCase = false;</span>
<span class="line-modified"> 611         if (!function.isCell())</span>
<span class="line-modified"> 612             customJoinCase = true;</span>
<span class="line-modified"> 613         CallData callData;</span>
<span class="line-modified"> 614         CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified"> 615         if (callType == CallType::None)</span>
<span class="line-modified"> 616             customJoinCase = true;</span>
 617 
<span class="line-modified"> 618         if (UNLIKELY(customJoinCase))</span>
<span class="line-modified"> 619             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
 620 
<span class="line-modified"> 621         // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.</span>
<span class="line-modified"> 622         if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)</span>
<span class="line-modified"> 623             RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>
<span class="line-added"> 624     }</span>
 625 
 626     ASSERT(isJSArray(thisValue));
 627     JSArray* thisArray = asArray(thisValue);
 628 
 629     unsigned length = thisArray-&gt;length();
 630 
 631     StringRecursionChecker checker(exec, thisArray);
 632     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 633     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 634         return JSValue::encode(earlyReturnValue);
 635 
 636     if (LIKELY(canUseFastJoin(thisArray))) {
 637         const LChar comma = &#39;,&#39;;
 638         scope.release();
 639 
 640         bool isCoW = isCopyOnWrite(thisArray-&gt;indexingMode());
 641         JSImmutableButterfly* immutableButterfly = nullptr;
 642         if (isCoW) {
 643             immutableButterfly = JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly());
 644             auto iter = vm.heap.immutableButterflyToStringCache.find(immutableButterfly);
</pre>
<hr />
<pre>
 682     JSObject* thisObject = thisValue.toObject(exec);
 683     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 684     unsigned length = toLength(exec, thisObject);
 685     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 686 
 687     StringRecursionChecker checker(exec, thisObject);
 688     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 689     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 690         return JSValue::encode(earlyReturnValue);
 691 
 692     JSStringJoiner stringJoiner(*exec, &#39;,&#39;, length);
 693     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 694 
 695 #if ENABLE(INTL)
 696     ArgList arguments(exec);
 697 #endif
 698     for (unsigned i = 0; i &lt; length; ++i) {
 699         JSValue element = thisObject-&gt;getIndex(exec, i);
 700         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 701         if (element.isUndefinedOrNull())
<span class="line-modified"> 702             element = jsEmptyString(vm);</span>
 703         else {
 704             JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);
 705             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 706             CallData callData;
 707             CallType callType = getCallData(vm, conversionFunction, callData);
 708             if (callType != CallType::None) {
 709 #if ENABLE(INTL)
 710                 element = call(exec, conversionFunction, callType, callData, element, arguments);
 711 #else
 712                 element = call(exec, conversionFunction, callType, callData, element, *vm.emptyList);
 713 #endif
 714                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
 715             }
 716         }
 717         stringJoiner.append(*exec, element);
 718         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 719     }
 720 
 721     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(*exec)));
 722 }
 723 
 724 static JSValue slowJoin(ExecState&amp; exec, JSObject* thisObject, JSString* separator, uint64_t length)
 725 {
 726     VM&amp; vm = exec.vm();
 727     auto scope = DECLARE_THROW_SCOPE(vm);
 728 
 729     // 5. If len is zero, return the empty String.
 730     if (!length)
<span class="line-modified"> 731         return jsEmptyString(vm);</span>
 732 
 733     // 6. Let element0 be Get(O, &quot;0&quot;).
 734     JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);
 735     RETURN_IF_EXCEPTION(scope, { });
 736 
 737     // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
 738     JSString* r = nullptr;
 739     if (element0.isUndefinedOrNull())
<span class="line-modified"> 740         r = jsEmptyString(vm);</span>
 741     else
 742         r = element0.toString(&amp;exec);
 743     RETURN_IF_EXCEPTION(scope, { });
 744 
 745     // 8. Let k be 1.
 746     // 9. Repeat, while k &lt; len
 747     // 9.e Increase k by 1..
 748     for (uint64_t k = 1; k &lt; length; ++k) {
 749         // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified"> 750         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(vm, AtomString::number(k)));</span>
 751         RETURN_IF_EXCEPTION(scope, { });
 752 
 753         // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
 754         JSString* next = nullptr;
 755         if (element.isUndefinedOrNull()) {
 756             if (!separator-&gt;length())
 757                 continue;
<span class="line-modified"> 758             next = jsEmptyString(vm);</span>
 759         } else
 760             next = element.toString(&amp;exec);
 761         RETURN_IF_EXCEPTION(scope, { });
 762 
 763         // a. Let S be the String value produced by concatenating R and sep.
 764         // d. Let R be a String value produced by concatenating S and next.
 765         r = jsString(&amp;exec, r, separator, next);
 766         RETURN_IF_EXCEPTION(scope, { });
 767     }
 768     // 10. Return R.
 769     return r;
 770 }
 771 
 772 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState* exec)
 773 {
 774     VM&amp; vm = exec-&gt;vm();
 775     auto scope = DECLARE_THROW_SCOPE(vm);
 776 
 777     // 1. Let O be ? ToObject(this value).
 778     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
</pre>
<hr />
<pre>
 780     if (UNLIKELY(!thisObject))
 781         return encodedJSValue();
 782 
 783     StringRecursionChecker checker(exec, thisObject);
 784     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 785     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 786         return JSValue::encode(earlyReturnValue);
 787 
 788     // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
 789     double length = toLength(exec, thisObject);
 790     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 791 
 792     // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
 793     JSValue separatorValue = exec-&gt;argument(0);
 794     if (separatorValue.isUndefined()) {
 795         const LChar comma = &#39;,&#39;;
 796 
 797         if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 798             uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 799             ASSERT(static_cast&lt;double&gt;(length64) == length);
<span class="line-modified"> 800             JSString* jsSeparator = jsSingleCharacterString(vm, comma);</span>
 801             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 802 
 803             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
 804         }
 805 
 806         unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
 807         ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
 808 
 809         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, { &amp;comma, 1 }, unsignedLength)));
 810     }
 811 
 812     // 4. Let sep be ? ToString(separator).
 813     JSString* jsSeparator = separatorValue.toString(exec);
 814     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 815 
 816     if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 817         uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 818         ASSERT(static_cast&lt;double&gt;(length64) == length);
 819 
 820         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));
</pre>
<hr />
<pre>
 871     if (LIKELY(isJSArray(thisValue) &amp;&amp; exec-&gt;argumentCount() == 1)) {
 872         JSArray* array = asArray(thisValue);
 873         scope.release();
 874         array-&gt;pushInline(exec, exec-&gt;uncheckedArgument(0));
 875         return JSValue::encode(jsNumber(array-&gt;length()));
 876     }
 877 
 878     JSObject* thisObj = thisValue.toObject(exec);
 879     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 880     if (UNLIKELY(!thisObj))
 881         return encodedJSValue();
 882     unsigned length = toLength(exec, thisObj);
 883     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 884 
 885     for (unsigned n = 0; n &lt; exec-&gt;argumentCount(); n++) {
 886         // Check for integer overflow; where safe we can do a fast put by index.
 887         if (length + n &gt;= length)
 888             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);
 889         else {
 890             PutPropertySlot slot(thisObj);
<span class="line-modified"> 891             Identifier propertyName = Identifier::fromString(vm, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
 892             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);
 893         }
 894         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 895     }
 896 
 897     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(exec-&gt;argumentCount()));
 898     scope.release();
 899     putLength(exec, vm, thisObj, newLength);
 900     return JSValue::encode(newLength);
 901 }
 902 
 903 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState* exec)
 904 {
 905     VM&amp; vm = exec-&gt;vm();
 906     auto scope = DECLARE_THROW_SCOPE(vm);
 907 
 908     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);
 909     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 910     if (UNLIKELY(!thisObject))
 911         return encodedJSValue();
</pre>
<hr />
<pre>
1578 
1579     } else if (type != ArrayWithUndecided) {
1580         WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
1581         copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
1582         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
1583     }
1584 
1585     result-&gt;butterfly()-&gt;setPublicLength(resultSize);
1586     return JSValue::encode(result);
1587 }
1588 
1589 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)
1590 {
1591     ASSERT(exec-&gt;argumentCount() == 3);
1592 
1593     VM&amp; vm = exec-&gt;vm();
1594     auto scope = DECLARE_THROW_SCOPE(vm);
1595     JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));
1596     JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));
1597     JSValue startValue = exec-&gt;uncheckedArgument(2);
<span class="line-modified">1598     ASSERT(startValue.isUInt32AsAnyInt());</span>
<span class="line-modified">1599     unsigned startIndex = startValue.asUInt32AsAnyInt();</span>
1600     bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);
1601     EXCEPTION_ASSERT(!scope.exception() || !success);
1602     if (success)
1603         return JSValue::encode(jsUndefined());
1604     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1605     scope.release();
1606     moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());
1607     return JSValue::encode(jsUndefined());
1608 }
1609 













































































































1610 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ArrayIteratorPrototype.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>