<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAdjacencyList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 485             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 486             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 487             for (Node* node : *block) {
 488                 clobberize(
 489                     m_graph, node, NoOpClobberize(),
 490                     [&amp;] (AbstractHeap heap) {
 491                         if (heap.kind() != Stack) {
 492                             ASSERT(!heap.overlaps(Stack));
 493                             return;
 494                         }
 495                         ASSERT(!heap.payload().isTop());
 496                         VirtualRegister reg(heap.payload().value32());
 497                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
 498                         if (!reg.isHeader())
 499                             clobberedByThisBlock.operand(reg) = true;
 500                     },
 501                     NoOpClobberize());
 502             }
 503         }
 504 



























 505         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 506             // Stop if we&#39;ve already removed all candidates.
 507             if (m_candidates.isEmpty())
 508                 return;
 509 
 510             // Ignore blocks that don&#39;t write to the stack.
 511             bool writesToStack = false;
 512             for (unsigned i = clobberedByBlock[block].size(); i--;) {
 513                 if (clobberedByBlock[block][i]) {
 514                     writesToStack = true;
 515                     break;
 516                 }
 517             }
 518             if (!writesToStack)
 519                 continue;
 520 
 521             forAllKillsInBlock(
 522                 m_graph, combinedLiveness, block,
 523                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 524                     if (!m_candidates.contains(candidate))
 525                         return;
 526 
<span class="line-modified"> 527                     // Check if this block has any clobbers that affect this candidate. This is a fairly</span>
<span class="line-modified"> 528                     // fast check.</span>
<span class="line-modified"> 529                     bool isClobberedByBlock = false;</span>
<span class="line-modified"> 530                     Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];</span>

 531 
<span class="line-modified"> 532                     if (InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame) {</span>
<span class="line-modified"> 533                         if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified"> 534                             isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 535                                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
<span class="line-modified"> 536                         }</span>
 537 
<span class="line-modified"> 538                         if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {</span>
<span class="line-modified"> 539                             isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 540                                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
<span class="line-modified"> 541                         }</span>
 542 
<span class="line-modified"> 543                         if (!isClobberedByBlock) {</span>
<span class="line-modified"> 544                             for (unsigned i = 0; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
<span class="line-modified"> 545                                 VirtualRegister reg =</span>
<span class="line-modified"> 546                                     VirtualRegister(inlineCallFrame-&gt;stackOffset) +</span>
<span class="line-modified"> 547                                     CallFrame::argumentOffset(i);</span>
<span class="line-modified"> 548                                 if (clobberedByThisBlock.operand(reg)) {</span>










 549                                     isClobberedByBlock = true;
 550                                     break;
 551                                 }
 552                             }
 553                         }
<span class="line-removed"> 554                     } else {</span>
<span class="line-removed"> 555                         // We don&#39;t include the ArgumentCount or Callee in this case because we can be</span>
<span class="line-removed"> 556                         // damn sure that this won&#39;t be clobbered.</span>
<span class="line-removed"> 557                         for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {</span>
<span class="line-removed"> 558                             if (clobberedByThisBlock.argument(i)) {</span>
<span class="line-removed"> 559                                 isClobberedByBlock = true;</span>
<span class="line-removed"> 560                                 break;</span>
<span class="line-removed"> 561                             }</span>
<span class="line-removed"> 562                         }</span>
<span class="line-removed"> 563                     }</span>
 564 
<span class="line-modified"> 565                     if (!isClobberedByBlock)</span>
<span class="line-modified"> 566                         return;</span>
 567 
<span class="line-modified"> 568                     // Check if we can immediately eliminate this candidate. If the block has a clobber</span>
<span class="line-modified"> 569                     // for this arguments allocation, and we&#39;d have to examine every node in the block,</span>
<span class="line-modified"> 570                     // then we can just eliminate the candidate.</span>
<span class="line-modified"> 571                     if (nodeIndex == block-&gt;size() &amp;&amp; candidate-&gt;owner != block) {</span>
<span class="line-modified"> 572                         if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 573                             dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by: &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 574                         transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 575                         return;</span>
<span class="line-modified"> 576                     }</span>
 577 
<span class="line-modified"> 578                     // This loop considers all nodes up to the nodeIndex, excluding the nodeIndex.</span>
<span class="line-modified"> 579                     while (nodeIndex--) {</span>
<span class="line-modified"> 580                         Node* node = block-&gt;at(nodeIndex);</span>
<span class="line-modified"> 581                         if (node == candidate)</span>
<span class="line-modified"> 582                             break;</span>













 583 
<span class="line-modified"> 584                         bool found = false;</span>
<span class="line-modified"> 585                         clobberize(</span>
<span class="line-modified"> 586                             m_graph, node, NoOpClobberize(),</span>
<span class="line-modified"> 587                             [&amp;] (AbstractHeap heap) {</span>
<span class="line-modified"> 588                                 if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {</span>
<span class="line-modified"> 589                                     if (argumentsInvolveStackSlot(candidate, VirtualRegister(heap.payload().value32())))</span>




 590                                         found = true;
<span class="line-modified"> 591                                     return;</span>
<span class="line-modified"> 592                                 }</span>
<span class="line-removed"> 593                                 if (heap.overlaps(Stack))</span>
<span class="line-removed"> 594                                     found = true;</span>
<span class="line-removed"> 595                             },</span>
<span class="line-removed"> 596                             NoOpClobberize());</span>
 597 
<span class="line-modified"> 598                         if (found) {</span>
<span class="line-modified"> 599                             if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 600                                 dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 601                             transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 602                             return;</span>

 603                         }
 604                     }
 605                 });
 606         }
 607 
 608         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
 609         // frame is dead?  A: Naively we could say that PhantomArguments must escape the stack slots. But
 610         // that would break PutStack sinking, which in turn would break object allocation sinking, in
 611         // cases where we have a varargs call to an otherwise pure method. So, we need something smarter.
 612         // For the outermost arguments, we just have a PhantomArguments that magically knows that it
 613         // should load the arguments from the call frame. For the inline arguments, we have the heap map
 614         // in the availabiltiy map track each possible inline argument as a promoted heap location. If the
 615         // PutStacks for those arguments aren&#39;t sunk, those heap locations will map to very trivial
 616         // availabilities (they will be flush availabilities). But if sinking happens then those
 617         // availabilities may become whatever. OSR exit should be able to handle this quite naturally,
 618         // since those availabilities speak of the stack before the optimizing compiler stack frame is
 619         // torn down.
 620 
 621         if (DFGArgumentsEliminationPhaseInternal::verbose)
 622             dataLog(&quot;After interference analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
</pre>
<hr />
<pre>
 644                     // We traverse in such a way that we are guaranteed to see a def before a use.
 645                     // Therefore, we should have already transformed the allocation before the use
 646                     // of an allocation.
 647                     ASSERT(candidate-&gt;op() == PhantomCreateRest || candidate-&gt;op() == PhantomDirectArguments || candidate-&gt;op() == PhantomClonedArguments
 648                         || candidate-&gt;op() == PhantomSpread || candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer);
 649                     return true;
 650                 };
 651 
 652                 switch (node-&gt;op()) {
 653                 case CreateDirectArguments:
 654                     if (!m_candidates.contains(node))
 655                         break;
 656 
 657                     node-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
 658                     break;
 659 
 660                 case CreateRest:
 661                     if (!m_candidates.contains(node))
 662                         break;
 663 






 664                     node-&gt;setOpAndDefaultFlags(PhantomCreateRest);
 665                     // We don&#39;t need this parameter for OSR exit, we can find out all the information
 666                     // we need via the static parameter count and the dynamic argument count.
 667                     node-&gt;child1() = Edge();
 668                     break;
 669 
 670                 case CreateClonedArguments:
 671                     if (!m_candidates.contains(node))
 672                         break;
 673 
 674                     node-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
 675                     break;
 676 
 677                 case Spread:
 678                     if (!m_candidates.contains(node))
 679                         break;
 680 
 681                     node-&gt;setOpAndDefaultFlags(PhantomSpread);
 682                     break;
 683 
</pre>
<hr />
<pre>
 736 
 737                 case GetByVal: {
 738                     // FIXME: For ClonedArguments, we would have already done a separate bounds check.
 739                     // This code will cause us to have two bounds checks - the original one that we
 740                     // already factored out in SSALoweringPhase, and the new one we insert here, which is
 741                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 742                     // second bounds check, but still - that&#39;s just silly.
 743                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 744 
 745                     Node* candidate = m_graph.varArgChild(node, 0).node();
 746                     if (!isEliminatedAllocation(candidate))
 747                         break;
 748 
 749                     unsigned numberOfArgumentsToSkip = 0;
 750                     if (candidate-&gt;op() == PhantomCreateRest)
 751                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 752 
 753                     Node* result = nullptr;
 754                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 755                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
<span class="line-modified"> 756                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 757                         index += numberOfArgumentsToSkip;
 758 
 759                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 760                         if (inlineCallFrame)
 761                             safeToGetStack &amp;= index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 762                         else {
 763                             safeToGetStack &amp;=
 764                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 765                         }
 766                         if (safeToGetStack) {
 767                             StackAccessData* data;
 768                             VirtualRegister arg = virtualRegisterForArgument(index + 1);
 769                             if (inlineCallFrame)
 770                                 arg += inlineCallFrame-&gt;stackOffset;
 771                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 772 
 773                             Node* check = nullptr;
 774                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 775                                 check = insertionSet.insertNode(
 776                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
</pre>
<hr />
<pre>
 795 
 796                     // Need to do this because we may have a data format conversion here.
 797                     node-&gt;convertToIdentityOn(result);
 798                     break;
 799                 }
 800 
 801                 case LoadVarargs: {
 802                     Node* candidate = node-&gt;child1().node();
 803                     if (!isEliminatedAllocation(candidate))
 804                         break;
 805 
 806                     // LoadVarargs can exit, so it better be exitOK.
 807                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 808                     bool canExit = true;
 809                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 810 
 811                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 812                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 813                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 814                             jsNumber(argumentCountIncludingThis));



 815                         insertionSet.insertNode(
 816                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 817                             OpInfo(varargsData-&gt;count.offset()), Edge(argumentCountIncludingThisNode));
 818                         insertionSet.insertNode(
 819                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 820                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 821                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 822                     };
 823 
 824                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 825                         VirtualRegister reg = varargsData-&gt;start + storeIndex;
 826                         StackAccessData* data =
 827                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 828 


 829                         insertionSet.insertNode(
 830                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 831                             OpInfo(reg.offset()), Edge(value));
 832                         insertionSet.insertNode(
 833                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 834                             OpInfo(data), Edge(value));
 835                     };
 836 
 837                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 838                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 839                             if (candidate-&gt;op() == PhantomSpread)
 840                                 return self(candidate-&gt;child1().node());
 841 
 842                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 843                                 BitVector* bitVector = candidate-&gt;bitVector();
 844                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 845                                     if (bitVector-&gt;get(i)) {
 846                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 847                                             return false;
 848                                     }
 849                                 }
 850                                 return true;
 851                             }
 852 
 853                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
 854                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
 855                                 return true;
 856 
 857                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 858                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 859                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
 860                         });
 861 
 862                         if (canConvertToStaticLoadStores(candidate)) {
 863                             auto countNumberOfArguments = recursableLambda([&amp;](auto self, Node* candidate) -&gt; unsigned {
 864                                 if (candidate-&gt;op() == PhantomSpread)
 865                                     return self(candidate-&gt;child1().node());
 866 
 867                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 868                                     BitVector* bitVector = candidate-&gt;bitVector();
 869                                     unsigned result = 0;
 870                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 871                                         if (bitVector-&gt;get(i))
 872                                             result += self(m_graph.varArgChild(candidate, i).node());
 873                                         else
 874                                             ++result;
 875                                     }
 876                                     return result;
 877                                 }
 878 
 879                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 880                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 881 
 882                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 883                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<span class="line-modified"> 884                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 885                                 unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 886                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 887                                     return frameArgumentCount - numberOfArgumentsToSkip;
 888                                 return 0;
 889                             });
 890 
 891                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 892                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 893                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 894 
 895                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 896                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 897                                 unsigned limit = varargsData-&gt;limit - 1;
 898 
 899                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 900                                     if (candidate-&gt;op() == PhantomSpread)
 901                                         return self(candidate-&gt;child1().node(), storeIndex);
 902 
 903                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 904                                         BitVector* bitVector = candidate-&gt;bitVector();
</pre>
<hr />
<pre>
 912                                         }
 913                                         return storeIndex;
 914                                     }
 915 
 916                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 917                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 918                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 919                                             JSValue constant;
 920                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 921                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 922                                             else
 923                                                 constant = array-&gt;get(index);
 924                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 925                                             storeValue(value, storeIndex++);
 926                                         }
 927                                         return storeIndex;
 928                                     }
 929 
 930                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
 931                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<span class="line-modified"> 932                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 933                                     unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 934                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
 935                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;
 936                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 937                                         Node* value = insertionSet.insertNode(
 938                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
 939                                             OpInfo(data));
 940                                         storeValue(value, storeIndex++);
 941                                     }
 942                                     return storeIndex;
 943                                 });
 944 
 945                                 unsigned storeIndex = forwardNode(candidate, 0);
 946                                 RELEASE_ASSERT(storeIndex &lt;= limit);
 947                                 Node* undefined = nullptr;
 948                                 for (; storeIndex &lt; limit; ++storeIndex) {
 949                                     if (!undefined) {
 950                                         undefined = insertionSet.insertConstant(
 951                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
 952                                     }
 953                                     storeValue(undefined, storeIndex);
 954                                 }
 955 
 956                                 node-&gt;remove(m_graph);
 957                                 node-&gt;origin.exitOK = canExit;
 958                                 break;
 959                             }
 960                         }
 961                     } else {
 962                         unsigned numberOfArgumentsToSkip = 0;
 963                         if (candidate-&gt;op() == PhantomCreateRest)
 964                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 965                         varargsData-&gt;offset += numberOfArgumentsToSkip;
 966 
<span class="line-modified"> 967                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
 968 
 969                         if (inlineCallFrame
 970                             &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
 971 
 972                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
 973                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
 974                                 argumentCountIncludingThis -= varargsData-&gt;offset;
 975                             else
 976                                 argumentCountIncludingThis = 1;
 977                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
 978 
 979                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 980 
 981                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 982 
 983                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 984                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 985                                 unsigned limit = varargsData-&gt;limit - 1;
 986                                 Node* undefined = nullptr;
 987                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
</pre>
<hr />
<pre>
1088                             if (candidate-&gt;op() == PhantomSpread)
1089                                 return self(candidate-&gt;child1().node());
1090 
1091                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1092                                 BitVector* bitVector = candidate-&gt;bitVector();
1093                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1094                                     if (bitVector-&gt;get(i)) {
1095                                         Node* spread = m_graph.varArgChild(candidate, i).node();
1096                                         if (!self(spread))
1097                                             return false;
1098                                     }
1099                                 }
1100                                 return true;
1101                             }
1102 
1103                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
1104                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
1105                                 return true;
1106 
1107                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified">1108                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1109                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
1110                         });
1111 
1112                         if (canTransformToStaticArgumentCountCall(candidate)) {
1113                             Vector&lt;Node*&gt; arguments;
1114                             auto appendNode = recursableLambda([&amp;](auto self, Node* candidate) -&gt; void {
1115                                 if (candidate-&gt;op() == PhantomSpread) {
1116                                     self(candidate-&gt;child1().node());
1117                                     return;
1118                                 }
1119 
1120                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1121                                     BitVector* bitVector = candidate-&gt;bitVector();
1122                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1123                                         Node* child = m_graph.varArgChild(candidate, i).node();
1124                                         if (bitVector-&gt;get(i))
1125                                             self(child);
1126                                         else
1127                                             arguments.append(child);
1128                                     }
1129                                     return;
1130                                 }
1131 
1132                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1133                                     bool canExit = true;
1134                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1135                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1136                                         JSValue constant;
1137                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1138                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1139                                         else
1140                                             constant = array-&gt;get(index);
1141                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1142                                     }
1143                                     return;
1144                                 }
1145 
1146                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified">1147                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1148                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1149                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1150                                     StackAccessData* data = m_graph.m_stackAccessData.add(
1151                                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1152                                         FlushedJSValue);
1153 
1154                                     Node* value = insertionSet.insertNode(
1155                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1156 
1157                                     arguments.append(value);
1158                                 }
1159                             });
1160 
1161                             appendNode(candidate);
1162                             convertToStaticArgumentCountCall(arguments);
1163                         } else
1164                             convertToForwardsCall();
1165                     } else {
1166                         unsigned numberOfArgumentsToSkip = 0;
1167                         if (candidate-&gt;op() == PhantomCreateRest)
1168                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1169                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1170                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1171 
<span class="line-modified">1172                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame;</span>
1173                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1174                             Vector&lt;Node*&gt; arguments;
1175                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1176                                 StackAccessData* data = m_graph.m_stackAccessData.add(
1177                                     virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1178                                     FlushedJSValue);
1179 
1180                                 Node* value = insertionSet.insertNode(
1181                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1182 
1183                                 arguments.append(value);
1184                             }
1185 
1186                             convertToStaticArgumentCountCall(arguments);
1187                         } else
1188                             convertToForwardsCall();
1189                     }
1190 
1191                     break;
1192                 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 485             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 486             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 487             for (Node* node : *block) {
 488                 clobberize(
 489                     m_graph, node, NoOpClobberize(),
 490                     [&amp;] (AbstractHeap heap) {
 491                         if (heap.kind() != Stack) {
 492                             ASSERT(!heap.overlaps(Stack));
 493                             return;
 494                         }
 495                         ASSERT(!heap.payload().isTop());
 496                         VirtualRegister reg(heap.payload().value32());
 497                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
 498                         if (!reg.isHeader())
 499                             clobberedByThisBlock.operand(reg) = true;
 500                     },
 501                     NoOpClobberize());
 502             }
 503         }
 504 
<span class="line-added"> 505         using InlineCallFrames = HashSet&lt;InlineCallFrame*, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt;;</span>
<span class="line-added"> 506         using InlineCallFramesForCanditates = HashMap&lt;Node*, InlineCallFrames&gt;;</span>
<span class="line-added"> 507         InlineCallFramesForCanditates inlineCallFramesForCandidate;</span>
<span class="line-added"> 508         auto forEachDependentNode = recursableLambda([&amp;](auto self, Node* node, const auto&amp; functor) -&gt; void {</span>
<span class="line-added"> 509             functor(node);</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511             if (node-&gt;op() == Spread) {</span>
<span class="line-added"> 512                 self(node-&gt;child1().node(), functor);</span>
<span class="line-added"> 513                 return;</span>
<span class="line-added"> 514             }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516             if (node-&gt;op() == NewArrayWithSpread) {</span>
<span class="line-added"> 517                 BitVector* bitVector = node-&gt;bitVector();</span>
<span class="line-added"> 518                 for (unsigned i = node-&gt;numChildren(); i--; ) {</span>
<span class="line-added"> 519                     if (bitVector-&gt;get(i))</span>
<span class="line-added"> 520                         self(m_graph.varArgChild(node, i).node(), functor);</span>
<span class="line-added"> 521                 }</span>
<span class="line-added"> 522                 return;</span>
<span class="line-added"> 523             }</span>
<span class="line-added"> 524         });</span>
<span class="line-added"> 525         for (Node* candidate : m_candidates) {</span>
<span class="line-added"> 526             auto&amp; set = inlineCallFramesForCandidate.add(candidate, InlineCallFrames()).iterator-&gt;value;</span>
<span class="line-added"> 527             forEachDependentNode(candidate, [&amp;](Node* dependent) {</span>
<span class="line-added"> 528                 set.add(dependent-&gt;origin.semantic.inlineCallFrame());</span>
<span class="line-added"> 529             });</span>
<span class="line-added"> 530         }</span>
<span class="line-added"> 531 </span>
 532         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 533             // Stop if we&#39;ve already removed all candidates.
 534             if (m_candidates.isEmpty())
 535                 return;
 536 
 537             // Ignore blocks that don&#39;t write to the stack.
 538             bool writesToStack = false;
 539             for (unsigned i = clobberedByBlock[block].size(); i--;) {
 540                 if (clobberedByBlock[block][i]) {
 541                     writesToStack = true;
 542                     break;
 543                 }
 544             }
 545             if (!writesToStack)
 546                 continue;
 547 
 548             forAllKillsInBlock(
 549                 m_graph, combinedLiveness, block,
 550                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 551                     if (!m_candidates.contains(candidate))
 552                         return;
 553 
<span class="line-modified"> 554                     for (InlineCallFrame* inlineCallFrame : inlineCallFramesForCandidate.get(candidate)) {</span>
<span class="line-modified"> 555                         // Check if this block has any clobbers that affect this candidate. This is a fairly</span>
<span class="line-modified"> 556                         // fast check.</span>
<span class="line-modified"> 557                         bool isClobberedByBlock = false;</span>
<span class="line-added"> 558                         Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];</span>
 559 
<span class="line-modified"> 560                         if (inlineCallFrame) {</span>
<span class="line-modified"> 561                             if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified"> 562                                 isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 563                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
<span class="line-modified"> 564                             }</span>
 565 
<span class="line-modified"> 566                             if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {</span>
<span class="line-modified"> 567                                 isClobberedByBlock |= clobberedByThisBlock.operand(</span>
<span class="line-modified"> 568                                     inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
<span class="line-modified"> 569                             }</span>
 570 
<span class="line-modified"> 571                             if (!isClobberedByBlock) {</span>
<span class="line-modified"> 572                                 for (unsigned i = 0; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
<span class="line-modified"> 573                                     VirtualRegister reg =</span>
<span class="line-modified"> 574                                         VirtualRegister(inlineCallFrame-&gt;stackOffset) +</span>
<span class="line-modified"> 575                                         CallFrame::argumentOffset(i);</span>
<span class="line-modified"> 576                                     if (clobberedByThisBlock.operand(reg)) {</span>
<span class="line-added"> 577                                         isClobberedByBlock = true;</span>
<span class="line-added"> 578                                         break;</span>
<span class="line-added"> 579                                     }</span>
<span class="line-added"> 580                                 }</span>
<span class="line-added"> 581                             }</span>
<span class="line-added"> 582                         } else {</span>
<span class="line-added"> 583                             // We don&#39;t include the ArgumentCount or Callee in this case because we can be</span>
<span class="line-added"> 584                             // damn sure that this won&#39;t be clobbered.</span>
<span class="line-added"> 585                             for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {</span>
<span class="line-added"> 586                                 if (clobberedByThisBlock.argument(i)) {</span>
 587                                     isClobberedByBlock = true;
 588                                     break;
 589                                 }
 590                             }
 591                         }










 592 
<span class="line-modified"> 593                         if (!isClobberedByBlock)</span>
<span class="line-modified"> 594                             continue;</span>
 595 
<span class="line-modified"> 596                         // Check if we can immediately eliminate this candidate. If the block has a clobber</span>
<span class="line-modified"> 597                         // for this arguments allocation, and we&#39;d have to examine every node in the block,</span>
<span class="line-modified"> 598                         // then we can just eliminate the candidate.</span>
<span class="line-modified"> 599                         if (nodeIndex == block-&gt;size() &amp;&amp; candidate-&gt;owner != block) {</span>
<span class="line-modified"> 600                             if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 601                                 dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by: &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 602                             transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 603                             return;</span>
<span class="line-modified"> 604                         }</span>
 605 
<span class="line-modified"> 606                         // This loop considers all nodes up to the nodeIndex, excluding the nodeIndex.</span>
<span class="line-modified"> 607                         //</span>
<span class="line-modified"> 608                         // Note: nodeIndex here has a double meaning. Before entering this</span>
<span class="line-modified"> 609                         // while loop, it refers to the remaining number of nodes that have</span>
<span class="line-modified"> 610                         // yet to be processed. Inside the look, it refers to the index</span>
<span class="line-added"> 611                         // of the current node to process (after we decrement it).</span>
<span class="line-added"> 612                         //</span>
<span class="line-added"> 613                         // If the remaining number of nodes is 0, we should not decrement nodeIndex.</span>
<span class="line-added"> 614                         // Hence, we must only decrement nodeIndex inside the while loop instead of</span>
<span class="line-added"> 615                         // in its condition statement. Note that this while loop is embedded in an</span>
<span class="line-added"> 616                         // outer for loop. If we decrement nodeIndex in the condition statement, a</span>
<span class="line-added"> 617                         // nodeIndex of 0 will become UINT_MAX, and the outer loop will wrongly</span>
<span class="line-added"> 618                         // treat this as there being UINT_MAX remaining nodes to process.</span>
<span class="line-added"> 619                         while (nodeIndex) {</span>
<span class="line-added"> 620                             --nodeIndex;</span>
<span class="line-added"> 621                             Node* node = block-&gt;at(nodeIndex);</span>
<span class="line-added"> 622                             if (node == candidate)</span>
<span class="line-added"> 623                                 break;</span>
 624 
<span class="line-modified"> 625                             bool found = false;</span>
<span class="line-modified"> 626                             clobberize(</span>
<span class="line-modified"> 627                                 m_graph, node, NoOpClobberize(),</span>
<span class="line-modified"> 628                                 [&amp;] (AbstractHeap heap) {</span>
<span class="line-modified"> 629                                     if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {</span>
<span class="line-modified"> 630                                         if (argumentsInvolveStackSlot(inlineCallFrame, VirtualRegister(heap.payload().value32())))</span>
<span class="line-added"> 631                                             found = true;</span>
<span class="line-added"> 632                                         return;</span>
<span class="line-added"> 633                                     }</span>
<span class="line-added"> 634                                     if (heap.overlaps(Stack))</span>
 635                                         found = true;
<span class="line-modified"> 636                                 },</span>
<span class="line-modified"> 637                                 NoOpClobberize());</span>




 638 
<span class="line-modified"> 639                             if (found) {</span>
<span class="line-modified"> 640                                 if (DFGArgumentsEliminationPhaseInternal::verbose)</span>
<span class="line-modified"> 641                                     dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);</span>
<span class="line-modified"> 642                                 transitivelyRemoveCandidate(candidate);</span>
<span class="line-modified"> 643                                 return;</span>
<span class="line-added"> 644                             }</span>
 645                         }
 646                     }
 647                 });
 648         }
 649 
 650         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
 651         // frame is dead?  A: Naively we could say that PhantomArguments must escape the stack slots. But
 652         // that would break PutStack sinking, which in turn would break object allocation sinking, in
 653         // cases where we have a varargs call to an otherwise pure method. So, we need something smarter.
 654         // For the outermost arguments, we just have a PhantomArguments that magically knows that it
 655         // should load the arguments from the call frame. For the inline arguments, we have the heap map
 656         // in the availabiltiy map track each possible inline argument as a promoted heap location. If the
 657         // PutStacks for those arguments aren&#39;t sunk, those heap locations will map to very trivial
 658         // availabilities (they will be flush availabilities). But if sinking happens then those
 659         // availabilities may become whatever. OSR exit should be able to handle this quite naturally,
 660         // since those availabilities speak of the stack before the optimizing compiler stack frame is
 661         // torn down.
 662 
 663         if (DFGArgumentsEliminationPhaseInternal::verbose)
 664             dataLog(&quot;After interference analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
</pre>
<hr />
<pre>
 686                     // We traverse in such a way that we are guaranteed to see a def before a use.
 687                     // Therefore, we should have already transformed the allocation before the use
 688                     // of an allocation.
 689                     ASSERT(candidate-&gt;op() == PhantomCreateRest || candidate-&gt;op() == PhantomDirectArguments || candidate-&gt;op() == PhantomClonedArguments
 690                         || candidate-&gt;op() == PhantomSpread || candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer);
 691                     return true;
 692                 };
 693 
 694                 switch (node-&gt;op()) {
 695                 case CreateDirectArguments:
 696                     if (!m_candidates.contains(node))
 697                         break;
 698 
 699                     node-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
 700                     break;
 701 
 702                 case CreateRest:
 703                     if (!m_candidates.contains(node))
 704                         break;
 705 
<span class="line-added"> 706                     ASSERT(node-&gt;origin.exitOK);</span>
<span class="line-added"> 707                     ASSERT(node-&gt;child1().useKind() == Int32Use);</span>
<span class="line-added"> 708                     insertionSet.insertNode(</span>
<span class="line-added"> 709                         nodeIndex, SpecNone, Check, node-&gt;origin,</span>
<span class="line-added"> 710                         node-&gt;child1());</span>
<span class="line-added"> 711 </span>
 712                     node-&gt;setOpAndDefaultFlags(PhantomCreateRest);
 713                     // We don&#39;t need this parameter for OSR exit, we can find out all the information
 714                     // we need via the static parameter count and the dynamic argument count.
 715                     node-&gt;child1() = Edge();
 716                     break;
 717 
 718                 case CreateClonedArguments:
 719                     if (!m_candidates.contains(node))
 720                         break;
 721 
 722                     node-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
 723                     break;
 724 
 725                 case Spread:
 726                     if (!m_candidates.contains(node))
 727                         break;
 728 
 729                     node-&gt;setOpAndDefaultFlags(PhantomSpread);
 730                     break;
 731 
</pre>
<hr />
<pre>
 784 
 785                 case GetByVal: {
 786                     // FIXME: For ClonedArguments, we would have already done a separate bounds check.
 787                     // This code will cause us to have two bounds checks - the original one that we
 788                     // already factored out in SSALoweringPhase, and the new one we insert here, which is
 789                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 790                     // second bounds check, but still - that&#39;s just silly.
 791                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 792 
 793                     Node* candidate = m_graph.varArgChild(node, 0).node();
 794                     if (!isEliminatedAllocation(candidate))
 795                         break;
 796 
 797                     unsigned numberOfArgumentsToSkip = 0;
 798                     if (candidate-&gt;op() == PhantomCreateRest)
 799                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 800 
 801                     Node* result = nullptr;
 802                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 803                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
<span class="line-modified"> 804                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
 805                         index += numberOfArgumentsToSkip;
 806 
 807                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 808                         if (inlineCallFrame)
 809                             safeToGetStack &amp;= index &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 810                         else {
 811                             safeToGetStack &amp;=
 812                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 813                         }
 814                         if (safeToGetStack) {
 815                             StackAccessData* data;
 816                             VirtualRegister arg = virtualRegisterForArgument(index + 1);
 817                             if (inlineCallFrame)
 818                                 arg += inlineCallFrame-&gt;stackOffset;
 819                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 820 
 821                             Node* check = nullptr;
 822                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 823                                 check = insertionSet.insertNode(
 824                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
</pre>
<hr />
<pre>
 843 
 844                     // Need to do this because we may have a data format conversion here.
 845                     node-&gt;convertToIdentityOn(result);
 846                     break;
 847                 }
 848 
 849                 case LoadVarargs: {
 850                     Node* candidate = node-&gt;child1().node();
 851                     if (!isEliminatedAllocation(candidate))
 852                         break;
 853 
 854                     // LoadVarargs can exit, so it better be exitOK.
 855                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 856                     bool canExit = true;
 857                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 858 
 859                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 860                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 861                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 862                             jsNumber(argumentCountIncludingThis));
<span class="line-added"> 863                         insertionSet.insertNode(</span>
<span class="line-added"> 864                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit),</span>
<span class="line-added"> 865                             OpInfo(varargsData-&gt;count.offset()));</span>
 866                         insertionSet.insertNode(
 867                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 868                             OpInfo(varargsData-&gt;count.offset()), Edge(argumentCountIncludingThisNode));
 869                         insertionSet.insertNode(
 870                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 871                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 872                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 873                     };
 874 
 875                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 876                         VirtualRegister reg = varargsData-&gt;start + storeIndex;
 877                         StackAccessData* data =
 878                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 879 
<span class="line-added"> 880                         insertionSet.insertNode(</span>
<span class="line-added"> 881                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg.offset()));</span>
 882                         insertionSet.insertNode(
 883                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
 884                             OpInfo(reg.offset()), Edge(value));
 885                         insertionSet.insertNode(
 886                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 887                             OpInfo(data), Edge(value));
 888                     };
 889 
 890                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 891                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 892                             if (candidate-&gt;op() == PhantomSpread)
 893                                 return self(candidate-&gt;child1().node());
 894 
 895                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 896                                 BitVector* bitVector = candidate-&gt;bitVector();
 897                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 898                                     if (bitVector-&gt;get(i)) {
 899                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 900                                             return false;
 901                                     }
 902                                 }
 903                                 return true;
 904                             }
 905 
 906                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
 907                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
 908                                 return true;
 909 
 910                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified"> 911                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
 912                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
 913                         });
 914 
 915                         if (canConvertToStaticLoadStores(candidate)) {
 916                             auto countNumberOfArguments = recursableLambda([&amp;](auto self, Node* candidate) -&gt; unsigned {
 917                                 if (candidate-&gt;op() == PhantomSpread)
 918                                     return self(candidate-&gt;child1().node());
 919 
 920                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 921                                     BitVector* bitVector = candidate-&gt;bitVector();
 922                                     unsigned result = 0;
 923                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 924                                         if (bitVector-&gt;get(i))
 925                                             result += self(m_graph.varArgChild(candidate, i).node());
 926                                         else
 927                                             ++result;
 928                                     }
 929                                     return result;
 930                                 }
 931 
 932                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 933                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 934 
 935                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 936                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<span class="line-modified"> 937                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
 938                                 unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 939                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 940                                     return frameArgumentCount - numberOfArgumentsToSkip;
 941                                 return 0;
 942                             });
 943 
 944                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 945                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 946                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 947 
 948                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 949                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 950                                 unsigned limit = varargsData-&gt;limit - 1;
 951 
 952                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 953                                     if (candidate-&gt;op() == PhantomSpread)
 954                                         return self(candidate-&gt;child1().node(), storeIndex);
 955 
 956                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 957                                         BitVector* bitVector = candidate-&gt;bitVector();
</pre>
<hr />
<pre>
 965                                         }
 966                                         return storeIndex;
 967                                     }
 968 
 969                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 970                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 971                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 972                                             JSValue constant;
 973                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 974                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 975                                             else
 976                                                 constant = array-&gt;get(index);
 977                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 978                                             storeValue(value, storeIndex++);
 979                                         }
 980                                         return storeIndex;
 981                                     }
 982 
 983                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
 984                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
<span class="line-modified"> 985                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
 986                                     unsigned frameArgumentCount = inlineCallFrame-&gt;argumentCountIncludingThis - 1;
 987                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
 988                                         VirtualRegister reg = virtualRegisterForArgument(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;
 989                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 990                                         Node* value = insertionSet.insertNode(
 991                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
 992                                             OpInfo(data));
 993                                         storeValue(value, storeIndex++);
 994                                     }
 995                                     return storeIndex;
 996                                 });
 997 
 998                                 unsigned storeIndex = forwardNode(candidate, 0);
 999                                 RELEASE_ASSERT(storeIndex &lt;= limit);
1000                                 Node* undefined = nullptr;
1001                                 for (; storeIndex &lt; limit; ++storeIndex) {
1002                                     if (!undefined) {
1003                                         undefined = insertionSet.insertConstant(
1004                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1005                                     }
1006                                     storeValue(undefined, storeIndex);
1007                                 }
1008 
1009                                 node-&gt;remove(m_graph);
1010                                 node-&gt;origin.exitOK = canExit;
1011                                 break;
1012                             }
1013                         }
1014                     } else {
1015                         unsigned numberOfArgumentsToSkip = 0;
1016                         if (candidate-&gt;op() == PhantomCreateRest)
1017                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1018                         varargsData-&gt;offset += numberOfArgumentsToSkip;
1019 
<span class="line-modified">1020                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
1021 
1022                         if (inlineCallFrame
1023                             &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1024 
1025                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
1026                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
1027                                 argumentCountIncludingThis -= varargsData-&gt;offset;
1028                             else
1029                                 argumentCountIncludingThis = 1;
1030                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
1031 
1032                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
1033 
1034                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
1035 
1036                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
1037                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
1038                                 unsigned limit = varargsData-&gt;limit - 1;
1039                                 Node* undefined = nullptr;
1040                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
</pre>
<hr />
<pre>
1141                             if (candidate-&gt;op() == PhantomSpread)
1142                                 return self(candidate-&gt;child1().node());
1143 
1144                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1145                                 BitVector* bitVector = candidate-&gt;bitVector();
1146                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1147                                     if (bitVector-&gt;get(i)) {
1148                                         Node* spread = m_graph.varArgChild(candidate, i).node();
1149                                         if (!self(spread))
1150                                             return false;
1151                                     }
1152                                 }
1153                                 return true;
1154                             }
1155 
1156                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
1157                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
1158                                 return true;
1159 
1160                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified">1161                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
1162                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
1163                         });
1164 
1165                         if (canTransformToStaticArgumentCountCall(candidate)) {
1166                             Vector&lt;Node*&gt; arguments;
1167                             auto appendNode = recursableLambda([&amp;](auto self, Node* candidate) -&gt; void {
1168                                 if (candidate-&gt;op() == PhantomSpread) {
1169                                     self(candidate-&gt;child1().node());
1170                                     return;
1171                                 }
1172 
1173                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1174                                     BitVector* bitVector = candidate-&gt;bitVector();
1175                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1176                                         Node* child = m_graph.varArgChild(candidate, i).node();
1177                                         if (bitVector-&gt;get(i))
1178                                             self(child);
1179                                         else
1180                                             arguments.append(child);
1181                                     }
1182                                     return;
1183                                 }
1184 
1185                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1186                                     bool canExit = true;
1187                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1188                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1189                                         JSValue constant;
1190                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1191                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1192                                         else
1193                                             constant = array-&gt;get(index);
1194                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1195                                     }
1196                                     return;
1197                                 }
1198 
1199                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
<span class="line-modified">1200                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
1201                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1202                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1203                                     StackAccessData* data = m_graph.m_stackAccessData.add(
1204                                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1205                                         FlushedJSValue);
1206 
1207                                     Node* value = insertionSet.insertNode(
1208                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1209 
1210                                     arguments.append(value);
1211                                 }
1212                             });
1213 
1214                             appendNode(candidate);
1215                             convertToStaticArgumentCountCall(arguments);
1216                         } else
1217                             convertToForwardsCall();
1218                     } else {
1219                         unsigned numberOfArgumentsToSkip = 0;
1220                         if (candidate-&gt;op() == PhantomCreateRest)
1221                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1222                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1223                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1224 
<span class="line-modified">1225                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();</span>
1226                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1227                             Vector&lt;Node*&gt; arguments;
1228                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1229                                 StackAccessData* data = m_graph.m_stackAccessData.add(
1230                                     virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset,
1231                                     FlushedJSValue);
1232 
1233                                 Node* value = insertionSet.insertNode(
1234                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1235 
1236                                 arguments.append(value);
1237                             }
1238 
1239                             convertToStaticArgumentCountCall(arguments);
1240                         } else
1241                             convertToForwardsCall();
1242                     }
1243 
1244                     break;
1245                 }
</pre>
</td>
</tr>
</table>
<center><a href="DFGAdjacencyList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArgumentsUtilities.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>