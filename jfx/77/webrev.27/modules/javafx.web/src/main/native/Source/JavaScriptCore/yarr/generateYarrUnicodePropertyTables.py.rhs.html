<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/generateYarrUnicodePropertyTables.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env python
  2 
  3 # Copyright (C) 2017 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 #
  9 # 1.  Redistributions of source code must retain the above copyright
 10 #     notice, this list of conditions and the following disclaimer.
 11 # 2.  Redistributions in binary form must reproduce the above copyright
 12 #     notice, this list of conditions and the following disclaimer in the
 13 #     documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool processes the Unicode Character Database file CaseFolding.txt to create
 27 # canonicalization table as decribed in ECMAScript 6 standard in section
 28 # &quot;21.2.2.8.2 Runtime Semantics: Canonicalize()&quot;, step 2.
 29 
 30 import sys
 31 import copy
 32 import optparse
 33 import os
 34 import re
 35 from hasher import stringHash
 36 
 37 header = &quot;&quot;&quot;/*
<a name="1" id="anc1"></a><span class="line-modified"> 38 * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
 39 *
 40 * Redistribution and use in source and binary forms, with or without
 41 * modification, are permitted provided that the following conditions
 42 * are met:
 43 *
 44 * 1.  Redistributions of source code must retain the above copyright
 45 *     notice, this list of conditions and the following disclaimer.
 46 * 2.  Redistributions in binary form must reproduce the above copyright
 47 *     notice, this list of conditions and the following disclaimer in the
 48 *     documentation and/or other materials provided with the distribution.
 49 *
 50 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 51 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 52 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 53 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 54 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 55 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 56 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 57 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 58 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 59 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 60 */
 61 
 62 // DO NO EDIT! - This file was generated by &quot;&quot;&quot; + __file__ + &quot;&quot;&quot;
 63 &quot;&quot;&quot;
 64 
 65 
 66 footer = &quot;&quot;&quot;
 67 &quot;&quot;&quot;
 68 
 69 RequiredUCDFiles = [&quot;DerivedBinaryProperties.txt&quot;, &quot;DerivedCoreProperties.txt&quot;, &quot;DerivedNormalizationProps.txt&quot;, &quot;PropList.txt&quot;, &quot;PropertyAliases.txt&quot;, &quot;PropertyValueAliases.txt&quot;, &quot;ScriptExtensions.txt&quot;, &quot;UnicodeData.txt&quot;, &quot;emoji-data.txt&quot;]
 70 UCDDirectoryPath = None
 71 
 72 SupportedBinaryProperties = [
 73     &quot;Alphabetic&quot;, &quot;Any&quot;, &quot;ASCII&quot;, &quot;ASCII_Hex_Digit&quot;, &quot;Assigned&quot;, &quot;Bidi_Control&quot;, &quot;Bidi_Mirrored&quot;, &quot;Case_Ignorable&quot;,
 74     &quot;Cased&quot;, &quot;Changes_When_Casefolded&quot;, &quot;Changes_When_Casemapped&quot;, &quot;Changes_When_Lowercased&quot;, &quot;Changes_When_NFKC_Casefolded&quot;,
 75     &quot;Changes_When_Titlecased&quot;, &quot;Changes_When_Uppercased&quot;, &quot;Dash&quot;, &quot;Default_Ignorable_Code_Point&quot;, &quot;Deprecated&quot;,
 76     &quot;Diacritic&quot;, &quot;Emoji&quot;, &quot;Emoji_Component&quot;, &quot;Emoji_Modifier_Base&quot;, &quot;Emoji_Modifier&quot;, &quot;Emoji_Presentation&quot;,
 77     &quot;Extended_Pictographic&quot;, &quot;Extender&quot;, &quot;Grapheme_Base&quot;, &quot;Grapheme_Extend&quot;, &quot;Hex_Digit&quot;, &quot;ID_Continue&quot;, &quot;ID_Start&quot;,
 78     &quot;Ideographic&quot;, &quot;IDS_Binary_Operator&quot;, &quot;IDS_Trinary_Operator&quot;, &quot;Join_Control&quot;, &quot;Logical_Order_Exception&quot;, &quot;Lowercase&quot;,
 79     &quot;Math&quot;, &quot;Noncharacter_Code_Point&quot;, &quot;Pattern_Syntax&quot;, &quot;Pattern_White_Space&quot;, &quot;Quotation_Mark&quot;, &quot;Radical&quot;,
 80     &quot;Regional_Indicator&quot;, &quot;Sentence_Terminal&quot;, &quot;Soft_Dotted&quot;, &quot;Terminal_Punctuation&quot;, &quot;Unified_Ideograph&quot;, &quot;Uppercase&quot;,
 81     &quot;Variation_Selector&quot;, &quot;White_Space&quot;, &quot;XID_Continue&quot;, &quot;XID_Start&quot;]
 82 
 83 lastASCIICodePoint = 0x7f
 84 firstUnicodeCodePoint = 0x80
 85 MaxUnicode = 0x10ffff
 86 MaxBMP = 0xffff
 87 commonAndSimpleLinesRE = re.compile(r&quot;(?P&lt;code&gt;[0-9A-F]+)\s*;\s*[CS]\s*;\s*(?P&lt;mapping&gt;[0-9A-F]+)&quot;, re.IGNORECASE)
 88 aliases = None
 89 
 90 
 91 def openOrExit(path, mode):
 92     try:
 93         if sys.version_info.major &gt;= 3:
 94             return open(path, mode, encoding=&quot;UTF-8&quot;)
 95         else:
 96             return open(path, mode)
 97     except IOError as e:
 98         print(&quot;I/O error opening {0}, ({1}): {2}&quot;.format(path, e.errno, e.strerror))
 99         exit(1)
100 
101 
102 def openUCDFileOrExit(path):
103     if not UCDDirectoryPath:
104         exit(1)
105 
106     return openOrExit(os.path.join(UCDDirectoryPath, path), &#39;r&#39;)
107 
108 
109 def verifyUCDFilesExist():
110     if not UCDDirectoryPath:
111         exit(1)
112 
113     missingFileCount = 0
114     for file in RequiredUCDFiles:
115         fullPath = os.path.join(UCDDirectoryPath, file)
116         if not os.path.exists(fullPath):
117             print(&quot;Couldn&#39;t find UCD file {0} at {1}&quot;.format(file, fullPath))
118             missingFileCount = missingFileCount + 1
119     if missingFileCount:
120         exit(1)
121 
122 
123 def ceilingToPowerOf2(size):
124     powerOf2 = 1
125     while size &gt; powerOf2:
126         powerOf2 = powerOf2 &lt;&lt; 1
127 
128     return powerOf2
129 
130 
131 class Aliases:
132     def __init__(self):
133         self.globalNameToAliases = {}
134         self.generalCategoryToAliases = {}
135         self.aliasToGeneralCategory = {}
136         self.scriptToAliases = {}
137         self.aliasToScript = {}
138 
139     def parsePropertyAliasesFile(self, file):
140         for line in file:
141             line = line.split(&#39;#&#39;, 1)[0]
142             line = line.rstrip()
143             if (not len(line)):
144                 continue
145 
146             fields = line.split(&#39;;&#39;)
147             if (not fields):
148                 continue
149 
150             aliases = [fields[0].strip()]
151             fullName = fields[1].strip()
152             for otherAlias in fields[2:]:
153                 aliases.append(otherAlias.strip())
154 
155             if fullName in self.globalNameToAliases:
156                 print(&quot;Error, already an alias for {}&quot;.format(fullName))
157             else:
158                 self.globalNameToAliases[fullName] = aliases
159 
160     def parsePropertyValueAliasesFile(self, file):
161         for line in file:
162             line = line.split(&#39;#&#39;, 1)[0]
163             line = line.rstrip()
164             if (not len(line)):
165                 continue
166 
167             fields = line.split(&#39;;&#39;)
168             if (not fields):
169                 continue
170 
171             propertyType = fields[0].strip()
172 
173             if propertyType == &quot;gc&quot;:
174                 mapToModify = self.generalCategoryToAliases
175                 reverseMapToModify = self.aliasToGeneralCategory
176             elif propertyType == &quot;sc&quot;:
177                 mapToModify = self.scriptToAliases
178                 reverseMapToModify = self.aliasToScript
179             else:
180                 continue
181 
182             primaryAlias = fields[1].strip()
183             fullName = fields[2].strip()
184             aliases = [primaryAlias]
185             for otherAlias in fields[3:]:
186                 aliases.append(otherAlias.strip())
187 
188             if fullName in mapToModify:
189                 print(&quot;Error, already an {} alias for {}&quot;.format(propertyType, fullName))
190             else:
191                 mapToModify[fullName] = aliases
192                 if reverseMapToModify != None:
193                     reverseMapToModify[primaryAlias] = fullName
194 
195     def globalAliasesFor(self, name):
196         if name not in self.globalNameToAliases:
197             return []
198         return self.globalNameToAliases[name]
199 
200     def generalCategoryAliasesFor(self, name):
201         if name not in self.generalCategoryToAliases:
202             return &quot;&quot;
203         return self.generalCategoryToAliases[name]
204 
205     def generalCategoryForAlias(self, name):
206         if name not in self.aliasToGeneralCategory:
207             return &quot;&quot;
208         return self.aliasToGeneralCategory[name]
209 
210     def scriptAliasesFor(self, name):
211         if name not in self.scriptToAliases:
212             return &quot;&quot;
213         return self.scriptToAliases[name]
214 
215     def scriptNameForAlias(self, name):
216         if name not in self.aliasToScript:
217             return &quot;&quot;
218         return self.aliasToScript[name]
219 
220 
221 class PropertyData:
222     allPropertyData = []
223 
224     def __init__(self, name):
225         self.name = name
226         self.aliases = []
227         self.index = len(PropertyData.allPropertyData)
<a name="2" id="anc2"></a><span class="line-added">228         self.hasBMPCharacters = False</span>
229         self.hasNonBMPCharacters = False
230         self.matches = []
231         self.ranges = []
232         self.unicodeMatches = []
233         self.unicodeRanges = []
234         self.codePointCount = 0
235         PropertyData.allPropertyData.append(self)
236 
237     def setAliases(self, aliases):
238         self.aliases = aliases
239 
240     def makeCopy(self):
241         result = copy.deepcopy(self)
242         result.index = len(PropertyData.allPropertyData)
243         PropertyData.allPropertyData.append(result)
244         return result
245 
246     def getIndex(self):
247         return self.index
248 
249     def getCreateFuncName(self):
250         return &quot;createCharacterClass{}&quot;.format(self.index)
251 
252     def addMatch(self, codePoint):
<a name="3" id="anc3"></a><span class="line-modified">253         if codePoint &lt;= MaxBMP:</span>
<span class="line-added">254             self.hasBMPCharacters = True</span>
<span class="line-added">255         else:</span>
256             self.hasNonBMPCharacters = True
257         if codePoint &lt;= lastASCIICodePoint:
258             if (len(self.matches) and self.matches[-1] &gt; codePoint) or (len(self.ranges) and self.ranges[-1][1] &gt; codePoint):
259                 self.addMatchUnordered(codePoint)
260                 return
261 
262             self.codePointCount = self.codePointCount + 1
263             if len(self.matches) and self.matches[-1] == (codePoint - 1):
264                 lowCodePoint = self.matches.pop()
265                 self.ranges.append((lowCodePoint, codePoint))
266             elif len(self.ranges) and self.ranges[-1][1] == (codePoint - 1):
267                 priorRange = self.ranges.pop()
268                 self.ranges.append((priorRange[0], codePoint))
269             else:
270                 self.matches.append(codePoint)
271         else:
272             if (len(self.unicodeMatches) and self.unicodeMatches[-1] &gt; codePoint) or (len(self.unicodeRanges) and self.unicodeRanges[-1][1] &gt; codePoint):
273                 self.addMatchUnordered(codePoint)
274                 return
275 
276             self.codePointCount = self.codePointCount + 1
277             if len(self.unicodeMatches) and self.unicodeMatches[-1] == (codePoint - 1):
278                 lowCodePoint = self.unicodeMatches.pop()
279                 self.unicodeRanges.append((lowCodePoint, codePoint))
280             elif len(self.unicodeRanges) and self.unicodeRanges[-1][1] == (codePoint - 1):
281                 priorRange = self.unicodeRanges.pop()
282                 self.unicodeRanges.append((priorRange[0], codePoint))
283             else:
284                 self.unicodeMatches.append(codePoint)
285 
286     def addRange(self, lowCodePoint, highCodePoint):
<a name="4" id="anc4"></a><span class="line-added">287         if lowCodePoint &lt;= MaxBMP:</span>
<span class="line-added">288             self.hasBMPCharacters = True</span>
289         if highCodePoint &gt; MaxBMP:
290             self.hasNonBMPCharacters = True
291         if highCodePoint &lt;= lastASCIICodePoint:
292             if (len(self.matches) and self.matches[-1] &gt; lowCodePoint) or (len(self.ranges) and self.ranges[-1][1] &gt; lowCodePoint):
293                 self.addRangeUnordered(lowCodePoint, highCodePoint)
294                 return
295 
296             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
297             if len(self.matches) and self.matches[-1] == (lowCodePoint - 1):
298                 lowCodePoint = self.matches.pop()
299             elif len(self.ranges) and self.ranges[-1][1] == (lowCodePoint - 1):
300                 priorRange = self.ranges.pop()
301                 lowCodePoint = priorRange[0]
302             self.ranges.append((lowCodePoint, highCodePoint))
303         elif lowCodePoint &lt;= lastASCIICodePoint:
304             if lowCodePoint == lastASCIICodePoint:
305                 self.addMatch(lowCodePoint)
306             else:
307                 self.addRange(lowCodePoint, lastASCIICodePoint)
308             if highCodePoint == firstUnicodeCodePoint:
309                 self.addMatch(highCodePoint)
310             else:
311                 self.addRange(firstUnicodeCodePoint, highCodePoint)
312         else:
313             if (len(self.unicodeMatches) and self.unicodeMatches[-1] &gt; lowCodePoint) or (len(self.unicodeRanges) and self.unicodeRanges[-1][1] &gt; lowCodePoint):
314                 self.addRangeUnordered(lowCodePoint, highCodePoint)
315                 return
316 
317             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
318             if len(self.unicodeMatches) and self.unicodeMatches[-1] == (lowCodePoint - 1):
319                 lowCodePoint = self.unicodeMatches.pop()
320                 self.unicodeRanges.append((lowCodePoint, highCodePoint))
321             elif len(self.unicodeRanges) and self.unicodeRanges[-1][1] == (lowCodePoint - 1):
322                 priorRange = self.unicodeRanges.pop()
323                 self.unicodeRanges.append((priorRange[0], highCodePoint))
324             else:
325                 self.unicodeRanges.append((lowCodePoint, highCodePoint))
326 
327     def addMatchUnorderedForMatchesAndRanges(self, codePoint, matches, ranges):
328         if codePoint in matches:
329             return
330         insertLocation = None
331         lowCodePoint = None
332         highCodePoint = None
333         for idx in range(len(matches)):
334             match = matches[idx]
335             if codePoint == match + 1:
336                 lowCodePoint = match
337                 if idx &lt; (len(matches) - 1) and codePoint == matches[idx + 1] - 1:
338                     highCodePoint = matches[idx + 1]
339                     del matches[idx + 1]
340                     self.codePointCount = self.codePointCount - 1
341                 else:
342                     highCodePoint = codePoint
343                 del matches[idx]
344                 self.codePointCount = self.codePointCount - 1
345                 break
346             elif codePoint == match - 1:
347                 lowCodePoint = codePoint
348                 highCodePoint = match
349                 del matches[idx]
350                 self.codePointCount = self.codePointCount - 1
351                 break
352             elif codePoint &lt; match:
353                 insertLocation = idx
354                 break
355 
356         if insertLocation is None:
357             insertLocation = len(matches)
358         if lowCodePoint is None:
359             lowCodePoint = codePoint
360             highCodePoint = codePoint
361 
362         for idx in range(len(ranges)):
363             cur_range = ranges[idx]
364             if lowCodePoint &gt;= cur_range[0] and highCodePoint &lt;= cur_range[1]:
365                 return
366             if lowCodePoint &lt;= (cur_range[1] + 1) and highCodePoint &gt;= (cur_range[0] - 1):
367                 while idx &lt; len(ranges) and highCodePoint &gt;= (ranges[idx][0] - 1):
368                     cur_range = ranges[idx]
369                     lowCodePoint = min(lowCodePoint, cur_range[0])
370                     highCodePoint = max(highCodePoint, cur_range[1])
371                     del ranges[idx]
372                     self.codePointCount = self.codePointCount - (cur_range[1] - cur_range[0]) - 1
373 
374                 ranges.insert(idx, (lowCodePoint, highCodePoint))
375                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
376                 return
377             elif highCodePoint &lt; cur_range[0]:
378                 if lowCodePoint != highCodePoint:
379                     ranges.insert(idx, (lowCodePoint, highCodePoint))
380                     self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
381                     return
382                 break
383 
384         if lowCodePoint != highCodePoint:
385             ranges.append((lowCodePoint, highCodePoint))
386             self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
387             return
388 
389         if insertLocation is not None:
390             matches.insert(insertLocation, codePoint)
391             self.codePointCount = self.codePointCount + 1
392 
393     def addRangeUnorderedForMatchesAndRanges(self, lowCodePoint, highCodePoint, matches, ranges):
394         if len(matches) and highCodePoint &gt;= matches[0] and lowCodePoint &lt;= matches[-1]:
395             for idx in range(len(matches)):
396                 match = matches[idx]
397                 if lowCodePoint &lt;= match and highCodePoint &gt;= match:
398                     while idx &lt; len(matches) and highCodePoint &gt;= matches[idx]:
399                         del matches[idx]
400                         self.codePointCount = self.codePointCount - 1
401                     if idx &lt; (len(matches) - 1) and highCodePoint == matches[idx + 1] - 1:
402                         highCodePoint = matches[idx + 1]
403                         del matches[idx + 1]
404                         self.codePointCount = self.codePointCount - 1
405                     break
406                 elif lowCodePoint == match + 1:
407                     lowCodePoint = match
408                     while idx &lt; len(matches) and highCodePoint &gt;= matches[idx]:
409                         del matches[idx]
410                         self.codePointCount = self.codePointCount - 1
411 
412                     if idx &lt; (len(matches) - 1) and highCodePoint == matches[idx + 1] - 1:
413                         highCodePoint = matches[idx + 1]
414                         del matches[idx + 1]
415                         self.codePointCount = self.codePointCount - 1
416                     break
417                 elif highCodePoint == match - 1:
418                     highCodePoint = match
419                     del matches[idx]
420                     self.codePointCount = self.codePointCount - 1
421                     break
422                 elif highCodePoint &lt; match:
423                     break
424 
425         for idx in range(len(ranges)):
426             cur_range = ranges[idx]
427             if lowCodePoint &gt;= cur_range[0] and highCodePoint &lt;= cur_range[1]:
428                 return
429             if lowCodePoint &lt;= (cur_range[1] + 1) and highCodePoint &gt;= (cur_range[0] - 1):
430                 while idx &lt; len(ranges) and highCodePoint &gt;= (ranges[idx][0] - 1):
431                     cur_range = ranges[idx]
432                     lowCodePoint = min(lowCodePoint, cur_range[0])
433                     highCodePoint = max(highCodePoint, cur_range[1])
434                     del ranges[idx]
435                     self.codePointCount = self.codePointCount - (cur_range[1] - cur_range[0]) - 1
436 
437                 ranges.insert(idx, (lowCodePoint, highCodePoint))
438                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
439                 return
440             elif highCodePoint &lt; cur_range[0]:
441                 ranges.insert(idx, (lowCodePoint, highCodePoint))
442                 self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
443                 return
444 
445         ranges.append((lowCodePoint, highCodePoint))
446         self.codePointCount = self.codePointCount + (highCodePoint - lowCodePoint) + 1
447 
448     def addMatchUnordered(self, codePoint):
449         if codePoint &lt;= lastASCIICodePoint:
450             self.addMatchUnorderedForMatchesAndRanges(codePoint, self.matches, self.ranges)
451         else:
452             self.addMatchUnorderedForMatchesAndRanges(codePoint, self.unicodeMatches, self.unicodeRanges)
453 
454     def addRangeUnordered(self, lowCodePoint, highCodePoint):
455         if highCodePoint &lt;= lastASCIICodePoint:
456             self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, highCodePoint, self.matches, self.ranges)
457         elif lowCodePoint &gt;= firstUnicodeCodePoint:
458             self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, highCodePoint, self.unicodeMatches, self.unicodeRanges)
459         else:
460             if lowCodePoint == lastASCIICodePoint:
461                 self.addMatchUnorderedForMatchesAndRanges(lowCodePoint, self.matches, self.ranges)
462             else:
463                 self.addRangeUnorderedForMatchesAndRanges(lowCodePoint, lastASCIICodePoint, self.unicodeMatches, self.ranges)
464             if highCodePoint == firstUnicodeCodePoint:
465                 self.addMatchUnorderedForMatchesAndRanges(highCodePoint, self.unicodeMatches, self.unicodeRanges)
466             else:
467                 self.addRangeUnorderedForMatchesAndRanges(firstUnicodeCodePoint, highCodePoint, self.unicodeMatches, self.unicodeRanges)
468 
469     def removeMatchFromRanges(self, codePoint, ranges):
470         for idx in range(len(ranges)):
471             cur_range = ranges[idx]
472             if cur_range[0] &lt;= codePoint and codePoint &lt;= cur_range[1]:
473                 ranges.pop(idx)
474                 if cur_range[0] &lt; codePoint and codePoint &lt; cur_range[1]:
475                     lowRange = (cur_range[0], codePoint - 1)
476                     highRange = (codePoint + 1, cur_range[1])
477                     # Since list.insert inserts before the index given, handle the high range first
478                     if highRange[0] == highRange[1]:
479                         self.addMatchUnordered(highRange[0])
480                     else:
481                         ranges.insert(idx, highRange)
482                     if lowRange[0] == lowRange[1]:
483                         self.addMatchUnordered(lowRange[0])
484                     else:
485                         ranges.insert(idx, lowRange)
486                 else:
487                     if cur_range[0] == codePoint:
488                         cur_range = (codePoint + 1, cur_range[1])
489                     else:
490                         cur_range = (cur_range[0], codePoint - 1)
491                     if cur_range[0] == cur_range[1]:
492                         self.addMatchUnordered(cur_range[0])
493                     else:
494                         ranges.insert(idx, cur_range)
495                 self.codePointCount = self.codePointCount - 1
496                 return
497 
498     def removeMatch(self, codePoint):
499         if codePoint &lt;= lastASCIICodePoint:
500             if codePoint in self.matches:
501                 self.matches.remove(codePoint)
502                 self.codePointCount = self.codePointCount - 1
503             else:
504                 self.removeMatchFromRanges(codePoint, self.ranges)
505         else:
506             if codePoint in self.unicodeMatches:
507                 self.unicodeMatches.remove(codePoint)
508                 self.codePointCount = self.codePointCount - 1
509             else:
510                 self.removeMatchFromRanges(codePoint, self.unicodeRanges)
511 
512     def dumpMatchData(self, file, valuesPerLine, dataList, formatter):
513         valuesThisLine = 0
514         firstValue = True
515 
516         file.write(&quot;{&quot;)
517         for elem in dataList:
518             if firstValue:
519                 firstValue = False
520             else:
521                 file.write(&quot;, &quot;)
522             valuesThisLine = valuesThisLine + 1
523             if valuesThisLine &gt; valuesPerLine:
524                 file.write(&quot;\n                 &quot;)
525                 valuesThisLine = 1
526             formatter(file, elem)
527         file.write(&quot;}&quot;)
528 
529     def dump(self, file, commaAfter):
530         file.write(&quot;static std::unique_ptr&lt;CharacterClass&gt; {}()\n{{\n&quot;.format(self.getCreateFuncName()))
531         file.write(&quot;    // Name = {}, number of codePoints: {}\n&quot;.format(self.name, self.codePointCount))
<a name="5" id="anc5"></a><span class="line-modified">532         file.write(&quot;    auto characterClass = makeUnique&lt;CharacterClass&gt;(\n&quot;)</span>
533         file.write(&quot;        std::initializer_list&lt;UChar32&gt;(&quot;)
534         self.dumpMatchData(file, 8, self.matches, lambda file, match: (file.write(&quot;{0:0=#4x}&quot;.format(match))))
535         file.write(&quot;),\n&quot;)
536         file.write(&quot;        std::initializer_list&lt;CharacterRange&gt;(&quot;)
537         self.dumpMatchData(file, 4, self.ranges, lambda file, range: (file.write(&quot;{{{0:0=#4x}, {1:0=#4x}}}&quot;.format(range[0], range[1]))))
538         file.write(&quot;),\n&quot;)
539         file.write(&quot;        std::initializer_list&lt;UChar32&gt;(&quot;)
540         self.dumpMatchData(file, 8, self.unicodeMatches, lambda file, match: (file.write(&quot;{0:0=#6x}&quot;.format(match))))
541         file.write(&quot;),\n&quot;)
542         file.write(&quot;        std::initializer_list&lt;CharacterRange&gt;(&quot;)
543         self.dumpMatchData(file, 4, self.unicodeRanges, lambda file, range: (file.write(&quot;{{{0:0=#6x}, {1:0=#6x}}}&quot;.format(range[0], range[1]))))
<a name="6" id="anc6"></a><span class="line-modified">544         file.write(&quot;),\n&quot;)</span>
545 
<a name="7" id="anc7"></a><span class="line-modified">546         file.write(&quot;        CharacterClassWidths::{});\n&quot;.format((&quot;Unknown&quot;, &quot;HasBMPChars&quot;, &quot;HasNonBMPChars&quot;, &quot;HasBothBMPAndNonBMP&quot;)[int(self.hasNonBMPCharacters) * 2 + int(self.hasBMPCharacters)]))</span>
547         file.write(&quot;    return characterClass;\n}\n\n&quot;)
548 
549     @classmethod
550     def dumpAll(cls, file):
551         for propertyData in cls.allPropertyData:
552             propertyData.dump(file, propertyData != cls.allPropertyData[-1])
553 
554         file.write(&quot;typedef std::unique_ptr&lt;CharacterClass&gt; (*CreateCharacterClass)();\n&quot;)
555         file.write(&quot;static CreateCharacterClass createFunctions[{}] = {{\n   &quot;.format(len(cls.allPropertyData)))
556         functionsOnThisLine = 0
557         for propertyData in cls.allPropertyData:
558             file.write(&quot; {},&quot;.format(propertyData.getCreateFuncName()))
559             functionsOnThisLine = functionsOnThisLine + 1
560             if functionsOnThisLine == 4:
561                 file.write(&quot;\n   &quot;)
562                 functionsOnThisLine = 0
563 
564         file.write(&quot;};\n\n&quot;)
565 
566     @classmethod
567     def createAndDumpHashTable(self, file, propertyDict, tablePrefix):
568         propertyKeys = propertyDict.keys()
569         numberOfKeys = len(propertyKeys)
570         hashSize = ceilingToPowerOf2(numberOfKeys * 2)
571         hashMask = hashSize - 1
572         hashTable = [None] * hashSize
573         valueTable = []
574         tableSize = hashSize
575 
576         keyValuesToHash = []
577         for propertyName in propertyKeys:
578             propertyData = propertyDict[propertyName]
579             keyValuesToHash.append((propertyName, propertyData.getIndex()))
580             for alias in propertyData.aliases:
581                 keyValuesToHash.append((alias, propertyData.getIndex()))
582 
583         for keyValue in keyValuesToHash:
584             key = keyValue[0]
585             hash = stringHash(key) % hashSize
586             while hashTable[hash] is not None:
587                 if hashTable[hash][1] is not None:
588                     hash = hashTable[hash][1]
589                 else:
590                     hashTable[hash] = (hashTable[hash][0], tableSize)
591                     hashTable.append(None)
592                     hash = tableSize
593                     tableSize = tableSize + 1
594 
595             hashTable[hash] = (len(valueTable), None)
596             valueTable.append((key, keyValue[1]))
597 
598         file.write(&quot;static const struct HashIndex {}TableIndex[{}] = {{\n&quot;.format(tablePrefix, len(hashTable)))
599 
600         for tableIndex in hashTable:
601             value = -1
602             next = -1
603             if tableIndex is not None:
604                 value = tableIndex[0]
605                 if tableIndex[1] is not None:
606                     next = tableIndex[1]
607 
608             file.write(&quot;    {{ {}, {} }},\n&quot;.format(value, next))
609 
610         file.write(&quot;};\n\n&quot;)
611 
612         file.write(&quot;static const struct HashValue {}TableValue[{}] = {{\n&quot;.format(tablePrefix, len(valueTable)))
613         for value in valueTable:
614             file.write(&quot;    {{ \&quot;{}\&quot;, {} }},\n&quot;.format(value[0], value[1]))
615         file.write(&quot;};\n\n&quot;)
616 
617         file.write(&quot;static const struct HashTable {}HashTable = \n&quot;.format(tablePrefix))
618         file.write(&quot;    {{ {}, {}, {}TableValue, {}TableIndex }};\n\n&quot;.format(len(valueTable), hashMask, tablePrefix, tablePrefix))
619 
620 
621 class Scripts:
622     def __init__(self):
623         self.allPropertyData = []
624         self.scriptsByName = {}
625         self.scriptExtensionsByName = {}
626         self.unknownScript = PropertyData(&quot;Unknown&quot;)
627         self.unknownScript.setAliases(aliases.scriptAliasesFor(&quot;Unknown&quot;))
628         self.allPropertyData.append(self.unknownScript)
629         self.scriptsParsed = False
630 
631     def parseScriptsFile(self, file):
632         currentScriptName = None
633         currentPropertyData = None
634         # To calculate the Unknown, we gather all the codePoints asigned to a scripts as ranges,
635         # sort them, and then go the list to create the inverse of the assigned ranges.
636         assignedCodePointRanges = []
637 
638         for line in file:
639             line = line.split(&#39;#&#39;, 1)[0]
640             line = line.rstrip()
641             if (not len(line)):
642                 continue
643 
644             fields = line.split(&#39;;&#39;)
645             if (not fields):
646                 continue
647 
648             codePoints = fields[0].strip()
649             scriptName = fields[1].strip()
650 
651             if scriptName != currentScriptName:
652                 currentScriptName = scriptName
653                 currentPropertyData = PropertyData(scriptName)
654                 currentPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
655                 self.allPropertyData.append(currentPropertyData)
656                 self.scriptsByName[scriptName] = currentPropertyData
657 
658             dotDot = codePoints.find(&quot;..&quot;)
659             if dotDot == -1:
660                 codePoint = int(codePoints, 16)
661                 currentPropertyData.addMatch(codePoint)
662                 assignedCodePointRanges.append((codePoint, codePoint))
663             else:
664                 lowCodePoint = int(codePoints[:dotDot], 16)
665                 highCodePoint = int(codePoints[dotDot + 2:], 16)
666                 currentPropertyData.addRange(lowCodePoint, highCodePoint)
667                 assignedCodePointRanges.append((lowCodePoint, highCodePoint))
668 
669         assignedCodePointRanges.sort(key=lambda range: range[0])
670         lastAssignedCodePoint = 0
671 
672         for range in assignedCodePointRanges:
673             if range[0] - lastAssignedCodePoint &gt; 1:
674                 if range[0] - lastAssignedCodePoint == 2:
675                     self.unknownScript.addMatch(lastAssignedCodePoint + 1)
676                 else:
677                     self.unknownScript.addRange(lastAssignedCodePoint + 1, range[0] - 1)
678             lastAssignedCodePoint = range[1]
679 
680         if lastAssignedCodePoint &lt; MaxUnicode:
681             if MaxUnicode - lastAssignedCodePoint == 1:
682                 self.unknownScript.addMatch(MaxUnicode)
683             else:
684                 self.unknownScript.addRange(lastAssignedCodePoint + 1, MaxUnicode)
685 
686         self.scriptsParsed = True
687 
688     def parseScriptExtensionsFile(self, file):
689         currentPropertyData = None
690         # To calculate the Unknown, we gather all the codePoints asigned to a scripts as ranges,
691         # sort them, and then go the list to create the inverse of the assigned ranges.
692         assignedCodePointRanges = []
693 
694         if not self.scriptsParsed:
695             print(&quot;Error: parsing ScriptExtensions.txt before Scripts.txt&quot;)
696             exit(1)
697 
698         commonScriptExtenstionPropertyData = None
699         inheritedScriptExtensionPropertyData = None
700 
701         scriptName = &quot;Common&quot;
702         if scriptName in self.scriptsByName:
703             commonScriptExtenstionPropertyData = self.scriptsByName[scriptName].makeCopy()
704         else:
705             commonScriptExtenstionPropertyData = PropertyData(scriptName)
706             commonScriptExtenstionPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
707         self.allPropertyData.append(commonScriptExtenstionPropertyData)
708         self.scriptExtensionsByName[scriptName] = commonScriptExtenstionPropertyData
709 
710         scriptName = &quot;Inherited&quot;
711         if scriptName in self.scriptsByName:
712             inheritedScriptExtensionPropertyData = self.scriptsByName[scriptName].makeCopy()
713         else:
714             inheritedScriptExtensionPropertyData = PropertyData(scriptName)
715             inheritedScriptExtensionPropertyData.setAliases(aliases.scriptAliasesFor(scriptName))
716         self.allPropertyData.append(inheritedScriptExtensionPropertyData)
717         self.scriptExtensionsByName[scriptName] = inheritedScriptExtensionPropertyData
718 
719         for line in file:
720             line = line.split(&#39;#&#39;, 1)[0]
721             line = line.rstrip()
722             if (not len(line)):
723                 continue
724 
725             fields = line.split(&#39;;&#39;)
726             if (not fields):
727                 continue
728 
729             codePoints = fields[0].strip()
730             scriptAliasList = fields[1].strip()
731 
732             for scriptAlias in scriptAliasList.split(&#39; &#39;):
733                 scriptName = aliases.scriptNameForAlias(scriptAlias)
734                 currentPropertyData = None
735 
736                 if scriptName not in self.scriptExtensionsByName:
737                     currentPropertyData = self.scriptsByName[scriptName].makeCopy()
738                     self.allPropertyData.append(currentPropertyData)
739                     self.scriptExtensionsByName[scriptName] = currentPropertyData
740                 else:
741                     currentPropertyData = self.scriptExtensionsByName[scriptName]
742 
743                 dotDot = codePoints.find(&quot;..&quot;)
744                 if dotDot == -1:
745                     codePoint = int(codePoints, 16)
746                     currentPropertyData.addMatch(codePoint)
747                     commonScriptExtenstionPropertyData.removeMatch(codePoint)
748                     inheritedScriptExtensionPropertyData.removeMatch(codePoint)
749                 else:
750                     lowCodePoint = int(codePoints[:dotDot], 16)
751                     highCodePoint = int(codePoints[dotDot + 2:], 16)
752                     currentPropertyData.addRange(lowCodePoint, highCodePoint)
753                     for codePoint in range(lowCodePoint, highCodePoint + 1):
754                         commonScriptExtenstionPropertyData.removeMatch(codePoint)
755                         inheritedScriptExtensionPropertyData.removeMatch(codePoint)
756 
757         # For the scripts that don&#39;t have any additional extension codePoints, copy the script
758         # data to the script extension with the same name
759         for scriptName, propertyData in self.scriptsByName.items():
760             if scriptName not in self.scriptExtensionsByName:
761                 self.scriptExtensionsByName[scriptName] = propertyData
762 
763     def dump(self, file):
764         file.write(&quot;// Scripts:\n&quot;)
765         PropertyData.createAndDumpHashTable(file, self.scriptsByName, &quot;script&quot;)
766 
767         file.write(&quot;// Script_Extensions:\n&quot;)
768         PropertyData.createAndDumpHashTable(file, self.scriptExtensionsByName, &quot;scriptExtension&quot;)
769 
770 
771 class GeneralCategory:
772     def __init__(self, file):
773         self.file = file
774         self.allPropertyData = []
775         self.propertyDataByCategory = {}
776         self.createSpecialPropertyData(&quot;Any&quot;, (0, MaxUnicode))
777         self.createSpecialPropertyData(&quot;ASCII&quot;, (0, lastASCIICodePoint))
778         self.assignedPropertyData = self.createSpecialPropertyData(&quot;Assigned&quot;)
779         self.unassignedProperyData = self.findPropertyGroupFor(&quot;Cn&quot;)[1]
780         self.casedLetterPropertyData = self.findPropertyGroupFor(&quot;LC&quot;)[1]
781         self.lastAddedCodePoint = 0
782 
783     def createSpecialPropertyData(self, name, range=None):
784         propertyData = PropertyData(name)
785         self.allPropertyData.append(propertyData)
786         self.propertyDataByCategory[name] = propertyData
787         if range:
788             propertyData.addRange(range[0], range[1])
789 
790         return propertyData
791 
792     def findPropertyGroupFor(self, categoryAlias):
793         category = aliases.generalCategoryForAlias(categoryAlias)
794         allCategoryAliases = aliases.generalCategoryAliasesFor(category)
795         categoryGroupAlias = categoryAlias[0]
796         categoryGroup = aliases.generalCategoryForAlias(categoryGroupAlias)
797         allCategoryGroupAlias = aliases.generalCategoryAliasesFor(categoryGroup)
798         groupPropertyData = None
799         propertyData = None
800 
801         if categoryGroup not in self.propertyDataByCategory:
802             groupPropertyData = PropertyData(categoryGroup)
803             groupPropertyData.setAliases(allCategoryGroupAlias)
804             self.allPropertyData.append(groupPropertyData)
805             self.propertyDataByCategory[categoryGroup] = groupPropertyData
806         else:
807             groupPropertyData = self.propertyDataByCategory[categoryGroup]
808 
809         if category not in self.propertyDataByCategory:
810             propertyData = PropertyData(category)
811             propertyData.setAliases(allCategoryAliases)
812             self.allPropertyData.append(propertyData)
813             self.propertyDataByCategory[category] = propertyData
814         else:
815             propertyData = self.propertyDataByCategory[category]
816 
817         return (groupPropertyData, propertyData)
818 
819     def addNextCodePoints(self, categoryAlias, codePoint, highCodePoint=None):
820         if codePoint - self.lastAddedCodePoint &gt; 1:
821             propertyDatas = self.findPropertyGroupFor(&quot;Cn&quot;)
822             if codePoint - self.lastAddedCodePoint == 2:
823                 propertyDatas[0].addMatch(self.lastAddedCodePoint + 1)
824                 propertyDatas[1].addMatch(self.lastAddedCodePoint + 1)
825             else:
826                 propertyDatas[0].addRange(self.lastAddedCodePoint + 1, codePoint - 1)
827                 propertyDatas[1].addRange(self.lastAddedCodePoint + 1, codePoint - 1)
828 
829         propertyDatas = self.findPropertyGroupFor(categoryAlias)
830         if highCodePoint:
831             propertyDatas[0].addRange(codePoint, highCodePoint)
832             propertyDatas[1].addRange(codePoint, highCodePoint)
833             if categoryAlias == &quot;Ll&quot; or categoryAlias == &quot;Lt&quot; or categoryAlias == &quot;Lu&quot;:
834                 self.casedLetterPropertyData.addRange(codePoint, highCodePoint)
835             self.assignedPropertyData.addRange(codePoint, highCodePoint)
836 
837             self.lastAddedCodePoint = highCodePoint
838         else:
839             propertyDatas[0].addMatch(codePoint)
840             propertyDatas[1].addMatch(codePoint)
841             if categoryAlias == &quot;Ll&quot; or categoryAlias == &quot;Lt&quot; or categoryAlias == &quot;Lu&quot;:
842                 self.casedLetterPropertyData.addMatch(codePoint)
843             self.assignedPropertyData.addMatch(codePoint)
844 
845             self.lastAddedCodePoint = codePoint
846 
847     def parse(self):
848         lastLineFirstOfRange = None
849         lastLineCodePoint = 0
850         for line in self.file:
851             line = line.split(&#39;#&#39;, 1)[0]
852             line = line.rstrip()
853             if (not len(line)):
854                 continue
855 
856             fields = line.split(&#39;;&#39;)
857             if (not fields):
858                 continue
859 
860             codePoint = int(fields[0].strip(), 16)
861             description = fields[1].strip()
862             categoryAlias = fields[2].strip()
863 
864             if lastLineFirstOfRange:
865                 if description[-5:-1] == &quot;Last&quot;:
866                     self.addNextCodePoints(categoryAlias, lastLineFirstOfRange, codePoint)
867                     lastLineFirstOfRange = None
868                     continue
869                 else:
870                     print(&quot;Malformed First..Last pair of lines&quot;)
871 
872             if description[-6:-1] == &quot;First&quot;:
873                 lastLineFirstOfRange = codePoint
874                 continue
875 
876             self.addNextCodePoints(categoryAlias, codePoint)
877 
878         if self.lastAddedCodePoint &lt; MaxUnicode:
879             propertyDatas = self.findPropertyGroupFor(&quot;Cn&quot;)
880             if MaxUnicode - self.lastAddedCodePoint == 1:
881                 propertyDatas[0].addMatch(MaxUnicode)
882                 propertyDatas[1].addMatch(MaxUnicode)
883             else:
884                 propertyDatas[0].addRange(self.lastAddedCodePoint + 1, MaxUnicode)
885                 propertyDatas[1].addRange(self.lastAddedCodePoint + 1, MaxUnicode)
886 
887     def dump(self, file):
888         file.write(&quot;// General_Category:\n&quot;)
889         PropertyData.createAndDumpHashTable(file, self.propertyDataByCategory, &quot;generalCategory&quot;)
890 
891 
892 class BinaryProperty:
893     def __init__(self):
894         self.allPropertyData = []
895         self.propertyDataByProperty = {}
896 
897     def parsePropertyFile(self, file):
898         currentPropertyName = None
899         currentPropertyData = None
900 
901         for line in file:
902             line = line.split(&#39;#&#39;, 1)[0]
903             line = line.rstrip()
904             if (not len(line)):
905                 continue
906 
907             fields = line.split(&#39;;&#39;)
908             if (not fields):
909                 continue
910 
911             codePoints = fields[0].strip()
912             propertyName = fields[1].strip()
913 
914             if propertyName != currentPropertyName:
915                 if propertyName not in SupportedBinaryProperties:
916                     continue
917 
918                 currentPropertyName = propertyName
919                 currentPropertyData = PropertyData(propertyName)
920                 currentPropertyData.setAliases(aliases.globalAliasesFor(propertyName))
921                 self.allPropertyData.append(currentPropertyData)
922                 self.propertyDataByProperty[propertyName] = currentPropertyData
923 
924             dotDot = codePoints.find(&quot;..&quot;)
925             if dotDot == -1:
926                 currentPropertyData.addMatch(int(codePoints, 16))
927             else:
928                 currentPropertyData.addRange(int(codePoints[:dotDot], 16), int(codePoints[dotDot + 2:], 16))
929 
930     def dump(self, file):
931         file.write(&quot;// binary properties:\n&quot;)
932         PropertyData.createAndDumpHashTable(file, self.propertyDataByProperty, &quot;binaryProperty&quot;)
933 
934 if __name__ == &quot;__main__&quot;:
935     parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;UCD-Directory&gt; &lt;YarrUnicodePropertyData.h&gt;&quot;)
936     (options, args) = parser.parse_args()
937 
938     if len(args) != 2:
939         parser.error(&quot;&lt;UCD-Directory&gt; &lt;YarrUnicodePropertyData.h&gt;&quot;)
940 
941     UCDDirectoryPath = args[0]
942     unicodeProertyDataHPath = args[1]
943 
944     verifyUCDFilesExist()
945 
946     propertyAliasesFile = openUCDFileOrExit(&quot;PropertyAliases.txt&quot;)
947     propertyValueAliasesFile = openUCDFileOrExit(&quot;PropertyValueAliases.txt&quot;)
948     scriptsFile = openUCDFileOrExit(&quot;Scripts.txt&quot;)
949     scriptExtensionsFile = openUCDFileOrExit(&quot;ScriptExtensions.txt&quot;)
950     unicodeDataFile = openUCDFileOrExit(&quot;UnicodeData.txt&quot;)
951     derivedBinaryPropertiesFile = openUCDFileOrExit(&quot;DerivedBinaryProperties.txt&quot;)
952     derivedCorePropertiesFile = openUCDFileOrExit(&quot;DerivedCoreProperties.txt&quot;)
953     derivedNormalizationPropertiesFile = openUCDFileOrExit(&quot;DerivedNormalizationProps.txt&quot;)
954     propListFile = openUCDFileOrExit(&quot;PropList.txt&quot;)
955     emojiDataFile = openUCDFileOrExit(&quot;emoji-data.txt&quot;)
956 
957     aliases = Aliases()
958 
959     propertyDataHFile = openOrExit(unicodeProertyDataHPath, &quot;w&quot;)
960 
961     propertyDataHFile.write(header)
962 
963     aliases.parsePropertyAliasesFile(propertyAliasesFile)
964     aliases.parsePropertyValueAliasesFile(propertyValueAliasesFile)
965 
966     generalCategory = GeneralCategory(unicodeDataFile)
967     generalCategory.parse()
968 
969     binaryProperty = BinaryProperty()
970     binaryProperty.parsePropertyFile(derivedBinaryPropertiesFile)
971     binaryProperty.parsePropertyFile(derivedCorePropertiesFile)
972     binaryProperty.parsePropertyFile(derivedNormalizationPropertiesFile)
973     binaryProperty.parsePropertyFile(propListFile)
974     binaryProperty.parsePropertyFile(emojiDataFile)
975 
976     scripts = Scripts()
977     scripts.parseScriptsFile(scriptsFile)
978     scripts.parseScriptExtensionsFile(scriptExtensionsFile)
979 
980     PropertyData.dumpAll(propertyDataHFile)
981     generalCategory.dump(propertyDataHFile)
982     binaryProperty.dump(propertyDataHFile)
983     scripts.dump(propertyDataHFile)
984 
985     propertyDataHFile.write(footer)
986 
987     exit(0)
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>