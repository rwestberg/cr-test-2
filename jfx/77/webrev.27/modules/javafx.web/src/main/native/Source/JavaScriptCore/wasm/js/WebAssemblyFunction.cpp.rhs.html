<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyFunction.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSFunctionInlines.h&quot;
 34 #include &quot;JSObject.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &quot;JSWebAssemblyHelpers.h&quot;</span>
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyMemory.h&quot;
 38 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 39 #include &quot;LLIntThunks.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 40 #include &quot;LinkBuffer.h&quot;</span>
 41 #include &quot;ProtoCallFrame.h&quot;
 42 #include &quot;VM.h&quot;
 43 #include &quot;WasmCallee.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 44 #include &quot;WasmCallingConvention.h&quot;</span>
 45 #include &quot;WasmContextInlines.h&quot;
 46 #include &quot;WasmFormat.h&quot;
 47 #include &quot;WasmMemory.h&quot;
<a name="5" id="anc5"></a><span class="line-added"> 48 #include &quot;WasmMemoryInformation.h&quot;</span>
<span class="line-added"> 49 #include &quot;WasmModuleInformation.h&quot;</span>
 50 #include &quot;WasmSignatureInlines.h&quot;
 51 #include &lt;wtf/FastTLS.h&gt;
 52 #include &lt;wtf/StackPointer.h&gt;
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 
 55 namespace JSC {
 56 
 57 const ClassInfo WebAssemblyFunction::s_info = { &quot;WebAssemblyFunction&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyFunction) };
 58 
 59 static EncodedJSValue JSC_HOST_CALL callWebAssemblyFunction(ExecState* exec)
 60 {
 61     VM&amp; vm = exec-&gt;vm();
 62     auto scope = DECLARE_THROW_SCOPE(vm);
 63     WebAssemblyFunction* wasmFunction = jsCast&lt;WebAssemblyFunction*&gt;(exec-&gt;jsCallee());
 64     Wasm::SignatureIndex signatureIndex = wasmFunction-&gt;signatureIndex();
 65     const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
 66 
 67     // Make sure that the memory we think we are going to run with matches the one we expect.
 68     ASSERT(wasmFunction-&gt;instance()-&gt;instance().codeBlock()-&gt;isSafeToRun(wasmFunction-&gt;instance()-&gt;memory()-&gt;memory().mode()));
 69 
 70     Optional&lt;TraceScope&gt; traceScope;
 71     if (Options::useTracePoints())
 72         traceScope.emplace(WebAssemblyExecuteStart, WebAssemblyExecuteEnd);
 73 
 74     Vector&lt;JSValue, MarkedArgumentBuffer::inlineCapacity&gt; boxedArgs;
 75     JSWebAssemblyInstance* instance = wasmFunction-&gt;instance();
 76     Wasm::Instance* wasmInstance = &amp;instance-&gt;instance();
 77     // When we don&#39;t use fast TLS to store the context, the JS
 78     // entry wrapper expects a JSWebAssemblyInstance as the first argument.
 79     if (!Wasm::Context::useFastTLS())
 80         boxedArgs.append(instance);
 81 
 82     for (unsigned argIndex = 0; argIndex &lt; signature.argumentCount(); ++argIndex) {
 83         JSValue arg = exec-&gt;argument(argIndex);
 84         switch (signature.argument(argIndex)) {
 85         case Wasm::I32:
 86             arg = JSValue::decode(arg.toInt32(exec));
 87             break;
<a name="6" id="anc6"></a><span class="line-added"> 88         case Wasm::Funcref: {</span>
<span class="line-added"> 89             if (!isWebAssemblyHostFunction(vm, arg) &amp;&amp; !arg.isNull())</span>
<span class="line-added"> 90                 return JSValue::encode(throwException(exec, scope, createJSWebAssemblyRuntimeError(exec, vm, &quot;Funcref must be an exported wasm function&quot;)));</span>
<span class="line-added"> 91             break;</span>
<span class="line-added"> 92         }</span>
<span class="line-added"> 93         case Wasm::Anyref:</span>
<span class="line-added"> 94             break;</span>
 95         case Wasm::I64:
 96             arg = JSValue();
 97             break;
 98         case Wasm::F32:
 99             arg = JSValue::decode(bitwise_cast&lt;uint32_t&gt;(arg.toFloat(exec)));
100             break;
101         case Wasm::F64:
102             arg = JSValue::decode(bitwise_cast&lt;uint64_t&gt;(arg.toNumber(exec)));
103             break;
104         case Wasm::Void:
105         case Wasm::Func:
<a name="7" id="anc7"></a>
106             RELEASE_ASSERT_NOT_REACHED();
107         }
108         RETURN_IF_EXCEPTION(scope, encodedJSValue());
109         boxedArgs.append(arg);
110     }
111 
112     JSValue firstArgument = JSValue();
113     int argCount = 1;
114     JSValue* remainingArgs = nullptr;
115     if (boxedArgs.size()) {
116         remainingArgs = boxedArgs.data();
117         firstArgument = *remainingArgs;
118         remainingArgs++;
119         argCount = boxedArgs.size();
120     }
121 
122     // Note: we specifically use the WebAssemblyFunction as the callee to begin with in the ProtoCallFrame.
123     // The reason for this is that calling into the llint may stack overflow, and the stack overflow
124     // handler might read the global object from the callee.
125     ProtoCallFrame protoCallFrame;
126     protoCallFrame.init(nullptr, wasmFunction, firstArgument, argCount, remainingArgs);
127 
128     // FIXME Do away with this entire function, and only use the entrypoint generated by B3. https://bugs.webkit.org/show_bug.cgi?id=166486
129     Wasm::Instance* prevWasmInstance = vm.wasmContext.load();
130     {
131         // We do the stack check here for the wrapper function because we don&#39;t
132         // want to emit a stack check inside every wrapper function.
133         const intptr_t sp = bitwise_cast&lt;intptr_t&gt;(currentStackPointer());
134         const intptr_t frameSize = (boxedArgs.size() + CallFrame::headerSizeInRegisters) * sizeof(Register);
135         const intptr_t stackSpaceUsed = 2 * frameSize; // We&#39;re making two calls. One to the wrapper, and one to the actual wasm code.
136         if (UNLIKELY((sp &lt; stackSpaceUsed) || ((sp - stackSpaceUsed) &lt; bitwise_cast&lt;intptr_t&gt;(vm.softStackLimit()))))
137             return JSValue::encode(throwException(exec, scope, createStackOverflowError(exec)));
138     }
139     vm.wasmContext.store(wasmInstance, vm.softStackLimit());
140     ASSERT(wasmFunction-&gt;instance());
141     ASSERT(&amp;wasmFunction-&gt;instance()-&gt;instance() == vm.wasmContext.load());
142     EncodedJSValue rawResult = vmEntryToWasm(wasmFunction-&gt;jsEntrypoint(MustCheckArity).executableAddress(), &amp;vm, &amp;protoCallFrame);
143     // We need to make sure this is in a register or on the stack since it&#39;s stored in Vector&lt;JSValue&gt;.
144     // This probably isn&#39;t strictly necessary, since the WebAssemblyFunction* should keep the instance
145     // alive. But it&#39;s good hygiene.
146     instance-&gt;use();
147     if (prevWasmInstance != wasmInstance) {
148         // This is just for some extra safety instead of leaving a cached
149         // value in there. If we ever forget to set the value to be a real
150         // bounds, this will force every stack overflow check to immediately
151         // fire. The stack limit never changes while executing except when
152         // WebAssembly is used through the JSC API: API users can ask the code
153         // to migrate threads.
154         wasmInstance-&gt;setCachedStackLimit(bitwise_cast&lt;void*&gt;(std::numeric_limits&lt;uintptr_t&gt;::max()));
155     }
156     vm.wasmContext.store(prevWasmInstance, vm.softStackLimit());
157     RETURN_IF_EXCEPTION(scope, { });
158 
159     return rawResult;
160 }
161 
<a name="8" id="anc8"></a><span class="line-modified">162 bool WebAssemblyFunction::useTagRegisters() const</span>
<span class="line-added">163 {</span>
<span class="line-added">164     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());</span>
<span class="line-added">165     return signature.argumentCount() || signature.returnType() != Wasm::Void;</span>
<span class="line-added">166 }</span>
<span class="line-added">167 </span>
<span class="line-added">168 RegisterSet WebAssemblyFunction::calleeSaves() const</span>
<span class="line-added">169 {</span>
<span class="line-added">170     RegisterSet toSave = Wasm::PinnedRegisterInfo::get().toSave(instance()-&gt;memoryMode());</span>
<span class="line-added">171     if (useTagRegisters()) {</span>
<span class="line-added">172         RegisterSet tagRegisters = RegisterSet::runtimeTagRegisters();</span>
<span class="line-added">173         // We rely on these being disjoint sets.</span>
<span class="line-added">174 #if !ASSERT_DISABLED</span>
<span class="line-added">175         for (Reg reg : tagRegisters)</span>
<span class="line-added">176             ASSERT(!toSave.contains(reg));</span>
<span class="line-added">177 #endif</span>
<span class="line-added">178         toSave.merge(tagRegisters);</span>
<span class="line-added">179     }</span>
<span class="line-added">180     return toSave;</span>
<span class="line-added">181 }</span>
<span class="line-added">182 </span>
<span class="line-added">183 RegisterAtOffsetList WebAssemblyFunction::usedCalleeSaveRegisters() const</span>
<span class="line-added">184 {</span>
<span class="line-added">185     return RegisterAtOffsetList { calleeSaves(), RegisterAtOffsetList::OffsetBaseType::FramePointerBased };</span>
<span class="line-added">186 }</span>
<span class="line-added">187 </span>
<span class="line-added">188 ptrdiff_t WebAssemblyFunction::previousInstanceOffset() const</span>
<span class="line-added">189 {</span>
<span class="line-added">190     ptrdiff_t result = calleeSaves().numberOfSetRegisters() * sizeof(CPURegister);</span>
<span class="line-added">191     result = -result - sizeof(CPURegister);</span>
<span class="line-added">192 #if !ASSERT_DISABLED</span>
<span class="line-added">193     ptrdiff_t minOffset = 1;</span>
<span class="line-added">194     for (const RegisterAtOffset&amp; regAtOffset : usedCalleeSaveRegisters()) {</span>
<span class="line-added">195         ptrdiff_t offset = regAtOffset.offset();</span>
<span class="line-added">196         ASSERT(offset &lt; 0);</span>
<span class="line-added">197         minOffset = std::min(offset, minOffset);</span>
<span class="line-added">198     }</span>
<span class="line-added">199     ASSERT(minOffset - static_cast&lt;ptrdiff_t&gt;(sizeof(CPURegister)) == result);</span>
<span class="line-added">200 #endif</span>
<span class="line-added">201     return result;</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 Wasm::Instance* WebAssemblyFunction::previousInstance(CallFrame* callFrame)</span>
<span class="line-added">205 {</span>
<span class="line-added">206     ASSERT(callFrame-&gt;callee().rawPtr() == m_jsToWasmICCallee.get());</span>
<span class="line-added">207     auto* result = *bitwise_cast&lt;Wasm::Instance**&gt;(bitwise_cast&lt;char*&gt;(callFrame) + previousInstanceOffset());</span>
<span class="line-added">208     return result;</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
<span class="line-added">211 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; WebAssemblyFunction::jsCallEntrypointSlow()</span>
<span class="line-added">212 {</span>
<span class="line-added">213     VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">214     CCallHelpers jit;</span>
<span class="line-added">215 </span>
<span class="line-added">216     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());</span>
<span class="line-added">217     const auto&amp; pinnedRegs = Wasm::PinnedRegisterInfo::get();</span>
<span class="line-added">218     RegisterAtOffsetList registersToSpill = usedCalleeSaveRegisters();</span>
<span class="line-added">219 </span>
<span class="line-added">220     auto&amp; moduleInformation = instance()-&gt;instance().module().moduleInformation();</span>
<span class="line-added">221 </span>
<span class="line-added">222     unsigned totalFrameSize = registersToSpill.size() * sizeof(CPURegister);</span>
<span class="line-added">223     totalFrameSize += sizeof(CPURegister); // Slot for the VM&#39;s previous wasm instance.</span>
<span class="line-added">224     totalFrameSize += Wasm::WasmCallingConvention::headerSizeInBytes();</span>
<span class="line-added">225     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="line-added">226 </span>
<span class="line-added">227     unsigned numGPRs = 0;</span>
<span class="line-added">228     unsigned numFPRs = 0;</span>
<span class="line-added">229     bool argumentsIncludeI64 = false;</span>
<span class="line-added">230     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-added">231         switch (signature.argument(i)) {</span>
<span class="line-added">232         case Wasm::I64:</span>
<span class="line-added">233             argumentsIncludeI64 = true;</span>
<span class="line-added">234             break;</span>
<span class="line-added">235         case Wasm::Anyref:</span>
<span class="line-added">236         case Wasm::Funcref:</span>
<span class="line-added">237         case Wasm::I32:</span>
<span class="line-added">238             if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size())</span>
<span class="line-added">239                 totalFrameSize += sizeof(CPURegister);</span>
<span class="line-added">240             ++numGPRs;</span>
<span class="line-added">241             break;</span>
<span class="line-added">242         case Wasm::F32:</span>
<span class="line-added">243         case Wasm::F64:</span>
<span class="line-added">244             if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size())</span>
<span class="line-added">245                 totalFrameSize += sizeof(CPURegister);</span>
<span class="line-added">246             ++numFPRs;</span>
<span class="line-added">247             break;</span>
<span class="line-added">248         default:</span>
<span class="line-added">249             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">250         }</span>
<span class="line-added">251     }</span>
<span class="line-added">252 </span>
<span class="line-added">253     if (argumentsIncludeI64)</span>
<span class="line-added">254         return nullptr;</span>
<span class="line-added">255 </span>
<span class="line-added">256     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);</span>
<span class="line-added">257 </span>
<span class="line-added">258     jit.emitFunctionPrologue();</span>
<span class="line-added">259     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);</span>
<span class="line-added">260     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::addressFor(CallFrameSlot::codeBlock));</span>
<span class="line-added">261 </span>
<span class="line-added">262     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {</span>
<span class="line-added">263         GPRReg reg = regAtOffset.reg().gpr();</span>
<span class="line-added">264         ptrdiff_t offset = regAtOffset.offset();</span>
<span class="line-added">265         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));</span>
<span class="line-added">266     }</span>
<span class="line-added">267 </span>
<span class="line-added">268     GPRReg scratchGPR = Wasm::wasmCallingConventionAir().prologueScratch(1);</span>
<span class="line-added">269     bool stackLimitGPRIsClobbered = false;</span>
<span class="line-added">270     GPRReg stackLimitGPR = Wasm::wasmCallingConventionAir().prologueScratch(0);</span>
<span class="line-added">271     jit.loadPtr(vm.addressOfSoftStackLimit(), stackLimitGPR);</span>
<span class="line-added">272 </span>
<span class="line-added">273     CCallHelpers::JumpList slowPath;</span>
<span class="line-added">274     slowPath.append(jit.branchPtr(CCallHelpers::Above, MacroAssembler::stackPointerRegister, GPRInfo::callFrameRegister));</span>
<span class="line-added">275     slowPath.append(jit.branchPtr(CCallHelpers::Below, MacroAssembler::stackPointerRegister, stackLimitGPR));</span>
<span class="line-added">276 </span>
<span class="line-added">277     // Ensure:</span>
<span class="line-added">278     // argCountPlusThis - 1 &gt;= signature.argumentCount()</span>
<span class="line-added">279     // argCountPlusThis &gt;= signature.argumentCount() + 1</span>
<span class="line-added">280     // FIXME: We should handle mismatched arity</span>
<span class="line-added">281     // https://bugs.webkit.org/show_bug.cgi?id=196564</span>
<span class="line-added">282     slowPath.append(jit.branch32(CCallHelpers::Below,</span>
<span class="line-added">283         CCallHelpers::payloadFor(CallFrameSlot::argumentCount), CCallHelpers::TrustedImm32(signature.argumentCount() + 1)));</span>
<span class="line-added">284 </span>
<span class="line-added">285     if (useTagRegisters())</span>
<span class="line-added">286         jit.emitMaterializeTagCheckRegisters();</span>
<span class="line-added">287 </span>
<span class="line-added">288     // First we do stack slots for FPRs so we can use FPR argument registers as scratch.</span>
<span class="line-added">289     // After that, we handle FPR argument registers.</span>
<span class="line-added">290     // We also handle all GPR types here as we have GPR scratch registers.</span>
<span class="line-added">291     {</span>
<span class="line-added">292         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="line-added">293         numGPRs = 0;</span>
<span class="line-added">294         numFPRs = 0;</span>
<span class="line-added">295         FPRReg scratchFPR = Wasm::wasmCallingConvention().m_fprArgs[0].fpr();</span>
<span class="line-added">296 </span>
<span class="line-added">297         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="line-added">298 </span>
<span class="line-added">299         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(CPURegister);</span>
<span class="line-added">300         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-added">301             switch (signature.argument(i)) {</span>
<span class="line-added">302             case Wasm::I32:</span>
<span class="line-added">303                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-added">304                 slowPath.append(jit.branchIfNotInt32(scratchGPR));</span>
<span class="line-added">305                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-added">306                     jit.store32(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">307                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-added">308                 } else {</span>
<span class="line-added">309                     jit.zeroExtend32ToPtr(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-added">310                     ++numGPRs;</span>
<span class="line-added">311                 }</span>
<span class="line-added">312                 break;</span>
<span class="line-added">313             case Wasm::Funcref: {</span>
<span class="line-added">314                 // Ensure we have a WASM exported function.</span>
<span class="line-added">315                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-added">316                 auto isNull = jit.branchIfNull(scratchGPR);</span>
<span class="line-added">317                 slowPath.append(jit.branchIfNotCell(scratchGPR));</span>
<span class="line-added">318 </span>
<span class="line-added">319                 stackLimitGPRIsClobbered = true;</span>
<span class="line-added">320                 jit.emitLoadStructure(vm, scratchGPR, scratchGPR, stackLimitGPR);</span>
<span class="line-added">321                 jit.loadPtr(CCallHelpers::Address(scratchGPR, Structure::classInfoOffset()), scratchGPR);</span>
<span class="line-added">322 </span>
<span class="line-added">323                 static_assert(std::is_final&lt;WebAssemblyFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-added">324                 static_assert(std::is_final&lt;WebAssemblyWrapperFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-added">325 </span>
<span class="line-added">326                 auto isWasmFunction = jit.branchPtr(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyFunction::info()));</span>
<span class="line-added">327                 slowPath.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyWrapperFunction::info())));</span>
<span class="line-added">328 </span>
<span class="line-added">329                 isWasmFunction.link(&amp;jit);</span>
<span class="line-added">330                 isNull.link(&amp;jit);</span>
<span class="line-added">331                 FALLTHROUGH;</span>
<span class="line-added">332             }</span>
<span class="line-added">333             case Wasm::Anyref: {</span>
<span class="line-added">334                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-added">335 </span>
<span class="line-added">336                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-added">337                     jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">338                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-added">339                 } else {</span>
<span class="line-added">340                     jit.move(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-added">341                     ++numGPRs;</span>
<span class="line-added">342                 }</span>
<span class="line-added">343                 break;</span>
<span class="line-added">344             }</span>
<span class="line-added">345             case Wasm::F32:</span>
<span class="line-added">346             case Wasm::F64:</span>
<span class="line-added">347                 if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-added">348                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-added">349                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="line-added">350                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="line-added">351                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-added">352                         jit.unboxDouble(scratchGPR, scratchGPR, scratchFPR);</span>
<span class="line-added">353                         jit.convertDoubleToFloat(scratchFPR, scratchFPR);</span>
<span class="line-added">354                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">355                     } else {</span>
<span class="line-added">356                         jit.add64(GPRInfo::tagTypeNumberRegister, scratchGPR, scratchGPR);</span>
<span class="line-added">357                         jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">358                     }</span>
<span class="line-added">359                     auto done = jit.jump();</span>
<span class="line-added">360 </span>
<span class="line-added">361                     isInt32.link(&amp;jit);</span>
<span class="line-added">362                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-added">363                         jit.convertInt32ToFloat(scratchGPR, scratchFPR);</span>
<span class="line-added">364                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">365                     } else {</span>
<span class="line-added">366                         jit.convertInt32ToDouble(scratchGPR, scratchFPR);</span>
<span class="line-added">367                         jit.storeDouble(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-added">368                     }</span>
<span class="line-added">369                     done.link(&amp;jit);</span>
<span class="line-added">370 </span>
<span class="line-added">371                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-added">372                 } else</span>
<span class="line-added">373                     ++numFPRs;</span>
<span class="line-added">374                 break;</span>
<span class="line-added">375             default:</span>
<span class="line-added">376                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">377             }</span>
<span class="line-added">378 </span>
<span class="line-added">379             jsOffset += sizeof(EncodedJSValue);</span>
<span class="line-added">380         }</span>
<span class="line-added">381     }</span>
<span class="line-added">382 </span>
<span class="line-added">383     // Now handle FPR arguments in registers.</span>
<span class="line-added">384     {</span>
<span class="line-added">385         numFPRs = 0;</span>
<span class="line-added">386         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="line-added">387         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-added">388             switch (signature.argument(i)) {</span>
<span class="line-added">389             case Wasm::F32:</span>
<span class="line-added">390             case Wasm::F64:</span>
<span class="line-added">391                 if (numFPRs &lt; Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-added">392                     FPRReg argFPR = Wasm::wasmCallingConvention().m_fprArgs[numFPRs].fpr();</span>
<span class="line-added">393                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-added">394                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="line-added">395                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="line-added">396                     jit.unboxDouble(scratchGPR, scratchGPR, argFPR);</span>
<span class="line-added">397                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-added">398                         jit.convertDoubleToFloat(argFPR, argFPR);</span>
<span class="line-added">399                     auto done = jit.jump();</span>
<span class="line-added">400 </span>
<span class="line-added">401                     isInt32.link(&amp;jit);</span>
<span class="line-added">402                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-added">403                         jit.convertInt32ToFloat(scratchGPR, argFPR);</span>
<span class="line-added">404                     else</span>
<span class="line-added">405                         jit.convertInt32ToDouble(scratchGPR, argFPR);</span>
<span class="line-added">406 </span>
<span class="line-added">407                     done.link(&amp;jit);</span>
<span class="line-added">408                     ++numFPRs;</span>
<span class="line-added">409                 }</span>
<span class="line-added">410                 break;</span>
<span class="line-added">411             default:</span>
<span class="line-added">412                 break;</span>
<span class="line-added">413             }</span>
<span class="line-added">414 </span>
<span class="line-added">415             jsOffset += sizeof(EncodedJSValue);</span>
<span class="line-added">416         }</span>
<span class="line-added">417     }</span>
<span class="line-added">418 </span>
<span class="line-added">419     // At this point, we&#39;re committed to doing a fast call.</span>
<span class="line-added">420 </span>
<span class="line-added">421     if (Wasm::Context::useFastTLS())</span>
<span class="line-added">422         jit.loadWasmContextInstance(scratchGPR);</span>
<span class="line-added">423     else</span>
<span class="line-added">424         jit.loadPtr(vm.wasmContext.pointerToInstance(), scratchGPR);</span>
<span class="line-added">425     ptrdiff_t previousInstanceOffset = this-&gt;previousInstanceOffset();</span>
<span class="line-added">426     jit.storePtr(scratchGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset));</span>
<span class="line-added">427 </span>
<span class="line-added">428     jit.move(CCallHelpers::TrustedImmPtr(&amp;instance()-&gt;instance()), scratchGPR);</span>
<span class="line-added">429     if (Wasm::Context::useFastTLS())</span>
<span class="line-added">430         jit.storeWasmContextInstance(scratchGPR);</span>
<span class="line-added">431     else {</span>
<span class="line-added">432         jit.move(scratchGPR, pinnedRegs.wasmContextInstancePointer);</span>
<span class="line-added">433         jit.storePtr(scratchGPR, vm.wasmContext.pointerToInstance());</span>
<span class="line-added">434     }</span>
<span class="line-added">435     if (stackLimitGPRIsClobbered)</span>
<span class="line-added">436         jit.loadPtr(vm.addressOfSoftStackLimit(), stackLimitGPR);</span>
<span class="line-added">437     jit.storePtr(stackLimitGPR, CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedStackLimit()));</span>
<span class="line-added">438 </span>
<span class="line-added">439     if (!!moduleInformation.memory) {</span>
<span class="line-added">440         GPRReg baseMemory = pinnedRegs.baseMemoryPointer;</span>
<span class="line-added">441         GPRReg scratchOrSize = stackLimitGPR;</span>
<span class="line-added">442         auto mode = instance()-&gt;memoryMode();</span>
<span class="line-added">443 </span>
<span class="line-added">444         if (isARM64E()) {</span>
<span class="line-added">445             if (mode != Wasm::MemoryMode::Signaling)</span>
<span class="line-added">446                 scratchOrSize = pinnedRegs.sizeRegister;</span>
<span class="line-added">447             jit.loadPtr(CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedMemorySize()), scratchOrSize);</span>
<span class="line-added">448         } else {</span>
<span class="line-added">449             if (mode != Wasm::MemoryMode::Signaling)</span>
<span class="line-added">450                 jit.loadPtr(CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister);</span>
<span class="line-added">451         }</span>
<span class="line-added">452 </span>
<span class="line-added">453         jit.loadPtr(CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);</span>
<span class="line-added">454         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);</span>
<span class="line-added">455     }</span>
<span class="line-added">456 </span>
<span class="line-added">457     // We use this callee to indicate how to unwind past these types of frames:</span>
<span class="line-added">458     // 1. We need to know where to get callee saves.</span>
<span class="line-added">459     // 2. We need to know to restore the previous wasm context.</span>
<span class="line-added">460     if (!m_jsToWasmICCallee)</span>
<span class="line-added">461         m_jsToWasmICCallee.set(vm, this, JSToWasmICCallee::create(vm, globalObject(), this));</span>
<span class="line-added">462     jit.storePtr(CCallHelpers::TrustedImmPtr(m_jsToWasmICCallee.get()), CCallHelpers::addressFor(CallFrameSlot::callee));</span>
<span class="line-added">463 </span>
<span class="line-added">464     {</span>
<span class="line-added">465         // FIXME: Currently we just do an indirect jump. But we should teach the Module</span>
<span class="line-added">466         // how to repatch us:</span>
<span class="line-added">467         // https://bugs.webkit.org/show_bug.cgi?id=196570</span>
<span class="line-added">468         jit.loadPtr(entrypointLoadLocation(), scratchGPR);</span>
<span class="line-added">469         jit.call(scratchGPR, WasmEntryPtrTag);</span>
<span class="line-added">470     }</span>
<span class="line-added">471 </span>
<span class="line-added">472     ASSERT(!RegisterSet::runtimeTagRegisters().contains(GPRInfo::nonPreservedNonReturnGPR));</span>
<span class="line-added">473     jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset), GPRInfo::nonPreservedNonReturnGPR);</span>
<span class="line-added">474     if (Wasm::Context::useFastTLS())</span>
<span class="line-added">475         jit.storeWasmContextInstance(GPRInfo::nonPreservedNonReturnGPR);</span>
<span class="line-added">476     else</span>
<span class="line-added">477         jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, vm.wasmContext.pointerToInstance());</span>
<span class="line-added">478 </span>
<span class="line-added">479     switch (signature.returnType()) {</span>
<span class="line-added">480     case Wasm::Void:</span>
<span class="line-added">481         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">482         break;</span>
<span class="line-added">483     case Wasm::I32:</span>
<span class="line-added">484         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-added">485         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">486         break;</span>
<span class="line-added">487     case Wasm::F32:</span>
<span class="line-added">488         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-added">489         FALLTHROUGH;</span>
<span class="line-added">490     case Wasm::F64: {</span>
<span class="line-added">491         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">492         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="line-added">493         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">494         isNaN.link(&amp;jit);</span>
<span class="line-added">495         break;</span>
<span class="line-added">496     }</span>
<span class="line-added">497     case Wasm::Funcref:</span>
<span class="line-added">498     case Wasm::Anyref:</span>
<span class="line-added">499         break;</span>
<span class="line-added">500     case Wasm::I64:</span>
<span class="line-added">501     case Wasm::Func:</span>
<span class="line-added">502         return nullptr;</span>
<span class="line-added">503     default:</span>
<span class="line-added">504         break;</span>
<span class="line-added">505     }</span>
<span class="line-added">506 </span>
<span class="line-added">507     auto emitRestoreCalleeSaves = [&amp;] {</span>
<span class="line-added">508         for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {</span>
<span class="line-added">509             GPRReg reg = regAtOffset.reg().gpr();</span>
<span class="line-added">510             ASSERT(reg != GPRInfo::returnValueGPR);</span>
<span class="line-added">511             ptrdiff_t offset = regAtOffset.offset();</span>
<span class="line-added">512             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);</span>
<span class="line-added">513         }</span>
<span class="line-added">514     };</span>
<span class="line-added">515 </span>
<span class="line-added">516     emitRestoreCalleeSaves();</span>
<span class="line-added">517 </span>
<span class="line-added">518     jit.emitFunctionEpilogue();</span>
<span class="line-added">519     jit.ret();</span>
<span class="line-added">520 </span>
<span class="line-added">521     slowPath.link(&amp;jit);</span>
<span class="line-added">522     emitRestoreCalleeSaves();</span>
<span class="line-added">523     jit.move(CCallHelpers::TrustedImmPtr(this), GPRInfo::regT0);</span>
<span class="line-added">524     jit.emitFunctionEpilogue();</span>
<span class="line-added">525 #if CPU(ARM64E)</span>
<span class="line-added">526     jit.untagReturnAddress();</span>
<span class="line-added">527 #endif</span>
<span class="line-added">528     auto jumpToHostCallThunk = jit.jump();</span>
<span class="line-added">529 </span>
<span class="line-added">530     LinkBuffer linkBuffer(jit, nullptr, JITCompilationCanFail);</span>
<span class="line-added">531     if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="line-added">532         return nullptr;</span>
<span class="line-added">533 </span>
<span class="line-added">534     linkBuffer.link(jumpToHostCallThunk, CodeLocationLabel&lt;JSEntryPtrTag&gt;(executable()-&gt;entrypointFor(CodeForCall, MustCheckArity).executableAddress()));</span>
<span class="line-added">535     m_jsCallEntrypoint = FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;JS-&gt;Wasm IC&quot;);</span>
<span class="line-added">536     return m_jsCallEntrypoint.code();</span>
<span class="line-added">537 }</span>
<span class="line-added">538 </span>
<span class="line-added">539 WebAssemblyFunction* WebAssemblyFunction::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, unsigned length, const String&amp; name, JSWebAssemblyInstance* instance, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)</span>
540 {
541     NativeExecutable* executable = vm.getHostFunction(callWebAssemblyFunction, NoIntrinsic, callHostFunctionAsConstructor, nullptr, name);
<a name="9" id="anc9"></a>
542     WebAssemblyFunction* function = new (NotNull, allocateCell&lt;WebAssemblyFunction&gt;(vm.heap)) WebAssemblyFunction(vm, globalObject, structure, jsEntrypoint, wasmToWasmEntrypointLoadLocation, signatureIndex);
543     function-&gt;finishCreation(vm, executable, length, name, instance);
544     ASSERT_WITH_MESSAGE(!function-&gt;isLargeAllocation(), &quot;WebAssemblyFunction should be allocated not in large allocation since it is JSCallee.&quot;);
545     return function;
546 }
547 
548 Structure* WebAssemblyFunction::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
549 {
550     ASSERT(globalObject);
551     return Structure::create(vm, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), info());
552 }
553 
554 WebAssemblyFunction::WebAssemblyFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)
555     : Base { vm, globalObject, structure }
556     , m_jsEntrypoint { jsEntrypoint.entrypoint() }
557     , m_importableFunction { signatureIndex, wasmToWasmEntrypointLoadLocation }
558 { }
559 
<a name="10" id="anc10"></a><span class="line-added">560 void WebAssemblyFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)</span>
<span class="line-added">561 {</span>
<span class="line-added">562     WebAssemblyFunction* thisObject = jsCast&lt;WebAssemblyFunction*&gt;(cell);</span>
<span class="line-added">563     ASSERT_GC_OBJECT_INHERITS(thisObject, info());</span>
<span class="line-added">564 </span>
<span class="line-added">565     Base::visitChildren(thisObject, visitor);</span>
<span class="line-added">566     visitor.append(thisObject-&gt;m_jsToWasmICCallee);</span>
<span class="line-added">567 }</span>
<span class="line-added">568 </span>
<span class="line-added">569 void WebAssemblyFunction::destroy(JSCell* cell)</span>
<span class="line-added">570 {</span>
<span class="line-added">571     static_cast&lt;WebAssemblyFunction*&gt;(cell)-&gt;WebAssemblyFunction::~WebAssemblyFunction();</span>
<span class="line-added">572 }</span>
<span class="line-added">573 </span>
574 } // namespace JSC
575 
576 #endif // ENABLE(WEBASSEMBLY)
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>