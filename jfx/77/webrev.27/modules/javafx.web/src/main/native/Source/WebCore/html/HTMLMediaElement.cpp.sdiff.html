<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMarqueeElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;HTMLMediaElement.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ApplicationCacheHost.h&quot;
  32 #include &quot;ApplicationCacheResource.h&quot;
  33 #include &quot;Attribute.h&quot;
  34 #include &quot;Blob.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CommonVM.h&quot;

  39 #include &quot;ContentSecurityPolicy.h&quot;
  40 #include &quot;ContentType.h&quot;
  41 #include &quot;CookieJar.h&quot;

  42 #include &quot;DeprecatedGlobalSettings.h&quot;
  43 #include &quot;DiagnosticLoggingClient.h&quot;
  44 #include &quot;DiagnosticLoggingKeys.h&quot;
  45 #include &quot;Document.h&quot;
  46 #include &quot;DocumentLoader.h&quot;
  47 #include &quot;ElementChildIterator.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameLoaderClient.h&quot;
  52 #include &quot;FrameView.h&quot;

  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;HTMLSourceElement.h&quot;
  55 #include &quot;HTMLVideoElement.h&quot;
  56 #include &quot;InspectorInstrumentation.h&quot;
  57 #include &quot;JSDOMException.h&quot;
  58 #include &quot;JSDOMPromiseDeferred.h&quot;
  59 #include &quot;JSHTMLMediaElement.h&quot;
  60 #include &quot;Logging.h&quot;
  61 #include &quot;MIMETypeRegistry.h&quot;
  62 #include &quot;MediaController.h&quot;
  63 #include &quot;MediaControls.h&quot;
  64 #include &quot;MediaDocument.h&quot;
  65 #include &quot;MediaError.h&quot;
  66 #include &quot;MediaFragmentURIParser.h&quot;
  67 #include &quot;MediaList.h&quot;
  68 #include &quot;MediaPlayer.h&quot;
  69 #include &quot;MediaQueryEvaluator.h&quot;
  70 #include &quot;MediaResourceLoader.h&quot;
  71 #include &quot;NetworkingContext.h&quot;
  72 #include &quot;Page.h&quot;
  73 #include &quot;PageGroup.h&quot;
  74 #include &quot;PlatformMediaSessionManager.h&quot;
  75 #include &quot;ProgressTracker.h&quot;
<span class="line-removed">  76 #include &quot;PublicSuffix.h&quot;</span>
  77 #include &quot;Quirks.h&quot;

  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTheme.h&quot;
  80 #include &quot;RenderVideo.h&quot;
  81 #include &quot;RenderView.h&quot;
  82 #include &quot;ResourceLoadInfo.h&quot;
  83 #include &quot;ScriptController.h&quot;
  84 #include &quot;ScriptDisallowedScope.h&quot;
  85 #include &quot;ScriptSourceCode.h&quot;
  86 #include &quot;SecurityOriginData.h&quot;
  87 #include &quot;SecurityPolicy.h&quot;
  88 #include &quot;Settings.h&quot;
  89 #include &quot;ShadowRoot.h&quot;
  90 #include &quot;TimeRanges.h&quot;
  91 #include &quot;UserContentController.h&quot;
  92 #include &quot;UserGestureIndicator.h&quot;
  93 #include &quot;VideoPlaybackQuality.h&quot;
  94 #include &lt;JavaScriptCore/Uint8Array.h&gt;
  95 #include &lt;limits&gt;
  96 #include &lt;pal/SessionID.h&gt;
  97 #include &lt;pal/system/SleepDisabler.h&gt;
</pre>
<hr />
<pre>
 124 #include &quot;RuntimeApplicationChecks.h&quot;
 125 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 126 #endif
 127 
 128 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 129 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 130 #endif
 131 
 132 #if ENABLE(MEDIA_SESSION)
 133 #include &quot;MediaSession.h&quot;
 134 #endif
 135 
 136 #if ENABLE(MEDIA_SOURCE)
 137 #include &quot;DOMWindow.h&quot;
 138 #include &quot;MediaSource.h&quot;
 139 #endif
 140 
 141 #if ENABLE(MEDIA_STREAM)
 142 #include &quot;DOMURL.h&quot;
 143 #include &quot;MediaStream.h&quot;
<span class="line-removed"> 144 #include &quot;MediaStreamRegistry.h&quot;</span>
 145 #endif
 146 
 147 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 148 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 149 #include &quot;WebKitMediaKeys.h&quot;
 150 #endif
 151 
 152 #if ENABLE(ENCRYPTED_MEDIA)
 153 #include &quot;MediaEncryptedEvent.h&quot;
 154 #include &quot;MediaKeys.h&quot;
 155 #endif
 156 
 157 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 158 #include &quot;JSMediaControlsHost.h&quot;
 159 #include &quot;MediaControlsHost.h&quot;
 160 #include &lt;JavaScriptCore/ScriptObject.h&gt;
 161 #endif
 162 
 163 #if ENABLE(ENCRYPTED_MEDIA)
 164 #include &quot;NotImplemented.h&quot;
</pre>
<hr />
<pre>
 294 }
 295 
 296 #if ENABLE(VIDEO_TRACK)
 297 
 298 class TrackDisplayUpdateScope {
 299 public:
 300     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 301         : m_element(element)
 302     {
 303         m_element.beginIgnoringTrackDisplayUpdateRequests();
 304     }
 305     ~TrackDisplayUpdateScope()
 306     {
 307         m_element.endIgnoringTrackDisplayUpdateRequests();
 308     }
 309 
 310 private:
 311     HTMLMediaElement&amp; m_element;
 312 };
 313 

 314 
 315 struct HTMLMediaElement::TrackGroup {
 316     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 317 
 318     TrackGroup(GroupKind kind)
 319         : kind(kind)
 320     {
 321     }
 322 
 323     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 324     RefPtr&lt;TextTrack&gt; visibleTrack;
 325     RefPtr&lt;TextTrack&gt; defaultTrack;
 326     GroupKind kind;
 327     bool hasSrcLang { false };
 328 };
<span class="line-removed"> 329 #endif</span>
 330 
 331 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 332 {
 333     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 334     return elements;
 335 }
 336 
 337 #if ENABLE(MEDIA_SESSION)
 338 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 339 
 340 static IDToElementMap&amp; elementIDsToElements()
 341 {
 342     static NeverDestroyed&lt;IDToElementMap&gt; map;
 343     return map;
 344 }
 345 
 346 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 347 {
 348     if (id == HTMLMediaElementInvalidID)
 349         return nullptr;
</pre>
<hr />
<pre>
 399     // As a tiebreaker, prioritize elements that the user recently interacted with.
 400     return session.timeOfLastUserInteraction &gt; otherSession.timeOfLastUserInteraction;
 401 }
 402 
 403 static bool mediaSessionMayBeConfusedWithMainContent(const MediaElementSessionInfo&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 404 {
 405     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying)
 406         return session.isPlayingAudio;
 407 
 408     if (!session.isVisibleInViewportOrFullscreen)
 409         return false;
 410 
 411     if (!session.isLargeEnoughForMainContent)
 412         return false;
 413 
 414     // Even if this video is not a candidate, if it is visible to the user and large enough
 415     // to be main content, it poses a risk for being confused with main content.
 416     return true;
 417 }
 418 
<span class="line-removed"> 419 #if !RELEASE_LOG_DISABLED</span>
<span class="line-removed"> 420 static uint64_t nextLogIdentifier()</span>
<span class="line-removed"> 421 {</span>
<span class="line-removed"> 422     static uint64_t logIdentifier = cryptographicallyRandomNumber();</span>
<span class="line-removed"> 423     return ++logIdentifier;</span>
<span class="line-removed"> 424 }</span>
<span class="line-removed"> 425 #endif</span>
<span class="line-removed"> 426 </span>
 427 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 428     : HTMLElement(tagName, document)
 429     , ActiveDOMObject(document)
 430     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 431     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 432     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 433     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 434     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
 435     , m_asyncEventQueue(*this)
 436     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 437     , m_firstTimePlaying(true)
 438     , m_playing(false)
 439     , m_isWaitingUntilMediaCanStart(false)
 440     , m_shouldDelayLoadEvent(false)
 441     , m_haveFiredLoadedData(false)
 442     , m_inActiveDocument(true)
 443     , m_autoplaying(true)
 444     , m_muted(false)
 445     , m_explicitlyMuted(false)
 446     , m_initiallyMuted(false)
 447     , m_paused(true)
 448     , m_seeking(false)
 449     , m_seekRequested(false)
 450     , m_sentStalledEvent(false)
 451     , m_sentEndEvent(false)
 452     , m_pausedInternal(false)
 453     , m_closedCaptionsVisible(false)
 454     , m_webkitLegacyClosedCaptionOverride(false)
 455     , m_completelyLoaded(false)
 456     , m_havePreparedToPlay(false)
 457     , m_parsingInProgress(createdByParser)
<span class="line-removed"> 458     , m_shouldBufferData(true)</span>
 459     , m_elementIsHidden(document.hidden())
 460     , m_creatingControls(false)
 461     , m_receivedLayoutSizeChanged(false)
 462     , m_hasEverNotifiedAboutPlaying(false)
 463     , m_hasEverHadAudio(false)
 464     , m_hasEverHadVideo(false)
 465 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 466     , m_mediaControlsDependOnPageScaleFactor(false)
 467     , m_haveSetUpCaptionContainer(false)
 468 #endif
 469     , m_isScrubbingRemotely(false)
 470 #if ENABLE(VIDEO_TRACK)
 471     , m_tracksAreReady(true)
 472     , m_haveVisibleTextTrack(false)
 473     , m_processingPreferenceChange(false)
 474 #endif
 475 #if !RELEASE_LOG_DISABLED
 476     , m_logger(&amp;document.logger())
<span class="line-modified"> 477     , m_logIdentifier(nextLogIdentifier())</span>
 478 #endif
 479 {
 480     allMediaElements().add(this);
 481 
 482     ALWAYS_LOG(LOGIDENTIFIER);
 483 
 484     setHasCustomStyleResolveCallbacks();
 485 
 486     InspectorInstrumentation::addEventListenersToNode(*this);
 487 }
 488 
 489 void HTMLMediaElement::finishInitialization()
 490 {
<span class="line-modified"> 491     m_mediaSession = std::make_unique&lt;MediaElementSession&gt;(*this);</span>
 492 
 493     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 494     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
 495 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 496     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
 497 #endif
 498     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
 499     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
 500 
 501     auto&amp; document = this-&gt;document();
 502     auto* page = document.page();
 503 
 504     if (document.settings().invisibleAutoplayNotPermitted())
 505         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted);
 506 
 507     if (document.ownerElement() || !document.isMediaDocument()) {
 508         const auto&amp; topDocument = document.topDocument();
 509         const bool isProcessingUserGesture = processingUserGestureForMedia();
 510         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 511         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
</pre>
<hr />
<pre>
 644     m_resumeTaskQueue.close();
 645     m_promiseTaskQueue.close();
 646     m_pauseAfterDetachedTaskQueue.close();
 647     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
 648     m_resourceSelectionTaskQueue.close();
 649     m_visibilityChangeTaskQueue.close();
 650 #if ENABLE(ENCRYPTED_MEDIA)
 651     m_encryptedMediaQueue.close();
 652 #endif
 653 
 654     m_completelyLoaded = true;
 655 
 656     if (m_player) {
 657         m_player-&gt;invalidate();
 658         m_player = nullptr;
 659     }
 660 
 661     m_mediaSession = nullptr;
 662     schedulePlaybackControlsManagerUpdate();
 663 }
<span class="line-removed"> 664 </span>
<span class="line-removed"> 665 static bool needsAutoplayPlayPauseEventsQuirk(const Document&amp; document)</span>
<span class="line-removed"> 666 {</span>
<span class="line-removed"> 667     auto* page = document.page();</span>
<span class="line-removed"> 668     if (!page || !page-&gt;settings().needsSiteSpecificQuirks())</span>
<span class="line-removed"> 669         return false;</span>
<span class="line-removed"> 670 </span>
<span class="line-removed"> 671     auto loader = makeRefPtr(document.loader());</span>
<span class="line-removed"> 672     return loader &amp;&amp; loader-&gt;allowedAutoplayQuirks().contains(AutoplayQuirk::SynthesizedPauseEvents);</span>
<span class="line-removed"> 673 }</span>
<span class="line-removed"> 674 </span>
 675 RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
 676 {
<span class="line-removed"> 677     auto allSessions = PlatformMediaSessionManager::sharedManager().currentSessionsMatching([] (const PlatformMediaSession&amp; session) {</span>
<span class="line-removed"> 678         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-removed"> 679     });</span>
<span class="line-removed"> 680 </span>
 681     Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
 682     bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<span class="line-modified"> 683     for (auto&amp; session : allSessions) {</span>
<span class="line-modified"> 684         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(*session), purpose);</span>


 685         if (mediaElementSessionInfo.canShowControlsManager)
 686             candidateSessions.append(mediaElementSessionInfo);
 687         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 688             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<span class="line-modified"> 689     }</span>
 690 
 691     if (!candidateSessions.size())
 692         return nullptr;
 693 
 694     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 695     auto strongestSessionCandidate = candidateSessions.first();
 696     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 697         return nullptr;
 698 
 699     return &amp;strongestSessionCandidate.session-&gt;element();
 700 }
 701 
 702 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 703 {
 704     m_mediaSession-&gt;registerWithDocument(document);
 705 
 706     if (m_isWaitingUntilMediaCanStart)
 707         document.addMediaCanStartListener(*this);
 708 
 709 #if !PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
 806 {
 807     m_mediaSession-&gt;registerWithDocument(document());
 808     updateShouldAutoplay();
 809 }
 810 #endif
 811 
 812 bool HTMLMediaElement::supportsFocus() const
 813 {
 814     if (document().isMediaDocument())
 815         return false;
 816 
 817     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 818     return controls() ||  HTMLElement::supportsFocus();
 819 }
 820 
 821 bool HTMLMediaElement::isMouseFocusable() const
 822 {
 823     return false;
 824 }
 825 
<span class="line-modified"> 826 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomicString&amp; value)</span>





 827 {
 828     if (name == srcAttr) {
 829         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 830         // Location of the Media Resource
 831         // 12 February 2017
 832 
 833         // If a src attribute of a media element is set or changed, the user
 834         // agent must invoke the media element&#39;s media element load algorithm.
 835         if (!value.isNull())
 836             prepareForLoad();
 837     } else if (name == controlsAttr)
 838         configureMediaControls();
 839     else if (name == loopAttr)
 840         updateSleepDisabling();
 841     else if (name == preloadAttr) {
 842         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
 843             m_preload = MediaPlayer::None;
 844         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
 845             m_preload = MediaPlayer::MetaData;
 846         else {
 847             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 848             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
 849             m_preload = MediaPlayer::Auto;
 850         }
 851 
 852         // The attribute must be ignored if the autoplay attribute is present
 853         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 854             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 855 
 856     } else if (name == mediagroupAttr)
 857         setMediaGroup(value);
 858     else if (name == autoplayAttr) {
 859         if (processingUserGestureForMedia())
<span class="line-modified"> 860             removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
 861     } else if (name == titleAttr) {
 862         if (m_mediaSession)
 863             m_mediaSession-&gt;clientCharacteristicsChanged();
 864     }
 865     else
 866         HTMLElement::parseAttribute(name, value);
 867 }
 868 
 869 void HTMLMediaElement::finishParsingChildren()
 870 {
 871     HTMLElement::finishParsingChildren();
 872     m_parsingInProgress = false;
 873 
 874 #if ENABLE(VIDEO_TRACK)
 875     if (childrenOfType&lt;HTMLTrackElement&gt;(*this).first())
 876         scheduleConfigureTextTracks();
 877 #endif
 878 }
 879 
 880 bool HTMLMediaElement::rendererIsNeeded(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
1012 
1013 void HTMLMediaElement::didRecalcStyle(Style::Change)
1014 {
1015     updateRenderer();
1016 }
1017 
1018 void HTMLMediaElement::scheduleNextSourceChild()
1019 {
1020     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
1021     m_resourceSelectionTaskQueue.enqueueTask([this] {
1022         loadNextSourceChild();
1023     });
1024 }
1025 
1026 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)
1027 {
1028     m_hasEverHadAudio |= hasAudio();
1029     m_hasEverHadVideo |= hasVideo();
1030 }
1031 
<span class="line-modified">1032 void HTMLMediaElement::scheduleEvent(const AtomicString&amp; eventName)</span>
1033 {
1034     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
1035 
1036     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
1037     // will trigger an ASSERT if this element has been marked for deletion.
1038 
1039     m_asyncEventQueue.enqueueEvent(WTFMove(event));
1040 }
1041 
1042 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
1043 {
1044     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1045         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1046     });
1047 }
1048 
1049 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
1050 {
1051     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1052         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
</pre>
<hr />
<pre>
1088     return m_hasEverNotifiedAboutPlaying;
1089 }
1090 
1091 void HTMLMediaElement::scheduleCheckPlaybackTargetCompatability()
1092 {
1093     if (m_checkPlaybackTargetCompatablityTask.hasPendingTask())
1094         return;
1095 
1096     auto logSiteIdentifier = LOGIDENTIFIER;
1097     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1098     m_checkPlaybackTargetCompatablityTask.scheduleTask([this, logSiteIdentifier] {
1099         UNUSED_PARAM(logSiteIdentifier);
1100         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1101         checkPlaybackTargetCompatablity();
1102     });
1103 }
1104 
1105 void HTMLMediaElement::checkPlaybackTargetCompatablity()
1106 {
1107 #if ENABLE(WIRELESS_PLAYBACK_TARGET)


1108     if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<span class="line-modified">1109         INFO_LOG(LOGIDENTIFIER, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>

1110         m_failedToPlayToWirelessTarget = true;
1111         m_player-&gt;setShouldPlayToPlaybackTarget(false);
1112     }
1113 #endif
1114 }
1115 
1116 MediaError* HTMLMediaElement::error() const
1117 {
1118     return m_error.get();
1119 }
1120 
1121 void HTMLMediaElement::setSrcObject(MediaProvider&amp;&amp; mediaProvider)
1122 {
1123     // FIXME: Setting the srcObject attribute may cause other changes to the media element&#39;s internal state:
1124     // Specifically, if srcObject is specified, the UA must use it as the source of media, even if the src
1125     // attribute is also set or children are present. If the value of srcObject is replaced or set to null
1126     // the UA must re-run the media element load algorithm.
1127     //
1128     // https://bugs.webkit.org/show_bug.cgi?id=124896
1129 
1130 
1131     // https://www.w3.org/TR/html51/semantics-embedded-content.html#dom-htmlmediaelement-srcobject
1132     // 4.7.14.2. Location of the media resource
1133     // srcObject: On setting, it must set the element’s assigned media provider object to the new
1134     // value, and then invoke the element’s media element load algorithm.
1135     INFO_LOG(LOGIDENTIFIER);
1136     m_mediaProvider = WTFMove(mediaProvider);
1137     prepareForLoad();
1138 }
1139 
<span class="line-modified">1140 void HTMLMediaElement::setCrossOrigin(const AtomicString&amp; value)</span>
1141 {
1142     setAttributeWithoutSynchronization(crossoriginAttr, value);
1143 }
1144 
1145 String HTMLMediaElement::crossOrigin() const
1146 {
1147     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1148 }
1149 
1150 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1151 {
1152     return m_networkState;
1153 }
1154 
1155 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1156 {
1157     MediaEngineSupportParameters parameters;
1158     ContentType contentType(mimeType);
1159     parameters.type = contentType;
1160     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1161     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1162     String canPlay;
1163 
1164     // 4.8.10.3
1165     switch (support)
1166     {
1167         case MediaPlayer::IsNotSupported:
1168             canPlay = emptyString();
1169             break;
1170         case MediaPlayer::MayBeSupported:
1171             canPlay = &quot;maybe&quot;_s;
1172             break;
1173         case MediaPlayer::IsSupported:
1174             canPlay = &quot;probably&quot;_s;
1175             break;
1176     }
1177 
<span class="line-modified">1178     DEBUG_LOG(LOGIDENTIFIER, &quot;[&quot;, mimeType, &quot;] -&gt; &quot;, canPlay);</span>
1179 
1180     return canPlay;
1181 }
1182 
1183 double HTMLMediaElement::getStartDate() const
1184 {
1185     if (!m_player)
1186         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1187     return m_player-&gt;getStartDate().toDouble();
1188 }
1189 
1190 void HTMLMediaElement::load()
1191 {
1192     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1193 
1194     INFO_LOG(LOGIDENTIFIER);
1195 
<span class="line-removed">1196     if (processingUserGestureForMedia())</span>
<span class="line-removed">1197         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
<span class="line-removed">1198 </span>
1199     prepareForLoad();
1200     m_resourceSelectionTaskQueue.enqueueTask([this] {
1201         prepareToPlay();
1202     });
1203 }
1204 
1205 void HTMLMediaElement::prepareForLoad()
1206 {
1207     // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
1208     // The Media Element Load Algorithm
1209     // 12 February 2017
1210 
<span class="line-modified">1211     INFO_LOG(LOGIDENTIFIER);</span>



1212 
1213     // 1 - Abort any already-running instance of the resource selection algorithm for this element.
1214     // Perform the cleanup required for the resource load algorithm to run.
1215     stopPeriodicTimers();
1216     m_resourceSelectionTaskQueue.cancelAllTasks();
1217     // FIXME: Figure out appropriate place to reset LoadTextTrackResource if necessary and set m_pendingActionFlags to 0 here.
1218     m_sentEndEvent = false;
1219     m_sentStalledEvent = false;
1220     m_haveFiredLoadedData = false;
1221     m_completelyLoaded = false;
1222     m_havePreparedToPlay = false;
1223     m_displayMode = Unknown;
1224     m_currentSrc = URL();
1225 
1226 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1227     m_failedToPlayToWirelessTarget = false;
1228 #endif
1229 
1230     m_loadState = WaitingForSource;
1231     m_currentSourceNode = nullptr;
</pre>
<hr />
<pre>
1241     cancelPendingEventsAndCallbacks();
1242 
1243     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1244     // a task to fire a simple event named abort at the media element.
1245     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1246         scheduleEvent(eventNames().abortEvent);
1247 
1248     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1249     if (m_networkState != NETWORK_EMPTY) {
1250         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1251         scheduleEvent(eventNames().emptiedEvent);
1252 
1253         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1254         m_networkState = NETWORK_EMPTY;
1255 
1256         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1257 #if ENABLE(MEDIA_SOURCE)
1258         detachMediaSource();
1259 #endif
1260 
<span class="line-removed">1261 #if ENABLE(VIDEO_TRACK)</span>
1262         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1263         forgetResourceSpecificTracks();
<span class="line-removed">1264 #endif</span>
1265 
1266         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1267         m_readyState = HAVE_NOTHING;
1268         m_readyStateMaximum = HAVE_NOTHING;
1269 
1270         // 6.6 - If the paused attribute is false, then set it to true.
1271         m_paused = true;
1272 
1273         // 6.7 - If seeking is true, set it to false.
1274         clearSeeking();
1275 
1276         // 6.8 - Set the current playback position to 0.
1277         //       Set the official playback position to 0.
1278         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1279         m_lastSeekTime = MediaTime::zeroTime();
1280         m_playedTimeRanges = TimeRanges::create();
1281         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1282 
1283         // 4.9 - Set the initial playback position to 0.
1284         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
</pre>
<hr />
<pre>
1498 {
1499     ContentType contentType;
1500     String keySystem;
1501     URL mediaURL = selectNextSourceChild(&amp;contentType, &amp;keySystem, Complain);
1502     if (!mediaURL.isValid()) {
1503         waitForSourceChange();
1504         return;
1505     }
1506 
1507     // Recreate the media player for the new url
1508     createMediaPlayer();
1509 
1510     m_loadState = LoadingFromSourceElement;
1511     loadResource(mediaURL, contentType, keySystem);
1512 }
1513 
1514 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1515 {
1516     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1517 
<span class="line-modified">1518     INFO_LOG(LOGIDENTIFIER, initialURL, contentType.raw(), keySystem);</span>
1519 
1520     RefPtr&lt;Frame&gt; frame = document().frame();
1521     if (!frame) {
1522         mediaLoadingFailed(MediaPlayer::FormatError);
1523         return;
1524     }
1525 
1526     Page* page = frame-&gt;page();
1527     if (!page) {
1528         mediaLoadingFailed(MediaPlayer::FormatError);
1529         return;
1530     }
1531 
1532     URL url = initialURL;
1533     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
1534         mediaLoadingFailed(MediaPlayer::FormatError);
1535         return;
1536     }
1537 
1538 #if ENABLE(CONTENT_EXTENSIONS)
1539     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<span class="line-modified">1540         if (page-&gt;userContentProvider().processContentExtensionRulesForLoad(url, ResourceType::Media, *documentLoader).blockedLoad) {</span>
1541             mediaLoadingFailed(MediaPlayer::FormatError);
1542             return;
1543         }
1544     }
1545 #endif
1546 
1547     // The resource fetch algorithm
1548     m_networkState = NETWORK_LOADING;
1549 
1550     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1551     ApplicationCacheResource* resource = nullptr;
1552     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1553         // Resources that are not present in the manifest will always fail to load (at least, after the
1554         // cache has been primed the first time), making the testing of offline applications simpler.
1555         if (!resource || resource-&gt;path().isEmpty()) {
1556             mediaLoadingFailed(MediaPlayer::NetworkError);
1557             return;
1558         }
1559     }
1560 
1561     // Log that we started loading a media element.
1562     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1563 
1564     m_firstTimePlaying = true;
1565 
1566     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1567     // cache is an internal detail not exposed through the media element API.
1568     m_currentSrc = url;
1569 
1570     if (resource) {
1571         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<span class="line-modified">1572         INFO_LOG(LOGIDENTIFIER, &quot;will load &quot;, url, &quot; from app cache&quot;);</span>
1573     }
1574 
1575     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1576 
1577     startProgressEventTimer();
1578 
1579     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();
1580     m_player-&gt;setPrivateBrowsingMode(privateMode);
1581 
1582     // Reset display mode to force a recalculation of what to show because we are resetting the player.
1583     setDisplayMode(Unknown);
1584 
1585     if (!autoplay() &amp;&amp; !m_havePreparedToPlay)
1586         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1587     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1588 
1589     if (!m_explicitlyMuted) {
1590         m_explicitlyMuted = true;
1591         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1592         m_mediaSession-&gt;canProduceAudioChanged();
</pre>
<hr />
<pre>
1594 
1595     updateVolume();
1596 
1597     bool loadAttempted = false;
1598 #if ENABLE(MEDIA_SOURCE)
1599     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1600         m_mediaSource = MediaSource::lookup(url.string());
1601 
1602     if (m_mediaSource) {
1603         loadAttempted = true;
1604 
1605         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
1606         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {
1607             // Forget our reference to the MediaSource, so we leave it alone
1608             // while processing remainder of load failure.
1609             m_mediaSource = nullptr;
1610             mediaLoadingFailed(MediaPlayer::FormatError);
1611         }
1612     }
1613 #endif
<span class="line-removed">1614 </span>
1615 #if ENABLE(MEDIA_STREAM)
<span class="line-modified">1616     if (!loadAttempted) {</span>
<span class="line-modified">1617         if (!m_mediaStreamSrcObject &amp;&amp; url.protocolIs(mediaStreamBlobProtocol))</span>
<span class="line-modified">1618             m_mediaStreamSrcObject = MediaStreamRegistry::shared().lookUp(url);</span>
<span class="line-modified">1619 </span>
<span class="line-modified">1620         if (m_mediaStreamSrcObject) {</span>
<span class="line-removed">1621             loadAttempted = true;</span>
<span class="line-removed">1622             ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-removed">1623             if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-removed">1624                 mediaLoadingFailed(MediaPlayer::FormatError);</span>
<span class="line-removed">1625         }</span>
1626     }
1627 #endif
1628 
1629     if (!loadAttempted &amp;&amp; m_blob) {
1630         loadAttempted = true;
1631         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1632         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
1633             mediaLoadingFailed(MediaPlayer::FormatError);
1634     }
1635 
1636     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
1637         mediaLoadingFailed(MediaPlayer::FormatError);
1638 
1639     // If there is no poster to display, allow the media engine to render video frames as soon as
1640     // they are available.
1641     updateDisplayState();
1642 
1643     updateRenderer();
1644 }
1645 
</pre>
<hr />
<pre>
1767 
1768         if (!cue-&gt;isActive())
1769             activeSetChanged = true;
1770     }
1771 
1772     MediaTime nextInterestingTime = MediaTime::invalidTime();
1773     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1774         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1775 
1776     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);
1777     if (nextCue)
1778         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1779 
1780     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1781 
1782     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1783         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1784             if (!weakThis)
1785                 return;
1786 
<span class="line-modified">1787             auto currentMediaTime = weakThis-&gt;currentMediaTime();</span>
<span class="line-modified">1788             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime:&quot;, currentMediaTime);</span>
<span class="line-modified">1789             weakThis-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
1790         }, nextInterestingTime);
1791     }
1792 
1793     if (!activeSetChanged)
1794         return;
1795 
1796     // 7 - If the time was reached through the usual monotonic increase of the
1797     // current playback position during normal playback, and there are cues in
1798     // other cues that have their text track cue pause-on-exi flag set and that
1799     // either have their text track cue active flag set or are also in missed
1800     // cues, then immediately pause the media element.
1801     for (size_t i = 0; !m_paused &amp;&amp; i &lt; previousCuesSize; ++i) {
1802         if (previousCues[i].data()-&gt;pauseOnExit()
1803             &amp;&amp; previousCues[i].data()-&gt;isActive()
1804             &amp;&amp; !currentCues.contains(previousCues[i]))
1805             pause();
1806     }
1807 
1808     for (size_t i = 0; !m_paused &amp;&amp; i &lt; missedCuesSize; ++i) {
1809         if (missedCues[i].data()-&gt;pauseOnExit())
</pre>
<hr />
<pre>
1951             mediaControls()-&gt;clearTextDisplayContainer();
1952         updateTextTrackDisplay();
1953     }
1954     if (m_player &amp;&amp; m_textTracksWhenResourceSelectionBegan.contains(track)) {
1955         if (track-&gt;readinessState() != TextTrack::Loading)
1956             setReadyState(m_player-&gt;readyState());
1957     } else {
1958         // The track readiness state might have changed as a result of the user
1959         // clicking the captions button. In this case, a check whether all the
1960         // resources have failed loading should be done in order to hide the CC button.
1961         if (hasMediaControls() &amp;&amp; track-&gt;readinessState() == TextTrack::FailedToLoad)
1962             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
1963     }
1964 }
1965 
1966 void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
1967 {
1968     if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
1969         m_audioTracks-&gt;scheduleChangeEvent();
1970     if (processingUserGestureForMedia())
<span class="line-modified">1971         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
1972 }
1973 
1974 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1975 {
1976     bool trackIsLoaded = true;
1977     if (track.trackType() == TextTrack::TrackElement) {
1978         trackIsLoaded = false;
1979         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1980             if (&amp;trackElement.track() == &amp;track) {
1981                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1982                     trackIsLoaded = true;
1983                 break;
1984             }
1985         }
1986     }
1987 
1988     // If this is the first added track, create the list of text tracks.
1989     if (!m_textTracks)
1990         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
1991 
</pre>
<hr />
<pre>
2098 
2099 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2100 {
2101     // Elements in user agent show tree should load whatever the embedding document policy is.
2102     if (isInUserAgentShadowTree)
2103         return true;
2104 
2105     ASSERT(element.document().contentSecurityPolicy());
2106     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2107 }
2108 
2109 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2110 {
2111     if (!url.isValid()) {
2112         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2113         return false;
2114     }
2115 
2116     RefPtr&lt;Frame&gt; frame = document().frame();
2117     if (!frame || !document().securityOrigin().canDisplay(url)) {
<span class="line-modified">2118         if (actionIfInvalid == Complain)</span>
2119             FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
2120             ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);

2121         return false;
2122     }
2123 
2124     if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
2125         ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
2126         return false;
2127     }
2128 
2129     return true;
2130 }
2131 
2132 void HTMLMediaElement::startProgressEventTimer()
2133 {
2134     if (m_progressEventTimer.isActive())
2135         return;
2136 
2137     m_previousProgressTime = MonotonicTime::now();
2138     // 350ms is not magic, it is in the spec!
2139     m_progressEventTimer.startRepeating(350_ms);
2140 }
</pre>
<hr />
<pre>
2158 
2159 void HTMLMediaElement::noneSupported()
2160 {
2161     if (m_error)
2162         return;
2163 
2164     INFO_LOG(LOGIDENTIFIER);
2165 
2166     stopPeriodicTimers();
2167     m_loadState = WaitingForSource;
2168     m_currentSourceNode = nullptr;
2169 
2170     // 4.8.10.5
2171     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2172     // URL could not be resolved. In one atomic operation, run the following steps:
2173 
2174     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2175     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2176     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2177 
<span class="line-removed">2178 #if ENABLE(VIDEO_TRACK)</span>
2179     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2180     forgetResourceSpecificTracks();
<span class="line-removed">2181 #endif</span>
2182 
2183     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2184     m_networkState = NETWORK_NO_SOURCE;
2185 
2186     // 7 - Queue a task to fire a simple event named error at the media element.
2187     scheduleEvent(eventNames().errorEvent);
2188 
2189     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2190 
2191 #if ENABLE(MEDIA_SOURCE)
2192     detachMediaSource();
2193 #endif
2194 
2195     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2196     setShouldDelayLoadEvent(false);
2197 
2198     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2199     // the element won&#39;t attempt to load another resource.
2200 
2201     updateDisplayState();
</pre>
<hr />
<pre>
2295     }
2296 }
2297 
2298 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2299 {
2300     stopPeriodicTimers();
2301 
2302     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2303     // &lt;source&gt; children, schedule the next one
2304     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2305 
2306         // resource selection algorithm
2307         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2308         if (m_currentSourceNode)
2309             m_currentSourceNode-&gt;scheduleErrorEvent();
2310         else
2311             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2312 
2313         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2314 
<span class="line-removed">2315 #if ENABLE(VIDEO_TRACK)</span>
2316         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2317         forgetResourceSpecificTracks();
<span class="line-removed">2318 #endif</span>
2319 
2320         if (havePotentialSourceChild()) {
2321             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2322             scheduleNextSourceChild();
2323         } else {
2324             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2325             waitForSourceChange();
2326         }
2327 
2328         return;
2329     }
2330 
2331     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)
2332         mediaLoadingFailedFatally(error);
2333     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)
2334         noneSupported();
2335 
2336     updateDisplayState();
2337     if (hasMediaControls()) {
2338         mediaControls()-&gt;reset();
</pre>
<hr />
<pre>
2394         mediaControls()-&gt;bufferingProgressed();
2395 
2396     // Schedule one last progress event so we guarantee that at least one is fired
2397     // for files that load very quickly.
2398     scheduleEvent(eventNames().progressEvent);
2399     scheduleEvent(eventNames().suspendEvent);
2400     m_networkState = NETWORK_IDLE;
2401 }
2402 
2403 void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)
2404 {
2405     beginProcessingMediaPlayerCallback();
2406 
2407     setReadyState(m_player-&gt;readyState());
2408 
2409     endProcessingMediaPlayerCallback();
2410 }
2411 
2412 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2413 {
<span class="line-modified">2414     if (isAutoplaying()</span>
<span class="line-modified">2415         &amp;&amp; mediaSession().autoplayPermitted()</span>
<span class="line-modified">2416         &amp;&amp; paused()</span>
<span class="line-modified">2417         &amp;&amp; autoplay()</span>
<span class="line-modified">2418         &amp;&amp; !pausedForUserInteraction()</span>
<span class="line-modified">2419         &amp;&amp; !document().isSandboxed(SandboxAutomaticFeatures)</span>
<span class="line-modified">2420         &amp;&amp; m_readyState == HAVE_ENOUGH_DATA)</span>
<span class="line-modified">2421         return mediaSession().playbackPermitted();</span>




















2422 
<span class="line-modified">2423     ALWAYS_LOG(LOGIDENTIFIER, &quot;page consent required&quot;);</span>
<span class="line-modified">2424     return MediaPlaybackDenialReason::PageConsentRequired;</span>







2425 }
2426 
2427 void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
2428 {
<span class="line-modified">2429     auto&amp; document = this-&gt;document();</span>
<span class="line-removed">2430     if (!needsAutoplayPlayPauseEventsQuirk(document) &amp;&amp; !needsAutoplayPlayPauseEventsQuirk(document.topDocument()))</span>
2431         return;
2432 
2433     ALWAYS_LOG(LOGIDENTIFIER);
2434     scheduleEvent(eventNames().playingEvent);
2435     scheduleEvent(eventNames().pauseEvent);
2436 }
2437 
2438 void HTMLMediaElement::setReadyState(MediaPlayer::ReadyState state)
2439 {
2440     // Set &quot;wasPotentiallyPlaying&quot; BEFORE updating m_readyState, potentiallyPlaying() uses it
2441     bool wasPotentiallyPlaying = potentiallyPlaying();
2442 
2443     ReadyState oldState = m_readyState;
2444     ReadyState newState = static_cast&lt;ReadyState&gt;(state);
2445 
2446 #if ENABLE(VIDEO_TRACK)
2447     bool tracksAreReady = textTracksAreReady();
2448 
2449     if (newState == oldState &amp;&amp; m_tracksAreReady == tracksAreReady)
2450         return;
</pre>
<hr />
<pre>
3012         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
3013         m_seekTaskQueue.cancelTask();
3014         if (m_pendingSeek) {
3015             now = m_pendingSeek-&gt;now;
3016             m_pendingSeek = nullptr;
3017         }
3018         m_pendingSeekType = NoSeek;
3019     }
3020 
3021     // 4 - Set the seeking IDL attribute to true.
3022     // The flag will be cleared when the engine tells us the time has actually changed.
3023     m_seeking = true;
3024     if (m_playing) {
3025         if (m_lastSeekTime &lt; now)
3026             addPlayedRange(m_lastSeekTime, now);
3027     }
3028     m_lastSeekTime = time;
3029 
3030     // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
3031     // the script. The remainder of these steps must be run asynchronously.
<span class="line-modified">3032     m_pendingSeek = std::make_unique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
3033     if (fromDOM) {
3034         INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
3035         m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
3036     } else
3037         seekTask();
3038 
3039     if (processingUserGestureForMedia())
3040         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3041 }
3042 
3043 void HTMLMediaElement::seekTask()
3044 {
3045     INFO_LOG(LOGIDENTIFIER);
3046 
3047     if (!m_player) {
3048         clearSeeking();
3049         return;
3050     }
3051 
3052     ASSERT(m_pendingSeek);
</pre>
<hr />
<pre>
3054     MediaTime time = m_pendingSeek-&gt;targetTime;
3055     MediaTime negativeTolerance = m_pendingSeek-&gt;negativeTolerance;
3056     MediaTime positiveTolerance = m_pendingSeek-&gt;positiveTolerance;
3057     m_pendingSeek = nullptr;
3058 
3059     ASSERT(negativeTolerance &gt;= MediaTime::zeroTime());
3060 
3061     // 6 - If the new playback position is later than the end of the media resource, then let it be the end
3062     // of the media resource instead.
3063     time = std::min(time, durationMediaTime());
3064 
3065     // 7 - If the new playback position is less than the earliest possible position, let it be that position instead.
3066     MediaTime earliestTime = m_player-&gt;startTime();
3067     time = std::max(time, earliestTime);
3068 
3069     // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
3070     // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
3071     // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
3072     // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
3073     // fire a &#39;seeked&#39; event.
<span class="line-modified">3074     if (willLog(WTFLogLevelDebug)) {</span>
3075         MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
3076         if (time != mediaTime)
<span class="line-modified">3077             DEBUG_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
3078     }
3079 
3080     time = m_player-&gt;mediaTimeForTimeValue(time);
3081 
3082     // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
3083     // seekable attribute, then let it be the position in one of the ranges given in the seekable attribute
3084     // that is the nearest to the new playback position. ... If there are no ranges given in the seekable
3085     // attribute then set the seeking IDL attribute to false and abort these steps.
3086     RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
3087     bool noSeekRequired = !seekableRanges-&gt;length();
3088 
3089     // Short circuit seeking to the current time by just firing the events if no seek is required.
3090     // Don&#39;t skip calling the media engine if 1) we are in poster mode (because a seek should always cancel
3091     // poster display), or 2) if there is a pending fast seek, or 3) if this seek is not an exact seek
3092     SeekType thisSeekType = (negativeTolerance == MediaTime::zeroTime() &amp;&amp; positiveTolerance == MediaTime::zeroTime()) ? Precise : Fast;
3093     if (!noSeekRequired &amp;&amp; time == now &amp;&amp; thisSeekType == Precise &amp;&amp; m_pendingSeekType != Fast &amp;&amp; displayMode() != Poster)
3094         noSeekRequired = true;
3095 
3096 #if ENABLE(MEDIA_SOURCE)
3097     // Always notify the media engine of a seek if the source is not closed. This ensures that the source is
3098     // always in a flushed state when the &#39;seeking&#39; event fires.
3099     if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
3100         noSeekRequired = false;
3101 #endif
3102 
3103     if (noSeekRequired) {
<span class="line-modified">3104         INFO_LOG(LOGIDENTIFIER, &quot;seek to &quot;, time, &quot; ignored&quot;);</span>
3105         if (time == now) {
3106             scheduleEvent(eventNames().seekingEvent);
3107             scheduleTimeupdateEvent(false);
3108             scheduleEvent(eventNames().seekedEvent);
3109         }
3110         clearSeeking();
3111         return;
3112     }
3113     time = seekableRanges-&gt;ranges().nearest(time);
3114 
3115     m_sentEndEvent = false;
3116     m_lastSeekTime = time;
3117     m_pendingSeekType = thisSeekType;
3118     m_seeking = true;
3119 
3120     // 10 - Queue a task to fire a simple event named seeking at the element.
3121     scheduleEvent(eventNames().seekingEvent);
3122 
3123     // 11 - Set the current playback position to the given new playback position
3124     m_seekRequested = true;
</pre>
<hr />
<pre>
3492 }
3493 
3494 void HTMLMediaElement::play(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
3495 {
3496     ALWAYS_LOG(LOGIDENTIFIER);
3497 
3498     auto success = m_mediaSession-&gt;playbackPermitted();
3499     if (!success) {
3500         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3501             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3502         promise.reject(NotAllowedError);
3503         return;
3504     }
3505 
3506     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
3507         promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
3508         return;
3509     }
3510 
3511     if (processingUserGestureForMedia())
<span class="line-modified">3512         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
3513 
3514     m_pendingPlayPromises.append(WTFMove(promise));
3515     playInternal();
3516 }
3517 
3518 void HTMLMediaElement::play()
3519 {
3520     ALWAYS_LOG(LOGIDENTIFIER);
3521 
3522     auto success = m_mediaSession-&gt;playbackPermitted();
3523     if (!success) {
3524         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3525             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3526         return;
3527     }
3528     if (processingUserGestureForMedia())
<span class="line-modified">3529         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
3530 
3531     playInternal();
3532 }
3533 
3534 void HTMLMediaElement::playInternal()
3535 {
3536     ALWAYS_LOG(LOGIDENTIFIER);
3537 
3538     if (isSuspended()) {
<span class="line-modified">3539         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
3540         return;
3541     }
3542 
3543     if (!document().hasBrowsingContext()) {
<span class="line-modified">3544         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
3545         return;
3546     }
3547 
3548     if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<span class="line-modified">3549         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
3550         return;
3551     }
3552 
3553     // 4.8.10.9. Playing the media resource
3554     if (!m_player || m_networkState == NETWORK_EMPTY)
3555         selectMediaResource();
3556 
3557     if (endedPlayback())
3558         seekInternal(MediaTime::zeroTime());
3559 
3560     if (m_mediaController)
3561         m_mediaController-&gt;bringElementUpToSpeed(*this);
3562 
3563     if (m_paused) {
3564         m_paused = false;
3565         invalidateCachedTime();
<span class="line-modified">3566         m_playbackStartedTime = currentMediaTime().toDouble();</span>





3567         scheduleEvent(eventNames().playEvent);
3568 
3569 #if ENABLE(MEDIA_SESSION)
3570         // 6.3 Activating a media session from a media element
3571         // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
3572         // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then
3573         // 1. Let media session be the value of the current media session.
3574         // 2. If we are not currently in media session&#39;s list of active participating media elements then append
3575         //    ourselves to this list.
3576         // 3. Let activated be the result of running the media session invocation algorithm for media session.
3577         // 4. If activated is failure, pause ourselves.
3578         if (m_readyState == HAVE_ENOUGH_DATA || m_readyState == HAVE_FUTURE_DATA) {
3579             if (m_session) {
3580                 m_session-&gt;addActiveMediaElement(*this);
3581 
3582                 if (m_session-&gt;kind() == MediaSessionKind::Content) {
3583                     if (Page* page = document().page())
3584                         page-&gt;chrome().client().focusedContentMediaElementDidChange(m_elementID);
3585                 }
3586 
</pre>
<hr />
<pre>
3605     } else
3606         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
3607 
3608     m_autoplaying = false;
3609     updatePlayState();
3610 }
3611 
3612 void HTMLMediaElement::pause()
3613 {
3614     ALWAYS_LOG(LOGIDENTIFIER);
3615 
3616     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
3617 
3618     if (m_waitingToEnterFullscreen)
3619         m_waitingToEnterFullscreen = false;
3620 
3621     if (!m_mediaSession-&gt;playbackPermitted())
3622         return;
3623 
3624     if (processingUserGestureForMedia())
<span class="line-modified">3625         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3626 
3627     pauseInternal();
3628 }
3629 
3630 
3631 void HTMLMediaElement::pauseInternal()
3632 {
3633     ALWAYS_LOG(LOGIDENTIFIER);
3634 
3635     if (isSuspended()) {
<span class="line-modified">3636         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because context is suspended&quot;);</span>
3637         return;
3638     }
3639 
3640     if (!document().hasBrowsingContext()) {
<span class="line-modified">3641         INFO_LOG(LOGIDENTIFIER, &quot;  returning because there is no browsing context&quot;);</span>
3642         return;
3643     }
3644 
3645     if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<span class="line-modified">3646         ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because of interruption&quot;);</span>
3647         return;
3648     }
3649 
3650     // 4.8.10.9. Playing the media resource
3651     if (!m_player || m_networkState == NETWORK_EMPTY) {
3652         // Unless the restriction on media requiring user action has been lifted
3653         // don&#39;t trigger loading if a script calls pause().
3654         if (!m_mediaSession-&gt;playbackPermitted())
3655             return;
3656         selectMediaResource();
3657     }
3658 
3659     m_autoplaying = false;
3660 
3661     if (processingUserGestureForMedia())
3662         userDidInterfereWithAutoplay();
3663 
3664     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3665 
3666     if (!m_paused) {
</pre>
<hr />
<pre>
3676 }
3677 
3678 #if ENABLE(MEDIA_SOURCE)
3679 
3680 void HTMLMediaElement::detachMediaSource()
3681 {
3682     if (!m_mediaSource)
3683         return;
3684 
3685     m_mediaSource-&gt;detachFromElement(*this);
3686     m_mediaSource = nullptr;
3687 }
3688 
3689 #endif
3690 
3691 bool HTMLMediaElement::loop() const
3692 {
3693     return hasAttributeWithoutSynchronization(loopAttr);
3694 }
3695 
<span class="line-modified">3696 void HTMLMediaElement::setLoop(bool b)</span>
3697 {
<span class="line-modified">3698     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">3699     setBooleanAttribute(loopAttr, b);</span>
3700 }
3701 
3702 bool HTMLMediaElement::controls() const
3703 {
3704     RefPtr&lt;Frame&gt; frame = document().frame();
3705 
3706     // always show controls when scripting is disabled
3707     if (frame &amp;&amp; !frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
3708         return true;
3709 
3710     return hasAttributeWithoutSynchronization(controlsAttr);
3711 }
3712 
<span class="line-modified">3713 void HTMLMediaElement::setControls(bool b)</span>
3714 {
<span class="line-modified">3715     INFO_LOG(LOGIDENTIFIER, b);</span>
<span class="line-modified">3716     setBooleanAttribute(controlsAttr, b);</span>
3717 }
3718 
3719 double HTMLMediaElement::volume() const
3720 {
3721     return m_volume;
3722 }
3723 
3724 ExceptionOr&lt;void&gt; HTMLMediaElement::setVolume(double volume)
3725 {
3726     INFO_LOG(LOGIDENTIFIER, volume);
3727 
3728     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
3729         return Exception { IndexSizeError };
3730 
<span class="line-removed">3731 #if !PLATFORM(IOS_FAMILY)</span>
3732     if (m_volume == volume)
3733         return { };
3734 

3735     if (volume &amp;&amp; processingUserGestureForMedia())
<span class="line-modified">3736         removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3737 
3738     m_volume = volume;
3739     m_volumeInitialized = true;
3740     updateVolume();
3741     scheduleEvent(eventNames().volumechangeEvent);
3742 
3743     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3744         pauseInternal();
3745         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3746     }











3747 #endif

3748     return { };
3749 }
3750 
3751 bool HTMLMediaElement::muted() const
3752 {
3753     return m_explicitlyMuted ? m_muted : hasAttributeWithoutSynchronization(mutedAttr);
3754 }
3755 
3756 void HTMLMediaElement::setMuted(bool muted)
3757 {
3758     INFO_LOG(LOGIDENTIFIER, muted);
3759 
3760     bool mutedStateChanged = m_muted != muted;
3761     if (mutedStateChanged || !m_explicitlyMuted) {
3762         if (processingUserGestureForMedia()) {
<span class="line-modified">3763             removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3764 
3765             if (hasAudio() &amp;&amp; muted)
3766                 userDidInterfereWithAutoplay();
3767         }
3768 
3769         m_muted = muted;
3770         m_explicitlyMuted = true;
3771 
3772         // Avoid recursion when the player reports volume changes.
3773         if (!processingMediaPlayerCallback()) {
3774             if (m_player) {
3775                 m_player-&gt;setMuted(effectiveMuted());
3776                 if (hasMediaControls())
3777                     mediaControls()-&gt;changedMute();
3778             }
3779         }
3780 
3781         if (mutedStateChanged)
3782             scheduleEvent(eventNames().volumechangeEvent);
3783 
</pre>
<hr />
<pre>
4220 void HTMLMediaElement::didRemoveTextTrack(HTMLTrackElement&amp; trackElement)
4221 {
4222     ASSERT(trackElement.hasTagName(trackTag));
4223 
4224     auto&amp; textTrack = trackElement.track();
4225 
4226     textTrack.setHasBeenConfigured(false);
4227 
4228     if (!m_textTracks)
4229         return;
4230 
4231     // 4.8.10.12.3 Sourcing out-of-band text tracks
4232     // When a track element&#39;s parent element changes and the old parent was a media element,
4233     // then the user agent must remove the track element&#39;s corresponding text track from the
4234     // media element&#39;s list of text tracks.
4235     removeTextTrack(textTrack);
4236 
4237     m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
4238 }
4239 
<span class="line-removed">4240 #if ENABLE(VIDEO_TRACK)</span>
4241 void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
4242 {
4243     ASSERT(group.tracks.size());
4244 
4245     Page* page = document().page();
4246     CaptionUserPreferences* captionPreferences = page ? &amp;page-&gt;group().captionPreferences() : 0;
4247     CaptionUserPreferences::CaptionDisplayMode displayMode = captionPreferences ? captionPreferences-&gt;captionDisplayMode() : CaptionUserPreferences::Automatic;
4248 
4249     // First, find the track in the group that should be enabled (if any).
4250     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; currentlyEnabledTracks;
4251     RefPtr&lt;TextTrack&gt; trackToEnable;
4252     RefPtr&lt;TextTrack&gt; defaultTrack;
4253     RefPtr&lt;TextTrack&gt; fallbackTrack;
4254     RefPtr&lt;TextTrack&gt; forcedSubitleTrack;
4255     int highestTrackScore = 0;
4256     int highestForcedScore = 0;
4257 
4258     // If there is a visible track, it has already been configured so it won&#39;t be considered in the loop below. We don&#39;t want to choose another
4259     // track if it is less suitable, and we do want to disable it if another track is more suitable.
4260     int alreadyVisibleTrackScore = 0;
</pre>
<hr />
<pre>
4333 
4334     if (currentlyEnabledTracks.size()) {
4335         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4336             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4337             if (textTrack != trackToEnable)
4338                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4339         }
4340     }
4341 
4342     if (trackToEnable) {
4343         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4344 
4345         // If user preferences indicate we should always display captions, make sure we reflect the
4346         // proper status via the webkitClosedCaptionsVisible API call:
4347         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4348             m_webkitLegacyClosedCaptionOverride = true;
4349     }
4350 
4351     m_processingPreferenceChange = false;
4352 }
<span class="line-modified">4353 #endif</span>
4354 static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
4355 {
4356     JSC::VM&amp; vm = globalObject.vm();
4357     auto scope = DECLARE_THROW_SCOPE(vm);
4358     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
4359 
4360     // Retrieve the controller through the JS object graph
4361     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4362     if (!mediaJSWrapperObject)
4363         return JSC::jsNull();
4364 
<span class="line-modified">4365     JSC::Identifier controlsHost = JSC::Identifier::fromString(&amp;vm, &quot;controlsHost&quot;);</span>
4366     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
4367     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4368 
4369     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4370     if (!controlsHostJSWrapperObject)
4371         return JSC::jsNull();
4372 
<span class="line-modified">4373     JSC::Identifier controllerID = JSC::Identifier::fromString(&amp;vm, &quot;controller&quot;);</span>
4374     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
4375     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4376 
4377     return controllerJSWrapper;
4378 }
4379 
4380 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4381 {
4382     ASSERT(!m_creatingControls);
4383     m_creatingControls = true;
4384     ensureUserAgentShadowRoot();
4385     m_creatingControls = false;
4386 }
4387 
4388 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4389 {
4390     Page* page = document().page();
4391     if (!page)
4392         return false;
4393 
</pre>
<hr />
<pre>
4416 
4417     ensureMediaControlsShadowRoot();
4418 
4419     if (!m_mediaControlsHost)
4420         m_mediaControlsHost = MediaControlsHost::create(this);
4421 
4422     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
4423         auto&amp; vm = globalObject.vm();
4424         auto scope = DECLARE_CATCH_SCOPE(vm);
4425         auto controllerValue = controllerJSValue(exec, globalObject, *this);
4426         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4427         if (!controllerObject)
4428             return false;
4429 
4430         // The media controls script must provide a method on the Controller object with the following details.
4431         // Name: updateCaptionContainer
4432         // Parameters:
4433         //     None
4434         // Return value:
4435         //     None
<span class="line-modified">4436         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;updateCaptionContainer&quot;));</span>
4437         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4438         if (!methodObject)
4439             return false;
4440 
4441         JSC::CallData callData;
4442         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4443         if (callType == JSC::CallType::None)
4444             return false;
4445 
4446         JSC::MarkedArgumentBuffer noArguments;
4447         ASSERT(!noArguments.hasOverflowed());
4448         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);
4449         scope.clearException();
4450 
4451         m_haveSetUpCaptionContainer = true;
4452 
4453         return true;
4454     });
4455 
4456 #endif
</pre>
<hr />
<pre>
4614 bool HTMLMediaElement::havePotentialSourceChild()
4615 {
4616     // Stash the current &lt;source&gt; node and next nodes so we can restore them after checking
4617     // to see there is another potential.
4618     RefPtr&lt;HTMLSourceElement&gt; currentSourceNode = m_currentSourceNode;
4619     RefPtr&lt;HTMLSourceElement&gt; nextNode = m_nextChildNodeToConsider;
4620 
4621     URL nextURL = selectNextSourceChild(0, 0, DoNothing);
4622 
4623     m_currentSourceNode = currentSourceNode;
4624     m_nextChildNodeToConsider = nextNode;
4625 
4626     return nextURL.isValid();
4627 }
4628 
4629 URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
4630 {
4631     UNUSED_PARAM(keySystem);
4632 
4633     // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<span class="line-modified">4634     bool shouldLog = willLog(WTFLogLevelDebug) &amp;&amp; actionIfInvalid != DoNothing;</span>
4635     if (shouldLog)
4636         INFO_LOG(LOGIDENTIFIER);
4637 
4638     if (!m_nextChildNodeToConsider) {
4639         if (shouldLog)
4640             INFO_LOG(LOGIDENTIFIER, &quot;end of list, stopping&quot;);
4641         return URL();
4642     }
4643 
4644     // Because the DOM may be mutated in the course of the following algorithm,
4645     // keep strong references to each of the child source nodes, and verify that
4646     // each still is a child of this media element before using.
4647     Vector&lt;Ref&lt;HTMLSourceElement&gt;&gt; potentialSourceNodes;
4648     auto sources = childrenOfType&lt;HTMLSourceElement&gt;(*this);
4649     for (auto next = m_nextChildNodeToConsider ? sources.beginAt(*m_nextChildNodeToConsider) : sources.begin(), end = sources.end(); next != end; ++next)
4650         potentialSourceNodes.append(*next);
4651 
4652     for (auto&amp; source : potentialSourceNodes) {
4653         if (source-&gt;parentNode() != this)
4654             continue;
</pre>
<hr />
<pre>
4713 
4714         return mediaURL;
4715 
4716 CheckAgain:
4717         if (actionIfInvalid == Complain)
4718             source-&gt;scheduleErrorEvent();
4719     }
4720 
4721     m_currentSourceNode = nullptr;
4722     m_nextChildNodeToConsider = nullptr;
4723 
4724 #if !LOG_DISABLED
4725     if (shouldLog)
4726         INFO_LOG(LOGIDENTIFIER, &quot;failed&quot;);
4727 #endif
4728     return URL();
4729 }
4730 
4731 void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
4732 {
<span class="line-modified">4733     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4734         URL url = source.getNonEmptyURLAttribute(srcAttr);
4735         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4736     }
4737 
4738     if (!document().hasBrowsingContext()) {
4739         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted inside a document without a browsing context is not loaded&quot;);
4740         return;
4741     }
4742 
4743     // We should only consider a &lt;source&gt; element when there is not src attribute at all.
4744     if (hasAttributeWithoutSynchronization(srcAttr))
4745         return;
4746 
4747     // 4.8.8 - If a source element is inserted as a child of a media element that has no src
4748     // attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke
4749     // the media element&#39;s resource selection algorithm.
4750     if (m_networkState == NETWORK_EMPTY) {
4751         m_nextChildNodeToConsider = &amp;source;
4752 #if PLATFORM(IOS_FAMILY)
4753         if (m_mediaSession-&gt;dataLoadingPermitted())
</pre>
<hr />
<pre>
4765     if (m_nextChildNodeToConsider)
4766         return;
4767 
4768     // 4.8.9.5, resource selection algorithm, source elements section:
4769     // 21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
4770     // 22. Asynchronously await a stable state...
4771     // 23. Set the element&#39;s delaying-the-load-event flag back to true (this delays the load event again, in case
4772     // it hasn&#39;t been fired yet).
4773     setShouldDelayLoadEvent(true);
4774 
4775     // 24. Set the networkState back to NETWORK_LOADING.
4776     m_networkState = NETWORK_LOADING;
4777 
4778     // 25. Jump back to the find next candidate step above.
4779     m_nextChildNodeToConsider = &amp;source;
4780     scheduleNextSourceChild();
4781 }
4782 
4783 void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
4784 {
<span class="line-modified">4785     if (willLog(WTFLogLevelInfo) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4786         URL url = source.getNonEmptyURLAttribute(srcAttr);
4787         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4788     }
4789 
4790     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4791         return;
4792 
4793     if (&amp;source == m_nextChildNodeToConsider) {
4794         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4795         INFO_LOG(LOGIDENTIFIER);
4796     } else if (&amp;source == m_currentSourceNode) {
4797         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4798         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4799         // inserted in a video or audio element will have no effect.
4800         m_currentSourceNode = nullptr;
<span class="line-modified">4801         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode set to 0&quot;);</span>
4802     }
4803 }
4804 
4805 void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
4806 {
4807     INFO_LOG(LOGIDENTIFIER);
4808 
4809 #if ENABLE(VIDEO_TRACK)
4810     updateActiveTextTrackCues(currentMediaTime());
4811 #endif
4812 
4813     beginProcessingMediaPlayerCallback();
4814 
4815     invalidateCachedTime();
4816     bool wasSeeking = seeking();
4817 
4818     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4819     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4820         finishSeek();
4821 
</pre>
<hr />
<pre>
5344 
5345 MediaTime HTMLMediaElement::maxTimeSeekable() const
5346 {
5347     return m_player ? m_player-&gt;maxTimeSeekable() : MediaTime::zeroTime();
5348 }
5349 
5350 void HTMLMediaElement::updateVolume()
5351 {
5352     if (!m_player)
5353         return;
5354 #if PLATFORM(IOS_FAMILY)
5355     // Only the user can change audio volume so update the cached volume and post the changed event.
5356     float volume = m_player-&gt;volume();
5357     if (m_volume != volume) {
5358         m_volume = volume;
5359         scheduleEvent(eventNames().volumechangeEvent);
5360     }
5361 #else
5362     // Avoid recursion when the player reports volume changes.
5363     if (!processingMediaPlayerCallback()) {
<span class="line-modified">5364         Page* page = document().page();</span>
<span class="line-modified">5365         double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-removed">5366         bool shouldMute = effectiveMuted();</span>
<span class="line-removed">5367 </span>
<span class="line-removed">5368         if (m_mediaController) {</span>
<span class="line-removed">5369             volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-removed">5370             shouldMute = m_mediaController-&gt;muted() || (page &amp;&amp; page-&gt;isAudioMuted());</span>
<span class="line-removed">5371         }</span>
<span class="line-removed">5372 </span>
<span class="line-removed">5373 #if ENABLE(MEDIA_SESSION)</span>
<span class="line-removed">5374         if (m_shouldDuck)</span>
<span class="line-removed">5375             volumeMultiplier *= 0.25;</span>
<span class="line-removed">5376 #endif</span>
<span class="line-removed">5377 </span>
<span class="line-removed">5378         m_player-&gt;setMuted(shouldMute);</span>
<span class="line-removed">5379         m_player-&gt;setVolume(m_volume * volumeMultiplier);</span>
5380     }
5381 
5382 #if ENABLE(MEDIA_SESSION)
5383     document().updateIsPlayingMedia(m_elementID);
5384 #else
5385     document().updateIsPlayingMedia();
5386 #endif
5387 
5388     if (hasMediaControls())
5389         mediaControls()-&gt;changedVolume();
5390 #endif
5391 }
5392 
5393 void HTMLMediaElement::scheduleUpdatePlayState()
5394 {
5395     if (m_updatePlayStateTask.hasPendingTask())
5396         return;
5397 
5398     auto logSiteIdentifier = LOGIDENTIFIER;
5399     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
</pre>
<hr />
<pre>
5427 
5428     if (shouldBePlaying &amp;&amp; playerPaused &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; (m_waitingToEnterFullscreen || !isFullscreen())) {
5429         if (!m_waitingToEnterFullscreen)
5430             enterFullscreen();
5431 
5432 #if PLATFORM(WATCHOS)
5433         // FIXME: Investigate doing this for all builds.
5434         return;
5435 #endif
5436     }
5437 
5438     if (shouldBePlaying) {
5439         schedulePlaybackControlsManagerUpdate();
5440 
5441         setDisplayMode(Video);
5442         invalidateCachedTime();
5443 
5444         if (playerPaused) {
5445             m_mediaSession-&gt;clientWillBeginPlayback();
5446 
<span class="line-modified">5447             // Set rate, muted before calling play in case they were set before the media engine was setup.</span>
<span class="line-modified">5448             // The media engine should just stash the rate and muted values since it isn&#39;t already playing.</span>
5449             m_player-&gt;setRate(requestedPlaybackRate());
5450             m_player-&gt;setMuted(effectiveMuted());

5451 
5452             if (m_firstTimePlaying) {
5453                 // Log that a media element was played.
5454                 if (auto* page = document().page())
5455                     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
5456                 m_firstTimePlaying = false;
5457             }
5458 
5459             m_player-&gt;play();
5460         }
5461 
5462         if (hasMediaControls())
5463             mediaControls()-&gt;playbackStarted();
5464 
5465         startPlaybackProgressTimer();
5466         setPlaying(true);
5467     } else {
5468         schedulePlaybackControlsManagerUpdate();
5469 
5470         if (!playerPaused)
</pre>
<hr />
<pre>
5517 
5518 void HTMLMediaElement::setPausedInternal(bool b)
5519 {
5520     m_pausedInternal = b;
5521     scheduleUpdatePlayState();
5522 }
5523 
5524 void HTMLMediaElement::stopPeriodicTimers()
5525 {
5526     m_progressEventTimer.stop();
5527     m_playbackProgressTimer.stop();
5528 }
5529 
5530 void HTMLMediaElement::cancelPendingTasks()
5531 {
5532     m_configureTextTracksTask.cancelTask();
5533     m_checkPlaybackTargetCompatablityTask.cancelTask();
5534     m_updateMediaStateTask.cancelTask();
5535     m_mediaEngineUpdatedTask.cancelTask();
5536     m_updatePlayStateTask.cancelTask();



5537 }
5538 
5539 void HTMLMediaElement::userCancelledLoad()
5540 {
5541     INFO_LOG(LOGIDENTIFIER);
5542 
5543     // FIXME: We should look to reconcile the iOS and non-iOS code (below).
5544 #if PLATFORM(IOS_FAMILY)
5545     if (m_networkState == NETWORK_EMPTY || m_readyState &gt;= HAVE_METADATA)
5546         return;
5547 #else
5548     if (m_networkState == NETWORK_EMPTY || m_completelyLoaded)
5549         return;
5550 #endif
5551 
5552     // If the media data fetching process is aborted by the user:
5553 
5554     // 1 - The user agent should cancel the fetching process.
5555     clearMediaPlayer();
5556 
</pre>
<hr />
<pre>
5695 void HTMLMediaElement::closeTaskQueues()
5696 {
5697     m_configureTextTracksTask.close();
5698     m_checkPlaybackTargetCompatablityTask.close();
5699     m_updateMediaStateTask.close();
5700     m_mediaEngineUpdatedTask.close();
5701     m_updatePlayStateTask.close();
5702     m_resumeTaskQueue.close();
5703     m_seekTaskQueue.close();
5704     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5705     m_seekTaskQueue.close();
5706     m_resumeTaskQueue.close();
5707     m_promiseTaskQueue.close();
5708     m_pauseAfterDetachedTaskQueue.close();
5709     m_resourceSelectionTaskQueue.close();
5710     m_visibilityChangeTaskQueue.close();
5711 #if ENABLE(ENCRYPTED_MEDIA)
5712     m_encryptedMediaQueue.close();
5713 #endif
5714     m_asyncEventQueue.close();



5715 }
5716 
5717 void HTMLMediaElement::contextDestroyed()
5718 {
5719     closeTaskQueues();
5720     m_pendingPlayPromises.clear();
5721 
5722     ActiveDOMObject::contextDestroyed();
5723 }
5724 
5725 void HTMLMediaElement::stop()
5726 {
5727     INFO_LOG(LOGIDENTIFIER);
5728 
5729     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5730     stopWithoutDestroyingMediaPlayer();
5731     closeTaskQueues();
5732 
5733     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5734     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5735     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5736     // loaded and calling it again won&#39;t cause any problems.
5737     clearMediaPlayer();
5738 
5739     m_mediaSession-&gt;stopSession();
5740 }
5741 
5742 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5743 {
5744     INFO_LOG(LOGIDENTIFIER);
5745     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5746 
5747     m_resumeTaskQueue.cancelTask();
5748 
5749     switch (reason) {
5750     case ReasonForSuspension::PageCache:
5751         stopWithoutDestroyingMediaPlayer();
5752         m_asyncEventQueue.suspend();
<span class="line-modified">5753         setShouldBufferData(false);</span>
5754         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5755         break;
5756     case ReasonForSuspension::PageWillBeSuspended:
5757     case ReasonForSuspension::JavaScriptDebuggerPaused:
5758     case ReasonForSuspension::WillDeferLoading:
5759         // Do nothing, we don&#39;t pause media playback in these cases.
5760         break;
5761     }
5762 }
5763 
5764 void HTMLMediaElement::resume()
5765 {
5766     INFO_LOG(LOGIDENTIFIER);
5767 
5768     setInActiveDocument(true);
5769 
5770     m_asyncEventQueue.resume();
5771 
<span class="line-removed">5772     setShouldBufferData(true);</span>
<span class="line-removed">5773 </span>
5774     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5775         document().addMediaCanStartListener(*this);
5776     else
5777         setPausedInternal(false);
5778 
5779     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);

5780 
5781     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
5782         // Restart the load if it was aborted in the middle by moving the document to the page cache.
5783         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5784         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5785         // This behavior is not specified but it seems like a sensible thing to do.
5786         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5787         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5788     }
5789 
5790     updateRenderer();
5791 }
5792 
5793 bool HTMLMediaElement::hasPendingActivity() const
5794 {
5795     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;
5796 }
5797 
5798 void HTMLMediaElement::mediaVolumeDidChange()
5799 {
</pre>
<hr />
<pre>
5834 }
5835 
5836 void HTMLMediaElement::setTextTrackRepresentation(TextTrackRepresentation* representation)
5837 {
5838     if (m_player)
5839         m_player-&gt;setTextTrackRepresentation(representation);
5840 }
5841 
5842 void HTMLMediaElement::syncTextTrackBounds()
5843 {
5844     if (m_player)
5845         m_player-&gt;syncTextTrackBounds();
5846 }
5847 #endif // ENABLE(VIDEO_TRACK)
5848 
5849 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5850 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5851 {
5852     ALWAYS_LOG(LOGIDENTIFIER);
5853     if (processingUserGestureForMedia())
<span class="line-modified">5854         removeBehaviorsRestrictionsAfterFirstUserGesture();</span>
5855     m_mediaSession-&gt;showPlaybackTargetPicker();
5856 }
5857 
5858 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5859 {
5860     enqueuePlaybackTargetAvailabilityChangedEvent();
5861 }
5862 
5863 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)
5864 {
5865     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());
5866 }
5867 
5868 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5869 {
5870     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5871         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5872             return;
5873         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
5874 
5875         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5876         configureMediaControls();
5877         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5878         m_mediaSession-&gt;canProduceAudioChanged();
5879         scheduleUpdateMediaState();
5880         updateSleepDisabling();
5881 
5882         m_failedToPlayToWirelessTarget = false;
5883         scheduleCheckPlaybackTargetCompatability();
5884 
5885         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5886     });
5887 }
5888 
5889 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5890 {
<span class="line-modified">5891     DEBUG_LOG(LOGIDENTIFIER, &quot;dispatching &#39;&quot;, event.type(), &quot;&#39;&quot;);</span>



5892 
5893     HTMLElement::dispatchEvent(event);
5894 }
5895 
<span class="line-modified">5896 bool HTMLMediaElement::addEventListener(const AtomicString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
5897 {
5898     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5899         return Node::addEventListener(eventType, WTFMove(listener), options);
5900 
5901     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5902     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5903         return false;
5904 
5905     if (isFirstAvailabilityChangedListener) {
5906         m_hasPlaybackTargetAvailabilityListeners = true;
5907         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5908     }
5909 
5910     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5911 
5912     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5913     return true;
5914 }
5915 
<span class="line-modified">5916 bool HTMLMediaElement::removeEventListener(const AtomicString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
5917 {
5918     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5919         return Node::removeEventListener(eventType, listener, options);
5920 
5921     if (!Node::removeEventListener(eventType, listener, options))
5922         return false;
5923 
5924     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5925     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5926     if (didRemoveLastAvailabilityChangedListener) {
5927         m_hasPlaybackTargetAvailabilityListeners = false;
5928         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5929         scheduleUpdateMediaState();
5930     }
5931 
5932     return true;
5933 }
5934 
5935 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5936 {
</pre>
<hr />
<pre>
5976     scheduleUpdateMediaState();
5977 #endif
5978 }
5979 
5980 double HTMLMediaElement::minFastReverseRate() const
5981 {
5982     return m_player ? m_player-&gt;minFastReverseRate() : 0;
5983 }
5984 
5985 double HTMLMediaElement::maxFastForwardRate() const
5986 {
5987     return m_player ? m_player-&gt;maxFastForwardRate() : 0;
5988 }
5989 
5990 bool HTMLMediaElement::isFullscreen() const
5991 {
5992     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5993         return true;
5994 
5995 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">5996     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
5997         return true;
5998 #endif
5999 
6000     return false;
6001 }
6002 
6003 bool HTMLMediaElement::isStandardFullscreen() const
6004 {
6005 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">6006     if (document().webkitIsFullScreen() &amp;&amp; document().webkitCurrentFullScreenElement() == this)</span>
6007         return true;
6008 #endif
6009 
6010     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6011 }
6012 
6013 void HTMLMediaElement::toggleStandardFullscreenState()
6014 {
6015     if (isStandardFullscreen())
6016         exitFullscreen();
6017     else
6018         enterFullscreen();
6019 }
6020 
6021 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6022 {
6023     INFO_LOG(LOGIDENTIFIER);
6024     ASSERT(mode != VideoFullscreenModeNone);
6025 
6026     if (m_videoFullscreenMode == mode)
6027         return;
6028 
6029     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6030     m_waitingToEnterFullscreen = true;
6031 
6032 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6033     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<span class="line-modified">6034         document().requestFullScreenForElement(this, Document::ExemptIFrameAllowFullScreenRequirement);</span>
6035         return;
6036     }
6037 #endif
6038 
6039     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6040         if (document().hidden()) {
6041             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6042             return;
6043         }
6044 
6045         fullscreenModeChanged(mode);
6046         configureMediaControls();
6047         if (hasMediaControls())
6048             mediaControls()-&gt;enteredFullscreen();
6049         if (is&lt;HTMLVideoElement&gt;(*this)) {
6050             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6051             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
6052                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6053                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6054             }
6055         }
6056     });
6057 }
6058 
6059 void HTMLMediaElement::enterFullscreen()
6060 {
6061     enterFullscreen(VideoFullscreenModeStandard);
6062 }
6063 
6064 void HTMLMediaElement::exitFullscreen()
6065 {
6066     INFO_LOG(LOGIDENTIFIER);
6067 
6068     m_waitingToEnterFullscreen = false;
6069 
6070 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">6071     if (document().settings().fullScreenEnabled() &amp;&amp; document().webkitCurrentFullScreenElement() == this) {</span>
<span class="line-modified">6072         if (document().webkitIsFullScreen())</span>
<span class="line-modified">6073             document().webkitCancelFullScreen();</span>
6074 
6075         if (m_videoFullscreenMode == VideoFullscreenModeStandard)
6076             return;
6077     }
6078 #endif
6079 
6080     ASSERT(m_videoFullscreenMode != VideoFullscreenModeNone);
6081     VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6082     fullscreenModeChanged(VideoFullscreenModeNone);
6083 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6084     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaControlsAfterPresentationModeChange calls methods that can trigger arbitrary DOM mutations.
6085     updateMediaControlsAfterPresentationModeChange();
6086 #endif
6087     if (hasMediaControls())
6088         mediaControls()-&gt;exitedFullscreen();
6089 
6090     if (!document().page() || !is&lt;HTMLVideoElement&gt;(*this))
6091         return;
6092 
6093     if (!paused() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback()) {
</pre>
<hr />
<pre>
6095             pauseInternal();
6096         else {
6097             // Allow inline playback, but set a flag so pausing and starting again (e.g. when scrubbing or looping) won&#39;t go back to fullscreen.
6098             // Also set the controls attribute so the user will be able to control playback.
6099             m_temporarilyAllowingInlinePlaybackAfterFullscreen = true;
6100             setControls(true);
6101         }
6102     }
6103 
6104 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6105     if (document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
6106         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(downcast&lt;HTMLVideoElement&gt;(*this), VideoFullscreenModeNone);
6107     else
6108 #endif
6109     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(oldVideoFullscreenMode)) {
6110         if (m_videoFullscreenStandby)
6111             document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6112         else
6113             document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6114         scheduleEvent(eventNames().webkitendfullscreenEvent);
<span class="line-removed">6115         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);</span>
6116     }
6117 }
6118 
6119 WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
6120 {
6121     ASSERT(is&lt;HTMLVideoElement&gt;(*this));
6122     if (m_videoFullscreenStandby == value)
6123         return;
6124 
6125     if (!document().page())
6126         return;
6127 
6128     if (!document().page()-&gt;chrome().client().supportsVideoFullscreenStandby())
6129         return;
6130 
6131     m_videoFullscreenStandby = value;
6132 
6133 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6134     if (m_player)
6135         m_player-&gt;videoFullscreenStandbyChanged();
</pre>
<hr />
<pre>
6410 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; HTMLMediaElement::originsInMediaCache(const String&amp; path)
6411 {
6412     return MediaPlayer::originsInMediaCache(path);
6413 }
6414 
6415 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6416 {
6417     MediaPlayer::clearMediaCache(path, modifiedSince);
6418 }
6419 
6420 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6421 {
6422     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6423 }
6424 
6425 void HTMLMediaElement::resetMediaEngines()
6426 {
6427     MediaPlayer::resetMediaEngines();
6428 }
6429 
<span class="line-modified">6430 void HTMLMediaElement::privateBrowsingStateDidChange()</span>
6431 {
6432     if (!m_player)
6433         return;
6434 
<span class="line-modified">6435     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();</span>
<span class="line-removed">6436     m_player-&gt;setPrivateBrowsingMode(privateMode);</span>
6437 }
6438 
6439 MediaControls* HTMLMediaElement::mediaControls() const
6440 {
6441 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6442     return nullptr;
6443 #else
6444     auto root = userAgentShadowRoot();
6445     if (!root)
6446         return nullptr;
6447 
6448     return childrenOfType&lt;MediaControls&gt;(*root).first();
6449 #endif
6450 }
6451 
6452 bool HTMLMediaElement::hasMediaControls() const
6453 {
6454 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6455     return false;
6456 #else
</pre>
<hr />
<pre>
6659 
6660 #if ENABLE(WEB_AUDIO)
6661     if (m_audioSourceNode)
6662         m_audioSourceNode-&gt;lock();
6663 #endif
6664 
6665 #if ENABLE(MEDIA_SOURCE)
6666     detachMediaSource();
6667 #endif
6668 
6669 #if ENABLE(VIDEO_TRACK)
6670     forgetResourceSpecificTracks();
6671 #endif
6672 
6673 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6674     if (m_isPlayingToWirelessTarget)
6675         setIsPlayingToWirelessTarget(false);
6676 #endif
6677 
6678     m_player = MediaPlayer::create(*this);
<span class="line-modified">6679     m_player-&gt;setShouldBufferData(m_shouldBufferData);</span>
6680     schedulePlaybackControlsManagerUpdate();
6681 
6682 #if ENABLE(WEB_AUDIO)
6683     if (m_audioSourceNode) {
6684         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6685         if (audioSourceProvider())
6686             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6687 
6688         m_audioSourceNode-&gt;unlock();
6689     }
6690 #endif
6691 
6692 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6693     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
6694         m_hasPlaybackTargetAvailabilityListeners = true;
6695         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6696         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6697     }
6698 #endif
6699 
</pre>
<hr />
<pre>
6877 {
6878     auto* track = item.get();
6879     return track-&gt;privateTrack().type() == RealtimeMediaSource::Type::Video &amp;&amp; !track-&gt;isCaptureTrack() &amp;&amp; !track-&gt;isCanvas();
6880 }
6881 #endif
6882 
6883 HTMLMediaElement::SleepType HTMLMediaElement::shouldDisableSleep() const
6884 {
6885 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(GTK) &amp;&amp; !PLATFORM(WPE)
6886     return SleepType::None;
6887 #endif
6888     if (!m_player || m_player-&gt;paused() || loop())
6889         return SleepType::None;
6890 
6891 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6892     // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
6893     if (m_isPlayingToWirelessTarget)
6894         return SleepType::System;
6895 #endif
6896 
<span class="line-modified">6897     bool shouldBeAbleToSleep = !hasVideo() || !hasAudio();</span>



6898 #if ENABLE(MEDIA_STREAM)
6899     // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
6900     // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
6901     shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
6902 #endif
6903 
6904     if (shouldBeAbleToSleep)
6905         return SleepType::None;
6906 
6907     if (m_elementIsHidden)
6908         return SleepType::System;
6909 
6910     return SleepType::Display;
6911 }
6912 
6913 String HTMLMediaElement::mediaPlayerReferrer() const
6914 {
6915     RefPtr&lt;Frame&gt; frame = document().frame();
6916     if (!frame)
6917         return String();
</pre>
<hr />
<pre>
7064 {
7065     return paused();
7066 }
7067 
7068 bool HTMLMediaElement::mediaPlayerIsLooping() const
7069 {
7070     return loop();
7071 }
7072 
7073 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7074 {
7075     return &amp;document().cachedResourceLoader();
7076 }
7077 
7078 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7079 {
7080     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7081 
7082     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7083 
<span class="line-modified">7084     return WTFMove(mediaResourceLoader);</span>
7085 }
7086 
7087 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7088 {
7089     return m_lastMediaResourceLoaderForTesting.get();
7090 }
7091 
7092 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7093 {
7094     if (Page* page = document().page())
7095         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();
7096 
7097     return false;
7098 }
7099 
7100 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7101 {
7102     return mediaCacheDirectory();
7103 }
7104 
7105 String HTMLMediaElement::sourceApplicationIdentifier() const
7106 {
7107     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7108         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7109             return networkingContext-&gt;sourceApplicationIdentifier();
7110     }
7111     return emptyString();
7112 }
7113 
7114 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7115 {
<span class="line-removed">7116 #if ENABLE(VIDEO_TRACK)</span>
7117     if (Page* page = document().page())
7118         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<span class="line-removed">7119 #endif</span>
7120     return Vector&lt;String&gt;();
7121 }
7122 
7123 #if PLATFORM(IOS_FAMILY)
7124 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7125 {
7126     return DeprecatedGlobalSettings::networkInterfaceName();
7127 }
7128 
7129 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7130 {
7131     if (auto* page = document().page())
7132         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7133     return false;
7134 }
7135 #endif
7136 
7137 bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const
7138 {
7139     return document().isMediaDocument();
</pre>
<hr />
<pre>
7165 
7166     if (m_loadState == LoadingFromSourceElement &amp;&amp; m_currentSourceNode &amp;&amp; !m_nextChildNodeToConsider)
7167         return false;
7168 
7169     if (m_loadState == LoadingFromSrcAttr)
7170         return false;
7171 
7172     return true;
7173 }
7174 
7175 #if USE(GSTREAMER)
7176 void HTMLMediaElement::requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback)
7177 {
7178     if (!document().page())
7179         return;
7180 
7181     document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
7182 }
7183 #endif
7184 
<span class="line-modified">7185 void HTMLMediaElement::removeBehaviorsRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
7186 {
7187     MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
7188         (MediaElementSession::RequireUserGestureForLoad
7189 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7190         | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
7191         | MediaElementSession::RequireUserGestureToAutoplayToExternalDevice
7192 #endif
7193         | MediaElementSession::RequireUserGestureForVideoRateChange
7194         | MediaElementSession::RequireUserGestureForAudioRateChange
7195         | MediaElementSession::RequireUserGestureForFullscreen
7196         | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
7197         | MediaElementSession::InvisibleAutoplayNotPermitted
7198         | MediaElementSession::RequireUserGestureToControlControlsManager);
7199 


7200     m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
7201     document().topDocument().noteUserInteractionWithMediaElement();
7202 }
7203 
7204 void HTMLMediaElement::updateRateChangeRestrictions()
7205 {
7206     const auto&amp; document = this-&gt;document();
7207     if (!document.ownerElement() &amp;&amp; document.isMediaDocument())
7208         return;
7209 
7210     const auto&amp; topDocument = document.topDocument();
7211     if (topDocument.videoPlaybackRequiresUserGesture())
7212         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7213     else
7214         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7215 
7216     if (topDocument.audioPlaybackRequiresUserGesture())
7217         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7218     else
7219         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
</pre>
<hr />
<pre>
7229         return VideoPlaybackQuality::create(timestamp, { });
7230 
7231 #if ENABLE(MEDIA_SOURCE)
7232     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7233     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7234 #endif
7235 
7236     return VideoPlaybackQuality::create(timestamp, metrics.value());
7237 }
7238 
7239 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7240 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7241 {
7242     if (!m_isolatedWorld)
7243         m_isolatedWorld = DOMWrapperWorld::create(commonVM());
7244     return *m_isolatedWorld;
7245 }
7246 
7247 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7248 {
<span class="line-modified">7249     DEBUG_LOG(LOGIDENTIFIER);</span>
7250 
7251     Page* page = document().page();
7252     if (!page)
7253         return false;
7254 
7255     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7256     if (!mediaControlsScript.length())
7257         return false;
7258 
7259     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
7260         auto&amp; vm = globalObject.vm();
7261         auto scope = DECLARE_CATCH_SCOPE(vm);
7262 
<span class="line-modified">7263         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
7264         if (functionValue.isFunction(vm))
7265             return true;
7266 
7267 #ifndef NDEBUG
7268         // Setting a scriptURL allows the source to be debuggable in the inspector.
7269         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7270 #else
7271         URL scriptURL;
7272 #endif
7273         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);
7274         if (UNLIKELY(scope.exception())) {
7275             scope.clearException();
7276             return false;
7277         }
7278 
7279         return true;
7280     });
7281 }
7282 
7283 void HTMLMediaElement::updatePageScaleFactorJSProperty()
</pre>
<hr />
<pre>
7295     if (!page)
7296         return;
7297 
7298     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7299     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7300 }
7301 
7302 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7303 {
7304     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7305         auto&amp; vm = globalObject.vm();
7306         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7307         if (controllerValue.isNull())
7308             return false;
7309 
7310         JSC::PutPropertySlot propertySlot(controllerValue);
7311         auto* controllerObject = controllerValue.toObject(&amp;exec);
7312         if (!controllerObject)
7313             return false;
7314 
<span class="line-modified">7315         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(&amp;exec, propertyName), propertyValue, propertySlot);</span>
7316 
7317         return true;
7318     });
7319 }
7320 
7321 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7322 {
<span class="line-modified">7323     DEBUG_LOG(LOGIDENTIFIER);</span>
7324 
7325     if (!ensureMediaControlsInjectedScript())
7326         return;
7327 
7328     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7329         auto&amp; vm = globalObject.vm();
7330         auto scope = DECLARE_CATCH_SCOPE(vm);
7331 
7332         // The media controls script must provide a method with the following details.
7333         // Name: createControls
7334         // Parameters:
7335         //     1. The ShadowRoot element that will hold the controls.
7336         //     2. This object (and HTMLMediaElement).
7337         //     3. The MediaControlsHost object.
7338         // Return value:
7339         //     A reference to the created media controller instance.
7340 
<span class="line-modified">7341         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;createControls&quot;));</span>
7342         if (functionValue.isUndefinedOrNull())
7343             return false;
7344 
7345         if (!m_mediaControlsHost)
7346             m_mediaControlsHost = MediaControlsHost::create(this);
7347 
7348         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);
7349         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);
7350 
7351         JSC::MarkedArgumentBuffer argList;
7352         argList.append(toJS(&amp;exec, &amp;globalObject, root));
7353         argList.append(mediaJSWrapper);
7354         argList.append(mediaControlsHostJSWrapper);
7355         ASSERT(!argList.hasOverflowed());
7356 
7357         auto* function = functionValue.toObject(&amp;exec);
7358         scope.assertNoException();
7359         JSC::CallData callData;
7360         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7361         if (callType == JSC::CallType::None)
7362             return false;
7363 
7364         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);
7365         scope.clearException();
7366         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7367         if (!controllerObject)
7368             return false;
7369 
7370         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
7371         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
7372         scope.assertNoException();
<span class="line-modified">7373         auto controlsHost = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controlsHost&quot;);</span>
7374 
7375         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
7376 
<span class="line-modified">7377         mediaJSWrapperObject-&gt;putDirect(exec.vm(), controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7378 
7379         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7380         if (!mediaControlsHostJSWrapperObject)
7381             return false;
7382 
<span class="line-modified">7383         auto controller = JSC::Identifier::fromString(&amp;exec.vm(), &quot;controller&quot;);</span>
7384 
7385         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
7386 
<span class="line-modified">7387         mediaControlsHostJSWrapperObject-&gt;putDirect(exec.vm(), controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7388 
7389         updatePageScaleFactorJSProperty();
7390         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7391 
7392         if (UNLIKELY(scope.exception()))
7393             scope.clearException();
7394 
7395         return true;
7396     });
7397 }
7398 
7399 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7400 {
<span class="line-modified">7401     DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, dependsOnPageScale);</span>
7402 
7403     if (document().settings().mediaControlsScaleWithPageZoom()) {
<span class="line-modified">7404         DEBUG_LOG(LOGIDENTIFIER, &quot;MediaElement::setMediaControlsDependPageScaleFactor&quot;, &quot;forced to false by Settings value&quot;);</span>
7405         m_mediaControlsDependOnPageScaleFactor = false;
7406         return;
7407     }
7408 
7409     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
7410         return;
7411 
7412     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
7413 
7414     if (m_mediaControlsDependOnPageScaleFactor)
7415         document().registerForPageScaleFactorChangedCallbacks(*this);
7416     else
7417         document().unregisterForPageScaleFactorChangedCallbacks(*this);
7418 }
7419 
7420 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7421 {
7422     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7423     // stopped/suspended the object.
7424     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7425         return;
7426 



7427     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7428         auto&amp; vm = globalObject.vm();
7429         auto scope = DECLARE_THROW_SCOPE(vm);
7430 
7431         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7432         auto* controllerObject = controllerValue.toObject(&amp;exec);
7433 
7434         RETURN_IF_EXCEPTION(scope, false);
7435 
<span class="line-modified">7436         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;handlePresentationModeChange&quot;));</span>
7437         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7438             return false;
7439 
7440         auto* function = functionValue.toObject(&amp;exec);
7441         scope.assertNoException();
7442         JSC::CallData callData;
7443         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7444         if (callType == JSC::CallType::None)
7445             return false;
7446 
7447         JSC::MarkedArgumentBuffer argList;
7448         ASSERT(!argList.hasOverflowed());
7449         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7450 
7451         return true;
7452     });
7453 }
7454 
7455 void HTMLMediaElement::pageScaleFactorChanged()
7456 {
</pre>
<hr />
<pre>
7459 
7460 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7461 {
7462     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7463 }
7464 
7465 String HTMLMediaElement::getCurrentMediaControlsStatus()
7466 {
7467     ensureMediaControlsShadowRoot();
7468 
7469     String status;
7470     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7471         auto&amp; vm = globalObject.vm();
7472         auto scope = DECLARE_THROW_SCOPE(vm);
7473 
7474         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7475         auto* controllerObject = controllerValue.toObject(&amp;exec);
7476 
7477         RETURN_IF_EXCEPTION(scope, false);
7478 
<span class="line-modified">7479         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(&amp;exec, &quot;getCurrentControlsStatus&quot;));</span>
7480         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7481             return false;
7482 
7483         auto* function = functionValue.toObject(&amp;exec);
7484         scope.assertNoException();
7485         JSC::CallData callData;
7486         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7487         JSC::MarkedArgumentBuffer argList;
7488         ASSERT(!argList.hasOverflowed());
7489         if (callType == JSC::CallType::None)
7490             return false;
7491 
7492         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7493 
7494         RETURN_IF_EXCEPTION(scope, false);
7495 
7496         status = outputValue.getString(&amp;exec);
7497         return true;
7498     });
7499 
</pre>
<hr />
<pre>
7606 }
7607 
7608 String HTMLMediaElement::mediaSessionTitle() const
7609 {
7610     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7611         return emptyString();
7612 
7613     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7614     if (!title.isEmpty())
7615         return title;
7616 
7617     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7618     if (!title.isEmpty())
7619         return title;
7620 
7621     title = m_currentSrc.host().toString();
7622 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
7623     if (!title.isEmpty())
7624         title = decodeHostName(title);
7625 #endif
<span class="line-removed">7626 #if ENABLE(PUBLIC_SUFFIX_LIST)</span>
7627     if (!title.isEmpty()) {
<span class="line-modified">7628         auto domain = topPrivatelyControlledDomain(title);</span>
7629         if (!domain.isEmpty())
<span class="line-modified">7630             title = domain;</span>
7631     }
<span class="line-removed">7632 #endif</span>
7633 
7634     return title;
7635 }
7636 
7637 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7638 {
7639     auto&amp; url = m_currentSrc.string();
7640     return url.impl() ? url.impl()-&gt;hash() : 0;
7641 }
7642 
7643 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7644 {
7645     INFO_LOG(LOGIDENTIFIER, command);
7646 
7647     UserGestureIndicator remoteControlUserGesture(ProcessingUserGesture, &amp;document());
7648     switch (command) {
7649     case PlatformMediaSession::PlayCommand:
7650         play();
7651         break;
7652     case PlatformMediaSession::StopCommand:
</pre>
<hr />
<pre>
7659     case PlatformMediaSession::BeginSeekingBackwardCommand:
7660         beginScanning(Backward);
7661         break;
7662     case PlatformMediaSession::BeginSeekingForwardCommand:
7663         beginScanning(Forward);
7664         break;
7665     case PlatformMediaSession::EndSeekingBackwardCommand:
7666     case PlatformMediaSession::EndSeekingForwardCommand:
7667         endScanning();
7668         break;
7669     case PlatformMediaSession::SeekToPlaybackPositionCommand:
7670         ASSERT(argument);
7671         if (argument)
7672             handleSeekToPlaybackPosition(argument-&gt;asDouble);
7673         break;
7674     default:
7675         { } // Do nothing
7676     }
7677 }
7678 
<span class="line-removed">7679 static bool needsSeekingSupportQuirk(Document&amp; document)</span>
<span class="line-removed">7680 {</span>
<span class="line-removed">7681     if (!document.settings().needsSiteSpecificQuirks())</span>
<span class="line-removed">7682         return false;</span>
<span class="line-removed">7683 </span>
<span class="line-removed">7684     auto host = document.topDocument().url().host();</span>
<span class="line-removed">7685     return equalLettersIgnoringASCIICase(host, &quot;netflix.com&quot;) || host.endsWithIgnoringASCIICase(&quot;.netflix.com&quot;);</span>
<span class="line-removed">7686 }</span>
<span class="line-removed">7687 </span>
7688 bool HTMLMediaElement::supportsSeeking() const
7689 {
<span class="line-modified">7690     return !needsSeekingSupportQuirk(document()) &amp;&amp; !isLiveStream();</span>
7691 }
7692 
7693 bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
7694 {
7695     if (type == PlatformMediaSession::EnteringBackground) {
7696         if (isPlayingToExternalTarget()) {
7697             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7698             return true;
7699         }




7700         if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7701             return true;
7702 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
7703         if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
7704             return true;
7705 #endif
7706     } else if (type == PlatformMediaSession::SuspendedUnderLock) {
7707         if (isPlayingToExternalTarget()) {
7708             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7709             return true;
7710         }




7711     }
7712     return false;
7713 }
7714 
7715 bool HTMLMediaElement::processingUserGestureForMedia() const
7716 {
7717     return document().processingUserGestureForMedia();
7718 }






7719 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7720 
7721 void HTMLMediaElement::scheduleUpdateMediaState()
7722 {
7723     if (m_updateMediaStateTask.hasPendingTask())
7724         return;
7725 
7726     auto logSiteIdentifier = LOGIDENTIFIER;
7727     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
7728     m_updateMediaStateTask.scheduleTask([this, logSiteIdentifier] {
7729         UNUSED_PARAM(logSiteIdentifier);
7730         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
7731         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaState calls methods that can trigger arbitrary DOM mutations.
7732         updateMediaState();
7733     });
7734 }
7735 
7736 void HTMLMediaElement::updateMediaState()
7737 {
7738     MediaProducer::MediaStateFlags state = mediaState();
</pre>
<hr />
<pre>
7827     ALWAYS_LOG(LOGIDENTIFIER, reason);
7828 
7829     m_autoplayEventPlaybackState = reason;
7830 
7831     if (reason == AutoplayEventPlaybackState::PreventedAutoplay) {
7832         dispatchPlayPauseEventsIfNeedsQuirks();
7833         handleAutoplayEvent(AutoplayEvent::DidPreventMediaFromPlaying);
7834     }
7835 }
7836 
7837 void HTMLMediaElement::pageMutedStateDidChange()
7838 {
7839     updateVolume();
7840 
7841     if (Page* page = document().page()) {
7842         if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
7843             userDidInterfereWithAutoplay();
7844     }
7845 }
7846 














7847 bool HTMLMediaElement::effectiveMuted() const
7848 {
<span class="line-modified">7849     return muted() || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
7850 }
7851 
<span class="line-modified">7852 bool HTMLMediaElement::doesHaveAttribute(const AtomicString&amp; attribute, AtomicString* value) const</span>
7853 {
7854     QualifiedName attributeName(nullAtom(), attribute, nullAtom());
7855 
7856     auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
7857     if (elementValue.isNull())
7858         return false;
7859 
7860     if (attributeName == HTMLNames::x_itunes_inherit_uri_query_componentAttr &amp;&amp; !document().settings().enableInheritURIQueryComponent())
7861         return false;
7862 
7863     if (value)
7864         *value = elementValue;
7865 
7866     return true;
7867 }
7868 
<span class="line-modified">7869 void HTMLMediaElement::setShouldBufferData(bool shouldBuffer)</span>
7870 {
<span class="line-modified">7871     if (shouldBuffer == m_shouldBufferData)</span>
7872         return;
7873 
<span class="line-modified">7874     m_shouldBufferData = shouldBuffer;</span>


7875     if (m_player)
<span class="line-modified">7876         m_player-&gt;setShouldBufferData(shouldBuffer);</span>
7877 }
7878 
7879 void HTMLMediaElement::purgeBufferedDataIfPossible()
7880 {
<span class="line-modified">7881 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">7882     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;dataBufferingPermitted())</span>

7883         return;
7884 
7885     if (isPlayingToExternalTarget()) {
7886         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7887         return;
7888     }
7889 
<span class="line-modified">7890     // This is called to relieve memory pressure. Turning off buffering causes the media playback</span>
<span class="line-removed">7891     // daemon to release memory associated with queued-up video frames.</span>
<span class="line-removed">7892     // We turn it back on right away, but new frames won&#39;t get loaded unless playback is resumed.</span>
<span class="line-removed">7893     INFO_LOG(LOGIDENTIFIER, &quot;toggling data buffering&quot;);</span>
<span class="line-removed">7894     setShouldBufferData(false);</span>
<span class="line-removed">7895     setShouldBufferData(true);</span>
<span class="line-removed">7896 #endif</span>
7897 }
7898 
7899 bool HTMLMediaElement::canSaveMediaData() const
7900 {
7901     if (m_player)
7902         return m_player-&gt;canSaveMediaData();
7903 
7904     return false;
7905 }
7906 
7907 #if ENABLE(MEDIA_SESSION)
7908 double HTMLMediaElement::playerVolume() const
7909 {
7910     return m_player ? m_player-&gt;volume() : 0;
7911 }
7912 
7913 MediaSession* HTMLMediaElement::session() const
7914 {
7915     RefPtr&lt;MediaSession&gt; session = m_session.get();
7916     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
</pre>
<hr />
<pre>
8098 {
8099     if (m_player)
8100         m_player-&gt;applicationWillResignActive();
8101 }
8102 
8103 void HTMLMediaElement::applicationDidBecomeActive()
8104 {
8105     if (m_player)
8106         m_player-&gt;applicationDidBecomeActive();
8107 }
8108 
8109 void HTMLMediaElement::setInActiveDocument(bool inActiveDocument)
8110 {
8111     if (inActiveDocument == m_inActiveDocument)
8112         return;
8113 
8114     m_inActiveDocument = inActiveDocument;
8115     m_mediaSession-&gt;inActiveDocumentChanged();
8116 }
8117 














8118 }
8119 
8120 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;HTMLMediaElement.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ApplicationCacheHost.h&quot;
  32 #include &quot;ApplicationCacheResource.h&quot;
  33 #include &quot;Attribute.h&quot;
  34 #include &quot;Blob.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CommonVM.h&quot;
<span class="line-added">  39 #include &quot;ContentRuleListResults.h&quot;</span>
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;ContentType.h&quot;
  42 #include &quot;CookieJar.h&quot;
<span class="line-added">  43 #include &quot;CustomHeaderFields.h&quot;</span>
  44 #include &quot;DeprecatedGlobalSettings.h&quot;
  45 #include &quot;DiagnosticLoggingClient.h&quot;
  46 #include &quot;DiagnosticLoggingKeys.h&quot;
  47 #include &quot;Document.h&quot;
  48 #include &quot;DocumentLoader.h&quot;
  49 #include &quot;ElementChildIterator.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameView.h&quot;
<span class="line-added">  55 #include &quot;FullscreenManager.h&quot;</span>
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSourceElement.h&quot;
  58 #include &quot;HTMLVideoElement.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;JSDOMException.h&quot;
  61 #include &quot;JSDOMPromiseDeferred.h&quot;
  62 #include &quot;JSHTMLMediaElement.h&quot;
  63 #include &quot;Logging.h&quot;
  64 #include &quot;MIMETypeRegistry.h&quot;
  65 #include &quot;MediaController.h&quot;
  66 #include &quot;MediaControls.h&quot;
  67 #include &quot;MediaDocument.h&quot;
  68 #include &quot;MediaError.h&quot;
  69 #include &quot;MediaFragmentURIParser.h&quot;
  70 #include &quot;MediaList.h&quot;
  71 #include &quot;MediaPlayer.h&quot;
  72 #include &quot;MediaQueryEvaluator.h&quot;
  73 #include &quot;MediaResourceLoader.h&quot;
  74 #include &quot;NetworkingContext.h&quot;
  75 #include &quot;Page.h&quot;
  76 #include &quot;PageGroup.h&quot;
  77 #include &quot;PlatformMediaSessionManager.h&quot;
  78 #include &quot;ProgressTracker.h&quot;

  79 #include &quot;Quirks.h&quot;
<span class="line-added">  80 #include &quot;RegistrableDomain.h&quot;</span>
  81 #include &quot;RenderLayerCompositor.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderVideo.h&quot;
  84 #include &quot;RenderView.h&quot;
  85 #include &quot;ResourceLoadInfo.h&quot;
  86 #include &quot;ScriptController.h&quot;
  87 #include &quot;ScriptDisallowedScope.h&quot;
  88 #include &quot;ScriptSourceCode.h&quot;
  89 #include &quot;SecurityOriginData.h&quot;
  90 #include &quot;SecurityPolicy.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;ShadowRoot.h&quot;
  93 #include &quot;TimeRanges.h&quot;
  94 #include &quot;UserContentController.h&quot;
  95 #include &quot;UserGestureIndicator.h&quot;
  96 #include &quot;VideoPlaybackQuality.h&quot;
  97 #include &lt;JavaScriptCore/Uint8Array.h&gt;
  98 #include &lt;limits&gt;
  99 #include &lt;pal/SessionID.h&gt;
 100 #include &lt;pal/system/SleepDisabler.h&gt;
</pre>
<hr />
<pre>
 127 #include &quot;RuntimeApplicationChecks.h&quot;
 128 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 129 #endif
 130 
 131 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 132 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 133 #endif
 134 
 135 #if ENABLE(MEDIA_SESSION)
 136 #include &quot;MediaSession.h&quot;
 137 #endif
 138 
 139 #if ENABLE(MEDIA_SOURCE)
 140 #include &quot;DOMWindow.h&quot;
 141 #include &quot;MediaSource.h&quot;
 142 #endif
 143 
 144 #if ENABLE(MEDIA_STREAM)
 145 #include &quot;DOMURL.h&quot;
 146 #include &quot;MediaStream.h&quot;

 147 #endif
 148 
 149 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 150 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 151 #include &quot;WebKitMediaKeys.h&quot;
 152 #endif
 153 
 154 #if ENABLE(ENCRYPTED_MEDIA)
 155 #include &quot;MediaEncryptedEvent.h&quot;
 156 #include &quot;MediaKeys.h&quot;
 157 #endif
 158 
 159 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 160 #include &quot;JSMediaControlsHost.h&quot;
 161 #include &quot;MediaControlsHost.h&quot;
 162 #include &lt;JavaScriptCore/ScriptObject.h&gt;
 163 #endif
 164 
 165 #if ENABLE(ENCRYPTED_MEDIA)
 166 #include &quot;NotImplemented.h&quot;
</pre>
<hr />
<pre>
 296 }
 297 
 298 #if ENABLE(VIDEO_TRACK)
 299 
 300 class TrackDisplayUpdateScope {
 301 public:
 302     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 303         : m_element(element)
 304     {
 305         m_element.beginIgnoringTrackDisplayUpdateRequests();
 306     }
 307     ~TrackDisplayUpdateScope()
 308     {
 309         m_element.endIgnoringTrackDisplayUpdateRequests();
 310     }
 311 
 312 private:
 313     HTMLMediaElement&amp; m_element;
 314 };
 315 
<span class="line-added"> 316 #endif</span>
 317 
 318 struct HTMLMediaElement::TrackGroup {
 319     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 320 
 321     TrackGroup(GroupKind kind)
 322         : kind(kind)
 323     {
 324     }
 325 
 326     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 327     RefPtr&lt;TextTrack&gt; visibleTrack;
 328     RefPtr&lt;TextTrack&gt; defaultTrack;
 329     GroupKind kind;
 330     bool hasSrcLang { false };
 331 };

 332 
 333 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 334 {
 335     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 336     return elements;
 337 }
 338 
 339 #if ENABLE(MEDIA_SESSION)
 340 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 341 
 342 static IDToElementMap&amp; elementIDsToElements()
 343 {
 344     static NeverDestroyed&lt;IDToElementMap&gt; map;
 345     return map;
 346 }
 347 
 348 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 349 {
 350     if (id == HTMLMediaElementInvalidID)
 351         return nullptr;
</pre>
<hr />
<pre>
 401     // As a tiebreaker, prioritize elements that the user recently interacted with.
 402     return session.timeOfLastUserInteraction &gt; otherSession.timeOfLastUserInteraction;
 403 }
 404 
 405 static bool mediaSessionMayBeConfusedWithMainContent(const MediaElementSessionInfo&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 406 {
 407     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying)
 408         return session.isPlayingAudio;
 409 
 410     if (!session.isVisibleInViewportOrFullscreen)
 411         return false;
 412 
 413     if (!session.isLargeEnoughForMainContent)
 414         return false;
 415 
 416     // Even if this video is not a candidate, if it is visible to the user and large enough
 417     // to be main content, it poses a risk for being confused with main content.
 418     return true;
 419 }
 420 








 421 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 422     : HTMLElement(tagName, document)
 423     , ActiveDOMObject(document)
 424     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 425     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 426     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 427     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 428     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
 429     , m_asyncEventQueue(*this)
 430     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 431     , m_firstTimePlaying(true)
 432     , m_playing(false)
 433     , m_isWaitingUntilMediaCanStart(false)
 434     , m_shouldDelayLoadEvent(false)
 435     , m_haveFiredLoadedData(false)
 436     , m_inActiveDocument(true)
 437     , m_autoplaying(true)
 438     , m_muted(false)
 439     , m_explicitlyMuted(false)
 440     , m_initiallyMuted(false)
 441     , m_paused(true)
 442     , m_seeking(false)
 443     , m_seekRequested(false)
 444     , m_sentStalledEvent(false)
 445     , m_sentEndEvent(false)
 446     , m_pausedInternal(false)
 447     , m_closedCaptionsVisible(false)
 448     , m_webkitLegacyClosedCaptionOverride(false)
 449     , m_completelyLoaded(false)
 450     , m_havePreparedToPlay(false)
 451     , m_parsingInProgress(createdByParser)

 452     , m_elementIsHidden(document.hidden())
 453     , m_creatingControls(false)
 454     , m_receivedLayoutSizeChanged(false)
 455     , m_hasEverNotifiedAboutPlaying(false)
 456     , m_hasEverHadAudio(false)
 457     , m_hasEverHadVideo(false)
 458 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 459     , m_mediaControlsDependOnPageScaleFactor(false)
 460     , m_haveSetUpCaptionContainer(false)
 461 #endif
 462     , m_isScrubbingRemotely(false)
 463 #if ENABLE(VIDEO_TRACK)
 464     , m_tracksAreReady(true)
 465     , m_haveVisibleTextTrack(false)
 466     , m_processingPreferenceChange(false)
 467 #endif
 468 #if !RELEASE_LOG_DISABLED
 469     , m_logger(&amp;document.logger())
<span class="line-modified"> 470     , m_logIdentifier(uniqueLogIdentifier())</span>
 471 #endif
 472 {
 473     allMediaElements().add(this);
 474 
 475     ALWAYS_LOG(LOGIDENTIFIER);
 476 
 477     setHasCustomStyleResolveCallbacks();
 478 
 479     InspectorInstrumentation::addEventListenersToNode(*this);
 480 }
 481 
 482 void HTMLMediaElement::finishInitialization()
 483 {
<span class="line-modified"> 484     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);</span>
 485 
 486     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 487     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
 488 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 489     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
 490 #endif
 491     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
 492     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
 493 
 494     auto&amp; document = this-&gt;document();
 495     auto* page = document.page();
 496 
 497     if (document.settings().invisibleAutoplayNotPermitted())
 498         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted);
 499 
 500     if (document.ownerElement() || !document.isMediaDocument()) {
 501         const auto&amp; topDocument = document.topDocument();
 502         const bool isProcessingUserGesture = processingUserGestureForMedia();
 503         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 504         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
</pre>
<hr />
<pre>
 637     m_resumeTaskQueue.close();
 638     m_promiseTaskQueue.close();
 639     m_pauseAfterDetachedTaskQueue.close();
 640     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
 641     m_resourceSelectionTaskQueue.close();
 642     m_visibilityChangeTaskQueue.close();
 643 #if ENABLE(ENCRYPTED_MEDIA)
 644     m_encryptedMediaQueue.close();
 645 #endif
 646 
 647     m_completelyLoaded = true;
 648 
 649     if (m_player) {
 650         m_player-&gt;invalidate();
 651         m_player = nullptr;
 652     }
 653 
 654     m_mediaSession = nullptr;
 655     schedulePlaybackControlsManagerUpdate();
 656 }











 657 RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
 658 {




 659     Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
 660     bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
<span class="line-modified"> 661     PlatformMediaSessionManager::sharedManager().forEachMatchingSession([](auto&amp; session) {</span>
<span class="line-modified"> 662         return is&lt;MediaElementSession&gt;(session);</span>
<span class="line-added"> 663     }, [&amp;](auto&amp; session) {</span>
<span class="line-added"> 664         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);</span>
 665         if (mediaElementSessionInfo.canShowControlsManager)
 666             candidateSessions.append(mediaElementSessionInfo);
 667         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 668             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
<span class="line-modified"> 669     });</span>
 670 
 671     if (!candidateSessions.size())
 672         return nullptr;
 673 
 674     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 675     auto strongestSessionCandidate = candidateSessions.first();
 676     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 677         return nullptr;
 678 
 679     return &amp;strongestSessionCandidate.session-&gt;element();
 680 }
 681 
 682 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 683 {
 684     m_mediaSession-&gt;registerWithDocument(document);
 685 
 686     if (m_isWaitingUntilMediaCanStart)
 687         document.addMediaCanStartListener(*this);
 688 
 689 #if !PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
 786 {
 787     m_mediaSession-&gt;registerWithDocument(document());
 788     updateShouldAutoplay();
 789 }
 790 #endif
 791 
 792 bool HTMLMediaElement::supportsFocus() const
 793 {
 794     if (document().isMediaDocument())
 795         return false;
 796 
 797     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 798     return controls() ||  HTMLElement::supportsFocus();
 799 }
 800 
 801 bool HTMLMediaElement::isMouseFocusable() const
 802 {
 803     return false;
 804 }
 805 
<span class="line-modified"> 806 bool HTMLMediaElement::isInteractiveContent() const</span>
<span class="line-added"> 807 {</span>
<span class="line-added"> 808     return controls();</span>
<span class="line-added"> 809 }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)</span>
 812 {
 813     if (name == srcAttr) {
 814         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 815         // Location of the Media Resource
 816         // 12 February 2017
 817 
 818         // If a src attribute of a media element is set or changed, the user
 819         // agent must invoke the media element&#39;s media element load algorithm.
 820         if (!value.isNull())
 821             prepareForLoad();
 822     } else if (name == controlsAttr)
 823         configureMediaControls();
 824     else if (name == loopAttr)
 825         updateSleepDisabling();
 826     else if (name == preloadAttr) {
 827         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
 828             m_preload = MediaPlayer::None;
 829         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
 830             m_preload = MediaPlayer::MetaData;
 831         else {
 832             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 833             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
 834             m_preload = MediaPlayer::Auto;
 835         }
 836 
 837         // The attribute must be ignored if the autoplay attribute is present
 838         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 839             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 840 
 841     } else if (name == mediagroupAttr)
 842         setMediaGroup(value);
 843     else if (name == autoplayAttr) {
 844         if (processingUserGestureForMedia())
<span class="line-modified"> 845             removeBehaviorRestrictionsAfterFirstUserGesture();</span>
 846     } else if (name == titleAttr) {
 847         if (m_mediaSession)
 848             m_mediaSession-&gt;clientCharacteristicsChanged();
 849     }
 850     else
 851         HTMLElement::parseAttribute(name, value);
 852 }
 853 
 854 void HTMLMediaElement::finishParsingChildren()
 855 {
 856     HTMLElement::finishParsingChildren();
 857     m_parsingInProgress = false;
 858 
 859 #if ENABLE(VIDEO_TRACK)
 860     if (childrenOfType&lt;HTMLTrackElement&gt;(*this).first())
 861         scheduleConfigureTextTracks();
 862 #endif
 863 }
 864 
 865 bool HTMLMediaElement::rendererIsNeeded(const RenderStyle&amp; style)
</pre>
<hr />
<pre>
 997 
 998 void HTMLMediaElement::didRecalcStyle(Style::Change)
 999 {
1000     updateRenderer();
1001 }
1002 
1003 void HTMLMediaElement::scheduleNextSourceChild()
1004 {
1005     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
1006     m_resourceSelectionTaskQueue.enqueueTask([this] {
1007         loadNextSourceChild();
1008     });
1009 }
1010 
1011 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*)
1012 {
1013     m_hasEverHadAudio |= hasAudio();
1014     m_hasEverHadVideo |= hasVideo();
1015 }
1016 
<span class="line-modified">1017 void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)</span>
1018 {
1019     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
1020 
1021     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
1022     // will trigger an ASSERT if this element has been marked for deletion.
1023 
1024     m_asyncEventQueue.enqueueEvent(WTFMove(event));
1025 }
1026 
1027 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
1028 {
1029     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1030         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1031     });
1032 }
1033 
1034 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
1035 {
1036     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1037         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
</pre>
<hr />
<pre>
1073     return m_hasEverNotifiedAboutPlaying;
1074 }
1075 
1076 void HTMLMediaElement::scheduleCheckPlaybackTargetCompatability()
1077 {
1078     if (m_checkPlaybackTargetCompatablityTask.hasPendingTask())
1079         return;
1080 
1081     auto logSiteIdentifier = LOGIDENTIFIER;
1082     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1083     m_checkPlaybackTargetCompatablityTask.scheduleTask([this, logSiteIdentifier] {
1084         UNUSED_PARAM(logSiteIdentifier);
1085         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1086         checkPlaybackTargetCompatablity();
1087     });
1088 }
1089 
1090 void HTMLMediaElement::checkPlaybackTargetCompatablity()
1091 {
1092 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-added">1093     auto logSiteIdentifier = LOGIDENTIFIER;</span>
<span class="line-added">1094     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);</span>
1095     if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
<span class="line-modified">1096         UNUSED_PARAM(logSiteIdentifier);</span>
<span class="line-added">1097         INFO_LOG(logSiteIdentifier, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
1098         m_failedToPlayToWirelessTarget = true;
1099         m_player-&gt;setShouldPlayToPlaybackTarget(false);
1100     }
1101 #endif
1102 }
1103 
1104 MediaError* HTMLMediaElement::error() const
1105 {
1106     return m_error.get();
1107 }
1108 
1109 void HTMLMediaElement::setSrcObject(MediaProvider&amp;&amp; mediaProvider)
1110 {
1111     // FIXME: Setting the srcObject attribute may cause other changes to the media element&#39;s internal state:
1112     // Specifically, if srcObject is specified, the UA must use it as the source of media, even if the src
1113     // attribute is also set or children are present. If the value of srcObject is replaced or set to null
1114     // the UA must re-run the media element load algorithm.
1115     //
1116     // https://bugs.webkit.org/show_bug.cgi?id=124896
1117 
1118 
1119     // https://www.w3.org/TR/html51/semantics-embedded-content.html#dom-htmlmediaelement-srcobject
1120     // 4.7.14.2. Location of the media resource
1121     // srcObject: On setting, it must set the element’s assigned media provider object to the new
1122     // value, and then invoke the element’s media element load algorithm.
1123     INFO_LOG(LOGIDENTIFIER);
1124     m_mediaProvider = WTFMove(mediaProvider);
1125     prepareForLoad();
1126 }
1127 
<span class="line-modified">1128 void HTMLMediaElement::setCrossOrigin(const AtomString&amp; value)</span>
1129 {
1130     setAttributeWithoutSynchronization(crossoriginAttr, value);
1131 }
1132 
1133 String HTMLMediaElement::crossOrigin() const
1134 {
1135     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1136 }
1137 
1138 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1139 {
1140     return m_networkState;
1141 }
1142 
1143 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1144 {
1145     MediaEngineSupportParameters parameters;
1146     ContentType contentType(mimeType);
1147     parameters.type = contentType;
1148     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1149     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1150     String canPlay;
1151 
1152     // 4.8.10.3
1153     switch (support)
1154     {
1155         case MediaPlayer::IsNotSupported:
1156             canPlay = emptyString();
1157             break;
1158         case MediaPlayer::MayBeSupported:
1159             canPlay = &quot;maybe&quot;_s;
1160             break;
1161         case MediaPlayer::IsSupported:
1162             canPlay = &quot;probably&quot;_s;
1163             break;
1164     }
1165 
<span class="line-modified">1166     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);</span>
1167 
1168     return canPlay;
1169 }
1170 
1171 double HTMLMediaElement::getStartDate() const
1172 {
1173     if (!m_player)
1174         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1175     return m_player-&gt;getStartDate().toDouble();
1176 }
1177 
1178 void HTMLMediaElement::load()
1179 {
1180     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1181 
1182     INFO_LOG(LOGIDENTIFIER);
1183 



1184     prepareForLoad();
1185     m_resourceSelectionTaskQueue.enqueueTask([this] {
1186         prepareToPlay();
1187     });
1188 }
1189 
1190 void HTMLMediaElement::prepareForLoad()
1191 {
1192     // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
1193     // The Media Element Load Algorithm
1194     // 12 February 2017
1195 
<span class="line-modified">1196     ALWAYS_LOG(LOGIDENTIFIER, &quot;gesture = &quot;, processingUserGestureForMedia());</span>
<span class="line-added">1197 </span>
<span class="line-added">1198     if (processingUserGestureForMedia())</span>
<span class="line-added">1199         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
1200 
1201     // 1 - Abort any already-running instance of the resource selection algorithm for this element.
1202     // Perform the cleanup required for the resource load algorithm to run.
1203     stopPeriodicTimers();
1204     m_resourceSelectionTaskQueue.cancelAllTasks();
1205     // FIXME: Figure out appropriate place to reset LoadTextTrackResource if necessary and set m_pendingActionFlags to 0 here.
1206     m_sentEndEvent = false;
1207     m_sentStalledEvent = false;
1208     m_haveFiredLoadedData = false;
1209     m_completelyLoaded = false;
1210     m_havePreparedToPlay = false;
1211     m_displayMode = Unknown;
1212     m_currentSrc = URL();
1213 
1214 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1215     m_failedToPlayToWirelessTarget = false;
1216 #endif
1217 
1218     m_loadState = WaitingForSource;
1219     m_currentSourceNode = nullptr;
</pre>
<hr />
<pre>
1229     cancelPendingEventsAndCallbacks();
1230 
1231     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1232     // a task to fire a simple event named abort at the media element.
1233     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1234         scheduleEvent(eventNames().abortEvent);
1235 
1236     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1237     if (m_networkState != NETWORK_EMPTY) {
1238         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1239         scheduleEvent(eventNames().emptiedEvent);
1240 
1241         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1242         m_networkState = NETWORK_EMPTY;
1243 
1244         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1245 #if ENABLE(MEDIA_SOURCE)
1246         detachMediaSource();
1247 #endif
1248 

1249         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1250         forgetResourceSpecificTracks();

1251 
1252         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1253         m_readyState = HAVE_NOTHING;
1254         m_readyStateMaximum = HAVE_NOTHING;
1255 
1256         // 6.6 - If the paused attribute is false, then set it to true.
1257         m_paused = true;
1258 
1259         // 6.7 - If seeking is true, set it to false.
1260         clearSeeking();
1261 
1262         // 6.8 - Set the current playback position to 0.
1263         //       Set the official playback position to 0.
1264         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1265         m_lastSeekTime = MediaTime::zeroTime();
1266         m_playedTimeRanges = TimeRanges::create();
1267         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1268 
1269         // 4.9 - Set the initial playback position to 0.
1270         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
</pre>
<hr />
<pre>
1484 {
1485     ContentType contentType;
1486     String keySystem;
1487     URL mediaURL = selectNextSourceChild(&amp;contentType, &amp;keySystem, Complain);
1488     if (!mediaURL.isValid()) {
1489         waitForSourceChange();
1490         return;
1491     }
1492 
1493     // Recreate the media player for the new url
1494     createMediaPlayer();
1495 
1496     m_loadState = LoadingFromSourceElement;
1497     loadResource(mediaURL, contentType, keySystem);
1498 }
1499 
1500 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1501 {
1502     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1503 
<span class="line-modified">1504     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);</span>
1505 
1506     RefPtr&lt;Frame&gt; frame = document().frame();
1507     if (!frame) {
1508         mediaLoadingFailed(MediaPlayer::FormatError);
1509         return;
1510     }
1511 
1512     Page* page = frame-&gt;page();
1513     if (!page) {
1514         mediaLoadingFailed(MediaPlayer::FormatError);
1515         return;
1516     }
1517 
1518     URL url = initialURL;
1519     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
1520         mediaLoadingFailed(MediaPlayer::FormatError);
1521         return;
1522     }
1523 
1524 #if ENABLE(CONTENT_EXTENSIONS)
1525     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
<span class="line-modified">1526         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {</span>
1527             mediaLoadingFailed(MediaPlayer::FormatError);
1528             return;
1529         }
1530     }
1531 #endif
1532 
1533     // The resource fetch algorithm
1534     m_networkState = NETWORK_LOADING;
1535 
1536     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1537     ApplicationCacheResource* resource = nullptr;
1538     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1539         // Resources that are not present in the manifest will always fail to load (at least, after the
1540         // cache has been primed the first time), making the testing of offline applications simpler.
1541         if (!resource || resource-&gt;path().isEmpty()) {
1542             mediaLoadingFailed(MediaPlayer::NetworkError);
1543             return;
1544         }
1545     }
1546 
1547     // Log that we started loading a media element.
1548     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1549 
1550     m_firstTimePlaying = true;
1551 
1552     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1553     // cache is an internal detail not exposed through the media element API.
1554     m_currentSrc = url;
1555 
1556     if (resource) {
1557         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
<span class="line-modified">1558         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);</span>
1559     }
1560 
1561     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1562 
1563     startProgressEventTimer();
1564 
1565     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();
1566     m_player-&gt;setPrivateBrowsingMode(privateMode);
1567 
1568     // Reset display mode to force a recalculation of what to show because we are resetting the player.
1569     setDisplayMode(Unknown);
1570 
1571     if (!autoplay() &amp;&amp; !m_havePreparedToPlay)
1572         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1573     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1574 
1575     if (!m_explicitlyMuted) {
1576         m_explicitlyMuted = true;
1577         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1578         m_mediaSession-&gt;canProduceAudioChanged();
</pre>
<hr />
<pre>
1580 
1581     updateVolume();
1582 
1583     bool loadAttempted = false;
1584 #if ENABLE(MEDIA_SOURCE)
1585     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1586         m_mediaSource = MediaSource::lookup(url.string());
1587 
1588     if (m_mediaSource) {
1589         loadAttempted = true;
1590 
1591         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
1592         if (!m_mediaSource-&gt;attachToElement(*this) || !m_player-&gt;load(url, contentType, m_mediaSource.get())) {
1593             // Forget our reference to the MediaSource, so we leave it alone
1594             // while processing remainder of load failure.
1595             m_mediaSource = nullptr;
1596             mediaLoadingFailed(MediaPlayer::FormatError);
1597         }
1598     }
1599 #endif

1600 #if ENABLE(MEDIA_STREAM)
<span class="line-modified">1601     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {</span>
<span class="line-modified">1602         loadAttempted = true;</span>
<span class="line-modified">1603         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);</span>
<span class="line-modified">1604         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))</span>
<span class="line-modified">1605             mediaLoadingFailed(MediaPlayer::FormatError);</span>





1606     }
1607 #endif
1608 
1609     if (!loadAttempted &amp;&amp; m_blob) {
1610         loadAttempted = true;
1611         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1612         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
1613             mediaLoadingFailed(MediaPlayer::FormatError);
1614     }
1615 
1616     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
1617         mediaLoadingFailed(MediaPlayer::FormatError);
1618 
1619     // If there is no poster to display, allow the media engine to render video frames as soon as
1620     // they are available.
1621     updateDisplayState();
1622 
1623     updateRenderer();
1624 }
1625 
</pre>
<hr />
<pre>
1747 
1748         if (!cue-&gt;isActive())
1749             activeSetChanged = true;
1750     }
1751 
1752     MediaTime nextInterestingTime = MediaTime::invalidTime();
1753     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1754         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1755 
1756     Optional&lt;CueInterval&gt; nextCue = m_cueTree.nextIntervalAfter(movieTimeInterval);
1757     if (nextCue)
1758         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1759 
1760     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1761 
1762     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1763         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1764             if (!weakThis)
1765                 return;
1766 
<span class="line-modified">1767             auto currentMediaTime = this-&gt;currentMediaTime();</span>
<span class="line-modified">1768             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);</span>
<span class="line-modified">1769             this-&gt;updateActiveTextTrackCues(currentMediaTime);</span>
1770         }, nextInterestingTime);
1771     }
1772 
1773     if (!activeSetChanged)
1774         return;
1775 
1776     // 7 - If the time was reached through the usual monotonic increase of the
1777     // current playback position during normal playback, and there are cues in
1778     // other cues that have their text track cue pause-on-exi flag set and that
1779     // either have their text track cue active flag set or are also in missed
1780     // cues, then immediately pause the media element.
1781     for (size_t i = 0; !m_paused &amp;&amp; i &lt; previousCuesSize; ++i) {
1782         if (previousCues[i].data()-&gt;pauseOnExit()
1783             &amp;&amp; previousCues[i].data()-&gt;isActive()
1784             &amp;&amp; !currentCues.contains(previousCues[i]))
1785             pause();
1786     }
1787 
1788     for (size_t i = 0; !m_paused &amp;&amp; i &lt; missedCuesSize; ++i) {
1789         if (missedCues[i].data()-&gt;pauseOnExit())
</pre>
<hr />
<pre>
1931             mediaControls()-&gt;clearTextDisplayContainer();
1932         updateTextTrackDisplay();
1933     }
1934     if (m_player &amp;&amp; m_textTracksWhenResourceSelectionBegan.contains(track)) {
1935         if (track-&gt;readinessState() != TextTrack::Loading)
1936             setReadyState(m_player-&gt;readyState());
1937     } else {
1938         // The track readiness state might have changed as a result of the user
1939         // clicking the captions button. In this case, a check whether all the
1940         // resources have failed loading should be done in order to hide the CC button.
1941         if (hasMediaControls() &amp;&amp; track-&gt;readinessState() == TextTrack::FailedToLoad)
1942             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
1943     }
1944 }
1945 
1946 void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
1947 {
1948     if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
1949         m_audioTracks-&gt;scheduleChangeEvent();
1950     if (processingUserGestureForMedia())
<span class="line-modified">1951         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
1952 }
1953 
1954 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1955 {
1956     bool trackIsLoaded = true;
1957     if (track.trackType() == TextTrack::TrackElement) {
1958         trackIsLoaded = false;
1959         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1960             if (&amp;trackElement.track() == &amp;track) {
1961                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1962                     trackIsLoaded = true;
1963                 break;
1964             }
1965         }
1966     }
1967 
1968     // If this is the first added track, create the list of text tracks.
1969     if (!m_textTracks)
1970         m_textTracks = TextTrackList::create(this, ActiveDOMObject::scriptExecutionContext());
1971 
</pre>
<hr />
<pre>
2078 
2079 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2080 {
2081     // Elements in user agent show tree should load whatever the embedding document policy is.
2082     if (isInUserAgentShadowTree)
2083         return true;
2084 
2085     ASSERT(element.document().contentSecurityPolicy());
2086     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2087 }
2088 
2089 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2090 {
2091     if (!url.isValid()) {
2092         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2093         return false;
2094     }
2095 
2096     RefPtr&lt;Frame&gt; frame = document().frame();
2097     if (!frame || !document().securityOrigin().canDisplay(url)) {
<span class="line-modified">2098         if (actionIfInvalid == Complain) {</span>
2099             FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
2100             ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
<span class="line-added">2101         }</span>
2102         return false;
2103     }
2104 
2105     if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
2106         ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
2107         return false;
2108     }
2109 
2110     return true;
2111 }
2112 
2113 void HTMLMediaElement::startProgressEventTimer()
2114 {
2115     if (m_progressEventTimer.isActive())
2116         return;
2117 
2118     m_previousProgressTime = MonotonicTime::now();
2119     // 350ms is not magic, it is in the spec!
2120     m_progressEventTimer.startRepeating(350_ms);
2121 }
</pre>
<hr />
<pre>
2139 
2140 void HTMLMediaElement::noneSupported()
2141 {
2142     if (m_error)
2143         return;
2144 
2145     INFO_LOG(LOGIDENTIFIER);
2146 
2147     stopPeriodicTimers();
2148     m_loadState = WaitingForSource;
2149     m_currentSourceNode = nullptr;
2150 
2151     // 4.8.10.5
2152     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2153     // URL could not be resolved. In one atomic operation, run the following steps:
2154 
2155     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2156     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2157     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2158 

2159     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2160     forgetResourceSpecificTracks();

2161 
2162     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2163     m_networkState = NETWORK_NO_SOURCE;
2164 
2165     // 7 - Queue a task to fire a simple event named error at the media element.
2166     scheduleEvent(eventNames().errorEvent);
2167 
2168     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2169 
2170 #if ENABLE(MEDIA_SOURCE)
2171     detachMediaSource();
2172 #endif
2173 
2174     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2175     setShouldDelayLoadEvent(false);
2176 
2177     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2178     // the element won&#39;t attempt to load another resource.
2179 
2180     updateDisplayState();
</pre>
<hr />
<pre>
2274     }
2275 }
2276 
2277 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2278 {
2279     stopPeriodicTimers();
2280 
2281     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2282     // &lt;source&gt; children, schedule the next one
2283     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2284 
2285         // resource selection algorithm
2286         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2287         if (m_currentSourceNode)
2288             m_currentSourceNode-&gt;scheduleErrorEvent();
2289         else
2290             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2291 
2292         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2293 

2294         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2295         forgetResourceSpecificTracks();

2296 
2297         if (havePotentialSourceChild()) {
2298             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2299             scheduleNextSourceChild();
2300         } else {
2301             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2302             waitForSourceChange();
2303         }
2304 
2305         return;
2306     }
2307 
2308     if ((error == MediaPlayer::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::DecodeError)
2309         mediaLoadingFailedFatally(error);
2310     else if ((error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)
2311         noneSupported();
2312 
2313     updateDisplayState();
2314     if (hasMediaControls()) {
2315         mediaControls()-&gt;reset();
</pre>
<hr />
<pre>
2371         mediaControls()-&gt;bufferingProgressed();
2372 
2373     // Schedule one last progress event so we guarantee that at least one is fired
2374     // for files that load very quickly.
2375     scheduleEvent(eventNames().progressEvent);
2376     scheduleEvent(eventNames().suspendEvent);
2377     m_networkState = NETWORK_IDLE;
2378 }
2379 
2380 void HTMLMediaElement::mediaPlayerReadyStateChanged(MediaPlayer*)
2381 {
2382     beginProcessingMediaPlayerCallback();
2383 
2384     setReadyState(m_player-&gt;readyState());
2385 
2386     endProcessingMediaPlayerCallback();
2387 }
2388 
2389 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2390 {
<span class="line-modified">2391     if (m_readyState != HAVE_ENOUGH_DATA) {</span>
<span class="line-modified">2392         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);</span>
<span class="line-modified">2393         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">2394     }</span>
<span class="line-modified">2395     if (!isAutoplaying()) {</span>
<span class="line-modified">2396         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);</span>
<span class="line-modified">2397         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-modified">2398     }</span>
<span class="line-added">2399     if (!mediaSession().autoplayPermitted()) {</span>
<span class="line-added">2400         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);</span>
<span class="line-added">2401         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2402     }</span>
<span class="line-added">2403     if (!paused()) {</span>
<span class="line-added">2404         ALWAYS_LOG(LOGIDENTIFIER, &quot;!paused&quot;);</span>
<span class="line-added">2405         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2406     }</span>
<span class="line-added">2407     if (!autoplay()) {</span>
<span class="line-added">2408         ALWAYS_LOG(LOGIDENTIFIER, &quot;!autoplay&quot;);</span>
<span class="line-added">2409         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2410     }</span>
<span class="line-added">2411     if (pausedForUserInteraction()) {</span>
<span class="line-added">2412         ALWAYS_LOG(LOGIDENTIFIER, &quot;pausedForUserInteraction&quot;);</span>
<span class="line-added">2413         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2414     }</span>
<span class="line-added">2415     if (document().isSandboxed(SandboxAutomaticFeatures)) {</span>
<span class="line-added">2416         ALWAYS_LOG(LOGIDENTIFIER, &quot;isSandboxed&quot;);</span>
<span class="line-added">2417         return MediaPlaybackDenialReason::PageConsentRequired;</span>
<span class="line-added">2418     }</span>
2419 
<span class="line-modified">2420     auto permitted = mediaSession().playbackPermitted();</span>
<span class="line-modified">2421 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">2422     if (!permitted)</span>
<span class="line-added">2423         ALWAYS_LOG(LOGIDENTIFIER, permitted.value());</span>
<span class="line-added">2424     else</span>
<span class="line-added">2425         ALWAYS_LOG(LOGIDENTIFIER, &quot;can transition!&quot;);</span>
<span class="line-added">2426 #endif</span>
<span class="line-added">2427 </span>
<span class="line-added">2428     return permitted;</span>
2429 }
2430 
2431 void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
2432 {
<span class="line-modified">2433     if (!document().quirks().needsAutoplayPlayPauseEvents())</span>

2434         return;
2435 
2436     ALWAYS_LOG(LOGIDENTIFIER);
2437     scheduleEvent(eventNames().playingEvent);
2438     scheduleEvent(eventNames().pauseEvent);
2439 }
2440 
2441 void HTMLMediaElement::setReadyState(MediaPlayer::ReadyState state)
2442 {
2443     // Set &quot;wasPotentiallyPlaying&quot; BEFORE updating m_readyState, potentiallyPlaying() uses it
2444     bool wasPotentiallyPlaying = potentiallyPlaying();
2445 
2446     ReadyState oldState = m_readyState;
2447     ReadyState newState = static_cast&lt;ReadyState&gt;(state);
2448 
2449 #if ENABLE(VIDEO_TRACK)
2450     bool tracksAreReady = textTracksAreReady();
2451 
2452     if (newState == oldState &amp;&amp; m_tracksAreReady == tracksAreReady)
2453         return;
</pre>
<hr />
<pre>
3015         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
3016         m_seekTaskQueue.cancelTask();
3017         if (m_pendingSeek) {
3018             now = m_pendingSeek-&gt;now;
3019             m_pendingSeek = nullptr;
3020         }
3021         m_pendingSeekType = NoSeek;
3022     }
3023 
3024     // 4 - Set the seeking IDL attribute to true.
3025     // The flag will be cleared when the engine tells us the time has actually changed.
3026     m_seeking = true;
3027     if (m_playing) {
3028         if (m_lastSeekTime &lt; now)
3029             addPlayedRange(m_lastSeekTime, now);
3030     }
3031     m_lastSeekTime = time;
3032 
3033     // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
3034     // the script. The remainder of these steps must be run asynchronously.
<span class="line-modified">3035     m_pendingSeek = makeUnique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);</span>
3036     if (fromDOM) {
3037         INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
3038         m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
3039     } else
3040         seekTask();
3041 
3042     if (processingUserGestureForMedia())
3043         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3044 }
3045 
3046 void HTMLMediaElement::seekTask()
3047 {
3048     INFO_LOG(LOGIDENTIFIER);
3049 
3050     if (!m_player) {
3051         clearSeeking();
3052         return;
3053     }
3054 
3055     ASSERT(m_pendingSeek);
</pre>
<hr />
<pre>
3057     MediaTime time = m_pendingSeek-&gt;targetTime;
3058     MediaTime negativeTolerance = m_pendingSeek-&gt;negativeTolerance;
3059     MediaTime positiveTolerance = m_pendingSeek-&gt;positiveTolerance;
3060     m_pendingSeek = nullptr;
3061 
3062     ASSERT(negativeTolerance &gt;= MediaTime::zeroTime());
3063 
3064     // 6 - If the new playback position is later than the end of the media resource, then let it be the end
3065     // of the media resource instead.
3066     time = std::min(time, durationMediaTime());
3067 
3068     // 7 - If the new playback position is less than the earliest possible position, let it be that position instead.
3069     MediaTime earliestTime = m_player-&gt;startTime();
3070     time = std::max(time, earliestTime);
3071 
3072     // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
3073     // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
3074     // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
3075     // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
3076     // fire a &#39;seeked&#39; event.
<span class="line-modified">3077     if (willLog(WTFLogLevel::Debug)) {</span>
3078         MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
3079         if (time != mediaTime)
<span class="line-modified">3080             INFO_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);</span>
3081     }
3082 
3083     time = m_player-&gt;mediaTimeForTimeValue(time);
3084 
3085     // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
3086     // seekable attribute, then let it be the position in one of the ranges given in the seekable attribute
3087     // that is the nearest to the new playback position. ... If there are no ranges given in the seekable
3088     // attribute then set the seeking IDL attribute to false and abort these steps.
3089     RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
3090     bool noSeekRequired = !seekableRanges-&gt;length();
3091 
3092     // Short circuit seeking to the current time by just firing the events if no seek is required.
3093     // Don&#39;t skip calling the media engine if 1) we are in poster mode (because a seek should always cancel
3094     // poster display), or 2) if there is a pending fast seek, or 3) if this seek is not an exact seek
3095     SeekType thisSeekType = (negativeTolerance == MediaTime::zeroTime() &amp;&amp; positiveTolerance == MediaTime::zeroTime()) ? Precise : Fast;
3096     if (!noSeekRequired &amp;&amp; time == now &amp;&amp; thisSeekType == Precise &amp;&amp; m_pendingSeekType != Fast &amp;&amp; displayMode() != Poster)
3097         noSeekRequired = true;
3098 
3099 #if ENABLE(MEDIA_SOURCE)
3100     // Always notify the media engine of a seek if the source is not closed. This ensures that the source is
3101     // always in a flushed state when the &#39;seeking&#39; event fires.
3102     if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
3103         noSeekRequired = false;
3104 #endif
3105 
3106     if (noSeekRequired) {
<span class="line-modified">3107         INFO_LOG(LOGIDENTIFIER, &quot;ignored seek to &quot;, time);</span>
3108         if (time == now) {
3109             scheduleEvent(eventNames().seekingEvent);
3110             scheduleTimeupdateEvent(false);
3111             scheduleEvent(eventNames().seekedEvent);
3112         }
3113         clearSeeking();
3114         return;
3115     }
3116     time = seekableRanges-&gt;ranges().nearest(time);
3117 
3118     m_sentEndEvent = false;
3119     m_lastSeekTime = time;
3120     m_pendingSeekType = thisSeekType;
3121     m_seeking = true;
3122 
3123     // 10 - Queue a task to fire a simple event named seeking at the element.
3124     scheduleEvent(eventNames().seekingEvent);
3125 
3126     // 11 - Set the current playback position to the given new playback position
3127     m_seekRequested = true;
</pre>
<hr />
<pre>
3495 }
3496 
3497 void HTMLMediaElement::play(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
3498 {
3499     ALWAYS_LOG(LOGIDENTIFIER);
3500 
3501     auto success = m_mediaSession-&gt;playbackPermitted();
3502     if (!success) {
3503         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3504             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3505         promise.reject(NotAllowedError);
3506         return;
3507     }
3508 
3509     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
3510         promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
3511         return;
3512     }
3513 
3514     if (processingUserGestureForMedia())
<span class="line-modified">3515         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
3516 
3517     m_pendingPlayPromises.append(WTFMove(promise));
3518     playInternal();
3519 }
3520 
3521 void HTMLMediaElement::play()
3522 {
3523     ALWAYS_LOG(LOGIDENTIFIER);
3524 
3525     auto success = m_mediaSession-&gt;playbackPermitted();
3526     if (!success) {
3527         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3528             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3529         return;
3530     }
3531     if (processingUserGestureForMedia())
<span class="line-modified">3532         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
3533 
3534     playInternal();
3535 }
3536 
3537 void HTMLMediaElement::playInternal()
3538 {
3539     ALWAYS_LOG(LOGIDENTIFIER);
3540 
3541     if (isSuspended()) {
<span class="line-modified">3542         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
3543         return;
3544     }
3545 
3546     if (!document().hasBrowsingContext()) {
<span class="line-modified">3547         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
3548         return;
3549     }
3550 
3551     if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
<span class="line-modified">3552         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
3553         return;
3554     }
3555 
3556     // 4.8.10.9. Playing the media resource
3557     if (!m_player || m_networkState == NETWORK_EMPTY)
3558         selectMediaResource();
3559 
3560     if (endedPlayback())
3561         seekInternal(MediaTime::zeroTime());
3562 
3563     if (m_mediaController)
3564         m_mediaController-&gt;bringElementUpToSpeed(*this);
3565 
3566     if (m_paused) {
3567         m_paused = false;
3568         invalidateCachedTime();
<span class="line-modified">3569 </span>
<span class="line-added">3570         // This avoids the first timeUpdated event after playback starts, when currentTime is still</span>
<span class="line-added">3571         // the same as it was when the video was paused (and the time hasn&#39;t changed yet).</span>
<span class="line-added">3572         m_lastTimeUpdateEventMovieTime = currentMediaTime();</span>
<span class="line-added">3573         m_playbackStartedTime = m_lastTimeUpdateEventMovieTime.toDouble();</span>
<span class="line-added">3574 </span>
3575         scheduleEvent(eventNames().playEvent);
3576 
3577 #if ENABLE(MEDIA_SESSION)
3578         // 6.3 Activating a media session from a media element
3579         // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
3580         // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then
3581         // 1. Let media session be the value of the current media session.
3582         // 2. If we are not currently in media session&#39;s list of active participating media elements then append
3583         //    ourselves to this list.
3584         // 3. Let activated be the result of running the media session invocation algorithm for media session.
3585         // 4. If activated is failure, pause ourselves.
3586         if (m_readyState == HAVE_ENOUGH_DATA || m_readyState == HAVE_FUTURE_DATA) {
3587             if (m_session) {
3588                 m_session-&gt;addActiveMediaElement(*this);
3589 
3590                 if (m_session-&gt;kind() == MediaSessionKind::Content) {
3591                     if (Page* page = document().page())
3592                         page-&gt;chrome().client().focusedContentMediaElementDidChange(m_elementID);
3593                 }
3594 
</pre>
<hr />
<pre>
3613     } else
3614         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
3615 
3616     m_autoplaying = false;
3617     updatePlayState();
3618 }
3619 
3620 void HTMLMediaElement::pause()
3621 {
3622     ALWAYS_LOG(LOGIDENTIFIER);
3623 
3624     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
3625 
3626     if (m_waitingToEnterFullscreen)
3627         m_waitingToEnterFullscreen = false;
3628 
3629     if (!m_mediaSession-&gt;playbackPermitted())
3630         return;
3631 
3632     if (processingUserGestureForMedia())
<span class="line-modified">3633         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3634 
3635     pauseInternal();
3636 }
3637 
3638 
3639 void HTMLMediaElement::pauseInternal()
3640 {
3641     ALWAYS_LOG(LOGIDENTIFIER);
3642 
3643     if (isSuspended()) {
<span class="line-modified">3644         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);</span>
3645         return;
3646     }
3647 
3648     if (!document().hasBrowsingContext()) {
<span class="line-modified">3649         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);</span>
3650         return;
3651     }
3652 
3653     if (!m_mediaSession-&gt;clientWillPausePlayback()) {
<span class="line-modified">3654         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);</span>
3655         return;
3656     }
3657 
3658     // 4.8.10.9. Playing the media resource
3659     if (!m_player || m_networkState == NETWORK_EMPTY) {
3660         // Unless the restriction on media requiring user action has been lifted
3661         // don&#39;t trigger loading if a script calls pause().
3662         if (!m_mediaSession-&gt;playbackPermitted())
3663             return;
3664         selectMediaResource();
3665     }
3666 
3667     m_autoplaying = false;
3668 
3669     if (processingUserGestureForMedia())
3670         userDidInterfereWithAutoplay();
3671 
3672     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3673 
3674     if (!m_paused) {
</pre>
<hr />
<pre>
3684 }
3685 
3686 #if ENABLE(MEDIA_SOURCE)
3687 
3688 void HTMLMediaElement::detachMediaSource()
3689 {
3690     if (!m_mediaSource)
3691         return;
3692 
3693     m_mediaSource-&gt;detachFromElement(*this);
3694     m_mediaSource = nullptr;
3695 }
3696 
3697 #endif
3698 
3699 bool HTMLMediaElement::loop() const
3700 {
3701     return hasAttributeWithoutSynchronization(loopAttr);
3702 }
3703 
<span class="line-modified">3704 void HTMLMediaElement::setLoop(bool loop)</span>
3705 {
<span class="line-modified">3706     INFO_LOG(LOGIDENTIFIER, loop);</span>
<span class="line-modified">3707     setBooleanAttribute(loopAttr, loop);</span>
3708 }
3709 
3710 bool HTMLMediaElement::controls() const
3711 {
3712     RefPtr&lt;Frame&gt; frame = document().frame();
3713 
3714     // always show controls when scripting is disabled
3715     if (frame &amp;&amp; !frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
3716         return true;
3717 
3718     return hasAttributeWithoutSynchronization(controlsAttr);
3719 }
3720 
<span class="line-modified">3721 void HTMLMediaElement::setControls(bool controls)</span>
3722 {
<span class="line-modified">3723     INFO_LOG(LOGIDENTIFIER, controls);</span>
<span class="line-modified">3724     setBooleanAttribute(controlsAttr, controls);</span>
3725 }
3726 
3727 double HTMLMediaElement::volume() const
3728 {
3729     return m_volume;
3730 }
3731 
3732 ExceptionOr&lt;void&gt; HTMLMediaElement::setVolume(double volume)
3733 {
3734     INFO_LOG(LOGIDENTIFIER, volume);
3735 
3736     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
3737         return Exception { IndexSizeError };
3738 

3739     if (m_volume == volume)
3740         return { };
3741 
<span class="line-added">3742 #if !PLATFORM(IOS_FAMILY)</span>
3743     if (volume &amp;&amp; processingUserGestureForMedia())
<span class="line-modified">3744         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3745 
3746     m_volume = volume;
3747     m_volumeInitialized = true;
3748     updateVolume();
3749     scheduleEvent(eventNames().volumechangeEvent);
3750 
3751     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3752         pauseInternal();
3753         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3754     }
<span class="line-added">3755 #else</span>
<span class="line-added">3756     auto oldVolume = m_volume;</span>
<span class="line-added">3757     m_volume = volume;</span>
<span class="line-added">3758 </span>
<span class="line-added">3759     if (m_volumeRevertTaskQueue.hasPendingTask())</span>
<span class="line-added">3760         return { };</span>
<span class="line-added">3761 </span>
<span class="line-added">3762     m_volumeRevertTaskQueue.scheduleTask([this, oldVolume] {</span>
<span class="line-added">3763         m_volume = oldVolume;</span>
<span class="line-added">3764     });</span>
<span class="line-added">3765 </span>
3766 #endif
<span class="line-added">3767 </span>
3768     return { };
3769 }
3770 
3771 bool HTMLMediaElement::muted() const
3772 {
3773     return m_explicitlyMuted ? m_muted : hasAttributeWithoutSynchronization(mutedAttr);
3774 }
3775 
3776 void HTMLMediaElement::setMuted(bool muted)
3777 {
3778     INFO_LOG(LOGIDENTIFIER, muted);
3779 
3780     bool mutedStateChanged = m_muted != muted;
3781     if (mutedStateChanged || !m_explicitlyMuted) {
3782         if (processingUserGestureForMedia()) {
<span class="line-modified">3783             removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);</span>
3784 
3785             if (hasAudio() &amp;&amp; muted)
3786                 userDidInterfereWithAutoplay();
3787         }
3788 
3789         m_muted = muted;
3790         m_explicitlyMuted = true;
3791 
3792         // Avoid recursion when the player reports volume changes.
3793         if (!processingMediaPlayerCallback()) {
3794             if (m_player) {
3795                 m_player-&gt;setMuted(effectiveMuted());
3796                 if (hasMediaControls())
3797                     mediaControls()-&gt;changedMute();
3798             }
3799         }
3800 
3801         if (mutedStateChanged)
3802             scheduleEvent(eventNames().volumechangeEvent);
3803 
</pre>
<hr />
<pre>
4240 void HTMLMediaElement::didRemoveTextTrack(HTMLTrackElement&amp; trackElement)
4241 {
4242     ASSERT(trackElement.hasTagName(trackTag));
4243 
4244     auto&amp; textTrack = trackElement.track();
4245 
4246     textTrack.setHasBeenConfigured(false);
4247 
4248     if (!m_textTracks)
4249         return;
4250 
4251     // 4.8.10.12.3 Sourcing out-of-band text tracks
4252     // When a track element&#39;s parent element changes and the old parent was a media element,
4253     // then the user agent must remove the track element&#39;s corresponding text track from the
4254     // media element&#39;s list of text tracks.
4255     removeTextTrack(textTrack);
4256 
4257     m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
4258 }
4259 

4260 void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
4261 {
4262     ASSERT(group.tracks.size());
4263 
4264     Page* page = document().page();
4265     CaptionUserPreferences* captionPreferences = page ? &amp;page-&gt;group().captionPreferences() : 0;
4266     CaptionUserPreferences::CaptionDisplayMode displayMode = captionPreferences ? captionPreferences-&gt;captionDisplayMode() : CaptionUserPreferences::Automatic;
4267 
4268     // First, find the track in the group that should be enabled (if any).
4269     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; currentlyEnabledTracks;
4270     RefPtr&lt;TextTrack&gt; trackToEnable;
4271     RefPtr&lt;TextTrack&gt; defaultTrack;
4272     RefPtr&lt;TextTrack&gt; fallbackTrack;
4273     RefPtr&lt;TextTrack&gt; forcedSubitleTrack;
4274     int highestTrackScore = 0;
4275     int highestForcedScore = 0;
4276 
4277     // If there is a visible track, it has already been configured so it won&#39;t be considered in the loop below. We don&#39;t want to choose another
4278     // track if it is less suitable, and we do want to disable it if another track is more suitable.
4279     int alreadyVisibleTrackScore = 0;
</pre>
<hr />
<pre>
4352 
4353     if (currentlyEnabledTracks.size()) {
4354         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4355             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4356             if (textTrack != trackToEnable)
4357                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4358         }
4359     }
4360 
4361     if (trackToEnable) {
4362         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4363 
4364         // If user preferences indicate we should always display captions, make sure we reflect the
4365         // proper status via the webkitClosedCaptionsVisible API call:
4366         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4367             m_webkitLegacyClosedCaptionOverride = true;
4368     }
4369 
4370     m_processingPreferenceChange = false;
4371 }
<span class="line-modified">4372 </span>
4373 static JSC::JSValue controllerJSValue(JSC::ExecState&amp; exec, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)
4374 {
4375     JSC::VM&amp; vm = globalObject.vm();
4376     auto scope = DECLARE_THROW_SCOPE(vm);
4377     auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, media);
4378 
4379     // Retrieve the controller through the JS object graph
4380     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4381     if (!mediaJSWrapperObject)
4382         return JSC::jsNull();
4383 
<span class="line-modified">4384     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
4385     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;exec, controlsHost);
4386     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4387 
4388     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4389     if (!controlsHostJSWrapperObject)
4390         return JSC::jsNull();
4391 
<span class="line-modified">4392     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
4393     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;exec, controllerID);
4394     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4395 
4396     return controllerJSWrapper;
4397 }
4398 
4399 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4400 {
4401     ASSERT(!m_creatingControls);
4402     m_creatingControls = true;
4403     ensureUserAgentShadowRoot();
4404     m_creatingControls = false;
4405 }
4406 
4407 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4408 {
4409     Page* page = document().page();
4410     if (!page)
4411         return false;
4412 
</pre>
<hr />
<pre>
4435 
4436     ensureMediaControlsShadowRoot();
4437 
4438     if (!m_mediaControlsHost)
4439         m_mediaControlsHost = MediaControlsHost::create(this);
4440 
4441     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
4442         auto&amp; vm = globalObject.vm();
4443         auto scope = DECLARE_CATCH_SCOPE(vm);
4444         auto controllerValue = controllerJSValue(exec, globalObject, *this);
4445         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4446         if (!controllerObject)
4447             return false;
4448 
4449         // The media controls script must provide a method on the Controller object with the following details.
4450         // Name: updateCaptionContainer
4451         // Parameters:
4452         //     None
4453         // Return value:
4454         //     None
<span class="line-modified">4455         auto methodValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
4456         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4457         if (!methodObject)
4458             return false;
4459 
4460         JSC::CallData callData;
4461         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4462         if (callType == JSC::CallType::None)
4463             return false;
4464 
4465         JSC::MarkedArgumentBuffer noArguments;
4466         ASSERT(!noArguments.hasOverflowed());
4467         JSC::call(&amp;exec, methodObject, callType, callData, controllerObject, noArguments);
4468         scope.clearException();
4469 
4470         m_haveSetUpCaptionContainer = true;
4471 
4472         return true;
4473     });
4474 
4475 #endif
</pre>
<hr />
<pre>
4633 bool HTMLMediaElement::havePotentialSourceChild()
4634 {
4635     // Stash the current &lt;source&gt; node and next nodes so we can restore them after checking
4636     // to see there is another potential.
4637     RefPtr&lt;HTMLSourceElement&gt; currentSourceNode = m_currentSourceNode;
4638     RefPtr&lt;HTMLSourceElement&gt; nextNode = m_nextChildNodeToConsider;
4639 
4640     URL nextURL = selectNextSourceChild(0, 0, DoNothing);
4641 
4642     m_currentSourceNode = currentSourceNode;
4643     m_nextChildNodeToConsider = nextNode;
4644 
4645     return nextURL.isValid();
4646 }
4647 
4648 URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
4649 {
4650     UNUSED_PARAM(keySystem);
4651 
4652     // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
<span class="line-modified">4653     bool shouldLog = willLog(WTFLogLevel::Debug) &amp;&amp; actionIfInvalid != DoNothing;</span>
4654     if (shouldLog)
4655         INFO_LOG(LOGIDENTIFIER);
4656 
4657     if (!m_nextChildNodeToConsider) {
4658         if (shouldLog)
4659             INFO_LOG(LOGIDENTIFIER, &quot;end of list, stopping&quot;);
4660         return URL();
4661     }
4662 
4663     // Because the DOM may be mutated in the course of the following algorithm,
4664     // keep strong references to each of the child source nodes, and verify that
4665     // each still is a child of this media element before using.
4666     Vector&lt;Ref&lt;HTMLSourceElement&gt;&gt; potentialSourceNodes;
4667     auto sources = childrenOfType&lt;HTMLSourceElement&gt;(*this);
4668     for (auto next = m_nextChildNodeToConsider ? sources.beginAt(*m_nextChildNodeToConsider) : sources.begin(), end = sources.end(); next != end; ++next)
4669         potentialSourceNodes.append(*next);
4670 
4671     for (auto&amp; source : potentialSourceNodes) {
4672         if (source-&gt;parentNode() != this)
4673             continue;
</pre>
<hr />
<pre>
4732 
4733         return mediaURL;
4734 
4735 CheckAgain:
4736         if (actionIfInvalid == Complain)
4737             source-&gt;scheduleErrorEvent();
4738     }
4739 
4740     m_currentSourceNode = nullptr;
4741     m_nextChildNodeToConsider = nullptr;
4742 
4743 #if !LOG_DISABLED
4744     if (shouldLog)
4745         INFO_LOG(LOGIDENTIFIER, &quot;failed&quot;);
4746 #endif
4747     return URL();
4748 }
4749 
4750 void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
4751 {
<span class="line-modified">4752     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4753         URL url = source.getNonEmptyURLAttribute(srcAttr);
4754         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4755     }
4756 
4757     if (!document().hasBrowsingContext()) {
4758         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted inside a document without a browsing context is not loaded&quot;);
4759         return;
4760     }
4761 
4762     // We should only consider a &lt;source&gt; element when there is not src attribute at all.
4763     if (hasAttributeWithoutSynchronization(srcAttr))
4764         return;
4765 
4766     // 4.8.8 - If a source element is inserted as a child of a media element that has no src
4767     // attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke
4768     // the media element&#39;s resource selection algorithm.
4769     if (m_networkState == NETWORK_EMPTY) {
4770         m_nextChildNodeToConsider = &amp;source;
4771 #if PLATFORM(IOS_FAMILY)
4772         if (m_mediaSession-&gt;dataLoadingPermitted())
</pre>
<hr />
<pre>
4784     if (m_nextChildNodeToConsider)
4785         return;
4786 
4787     // 4.8.9.5, resource selection algorithm, source elements section:
4788     // 21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
4789     // 22. Asynchronously await a stable state...
4790     // 23. Set the element&#39;s delaying-the-load-event flag back to true (this delays the load event again, in case
4791     // it hasn&#39;t been fired yet).
4792     setShouldDelayLoadEvent(true);
4793 
4794     // 24. Set the networkState back to NETWORK_LOADING.
4795     m_networkState = NETWORK_LOADING;
4796 
4797     // 25. Jump back to the find next candidate step above.
4798     m_nextChildNodeToConsider = &amp;source;
4799     scheduleNextSourceChild();
4800 }
4801 
4802 void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
4803 {
<span class="line-modified">4804     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {</span>
4805         URL url = source.getNonEmptyURLAttribute(srcAttr);
4806         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4807     }
4808 
4809     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4810         return;
4811 
4812     if (&amp;source == m_nextChildNodeToConsider) {
4813         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4814         INFO_LOG(LOGIDENTIFIER);
4815     } else if (&amp;source == m_currentSourceNode) {
4816         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4817         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4818         // inserted in a video or audio element will have no effect.
4819         m_currentSourceNode = nullptr;
<span class="line-modified">4820         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);</span>
4821     }
4822 }
4823 
4824 void HTMLMediaElement::mediaPlayerTimeChanged(MediaPlayer*)
4825 {
4826     INFO_LOG(LOGIDENTIFIER);
4827 
4828 #if ENABLE(VIDEO_TRACK)
4829     updateActiveTextTrackCues(currentMediaTime());
4830 #endif
4831 
4832     beginProcessingMediaPlayerCallback();
4833 
4834     invalidateCachedTime();
4835     bool wasSeeking = seeking();
4836 
4837     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4838     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4839         finishSeek();
4840 
</pre>
<hr />
<pre>
5363 
5364 MediaTime HTMLMediaElement::maxTimeSeekable() const
5365 {
5366     return m_player ? m_player-&gt;maxTimeSeekable() : MediaTime::zeroTime();
5367 }
5368 
5369 void HTMLMediaElement::updateVolume()
5370 {
5371     if (!m_player)
5372         return;
5373 #if PLATFORM(IOS_FAMILY)
5374     // Only the user can change audio volume so update the cached volume and post the changed event.
5375     float volume = m_player-&gt;volume();
5376     if (m_volume != volume) {
5377         m_volume = volume;
5378         scheduleEvent(eventNames().volumechangeEvent);
5379     }
5380 #else
5381     // Avoid recursion when the player reports volume changes.
5382     if (!processingMediaPlayerCallback()) {
<span class="line-modified">5383         m_player-&gt;setMuted(effectiveMuted());</span>
<span class="line-modified">5384         m_player-&gt;setVolume(effectiveVolume());</span>














5385     }
5386 
5387 #if ENABLE(MEDIA_SESSION)
5388     document().updateIsPlayingMedia(m_elementID);
5389 #else
5390     document().updateIsPlayingMedia();
5391 #endif
5392 
5393     if (hasMediaControls())
5394         mediaControls()-&gt;changedVolume();
5395 #endif
5396 }
5397 
5398 void HTMLMediaElement::scheduleUpdatePlayState()
5399 {
5400     if (m_updatePlayStateTask.hasPendingTask())
5401         return;
5402 
5403     auto logSiteIdentifier = LOGIDENTIFIER;
5404     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
</pre>
<hr />
<pre>
5432 
5433     if (shouldBePlaying &amp;&amp; playerPaused &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; (m_waitingToEnterFullscreen || !isFullscreen())) {
5434         if (!m_waitingToEnterFullscreen)
5435             enterFullscreen();
5436 
5437 #if PLATFORM(WATCHOS)
5438         // FIXME: Investigate doing this for all builds.
5439         return;
5440 #endif
5441     }
5442 
5443     if (shouldBePlaying) {
5444         schedulePlaybackControlsManagerUpdate();
5445 
5446         setDisplayMode(Video);
5447         invalidateCachedTime();
5448 
5449         if (playerPaused) {
5450             m_mediaSession-&gt;clientWillBeginPlayback();
5451 
<span class="line-modified">5452             // Set rate, muted and volume before calling play in case they were set before the media engine was set up.</span>
<span class="line-modified">5453             // The media engine should just stash the rate, muted and volume values since it isn&#39;t already playing.</span>
5454             m_player-&gt;setRate(requestedPlaybackRate());
5455             m_player-&gt;setMuted(effectiveMuted());
<span class="line-added">5456             m_player-&gt;setVolume(effectiveVolume());</span>
5457 
5458             if (m_firstTimePlaying) {
5459                 // Log that a media element was played.
5460                 if (auto* page = document().page())
5461                     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
5462                 m_firstTimePlaying = false;
5463             }
5464 
5465             m_player-&gt;play();
5466         }
5467 
5468         if (hasMediaControls())
5469             mediaControls()-&gt;playbackStarted();
5470 
5471         startPlaybackProgressTimer();
5472         setPlaying(true);
5473     } else {
5474         schedulePlaybackControlsManagerUpdate();
5475 
5476         if (!playerPaused)
</pre>
<hr />
<pre>
5523 
5524 void HTMLMediaElement::setPausedInternal(bool b)
5525 {
5526     m_pausedInternal = b;
5527     scheduleUpdatePlayState();
5528 }
5529 
5530 void HTMLMediaElement::stopPeriodicTimers()
5531 {
5532     m_progressEventTimer.stop();
5533     m_playbackProgressTimer.stop();
5534 }
5535 
5536 void HTMLMediaElement::cancelPendingTasks()
5537 {
5538     m_configureTextTracksTask.cancelTask();
5539     m_checkPlaybackTargetCompatablityTask.cancelTask();
5540     m_updateMediaStateTask.cancelTask();
5541     m_mediaEngineUpdatedTask.cancelTask();
5542     m_updatePlayStateTask.cancelTask();
<span class="line-added">5543 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">5544     m_volumeRevertTaskQueue.cancelTask();</span>
<span class="line-added">5545 #endif</span>
5546 }
5547 
5548 void HTMLMediaElement::userCancelledLoad()
5549 {
5550     INFO_LOG(LOGIDENTIFIER);
5551 
5552     // FIXME: We should look to reconcile the iOS and non-iOS code (below).
5553 #if PLATFORM(IOS_FAMILY)
5554     if (m_networkState == NETWORK_EMPTY || m_readyState &gt;= HAVE_METADATA)
5555         return;
5556 #else
5557     if (m_networkState == NETWORK_EMPTY || m_completelyLoaded)
5558         return;
5559 #endif
5560 
5561     // If the media data fetching process is aborted by the user:
5562 
5563     // 1 - The user agent should cancel the fetching process.
5564     clearMediaPlayer();
5565 
</pre>
<hr />
<pre>
5704 void HTMLMediaElement::closeTaskQueues()
5705 {
5706     m_configureTextTracksTask.close();
5707     m_checkPlaybackTargetCompatablityTask.close();
5708     m_updateMediaStateTask.close();
5709     m_mediaEngineUpdatedTask.close();
5710     m_updatePlayStateTask.close();
5711     m_resumeTaskQueue.close();
5712     m_seekTaskQueue.close();
5713     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5714     m_seekTaskQueue.close();
5715     m_resumeTaskQueue.close();
5716     m_promiseTaskQueue.close();
5717     m_pauseAfterDetachedTaskQueue.close();
5718     m_resourceSelectionTaskQueue.close();
5719     m_visibilityChangeTaskQueue.close();
5720 #if ENABLE(ENCRYPTED_MEDIA)
5721     m_encryptedMediaQueue.close();
5722 #endif
5723     m_asyncEventQueue.close();
<span class="line-added">5724 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">5725     m_volumeRevertTaskQueue.close();</span>
<span class="line-added">5726 #endif</span>
5727 }
5728 
5729 void HTMLMediaElement::contextDestroyed()
5730 {
5731     closeTaskQueues();
5732     m_pendingPlayPromises.clear();
5733 
5734     ActiveDOMObject::contextDestroyed();
5735 }
5736 
5737 void HTMLMediaElement::stop()
5738 {
5739     INFO_LOG(LOGIDENTIFIER);
5740 
5741     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5742     stopWithoutDestroyingMediaPlayer();
5743     closeTaskQueues();
5744 
5745     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5746     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5747     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5748     // loaded and calling it again won&#39;t cause any problems.
5749     clearMediaPlayer();
5750 
5751     m_mediaSession-&gt;stopSession();
5752 }
5753 
5754 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5755 {
5756     INFO_LOG(LOGIDENTIFIER);
5757     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5758 
5759     m_resumeTaskQueue.cancelTask();
5760 
5761     switch (reason) {
5762     case ReasonForSuspension::PageCache:
5763         stopWithoutDestroyingMediaPlayer();
5764         m_asyncEventQueue.suspend();
<span class="line-modified">5765         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);</span>
5766         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5767         break;
5768     case ReasonForSuspension::PageWillBeSuspended:
5769     case ReasonForSuspension::JavaScriptDebuggerPaused:
5770     case ReasonForSuspension::WillDeferLoading:
5771         // Do nothing, we don&#39;t pause media playback in these cases.
5772         break;
5773     }
5774 }
5775 
5776 void HTMLMediaElement::resume()
5777 {
5778     INFO_LOG(LOGIDENTIFIER);
5779 
5780     setInActiveDocument(true);
5781 
5782     m_asyncEventQueue.resume();
5783 


5784     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5785         document().addMediaCanStartListener(*this);
5786     else
5787         setPausedInternal(false);
5788 
5789     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
<span class="line-added">5790     m_mediaSession-&gt;updateBufferingPolicy();</span>
5791 
5792     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
5793         // Restart the load if it was aborted in the middle by moving the document to the page cache.
5794         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5795         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5796         // This behavior is not specified but it seems like a sensible thing to do.
5797         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5798         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5799     }
5800 
5801     updateRenderer();
5802 }
5803 
5804 bool HTMLMediaElement::hasPendingActivity() const
5805 {
5806     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue.hasPendingEvents() || m_creatingControls;
5807 }
5808 
5809 void HTMLMediaElement::mediaVolumeDidChange()
5810 {
</pre>
<hr />
<pre>
5845 }
5846 
5847 void HTMLMediaElement::setTextTrackRepresentation(TextTrackRepresentation* representation)
5848 {
5849     if (m_player)
5850         m_player-&gt;setTextTrackRepresentation(representation);
5851 }
5852 
5853 void HTMLMediaElement::syncTextTrackBounds()
5854 {
5855     if (m_player)
5856         m_player-&gt;syncTextTrackBounds();
5857 }
5858 #endif // ENABLE(VIDEO_TRACK)
5859 
5860 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5861 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5862 {
5863     ALWAYS_LOG(LOGIDENTIFIER);
5864     if (processingUserGestureForMedia())
<span class="line-modified">5865         removeBehaviorRestrictionsAfterFirstUserGesture();</span>
5866     m_mediaSession-&gt;showPlaybackTargetPicker();
5867 }
5868 
5869 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5870 {
5871     enqueuePlaybackTargetAvailabilityChangedEvent();
5872 }
5873 
5874 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*)
5875 {
5876     setIsPlayingToWirelessTarget(m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless());
5877 }
5878 
5879 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5880 {
5881     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5882         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5883             return;
5884         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
5885 
5886         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5887         configureMediaControls();
5888         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5889         m_mediaSession-&gt;canProduceAudioChanged();
5890         scheduleUpdateMediaState();
5891         updateSleepDisabling();
5892 
5893         m_failedToPlayToWirelessTarget = false;
5894         scheduleCheckPlaybackTargetCompatability();
5895 
5896         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5897     });
5898 }
5899 
5900 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5901 {
<span class="line-modified">5902     DEBUG_LOG(LOGIDENTIFIER, event.type());</span>
<span class="line-added">5903 </span>
<span class="line-added">5904     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)</span>
<span class="line-added">5905         document().userActivatedMediaFinishedPlaying();</span>
5906 
5907     HTMLElement::dispatchEvent(event);
5908 }
5909 
<span class="line-modified">5910 bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
5911 {
5912     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5913         return Node::addEventListener(eventType, WTFMove(listener), options);
5914 
5915     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5916     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5917         return false;
5918 
5919     if (isFirstAvailabilityChangedListener) {
5920         m_hasPlaybackTargetAvailabilityListeners = true;
5921         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5922     }
5923 
5924     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5925 
5926     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5927     return true;
5928 }
5929 
<span class="line-modified">5930 bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
5931 {
5932     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5933         return Node::removeEventListener(eventType, listener, options);
5934 
5935     if (!Node::removeEventListener(eventType, listener, options))
5936         return false;
5937 
5938     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent);
5939     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5940     if (didRemoveLastAvailabilityChangedListener) {
5941         m_hasPlaybackTargetAvailabilityListeners = false;
5942         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5943         scheduleUpdateMediaState();
5944     }
5945 
5946     return true;
5947 }
5948 
5949 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5950 {
</pre>
<hr />
<pre>
5990     scheduleUpdateMediaState();
5991 #endif
5992 }
5993 
5994 double HTMLMediaElement::minFastReverseRate() const
5995 {
5996     return m_player ? m_player-&gt;minFastReverseRate() : 0;
5997 }
5998 
5999 double HTMLMediaElement::maxFastForwardRate() const
6000 {
6001     return m_player ? m_player-&gt;maxFastForwardRate() : 0;
6002 }
6003 
6004 bool HTMLMediaElement::isFullscreen() const
6005 {
6006     if (m_videoFullscreenMode != VideoFullscreenModeNone)
6007         return true;
6008 
6009 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">6010     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
6011         return true;
6012 #endif
6013 
6014     return false;
6015 }
6016 
6017 bool HTMLMediaElement::isStandardFullscreen() const
6018 {
6019 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">6020     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)</span>
6021         return true;
6022 #endif
6023 
6024     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6025 }
6026 
6027 void HTMLMediaElement::toggleStandardFullscreenState()
6028 {
6029     if (isStandardFullscreen())
6030         exitFullscreen();
6031     else
6032         enterFullscreen();
6033 }
6034 
6035 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6036 {
6037     INFO_LOG(LOGIDENTIFIER);
6038     ASSERT(mode != VideoFullscreenModeNone);
6039 
6040     if (m_videoFullscreenMode == mode)
6041         return;
6042 
6043     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6044     m_waitingToEnterFullscreen = true;
6045 
6046 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6047     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
<span class="line-modified">6048         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);</span>
6049         return;
6050     }
6051 #endif
6052 
6053     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6054         if (document().hidden()) {
6055             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6056             return;
6057         }
6058 
6059         fullscreenModeChanged(mode);
6060         configureMediaControls();
6061         if (hasMediaControls())
6062             mediaControls()-&gt;enteredFullscreen();
6063         if (is&lt;HTMLVideoElement&gt;(*this)) {
6064             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6065             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
6066                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6067                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6068             }
6069         }
6070     });
6071 }
6072 
6073 void HTMLMediaElement::enterFullscreen()
6074 {
6075     enterFullscreen(VideoFullscreenModeStandard);
6076 }
6077 
6078 void HTMLMediaElement::exitFullscreen()
6079 {
6080     INFO_LOG(LOGIDENTIFIER);
6081 
6082     m_waitingToEnterFullscreen = false;
6083 
6084 #if ENABLE(FULLSCREEN_API)
<span class="line-modified">6085     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {</span>
<span class="line-modified">6086         if (document().fullscreenManager().isFullscreen())</span>
<span class="line-modified">6087             document().fullscreenManager().cancelFullscreen();</span>
6088 
6089         if (m_videoFullscreenMode == VideoFullscreenModeStandard)
6090             return;
6091     }
6092 #endif
6093 
6094     ASSERT(m_videoFullscreenMode != VideoFullscreenModeNone);
6095     VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6096     fullscreenModeChanged(VideoFullscreenModeNone);
6097 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6098     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaControlsAfterPresentationModeChange calls methods that can trigger arbitrary DOM mutations.
6099     updateMediaControlsAfterPresentationModeChange();
6100 #endif
6101     if (hasMediaControls())
6102         mediaControls()-&gt;exitedFullscreen();
6103 
6104     if (!document().page() || !is&lt;HTMLVideoElement&gt;(*this))
6105         return;
6106 
6107     if (!paused() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback()) {
</pre>
<hr />
<pre>
6109             pauseInternal();
6110         else {
6111             // Allow inline playback, but set a flag so pausing and starting again (e.g. when scrubbing or looping) won&#39;t go back to fullscreen.
6112             // Also set the controls attribute so the user will be able to control playback.
6113             m_temporarilyAllowingInlinePlaybackAfterFullscreen = true;
6114             setControls(true);
6115         }
6116     }
6117 
6118 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6119     if (document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
6120         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(downcast&lt;HTMLVideoElement&gt;(*this), VideoFullscreenModeNone);
6121     else
6122 #endif
6123     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(oldVideoFullscreenMode)) {
6124         if (m_videoFullscreenStandby)
6125             document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6126         else
6127             document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6128         scheduleEvent(eventNames().webkitendfullscreenEvent);

6129     }
6130 }
6131 
6132 WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
6133 {
6134     ASSERT(is&lt;HTMLVideoElement&gt;(*this));
6135     if (m_videoFullscreenStandby == value)
6136         return;
6137 
6138     if (!document().page())
6139         return;
6140 
6141     if (!document().page()-&gt;chrome().client().supportsVideoFullscreenStandby())
6142         return;
6143 
6144     m_videoFullscreenStandby = value;
6145 
6146 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6147     if (m_player)
6148         m_player-&gt;videoFullscreenStandbyChanged();
</pre>
<hr />
<pre>
6423 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; HTMLMediaElement::originsInMediaCache(const String&amp; path)
6424 {
6425     return MediaPlayer::originsInMediaCache(path);
6426 }
6427 
6428 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6429 {
6430     MediaPlayer::clearMediaCache(path, modifiedSince);
6431 }
6432 
6433 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6434 {
6435     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6436 }
6437 
6438 void HTMLMediaElement::resetMediaEngines()
6439 {
6440     MediaPlayer::resetMediaEngines();
6441 }
6442 
<span class="line-modified">6443 void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)</span>
6444 {
6445     if (!m_player)
6446         return;
6447 
<span class="line-modified">6448     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());</span>

6449 }
6450 
6451 MediaControls* HTMLMediaElement::mediaControls() const
6452 {
6453 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6454     return nullptr;
6455 #else
6456     auto root = userAgentShadowRoot();
6457     if (!root)
6458         return nullptr;
6459 
6460     return childrenOfType&lt;MediaControls&gt;(*root).first();
6461 #endif
6462 }
6463 
6464 bool HTMLMediaElement::hasMediaControls() const
6465 {
6466 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6467     return false;
6468 #else
</pre>
<hr />
<pre>
6671 
6672 #if ENABLE(WEB_AUDIO)
6673     if (m_audioSourceNode)
6674         m_audioSourceNode-&gt;lock();
6675 #endif
6676 
6677 #if ENABLE(MEDIA_SOURCE)
6678     detachMediaSource();
6679 #endif
6680 
6681 #if ENABLE(VIDEO_TRACK)
6682     forgetResourceSpecificTracks();
6683 #endif
6684 
6685 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6686     if (m_isPlayingToWirelessTarget)
6687         setIsPlayingToWirelessTarget(false);
6688 #endif
6689 
6690     m_player = MediaPlayer::create(*this);
<span class="line-modified">6691     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);</span>
6692     schedulePlaybackControlsManagerUpdate();
6693 
6694 #if ENABLE(WEB_AUDIO)
6695     if (m_audioSourceNode) {
6696         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6697         if (audioSourceProvider())
6698             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6699 
6700         m_audioSourceNode-&gt;unlock();
6701     }
6702 #endif
6703 
6704 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6705     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent)) {
6706         m_hasPlaybackTargetAvailabilityListeners = true;
6707         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6708         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6709     }
6710 #endif
6711 
</pre>
<hr />
<pre>
6889 {
6890     auto* track = item.get();
6891     return track-&gt;privateTrack().type() == RealtimeMediaSource::Type::Video &amp;&amp; !track-&gt;isCaptureTrack() &amp;&amp; !track-&gt;isCanvas();
6892 }
6893 #endif
6894 
6895 HTMLMediaElement::SleepType HTMLMediaElement::shouldDisableSleep() const
6896 {
6897 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(GTK) &amp;&amp; !PLATFORM(WPE)
6898     return SleepType::None;
6899 #endif
6900     if (!m_player || m_player-&gt;paused() || loop())
6901         return SleepType::None;
6902 
6903 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6904     // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
6905     if (m_isPlayingToWirelessTarget)
6906         return SleepType::System;
6907 #endif
6908 
<span class="line-modified">6909     if (PlatformMediaSessionManager::sharedManager().processIsSuspended())</span>
<span class="line-added">6910         return SleepType::None;</span>
<span class="line-added">6911 </span>
<span class="line-added">6912     bool shouldBeAbleToSleep = mediaType() != PlatformMediaSession::VideoAudio;</span>
6913 #if ENABLE(MEDIA_STREAM)
6914     // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
6915     // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
6916     shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
6917 #endif
6918 
6919     if (shouldBeAbleToSleep)
6920         return SleepType::None;
6921 
6922     if (m_elementIsHidden)
6923         return SleepType::System;
6924 
6925     return SleepType::Display;
6926 }
6927 
6928 String HTMLMediaElement::mediaPlayerReferrer() const
6929 {
6930     RefPtr&lt;Frame&gt; frame = document().frame();
6931     if (!frame)
6932         return String();
</pre>
<hr />
<pre>
7079 {
7080     return paused();
7081 }
7082 
7083 bool HTMLMediaElement::mediaPlayerIsLooping() const
7084 {
7085     return loop();
7086 }
7087 
7088 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7089 {
7090     return &amp;document().cachedResourceLoader();
7091 }
7092 
7093 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7094 {
7095     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7096 
7097     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7098 
<span class="line-modified">7099     return mediaResourceLoader;</span>
7100 }
7101 
7102 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7103 {
7104     return m_lastMediaResourceLoaderForTesting.get();
7105 }
7106 
7107 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7108 {
7109     if (Page* page = document().page())
7110         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabled();
7111 
7112     return false;
7113 }
7114 
7115 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7116 {
7117     return mediaCacheDirectory();
7118 }
7119 
7120 String HTMLMediaElement::sourceApplicationIdentifier() const
7121 {
7122     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7123         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7124             return networkingContext-&gt;sourceApplicationIdentifier();
7125     }
7126     return emptyString();
7127 }
7128 
7129 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7130 {

7131     if (Page* page = document().page())
7132         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();

7133     return Vector&lt;String&gt;();
7134 }
7135 
7136 #if PLATFORM(IOS_FAMILY)
7137 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7138 {
7139     return DeprecatedGlobalSettings::networkInterfaceName();
7140 }
7141 
7142 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7143 {
7144     if (auto* page = document().page())
7145         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7146     return false;
7147 }
7148 #endif
7149 
7150 bool HTMLMediaElement::mediaPlayerIsInMediaDocument() const
7151 {
7152     return document().isMediaDocument();
</pre>
<hr />
<pre>
7178 
7179     if (m_loadState == LoadingFromSourceElement &amp;&amp; m_currentSourceNode &amp;&amp; !m_nextChildNodeToConsider)
7180         return false;
7181 
7182     if (m_loadState == LoadingFromSrcAttr)
7183         return false;
7184 
7185     return true;
7186 }
7187 
7188 #if USE(GSTREAMER)
7189 void HTMLMediaElement::requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback)
7190 {
7191     if (!document().page())
7192         return;
7193 
7194     document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
7195 }
7196 #endif
7197 
<span class="line-modified">7198 void HTMLMediaElement::removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)</span>
7199 {
7200     MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
7201         (MediaElementSession::RequireUserGestureForLoad
7202 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7203         | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
7204         | MediaElementSession::RequireUserGestureToAutoplayToExternalDevice
7205 #endif
7206         | MediaElementSession::RequireUserGestureForVideoRateChange
7207         | MediaElementSession::RequireUserGestureForAudioRateChange
7208         | MediaElementSession::RequireUserGestureForFullscreen
7209         | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
7210         | MediaElementSession::InvisibleAutoplayNotPermitted
7211         | MediaElementSession::RequireUserGestureToControlControlsManager);
7212 
<span class="line-added">7213     m_removedBehaviorRestrictionsAfterFirstUserGesture = true;</span>
<span class="line-added">7214 </span>
7215     m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
7216     document().topDocument().noteUserInteractionWithMediaElement();
7217 }
7218 
7219 void HTMLMediaElement::updateRateChangeRestrictions()
7220 {
7221     const auto&amp; document = this-&gt;document();
7222     if (!document.ownerElement() &amp;&amp; document.isMediaDocument())
7223         return;
7224 
7225     const auto&amp; topDocument = document.topDocument();
7226     if (topDocument.videoPlaybackRequiresUserGesture())
7227         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7228     else
7229         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7230 
7231     if (topDocument.audioPlaybackRequiresUserGesture())
7232         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7233     else
7234         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
</pre>
<hr />
<pre>
7244         return VideoPlaybackQuality::create(timestamp, { });
7245 
7246 #if ENABLE(MEDIA_SOURCE)
7247     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7248     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7249 #endif
7250 
7251     return VideoPlaybackQuality::create(timestamp, metrics.value());
7252 }
7253 
7254 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7255 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7256 {
7257     if (!m_isolatedWorld)
7258         m_isolatedWorld = DOMWrapperWorld::create(commonVM());
7259     return *m_isolatedWorld;
7260 }
7261 
7262 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7263 {
<span class="line-modified">7264     INFO_LOG(LOGIDENTIFIER);</span>
7265 
7266     Page* page = document().page();
7267     if (!page)
7268         return false;
7269 
7270     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7271     if (!mediaControlsScript.length())
7272         return false;
7273 
7274     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {
7275         auto&amp; vm = globalObject.vm();
7276         auto scope = DECLARE_CATCH_SCOPE(vm);
7277 
<span class="line-modified">7278         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7279         if (functionValue.isFunction(vm))
7280             return true;
7281 
7282 #ifndef NDEBUG
7283         // Setting a scriptURL allows the source to be debuggable in the inspector.
7284         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7285 #else
7286         URL scriptURL;
7287 #endif
7288         scriptController.evaluateInWorld(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);
7289         if (UNLIKELY(scope.exception())) {
7290             scope.clearException();
7291             return false;
7292         }
7293 
7294         return true;
7295     });
7296 }
7297 
7298 void HTMLMediaElement::updatePageScaleFactorJSProperty()
</pre>
<hr />
<pre>
7310     if (!page)
7311         return;
7312 
7313     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7314     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7315 }
7316 
7317 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7318 {
7319     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7320         auto&amp; vm = globalObject.vm();
7321         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7322         if (controllerValue.isNull())
7323             return false;
7324 
7325         JSC::PutPropertySlot propertySlot(controllerValue);
7326         auto* controllerObject = controllerValue.toObject(&amp;exec);
7327         if (!controllerObject)
7328             return false;
7329 
<span class="line-modified">7330         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;exec, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
7331 
7332         return true;
7333     });
7334 }
7335 
7336 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7337 {
<span class="line-modified">7338     INFO_LOG(LOGIDENTIFIER);</span>
7339 
7340     if (!ensureMediaControlsInjectedScript())
7341         return;
7342 
7343     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7344         auto&amp; vm = globalObject.vm();
7345         auto scope = DECLARE_CATCH_SCOPE(vm);
7346 
7347         // The media controls script must provide a method with the following details.
7348         // Name: createControls
7349         // Parameters:
7350         //     1. The ShadowRoot element that will hold the controls.
7351         //     2. This object (and HTMLMediaElement).
7352         //     3. The MediaControlsHost object.
7353         // Return value:
7354         //     A reference to the created media controller instance.
7355 
<span class="line-modified">7356         auto functionValue = globalObject.get(&amp;exec, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7357         if (functionValue.isUndefinedOrNull())
7358             return false;
7359 
7360         if (!m_mediaControlsHost)
7361             m_mediaControlsHost = MediaControlsHost::create(this);
7362 
7363         auto mediaJSWrapper = toJS(&amp;exec, &amp;globalObject, *this);
7364         auto mediaControlsHostJSWrapper = toJS(&amp;exec, &amp;globalObject, *m_mediaControlsHost);
7365 
7366         JSC::MarkedArgumentBuffer argList;
7367         argList.append(toJS(&amp;exec, &amp;globalObject, root));
7368         argList.append(mediaJSWrapper);
7369         argList.append(mediaControlsHostJSWrapper);
7370         ASSERT(!argList.hasOverflowed());
7371 
7372         auto* function = functionValue.toObject(&amp;exec);
7373         scope.assertNoException();
7374         JSC::CallData callData;
7375         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7376         if (callType == JSC::CallType::None)
7377             return false;
7378 
7379         auto controllerValue = JSC::call(&amp;exec, function, callType, callData, &amp;globalObject, argList);
7380         scope.clearException();
7381         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7382         if (!controllerObject)
7383             return false;
7384 
7385         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
7386         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;exec);
7387         scope.assertNoException();
<span class="line-modified">7388         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);</span>
7389 
7390         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;exec, controlsHost));
7391 
<span class="line-modified">7392         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7393 
7394         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7395         if (!mediaControlsHostJSWrapperObject)
7396             return false;
7397 
<span class="line-modified">7398         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);</span>
7399 
7400         ASSERT(!controllerObject-&gt;hasProperty(&amp;exec, controller));
7401 
<span class="line-modified">7402         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
7403 
7404         updatePageScaleFactorJSProperty();
7405         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7406 
7407         if (UNLIKELY(scope.exception()))
7408             scope.clearException();
7409 
7410         return true;
7411     });
7412 }
7413 
7414 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7415 {
<span class="line-modified">7416     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);</span>
7417 
7418     if (document().settings().mediaControlsScaleWithPageZoom()) {
<span class="line-modified">7419         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);</span>
7420         m_mediaControlsDependOnPageScaleFactor = false;
7421         return;
7422     }
7423 
7424     if (m_mediaControlsDependOnPageScaleFactor == dependsOnPageScale)
7425         return;
7426 
7427     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
7428 
7429     if (m_mediaControlsDependOnPageScaleFactor)
7430         document().registerForPageScaleFactorChangedCallbacks(*this);
7431     else
7432         document().unregisterForPageScaleFactorChangedCallbacks(*this);
7433 }
7434 
7435 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7436 {
7437     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7438     // stopped/suspended the object.
7439     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7440         return;
7441 
<span class="line-added">7442     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())</span>
<span class="line-added">7443         return;</span>
<span class="line-added">7444 </span>
7445     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7446         auto&amp; vm = globalObject.vm();
7447         auto scope = DECLARE_THROW_SCOPE(vm);
7448 
7449         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7450         auto* controllerObject = controllerValue.toObject(&amp;exec);
7451 
7452         RETURN_IF_EXCEPTION(scope, false);
7453 
<span class="line-modified">7454         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
7455         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7456             return false;
7457 
7458         auto* function = functionValue.toObject(&amp;exec);
7459         scope.assertNoException();
7460         JSC::CallData callData;
7461         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7462         if (callType == JSC::CallType::None)
7463             return false;
7464 
7465         JSC::MarkedArgumentBuffer argList;
7466         ASSERT(!argList.hasOverflowed());
7467         JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7468 
7469         return true;
7470     });
7471 }
7472 
7473 void HTMLMediaElement::pageScaleFactorChanged()
7474 {
</pre>
<hr />
<pre>
7477 
7478 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7479 {
7480     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7481 }
7482 
7483 String HTMLMediaElement::getCurrentMediaControlsStatus()
7484 {
7485     ensureMediaControlsShadowRoot();
7486 
7487     String status;
7488     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::ExecState&amp; exec, ScriptController&amp;, DOMWrapperWorld&amp;) {
7489         auto&amp; vm = globalObject.vm();
7490         auto scope = DECLARE_THROW_SCOPE(vm);
7491 
7492         auto controllerValue = controllerJSValue(exec, globalObject, *this);
7493         auto* controllerObject = controllerValue.toObject(&amp;exec);
7494 
7495         RETURN_IF_EXCEPTION(scope, false);
7496 
<span class="line-modified">7497         auto functionValue = controllerObject-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
7498         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7499             return false;
7500 
7501         auto* function = functionValue.toObject(&amp;exec);
7502         scope.assertNoException();
7503         JSC::CallData callData;
7504         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7505         JSC::MarkedArgumentBuffer argList;
7506         ASSERT(!argList.hasOverflowed());
7507         if (callType == JSC::CallType::None)
7508             return false;
7509 
7510         auto outputValue = JSC::call(&amp;exec, function, callType, callData, controllerObject, argList);
7511 
7512         RETURN_IF_EXCEPTION(scope, false);
7513 
7514         status = outputValue.getString(&amp;exec);
7515         return true;
7516     });
7517 
</pre>
<hr />
<pre>
7624 }
7625 
7626 String HTMLMediaElement::mediaSessionTitle() const
7627 {
7628     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7629         return emptyString();
7630 
7631     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7632     if (!title.isEmpty())
7633         return title;
7634 
7635     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7636     if (!title.isEmpty())
7637         return title;
7638 
7639     title = m_currentSrc.host().toString();
7640 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
7641     if (!title.isEmpty())
7642         title = decodeHostName(title);
7643 #endif

7644     if (!title.isEmpty()) {
<span class="line-modified">7645         auto domain = RegistrableDomain { m_currentSrc };</span>
7646         if (!domain.isEmpty())
<span class="line-modified">7647             title = domain.string();</span>
7648     }

7649 
7650     return title;
7651 }
7652 
7653 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7654 {
7655     auto&amp; url = m_currentSrc.string();
7656     return url.impl() ? url.impl()-&gt;hash() : 0;
7657 }
7658 
7659 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7660 {
7661     INFO_LOG(LOGIDENTIFIER, command);
7662 
7663     UserGestureIndicator remoteControlUserGesture(ProcessingUserGesture, &amp;document());
7664     switch (command) {
7665     case PlatformMediaSession::PlayCommand:
7666         play();
7667         break;
7668     case PlatformMediaSession::StopCommand:
</pre>
<hr />
<pre>
7675     case PlatformMediaSession::BeginSeekingBackwardCommand:
7676         beginScanning(Backward);
7677         break;
7678     case PlatformMediaSession::BeginSeekingForwardCommand:
7679         beginScanning(Forward);
7680         break;
7681     case PlatformMediaSession::EndSeekingBackwardCommand:
7682     case PlatformMediaSession::EndSeekingForwardCommand:
7683         endScanning();
7684         break;
7685     case PlatformMediaSession::SeekToPlaybackPositionCommand:
7686         ASSERT(argument);
7687         if (argument)
7688             handleSeekToPlaybackPosition(argument-&gt;asDouble);
7689         break;
7690     default:
7691         { } // Do nothing
7692     }
7693 }
7694 









7695 bool HTMLMediaElement::supportsSeeking() const
7696 {
<span class="line-modified">7697     return !document().quirks().needsSeekingSupportDisabled() &amp;&amp; !isLiveStream();</span>
7698 }
7699 
7700 bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
7701 {
7702     if (type == PlatformMediaSession::EnteringBackground) {
7703         if (isPlayingToExternalTarget()) {
7704             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7705             return true;
7706         }
<span class="line-added">7707         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">7708             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">7709             return true;</span>
<span class="line-added">7710         }</span>
7711         if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7712             return true;
7713 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
7714         if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
7715             return true;
7716 #endif
7717     } else if (type == PlatformMediaSession::SuspendedUnderLock) {
7718         if (isPlayingToExternalTarget()) {
7719             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7720             return true;
7721         }
<span class="line-added">7722         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {</span>
<span class="line-added">7723             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);</span>
<span class="line-added">7724             return true;</span>
<span class="line-added">7725         }</span>
7726     }
7727     return false;
7728 }
7729 
7730 bool HTMLMediaElement::processingUserGestureForMedia() const
7731 {
7732     return document().processingUserGestureForMedia();
7733 }
<span class="line-added">7734 </span>
<span class="line-added">7735 void HTMLMediaElement::processIsSuspendedChanged()</span>
<span class="line-added">7736 {</span>
<span class="line-added">7737     updateSleepDisabling();</span>
<span class="line-added">7738 }</span>
<span class="line-added">7739 </span>
7740 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7741 
7742 void HTMLMediaElement::scheduleUpdateMediaState()
7743 {
7744     if (m_updateMediaStateTask.hasPendingTask())
7745         return;
7746 
7747     auto logSiteIdentifier = LOGIDENTIFIER;
7748     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
7749     m_updateMediaStateTask.scheduleTask([this, logSiteIdentifier] {
7750         UNUSED_PARAM(logSiteIdentifier);
7751         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
7752         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaState calls methods that can trigger arbitrary DOM mutations.
7753         updateMediaState();
7754     });
7755 }
7756 
7757 void HTMLMediaElement::updateMediaState()
7758 {
7759     MediaProducer::MediaStateFlags state = mediaState();
</pre>
<hr />
<pre>
7848     ALWAYS_LOG(LOGIDENTIFIER, reason);
7849 
7850     m_autoplayEventPlaybackState = reason;
7851 
7852     if (reason == AutoplayEventPlaybackState::PreventedAutoplay) {
7853         dispatchPlayPauseEventsIfNeedsQuirks();
7854         handleAutoplayEvent(AutoplayEvent::DidPreventMediaFromPlaying);
7855     }
7856 }
7857 
7858 void HTMLMediaElement::pageMutedStateDidChange()
7859 {
7860     updateVolume();
7861 
7862     if (Page* page = document().page()) {
7863         if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
7864             userDidInterfereWithAutoplay();
7865     }
7866 }
7867 
<span class="line-added">7868 double HTMLMediaElement::effectiveVolume() const</span>
<span class="line-added">7869 {</span>
<span class="line-added">7870     auto* page = document().page();</span>
<span class="line-added">7871     double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;</span>
<span class="line-added">7872     if (m_mediaController)</span>
<span class="line-added">7873         volumeMultiplier *= m_mediaController-&gt;volume();</span>
<span class="line-added">7874 #if ENABLE(MEDIA_SESSION)</span>
<span class="line-added">7875     if (m_shouldDuck)</span>
<span class="line-added">7876         volumeMultiplier *= 0.25;</span>
<span class="line-added">7877 #endif</span>
<span class="line-added">7878 </span>
<span class="line-added">7879     return m_volume * volumeMultiplier;</span>
<span class="line-added">7880 }</span>
<span class="line-added">7881 </span>
7882 bool HTMLMediaElement::effectiveMuted() const
7883 {
<span class="line-modified">7884     return muted() || (m_mediaController &amp;&amp; m_mediaController-&gt;muted()) || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());</span>
7885 }
7886 
<span class="line-modified">7887 bool HTMLMediaElement::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const</span>
7888 {
7889     QualifiedName attributeName(nullAtom(), attribute, nullAtom());
7890 
7891     auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
7892     if (elementValue.isNull())
7893         return false;
7894 
7895     if (attributeName == HTMLNames::x_itunes_inherit_uri_query_componentAttr &amp;&amp; !document().settings().enableInheritURIQueryComponent())
7896         return false;
7897 
7898     if (value)
7899         *value = elementValue;
7900 
7901     return true;
7902 }
7903 
<span class="line-modified">7904 void HTMLMediaElement::setBufferingPolicy(BufferingPolicy policy)</span>
7905 {
<span class="line-modified">7906     if (policy == m_bufferingPolicy)</span>
7907         return;
7908 
<span class="line-modified">7909     INFO_LOG(LOGIDENTIFIER, policy);</span>
<span class="line-added">7910 </span>
<span class="line-added">7911     m_bufferingPolicy = policy;</span>
7912     if (m_player)
<span class="line-modified">7913         m_player-&gt;setBufferingPolicy(policy);</span>
7914 }
7915 
7916 void HTMLMediaElement::purgeBufferedDataIfPossible()
7917 {
<span class="line-modified">7918     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-modified">7919 </span>
<span class="line-added">7920     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)</span>
7921         return;
7922 
7923     if (isPlayingToExternalTarget()) {
7924         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7925         return;
7926     }
7927 
<span class="line-modified">7928     setBufferingPolicy(BufferingPolicy::PurgeResources);</span>






7929 }
7930 
7931 bool HTMLMediaElement::canSaveMediaData() const
7932 {
7933     if (m_player)
7934         return m_player-&gt;canSaveMediaData();
7935 
7936     return false;
7937 }
7938 
7939 #if ENABLE(MEDIA_SESSION)
7940 double HTMLMediaElement::playerVolume() const
7941 {
7942     return m_player ? m_player-&gt;volume() : 0;
7943 }
7944 
7945 MediaSession* HTMLMediaElement::session() const
7946 {
7947     RefPtr&lt;MediaSession&gt; session = m_session.get();
7948     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
</pre>
<hr />
<pre>
8130 {
8131     if (m_player)
8132         m_player-&gt;applicationWillResignActive();
8133 }
8134 
8135 void HTMLMediaElement::applicationDidBecomeActive()
8136 {
8137     if (m_player)
8138         m_player-&gt;applicationDidBecomeActive();
8139 }
8140 
8141 void HTMLMediaElement::setInActiveDocument(bool inActiveDocument)
8142 {
8143     if (inActiveDocument == m_inActiveDocument)
8144         return;
8145 
8146     m_inActiveDocument = inActiveDocument;
8147     m_mediaSession-&gt;inActiveDocumentChanged();
8148 }
8149 
<span class="line-added">8150 HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const</span>
<span class="line-added">8151 {</span>
<span class="line-added">8152     return m_bufferingPolicy;</span>
<span class="line-added">8153 }</span>
<span class="line-added">8154 </span>
<span class="line-added">8155 bool HTMLMediaElement::hasMediaStreamSource() const</span>
<span class="line-added">8156 {</span>
<span class="line-added">8157 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">8158     return hasMediaStreamSrcObject();</span>
<span class="line-added">8159 #else</span>
<span class="line-added">8160     return false;</span>
<span class="line-added">8161 #endif</span>
<span class="line-added">8162 }</span>
<span class="line-added">8163 </span>
8164 }
8165 
8166 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLMarqueeElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMediaElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>