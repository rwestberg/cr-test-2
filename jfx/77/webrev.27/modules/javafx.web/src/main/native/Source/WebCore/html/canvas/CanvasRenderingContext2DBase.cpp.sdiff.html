<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CanvasRenderingContext2D.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/CanvasRenderingContext2DBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;CanvasRenderingContext2DBase.h&quot;
  35 
  36 #include &quot;BitmapImage.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSParser.h&quot;
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CachedImage.h&quot;
  41 #include &quot;CanvasGradient.h&quot;
  42 #include &quot;CanvasPattern.h&quot;
  43 #include &quot;DOMMatrix.h&quot;
  44 #include &quot;DOMMatrix2DInit.h&quot;
  45 #include &quot;DisplayListRecorder.h&quot;
  46 #include &quot;DisplayListReplayer.h&quot;
  47 #include &quot;FloatQuad.h&quot;

  48 #include &quot;HTMLImageElement.h&quot;
  49 #include &quot;HTMLVideoElement.h&quot;
  50 #include &quot;ImageBitmap.h&quot;
  51 #include &quot;ImageBuffer.h&quot;
  52 #include &quot;ImageData.h&quot;
  53 #include &quot;Path2D.h&quot;
  54 #include &quot;RenderElement.h&quot;
  55 #include &quot;RenderImage.h&quot;
  56 #include &quot;RenderLayer.h&quot;
  57 #include &quot;RenderTheme.h&quot;
  58 #include &quot;SecurityOrigin.h&quot;

  59 #include &quot;StrokeStyleApplier.h&quot;
  60 #include &quot;StyleProperties.h&quot;
  61 #include &quot;StyleResolver.h&quot;
  62 #include &quot;TextMetrics.h&quot;
  63 #include &quot;TextRun.h&quot;
  64 #include &quot;TypedOMCSSImageValue.h&quot;
  65 #include &lt;wtf/CheckedArithmetic.h&gt;

  66 #include &lt;wtf/MathExtras.h&gt;
  67 #include &lt;wtf/NeverDestroyed.h&gt;
  68 #include &lt;wtf/text/StringBuilder.h&gt;
  69 #include &lt;wtf/text/TextStream.h&gt;
  70 
  71 namespace WebCore {
  72 
  73 using namespace HTMLNames;
  74 


  75 #if USE(CG)
  76 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Low;
  77 #else
  78 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Medium;
  79 #endif
  80 
  81 const int CanvasRenderingContext2DBase::DefaultFontSize = 10;
  82 const char* const CanvasRenderingContext2DBase::DefaultFontFamily = &quot;sans-serif&quot;;
  83 const char* const CanvasRenderingContext2DBase::DefaultFont = &quot;10px sans-serif&quot;;
  84 
  85 struct DisplayListDrawingContext {
  86     WTF_MAKE_FAST_ALLOCATED;
  87 public:
  88     GraphicsContext context;
  89     DisplayList::DisplayList displayList;
  90 
  91     DisplayListDrawingContext(GraphicsContext&amp; context, const FloatRect&amp; clip)
  92         : DisplayListDrawingContext(context.state(), clip)
  93     {
  94     }
  95 
  96     DisplayListDrawingContext(const GraphicsContextState&amp; state, const FloatRect&amp; clip)
  97         : context([&amp;](GraphicsContext&amp; displayListContext) {
<span class="line-modified">  98             return std::make_unique&lt;DisplayList::Recorder&gt;(displayListContext, displayList, state, clip, AffineTransform());</span>
  99         })
 100     {
 101     }
 102 };
 103 
 104 typedef HashMap&lt;const CanvasRenderingContext2DBase*, std::unique_ptr&lt;DisplayList::DisplayList&gt;&gt; ContextDisplayListHashMap;
 105 
 106 static ContextDisplayListHashMap&amp; contextDisplayListMap()
 107 {
 108     static NeverDestroyed&lt;ContextDisplayListHashMap&gt; sharedHashMap;
 109     return sharedHashMap;
 110 }
 111 
 112 class CanvasStrokeStyleApplier : public StrokeStyleApplier {
 113 public:
 114     CanvasStrokeStyleApplier(CanvasRenderingContext2DBase* canvasContext)
 115         : m_canvasContext(canvasContext)
 116     {
 117     }
 118 
 119     void strokeStyle(GraphicsContext* c) override
 120     {
 121         c-&gt;setStrokeThickness(m_canvasContext-&gt;lineWidth());
 122         c-&gt;setLineCap(m_canvasContext-&gt;getLineCap());
 123         c-&gt;setLineJoin(m_canvasContext-&gt;getLineJoin());
 124         c-&gt;setMiterLimit(m_canvasContext-&gt;miterLimit());
 125         const Vector&lt;float&gt;&amp; lineDash = m_canvasContext-&gt;getLineDash();
 126         DashArray convertedLineDash(lineDash.size());
 127         for (size_t i = 0; i &lt; lineDash.size(); ++i)
 128             convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(lineDash[i]);
 129         c-&gt;setLineDash(convertedLineDash, m_canvasContext-&gt;lineDashOffset());
 130     }
 131 
 132 private:
 133     CanvasRenderingContext2DBase* m_canvasContext;
 134 };
 135 
<span class="line-modified"> 136 CanvasRenderingContext2DBase::CanvasRenderingContext2DBase(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode, bool usesDashboardCompatibilityMode)</span>
 137     : CanvasRenderingContext(canvas)
 138     , m_stateStack(1)
 139     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)
<span class="line-removed"> 140 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 141     , m_usesDashboardCompatibilityMode(usesDashboardCompatibilityMode)</span>
<span class="line-removed"> 142 #endif</span>
 143 {
<span class="line-removed"> 144 #if !ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed"> 145     ASSERT_UNUSED(usesDashboardCompatibilityMode, !usesDashboardCompatibilityMode);</span>
<span class="line-removed"> 146 #endif</span>
 147 }
 148 
 149 void CanvasRenderingContext2DBase::unwindStateStack()
 150 {
 151     // Ensure that the state stack in the ImageBuffer&#39;s context
 152     // is cleared before destruction, to avoid assertions in the
 153     // GraphicsContext dtor.
 154     if (size_t stackSize = m_stateStack.size()) {
 155         if (auto* context = canvasBase().existingDrawingContext()) {
 156             while (--stackSize)
 157                 context-&gt;restore();
 158         }
 159     }
 160 }
 161 
 162 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 163 {
 164 #if !ASSERT_DISABLED
 165     unwindStateStack();
 166 #endif
</pre>
<hr />
<pre>
 301 
 302 inline void CanvasRenderingContext2DBase::FontProxy::update(FontSelector&amp; selector)
 303 {
 304     ASSERT(&amp;selector == m_font.fontSelector()); // This is an invariant. We should only ever be registered for callbacks on m_font.m_fonts.m_fontSelector.
 305     if (realized())
 306         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 307     m_font.update(&amp;selector);
 308     if (realized())
 309         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 310     ASSERT(&amp;selector == m_font.fontSelector());
 311 }
 312 
 313 void CanvasRenderingContext2DBase::FontProxy::fontsNeedUpdate(FontSelector&amp; selector)
 314 {
 315     ASSERT_ARG(selector, &amp;selector == m_font.fontSelector());
 316     ASSERT(realized());
 317 
 318     update(selector);
 319 }
 320 
<span class="line-modified"> 321 inline void CanvasRenderingContext2DBase::FontProxy::initialize(FontSelector&amp; fontSelector, const RenderStyle&amp; newStyle)</span>
 322 {
 323     // Beware! m_font.fontSelector() might not point to document.fontSelector()!
 324     ASSERT(newStyle.fontCascade().fontSelector() == &amp;fontSelector);
 325     if (realized())
 326         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 327     m_font = newStyle.fontCascade();
 328     m_font.update(&amp;fontSelector);
 329     ASSERT(&amp;fontSelector == m_font.fontSelector());
 330     m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 331 }
 332 
<span class="line-modified"> 333 inline const FontMetrics&amp; CanvasRenderingContext2DBase::FontProxy::fontMetrics() const</span>
 334 {
 335     return m_font.fontMetrics();
 336 }
 337 
<span class="line-modified"> 338 inline const FontCascadeDescription&amp; CanvasRenderingContext2DBase::FontProxy::fontDescription() const</span>
 339 {
 340     return m_font.fontDescription();
 341 }
 342 
<span class="line-modified"> 343 inline float CanvasRenderingContext2DBase::FontProxy::width(const TextRun&amp; textRun, GlyphOverflow* overflow) const</span>
 344 {
 345     return m_font.width(textRun, 0, overflow);
 346 }
 347 
<span class="line-modified"> 348 inline void CanvasRenderingContext2DBase::FontProxy::drawBidiText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction action) const</span>
 349 {
 350     context.drawBidiText(m_font, run, point, action);
 351 }
 352 
 353 void CanvasRenderingContext2DBase::realizeSaves()
 354 {
 355     if (m_unrealizedSaveCount)
 356         realizeSavesLoop();
 357 
 358     if (m_unrealizedSaveCount) {
 359         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;CanvasRenderingContext2D.save() has been called without a matching restore() too many times. Ignoring save().&quot;));
 360 
 361         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage);
 362     }
 363 }
 364 
 365 void CanvasRenderingContext2DBase::realizeSavesLoop()
 366 {
 367     ASSERT(m_unrealizedSaveCount);
 368     ASSERT(m_stateStack.size() &gt;= 1);
</pre>
<hr />
<pre>
 898 
 899 void CanvasRenderingContext2DBase::setTransform(float m11, float m12, float m21, float m22, float dx, float dy)
 900 {
 901     GraphicsContext* c = drawingContext();
 902     if (!c)
 903         return;
 904 
 905     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 906         return;
 907 
 908     resetTransform();
 909     transform(m11, m12, m21, m22, dx, dy);
 910 }
 911 
 912 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::setTransform(DOMMatrix2DInit&amp;&amp; matrixInit)
 913 {
 914     auto checkValid = DOMMatrixReadOnly::validateAndFixup(matrixInit);
 915     if (checkValid.hasException())
 916         return checkValid.releaseException();
 917 
<span class="line-modified"> 918     setTransform(matrixInit.a.valueOr(1), matrixInit.b.valueOr(0), matrixInit.c.valueOr(0), matrixInit.d.valueOr(1), matrixInit.e.valueOr(0), matrixInit.f.valueOr(0));</span>
 919     return { };
 920 }
 921 
 922 void CanvasRenderingContext2DBase::resetTransform()
 923 {
 924     GraphicsContext* c = drawingContext();
 925     if (!c)
 926         return;
 927 
 928     AffineTransform ctm = state().transform;
 929     bool hasInvertibleTransform = state().hasInvertibleTransform;
 930 
 931     realizeSaves();
 932 
 933     c-&gt;setCTM(canvasBase().baseTransform());
 934     modifiableState().transform = AffineTransform();
 935 
 936     if (hasInvertibleTransform)
 937         m_path.transform(ctm);
 938 
</pre>
<hr />
<pre>
1036 
1037     return true;
1038 }
1039 
1040 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1041 {
1042     // See 4.8.11.1.3 Compositing
1043     // CompositeSourceAtop and CompositeDestinationOut are not listed here as the platforms already
1044     // implement the specification&#39;s behavior.
1045     return op == CompositeSourceIn || op == CompositeSourceOut || op == CompositeDestinationIn || op == CompositeDestinationAtop;
1046 }
1047 
1048 static WindRule toWindRule(CanvasFillRule rule)
1049 {
1050     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1051 }
1052 
1053 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1054 {
1055     fillInternal(m_path, windingRule);
<span class="line-removed">1056     clearPathForDashboardBackwardCompatibilityMode();</span>
1057 }
1058 
1059 void CanvasRenderingContext2DBase::stroke()
1060 {
1061     strokeInternal(m_path);
<span class="line-removed">1062     clearPathForDashboardBackwardCompatibilityMode();</span>
1063 }
1064 
1065 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1066 {
1067     clipInternal(m_path, windingRule);
<span class="line-removed">1068     clearPathForDashboardBackwardCompatibilityMode();</span>
1069 }
1070 
1071 void CanvasRenderingContext2DBase::fill(Path2D&amp; path, CanvasFillRule windingRule)
1072 {
1073     fillInternal(path.path(), windingRule);
1074 }
1075 
1076 void CanvasRenderingContext2DBase::stroke(Path2D&amp; path)
1077 {
1078     strokeInternal(path.path());
1079 }
1080 
1081 void CanvasRenderingContext2DBase::clip(Path2D&amp; path, CanvasFillRule windingRule)
1082 {
1083     clipInternal(path.path(), windingRule);
1084 }
1085 
1086 void CanvasRenderingContext2DBase::fillInternal(const Path&amp; path, CanvasFillRule windingRule)
1087 {
1088     auto* c = drawingContext();
</pre>
<hr />
<pre>
1145             FloatRect dirtyRect = path.fastBoundingRect();
1146             inflateStrokeRect(dirtyRect);
1147             c-&gt;strokePath(path);
1148             didDraw(dirtyRect);
1149         }
1150     }
1151 }
1152 
1153 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1154 {
1155     auto* c = drawingContext();
1156     if (!c)
1157         return;
1158     if (!state().hasInvertibleTransform)
1159         return;
1160 
1161     realizeSaves();
1162     c-&gt;canvasClip(path, toWindRule(windingRule));
1163 }
1164 
<span class="line-modified">1165 inline void CanvasRenderingContext2DBase::beginCompositeLayer()</span>
1166 {
1167 #if !USE(CAIRO)
1168     drawingContext()-&gt;beginTransparencyLayer(1);
1169 #endif
1170 }
1171 
<span class="line-modified">1172 inline void CanvasRenderingContext2DBase::endCompositeLayer()</span>
1173 {
1174 #if !USE(CAIRO)
1175     drawingContext()-&gt;endTransparencyLayer();
1176 #endif
1177 }
1178 
1179 bool CanvasRenderingContext2DBase::isPointInPath(float x, float y, CanvasFillRule windingRule)
1180 {
1181     return isPointInPathInternal(m_path, x, y, windingRule);
1182 }
1183 
1184 bool CanvasRenderingContext2DBase::isPointInStroke(float x, float y)
1185 {
1186     return isPointInStrokeInternal(m_path, x, y);
1187 }
1188 
1189 bool CanvasRenderingContext2DBase::isPointInPath(Path2D&amp; path, float x, float y, CanvasFillRule windingRule)
1190 {
1191     return isPointInPathInternal(path.path(), x, y, windingRule);
1192 }
</pre>
<hr />
<pre>
1558     GraphicsContext* c = drawingContext();
1559     if (!c)
1560         return { };
1561     if (!state().hasInvertibleTransform)
1562         return { };
1563 
1564     if (!cachedImage)
1565         return { };
1566 
1567     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1568     if (!image)
1569         return { };
1570 
1571     ImageObserver* observer = image-&gt;imageObserver();
1572 
1573     if (image-&gt;isSVGImage()) {
1574         image-&gt;setImageObserver(nullptr);
1575         image-&gt;setContainerSize(imageRect.size());
1576     }
1577 
<span class="line-modified">1578     if (image-&gt;isBitmapImage())</span>



1579         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());

1580 
1581     if (rectContainsCanvas(normalizedDstRect)) {
<span class="line-modified">1582         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));</span>
1583         didDrawEntireCanvas();
1584     } else if (isFullCanvasCompositeMode(op)) {
1585         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1586         didDrawEntireCanvas();
1587     } else if (op == CompositeCopy) {
1588         clearCanvas();
<span class="line-modified">1589         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));</span>
1590         didDrawEntireCanvas();
1591     } else {
<span class="line-modified">1592         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, ImagePaintingOptions(op, blendMode));</span>
1593         didDraw(normalizedDstRect);
1594     }
1595 
1596     if (image-&gt;isSVGImage())
1597         image-&gt;setImageObserver(observer);
1598 
1599     return { };
1600 }
1601 
1602 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLCanvasElement&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1603 {
1604     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1605 
1606     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1607         return Exception { InvalidStateError };
1608 
1609     if (!srcRect.width() || !srcRect.height())
1610         return Exception { IndexSizeError };
1611 
1612     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
</pre>
<hr />
<pre>
1620 
1621     // FIXME: Do this through platform-independent GraphicsContext API.
1622     ImageBuffer* buffer = sourceCanvas.buffer();
1623     if (!buffer)
1624         return { };
1625 
1626     checkOrigin(&amp;sourceCanvas);
1627 
1628 #if ENABLE(ACCELERATED_2D_CANVAS)
1629     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1630     // as that will do a readback to software.
1631     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1632     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1633     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1634         sourceCanvas.makeRenderingResultsAvailable();
1635 #else
1636     sourceCanvas.makeRenderingResultsAvailable();
1637 #endif
1638 
1639     if (rectContainsCanvas(dstRect)) {
<span class="line-modified">1640         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1641         didDrawEntireCanvas();
1642     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1643         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1644         didDrawEntireCanvas();
1645     } else if (state().globalComposite == CompositeCopy) {
1646         if (&amp;sourceCanvas == &amp;canvasBase()) {
1647             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpaceSRGB, *c)) {
1648                 clearCanvas();
<span class="line-modified">1649                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1650             }
1651         } else {
<span class="line-modified">1652         clearCanvas();</span>
<span class="line-modified">1653         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1654         }
1655         didDrawEntireCanvas();
1656     } else {
<span class="line-modified">1657         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1658         didDraw(dstRect);
1659     }
1660 
1661     return { };
1662 }
1663 
1664 #if ENABLE(VIDEO)
1665 
1666 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1667 {
1668     if (video.readyState() == HTMLMediaElement::HAVE_NOTHING || video.readyState() == HTMLMediaElement::HAVE_METADATA)
1669         return { };
1670 
1671     FloatRect videoRect = FloatRect(FloatPoint(), size(video));
1672     if (!srcRect.width() || !srcRect.height())
1673         return Exception { IndexSizeError };
1674 
1675     if (!videoRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1676         return { };
1677 
</pre>
<hr />
<pre>
1718         return Exception { IndexSizeError };
1719 
1720     FloatRect srcBitmapRect = FloatRect(FloatPoint(), FloatSize(imageBitmap.width(), imageBitmap.height()));
1721 
1722     if (!srcBitmapRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1723         return { };
1724 
1725     GraphicsContext* c = drawingContext();
1726     if (!c)
1727         return { };
1728     if (!state().hasInvertibleTransform)
1729         return { };
1730 
1731     ImageBuffer* buffer = imageBitmap.buffer();
1732     if (!buffer)
1733         return { };
1734 
1735     checkOrigin(&amp;imageBitmap);
1736 
1737     if (rectContainsCanvas(dstRect)) {
<span class="line-modified">1738         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1739         didDrawEntireCanvas();
1740     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1741         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1742         didDrawEntireCanvas();
1743     } else if (state().globalComposite == CompositeCopy) {
1744         clearCanvas();
<span class="line-modified">1745         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1746         didDrawEntireCanvas();
1747     } else {
<span class="line-modified">1748         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, ImagePaintingOptions(state().globalComposite, state().globalBlend));</span>
1749         didDraw(dstRect);
1750     }
1751 
1752     return { };
1753 }
1754 
1755 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1756 {
1757     CompositeOperator op;
1758     auto blendOp = BlendMode::Normal;
1759     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
1760         op = CompositeSourceOver;
1761     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1762 }
1763 
1764 void CanvasRenderingContext2DBase::clearCanvas()
1765 {
1766     auto* c = drawingContext();
1767     if (!c)
1768         return;
</pre>
<hr />
<pre>
1817 {
1818     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1819     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1820 
1821     auto* c = drawingContext();
1822     if (!c)
1823         return;
1824 
1825     c-&gt;save();
1826     c-&gt;setCTM(AffineTransform());
1827     c-&gt;setCompositeOperation(op);
1828 
1829     c-&gt;save();
1830     c-&gt;clipOut(bufferRect);
1831     c-&gt;clearRect(canvasRect);
1832     c-&gt;restore();
1833     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
1834     c-&gt;restore();
1835 }
1836 
<span class="line-modified">1837 static void drawImageToContext(Image&amp; image, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)</span>
1838 {
<span class="line-modified">1839     context.drawImage(image, dest, src, op);</span>
1840 }
1841 
<span class="line-modified">1842 static void drawImageToContext(ImageBuffer&amp; imageBuffer, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)</span>
1843 {
<span class="line-modified">1844     context.drawImageBuffer(imageBuffer, dest, src, op);</span>
1845 }
1846 
1847 template&lt;class T&gt; void CanvasRenderingContext2DBase::fullCanvasCompositedDrawImage(T&amp; image, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1848 {
1849     ASSERT(isFullCanvasCompositeMode(op));
1850 
1851     IntSize croppedOffset;
1852     auto bufferRect = calculateCompositingBufferRect(dest, &amp;croppedOffset);
1853     if (bufferRect.isEmpty()) {
1854         clearCanvas();
1855         return;
1856     }
1857 
1858     auto buffer = createCompositingBuffer(bufferRect);
1859     if (!buffer)
1860         return;
1861 
1862     auto* c = drawingContext();
1863     if (!c)
1864         return;
1865 
1866     FloatRect adjustedDest = dest;
1867     adjustedDest.setLocation(FloatPoint(0, 0));
1868     AffineTransform effectiveTransform = c-&gt;getCTM();
1869     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1870     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1871     buffer-&gt;context().translate(croppedOffset);
1872     buffer-&gt;context().concatCTM(effectiveTransform);
<span class="line-modified">1873     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, CompositeSourceOver);</span>
1874 
1875     compositeBuffer(*buffer, bufferRect, op);
1876 }
1877 
<span class="line-removed">1878 void CanvasRenderingContext2DBase::prepareGradientForDashboard(CanvasGradient&amp; gradient) const</span>
<span class="line-removed">1879 {</span>
<span class="line-removed">1880 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">1881     if (m_usesDashboardCompatibilityMode)</span>
<span class="line-removed">1882         gradient.setDashboardCompatibilityMode();</span>
<span class="line-removed">1883 #else</span>
<span class="line-removed">1884     UNUSED_PARAM(gradient);</span>
<span class="line-removed">1885 #endif</span>
<span class="line-removed">1886 }</span>
<span class="line-removed">1887 </span>
1888 static CanvasRenderingContext2DBase::Style toStyle(const CanvasStyle&amp; style)
1889 {
1890     if (auto gradient = style.canvasGradient())
1891         return gradient;
1892     if (auto pattern = style.canvasPattern())
1893         return pattern;
1894     return style.color();
1895 }
1896 
1897 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::strokeStyle() const
1898 {
1899     return toStyle(state().strokeStyle);
1900 }
1901 
1902 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1903 {
1904     WTF::switchOn(style,
1905         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1906         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1907         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
</pre>
<hr />
<pre>
1910 
1911 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::fillStyle() const
1912 {
1913     return toStyle(state().fillStyle);
1914 }
1915 
1916 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1917 {
1918     WTF::switchOn(style,
1919         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1920         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1921         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1922     );
1923 }
1924 
1925 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1926 {
1927     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1928         return Exception { NotSupportedError };
1929 
<span class="line-modified">1930     auto gradient = CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1));</span>
<span class="line-removed">1931     prepareGradientForDashboard(gradient.get());</span>
<span class="line-removed">1932     return WTFMove(gradient);</span>
1933 }
1934 
1935 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1936 {
1937     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1938         return Exception { NotSupportedError };
1939 
1940     if (r0 &lt; 0 || r1 &lt; 0)
1941         return Exception { IndexSizeError };
1942 
<span class="line-modified">1943     auto gradient = CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1);</span>
<span class="line-removed">1944     prepareGradientForDashboard(gradient.get());</span>
<span class="line-removed">1945     return WTFMove(gradient);</span>
1946 }
1947 
1948 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1949 {
1950     bool repeatX, repeatY;
1951     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1952         return Exception { SyntaxError };
1953 
1954     return WTF::switchOn(image,
1955         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1956     );
1957 }
1958 
1959 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1960 {
1961     auto* cachedImage = imageElement.cachedImage();
1962 
1963     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1964     if (!cachedImage || !imageElement.complete())
1965         return nullptr;
</pre>
<hr />
<pre>
2120         if (!m_recordingContext)
2121             return;
2122 
2123         FloatRect clip(FloatPoint::zero(), canvasBase().size());
2124         DisplayList::Replayer replayer(*canvasBase().drawingContext(), m_recordingContext-&gt;displayList);
2125 
2126         if (UNLIKELY(m_tracksDisplayListReplay)) {
2127             auto replayList = replayer.replay(clip, m_tracksDisplayListReplay);
2128             contextDisplayListMap().add(this, WTFMove(replayList));
2129         } else
2130             replayer.replay(clip);
2131 
2132         m_recordingContext-&gt;displayList.clear();
2133     }
2134 }
2135 
2136 GraphicsContext* CanvasRenderingContext2DBase::drawingContext() const
2137 {
2138     if (UNLIKELY(m_usesDisplayListDrawing)) {
2139         if (!m_recordingContext)
<span class="line-modified">2140             m_recordingContext = std::make_unique&lt;DisplayListDrawingContext&gt;(GraphicsContextState(), FloatRect(FloatPoint::zero(), canvasBase().size()));</span>
2141         return &amp;m_recordingContext-&gt;context;
2142     }
2143 
2144     return canvasBase().drawingContext();
2145 }
2146 
2147 static RefPtr&lt;ImageData&gt; createEmptyImageData(const IntSize&amp; size)
2148 {
2149     auto data = ImageData::create(size);
2150     if (data)
2151         data-&gt;data()-&gt;zeroFill();
2152     return data;
2153 }
2154 
2155 RefPtr&lt;ImageData&gt; CanvasRenderingContext2DBase::createImageData(ImageData&amp; imageData) const
2156 {
2157     return createEmptyImageData(imageData.size());
2158 }
2159 
2160 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::createImageData(float sw, float sh) const
</pre>
<hr />
<pre>
2349     if (enabled == state().imageSmoothingEnabled)
2350         return;
2351 
2352     realizeSaves();
2353     modifiableState().imageSmoothingEnabled = enabled;
2354     auto* c = drawingContext();
2355     if (c)
2356         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationNone);
2357 }
2358 
2359 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2360 {
2361     m_path = path.path();
2362 }
2363 
2364 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2365 {
2366     return Path2D::create(m_path);
2367 }
2368 
<span class="line-removed">2369 inline void CanvasRenderingContext2DBase::clearPathForDashboardBackwardCompatibilityMode()</span>
<span class="line-removed">2370 {</span>
<span class="line-removed">2371 #if ENABLE(DASHBOARD_SUPPORT)</span>
<span class="line-removed">2372     if (m_usesDashboardCompatibilityMode)</span>
<span class="line-removed">2373         m_path.clear();</span>
<span class="line-removed">2374 #endif</span>
<span class="line-removed">2375 }</span>
<span class="line-removed">2376 </span>
2377 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  28  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;CanvasRenderingContext2DBase.h&quot;
  35 
  36 #include &quot;BitmapImage.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSParser.h&quot;
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CachedImage.h&quot;
  41 #include &quot;CanvasGradient.h&quot;
  42 #include &quot;CanvasPattern.h&quot;
  43 #include &quot;DOMMatrix.h&quot;
  44 #include &quot;DOMMatrix2DInit.h&quot;
  45 #include &quot;DisplayListRecorder.h&quot;
  46 #include &quot;DisplayListReplayer.h&quot;
  47 #include &quot;FloatQuad.h&quot;
<span class="line-added">  48 #include &quot;HTMLCanvasElement.h&quot;</span>
  49 #include &quot;HTMLImageElement.h&quot;
  50 #include &quot;HTMLVideoElement.h&quot;
  51 #include &quot;ImageBitmap.h&quot;
  52 #include &quot;ImageBuffer.h&quot;
  53 #include &quot;ImageData.h&quot;
  54 #include &quot;Path2D.h&quot;
  55 #include &quot;RenderElement.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderLayer.h&quot;
  58 #include &quot;RenderTheme.h&quot;
  59 #include &quot;SecurityOrigin.h&quot;
<span class="line-added">  60 #include &quot;Settings.h&quot;</span>
  61 #include &quot;StrokeStyleApplier.h&quot;
  62 #include &quot;StyleProperties.h&quot;
  63 #include &quot;StyleResolver.h&quot;
  64 #include &quot;TextMetrics.h&quot;
  65 #include &quot;TextRun.h&quot;
  66 #include &quot;TypedOMCSSImageValue.h&quot;
  67 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-added">  68 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/NeverDestroyed.h&gt;
  71 #include &lt;wtf/text/StringBuilder.h&gt;
  72 #include &lt;wtf/text/TextStream.h&gt;
  73 
  74 namespace WebCore {
  75 
  76 using namespace HTMLNames;
  77 
<span class="line-added">  78 WTF_MAKE_ISO_ALLOCATED_IMPL(CanvasRenderingContext2DBase);</span>
<span class="line-added">  79 </span>
  80 #if USE(CG)
  81 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Low;
  82 #else
  83 const ImageSmoothingQuality defaultSmoothingQuality = ImageSmoothingQuality::Medium;
  84 #endif
  85 
  86 const int CanvasRenderingContext2DBase::DefaultFontSize = 10;
  87 const char* const CanvasRenderingContext2DBase::DefaultFontFamily = &quot;sans-serif&quot;;
  88 const char* const CanvasRenderingContext2DBase::DefaultFont = &quot;10px sans-serif&quot;;
  89 
  90 struct DisplayListDrawingContext {
  91     WTF_MAKE_FAST_ALLOCATED;
  92 public:
  93     GraphicsContext context;
  94     DisplayList::DisplayList displayList;
  95 
  96     DisplayListDrawingContext(GraphicsContext&amp; context, const FloatRect&amp; clip)
  97         : DisplayListDrawingContext(context.state(), clip)
  98     {
  99     }
 100 
 101     DisplayListDrawingContext(const GraphicsContextState&amp; state, const FloatRect&amp; clip)
 102         : context([&amp;](GraphicsContext&amp; displayListContext) {
<span class="line-modified"> 103             return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, displayList, state, clip, AffineTransform());</span>
 104         })
 105     {
 106     }
 107 };
 108 
 109 typedef HashMap&lt;const CanvasRenderingContext2DBase*, std::unique_ptr&lt;DisplayList::DisplayList&gt;&gt; ContextDisplayListHashMap;
 110 
 111 static ContextDisplayListHashMap&amp; contextDisplayListMap()
 112 {
 113     static NeverDestroyed&lt;ContextDisplayListHashMap&gt; sharedHashMap;
 114     return sharedHashMap;
 115 }
 116 
 117 class CanvasStrokeStyleApplier : public StrokeStyleApplier {
 118 public:
 119     CanvasStrokeStyleApplier(CanvasRenderingContext2DBase* canvasContext)
 120         : m_canvasContext(canvasContext)
 121     {
 122     }
 123 
 124     void strokeStyle(GraphicsContext* c) override
 125     {
 126         c-&gt;setStrokeThickness(m_canvasContext-&gt;lineWidth());
 127         c-&gt;setLineCap(m_canvasContext-&gt;getLineCap());
 128         c-&gt;setLineJoin(m_canvasContext-&gt;getLineJoin());
 129         c-&gt;setMiterLimit(m_canvasContext-&gt;miterLimit());
 130         const Vector&lt;float&gt;&amp; lineDash = m_canvasContext-&gt;getLineDash();
 131         DashArray convertedLineDash(lineDash.size());
 132         for (size_t i = 0; i &lt; lineDash.size(); ++i)
 133             convertedLineDash[i] = static_cast&lt;DashArrayElement&gt;(lineDash[i]);
 134         c-&gt;setLineDash(convertedLineDash, m_canvasContext-&gt;lineDashOffset());
 135     }
 136 
 137 private:
 138     CanvasRenderingContext2DBase* m_canvasContext;
 139 };
 140 
<span class="line-modified"> 141 CanvasRenderingContext2DBase::CanvasRenderingContext2DBase(CanvasBase&amp; canvas, bool usesCSSCompatibilityParseMode)</span>
 142     : CanvasRenderingContext(canvas)
 143     , m_stateStack(1)
 144     , m_usesCSSCompatibilityParseMode(usesCSSCompatibilityParseMode)



 145 {



 146 }
 147 
 148 void CanvasRenderingContext2DBase::unwindStateStack()
 149 {
 150     // Ensure that the state stack in the ImageBuffer&#39;s context
 151     // is cleared before destruction, to avoid assertions in the
 152     // GraphicsContext dtor.
 153     if (size_t stackSize = m_stateStack.size()) {
 154         if (auto* context = canvasBase().existingDrawingContext()) {
 155             while (--stackSize)
 156                 context-&gt;restore();
 157         }
 158     }
 159 }
 160 
 161 CanvasRenderingContext2DBase::~CanvasRenderingContext2DBase()
 162 {
 163 #if !ASSERT_DISABLED
 164     unwindStateStack();
 165 #endif
</pre>
<hr />
<pre>
 300 
 301 inline void CanvasRenderingContext2DBase::FontProxy::update(FontSelector&amp; selector)
 302 {
 303     ASSERT(&amp;selector == m_font.fontSelector()); // This is an invariant. We should only ever be registered for callbacks on m_font.m_fonts.m_fontSelector.
 304     if (realized())
 305         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 306     m_font.update(&amp;selector);
 307     if (realized())
 308         m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 309     ASSERT(&amp;selector == m_font.fontSelector());
 310 }
 311 
 312 void CanvasRenderingContext2DBase::FontProxy::fontsNeedUpdate(FontSelector&amp; selector)
 313 {
 314     ASSERT_ARG(selector, &amp;selector == m_font.fontSelector());
 315     ASSERT(realized());
 316 
 317     update(selector);
 318 }
 319 
<span class="line-modified"> 320 void CanvasRenderingContext2DBase::FontProxy::initialize(FontSelector&amp; fontSelector, const RenderStyle&amp; newStyle)</span>
 321 {
 322     // Beware! m_font.fontSelector() might not point to document.fontSelector()!
 323     ASSERT(newStyle.fontCascade().fontSelector() == &amp;fontSelector);
 324     if (realized())
 325         m_font.fontSelector()-&gt;unregisterForInvalidationCallbacks(*this);
 326     m_font = newStyle.fontCascade();
 327     m_font.update(&amp;fontSelector);
 328     ASSERT(&amp;fontSelector == m_font.fontSelector());
 329     m_font.fontSelector()-&gt;registerForInvalidationCallbacks(*this);
 330 }
 331 
<span class="line-modified"> 332 const FontMetrics&amp; CanvasRenderingContext2DBase::FontProxy::fontMetrics() const</span>
 333 {
 334     return m_font.fontMetrics();
 335 }
 336 
<span class="line-modified"> 337 const FontCascadeDescription&amp; CanvasRenderingContext2DBase::FontProxy::fontDescription() const</span>
 338 {
 339     return m_font.fontDescription();
 340 }
 341 
<span class="line-modified"> 342 float CanvasRenderingContext2DBase::FontProxy::width(const TextRun&amp; textRun, GlyphOverflow* overflow) const</span>
 343 {
 344     return m_font.width(textRun, 0, overflow);
 345 }
 346 
<span class="line-modified"> 347 void CanvasRenderingContext2DBase::FontProxy::drawBidiText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction action) const</span>
 348 {
 349     context.drawBidiText(m_font, run, point, action);
 350 }
 351 
 352 void CanvasRenderingContext2DBase::realizeSaves()
 353 {
 354     if (m_unrealizedSaveCount)
 355         realizeSavesLoop();
 356 
 357     if (m_unrealizedSaveCount) {
 358         static NeverDestroyed&lt;String&gt; consoleMessage(MAKE_STATIC_STRING_IMPL(&quot;CanvasRenderingContext2D.save() has been called without a matching restore() too many times. Ignoring save().&quot;));
 359 
 360         canvasBase().scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, consoleMessage);
 361     }
 362 }
 363 
 364 void CanvasRenderingContext2DBase::realizeSavesLoop()
 365 {
 366     ASSERT(m_unrealizedSaveCount);
 367     ASSERT(m_stateStack.size() &gt;= 1);
</pre>
<hr />
<pre>
 897 
 898 void CanvasRenderingContext2DBase::setTransform(float m11, float m12, float m21, float m22, float dx, float dy)
 899 {
 900     GraphicsContext* c = drawingContext();
 901     if (!c)
 902         return;
 903 
 904     if (!std::isfinite(m11) | !std::isfinite(m21) | !std::isfinite(dx) | !std::isfinite(m12) | !std::isfinite(m22) | !std::isfinite(dy))
 905         return;
 906 
 907     resetTransform();
 908     transform(m11, m12, m21, m22, dx, dy);
 909 }
 910 
 911 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::setTransform(DOMMatrix2DInit&amp;&amp; matrixInit)
 912 {
 913     auto checkValid = DOMMatrixReadOnly::validateAndFixup(matrixInit);
 914     if (checkValid.hasException())
 915         return checkValid.releaseException();
 916 
<span class="line-modified"> 917     setTransform(matrixInit.m11.value(), matrixInit.m12.value(), matrixInit.m21.value(), matrixInit.m22.value(), matrixInit.m41.value(), matrixInit.m42.value());</span>
 918     return { };
 919 }
 920 
 921 void CanvasRenderingContext2DBase::resetTransform()
 922 {
 923     GraphicsContext* c = drawingContext();
 924     if (!c)
 925         return;
 926 
 927     AffineTransform ctm = state().transform;
 928     bool hasInvertibleTransform = state().hasInvertibleTransform;
 929 
 930     realizeSaves();
 931 
 932     c-&gt;setCTM(canvasBase().baseTransform());
 933     modifiableState().transform = AffineTransform();
 934 
 935     if (hasInvertibleTransform)
 936         m_path.transform(ctm);
 937 
</pre>
<hr />
<pre>
1035 
1036     return true;
1037 }
1038 
1039 bool CanvasRenderingContext2DBase::isFullCanvasCompositeMode(CompositeOperator op)
1040 {
1041     // See 4.8.11.1.3 Compositing
1042     // CompositeSourceAtop and CompositeDestinationOut are not listed here as the platforms already
1043     // implement the specification&#39;s behavior.
1044     return op == CompositeSourceIn || op == CompositeSourceOut || op == CompositeDestinationIn || op == CompositeDestinationAtop;
1045 }
1046 
1047 static WindRule toWindRule(CanvasFillRule rule)
1048 {
1049     return rule == CanvasFillRule::Nonzero ? WindRule::NonZero : WindRule::EvenOdd;
1050 }
1051 
1052 void CanvasRenderingContext2DBase::fill(CanvasFillRule windingRule)
1053 {
1054     fillInternal(m_path, windingRule);

1055 }
1056 
1057 void CanvasRenderingContext2DBase::stroke()
1058 {
1059     strokeInternal(m_path);

1060 }
1061 
1062 void CanvasRenderingContext2DBase::clip(CanvasFillRule windingRule)
1063 {
1064     clipInternal(m_path, windingRule);

1065 }
1066 
1067 void CanvasRenderingContext2DBase::fill(Path2D&amp; path, CanvasFillRule windingRule)
1068 {
1069     fillInternal(path.path(), windingRule);
1070 }
1071 
1072 void CanvasRenderingContext2DBase::stroke(Path2D&amp; path)
1073 {
1074     strokeInternal(path.path());
1075 }
1076 
1077 void CanvasRenderingContext2DBase::clip(Path2D&amp; path, CanvasFillRule windingRule)
1078 {
1079     clipInternal(path.path(), windingRule);
1080 }
1081 
1082 void CanvasRenderingContext2DBase::fillInternal(const Path&amp; path, CanvasFillRule windingRule)
1083 {
1084     auto* c = drawingContext();
</pre>
<hr />
<pre>
1141             FloatRect dirtyRect = path.fastBoundingRect();
1142             inflateStrokeRect(dirtyRect);
1143             c-&gt;strokePath(path);
1144             didDraw(dirtyRect);
1145         }
1146     }
1147 }
1148 
1149 void CanvasRenderingContext2DBase::clipInternal(const Path&amp; path, CanvasFillRule windingRule)
1150 {
1151     auto* c = drawingContext();
1152     if (!c)
1153         return;
1154     if (!state().hasInvertibleTransform)
1155         return;
1156 
1157     realizeSaves();
1158     c-&gt;canvasClip(path, toWindRule(windingRule));
1159 }
1160 
<span class="line-modified">1161 void CanvasRenderingContext2DBase::beginCompositeLayer()</span>
1162 {
1163 #if !USE(CAIRO)
1164     drawingContext()-&gt;beginTransparencyLayer(1);
1165 #endif
1166 }
1167 
<span class="line-modified">1168 void CanvasRenderingContext2DBase::endCompositeLayer()</span>
1169 {
1170 #if !USE(CAIRO)
1171     drawingContext()-&gt;endTransparencyLayer();
1172 #endif
1173 }
1174 
1175 bool CanvasRenderingContext2DBase::isPointInPath(float x, float y, CanvasFillRule windingRule)
1176 {
1177     return isPointInPathInternal(m_path, x, y, windingRule);
1178 }
1179 
1180 bool CanvasRenderingContext2DBase::isPointInStroke(float x, float y)
1181 {
1182     return isPointInStrokeInternal(m_path, x, y);
1183 }
1184 
1185 bool CanvasRenderingContext2DBase::isPointInPath(Path2D&amp; path, float x, float y, CanvasFillRule windingRule)
1186 {
1187     return isPointInPathInternal(path.path(), x, y, windingRule);
1188 }
</pre>
<hr />
<pre>
1554     GraphicsContext* c = drawingContext();
1555     if (!c)
1556         return { };
1557     if (!state().hasInvertibleTransform)
1558         return { };
1559 
1560     if (!cachedImage)
1561         return { };
1562 
1563     RefPtr&lt;Image&gt; image = cachedImage-&gt;imageForRenderer(renderer);
1564     if (!image)
1565         return { };
1566 
1567     ImageObserver* observer = image-&gt;imageObserver();
1568 
1569     if (image-&gt;isSVGImage()) {
1570         image-&gt;setImageObserver(nullptr);
1571         image-&gt;setContainerSize(imageRect.size());
1572     }
1573 
<span class="line-modified">1574     if (image-&gt;isBitmapImage()) {</span>
<span class="line-added">1575         // Drawing an animated image to a canvas should draw the first frame (except for a few layout tests)</span>
<span class="line-added">1576         if (image-&gt;isAnimated() &amp;&amp; !document.settings().animatedImageDebugCanvasDrawingEnabled())</span>
<span class="line-added">1577             image = BitmapImage::create(image-&gt;nativeImage());</span>
1578         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(document.settings());
<span class="line-added">1579     }</span>
1580 
1581     if (rectContainsCanvas(normalizedDstRect)) {
<span class="line-modified">1582         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1583         didDrawEntireCanvas();
1584     } else if (isFullCanvasCompositeMode(op)) {
1585         fullCanvasCompositedDrawImage(*image, normalizedDstRect, normalizedSrcRect, op);
1586         didDrawEntireCanvas();
1587     } else if (op == CompositeCopy) {
1588         clearCanvas();
<span class="line-modified">1589         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1590         didDrawEntireCanvas();
1591     } else {
<span class="line-modified">1592         c-&gt;drawImage(*image, normalizedDstRect, normalizedSrcRect, { op, blendMode });</span>
1593         didDraw(normalizedDstRect);
1594     }
1595 
1596     if (image-&gt;isSVGImage())
1597         image-&gt;setImageObserver(observer);
1598 
1599     return { };
1600 }
1601 
1602 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLCanvasElement&amp; sourceCanvas, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1603 {
1604     FloatRect srcCanvasRect = FloatRect(FloatPoint(), sourceCanvas.size());
1605 
1606     if (!srcCanvasRect.width() || !srcCanvasRect.height())
1607         return Exception { InvalidStateError };
1608 
1609     if (!srcRect.width() || !srcRect.height())
1610         return Exception { IndexSizeError };
1611 
1612     if (!srcCanvasRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
</pre>
<hr />
<pre>
1620 
1621     // FIXME: Do this through platform-independent GraphicsContext API.
1622     ImageBuffer* buffer = sourceCanvas.buffer();
1623     if (!buffer)
1624         return { };
1625 
1626     checkOrigin(&amp;sourceCanvas);
1627 
1628 #if ENABLE(ACCELERATED_2D_CANVAS)
1629     // If we&#39;re drawing from one accelerated canvas 2d to another, avoid calling sourceCanvas.makeRenderingResultsAvailable()
1630     // as that will do a readback to software.
1631     RefPtr&lt;CanvasRenderingContext&gt; sourceContext = sourceCanvas.renderingContext();
1632     // FIXME: Implement an accelerated path for drawing from a WebGL canvas to a 2d canvas when possible.
1633     if (!isAccelerated() || !sourceContext || !sourceContext-&gt;isAccelerated() || !sourceContext-&gt;is2d())
1634         sourceCanvas.makeRenderingResultsAvailable();
1635 #else
1636     sourceCanvas.makeRenderingResultsAvailable();
1637 #endif
1638 
1639     if (rectContainsCanvas(dstRect)) {
<span class="line-modified">1640         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1641         didDrawEntireCanvas();
1642     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1643         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1644         didDrawEntireCanvas();
1645     } else if (state().globalComposite == CompositeCopy) {
1646         if (&amp;sourceCanvas == &amp;canvasBase()) {
1647             if (auto copy = buffer-&gt;copyRectToBuffer(srcRect, ColorSpaceSRGB, *c)) {
1648                 clearCanvas();
<span class="line-modified">1649                 c-&gt;drawImageBuffer(*copy, dstRect, { { }, srcRect.size() }, { state().globalComposite, state().globalBlend });</span>
1650             }
1651         } else {
<span class="line-modified">1652             clearCanvas();</span>
<span class="line-modified">1653             c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1654         }
1655         didDrawEntireCanvas();
1656     } else {
<span class="line-modified">1657         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1658         didDraw(dstRect);
1659     }
1660 
1661     return { };
1662 }
1663 
1664 #if ENABLE(VIDEO)
1665 
1666 ExceptionOr&lt;void&gt; CanvasRenderingContext2DBase::drawImage(HTMLVideoElement&amp; video, const FloatRect&amp; srcRect, const FloatRect&amp; dstRect)
1667 {
1668     if (video.readyState() == HTMLMediaElement::HAVE_NOTHING || video.readyState() == HTMLMediaElement::HAVE_METADATA)
1669         return { };
1670 
1671     FloatRect videoRect = FloatRect(FloatPoint(), size(video));
1672     if (!srcRect.width() || !srcRect.height())
1673         return Exception { IndexSizeError };
1674 
1675     if (!videoRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1676         return { };
1677 
</pre>
<hr />
<pre>
1718         return Exception { IndexSizeError };
1719 
1720     FloatRect srcBitmapRect = FloatRect(FloatPoint(), FloatSize(imageBitmap.width(), imageBitmap.height()));
1721 
1722     if (!srcBitmapRect.contains(normalizeRect(srcRect)) || !dstRect.width() || !dstRect.height())
1723         return { };
1724 
1725     GraphicsContext* c = drawingContext();
1726     if (!c)
1727         return { };
1728     if (!state().hasInvertibleTransform)
1729         return { };
1730 
1731     ImageBuffer* buffer = imageBitmap.buffer();
1732     if (!buffer)
1733         return { };
1734 
1735     checkOrigin(&amp;imageBitmap);
1736 
1737     if (rectContainsCanvas(dstRect)) {
<span class="line-modified">1738         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1739         didDrawEntireCanvas();
1740     } else if (isFullCanvasCompositeMode(state().globalComposite)) {
1741         fullCanvasCompositedDrawImage(*buffer, dstRect, srcRect, state().globalComposite);
1742         didDrawEntireCanvas();
1743     } else if (state().globalComposite == CompositeCopy) {
1744         clearCanvas();
<span class="line-modified">1745         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1746         didDrawEntireCanvas();
1747     } else {
<span class="line-modified">1748         c-&gt;drawImageBuffer(*buffer, dstRect, srcRect, { state().globalComposite, state().globalBlend });</span>
1749         didDraw(dstRect);
1750     }
1751 
1752     return { };
1753 }
1754 
1755 void CanvasRenderingContext2DBase::drawImageFromRect(HTMLImageElement&amp; imageElement, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, const String&amp; compositeOperation)
1756 {
1757     CompositeOperator op;
1758     auto blendOp = BlendMode::Normal;
1759     if (!parseCompositeAndBlendOperator(compositeOperation, op, blendOp) || blendOp != BlendMode::Normal)
1760         op = CompositeSourceOver;
1761     drawImage(imageElement, FloatRect { sx, sy, sw, sh }, FloatRect { dx, dy, dw, dh }, op, BlendMode::Normal);
1762 }
1763 
1764 void CanvasRenderingContext2DBase::clearCanvas()
1765 {
1766     auto* c = drawingContext();
1767     if (!c)
1768         return;
</pre>
<hr />
<pre>
1817 {
1818     IntRect canvasRect(0, 0, canvasBase().width(), canvasBase().height());
1819     canvasRect = canvasBase().baseTransform().mapRect(canvasRect);
1820 
1821     auto* c = drawingContext();
1822     if (!c)
1823         return;
1824 
1825     c-&gt;save();
1826     c-&gt;setCTM(AffineTransform());
1827     c-&gt;setCompositeOperation(op);
1828 
1829     c-&gt;save();
1830     c-&gt;clipOut(bufferRect);
1831     c-&gt;clearRect(canvasRect);
1832     c-&gt;restore();
1833     c-&gt;drawImageBuffer(buffer, bufferRect.location(), state().globalComposite);
1834     c-&gt;restore();
1835 }
1836 
<span class="line-modified">1837 static void drawImageToContext(Image&amp; image, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, const ImagePaintingOptions&amp; options)</span>
1838 {
<span class="line-modified">1839     context.drawImage(image, dest, src, options);</span>
1840 }
1841 
<span class="line-modified">1842 static void drawImageToContext(ImageBuffer&amp; imageBuffer, GraphicsContext&amp; context, const FloatRect&amp; dest, const FloatRect&amp; src, const ImagePaintingOptions&amp; options)</span>
1843 {
<span class="line-modified">1844     context.drawImageBuffer(imageBuffer, dest, src, options);</span>
1845 }
1846 
1847 template&lt;class T&gt; void CanvasRenderingContext2DBase::fullCanvasCompositedDrawImage(T&amp; image, const FloatRect&amp; dest, const FloatRect&amp; src, CompositeOperator op)
1848 {
1849     ASSERT(isFullCanvasCompositeMode(op));
1850 
1851     IntSize croppedOffset;
1852     auto bufferRect = calculateCompositingBufferRect(dest, &amp;croppedOffset);
1853     if (bufferRect.isEmpty()) {
1854         clearCanvas();
1855         return;
1856     }
1857 
1858     auto buffer = createCompositingBuffer(bufferRect);
1859     if (!buffer)
1860         return;
1861 
1862     auto* c = drawingContext();
1863     if (!c)
1864         return;
1865 
1866     FloatRect adjustedDest = dest;
1867     adjustedDest.setLocation(FloatPoint(0, 0));
1868     AffineTransform effectiveTransform = c-&gt;getCTM();
1869     IntRect transformedAdjustedRect = enclosingIntRect(effectiveTransform.mapRect(adjustedDest));
1870     buffer-&gt;context().translate(-transformedAdjustedRect.location());
1871     buffer-&gt;context().translate(croppedOffset);
1872     buffer-&gt;context().concatCTM(effectiveTransform);
<span class="line-modified">1873     drawImageToContext(image, buffer-&gt;context(), adjustedDest, src, { CompositeSourceOver });</span>
1874 
1875     compositeBuffer(*buffer, bufferRect, op);
1876 }
1877 










1878 static CanvasRenderingContext2DBase::Style toStyle(const CanvasStyle&amp; style)
1879 {
1880     if (auto gradient = style.canvasGradient())
1881         return gradient;
1882     if (auto pattern = style.canvasPattern())
1883         return pattern;
1884     return style.color();
1885 }
1886 
1887 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::strokeStyle() const
1888 {
1889     return toStyle(state().strokeStyle);
1890 }
1891 
1892 void CanvasRenderingContext2DBase::setStrokeStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1893 {
1894     WTF::switchOn(style,
1895         [this] (const String&amp; string) { this-&gt;setStrokeColor(string); },
1896         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setStrokeStyle(CanvasStyle(*gradient)); },
1897         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setStrokeStyle(CanvasStyle(*pattern)); }
</pre>
<hr />
<pre>
1900 
1901 CanvasRenderingContext2DBase::Style CanvasRenderingContext2DBase::fillStyle() const
1902 {
1903     return toStyle(state().fillStyle);
1904 }
1905 
1906 void CanvasRenderingContext2DBase::setFillStyle(CanvasRenderingContext2DBase::Style&amp;&amp; style)
1907 {
1908     WTF::switchOn(style,
1909         [this] (const String&amp; string) { this-&gt;setFillColor(string); },
1910         [this] (const RefPtr&lt;CanvasGradient&gt;&amp; gradient) { this-&gt;setFillStyle(CanvasStyle(*gradient)); },
1911         [this] (const RefPtr&lt;CanvasPattern&gt;&amp; pattern) { this-&gt;setFillStyle(CanvasStyle(*pattern)); }
1912     );
1913 }
1914 
1915 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createLinearGradient(float x0, float y0, float x1, float y1)
1916 {
1917     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(x1) || !std::isfinite(y1))
1918         return Exception { NotSupportedError };
1919 
<span class="line-modified">1920     return CanvasGradient::create(FloatPoint(x0, y0), FloatPoint(x1, y1));</span>


1921 }
1922 
1923 ExceptionOr&lt;Ref&lt;CanvasGradient&gt;&gt; CanvasRenderingContext2DBase::createRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1)
1924 {
1925     if (!std::isfinite(x0) || !std::isfinite(y0) || !std::isfinite(r0) || !std::isfinite(x1) || !std::isfinite(y1) || !std::isfinite(r1))
1926         return Exception { NotSupportedError };
1927 
1928     if (r0 &lt; 0 || r1 &lt; 0)
1929         return Exception { IndexSizeError };
1930 
<span class="line-modified">1931     return CanvasGradient::create(FloatPoint(x0, y0), r0, FloatPoint(x1, y1), r1);</span>


1932 }
1933 
1934 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(CanvasImageSource&amp;&amp; image, const String&amp; repetition)
1935 {
1936     bool repeatX, repeatY;
1937     if (!CanvasPattern::parseRepetitionType(repetition, repeatX, repeatY))
1938         return Exception { SyntaxError };
1939 
1940     return WTF::switchOn(image,
1941         [&amp;] (auto&amp; element) -&gt; ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; { return this-&gt;createPattern(*element, repeatX, repeatY); }
1942     );
1943 }
1944 
1945 ExceptionOr&lt;RefPtr&lt;CanvasPattern&gt;&gt; CanvasRenderingContext2DBase::createPattern(HTMLImageElement&amp; imageElement, bool repeatX, bool repeatY)
1946 {
1947     auto* cachedImage = imageElement.cachedImage();
1948 
1949     // If the image loading hasn&#39;t started or the image is not complete, it is not fully decodable.
1950     if (!cachedImage || !imageElement.complete())
1951         return nullptr;
</pre>
<hr />
<pre>
2106         if (!m_recordingContext)
2107             return;
2108 
2109         FloatRect clip(FloatPoint::zero(), canvasBase().size());
2110         DisplayList::Replayer replayer(*canvasBase().drawingContext(), m_recordingContext-&gt;displayList);
2111 
2112         if (UNLIKELY(m_tracksDisplayListReplay)) {
2113             auto replayList = replayer.replay(clip, m_tracksDisplayListReplay);
2114             contextDisplayListMap().add(this, WTFMove(replayList));
2115         } else
2116             replayer.replay(clip);
2117 
2118         m_recordingContext-&gt;displayList.clear();
2119     }
2120 }
2121 
2122 GraphicsContext* CanvasRenderingContext2DBase::drawingContext() const
2123 {
2124     if (UNLIKELY(m_usesDisplayListDrawing)) {
2125         if (!m_recordingContext)
<span class="line-modified">2126             m_recordingContext = makeUnique&lt;DisplayListDrawingContext&gt;(GraphicsContextState(), FloatRect(FloatPoint::zero(), canvasBase().size()));</span>
2127         return &amp;m_recordingContext-&gt;context;
2128     }
2129 
2130     return canvasBase().drawingContext();
2131 }
2132 
2133 static RefPtr&lt;ImageData&gt; createEmptyImageData(const IntSize&amp; size)
2134 {
2135     auto data = ImageData::create(size);
2136     if (data)
2137         data-&gt;data()-&gt;zeroFill();
2138     return data;
2139 }
2140 
2141 RefPtr&lt;ImageData&gt; CanvasRenderingContext2DBase::createImageData(ImageData&amp; imageData) const
2142 {
2143     return createEmptyImageData(imageData.size());
2144 }
2145 
2146 ExceptionOr&lt;RefPtr&lt;ImageData&gt;&gt; CanvasRenderingContext2DBase::createImageData(float sw, float sh) const
</pre>
<hr />
<pre>
2335     if (enabled == state().imageSmoothingEnabled)
2336         return;
2337 
2338     realizeSaves();
2339     modifiableState().imageSmoothingEnabled = enabled;
2340     auto* c = drawingContext();
2341     if (c)
2342         c-&gt;setImageInterpolationQuality(enabled ? smoothingToInterpolationQuality(state().imageSmoothingQuality) : InterpolationNone);
2343 }
2344 
2345 void CanvasRenderingContext2DBase::setPath(Path2D&amp; path)
2346 {
2347     m_path = path.path();
2348 }
2349 
2350 Ref&lt;Path2D&gt; CanvasRenderingContext2DBase::getPath() const
2351 {
2352     return Path2D::create(m_path);
2353 }
2354 








2355 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CanvasRenderingContext2D.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CanvasRenderingContext2DBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>