<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderInline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 251         if (respectOverflow == RespectOverflowClip)
 252             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 253         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 254         return index;
 255     }
 256 
 257     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 258 };
 259 
 260 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 261 {
 262 #if !ENABLE(3D_TRANSFORMS)
 263     UNUSED_PARAM(has3DRendering);
 264     matrix.makeAffine();
 265 #else
 266     if (!has3DRendering)
 267         matrix.makeAffine();
 268 #endif
 269 }
 270 














 271 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 272     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 273     , m_forcedStackingContext(rendererLayerModelObject.isMedia())

 274     , m_zOrderListsDirty(false)
 275     , m_normalFlowListDirty(true)
 276     , m_hadNegativeZOrderList(false)
 277     , m_inResizeMode(false)
 278     , m_scrollDimensionsDirty(true)
 279     , m_hasSelfPaintingLayerDescendant(false)
 280     , m_hasSelfPaintingLayerDescendantDirty(false)
 281     , m_usedTransparency(false)
 282     , m_paintingInsideReflection(false)
 283     , m_inOverflowRelayout(false)
 284     , m_repaintStatus(NeedsNormalRepaint)
 285     , m_visibleContentStatusDirty(true)
 286     , m_hasVisibleContent(false)
 287     , m_visibleDescendantStatusDirty(false)
 288     , m_hasVisibleDescendant(false)
 289     , m_registeredScrollableArea(false)
 290     , m_isFixedIntersectingViewport(false)

 291     , m_3DTransformedDescendantStatusDirty(true)
 292     , m_has3DTransformedDescendant(false)
 293     , m_hasCompositingDescendant(false)


 294     , m_hasTransformedAncestor(false)
 295     , m_has3DTransformedAncestor(false)
 296     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 297     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 298 #if PLATFORM(IOS_FAMILY)
 299 #if ENABLE(IOS_TOUCH_EVENTS)
 300     , m_registeredAsTouchEventListenerForScrolling(false)
 301 #endif
 302     , m_adjustForIOSCaretWhenScrolling(false)
 303 #endif
<span class="line-removed"> 304     , m_inUserScroll(false)</span>
 305     , m_requiresScrollPositionReconciliation(false)
 306     , m_containsDirtyOverlayScrollbars(false)
 307     , m_updatingMarqueePosition(false)
 308 #if !ASSERT_DISABLED
 309     , m_layerListMutationAllowed(true)
 310 #endif
 311 #if ENABLE(CSS_COMPOSITING)
 312     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 313     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 314     , m_hasNotIsolatedBlendingDescendants(false)
 315     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 316 #endif
 317     , m_renderer(rendererLayerModelObject)
 318 {
 319     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
<span class="line-modified"> 320     setIsStackingContext(shouldBeStackingContext());</span>
 321 
 322     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 323 
 324     if (!renderer().firstChild()) {
 325         m_visibleContentStatusDirty = false;
 326         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 327     }
 328 
 329     if (Element* element = renderer().element()) {
 330         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 331         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 332         if (!m_scrollPosition.isZero())
 333             scrollAnimator().setCurrentPosition(m_scrollPosition);
 334         element-&gt;setSavedLayerScrollPosition(IntPoint());
 335     }
 336 }
 337 
 338 RenderLayer::~RenderLayer()
 339 {
 340     if (inResizeMode())
</pre>
<hr />
<pre>
 348 #if ENABLE(IOS_TOUCH_EVENTS)
 349     unregisterAsTouchEventListenerForScrolling();
 350 #endif
 351     if (Element* element = renderer().element())
 352         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 353 
 354     destroyScrollbar(HorizontalScrollbar);
 355     destroyScrollbar(VerticalScrollbar);
 356 
 357     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 358         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 359 
 360     if (m_reflection)
 361         removeReflection();
 362 
 363     clearScrollCorner();
 364     clearResizer();
 365 
 366     clearLayerFilters();
 367 






 368     // Child layers will be deleted by their corresponding render objects, so
 369     // we don&#39;t need to delete them ourselves.
 370 
 371     clearBacking(true);
 372 
 373     // Layer and all its children should be removed from the tree before destruction.
 374     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 375     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 376 }
 377 
 378 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 379 {
 380     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 381     if (prevSibling) {
 382         child.setPreviousSibling(prevSibling);
 383         prevSibling-&gt;setNextSibling(&amp;child);
 384         ASSERT(prevSibling != &amp;child);
 385     } else
 386         setFirstChild(&amp;child);
 387 
</pre>
<hr />
<pre>
 543         || renderer.style().hasIsolation()
 544         || !renderer.style().hasAutoZIndex()
 545         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 546 }
 547 
 548 bool RenderLayer::shouldBeNormalFlowOnly() const
 549 {
 550     if (canCreateStackingContext(*this))
 551         return false;
 552 
 553     return renderer().hasOverflowClip()
 554         || renderer().isCanvas()
 555         || renderer().isVideo()
 556         || renderer().isEmbeddedObject()
 557         || renderer().isRenderIFrame()
 558         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 559         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 560         || renderer().isInFlowRenderFragmentedFlow();
 561 }
 562 
<span class="line-modified"> 563 bool RenderLayer::shouldBeStackingContext() const</span>
 564 {
<span class="line-modified"> 565     return !renderer().style().hasAutoZIndex() || isRenderViewLayer() || isForcedStackingContext();</span>
 566 }
 567 
 568 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 569 {
 570     if (isNormalFlowOnly == m_isNormalFlowOnly)
 571         return false;
 572 
 573     m_isNormalFlowOnly = isNormalFlowOnly;
 574 
 575     if (auto* p = parent())
 576         p-&gt;dirtyNormalFlowList();
 577     dirtyStackingContextZOrderLists();
 578     return true;
 579 }
 580 
<span class="line-modified"> 581 bool RenderLayer::setIsStackingContext(bool isStackingContext)</span>
 582 {
<span class="line-removed"> 583     if (isStackingContext == m_isStackingContext)</span>
<span class="line-removed"> 584         return false;</span>
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586     m_isStackingContext = isStackingContext;</span>
<span class="line-removed"> 587 </span>
 588     dirtyStackingContextZOrderLists();
<span class="line-modified"> 589     if (isStackingContext)</span>
 590         dirtyZOrderLists();
 591     else
 592         clearZOrderLists();

 593 



















 594     return true;
 595 }
 596 
 597 void RenderLayer::setParent(RenderLayer* parent)
 598 {
 599     if (parent == m_parent)
 600         return;
 601 
 602     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 603         compositor().layerWillBeRemoved(*m_parent, *this);
 604 
 605     m_parent = parent;
 606 
 607     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 608         compositor().layerWasAdded(*m_parent, *this);
 609 }
 610 
 611 RenderLayer* RenderLayer::stackingContext() const
 612 {
 613     auto* layer = parent();
</pre>
<hr />
<pre>
 646 
 647     if (m_normalFlowList)
 648         m_normalFlowList-&gt;clear();
 649     m_normalFlowListDirty = true;
 650 
 651     if (hasCompositingDescendant())
 652         setNeedsCompositingPaintOrderChildrenUpdate();
 653 }
 654 
 655 void RenderLayer::updateNormalFlowList()
 656 {
 657     if (!m_normalFlowListDirty)
 658         return;
 659 
 660     ASSERT(layerListMutationAllowed());
 661 
 662     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 663         // Ignore non-overflow layers and reflections.
 664         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 665             if (!m_normalFlowList)
<span class="line-modified"> 666                 m_normalFlowList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 667             m_normalFlowList-&gt;append(child);
 668         }
 669     }
 670 
 671     m_normalFlowListDirty = false;
 672 }
 673 
 674 void RenderLayer::rebuildZOrderLists()
 675 {
 676     ASSERT(layerListMutationAllowed());
 677     ASSERT(isDirtyStackingContext());
 678     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);
 679     m_zOrderListsDirty = false;
 680 
 681     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 682     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 683     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 684     // lists on dirtying so we don&#39;t know the old state.
 685     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 686         m_hadNegativeZOrderList = hasNegativeZOrderList;
</pre>
<hr />
<pre>
 702     };
 703 
 704     // Sort the two lists.
 705     if (posZOrderList)
 706         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 707 
 708     if (negZOrderList)
 709         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 710 }
 711 
 712 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)
 713 {
 714     updateDescendantDependentFlags();
 715 
 716     bool isStacking = isStackingContext();
 717     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 718     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 719     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 720         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 721         if (!layerList)
<span class="line-modified"> 722             layerList = std::make_unique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 723         layerList-&gt;append(this);
 724     }
 725 
 726     // Recur into our children to collect more layers, but only if we don&#39;t establish
 727     // a stacking context/container.
 728     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 729         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 730             // Ignore reflections.
 731             if (!isReflectionLayer(*child))
 732                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);
 733         }
 734     }
 735 }
 736 
 737 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 738 {
 739     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 740         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 741             break;
 742         layer-&gt;m_compositingDirtyBits.add(flag);
</pre>
<hr />
<pre>
 820 
 821 bool RenderLayer::paintsWithFilters() const
 822 {
 823     if (!renderer().hasFilter())
 824         return false;
 825 
 826     if (!isComposited())
 827         return true;
 828 
 829     return !m_backing-&gt;canCompositeFilters();
 830 }
 831 
 832 bool RenderLayer::requiresFullLayerImageForFilters() const
 833 {
 834     if (!paintsWithFilters())
 835         return false;
 836 
 837     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 838 }
 839 
<span class="line-modified"> 840 void RenderLayer::updateLayerPositionsAfterLayout(const RenderLayer* rootLayer, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)</span>





















 841 {
















 842     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 843     RenderGeometryMap geometryMap(UseTransforms);
<span class="line-modified"> 844     if (this != rootLayer)</span>
 845         geometryMap.pushMappingsToAncestor(parent(), nullptr);
<span class="line-modified"> 846     updateLayerPositions(&amp;geometryMap, flags);</span>

 847 }
 848 
 849 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 850 {
<span class="line-modified"> 851     updateLayerPosition(); // For relpositioned layers or non-positioned layers,</span>
<span class="line-removed"> 852                            // we need to keep in sync, since we may have shifted relative</span>
<span class="line-removed"> 853                            // to our parent layer.</span>
<span class="line-removed"> 854 </span>
 855     applyPostLayoutScrollPositionIfNeeded();
 856 
 857     if (geometryMap)
 858         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 859 
 860     // Clear our cached clip rect information.
 861     clearClipRects();
 862 
 863     if (hasOverflowControls()) {
 864         LayoutSize offsetFromRoot;
 865         if (geometryMap)
 866             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 867         else {
 868             // FIXME: It looks suspicious to call convertToLayerCoords here
<span class="line-modified"> 869             // as canUseConvertToLayerCoords may be true for an ancestor layer.</span>
 870             offsetFromRoot = offsetFromAncestor(root());
 871         }
 872         positionOverflowControls(roundedIntSize(offsetFromRoot));
 873     }
 874 
 875     updateDescendantDependentFlags();
 876 
 877     if (flags &amp; UpdatePagination)
 878         updatePagination();
 879     else
 880         m_enclosingPaginationLayer = nullptr;
 881 
 882     if (m_hasVisibleContent) {
 883         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 884         // mapping between them and the RenderObjects. It would be neat to enable
 885         // LayoutState outside the layout() phase and use it here.
 886         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 887 
 888         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 889 
</pre>
<hr />
<pre>
 898         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 899             if (!renderer().view().printing()) {
 900                 if (m_repaintStatus &amp; NeedsFullRepaint) {
 901                     if (hadRepaintLayoutRects)
 902                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
 903                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
 904                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
 905                 } else if (shouldRepaintAfterLayout()) {
 906                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
 907                     // we change other callers to use RepaintLayoutRects.
 908                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
 909                 }
 910             }
 911         }
 912     } else
 913         clearRepaintRects();
 914 
 915     m_repaintStatus = NeedsNormalRepaint;
 916     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
 917     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);


 918 
 919     // Update the reflection&#39;s position and size.
 920     if (m_reflection)
 921         m_reflection-&gt;layout();
 922 
 923     if (renderer().isInFlowRenderFragmentedFlow()) {
 924         updatePagination();
 925         flags.add(UpdatePagination);
 926     }
 927 
 928     if (transform()) {
 929         flags.add(SeenTransformedLayer);
 930         if (!transform()-&gt;isAffine())
 931             flags.add(Seen3DTransformedLayer);
 932     }
 933 









 934     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
 935         child-&gt;updateLayerPositions(geometryMap, flags);
 936 
 937     // With all our children positioned, now update our marquee if we need to.
 938     if (m_marquee) {
 939         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
 940         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
 941         m_updatingMarqueePosition = true;
 942         m_marquee-&gt;updateMarqueePosition();
 943         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
 944     }
 945 
<span class="line-modified"> 946     if (renderer().isOutOfFlowPositioned() &amp;&amp; renderer().style().position() == PositionType::Fixed &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {</span>
 947         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
 948         if (intersectsViewport != m_isFixedIntersectingViewport) {
 949             m_isFixedIntersectingViewport = intersectsViewport;
 950             setNeedsPostLayoutCompositingUpdate();
 951         }
 952     }
 953 
 954     if (isComposited())
<span class="line-modified"> 955         backing()-&gt;updateAfterLayout(flags.contains(NeedsFullRepaintInBacking));</span>
 956 
 957     if (geometryMap)
 958         geometryMap-&gt;popMappingsToAncestor(parent());
 959 
 960     renderer().document().markers().invalidateRectsForAllMarkers();
 961 }
 962 
 963 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
 964 {
 965     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
 966     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 967         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
 968         if (child-&gt;isComposited())
 969             continue;
 970 
 971         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
 972     }
 973     return repaintRect;
 974 }
 975 
</pre>
<hr />
<pre>
1107     renderer().document().markers().invalidateRectsForAllMarkers();
1108 }
1109 
1110 #if ENABLE(CSS_COMPOSITING)
1111 
1112 void RenderLayer::updateBlendMode()
1113 {
1114     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1115     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1116         if (hasBlendMode())
1117             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1118         else
1119             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1120     }
1121 
1122     BlendMode newBlendMode = renderer().style().blendMode();
1123     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1124         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1125 }
1126 





1127 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1128 {
1129     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1130         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1131             break;
1132         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1133         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1134 
1135         layer-&gt;updateSelfPaintingLayer();
1136 
<span class="line-modified">1137         if (layer-&gt;isStackingContext())</span>
1138             break;
1139     }
1140 }
1141 
1142 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1143 {
1144     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1145         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1146             break;
1147 
1148         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1149 
<span class="line-modified">1150         if (layer-&gt;isStackingContext())</span>
1151             break;
1152     }
1153 }
1154 #endif
1155 
1156 void RenderLayer::updateTransform()
1157 {
1158     bool hasTransform = renderer().hasTransform();
1159     bool had3DTransform = has3DTransform();
1160 
1161     bool hadTransform = !!m_transform;
1162     if (hasTransform != hadTransform) {
1163         if (hasTransform)
<span class="line-modified">1164             m_transform = std::make_unique&lt;TransformationMatrix&gt;();</span>
1165         else
1166             m_transform = nullptr;
1167 
1168         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1169         clearClipRectsIncludingDescendants();
1170     }
1171 
1172     if (hasTransform) {
1173         RenderBox* box = renderBox();
1174         ASSERT(box);
1175         m_transform-&gt;makeIdentity();
1176         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1177         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1178     }
1179 
1180     if (had3DTransform != has3DTransform()) {
1181         dirty3DTransformedDescendantStatus();
1182         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1183         setNeedsPostLayoutCompositingUpdateOnAncestors();
1184     }
</pre>
<hr />
<pre>
1481         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1482         // in the normal flow list, so we only need to check those.
1483         for (auto* layer : positiveZOrderLayers())
1484             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1485 
1486         // Now check our negative z-index children.
1487         for (auto* layer : negativeZOrderLayers())
1488             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1489 
1490         m_3DTransformedDescendantStatusDirty = false;
1491     }
1492 
1493     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1494     // the m_has3DTransformedDescendant set.
1495     if (preserves3D())
1496         return has3DTransform() || m_has3DTransformedDescendant;
1497 
1498     return has3DTransform();
1499 }
1500 
<span class="line-modified">1501 bool RenderLayer::updateLayerPosition()</span>
1502 {
1503     LayoutPoint localPoint;
1504     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1505     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1506         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1507         IntRect lineBox = inlineFlow.linesBoundingBox();
1508         setSize(lineBox.size());
1509         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1510         localPoint += inlineBoundingBoxOffset;
1511     } else if (RenderBox* box = renderBox()) {
1512         // FIXME: Is snapping the size really needed here for the RenderBox case?
1513         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1514         if (newSize != size()) {
1515             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1516                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1517                 setNeedsPostLayoutCompositingUpdate();
1518             }




1519             setSize(newSize);
1520         }
1521 
1522         box-&gt;applyTopLeftLocationOffset(localPoint);
1523     }
1524 
1525     if (!renderer().isOutOfFlowPositioned()) {
1526         auto* ancestor = renderer().parent();
1527         // We must adjust our position by walking up the render tree looking for the
1528         // nearest enclosing object with a layer.
1529         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1530             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1531                 // Rows and cells share the same coordinate space (that of the section).
1532                 // Omit them when computing our xpos/ypos.
1533                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1534             }
1535             ancestor = ancestor-&gt;parent();
1536         }
1537         if (is&lt;RenderTableRow&gt;(ancestor)) {
1538             // Put ourselves into the row coordinate space.
</pre>
<hr />
<pre>
1625 
1626     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1627                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1628 }
1629 
1630 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1631 {
1632     switch (position) {
1633     case PositionType::Fixed:
1634         return layer.renderer().canContainFixedPositionObjects();
1635 
1636     case PositionType::Absolute:
1637         return layer.renderer().canContainAbsolutelyPositionedObjects();
1638 
1639     default:
1640         ASSERT_NOT_REACHED();
1641         return false;
1642     }
1643 }
1644 

















1645 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1646 {
1647     RenderLayer* curr = parent();
1648     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1649         curr = curr-&gt;parent();
1650 
1651     return curr;
1652 }
1653 
<span class="line-modified">1654 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)</span>
1655 {
<span class="line-modified">1656     if (layer.parent())</span>
<span class="line-removed">1657         return layer.parent();</span>
<span class="line-removed">1658 </span>
<span class="line-removed">1659     HTMLFrameOwnerElement* ownerElement = layer.renderer().document().ownerElement();</span>
1660     if (!ownerElement)
1661         return nullptr;
1662 
<span class="line-modified">1663     RenderElement* ownerRenderer = ownerElement-&gt;renderer();</span>
1664     if (!ownerRenderer)
1665         return nullptr;
1666 
1667     return ownerRenderer-&gt;enclosingLayer();
1668 }
1669 








1670 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1671 {
1672     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1673         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1674             return nextLayer;
1675     }
1676 
1677     return nullptr;
1678 }
1679 
1680 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1681 {
1682     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1683 }
1684 
1685 bool RenderLayer::isRubberBandInProgress() const
1686 {
1687 #if ENABLE(RUBBER_BANDING)
1688     if (!scrollsOverflow())
1689         return false;
</pre>
<hr />
<pre>
1703 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1704 {
1705     RenderLayer* curr = parent();
1706     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1707         curr = curr-&gt;parent();
1708 
1709     return curr;
1710 }
1711 
1712 inline bool RenderLayer::shouldRepaintAfterLayout() const
1713 {
1714     if (m_repaintStatus == NeedsNormalRepaint)
1715         return true;
1716 
1717     // Composited layers that were moved during a positioned movement only
1718     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1719     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1720     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1721 }
1722 





















1723 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1724 {
1725     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1726 }
1727 
1728 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1729 {
1730     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1731         return const_cast&lt;RenderLayer*&gt;(this);
1732 
1733     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1734         if (curr-&gt;isComposited())
1735             return const_cast&lt;RenderLayer*&gt;(curr);
1736     }
1737 
1738     return nullptr;
1739 }
1740 
1741 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1742 {
<span class="line-modified">1743     if (includeSelf == IncludeSelf &amp;&amp; compositedWithOwnBackingStore(*this))</span>
<span class="line-modified">1744         return const_cast&lt;RenderLayer*&gt;(this);</span>











1745 
1746     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
<span class="line-modified">1747         if (compositedWithOwnBackingStore(*curr))</span>
<span class="line-modified">1748             return const_cast&lt;RenderLayer*&gt;(curr);</span>
1749     }
1750 
1751     return nullptr;
1752 }
1753 
1754 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1755 {
1756     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1757     for (; curr; curr = curr-&gt;parent()) {
1758         if (curr-&gt;requiresFullLayerImageForFilters())
1759             return const_cast&lt;RenderLayer*&gt;(curr);
1760     }
1761 
1762     return nullptr;
1763 }
1764 
1765 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
1766 {
1767     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1768         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
</pre>
<hr />
<pre>
1810         return;
1811     }
1812 
1813     ASSERT_NOT_REACHED();
1814 }
1815 
1816 bool RenderLayer::hasAncestorWithFilterOutsets() const
1817 {
1818     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1819         if (curr-&gt;renderer().style().hasFilterOutsets())
1820             return true;
1821     }
1822     return false;
1823 }
1824 
1825 RenderLayer* RenderLayer::clippingRootForPainting() const
1826 {
1827     if (isComposited())
1828         return const_cast&lt;RenderLayer*&gt;(this);
1829 



1830     const RenderLayer* current = this;
1831     while (current) {
1832         if (current-&gt;isRenderViewLayer())
1833             return const_cast&lt;RenderLayer*&gt;(current);
1834 
1835         current = current-&gt;paintOrderParent();
1836         ASSERT(current);
1837         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
1838             return const_cast&lt;RenderLayer*&gt;(current);



1839     }
1840 
1841     ASSERT_NOT_REACHED();
1842     return nullptr;
1843 }
1844 
1845 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
1846 {
1847     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
1848     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
1849 }
1850 
1851 bool RenderLayer::cannotBlitToWindow() const
1852 {
1853     if (isTransparent() || hasReflection() || hasTransform())
1854         return true;
1855     if (!parent())
1856         return false;
1857     return parent()-&gt;cannotBlitToWindow();
1858 }
</pre>
<hr />
<pre>
1952     layer.renderer().style().filterOutsets().expandRect(clipRect);
1953 
1954     return clipRect;
1955 }
1956 
1957 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
1958 {
1959     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
1960 }
1961 
1962 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
1963 {
1964     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
1965         return;
1966 
1967     RenderLayer* ancestor = transparentPaintingAncestor();
1968     if (ancestor)
1969         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
1970 
1971     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
<span class="line-modified">1972         ASSERT(isStackingContext());</span>
1973         m_usedTransparency = true;
1974         context.save();
1975         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
1976         adjustedClipRect.move(paintingInfo.subpixelOffset);
1977         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
1978         context.clip(pixelSnappedClipRect);
1979 
1980 #if ENABLE(CSS_COMPOSITING)
1981         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
1982         if (usesCompositeOperation)
1983             context.setCompositeOperation(context.compositeOperation(), blendMode());
1984 #endif
1985 
1986         context.beginTransparencyLayer(renderer().opacity());
1987 
1988 #if ENABLE(CSS_COMPOSITING)
1989         if (usesCompositeOperation)
1990             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
1991 #endif
1992 
</pre>
<hr />
<pre>
2151 
2152 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2153 {
2154     if (ancestorLayer == this)
2155         return location;
2156 
2157     const RenderLayer* currLayer = this;
2158     LayoutPoint locationInLayerCoords = location;
2159     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2160         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2161     return locationInLayerCoords;
2162 }
2163 
2164 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2165 {
2166     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2167 }
2168 
2169 bool RenderLayer::canUseCompositedScrolling() const
2170 {

2171     if (renderer().settings().asyncOverflowScrollingEnabled())
<span class="line-modified">2172         return scrollsOverflow();</span>
2173 
<span class="line-modified">2174 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(ACCELERATED_OVERFLOW_SCROLLING)</span>
<span class="line-modified">2175     return scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());</span>
2176 #else
2177     return false;
2178 #endif
2179 }
2180 
<span class="line-removed">2181 bool RenderLayer::hasCompositedScrollableOverflow() const</span>
<span class="line-removed">2182 {</span>
<span class="line-removed">2183     return canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());</span>
<span class="line-removed">2184 }</span>
<span class="line-removed">2185 </span>
2186 #if ENABLE(IOS_TOUCH_EVENTS)
2187 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2188 {
2189     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2190     if (hasCompositedScrollableOverflow())
2191         return false;
2192 
2193     return ScrollableArea::handleTouchEvent(touchEvent);
2194 }
2195 
2196 void RenderLayer::registerAsTouchEventListenerForScrolling()
2197 {
2198     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2199         return;
2200 
2201     renderer().document().addTouchEventHandler(*renderer().element());
2202     m_registeredAsTouchEventListenerForScrolling = true;
2203 }
2204 
2205 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
</pre>
<hr />
<pre>
2298 
2299         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2300         // https://bugs.webkit.org/show_bug.cgi?id=28237
2301     }
2302 }
2303 
2304 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2305 {
2306     m_postLayoutScrollPosition = position;
2307 }
2308 
2309 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2310 {
2311     if (!m_postLayoutScrollPosition)
2312         return;
2313 
2314     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2315     m_postLayoutScrollPosition = WTF::nullopt;
2316 }
2317 
<span class="line-modified">2318 void RenderLayer::scrollToXPosition(int x, ScrollClamping clamping)</span>
2319 {
2320     ScrollPosition position(x, m_scrollPosition.y());
<span class="line-modified">2321     scrollToOffset(scrollOffsetFromPosition(position), clamping);</span>
2322 }
2323 
<span class="line-modified">2324 void RenderLayer::scrollToYPosition(int y, ScrollClamping clamping)</span>
2325 {
2326     ScrollPosition position(m_scrollPosition.x(), y);
<span class="line-modified">2327     scrollToOffset(scrollOffsetFromPosition(position), clamping);</span>
2328 }
2329 
2330 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2331 {
2332     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2333 }
2334 
<span class="line-modified">2335 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollClamping clamping)</span>
2336 {
<span class="line-modified">2337     ScrollOffset newScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;</span>
<span class="line-modified">2338     if (newScrollOffset != this-&gt;scrollOffset())</span>
<span class="line-modified">2339         scrollToOffsetWithoutAnimation(newScrollOffset, clamping);</span>














2340 }
2341 
2342 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2343 {
2344     RenderBox* box = renderBox();
2345     if (!box)
2346         return;
2347 
<span class="line-modified">2348     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (in user scroll &quot; &lt;&lt; isInUserScroll() &lt;&lt; &quot;)&quot;);</span>
2349 
2350     ScrollPosition newPosition = position;
2351     if (!box-&gt;isHTMLMarquee()) {
2352         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2353         if (m_scrollDimensionsDirty)
2354             computeScrollDimensions();
2355 #if PLATFORM(IOS_FAMILY)
2356         if (adjustForIOSCaretWhenScrolling()) {
2357             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2358             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2359             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2360             int scrollXOffset = newOffset.x();
2361             if (scrollXOffset &gt; maxOffset - caretWidth) {
2362                 scrollXOffset += caretWidth;
2363                 if (scrollXOffset &lt;= caretWidth)
2364                     scrollXOffset = 0;
2365             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2366                 scrollXOffset -= caretWidth;
2367 
2368             newOffset.setX(scrollXOffset);
</pre>
<hr />
<pre>
2383 
2384     m_scrollPosition = newPosition;
2385 
2386     RenderView&amp; view = renderer().view();
2387 
2388     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2389     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2390     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2391         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2392         updateLayerPositionsAfterOverflowScroll();
2393 
2394         view.frameView().scheduleUpdateWidgetPositions();
2395 
2396         if (!m_updatingMarqueePosition) {
2397             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2398             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2399             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2400             // when that completes.
2401             if (usesCompositedScrolling()) {
2402                 setNeedsCompositingGeometryUpdate();
<span class="line-modified">2403                 setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>




2404             }
2405 
2406             updateCompositingLayersAfterScroll();
2407         }
2408 
2409         // Update regions, scrolling may change the clip of a particular region.
<span class="line-modified">2410         renderer().document().invalidateRenderingDependentRegions(Document::AnnotationsAction::Update);</span>
2411         DebugPageOverlays::didLayout(renderer().frame());
2412     }
2413 
2414     Frame&amp; frame = renderer().frame();
2415     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2416     // The caret rect needs to be invalidated after scrolling
2417     frame.selection().setCaretRectNeedsUpdate();
2418 
2419     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2420 
2421     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2422     if (repaintContainer)
2423         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2424     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2425 
2426     bool requiresRepaint = true;
2427     if (usesCompositedScrolling()) {
2428         setNeedsCompositingGeometryUpdate();
2429         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2430         requiresRepaint = false;
</pre>
<hr />
<pre>
2485 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2486 {
2487     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2488 
2489     RenderLayer* parentLayer = nullptr;
2490     LayoutRect newRect = absoluteRect;
2491 
2492     // We may end up propagating a scroll event. It is important that we suspend events until
2493     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2494     FrameView&amp; frameView = renderer().view().frameView();
2495 
2496     if (renderer().parent())
2497         parentLayer = renderer().parent()-&gt;enclosingLayer();
2498 
2499     if (allowsCurrentScroll()) {
2500         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2501         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2502         RenderBox* box = renderBox();
2503         ASSERT(box);
2504         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());





2505         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2506         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2507 
2508         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2509         if (clampedScrollOffset != scrollOffset()) {
2510             ScrollOffset oldScrollOffset = scrollOffset();
2511             scrollToOffset(clampedScrollOffset);
2512             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2513             localExposeRect.move(-scrollOffsetDifference);
2514             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2515         }
2516     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2517         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2518 
2519         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2520             HTMLFrameElementBase* frameElementBase = nullptr;
2521 
2522             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2523                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2524 
</pre>
<hr />
<pre>
2529                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2530                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2531 
2532                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2533                 // Adjust offsets if they&#39;re outside of the allowable range.
2534                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2535                 frameView.setScrollPosition(scrollOffset);
2536 
2537                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2538                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2539                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2540                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2541                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2542                 } else
2543                     parentLayer = nullptr;
2544             }
2545         } else {
2546             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2547                 return;
2548 



2549 #if !PLATFORM(IOS_FAMILY)
2550             LayoutRect viewRect = frameView.visibleContentRect();
2551 #else
<span class="line-modified">2552             LayoutRect viewRect = frameView.unobscuredContentRectExpandedByContentInsets();</span>









2553 #endif
2554             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2555             LayoutRect targetRect = absoluteRect;
2556             targetRect.move(0, frameView.headerHeight());
2557 
2558             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
<span class="line-modified">2559 </span>
<span class="line-modified">2560             frameView.setScrollPosition(roundedIntPoint(revealRect.location()));</span>



2561 
2562             // This is the outermost view of a web page, so after scrolling this view we
2563             // scroll its container by calling Page::scrollRectIntoView.
2564             // This only has an effect on the Mac platform in applications
2565             // that put web views into scrolling containers, such as Mac OS X Mail.
2566             // The canAutoscroll function in EventHandler also knows about this.
2567             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2568         }
2569     }
2570 
2571     if (parentLayer)
2572         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2573 }
2574 
2575 void RenderLayer::updateCompositingLayersAfterScroll()
2576 {
2577     if (compositor().hasContentCompositingLayers()) {
2578         // Our stacking container is guaranteed to contain all of our descendants that may need
2579         // repositioning, so update compositing layers from there.
2580         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
</pre>
<hr />
<pre>
2753         baseWidth = baseWidth / zoomFactor;
2754         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);
2755     }
2756 
2757     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
2758         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2759             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2760             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2761             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2762         }
2763         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
2764         baseHeight = baseHeight / zoomFactor;
2765         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);
2766     }
2767 
2768     document.updateLayout();
2769 
2770     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
2771 }
2772 
<span class="line-removed">2773 int RenderLayer::scrollSize(ScrollbarOrientation orientation) const</span>
<span class="line-removed">2774 {</span>
<span class="line-removed">2775     Scrollbar* scrollbar = ((orientation == HorizontalScrollbar) ? m_hBar : m_vBar).get();</span>
<span class="line-removed">2776     return scrollbar ? (scrollbar-&gt;totalSize() - scrollbar-&gt;visibleSize()) : 0;</span>
<span class="line-removed">2777 }</span>
<span class="line-removed">2778 </span>
2779 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
2780 {
2781     scrollTo(scrollPositionFromOffset(offset));
2782 }
2783 
<span class="line-modified">2784 int RenderLayer::scrollOffset(ScrollbarOrientation orientation) const</span>
2785 {
<span class="line-modified">2786     if (orientation == HorizontalScrollbar)</span>
<span class="line-modified">2787         return scrollOffset().x();</span>
<span class="line-removed">2788 </span>
<span class="line-removed">2789     if (orientation == VerticalScrollbar)</span>
<span class="line-removed">2790         return scrollOffset().y();</span>
2791 
<span class="line-modified">2792     return 0;</span>
2793 }
2794 
2795 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
2796 {
2797     IntSize scrollbarSpace;
2798     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
2799         scrollbarSpace = scrollbarIntrusion();
2800 
2801     auto visibleSize = this-&gt;visibleSize();
2802     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
2803 }
2804 
2805 IntSize RenderLayer::overhangAmount() const
2806 {
2807 #if ENABLE(RUBBER_BANDING)
2808     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
2809         return IntSize();
2810 
2811     IntSize stretch;
2812 
2813     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
2814     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());

2815     if (scrollOffset.y() &lt; 0)
2816         stretch.setHeight(scrollOffset.y());
<span class="line-modified">2817     else if (scrollableContentsSize().height() &amp;&amp; scrollOffset.y() &gt; scrollableContentsSize().height() - visibleHeight())</span>
<span class="line-modified">2818         stretch.setHeight(scrollOffset.y() - (scrollableContentsSize().height() - visibleHeight()));</span>
2819 
2820     if (scrollOffset.x() &lt; 0)
2821         stretch.setWidth(scrollOffset.x());
<span class="line-modified">2822     else if (scrollableContentsSize().width() &amp;&amp; scrollOffset.x() &gt; scrollableContentsSize().width() - visibleWidth())</span>
<span class="line-modified">2823         stretch.setWidth(scrollOffset.x() - (scrollableContentsSize().width() - visibleWidth()));</span>
2824 
2825     return stretch;
2826 #else
2827     return IntSize();
2828 #endif
2829 }
2830 
2831 bool RenderLayer::isActive() const
2832 {
2833     return page().focusController().isActive();
2834 }
2835 
2836 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
2837 {
2838     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
2839         return minX + layer.renderer().style().borderLeftWidth();
2840     return maxX - thickness - layer.renderer().style().borderRightWidth();
2841 }
2842 
2843 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
</pre>
<hr />
<pre>
2930 {
2931     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
2932     point.move(-scrollbarOffset(scrollbar));
2933     return point;
2934 }
2935 
2936 IntSize RenderLayer::visibleSize() const
2937 {
2938     RenderBox* box = renderBox();
2939     if (!box)
2940         return IntSize();
2941 
2942     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
2943 }
2944 
2945 IntSize RenderLayer::contentsSize() const
2946 {
2947     return IntSize(scrollWidth(), scrollHeight());
2948 }
2949 
<span class="line-modified">2950 IntSize RenderLayer::scrollableContentsSize() const</span>
2951 {
2952     IntSize contentsSize = this-&gt;contentsSize();
2953 
2954     if (!hasScrollableHorizontalOverflow())
2955         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
2956 
2957     if (!hasScrollableVerticalOverflow())
2958         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
2959 
2960     return contentsSize;
2961 }
2962 
2963 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
2964 {
2965     ScrollableArea::availableContentSizeChanged(reason);
2966 
2967     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
2968         if (is&lt;RenderBlock&gt;(renderer()))
2969             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
2970         renderer().setNeedsLayout();
</pre>
<hr />
<pre>
3095     renderBox()-&gt;flipForWritingMode(repaintRect);
3096     renderer().repaintRectangle(repaintRect);
3097 }
3098 
3099 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3100 {
3101     if (!showsOverflowControls())
3102         return;
3103 
3104     if (GraphicsLayer* layer = layerForScrollCorner()) {
3105         layer-&gt;setNeedsDisplayInRect(rect);
3106         return;
3107     }
3108 
3109     if (m_scrollCorner)
3110         m_scrollCorner-&gt;repaintRectangle(rect);
3111     if (m_resizer)
3112         m_resizer-&gt;repaintRectangle(rect);
3113 }
3114 




















3115 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3116 {
3117     if (Element* element = renderer.element()) {
3118         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3119             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3120                 return shadowRoot-&gt;host()-&gt;renderer();
3121         }
3122     }
3123 
3124     return &amp;renderer;
3125 }
3126 
3127 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3128 {
3129     RefPtr&lt;Scrollbar&gt; widget;
3130     ASSERT(rendererForScrollbar(renderer()));
3131     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3132     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3133     if (hasCustomScrollbarStyle)
3134         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
</pre>
<hr />
<pre>
3169         return;
3170 
3171     if (hasScrollbar) {
3172         m_hBar = createScrollbar(HorizontalScrollbar);
3173 #if ENABLE(RUBBER_BANDING)
3174         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3175         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3176 #endif
3177     } else {
3178         destroyScrollbar(HorizontalScrollbar);
3179 #if ENABLE(RUBBER_BANDING)
3180         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3181 #endif
3182     }
3183 
3184     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3185     if (m_hBar)
3186         m_hBar-&gt;styleChanged();
3187     if (m_vBar)
3188         m_vBar-&gt;styleChanged();
<span class="line-removed">3189 </span>
<span class="line-removed">3190     renderer().document().invalidateScrollbarDependentRegions();</span>
3191 }
3192 
3193 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3194 {
3195     if (hasScrollbar == hasVerticalScrollbar())
3196         return;
3197 
3198     if (hasScrollbar) {
3199         m_vBar = createScrollbar(VerticalScrollbar);
3200 #if ENABLE(RUBBER_BANDING)
3201         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3202         ScrollableArea::setVerticalScrollElasticity(elasticity);
3203 #endif
3204     } else {
3205         destroyScrollbar(VerticalScrollbar);
3206 #if ENABLE(RUBBER_BANDING)
3207         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3208 #endif
3209     }
3210 
3211      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3212     if (m_hBar)
3213         m_hBar-&gt;styleChanged();
3214     if (m_vBar)
3215         m_vBar-&gt;styleChanged();
<span class="line-removed">3216 </span>
<span class="line-removed">3217     renderer().document().invalidateScrollbarDependentRegions();</span>
3218 }
3219 
3220 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3221 {
3222     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3223         return scrollableLayer;
3224 
3225     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3226     // if the frame view isn&#39;t scrollable.
3227     return nullptr;
3228 }
3229 
3230 bool RenderLayer::isScrollableOrRubberbandable()
3231 {
3232     return renderer().isScrollableOrRubberbandableBox();
3233 }
3234 
3235 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3236 {
3237     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
</pre>
<hr />
<pre>
3398     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3399     box-&gt;flipForWritingMode(overflowRect);
3400     return overflowRect.maxX();
3401 }
3402 
3403 void RenderLayer::computeScrollDimensions()
3404 {
3405     RenderBox* box = renderBox();
3406     ASSERT(box);
3407 
3408     m_scrollDimensionsDirty = false;
3409 
3410     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3411     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3412 
3413     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3414     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3415         scrollableLeftOverflow -= verticalScrollbarWidth();
3416     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3417     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));


3418 }
3419 
3420 bool RenderLayer::hasScrollableHorizontalOverflow() const
3421 {
3422     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3423 }
3424 
3425 bool RenderLayer::hasScrollableVerticalOverflow() const
3426 {
3427     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3428 }
3429 
3430 bool RenderLayer::hasHorizontalOverflow() const
3431 {
3432     ASSERT(!m_scrollDimensionsDirty);
3433 
3434     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3435 }
3436 
3437 bool RenderLayer::hasVerticalOverflow() const
</pre>
<hr />
<pre>
3468     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3469 
3470     // If overflow requires a scrollbar, then we just need to enable or disable.
3471     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3472         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3473     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3474         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3475 
3476     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3477     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3478     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3479 
3480     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3481         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3482             setHasHorizontalScrollbar(hasHorizontalOverflow);
3483         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3484             setHasVerticalScrollbar(hasVerticalOverflow);
3485 
3486         updateSelfPaintingLayer();
3487 
<span class="line-removed">3488         renderer().document().invalidateScrollbarDependentRegions();</span>
3489         renderer().repaint();
3490 
3491         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3492             if (!m_inOverflowRelayout) {
3493                 m_inOverflowRelayout = true;
3494                 renderer().setNeedsLayout(MarkOnlyThis);
3495                 if (is&lt;RenderBlock&gt;(renderer())) {
3496                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3497                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3498                     block.layoutBlock(true);
3499                 } else
3500                     renderer().layout();
3501                 m_inOverflowRelayout = false;
3502             }
3503         }
3504 
3505         RenderObject* parent = renderer().parent();
3506         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3507             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3508     }
</pre>
<hr />
<pre>
3553         setAdjustForIOSCaretWhenScrolling(true);
3554 #endif
3555         if (clampedScrollOffset != scrollOffset())
3556             scrollToOffset(clampedScrollOffset);
3557 
3558 #if PLATFORM(IOS_FAMILY)
3559         setAdjustForIOSCaretWhenScrolling(false);
3560 #endif
3561     }
3562 
3563     updateScrollbarsAfterLayout();
3564 
3565     if (originalScrollOffset != scrollOffset())
3566         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3567 
3568     if (isComposited()) {
3569         setNeedsCompositingGeometryUpdate();
3570         setNeedsCompositingConfigurationUpdate();
3571     }
3572 
<span class="line-removed">3573 #if PLATFORM(IOS_FAMILY)</span>
3574     if (canUseCompositedScrolling())
3575         setNeedsPostLayoutCompositingUpdate();
<span class="line-removed">3576 #endif</span>
3577 
3578     updateScrollSnapState();
3579 }
3580 
3581 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3582 {
3583     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3584 
3585     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3586         return true;
3587 
3588     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3589         return true;
3590 
3591     if (scrollCornerRect().intersects(localRect))
3592         return true;
3593 
3594     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3595         return true;
3596 
</pre>
<hr />
<pre>
3833     OverlapTestRequestMap overlapTestRequests;
3834 
3835     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
3836     paintLayer(context, paintingInfo, paintFlags);
3837 
3838     for (auto&amp; widget : overlapTestRequests.keys())
3839         widget-&gt;setOverlapTestResult(false);
3840 }
3841 
3842 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
3843 {
3844     if (!m_containsDirtyOverlayScrollbars)
3845         return;
3846 
3847     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
3848     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
3849 
3850     m_containsDirtyOverlayScrollbars = false;
3851 }
3852 
<span class="line-removed">3853 static bool inContainingBlockChain(RenderLayer* startLayer, RenderLayer* endLayer)</span>
<span class="line-removed">3854 {</span>
<span class="line-removed">3855     if (startLayer == endLayer)</span>
<span class="line-removed">3856         return true;</span>
<span class="line-removed">3857     for (const auto* currentBlock = startLayer-&gt;renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {</span>
<span class="line-removed">3858         if (currentBlock-&gt;layer() == endLayer)</span>
<span class="line-removed">3859             return true;</span>
<span class="line-removed">3860     }</span>
<span class="line-removed">3861 </span>
<span class="line-removed">3862     return false;</span>
<span class="line-removed">3863 }</span>
<span class="line-removed">3864 </span>
3865 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
3866 {
3867     float deviceScaleFactor = renderer().document().deviceScaleFactor();
3868     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
3869     if (needsClipping || clipRect.affectedByRadius())
3870         context.save();
3871 
3872     if (needsClipping) {
3873         LayoutRect adjustedClipRect = clipRect.rect();
3874         adjustedClipRect.move(paintingInfo.subpixelOffset);
<span class="line-modified">3875         context.clip(snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor));</span>




3876     }
3877 
3878     if (clipRect.affectedByRadius()) {
3879         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
3880         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
3881         // containing block chain so we check that also.
3882         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
<span class="line-modified">3883             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; inContainingBlockChain(this, layer)) {</span>
3884                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
3885                 adjustedClipRect.move(paintingInfo.subpixelOffset);
3886                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
3887                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
3888                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
3889                 else
3890                     context.clipRoundedRect(roundedRect);
3891             }
3892 
3893             if (layer == paintingInfo.rootLayer)
3894                 break;
3895         }
3896     }
3897 }
3898 
3899 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
3900 {
<span class="line-modified">3901     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius())</span>
3902         context.restore();




3903 }
3904 
3905 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
3906 {



3907     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
3908     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
3909     for (auto&amp; request : overlapTestRequests) {
3910         if (!boundingBox.intersects(request.value))
3911             continue;
3912 
3913         request.key-&gt;setOverlapTestResult(true);
3914         overlappedRequestClients.append(request.key);
3915     }
3916     for (auto* client : overlappedRequestClients)
3917         overlapTestRequests.remove(client);
3918 }
3919 
3920 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
3921 {
3922     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
3923 }
3924 
3925 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
3926 {
3927     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
3928         return true;
3929 
3930     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
3931     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
3932     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
3933         return true;
3934 
3935     return false;
3936 }
3937 
3938 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
3939 {
3940     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
3941 }
3942 
3943 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
3944 {
<span class="line-modified">3945     if (isComposited()) {</span>
<span class="line-modified">3946         // The performingPaintInvalidation() painting pass goes through compositing layers,</span>
<span class="line-modified">3947         // but we need to ensure that we don&#39;t cache clip rects computed with the wrong root in this case.</span>
<span class="line-modified">3948         if (context.performingPaintInvalidation() || (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))</span>
<span class="line-modified">3949             paintFlags.add(PaintLayerTemporaryClipRects);</span>
<span class="line-modified">3950         else if (!backing()-&gt;paintsIntoWindow()</span>
<span class="line-modified">3951             &amp;&amp; !backing()-&gt;paintsIntoCompositedAncestor()</span>
<span class="line-modified">3952             &amp;&amp; !shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))</span>
<span class="line-modified">3953             &amp;&amp; !paintForFixedRootBackground(this, paintFlags)) {</span>
<span class="line-modified">3954             // If this RenderLayer should paint into its backing, that will be done via RenderLayerBacking::paintIntoLayer().</span>









3955             return;
<span class="line-modified">3956         }</span>
<span class="line-modified">3957     } else if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {</span>



3958         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
3959         // unless their position or viewport size is changed.
3960         ASSERT(renderer().isFixedPositioned());
3961         return;
3962     }
3963 





3964     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
3965     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
3966         return;
3967 
3968     if (shouldSuppressPaintingLayer(this))
3969         return;
3970 
3971     // If this layer is totally invisible then there is nothing to paint.
3972     if (!renderer().opacity())
3973         return;
3974 
3975     if (paintsWithTransparency(paintingInfo.paintBehavior))
3976         paintFlags.add(PaintLayerHaveTransparency);
3977 
3978     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
3979     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
3980         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
3981         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
3982         if (!layerTransform.isInvertible())
3983             return;
</pre>
<hr />
<pre>
4219 {
4220     // FIXME: Handle more than one fragment.
4221     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4222     clipToRect(originalContext, paintingInfo, backgroundRect);
4223     m_filters-&gt;applyFilterEffect(originalContext);
4224     restoreClip(originalContext, paintingInfo, backgroundRect);
4225 }
4226 
4227 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4228 {
4229     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4230 
4231     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4232     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4233     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4234     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4235     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4236     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4237     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4238     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);

4239     // Outline always needs to be painted even if we have no visible content. Also,
4240     // the outline is painted in the background phase during composited scrolling.
4241     // If it were painted in the foreground phase, it would move with the scrolled
4242     // content. When not composited scrolling, the outline is painted in the
4243     // foreground phase. Since scrolled contents are moved by repainting in this
4244     // case, the outline won&#39;t get &#39;dragged along&#39;.
<span class="line-modified">4245     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars</span>

4246         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4247         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
<span class="line-modified">4248     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars;</span>
4249 
4250     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
4251         return;
4252 
4253     updateLayerListsIfNeeded();
4254 
4255     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4256     LayoutRect rootRelativeBounds;
4257     bool rootRelativeBoundsComputed = false;
4258 
4259     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4260     // things on the scrolling thread.
4261     bool didQuantizeFonts = true;
4262     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4263 
4264     // Apply clip-path to context.
4265     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4266     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4267         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4268 
</pre>
<hr />
<pre>
4299 
4300         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4301         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4302             paintBehavior.add(PaintBehavior::SkipRootBackground);
4303         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4304             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4305 
4306         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4307             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4308 
4309         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4310             paintBehavior.add(PaintBehavior::Snapshotting);
4311 
4312         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4313             paintBehavior.add(PaintBehavior::TileFirstPaint);
4314 
4315         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4316             paintBehavior.add(PaintBehavior::ExcludeSelection);
4317 
4318         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
<span class="line-modified">4319         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars) {</span>
4320             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4321             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4322             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4323             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4324                 // We can turn clipping back by requesting full repaint for the overflow area.
4325                 localPaintingInfo.clipToDirtyRect = true;
4326                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4327             }
4328             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4329                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4330                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4331             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4332         }
4333 
4334         if (isPaintingCompositedBackground) {
4335             // Paint only the backgrounds for all of the fragments of the layer.
4336             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4337                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4338                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4339             }
4340         }
4341 
4342         // Now walk the sorted list of children with negative z-indices.
4343         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4344             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4345 
4346         if (isPaintingCompositedForeground) {
4347             if (shouldPaintContent) {
4348                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4349                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4350             }
4351         }
4352 



4353         if (shouldPaintOutline)
4354             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4355 
4356         if (isPaintingCompositedForeground) {
4357             // Paint any child layers that have overflow.
4358             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4359 
4360             // Now walk the sorted list of children with positive z-indices.
4361             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4362         }
4363 
4364         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4365             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4366 
4367         if (filterContext) {
4368             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4369             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4370             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4371             LayerFragments layerFragments;
4372             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
</pre>
<hr />
<pre>
4419     if (hasClipPath)
4420         context.restore();
4421 }
4422 
4423 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4424 {
4425     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4426     // the accumulated error for sub-pixel layout.
4427     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4428     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4429     offsetFromParent += translationOffset;
4430     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4431     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4432     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4433     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4434     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4435     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4436     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4437     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4438     // Apply the transform.
<span class="line-modified">4439     AffineTransform oldTransfrom = context.getCTM();</span>
<span class="line-modified">4440     context.concatCTM(transform.toAffineTransform());</span>




4441 
4442     // Now do a paint with the root layer shifted to be us.
4443     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4444     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4445     transformedPaintingInfo.rootLayer = this;
4446     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4447     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4448     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
<span class="line-modified">4449     context.setCTM(oldTransfrom);</span>




4450 }
4451 
4452 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4453 {
4454     if (layerIterator.begin() == layerIterator.end())
4455         return;
4456 
4457     if (!hasSelfPaintingLayerDescendant())
4458         return;
4459 
4460 #if !ASSERT_DISABLED
4461     LayerListMutationDetector mutationChecker(*this);
4462 #endif
4463 
4464     for (auto* childLayer : layerIterator)
4465         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4466 }
4467 
4468 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4469 {
</pre>
<hr />
<pre>
4714 
4715     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4716         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
4717 
4718     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4719         localPaintBehavior.add(PaintBehavior::Snapshotting);
4720 
4721     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4722         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
4723 
4724     // Optimize clipping for the single fragment case.
4725     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
4726     ClipRect clippedRect;
4727     if (shouldClip) {
4728         clippedRect = layerFragments[0].foregroundRect;
4729         clipToRect(context, localPaintingInfo, clippedRect);
4730     }
4731 
4732     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
4733     // interleaving of the fragments to work properly.
<span class="line-modified">4734     bool selectionOnly = localPaintingInfo.paintBehavior.containsAny({ PaintBehavior::SelectionAndBackgroundsOnly, PaintBehavior::SelectionOnly });</span>
<span class="line-modified">4735     paintForegroundForFragmentsWithPhase(selectionOnly ? PaintPhase::Selection : PaintPhase::ChildBlockBackgrounds, layerFragments,</span>
<span class="line-modified">4736         context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>


4737 
<span class="line-modified">4738     if (!selectionOnly) {</span>


4739         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4740         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4741         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4742     }
4743 
4744     if (shouldClip)
4745         restoreClip(context, localPaintingInfo, clippedRect);
4746 }
4747 
4748 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
4749     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4750 {
4751     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
4752 
4753     for (const auto&amp; fragment : layerFragments) {
4754         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
4755             continue;
4756 
4757         if (shouldClip)
4758             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
</pre>
<hr />
<pre>
4815         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4816         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4817 
4818         if (localPaintingInfo.clipToDirtyRect)
4819             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
4820     }
4821 }
4822 
4823 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
4824 {
4825     for (const auto&amp; fragment : layerFragments) {
4826         if (fragment.backgroundRect.isEmpty())
4827             continue;
4828         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
4829         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
4830             snappedIntRect(fragment.backgroundRect.rect()), true);
4831         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4832     }
4833 }
4834 











4835 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
4836 {
4837     return hitTest(request, result.hitTestLocation(), result);
4838 }
4839 
4840 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
4841 {
4842     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4843     ASSERT(!renderer().view().needsLayout());
4844 
4845     ASSERT(!isRenderFragmentedFlow());
4846     LayoutRect hitTestArea = renderer().view().documentRect();
4847     if (!request.ignoreClipping()) {
4848         const auto&amp; settings = renderer().settings();
4849         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
4850             auto&amp; frameView = renderer().view().frameView();
4851             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
4852             auto scaleFactor = frameView.frame().frameScaleFactor();
4853             if (scaleFactor &gt; 1)
4854                 absoluteLayoutViewportRect.scale(scaleFactor);
</pre>
<hr />
<pre>
5320     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5321     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5322     if (m_clipRectsCache) {
5323         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5324             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5325             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5326 
5327 #ifdef CHECK_CACHED_CLIP_RECTS
5328             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5329             ClipRectsContext tempContext(clipRectsContext);
5330             tempContext.clipRectsType = TemporaryClipRects;
5331             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5332             calculateClipRects(tempContext, tempClipRects);
5333             ASSERT(tempClipRects.get() == *clipRects);
5334 #endif
5335             return *clipRects; // We have the correct cached value.
5336         }
5337     }
5338 
5339     if (!m_clipRectsCache)
<span class="line-modified">5340         m_clipRectsCache = std::make_unique&lt;ClipRectsCache&gt;();</span>
5341 #ifndef NDEBUG
5342     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5343     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5344 #endif
5345 
5346     RefPtr&lt;ClipRects&gt; parentClipRects;
5347     // For transformed layers, the root layer was shifted to be us, so there is no need to
5348     // examine the parent. We want to cache clip rects with us as the root.
<span class="line-modified">5349     if (auto* parentLayer = (clipRectsContext.rootLayer != this ? parent() : nullptr))</span>
<span class="line-modified">5350         parentClipRects = parentLayer-&gt;updateClipRects(clipRectsContext);</span>
5351 
5352     auto clipRects = ClipRects::create();
5353     calculateClipRects(clipRectsContext, clipRects);
5354 
5355     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5356         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5357         return parentClipRects.releaseNonNull();
5358     }
5359     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5360     return clipRects;
5361 }
5362 
5363 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5364 {
5365     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5366     if (!m_clipRectsCache)
5367         return nullptr;
5368     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5369 }
5370 






5371 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5372 {
5373     if (!parent()) {
5374         // The root layer&#39;s clip rect is always infinite.
5375         clipRects.reset();
5376         return;
5377     }
5378 
5379     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5380     bool useCached = clipRectsType != TemporaryClipRects;
5381 
5382     // For transformed layers, the root layer was shifted to be us, so there is no need to
5383     // examine the parent. We want to cache clip rects with us as the root.
5384     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5385 
5386     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5387     if (parentLayer) {
5388         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5389             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5390         else {
5391             ClipRectsContext parentContext(clipRectsContext);
5392             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?




5393             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5394         }
5395     } else
5396         clipRects.reset();
5397 
5398     // A fixed object is essentially the root of its containing block hierarchy, so when
5399     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5400     if (renderer().isFixedPositioned()) {
5401         clipRects.setPosClipRect(clipRects.fixedClipRect());
5402         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5403         clipRects.setFixed(true);
5404     } else if (renderer().isInFlowPositioned())
5405         clipRects.setPosClipRect(clipRects.overflowClipRect());
5406     else if (renderer().isAbsolutelyPositioned())
5407         clipRects.setOverflowClipRect(clipRects.posClipRect());
5408 
5409     // Update the clip rects that will be passed to child layers.
5410 #if PLATFORM(IOS_FAMILY)
5411     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5412 #else
5413     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5414 #endif
5415         // This layer establishes a clip of some kind.





5416 
<span class="line-removed">5417         // This offset cannot use convertToLayerCoords, because sometimes our rootLayer may be across</span>
<span class="line-removed">5418         // some transformed layer boundary, for example, in the RenderLayerCompositor overlapMap, where</span>
<span class="line-removed">5419         // clipRects are needed in view space.</span>
<span class="line-removed">5420         LayoutPoint offset(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));</span>
5421         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5422             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5423 
5424         if (renderer().hasOverflowClip()) {
5425             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5426             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5427             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5428             if (renderer().isPositioned())
5429                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5430         }
5431         if (renderer().hasClip()) {
5432             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5433             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5434             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5435             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5436         }
5437     }


5438 }
5439 
5440 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5441 {
5442     ASSERT(parent());
5443 
<span class="line-modified">5444     if (clipRectsContext.clipRectsType == TemporaryClipRects) {</span>
5445         auto parentClipRects = ClipRects::create();
<span class="line-modified">5446         parent()-&gt;calculateClipRects(clipRectsContext, parentClipRects);</span>
5447         return parentClipRects;









5448     }
5449 
5450     return parent()-&gt;updateClipRects(clipRectsContext);
5451 }
5452 
5453 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5454 {
5455     if (position == PositionType::Fixed)
5456         return parentRects.fixedClipRect();
5457 
5458     if (position == PositionType::Absolute)
5459         return parentRects.posClipRect();
5460 
5461     return parentRects.overflowClipRect();
5462 }
5463 
5464 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5465 {
5466     ASSERT(parent());
<span class="line-modified">5467     auto computeParentRects = [&amp;] {</span>
<span class="line-removed">5468         if (clipRectsContext.clipRectsType == TemporaryClipRects)</span>
<span class="line-removed">5469             return parentClipRects(clipRectsContext);</span>
<span class="line-removed">5470         // If we cross into a different composition/pagination context, then we can&#39;t rely on the cache since the root layer differs.</span>
<span class="line-removed">5471         bool crossesPaginationBoundary = parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers);</span>
<span class="line-removed">5472         bool crossesCompositingBoundary = parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();</span>
<span class="line-removed">5473         if (!crossesPaginationBoundary &amp;&amp; !crossesCompositingBoundary)</span>
<span class="line-removed">5474             return parentClipRects(clipRectsContext);</span>
<span class="line-removed">5475 </span>
<span class="line-removed">5476         ClipRectsContext tempContext(clipRectsContext);</span>
<span class="line-removed">5477         tempContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-removed">5478         return parentClipRects(tempContext);</span>
<span class="line-removed">5479     };</span>
<span class="line-removed">5480 </span>
<span class="line-removed">5481     auto parentRects = computeParentRects();</span>
5482     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5483     RenderView&amp; view = renderer().view();
5484     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5485     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5486         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());


5487     return backgroundClipRect;
5488 }
5489 
5490 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5491     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5492 {
5493     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5494         backgroundRect = backgroundClipRect(clipRectsContext);
5495         backgroundRect.intersect(paintDirtyRect);
5496     } else
5497         backgroundRect = paintDirtyRect;
5498 
5499     LayoutSize offsetFromRootLocal = offsetFromRoot;
5500 
5501     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5502         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5503         offsetFromRootLocal += toLayoutSize(absPos);
5504     }
5505 
5506     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
</pre>
<hr />
<pre>
5673     // floats.
5674     LayoutRect result;
5675     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
5676         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
5677     else if (is&lt;RenderTableRow&gt;(renderer())) {
5678         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
5679         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
5680         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
5681             LayoutRect bbox = cell-&gt;borderBoxRect();
5682             result.unite(bbox);
5683             LayoutRect overflowRect = tableRow.visualOverflowRect();
5684             if (bbox != overflowRect)
5685                 result.unite(overflowRect);
5686         }
5687     } else {
5688         RenderBox* box = renderBox();
5689         ASSERT(box);
5690         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
5691             result = box-&gt;maskClipRect(LayoutPoint());
5692             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
<span class="line-modified">5693         } else {</span>
<span class="line-modified">5694             LayoutRect bbox = box-&gt;borderBoxRect();</span>
<span class="line-removed">5695             result = bbox;</span>
<span class="line-removed">5696             LayoutRect overflowRect = box-&gt;visualOverflowRect();</span>
<span class="line-removed">5697             if (bbox != overflowRect)</span>
<span class="line-removed">5698                 result.unite(overflowRect);</span>
<span class="line-removed">5699         }</span>
5700     }
5701     return result;
5702 }
5703 
5704 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5705 {
5706     LayoutRect result = localBoundingBox(flags);
5707     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
5708         if (renderer().isBox())
5709             renderBox()-&gt;flipForWritingMode(result);
5710         else
5711             renderer().containingBlock()-&gt;flipForWritingMode(result);
5712     }
5713 
5714     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
5715     if (flags &amp; UseFragmentBoxesIncludingCompositing)
5716         inclusionMode = IncludeCompositedPaginatedLayers;
5717 
5718     const RenderLayer* paginationLayer = nullptr;
5719     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
</pre>
<hr />
<pre>
5834 
5835     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
5836     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
5837 
5838     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
5839 
5840     if (RenderLayer* reflection = reflectionLayer()) {
5841         if (!reflection-&gt;isComposited()) {
5842             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
5843             unionBounds.unite(childUnionBounds);
5844         }
5845     }
5846 
5847     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
5848 
5849 #if !ASSERT_DISABLED
5850     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
5851 #endif
5852 
5853     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
<span class="line-modified">5854         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; childLayer.isComposited())</span>
5855             return;
5856         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
5857         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
5858         // that we hit the max LayoutUnit value.
5859         unionBounds.checkedUnite(childBounds);
5860     };
5861 
5862     for (auto* childLayer : negativeZOrderLayers())
5863         computeLayersUnion(*childLayer);
5864 
5865     for (auto* childLayer : positiveZOrderLayers())
5866         computeLayersUnion(*childLayer);
5867 
5868     for (auto* childLayer : normalFlowLayers())
5869         computeLayersUnion(*childLayer);
5870 
5871     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
5872         renderer().style().filterOutsets().expandRect(unionBounds);
5873 
5874     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
</pre>
<hr />
<pre>
5889     clearClipRects(typeToClear);
5890 
5891     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
5892         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
5893 }
5894 
5895 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
5896 {
5897     if (typeToClear == AllClipRectTypes)
5898         m_clipRectsCache = nullptr;
5899     else {
5900         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
5901         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
5902         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
5903     }
5904 }
5905 
5906 RenderLayerBacking* RenderLayer::ensureBacking()
5907 {
5908     if (!m_backing) {
<span class="line-modified">5909         m_backing = std::make_unique&lt;RenderLayerBacking&gt;(*this);</span>
5910         compositor().layerBecameComposited(*this);
5911 
5912         updateFilterPaintingStrategy();
5913     }
5914     return m_backing.get();
5915 }
5916 
5917 void RenderLayer::clearBacking(bool layerBeingDestroyed)
5918 {
5919     if (!m_backing)
5920         return;
5921 
5922     if (!renderer().renderTreeBeingDestroyed())
5923         compositor().layerBecameNonComposited(*this);
5924 
5925     m_backing-&gt;willBeDestroyed();
5926     m_backing = nullptr;
5927 
5928     if (!layerBeingDestroyed)
5929         updateFilterPaintingStrategy();
</pre>
<hr />
<pre>
6028     // We can&#39;t consult child layers if we clip, since they might cover
6029     // parts of the rect that are clipped out.
6030     if (renderer().hasOverflowClip())
6031         return false;
6032 
6033     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6034         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6035         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6036 }
6037 
6038 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6039 {
6040     if (list.begin() == list.end())
6041         return false;
6042 
6043     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6044         const auto* childLayer = *iter;
6045         if (childLayer-&gt;isComposited())
6046             continue;
6047 
<span class="line-modified">6048         if (!childLayer-&gt;canUseConvertToLayerCoords())</span>
6049             continue;
6050 
6051         LayoutRect childLocalRect(localRect);
6052         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6053 
6054         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6055             return true;
6056     }
6057     return false;
6058 }
6059 
6060 void RenderLayer::repaintIncludingDescendants()
6061 {
6062     renderer().repaint();
6063     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6064         current-&gt;repaintIncludingDescendants();
6065 }
6066 
6067 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6068 {
</pre>
<hr />
<pre>
6140 
6141 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6142 {
6143     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6144     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6145 }
6146 
6147 // Constrain the depth and breadth of the search for performance.
6148 static const unsigned maxRendererTraversalCount = 200;
6149 
6150 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6151 {
6152     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6153         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6154             request.makeStatesUndetermined();
6155             return;
6156         }
6157 
6158         if (is&lt;RenderText&gt;(child)) {
6159             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
<span class="line-modified">6160             if (renderText.linesBoundingBox().isEmpty())</span>
6161                 continue;
6162 
6163             if (renderer.style().userSelect() != UserSelect::None)
6164                 request.setHasPaintedContent();
6165 
6166             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6167                 request.setHasPaintedContent();
6168 
6169                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6170                     request.setHasSubpixelAntialiasedText();
6171             }
6172 
6173             if (request.isSatisfied())
6174                 return;
6175         }
6176 
6177         if (!is&lt;RenderElement&gt;(child))
6178             continue;
6179 
6180         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
</pre>
<hr />
<pre>
6279     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6280     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6281     setHasVerticalScrollbar(needsVerticalScrollbar);
6282 
6283     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6284     // When switching to another value, we need to re-enable them (see bug 11985).
6285     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6286         m_hBar-&gt;setEnabled(true);
6287 
6288     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6289         m_vBar-&gt;setEnabled(true);
6290 
6291     if (!m_scrollDimensionsDirty)
6292         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6293 }
6294 
6295 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6296 {
6297     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6298 
<span class="line-modified">6299     if (setIsStackingContext(shouldBeStackingContext())) {</span>
6300 #if ENABLE(CSS_COMPOSITING)
6301         if (parent()) {
<span class="line-modified">6302             if (isStackingContext()) {</span>
6303                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6304                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6305             } else {
6306                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6307                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6308                 else if (hasNotIsolatedBlendingDescendants())
6309                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6310             }
6311         }
6312 #endif
6313     }
6314 
6315     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could
6316     // likely be folded along with the rest.
6317     if (oldStyle) {
6318         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6319             dirtyStackingContextZOrderLists();
6320             if (isStackingContext())
6321                 dirtyZOrderLists();
6322         }
6323     }
6324 
6325     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6326         if (!m_marquee)
<span class="line-modified">6327             m_marquee = std::make_unique&lt;RenderMarquee&gt;(this);</span>
6328         m_marquee-&gt;updateMarqueeStyle();
6329     } else if (m_marquee)
6330         m_marquee = nullptr;
6331 
6332     updateScrollbarsAfterStyleChange(oldStyle);
6333     // Overlay scrollbars can make this layer self-painting so we need
6334     // to recompute the bit once scrollbars have been updated.
6335     updateSelfPaintingLayer();
6336 
6337     if (!hasReflection() &amp;&amp; m_reflection)
6338         removeReflection();
6339     else if (hasReflection()) {
6340         if (!m_reflection)
6341             createReflection();
6342         else
6343             m_reflection-&gt;setStyle(createReflectionStyle());
6344     }
6345 
6346     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6347     if (m_hBar)
</pre>
<hr />
<pre>
6519             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6520             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6521             break;
6522     }
6523     newStyle.setTransform(transform);
6524 
6525     // Map in our mask.
6526     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6527 
6528     // Style has transform and mask, so needs to be stacking context.
6529     newStyle.setZIndex(0);
6530 
6531     return newStyle;
6532 }
6533 
6534 void RenderLayer::ensureLayerFilters()
6535 {
6536     if (m_filters)
6537         return;
6538 
<span class="line-modified">6539     m_filters = std::make_unique&lt;RenderLayerFilters&gt;(*this);</span>
6540 }
6541 
6542 void RenderLayer::clearLayerFilters()
6543 {
6544     m_filters = nullptr;
6545 }
6546 
6547 void RenderLayer::updateFiltersAfterStyleChange()
6548 {
6549     if (!hasFilter()) {
6550         clearLayerFilters();
6551         return;
6552     }
6553 
6554     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6555     // an SVG. In that case it takes care of its own resource management for filters.
6556     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6557         ensureLayerFilters();
6558         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6559     } else if (m_filters)
</pre>
<hr />
<pre>
6575         // For reference filters, we still want the FilterEffect graph built
6576         // for us, even if we&#39;re composited.
6577         if (!renderer().style().filter().hasReferenceFilter())
6578             return;
6579     }
6580 
6581     ensureLayerFilters();
6582     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);
6583 }
6584 
6585 void RenderLayer::filterNeedsRepaint()
6586 {
6587     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6588     if (Element* element = enclosingElement()) {
6589         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6590         element-&gt;invalidateStyleAndLayerComposition();
6591     }
6592     renderer().repaint();
6593 }
6594 



















































































6595 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6596 {
6597     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6598     if (layer.transform())
6599         ts &lt;&lt; &quot; has transform&quot;;
6600     if (layer.hasFilter())
6601         ts &lt;&lt; &quot; has filter&quot;;
6602     if (layer.hasBackdropFilter())
6603         ts &lt;&lt; &quot; has backdrop filter&quot;;
6604     if (layer.hasBlendMode())
6605         ts &lt;&lt; &quot; has blend mode&quot;;
6606     if (layer.isolatesBlending())
6607         ts &lt;&lt; &quot; isolates blending&quot;;
6608     if (layer.isComposited())
6609         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6610     return ts;
6611 }
6612 

























6613 } // namespace WebCore
6614 
6615 #if ENABLE(TREE_DEBUGGING)
6616 
6617 void showLayerTree(const WebCore::RenderLayer* layer)
6618 {
6619     if (!layer)
6620         return;
6621 
<span class="line-modified">6622     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), WebCore::RenderAsTextShowAllLayers | WebCore::RenderAsTextShowLayerNesting | WebCore::RenderAsTextShowCompositedLayers | WebCore::RenderAsTextShowAddresses | WebCore::RenderAsTextShowIDAndClass | WebCore::RenderAsTextDontUpdateLayout | WebCore::RenderAsTextShowLayoutState | WebCore::RenderAsTextShowOverflow | WebCore::RenderAsTextShowSVGGeometry | WebCore::RenderAsTextShowLayerFragments);</span>











6623     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
6624 }
6625 
6626 void showLayerTree(const WebCore::RenderObject* renderer)
6627 {
6628     if (!renderer)
6629         return;
6630     showLayerTree(renderer-&gt;enclosingLayer());
6631 }
6632 
6633 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
6634 {
6635     stream.nextLine();
<span class="line-modified">6636     stream &lt;&lt; &quot;(S)tacking Context, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, (C)omposited, (c)omposited descendant\n&quot;</span>
6637         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
6638         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
6639         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
6640     stream.nextLine();
6641 }
6642 
6643 static void outputIdent(TextStream&amp; stream, unsigned depth)
6644 {
6645     unsigned i = 0;
6646     while (++i &lt;= depth * 2)
6647         stream &lt;&lt; &quot; &quot;;
6648 }
6649 
6650 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
6651 {
<span class="line-modified">6652     stream &lt;&lt; (layer.isStackingContext() ? &quot;S&quot; : &quot;-&quot;);</span>
6653     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
6654     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
6655     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
6656     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
6657     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
6658     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
6659     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
6660     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);

6661     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);


















6662     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);


6663 
6664     stream &lt;&lt; &quot; &quot;;
6665 
6666     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
6667     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
6668 
6669     stream &lt;&lt; &quot; &quot;;
6670 
6671     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
6672     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
6673     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
6674     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
6675     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
6676     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
6677 
6678     stream &lt;&lt; &quot; &quot;;
6679 
6680     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
6681     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
6682     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
6683     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
6684     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
6685     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
6686 
6687     stream &lt;&lt; &quot; &quot;;
6688 
6689     outputIdent(stream, depth);
6690 
6691     stream &lt;&lt; prefix;
6692 
6693     auto layerRect = layer.rect();
6694 
6695     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
6696     if (layer.isComposited()) {
6697         auto&amp; backing = *layer.backing();
6698         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
6699 



6700         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
6701         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
6702         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);

6703 
<span class="line-modified">6704         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID) {</span>
6705             stream &lt;&lt; &quot; {&quot;;
6706             bool first = true;
6707             if (scrollingNodeID) {
6708                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
6709                 first = false;
6710             }
6711 
6712             if (frameHostingNodeID) {
6713                 if (!first)
6714                     stream &lt;&lt; &quot;, &quot;;
6715                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
6716                 first = false;
6717             }
6718 
6719             if (viewportConstrainedNodeID) {
6720                 if (!first)
6721                     stream &lt;&lt; &quot;, &quot;;
6722                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;







6723             }
6724 
6725             stream &lt;&lt; &quot;}&quot;;
6726         }
6727     }
6728     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
6729     stream.nextLine();
6730 
6731     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
6732 
6733     for (auto* child : layer.negativeZOrderLayers())
6734         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
6735 
6736     for (auto* child : layer.normalFlowLayers())
6737         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
6738 
6739     for (auto* child : layer.positiveZOrderLayers())
6740         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
6741 }
6742 
</pre>
</td>
<td>
<hr />
<pre>
 251         if (respectOverflow == RespectOverflowClip)
 252             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 253         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 254         return index;
 255     }
 256 
 257     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 258 };
 259 
 260 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 261 {
 262 #if !ENABLE(3D_TRANSFORMS)
 263     UNUSED_PARAM(has3DRendering);
 264     matrix.makeAffine();
 265 #else
 266     if (!has3DRendering)
 267         matrix.makeAffine();
 268 #endif
 269 }
 270 
<span class="line-added"> 271 #if !LOG_DISABLED</span>
<span class="line-added"> 272 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)</span>
<span class="line-added"> 273 {</span>
<span class="line-added"> 274     TextStream::GroupScope scope(ts);</span>
<span class="line-added"> 275     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;</span>
<span class="line-added"> 276     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 277     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 278     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;</span>
<span class="line-added"> 279 </span>
<span class="line-added"> 280     return ts;</span>
<span class="line-added"> 281 }</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283 #endif</span>
<span class="line-added"> 284 </span>
 285 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 286     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 287     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
<span class="line-added"> 288     , m_isOpportunisticStackingContext(false)</span>
 289     , m_zOrderListsDirty(false)
 290     , m_normalFlowListDirty(true)
 291     , m_hadNegativeZOrderList(false)
 292     , m_inResizeMode(false)
 293     , m_scrollDimensionsDirty(true)
 294     , m_hasSelfPaintingLayerDescendant(false)
 295     , m_hasSelfPaintingLayerDescendantDirty(false)
 296     , m_usedTransparency(false)
 297     , m_paintingInsideReflection(false)
 298     , m_inOverflowRelayout(false)
 299     , m_repaintStatus(NeedsNormalRepaint)
 300     , m_visibleContentStatusDirty(true)
 301     , m_hasVisibleContent(false)
 302     , m_visibleDescendantStatusDirty(false)
 303     , m_hasVisibleDescendant(false)
 304     , m_registeredScrollableArea(false)
 305     , m_isFixedIntersectingViewport(false)
<span class="line-added"> 306     , m_behavesAsFixed(false)</span>
 307     , m_3DTransformedDescendantStatusDirty(true)
 308     , m_has3DTransformedDescendant(false)
 309     , m_hasCompositingDescendant(false)
<span class="line-added"> 310     , m_hasCompositedScrollingAncestor(false)</span>
<span class="line-added"> 311     , m_hasCompositedScrollableOverflow(false)</span>
 312     , m_hasTransformedAncestor(false)
 313     , m_has3DTransformedAncestor(false)
 314     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 315     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 316 #if PLATFORM(IOS_FAMILY)
 317 #if ENABLE(IOS_TOUCH_EVENTS)
 318     , m_registeredAsTouchEventListenerForScrolling(false)
 319 #endif
 320     , m_adjustForIOSCaretWhenScrolling(false)
 321 #endif

 322     , m_requiresScrollPositionReconciliation(false)
 323     , m_containsDirtyOverlayScrollbars(false)
 324     , m_updatingMarqueePosition(false)
 325 #if !ASSERT_DISABLED
 326     , m_layerListMutationAllowed(true)
 327 #endif
 328 #if ENABLE(CSS_COMPOSITING)
 329     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 330     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 331     , m_hasNotIsolatedBlendingDescendants(false)
 332     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 333 #endif
 334     , m_renderer(rendererLayerModelObject)
 335 {
 336     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
<span class="line-modified"> 337     setIsCSSStackingContext(shouldBeCSSStackingContext());</span>
 338 
 339     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 340 
 341     if (!renderer().firstChild()) {
 342         m_visibleContentStatusDirty = false;
 343         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 344     }
 345 
 346     if (Element* element = renderer().element()) {
 347         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 348         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 349         if (!m_scrollPosition.isZero())
 350             scrollAnimator().setCurrentPosition(m_scrollPosition);
 351         element-&gt;setSavedLayerScrollPosition(IntPoint());
 352     }
 353 }
 354 
 355 RenderLayer::~RenderLayer()
 356 {
 357     if (inResizeMode())
</pre>
<hr />
<pre>
 365 #if ENABLE(IOS_TOUCH_EVENTS)
 366     unregisterAsTouchEventListenerForScrolling();
 367 #endif
 368     if (Element* element = renderer().element())
 369         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 370 
 371     destroyScrollbar(HorizontalScrollbar);
 372     destroyScrollbar(VerticalScrollbar);
 373 
 374     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 375         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 376 
 377     if (m_reflection)
 378         removeReflection();
 379 
 380     clearScrollCorner();
 381     clearResizer();
 382 
 383     clearLayerFilters();
 384 
<span class="line-added"> 385     if (paintsIntoProvidedBacking()) {</span>
<span class="line-added"> 386         auto* backingProviderLayer = this-&gt;backingProviderLayer();</span>
<span class="line-added"> 387         if (backingProviderLayer-&gt;backing())</span>
<span class="line-added"> 388             backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added"> 389     }</span>
<span class="line-added"> 390 </span>
 391     // Child layers will be deleted by their corresponding render objects, so
 392     // we don&#39;t need to delete them ourselves.
 393 
 394     clearBacking(true);
 395 
 396     // Layer and all its children should be removed from the tree before destruction.
 397     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 398     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 399 }
 400 
 401 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 402 {
 403     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 404     if (prevSibling) {
 405         child.setPreviousSibling(prevSibling);
 406         prevSibling-&gt;setNextSibling(&amp;child);
 407         ASSERT(prevSibling != &amp;child);
 408     } else
 409         setFirstChild(&amp;child);
 410 
</pre>
<hr />
<pre>
 566         || renderer.style().hasIsolation()
 567         || !renderer.style().hasAutoZIndex()
 568         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 569 }
 570 
 571 bool RenderLayer::shouldBeNormalFlowOnly() const
 572 {
 573     if (canCreateStackingContext(*this))
 574         return false;
 575 
 576     return renderer().hasOverflowClip()
 577         || renderer().isCanvas()
 578         || renderer().isVideo()
 579         || renderer().isEmbeddedObject()
 580         || renderer().isRenderIFrame()
 581         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 582         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 583         || renderer().isInFlowRenderFragmentedFlow();
 584 }
 585 
<span class="line-modified"> 586 bool RenderLayer::shouldBeCSSStackingContext() const</span>
 587 {
<span class="line-modified"> 588     return !renderer().style().hasAutoZIndex() || isRenderViewLayer();</span>
 589 }
 590 
 591 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 592 {
 593     if (isNormalFlowOnly == m_isNormalFlowOnly)
 594         return false;
 595 
 596     m_isNormalFlowOnly = isNormalFlowOnly;
 597 
 598     if (auto* p = parent())
 599         p-&gt;dirtyNormalFlowList();
 600     dirtyStackingContextZOrderLists();
 601     return true;
 602 }
 603 
<span class="line-modified"> 604 void RenderLayer::isStackingContextChanged()</span>
 605 {





 606     dirtyStackingContextZOrderLists();
<span class="line-modified"> 607     if (isStackingContext())</span>
 608         dirtyZOrderLists();
 609     else
 610         clearZOrderLists();
<span class="line-added"> 611 }</span>
 612 
<span class="line-added"> 613 bool RenderLayer::setIsOpportunisticStackingContext(bool isStacking)</span>
<span class="line-added"> 614 {</span>
<span class="line-added"> 615     bool wasStacking = isStackingContext();</span>
<span class="line-added"> 616     m_isOpportunisticStackingContext = isStacking;</span>
<span class="line-added"> 617     if (wasStacking == isStackingContext())</span>
<span class="line-added"> 618         return false;</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620     isStackingContextChanged();</span>
<span class="line-added"> 621     return true;</span>
<span class="line-added"> 622 }</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624 bool RenderLayer::setIsCSSStackingContext(bool isCSSStackingContext)</span>
<span class="line-added"> 625 {</span>
<span class="line-added"> 626     bool wasStacking = isStackingContext();</span>
<span class="line-added"> 627     m_isCSSStackingContext = isCSSStackingContext;</span>
<span class="line-added"> 628     if (wasStacking == isStackingContext())</span>
<span class="line-added"> 629         return false;</span>
<span class="line-added"> 630 </span>
<span class="line-added"> 631     isStackingContextChanged();</span>
 632     return true;
 633 }
 634 
 635 void RenderLayer::setParent(RenderLayer* parent)
 636 {
 637     if (parent == m_parent)
 638         return;
 639 
 640     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 641         compositor().layerWillBeRemoved(*m_parent, *this);
 642 
 643     m_parent = parent;
 644 
 645     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 646         compositor().layerWasAdded(*m_parent, *this);
 647 }
 648 
 649 RenderLayer* RenderLayer::stackingContext() const
 650 {
 651     auto* layer = parent();
</pre>
<hr />
<pre>
 684 
 685     if (m_normalFlowList)
 686         m_normalFlowList-&gt;clear();
 687     m_normalFlowListDirty = true;
 688 
 689     if (hasCompositingDescendant())
 690         setNeedsCompositingPaintOrderChildrenUpdate();
 691 }
 692 
 693 void RenderLayer::updateNormalFlowList()
 694 {
 695     if (!m_normalFlowListDirty)
 696         return;
 697 
 698     ASSERT(layerListMutationAllowed());
 699 
 700     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 701         // Ignore non-overflow layers and reflections.
 702         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 703             if (!m_normalFlowList)
<span class="line-modified"> 704                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 705             m_normalFlowList-&gt;append(child);
 706         }
 707     }
 708 
 709     m_normalFlowListDirty = false;
 710 }
 711 
 712 void RenderLayer::rebuildZOrderLists()
 713 {
 714     ASSERT(layerListMutationAllowed());
 715     ASSERT(isDirtyStackingContext());
 716     rebuildZOrderLists(m_posZOrderList, m_negZOrderList);
 717     m_zOrderListsDirty = false;
 718 
 719     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 720     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 721     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 722     // lists on dirtying so we don&#39;t know the old state.
 723     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 724         m_hadNegativeZOrderList = hasNegativeZOrderList;
</pre>
<hr />
<pre>
 740     };
 741 
 742     // Sort the two lists.
 743     if (posZOrderList)
 744         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 745 
 746     if (negZOrderList)
 747         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 748 }
 749 
 750 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList)
 751 {
 752     updateDescendantDependentFlags();
 753 
 754     bool isStacking = isStackingContext();
 755     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 756     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 757     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 758         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 759         if (!layerList)
<span class="line-modified"> 760             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();</span>
 761         layerList-&gt;append(this);
 762     }
 763 
 764     // Recur into our children to collect more layers, but only if we don&#39;t establish
 765     // a stacking context/container.
 766     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 767         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 768             // Ignore reflections.
 769             if (!isReflectionLayer(*child))
 770                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList);
 771         }
 772     }
 773 }
 774 
 775 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 776 {
 777     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 778         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 779             break;
 780         layer-&gt;m_compositingDirtyBits.add(flag);
</pre>
<hr />
<pre>
 858 
 859 bool RenderLayer::paintsWithFilters() const
 860 {
 861     if (!renderer().hasFilter())
 862         return false;
 863 
 864     if (!isComposited())
 865         return true;
 866 
 867     return !m_backing-&gt;canCompositeFilters();
 868 }
 869 
 870 bool RenderLayer::requiresFullLayerImageForFilters() const
 871 {
 872     if (!paintsWithFilters())
 873         return false;
 874 
 875     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 876 }
 877 
<span class="line-modified"> 878 OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; RenderLayer::flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer)</span>
<span class="line-added"> 879 {</span>
<span class="line-added"> 880     OptionSet&lt;UpdateLayerPositionsFlag&gt; flags = { CheckForRepaint };</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882     if (auto* parent = startingLayer.parent()) {</span>
<span class="line-added"> 883         if (parent-&gt;hasTransformedAncestor() || parent-&gt;transform())</span>
<span class="line-added"> 884             flags.add(SeenTransformedLayer);</span>
<span class="line-added"> 885 </span>
<span class="line-added"> 886         if (parent-&gt;has3DTransformedAncestor() || (parent-&gt;transform() &amp;&amp; !parent-&gt;transform()-&gt;isAffine()))</span>
<span class="line-added"> 887             flags.add(Seen3DTransformedLayer);</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889         if (parent-&gt;behavesAsFixed() || (parent-&gt;renderer().isFixedPositioned() &amp;&amp; !parent-&gt;hasTransformedAncestor()))</span>
<span class="line-added"> 890             flags.add(SeenFixedLayer);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         if (parent-&gt;hasCompositedScrollingAncestor() || parent-&gt;hasCompositedScrollableOverflow())</span>
<span class="line-added"> 893             flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added"> 894     }</span>
<span class="line-added"> 895 </span>
<span class="line-added"> 896     return flags;</span>
<span class="line-added"> 897 }</span>
<span class="line-added"> 898 </span>
<span class="line-added"> 899 void RenderLayer::updateLayerPositionsAfterStyleChange()</span>
 900 {
<span class="line-added"> 901     updateLayerPositions(nullptr, flagsForUpdateLayerPositions(*this));</span>
<span class="line-added"> 902 }</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904 void RenderLayer::updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint)</span>
<span class="line-added"> 905 {</span>
<span class="line-added"> 906     auto updateLayerPositionFlags = [&amp;](bool isRelayoutingSubtree, bool didFullRepaint) {</span>
<span class="line-added"> 907         auto flags = flagsForUpdateLayerPositions(*this);</span>
<span class="line-added"> 908         if (didFullRepaint) {</span>
<span class="line-added"> 909             flags.remove(RenderLayer::CheckForRepaint);</span>
<span class="line-added"> 910             flags.add(RenderLayer::NeedsFullRepaintInBacking);</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912         if (isRelayoutingSubtree &amp;&amp; enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))</span>
<span class="line-added"> 913             flags.add(RenderLayer::UpdatePagination);</span>
<span class="line-added"> 914         return flags;</span>
<span class="line-added"> 915     };</span>
<span class="line-added"> 916 </span>
 917     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 918     RenderGeometryMap geometryMap(UseTransforms);
<span class="line-modified"> 919     if (!isRenderViewLayer())</span>
 920         geometryMap.pushMappingsToAncestor(parent(), nullptr);
<span class="line-modified"> 921 </span>
<span class="line-added"> 922     updateLayerPositions(&amp;geometryMap, updateLayerPositionFlags(isRelayoutingSubtree, didFullRepaint));</span>
 923 }
 924 
 925 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 926 {
<span class="line-modified"> 927     updateLayerPosition(&amp;flags);</span>



 928     applyPostLayoutScrollPositionIfNeeded();
 929 
 930     if (geometryMap)
 931         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 932 
 933     // Clear our cached clip rect information.
 934     clearClipRects();
 935 
 936     if (hasOverflowControls()) {
 937         LayoutSize offsetFromRoot;
 938         if (geometryMap)
 939             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 940         else {
 941             // FIXME: It looks suspicious to call convertToLayerCoords here
<span class="line-modified"> 942             // as canUseOffsetFromAncestor may be true for an ancestor layer.</span>
 943             offsetFromRoot = offsetFromAncestor(root());
 944         }
 945         positionOverflowControls(roundedIntSize(offsetFromRoot));
 946     }
 947 
 948     updateDescendantDependentFlags();
 949 
 950     if (flags &amp; UpdatePagination)
 951         updatePagination();
 952     else
 953         m_enclosingPaginationLayer = nullptr;
 954 
 955     if (m_hasVisibleContent) {
 956         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 957         // mapping between them and the RenderObjects. It would be neat to enable
 958         // LayoutState outside the layout() phase and use it here.
 959         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 960 
 961         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 962 
</pre>
<hr />
<pre>
 971         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 972             if (!renderer().view().printing()) {
 973                 if (m_repaintStatus &amp; NeedsFullRepaint) {
 974                     if (hadRepaintLayoutRects)
 975                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
 976                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
 977                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
 978                 } else if (shouldRepaintAfterLayout()) {
 979                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
 980                     // we change other callers to use RepaintLayoutRects.
 981                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
 982                 }
 983             }
 984         }
 985     } else
 986         clearRepaintRects();
 987 
 988     m_repaintStatus = NeedsNormalRepaint;
 989     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
 990     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
<span class="line-added"> 991     m_behavesAsFixed = flags.contains(SeenFixedLayer);</span>
<span class="line-added"> 992     setHasCompositedScrollingAncestor(flags.contains(SeenCompositedScrollingLayer));</span>
 993 
 994     // Update the reflection&#39;s position and size.
 995     if (m_reflection)
 996         m_reflection-&gt;layout();
 997 
 998     if (renderer().isInFlowRenderFragmentedFlow()) {
 999         updatePagination();
1000         flags.add(UpdatePagination);
1001     }
1002 
1003     if (transform()) {
1004         flags.add(SeenTransformedLayer);
1005         if (!transform()-&gt;isAffine())
1006             flags.add(Seen3DTransformedLayer);
1007     }
1008 
<span class="line-added">1009     // Fixed inside transform behaves like absolute (per spec).</span>
<span class="line-added">1010     if (renderer().isFixedPositioned() &amp;&amp; !m_hasTransformedAncestor) {</span>
<span class="line-added">1011         m_behavesAsFixed = true;</span>
<span class="line-added">1012         flags.add(SeenFixedLayer);</span>
<span class="line-added">1013     }</span>
<span class="line-added">1014 </span>
<span class="line-added">1015     if (hasCompositedScrollableOverflow())</span>
<span class="line-added">1016         flags.add(SeenCompositedScrollingLayer);</span>
<span class="line-added">1017 </span>
1018     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1019         child-&gt;updateLayerPositions(geometryMap, flags);
1020 
1021     // With all our children positioned, now update our marquee if we need to.
1022     if (m_marquee) {
1023         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
1024         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1025         m_updatingMarqueePosition = true;
1026         m_marquee-&gt;updateMarqueePosition();
1027         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1028     }
1029 
<span class="line-modified">1030     if (renderer().isFixedPositioned() &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {</span>
1031         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
1032         if (intersectsViewport != m_isFixedIntersectingViewport) {
1033             m_isFixedIntersectingViewport = intersectsViewport;
1034             setNeedsPostLayoutCompositingUpdate();
1035         }
1036     }
1037 
1038     if (isComposited())
<span class="line-modified">1039         backing()-&gt;updateAfterLayout(flags.contains(ContainingClippingLayerChangedSize), flags.contains(NeedsFullRepaintInBacking));</span>
1040 
1041     if (geometryMap)
1042         geometryMap-&gt;popMappingsToAncestor(parent());
1043 
1044     renderer().document().markers().invalidateRectsForAllMarkers();
1045 }
1046 
1047 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
1048 {
1049     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
1050     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1051         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
1052         if (child-&gt;isComposited())
1053             continue;
1054 
1055         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
1056     }
1057     return repaintRect;
1058 }
1059 
</pre>
<hr />
<pre>
1191     renderer().document().markers().invalidateRectsForAllMarkers();
1192 }
1193 
1194 #if ENABLE(CSS_COMPOSITING)
1195 
1196 void RenderLayer::updateBlendMode()
1197 {
1198     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1199     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1200         if (hasBlendMode())
1201             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1202         else
1203             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1204     }
1205 
1206     BlendMode newBlendMode = renderer().style().blendMode();
1207     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1208         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1209 }
1210 
<span class="line-added">1211 void RenderLayer::willRemoveChildWithBlendMode()</span>
<span class="line-added">1212 {</span>
<span class="line-added">1213     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();</span>
<span class="line-added">1214 }</span>
<span class="line-added">1215 </span>
1216 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1217 {
1218     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1219         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1220             break;
1221         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1222         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1223 
1224         layer-&gt;updateSelfPaintingLayer();
1225 
<span class="line-modified">1226         if (layer-&gt;isCSSStackingContext())</span>
1227             break;
1228     }
1229 }
1230 
1231 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1232 {
1233     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1234         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1235             break;
1236 
1237         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1238 
<span class="line-modified">1239         if (layer-&gt;isCSSStackingContext())</span>
1240             break;
1241     }
1242 }
1243 #endif
1244 
1245 void RenderLayer::updateTransform()
1246 {
1247     bool hasTransform = renderer().hasTransform();
1248     bool had3DTransform = has3DTransform();
1249 
1250     bool hadTransform = !!m_transform;
1251     if (hasTransform != hadTransform) {
1252         if (hasTransform)
<span class="line-modified">1253             m_transform = makeUnique&lt;TransformationMatrix&gt;();</span>
1254         else
1255             m_transform = nullptr;
1256 
1257         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1258         clearClipRectsIncludingDescendants();
1259     }
1260 
1261     if (hasTransform) {
1262         RenderBox* box = renderBox();
1263         ASSERT(box);
1264         m_transform-&gt;makeIdentity();
1265         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1266         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1267     }
1268 
1269     if (had3DTransform != has3DTransform()) {
1270         dirty3DTransformedDescendantStatus();
1271         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1272         setNeedsPostLayoutCompositingUpdateOnAncestors();
1273     }
</pre>
<hr />
<pre>
1570         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1571         // in the normal flow list, so we only need to check those.
1572         for (auto* layer : positiveZOrderLayers())
1573             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1574 
1575         // Now check our negative z-index children.
1576         for (auto* layer : negativeZOrderLayers())
1577             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1578 
1579         m_3DTransformedDescendantStatusDirty = false;
1580     }
1581 
1582     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1583     // the m_has3DTransformedDescendant set.
1584     if (preserves3D())
1585         return has3DTransform() || m_has3DTransformedDescendant;
1586 
1587     return has3DTransform();
1588 }
1589 
<span class="line-modified">1590 bool RenderLayer::updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* flags)</span>
1591 {
1592     LayoutPoint localPoint;
1593     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1594     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1595         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1596         IntRect lineBox = inlineFlow.linesBoundingBox();
1597         setSize(lineBox.size());
1598         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1599         localPoint += inlineBoundingBoxOffset;
1600     } else if (RenderBox* box = renderBox()) {
1601         // FIXME: Is snapping the size really needed here for the RenderBox case?
1602         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1603         if (newSize != size()) {
1604             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1605                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1606                 setNeedsPostLayoutCompositingUpdate();
1607             }
<span class="line-added">1608 </span>
<span class="line-added">1609             if (flags &amp;&amp; renderer().hasOverflowClip())</span>
<span class="line-added">1610                 flags-&gt;add(ContainingClippingLayerChangedSize);</span>
<span class="line-added">1611 </span>
1612             setSize(newSize);
1613         }
1614 
1615         box-&gt;applyTopLeftLocationOffset(localPoint);
1616     }
1617 
1618     if (!renderer().isOutOfFlowPositioned()) {
1619         auto* ancestor = renderer().parent();
1620         // We must adjust our position by walking up the render tree looking for the
1621         // nearest enclosing object with a layer.
1622         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1623             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1624                 // Rows and cells share the same coordinate space (that of the section).
1625                 // Omit them when computing our xpos/ypos.
1626                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1627             }
1628             ancestor = ancestor-&gt;parent();
1629         }
1630         if (is&lt;RenderTableRow&gt;(ancestor)) {
1631             // Put ourselves into the row coordinate space.
</pre>
<hr />
<pre>
1718 
1719     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1720                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1721 }
1722 
1723 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1724 {
1725     switch (position) {
1726     case PositionType::Fixed:
1727         return layer.renderer().canContainFixedPositionObjects();
1728 
1729     case PositionType::Absolute:
1730         return layer.renderer().canContainAbsolutelyPositionedObjects();
1731 
1732     default:
1733         ASSERT_NOT_REACHED();
1734         return false;
1735     }
1736 }
1737 
<span class="line-added">1738 bool RenderLayer::ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit) const</span>
<span class="line-added">1739 {</span>
<span class="line-added">1740     if (&amp;ancestor == this)</span>
<span class="line-added">1741         return true;</span>
<span class="line-added">1742 </span>
<span class="line-added">1743     for (const auto* currentBlock = renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {</span>
<span class="line-added">1744         auto* currLayer = currentBlock-&gt;layer();</span>
<span class="line-added">1745         if (currLayer == &amp;ancestor)</span>
<span class="line-added">1746             return true;</span>
<span class="line-added">1747 </span>
<span class="line-added">1748         if (currLayer &amp;&amp; currLayer == checkLimit)</span>
<span class="line-added">1749             return false;</span>
<span class="line-added">1750     }</span>
<span class="line-added">1751 </span>
<span class="line-added">1752     return false;</span>
<span class="line-added">1753 }</span>
<span class="line-added">1754 </span>
1755 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1756 {
1757     RenderLayer* curr = parent();
1758     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1759         curr = curr-&gt;parent();
1760 
1761     return curr;
1762 }
1763 
<span class="line-modified">1764 static RenderLayer* enclosingFrameRenderLayer(const RenderLayer&amp; layer)</span>
1765 {
<span class="line-modified">1766     auto* ownerElement = layer.renderer().document().ownerElement();</span>



1767     if (!ownerElement)
1768         return nullptr;
1769 
<span class="line-modified">1770     auto* ownerRenderer = ownerElement-&gt;renderer();</span>
1771     if (!ownerRenderer)
1772         return nullptr;
1773 
1774     return ownerRenderer-&gt;enclosingLayer();
1775 }
1776 
<span class="line-added">1777 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)</span>
<span class="line-added">1778 {</span>
<span class="line-added">1779     if (auto* parent = layer.parent())</span>
<span class="line-added">1780         return parent;</span>
<span class="line-added">1781 </span>
<span class="line-added">1782     return enclosingFrameRenderLayer(layer);</span>
<span class="line-added">1783 }</span>
<span class="line-added">1784 </span>
1785 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1786 {
1787     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1788         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1789             return nextLayer;
1790     }
1791 
1792     return nullptr;
1793 }
1794 
1795 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1796 {
1797     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1798 }
1799 
1800 bool RenderLayer::isRubberBandInProgress() const
1801 {
1802 #if ENABLE(RUBBER_BANDING)
1803     if (!scrollsOverflow())
1804         return false;
</pre>
<hr />
<pre>
1818 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1819 {
1820     RenderLayer* curr = parent();
1821     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1822         curr = curr-&gt;parent();
1823 
1824     return curr;
1825 }
1826 
1827 inline bool RenderLayer::shouldRepaintAfterLayout() const
1828 {
1829     if (m_repaintStatus == NeedsNormalRepaint)
1830         return true;
1831 
1832     // Composited layers that were moved during a positioned movement only
1833     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1834     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1835     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1836 }
1837 
<span class="line-added">1838 void RenderLayer::setBackingProviderLayer(RenderLayer* backingProvider)</span>
<span class="line-added">1839 {</span>
<span class="line-added">1840     if (backingProvider == m_backingProviderLayer)</span>
<span class="line-added">1841         return;</span>
<span class="line-added">1842 </span>
<span class="line-added">1843     if (!renderer().renderTreeBeingDestroyed())</span>
<span class="line-added">1844         clearClipRectsIncludingDescendants();</span>
<span class="line-added">1845 </span>
<span class="line-added">1846     m_backingProviderLayer = makeWeakPtr(backingProvider);</span>
<span class="line-added">1847 }</span>
<span class="line-added">1848 </span>
<span class="line-added">1849 void RenderLayer::disconnectFromBackingProviderLayer()</span>
<span class="line-added">1850 {</span>
<span class="line-added">1851     if (!m_backingProviderLayer)</span>
<span class="line-added">1852         return;</span>
<span class="line-added">1853 </span>
<span class="line-added">1854     ASSERT(m_backingProviderLayer-&gt;isComposited());</span>
<span class="line-added">1855     if (m_backingProviderLayer-&gt;isComposited())</span>
<span class="line-added">1856         m_backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);</span>
<span class="line-added">1857 }</span>
<span class="line-added">1858 </span>
1859 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1860 {
1861     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1862 }
1863 
1864 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1865 {
1866     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1867         return const_cast&lt;RenderLayer*&gt;(this);
1868 
1869     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1870         if (curr-&gt;isComposited())
1871             return const_cast&lt;RenderLayer*&gt;(curr);
1872     }
1873 
1874     return nullptr;
1875 }
1876 
1877 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1878 {
<span class="line-modified">1879     auto repaintTargetForLayer = [](const RenderLayer&amp; layer) -&gt; RenderLayer* {</span>
<span class="line-modified">1880         if (compositedWithOwnBackingStore(layer))</span>
<span class="line-added">1881             return const_cast&lt;RenderLayer*&gt;(&amp;layer);</span>
<span class="line-added">1882 </span>
<span class="line-added">1883         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">1884             return layer.backingProviderLayer();</span>
<span class="line-added">1885 </span>
<span class="line-added">1886         return nullptr;</span>
<span class="line-added">1887     };</span>
<span class="line-added">1888 </span>
<span class="line-added">1889     RenderLayer* repaintTarget = nullptr;</span>
<span class="line-added">1890     if (includeSelf == IncludeSelf &amp;&amp; (repaintTarget = repaintTargetForLayer(*this)))</span>
<span class="line-added">1891         return repaintTarget;</span>
1892 
1893     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
<span class="line-modified">1894         if ((repaintTarget = repaintTargetForLayer(*curr)))</span>
<span class="line-modified">1895             return repaintTarget;</span>
1896     }
1897 
1898     return nullptr;
1899 }
1900 
1901 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1902 {
1903     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1904     for (; curr; curr = curr-&gt;parent()) {
1905         if (curr-&gt;requiresFullLayerImageForFilters())
1906             return const_cast&lt;RenderLayer*&gt;(curr);
1907     }
1908 
1909     return nullptr;
1910 }
1911 
1912 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
1913 {
1914     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1915         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
</pre>
<hr />
<pre>
1957         return;
1958     }
1959 
1960     ASSERT_NOT_REACHED();
1961 }
1962 
1963 bool RenderLayer::hasAncestorWithFilterOutsets() const
1964 {
1965     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
1966         if (curr-&gt;renderer().style().hasFilterOutsets())
1967             return true;
1968     }
1969     return false;
1970 }
1971 
1972 RenderLayer* RenderLayer::clippingRootForPainting() const
1973 {
1974     if (isComposited())
1975         return const_cast&lt;RenderLayer*&gt;(this);
1976 
<span class="line-added">1977     if (paintsIntoProvidedBacking())</span>
<span class="line-added">1978         return backingProviderLayer();</span>
<span class="line-added">1979 </span>
1980     const RenderLayer* current = this;
1981     while (current) {
1982         if (current-&gt;isRenderViewLayer())
1983             return const_cast&lt;RenderLayer*&gt;(current);
1984 
1985         current = current-&gt;paintOrderParent();
1986         ASSERT(current);
1987         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
1988             return const_cast&lt;RenderLayer*&gt;(current);
<span class="line-added">1989 </span>
<span class="line-added">1990         if (current-&gt;paintsIntoProvidedBacking())</span>
<span class="line-added">1991             return current-&gt;backingProviderLayer();</span>
1992     }
1993 
1994     ASSERT_NOT_REACHED();
1995     return nullptr;
1996 }
1997 
1998 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
1999 {
2000     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
2001     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
2002 }
2003 
2004 bool RenderLayer::cannotBlitToWindow() const
2005 {
2006     if (isTransparent() || hasReflection() || hasTransform())
2007         return true;
2008     if (!parent())
2009         return false;
2010     return parent()-&gt;cannotBlitToWindow();
2011 }
</pre>
<hr />
<pre>
2105     layer.renderer().style().filterOutsets().expandRect(clipRect);
2106 
2107     return clipRect;
2108 }
2109 
2110 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2111 {
2112     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2113 }
2114 
2115 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2116 {
2117     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2118         return;
2119 
2120     RenderLayer* ancestor = transparentPaintingAncestor();
2121     if (ancestor)
2122         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2123 
2124     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
<span class="line-modified">2125         ASSERT(isCSSStackingContext());</span>
2126         m_usedTransparency = true;
2127         context.save();
2128         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
2129         adjustedClipRect.move(paintingInfo.subpixelOffset);
2130         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
2131         context.clip(pixelSnappedClipRect);
2132 
2133 #if ENABLE(CSS_COMPOSITING)
2134         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
2135         if (usesCompositeOperation)
2136             context.setCompositeOperation(context.compositeOperation(), blendMode());
2137 #endif
2138 
2139         context.beginTransparencyLayer(renderer().opacity());
2140 
2141 #if ENABLE(CSS_COMPOSITING)
2142         if (usesCompositeOperation)
2143             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
2144 #endif
2145 
</pre>
<hr />
<pre>
2304 
2305 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2306 {
2307     if (ancestorLayer == this)
2308         return location;
2309 
2310     const RenderLayer* currLayer = this;
2311     LayoutPoint locationInLayerCoords = location;
2312     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2313         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2314     return locationInLayerCoords;
2315 }
2316 
2317 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2318 {
2319     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2320 }
2321 
2322 bool RenderLayer::canUseCompositedScrolling() const
2323 {
<span class="line-added">2324     bool isVisible = renderer().style().visibility() == Visibility::Visible;</span>
2325     if (renderer().settings().asyncOverflowScrollingEnabled())
<span class="line-modified">2326         return isVisible &amp;&amp; scrollsOverflow();</span>
2327 
<span class="line-modified">2328 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
<span class="line-modified">2329     return isVisible &amp;&amp; scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());</span>
2330 #else
2331     return false;
2332 #endif
2333 }
2334 





2335 #if ENABLE(IOS_TOUCH_EVENTS)
2336 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2337 {
2338     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2339     if (hasCompositedScrollableOverflow())
2340         return false;
2341 
2342     return ScrollableArea::handleTouchEvent(touchEvent);
2343 }
2344 
2345 void RenderLayer::registerAsTouchEventListenerForScrolling()
2346 {
2347     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2348         return;
2349 
2350     renderer().document().addTouchEventHandler(*renderer().element());
2351     m_registeredAsTouchEventListenerForScrolling = true;
2352 }
2353 
2354 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
</pre>
<hr />
<pre>
2447 
2448         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2449         // https://bugs.webkit.org/show_bug.cgi?id=28237
2450     }
2451 }
2452 
2453 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2454 {
2455     m_postLayoutScrollPosition = position;
2456 }
2457 
2458 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2459 {
2460     if (!m_postLayoutScrollPosition)
2461         return;
2462 
2463     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2464     m_postLayoutScrollPosition = WTF::nullopt;
2465 }
2466 
<span class="line-modified">2467 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)</span>
2468 {
2469     ScrollPosition position(x, m_scrollPosition.y());
<span class="line-modified">2470     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
2471 }
2472 
<span class="line-modified">2473 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)</span>
2474 {
2475     ScrollPosition position(m_scrollPosition.x(), y);
<span class="line-modified">2476     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);</span>
2477 }
2478 
2479 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2480 {
2481     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2482 }
2483 
<span class="line-modified">2484 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)</span>
2485 {
<span class="line-modified">2486     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;</span>
<span class="line-modified">2487     if (clampedScrollOffset == this-&gt;scrollOffset())</span>
<span class="line-modified">2488         return;</span>
<span class="line-added">2489 </span>
<span class="line-added">2490     auto previousScrollType = currentScrollType();</span>
<span class="line-added">2491     setCurrentScrollType(scrollType);</span>
<span class="line-added">2492 </span>
<span class="line-added">2493     bool handled = false;</span>
<span class="line-added">2494 #if ENABLE(ASYNC_SCROLLING)</span>
<span class="line-added">2495     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())</span>
<span class="line-added">2496         handled = scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, scrollPositionFromOffset(clampedScrollOffset));</span>
<span class="line-added">2497 #endif</span>
<span class="line-added">2498 </span>
<span class="line-added">2499     if (!handled)</span>
<span class="line-added">2500         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);</span>
<span class="line-added">2501 </span>
<span class="line-added">2502     setCurrentScrollType(previousScrollType);</span>
2503 }
2504 
2505 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2506 {
2507     RenderBox* box = renderBox();
2508     if (!box)
2509         return;
2510 
<span class="line-modified">2511     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);</span>
2512 
2513     ScrollPosition newPosition = position;
2514     if (!box-&gt;isHTMLMarquee()) {
2515         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2516         if (m_scrollDimensionsDirty)
2517             computeScrollDimensions();
2518 #if PLATFORM(IOS_FAMILY)
2519         if (adjustForIOSCaretWhenScrolling()) {
2520             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2521             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2522             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2523             int scrollXOffset = newOffset.x();
2524             if (scrollXOffset &gt; maxOffset - caretWidth) {
2525                 scrollXOffset += caretWidth;
2526                 if (scrollXOffset &lt;= caretWidth)
2527                     scrollXOffset = 0;
2528             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2529                 scrollXOffset -= caretWidth;
2530 
2531             newOffset.setX(scrollXOffset);
</pre>
<hr />
<pre>
2546 
2547     m_scrollPosition = newPosition;
2548 
2549     RenderView&amp; view = renderer().view();
2550 
2551     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2552     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2553     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2554         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2555         updateLayerPositionsAfterOverflowScroll();
2556 
2557         view.frameView().scheduleUpdateWidgetPositions();
2558 
2559         if (!m_updatingMarqueePosition) {
2560             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2561             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2562             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2563             // when that completes.
2564             if (usesCompositedScrolling()) {
2565                 setNeedsCompositingGeometryUpdate();
<span class="line-modified">2566 </span>
<span class="line-added">2567                 // Scroll position can affect the location of a composited descendant (which may be a sibling in z-order),</span>
<span class="line-added">2568                 // so trigger a descendant walk from the paint-order parent.</span>
<span class="line-added">2569                 if (auto* paintParent = paintOrderParent())</span>
<span class="line-added">2570                     paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();</span>
2571             }
2572 
2573             updateCompositingLayersAfterScroll();
2574         }
2575 
2576         // Update regions, scrolling may change the clip of a particular region.
<span class="line-modified">2577         renderer().document().invalidateRenderingDependentRegions();</span>
2578         DebugPageOverlays::didLayout(renderer().frame());
2579     }
2580 
2581     Frame&amp; frame = renderer().frame();
2582     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2583     // The caret rect needs to be invalidated after scrolling
2584     frame.selection().setCaretRectNeedsUpdate();
2585 
2586     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2587 
2588     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2589     if (repaintContainer)
2590         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2591     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2592 
2593     bool requiresRepaint = true;
2594     if (usesCompositedScrolling()) {
2595         setNeedsCompositingGeometryUpdate();
2596         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2597         requiresRepaint = false;
</pre>
<hr />
<pre>
2652 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2653 {
2654     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2655 
2656     RenderLayer* parentLayer = nullptr;
2657     LayoutRect newRect = absoluteRect;
2658 
2659     // We may end up propagating a scroll event. It is important that we suspend events until
2660     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2661     FrameView&amp; frameView = renderer().view().frameView();
2662 
2663     if (renderer().parent())
2664         parentLayer = renderer().parent()-&gt;enclosingLayer();
2665 
2666     if (allowsCurrentScroll()) {
2667         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2668         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2669         RenderBox* box = renderBox();
2670         ASSERT(box);
2671         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
<span class="line-added">2672         if (shouldPlaceBlockDirectionScrollbarOnLeft()) {</span>
<span class="line-added">2673             // For direction: rtl; writing-mode: horizontal-tb box, the scroll bar is on the left side. The visible rect</span>
<span class="line-added">2674             // starts from the right side of scroll bar. So the x of localExposeRect should start from the same position too.</span>
<span class="line-added">2675             localExposeRect.moveBy(LayoutPoint(-verticalScrollbarWidth(), 0));</span>
<span class="line-added">2676         }</span>
2677         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2678         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2679 
2680         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2681         if (clampedScrollOffset != scrollOffset()) {
2682             ScrollOffset oldScrollOffset = scrollOffset();
2683             scrollToOffset(clampedScrollOffset);
2684             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2685             localExposeRect.move(-scrollOffsetDifference);
2686             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2687         }
2688     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2689         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2690 
2691         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2692             HTMLFrameElementBase* frameElementBase = nullptr;
2693 
2694             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2695                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2696 
</pre>
<hr />
<pre>
2701                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2702                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2703 
2704                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2705                 // Adjust offsets if they&#39;re outside of the allowable range.
2706                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2707                 frameView.setScrollPosition(scrollOffset);
2708 
2709                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2710                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2711                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2712                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2713                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2714                 } else
2715                     parentLayer = nullptr;
2716             }
2717         } else {
2718             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2719                 return;
2720 
<span class="line-added">2721             auto minScrollPosition = frameView.minimumScrollPosition();</span>
<span class="line-added">2722             auto maxScrollPosition = frameView.maximumScrollPosition();</span>
<span class="line-added">2723 </span>
2724 #if !PLATFORM(IOS_FAMILY)
2725             LayoutRect viewRect = frameView.visibleContentRect();
2726 #else
<span class="line-modified">2727             // FIXME: ContentInsets should be taken care of in UI process side. webkit.org/b/199682</span>
<span class="line-added">2728             // To do that, getRectToExpose needs to return the additional scrolling to do beyond content rect.</span>
<span class="line-added">2729             LayoutRect viewRect = frameView.viewRectExpandedByContentInsets();</span>
<span class="line-added">2730 </span>
<span class="line-added">2731             // FIXME: webkit.org/b/199683 FrameView::visibleContentRect is wrong when content insets are present</span>
<span class="line-added">2732             maxScrollPosition = frameView.scrollPositionFromOffset(ScrollPosition(frameView.totalContentsSize() - flooredIntSize(viewRect.size())));</span>
<span class="line-added">2733 </span>
<span class="line-added">2734             auto contentInsets = page().contentInsets();</span>
<span class="line-added">2735             minScrollPosition.move(-contentInsets.left(), -contentInsets.top());</span>
<span class="line-added">2736             maxScrollPosition.move(contentInsets.right(), contentInsets.bottom());</span>
2737 #endif
2738             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2739             LayoutRect targetRect = absoluteRect;
2740             targetRect.move(0, frameView.headerHeight());
2741 
2742             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
<span class="line-modified">2743             // Avoid scrolling to the rounded value of revealRect.location() if we don&#39;t actually need to scroll</span>
<span class="line-modified">2744             if (revealRect != viewRect) {</span>
<span class="line-added">2745                 ScrollOffset clampedScrollPosition = roundedIntPoint(revealRect.location()).constrainedBetween(minScrollPosition, maxScrollPosition);</span>
<span class="line-added">2746                 frameView.setScrollPosition(clampedScrollPosition);</span>
<span class="line-added">2747             }</span>
2748 
2749             // This is the outermost view of a web page, so after scrolling this view we
2750             // scroll its container by calling Page::scrollRectIntoView.
2751             // This only has an effect on the Mac platform in applications
2752             // that put web views into scrolling containers, such as Mac OS X Mail.
2753             // The canAutoscroll function in EventHandler also knows about this.
2754             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2755         }
2756     }
2757 
2758     if (parentLayer)
2759         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2760 }
2761 
2762 void RenderLayer::updateCompositingLayersAfterScroll()
2763 {
2764     if (compositor().hasContentCompositingLayers()) {
2765         // Our stacking container is guaranteed to contain all of our descendants that may need
2766         // repositioning, so update compositing layers from there.
2767         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
</pre>
<hr />
<pre>
2940         baseWidth = baseWidth / zoomFactor;
2941         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSPrimitiveValue::CSS_PX);
2942     }
2943 
2944     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
2945         if (is&lt;HTMLFormControlElement&gt;(*element)) {
2946             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
2947             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2948             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSPrimitiveValue::CSS_PX);
2949         }
2950         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
2951         baseHeight = baseHeight / zoomFactor;
2952         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSPrimitiveValue::CSS_PX);
2953     }
2954 
2955     document.updateLayout();
2956 
2957     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
2958 }
2959 






2960 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
2961 {
2962     scrollTo(scrollPositionFromOffset(offset));
2963 }
2964 
<span class="line-modified">2965 ScrollingNodeID RenderLayer::scrollingNodeID() const</span>
2966 {
<span class="line-modified">2967     if (!isComposited())</span>
<span class="line-modified">2968         return 0;</span>



2969 
<span class="line-modified">2970     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);</span>
2971 }
2972 
2973 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
2974 {
2975     IntSize scrollbarSpace;
2976     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
2977         scrollbarSpace = scrollbarIntrusion();
2978 
2979     auto visibleSize = this-&gt;visibleSize();
2980     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
2981 }
2982 
2983 IntSize RenderLayer::overhangAmount() const
2984 {
2985 #if ENABLE(RUBBER_BANDING)
2986     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
2987         return IntSize();
2988 
2989     IntSize stretch;
2990 
2991     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
2992     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
<span class="line-added">2993     auto reachableSize = reachableTotalContentsSize();</span>
2994     if (scrollOffset.y() &lt; 0)
2995         stretch.setHeight(scrollOffset.y());
<span class="line-modified">2996     else if (reachableSize.height() &amp;&amp; scrollOffset.y() &gt; reachableSize.height() - visibleHeight())</span>
<span class="line-modified">2997         stretch.setHeight(scrollOffset.y() - (reachableSize.height() - visibleHeight()));</span>
2998 
2999     if (scrollOffset.x() &lt; 0)
3000         stretch.setWidth(scrollOffset.x());
<span class="line-modified">3001     else if (reachableSize.width() &amp;&amp; scrollOffset.x() &gt; reachableSize.width() - visibleWidth())</span>
<span class="line-modified">3002         stretch.setWidth(scrollOffset.x() - (reachableSize.width() - visibleWidth()));</span>
3003 
3004     return stretch;
3005 #else
3006     return IntSize();
3007 #endif
3008 }
3009 
3010 bool RenderLayer::isActive() const
3011 {
3012     return page().focusController().isActive();
3013 }
3014 
3015 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
3016 {
3017     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
3018         return minX + layer.renderer().style().borderLeftWidth();
3019     return maxX - thickness - layer.renderer().style().borderRightWidth();
3020 }
3021 
3022 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
</pre>
<hr />
<pre>
3109 {
3110     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
3111     point.move(-scrollbarOffset(scrollbar));
3112     return point;
3113 }
3114 
3115 IntSize RenderLayer::visibleSize() const
3116 {
3117     RenderBox* box = renderBox();
3118     if (!box)
3119         return IntSize();
3120 
3121     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
3122 }
3123 
3124 IntSize RenderLayer::contentsSize() const
3125 {
3126     return IntSize(scrollWidth(), scrollHeight());
3127 }
3128 
<span class="line-modified">3129 IntSize RenderLayer::reachableTotalContentsSize() const</span>
3130 {
3131     IntSize contentsSize = this-&gt;contentsSize();
3132 
3133     if (!hasScrollableHorizontalOverflow())
3134         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
3135 
3136     if (!hasScrollableVerticalOverflow())
3137         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
3138 
3139     return contentsSize;
3140 }
3141 
3142 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
3143 {
3144     ScrollableArea::availableContentSizeChanged(reason);
3145 
3146     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
3147         if (is&lt;RenderBlock&gt;(renderer()))
3148             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
3149         renderer().setNeedsLayout();
</pre>
<hr />
<pre>
3274     renderBox()-&gt;flipForWritingMode(repaintRect);
3275     renderer().repaintRectangle(repaintRect);
3276 }
3277 
3278 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3279 {
3280     if (!showsOverflowControls())
3281         return;
3282 
3283     if (GraphicsLayer* layer = layerForScrollCorner()) {
3284         layer-&gt;setNeedsDisplayInRect(rect);
3285         return;
3286     }
3287 
3288     if (m_scrollCorner)
3289         m_scrollCorner-&gt;repaintRectangle(rect);
3290     if (m_resizer)
3291         m_resizer-&gt;repaintRectangle(rect);
3292 }
3293 
<span class="line-added">3294 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)</span>
<span class="line-added">3295 {</span>
<span class="line-added">3296     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())</span>
<span class="line-added">3297         return false;</span>
<span class="line-added">3298 </span>
<span class="line-added">3299     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);</span>
<span class="line-added">3300 </span>
<span class="line-added">3301     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">3302 }</span>
<span class="line-added">3303 </span>
<span class="line-added">3304 bool RenderLayer::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">3305 {</span>
<span class="line-added">3306     return scrollbarHiddenByStyle(horizontalScrollbar());</span>
<span class="line-added">3307 }</span>
<span class="line-added">3308 </span>
<span class="line-added">3309 bool RenderLayer::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">3310 {</span>
<span class="line-added">3311     return scrollbarHiddenByStyle(verticalScrollbar());</span>
<span class="line-added">3312 }</span>
<span class="line-added">3313 </span>
3314 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3315 {
3316     if (Element* element = renderer.element()) {
3317         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3318             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3319                 return shadowRoot-&gt;host()-&gt;renderer();
3320         }
3321     }
3322 
3323     return &amp;renderer;
3324 }
3325 
3326 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3327 {
3328     RefPtr&lt;Scrollbar&gt; widget;
3329     ASSERT(rendererForScrollbar(renderer()));
3330     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3331     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3332     if (hasCustomScrollbarStyle)
3333         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
</pre>
<hr />
<pre>
3368         return;
3369 
3370     if (hasScrollbar) {
3371         m_hBar = createScrollbar(HorizontalScrollbar);
3372 #if ENABLE(RUBBER_BANDING)
3373         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3374         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3375 #endif
3376     } else {
3377         destroyScrollbar(HorizontalScrollbar);
3378 #if ENABLE(RUBBER_BANDING)
3379         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3380 #endif
3381     }
3382 
3383     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3384     if (m_hBar)
3385         m_hBar-&gt;styleChanged();
3386     if (m_vBar)
3387         m_vBar-&gt;styleChanged();


3388 }
3389 
3390 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3391 {
3392     if (hasScrollbar == hasVerticalScrollbar())
3393         return;
3394 
3395     if (hasScrollbar) {
3396         m_vBar = createScrollbar(VerticalScrollbar);
3397 #if ENABLE(RUBBER_BANDING)
3398         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3399         ScrollableArea::setVerticalScrollElasticity(elasticity);
3400 #endif
3401     } else {
3402         destroyScrollbar(VerticalScrollbar);
3403 #if ENABLE(RUBBER_BANDING)
3404         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3405 #endif
3406     }
3407 
3408      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3409     if (m_hBar)
3410         m_hBar-&gt;styleChanged();
3411     if (m_vBar)
3412         m_vBar-&gt;styleChanged();


3413 }
3414 
3415 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3416 {
3417     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3418         return scrollableLayer;
3419 
3420     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3421     // if the frame view isn&#39;t scrollable.
3422     return nullptr;
3423 }
3424 
3425 bool RenderLayer::isScrollableOrRubberbandable()
3426 {
3427     return renderer().isScrollableOrRubberbandableBox();
3428 }
3429 
3430 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3431 {
3432     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
</pre>
<hr />
<pre>
3593     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3594     box-&gt;flipForWritingMode(overflowRect);
3595     return overflowRect.maxX();
3596 }
3597 
3598 void RenderLayer::computeScrollDimensions()
3599 {
3600     RenderBox* box = renderBox();
3601     ASSERT(box);
3602 
3603     m_scrollDimensionsDirty = false;
3604 
3605     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3606     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3607 
3608     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3609     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3610         scrollableLeftOverflow -= verticalScrollbarWidth();
3611     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3612     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
<span class="line-added">3613 </span>
<span class="line-added">3614     m_hasCompositedScrollableOverflow = canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());</span>
3615 }
3616 
3617 bool RenderLayer::hasScrollableHorizontalOverflow() const
3618 {
3619     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3620 }
3621 
3622 bool RenderLayer::hasScrollableVerticalOverflow() const
3623 {
3624     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3625 }
3626 
3627 bool RenderLayer::hasHorizontalOverflow() const
3628 {
3629     ASSERT(!m_scrollDimensionsDirty);
3630 
3631     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3632 }
3633 
3634 bool RenderLayer::hasVerticalOverflow() const
</pre>
<hr />
<pre>
3665     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3666 
3667     // If overflow requires a scrollbar, then we just need to enable or disable.
3668     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3669         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3670     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3671         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3672 
3673     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3674     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3675     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3676 
3677     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3678         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3679             setHasHorizontalScrollbar(hasHorizontalOverflow);
3680         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3681             setHasVerticalScrollbar(hasVerticalOverflow);
3682 
3683         updateSelfPaintingLayer();
3684 

3685         renderer().repaint();
3686 
3687         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3688             if (!m_inOverflowRelayout) {
3689                 m_inOverflowRelayout = true;
3690                 renderer().setNeedsLayout(MarkOnlyThis);
3691                 if (is&lt;RenderBlock&gt;(renderer())) {
3692                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3693                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3694                     block.layoutBlock(true);
3695                 } else
3696                     renderer().layout();
3697                 m_inOverflowRelayout = false;
3698             }
3699         }
3700 
3701         RenderObject* parent = renderer().parent();
3702         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3703             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3704     }
</pre>
<hr />
<pre>
3749         setAdjustForIOSCaretWhenScrolling(true);
3750 #endif
3751         if (clampedScrollOffset != scrollOffset())
3752             scrollToOffset(clampedScrollOffset);
3753 
3754 #if PLATFORM(IOS_FAMILY)
3755         setAdjustForIOSCaretWhenScrolling(false);
3756 #endif
3757     }
3758 
3759     updateScrollbarsAfterLayout();
3760 
3761     if (originalScrollOffset != scrollOffset())
3762         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3763 
3764     if (isComposited()) {
3765         setNeedsCompositingGeometryUpdate();
3766         setNeedsCompositingConfigurationUpdate();
3767     }
3768 

3769     if (canUseCompositedScrolling())
3770         setNeedsPostLayoutCompositingUpdate();

3771 
3772     updateScrollSnapState();
3773 }
3774 
3775 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3776 {
3777     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3778 
3779     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3780         return true;
3781 
3782     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3783         return true;
3784 
3785     if (scrollCornerRect().intersects(localRect))
3786         return true;
3787 
3788     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3789         return true;
3790 
</pre>
<hr />
<pre>
4027     OverlapTestRequestMap overlapTestRequests;
4028 
4029     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
4030     paintLayer(context, paintingInfo, paintFlags);
4031 
4032     for (auto&amp; widget : overlapTestRequests.keys())
4033         widget-&gt;setOverlapTestResult(false);
4034 }
4035 
4036 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
4037 {
4038     if (!m_containsDirtyOverlayScrollbars)
4039         return;
4040 
4041     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
4042     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
4043 
4044     m_containsDirtyOverlayScrollbars = false;
4045 }
4046 












4047 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
4048 {
4049     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4050     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
4051     if (needsClipping || clipRect.affectedByRadius())
4052         context.save();
4053 
4054     if (needsClipping) {
4055         LayoutRect adjustedClipRect = clipRect.rect();
4056         adjustedClipRect.move(paintingInfo.subpixelOffset);
<span class="line-modified">4057         auto snappedClipRect = snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor);</span>
<span class="line-added">4058         context.clip(snappedClipRect);</span>
<span class="line-added">4059 </span>
<span class="line-added">4060         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4061             paintingInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(snappedClipRect));</span>
4062     }
4063 
4064     if (clipRect.affectedByRadius()) {
4065         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
4066         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
4067         // containing block chain so we check that also.
4068         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
<span class="line-modified">4069             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; ancestorLayerIsInContainingBlockChain(*layer)) {</span>
4070                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
4071                 adjustedClipRect.move(paintingInfo.subpixelOffset);
4072                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
4073                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
4074                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
4075                 else
4076                     context.clipRoundedRect(roundedRect);
4077             }
4078 
4079             if (layer == paintingInfo.rootLayer)
4080                 break;
4081         }
4082     }
4083 }
4084 
4085 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
4086 {
<span class="line-modified">4087     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius()) {</span>
4088         context.restore();
<span class="line-added">4089 </span>
<span class="line-added">4090         if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4091             paintingInfo.eventRegionContext-&gt;popClip();</span>
<span class="line-added">4092     }</span>
4093 }
4094 
4095 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
4096 {
<span class="line-added">4097     if (overlapTestRequests.isEmpty())</span>
<span class="line-added">4098         return;</span>
<span class="line-added">4099 </span>
4100     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
4101     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
4102     for (auto&amp; request : overlapTestRequests) {
4103         if (!boundingBox.intersects(request.value))
4104             continue;
4105 
4106         request.key-&gt;setOverlapTestResult(true);
4107         overlappedRequestClients.append(request.key);
4108     }
4109     for (auto* client : overlappedRequestClients)
4110         overlapTestRequests.remove(client);
4111 }
4112 
4113 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
4114 {
4115     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
4116 }
4117 
4118 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
4119 {
4120     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
4121         return true;
4122 
4123     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
4124     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
4125     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
4126         return true;
4127 
4128     return false;
4129 }
4130 
4131 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
4132 {
4133     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
4134 }
4135 
4136 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4137 {
<span class="line-modified">4138     auto shouldContinuePaint = [&amp;] () {</span>
<span class="line-modified">4139         return backing()-&gt;paintsIntoWindow()</span>
<span class="line-modified">4140             || backing()-&gt;paintsIntoCompositedAncestor()</span>
<span class="line-modified">4141             || shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))</span>
<span class="line-modified">4142             || paintForFixedRootBackground(this, paintFlags);</span>
<span class="line-modified">4143     };</span>
<span class="line-modified">4144 </span>
<span class="line-modified">4145     auto paintsIntoDifferentCompositedDestination = [&amp;]() {</span>
<span class="line-modified">4146         if (paintsIntoProvidedBacking())</span>
<span class="line-modified">4147             return true;</span>
<span class="line-added">4148 </span>
<span class="line-added">4149         if (isComposited() &amp;&amp; !shouldContinuePaint())</span>
<span class="line-added">4150             return true;</span>
<span class="line-added">4151 </span>
<span class="line-added">4152         return false;</span>
<span class="line-added">4153     };</span>
<span class="line-added">4154 </span>
<span class="line-added">4155     if (paintsIntoDifferentCompositedDestination()) {</span>
<span class="line-added">4156         if (!context.performingPaintInvalidation() &amp;&amp; !(paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))</span>
4157             return;
<span class="line-modified">4158 </span>
<span class="line-modified">4159         paintFlags.add(PaintLayerTemporaryClipRects);</span>
<span class="line-added">4160     }</span>
<span class="line-added">4161 </span>
<span class="line-added">4162     if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {</span>
4163         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
4164         // unless their position or viewport size is changed.
4165         ASSERT(renderer().isFixedPositioned());
4166         return;
4167     }
4168 
<span class="line-added">4169     paintLayerWithEffects(context, paintingInfo, paintFlags);</span>
<span class="line-added">4170 }</span>
<span class="line-added">4171 </span>
<span class="line-added">4172 void RenderLayer::paintLayerWithEffects(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)</span>
<span class="line-added">4173 {</span>
4174     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
4175     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
4176         return;
4177 
4178     if (shouldSuppressPaintingLayer(this))
4179         return;
4180 
4181     // If this layer is totally invisible then there is nothing to paint.
4182     if (!renderer().opacity())
4183         return;
4184 
4185     if (paintsWithTransparency(paintingInfo.paintBehavior))
4186         paintFlags.add(PaintLayerHaveTransparency);
4187 
4188     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
4189     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
4190         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
4191         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
4192         if (!layerTransform.isInvertible())
4193             return;
</pre>
<hr />
<pre>
4429 {
4430     // FIXME: Handle more than one fragment.
4431     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4432     clipToRect(originalContext, paintingInfo, backgroundRect);
4433     m_filters-&gt;applyFilterEffect(originalContext);
4434     restoreClip(originalContext, paintingInfo, backgroundRect);
4435 }
4436 
4437 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4438 {
4439     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4440 
4441     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4442     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4443     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4444     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4445     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4446     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4447     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4448     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
<span class="line-added">4449     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);</span>
4450     // Outline always needs to be painted even if we have no visible content. Also,
4451     // the outline is painted in the background phase during composited scrolling.
4452     // If it were painted in the foreground phase, it would move with the scrolled
4453     // content. When not composited scrolling, the outline is painted in the
4454     // foreground phase. Since scrolled contents are moved by repainting in this
4455     // case, the outline won&#39;t get &#39;dragged along&#39;.
<span class="line-modified">4456     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion</span>
<span class="line-added">4457         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())</span>
4458         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4459         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
<span class="line-modified">4460     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;</span>
4461 
4462     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer())
4463         return;
4464 
4465     updateLayerListsIfNeeded();
4466 
4467     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4468     LayoutRect rootRelativeBounds;
4469     bool rootRelativeBoundsComputed = false;
4470 
4471     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4472     // things on the scrolling thread.
4473     bool didQuantizeFonts = true;
4474     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4475 
4476     // Apply clip-path to context.
4477     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4478     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4479         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4480 
</pre>
<hr />
<pre>
4511 
4512         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4513         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4514             paintBehavior.add(PaintBehavior::SkipRootBackground);
4515         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4516             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4517 
4518         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4519             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4520 
4521         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4522             paintBehavior.add(PaintBehavior::Snapshotting);
4523 
4524         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4525             paintBehavior.add(PaintBehavior::TileFirstPaint);
4526 
4527         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4528             paintBehavior.add(PaintBehavior::ExcludeSelection);
4529 
4530         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
<span class="line-modified">4531         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars || isCollectingEventRegion) {</span>
4532             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4533             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4534             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4535             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4536                 // We can turn clipping back by requesting full repaint for the overflow area.
4537                 localPaintingInfo.clipToDirtyRect = true;
4538                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4539             }
4540             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4541                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4542                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4543             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4544         }
4545 
4546         if (isPaintingCompositedBackground) {
4547             // Paint only the backgrounds for all of the fragments of the layer.
4548             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4549                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4550                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4551             }
4552         }
4553 
4554         // Now walk the sorted list of children with negative z-indices.
4555         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4556             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4557 
4558         if (isPaintingCompositedForeground) {
4559             if (shouldPaintContent) {
4560                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4561                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4562             }
4563         }
4564 
<span class="line-added">4565         if (isCollectingEventRegion)</span>
<span class="line-added">4566             collectEventRegionForFragments(layerFragments, currentContext, localPaintingInfo);</span>
<span class="line-added">4567 </span>
4568         if (shouldPaintOutline)
4569             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4570 
4571         if (isPaintingCompositedForeground) {
4572             // Paint any child layers that have overflow.
4573             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4574 
4575             // Now walk the sorted list of children with positive z-indices.
4576             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4577         }
4578 
4579         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4580             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4581 
4582         if (filterContext) {
4583             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4584             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4585             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4586             LayerFragments layerFragments;
4587             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
</pre>
<hr />
<pre>
4634     if (hasClipPath)
4635         context.restore();
4636 }
4637 
4638 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4639 {
4640     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4641     // the accumulated error for sub-pixel layout.
4642     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4643     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4644     offsetFromParent += translationOffset;
4645     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4646     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4647     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4648     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4649     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4650     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4651     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4652     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4653     // Apply the transform.
<span class="line-modified">4654     auto oldTransform = context.getCTM();</span>
<span class="line-modified">4655     auto affineTransform = transform.toAffineTransform();</span>
<span class="line-added">4656     context.concatCTM(affineTransform);</span>
<span class="line-added">4657 </span>
<span class="line-added">4658     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4659         paintingInfo.eventRegionContext-&gt;pushTransform(affineTransform);</span>
4660 
4661     // Now do a paint with the root layer shifted to be us.
4662     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4663     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4664     transformedPaintingInfo.rootLayer = this;
4665     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4666     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4667     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
<span class="line-modified">4668 </span>
<span class="line-added">4669     if (paintingInfo.eventRegionContext)</span>
<span class="line-added">4670         paintingInfo.eventRegionContext-&gt;popTransform();</span>
<span class="line-added">4671 </span>
<span class="line-added">4672     context.setCTM(oldTransform);</span>
4673 }
4674 
4675 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4676 {
4677     if (layerIterator.begin() == layerIterator.end())
4678         return;
4679 
4680     if (!hasSelfPaintingLayerDescendant())
4681         return;
4682 
4683 #if !ASSERT_DISABLED
4684     LayerListMutationDetector mutationChecker(*this);
4685 #endif
4686 
4687     for (auto* childLayer : layerIterator)
4688         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4689 }
4690 
4691 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4692 {
</pre>
<hr />
<pre>
4937 
4938     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4939         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
4940 
4941     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4942         localPaintBehavior.add(PaintBehavior::Snapshotting);
4943 
4944     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4945         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
4946 
4947     // Optimize clipping for the single fragment case.
4948     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
4949     ClipRect clippedRect;
4950     if (shouldClip) {
4951         clippedRect = layerFragments[0].foregroundRect;
4952         clipToRect(context, localPaintingInfo, clippedRect);
4953     }
4954 
4955     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
4956     // interleaving of the fragments to work properly.
<span class="line-modified">4957     bool selectionOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);</span>
<span class="line-modified">4958     bool selectionAndBackgroundsOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);</span>
<span class="line-modified">4959 </span>
<span class="line-added">4960     if (!selectionOnly)</span>
<span class="line-added">4961         paintForegroundForFragmentsWithPhase(PaintPhase::ChildBlockBackgrounds, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
4962 
<span class="line-modified">4963     if (selectionOnly || selectionAndBackgroundsOnly)</span>
<span class="line-added">4964         paintForegroundForFragmentsWithPhase(PaintPhase::Selection, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);</span>
<span class="line-added">4965     else {</span>
4966         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4967         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4968         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
4969     }
4970 
4971     if (shouldClip)
4972         restoreClip(context, localPaintingInfo, clippedRect);
4973 }
4974 
4975 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
4976     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
4977 {
4978     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
4979 
4980     for (const auto&amp; fragment : layerFragments) {
4981         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
4982             continue;
4983 
4984         if (shouldClip)
4985             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
</pre>
<hr />
<pre>
5042         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5043         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5044 
5045         if (localPaintingInfo.clipToDirtyRect)
5046             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5047     }
5048 }
5049 
5050 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5051 {
5052     for (const auto&amp; fragment : layerFragments) {
5053         if (fragment.backgroundRect.isEmpty())
5054             continue;
5055         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
5056         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
5057             snappedIntRect(fragment.backgroundRect.rect()), true);
5058         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5059     }
5060 }
5061 
<span class="line-added">5062 void RenderLayer::collectEventRegionForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)</span>
<span class="line-added">5063 {</span>
<span class="line-added">5064     ASSERT(localPaintingInfo.eventRegionContext);</span>
<span class="line-added">5065 </span>
<span class="line-added">5066     for (const auto&amp; fragment : layerFragments) {</span>
<span class="line-added">5067         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), PaintPhase::EventRegion, { });</span>
<span class="line-added">5068         paintInfo.eventRegionContext = localPaintingInfo.eventRegionContext;</span>
<span class="line-added">5069         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));</span>
<span class="line-added">5070     }</span>
<span class="line-added">5071 }</span>
<span class="line-added">5072 </span>
5073 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
5074 {
5075     return hitTest(request, result.hitTestLocation(), result);
5076 }
5077 
5078 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
5079 {
5080     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5081     ASSERT(!renderer().view().needsLayout());
5082 
5083     ASSERT(!isRenderFragmentedFlow());
5084     LayoutRect hitTestArea = renderer().view().documentRect();
5085     if (!request.ignoreClipping()) {
5086         const auto&amp; settings = renderer().settings();
5087         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
5088             auto&amp; frameView = renderer().view().frameView();
5089             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
5090             auto scaleFactor = frameView.frame().frameScaleFactor();
5091             if (scaleFactor &gt; 1)
5092                 absoluteLayoutViewportRect.scale(scaleFactor);
</pre>
<hr />
<pre>
5558     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5559     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5560     if (m_clipRectsCache) {
5561         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5562             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5563             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5564 
5565 #ifdef CHECK_CACHED_CLIP_RECTS
5566             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5567             ClipRectsContext tempContext(clipRectsContext);
5568             tempContext.clipRectsType = TemporaryClipRects;
5569             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5570             calculateClipRects(tempContext, tempClipRects);
5571             ASSERT(tempClipRects.get() == *clipRects);
5572 #endif
5573             return *clipRects; // We have the correct cached value.
5574         }
5575     }
5576 
5577     if (!m_clipRectsCache)
<span class="line-modified">5578         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();</span>
5579 #ifndef NDEBUG
5580     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5581     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5582 #endif
5583 
5584     RefPtr&lt;ClipRects&gt; parentClipRects;
5585     // For transformed layers, the root layer was shifted to be us, so there is no need to
5586     // examine the parent. We want to cache clip rects with us as the root.
<span class="line-modified">5587     if (clipRectsContext.rootLayer != this &amp;&amp; parent())</span>
<span class="line-modified">5588         parentClipRects = this-&gt;parentClipRects(clipRectsContext);</span>
5589 
5590     auto clipRects = ClipRects::create();
5591     calculateClipRects(clipRectsContext, clipRects);
5592 
5593     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5594         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5595         return parentClipRects.releaseNonNull();
5596     }
5597     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5598     return clipRects;
5599 }
5600 
5601 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5602 {
5603     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5604     if (!m_clipRectsCache)
5605         return nullptr;
5606     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5607 }
5608 
<span class="line-added">5609 bool RenderLayer::clipCrossesPaintingBoundary() const</span>
<span class="line-added">5610 {</span>
<span class="line-added">5611     return parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers)</span>
<span class="line-added">5612         || parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();</span>
<span class="line-added">5613 }</span>
<span class="line-added">5614 </span>
5615 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5616 {
5617     if (!parent()) {
5618         // The root layer&#39;s clip rect is always infinite.
5619         clipRects.reset();
5620         return;
5621     }
5622 
5623     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5624     bool useCached = clipRectsType != TemporaryClipRects;
5625 
5626     // For transformed layers, the root layer was shifted to be us, so there is no need to
5627     // examine the parent. We want to cache clip rects with us as the root.
5628     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5629 
5630     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5631     if (parentLayer) {
5632         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5633             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5634         else {
5635             ClipRectsContext parentContext(clipRectsContext);
5636             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
<span class="line-added">5637 </span>
<span class="line-added">5638             if ((parentContext.clipRectsType != TemporaryClipRects &amp;&amp; parentContext.clipRectsType != AbsoluteClipRects) &amp;&amp; clipCrossesPaintingBoundary())</span>
<span class="line-added">5639                 parentContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">5640 </span>
5641             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5642         }
5643     } else
5644         clipRects.reset();
5645 
5646     // A fixed object is essentially the root of its containing block hierarchy, so when
5647     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5648     if (renderer().isFixedPositioned()) {
5649         clipRects.setPosClipRect(clipRects.fixedClipRect());
5650         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5651         clipRects.setFixed(true);
5652     } else if (renderer().isInFlowPositioned())
5653         clipRects.setPosClipRect(clipRects.overflowClipRect());
5654     else if (renderer().isAbsolutelyPositioned())
5655         clipRects.setOverflowClipRect(clipRects.posClipRect());
5656 
5657     // Update the clip rects that will be passed to child layers.
5658 #if PLATFORM(IOS_FAMILY)
5659     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5660 #else
5661     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5662 #endif
5663         // This layer establishes a clip of some kind.
<span class="line-added">5664         LayoutPoint offset;</span>
<span class="line-added">5665         if (!m_hasTransformedAncestor &amp;&amp; canUseOffsetFromAncestor())</span>
<span class="line-added">5666             offset = toLayoutPoint(offsetFromAncestor(clipRectsContext.rootLayer, AdjustForColumns));</span>
<span class="line-added">5667         else</span>
<span class="line-added">5668             offset = LayoutPoint(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));</span>
5669 




5670         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5671             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5672 
5673         if (renderer().hasOverflowClip()) {
5674             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5675             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5676             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5677             if (renderer().isPositioned())
5678                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5679         }
5680         if (renderer().hasClip()) {
5681             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5682             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5683             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5684             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5685         }
5686     }
<span class="line-added">5687 </span>
<span class="line-added">5688     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; calculateClipRects &quot; &lt;&lt; clipRects);</span>
5689 }
5690 
5691 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5692 {
5693     ASSERT(parent());
5694 
<span class="line-modified">5695     auto temporaryParentClipRects = [&amp;](const ClipRectsContext&amp; clipContext) {</span>
5696         auto parentClipRects = ClipRects::create();
<span class="line-modified">5697         parent()-&gt;calculateClipRects(clipContext, parentClipRects);</span>
5698         return parentClipRects;
<span class="line-added">5699     };</span>
<span class="line-added">5700 </span>
<span class="line-added">5701     if (clipRectsContext.clipRectsType == TemporaryClipRects)</span>
<span class="line-added">5702         return temporaryParentClipRects(clipRectsContext);</span>
<span class="line-added">5703 </span>
<span class="line-added">5704     if (clipRectsContext.clipRectsType != AbsoluteClipRects &amp;&amp; clipCrossesPaintingBoundary()) {</span>
<span class="line-added">5705         ClipRectsContext tempClipRectsContext(clipRectsContext);</span>
<span class="line-added">5706         tempClipRectsContext.clipRectsType = TemporaryClipRects;</span>
<span class="line-added">5707         return temporaryParentClipRects(tempClipRectsContext);</span>
5708     }
5709 
5710     return parent()-&gt;updateClipRects(clipRectsContext);
5711 }
5712 
5713 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5714 {
5715     if (position == PositionType::Fixed)
5716         return parentRects.fixedClipRect();
5717 
5718     if (position == PositionType::Absolute)
5719         return parentRects.posClipRect();
5720 
5721     return parentRects.overflowClipRect();
5722 }
5723 
5724 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5725 {
5726     ASSERT(parent());
<span class="line-modified">5727     auto parentRects = parentClipRects(clipRectsContext);</span>














5728     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5729     RenderView&amp; view = renderer().view();
5730     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5731     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5732         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
<span class="line-added">5733 </span>
<span class="line-added">5734     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; backgroundClipRect with context &quot; &lt;&lt; clipRectsContext &lt;&lt; &quot; returning &quot; &lt;&lt; backgroundClipRect);</span>
5735     return backgroundClipRect;
5736 }
5737 
5738 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5739     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5740 {
5741     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5742         backgroundRect = backgroundClipRect(clipRectsContext);
5743         backgroundRect.intersect(paintDirtyRect);
5744     } else
5745         backgroundRect = paintDirtyRect;
5746 
5747     LayoutSize offsetFromRootLocal = offsetFromRoot;
5748 
5749     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5750         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5751         offsetFromRootLocal += toLayoutSize(absPos);
5752     }
5753 
5754     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
</pre>
<hr />
<pre>
5921     // floats.
5922     LayoutRect result;
5923     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
5924         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
5925     else if (is&lt;RenderTableRow&gt;(renderer())) {
5926         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
5927         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
5928         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
5929             LayoutRect bbox = cell-&gt;borderBoxRect();
5930             result.unite(bbox);
5931             LayoutRect overflowRect = tableRow.visualOverflowRect();
5932             if (bbox != overflowRect)
5933                 result.unite(overflowRect);
5934         }
5935     } else {
5936         RenderBox* box = renderBox();
5937         ASSERT(box);
5938         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
5939             result = box-&gt;maskClipRect(LayoutPoint());
5940             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
<span class="line-modified">5941         } else</span>
<span class="line-modified">5942             result = box-&gt;visualOverflowRect();</span>





5943     }
5944     return result;
5945 }
5946 
5947 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5948 {
5949     LayoutRect result = localBoundingBox(flags);
5950     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
5951         if (renderer().isBox())
5952             renderBox()-&gt;flipForWritingMode(result);
5953         else
5954             renderer().containingBlock()-&gt;flipForWritingMode(result);
5955     }
5956 
5957     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
5958     if (flags &amp; UseFragmentBoxesIncludingCompositing)
5959         inclusionMode = IncludeCompositedPaginatedLayers;
5960 
5961     const RenderLayer* paginationLayer = nullptr;
5962     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
</pre>
<hr />
<pre>
6077 
6078     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6079     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6080 
6081     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6082 
6083     if (RenderLayer* reflection = reflectionLayer()) {
6084         if (!reflection-&gt;isComposited()) {
6085             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6086             unionBounds.unite(childUnionBounds);
6087         }
6088     }
6089 
6090     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6091 
6092 #if !ASSERT_DISABLED
6093     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6094 #endif
6095 
6096     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
<span class="line-modified">6097         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))</span>
6098             return;
6099         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6100         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6101         // that we hit the max LayoutUnit value.
6102         unionBounds.checkedUnite(childBounds);
6103     };
6104 
6105     for (auto* childLayer : negativeZOrderLayers())
6106         computeLayersUnion(*childLayer);
6107 
6108     for (auto* childLayer : positiveZOrderLayers())
6109         computeLayersUnion(*childLayer);
6110 
6111     for (auto* childLayer : normalFlowLayers())
6112         computeLayersUnion(*childLayer);
6113 
6114     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
6115         renderer().style().filterOutsets().expandRect(unionBounds);
6116 
6117     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
</pre>
<hr />
<pre>
6132     clearClipRects(typeToClear);
6133 
6134     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6135         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
6136 }
6137 
6138 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
6139 {
6140     if (typeToClear == AllClipRectTypes)
6141         m_clipRectsCache = nullptr;
6142     else {
6143         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
6144         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
6145         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
6146     }
6147 }
6148 
6149 RenderLayerBacking* RenderLayer::ensureBacking()
6150 {
6151     if (!m_backing) {
<span class="line-modified">6152         m_backing = makeUnique&lt;RenderLayerBacking&gt;(*this);</span>
6153         compositor().layerBecameComposited(*this);
6154 
6155         updateFilterPaintingStrategy();
6156     }
6157     return m_backing.get();
6158 }
6159 
6160 void RenderLayer::clearBacking(bool layerBeingDestroyed)
6161 {
6162     if (!m_backing)
6163         return;
6164 
6165     if (!renderer().renderTreeBeingDestroyed())
6166         compositor().layerBecameNonComposited(*this);
6167 
6168     m_backing-&gt;willBeDestroyed();
6169     m_backing = nullptr;
6170 
6171     if (!layerBeingDestroyed)
6172         updateFilterPaintingStrategy();
</pre>
<hr />
<pre>
6271     // We can&#39;t consult child layers if we clip, since they might cover
6272     // parts of the rect that are clipped out.
6273     if (renderer().hasOverflowClip())
6274         return false;
6275 
6276     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6277         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6278         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6279 }
6280 
6281 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6282 {
6283     if (list.begin() == list.end())
6284         return false;
6285 
6286     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6287         const auto* childLayer = *iter;
6288         if (childLayer-&gt;isComposited())
6289             continue;
6290 
<span class="line-modified">6291         if (!childLayer-&gt;canUseOffsetFromAncestor())</span>
6292             continue;
6293 
6294         LayoutRect childLocalRect(localRect);
6295         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6296 
6297         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6298             return true;
6299     }
6300     return false;
6301 }
6302 
6303 void RenderLayer::repaintIncludingDescendants()
6304 {
6305     renderer().repaint();
6306     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6307         current-&gt;repaintIncludingDescendants();
6308 }
6309 
6310 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6311 {
</pre>
<hr />
<pre>
6383 
6384 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6385 {
6386     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6387     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6388 }
6389 
6390 // Constrain the depth and breadth of the search for performance.
6391 static const unsigned maxRendererTraversalCount = 200;
6392 
6393 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6394 {
6395     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6396         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6397             request.makeStatesUndetermined();
6398             return;
6399         }
6400 
6401         if (is&lt;RenderText&gt;(child)) {
6402             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
<span class="line-modified">6403             if (!renderText.hasRenderedText())</span>
6404                 continue;
6405 
6406             if (renderer.style().userSelect() != UserSelect::None)
6407                 request.setHasPaintedContent();
6408 
6409             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6410                 request.setHasPaintedContent();
6411 
6412                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6413                     request.setHasSubpixelAntialiasedText();
6414             }
6415 
6416             if (request.isSatisfied())
6417                 return;
6418         }
6419 
6420         if (!is&lt;RenderElement&gt;(child))
6421             continue;
6422 
6423         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
</pre>
<hr />
<pre>
6522     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6523     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6524     setHasVerticalScrollbar(needsVerticalScrollbar);
6525 
6526     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6527     // When switching to another value, we need to re-enable them (see bug 11985).
6528     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6529         m_hBar-&gt;setEnabled(true);
6530 
6531     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6532         m_vBar-&gt;setEnabled(true);
6533 
6534     if (!m_scrollDimensionsDirty)
6535         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6536 }
6537 
6538 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6539 {
6540     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6541 
<span class="line-modified">6542     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {</span>
6543 #if ENABLE(CSS_COMPOSITING)
6544         if (parent()) {
<span class="line-modified">6545             if (isCSSStackingContext()) {</span>
6546                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6547                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6548             } else {
6549                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6550                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6551                 else if (hasNotIsolatedBlendingDescendants())
6552                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6553             }
6554         }
6555 #endif
6556     }
6557 
6558     // FIXME: RenderLayer already handles visibility changes through our visiblity dirty bits. This logic could
6559     // likely be folded along with the rest.
6560     if (oldStyle) {
6561         if (oldStyle-&gt;zIndex() != renderer().style().zIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6562             dirtyStackingContextZOrderLists();
6563             if (isStackingContext())
6564                 dirtyZOrderLists();
6565         }
6566     }
6567 
6568     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6569         if (!m_marquee)
<span class="line-modified">6570             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);</span>
6571         m_marquee-&gt;updateMarqueeStyle();
6572     } else if (m_marquee)
6573         m_marquee = nullptr;
6574 
6575     updateScrollbarsAfterStyleChange(oldStyle);
6576     // Overlay scrollbars can make this layer self-painting so we need
6577     // to recompute the bit once scrollbars have been updated.
6578     updateSelfPaintingLayer();
6579 
6580     if (!hasReflection() &amp;&amp; m_reflection)
6581         removeReflection();
6582     else if (hasReflection()) {
6583         if (!m_reflection)
6584             createReflection();
6585         else
6586             m_reflection-&gt;setStyle(createReflectionStyle());
6587     }
6588 
6589     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6590     if (m_hBar)
</pre>
<hr />
<pre>
6762             transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6763             transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6764             break;
6765     }
6766     newStyle.setTransform(transform);
6767 
6768     // Map in our mask.
6769     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6770 
6771     // Style has transform and mask, so needs to be stacking context.
6772     newStyle.setZIndex(0);
6773 
6774     return newStyle;
6775 }
6776 
6777 void RenderLayer::ensureLayerFilters()
6778 {
6779     if (m_filters)
6780         return;
6781 
<span class="line-modified">6782     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);</span>
6783 }
6784 
6785 void RenderLayer::clearLayerFilters()
6786 {
6787     m_filters = nullptr;
6788 }
6789 
6790 void RenderLayer::updateFiltersAfterStyleChange()
6791 {
6792     if (!hasFilter()) {
6793         clearLayerFilters();
6794         return;
6795     }
6796 
6797     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6798     // an SVG. In that case it takes care of its own resource management for filters.
6799     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6800         ensureLayerFilters();
6801         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6802     } else if (m_filters)
</pre>
<hr />
<pre>
6818         // For reference filters, we still want the FilterEffect graph built
6819         // for us, even if we&#39;re composited.
6820         if (!renderer().style().filter().hasReferenceFilter())
6821             return;
6822     }
6823 
6824     ensureLayerFilters();
6825     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? Accelerated : Unaccelerated);
6826 }
6827 
6828 void RenderLayer::filterNeedsRepaint()
6829 {
6830     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.
6831     if (Element* element = enclosingElement()) {
6832         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.
6833         element-&gt;invalidateStyleAndLayerComposition();
6834     }
6835     renderer().repaint();
6836 }
6837 
<span class="line-added">6838 bool RenderLayer::isTransparentOrFullyClippedRespectingParentFrames() const</span>
<span class="line-added">6839 {</span>
<span class="line-added">6840     static const double minimumVisibleOpacity = 0.01;</span>
<span class="line-added">6841 </span>
<span class="line-added">6842     float currentOpacity = 1;</span>
<span class="line-added">6843     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {</span>
<span class="line-added">6844         currentOpacity *= layer-&gt;renderer().style().opacity();</span>
<span class="line-added">6845         if (currentOpacity &lt; minimumVisibleOpacity)</span>
<span class="line-added">6846             return true;</span>
<span class="line-added">6847     }</span>
<span class="line-added">6848 </span>
<span class="line-added">6849     auto hasEmptyClipRect = [] (const RenderLayer&amp; layer) -&gt; bool {</span>
<span class="line-added">6850         auto* frameView = layer.renderer().document().view();</span>
<span class="line-added">6851         if (!frameView)</span>
<span class="line-added">6852             return false;</span>
<span class="line-added">6853 </span>
<span class="line-added">6854         auto* renderView = frameView-&gt;renderView();</span>
<span class="line-added">6855         if (!renderView)</span>
<span class="line-added">6856             return false;</span>
<span class="line-added">6857 </span>
<span class="line-added">6858         auto* renderViewLayer = renderView-&gt;layer();</span>
<span class="line-added">6859         if (!renderViewLayer)</span>
<span class="line-added">6860             return false;</span>
<span class="line-added">6861 </span>
<span class="line-added">6862         if (is&lt;HTMLFrameOwnerElement&gt;(layer.renderer().element()) &amp;&amp; layer.visibleSize().isEmpty())</span>
<span class="line-added">6863             return true;</span>
<span class="line-added">6864 </span>
<span class="line-added">6865         LayoutRect layerBounds;</span>
<span class="line-added">6866         ClipRect backgroundRect;</span>
<span class="line-added">6867         ClipRect foregroundRect;</span>
<span class="line-added">6868         layer.calculateRects({ renderViewLayer, TemporaryClipRects }, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, layer.offsetFromAncestor(renderViewLayer));</span>
<span class="line-added">6869         return backgroundRect.isEmpty();</span>
<span class="line-added">6870     };</span>
<span class="line-added">6871 </span>
<span class="line-added">6872     for (auto* layer = this; layer; layer = enclosingFrameRenderLayer(*layer)) {</span>
<span class="line-added">6873         if (hasEmptyClipRect(*layer))</span>
<span class="line-added">6874             return true;</span>
<span class="line-added">6875     }</span>
<span class="line-added">6876 </span>
<span class="line-added">6877     return false;</span>
<span class="line-added">6878 }</span>
<span class="line-added">6879 </span>
<span class="line-added">6880 void RenderLayer::invalidateEventRegion()</span>
<span class="line-added">6881 {</span>
<span class="line-added">6882 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">6883     auto* compositingLayer = enclosingCompositingLayerForRepaint();</span>
<span class="line-added">6884     if (!compositingLayer)</span>
<span class="line-added">6885         return;</span>
<span class="line-added">6886 </span>
<span class="line-added">6887     auto maintainsEventRegion = [&amp;] {</span>
<span class="line-added">6888         // UI side scroll overlap testing.</span>
<span class="line-added">6889         if (!compositingLayer-&gt;isRenderViewLayer())</span>
<span class="line-added">6890             return true;</span>
<span class="line-added">6891 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-added">6892         // UI side touch-action resolution.</span>
<span class="line-added">6893         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())</span>
<span class="line-added">6894             return true;</span>
<span class="line-added">6895 #endif</span>
<span class="line-added">6896         return false;</span>
<span class="line-added">6897     };</span>
<span class="line-added">6898 </span>
<span class="line-added">6899     if (!maintainsEventRegion())</span>
<span class="line-added">6900         return;</span>
<span class="line-added">6901 </span>
<span class="line-added">6902     compositingLayer-&gt;setNeedsCompositingConfigurationUpdate();</span>
<span class="line-added">6903 #endif</span>
<span class="line-added">6904 }</span>
<span class="line-added">6905 </span>
<span class="line-added">6906 TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, ClipRectsType clipRectsType)</span>
<span class="line-added">6907 {</span>
<span class="line-added">6908     switch (clipRectsType) {</span>
<span class="line-added">6909     case PaintingClipRects: ts &lt;&lt; &quot;painting&quot;; break;</span>
<span class="line-added">6910     case RootRelativeClipRects: ts &lt;&lt; &quot;root-relative&quot;; break;</span>
<span class="line-added">6911     case AbsoluteClipRects: ts &lt;&lt; &quot;absolute&quot;; break;</span>
<span class="line-added">6912     case TemporaryClipRects: ts &lt;&lt; &quot;temporary&quot;; break;</span>
<span class="line-added">6913     case NumCachedClipRectsTypes:</span>
<span class="line-added">6914     case AllClipRectTypes:</span>
<span class="line-added">6915         ts &lt;&lt; &quot;?&quot;;</span>
<span class="line-added">6916         break;</span>
<span class="line-added">6917     }</span>
<span class="line-added">6918     return ts;</span>
<span class="line-added">6919 }</span>
<span class="line-added">6920 </span>
6921 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6922 {
6923     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6924     if (layer.transform())
6925         ts &lt;&lt; &quot; has transform&quot;;
6926     if (layer.hasFilter())
6927         ts &lt;&lt; &quot; has filter&quot;;
6928     if (layer.hasBackdropFilter())
6929         ts &lt;&lt; &quot; has backdrop filter&quot;;
6930     if (layer.hasBlendMode())
6931         ts &lt;&lt; &quot; has blend mode&quot;;
6932     if (layer.isolatesBlending())
6933         ts &lt;&lt; &quot; isolates blending&quot;;
6934     if (layer.isComposited())
6935         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6936     return ts;
6937 }
6938 
<span class="line-added">6939 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)</span>
<span class="line-added">6940 {</span>
<span class="line-added">6941     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);</span>
<span class="line-added">6942     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);</span>
<span class="line-added">6943     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);</span>
<span class="line-added">6944 </span>
<span class="line-added">6945     return ts;</span>
<span class="line-added">6946 }</span>
<span class="line-added">6947 </span>
<span class="line-added">6948 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)</span>
<span class="line-added">6949 {</span>
<span class="line-added">6950     switch (reason) {</span>
<span class="line-added">6951     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;</span>
<span class="line-added">6952     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;</span>
<span class="line-added">6953     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;</span>
<span class="line-added">6954     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;</span>
<span class="line-added">6955     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;</span>
<span class="line-added">6956     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;</span>
<span class="line-added">6957     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;</span>
<span class="line-added">6958     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;</span>
<span class="line-added">6959     }</span>
<span class="line-added">6960 </span>
<span class="line-added">6961     return ts;</span>
<span class="line-added">6962 }</span>
<span class="line-added">6963 </span>
6964 } // namespace WebCore
6965 
6966 #if ENABLE(TREE_DEBUGGING)
6967 
6968 void showLayerTree(const WebCore::RenderLayer* layer)
6969 {
6970     if (!layer)
6971         return;
6972 
<span class="line-modified">6973     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), {</span>
<span class="line-added">6974         WebCore::RenderAsTextFlag::ShowAllLayers,</span>
<span class="line-added">6975         WebCore::RenderAsTextFlag::ShowLayerNesting,</span>
<span class="line-added">6976         WebCore::RenderAsTextFlag::ShowCompositedLayers,</span>
<span class="line-added">6977         WebCore::RenderAsTextFlag::ShowOverflow,</span>
<span class="line-added">6978         WebCore::RenderAsTextFlag::ShowSVGGeometry,</span>
<span class="line-added">6979         WebCore::RenderAsTextFlag::ShowLayerFragments,</span>
<span class="line-added">6980         WebCore::RenderAsTextFlag::ShowAddresses,</span>
<span class="line-added">6981         WebCore::RenderAsTextFlag::ShowIDAndClass,</span>
<span class="line-added">6982         WebCore::RenderAsTextFlag::DontUpdateLayout,</span>
<span class="line-added">6983         WebCore::RenderAsTextFlag::ShowLayoutState,</span>
<span class="line-added">6984     });</span>
6985     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
6986 }
6987 
6988 void showLayerTree(const WebCore::RenderObject* renderer)
6989 {
6990     if (!renderer)
6991         return;
6992     showLayerTree(renderer-&gt;enclosingLayer());
6993 }
6994 
6995 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
6996 {
6997     stream.nextLine();
<span class="line-modified">6998     stream &lt;&lt; &quot;(S)tacking Context/(F)orced SC/O(P)portunistic SC, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, Behaves as fi(x)ed, (C)omposited, (P)rovides backing/uses (p)rovided backing/paints to (a)ncestor, (c)omposited descendant, (s)scrolling ancestor, (t)transformed ancestor\n&quot;</span>
6999         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
7000         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
7001         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
7002     stream.nextLine();
7003 }
7004 
7005 static void outputIdent(TextStream&amp; stream, unsigned depth)
7006 {
7007     unsigned i = 0;
7008     while (++i &lt;= depth * 2)
7009         stream &lt;&lt; &quot; &quot;;
7010 }
7011 
7012 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
7013 {
<span class="line-modified">7014     stream &lt;&lt; (layer.isCSSStackingContext() ? &quot;S&quot; : (layer.isForcedStackingContext() ? &quot;F&quot; : (layer.isOpportunisticStackingContext() ? &quot;P&quot; : &quot;-&quot;)));</span>
7015     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
7016     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
7017     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
7018     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
7019     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
7020     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
7021     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
7022     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
<span class="line-added">7023     stream &lt;&lt; (layer.behavesAsFixed() ? &quot;x&quot; : &quot;-&quot;);</span>
7024     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
<span class="line-added">7025 </span>
<span class="line-added">7026     auto compositedPaintingDestinationString = [&amp;layer]() {</span>
<span class="line-added">7027         if (layer.paintsIntoProvidedBacking())</span>
<span class="line-added">7028             return &quot;p&quot;;</span>
<span class="line-added">7029 </span>
<span class="line-added">7030         if (!layer.isComposited())</span>
<span class="line-added">7031             return &quot;-&quot;;</span>
<span class="line-added">7032 </span>
<span class="line-added">7033         if (layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="line-added">7034             return &quot;P&quot;;</span>
<span class="line-added">7035 </span>
<span class="line-added">7036         if (layer.backing()-&gt;paintsIntoCompositedAncestor())</span>
<span class="line-added">7037             return &quot;a&quot;;</span>
<span class="line-added">7038 </span>
<span class="line-added">7039         return &quot;-&quot;;</span>
<span class="line-added">7040     };</span>
<span class="line-added">7041 </span>
<span class="line-added">7042     stream &lt;&lt; compositedPaintingDestinationString();</span>
7043     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
<span class="line-added">7044     stream &lt;&lt; (layer.hasCompositedScrollingAncestor() ? &quot;s&quot; : &quot;-&quot;);</span>
<span class="line-added">7045     stream &lt;&lt; (layer.hasTransformedAncestor() ? &quot;t&quot; : &quot;-&quot;);</span>
7046 
7047     stream &lt;&lt; &quot; &quot;;
7048 
7049     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
7050     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
7051 
7052     stream &lt;&lt; &quot; &quot;;
7053 
7054     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
7055     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
7056     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
7057     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
7058     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
7059     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
7060 
7061     stream &lt;&lt; &quot; &quot;;
7062 
7063     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
7064     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
7065     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
7066     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
7067     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
7068     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
7069 
7070     stream &lt;&lt; &quot; &quot;;
7071 
7072     outputIdent(stream, depth);
7073 
7074     stream &lt;&lt; prefix;
7075 
7076     auto layerRect = layer.rect();
7077 
7078     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
7079     if (layer.isComposited()) {
7080         auto&amp; backing = *layer.backing();
7081         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
7082 
<span class="line-added">7083         if (layer.indirectCompositingReason() != WebCore::IndirectCompositingReason::None)</span>
<span class="line-added">7084             stream &lt;&lt; &quot; &quot; &lt;&lt; layer.indirectCompositingReason();</span>
<span class="line-added">7085 </span>
7086         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
7087         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
7088         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
<span class="line-added">7089         auto positionedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Positioning);</span>
7090 
<span class="line-modified">7091         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID || positionedNodeID) {</span>
7092             stream &lt;&lt; &quot; {&quot;;
7093             bool first = true;
7094             if (scrollingNodeID) {
7095                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
7096                 first = false;
7097             }
7098 
7099             if (frameHostingNodeID) {
7100                 if (!first)
7101                     stream &lt;&lt; &quot;, &quot;;
7102                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
7103                 first = false;
7104             }
7105 
7106             if (viewportConstrainedNodeID) {
7107                 if (!first)
7108                     stream &lt;&lt; &quot;, &quot;;
7109                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
<span class="line-added">7110                 first = false;</span>
<span class="line-added">7111             }</span>
<span class="line-added">7112 </span>
<span class="line-added">7113             if (positionedNodeID) {</span>
<span class="line-added">7114                 if (!first)</span>
<span class="line-added">7115                     stream &lt;&lt; &quot;, &quot;;</span>
<span class="line-added">7116                 stream &lt;&lt; &quot;pos &quot; &lt;&lt; positionedNodeID;</span>
7117             }
7118 
7119             stream &lt;&lt; &quot;}&quot;;
7120         }
7121     }
7122     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
7123     stream.nextLine();
7124 
7125     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
7126 
7127     for (auto* child : layer.negativeZOrderLayers())
7128         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
7129 
7130     for (auto* child : layer.normalFlowLayers())
7131         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
7132 
7133     for (auto* child : layer.positiveZOrderLayers())
7134         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
7135 }
7136 
</pre>
</td>
</tr>
</table>
<center><a href="RenderInline.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>