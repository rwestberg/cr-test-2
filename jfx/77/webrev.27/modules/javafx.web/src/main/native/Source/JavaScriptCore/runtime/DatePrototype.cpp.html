<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;DatePrototype.h&quot;
  26 
  27 #include &quot;DateConversion.h&quot;
  28 #include &quot;DateInstance.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;JSCBuiltins.h&quot;
  31 #include &quot;JSDateMath.h&quot;
  32 #include &quot;JSGlobalObject.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSString.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;ObjectPrototype.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &lt;limits.h&gt;
  39 #include &lt;locale.h&gt;
  40 #include &lt;math.h&gt;
  41 #include &lt;stdlib.h&gt;
  42 #include &lt;time.h&gt;
  43 #include &lt;wtf/Assertions.h&gt;
  44 #include &lt;wtf/MathExtras.h&gt;
  45 
  46 #if HAVE(LANGINFO_H)
  47 #include &lt;langinfo.h&gt;
  48 #endif
  49 
  50 #if HAVE(SYS_PARAM_H)
  51 #include &lt;sys/param.h&gt;
  52 #endif
  53 
  54 #if HAVE(SYS_TIME_H)
  55 #include &lt;sys/time.h&gt;
  56 #endif
  57 
  58 #if HAVE(SYS_TIMEB_H)
  59 #include &lt;sys/timeb.h&gt;
  60 #endif
  61 
  62 #if !(OS(DARWIN) &amp;&amp; USE(CF))
  63 #include &lt;unicode/udat.h&gt;
  64 #endif
  65 
  66 #if USE(CF)
  67 #include &lt;CoreFoundation/CoreFoundation.h&gt;
  68 #endif
  69 
  70 namespace JSC {
  71 
  72 using namespace WTF;
  73 
  74 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState*);
  75 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState*);
  76 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState*);
  77 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState*);
  78 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState*);
  79 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState*);
  80 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState*);
  81 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState*);
  82 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState*);
  83 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState*);
  84 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState*);
  85 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState*);
  86 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState*);
  87 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState*);
  88 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState*);
  89 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState*);
  90 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState*);
  91 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState*);
  92 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState*);
  93 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState*);
  94 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState*);
  95 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState*);
  96 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState*);
  97 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState*);
  98 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState*);
  99 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState*);
 100 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState*);
 101 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState*);
 102 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState*);
 103 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState*);
 104 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState*);
 105 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState*);
 106 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState*);
 107 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState*);
 108 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState*);
 109 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState*);
 110 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState*);
 111 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState*);
 112 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState*);
 113 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState*);
 114 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState*);
 115 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState*);
 116 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState*);
 117 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState*);
 118 
 119 }
 120 
 121 #include &quot;DatePrototype.lut.h&quot;
 122 
 123 namespace JSC {
 124 
 125 enum LocaleDateTimeFormat { LocaleDateAndTime, LocaleDate, LocaleTime };
 126 
 127 #if OS(DARWIN) &amp;&amp; USE(CF)
 128 
 129 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 130 // Instead we should consider using this whenever USE(CF) is true.
 131 
 132 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 133 {
 134     if (string == &quot;short&quot;)
 135         return kCFDateFormatterShortStyle;
 136     if (string == &quot;medium&quot;)
 137         return kCFDateFormatterMediumStyle;
 138     if (string == &quot;long&quot;)
 139         return kCFDateFormatterLongStyle;
 140     if (string == &quot;full&quot;)
 141         return kCFDateFormatterFullStyle;
 142     return defaultStyle;
 143 }
 144 
 145 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 146 {
 147     VM&amp; vm = exec-&gt;vm();
 148     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 149     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 150 
 151     bool useCustomFormat = false;
 152     String customFormatString;
 153 
 154     String arg0String = exec-&gt;argument(0).toWTFString(exec);
 155     if (arg0String == &quot;custom&quot; &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 156         useCustomFormat = true;
 157         customFormatString = exec-&gt;argument(1).toWTFString(exec);
 158     } else if (format == LocaleDateAndTime &amp;&amp; !exec-&gt;argument(1).isUndefined()) {
 159         dateStyle = styleFromArgString(arg0String, dateStyle);
 160         timeStyle = styleFromArgString(exec-&gt;argument(1).toWTFString(exec), timeStyle);
 161     } else if (format != LocaleTime &amp;&amp; !exec-&gt;argument(0).isUndefined())
 162         dateStyle = styleFromArgString(arg0String, dateStyle);
 163     else if (format != LocaleDate &amp;&amp; !exec-&gt;argument(0).isUndefined())
 164         timeStyle = styleFromArgString(arg0String, timeStyle);
 165 
 166     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 167 
 168     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 169     if (useCustomFormat)
 170         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
 171     return jsNontrivialString(vm, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());
 172 }
 173 
 174 #elif !UCONFIG_NO_FORMATTING
 175 
 176 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)
 177 {
 178     VM&amp; vm = exec-&gt;vm();
 179     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 180     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 181 
 182     UErrorCode status = U_ZERO_ERROR;
 183     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 184     if (!df)
 185         return jsEmptyString(vm);
 186 
 187     UChar buffer[128];
 188     int32_t length;
 189     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 190     udat_close(df);
 191     if (status != U_ZERO_ERROR)
 192         return jsEmptyString(vm);
 193 
 194     return jsNontrivialString(vm, String(buffer, length));
 195 }
 196 
 197 #else
 198 
 199 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)
 200 {
 201     VM&amp; vm = exec-&gt;vm();
 202 #if OS(WINDOWS)
 203     SYSTEMTIME systemTime;
 204     memset(&amp;systemTime, 0, sizeof(systemTime));
 205     systemTime.wYear = gdt.year();
 206     systemTime.wMonth = gdt.month() + 1;
 207     systemTime.wDay = gdt.monthDay();
 208     systemTime.wDayOfWeek = gdt.weekDay();
 209     systemTime.wHour = gdt.hour();
 210     systemTime.wMinute = gdt.minute();
 211     systemTime.wSecond = gdt.second();
 212 
 213     Vector&lt;UChar, 128&gt; buffer;
 214     size_t length = 0;
 215 
 216     if (format == LocaleDate) {
 217         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 218         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 219     } else if (format == LocaleTime) {
 220         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 221         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 222     } else if (format == LocaleDateAndTime) {
 223         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 224         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 225         if (length) {
 226             buffer[length - 1] = &#39; &#39;;
 227             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 228         }
 229     } else
 230         RELEASE_ASSERT_NOT_REACHED();
 231 
 232     //  Remove terminating null character.
 233     if (length)
 234         length--;
 235 
 236     return jsNontrivialString(vm, String(buffer.data(), length));
 237 
 238 #else // OS(WINDOWS)
 239 
 240 #if HAVE(LANGINFO_H)
 241     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 242 #else
 243     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 244 #endif
 245 
 246     // Offset year if needed
 247     struct tm localTM = gdt;
 248     int year = gdt.year();
 249     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 250     if (yearNeedsOffset)
 251         localTM.tm_year = equivalentYearForDST(year) - 1900;
 252 
 253 #if HAVE(LANGINFO_H)
 254     // We do not allow strftime to generate dates with 2-digits years,
 255     // both to avoid ambiguity, and a crash in strncpy, for years that
 256     // need offset.
 257     char* formatString = strdup(nl_langinfo(formats[format]));
 258     char* yPos = strchr(formatString, &#39;y&#39;);
 259     if (yPos)
 260         *yPos = &#39;Y&#39;;
 261 #endif
 262 
 263     // Do the formatting
 264     const int bufsize = 128;
 265     char timebuffer[bufsize];
 266 
 267 #if HAVE(LANGINFO_H)
 268     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 269     free(formatString);
 270 #else
 271     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 272 #endif
 273 
 274     if (ret == 0)
 275         return jsEmptyString(vm);
 276 
 277     // Copy original into the buffer
 278     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 279         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 280         char yearString[yearLen];
 281 
 282         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 283         char* yearLocation = strstr(timebuffer, yearString);
 284         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 285 
 286         strncpy(yearLocation, yearString, yearLen - 1);
 287     }
 288 
 289     // Convert multi-byte result to UNICODE.
 290     // If __STDC_ISO_10646__ is defined, wide character represents
 291     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 292     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 293     // and wide character represents UTF-32 code point.
 294     // Here we static_cast potential UTF-32 to UTF-16, it should be
 295     // safe because date and (or) time related characters in different languages
 296     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 297     // back on using multi-byte result as-is.
 298 #ifdef __STDC_ISO_10646__
 299     UChar buffer[bufsize];
 300     wchar_t tempbuffer[bufsize];
 301     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 302     if (length != static_cast&lt;size_t&gt;(-1)) {
 303         for (size_t i = 0; i &lt; length; ++i)
 304             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
 305         return jsNontrivialString(vm, String(buffer, length));
 306     }
 307 #endif
 308 
 309     return jsNontrivialString(vm, timebuffer);
 310 #endif // OS(WINDOWS)
 311 }
 312 
 313 static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, double, LocaleDateTimeFormat format)
 314 {
 315     VM&amp; vm = exec-&gt;vm();
 316     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(exec);
 317     if (!gregorianDateTime)
 318         return jsNontrivialString(vm, &quot;Invalid Date&quot;_s);
 319     return formatLocaleDate(exec, *gregorianDateTime, format);
 320 }
 321 
 322 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 323 
 324 static EncodedJSValue formateDateInstance(ExecState* exec, DateTimeFormat format, bool asUTCVariant)
 325 {
 326     VM&amp; vm = exec-&gt;vm();
 327     auto scope = DECLARE_THROW_SCOPE(vm);
 328     JSValue thisValue = exec-&gt;thisValue();
 329     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 330     if (UNLIKELY(!thisDateObj))
 331         return throwVMTypeError(exec, scope);
 332 
 333     const GregorianDateTime* gregorianDateTime = asUTCVariant
 334         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 335         : thisDateObj-&gt;gregorianDateTime(exec);
 336     if (!gregorianDateTime)
 337         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 338 
 339     return JSValue::encode(jsNontrivialString(vm, formatDateTime(*gregorianDateTime, format, asUTCVariant)));
 340 }
 341 
 342 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 343 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 344 //
 345 // Format of member function: f([hour,] [min,] [sec,] [ms])
 346 static bool fillStructuresUsingTimeArgs(ExecState* exec, int maxArgs, double* ms, GregorianDateTime* t)
 347 {
 348     VM&amp; vm = exec-&gt;vm();
 349     auto scope = DECLARE_THROW_SCOPE(vm);
 350 
 351     double milliseconds = 0;
 352     bool ok = true;
 353     int idx = 0;
 354     int numArgs = exec-&gt;argumentCount();
 355 
 356     // JS allows extra trailing arguments -- ignore them
 357     if (numArgs &gt; maxArgs)
 358         numArgs = maxArgs;
 359 
 360     // hours
 361     if (maxArgs &gt;= 4 &amp;&amp; idx &lt; numArgs) {
 362         t-&gt;setHour(0);
 363         double hours = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 364         RETURN_IF_EXCEPTION(scope, false);
 365         ok = std::isfinite(hours);
 366         milliseconds += hours * msPerHour;
 367     }
 368 
 369     // minutes
 370     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 371         t-&gt;setMinute(0);
 372         double minutes = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 373         RETURN_IF_EXCEPTION(scope, false);
 374         ok = std::isfinite(minutes);
 375         milliseconds += minutes * msPerMinute;
 376     }
 377 
 378     // seconds
 379     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 380         t-&gt;setSecond(0);
 381         double seconds = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 382         RETURN_IF_EXCEPTION(scope, false);
 383         ok = std::isfinite(seconds);
 384         milliseconds += seconds * msPerSecond;
 385     }
 386 
 387     if (!ok)
 388         return false;
 389 
 390     // milliseconds
 391     if (idx &lt; numArgs) {
 392         double millis = exec-&gt;uncheckedArgument(idx).toIntegerPreserveNaN(exec);
 393         RETURN_IF_EXCEPTION(scope, false);
 394         ok = std::isfinite(millis);
 395         milliseconds += millis;
 396     } else
 397         milliseconds += *ms;
 398 
 399     *ms = milliseconds;
 400     return ok;
 401 }
 402 
 403 // Converts a list of arguments sent to a Date member function into years, months, and milliseconds, updating
 404 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 405 //
 406 // Format of member function: f([years,] [months,] [days])
 407 static bool fillStructuresUsingDateArgs(ExecState *exec, int maxArgs, double *ms, GregorianDateTime *t)
 408 {
 409     VM&amp; vm = exec-&gt;vm();
 410     auto scope = DECLARE_THROW_SCOPE(vm);
 411 
 412     int idx = 0;
 413     bool ok = true;
 414     int numArgs = exec-&gt;argumentCount();
 415 
 416     // JS allows extra trailing arguments -- ignore them
 417     if (numArgs &gt; maxArgs)
 418         numArgs = maxArgs;
 419 
 420     // years
 421     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs) {
 422         double years = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 423         RETURN_IF_EXCEPTION(scope, false);
 424         ok = std::isfinite(years);
 425         t-&gt;setYear(toInt32(years));
 426     }
 427     // months
 428     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 429         double months = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 430         RETURN_IF_EXCEPTION(scope, false);
 431         ok = std::isfinite(months);
 432         t-&gt;setMonth(toInt32(months));
 433     }
 434     // days
 435     if (idx &lt; numArgs &amp;&amp; ok) {
 436         double days = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);
 437         RETURN_IF_EXCEPTION(scope, false);
 438         ok = std::isfinite(days);
 439         t-&gt;setMonthDay(0);
 440         *ms += days * msPerDay;
 441     }
 442 
 443     return ok;
 444 }
 445 
 446 const ClassInfo DatePrototype::s_info = {&quot;Object&quot;, &amp;JSNonFinalObject::s_info, &amp;dateTable, nullptr, CREATE_METHOD_TABLE(DatePrototype)};
 447 
 448 /* Source for DatePrototype.lut.h
 449 @begin dateTable
 450   toString              dateProtoFuncToString                DontEnum|Function       0
 451   toISOString           dateProtoFuncToISOString             DontEnum|Function       0
 452   toDateString          dateProtoFuncToDateString            DontEnum|Function       0
 453   toTimeString          dateProtoFuncToTimeString            DontEnum|Function       0
 454   toLocaleString        dateProtoFuncToLocaleString          DontEnum|Function       0
 455   toLocaleDateString    dateProtoFuncToLocaleDateString      DontEnum|Function       0
 456   toLocaleTimeString    dateProtoFuncToLocaleTimeString      DontEnum|Function       0
 457   valueOf               dateProtoFuncGetTime                 DontEnum|Function       0
 458   getTime               dateProtoFuncGetTime                 DontEnum|Function       0
 459   getFullYear           dateProtoFuncGetFullYear             DontEnum|Function       0
 460   getUTCFullYear        dateProtoFuncGetUTCFullYear          DontEnum|Function       0
 461   getMonth              dateProtoFuncGetMonth                DontEnum|Function       0
 462   getUTCMonth           dateProtoFuncGetUTCMonth             DontEnum|Function       0
 463   getDate               dateProtoFuncGetDate                 DontEnum|Function       0
 464   getUTCDate            dateProtoFuncGetUTCDate              DontEnum|Function       0
 465   getDay                dateProtoFuncGetDay                  DontEnum|Function       0
 466   getUTCDay             dateProtoFuncGetUTCDay               DontEnum|Function       0
 467   getHours              dateProtoFuncGetHours                DontEnum|Function       0
 468   getUTCHours           dateProtoFuncGetUTCHours             DontEnum|Function       0
 469   getMinutes            dateProtoFuncGetMinutes              DontEnum|Function       0
 470   getUTCMinutes         dateProtoFuncGetUTCMinutes           DontEnum|Function       0
 471   getSeconds            dateProtoFuncGetSeconds              DontEnum|Function       0
 472   getUTCSeconds         dateProtoFuncGetUTCSeconds           DontEnum|Function       0
 473   getMilliseconds       dateProtoFuncGetMilliSeconds         DontEnum|Function       0
 474   getUTCMilliseconds    dateProtoFuncGetUTCMilliseconds      DontEnum|Function       0
 475   getTimezoneOffset     dateProtoFuncGetTimezoneOffset       DontEnum|Function       0
 476   setTime               dateProtoFuncSetTime                 DontEnum|Function       1
 477   setMilliseconds       dateProtoFuncSetMilliSeconds         DontEnum|Function       1
 478   setUTCMilliseconds    dateProtoFuncSetUTCMilliseconds      DontEnum|Function       1
 479   setSeconds            dateProtoFuncSetSeconds              DontEnum|Function       2
 480   setUTCSeconds         dateProtoFuncSetUTCSeconds           DontEnum|Function       2
 481   setMinutes            dateProtoFuncSetMinutes              DontEnum|Function       3
 482   setUTCMinutes         dateProtoFuncSetUTCMinutes           DontEnum|Function       3
 483   setHours              dateProtoFuncSetHours                DontEnum|Function       4
 484   setUTCHours           dateProtoFuncSetUTCHours             DontEnum|Function       4
 485   setDate               dateProtoFuncSetDate                 DontEnum|Function       1
 486   setUTCDate            dateProtoFuncSetUTCDate              DontEnum|Function       1
 487   setMonth              dateProtoFuncSetMonth                DontEnum|Function       2
 488   setUTCMonth           dateProtoFuncSetUTCMonth             DontEnum|Function       2
 489   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 490   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 491   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
 492   getYear               dateProtoFuncGetYear                 DontEnum|Function       0
 493   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 494 @end
 495 */
 496 
 497 // ECMA 15.9.4
 498 
 499 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 500     : Base(vm, structure)
 501 {
 502 }
 503 
 504 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 505 {
 506     Base::finishCreation(vm);
 507     ASSERT(inherits(vm, info()));
 508 
 509     Identifier toUTCStringName = Identifier::fromString(vm, &quot;toUTCString&quot;_s);
 510     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 511     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 512     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 513 
 514 #if ENABLE(INTL)
 515     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 516     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 517     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 518 #endif
 519 
 520     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 521     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 522 
 523     // The constructor will be added later, after DateConstructor has been built.
 524 }
 525 
 526 // Functions
 527 
 528 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState* exec)
 529 {
 530     const bool asUTCVariant = false;
 531     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 532 }
 533 
 534 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState* exec)
 535 {
 536     const bool asUTCVariant = true;
 537     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);
 538 }
 539 
 540 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState* exec)
 541 {
 542     VM&amp; vm = exec-&gt;vm();
 543     auto scope = DECLARE_THROW_SCOPE(vm);
 544     JSValue thisValue = exec-&gt;thisValue();
 545     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 546     if (UNLIKELY(!thisDateObj))
 547         return throwVMTypeError(exec, scope);
 548 
 549     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
 550         return throwVMError(exec, scope, createRangeError(exec, &quot;Invalid Date&quot;_s));
 551 
 552     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 553     if (!gregorianDateTime)
 554         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 555     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 556     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 557     char buffer[28];
 558     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 559     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 560     if (ms &lt; 0)
 561         ms += msPerSecond;
 562 
 563     int charactersWritten;
 564     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 565         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 566     else
 567         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 568 
 569     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 570     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
 571         return JSValue::encode(jsEmptyString(vm));
 572 
 573     return JSValue::encode(jsNontrivialString(vm, String(buffer, charactersWritten)));
 574 }
 575 
 576 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState* exec)
 577 {
 578     const bool asUTCVariant = false;
 579     return formateDateInstance(exec, DateTimeFormatDate, asUTCVariant);
 580 }
 581 
 582 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState* exec)
 583 {
 584     const bool asUTCVariant = false;
 585     return formateDateInstance(exec, DateTimeFormatTime, asUTCVariant);
 586 }
 587 
 588 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState* exec)
 589 {
 590     VM&amp; vm = exec-&gt;vm();
 591     auto scope = DECLARE_THROW_SCOPE(vm);
 592     JSValue thisValue = exec-&gt;thisValue();
 593     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 594     if (UNLIKELY(!thisDateObj))
 595         return throwVMTypeError(exec, scope);
 596 
 597     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDateAndTime));
 598 }
 599 
 600 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState* exec)
 601 {
 602     VM&amp; vm = exec-&gt;vm();
 603     auto scope = DECLARE_THROW_SCOPE(vm);
 604     JSValue thisValue = exec-&gt;thisValue();
 605     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 606     if (UNLIKELY(!thisDateObj))
 607         return throwVMTypeError(exec, scope);
 608 
 609     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDate));
 610 }
 611 
 612 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState* exec)
 613 {
 614     VM&amp; vm = exec-&gt;vm();
 615     auto scope = DECLARE_THROW_SCOPE(vm);
 616     JSValue thisValue = exec-&gt;thisValue();
 617     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 618     if (UNLIKELY(!thisDateObj))
 619         return throwVMTypeError(exec, scope);
 620 
 621     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleTime));
 622 }
 623 
 624 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState* exec)
 625 {
 626     VM&amp; vm = exec-&gt;vm();
 627     auto scope = DECLARE_THROW_SCOPE(vm);
 628     JSValue thisValue = exec-&gt;thisValue();
 629     if (!thisValue.isObject())
 630         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected |this| to be an object.&quot;);
 631     JSObject* thisObject = jsCast&lt;JSObject*&gt;(thisValue);
 632 
 633     if (!exec-&gt;argumentCount())
 634         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected a first argument.&quot;);
 635 
 636     JSValue hintValue = exec-&gt;uncheckedArgument(0);
 637     PreferredPrimitiveType type = toPreferredPrimitiveType(exec, hintValue);
 638     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 639 
 640     if (type == NoPreference)
 641         type = PreferString;
 642 
 643     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;ordinaryToPrimitive(exec, type)));
 644 }
 645 
 646 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTime(ExecState* exec)
 647 {
 648     VM&amp; vm = exec-&gt;vm();
 649     auto scope = DECLARE_THROW_SCOPE(vm);
 650     JSValue thisValue = exec-&gt;thisValue();
 651     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 652     if (UNLIKELY(!thisDateObj))
 653         return throwVMTypeError(exec, scope);
 654 
 655     return JSValue::encode(jsNumber(thisDateObj-&gt;internalNumber()));
 656 }
 657 
 658 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState* exec)
 659 {
 660     VM&amp; vm = exec-&gt;vm();
 661     auto scope = DECLARE_THROW_SCOPE(vm);
 662     JSValue thisValue = exec-&gt;thisValue();
 663     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 664     if (UNLIKELY(!thisDateObj))
 665         return throwVMTypeError(exec, scope);
 666 
 667     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 668     if (!gregorianDateTime)
 669         return JSValue::encode(jsNaN());
 670     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 671 }
 672 
 673 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState* exec)
 674 {
 675     VM&amp; vm = exec-&gt;vm();
 676     auto scope = DECLARE_THROW_SCOPE(vm);
 677     JSValue thisValue = exec-&gt;thisValue();
 678     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 679     if (UNLIKELY(!thisDateObj))
 680         return throwVMTypeError(exec, scope);
 681 
 682     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 683     if (!gregorianDateTime)
 684         return JSValue::encode(jsNaN());
 685     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 686 }
 687 
 688 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState* exec)
 689 {
 690     VM&amp; vm = exec-&gt;vm();
 691     auto scope = DECLARE_THROW_SCOPE(vm);
 692     JSValue thisValue = exec-&gt;thisValue();
 693     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 694     if (UNLIKELY(!thisDateObj))
 695         return throwVMTypeError(exec, scope);
 696 
 697     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 698     if (!gregorianDateTime)
 699         return JSValue::encode(jsNaN());
 700     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 701 }
 702 
 703 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState* exec)
 704 {
 705     VM&amp; vm = exec-&gt;vm();
 706     auto scope = DECLARE_THROW_SCOPE(vm);
 707     JSValue thisValue = exec-&gt;thisValue();
 708     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 709     if (UNLIKELY(!thisDateObj))
 710         return throwVMTypeError(exec, scope);
 711 
 712     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 713     if (!gregorianDateTime)
 714         return JSValue::encode(jsNaN());
 715     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 716 }
 717 
 718 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState* exec)
 719 {
 720     VM&amp; vm = exec-&gt;vm();
 721     auto scope = DECLARE_THROW_SCOPE(vm);
 722     JSValue thisValue = exec-&gt;thisValue();
 723     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 724     if (UNLIKELY(!thisDateObj))
 725         return throwVMTypeError(exec, scope);
 726 
 727     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 728     if (!gregorianDateTime)
 729         return JSValue::encode(jsNaN());
 730     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 731 }
 732 
 733 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState* exec)
 734 {
 735     VM&amp; vm = exec-&gt;vm();
 736     auto scope = DECLARE_THROW_SCOPE(vm);
 737     JSValue thisValue = exec-&gt;thisValue();
 738     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 739     if (UNLIKELY(!thisDateObj))
 740         return throwVMTypeError(exec, scope);
 741 
 742     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 743     if (!gregorianDateTime)
 744         return JSValue::encode(jsNaN());
 745     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 746 }
 747 
 748 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState* exec)
 749 {
 750     VM&amp; vm = exec-&gt;vm();
 751     auto scope = DECLARE_THROW_SCOPE(vm);
 752     JSValue thisValue = exec-&gt;thisValue();
 753     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 754     if (UNLIKELY(!thisDateObj))
 755         return throwVMTypeError(exec, scope);
 756 
 757     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 758     if (!gregorianDateTime)
 759         return JSValue::encode(jsNaN());
 760     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 761 }
 762 
 763 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState* exec)
 764 {
 765     VM&amp; vm = exec-&gt;vm();
 766     auto scope = DECLARE_THROW_SCOPE(vm);
 767     JSValue thisValue = exec-&gt;thisValue();
 768     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 769     if (UNLIKELY(!thisDateObj))
 770         return throwVMTypeError(exec, scope);
 771 
 772     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 773     if (!gregorianDateTime)
 774         return JSValue::encode(jsNaN());
 775     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 776 }
 777 
 778 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState* exec)
 779 {
 780     VM&amp; vm = exec-&gt;vm();
 781     auto scope = DECLARE_THROW_SCOPE(vm);
 782     JSValue thisValue = exec-&gt;thisValue();
 783     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 784     if (UNLIKELY(!thisDateObj))
 785         return throwVMTypeError(exec, scope);
 786 
 787     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 788     if (!gregorianDateTime)
 789         return JSValue::encode(jsNaN());
 790     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 791 }
 792 
 793 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState* exec)
 794 {
 795     VM&amp; vm = exec-&gt;vm();
 796     auto scope = DECLARE_THROW_SCOPE(vm);
 797     JSValue thisValue = exec-&gt;thisValue();
 798     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 799     if (UNLIKELY(!thisDateObj))
 800         return throwVMTypeError(exec, scope);
 801 
 802     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 803     if (!gregorianDateTime)
 804         return JSValue::encode(jsNaN());
 805     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 806 }
 807 
 808 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState* exec)
 809 {
 810     VM&amp; vm = exec-&gt;vm();
 811     auto scope = DECLARE_THROW_SCOPE(vm);
 812     JSValue thisValue = exec-&gt;thisValue();
 813     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 814     if (UNLIKELY(!thisDateObj))
 815         return throwVMTypeError(exec, scope);
 816 
 817     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 818     if (!gregorianDateTime)
 819         return JSValue::encode(jsNaN());
 820     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 821 }
 822 
 823 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState* exec)
 824 {
 825     VM&amp; vm = exec-&gt;vm();
 826     auto scope = DECLARE_THROW_SCOPE(vm);
 827     JSValue thisValue = exec-&gt;thisValue();
 828     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 829     if (UNLIKELY(!thisDateObj))
 830         return throwVMTypeError(exec, scope);
 831 
 832     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 833     if (!gregorianDateTime)
 834         return JSValue::encode(jsNaN());
 835     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 836 }
 837 
 838 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState* exec)
 839 {
 840     VM&amp; vm = exec-&gt;vm();
 841     auto scope = DECLARE_THROW_SCOPE(vm);
 842     JSValue thisValue = exec-&gt;thisValue();
 843     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 844     if (UNLIKELY(!thisDateObj))
 845         return throwVMTypeError(exec, scope);
 846 
 847     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 848     if (!gregorianDateTime)
 849         return JSValue::encode(jsNaN());
 850     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 851 }
 852 
 853 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState* exec)
 854 {
 855     VM&amp; vm = exec-&gt;vm();
 856     auto scope = DECLARE_THROW_SCOPE(vm);
 857     JSValue thisValue = exec-&gt;thisValue();
 858     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 859     if (UNLIKELY(!thisDateObj))
 860         return throwVMTypeError(exec, scope);
 861 
 862     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);
 863     if (!gregorianDateTime)
 864         return JSValue::encode(jsNaN());
 865     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 866 }
 867 
 868 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState* exec)
 869 {
 870     VM&amp; vm = exec-&gt;vm();
 871     auto scope = DECLARE_THROW_SCOPE(vm);
 872     JSValue thisValue = exec-&gt;thisValue();
 873     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 874     if (UNLIKELY(!thisDateObj))
 875         return throwVMTypeError(exec, scope);
 876 
 877     double milli = thisDateObj-&gt;internalNumber();
 878     if (std::isnan(milli))
 879         return JSValue::encode(jsNaN());
 880 
 881     double secs = floor(milli / msPerSecond);
 882     double ms = milli - secs * msPerSecond;
 883     return JSValue::encode(jsNumber(ms));
 884 }
 885 
 886 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState* exec)
 887 {
 888     VM&amp; vm = exec-&gt;vm();
 889     auto scope = DECLARE_THROW_SCOPE(vm);
 890     JSValue thisValue = exec-&gt;thisValue();
 891     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 892     if (UNLIKELY(!thisDateObj))
 893         return throwVMTypeError(exec, scope);
 894 
 895     double milli = thisDateObj-&gt;internalNumber();
 896     if (std::isnan(milli))
 897         return JSValue::encode(jsNaN());
 898 
 899     double secs = floor(milli / msPerSecond);
 900     double ms = milli - secs * msPerSecond;
 901     return JSValue::encode(jsNumber(ms));
 902 }
 903 
 904 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState* exec)
 905 {
 906     VM&amp; vm = exec-&gt;vm();
 907     auto scope = DECLARE_THROW_SCOPE(vm);
 908     JSValue thisValue = exec-&gt;thisValue();
 909     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 910     if (UNLIKELY(!thisDateObj))
 911         return throwVMTypeError(exec, scope);
 912 
 913     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
 914     if (!gregorianDateTime)
 915         return JSValue::encode(jsNaN());
 916     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffset() / minutesPerHour));
 917 }
 918 
 919 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState* exec)
 920 {
 921     VM&amp; vm = exec-&gt;vm();
 922     auto scope = DECLARE_THROW_SCOPE(vm);
 923     JSValue thisValue = exec-&gt;thisValue();
 924     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 925     if (UNLIKELY(!thisDateObj))
 926         return throwVMTypeError(exec, scope);
 927 
 928     double milli = timeClip(exec-&gt;argument(0).toNumber(exec));
 929     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 930     thisDateObj-&gt;setInternalNumber(milli);
 931     return JSValue::encode(jsNumber(milli));
 932 }
 933 
 934 static EncodedJSValue setNewValueFromTimeArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)
 935 {
 936     VM&amp; vm = exec-&gt;vm();
 937     auto scope = DECLARE_THROW_SCOPE(vm);
 938     JSValue thisValue = exec-&gt;thisValue();
 939     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 940     if (UNLIKELY(!thisDateObj))
 941         return throwVMTypeError(exec, scope);
 942 
 943     double milli = thisDateObj-&gt;internalNumber();
 944 
 945     if (!exec-&gt;argumentCount() || std::isnan(milli)) {
 946         thisDateObj-&gt;setInternalNumber(PNaN);
 947         return JSValue::encode(jsNaN());
 948     }
 949 
 950     double secs = floor(milli / msPerSecond);
 951     double ms = milli - secs * msPerSecond;
 952 
 953     const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 954         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 955         : thisDateObj-&gt;gregorianDateTime(exec);
 956     if (!other)
 957         return JSValue::encode(jsNaN());
 958 
 959     GregorianDateTime gregorianDateTime;
 960     gregorianDateTime.copyFrom(*other);
 961     bool success = fillStructuresUsingTimeArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
 962     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 963     if (!success) {
 964         thisDateObj-&gt;setInternalNumber(PNaN);
 965         return JSValue::encode(jsNaN());
 966     }
 967 
 968     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
 969     double result = timeClip(newUTCDate);
 970     thisDateObj-&gt;setInternalNumber(result);
 971     return JSValue::encode(jsNumber(result));
 972 }
 973 
 974 static EncodedJSValue setNewValueFromDateArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)
 975 {
 976     VM&amp; vm = exec-&gt;vm();
 977     auto scope = DECLARE_THROW_SCOPE(vm);
 978     JSValue thisValue = exec-&gt;thisValue();
 979     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 980     if (UNLIKELY(!thisDateObj))
 981         return throwVMTypeError(exec, scope);
 982 
 983     if (!exec-&gt;argumentCount()) {
 984         thisDateObj-&gt;setInternalNumber(PNaN);
 985         return JSValue::encode(jsNaN());
 986     }
 987 
 988     double milli = thisDateObj-&gt;internalNumber();
 989     double ms = 0;
 990 
 991     GregorianDateTime gregorianDateTime;
 992     if (numArgsToUse == 3 &amp;&amp; std::isnan(milli))
 993         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
 994     else {
 995         ms = milli - floor(milli / msPerSecond) * msPerSecond;
 996         const GregorianDateTime* other = inputTimeType == WTF::UTCTime
 997             ? thisDateObj-&gt;gregorianDateTimeUTC(exec)
 998             : thisDateObj-&gt;gregorianDateTime(exec);
 999         if (!other)
1000             return JSValue::encode(jsNaN());
1001         gregorianDateTime.copyFrom(*other);
1002     }
1003 
1004     bool success = fillStructuresUsingDateArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);
1005     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1006     if (!success) {
1007         thisDateObj-&gt;setInternalNumber(PNaN);
1008         return JSValue::encode(jsNaN());
1009     }
1010 
1011     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
1012     double result = timeClip(newUTCDate);
1013     thisDateObj-&gt;setInternalNumber(result);
1014     return JSValue::encode(jsNumber(result));
1015 }
1016 
1017 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState* exec)
1018 {
1019     return setNewValueFromTimeArgs(exec, 1, WTF::LocalTime);
1020 }
1021 
1022 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState* exec)
1023 {
1024     return setNewValueFromTimeArgs(exec, 1, WTF::UTCTime);
1025 }
1026 
1027 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState* exec)
1028 {
1029     return setNewValueFromTimeArgs(exec, 2, WTF::LocalTime);
1030 }
1031 
1032 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState* exec)
1033 {
1034     return setNewValueFromTimeArgs(exec, 2, WTF::UTCTime);
1035 }
1036 
1037 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState* exec)
1038 {
1039     return setNewValueFromTimeArgs(exec, 3, WTF::LocalTime);
1040 }
1041 
1042 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState* exec)
1043 {
1044     return setNewValueFromTimeArgs(exec, 3, WTF::UTCTime);
1045 }
1046 
1047 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState* exec)
1048 {
1049     return setNewValueFromTimeArgs(exec, 4, WTF::LocalTime);
1050 }
1051 
1052 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState* exec)
1053 {
1054     return setNewValueFromTimeArgs(exec, 4, WTF::UTCTime);
1055 }
1056 
1057 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState* exec)
1058 {
1059     return setNewValueFromDateArgs(exec, 1, WTF::LocalTime);
1060 }
1061 
1062 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState* exec)
1063 {
1064     return setNewValueFromDateArgs(exec, 1, WTF::UTCTime);
1065 }
1066 
1067 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState* exec)
1068 {
1069     return setNewValueFromDateArgs(exec, 2, WTF::LocalTime);
1070 }
1071 
1072 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState* exec)
1073 {
1074     return setNewValueFromDateArgs(exec, 2, WTF::UTCTime);
1075 }
1076 
1077 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState* exec)
1078 {
1079     return setNewValueFromDateArgs(exec, 3, WTF::LocalTime);
1080 }
1081 
1082 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState* exec)
1083 {
1084     return setNewValueFromDateArgs(exec, 3, WTF::UTCTime);
1085 }
1086 
1087 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState* exec)
1088 {
1089     VM&amp; vm = exec-&gt;vm();
1090     auto scope = DECLARE_THROW_SCOPE(vm);
1091     JSValue thisValue = exec-&gt;thisValue();
1092     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1093     if (UNLIKELY(!thisDateObj))
1094         return throwVMTypeError(exec, scope);
1095 
1096     if (!exec-&gt;argumentCount()) {
1097         thisDateObj-&gt;setInternalNumber(PNaN);
1098         return JSValue::encode(jsNaN());
1099     }
1100 
1101     double milli = thisDateObj-&gt;internalNumber();
1102     double ms = 0;
1103 
1104     GregorianDateTime gregorianDateTime;
1105     if (std::isnan(milli))
1106         // Based on ECMA 262 B.2.5 (setYear)
1107         // the time must be reset to +0 if it is NaN.
1108         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
1109     else {
1110         double secs = floor(milli / msPerSecond);
1111         ms = milli - secs * msPerSecond;
1112         if (const GregorianDateTime* other = thisDateObj-&gt;gregorianDateTime(exec))
1113             gregorianDateTime.copyFrom(*other);
1114     }
1115 
1116     double year = exec-&gt;argument(0).toIntegerPreserveNaN(exec);
1117     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1118     if (!std::isfinite(year)) {
1119         thisDateObj-&gt;setInternalNumber(PNaN);
1120         return JSValue::encode(jsNaN());
1121     }
1122 
1123     gregorianDateTime.setYear(toInt32((year &gt;= 0 &amp;&amp; year &lt;= 99) ? (year + 1900) : year));
1124     double timeInMilliseconds = gregorianDateTimeToMS(vm, gregorianDateTime, ms, WTF::LocalTime);
1125     double result = timeClip(timeInMilliseconds);
1126     thisDateObj-&gt;setInternalNumber(result);
1127     return JSValue::encode(jsNumber(result));
1128 }
1129 
1130 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState* exec)
1131 {
1132     VM&amp; vm = exec-&gt;vm();
1133     auto scope = DECLARE_THROW_SCOPE(vm);
1134     JSValue thisValue = exec-&gt;thisValue();
1135     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1136     if (UNLIKELY(!thisDateObj))
1137         return throwVMTypeError(exec, scope);
1138 
1139     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);
1140     if (!gregorianDateTime)
1141         return JSValue::encode(jsNaN());
1142 
1143     // NOTE: IE returns the full year even in getYear.
1144     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));
1145 }
1146 
1147 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState* exec)
1148 {
1149     VM&amp; vm = exec-&gt;vm();
1150     auto scope = DECLARE_THROW_SCOPE(vm);
1151     JSValue thisValue = exec-&gt;thisValue();
1152     JSObject* object = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
1155     JSValue timeValue = object-&gt;toPrimitive(exec, PreferNumber);
1156     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1157     if (timeValue.isNumber() &amp;&amp; !(timeValue.isInt32() || std::isfinite(timeValue.asDouble())))
1158         return JSValue::encode(jsNull());
1159 
1160     JSValue toISOValue = object-&gt;get(exec, vm.propertyNames-&gt;toISOString);
1161     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1162 
1163     CallData callData;
1164     CallType callType = getCallData(vm, toISOValue, callData);
1165     if (callType == CallType::None)
1166         return throwVMTypeError(exec, scope, &quot;toISOString is not a function&quot;_s);
1167 
1168     JSValue result = call(exec, asObject(toISOValue), callType, callData, object, *vm.emptyList);
1169     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1170     return JSValue::encode(result);
1171 }
1172 
1173 } // namespace JSC
    </pre>
  </body>
</html>