<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBRequestCompletionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;IDBCursorWithValue.h&quot;
  39 #include &quot;IDBDatabase.h&quot;
  40 #include &quot;IDBError.h&quot;
  41 #include &quot;IDBGetRecordData.h&quot;
  42 #include &quot;IDBIndex.h&quot;
  43 #include &quot;IDBIterateCursorData.h&quot;
  44 #include &quot;IDBKeyData.h&quot;
  45 #include &quot;IDBKeyRangeData.h&quot;
  46 #include &quot;IDBObjectStore.h&quot;
  47 #include &quot;IDBOpenDBRequest.h&quot;
  48 #include &quot;IDBRequest.h&quot;
  49 #include &quot;IDBResultData.h&quot;
  50 #include &quot;IDBValue.h&quot;
  51 #include &quot;JSDOMWindowBase.h&quot;
  52 #include &quot;Logging.h&quot;
  53 #include &quot;ScriptExecutionContext.h&quot;
  54 #include &quot;ScriptState.h&quot;
  55 #include &quot;SerializedScriptValue.h&quot;
  56 #include &quot;TransactionOperation.h&quot;
  57 #include &lt;wtf/CompletionHandler.h&gt;

  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 


  62 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  63 
  64 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  65 {
  66     return adoptRef(*new IDBTransaction(database, info, nullptr));
  67 }
  68 
  69 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  70 {
  71     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  72 }
  73 
  74 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  75     : IDBActiveDOMObject(database.scriptExecutionContext())
  76     , m_database(database)
  77     , m_info(info)
  78     , m_pendingOperationTimer(*this, &amp;IDBTransaction::pendingOperationTimerFired)
  79     , m_completedOperationTimer(*this, &amp;IDBTransaction::completedOperationTimerFired)
  80     , m_openDBRequest(request)
  81     , m_currentlyCompletingRequest(request)
</pre>
<hr />
<pre>
 159 
 160     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 161         return makeRef(*store);
 162 
 163     bool found = false;
 164     for (auto&amp; objectStore : m_info.objectStores()) {
 165         if (objectStore == objectStoreName) {
 166             found = true;
 167             break;
 168         }
 169     }
 170 
 171     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 172     if (!info)
 173         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 174 
 175     // Version change transactions are scoped to every object store in the database.
 176     if (!info || (!found &amp;&amp; !isVersionChange()))
 177         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 178 
<span class="line-modified"> 179     auto objectStore = std::make_unique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);</span>
 180     auto* rawObjectStore = objectStore.get();
 181     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 182 
 183     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 184 }
 185 
 186 
 187 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 188 {
 189     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
 190     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 191 
 192     if (isFinishedOrFinishing())
 193         return;
 194 
 195     m_domError = &amp;error;
 196     internalAbort();
 197 }
 198 
 199 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
</pre>
<hr />
<pre>
 311 
 312     m_abortQueue.clear();
 313     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 314     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 315 }
 316 
 317 const char* IDBTransaction::activeDOMObjectName() const
 318 {
 319     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 320     return &quot;IDBTransaction&quot;;
 321 }
 322 
 323 bool IDBTransaction::canSuspendForDocumentSuspension() const
 324 {
 325     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 326     return false;
 327 }
 328 
 329 bool IDBTransaction::hasPendingActivity() const
 330 {
<span class="line-modified"> 331     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current() || mayBeGCThread());</span>
 332     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 333 }
 334 
 335 void IDBTransaction::stop()
 336 {
 337     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
 338     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 339 
 340     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 341     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 342     if (m_contextStopped)
 343         return;
 344 
 345     removeAllEventListeners();
 346 
 347     m_contextStopped = true;
 348 
 349     if (isVersionChange())
 350         m_openDBRequest = nullptr;
 351 
</pre>
<hr />
<pre>
 426         operation-&gt;perform();
 427 
 428         if (!operation-&gt;nextRequestCanGoToServer())
 429             break;
 430 
 431     }
 432 
 433     if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())
 434         return;
 435 
 436     if (!isFinishedOrFinishing())
 437         commit();
 438 }
 439 
 440 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)
 441 {
 442     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 443     ASSERT(&amp;operation.originThread() == &amp;Thread::current());
 444 
 445     m_completedOnServerQueue.append({ &amp;operation, data });
<span class="line-modified"> 446     scheduleCompletedOperationTimer();</span>


 447 }
 448 
 449 void IDBTransaction::scheduleCompletedOperationTimer()
 450 {
 451     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 452 
 453     if (!m_completedOperationTimer.isActive())
 454         m_completedOperationTimer.startOneShot(0_s);
 455 }
 456 
 457 void IDBTransaction::completedOperationTimerFired()
 458 {
 459     LOG(IndexedDB, &quot;IDBTransaction::completedOperationTimerFired (%p)&quot;, this);
 460     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 461 
 462     if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)
 463         return;
 464 
 465     auto iterator = m_completedOnServerQueue.takeFirst();
 466     iterator.first-&gt;doComplete(iterator.second);
</pre>
<hr />
<pre>
 621     if (!scriptExecutionContext() || m_contextStopped)
 622         return;
 623 
 624     event-&gt;setTarget(this);
 625     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));
 626 }
 627 
 628 void IDBTransaction::dispatchEvent(Event&amp; event)
 629 {
 630     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 631 
 632     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 633     ASSERT(scriptExecutionContext());
 634     ASSERT(!m_contextStopped);
 635     ASSERT(event.target() == this);
 636     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 637 
 638     auto protectedThis = makeRef(*this);
 639 
 640     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);

 641 
 642     if (isVersionChange()) {
 643         ASSERT(m_openDBRequest);
 644         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 645 
 646         if (event.type() == eventNames().completeEvent) {
 647             if (m_database-&gt;isClosingOrClosed())
 648                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 649             else
 650                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 651         }
 652 
 653         m_openDBRequest = nullptr;
 654     }
 655 }
 656 
 657 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 658 {
 659     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 660     ASSERT(isVersionChange());
 661     ASSERT(scriptExecutionContext());
 662     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 663 
 664     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 665 
<span class="line-modified"> 666     auto objectStore = std::make_unique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);</span>
 667     auto* rawObjectStore = objectStore.get();
 668     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 669 
 670     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 671     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 672         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 673     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 674         protectedThis-&gt;createObjectStoreOnServer(operation, info);
 675     }));
 676 
 677     return *rawObjectStore;
 678 }
 679 
 680 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 681 {
 682     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
 683     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 684     ASSERT(isVersionChange());
 685 
 686     m_database-&gt;connectionProxy().createObjectStore(operation, info);
</pre>
<hr />
<pre>
 734     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 735     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 736 }
 737 
 738 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 739 {
 740     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 741     ASSERT(isVersionChange());
 742     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 743 
 744     if (!scriptExecutionContext())
 745         return nullptr;
 746 
 747     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 748     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 749         protectedThis-&gt;didCreateIndexOnServer(result);
 750     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 751         protectedThis-&gt;createIndexOnServer(operation, info);
 752     }));
 753 
<span class="line-modified"> 754     return std::make_unique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);</span>
 755 }
 756 
 757 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 758 {
 759     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
 760     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 761     ASSERT(isVersionChange());
 762 
 763     m_database-&gt;connectionProxy().createIndex(operation, info);
 764 }
 765 
 766 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 767 {
 768     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
 769     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 770 
 771     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 772         return;
 773 
 774     ASSERT(resultData.type() == IDBResultType::Error);
</pre>
<hr />
<pre>
 969 }
 970 
 971 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 972 {
 973     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
 974     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 975 
 976     if (resultData.type() == IDBResultType::Error) {
 977         completeNoncursorRequest(request, resultData);
 978         return;
 979     }
 980 
 981     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 982 
 983     auto&amp; getAllResult = resultData.getAllResult();
 984     switch (getAllResult.type()) {
 985     case IndexedDB::GetAllType::Keys:
 986         request.setResult(getAllResult.keys());
 987         break;
 988     case IndexedDB::GetAllType::Values:
<span class="line-modified"> 989         request.setResult(getAllResult.values());</span>
 990         break;
 991     }
 992 
 993     completeNoncursorRequest(request, resultData);
 994 }
 995 
 996 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)
 997 {
 998     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
 999     ASSERT(isActive());
1000     ASSERT(!getRecordData.keyRangeData.isNull);
1001     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1002 
1003     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1004 
1005     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
1006 
1007     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
1008     addRequest(request.get());
1009 
</pre>
<hr />
<pre>
1073     if (resultData.type() == IDBResultType::Error) {
1074         completeNoncursorRequest(request, resultData);
1075         return;
1076     }
1077 
1078     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1079 
1080     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1081     if (!useResultKey)
1082         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1083 
1084     const IDBGetResult&amp; result = resultData.getResult();
1085 
1086     if (useResultKey) {
1087         if (!result.keyData().isNull())
1088             request.setResult(result.keyData());
1089         else
1090             request.setResultToUndefined();
1091     } else {
1092         if (resultData.getResult().value().data().data())
<span class="line-modified">1093             request.setResultToStructuredClone(resultData.getResult().value());</span>
1094         else
1095             request.setResultToUndefined();
1096     }
1097 
1098     completeNoncursorRequest(request, resultData);
1099 }
1100 
1101 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1102 {
1103     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1104     ASSERT(isActive());
1105     ASSERT(!range.isNull);
1106     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1107 
1108     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1109 
1110     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1111     addRequest(request.get());
1112 
1113     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
</pre>
<hr />
<pre>
1259 
1260     return request;
1261 }
1262 
1263 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1264 {
1265     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
1266     ASSERT(&amp;originThread() == &amp;Thread::current());
1267     ASSERT(!isReadOnly());
1268     ASSERT(value);
1269 
1270     if (!value-&gt;hasBlobURLs()) {
1271         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1272         return;
1273     }
1274 
1275     // Due to current limitations on our ability to post tasks back to a worker thread,
1276     // workers currently write blobs to disk synchronously.
1277     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1278     if (!isMainThread()) {
<span class="line-modified">1279         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously();</span>
1280         if (idbValue.data().data())
1281             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1282         else {
1283             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1284             // In that case, we cannot successfully store this record, so we callback with an error.
1285             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1286             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1287             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1288                 protectedOperation-&gt;doComplete(result);
1289             });
1290         }
1291         return;
1292     }
1293 
1294     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1295     // stop future requests from going to the server ahead of it.
1296     operation.setNextRequestCanGoToServer(false);
1297 
<span class="line-modified">1298     value-&gt;writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
1299         ASSERT(&amp;originThread() == &amp;Thread::current());
1300         ASSERT(isMainThread());
1301         if (idbValue.data().data()) {
1302             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1303             return;
1304         }
1305 
1306         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1307         // In that case, we cannot successfully store this record, so we callback with an error.
1308         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1309         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1310             protectedOperation-&gt;doComplete(result);
1311         });
1312     });
1313 }
1314 
1315 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1316 {
1317     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
1318     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;IDBCursorWithValue.h&quot;
  39 #include &quot;IDBDatabase.h&quot;
  40 #include &quot;IDBError.h&quot;
  41 #include &quot;IDBGetRecordData.h&quot;
  42 #include &quot;IDBIndex.h&quot;
  43 #include &quot;IDBIterateCursorData.h&quot;
  44 #include &quot;IDBKeyData.h&quot;
  45 #include &quot;IDBKeyRangeData.h&quot;
  46 #include &quot;IDBObjectStore.h&quot;
  47 #include &quot;IDBOpenDBRequest.h&quot;
  48 #include &quot;IDBRequest.h&quot;
  49 #include &quot;IDBResultData.h&quot;
  50 #include &quot;IDBValue.h&quot;
  51 #include &quot;JSDOMWindowBase.h&quot;
  52 #include &quot;Logging.h&quot;
  53 #include &quot;ScriptExecutionContext.h&quot;
  54 #include &quot;ScriptState.h&quot;
  55 #include &quot;SerializedScriptValue.h&quot;
  56 #include &quot;TransactionOperation.h&quot;
  57 #include &lt;wtf/CompletionHandler.h&gt;
<span class="line-added">  58 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
  59 
  60 namespace WebCore {
  61 using namespace JSC;
  62 
<span class="line-added">  63 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBTransaction);</span>
<span class="line-added">  64 </span>
  65 std::atomic&lt;unsigned&gt; IDBTransaction::numberOfIDBTransactions { 0 };
  66 
  67 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info)
  68 {
  69     return adoptRef(*new IDBTransaction(database, info, nullptr));
  70 }
  71 
  72 Ref&lt;IDBTransaction&gt; IDBTransaction::create(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
  73 {
  74     return adoptRef(*new IDBTransaction(database, info, &amp;request));
  75 }
  76 
  77 IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
  78     : IDBActiveDOMObject(database.scriptExecutionContext())
  79     , m_database(database)
  80     , m_info(info)
  81     , m_pendingOperationTimer(*this, &amp;IDBTransaction::pendingOperationTimerFired)
  82     , m_completedOperationTimer(*this, &amp;IDBTransaction::completedOperationTimerFired)
  83     , m_openDBRequest(request)
  84     , m_currentlyCompletingRequest(request)
</pre>
<hr />
<pre>
 162 
 163     if (auto* store = m_referencedObjectStores.get(objectStoreName))
 164         return makeRef(*store);
 165 
 166     bool found = false;
 167     for (auto&amp; objectStore : m_info.objectStores()) {
 168         if (objectStore == objectStoreName) {
 169             found = true;
 170             break;
 171         }
 172     }
 173 
 174     auto* info = m_database-&gt;info().infoForExistingObjectStore(objectStoreName);
 175     if (!info)
 176         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 177 
 178     // Version change transactions are scoped to every object store in the database.
 179     if (!info || (!found &amp;&amp; !isVersionChange()))
 180         return Exception { NotFoundError, &quot;Failed to execute &#39;objectStore&#39; on &#39;IDBTransaction&#39;: The specified object store was not found.&quot;_s };
 181 
<span class="line-modified"> 182     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), *info, *this);</span>
 183     auto* rawObjectStore = objectStore.get();
 184     m_referencedObjectStores.set(objectStoreName, WTFMove(objectStore));
 185 
 186     return Ref&lt;IDBObjectStore&gt;(*rawObjectStore);
 187 }
 188 
 189 
 190 void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
 191 {
 192     LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
 193     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 194 
 195     if (isFinishedOrFinishing())
 196         return;
 197 
 198     m_domError = &amp;error;
 199     internalAbort();
 200 }
 201 
 202 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
</pre>
<hr />
<pre>
 314 
 315     m_abortQueue.clear();
 316     // Since we&#39;re aborting, it should be impossible to have queued any further operations.
 317     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 318 }
 319 
 320 const char* IDBTransaction::activeDOMObjectName() const
 321 {
 322     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 323     return &quot;IDBTransaction&quot;;
 324 }
 325 
 326 bool IDBTransaction::canSuspendForDocumentSuspension() const
 327 {
 328     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 329     return false;
 330 }
 331 
 332 bool IDBTransaction::hasPendingActivity() const
 333 {
<span class="line-modified"> 334     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());</span>
 335     return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
 336 }
 337 
 338 void IDBTransaction::stop()
 339 {
 340     LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
 341     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 342 
 343     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
 344     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
 345     if (m_contextStopped)
 346         return;
 347 
 348     removeAllEventListeners();
 349 
 350     m_contextStopped = true;
 351 
 352     if (isVersionChange())
 353         m_openDBRequest = nullptr;
 354 
</pre>
<hr />
<pre>
 429         operation-&gt;perform();
 430 
 431         if (!operation-&gt;nextRequestCanGoToServer())
 432             break;
 433 
 434     }
 435 
 436     if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())
 437         return;
 438 
 439     if (!isFinishedOrFinishing())
 440         commit();
 441 }
 442 
 443 void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)
 444 {
 445     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 446     ASSERT(&amp;operation.originThread() == &amp;Thread::current());
 447 
 448     m_completedOnServerQueue.append({ &amp;operation, data });
<span class="line-modified"> 449 </span>
<span class="line-added"> 450     if (!m_currentlyCompletingRequest)</span>
<span class="line-added"> 451         scheduleCompletedOperationTimer();</span>
 452 }
 453 
 454 void IDBTransaction::scheduleCompletedOperationTimer()
 455 {
 456     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 457 
 458     if (!m_completedOperationTimer.isActive())
 459         m_completedOperationTimer.startOneShot(0_s);
 460 }
 461 
 462 void IDBTransaction::completedOperationTimerFired()
 463 {
 464     LOG(IndexedDB, &quot;IDBTransaction::completedOperationTimerFired (%p)&quot;, this);
 465     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 466 
 467     if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)
 468         return;
 469 
 470     auto iterator = m_completedOnServerQueue.takeFirst();
 471     iterator.first-&gt;doComplete(iterator.second);
</pre>
<hr />
<pre>
 626     if (!scriptExecutionContext() || m_contextStopped)
 627         return;
 628 
 629     event-&gt;setTarget(this);
 630     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));
 631 }
 632 
 633 void IDBTransaction::dispatchEvent(Event&amp; event)
 634 {
 635     LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
 636 
 637     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 638     ASSERT(scriptExecutionContext());
 639     ASSERT(!m_contextStopped);
 640     ASSERT(event.target() == this);
 641     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 642 
 643     auto protectedThis = makeRef(*this);
 644 
 645     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
<span class="line-added"> 646     m_didDispatchAbortOrCommit = true;</span>
 647 
 648     if (isVersionChange()) {
 649         ASSERT(m_openDBRequest);
 650         m_openDBRequest-&gt;versionChangeTransactionDidFinish();
 651 
 652         if (event.type() == eventNames().completeEvent) {
 653             if (m_database-&gt;isClosingOrClosed())
 654                 m_openDBRequest-&gt;fireErrorAfterVersionChangeCompletion();
 655             else
 656                 m_openDBRequest-&gt;fireSuccessAfterVersionChangeCommit();
 657         }
 658 
 659         m_openDBRequest = nullptr;
 660     }
 661 }
 662 
 663 Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
 664 {
 665     LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
 666     ASSERT(isVersionChange());
 667     ASSERT(scriptExecutionContext());
 668     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 669 
 670     Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
 671 
<span class="line-modified"> 672     auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);</span>
 673     auto* rawObjectStore = objectStore.get();
 674     m_referencedObjectStores.set(info.name(), WTFMove(objectStore));
 675 
 676     LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
 677     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 678         protectedThis-&gt;didCreateObjectStoreOnServer(result);
 679     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 680         protectedThis-&gt;createObjectStoreOnServer(operation, info);
 681     }));
 682 
 683     return *rawObjectStore;
 684 }
 685 
 686 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
 687 {
 688     LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
 689     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 690     ASSERT(isVersionChange());
 691 
 692     m_database-&gt;connectionProxy().createObjectStore(operation, info);
</pre>
<hr />
<pre>
 740     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 741     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 742 }
 743 
 744 std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
 745 {
 746     LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
 747     ASSERT(isVersionChange());
 748     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 749 
 750     if (!scriptExecutionContext())
 751         return nullptr;
 752 
 753     LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
 754     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
 755         protectedThis-&gt;didCreateIndexOnServer(result);
 756     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
 757         protectedThis-&gt;createIndexOnServer(operation, info);
 758     }));
 759 
<span class="line-modified"> 760     return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);</span>
 761 }
 762 
 763 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
 764 {
 765     LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
 766     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 767     ASSERT(isVersionChange());
 768 
 769     m_database-&gt;connectionProxy().createIndex(operation, info);
 770 }
 771 
 772 void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
 773 {
 774     LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
 775     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 776 
 777     if (resultData.type() == IDBResultType::CreateIndexSuccess)
 778         return;
 779 
 780     ASSERT(resultData.type() == IDBResultType::Error);
</pre>
<hr />
<pre>
 975 }
 976 
 977 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
 978 {
 979     LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
 980     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
 981 
 982     if (resultData.type() == IDBResultType::Error) {
 983         completeNoncursorRequest(request, resultData);
 984         return;
 985     }
 986 
 987     ASSERT(resultData.type() == IDBResultType::GetAllRecordsSuccess);
 988 
 989     auto&amp; getAllResult = resultData.getAllResult();
 990     switch (getAllResult.type()) {
 991     case IndexedDB::GetAllType::Keys:
 992         request.setResult(getAllResult.keys());
 993         break;
 994     case IndexedDB::GetAllType::Values:
<span class="line-modified"> 995         request.setResult(getAllResult);</span>
 996         break;
 997     }
 998 
 999     completeNoncursorRequest(request, resultData);
1000 }
1001 
1002 Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)
1003 {
1004     LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
1005     ASSERT(isActive());
1006     ASSERT(!getRecordData.keyRangeData.isNull);
1007     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1008 
1009     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1010 
1011     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
1012 
1013     auto request = IDBRequest::createObjectStoreGet(*scriptExecutionContext(), objectStore, type, *this);
1014     addRequest(request.get());
1015 
</pre>
<hr />
<pre>
1079     if (resultData.type() == IDBResultType::Error) {
1080         completeNoncursorRequest(request, resultData);
1081         return;
1082     }
1083 
1084     ASSERT(resultData.type() == IDBResultType::GetRecordSuccess);
1085 
1086     bool useResultKey = request.sourceIndexIdentifier() &amp;&amp; request.requestedIndexRecordType() == IndexedDB::IndexRecordType::Key;
1087     if (!useResultKey)
1088         useResultKey = request.requestedObjectStoreRecordType() == IndexedDB::ObjectStoreRecordType::KeyOnly;
1089 
1090     const IDBGetResult&amp; result = resultData.getResult();
1091 
1092     if (useResultKey) {
1093         if (!result.keyData().isNull())
1094             request.setResult(result.keyData());
1095         else
1096             request.setResultToUndefined();
1097     } else {
1098         if (resultData.getResult().value().data().data())
<span class="line-modified">1099             request.setResultToStructuredClone(resultData.getResult());</span>
1100         else
1101             request.setResultToUndefined();
1102     }
1103 
1104     completeNoncursorRequest(request, resultData);
1105 }
1106 
1107 Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)
1108 {
1109     LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
1110     ASSERT(isActive());
1111     ASSERT(!range.isNull);
1112     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
1113 
1114     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
1115 
1116     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
1117     addRequest(request.get());
1118 
1119     LOG(IndexedDBOperations, &quot;IDB object store count operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
</pre>
<hr />
<pre>
1265 
1266     return request;
1267 }
1268 
1269 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
1270 {
1271     LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
1272     ASSERT(&amp;originThread() == &amp;Thread::current());
1273     ASSERT(!isReadOnly());
1274     ASSERT(value);
1275 
1276     if (!value-&gt;hasBlobURLs()) {
1277         m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
1278         return;
1279     }
1280 
1281     // Due to current limitations on our ability to post tasks back to a worker thread,
1282     // workers currently write blobs to disk synchronously.
1283     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
1284     if (!isMainThread()) {
<span class="line-modified">1285         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously(scriptExecutionContext()-&gt;sessionID());</span>
1286         if (idbValue.data().data())
1287             m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
1288         else {
1289             // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1290             // In that case, we cannot successfully store this record, so we callback with an error.
1291             RefPtr&lt;IDBClient::TransactionOperation&gt; protectedOperation(&amp;operation);
1292             auto result = IDBResultData::error(operation.identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1293             scriptExecutionContext()-&gt;postTask([protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)](ScriptExecutionContext&amp;) {
1294                 protectedOperation-&gt;doComplete(result);
1295             });
1296         }
1297         return;
1298     }
1299 
1300     // Since this request won&#39;t actually go to the server until the blob writes are complete,
1301     // stop future requests from going to the server ahead of it.
1302     operation.setNextRequestCanGoToServer(false);
1303 
<span class="line-modified">1304     value-&gt;writeBlobsToDiskForIndexedDB(scriptExecutionContext()-&gt;sessionID(), [protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
1305         ASSERT(&amp;originThread() == &amp;Thread::current());
1306         ASSERT(isMainThread());
1307         if (idbValue.data().data()) {
1308             m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
1309             return;
1310         }
1311 
1312         // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
1313         // In that case, we cannot successfully store this record, so we callback with an error.
1314         auto result = IDBResultData::error(protectedOperation-&gt;identifier(), IDBError { UnknownError, &quot;Error preparing Blob/File data to be stored in object store&quot;_s });
1315         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedOperation = WTFMove(protectedOperation), result = WTFMove(result)]() mutable {
1316             protectedOperation-&gt;doComplete(result);
1317         });
1318     });
1319 }
1320 
1321 void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
1322 {
1323     LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
1324     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());
</pre>
</td>
</tr>
</table>
<center><a href="IDBRequestCompletionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>