<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../bytecode/Watchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,10 ***</span>
<span class="line-new-header">--- 62,11 ---</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  #include &quot;UnlinkedProgramCodeBlock.h&quot;
  #include &lt;wtf/BitVector.h&gt;
  #include &lt;wtf/CommaPrinter.h&gt;
<span class="line-added">+ #include &lt;wtf/Optional.h&gt;</span>
  #include &lt;wtf/SmallPtrSet.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,10 ***</span>
<span class="line-new-header">--- 113,12 ---</span>
          CASE(OpJmp)
          CASE(OpJtrue)
          CASE(OpJfalse)
          CASE(OpJeqNull)
          CASE(OpJneqNull)
<span class="line-added">+         CASE(OpJundefinedOrNull)</span>
<span class="line-added">+         CASE(OpJnundefinedOrNull)</span>
          CASE(OpJeq)
          CASE(OpJstricteq)
          CASE(OpJneq)
          CASE(OpJneqPtr)
          CASE(OpJnstricteq)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,10 ***</span>
<span class="line-new-header">--- 184,21 ---</span>
          &quot;, kind = &quot;, m_kind,
          &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
          &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
  }
  
<span class="line-added">+ FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)</span>
<span class="line-added">+     : m_outerContext(generator.m_currentFinallyContext)</span>
<span class="line-added">+     , m_finallyLabel(&amp;finallyLabel)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_jumps.isEmpty());</span>
<span class="line-added">+     m_completionRecord.typeRegister = generator.newTemporary();</span>
<span class="line-added">+     m_completionRecord.valueRegister = generator.newTemporary();</span>
<span class="line-added">+     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);</span>
<span class="line-added">+     generator.moveEmptyValue(completionValueRegister());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ParserError BytecodeGenerator::generate()
  {
      m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
  
      emitLogShadowChickenPrologueIfNecessary();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,18 ***</span>
          // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
          // basic block the strongest way possible.
          emitUnreachable();
      }
  
<span class="line-modified">!     for (auto&amp; tuple : m_catchesToEmit) {</span>
          Ref&lt;Label&gt; realCatchTarget = newLabel();
<span class="line-modified">!         OpCatch::emit(this, std::get&lt;1&gt;(tuple), std::get&lt;2&gt;(tuple));</span>
          realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
          m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
  
  
<span class="line-removed">-         TryData* tryData = std::get&lt;0&gt;(tuple);</span>
          emitJump(tryData-&gt;target.get());
          tryData-&gt;target = WTFMove(realCatchTarget);
      }
  
      m_staticPropertyAnalyzer.kill();
<span class="line-new-header">--- 257,27 ---</span>
          // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
          // basic block the strongest way possible.
          emitUnreachable();
      }
  
<span class="line-modified">!     for (auto&amp; handler : m_exceptionHandlersToEmit) {</span>
          Ref&lt;Label&gt; realCatchTarget = newLabel();
<span class="line-modified">!         TryData* tryData = handler.tryData;</span>
<span class="line-added">+ </span>
<span class="line-added">+         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);</span>
          realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
<span class="line-added">+         if (handler.completionTypeRegister.isValid()) {</span>
<span class="line-added">+             RegisterID completionTypeRegister { handler.completionTypeRegister };</span>
<span class="line-added">+             CompletionType completionType =</span>
<span class="line-added">+                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally</span>
<span class="line-added">+                 ? CompletionType::Throw</span>
<span class="line-added">+                 : CompletionType::Normal;</span>
<span class="line-added">+             emitLoad(&amp;completionTypeRegister, completionType);</span>
<span class="line-added">+         }</span>
          m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
  
  
          emitJump(tryData-&gt;target.get());
          tryData-&gt;target = WTFMove(realCatchTarget);
      }
  
      m_staticPropertyAnalyzer.kill();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,17 ***</span>
      if (m_expressionTooDeep)
          return ParserError(ParserError::OutOfMemory);
      return ParserError(ParserError::ErrorNone);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
      , m_scopeNode(programNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(GlobalCode)
<span class="line-modified">!     , m_vm(&amp;vm)</span>
      , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
<span class="line-new-header">--- 328,17 ---</span>
      if (m_expressionTooDeep)
          return ParserError(ParserError::OutOfMemory);
      return ParserError(ParserError::ErrorNone);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(programNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(GlobalCode)
<span class="line-modified">!     , m_vm(vm)</span>
      , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,12 ***</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-removed">-     emitCheckTraps();</span>
<span class="line-removed">- </span>
      const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
  
      for (auto* function : functionStack)
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
  
<span class="line-new-header">--- 350,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,16 ***</span>
          initializeArrowFunctionContextScopeIfNeeded();
          emitPutThisToArrowFunctionContextScope();
      }
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
      , m_scopeNode(functionNode)
      , m_codeBlock(vm, codeBlock)
      , m_codeType(FunctionCode)
<span class="line-modified">!     , m_vm(&amp;vm)</span>
      , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      // FIXME: We should be able to have tail call elimination with the profiler
      // enabled. This is currently not possible because the profiler expects
      // op_will_call / op_did_call pairs before and after a call, which are not
<span class="line-new-header">--- 372,16 ---</span>
          initializeArrowFunctionContextScopeIfNeeded();
          emitPutThisToArrowFunctionContextScope();
      }
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(functionNode)
      , m_codeBlock(vm, codeBlock)
      , m_codeType(FunctionCode)
<span class="line-modified">!     , m_vm(vm)</span>
      , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      // FIXME: We should be able to have tail call elimination with the profiler
      // enabled. This is currently not possible because the profiler expects
      // op_will_call / op_did_call pairs before and after a call, which are not
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,16 ***</span>
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
          constantRegister = nullptr;
  
<span class="line-removed">-     if (m_isBuiltinFunction)</span>
<span class="line-removed">-         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed">- </span>
      allocateCalleeSaveSpace();
  
<span class="line-modified">!     SymbolTable* functionSymbolTable = SymbolTable::create(*m_vm);</span>
      functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      int symbolTableConstantIndex = 0;
  
      FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
      // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
<span class="line-new-header">--- 392,13 ---</span>
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
          constantRegister = nullptr;
  
      allocateCalleeSaveSpace();
  
<span class="line-modified">!     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);</span>
      functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      int symbolTableConstantIndex = 0;
  
      FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
      // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,21 ***</span>
      bool isSimpleParameterList = parameters.isSimpleParameterList();
  
      SourceParseMode parseMode = codeBlock-&gt;parseMode();
  
      bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
<span class="line-modified">!     bool shouldCaptureSomeOfTheThings = m_shouldEmitDebugHooks || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;</span>
  
<span class="line-modified">!     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
      bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
          // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
          needsArguments = false;
<span class="line-removed">- </span>
<span class="line-removed">-         // Generator and AsyncFunction uses the var scope to save and resume its variables. So the lexical scope is always instantiated.</span>
<span class="line-removed">-         shouldCaptureSomeOfTheThings = true;</span>
      }
  
      if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
          // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
          // This is because arguments of a generator should be evaluated before starting it.
<span class="line-new-header">--- 410,18 ---</span>
      bool isSimpleParameterList = parameters.isSimpleParameterList();
  
      SourceParseMode parseMode = codeBlock-&gt;parseMode();
  
      bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
<span class="line-modified">!     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;</span>
  
<span class="line-modified">!     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();</span>
      bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
          // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
          needsArguments = false;
      }
  
      if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
          // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
          // This is because arguments of a generator should be evaluated before starting it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,12 ***</span>
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
          m_generatorRegister = &amp;m_parameters[1];
  
      allocateAndEmitScope();
  
<span class="line-removed">-     emitCheckTraps();</span>
<span class="line-removed">- </span>
      if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
          ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
          ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
          bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
          bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
<span class="line-new-header">--- 469,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,11 ***</span>
      }
  
      if (shouldCaptureSomeOfTheThings)
          m_lexicalEnvironmentRegister = addVar();
  
<span class="line-modified">!     if (shouldCaptureSomeOfTheThings || vm.typeProfiler())</span>
          symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
  
      // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
      // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
      // the parent scope of the &quot;var&quot; environment is the parameter environment.
<span class="line-new-header">--- 481,11 ---</span>
      }
  
      if (shouldCaptureSomeOfTheThings)
          m_lexicalEnvironmentRegister = addVar();
  
<span class="line-modified">!     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())</span>
          symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
  
      // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
      // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
      // the parent scope of the &quot;var&quot; environment is the parameter environment.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,14 ***</span>
                      SymbolTableEntry entry(varOffset);
                      // Stores to these variables via the ScopedArguments object will not do
                      // notifyWrite(), since that would be cumbersome. Also, watching formal
                      // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
                      // So, we just disable it.
<span class="line-modified">!                     entry.disableWatching(*m_vm);</span>
                      functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
                  }
<span class="line-modified">!                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
              }
  
              // This creates a scoped arguments object and copies the overflow arguments into the
              // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
              OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
<span class="line-new-header">--- 544,14 ---</span>
                      SymbolTableEntry entry(varOffset);
                      // Stores to these variables via the ScopedArguments object will not do
                      // notifyWrite(), since that would be cumbersome. Also, watching formal
                      // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
                      // So, we just disable it.
<span class="line-modified">!                     entry.disableWatching(m_vm);</span>
                      functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
                  }
<span class="line-modified">!                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
              }
  
              // This creates a scoped arguments object and copies the overflow arguments into the
              // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
              OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 572,11 ***</span>
              ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
              const Identifier&amp; ident =
                  static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
              functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
  
<span class="line-modified">!             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), symbolTableConstantIndex, offset.offset());</span>
          }
      }
  
      if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
          // Allocate a cloned arguments object.
<span class="line-new-header">--- 585,11 ---</span>
              ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
              const Identifier&amp; ident =
                  static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
              functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
  
<span class="line-modified">!             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
          }
      }
  
      if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
          // Allocate a cloned arguments object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,11 ***</span>
              continue;
          createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
      }
  
  
<span class="line-modified">!     m_newTargetRegister = addVar();</span>
      switch (parseMode) {
      case SourceParseMode::GeneratorWrapperFunctionMode:
      case SourceParseMode::GeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
<span class="line-new-header">--- 661,13 ---</span>
              continue;
          createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
      }
  
  
<span class="line-modified">!     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())</span>
<span class="line-added">+         m_newTargetRegister = addVar();</span>
<span class="line-added">+ </span>
      switch (parseMode) {
      case SourceParseMode::GeneratorWrapperFunctionMode:
      case SourceParseMode::GeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,18 ***</span>
      case SourceParseMode::AsyncGeneratorBodyMode:
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::AsyncArrowFunctionBodyMode:
      case SourceParseMode::GeneratorBodyMode: {
          // |this| is already filled correctly before here.
<span class="line-modified">!         emitLoad(m_newTargetRegister, jsUndefined());</span>
          break;
      }
  
      default: {
          if (SourceParseMode::ArrowFunctionMode != parseMode) {
              if (isConstructor()) {
<span class="line-modified">!                 move(m_newTargetRegister, &amp;m_thisRegister);</span>
                  if (constructorKind() == ConstructorKind::Extends) {
                      moveEmptyValue(&amp;m_thisRegister);
                  } else
                      emitCreateThis(&amp;m_thisRegister);
              } else if (constructorKind() != ConstructorKind::None)
<span class="line-new-header">--- 721,20 ---</span>
      case SourceParseMode::AsyncGeneratorBodyMode:
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::AsyncArrowFunctionBodyMode:
      case SourceParseMode::GeneratorBodyMode: {
          // |this| is already filled correctly before here.
<span class="line-modified">!         if (m_newTargetRegister)</span>
<span class="line-added">+             emitLoad(m_newTargetRegister, jsUndefined());</span>
          break;
      }
  
      default: {
          if (SourceParseMode::ArrowFunctionMode != parseMode) {
              if (isConstructor()) {
<span class="line-modified">!                 if (m_newTargetRegister)</span>
<span class="line-added">+                     move(m_newTargetRegister, &amp;m_thisRegister);</span>
                  if (constructorKind() == ConstructorKind::Extends) {
                      moveEmptyValue(&amp;m_thisRegister);
                  } else
                      emitCreateThis(&amp;m_thisRegister);
              } else if (constructorKind() != ConstructorKind::None)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 753,11 ***</span>
      // if we have default parameter expression. Because |super| &amp; |this| values can be used there
      if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
          if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
              emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
              emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
      }
  
      if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
          bool canReuseLexicalEnvironment = isSimpleParameterList;
<span class="line-new-header">--- 770,11 ---</span>
      // if we have default parameter expression. Because |super| &amp; |this| values can be used there
      if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
          if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
              emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())</span>
              emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
      }
  
      if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
          bool canReuseLexicalEnvironment = isSimpleParameterList;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 786,24 ***</span>
          emitJump(didNotThrow.get());
          emitLabel(catchLabel.get());
          popTry(tryFormalParametersData, catchLabel.get());
  
          RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
<span class="line-modified">!         RegisterID* unused = newTemporary();</span>
<span class="line-removed">-         emitCatch(unused, thrownValue.get(), tryFormalParametersData);</span>
  
          // return promiseCapability.@reject(thrownValue)
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().rejectPrivateName());</span>
  
          CallArguments args(*this, nullptr, 1);
          emitLoad(args.thisRegister(), jsUndefined());
          move(args.argumentRegister(0), thrownValue.get());
  
          JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
  
          RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<span class="line-modified">!         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm-&gt;propertyNames-&gt;builtinNames().promisePrivateName()));</span>
  
          emitLabel(didNotThrow.get());
      }
  
      // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
<span class="line-new-header">--- 803,23 ---</span>
          emitJump(didNotThrow.get());
          emitLabel(catchLabel.get());
          popTry(tryFormalParametersData, catchLabel.get());
  
          RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
<span class="line-modified">!         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);</span>
  
          // return promiseCapability.@reject(thrownValue)
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().rejectPrivateName());</span>
  
          CallArguments args(*this, nullptr, 1);
          emitLoad(args.thisRegister(), jsUndefined());
          move(args.argumentRegister(0), thrownValue.get());
  
          JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
  
          RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<span class="line-modified">!         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().promisePrivateName()));</span>
  
          emitLabel(didNotThrow.get());
      }
  
      // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,35 ***</span>
      // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
      if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
          if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
              emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!         if (m_scopeNode-&gt;usesNewTarget() || m_scopeNode-&gt;usesSuperCall())</span>
              emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
      }
  
      // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
      // Since they are symbol keyed, these variables cannot be reached from the usual code.
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
<span class="line-modified">!         ASSERT(m_lexicalEnvironmentRegister);</span>
<span class="line-removed">-         m_generatorFrameSymbolTable.set(*m_vm, functionSymbolTable);</span>
          m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
<span class="line-modified">!         move(generatorFrameRegister(), m_lexicalEnvironmentRegister);</span>
          emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
      }
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
      , m_scopeNode(evalNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(EvalCode)
<span class="line-modified">!     , m_vm(&amp;vm)</span>
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
<span class="line-new-header">--- 827,42 ---</span>
      // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
      if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
          if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
              emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())</span>
              emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
      }
  
      // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
      // Since they are symbol keyed, these variables cannot be reached from the usual code.
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
<span class="line-modified">!         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);</span>
          m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
<span class="line-modified">!         if (m_lexicalEnvironmentRegister)</span>
<span class="line-added">+             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);</span>
<span class="line-added">+         else {</span>
<span class="line-added">+             // It would be possible that generator does not need to suspend and resume any registers.</span>
<span class="line-added">+             // In this case, we would like to avoid creating a lexical environment as much as possible.</span>
<span class="line-added">+             // op_create_generator_frame_environment is a marker, which is similar to op_yield.</span>
<span class="line-added">+             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.</span>
<span class="line-added">+             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));</span>
<span class="line-added">+         }</span>
          emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());
      }
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(evalNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(EvalCode)
<span class="line-modified">!     , m_vm(vm)</span>
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 853,38 ***</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-removed">-     emitCheckTraps();</span>
<span class="line-removed">- </span>
      for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
          m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
      }
  
      const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
      Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
      Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
      for (auto&amp; entry : varDeclarations) {
          ASSERT(entry.value.isVar());
<span class="line-modified">!         ASSERT(entry.key-&gt;isAtomic() || entry.key-&gt;isSymbol());</span>
          if (entry.value.isSloppyModeHoistingCandidate())
              hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
          else
              variables.append(Identifier::fromUid(m_vm, entry.key.get()));
      }
      codeBlock-&gt;adoptVariables(variables);
      codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
  
<span class="line-modified">!     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
          m_newTargetRegister = addVar();
  
      if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
          emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!     if (evalNode-&gt;usesSuperCall() || evalNode-&gt;usesNewTarget())</span>
          emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
  
      if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
          initializeArrowFunctionContextScopeIfNeeded();
          emitPutThisToArrowFunctionContextScope();
<span class="line-new-header">--- 876,36 ---</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
      for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
          m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
      }
  
      const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
      Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
      Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
      for (auto&amp; entry : varDeclarations) {
          ASSERT(entry.value.isVar());
<span class="line-modified">!         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());</span>
          if (entry.value.isSloppyModeHoistingCandidate())
              hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
          else
              variables.append(Identifier::fromUid(m_vm, entry.key.get()));
      }
      codeBlock-&gt;adoptVariables(variables);
      codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
  
<span class="line-modified">!     if (evalNode-&gt;needsNewTargetRegisterForThisScope())</span>
          m_newTargetRegister = addVar();
  
      if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
          emitLoadThisFromArrowFunctionLexicalEnvironment();
  
<span class="line-modified">!     if (evalNode-&gt;needsNewTargetRegisterForThisScope())</span>
          emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
  
      if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
          initializeArrowFunctionContextScopeIfNeeded();
          emitPutThisToArrowFunctionContextScope();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 892,35 ***</span>
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, DebuggerMode debuggerMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_shouldEmitDebugHooks(Options::forceDebuggerBytecodeGeneration() || debuggerMode == DebuggerOn)</span>
      , m_scopeNode(moduleProgramNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(ModuleCode)
<span class="line-modified">!     , m_vm(&amp;vm)</span>
      , m_usesNonStrictEval(false)
      , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
          constantRegister = nullptr;
  
<span class="line-removed">-     if (m_isBuiltinFunction)</span>
<span class="line-removed">-         m_shouldEmitDebugHooks = false;</span>
<span class="line-removed">- </span>
      allocateCalleeSaveSpace();
  
<span class="line-modified">!     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(*m_vm);</span>
      moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
  
<span class="line-modified">!     bool shouldCaptureAllOfTheThings = m_shouldEmitDebugHooks || codeBlock-&gt;usesEval();</span>
      if (shouldCaptureAllOfTheThings)
          moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
  
      auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
          return moduleProgramNode-&gt;captures(uid);
<span class="line-new-header">--- 913,32 ---</span>
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
<span class="line-modified">! BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)</span>
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(moduleProgramNode)
      , m_codeBlock(vm, codeBlock)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(ModuleCode)
<span class="line-modified">!     , m_vm(vm)</span>
      , m_usesNonStrictEval(false)
      , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      for (auto&amp; constantRegister : m_linkTimeConstantRegisters)
          constantRegister = nullptr;
  
      allocateCalleeSaveSpace();
  
<span class="line-modified">!     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);</span>
      moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
  
<span class="line-modified">!     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();</span>
      if (shouldCaptureAllOfTheThings)
          moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
  
      auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
          return moduleProgramNode-&gt;captures(uid);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 942,19 ***</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-removed">-     emitCheckTraps();</span>
<span class="line-removed">- </span>
      m_calleeRegister.setIndex(CallFrameSlot::callee);
  
      m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
  
      // Now declare all variables.
  
<span class="line-modified">!     createVariable(m_vm-&gt;propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);</span>
  
      for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
          ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
          if (!entry.value.isVar()) // This is either a parameter or callee.
              continue;
<span class="line-new-header">--- 960,17 ---</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
      m_calleeRegister.setIndex(CallFrameSlot::callee);
  
      m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
  
      // Now declare all variables.
  
<span class="line-modified">!     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);</span>
  
      for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
          ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
          if (!entry.value.isVar()) // This is either a parameter or callee.
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 969,14 ***</span>
      VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
      instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
  
      // We keep the symbol table in the constant pool.
      RegisterID* constantSymbolTable = nullptr;
<span class="line-modified">!     if (vm.typeProfiler())</span>
          constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
      else
<span class="line-modified">!         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(*m_vm));</span>
  
      pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
      bool isWithScope = false;
      m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
      emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
<span class="line-new-header">--- 985,14 ---</span>
      VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
      instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
  
      // We keep the symbol table in the constant pool.
      RegisterID* constantSymbolTable = nullptr;
<span class="line-modified">!     if (shouldEmitTypeProfilerHooks())</span>
          constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
      else
<span class="line-modified">!         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(m_vm));</span>
  
      pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
      bool isWithScope = false;
      m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
      emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,14 ***</span>
      ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
      m_lastInstruction = m_writer.ref();
      m_lastOpcodeID = opcodeID;
  }
  
<span class="line-modified">! void BytecodeGenerator::alignWideOpcode()</span>
  {
  #if CPU(NEEDS_ALIGNED_ACCESS)
<span class="line-modified">!     while ((m_writer.position() + 1) % OpcodeSize::Wide)</span>
          OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
  #endif
  }
  
  void BytecodeGenerator::emitLabel(Label&amp; l0)
<span class="line-new-header">--- 1335,22 ---</span>
      ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));
      m_lastInstruction = m_writer.ref();
      m_lastOpcodeID = opcodeID;
  }
  
<span class="line-modified">! void BytecodeGenerator::alignWideOpcode16()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-added">+     while ((m_writer.position() + 1) % OpcodeSize::Wide16)</span>
<span class="line-added">+         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::alignWideOpcode32()</span>
  {
  #if CPU(NEEDS_ALIGNED_ACCESS)
<span class="line-modified">!     while ((m_writer.position() + 1) % OpcodeSize::Wide32)</span>
          OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
  #endif
  }
  
  void BytecodeGenerator::emitLabel(Label&amp; l0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1363,33 ***</span>
  }
  
  void BytecodeGenerator::emitLoopHint()
  {
      OpLoopHint::emit(this);
<span class="line-removed">-     emitCheckTraps();</span>
  }
  
  void BytecodeGenerator::emitJump(Label&amp; target)
  {
      OpJmp::emit(this, target.bind(this));
  }
  
<span class="line-removed">- void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     OpCheckTraps::emit(this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void ALWAYS_INLINE BytecodeGenerator::rewind()
  {
      ASSERT(m_lastInstruction.isValid());
      m_lastOpcodeID = op_end;
      m_writer.rewind(m_lastInstruction);
  }
  
  template&lt;typename BinOp, typename JmpOp&gt;
  bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
  {
      auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
      if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
          rewind();
  
          if (swapOperands)
<span class="line-new-header">--- 1387,28 ---</span>
  }
  
  void BytecodeGenerator::emitLoopHint()
  {
      OpLoopHint::emit(this);
  }
  
  void BytecodeGenerator::emitJump(Label&amp; target)
  {
      OpJmp::emit(this, target.bind(this));
  }
  
  void ALWAYS_INLINE BytecodeGenerator::rewind()
  {
      ASSERT(m_lastInstruction.isValid());
      m_lastOpcodeID = op_end;
      m_writer.rewind(m_lastInstruction);
  }
  
  template&lt;typename BinOp, typename JmpOp&gt;
  bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
  {
<span class="line-added">+     ASSERT(canDoPeepholeOptimization());</span>
      auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
      if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
          rewind();
  
          if (swapOperands)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1402,10 ***</span>
<span class="line-new-header">--- 1421,11 ---</span>
  }
  
  template&lt;typename UnaryOp, typename JmpOp&gt;
  bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
  {
<span class="line-added">+     ASSERT(canDoPeepholeOptimization());</span>
      auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
      if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
          rewind();
  
          JmpOp::emit(this, unop.m_operand, target.bind(this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1414,93 ***</span>
      return false;
  }
  
  void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">! </span>
<span class="line-modified">!     if (m_lastOpcodeID == op_less) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_lesseq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_greater) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_greatereq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_eq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_stricteq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_neq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_nstricteq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_below) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_beloweq) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
      }
  
      OpJtrue::emit(this, cond, target.bind(this));
  }
  
  void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_not) {</span>
<span class="line-modified">!         if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!     } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!         if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">!             return;</span>
      }
  
      OpJfalse::emit(this, cond, target.bind(this));
  }
  
<span class="line-new-header">--- 1434,102 ---</span>
      return false;
  }
  
  void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     if (canDoPeepholeOptimization()) {</span>
<span class="line-modified">!         if (m_lastOpcodeID == op_less) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_lesseq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_greater) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_greatereq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_eq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_stricteq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_neq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_nstricteq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_below) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_beloweq) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-added">+         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {</span>
<span class="line-added">+             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJundefinedOrNull&gt;(cond, target))</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+         }</span>
      }
  
      OpJtrue::emit(this, cond, target.bind(this));
  }
  
  void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     if (canDoPeepholeOptimization()) {</span>
<span class="line-modified">!         if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_not) {</span>
<span class="line-modified">!             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {</span>
<span class="line-modified">!             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {</span>
<span class="line-added">+             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+         }</span>
      }
  
      OpJfalse::emit(this, cond, target.bind(this));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,86 ***</span>
  {
      OpDec::emit(this, srcDst);
      return srcDst;
  }
  
<span class="line-modified">! template&lt;typename EqOp&gt;</span>
<span class="line-removed">- RegisterID* BytecodeGenerator::emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
  {
      if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
          auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
          if (src1-&gt;index() == op.m_dst.offset()
              &amp;&amp; src1-&gt;isTemporary()
              &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
              &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
              const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
              if (value == &quot;undefined&quot;) {
                  rewind();
                  OpIsUndefined::emit(this, dst, op.m_value);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;boolean&quot;) {
                  rewind();
                  OpIsBoolean::emit(this, dst, op.m_value);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;number&quot;) {
                  rewind();
                  OpIsNumber::emit(this, dst, op.m_value);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;string&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, StringType);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;symbol&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
<span class="line-modified">!                 return dst;</span>
              }
              if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;object&quot;) {
                  rewind();
                  OpIsObjectOrNull::emit(this, dst, op.m_value);
<span class="line-modified">!                 return dst;</span>
              }
              if (value == &quot;function&quot;) {
                  rewind();
                  OpIsFunction::emit(this, dst, op.m_value);
<span class="line-modified">!                 return dst;</span>
              }
          }
      }
  
<span class="line-modified">!     EqOp::emit(this, dst, src1, src2);</span>
<span class="line-removed">-     return dst;</span>
  }
  
  void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     ASSERT(vm()-&gt;typeProfiler());</span>
  
      unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
      unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
      unsigned instructionOffset = instructions().size() - 1;
      m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
  {
<span class="line-modified">!     if (!vm()-&gt;typeProfiler())</span>
          return;
  
      if (!registerToProfile)
          return;
  
<span class="line-modified">!     OpProfileType::emit(this, registerToProfile, 0, flag, { }, resolveType());</span>
  
      // Don&#39;t emit expression info for this version of profile type. This generally means
      // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
      // program. For example, implicit return undefined from a function call.
  }
<span class="line-new-header">--- 1731,87 ---</span>
  {
      OpDec::emit(this, srcDst);
      return srcDst;
  }
  
<span class="line-modified">! bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
  {
<span class="line-added">+     if (!canDoPeepholeOptimization())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
          auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
          if (src1-&gt;index() == op.m_dst.offset()
              &amp;&amp; src1-&gt;isTemporary()
              &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())
              &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {
              const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();
              if (value == &quot;undefined&quot;) {
                  rewind();
                  OpIsUndefined::emit(this, dst, op.m_value);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;boolean&quot;) {
                  rewind();
                  OpIsBoolean::emit(this, dst, op.m_value);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;number&quot;) {
                  rewind();
                  OpIsNumber::emit(this, dst, op.m_value);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;string&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, StringType);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;symbol&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
<span class="line-modified">!                 return true;</span>
              }
              if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
                  rewind();
                  OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;object&quot;) {
                  rewind();
                  OpIsObjectOrNull::emit(this, dst, op.m_value);
<span class="line-modified">!                 return true;</span>
              }
              if (value == &quot;function&quot;) {
                  rewind();
                  OpIsFunction::emit(this, dst, op.m_value);
<span class="line-modified">!                 return true;</span>
              }
          }
      }
  
<span class="line-modified">!     return false;</span>
  }
  
  void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     ASSERT(shouldEmitTypeProfilerHooks());</span>
  
      unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
      unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
      unsigned instructionOffset = instructions().size() - 1;
      m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
  {
<span class="line-modified">!     if (!shouldEmitTypeProfilerHooks())</span>
          return;
  
      if (!registerToProfile)
          return;
  
<span class="line-modified">!     OpProfileType::emit(this, registerToProfile, { }, flag, { }, resolveType());</span>
  
      // Don&#39;t emit expression info for this version of profile type. This generally means
      // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
      // program. For example, implicit return undefined from a function call.
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1791,46 ***</span>
      emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     if (!vm()-&gt;typeProfiler())</span>
          return;
  
      if (!registerToProfile)
          return;
  
<span class="line-modified">!     OpProfileType::emit(this, registerToProfile, 0,  flag, { }, resolveType());</span>
      emitTypeProfilerExpressionInfo(startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     if (!vm()-&gt;typeProfiler())</span>
          return;
  
      if (!registerToProfile)
          return;
  
      ProfileTypeBytecodeFlag flag;
<span class="line-modified">!     int symbolTableOrScopeDepth;</span>
      if (var.local() || var.offset().isScope()) {
          flag = ProfileTypeBytecodeLocallyResolved;
          ASSERT(var.symbolTableConstantIndex());
<span class="line-modified">!         symbolTableOrScopeDepth = var.symbolTableConstantIndex();</span>
      } else {
          flag = ProfileTypeBytecodeClosureVar;
<span class="line-modified">!         symbolTableOrScopeDepth = localScopeDepth();</span>
      }
  
      OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
      emitTypeProfilerExpressionInfo(startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileControlFlow(int textOffset)
  {
<span class="line-modified">!     if (vm()-&gt;controlFlowProfiler()) {</span>
          RELEASE_ASSERT(textOffset &gt;= 0);
  
          OpProfileControlFlow::emit(this, textOffset);
          m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
      }
<span class="line-new-header">--- 1821,46 ---</span>
      emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     if (!shouldEmitTypeProfilerHooks())</span>
          return;
  
      if (!registerToProfile)
          return;
  
<span class="line-modified">!     OpProfileType::emit(this, registerToProfile, { },  flag, { }, resolveType());</span>
      emitTypeProfilerExpressionInfo(startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
  {
<span class="line-modified">!     if (!shouldEmitTypeProfilerHooks())</span>
          return;
  
      if (!registerToProfile)
          return;
  
      ProfileTypeBytecodeFlag flag;
<span class="line-modified">!     SymbolTableOrScopeDepth symbolTableOrScopeDepth;</span>
      if (var.local() || var.offset().isScope()) {
          flag = ProfileTypeBytecodeLocallyResolved;
          ASSERT(var.symbolTableConstantIndex());
<span class="line-modified">!         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { var.symbolTableConstantIndex() });</span>
      } else {
          flag = ProfileTypeBytecodeClosureVar;
<span class="line-modified">!         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());</span>
      }
  
      OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
      emitTypeProfilerExpressionInfo(startDivot, endDivot);
  }
  
  void BytecodeGenerator::emitProfileControlFlow(int textOffset)
  {
<span class="line-modified">!     if (shouldEmitControlFlowProfilerHooks()) {</span>
          RELEASE_ASSERT(textOffset &gt;= 0);
  
          OpProfileControlFlow::emit(this, textOffset);
          m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1972,14 ***</span>
      RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
  {
      if (!environment.size())
          return;
  
<span class="line-modified">!     if (m_shouldEmitDebugHooks)</span>
          environment.markAllVariablesAsCaptured();
  
<span class="line-modified">!     SymbolTable* symbolTable = SymbolTable::create(*m_vm);</span>
      switch (scopeType) {
      case ScopeType::CatchScope:
          symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
          break;
      case ScopeType::LetConstScope:
<span class="line-new-header">--- 2002,14 ---</span>
      RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
  {
      if (!environment.size())
          return;
  
<span class="line-modified">!     if (shouldEmitDebugHooks())</span>
          environment.markAllVariablesAsCaptured();
  
<span class="line-modified">!     SymbolTable* symbolTable = SymbolTable::create(m_vm);</span>
      switch (scopeType) {
      case ScopeType::CatchScope:
          symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
          break;
      case ScopeType::LetConstScope:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2000,23 ***</span>
      bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
  
      RegisterID* newScope = nullptr;
      RegisterID* constantSymbolTable = nullptr;
      int symbolTableConstantIndex = 0;
<span class="line-modified">!     if (vm()-&gt;typeProfiler()) {</span>
          constantSymbolTable = addConstantValue(symbolTable);
          symbolTableConstantIndex = constantSymbolTable-&gt;index();
      }
      if (hasCapturedVariables) {
          if (scopeRegisterType == ScopeRegisterType::Block) {
              newScope = newBlockScopeVariable();
              newScope-&gt;ref();
          } else
              newScope = addVar();
          if (!constantSymbolTable) {
<span class="line-modified">!             ASSERT(!vm()-&gt;typeProfiler());</span>
<span class="line-modified">!             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(*m_vm));</span>
              symbolTableConstantIndex = constantSymbolTable-&gt;index();
          }
          if (constantSymbolTableResult)
              *constantSymbolTableResult = constantSymbolTable;
  
<span class="line-new-header">--- 2030,23 ---</span>
      bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
  
      RegisterID* newScope = nullptr;
      RegisterID* constantSymbolTable = nullptr;
      int symbolTableConstantIndex = 0;
<span class="line-modified">!     if (shouldEmitTypeProfilerHooks()) {</span>
          constantSymbolTable = addConstantValue(symbolTable);
          symbolTableConstantIndex = constantSymbolTable-&gt;index();
      }
      if (hasCapturedVariables) {
          if (scopeRegisterType == ScopeRegisterType::Block) {
              newScope = newBlockScopeVariable();
              newScope-&gt;ref();
          } else
              newScope = addVar();
          if (!constantSymbolTable) {
<span class="line-modified">!             ASSERT(!shouldEmitTypeProfilerHooks());</span>
<span class="line-modified">!             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(m_vm));</span>
              symbolTableConstantIndex = constantSymbolTable-&gt;index();
          }
          if (constantSymbolTableResult)
              *constantSymbolTableResult = constantSymbolTable;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2166,11 ***</span>
      // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
      // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
      if (!environment.size())
          return;
  
<span class="line-modified">!     if (m_shouldEmitDebugHooks)</span>
          environment.markAllVariablesAsCaptured();
  
      auto stackEntry = m_lexicalScopeStack.takeLast();
      SymbolTable* symbolTable = stackEntry.m_symbolTable;
      bool hasCapturedVariables = false;
<span class="line-new-header">--- 2196,11 ---</span>
      // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
      // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
      if (!environment.size())
          return;
  
<span class="line-modified">!     if (shouldEmitDebugHooks())</span>
          environment.markAllVariablesAsCaptured();
  
      auto stackEntry = m_lexicalScopeStack.takeLast();
      SymbolTable* symbolTable = stackEntry.m_symbolTable;
      bool hasCapturedVariables = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2201,11 ***</span>
  void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
  {
      VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
      if (!environment.size())
          return;
<span class="line-modified">!     if (m_shouldEmitDebugHooks)</span>
          environment.markAllVariablesAsCaptured();
      if (!environment.hasCapturedVariables())
          return;
  
      RELEASE_ASSERT(loopSymbolTable);
<span class="line-new-header">--- 2231,11 ---</span>
  void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
  {
      VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
      if (!environment.size())
          return;
<span class="line-modified">!     if (shouldEmitDebugHooks())</span>
          environment.markAllVariablesAsCaptured();
      if (!environment.hasCapturedVariables())
          return;
  
      RELEASE_ASSERT(loopSymbolTable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2486,22 ***</span>
          return value;
  
      case VarKind::Scope:
      case VarKind::Invalid: {
          GetPutInfo getPutInfo(0);
<span class="line-modified">!         int scopeDepth;</span>
          ScopeOffset offset;
          if (variable.offset().isScope()) {
              offset = variable.offset().scopeOffset();
              getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
<span class="line-modified">!             scopeDepth = variable.symbolTableConstantIndex();</span>
          } else {
              ASSERT(resolveType() != LocalClosureVar);
              getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
<span class="line-modified">!             scopeDepth = localScopeDepth();</span>
          }
<span class="line-modified">!         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, scopeDepth, !!offset ? offset.offset() : 0);</span>
          m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
          return value;
      } }
  
      RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 2516,22 ---</span>
          return value;
  
      case VarKind::Scope:
      case VarKind::Invalid: {
          GetPutInfo getPutInfo(0);
<span class="line-modified">!         SymbolTableOrScopeDepth symbolTableOrScopeDepth;</span>
          ScopeOffset offset;
          if (variable.offset().isScope()) {
              offset = variable.offset().scopeOffset();
              getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
<span class="line-modified">!             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });</span>
          } else {
              ASSERT(resolveType() != LocalClosureVar);
              getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
<span class="line-modified">!             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());</span>
          }
<span class="line-modified">!         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);</span>
          m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
          return value;
      } }
  
      RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2603,11 ***</span>
  
      unsigned propertyIndex = addConstant(property);
  
      m_staticPropertyAnalyzer.putById(base, propertyIndex);
  
<span class="line-modified">!     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm-&gt;propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;</span>
      OpPutById::emit(this, base, propertyIndex, value, type);
      m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
      return value;
  }
  
<span class="line-new-header">--- 2633,11 ---</span>
  
      unsigned propertyIndex = addConstant(property);
  
      m_staticPropertyAnalyzer.putById(base, propertyIndex);
  
<span class="line-modified">!     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;</span>
      OpPutById::emit(this, base, propertyIndex, value, type);
      m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());
      return value;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2695,17 ***</span>
          if (context.local() != property)
              continue;
  
          if (context.isIndexedForInContext()) {
              auto&amp; indexedContext = context.asIndexedForInContext();
<span class="line-modified">!             OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, indexedContext.index());</span>
              indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
              return dst;
          }
  
          StructureForInContext&amp; structureContext = context.asStructureForInContext();
<span class="line-modified">!         OpGetDirectPname::emit&lt;OpcodeSize::Wide&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());</span>
  
          structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
          return dst;
      }
  
<span class="line-new-header">--- 2725,24 ---</span>
          if (context.local() != property)
              continue;
  
          if (context.isIndexedForInContext()) {
              auto&amp; indexedContext = context.asIndexedForInContext();
<span class="line-modified">!             kill(dst);</span>
<span class="line-added">+             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))</span>
<span class="line-added">+                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());</span>
<span class="line-added">+             else if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Wide16&gt;(this, dst, base, property))</span>
<span class="line-added">+                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Wide16&gt;(this, dst, base, indexedContext.index());</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(this, dst, base, indexedContext.index());</span>
              indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
              return dst;
          }
  
<span class="line-added">+         // We cannot do the above optimization here since OpGetDirectPname =&gt; OpGetByVal conversion involves different metadata ID allocation.</span>
          StructureForInContext&amp; structureContext = context.asStructureForInContext();
<span class="line-modified">!         OpGetDirectPname::emit&lt;OpcodeSize::Wide32&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());</span>
  
          structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
          return dst;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2844,14 ***</span>
  
      m_TDZStack.append(WTFMove(map));
      m_cachedVariablesUnderTDZ = { };
  }
  
<span class="line-modified">! CompactVariableMap::Handle BytecodeGenerator::getVariablesUnderTDZ()</span>
  {
<span class="line-modified">!     if (m_cachedVariablesUnderTDZ)</span>
          return m_cachedVariablesUnderTDZ;
  
      // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
      // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
      //
      //     {
<span class="line-new-header">--- 2881,19 ---</span>
  
      m_TDZStack.append(WTFMove(map));
      m_cachedVariablesUnderTDZ = { };
  }
  
<span class="line-modified">! Optional&lt;CompactVariableMap::Handle&gt; BytecodeGenerator::getVariablesUnderTDZ()</span>
  {
<span class="line-modified">!     if (m_cachedVariablesUnderTDZ) {</span>
<span class="line-added">+         if (!m_hasCachedVariablesUnderTDZ) {</span>
<span class="line-added">+             ASSERT(m_cachedVariablesUnderTDZ.environment().toVariableEnvironment().isEmpty());</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+         }</span>
          return m_cachedVariablesUnderTDZ;
<span class="line-added">+     }</span>
  
      // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
      // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
      //
      //     {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2872,11 ***</span>
              } else
                  variablesThatDontNeedTDZ.add(entry.key.get());
          }
      }
  
<span class="line-modified">!     m_cachedVariablesUnderTDZ = m_vm-&gt;m_compactVariableMap-&gt;get(environment);</span>
      return m_cachedVariablesUnderTDZ;
  }
  
  void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
  {
<span class="line-new-header">--- 2914,15 ---</span>
              } else
                  variablesThatDontNeedTDZ.add(entry.key.get());
          }
      }
  
<span class="line-modified">!     m_cachedVariablesUnderTDZ = m_vm.m_compactVariableMap-&gt;get(environment);</span>
<span class="line-added">+     m_hasCachedVariablesUnderTDZ = !environment.isEmpty();</span>
<span class="line-added">+     if (!m_hasCachedVariablesUnderTDZ)</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+ </span>
      return m_cachedVariablesUnderTDZ;
  }
  
  void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2898,13 ***</span>
  }
  
  JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
  {
      return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(*vm());</span>
          auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
<span class="line-modified">!         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, *vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);</span>
          // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
          // https://bugs.webkit.org/show_bug.cgi?id=180139
          scope.assertNoException();
          RELEASE_ASSERT(bigIntInMap);
          addConstantValue(bigIntInMap);
<span class="line-new-header">--- 2944,13 ---</span>
  }
  
  JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
  {
      return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(vm());</span>
          auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
<span class="line-modified">!         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);</span>
          // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step
          // https://bugs.webkit.org/show_bug.cgi?id=180139
          scope.assertNoException();
          RELEASE_ASSERT(bigIntInMap);
          addConstantValue(bigIntInMap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2921,16 ***</span>
          addConstantValue(stringInMap);
      }
      return stringInMap;
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor)</span>
  {
<span class="line-modified">!     JSTemplateObjectDescriptor* descriptorValue = m_templateObjectDescriptorMap.ensure(descriptor.copyRef(), [&amp;] {</span>
<span class="line-modified">!         return JSTemplateObjectDescriptor::create(*vm(), WTFMove(descriptor));</span>
      }).iterator-&gt;value;
<span class="line-removed">- </span>
      int index = addConstantIndex();
      m_codeBlock-&gt;addConstant(descriptorValue);
      return &amp;m_constantPoolRegisters[index];
  }
  
<span class="line-new-header">--- 2967,16 ---</span>
          addConstantValue(stringInMap);
      }
      return stringInMap;
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)</span>
  {
<span class="line-modified">!     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));</span>
<span class="line-modified">!     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {</span>
<span class="line-added">+         return JSTemplateObjectDescriptor::create(vm(), result.iterator-&gt;copyRef(), endOffset);</span>
      }).iterator-&gt;value;
      int index = addConstantIndex();
      m_codeBlock-&gt;addConstant(descriptorValue);
      return &amp;m_constantPoolRegisters[index];
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3051,11 ***</span>
  }
  
  RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
      const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
  {
<span class="line-modified">!     UnlinkedFunctionExecutable* executable = m_vm-&gt;builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
      executable-&gt;setInvalidTypeProfilingOffsets();
      executable-&gt;setEcmaName(ecmaName);
      executable-&gt;setClassSource(classSource);
  
      unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
<span class="line-new-header">--- 3097,11 ---</span>
  }
  
  RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
      const Identifier&amp; ecmaName, const SourceCode&amp; classSource)
  {
<span class="line-modified">!     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
      executable-&gt;setInvalidTypeProfilingOffsets();
      executable-&gt;setEcmaName(ecmaName);
      executable-&gt;setClassSource(classSource);
  
      unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3086,11 ***</span>
              return;
      } else if (valueNode-&gt;isClassExprNode()) {
          ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
          if (!classExprNode-&gt;ecmaName().isNull())
              return;
<span class="line-modified">!         if (classExprNode-&gt;hasStaticProperty(m_vm-&gt;propertyNames-&gt;name))</span>
              return;
      } else
          return;
  
      // FIXME: We should use an op_call to an internal function here instead.
<span class="line-new-header">--- 3132,11 ---</span>
              return;
      } else if (valueNode-&gt;isClassExprNode()) {
          ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
          if (!classExprNode-&gt;ecmaName().isNull())
              return;
<span class="line-modified">!         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))</span>
              return;
      } else
          return;
  
      // FIXME: We should use an op_call to an internal function here instead.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3211,11 ***</span>
      // Reserve space for call frame.
      Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
      for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
          callFrame.append(newTemporary());
  
<span class="line-modified">!     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
          emitDebugHook(WillExecuteExpression, divotStart);
  
      emitExpressionInfo(divot, divotStart, divotEnd);
  
      Ref&lt;Label&gt; done = newLabel();
<span class="line-new-header">--- 3257,11 ---</span>
      // Reserve space for call frame.
      Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
      for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
          callFrame.append(newTemporary());
  
<span class="line-modified">!     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
          emitDebugHook(WillExecuteExpression, divotStart);
  
      emitExpressionInfo(divot, divotStart, divotEnd);
  
      Ref&lt;Label&gt; done = newLabel();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3252,18 ***</span>
      return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
  }
  
  RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
  {
<span class="line-modified">!     ASSERT(m_inTailPosition);</span>
      return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
  }
  
  template&lt;typename VarargsOp&gt;
  RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
  {
<span class="line-modified">!     if (m_shouldEmitDebugHooks &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
          emitDebugHook(WillExecuteExpression, divotStart);
  
      emitExpressionInfo(divot, divotStart, divotEnd);
  
      if (VarargsOp::opcodeID == op_tail_call_varargs)
<span class="line-new-header">--- 3298,19 ---</span>
      return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
  }
  
  RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
  {
<span class="line-modified">!     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.</span>
<span class="line-added">+     ASSERT(m_inTailPosition || !Options::useTailCalls());</span>
      return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
  }
  
  template&lt;typename VarargsOp&gt;
  RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
  {
<span class="line-modified">!     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)</span>
          emitDebugHook(WillExecuteExpression, divotStart);
  
      emitExpressionInfo(divot, divotStart, divotEnd);
  
      if (VarargsOp::opcodeID == op_tail_call_varargs)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3275,18 ***</span>
      return dst;
  }
  
  void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
  {
<span class="line-modified">!     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
          return;
      OpLogShadowChickenPrologue::emit(this, scopeRegister());
  }
  
  void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
  {
<span class="line-modified">!     if (!m_shouldEmitDebugHooks &amp;&amp; !Options::alwaysUseShadowChicken())</span>
          return;
      OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
  }
  
  void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
<span class="line-new-header">--- 3322,18 ---</span>
      return dst;
  }
  
  void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
  {
<span class="line-modified">!     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())</span>
          return;
      OpLogShadowChickenPrologue::emit(this, scopeRegister());
  }
  
  void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
  {
<span class="line-modified">!     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())</span>
          return;
      OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
  }
  
  void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3479,11 ***</span>
      RELEASE_ASSERT(stackEntry.m_isWithScope);
  }
  
  void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
  {
<span class="line-modified">!     if (!m_shouldEmitDebugHooks)</span>
          return;
  
      emitExpressionInfo(divot, divot, divot);
      OpDebug::emit(this, debugHookType, false);
  }
<span class="line-new-header">--- 3526,11 ---</span>
      RELEASE_ASSERT(stackEntry.m_isWithScope);
  }
  
  void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
  {
<span class="line-modified">!     if (!shouldEmitDebugHooks())</span>
          return;
  
      emitExpressionInfo(divot, divot, divot);
      OpDebug::emit(this, debugHookType, false);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3511,29 ***</span>
  {
      RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
      emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
  }
  
<span class="line-modified">! FinallyContext* BytecodeGenerator::pushFinallyControlFlowScope(Label&amp; finallyLabel)</span>
  {
<span class="line-modified">!     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), FinallyContext(m_currentFinallyContext, finallyLabel));</span>
      m_controlFlowScopeStack.append(WTFMove(scope));
  
      m_finallyDepth++;
<span class="line-modified">!     m_currentFinallyContext = &amp;m_controlFlowScopeStack.last().finallyContext;</span>
<span class="line-removed">-     return m_currentFinallyContext;</span>
  }
  
<span class="line-modified">! FinallyContext BytecodeGenerator::popFinallyControlFlowScope()</span>
  {
      ASSERT(m_controlFlowScopeStack.size());
      ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
      ASSERT(m_finallyDepth &gt; 0);
      ASSERT(m_currentFinallyContext);
      m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
      m_finallyDepth--;
<span class="line-modified">!     return m_controlFlowScopeStack.takeLast().finallyContext;</span>
  }
  
  LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
  {
      shrinkToFit(m_labelScopes);
<span class="line-new-header">--- 3558,28 ---</span>
  {
      RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
      emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
  }
  
<span class="line-modified">! void BytecodeGenerator::pushFinallyControlFlowScope(FinallyContext&amp; finallyContext)</span>
  {
<span class="line-modified">!     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), &amp;finallyContext);</span>
      m_controlFlowScopeStack.append(WTFMove(scope));
  
      m_finallyDepth++;
<span class="line-modified">!     m_currentFinallyContext = &amp;finallyContext;</span>
  }
  
<span class="line-modified">! void BytecodeGenerator::popFinallyControlFlowScope()</span>
  {
      ASSERT(m_controlFlowScopeStack.size());
      ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
      ASSERT(m_finallyDepth &gt; 0);
      ASSERT(m_currentFinallyContext);
      m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
      m_finallyDepth--;
<span class="line-modified">!     m_controlFlowScopeStack.removeLast();</span>
  }
  
  LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
  {
      shrinkToFit(m_labelScopes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3640,13 ***</span>
          m_tryContextStack.last().tryData
      });
      m_tryContextStack.removeLast();
  }
  
<span class="line-modified">! void BytecodeGenerator::emitCatch(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, TryData* data)</span>
  {
<span class="line-modified">!     m_catchesToEmit.append(CatchEntry { data, exceptionRegister, thrownValueRegister });</span>
  }
  
  void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
  {
      if (lexicalScopeIndex == CurrentLexicalScopeIndex)
<span class="line-new-header">--- 3686,27 ---</span>
          m_tryContextStack.last().tryData
      });
      m_tryContextStack.removeLast();
  }
  
<span class="line-modified">! void BytecodeGenerator::emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)</span>
  {
<span class="line-modified">!     RegisterID* unused = newTemporary();</span>
<span class="line-added">+     emitOutOfLineExceptionHandler(unused, thrownValueRegister, completionTypeRegister, data);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData* data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RegisterID* unused = newTemporary();</span>
<span class="line-added">+     ASSERT(completionTypeRegister);</span>
<span class="line-added">+     emitOutOfLineExceptionHandler(exceptionRegister, unused, completionTypeRegister, data);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VirtualRegister completionTypeVirtualRegister = completionTypeRegister ? completionTypeRegister : VirtualRegister();</span>
<span class="line-added">+     m_exceptionHandlersToEmit.append({ data, exceptionRegister, thrownValueRegister, completionTypeVirtualRegister });</span>
  }
  
  void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
  {
      if (lexicalScopeIndex == CurrentLexicalScopeIndex)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3694,11 ***</span>
  {
      OpArgumentCount::emit(this, dst);
      return dst;
  }
  
<span class="line-modified">! int BytecodeGenerator::localScopeDepth() const</span>
  {
      return m_localScopeDepth;
  }
  
  int BytecodeGenerator::labelScopeDepth() const
<span class="line-new-header">--- 3754,11 ---</span>
  {
      OpArgumentCount::emit(this, dst);
      return dst;
  }
  
<span class="line-modified">! unsigned BytecodeGenerator::localScopeDepth() const</span>
  {
      return m_localScopeDepth;
  }
  
  int BytecodeGenerator::labelScopeDepth() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3957,12 ***</span>
  void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
  {
      bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
      ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
  
<span class="line-removed">-     CompletionRecordScope completionRecordScope(*this);</span>
<span class="line-removed">- </span>
      RefPtr&lt;RegisterID&gt; subject = newTemporary();
      emitNode(subject.get(), subjectNode);
      RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
      RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
  
<span class="line-new-header">--- 4017,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3972,11 ***</span>
      Ref&lt;Label&gt; finallyLabel = newLabel();
      Ref&lt;Label&gt; catchLabel = newLabel();
      Ref&lt;Label&gt; endCatchLabel = newLabel();
  
      // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
<span class="line-modified">!     FinallyContext* finallyContext = pushFinallyControlFlowScope(finallyLabel.get());</span>
  
      {
          Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
          RefPtr&lt;RegisterID&gt; value = newTemporary();
          emitLoad(value.get(), jsUndefined());
<span class="line-new-header">--- 4030,12 ---</span>
      Ref&lt;Label&gt; finallyLabel = newLabel();
      Ref&lt;Label&gt; catchLabel = newLabel();
      Ref&lt;Label&gt; endCatchLabel = newLabel();
  
      // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
<span class="line-modified">!     FinallyContext finallyContext(*this, finallyLabel.get());</span>
<span class="line-added">+     pushFinallyControlFlowScope(finallyContext);</span>
  
      {
          Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
          RefPtr&lt;RegisterID&gt; value = newTemporary();
          emitLoad(value.get(), jsUndefined());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3998,20 ***</span>
              emitLabel(finallyViaThrowLabel.get());
              popTry(tryData, finallyViaThrowLabel.get());
  
              Ref&lt;Label&gt; finallyBodyLabel = newLabel();
              RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
<span class="line-removed">-             RegisterID* unused = newTemporary();</span>
  
<span class="line-modified">!             emitCatch(completionValueRegister(), unused, tryData);</span>
<span class="line-modified">!             emitSetCompletionType(CompletionType::Throw);</span>
<span class="line-removed">-             move(finallyExceptionRegister.get(), completionValueRegister());</span>
              emitJump(finallyBodyLabel.get());
  
              emitLabel(finallyLabel.get());
              moveEmptyValue(finallyExceptionRegister.get());
  
              emitLabel(finallyBodyLabel.get());
              restoreScopeRegister();
  
              Ref&lt;Label&gt; finallyDone = newLabel();
  
<span class="line-new-header">--- 4057,19 ---</span>
              emitLabel(finallyViaThrowLabel.get());
              popTry(tryData, finallyViaThrowLabel.get());
  
              Ref&lt;Label&gt; finallyBodyLabel = newLabel();
              RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
  
<span class="line-modified">!             emitOutOfLineFinallyHandler(finallyContext.completionValueRegister(), finallyContext.completionTypeRegister(), tryData);</span>
<span class="line-modified">!             move(finallyExceptionRegister.get(), finallyContext.completionValueRegister());</span>
              emitJump(finallyBodyLabel.get());
  
              emitLabel(finallyLabel.get());
              moveEmptyValue(finallyExceptionRegister.get());
  
<span class="line-added">+             // Finally fall through case.</span>
              emitLabel(finallyBodyLabel.get());
              restoreScopeRegister();
  
              Ref&lt;Label&gt; finallyDone = newLabel();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4031,24 ***</span>
  
              emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
              emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
  
              emitLabel(finallyDone.get());
<span class="line-modified">!             emitFinallyCompletion(*finallyContext, completionTypeRegister(), endCatchLabel.get());</span>
  
              popTry(returnCallTryData, finallyDone.get());
  
              // Catch block for exceptions that may be thrown while calling the return
              // handler in the enumeration finally block. The only reason we need this
              // catch block is because if entered the above finally block due to a thrown
              // exception, then we want to re-throw the original exception on exiting
              // the finally block. Otherwise, we&#39;ll let any new exception pass through.
              {
                  emitLabel(catchLabel.get());
                  RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
<span class="line-modified">!                 RegisterID* unused = newTemporary();</span>
<span class="line-removed">-                 emitCatch(exceptionRegister.get(), unused, returnCallTryData);</span>
                  // Since this is a synthesized catch block and we&#39;re guaranteed to never need
                  // to resolve any symbols from the scope, we can skip restoring the scope
                  // register here.
  
                  Ref&lt;Label&gt; throwLabel = newLabel();
<span class="line-new-header">--- 4089,24 ---</span>
  
              emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
              emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
  
              emitLabel(finallyDone.get());
<span class="line-modified">!             emitFinallyCompletion(finallyContext, endCatchLabel.get());</span>
  
              popTry(returnCallTryData, finallyDone.get());
  
              // Catch block for exceptions that may be thrown while calling the return
              // handler in the enumeration finally block. The only reason we need this
              // catch block is because if entered the above finally block due to a thrown
              // exception, then we want to re-throw the original exception on exiting
              // the finally block. Otherwise, we&#39;ll let any new exception pass through.
              {
                  emitLabel(catchLabel.get());
<span class="line-added">+ </span>
                  RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
<span class="line-modified">!                 emitOutOfLineFinallyHandler(exceptionRegister.get(), finallyContext.completionTypeRegister(), returnCallTryData);</span>
                  // Since this is a synthesized catch block and we&#39;re guaranteed to never need
                  // to resolve any symbols from the scope, we can skip restoring the scope
                  // register here.
  
                  Ref&lt;Label&gt; throwLabel = newLabel();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4102,11 ***</span>
          if (!string-&gt;cooked())
              cookedStrings.append(WTF::nullopt);
          else
              cookedStrings.append(string-&gt;cooked()-&gt;impl());
      }
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)));</span>
      if (!dst)
          return constant.get();
      return move(dst, constant.get());
  }
  
<span class="line-new-header">--- 4160,11 ---</span>
          if (!string-&gt;cooked())
              cookedStrings.append(WTF::nullopt);
          else
              cookedStrings.append(string-&gt;cooked()-&gt;impl());
      }
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)), taggedTemplate-&gt;endOffset());</span>
      if (!dst)
          return constant.get();
      return move(dst, constant.get());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4395,14 ***</span>
      return result;
  }
  
  void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
  {
<span class="line-removed">-     // FIXME: op_jneq_null treats &quot;undetectable&quot; objects as null/undefined. RequireObjectCoercible</span>
<span class="line-removed">-     // thus incorrectly throws a TypeError for interfaces like HTMLAllCollection.</span>
      Ref&lt;Label&gt; target = newLabel();
<span class="line-modified">!     OpJneqNull::emit(this, value, target-&gt;bind(this));</span>
      emitThrowTypeError(error);
      emitLabel(target.get());
  }
  
  void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
<span class="line-new-header">--- 4453,12 ---</span>
      return result;
  }
  
  void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
  {
      Ref&lt;Label&gt; target = newLabel();
<span class="line-modified">!     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));</span>
      emitThrowTypeError(error);
      emitLabel(target.get());
  }
  
  void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4433,11 ***</span>
  
  
  #if CPU(NEEDS_ALIGNED_ACCESS)
      // conservatively align for the bytecode rewriter: it will delete this yield and
      // append a fragment, so we make sure that the start of the fragments is aligned
<span class="line-modified">!     while (m_writer.position() % OpcodeSize::Wide)</span>
          OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
  #endif
      OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
  
      // Restore the try contexts, which start offset is updated to the merge point.
<span class="line-new-header">--- 4489,11 ---</span>
  
  
  #if CPU(NEEDS_ALIGNED_ACCESS)
      // conservatively align for the bytecode rewriter: it will delete this yield and
      // append a fragment, so we make sure that the start of the fragments is aligned
<span class="line-modified">!     while (m_writer.position() % OpcodeSize::Wide32)</span>
          OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
  #endif
      OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
  
      // Restore the try contexts, which start offset is updated to the merge point.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4683,11 ***</span>
      FinallyContext* outermostFinallyContext = nullptr;
      size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
      while (numberOfScopesToCheckForFinally--) {
          ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
          if (scope-&gt;isFinallyScope()) {
<span class="line-modified">!             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
              if (!innermostFinallyContext)
                  innermostFinallyContext = finallyContext;
              outermostFinallyContext = finallyContext;
              finallyContext-&gt;incNumberOfBreaksOrContinues();
          }
<span class="line-new-header">--- 4739,11 ---</span>
      FinallyContext* outermostFinallyContext = nullptr;
      size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
      while (numberOfScopesToCheckForFinally--) {
          ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
          if (scope-&gt;isFinallyScope()) {
<span class="line-modified">!             FinallyContext* finallyContext = scope-&gt;finallyContext;</span>
              if (!innermostFinallyContext)
                  innermostFinallyContext = finallyContext;
              outermostFinallyContext = finallyContext;
              finallyContext-&gt;incNumberOfBreaksOrContinues();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4697,11 ***</span>
  
      auto jumpID = bytecodeOffsetToJumpID(instructions().size());
      int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
      outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
  
<span class="line-modified">!     emitSetCompletionType(jumpID);</span>
      emitJump(*innermostFinallyContext-&gt;finallyLabel());
      return true; // We&#39;ll be jumping to a finally block.
  }
  
  bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
<span class="line-new-header">--- 4753,11 ---</span>
  
      auto jumpID = bytecodeOffsetToJumpID(instructions().size());
      int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
      outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
  
<span class="line-modified">!     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), jumpID);</span>
      emitJump(*innermostFinallyContext-&gt;finallyLabel());
      return true; // We&#39;ll be jumping to a finally block.
  }
  
  bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4713,102 ***</span>
      FinallyContext* innermostFinallyContext = nullptr;
      while (numberOfScopesToCheckForFinally) {
          size_t scopeIndex = --numberOfScopesToCheckForFinally;
          ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
          if (scope-&gt;isFinallyScope()) {
<span class="line-modified">!             FinallyContext* finallyContext = &amp;scope-&gt;finallyContext;</span>
              if (!innermostFinallyContext)
                  innermostFinallyContext = finallyContext;
              finallyContext-&gt;setHandlesReturns();
          }
      }
      if (!innermostFinallyContext)
          return false; // No finallys to thread through.
  
<span class="line-modified">!     emitSetCompletionType(CompletionType::Return);</span>
<span class="line-modified">!     emitSetCompletionValue(returnRegister);</span>
      emitJump(*innermostFinallyContext-&gt;finallyLabel());
      return true; // We&#39;ll be jumping to a finally block.
  }
  
<span class="line-modified">! void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, RegisterID* completionTypeRegister, Label&amp; normalCompletionLabel)</span>
  {
      if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
<span class="line-modified">!         emitJumpIf&lt;OpStricteq&gt;(completionTypeRegister, CompletionType::Normal, normalCompletionLabel);</span>
  
          FinallyContext* outerContext = context.outerContext();
  
          size_t numberOfJumps = context.numberOfJumps();
          ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
  
          for (size_t i = 0; i &lt; numberOfJumps; i++) {
              Ref&lt;Label&gt; nextLabel = newLabel();
              auto&amp; jump = context.jumps(i);
<span class="line-modified">!             emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, jump.jumpID, nextLabel.get());</span>
  
              restoreScopeRegister(jump.targetLexicalScopeIndex);
<span class="line-modified">!             emitSetCompletionType(CompletionType::Normal);</span>
              emitJump(jump.targetLabel.get());
  
              emitLabel(nextLabel.get());
          }
  
          if (outerContext) {
<span class="line-modified">!             // We are not the outermost finally.</span>
<span class="line-modified">!             bool hasBreaksOrContinuesNotCoveredByJumps = context.numberOfBreaksOrContinues() &gt; numberOfJumps;</span>
<span class="line-modified">!             if (hasBreaksOrContinuesNotCoveredByJumps || context.handlesReturns())</span>
<span class="line-modified">!                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, *outerContext-&gt;finallyLabel());</span>
  
          } else {
              // We are the outermost finally.
              if (context.handlesReturns()) {
                  Ref&lt;Label&gt; notReturnLabel = newLabel();
<span class="line-modified">!                 emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Return, notReturnLabel.get());</span>
  
                  emitWillLeaveCallFrameDebugHook();
<span class="line-modified">!                 emitReturn(completionValueRegister(), ReturnFrom::Finally);</span>
  
                  emitLabel(notReturnLabel.get());
              }
          }
      }
<span class="line-removed">-     emitJumpIf&lt;OpNstricteq&gt;(completionTypeRegister, CompletionType::Throw, normalCompletionLabel);</span>
<span class="line-removed">-     emitThrow(completionValueRegister());</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool BytecodeGenerator::allocateCompletionRecordRegisters()</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     if (m_completionTypeRegister)</span>
<span class="line-removed">-         return false;</span>
  
<span class="line-modified">!     ASSERT(!m_completionValueRegister);</span>
<span class="line-removed">-     m_completionTypeRegister = newTemporary();</span>
<span class="line-removed">-     m_completionValueRegister = newTemporary();</span>
  
<span class="line-modified">!     emitSetCompletionType(CompletionType::Normal);</span>
<span class="line-modified">!     moveEmptyValue(m_completionValueRegister.get());</span>
<span class="line-modified">!     return true;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void BytecodeGenerator::releaseCompletionRecordRegisters()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_completionTypeRegister &amp;&amp; m_completionValueRegister);</span>
<span class="line-removed">-     m_completionTypeRegister = nullptr;</span>
<span class="line-removed">-     m_completionValueRegister = nullptr;</span>
  }
  
  template&lt;typename CompareOp&gt;
  void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
  {
      RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
      RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
      OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
  
<span class="line-modified">!     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), valueConstant, completionTypeRegister, operandTypes);</span>
      emitJumpIfTrue(equivalenceResult, jumpTarget);
  }
  
  void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
  {
      // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
      // either of the following conditions is true:
      //
<span class="line-new-header">--- 4769,221 ---</span>
      FinallyContext* innermostFinallyContext = nullptr;
      while (numberOfScopesToCheckForFinally) {
          size_t scopeIndex = --numberOfScopesToCheckForFinally;
          ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
          if (scope-&gt;isFinallyScope()) {
<span class="line-modified">!             FinallyContext* finallyContext = scope-&gt;finallyContext;</span>
              if (!innermostFinallyContext)
                  innermostFinallyContext = finallyContext;
              finallyContext-&gt;setHandlesReturns();
          }
      }
      if (!innermostFinallyContext)
          return false; // No finallys to thread through.
  
<span class="line-modified">!     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), CompletionType::Return);</span>
<span class="line-modified">!     move(innermostFinallyContext-&gt;completionValueRegister(), returnRegister);</span>
      emitJump(*innermostFinallyContext-&gt;finallyLabel());
      return true; // We&#39;ll be jumping to a finally block.
  }
  
<span class="line-modified">! void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, Label&amp; normalCompletionLabel)</span>
  {
      if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
<span class="line-modified">!         emitJumpIf&lt;OpStricteq&gt;(context.completionTypeRegister(), CompletionType::Normal, normalCompletionLabel);</span>
  
          FinallyContext* outerContext = context.outerContext();
  
          size_t numberOfJumps = context.numberOfJumps();
          ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
  
<span class="line-added">+         // Handle Break or Continue completions that jumps into this FinallyContext.</span>
          for (size_t i = 0; i &lt; numberOfJumps; i++) {
              Ref&lt;Label&gt; nextLabel = newLabel();
              auto&amp; jump = context.jumps(i);
<span class="line-modified">!             emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), jump.jumpID, nextLabel.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+             // This case is for Break / Continue completions from an inner finally context</span>
<span class="line-added">+             // with a jump target that is not beyond the next outer finally context:</span>
<span class="line-added">+             //</span>
<span class="line-added">+             //     try {</span>
<span class="line-added">+             //         for (... stuff ...) {</span>
<span class="line-added">+             //             try {</span>
<span class="line-added">+             //                 continue; // Sets completionType to jumpID of top of the for loop.</span>
<span class="line-added">+             //             } finally {</span>
<span class="line-added">+             //             } // Jump to top of the for loop on completion.</span>
<span class="line-added">+             //         }</span>
<span class="line-added">+             //     } finally {</span>
<span class="line-added">+             //     }</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // Since the jumpID is targetting a label that is inside the outer finally context,</span>
<span class="line-added">+             // we can jump to it directly on completion of this finally context: there is no intermediate</span>
<span class="line-added">+             // finally blocks to run. After the Break / Continue, we will contnue execution as normal.</span>
<span class="line-added">+             // So, we&#39;ll set the completionType to Normal (on behalf of the target) before we jump.</span>
<span class="line-added">+             // We can also set the completion value to undefined, but it will never be used for normal</span>
<span class="line-added">+             // completion anyway. So, we&#39;ll skip setting it.</span>
  
              restoreScopeRegister(jump.targetLexicalScopeIndex);
<span class="line-modified">!             emitLoad(context.completionTypeRegister(), CompletionType::Normal);</span>
              emitJump(jump.targetLabel.get());
  
              emitLabel(nextLabel.get());
          }
  
<span class="line-added">+         // Handle completions that take us out of this FinallyContext.</span>
          if (outerContext) {
<span class="line-modified">!             if (context.handlesReturns()) {</span>
<span class="line-modified">!                 Ref&lt;Label&gt; isNotReturnLabel = newLabel();</span>
<span class="line-modified">!                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, isNotReturnLabel.get());</span>
<span class="line-modified">! </span>
<span class="line-added">+                 // This case is for Return completion from an inner finally context:</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 //     try {</span>
<span class="line-added">+                 //         try {</span>
<span class="line-added">+                 //             return result; // Sets completionType to Return, and completionValue to result.</span>
<span class="line-added">+                 //         } finally {</span>
<span class="line-added">+                 //         } // Jump to outer finally on completion.</span>
<span class="line-added">+                 //     } finally {</span>
<span class="line-added">+                 //     }</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // Since we know there&#39;s at least one outer finally context (beyond the current context),</span>
<span class="line-added">+                 // we cannot actually return from here. Instead, we pass the completionType and completionValue</span>
<span class="line-added">+                 // on to the next outer finally, and let it decide what to do next on its completion. The</span>
<span class="line-added">+                 // outer finally may or may not actual return depending on whether it encounters an abrupt</span>
<span class="line-added">+                 // completion in its body that overrrides this Return completion.</span>
<span class="line-added">+ </span>
<span class="line-added">+                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());</span>
<span class="line-added">+                 move(outerContext-&gt;completionValueRegister(), context.completionValueRegister());</span>
<span class="line-added">+                 emitJump(*outerContext-&gt;finallyLabel());</span>
<span class="line-added">+ </span>
<span class="line-added">+                 emitLabel(isNotReturnLabel.get());</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             bool hasBreaksOrContinuesThatEscapeCurrentFinally = context.numberOfBreaksOrContinues() &gt; numberOfJumps;</span>
<span class="line-added">+             if (hasBreaksOrContinuesThatEscapeCurrentFinally) {</span>
<span class="line-added">+                 Ref&lt;Label&gt; isThrowOrNormalLabel = newLabel();</span>
<span class="line-added">+                 emitJumpIf&lt;OpBeloweq&gt;(context.completionTypeRegister(), CompletionType::Throw, isThrowOrNormalLabel.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // A completionType above Throw means we have a Break or Continue encoded as a jumpID.</span>
<span class="line-added">+                 // We already ruled out Return above.</span>
<span class="line-added">+                 static_assert(CompletionType::Throw &lt; CompletionType::Return &amp;&amp; CompletionType::Throw &lt; CompletionType::Return, &quot;jumpIDs are above CompletionType::Return&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // This case is for Break / Continue completions in an inner finally context:</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // 10: label:</span>
<span class="line-added">+                 // 11: try {</span>
<span class="line-added">+                 // 12:     try {</span>
<span class="line-added">+                 // 13:         for (... stuff ...)</span>
<span class="line-added">+                 // 14:             break label; // Sets completionType to jumpID of label.</span>
<span class="line-added">+                 // 15:     } finally {</span>
<span class="line-added">+                 // 16:     } // Jumps to outer finally on completion.</span>
<span class="line-added">+                 // 17:  } finally {</span>
<span class="line-added">+                 // 18:  }</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // The break (line 14) says to continue execution at the label at line 10. Before we can</span>
<span class="line-added">+                 // goto line 10, the inner context&#39;s finally (line 15) needs to be run, followed by the</span>
<span class="line-added">+                 // outer context&#39;s finally (line 17). &#39;outerContext&#39; being non-null above tells us that</span>
<span class="line-added">+                 // there is at least one outer finally context that we need to run after we complete the</span>
<span class="line-added">+                 // current finally. Note that unless the body of the outer finally abruptly completes in a</span>
<span class="line-added">+                 // different way, that outer finally also needs to complete with a Break / Continue to</span>
<span class="line-added">+                 // the same target label. Hence, we need to pass the jumpID in this finally&#39;s completionTypeRegister</span>
<span class="line-added">+                 // to the outer finally. The completion value for Break and Continue according to the spec</span>
<span class="line-added">+                 // is undefined, but it won&#39;t ever be used. So, we&#39;ll skip setting it.</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // Note that all we&#39;re doing here is passing the Break / Continue completion to the next</span>
<span class="line-added">+                 // outer finally context. We don&#39;t worry about finally contexts beyond that. It is the</span>
<span class="line-added">+                 // responsibility of the next outer finally to determine what to do next at its completion,</span>
<span class="line-added">+                 // and pass on to the next outer context if present and needed.</span>
<span class="line-added">+ </span>
<span class="line-added">+                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());</span>
<span class="line-added">+                 emitJump(*outerContext-&gt;finallyLabel());</span>
<span class="line-added">+ </span>
<span class="line-added">+                 emitLabel(isThrowOrNormalLabel.get());</span>
<span class="line-added">+             }</span>
  
          } else {
              // We are the outermost finally.
              if (context.handlesReturns()) {
                  Ref&lt;Label&gt; notReturnLabel = newLabel();
<span class="line-modified">!                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, notReturnLabel.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // This case is for Return completion from the outermost finally context:</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 //     try {</span>
<span class="line-added">+                 //         return result; // Sets completionType to Return, and completionValue to result.</span>
<span class="line-added">+                 //     } finally {</span>
<span class="line-added">+                 //     } // Executes the return of the completionValue.</span>
<span class="line-added">+                 //</span>
<span class="line-added">+                 // Since we know there&#39;s no outer finally context (beyond the current context) to run,</span>
<span class="line-added">+                 // we can actually execute a return for this Return completion. The value to return</span>
<span class="line-added">+                 // is whatever is in the completionValueRegister.</span>
  
                  emitWillLeaveCallFrameDebugHook();
<span class="line-modified">!                 emitReturn(context.completionValueRegister(), ReturnFrom::Finally);</span>
  
                  emitLabel(notReturnLabel.get());
              }
          }
      }
  
<span class="line-modified">!     // By now, we&#39;ve rule out all Break / Continue / Return completions above. The only remaining</span>
<span class="line-modified">!     // possibilities are Normal or Throw.</span>
  
<span class="line-modified">!     emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Throw, normalCompletionLabel);</span>
  
<span class="line-modified">!     // We get here because we entered this finally context with Throw completionType (i.e. we have</span>
<span class="line-modified">!     // an exception that we need to rethrow), and we didn&#39;t encounter a different abrupt completion</span>
<span class="line-modified">!     // that overrides that incoming completionType. All we have to do here is re-throw the exception</span>
<span class="line-modified">!     // captured in the completionValue.</span>
<span class="line-added">+     //</span>
<span class="line-added">+     // Note that unlike for Break / Continue / Return, we don&#39;t need to worry about outer finally</span>
<span class="line-added">+     // contexts. This is because any outer finally context (if present) will have its own exception</span>
<span class="line-added">+     // handler, which will take care of receiving the Throw completion, and re-capturing the exception</span>
<span class="line-added">+     // in its completionValue.</span>
  
<span class="line-modified">!     emitThrow(context.completionValueRegister());</span>
  }
  
  template&lt;typename CompareOp&gt;
  void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
  {
      RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
      RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
      OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
  
<span class="line-modified">!     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), completionTypeRegister, valueConstant, operandTypes);</span>
      emitJumpIfTrue(equivalenceResult, jumpTarget);
  }
  
<span class="line-added">+ void BytecodeGenerator::pushOptionalChainTarget()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_optionalChainTargetStack.append(newLabel());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::popOptionalChainTarget()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_optionalChainTargetStack.size());</span>
<span class="line-added">+     emitLabel(m_optionalChainTargetStack.takeLast().get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Ref&lt;Label&gt; endLabel = newLabel();</span>
<span class="line-added">+     emitJump(endLabel.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     popOptionalChainTarget();</span>
<span class="line-added">+     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLabel(endLabel.get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::emitOptionalCheck(RegisterID* src)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_optionalChainTargetStack.size());</span>
<span class="line-added">+     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)
  {
      // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
      // either of the following conditions is true:
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4845,11 ***</span>
      for (const auto&amp; instTuple : m_getInsts) {
          unsigned instIndex = std::get&lt;0&gt;(instTuple);
          int propertyRegIndex = std::get&lt;1&gt;(instTuple);
          auto instruction = generator.m_writer.ref(instIndex);
          auto end = instIndex + instruction-&gt;size();
<span class="line-modified">!         ASSERT(instruction-&gt;isWide());</span>
  
          generator.m_writer.seek(instIndex);
  
          auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
  
<span class="line-new-header">--- 5020,11 ---</span>
      for (const auto&amp; instTuple : m_getInsts) {
          unsigned instIndex = std::get&lt;0&gt;(instTuple);
          int propertyRegIndex = std::get&lt;1&gt;(instTuple);
          auto instruction = generator.m_writer.ref(instIndex);
          auto end = instIndex + instruction-&gt;size();
<span class="line-modified">!         ASSERT(instruction-&gt;isWide32());</span>
  
          generator.m_writer.seek(instIndex);
  
          auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4858,11 ***</span>
  
          // Change the opcode to get_by_val.
          // 1. dst stays the same.
          // 2. base stays the same.
          // 3. property gets switched to the original property.
<span class="line-modified">!         OpGetByVal::emit&lt;OpcodeSize::Wide&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));</span>
  
          // 4. nop out the remaining bytes
          while (generator.m_writer.position() &lt; end)
              OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
      }
<span class="line-new-header">--- 5033,11 ---</span>
  
          // Change the opcode to get_by_val.
          // 1. dst stays the same.
          // 2. base stays the same.
          // 3. property gets switched to the original property.
<span class="line-modified">!         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));</span>
  
          // 4. nop out the remaining bytes
          while (generator.m_writer.position() &lt; end)
              OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4880,12 ***</span>
          return;
  
      for (const auto&amp; instPair : m_getInsts) {
          unsigned instIndex = instPair.first;
          int propertyRegIndex = instPair.second;
<span class="line-removed">-         // FIXME: we should not have to force this get_by_val to be wide, just guarantee that propertyRegIndex fits</span>
<span class="line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=190929</span>
          generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
              ASSERT_NOT_REACHED();
              return VirtualRegister();
          });
      }
<span class="line-new-header">--- 5055,10 ---</span>
</pre>
<center><a href="../bytecode/Watchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>