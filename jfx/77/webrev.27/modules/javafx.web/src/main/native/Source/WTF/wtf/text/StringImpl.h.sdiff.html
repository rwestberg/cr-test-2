<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringOperators.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  57 struct CStringTranslator;
  58 struct HashAndUTF8CharactersTranslator;
  59 struct LCharBufferTranslator;
  60 struct StringHash;
  61 struct SubstringTranslator;
  62 struct UCharBufferTranslator;
  63 
  64 template&lt;typename&gt; class RetainPtr;
  65 
  66 template&lt;typename&gt; struct BufferFromStaticDataTranslator;
  67 template&lt;typename&gt; struct HashAndCharactersTranslator;
  68 
  69 // Define STRING_STATS to 1 turn on runtime statistics of string sizes and memory usage.
  70 #define STRING_STATS 0
  71 
  72 template&lt;bool isSpecialCharacter(UChar), typename CharacterType&gt; bool isAllSpecialCharacters(const CharacterType*, size_t length);
  73 
  74 #if STRING_STATS
  75 
  76 struct StringStats {

  77     void add8BitString(unsigned length, bool isSubString = false)
  78     {
  79         ++m_totalNumberStrings;
  80         ++m_number8BitStrings;
  81         if (!isSubString)
  82             m_total8BitData += length;
  83     }
  84 
  85     void add16BitString(unsigned length, bool isSubString = false)
  86     {
  87         ++m_totalNumberStrings;
  88         ++m_number16BitStrings;
  89         if (!isSubString)
  90             m_total16BitData += length;
  91     }
  92 
  93     void removeString(StringImpl&amp;);
  94     void printStats();
  95 
  96     static const unsigned s_printStringStatsFrequency = 5000;
</pre>
<hr />
<pre>
 110 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) StringImpl::stringStats().add8BitString(length, isSubString)
 111 #define STRING_STATS_ADD_16BIT_STRING(length) StringImpl::stringStats().add16BitString(length)
 112 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) StringImpl::stringStats().add16BitString(length, isSubString)
 113 #define STRING_STATS_REMOVE_STRING(string) StringImpl::stringStats().removeString(string)
 114 #define STRING_STATS_REF_STRING(string) ++StringImpl::stringStats().m_refCalls;
 115 #define STRING_STATS_DEREF_STRING(string) ++StringImpl::stringStats().m_derefCalls;
 116 
 117 #else
 118 
 119 #define STRING_STATS_ADD_8BIT_STRING(length) ((void)0)
 120 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) ((void)0)
 121 #define STRING_STATS_ADD_16BIT_STRING(length) ((void)0)
 122 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) ((void)0)
 123 #define STRING_STATS_ADD_UPCONVERTED_STRING(length) ((void)0)
 124 #define STRING_STATS_REMOVE_STRING(string) ((void)0)
 125 #define STRING_STATS_REF_STRING(string) ((void)0)
 126 #define STRING_STATS_DEREF_STRING(string) ((void)0)
 127 
 128 #endif
 129 
<span class="line-removed"> 130 template&lt;typename CharacterType&gt; inline bool isLatin1(CharacterType character)</span>
<span class="line-removed"> 131 {</span>
<span class="line-removed"> 132     using UnsignedCharacterType = typename std::make_unsigned&lt;CharacterType&gt;::type;</span>
<span class="line-removed"> 133     return static_cast&lt;UnsignedCharacterType&gt;(character) &lt;= static_cast&lt;UnsignedCharacterType&gt;(0xFF);</span>
<span class="line-removed"> 134 }</span>
<span class="line-removed"> 135 </span>
 136 class StringImplShape {
 137     WTF_MAKE_NONCOPYABLE(StringImplShape);
 138 public:
 139     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 140 
 141 protected:
 142     StringImplShape(unsigned refCount, unsigned length, const LChar*, unsigned hashAndFlags);
 143     StringImplShape(unsigned refCount, unsigned length, const UChar*, unsigned hashAndFlags);
 144 
 145     enum ConstructWithConstExprTag { ConstructWithConstExpr };
 146     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 147     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char16_t (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 148 
 149     unsigned m_refCount;
 150     unsigned m_length;
 151     union {
 152         const LChar* m_data8;
 153         const UChar* m_data16;
 154         // It seems that reinterpret_cast prevents constexpr&#39;s compile time initialization in VC++.
 155         // These are needed to avoid reinterpret_cast.
 156         const char* m_data8Char;
 157         const char16_t* m_data16Char;
 158     };
 159     mutable unsigned m_hashAndFlags;
 160 };
 161 
 162 // FIXME: Use of StringImpl and const is rather confused.
 163 // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
 164 // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
 165 // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
 166 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 167 
 168 class StringImpl : private StringImplShape {
 169     WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;
 170 
<span class="line-modified"> 171     friend class AtomicStringImpl;</span>
 172     friend class JSC::LLInt::Data;
 173     friend class JSC::LLIntOffsetsExtractor;
 174     friend class PrivateSymbolImpl;
 175     friend class RegisteredSymbolImpl;
 176     friend class SymbolImpl;
 177     friend class ExternalStringImpl;
 178 
 179     friend struct WTF::CStringTranslator;
 180     friend struct WTF::HashAndUTF8CharactersTranslator;
 181     friend struct WTF::LCharBufferTranslator;
 182     friend struct WTF::SubstringTranslator;
 183     friend struct WTF::UCharBufferTranslator;
 184 
 185     template&lt;typename&gt; friend struct WTF::BufferFromStaticDataTranslator;
 186     template&lt;typename&gt; friend struct WTF::HashAndCharactersTranslator;
 187 
 188 public:
 189     enum BufferOwnership { BufferInternal, BufferOwned, BufferSubstring, BufferExternal };
 190 
 191     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 192 
 193     // The bottom 6 bits in the hash are flags.
 194     static constexpr const unsigned s_flagCount = 6;
 195 private:
 196     static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
 197     static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
 198     static constexpr const unsigned s_flagStringKindCount = 4;
 199 
<span class="line-modified"> 200     static constexpr const unsigned s_hashFlagStringKindIsAtomic = 1u &lt;&lt; (s_flagStringKindCount);</span>
 201     static constexpr const unsigned s_hashFlagStringKindIsSymbol = 1u &lt;&lt; (s_flagStringKindCount + 1);
<span class="line-modified"> 202     static constexpr const unsigned s_hashMaskStringKind = s_hashFlagStringKindIsAtomic | s_hashFlagStringKindIsSymbol;</span>
 203     static constexpr const unsigned s_hashFlagDidReportCost = 1u &lt;&lt; 3;
 204     static constexpr const unsigned s_hashFlag8BitBuffer = 1u &lt;&lt; 2;
 205     static constexpr const unsigned s_hashMaskBufferOwnership = (1u &lt;&lt; 0) | (1u &lt;&lt; 1);
 206 
 207     enum StringKind {
 208         StringNormal = 0u, // non-symbol, non-atomic
<span class="line-modified"> 209         StringAtomic = s_hashFlagStringKindIsAtomic, // non-symbol, atomic</span>
 210         StringSymbol = s_hashFlagStringKindIsSymbol, // symbol, non-atomic
 211     };
 212 
 213     // Create a normal 8-bit string with internal storage (BufferInternal).
 214     enum Force8Bit { Force8BitConstructor };
 215     StringImpl(unsigned length, Force8Bit);
 216 
 217     // Create a normal 16-bit string with internal storage (BufferInternal).
 218     explicit StringImpl(unsigned length);
 219 
 220     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
 221     StringImpl(MallocPtr&lt;LChar&gt;, unsigned length);
 222     StringImpl(MallocPtr&lt;UChar&gt;, unsigned length);
 223     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
 224     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
 225     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 226 
 227     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
 228     StringImpl(const LChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 229     StringImpl(const UChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
</pre>
<hr />
<pre>
 248     // FIXME: Replace calls to these overloads of createFromLiteral to createWithoutCopying instead.
 249     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*, unsigned length);
 250     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*);
 251 
 252     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const UChar*, unsigned length);
 253     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
 254     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
 255     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
 256     template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
 257 
 258     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
 259     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
 260     // the originalString can&#39;t be used after this function.
 261     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 262     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 263     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 264     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 265 
 266     static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }
 267     static constexpr unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }
<span class="line-modified"> 268     static constexpr unsigned flagIsAtomic() { return s_hashFlagStringKindIsAtomic; }</span>
 269     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
 270     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
 271     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 272 
 273     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 274     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp;);
 275 
 276     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
 277     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
 278 
 279     unsigned length() const { return m_length; }
 280     static ptrdiff_t lengthMemoryOffset() { return OBJECT_OFFSETOF(StringImpl, m_length); }
 281     bool isEmpty() const { return !m_length; }
 282 
 283     bool is8Bit() const { return m_hashAndFlags &amp; s_hashFlag8BitBuffer; }
 284     ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }
 285     ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }
 286 
 287     template&lt;typename CharacterType&gt; const CharacterType* characters() const;
 288 
 289     size_t cost() const;
 290     size_t costDuringGC();
 291 
 292     WTF_EXPORT_PRIVATE size_t sizeInBytes() const;
 293 
 294     bool isSymbol() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsSymbol; }
<span class="line-modified"> 295     bool isAtomic() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsAtomic; }</span>
<span class="line-modified"> 296     void setIsAtomic(bool);</span>
 297 
 298     bool isExternal() const { return bufferOwnership() == BufferExternal; }
 299 
 300     bool isSubString() const { return bufferOwnership() == BufferSubstring; }
 301 
 302     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const LChar* characters, unsigned length);
 303     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const UChar* characters, unsigned length, ConversionMode = LenientConversion);
 304 
 305     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8ForRange(unsigned offset, unsigned length, ConversionMode = LenientConversion) const;
 306     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 307     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 308 
 309 private:
 310     static WTF_EXPORT_PRIVATE UTF8ConversionError utf8Impl(const UChar* characters, unsigned length, char*&amp; buffer, size_t bufferSize, ConversionMode);
 311 
 312     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
 313     // in the low bits because it makes them slightly more efficient to access.
 314     // So, we shift left and right when setting and getting our hash code.
 315     void setHash(unsigned) const;
 316 
</pre>
<hr />
<pre>
 342         // Used to construct static strings, which have an special refCount that can never hit zero.
 343         // This means that the static string will never be destroyed, which is important because
 344         // static strings will be shared across threads &amp; ref-counted in a non-threadsafe manner.
 345         //
 346         // In order to make StaticStringImpl thread safe, we also need to ensure that the rest of
 347         // the fields are never mutated by threads. We have this guarantee because:
 348         //
 349         // 1. m_length is only set on construction and never mutated thereafter.
 350         //
 351         // 2. m_data8 and m_data16 are only set on construction and never mutated thereafter.
 352         //    We also know that a StringImpl never changes from 8 bit to 16 bit because there
 353         //    is no way to set/clear the s_hashFlag8BitBuffer flag other than at construction.
 354         //
 355         // 3. m_hashAndFlags will not be mutated by different threads because:
 356         //
 357         //    a. StaticStringImpl&#39;s constructor sets the s_hashFlagDidReportCost flag to ensure
 358         //       that StringImpl::cost() returns early.
 359         //       This means StaticStringImpl costs are not counted. But since there should only
 360         //       be a finite set of StaticStringImpls, their cost can be aggregated into a single
 361         //       system cost if needed.
<span class="line-modified"> 362         //    b. setIsAtomic() is never called on a StaticStringImpl.</span>
<span class="line-modified"> 363         //       setIsAtomic() asserts !isStatic().</span>
 364         //    c. setHash() is never called on a StaticStringImpl.
 365         //       StaticStringImpl&#39;s constructor sets the hash on construction.
 366         //       StringImpl::hash() only sets a new hash iff !hasHash().
 367         //       Additionally, StringImpl::setHash() asserts hasHash() and !isStatic().
 368 
 369         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char (&amp;characters)[characterCount], StringKind = StringNormal);
 370         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind = StringNormal);
 371         operator StringImpl&amp;();
 372     };
 373 
<span class="line-modified"> 374     WTF_EXPORT_PRIVATE static StaticStringImpl s_atomicEmptyString;</span>
<span class="line-modified"> 375     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_atomicEmptyString); }</span>
 376 
 377     // FIXME: Does this really belong in StringImpl?
 378     template&lt;typename CharacterType&gt; static void copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters);
 379     static void copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters);
 380 
 381     // Some string features, like reference counting and the atomicity flag, are not
 382     // thread-safe. We achieve thread safety by isolation, giving each thread
 383     // its own copy of the string.
 384     Ref&lt;StringImpl&gt; isolatedCopy() const;
 385 
 386     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; substring(unsigned position, unsigned length = MaxLength);
 387 
 388     UChar at(unsigned) const;
 389     UChar operator[](unsigned i) const { return at(i); }
 390     WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);
 391 
 392     int toIntStrict(bool* ok = 0, int base = 10);
 393     unsigned toUIntStrict(bool* ok = 0, int base = 10);
 394     int64_t toInt64Strict(bool* ok = 0, int base = 10);
 395     uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
 396     intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);
 397 
 398     WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); // ignores trailing garbage
 399     unsigned toUInt(bool* ok = 0); // ignores trailing garbage
 400     int64_t toInt64(bool* ok = 0); // ignores trailing garbage
 401     uint64_t toUInt64(bool* ok = 0); // ignores trailing garbage
 402     intptr_t toIntPtr(bool* ok = 0); // ignores trailing garbage
 403 
 404     // FIXME: Like the strict functions above, these give false for &quot;ok&quot; when there is trailing garbage.
 405     // Like the non-strict functions above, these return the value when there is trailing garbage.
 406     // It would be better if these were more consistent with the above functions instead.
 407     double toDouble(bool* ok = 0);
 408     float toFloat(bool* ok = 0);
 409 
 410     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIILowercase();
 411     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIIUppercase();
 412     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocale();
 413     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned);
 414     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithoutLocale();
<span class="line-modified"> 415     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithLocale(const AtomicString&amp; localeIdentifier);</span>
<span class="line-modified"> 416     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithLocale(const AtomicString&amp; localeIdentifier);</span>
 417 
 418     Ref&lt;StringImpl&gt; foldCase();
 419 
 420     Ref&lt;StringImpl&gt; stripWhiteSpace();
 421     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; simplifyWhiteSpace();
 422     Ref&lt;StringImpl&gt; simplifyWhiteSpace(CodeUnitMatchFunction);
 423 
 424     Ref&lt;StringImpl&gt; stripLeadingAndTrailingCharacters(CodeUnitMatchFunction);
 425     Ref&lt;StringImpl&gt; removeCharacters(CodeUnitMatchFunction);
 426 
 427     bool isAllASCII() const;
 428     bool isAllLatin1() const;
 429     template&lt;bool isSpecialCharacter(UChar)&gt; bool isAllSpecialCharacters() const;
 430 
 431     size_t find(LChar character, unsigned start = 0);
 432     size_t find(char character, unsigned start = 0);
 433     size_t find(UChar character, unsigned start = 0);
 434     WTF_EXPORT_PRIVATE size_t find(CodeUnitMatchFunction, unsigned index = 0);
 435     size_t find(const LChar*, unsigned index = 0);
 436     ALWAYS_INLINE size_t find(const char* string, unsigned index = 0) { return find(reinterpret_cast&lt;const LChar*&gt;(string), index); }
</pre>
<hr />
<pre>
 664 template&lt;typename CharacterType&gt; inline size_t reverseFind(const CharacterType* characters, unsigned length, CharacterType matchCharacter, unsigned index)
 665 {
 666     if (!length)
 667         return notFound;
 668     if (index &gt;= length)
 669         index = length - 1;
 670     while (characters[index] != matchCharacter) {
 671         if (!index--)
 672             return notFound;
 673     }
 674     return index;
 675 }
 676 
 677 ALWAYS_INLINE size_t reverseFind(const UChar* characters, unsigned length, LChar matchCharacter, unsigned index)
 678 {
 679     return reverseFind(characters, length, static_cast&lt;UChar&gt;(matchCharacter), index);
 680 }
 681 
 682 inline size_t reverseFind(const LChar* characters, unsigned length, UChar matchCharacter, unsigned index)
 683 {
<span class="line-modified"> 684     if (matchCharacter &amp; ~0xFF)</span>
 685         return notFound;
 686     return reverseFind(characters, length, static_cast&lt;LChar&gt;(matchCharacter), index);
 687 }
 688 
 689 inline size_t StringImpl::find(LChar character, unsigned start)
 690 {
 691     if (is8Bit())
 692         return WTF::find(characters8(), m_length, character, start);
 693     return WTF::find(characters16(), m_length, character, start);
 694 }
 695 
 696 ALWAYS_INLINE size_t StringImpl::find(char character, unsigned start)
 697 {
 698     return find(static_cast&lt;LChar&gt;(character), start);
 699 }
 700 
 701 inline size_t StringImpl::find(UChar character, unsigned start)
 702 {
 703     if (is8Bit())
 704         return WTF::find(characters8(), m_length, character, start);
</pre>
<hr />
<pre>
 735     if (!string1)
 736         return (string2 &amp;&amp; string2-&gt;length()) ? -1 : 0;
 737     if (!string2)
 738         return string1-&gt;length() ? 1 : 0;
 739 
 740     bool string1Is8Bit = string1-&gt;is8Bit();
 741     bool string2Is8Bit = string2-&gt;is8Bit();
 742     if (string1Is8Bit) {
 743         if (string2Is8Bit)
 744             return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 745         return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 746     }
 747     if (string2Is8Bit)
 748         return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 749     return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 750 }
 751 
 752 inline bool isSpaceOrNewline(UChar32 character)
 753 {
 754     // Use isASCIISpace() for all Latin-1 characters. This will include newlines, which aren&#39;t included in Unicode DirWS.
<span class="line-modified"> 755     return character &lt;= 0xFF ? isASCIISpace(character) : u_charDirection(character) == U_WHITE_SPACE_NEUTRAL;</span>
 756 }
 757 
 758 template&lt;typename CharacterType&gt; inline unsigned lengthOfNullTerminatedString(const CharacterType* string)
 759 {
 760     ASSERT(string);
 761     size_t length = 0;
 762     while (string[length])
 763         ++length;
 764 
 765     RELEASE_ASSERT(length &lt; StringImpl::MaxLength);
 766     return static_cast&lt;unsigned&gt;(length);
 767 }
 768 
 769 inline StringImplShape::StringImplShape(unsigned refCount, unsigned length, const LChar* data8, unsigned hashAndFlags)
 770     : m_refCount(refCount)
 771     , m_length(length)
 772     , m_data8(data8)
 773     , m_hashAndFlags(hashAndFlags)
 774 {
 775 }
</pre>
<hr />
<pre>
1014     size_t result = m_length;
1015     if (!is8Bit())
1016         result &lt;&lt;= 1;
1017     return result;
1018 }
1019 
1020 inline size_t StringImpl::costDuringGC()
1021 {
1022     if (isStatic())
1023         return 0;
1024 
1025     if (bufferOwnership() == BufferSubstring)
1026         return divideRoundedUp(substringBuffer()-&gt;costDuringGC(), refCount());
1027 
1028     size_t result = m_length;
1029     if (!is8Bit())
1030         result &lt;&lt;= 1;
1031     return divideRoundedUp(result, refCount());
1032 }
1033 
<span class="line-modified">1034 inline void StringImpl::setIsAtomic(bool isAtomic)</span>
1035 {
1036     ASSERT(!isStatic());
1037     ASSERT(!isSymbol());
<span class="line-modified">1038     if (isAtomic)</span>
<span class="line-modified">1039         m_hashAndFlags |= s_hashFlagStringKindIsAtomic;</span>
1040     else
<span class="line-modified">1041         m_hashAndFlags &amp;= ~s_hashFlagStringKindIsAtomic;</span>
1042 }
1043 
1044 inline void StringImpl::setHash(unsigned hash) const
1045 {
1046     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
1047     // in the low bits because it makes them slightly more efficient to access.
1048     // So, we shift left and right when setting and getting our hash code.
1049 
1050     ASSERT(!hasHash());
1051     ASSERT(!isStatic());
1052     // Multiple clients assume that StringHasher is the canonical string hash function.
1053     ASSERT(hash == (is8Bit() ? StringHasher::computeHashAndMaskTop8Bits(m_data8, m_length) : StringHasher::computeHashAndMaskTop8Bits(m_data16, m_length)));
1054     ASSERT(!(hash &amp; (s_flagMask &lt;&lt; (8 * sizeof(hash) - s_flagCount)))); // Verify that enough high bits are empty.
1055 
1056     hash &lt;&lt;= s_flagCount;
1057     ASSERT(!(hash &amp; m_hashAndFlags)); // Verify that enough low bits are empty after shift.
1058     ASSERT(hash); // Verify that 0 is a valid sentinel hash value.
1059 
1060     m_hashAndFlags |= hash; // Store hash with flags in low bits.
1061 }
</pre>
<hr />
<pre>
1225 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1226 {
1227     return string &amp;&amp; startsWithLettersIgnoringASCIICase(*string, lowercaseLetters);
1228 }
1229 
1230 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl&amp; string, const char (&amp;lowercaseLetters)[length])
1231 {
1232     return equalLettersIgnoringASCIICaseCommon(string, lowercaseLetters);
1233 }
1234 
1235 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1236 {
1237     return string &amp;&amp; equalLettersIgnoringASCIICase(*string, lowercaseLetters);
1238 }
1239 
1240 } // namespace WTF
1241 
1242 using WTF::StaticStringImpl;
1243 using WTF::StringImpl;
1244 using WTF::equal;
<span class="line-removed">1245 using WTF::isLatin1;</span>
</pre>
</td>
<td>
<hr />
<pre>
  57 struct CStringTranslator;
  58 struct HashAndUTF8CharactersTranslator;
  59 struct LCharBufferTranslator;
  60 struct StringHash;
  61 struct SubstringTranslator;
  62 struct UCharBufferTranslator;
  63 
  64 template&lt;typename&gt; class RetainPtr;
  65 
  66 template&lt;typename&gt; struct BufferFromStaticDataTranslator;
  67 template&lt;typename&gt; struct HashAndCharactersTranslator;
  68 
  69 // Define STRING_STATS to 1 turn on runtime statistics of string sizes and memory usage.
  70 #define STRING_STATS 0
  71 
  72 template&lt;bool isSpecialCharacter(UChar), typename CharacterType&gt; bool isAllSpecialCharacters(const CharacterType*, size_t length);
  73 
  74 #if STRING_STATS
  75 
  76 struct StringStats {
<span class="line-added">  77     WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
  78     void add8BitString(unsigned length, bool isSubString = false)
  79     {
  80         ++m_totalNumberStrings;
  81         ++m_number8BitStrings;
  82         if (!isSubString)
  83             m_total8BitData += length;
  84     }
  85 
  86     void add16BitString(unsigned length, bool isSubString = false)
  87     {
  88         ++m_totalNumberStrings;
  89         ++m_number16BitStrings;
  90         if (!isSubString)
  91             m_total16BitData += length;
  92     }
  93 
  94     void removeString(StringImpl&amp;);
  95     void printStats();
  96 
  97     static const unsigned s_printStringStatsFrequency = 5000;
</pre>
<hr />
<pre>
 111 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) StringImpl::stringStats().add8BitString(length, isSubString)
 112 #define STRING_STATS_ADD_16BIT_STRING(length) StringImpl::stringStats().add16BitString(length)
 113 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) StringImpl::stringStats().add16BitString(length, isSubString)
 114 #define STRING_STATS_REMOVE_STRING(string) StringImpl::stringStats().removeString(string)
 115 #define STRING_STATS_REF_STRING(string) ++StringImpl::stringStats().m_refCalls;
 116 #define STRING_STATS_DEREF_STRING(string) ++StringImpl::stringStats().m_derefCalls;
 117 
 118 #else
 119 
 120 #define STRING_STATS_ADD_8BIT_STRING(length) ((void)0)
 121 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) ((void)0)
 122 #define STRING_STATS_ADD_16BIT_STRING(length) ((void)0)
 123 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) ((void)0)
 124 #define STRING_STATS_ADD_UPCONVERTED_STRING(length) ((void)0)
 125 #define STRING_STATS_REMOVE_STRING(string) ((void)0)
 126 #define STRING_STATS_REF_STRING(string) ((void)0)
 127 #define STRING_STATS_DEREF_STRING(string) ((void)0)
 128 
 129 #endif
 130 






 131 class StringImplShape {
 132     WTF_MAKE_NONCOPYABLE(StringImplShape);
 133 public:
 134     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 135 
 136 protected:
 137     StringImplShape(unsigned refCount, unsigned length, const LChar*, unsigned hashAndFlags);
 138     StringImplShape(unsigned refCount, unsigned length, const UChar*, unsigned hashAndFlags);
 139 
 140     enum ConstructWithConstExprTag { ConstructWithConstExpr };
 141     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 142     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char16_t (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 143 
 144     unsigned m_refCount;
 145     unsigned m_length;
 146     union {
 147         const LChar* m_data8;
 148         const UChar* m_data16;
 149         // It seems that reinterpret_cast prevents constexpr&#39;s compile time initialization in VC++.
 150         // These are needed to avoid reinterpret_cast.
 151         const char* m_data8Char;
 152         const char16_t* m_data16Char;
 153     };
 154     mutable unsigned m_hashAndFlags;
 155 };
 156 
 157 // FIXME: Use of StringImpl and const is rather confused.
 158 // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
 159 // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
 160 // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
 161 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 162 
 163 class StringImpl : private StringImplShape {
 164     WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;
 165 
<span class="line-modified"> 166     friend class AtomStringImpl;</span>
 167     friend class JSC::LLInt::Data;
 168     friend class JSC::LLIntOffsetsExtractor;
 169     friend class PrivateSymbolImpl;
 170     friend class RegisteredSymbolImpl;
 171     friend class SymbolImpl;
 172     friend class ExternalStringImpl;
 173 
 174     friend struct WTF::CStringTranslator;
 175     friend struct WTF::HashAndUTF8CharactersTranslator;
 176     friend struct WTF::LCharBufferTranslator;
 177     friend struct WTF::SubstringTranslator;
 178     friend struct WTF::UCharBufferTranslator;
 179 
 180     template&lt;typename&gt; friend struct WTF::BufferFromStaticDataTranslator;
 181     template&lt;typename&gt; friend struct WTF::HashAndCharactersTranslator;
 182 
 183 public:
 184     enum BufferOwnership { BufferInternal, BufferOwned, BufferSubstring, BufferExternal };
 185 
 186     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 187 
 188     // The bottom 6 bits in the hash are flags.
 189     static constexpr const unsigned s_flagCount = 6;
 190 private:
 191     static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
 192     static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
 193     static constexpr const unsigned s_flagStringKindCount = 4;
 194 
<span class="line-modified"> 195     static constexpr const unsigned s_hashFlagStringKindIsAtom = 1u &lt;&lt; (s_flagStringKindCount);</span>
 196     static constexpr const unsigned s_hashFlagStringKindIsSymbol = 1u &lt;&lt; (s_flagStringKindCount + 1);
<span class="line-modified"> 197     static constexpr const unsigned s_hashMaskStringKind = s_hashFlagStringKindIsAtom | s_hashFlagStringKindIsSymbol;</span>
 198     static constexpr const unsigned s_hashFlagDidReportCost = 1u &lt;&lt; 3;
 199     static constexpr const unsigned s_hashFlag8BitBuffer = 1u &lt;&lt; 2;
 200     static constexpr const unsigned s_hashMaskBufferOwnership = (1u &lt;&lt; 0) | (1u &lt;&lt; 1);
 201 
 202     enum StringKind {
 203         StringNormal = 0u, // non-symbol, non-atomic
<span class="line-modified"> 204         StringAtom = s_hashFlagStringKindIsAtom, // non-symbol, atomic</span>
 205         StringSymbol = s_hashFlagStringKindIsSymbol, // symbol, non-atomic
 206     };
 207 
 208     // Create a normal 8-bit string with internal storage (BufferInternal).
 209     enum Force8Bit { Force8BitConstructor };
 210     StringImpl(unsigned length, Force8Bit);
 211 
 212     // Create a normal 16-bit string with internal storage (BufferInternal).
 213     explicit StringImpl(unsigned length);
 214 
 215     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
 216     StringImpl(MallocPtr&lt;LChar&gt;, unsigned length);
 217     StringImpl(MallocPtr&lt;UChar&gt;, unsigned length);
 218     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
 219     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
 220     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 221 
 222     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
 223     StringImpl(const LChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 224     StringImpl(const UChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
</pre>
<hr />
<pre>
 243     // FIXME: Replace calls to these overloads of createFromLiteral to createWithoutCopying instead.
 244     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*, unsigned length);
 245     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*);
 246 
 247     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const UChar*, unsigned length);
 248     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
 249     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
 250     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
 251     template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
 252 
 253     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
 254     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
 255     // the originalString can&#39;t be used after this function.
 256     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 257     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 258     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 259     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 260 
 261     static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }
 262     static constexpr unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }
<span class="line-modified"> 263     static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }</span>
 264     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
 265     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
 266     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 267 
 268     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;
 269     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp;);
 270 
 271     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
 272     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
 273 
 274     unsigned length() const { return m_length; }
 275     static ptrdiff_t lengthMemoryOffset() { return OBJECT_OFFSETOF(StringImpl, m_length); }
 276     bool isEmpty() const { return !m_length; }
 277 
 278     bool is8Bit() const { return m_hashAndFlags &amp; s_hashFlag8BitBuffer; }
 279     ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }
 280     ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }
 281 
 282     template&lt;typename CharacterType&gt; const CharacterType* characters() const;
 283 
 284     size_t cost() const;
 285     size_t costDuringGC();
 286 
 287     WTF_EXPORT_PRIVATE size_t sizeInBytes() const;
 288 
 289     bool isSymbol() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsSymbol; }
<span class="line-modified"> 290     bool isAtom() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsAtom; }</span>
<span class="line-modified"> 291     void setIsAtom(bool);</span>
 292 
 293     bool isExternal() const { return bufferOwnership() == BufferExternal; }
 294 
 295     bool isSubString() const { return bufferOwnership() == BufferSubstring; }
 296 
 297     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const LChar* characters, unsigned length);
 298     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const UChar* characters, unsigned length, ConversionMode = LenientConversion);
 299 
 300     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8ForRange(unsigned offset, unsigned length, ConversionMode = LenientConversion) const;
 301     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 302     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 303 
 304 private:
 305     static WTF_EXPORT_PRIVATE UTF8ConversionError utf8Impl(const UChar* characters, unsigned length, char*&amp; buffer, size_t bufferSize, ConversionMode);
 306 
 307     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
 308     // in the low bits because it makes them slightly more efficient to access.
 309     // So, we shift left and right when setting and getting our hash code.
 310     void setHash(unsigned) const;
 311 
</pre>
<hr />
<pre>
 337         // Used to construct static strings, which have an special refCount that can never hit zero.
 338         // This means that the static string will never be destroyed, which is important because
 339         // static strings will be shared across threads &amp; ref-counted in a non-threadsafe manner.
 340         //
 341         // In order to make StaticStringImpl thread safe, we also need to ensure that the rest of
 342         // the fields are never mutated by threads. We have this guarantee because:
 343         //
 344         // 1. m_length is only set on construction and never mutated thereafter.
 345         //
 346         // 2. m_data8 and m_data16 are only set on construction and never mutated thereafter.
 347         //    We also know that a StringImpl never changes from 8 bit to 16 bit because there
 348         //    is no way to set/clear the s_hashFlag8BitBuffer flag other than at construction.
 349         //
 350         // 3. m_hashAndFlags will not be mutated by different threads because:
 351         //
 352         //    a. StaticStringImpl&#39;s constructor sets the s_hashFlagDidReportCost flag to ensure
 353         //       that StringImpl::cost() returns early.
 354         //       This means StaticStringImpl costs are not counted. But since there should only
 355         //       be a finite set of StaticStringImpls, their cost can be aggregated into a single
 356         //       system cost if needed.
<span class="line-modified"> 357         //    b. setIsAtom() is never called on a StaticStringImpl.</span>
<span class="line-modified"> 358         //       setIsAtom() asserts !isStatic().</span>
 359         //    c. setHash() is never called on a StaticStringImpl.
 360         //       StaticStringImpl&#39;s constructor sets the hash on construction.
 361         //       StringImpl::hash() only sets a new hash iff !hasHash().
 362         //       Additionally, StringImpl::setHash() asserts hasHash() and !isStatic().
 363 
 364         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char (&amp;characters)[characterCount], StringKind = StringNormal);
 365         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind = StringNormal);
 366         operator StringImpl&amp;();
 367     };
 368 
<span class="line-modified"> 369     WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;</span>
<span class="line-modified"> 370     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_emptyAtomString); }</span>
 371 
 372     // FIXME: Does this really belong in StringImpl?
 373     template&lt;typename CharacterType&gt; static void copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters);
 374     static void copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters);
 375 
 376     // Some string features, like reference counting and the atomicity flag, are not
 377     // thread-safe. We achieve thread safety by isolation, giving each thread
 378     // its own copy of the string.
 379     Ref&lt;StringImpl&gt; isolatedCopy() const;
 380 
 381     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; substring(unsigned position, unsigned length = MaxLength);
 382 
 383     UChar at(unsigned) const;
 384     UChar operator[](unsigned i) const { return at(i); }
 385     WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);
 386 
 387     int toIntStrict(bool* ok = 0, int base = 10);
 388     unsigned toUIntStrict(bool* ok = 0, int base = 10);
 389     int64_t toInt64Strict(bool* ok = 0, int base = 10);
 390     uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
 391     intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);
 392 
 393     WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); // ignores trailing garbage
 394     unsigned toUInt(bool* ok = 0); // ignores trailing garbage
 395     int64_t toInt64(bool* ok = 0); // ignores trailing garbage
 396     uint64_t toUInt64(bool* ok = 0); // ignores trailing garbage
 397     intptr_t toIntPtr(bool* ok = 0); // ignores trailing garbage
 398 
 399     // FIXME: Like the strict functions above, these give false for &quot;ok&quot; when there is trailing garbage.
 400     // Like the non-strict functions above, these return the value when there is trailing garbage.
 401     // It would be better if these were more consistent with the above functions instead.
 402     double toDouble(bool* ok = 0);
 403     float toFloat(bool* ok = 0);
 404 
 405     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIILowercase();
 406     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIIUppercase();
 407     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocale();
 408     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned);
 409     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithoutLocale();
<span class="line-modified"> 410     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithLocale(const AtomString&amp; localeIdentifier);</span>
<span class="line-modified"> 411     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithLocale(const AtomString&amp; localeIdentifier);</span>
 412 
 413     Ref&lt;StringImpl&gt; foldCase();
 414 
 415     Ref&lt;StringImpl&gt; stripWhiteSpace();
 416     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; simplifyWhiteSpace();
 417     Ref&lt;StringImpl&gt; simplifyWhiteSpace(CodeUnitMatchFunction);
 418 
 419     Ref&lt;StringImpl&gt; stripLeadingAndTrailingCharacters(CodeUnitMatchFunction);
 420     Ref&lt;StringImpl&gt; removeCharacters(CodeUnitMatchFunction);
 421 
 422     bool isAllASCII() const;
 423     bool isAllLatin1() const;
 424     template&lt;bool isSpecialCharacter(UChar)&gt; bool isAllSpecialCharacters() const;
 425 
 426     size_t find(LChar character, unsigned start = 0);
 427     size_t find(char character, unsigned start = 0);
 428     size_t find(UChar character, unsigned start = 0);
 429     WTF_EXPORT_PRIVATE size_t find(CodeUnitMatchFunction, unsigned index = 0);
 430     size_t find(const LChar*, unsigned index = 0);
 431     ALWAYS_INLINE size_t find(const char* string, unsigned index = 0) { return find(reinterpret_cast&lt;const LChar*&gt;(string), index); }
</pre>
<hr />
<pre>
 659 template&lt;typename CharacterType&gt; inline size_t reverseFind(const CharacterType* characters, unsigned length, CharacterType matchCharacter, unsigned index)
 660 {
 661     if (!length)
 662         return notFound;
 663     if (index &gt;= length)
 664         index = length - 1;
 665     while (characters[index] != matchCharacter) {
 666         if (!index--)
 667             return notFound;
 668     }
 669     return index;
 670 }
 671 
 672 ALWAYS_INLINE size_t reverseFind(const UChar* characters, unsigned length, LChar matchCharacter, unsigned index)
 673 {
 674     return reverseFind(characters, length, static_cast&lt;UChar&gt;(matchCharacter), index);
 675 }
 676 
 677 inline size_t reverseFind(const LChar* characters, unsigned length, UChar matchCharacter, unsigned index)
 678 {
<span class="line-modified"> 679     if (!isLatin1(matchCharacter))</span>
 680         return notFound;
 681     return reverseFind(characters, length, static_cast&lt;LChar&gt;(matchCharacter), index);
 682 }
 683 
 684 inline size_t StringImpl::find(LChar character, unsigned start)
 685 {
 686     if (is8Bit())
 687         return WTF::find(characters8(), m_length, character, start);
 688     return WTF::find(characters16(), m_length, character, start);
 689 }
 690 
 691 ALWAYS_INLINE size_t StringImpl::find(char character, unsigned start)
 692 {
 693     return find(static_cast&lt;LChar&gt;(character), start);
 694 }
 695 
 696 inline size_t StringImpl::find(UChar character, unsigned start)
 697 {
 698     if (is8Bit())
 699         return WTF::find(characters8(), m_length, character, start);
</pre>
<hr />
<pre>
 730     if (!string1)
 731         return (string2 &amp;&amp; string2-&gt;length()) ? -1 : 0;
 732     if (!string2)
 733         return string1-&gt;length() ? 1 : 0;
 734 
 735     bool string1Is8Bit = string1-&gt;is8Bit();
 736     bool string2Is8Bit = string2-&gt;is8Bit();
 737     if (string1Is8Bit) {
 738         if (string2Is8Bit)
 739             return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 740         return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 741     }
 742     if (string2Is8Bit)
 743         return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 744     return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 745 }
 746 
 747 inline bool isSpaceOrNewline(UChar32 character)
 748 {
 749     // Use isASCIISpace() for all Latin-1 characters. This will include newlines, which aren&#39;t included in Unicode DirWS.
<span class="line-modified"> 750     return isLatin1(character) ? isASCIISpace(character) : u_charDirection(character) == U_WHITE_SPACE_NEUTRAL;</span>
 751 }
 752 
 753 template&lt;typename CharacterType&gt; inline unsigned lengthOfNullTerminatedString(const CharacterType* string)
 754 {
 755     ASSERT(string);
 756     size_t length = 0;
 757     while (string[length])
 758         ++length;
 759 
 760     RELEASE_ASSERT(length &lt; StringImpl::MaxLength);
 761     return static_cast&lt;unsigned&gt;(length);
 762 }
 763 
 764 inline StringImplShape::StringImplShape(unsigned refCount, unsigned length, const LChar* data8, unsigned hashAndFlags)
 765     : m_refCount(refCount)
 766     , m_length(length)
 767     , m_data8(data8)
 768     , m_hashAndFlags(hashAndFlags)
 769 {
 770 }
</pre>
<hr />
<pre>
1009     size_t result = m_length;
1010     if (!is8Bit())
1011         result &lt;&lt;= 1;
1012     return result;
1013 }
1014 
1015 inline size_t StringImpl::costDuringGC()
1016 {
1017     if (isStatic())
1018         return 0;
1019 
1020     if (bufferOwnership() == BufferSubstring)
1021         return divideRoundedUp(substringBuffer()-&gt;costDuringGC(), refCount());
1022 
1023     size_t result = m_length;
1024     if (!is8Bit())
1025         result &lt;&lt;= 1;
1026     return divideRoundedUp(result, refCount());
1027 }
1028 
<span class="line-modified">1029 inline void StringImpl::setIsAtom(bool isAtom)</span>
1030 {
1031     ASSERT(!isStatic());
1032     ASSERT(!isSymbol());
<span class="line-modified">1033     if (isAtom)</span>
<span class="line-modified">1034         m_hashAndFlags |= s_hashFlagStringKindIsAtom;</span>
1035     else
<span class="line-modified">1036         m_hashAndFlags &amp;= ~s_hashFlagStringKindIsAtom;</span>
1037 }
1038 
1039 inline void StringImpl::setHash(unsigned hash) const
1040 {
1041     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
1042     // in the low bits because it makes them slightly more efficient to access.
1043     // So, we shift left and right when setting and getting our hash code.
1044 
1045     ASSERT(!hasHash());
1046     ASSERT(!isStatic());
1047     // Multiple clients assume that StringHasher is the canonical string hash function.
1048     ASSERT(hash == (is8Bit() ? StringHasher::computeHashAndMaskTop8Bits(m_data8, m_length) : StringHasher::computeHashAndMaskTop8Bits(m_data16, m_length)));
1049     ASSERT(!(hash &amp; (s_flagMask &lt;&lt; (8 * sizeof(hash) - s_flagCount)))); // Verify that enough high bits are empty.
1050 
1051     hash &lt;&lt;= s_flagCount;
1052     ASSERT(!(hash &amp; m_hashAndFlags)); // Verify that enough low bits are empty after shift.
1053     ASSERT(hash); // Verify that 0 is a valid sentinel hash value.
1054 
1055     m_hashAndFlags |= hash; // Store hash with flags in low bits.
1056 }
</pre>
<hr />
<pre>
1220 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1221 {
1222     return string &amp;&amp; startsWithLettersIgnoringASCIICase(*string, lowercaseLetters);
1223 }
1224 
1225 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl&amp; string, const char (&amp;lowercaseLetters)[length])
1226 {
1227     return equalLettersIgnoringASCIICaseCommon(string, lowercaseLetters);
1228 }
1229 
1230 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1231 {
1232     return string &amp;&amp; equalLettersIgnoringASCIICase(*string, lowercaseLetters);
1233 }
1234 
1235 } // namespace WTF
1236 
1237 using WTF::StaticStringImpl;
1238 using WTF::StringImpl;
1239 using WTF::equal;

</pre>
</td>
</tr>
</table>
<center><a href="StringImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringOperators.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>