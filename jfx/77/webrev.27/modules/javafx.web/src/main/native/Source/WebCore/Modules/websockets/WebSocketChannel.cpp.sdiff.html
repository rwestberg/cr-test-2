<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocketChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebSocket.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocketChannel.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocketChannel.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;WebSocketChannel.h&quot;
 34 
 35 #include &quot;Blob.h&quot;

 36 #include &quot;CookieJar.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;FileError.h&quot;
 39 #include &quot;FileReaderLoader.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;NetworkingContext.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ProgressTracker.h&quot;
 47 #include &quot;ResourceRequest.h&quot;
 48 #include &quot;ScriptExecutionContext.h&quot;
 49 #include &quot;SocketProvider.h&quot;
 50 #include &quot;SocketStreamError.h&quot;
 51 #include &quot;SocketStreamHandle.h&quot;
 52 #include &quot;UserContentProvider.h&quot;
 53 #include &quot;WebSocketChannelClient.h&quot;
 54 #include &quot;WebSocketHandshake.h&quot;
 55 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 56 #include &lt;wtf/FastMalloc.h&gt;
 57 #include &lt;wtf/HashMap.h&gt;
 58 #include &lt;wtf/text/CString.h&gt;
 59 #include &lt;wtf/text/StringHash.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 const Seconds TCPMaximumSegmentLifetime { 2_min };
 64 
 65 WebSocketChannel::WebSocketChannel(Document&amp; document, WebSocketChannelClient&amp; client, SocketProvider&amp; provider)
<span class="line-modified"> 66     : m_document(&amp;document)</span>
<span class="line-modified"> 67     , m_client(&amp;client)</span>
 68     , m_resumeTimer(*this, &amp;WebSocketChannel::resumeTimerFired)
 69     , m_closingTimer(*this, &amp;WebSocketChannel::closingTimerFired)
 70     , m_socketProvider(provider)
 71 {
 72     if (Page* page = document.page())
 73         m_identifier = page-&gt;progress().createUniqueIdentifier();
 74 
 75     LOG(Network, &quot;WebSocketChannel %p ctor, identifier %u&quot;, this, m_identifier);
 76 }
 77 
 78 WebSocketChannel::~WebSocketChannel()
 79 {
 80     LOG(Network, &quot;WebSocketChannel %p dtor&quot;, this);
 81 }
 82 
<span class="line-modified"> 83 void WebSocketChannel::connect(const URL&amp; requestedURL, const String&amp; protocol)</span>
 84 {
 85     LOG(Network, &quot;WebSocketChannel %p connect()&quot;, this);
 86 
<span class="line-modified"> 87     URL url = requestedURL;</span>
<span class="line-modified"> 88     bool allowCookies = true;</span>
<span class="line-modified"> 89 #if ENABLE(CONTENT_EXTENSIONS)</span>
<span class="line-removed"> 90     if (auto* page = m_document-&gt;page()) {</span>
<span class="line-removed"> 91         if (auto* documentLoader = m_document-&gt;loader()) {</span>
<span class="line-removed"> 92             auto blockedStatus = page-&gt;userContentProvider().processContentExtensionRulesForLoad(url, ResourceType::Raw, *documentLoader);</span>
<span class="line-removed"> 93             if (blockedStatus.blockedLoad) {</span>
<span class="line-removed"> 94                 Ref&lt;WebSocketChannel&gt; protectedThis(*this);</span>
<span class="line-removed"> 95                 callOnMainThread([protectedThis = WTFMove(protectedThis)] {</span>
<span class="line-removed"> 96                     if (protectedThis-&gt;m_client)</span>
<span class="line-removed"> 97                         protectedThis-&gt;m_client-&gt;didReceiveMessageError();</span>
<span class="line-removed"> 98                 });</span>
<span class="line-removed"> 99                 return;</span>
<span class="line-removed">100             }</span>
<span class="line-removed">101             if (blockedStatus.madeHTTPS) {</span>
<span class="line-removed">102                 ASSERT(url.protocolIs(&quot;ws&quot;));</span>
<span class="line-removed">103                 url.setProtocol(&quot;wss&quot;);</span>
<span class="line-removed">104                 if (m_client)</span>
<span class="line-removed">105                     m_client-&gt;didUpgradeURL();</span>
<span class="line-removed">106             }</span>
<span class="line-removed">107             if (blockedStatus.blockedCookies)</span>
<span class="line-removed">108                 allowCookies = false;</span>
<span class="line-removed">109         }</span>
<span class="line-removed">110     }</span>
<span class="line-removed">111 #endif</span>
<span class="line-removed">112 </span>
113     ASSERT(!m_handle);
114     ASSERT(!m_suspended);
<span class="line-modified">115     m_handshake = std::make_unique&lt;WebSocketHandshake&gt;(url, protocol, m_document, allowCookies);</span>







116     m_handshake-&gt;reset();
117     if (m_deflateFramer.canDeflate())
118         m_handshake-&gt;addExtensionProcessor(m_deflateFramer.createExtensionProcessor());
119     if (m_identifier)
<span class="line-modified">120         InspectorInstrumentation::didCreateWebSocket(m_document, m_identifier, url);</span>
121 
122     if (Frame* frame = m_document-&gt;frame()) {
123         ref();
124         Page* page = frame-&gt;page();
125         PAL::SessionID sessionID = page ? page-&gt;sessionID() : PAL::SessionID::defaultSessionID();
126         String partition = m_document-&gt;domainForCachePartition();

127         // JDK-8094172: JavaFX needs Page instance
128         m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, page, partition, frame-&gt;loader().networkingContext());
129     }






130 }
131 
132 String WebSocketChannel::subprotocol()
133 {
134     LOG(Network, &quot;WebSocketChannel %p subprotocol()&quot;, this);
135     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
136         return emptyString();
137     String serverProtocol = m_handshake-&gt;serverWebSocketProtocol();
138     if (serverProtocol.isNull())
139         return emptyString();
140     return serverProtocol;
141 }
142 
143 String WebSocketChannel::extensions()
144 {
145     LOG(Network, &quot;WebSocketChannel %p extensions()&quot;, this);
146     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
147         return emptyString();
148     String extensions = m_handshake-&gt;acceptedExtensions();
149     if (extensions.isNull())
</pre>
<hr />
<pre>
198     return m_handle-&gt;bufferedAmount();
199 }
200 
201 void WebSocketChannel::close(int code, const String&amp; reason)
202 {
203     LOG(Network, &quot;WebSocketChannel %p close() code=%d reason=&#39;%s&#39;&quot;, this, code, reason.utf8().data());
204     ASSERT(!m_suspended);
205     if (!m_handle)
206         return;
207     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
208     startClosingHandshake(code, reason);
209     if (m_closing &amp;&amp; !m_closingTimer.isActive())
210         m_closingTimer.startOneShot(TCPMaximumSegmentLifetime * 2);
211 }
212 
213 void WebSocketChannel::fail(const String&amp; reason)
214 {
215     LOG(Network, &quot;WebSocketChannel %p fail() reason=&#39;%s&#39;&quot;, this, reason.utf8().data());
216     ASSERT(!m_suspended);
217     if (m_document) {
<span class="line-modified">218         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document, m_identifier, reason);</span>
219 
220         String consoleMessage;
221         if (m_handshake)
222             consoleMessage = makeString(&quot;WebSocket connection to &#39;&quot;, m_handshake-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; failed: &quot;, reason);
223         else
224             consoleMessage = makeString(&quot;WebSocket connection failed: &quot;, reason);
225 
226         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, consoleMessage);
227     }
228 
229     // Hybi-10 specification explicitly states we must not continue to handle incoming data
230     // once the WebSocket connection is failed (section 7.1.7).
231     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
232     m_shouldDiscardReceivedData = true;
233     if (!m_buffer.isEmpty())
234         skipBuffer(m_buffer.size()); // Save memory.
235     m_deflateFramer.didFail();
236     m_hasContinuousFrame = false;
237     m_continuousFrameData.clear();
238     if (m_client)
239         m_client-&gt;didReceiveMessageError();
240 
241     if (m_handle &amp;&amp; !m_closed)
242         m_handle-&gt;disconnect(); // Will call didCloseSocketStream() but maybe not synchronously.
243 }
244 
245 void WebSocketChannel::disconnect()
246 {
247     LOG(Network, &quot;WebSocketChannel %p disconnect()&quot;, this);
248     if (m_identifier &amp;&amp; m_document)
<span class="line-modified">249         InspectorInstrumentation::didCloseWebSocket(m_document, m_identifier);</span>
<span class="line-removed">250     if (m_handshake)</span>
<span class="line-removed">251         m_handshake-&gt;clearDocument();</span>
252     m_client = nullptr;
253     m_document = nullptr;
254     if (m_handle)
255         m_handle-&gt;disconnect();
256 }
257 
258 void WebSocketChannel::suspend()
259 {
260     m_suspended = true;
261 }
262 
263 void WebSocketChannel::resume()
264 {
265     m_suspended = false;
266     if ((!m_buffer.isEmpty() || m_closed) &amp;&amp; m_client &amp;&amp; !m_resumeTimer.isActive())
267         m_resumeTimer.startOneShot(0_s);
268 }
269 
270 void WebSocketChannel::didOpenSocketStream(SocketStreamHandle&amp; handle)
271 {
272     LOG(Network, &quot;WebSocketChannel %p didOpenSocketStream()&quot;, this);
273     ASSERT(&amp;handle == m_handle);
274     if (!m_document)
275         return;
<span class="line-modified">276     if (m_identifier &amp;&amp; UNLIKELY(InspectorInstrumentation::hasFrontends()))</span>
<span class="line-modified">277         InspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document, m_identifier, m_handshake-&gt;clientHandshakeRequest());</span>






278     auto handshakeMessage = m_handshake-&gt;clientHandshakeMessage();
<span class="line-modified">279     auto cookieRequestHeaderFieldProxy = m_handshake-&gt;clientHandshakeCookieRequestHeaderFieldProxy();</span>


280     handle.sendHandshake(WTFMove(handshakeMessage), WTFMove(cookieRequestHeaderFieldProxy), [this, protectedThis = makeRef(*this)] (bool success, bool didAccessSecureCookies) {
281         if (!success)
282             fail(&quot;Failed to send WebSocket handshake.&quot;);
283 
284         if (didAccessSecureCookies &amp;&amp; m_document)
285             m_document-&gt;setSecureCookiesAccessed();
286     });
287 }
288 
289 void WebSocketChannel::didCloseSocketStream(SocketStreamHandle&amp; handle)
290 {
291     LOG(Network, &quot;WebSocketChannel %p didCloseSocketStream()&quot;, this);
292     if (m_identifier &amp;&amp; m_document)
<span class="line-modified">293         InspectorInstrumentation::didCloseWebSocket(m_document, m_identifier);</span>
294     ASSERT_UNUSED(handle, &amp;handle == m_handle || !m_handle);
295     m_closed = true;
296     if (m_closingTimer.isActive())
297         m_closingTimer.stop();
298     if (m_outgoingFrameQueueStatus != OutgoingFrameQueueClosed)
299         abortOutgoingFrameQueue();
300     if (m_handle) {
301         m_unhandledBufferedAmount = m_handle-&gt;bufferedAmount();
302         if (m_suspended)
303             return;
<span class="line-modified">304         WebSocketChannelClient* client = m_client;</span>
305         m_client = nullptr;
306         m_document = nullptr;
307         m_handle = nullptr;
308         if (client)
309             client-&gt;didClose(m_unhandledBufferedAmount, m_receivedClosingHandshake ? WebSocketChannelClient::ClosingHandshakeComplete : WebSocketChannelClient::ClosingHandshakeIncomplete, m_closeEventCode, m_closeEventReason);
310     }
311     deref();
312 }
313 
314 void WebSocketChannel::didReceiveSocketStreamData(SocketStreamHandle&amp; handle, const char* data, size_t length)
315 {
316     LOG(Network, &quot;WebSocketChannel %p didReceiveSocketStreamData() Received %zu bytes&quot;, this, length);
317     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
318     ASSERT(&amp;handle == m_handle);
319     if (!m_document) {
320         return;
321     }
322     if (!length) {
323         handle.disconnect();
324         return;
</pre>
<hr />
<pre>
347 }
348 
349 void WebSocketChannel::didUpdateBufferedAmount(SocketStreamHandle&amp;, size_t bufferedAmount)
350 {
351     if (m_client)
352         m_client-&gt;didUpdateBufferedAmount(bufferedAmount);
353 }
354 
355 void WebSocketChannel::didFailSocketStream(SocketStreamHandle&amp; handle, const SocketStreamError&amp; error)
356 {
357     LOG(Network, &quot;WebSocketChannel %p didFailSocketStream()&quot;, this);
358     ASSERT(&amp;handle == m_handle || !m_handle);
359     if (m_document) {
360         String message;
361         if (error.isNull())
362             message = &quot;WebSocket network error&quot;_s;
363         else if (error.localizedDescription().isNull())
364             message = makeString(&quot;WebSocket network error: error code &quot;, error.errorCode());
365         else
366             message = &quot;WebSocket network error: &quot; + error.localizedDescription();
<span class="line-modified">367         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document, m_identifier, message);</span>
368         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, message);
369     }
370     m_shouldDiscardReceivedData = true;
371     if (m_client)
372         m_client-&gt;didReceiveMessageError();
373     handle.disconnect();
374 }
375 
376 void WebSocketChannel::didStartLoading()
377 {
378     LOG(Network, &quot;WebSocketChannel %p didStartLoading()&quot;, this);
379     ASSERT(m_blobLoader);
380     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
381 }
382 
383 void WebSocketChannel::didReceiveData()
384 {
385     LOG(Network, &quot;WebSocketChannel %p didReceiveData()&quot;, this);
386     ASSERT(m_blobLoader);
387     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
</pre>
<hr />
<pre>
432     ASSERT(m_client);
433     ASSERT(!m_buffer.isEmpty());
434     LOG(Network, &quot;WebSocketChannel %p processBuffer() Receive buffer has %u bytes&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
435 
436     if (m_shouldDiscardReceivedData)
437         return false;
438 
439     if (m_receivedClosingHandshake) {
440         skipBuffer(m_buffer.size());
441         return false;
442     }
443 
444     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
445 
446     if (m_handshake-&gt;mode() == WebSocketHandshake::Incomplete) {
447         int headerLength = m_handshake-&gt;readServerHandshake(m_buffer.data(), m_buffer.size());
448         if (headerLength &lt;= 0)
449             return false;
450         if (m_handshake-&gt;mode() == WebSocketHandshake::Connected) {
451             if (m_identifier)
<span class="line-modified">452                 InspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document, m_identifier, m_handshake-&gt;serverHandshakeResponse());</span>
453             String serverSetCookie = m_handshake-&gt;serverSetCookie();
454             if (!serverSetCookie.isEmpty()) {
455                 if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; m_document-&gt;page()-&gt;cookieJar().cookiesEnabled(*m_document))
456                     m_document-&gt;page()-&gt;cookieJar().setCookies(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies(), serverSetCookie);
457             }
458             LOG(Network, &quot;WebSocketChannel %p Connected&quot;, this);
459             skipBuffer(headerLength);
460             m_client-&gt;didConnect();
461             LOG(Network, &quot;WebSocketChannel %p %u bytes remaining in m_buffer&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
462             return !m_buffer.isEmpty();
463         }
464         ASSERT(m_handshake-&gt;mode() == WebSocketHandshake::Failed);
465         LOG(Network, &quot;WebSocketChannel %p Connection failed&quot;, this);
466         skipBuffer(headerLength);
467         m_shouldDiscardReceivedData = true;
468         fail(m_handshake-&gt;failureReason());
469         return false;
470     }
471     if (m_handshake-&gt;mode() != WebSocketHandshake::Connected)
472         return false;
</pre>
<hr />
<pre>
566     // All control frames must not be fragmented.
567     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; !frame.final) {
568         fail(makeString(&quot;Received fragmented control frame: opcode = &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
569         return false;
570     }
571 
572     // All control frames must have a payload of 125 bytes or less, which means the frame must not contain
573     // the &quot;extended payload length&quot; field.
574     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; WebSocketFrame::needsExtendedLengthField(frame.payloadLength)) {
575         fail(makeString(&quot;Received control frame having too long payload: &quot;, frame.payloadLength, &quot; bytes&quot;));
576         return false;
577     }
578 
579     // A new data frame is received before the previous continuous frame finishes.
580     // Note that control frames are allowed to come in the middle of continuous frames.
581     if (m_hasContinuousFrame &amp;&amp; frame.opCode != WebSocketFrame::OpCodeContinuation &amp;&amp; !WebSocketFrame::isControlOpCode(frame.opCode)) {
582         fail(&quot;Received new data frame but previous continuous frame is unfinished.&quot;);
583         return false;
584     }
585 
<span class="line-modified">586     InspectorInstrumentation::didReceiveWebSocketFrame(m_document, m_identifier, frame);</span>
587 
588     switch (frame.opCode) {
589     case WebSocketFrame::OpCodeContinuation:
590         // An unexpected continuation frame is received without any leading frame.
591         if (!m_hasContinuousFrame) {
592             fail(&quot;Received unexpected continuation frame.&quot;);
593             return false;
594         }
595         m_continuousFrameData.append(frame.payload, frame.payloadLength);
596         skipBuffer(frameEnd - m_buffer.data());
597         if (frame.final) {
598             // onmessage handler may eventually call the other methods of this channel,
599             // so we should pretend that we have finished to read this frame and
600             // make sure that the member variables are in a consistent state before
601             // the handler is invoked.
602             Vector&lt;uint8_t&gt; continuousFrameData = WTFMove(m_continuousFrameData);
603             m_hasContinuousFrame = false;
604             if (m_continuousFrameOpCode == WebSocketFrame::OpCodeText) {
605                 String message;
606                 if (continuousFrameData.size())
</pre>
<hr />
<pre>
690         break;
691 
692     case WebSocketFrame::OpCodePong:
693         // A server may send a pong in response to our ping, or an unsolicited pong which is not associated with
694         // any specific ping. Either way, there&#39;s nothing to do on receipt of pong.
695         skipBuffer(frameEnd - m_buffer.data());
696         break;
697 
698     default:
699         ASSERT_NOT_REACHED();
700         skipBuffer(frameEnd - m_buffer.data());
701         break;
702     }
703 
704     return !m_buffer.isEmpty();
705 }
706 
707 void WebSocketChannel::enqueueTextFrame(const CString&amp; string)
708 {
709     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">710     auto frame = std::make_unique&lt;QueuedFrame&gt;();</span>
711     frame-&gt;opCode = WebSocketFrame::OpCodeText;
712     frame-&gt;frameType = QueuedFrameTypeString;
713     frame-&gt;stringData = string;
714     m_outgoingFrameQueue.append(WTFMove(frame));
715 }
716 
717 void WebSocketChannel::enqueueRawFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength)
718 {
719     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">720     auto frame = std::make_unique&lt;QueuedFrame&gt;();</span>
721     frame-&gt;opCode = opCode;
722     frame-&gt;frameType = QueuedFrameTypeVector;
723     frame-&gt;vectorData.resize(dataLength);
724     if (dataLength)
725         memcpy(frame-&gt;vectorData.data(), data, dataLength);
726     m_outgoingFrameQueue.append(WTFMove(frame));
727 }
728 
729 void WebSocketChannel::enqueueBlobFrame(WebSocketFrame::OpCode opCode, Blob&amp; blob)
730 {
731     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">732     auto frame = std::make_unique&lt;QueuedFrame&gt;();</span>
733     frame-&gt;opCode = opCode;
734     frame-&gt;frameType = QueuedFrameTypeBlob;
735     frame-&gt;blobData = &amp;blob;
736     m_outgoingFrameQueue.append(WTFMove(frame));
737 }
738 
739 void WebSocketChannel::processOutgoingFrameQueue()
740 {
741     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosed)
742         return;
743 
744     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // Any call to fail() will get the channel closed and dereferenced.
745 
746     while (!m_outgoingFrameQueue.isEmpty()) {
747         auto frame = m_outgoingFrameQueue.takeFirst();
748         switch (frame-&gt;frameType) {
749         case QueuedFrameTypeString: {
750             sendFrame(frame-&gt;opCode, frame-&gt;stringData.data(), frame-&gt;stringData.length(), [this, protectedThis = makeRef(*this)] (bool success) {
751                 if (!success)
752                     fail(&quot;Failed to send WebSocket frame.&quot;);
753             });
754             break;
755         }
756 
757         case QueuedFrameTypeVector:
758             sendFrame(frame-&gt;opCode, frame-&gt;vectorData.data(), frame-&gt;vectorData.size(), [this, protectedThis = makeRef(*this)] (bool success) {
759                 if (!success)
760                     fail(&quot;Failed to send WebSocket frame.&quot;);
761             });
762             break;
763 
764         case QueuedFrameTypeBlob: {
765             switch (m_blobLoaderStatus) {
766             case BlobLoaderNotStarted:
767                 ref(); // Will be derefed after didFinishLoading() or didFail().
768                 ASSERT(!m_blobLoader);
769                 ASSERT(frame-&gt;blobData);
<span class="line-modified">770                 m_blobLoader = std::make_unique&lt;FileReaderLoader&gt;(FileReaderLoader::ReadAsArrayBuffer, this);</span>
771                 m_blobLoaderStatus = BlobLoaderStarted;
<span class="line-modified">772                 m_blobLoader-&gt;start(m_document, *frame-&gt;blobData);</span>
773                 m_outgoingFrameQueue.prepend(WTFMove(frame));
774                 return;
775 
776             case BlobLoaderStarted:
777             case BlobLoaderFailed:
778                 m_outgoingFrameQueue.prepend(WTFMove(frame));
779                 return;
780 
781             case BlobLoaderFinished: {
782                 RefPtr&lt;ArrayBuffer&gt; result = m_blobLoader-&gt;arrayBufferResult();
783                 m_blobLoader = nullptr;
784                 m_blobLoaderStatus = BlobLoaderNotStarted;
785                 sendFrame(frame-&gt;opCode, static_cast&lt;const char*&gt;(result-&gt;data()), result-&gt;byteLength(), [this, protectedThis = makeRef(*this)] (bool success) {
786                     if (!success)
787                         fail(&quot;Failed to send WebSocket frame.&quot;);
788                 });
789                 break;
790             }
791             }
792             break;
</pre>
<hr />
<pre>
804         m_handle-&gt;close();
805     }
806 }
807 
808 void WebSocketChannel::abortOutgoingFrameQueue()
809 {
810     m_outgoingFrameQueue.clear();
811     m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
812     if (m_blobLoaderStatus == BlobLoaderStarted) {
813         m_blobLoader-&gt;cancel();
814         didFail(FileError::ABORT_ERR);
815     }
816 }
817 
818 void WebSocketChannel::sendFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength, WTF::Function&lt;void(bool)&gt; completionHandler)
819 {
820     ASSERT(m_handle);
821     ASSERT(!m_suspended);
822 
823     WebSocketFrame frame(opCode, true, false, true, data, dataLength);
<span class="line-modified">824     InspectorInstrumentation::didSendWebSocketFrame(m_document, m_identifier, frame);</span>
825 
826     auto deflateResult = m_deflateFramer.deflate(frame);
827     if (!deflateResult-&gt;succeeded()) {
828         fail(deflateResult-&gt;failureReason());
829         return completionHandler(false);
830     }
831 
832     Vector&lt;char&gt; frameData;
833     frame.makeFrameData(frameData);
834 
835     m_handle-&gt;sendData(frameData.data(), frameData.size(), WTFMove(completionHandler));
836 }
837 
<span class="line-modified">838 ResourceRequest WebSocketChannel::clientHandshakeRequest()</span>
839 {
<span class="line-modified">840     return m_handshake-&gt;clientHandshakeRequest();</span>
841 }
842 
843 const ResourceResponse&amp; WebSocketChannel::serverHandshakeResponse() const
844 {
845     return m_handshake-&gt;serverHandshakeResponse();
846 }
847 
848 WebSocketHandshake::Mode WebSocketChannel::handshakeMode() const
849 {
850     return m_handshake-&gt;mode();
851 }
852 
853 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;WebSocketChannel.h&quot;
 34 
 35 #include &quot;Blob.h&quot;
<span class="line-added"> 36 #include &quot;ContentRuleListResults.h&quot;</span>
 37 #include &quot;CookieJar.h&quot;
 38 #include &quot;Document.h&quot;
 39 #include &quot;FileError.h&quot;
 40 #include &quot;FileReaderLoader.h&quot;
 41 #include &quot;Frame.h&quot;
 42 #include &quot;FrameLoader.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;NetworkingContext.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ProgressTracker.h&quot;
 48 #include &quot;ResourceRequest.h&quot;
 49 #include &quot;ScriptExecutionContext.h&quot;
 50 #include &quot;SocketProvider.h&quot;
 51 #include &quot;SocketStreamError.h&quot;
 52 #include &quot;SocketStreamHandle.h&quot;
 53 #include &quot;UserContentProvider.h&quot;
 54 #include &quot;WebSocketChannelClient.h&quot;
 55 #include &quot;WebSocketHandshake.h&quot;
 56 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 57 #include &lt;wtf/FastMalloc.h&gt;
 58 #include &lt;wtf/HashMap.h&gt;
 59 #include &lt;wtf/text/CString.h&gt;
 60 #include &lt;wtf/text/StringHash.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 const Seconds TCPMaximumSegmentLifetime { 2_min };
 65 
 66 WebSocketChannel::WebSocketChannel(Document&amp; document, WebSocketChannelClient&amp; client, SocketProvider&amp; provider)
<span class="line-modified"> 67     : m_document(makeWeakPtr(document))</span>
<span class="line-modified"> 68     , m_client(makeWeakPtr(client))</span>
 69     , m_resumeTimer(*this, &amp;WebSocketChannel::resumeTimerFired)
 70     , m_closingTimer(*this, &amp;WebSocketChannel::closingTimerFired)
 71     , m_socketProvider(provider)
 72 {
 73     if (Page* page = document.page())
 74         m_identifier = page-&gt;progress().createUniqueIdentifier();
 75 
 76     LOG(Network, &quot;WebSocketChannel %p ctor, identifier %u&quot;, this, m_identifier);
 77 }
 78 
 79 WebSocketChannel::~WebSocketChannel()
 80 {
 81     LOG(Network, &quot;WebSocketChannel %p dtor&quot;, this);
 82 }
 83 
<span class="line-modified"> 84 WebSocketChannel::ConnectStatus WebSocketChannel::connect(const URL&amp; requestedURL, const String&amp; protocol)</span>
 85 {
 86     LOG(Network, &quot;WebSocketChannel %p connect()&quot;, this);
 87 
<span class="line-modified"> 88     auto validatedURL = validateURL(*m_document, requestedURL);</span>
<span class="line-modified"> 89     if (!validatedURL)</span>
<span class="line-modified"> 90         return ConnectStatus::KO;</span>























 91     ASSERT(!m_handle);
 92     ASSERT(!m_suspended);
<span class="line-modified"> 93 </span>
<span class="line-added"> 94     if (validatedURL-&gt;url != requestedURL &amp;&amp; m_client)</span>
<span class="line-added"> 95         m_client-&gt;didUpgradeURL();</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     m_allowCookies = validatedURL-&gt;areCookiesAllowed;</span>
<span class="line-added"> 98     String userAgent = m_document-&gt;userAgent(m_document-&gt;url());</span>
<span class="line-added"> 99     String clientOrigin = m_document-&gt;securityOrigin().toString();</span>
<span class="line-added">100     m_handshake = makeUnique&lt;WebSocketHandshake&gt;(validatedURL-&gt;url, protocol, userAgent, clientOrigin, m_allowCookies);</span>
101     m_handshake-&gt;reset();
102     if (m_deflateFramer.canDeflate())
103         m_handshake-&gt;addExtensionProcessor(m_deflateFramer.createExtensionProcessor());
104     if (m_identifier)
<span class="line-modified">105         InspectorInstrumentation::didCreateWebSocket(m_document.get(), m_identifier, validatedURL-&gt;url);</span>
106 
107     if (Frame* frame = m_document-&gt;frame()) {
108         ref();
109         Page* page = frame-&gt;page();
110         PAL::SessionID sessionID = page ? page-&gt;sessionID() : PAL::SessionID::defaultSessionID();
111         String partition = m_document-&gt;domainForCachePartition();
<span class="line-added">112         // m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, partition, frame-&gt;loader().networkingContext());</span>
113         // JDK-8094172: JavaFX needs Page instance
114         m_handle = m_socketProvider-&gt;createSocketStreamHandle(m_handshake-&gt;url(), *this, sessionID, page, partition, frame-&gt;loader().networkingContext());
115     }
<span class="line-added">116     return ConnectStatus::OK;</span>
<span class="line-added">117 }</span>
<span class="line-added">118 </span>
<span class="line-added">119 Document* WebSocketChannel::document()</span>
<span class="line-added">120 {</span>
<span class="line-added">121     return m_document.get();</span>
122 }
123 
124 String WebSocketChannel::subprotocol()
125 {
126     LOG(Network, &quot;WebSocketChannel %p subprotocol()&quot;, this);
127     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
128         return emptyString();
129     String serverProtocol = m_handshake-&gt;serverWebSocketProtocol();
130     if (serverProtocol.isNull())
131         return emptyString();
132     return serverProtocol;
133 }
134 
135 String WebSocketChannel::extensions()
136 {
137     LOG(Network, &quot;WebSocketChannel %p extensions()&quot;, this);
138     if (!m_handshake || m_handshake-&gt;mode() != WebSocketHandshake::Connected)
139         return emptyString();
140     String extensions = m_handshake-&gt;acceptedExtensions();
141     if (extensions.isNull())
</pre>
<hr />
<pre>
190     return m_handle-&gt;bufferedAmount();
191 }
192 
193 void WebSocketChannel::close(int code, const String&amp; reason)
194 {
195     LOG(Network, &quot;WebSocketChannel %p close() code=%d reason=&#39;%s&#39;&quot;, this, code, reason.utf8().data());
196     ASSERT(!m_suspended);
197     if (!m_handle)
198         return;
199     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // An attempt to send closing handshake may fail, which will get the channel closed and dereferenced.
200     startClosingHandshake(code, reason);
201     if (m_closing &amp;&amp; !m_closingTimer.isActive())
202         m_closingTimer.startOneShot(TCPMaximumSegmentLifetime * 2);
203 }
204 
205 void WebSocketChannel::fail(const String&amp; reason)
206 {
207     LOG(Network, &quot;WebSocketChannel %p fail() reason=&#39;%s&#39;&quot;, this, reason.utf8().data());
208     ASSERT(!m_suspended);
209     if (m_document) {
<span class="line-modified">210         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_identifier, reason);</span>
211 
212         String consoleMessage;
213         if (m_handshake)
214             consoleMessage = makeString(&quot;WebSocket connection to &#39;&quot;, m_handshake-&gt;url().stringCenterEllipsizedToLength(), &quot;&#39; failed: &quot;, reason);
215         else
216             consoleMessage = makeString(&quot;WebSocket connection failed: &quot;, reason);
217 
218         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, consoleMessage);
219     }
220 
221     // Hybi-10 specification explicitly states we must not continue to handle incoming data
222     // once the WebSocket connection is failed (section 7.1.7).
223     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
224     m_shouldDiscardReceivedData = true;
225     if (!m_buffer.isEmpty())
226         skipBuffer(m_buffer.size()); // Save memory.
227     m_deflateFramer.didFail();
228     m_hasContinuousFrame = false;
229     m_continuousFrameData.clear();
230     if (m_client)
231         m_client-&gt;didReceiveMessageError();
232 
233     if (m_handle &amp;&amp; !m_closed)
234         m_handle-&gt;disconnect(); // Will call didCloseSocketStream() but maybe not synchronously.
235 }
236 
237 void WebSocketChannel::disconnect()
238 {
239     LOG(Network, &quot;WebSocketChannel %p disconnect()&quot;, this);
240     if (m_identifier &amp;&amp; m_document)
<span class="line-modified">241         InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_identifier);</span>


242     m_client = nullptr;
243     m_document = nullptr;
244     if (m_handle)
245         m_handle-&gt;disconnect();
246 }
247 
248 void WebSocketChannel::suspend()
249 {
250     m_suspended = true;
251 }
252 
253 void WebSocketChannel::resume()
254 {
255     m_suspended = false;
256     if ((!m_buffer.isEmpty() || m_closed) &amp;&amp; m_client &amp;&amp; !m_resumeTimer.isActive())
257         m_resumeTimer.startOneShot(0_s);
258 }
259 
260 void WebSocketChannel::didOpenSocketStream(SocketStreamHandle&amp; handle)
261 {
262     LOG(Network, &quot;WebSocketChannel %p didOpenSocketStream()&quot;, this);
263     ASSERT(&amp;handle == m_handle);
264     if (!m_document)
265         return;
<span class="line-modified">266     if (m_identifier &amp;&amp; UNLIKELY(InspectorInstrumentation::hasFrontends())) {</span>
<span class="line-modified">267         auto cookieRequestHeaderFieldValue = [document = m_document] (const URL&amp; url) -&gt; String {</span>
<span class="line-added">268             if (!document || !document-&gt;page())</span>
<span class="line-added">269                 return { };</span>
<span class="line-added">270             return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);</span>
<span class="line-added">271         };</span>
<span class="line-added">272         InspectorInstrumentation::willSendWebSocketHandshakeRequest(m_document.get(), m_identifier, m_handshake-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));</span>
<span class="line-added">273     }</span>
274     auto handshakeMessage = m_handshake-&gt;clientHandshakeMessage();
<span class="line-modified">275     Optional&lt;CookieRequestHeaderFieldProxy&gt; cookieRequestHeaderFieldProxy;</span>
<span class="line-added">276     if (m_allowCookies)</span>
<span class="line-added">277         cookieRequestHeaderFieldProxy = CookieJar::cookieRequestHeaderFieldProxy(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies());</span>
278     handle.sendHandshake(WTFMove(handshakeMessage), WTFMove(cookieRequestHeaderFieldProxy), [this, protectedThis = makeRef(*this)] (bool success, bool didAccessSecureCookies) {
279         if (!success)
280             fail(&quot;Failed to send WebSocket handshake.&quot;);
281 
282         if (didAccessSecureCookies &amp;&amp; m_document)
283             m_document-&gt;setSecureCookiesAccessed();
284     });
285 }
286 
287 void WebSocketChannel::didCloseSocketStream(SocketStreamHandle&amp; handle)
288 {
289     LOG(Network, &quot;WebSocketChannel %p didCloseSocketStream()&quot;, this);
290     if (m_identifier &amp;&amp; m_document)
<span class="line-modified">291         InspectorInstrumentation::didCloseWebSocket(m_document.get(), m_identifier);</span>
292     ASSERT_UNUSED(handle, &amp;handle == m_handle || !m_handle);
293     m_closed = true;
294     if (m_closingTimer.isActive())
295         m_closingTimer.stop();
296     if (m_outgoingFrameQueueStatus != OutgoingFrameQueueClosed)
297         abortOutgoingFrameQueue();
298     if (m_handle) {
299         m_unhandledBufferedAmount = m_handle-&gt;bufferedAmount();
300         if (m_suspended)
301             return;
<span class="line-modified">302         WebSocketChannelClient* client = m_client.get();</span>
303         m_client = nullptr;
304         m_document = nullptr;
305         m_handle = nullptr;
306         if (client)
307             client-&gt;didClose(m_unhandledBufferedAmount, m_receivedClosingHandshake ? WebSocketChannelClient::ClosingHandshakeComplete : WebSocketChannelClient::ClosingHandshakeIncomplete, m_closeEventCode, m_closeEventReason);
308     }
309     deref();
310 }
311 
312 void WebSocketChannel::didReceiveSocketStreamData(SocketStreamHandle&amp; handle, const char* data, size_t length)
313 {
314     LOG(Network, &quot;WebSocketChannel %p didReceiveSocketStreamData() Received %zu bytes&quot;, this, length);
315     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
316     ASSERT(&amp;handle == m_handle);
317     if (!m_document) {
318         return;
319     }
320     if (!length) {
321         handle.disconnect();
322         return;
</pre>
<hr />
<pre>
345 }
346 
347 void WebSocketChannel::didUpdateBufferedAmount(SocketStreamHandle&amp;, size_t bufferedAmount)
348 {
349     if (m_client)
350         m_client-&gt;didUpdateBufferedAmount(bufferedAmount);
351 }
352 
353 void WebSocketChannel::didFailSocketStream(SocketStreamHandle&amp; handle, const SocketStreamError&amp; error)
354 {
355     LOG(Network, &quot;WebSocketChannel %p didFailSocketStream()&quot;, this);
356     ASSERT(&amp;handle == m_handle || !m_handle);
357     if (m_document) {
358         String message;
359         if (error.isNull())
360             message = &quot;WebSocket network error&quot;_s;
361         else if (error.localizedDescription().isNull())
362             message = makeString(&quot;WebSocket network error: error code &quot;, error.errorCode());
363         else
364             message = &quot;WebSocket network error: &quot; + error.localizedDescription();
<span class="line-modified">365         InspectorInstrumentation::didReceiveWebSocketFrameError(m_document.get(), m_identifier, message);</span>
366         m_document-&gt;addConsoleMessage(MessageSource::Network, MessageLevel::Error, message);
367     }
368     m_shouldDiscardReceivedData = true;
369     if (m_client)
370         m_client-&gt;didReceiveMessageError();
371     handle.disconnect();
372 }
373 
374 void WebSocketChannel::didStartLoading()
375 {
376     LOG(Network, &quot;WebSocketChannel %p didStartLoading()&quot;, this);
377     ASSERT(m_blobLoader);
378     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
379 }
380 
381 void WebSocketChannel::didReceiveData()
382 {
383     LOG(Network, &quot;WebSocketChannel %p didReceiveData()&quot;, this);
384     ASSERT(m_blobLoader);
385     ASSERT(m_blobLoaderStatus == BlobLoaderStarted);
</pre>
<hr />
<pre>
430     ASSERT(m_client);
431     ASSERT(!m_buffer.isEmpty());
432     LOG(Network, &quot;WebSocketChannel %p processBuffer() Receive buffer has %u bytes&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
433 
434     if (m_shouldDiscardReceivedData)
435         return false;
436 
437     if (m_receivedClosingHandshake) {
438         skipBuffer(m_buffer.size());
439         return false;
440     }
441 
442     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // The client can close the channel, potentially removing the last reference.
443 
444     if (m_handshake-&gt;mode() == WebSocketHandshake::Incomplete) {
445         int headerLength = m_handshake-&gt;readServerHandshake(m_buffer.data(), m_buffer.size());
446         if (headerLength &lt;= 0)
447             return false;
448         if (m_handshake-&gt;mode() == WebSocketHandshake::Connected) {
449             if (m_identifier)
<span class="line-modified">450                 InspectorInstrumentation::didReceiveWebSocketHandshakeResponse(m_document.get(), m_identifier, m_handshake-&gt;serverHandshakeResponse());</span>
451             String serverSetCookie = m_handshake-&gt;serverSetCookie();
452             if (!serverSetCookie.isEmpty()) {
453                 if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; m_document-&gt;page()-&gt;cookieJar().cookiesEnabled(*m_document))
454                     m_document-&gt;page()-&gt;cookieJar().setCookies(*m_document, m_handshake-&gt;httpURLForAuthenticationAndCookies(), serverSetCookie);
455             }
456             LOG(Network, &quot;WebSocketChannel %p Connected&quot;, this);
457             skipBuffer(headerLength);
458             m_client-&gt;didConnect();
459             LOG(Network, &quot;WebSocketChannel %p %u bytes remaining in m_buffer&quot;, this, static_cast&lt;unsigned&gt;(m_buffer.size()));
460             return !m_buffer.isEmpty();
461         }
462         ASSERT(m_handshake-&gt;mode() == WebSocketHandshake::Failed);
463         LOG(Network, &quot;WebSocketChannel %p Connection failed&quot;, this);
464         skipBuffer(headerLength);
465         m_shouldDiscardReceivedData = true;
466         fail(m_handshake-&gt;failureReason());
467         return false;
468     }
469     if (m_handshake-&gt;mode() != WebSocketHandshake::Connected)
470         return false;
</pre>
<hr />
<pre>
564     // All control frames must not be fragmented.
565     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; !frame.final) {
566         fail(makeString(&quot;Received fragmented control frame: opcode = &quot;, static_cast&lt;unsigned&gt;(frame.opCode)));
567         return false;
568     }
569 
570     // All control frames must have a payload of 125 bytes or less, which means the frame must not contain
571     // the &quot;extended payload length&quot; field.
572     if (WebSocketFrame::isControlOpCode(frame.opCode) &amp;&amp; WebSocketFrame::needsExtendedLengthField(frame.payloadLength)) {
573         fail(makeString(&quot;Received control frame having too long payload: &quot;, frame.payloadLength, &quot; bytes&quot;));
574         return false;
575     }
576 
577     // A new data frame is received before the previous continuous frame finishes.
578     // Note that control frames are allowed to come in the middle of continuous frames.
579     if (m_hasContinuousFrame &amp;&amp; frame.opCode != WebSocketFrame::OpCodeContinuation &amp;&amp; !WebSocketFrame::isControlOpCode(frame.opCode)) {
580         fail(&quot;Received new data frame but previous continuous frame is unfinished.&quot;);
581         return false;
582     }
583 
<span class="line-modified">584     InspectorInstrumentation::didReceiveWebSocketFrame(m_document.get(), m_identifier, frame);</span>
585 
586     switch (frame.opCode) {
587     case WebSocketFrame::OpCodeContinuation:
588         // An unexpected continuation frame is received without any leading frame.
589         if (!m_hasContinuousFrame) {
590             fail(&quot;Received unexpected continuation frame.&quot;);
591             return false;
592         }
593         m_continuousFrameData.append(frame.payload, frame.payloadLength);
594         skipBuffer(frameEnd - m_buffer.data());
595         if (frame.final) {
596             // onmessage handler may eventually call the other methods of this channel,
597             // so we should pretend that we have finished to read this frame and
598             // make sure that the member variables are in a consistent state before
599             // the handler is invoked.
600             Vector&lt;uint8_t&gt; continuousFrameData = WTFMove(m_continuousFrameData);
601             m_hasContinuousFrame = false;
602             if (m_continuousFrameOpCode == WebSocketFrame::OpCodeText) {
603                 String message;
604                 if (continuousFrameData.size())
</pre>
<hr />
<pre>
688         break;
689 
690     case WebSocketFrame::OpCodePong:
691         // A server may send a pong in response to our ping, or an unsolicited pong which is not associated with
692         // any specific ping. Either way, there&#39;s nothing to do on receipt of pong.
693         skipBuffer(frameEnd - m_buffer.data());
694         break;
695 
696     default:
697         ASSERT_NOT_REACHED();
698         skipBuffer(frameEnd - m_buffer.data());
699         break;
700     }
701 
702     return !m_buffer.isEmpty();
703 }
704 
705 void WebSocketChannel::enqueueTextFrame(const CString&amp; string)
706 {
707     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">708     auto frame = makeUnique&lt;QueuedFrame&gt;();</span>
709     frame-&gt;opCode = WebSocketFrame::OpCodeText;
710     frame-&gt;frameType = QueuedFrameTypeString;
711     frame-&gt;stringData = string;
712     m_outgoingFrameQueue.append(WTFMove(frame));
713 }
714 
715 void WebSocketChannel::enqueueRawFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength)
716 {
717     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">718     auto frame = makeUnique&lt;QueuedFrame&gt;();</span>
719     frame-&gt;opCode = opCode;
720     frame-&gt;frameType = QueuedFrameTypeVector;
721     frame-&gt;vectorData.resize(dataLength);
722     if (dataLength)
723         memcpy(frame-&gt;vectorData.data(), data, dataLength);
724     m_outgoingFrameQueue.append(WTFMove(frame));
725 }
726 
727 void WebSocketChannel::enqueueBlobFrame(WebSocketFrame::OpCode opCode, Blob&amp; blob)
728 {
729     ASSERT(m_outgoingFrameQueueStatus == OutgoingFrameQueueOpen);
<span class="line-modified">730     auto frame = makeUnique&lt;QueuedFrame&gt;();</span>
731     frame-&gt;opCode = opCode;
732     frame-&gt;frameType = QueuedFrameTypeBlob;
733     frame-&gt;blobData = &amp;blob;
734     m_outgoingFrameQueue.append(WTFMove(frame));
735 }
736 
737 void WebSocketChannel::processOutgoingFrameQueue()
738 {
739     if (m_outgoingFrameQueueStatus == OutgoingFrameQueueClosed)
740         return;
741 
742     Ref&lt;WebSocketChannel&gt; protectedThis(*this); // Any call to fail() will get the channel closed and dereferenced.
743 
744     while (!m_outgoingFrameQueue.isEmpty()) {
745         auto frame = m_outgoingFrameQueue.takeFirst();
746         switch (frame-&gt;frameType) {
747         case QueuedFrameTypeString: {
748             sendFrame(frame-&gt;opCode, frame-&gt;stringData.data(), frame-&gt;stringData.length(), [this, protectedThis = makeRef(*this)] (bool success) {
749                 if (!success)
750                     fail(&quot;Failed to send WebSocket frame.&quot;);
751             });
752             break;
753         }
754 
755         case QueuedFrameTypeVector:
756             sendFrame(frame-&gt;opCode, frame-&gt;vectorData.data(), frame-&gt;vectorData.size(), [this, protectedThis = makeRef(*this)] (bool success) {
757                 if (!success)
758                     fail(&quot;Failed to send WebSocket frame.&quot;);
759             });
760             break;
761 
762         case QueuedFrameTypeBlob: {
763             switch (m_blobLoaderStatus) {
764             case BlobLoaderNotStarted:
765                 ref(); // Will be derefed after didFinishLoading() or didFail().
766                 ASSERT(!m_blobLoader);
767                 ASSERT(frame-&gt;blobData);
<span class="line-modified">768                 m_blobLoader = makeUnique&lt;FileReaderLoader&gt;(FileReaderLoader::ReadAsArrayBuffer, this);</span>
769                 m_blobLoaderStatus = BlobLoaderStarted;
<span class="line-modified">770                 m_blobLoader-&gt;start(m_document.get(), *frame-&gt;blobData);</span>
771                 m_outgoingFrameQueue.prepend(WTFMove(frame));
772                 return;
773 
774             case BlobLoaderStarted:
775             case BlobLoaderFailed:
776                 m_outgoingFrameQueue.prepend(WTFMove(frame));
777                 return;
778 
779             case BlobLoaderFinished: {
780                 RefPtr&lt;ArrayBuffer&gt; result = m_blobLoader-&gt;arrayBufferResult();
781                 m_blobLoader = nullptr;
782                 m_blobLoaderStatus = BlobLoaderNotStarted;
783                 sendFrame(frame-&gt;opCode, static_cast&lt;const char*&gt;(result-&gt;data()), result-&gt;byteLength(), [this, protectedThis = makeRef(*this)] (bool success) {
784                     if (!success)
785                         fail(&quot;Failed to send WebSocket frame.&quot;);
786                 });
787                 break;
788             }
789             }
790             break;
</pre>
<hr />
<pre>
802         m_handle-&gt;close();
803     }
804 }
805 
806 void WebSocketChannel::abortOutgoingFrameQueue()
807 {
808     m_outgoingFrameQueue.clear();
809     m_outgoingFrameQueueStatus = OutgoingFrameQueueClosed;
810     if (m_blobLoaderStatus == BlobLoaderStarted) {
811         m_blobLoader-&gt;cancel();
812         didFail(FileError::ABORT_ERR);
813     }
814 }
815 
816 void WebSocketChannel::sendFrame(WebSocketFrame::OpCode opCode, const char* data, size_t dataLength, WTF::Function&lt;void(bool)&gt; completionHandler)
817 {
818     ASSERT(m_handle);
819     ASSERT(!m_suspended);
820 
821     WebSocketFrame frame(opCode, true, false, true, data, dataLength);
<span class="line-modified">822     InspectorInstrumentation::didSendWebSocketFrame(m_document.get(), m_identifier, frame);</span>
823 
824     auto deflateResult = m_deflateFramer.deflate(frame);
825     if (!deflateResult-&gt;succeeded()) {
826         fail(deflateResult-&gt;failureReason());
827         return completionHandler(false);
828     }
829 
830     Vector&lt;char&gt; frameData;
831     frame.makeFrameData(frameData);
832 
833     m_handle-&gt;sendData(frameData.data(), frameData.size(), WTFMove(completionHandler));
834 }
835 
<span class="line-modified">836 ResourceRequest WebSocketChannel::clientHandshakeRequest(Function&lt;String(const URL&amp;)&gt;&amp;&amp; cookieRequestHeaderFieldValue)</span>
837 {
<span class="line-modified">838     return m_handshake-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue));</span>
839 }
840 
841 const ResourceResponse&amp; WebSocketChannel::serverHandshakeResponse() const
842 {
843     return m_handshake-&gt;serverHandshakeResponse();
844 }
845 
846 WebSocketHandshake::Mode WebSocketChannel::handshakeMode() const
847 {
848     return m_handshake-&gt;mode();
849 }
850 
851 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="WebSocket.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebSocketChannel.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>