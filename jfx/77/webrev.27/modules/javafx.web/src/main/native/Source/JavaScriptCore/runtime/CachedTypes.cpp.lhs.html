<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
<a name="1" id="anc1"></a>
  29 #include &quot;BytecodeCacheVersion.h&quot;
  30 #include &quot;BytecodeLivenessAnalysis.h&quot;
<a name="2" id="anc2"></a><span class="line-modified">  31 #include &quot;JSCast.h&quot;</span>
  32 #include &quot;JSImmutableButterfly.h&quot;
  33 #include &quot;JSTemplateObjectDescriptor.h&quot;
  34 #include &quot;ScopedArgumentsTable.h&quot;
  35 #include &quot;SourceCodeKey.h&quot;
<a name="3" id="anc3"></a>
  36 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  37 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  38 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  39 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  40 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  41 #include &lt;wtf/FastMalloc.h&gt;
<a name="4" id="anc4"></a><span class="line-removed">  42 #include &lt;wtf/Forward.h&gt;</span>
  43 #include &lt;wtf/Optional.h&gt;
  44 #include &lt;wtf/UUID.h&gt;
<a name="5" id="anc5"></a><span class="line-modified">  45 #include &lt;wtf/text/AtomicStringImpl.h&gt;</span>
  46 
  47 namespace JSC {
  48 
<a name="6" id="anc6"></a>



  49 template &lt;typename T, typename = void&gt;
  50 struct SourceTypeImpl {
  51     using type = T;
  52 };
  53 
  54 template&lt;typename T&gt;
  55 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  56     using type = typename T::SourceType_;
  57 
  58 };
  59 
  60 template&lt;typename T&gt;
  61 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  62 
  63 class Encoder {
  64     WTF_MAKE_NONCOPYABLE(Encoder);
  65     WTF_FORBID_HEAP_ALLOCATION;
  66 
  67 public:
  68     class Allocation {
  69         friend class Encoder;
  70 
  71     public:
  72         uint8_t* buffer() const { return m_buffer; }
  73         ptrdiff_t offset() const { return m_offset; }
  74 
  75     private:
  76         Allocation(uint8_t* buffer, ptrdiff_t offset)
  77             : m_buffer(buffer)
  78             , m_offset(offset)
  79         {
  80         }
  81 
  82         uint8_t* m_buffer;
  83         ptrdiff_t m_offset;
  84     };
  85 
<a name="7" id="anc7"></a><span class="line-modified">  86     Encoder(VM&amp; vm)</span>
  87         : m_vm(vm)
<a name="8" id="anc8"></a>
  88         , m_baseOffset(0)
  89         , m_currentPage(nullptr)
  90     {
  91         allocateNewPage();
  92     }
  93 
  94     VM&amp; vm() { return m_vm; }
  95 
  96     Allocation malloc(unsigned size)
  97     {
<a name="9" id="anc9"></a><span class="line-modified">  98         ASSERT(size);</span>
  99         ptrdiff_t offset;
 100         if (m_currentPage-&gt;malloc(size, offset))
 101             return Allocation { m_currentPage-&gt;buffer() + offset, m_baseOffset + offset };
 102         allocateNewPage(size);
 103         return malloc(size);
 104     }
 105 
 106     template&lt;typename T, typename... Args&gt;
 107     T* malloc(Args&amp;&amp;... args)
 108     {
 109         return new (malloc(sizeof(T)).buffer()) T(std::forward&lt;Args&gt;(args)...);
 110     }
 111 
 112     ptrdiff_t offsetOf(const void* address)
 113     {
 114         ptrdiff_t offset;
 115         ptrdiff_t baseOffset = 0;
 116         for (const auto&amp; page : m_pages) {
 117             if (page.getOffset(address, offset))
 118                 return baseOffset + offset;
 119             baseOffset += page.size();
 120         }
 121         RELEASE_ASSERT_NOT_REACHED();
 122         return 0;
 123     }
 124 
 125     void cachePtr(const void* ptr, ptrdiff_t offset)
 126     {
 127         m_ptrToOffsetMap.add(ptr, offset);
 128     }
 129 
<a name="10" id="anc10"></a><span class="line-modified"> 130     WTF::Optional&lt;ptrdiff_t&gt; offsetForPtr(const void* ptr)</span>
 131     {
 132         auto it = m_ptrToOffsetMap.find(ptr);
 133         if (it == m_ptrToOffsetMap.end())
 134             return WTF::nullopt;
 135         return { it-&gt;value };
 136     }
 137 
<a name="11" id="anc11"></a><span class="line-modified"> 138     std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; release()</span>





 139     {
<a name="12" id="anc12"></a>







 140         size_t size = m_baseOffset + m_currentPage-&gt;size();
 141         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 142         unsigned offset = 0;
 143         for (const auto&amp; page : m_pages) {
 144             memcpy(buffer.get() + offset, page.buffer(), page.size());
 145             offset += page.size();
 146         }
 147         RELEASE_ASSERT(offset == size);
<a name="13" id="anc13"></a><span class="line-modified"> 148         return { WTFMove(buffer), size };</span>
 149     }
 150 
 151 private:
<a name="14" id="anc14"></a>






























 152     class Page {
 153     public:
 154         Page(size_t size)
 155             : m_offset(0)
 156             , m_capacity(size)
 157         {
 158             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);
 159         }
 160 
 161         bool malloc(size_t size, ptrdiff_t&amp; result)
 162         {
 163             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
<a name="15" id="anc15"></a><span class="line-modified"> 164             ptrdiff_t offset = WTF::roundUpToMultipleOf(alignment, m_offset);</span>
<span class="line-modified"> 165             size = WTF::roundUpToMultipleOf(alignment, size);</span>
 166             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 167                 return false;
 168 
 169             result = offset;
 170             m_offset = offset + size;
 171             return true;
 172         }
 173 
 174         uint8_t* buffer() const { return m_buffer.get(); }
 175         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 176 
 177         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 178         {
 179             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 180             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 181                 result = addr - m_buffer.get();
 182                 return true;
 183             }
 184             return false;
 185         }
 186 
<a name="16" id="anc16"></a>








 187     private:
 188         MallocPtr&lt;uint8_t&gt; m_buffer;
 189         ptrdiff_t m_offset;
 190         size_t m_capacity;
 191     };
 192 
 193     void allocateNewPage(size_t size = 0)
 194     {
<a name="17" id="anc17"></a><span class="line-modified"> 195         static size_t minPageSize = WTF::pageSize();</span>
<span class="line-modified"> 196         if (m_currentPage)</span>

 197             m_baseOffset += m_currentPage-&gt;size();
<a name="18" id="anc18"></a>
 198         if (size &lt; minPageSize)
 199             size = minPageSize;
 200         else
<a name="19" id="anc19"></a><span class="line-modified"> 201             size = WTF::roundUpToMultipleOf(minPageSize, size);</span>
 202         m_pages.append(Page { size });
 203         m_currentPage = &amp;m_pages.last();
 204     }
 205 
 206     VM&amp; m_vm;
<a name="20" id="anc20"></a>
 207     ptrdiff_t m_baseOffset;
 208     Page* m_currentPage;
 209     Vector&lt;Page&gt; m_pages;
 210     HashMap&lt;const void*, ptrdiff_t&gt; m_ptrToOffsetMap;
<a name="21" id="anc21"></a>
 211 };
 212 
<a name="22" id="anc22"></a><span class="line-modified"> 213 class Decoder {</span>
<span class="line-modified"> 214     WTF_MAKE_NONCOPYABLE(Decoder);</span>
<span class="line-modified"> 215     WTF_FORBID_HEAP_ALLOCATION;</span>



 216 
<a name="23" id="anc23"></a><span class="line-modified"> 217 public:</span>
<span class="line-modified"> 218     Decoder(VM&amp; vm, const void* baseAddress, size_t size)</span>
<span class="line-modified"> 219         : m_vm(vm)</span>
<span class="line-modified"> 220         , m_baseAddress(reinterpret_cast&lt;const uint8_t*&gt;(baseAddress))</span>
<span class="line-modified"> 221 #ifndef NDEBUG</span>
<span class="line-removed"> 222         , m_size(size)</span>
<span class="line-removed"> 223 #endif</span>
<span class="line-removed"> 224     {</span>
<span class="line-removed"> 225         UNUSED_PARAM(size);</span>
<span class="line-removed"> 226     }</span>
 227 
<a name="24" id="anc24"></a><span class="line-modified"> 228     ~Decoder()</span>
<span class="line-modified"> 229     {</span>
<span class="line-modified"> 230         for (auto&amp; pair : m_finalizers)</span>
<span class="line-modified"> 231             pair.value();</span>
<span class="line-removed"> 232     }</span>
 233 
<a name="25" id="anc25"></a><span class="line-modified"> 234     VM&amp; vm() { return m_vm; }</span>



 235 
<a name="26" id="anc26"></a><span class="line-modified"> 236     ptrdiff_t offsetOf(const void* ptr)</span>
<span class="line-modified"> 237     {</span>
<span class="line-modified"> 238         const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-modified"> 239         ASSERT(addr &gt;= m_baseAddress &amp;&amp; addr &lt; m_baseAddress + m_size);</span>
<span class="line-modified"> 240         return addr - m_baseAddress;</span>
<span class="line-modified"> 241     }</span>
 242 
<a name="27" id="anc27"></a><span class="line-modified"> 243     void cacheOffset(ptrdiff_t offset, void* ptr)</span>
<span class="line-modified"> 244     {</span>
<span class="line-modified"> 245         m_offsetToPtrMap.add(offset, ptr);</span>
<span class="line-modified"> 246     }</span>
 247 
<a name="28" id="anc28"></a><span class="line-modified"> 248     WTF::Optional&lt;void*&gt; ptrForOffset(ptrdiff_t offset)</span>
<span class="line-modified"> 249     {</span>
<span class="line-modified"> 250         auto it = m_offsetToPtrMap.find(offset);</span>
<span class="line-modified"> 251         if (it == m_offsetToPtrMap.end())</span>
<span class="line-modified"> 252             return WTF::nullopt;</span>
<span class="line-modified"> 253         return { it-&gt;value };</span>
<span class="line-modified"> 254     }</span>
 255 
<a name="29" id="anc29"></a><span class="line-modified"> 256     template&lt;typename Functor&gt;</span>
<span class="line-modified"> 257     void addFinalizer(ptrdiff_t offset, const Functor&amp; fn)</span>
<span class="line-modified"> 258     {</span>
<span class="line-modified"> 259         m_finalizers.add(offset, fn);</span>
<span class="line-modified"> 260     }</span>
 261 
<a name="30" id="anc30"></a><span class="line-modified"> 262 private:</span>
<span class="line-modified"> 263     VM&amp; m_vm;</span>
<span class="line-modified"> 264     const uint8_t* m_baseAddress;</span>
<span class="line-modified"> 265 #ifndef NDEBUG</span>
<span class="line-modified"> 266     size_t m_size;</span>
<span class="line-modified"> 267 #endif</span>
<span class="line-modified"> 268     HashMap&lt;ptrdiff_t, void*&gt; m_offsetToPtrMap;</span>
<span class="line-modified"> 269     HashMap&lt;ptrdiff_t, std::function&lt;void()&gt;&gt; m_finalizers;</span>
<span class="line-modified"> 270 };</span>



















 271 
 272 template&lt;typename T&gt;
 273 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp;, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 274 {
 275     dst = src;
 276 }
 277 
 278 template&lt;typename T&gt;
 279 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; encode(Encoder&amp; encoder, T&amp; dst, const SourceType&lt;T&gt;&amp; src)
 280 {
 281     dst.encode(encoder, src);
 282 }
 283 
 284 template&lt;typename T, typename... Args&gt;
 285 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp;, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args...)
 286 {
 287     dst = src;
 288 }
 289 
 290 template&lt;typename T, typename... Args&gt;
 291 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value&gt; decode(Decoder&amp; decoder, const T&amp; src, SourceType&lt;T&gt;&amp; dst, Args... args)
 292 {
 293     src.decode(decoder, dst, args...);
 294 }
 295 
 296 template&lt;typename T&gt;
 297 static std::enable_if_t&lt;std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, T&gt; decode(Decoder&amp;, T src)
 298 {
 299     return src;
 300 }
 301 
 302 template&lt;typename T&gt;
 303 static std::enable_if_t&lt;!std::is_same&lt;T, SourceType&lt;T&gt;&gt;::value, SourceType&lt;T&gt;&gt;&amp;&amp; decode(Decoder&amp; decoder, const T&amp; src)
 304 {
 305     return src.decode(decoder);
 306 }
 307 
 308 template&lt;typename Source&gt;
 309 class CachedObject {
 310     WTF_MAKE_NONCOPYABLE(CachedObject&lt;Source&gt;);
 311 
 312 public:
 313     using SourceType_ = Source;
 314 
 315     CachedObject() = default;
 316 
 317     inline void* operator new(size_t, void* where) { return where; }
<a name="31" id="anc31"></a>
 318 
 319     // Copied from WTF_FORBID_HEAP_ALLOCATION, since we only want to allow placement new
<a name="32" id="anc32"></a><span class="line-removed"> 320     void* operator new[](size_t, void*) = delete;</span>
 321     void* operator new(size_t) = delete;
 322     void operator delete(void*) = delete;
 323     void* operator new[](size_t size) = delete;
 324     void operator delete[](void*) = delete;
 325     void* operator new(size_t, NotNullTag, void* location) = delete;
 326 };
 327 
 328 template&lt;typename Source&gt;
<a name="33" id="anc33"></a><span class="line-modified"> 329 class VariableLengthObject : public CachedObject&lt;Source&gt; {</span>
 330     template&lt;typename, typename&gt;
<a name="34" id="anc34"></a><span class="line-modified"> 331     friend struct CachedPtr;</span>












 332 
 333 protected:
 334     const uint8_t* buffer() const
 335     {
<a name="35" id="anc35"></a><span class="line-modified"> 336         ASSERT(m_offset != s_invalidOffset);</span>
<span class="line-modified"> 337         return reinterpret_cast&lt;const uint8_t*&gt;(this) + m_offset;</span>
 338     }
 339 
 340     template&lt;typename T&gt;
 341     const T* buffer() const
 342     {
<a name="36" id="anc36"></a>
 343         return bitwise_cast&lt;const T*&gt;(buffer());
 344     }
 345 
 346     uint8_t* allocate(Encoder&amp; encoder, size_t size)
 347     {
 348         ptrdiff_t offsetOffset = encoder.offsetOf(&amp;m_offset);
 349         auto result = encoder.malloc(size);
 350         m_offset = result.offset() - offsetOffset;
 351         return result.buffer();
 352     }
 353 
 354     template&lt;typename T&gt;
<a name="37" id="anc37"></a>




 355     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 356     {
 357         uint8_t* result = allocate(encoder, sizeof(T) * size);
<a name="38" id="anc38"></a><span class="line-modified"> 358         return new (result) T();</span>

 359     }
 360 
 361 private:
 362     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
<a name="39" id="anc39"></a><span class="line-removed"> 363 </span>
<span class="line-removed"> 364     ptrdiff_t m_offset { s_invalidOffset };</span>
<span class="line-removed"> 365 </span>
 366 };
 367 
 368 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 369 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
 370     template&lt;typename, typename&gt;
<a name="40" id="anc40"></a><span class="line-modified"> 371     friend struct CachedRefPtr;</span>


 372 
 373 public:
 374     void encode(Encoder&amp; encoder, const Source* src)
 375     {
<a name="41" id="anc41"></a><span class="line-modified"> 376         m_isEmpty = !src;</span>
<span class="line-removed"> 377         if (m_isEmpty)</span>
 378             return;
 379 
<a name="42" id="anc42"></a><span class="line-modified"> 380         if (WTF::Optional&lt;ptrdiff_t&gt; offset = encoder.offsetForPtr(src)) {</span>
 381             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 382             return;
 383         }
 384 
 385         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 386         cachedObject-&gt;encode(encoder, *src);
 387         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 388     }
 389 
 390     template&lt;typename... Args&gt;
<a name="43" id="anc43"></a><span class="line-modified"> 391     Source* decode(Decoder&amp; decoder, Args... args) const</span>
 392     {
<a name="44" id="anc44"></a><span class="line-modified"> 393         if (m_isEmpty)</span>

 394             return nullptr;
<a name="45" id="anc45"></a>
 395 
 396         ptrdiff_t bufferOffset = decoder.offsetOf(this-&gt;buffer());
<a name="46" id="anc46"></a><span class="line-modified"> 397         if (WTF::Optional&lt;void*&gt; ptr = decoder.ptrForOffset(bufferOffset))</span>
<span class="line-modified"> 398             return reinterpret_cast&lt;Source*&gt;(*ptr);</span>


 399 
<a name="47" id="anc47"></a><span class="line-modified"> 400         Source* ptr = get()-&gt;decode(decoder, args...);</span>

 401         decoder.cacheOffset(bufferOffset, ptr);
 402         return ptr;
 403     }
 404 
<a name="48" id="anc48"></a>






 405     const T* operator-&gt;() const { return get(); }
 406 
 407 private:
 408     const T* get() const
 409     {
<a name="49" id="anc49"></a><span class="line-modified"> 410         if (m_isEmpty)</span>
<span class="line-removed"> 411             return nullptr;</span>
 412         return this-&gt;template buffer&lt;T&gt;();
 413     }
<a name="50" id="anc50"></a><span class="line-removed"> 414 </span>
<span class="line-removed"> 415     bool m_isEmpty;</span>
<span class="line-removed"> 416 </span>
 417 };
 418 
<a name="51" id="anc51"></a>




 419 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 420 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {
 421 public:
 422     void encode(Encoder&amp; encoder, const Source* src)
 423     {
 424         m_ptr.encode(encoder, src);
 425     }
 426 
 427     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)
 428     {
 429         encode(encoder, src.get());
 430     }
 431 
 432     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const
 433     {
<a name="52" id="anc52"></a><span class="line-modified"> 434         Source* decodedPtr = m_ptr.decode(decoder);</span>

 435         if (!decodedPtr)
 436             return nullptr;
<a name="53" id="anc53"></a><span class="line-modified"> 437         decoder.addFinalizer(decoder.offsetOf(m_ptr.buffer()), [=] { derefIfNotNull(decodedPtr); });</span>




 438         refIfNotNull(decodedPtr);
 439         return adoptRef(decodedPtr);
 440     }
 441 
 442     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const
 443     {
 444         src = decode(decoder);
 445     }
 446 
 447 private:
 448     CachedPtr&lt;T, Source&gt; m_ptr;
 449 };
 450 
 451 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 452 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
<a name="54" id="anc54"></a>

 453 public:
<a name="55" id="anc55"></a>

 454     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 455     {
 456         m_ptr.encode(encoder, src.get());
 457     }
 458 
 459     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 460     {
 461         Source* decodedPtr = m_ptr.decode(decoder);
 462         if (decodedPtr)
 463             src.set(decoder.vm(), owner, decodedPtr);
 464     }
 465 
 466 private:
 467     CachedPtr&lt;T, Source&gt; m_ptr;
 468 };
 469 
<a name="56" id="anc56"></a>




 470 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;
 471 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {
 472 public:
 473     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)
 474     {
 475         m_size = vector.size();
 476         if (!m_size)
 477             return;
 478         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 479         for (unsigned i = 0; i &lt; m_size; ++i)
 480             ::JSC::encode(encoder, buffer[i], vector[i]);
 481     }
 482 
 483     template&lt;typename... Args&gt;
 484     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const
 485     {
 486         if (!m_size)
 487             return;
 488         vector.resizeToFit(m_size);
 489         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 490         for (unsigned i = 0; i &lt; m_size; ++i)
 491             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 492     }
 493 
 494 private:
 495     unsigned m_size;
 496 };
 497 
 498 template&lt;typename First, typename Second&gt;
 499 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 500 public:
 501     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 502     {
 503         ::JSC::encode(encoder, m_first, pair.first);
 504         ::JSC::encode(encoder, m_second, pair.second);
 505     }
 506 
 507     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 508     {
 509         ::JSC::decode(decoder, m_first, pair.first);
 510         ::JSC::decode(decoder, m_second, pair.second);
 511     }
 512 
 513 private:
 514     First m_first;
 515     Second m_second;
 516 };
 517 
 518 template&lt;typename Key, typename Value, typename HashArg = typename DefaultHash&lt;SourceType&lt;Key&gt;&gt;::Hash, typename KeyTraitsArg = HashTraits&lt;SourceType&lt;Key&gt;&gt;, typename MappedTraitsArg = HashTraits&lt;SourceType&lt;Value&gt;&gt;&gt;
 519 class CachedHashMap : public VariableLengthObject&lt;HashMap&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;, HashArg, KeyTraitsArg, MappedTraitsArg&gt;&gt; {
 520     template&lt;typename K, typename V&gt;
 521     using Map = HashMap&lt;K, V, HashArg, KeyTraitsArg, MappedTraitsArg&gt;;
 522 
 523 public:
 524     void encode(Encoder&amp; encoder, const Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map)
 525     {
 526         SourceType&lt;decltype(m_entries)&gt; entriesVector(map.size());
 527         unsigned i = 0;
 528         for (const auto&amp; it : map)
 529             entriesVector[i++] = { it.key, it.value };
 530         m_entries.encode(encoder, entriesVector);
 531     }
 532 
 533     void decode(Decoder&amp; decoder, Map&lt;SourceType&lt;Key&gt;, SourceType&lt;Value&gt;&gt;&amp; map) const
 534     {
 535         SourceType&lt;decltype(m_entries)&gt; decodedEntries;
 536         m_entries.decode(decoder, decodedEntries);
 537         for (const auto&amp; pair : decodedEntries)
 538             map.set(pair.first, pair.second);
 539     }
 540 
 541 private:
 542     CachedVector&lt;CachedPair&lt;Key, Value&gt;&gt; m_entries;
 543 };
 544 
<a name="57" id="anc57"></a><span class="line-modified"> 545 class CachedUniquedStringImpl : public VariableLengthObject&lt;UniquedStringImpl&gt; {</span>

 546 public:
 547     void encode(Encoder&amp; encoder, const StringImpl&amp; string)
 548     {
<a name="58" id="anc58"></a><span class="line-modified"> 549         m_isAtomic = string.isAtomic();</span>
 550         m_isSymbol = string.isSymbol();
 551         RefPtr&lt;StringImpl&gt; impl = const_cast&lt;StringImpl*&gt;(&amp;string);
 552 
 553         if (m_isSymbol) {
 554             SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(impl.get());
 555             if (!symbol-&gt;isNullSymbol()) {
 556                 // We have special handling for well-known symbols.
 557                 if (!symbol-&gt;isPrivate())
 558                     impl = encoder.vm().propertyNames-&gt;getPublicName(encoder.vm(), symbol).impl();
 559             }
 560         }
 561 
 562         m_is8Bit = impl-&gt;is8Bit();
 563         m_length = impl-&gt;length();
 564 
 565         if (!m_length)
 566             return;
 567 
 568         unsigned size = m_length;
 569         const void* payload;
 570         if (m_is8Bit)
 571             payload = impl-&gt;characters8();
 572         else {
 573             payload = impl-&gt;characters16();
 574             size *= 2;
 575         }
 576 
 577         uint8_t* buffer = this-&gt;allocate(encoder, size);
 578         memcpy(buffer, payload, size);
 579     }
 580 
 581     UniquedStringImpl* decode(Decoder&amp; decoder) const
 582     {
 583         auto create = [&amp;](const auto* buffer) -&gt; UniquedStringImpl* {
 584             if (!m_isSymbol)
<a name="59" id="anc59"></a><span class="line-modified"> 585                 return AtomicStringImpl::add(buffer, m_length).leakRef();</span>
 586 
<a name="60" id="anc60"></a><span class="line-modified"> 587             Identifier ident = Identifier::fromString(&amp;decoder.vm(), buffer, m_length);</span>
 588             String str = decoder.vm().propertyNames-&gt;lookUpPrivateName(ident);
 589             StringImpl* impl = str.releaseImpl().get();
 590             ASSERT(impl-&gt;isSymbol());
 591             return static_cast&lt;UniquedStringImpl*&gt;(impl);
 592         };
 593 
 594         if (!m_length) {
 595             if (m_isSymbol)
 596                 return &amp;SymbolImpl::createNullSymbol().leakRef();
<a name="61" id="anc61"></a><span class="line-modified"> 597             return AtomicStringImpl::add(&quot;&quot;).leakRef();</span>
 598         }
 599 
 600         if (m_is8Bit)
<a name="62" id="anc62"></a><span class="line-modified"> 601             return create(this-&gt;buffer&lt;LChar&gt;());</span>
<span class="line-modified"> 602         return create(this-&gt;buffer&lt;UChar&gt;());</span>
 603     }
 604 
 605 private:
 606     bool m_is8Bit : 1;
 607     bool m_isSymbol : 1;
 608     bool m_isAtomic : 1;
 609     unsigned m_length;
 610 };
 611 
<a name="63" id="anc63"></a><span class="line-modified"> 612 class CachedStringImpl : public VariableLengthObject&lt;StringImpl&gt; {</span>
<span class="line-modified"> 613 public:</span>
<span class="line-removed"> 614     void encode(Encoder&amp; encoder, const StringImpl&amp; impl)</span>
<span class="line-removed"> 615     {</span>
<span class="line-removed"> 616         m_uniquedStringImpl.encode(encoder, impl);</span>
<span class="line-removed"> 617     }</span>
<span class="line-removed"> 618 </span>
<span class="line-removed"> 619     StringImpl* decode(Decoder&amp; decoder) const</span>
<span class="line-removed"> 620     {</span>
<span class="line-removed"> 621         return m_uniquedStringImpl.decode(decoder);</span>
<span class="line-removed"> 622     }</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624 private:</span>
<span class="line-removed"> 625     CachedUniquedStringImpl m_uniquedStringImpl;</span>
<span class="line-removed"> 626 };</span>
 627 
 628 class CachedString : public VariableLengthObject&lt;String&gt; {
 629 public:
 630     void encode(Encoder&amp; encoder, const String&amp; string)
 631     {
 632         m_impl.encode(encoder, static_cast&lt;UniquedStringImpl*&gt;(string.impl()));
 633     }
 634 
 635     String decode(Decoder&amp; decoder) const
 636     {
 637         return String(static_cast&lt;RefPtr&lt;StringImpl&gt;&gt;(m_impl.decode(decoder)));
 638     }
 639 
 640     void decode(Decoder&amp; decoder, String&amp; dst) const
 641     {
 642         dst = decode(decoder);
 643     }
 644 
 645 private:
 646     CachedRefPtr&lt;CachedUniquedStringImpl&gt; m_impl;
 647 };
 648 
 649 class CachedIdentifier : public VariableLengthObject&lt;Identifier&gt; {
 650 public:
 651     void encode(Encoder&amp; encoder, const Identifier&amp; identifier)
 652     {
 653         m_string.encode(encoder, identifier.string());
 654     }
 655 
 656     Identifier decode(Decoder&amp; decoder) const
 657     {
 658         String str = m_string.decode(decoder);
 659         if (str.isNull())
 660             return Identifier();
 661 
<a name="64" id="anc64"></a><span class="line-modified"> 662         return Identifier::fromUid(&amp;decoder.vm(), (UniquedStringImpl*)str.impl());</span>
 663     }
 664 
 665     void decode(Decoder&amp; decoder, Identifier&amp; ident) const
 666     {
 667         ident = decode(decoder);
 668     }
 669 
 670 private:
 671     CachedString m_string;
 672 };
 673 
 674 template&lt;typename T&gt;
<a name="65" id="anc65"></a><span class="line-modified"> 675 class CachedOptional : public VariableLengthObject&lt;WTF::Optional&lt;SourceType&lt;T&gt;&gt;&gt; {</span>
 676 public:
<a name="66" id="anc66"></a><span class="line-modified"> 677     void encode(Encoder&amp; encoder, const WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; source)</span>
 678     {
<a name="67" id="anc67"></a><span class="line-modified"> 679         m_isEmpty = !source;</span>
<span class="line-removed"> 680 </span>
<span class="line-removed"> 681         if (m_isEmpty)</span>
 682             return;
 683 
 684         this-&gt;template allocate&lt;T&gt;(encoder)-&gt;encode(encoder, *source);
 685     }
 686 
<a name="68" id="anc68"></a><span class="line-modified"> 687     WTF::Optional&lt;SourceType&lt;T&gt;&gt; decode(Decoder&amp; decoder) const</span>
 688     {
<a name="69" id="anc69"></a><span class="line-modified"> 689         if (m_isEmpty)</span>
 690             return WTF::nullopt;
 691 
 692         return { this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder) };
 693     }
 694 
<a name="70" id="anc70"></a><span class="line-modified"> 695     void decode(Decoder&amp; decoder, WTF::Optional&lt;SourceType&lt;T&gt;&gt;&amp; dst) const</span>
 696     {
 697         dst = decode(decoder);
 698     }
 699 
 700     void encode(Encoder&amp; encoder, const std::unique_ptr&lt;SourceType&lt;T&gt;&gt;&amp; source)
 701     {
 702         if (!source)
 703             encode(encoder, WTF::nullopt);
 704         else
 705             encode(encoder, { *source });
 706     }
<a name="71" id="anc71"></a><span class="line-removed"> 707 </span>
<span class="line-removed"> 708     SourceType&lt;T&gt;* decodeAsPtr(Decoder&amp; decoder) const</span>
<span class="line-removed"> 709     {</span>
<span class="line-removed"> 710         if (m_isEmpty)</span>
<span class="line-removed"> 711             return nullptr;</span>
<span class="line-removed"> 712 </span>
<span class="line-removed"> 713         return this-&gt;template buffer&lt;T&gt;()-&gt;decode(decoder);</span>
<span class="line-removed"> 714     }</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716 private:</span>
<span class="line-removed"> 717     bool m_isEmpty;</span>
 718 };
 719 
 720 class CachedSimpleJumpTable : public CachedObject&lt;UnlinkedSimpleJumpTable&gt; {
 721 public:
 722     void encode(Encoder&amp; encoder, const UnlinkedSimpleJumpTable&amp; jumpTable)
 723     {
 724         m_min = jumpTable.min;
 725         m_branchOffsets.encode(encoder, jumpTable.branchOffsets);
 726     }
 727 
 728     void decode(Decoder&amp; decoder, UnlinkedSimpleJumpTable&amp; jumpTable) const
 729     {
 730         jumpTable.min = m_min;
 731         m_branchOffsets.decode(decoder, jumpTable.branchOffsets);
 732     }
 733 
 734 private:
 735     int32_t m_min;
 736     CachedVector&lt;int32_t&gt; m_branchOffsets;
 737 };
 738 
 739 class CachedStringJumpTable : public CachedObject&lt;UnlinkedStringJumpTable&gt; {
 740 public:
 741     void encode(Encoder&amp; encoder, const UnlinkedStringJumpTable&amp; jumpTable)
 742     {
 743         m_offsetTable.encode(encoder, jumpTable.offsetTable);
 744     }
 745 
 746     void decode(Decoder&amp; decoder, UnlinkedStringJumpTable&amp; jumpTable) const
 747     {
 748         m_offsetTable.decode(decoder, jumpTable.offsetTable);
 749     }
 750 
 751 private:
 752     CachedHashMap&lt;CachedRefPtr&lt;CachedStringImpl&gt;, UnlinkedStringJumpTable:: OffsetLocation&gt; m_offsetTable;
 753 };
 754 
 755 class CachedBitVector : public VariableLengthObject&lt;BitVector&gt; {
 756 public:
 757     void encode(Encoder&amp; encoder, const BitVector&amp; bitVector)
 758     {
 759         m_numBits = bitVector.size();
 760         if (!m_numBits)
 761             return;
 762         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 763         uint8_t* buffer = this-&gt;allocate(encoder, sizeInBytes);
 764         memcpy(buffer, bitVector.bits(), sizeInBytes);
 765     }
 766 
 767     void decode(Decoder&amp;, BitVector&amp; bitVector) const
 768     {
 769         if (!m_numBits)
 770             return;
 771         bitVector.ensureSize(m_numBits);
 772         size_t sizeInBytes = BitVector::byteCount(m_numBits);
 773         memcpy(bitVector.bits(), this-&gt;buffer(), sizeInBytes);
 774     }
 775 
 776 private:
 777     size_t m_numBits;
 778 };
 779 
 780 template&lt;typename T, typename HashArg = typename DefaultHash&lt;T&gt;::Hash&gt;
 781 class CachedHashSet : public CachedObject&lt;HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&gt; {
 782 public:
 783     void encode(Encoder&amp; encoder, const HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set)
 784     {
 785         SourceType&lt;decltype(m_entries)&gt; entriesVector(set.size());
 786         unsigned i = 0;
 787         for (const auto&amp; item : set)
 788             entriesVector[i++] = item;
 789         m_entries.encode(encoder, entriesVector);
 790     }
 791 
 792     void decode(Decoder&amp; decoder, HashSet&lt;SourceType&lt;T&gt;, HashArg&gt;&amp; set) const
 793     {
 794         SourceType&lt;decltype(m_entries)&gt; entriesVector;
 795         m_entries.decode(decoder, entriesVector);
 796         for (const auto&amp; item : entriesVector)
 797             set.add(item);
 798     }
 799 
 800 private:
 801     CachedVector&lt;T&gt; m_entries;
 802 };
 803 
 804 class CachedConstantIdentifierSetEntry : public VariableLengthObject&lt;ConstantIdentifierSetEntry&gt; {
 805 public:
 806     void encode(Encoder&amp; encoder, const ConstantIdentifierSetEntry&amp; entry)
 807     {
 808         m_constant = entry.second;
 809         m_set.encode(encoder, entry.first);
 810     }
 811 
 812     void decode(Decoder&amp; decoder, ConstantIdentifierSetEntry&amp; entry) const
 813     {
 814         entry.second = m_constant;
 815         m_set.decode(decoder, entry.first);
 816     }
 817 
 818 private:
 819     unsigned m_constant;
 820     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 821 };
 822 
 823 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 824 public:
 825     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 826     {
 827         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 828         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 829         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 830         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 831         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 832         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 833         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 834         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
 835     }
 836 
 837     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 838     {
 839         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 840         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 841         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 842         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 843         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 844         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 845         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 846         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 847         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
 848         return rareData;
 849     }
 850 
 851 private:
 852     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 853     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 854     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 855     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 856     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 857     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 858     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 859     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
 860 };
 861 
 862 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 863 public:
 864     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 865     {
 866         m_isEverythingCaptured = env.m_isEverythingCaptured;
 867         m_map.encode(encoder, env.m_map);
 868     }
 869 
 870     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 871     {
 872         env.m_isEverythingCaptured = m_isEverythingCaptured;
 873         m_map.decode(decoder, env.m_map);
 874     }
 875 
 876 private:
 877     bool m_isEverythingCaptured;
 878     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;
 879 };
 880 
<a name="72" id="anc72"></a>
































































 881 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 882 class CachedArray : public VariableLengthObject&lt;Source*&gt; {
 883 public:
 884     void encode(Encoder&amp; encoder, const Source* array, unsigned size)
 885     {
 886         if (!size)
 887             return;
 888         T* dst = this-&gt;template allocate&lt;T&gt;(encoder, size);
 889         for (unsigned i = 0; i &lt; size; ++i)
 890             ::JSC::encode(encoder, dst[i], array[i]);
 891     }
 892 
 893     template&lt;typename... Args&gt;
 894     void decode(Decoder&amp; decoder, Source* array, unsigned size, Args... args) const
 895     {
 896         if (!size)
 897             return;
 898         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 899         for (unsigned i = 0; i &lt; size; ++i)
 900             ::JSC::decode(decoder, buffer[i], array[i], args...);
 901     }
 902 };
 903 
 904 class CachedScopedArgumentsTable : public CachedObject&lt;ScopedArgumentsTable&gt; {
 905 public:
 906     void encode(Encoder&amp; encoder, const ScopedArgumentsTable&amp; scopedArgumentsTable)
 907     {
 908         m_length = scopedArgumentsTable.m_length;
<a name="73" id="anc73"></a><span class="line-modified"> 909         m_arguments.encode(encoder, scopedArgumentsTable.m_arguments.get(), m_length);</span>
 910     }
 911 
 912     ScopedArgumentsTable* decode(Decoder&amp; decoder) const
 913     {
 914         ScopedArgumentsTable* scopedArgumentsTable = ScopedArgumentsTable::create(decoder.vm(), m_length);
<a name="74" id="anc74"></a><span class="line-modified"> 915         m_arguments.decode(decoder, scopedArgumentsTable-&gt;m_arguments.get(), m_length);</span>
 916         return scopedArgumentsTable;
 917     }
 918 
 919 private:
 920     uint32_t m_length;
 921     CachedArray&lt;ScopeOffset&gt; m_arguments;
 922 };
 923 
 924 class CachedSymbolTableEntry : public CachedObject&lt;SymbolTableEntry&gt; {
 925 public:
 926     void encode(Encoder&amp;, const SymbolTableEntry&amp; symbolTableEntry)
 927     {
 928         m_bits = symbolTableEntry.m_bits | SymbolTableEntry::SlimFlag;
 929     }
 930 
 931     void decode(Decoder&amp;, SymbolTableEntry&amp; symbolTableEntry) const
 932     {
 933         symbolTableEntry.m_bits = m_bits;
 934     }
 935 
 936 private:
 937     intptr_t m_bits;
 938 };
 939 
 940 class CachedSymbolTable : public CachedObject&lt;SymbolTable&gt; {
 941 public:
 942     void encode(Encoder&amp; encoder, const SymbolTable&amp; symbolTable)
 943     {
 944         m_map.encode(encoder, symbolTable.m_map);
 945         m_maxScopeOffset = symbolTable.m_maxScopeOffset;
 946         m_usesNonStrictEval = symbolTable.m_usesNonStrictEval;
 947         m_nestedLexicalScope = symbolTable.m_nestedLexicalScope;
 948         m_scopeType = symbolTable.m_scopeType;
 949         m_arguments.encode(encoder, symbolTable.m_arguments.get());
 950     }
 951 
 952     SymbolTable* decode(Decoder&amp; decoder) const
 953     {
 954         SymbolTable* symbolTable = SymbolTable::create(decoder.vm());
 955         m_map.decode(decoder, symbolTable-&gt;m_map);
 956         symbolTable-&gt;m_maxScopeOffset = m_maxScopeOffset;
 957         symbolTable-&gt;m_usesNonStrictEval = m_usesNonStrictEval;
 958         symbolTable-&gt;m_nestedLexicalScope = m_nestedLexicalScope;
 959         symbolTable-&gt;m_scopeType = m_scopeType;
 960         ScopedArgumentsTable* scopedArgumentsTable = m_arguments.decode(decoder);
 961         if (scopedArgumentsTable)
 962             symbolTable-&gt;m_arguments.set(decoder.vm(), symbolTable, scopedArgumentsTable);
 963         return symbolTable;
 964     }
 965 
 966 private:
 967     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, CachedSymbolTableEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, SymbolTableIndexHashTraits&gt; m_map;
 968     ScopeOffset m_maxScopeOffset;
 969     unsigned m_usesNonStrictEval : 1;
 970     unsigned m_nestedLexicalScope : 1;
 971     unsigned m_scopeType : 3;
 972     CachedPtr&lt;CachedScopedArgumentsTable&gt; m_arguments;
 973 };
 974 
 975 class CachedJSValue;
 976 class CachedImmutableButterfly : public CachedObject&lt;JSImmutableButterfly&gt; {
 977 public:
 978     CachedImmutableButterfly()
 979         : m_cachedDoubles()
 980     {
 981     }
 982 
 983     void encode(Encoder&amp; encoder, JSImmutableButterfly&amp; immutableButterfly)
 984     {
 985         m_length = immutableButterfly.length();
 986         m_indexingType = immutableButterfly.indexingTypeAndMisc();
 987         if (hasDouble(m_indexingType))
 988             m_cachedDoubles.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguousDouble().data(), m_length);
 989         else
 990             m_cachedValues.encode(encoder, immutableButterfly.toButterfly()-&gt;contiguous().data(), m_length);
 991     }
 992 
 993     JSImmutableButterfly* decode(Decoder&amp; decoder) const
 994     {
 995         JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::create(decoder.vm(), m_indexingType, m_length);
 996         if (hasDouble(m_indexingType))
 997             m_cachedDoubles.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguousDouble().data(), m_length, immutableButterfly);
 998         else
 999             m_cachedValues.decode(decoder, immutableButterfly-&gt;toButterfly()-&gt;contiguous().data(), m_length, immutableButterfly);
1000         return immutableButterfly;
1001     }
1002 
1003 private:
1004     IndexingType m_indexingType;
1005     unsigned m_length;
1006     union {
1007         CachedArray&lt;double&gt; m_cachedDoubles;
1008         CachedArray&lt;CachedJSValue, WriteBarrier&lt;Unknown&gt;&gt; m_cachedValues;
1009     };
1010 };
1011 
1012 class CachedRegExp : public CachedObject&lt;RegExp&gt; {
1013 public:
1014     void encode(Encoder&amp; encoder, const RegExp&amp; regExp)
1015     {
1016         m_patternString.encode(encoder, regExp.m_patternString);
1017         m_flags = regExp.m_flags;
1018     }
1019 
1020     RegExp* decode(Decoder&amp; decoder) const
1021     {
1022         String pattern { m_patternString.decode(decoder) };
1023         return RegExp::create(decoder.vm(), pattern, m_flags);
1024     }
1025 
1026 private:
1027     CachedString m_patternString;
<a name="75" id="anc75"></a><span class="line-modified">1028     RegExpFlags m_flags;</span>
1029 };
1030 
1031 class CachedTemplateObjectDescriptor : public CachedObject&lt;TemplateObjectDescriptor&gt; {
1032 public:
<a name="76" id="anc76"></a><span class="line-modified">1033     void encode(Encoder&amp; encoder, const TemplateObjectDescriptor&amp; templateObjectDescriptor)</span>
1034     {
<a name="77" id="anc77"></a><span class="line-modified">1035         m_rawStrings.encode(encoder, templateObjectDescriptor.rawStrings());</span>
<span class="line-modified">1036         m_cookedStrings.encode(encoder, templateObjectDescriptor.cookedStrings());</span>

1037     }
1038 
<a name="78" id="anc78"></a><span class="line-modified">1039     Ref&lt;TemplateObjectDescriptor&gt; decode(Decoder&amp; decoder) const</span>
1040     {
1041         TemplateObjectDescriptor::StringVector decodedRawStrings;
1042         TemplateObjectDescriptor::OptionalStringVector decodedCookedStrings;
1043         m_rawStrings.decode(decoder, decodedRawStrings);
1044         m_cookedStrings.decode(decoder, decodedCookedStrings);
<a name="79" id="anc79"></a><span class="line-modified">1045         return TemplateObjectDescriptor::create(WTFMove(decodedRawStrings), WTFMove(decodedCookedStrings));</span>
1046     }
1047 
1048 private:
1049     CachedVector&lt;CachedString, 4&gt; m_rawStrings;
1050     CachedVector&lt;CachedOptional&lt;CachedString&gt;, 4&gt; m_cookedStrings;
<a name="80" id="anc80"></a>
1051 };
1052 
1053 class CachedBigInt : public VariableLengthObject&lt;JSBigInt&gt; {
1054 public:
1055     void encode(Encoder&amp; encoder, JSBigInt&amp; bigInt)
1056     {
1057         m_length = bigInt.length();
1058         m_sign = bigInt.sign();
1059 
1060         if (!m_length)
1061             return;
1062 
1063         unsigned size = sizeof(JSBigInt::Digit) * m_length;
1064         uint8_t* buffer = this-&gt;allocate(encoder, size);
1065         memcpy(buffer, bigInt.dataStorage(), size);
1066     }
1067 
1068     JSBigInt* decode(Decoder&amp; decoder) const
1069     {
1070         JSBigInt* bigInt = JSBigInt::createWithLengthUnchecked(decoder.vm(), m_length);
1071         bigInt-&gt;setSign(m_sign);
1072         if (m_length)
1073             memcpy(bigInt-&gt;dataStorage(), this-&gt;buffer(), sizeof(JSBigInt::Digit) * m_length);
1074         return bigInt;
1075     }
1076 
1077 private:
1078     unsigned m_length;
1079     bool m_sign;
1080 };
1081 
1082 class CachedJSValue : public VariableLengthObject&lt;WriteBarrier&lt;Unknown&gt;&gt; {
1083 public:
1084     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Unknown&gt; value)
1085     {
1086         JSValue v = value.get();
1087 
1088         if (!v.isCell() || v.isEmpty()) {
1089             m_type = EncodedType::JSValue;
1090             *this-&gt;allocate&lt;EncodedJSValue&gt;(encoder) = JSValue::encode(v);
1091             return;
1092         }
1093 
1094         JSCell* cell = v.asCell();
1095         VM&amp; vm = encoder.vm();
1096 
1097         if (auto* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {
1098             m_type = EncodedType::SymbolTable;
1099             this-&gt;allocate&lt;CachedSymbolTable&gt;(encoder)-&gt;encode(encoder, *symbolTable);
1100             return;
1101         }
1102 
1103         if (auto* string = jsDynamicCast&lt;JSString*&gt;(vm, cell)) {
1104             m_type = EncodedType::String;
1105             StringImpl* impl = string-&gt;tryGetValue().impl();
1106             this-&gt;allocate&lt;CachedUniquedStringImpl&gt;(encoder)-&gt;encode(encoder, *impl);
1107             return;
1108         }
1109 
1110         if (auto* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, cell)) {
1111             m_type = EncodedType::ImmutableButterfly;
1112             this-&gt;allocate&lt;CachedImmutableButterfly&gt;(encoder)-&gt;encode(encoder, *immutableButterfly);
1113             return;
1114         }
1115 
1116         if (auto* regexp = jsDynamicCast&lt;RegExp*&gt;(vm, cell)) {
1117             m_type = EncodedType::RegExp;
1118             this-&gt;allocate&lt;CachedRegExp&gt;(encoder)-&gt;encode(encoder, *regexp);
1119             return;
1120         }
1121 
1122         if (auto* templateObjectDescriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {
1123             m_type = EncodedType::TemplateObjectDescriptor;
<a name="81" id="anc81"></a><span class="line-modified">1124             this-&gt;allocate&lt;CachedTemplateObjectDescriptor&gt;(encoder)-&gt;encode(encoder, templateObjectDescriptor-&gt;descriptor());</span>
1125             return;
1126         }
1127 
1128         if (auto* bigInt = jsDynamicCast&lt;JSBigInt*&gt;(vm, cell)) {
1129             m_type = EncodedType::BigInt;
1130             this-&gt;allocate&lt;CachedBigInt&gt;(encoder)-&gt;encode(encoder, *bigInt);
1131             return;
1132         }
1133 
1134         RELEASE_ASSERT_NOT_REACHED();
1135     }
1136 
1137     void decode(Decoder&amp; decoder, WriteBarrier&lt;Unknown&gt;&amp; value, const JSCell* owner) const
1138     {
1139         JSValue v;
1140         switch (m_type) {
1141         case EncodedType::JSValue:
1142             v = JSValue::decode(*this-&gt;buffer&lt;EncodedJSValue&gt;());
1143             break;
1144         case EncodedType::SymbolTable:
1145             v = this-&gt;buffer&lt;CachedSymbolTable&gt;()-&gt;decode(decoder);
1146             break;
1147         case EncodedType::String: {
1148             StringImpl* impl = this-&gt;buffer&lt;CachedUniquedStringImpl&gt;()-&gt;decode(decoder);
<a name="82" id="anc82"></a><span class="line-modified">1149             v = jsString(&amp;decoder.vm(), adoptRef(*impl));</span>
1150             break;
1151         }
1152         case EncodedType::ImmutableButterfly:
1153             v = this-&gt;buffer&lt;CachedImmutableButterfly&gt;()-&gt;decode(decoder);
1154             break;
1155         case EncodedType::RegExp:
1156             v = this-&gt;buffer&lt;CachedRegExp&gt;()-&gt;decode(decoder);
1157             break;
1158         case EncodedType::TemplateObjectDescriptor:
<a name="83" id="anc83"></a><span class="line-modified">1159             v = JSTemplateObjectDescriptor::create(decoder.vm(), this-&gt;buffer&lt;CachedTemplateObjectDescriptor&gt;()-&gt;decode(decoder));</span>
1160             break;
1161         case EncodedType::BigInt:
1162             v = this-&gt;buffer&lt;CachedBigInt&gt;()-&gt;decode(decoder);
1163             break;
1164         default:
1165             RELEASE_ASSERT_NOT_REACHED();
1166         }
1167         value.set(decoder.vm(), owner, v);
1168     }
1169 
1170 private:
1171     enum class EncodedType : uint8_t {
1172         JSValue,
1173         SymbolTable,
1174         String,
1175         ImmutableButterfly,
1176         RegExp,
1177         TemplateObjectDescriptor,
1178         BigInt,
1179     };
1180 
1181     EncodedType m_type;
1182 };
1183 
1184 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1185 public:
1186     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1187     {
1188         m_instructions.encode(encoder, stream.m_instructions);
1189     }
1190 
1191     InstructionStream* decode(Decoder&amp; decoder) const
1192     {
1193         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;
1194         m_instructions.decode(decoder, instructionsVector);
1195         return new InstructionStream(WTFMove(instructionsVector));
1196     }
1197 
1198 private:
1199     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;
1200 };
1201 
1202 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1203 public:
1204     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1205     {
1206         ASSERT(metadataTable.m_isFinalized);
1207         m_hasMetadata = metadataTable.m_hasMetadata;
1208         if (!m_hasMetadata)
1209             return;
<a name="84" id="anc84"></a><span class="line-modified">1210         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-modified">1211             m_metadata[i] = metadataTable.buffer()[i];</span>






1212     }
1213 
1214     Ref&lt;UnlinkedMetadataTable&gt; decode(Decoder&amp;) const
1215     {
<a name="85" id="anc85"></a><span class="line-modified">1216         Ref&lt;UnlinkedMetadataTable&gt; metadataTable = UnlinkedMetadataTable::create();</span>



1217         metadataTable-&gt;m_isFinalized = true;
1218         metadataTable-&gt;m_isLinked = false;
1219         metadataTable-&gt;m_hasMetadata = m_hasMetadata;
<a name="86" id="anc86"></a><span class="line-modified">1220         for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)</span>
<span class="line-modified">1221             metadataTable-&gt;buffer()[i] = m_metadata[i];</span>





1222         return metadataTable;
1223     }
1224 
1225 private:
1226     bool m_hasMetadata;
<a name="87" id="anc87"></a>
1227     std::array&lt;unsigned, UnlinkedMetadataTable::s_offsetTableEntries&gt; m_metadata;
1228 };
1229 
1230 class CachedSourceOrigin : public CachedObject&lt;SourceOrigin&gt; {
1231 public:
1232     void encode(Encoder&amp; encoder, const SourceOrigin&amp; sourceOrigin)
1233     {
1234         m_string.encode(encoder, sourceOrigin.string());
1235     }
1236 
1237     SourceOrigin decode(Decoder&amp; decoder) const
1238     {
1239         return SourceOrigin { m_string.decode(decoder) };
1240     }
1241 
1242 private:
1243     CachedString m_string;
1244 };
1245 
1246 class CachedTextPosition : public CachedObject&lt;TextPosition&gt; {
1247 public:
1248     void encode(Encoder&amp;, TextPosition textPosition)
1249     {
1250         m_line = textPosition.m_line.zeroBasedInt();
1251         m_column = textPosition.m_column.zeroBasedInt();
1252     }
1253 
1254     TextPosition decode(Decoder&amp;) const
1255     {
1256         return TextPosition { OrdinalNumber::fromZeroBasedInt(m_line), OrdinalNumber::fromZeroBasedInt(m_column) };
1257     }
1258 
1259 private:
1260     int m_line;
1261     int m_column;
1262 };
1263 
1264 template &lt;typename Source, typename CachedType&gt;
1265 class CachedSourceProviderShape : public CachedObject&lt;Source&gt; {
1266 public:
1267     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1268     {
1269         m_sourceOrigin.encode(encoder, sourceProvider.sourceOrigin());
1270         m_url.encode(encoder, sourceProvider.url());
1271         m_sourceURLDirective.encode(encoder, sourceProvider.sourceURLDirective());
1272         m_sourceMappingURLDirective.encode(encoder, sourceProvider.sourceMappingURLDirective());
1273         m_startPosition.encode(encoder, sourceProvider.startPosition());
1274     }
1275 
1276     void decode(Decoder&amp; decoder, SourceProvider&amp; sourceProvider) const
1277     {
1278         sourceProvider.setSourceURLDirective(m_sourceURLDirective.decode(decoder));
1279         sourceProvider.setSourceMappingURLDirective(m_sourceMappingURLDirective.decode(decoder));
1280     }
1281 
1282 protected:
1283     CachedSourceOrigin m_sourceOrigin;
1284     CachedString m_url;
1285     CachedString m_sourceURLDirective;
1286     CachedString m_sourceMappingURLDirective;
1287     CachedTextPosition m_startPosition;
1288 };
1289 
1290 class CachedStringSourceProvider : public CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt; {
1291     using Base = CachedSourceProviderShape&lt;StringSourceProvider, CachedStringSourceProvider&gt;;
1292 
1293 public:
1294     void encode(Encoder&amp; encoder, const StringSourceProvider&amp; sourceProvider)
1295     {
1296         Base::encode(encoder, sourceProvider);
1297         m_source.encode(encoder, sourceProvider.source().toString());
1298     }
1299 
1300     StringSourceProvider* decode(Decoder&amp; decoder, SourceProviderSourceType sourceType) const
1301     {
1302         String decodedSource = m_source.decode(decoder);
1303         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1304         String decodedURL = m_url.decode(decoder);
1305         TextPosition decodedStartPosition = m_startPosition.decode(decoder);
1306 
1307         Ref&lt;StringSourceProvider&gt; sourceProvider = StringSourceProvider::create(decodedSource, decodedSourceOrigin, URL(URL(), decodedURL), decodedStartPosition, sourceType);
1308         Base::decode(decoder, sourceProvider.get());
1309         return &amp;sourceProvider.leakRef();
1310     }
1311 
1312 private:
1313     CachedString m_source;
1314 };
1315 
1316 #if ENABLE(WEBASSEMBLY)
1317 class CachedWebAssemblySourceProvider : public CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt; {
1318     using Base = CachedSourceProviderShape&lt;WebAssemblySourceProvider, CachedWebAssemblySourceProvider&gt;;
1319 
1320 public:
1321     void encode(Encoder&amp; encoder, const WebAssemblySourceProvider&amp; sourceProvider)
1322     {
1323         Base::encode(encoder, sourceProvider);
1324         m_data.encode(encoder, sourceProvider.data());
1325     }
1326 
1327     WebAssemblySourceProvider* decode(Decoder&amp; decoder) const
1328     {
1329         Vector&lt;uint8_t&gt; decodedData;
1330         SourceOrigin decodedSourceOrigin = m_sourceOrigin.decode(decoder);
1331         String decodedURL = m_url.decode(decoder);
1332 
1333         m_data.decode(decoder, decodedData);
1334 
1335         Ref&lt;WebAssemblySourceProvider&gt; sourceProvider = WebAssemblySourceProvider::create(WTFMove(decodedData), decodedSourceOrigin, URL(URL(), decodedURL));
1336         Base::decode(decoder, sourceProvider.get());
1337 
1338         return &amp;sourceProvider.leakRef();
1339     }
1340 
1341 private:
1342     CachedVector&lt;uint8_t&gt; m_data;
1343 };
1344 #endif
1345 
1346 class CachedSourceProvider : public VariableLengthObject&lt;SourceProvider&gt; {
1347 public:
1348     void encode(Encoder&amp; encoder, const SourceProvider&amp; sourceProvider)
1349     {
1350         m_sourceType = sourceProvider.sourceType();
1351         switch (m_sourceType) {
1352         case SourceProviderSourceType::Program:
1353         case SourceProviderSourceType::Module:
1354             this-&gt;allocate&lt;CachedStringSourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const StringSourceProvider&amp;&gt;(sourceProvider));
1355             break;
1356 #if ENABLE(WEBASSEMBLY)
1357         case SourceProviderSourceType::WebAssembly:
1358             this-&gt;allocate&lt;CachedWebAssemblySourceProvider&gt;(encoder)-&gt;encode(encoder, reinterpret_cast&lt;const WebAssemblySourceProvider&amp;&gt;(sourceProvider));
1359             break;
1360 #endif
1361         default:
1362             RELEASE_ASSERT_NOT_REACHED();
1363         }
1364     }
1365 
1366     SourceProvider* decode(Decoder&amp; decoder) const
1367     {
1368         switch (m_sourceType) {
1369         case SourceProviderSourceType::Program:
1370         case SourceProviderSourceType::Module:
1371             return this-&gt;buffer&lt;CachedStringSourceProvider&gt;()-&gt;decode(decoder, m_sourceType);
1372 #if ENABLE(WEBASSEMBLY)
1373         case SourceProviderSourceType::WebAssembly:
1374             return this-&gt;buffer&lt;CachedWebAssemblySourceProvider&gt;()-&gt;decode(decoder);
1375 #endif
1376         default:
1377             RELEASE_ASSERT_NOT_REACHED();
1378         }
1379     }
1380 
1381 private:
1382     SourceProviderSourceType m_sourceType;
1383 };
1384 
1385 template&lt;typename Source&gt;
1386 class CachedUnlinkedSourceCodeShape : public CachedObject&lt;Source&gt; {
1387 public:
1388     void encode(Encoder&amp; encoder, const UnlinkedSourceCode&amp; sourceCode)
1389     {
<a name="88" id="anc88"></a><span class="line-modified">1390         m_provider.encode(encoder, sourceCode.m_provider.get());</span>
1391         m_startOffset = sourceCode.startOffset();
1392         m_endOffset = sourceCode.endOffset();
1393     }
1394 
1395     void decode(Decoder&amp; decoder, UnlinkedSourceCode&amp; sourceCode) const
1396     {
1397         sourceCode.m_provider = m_provider.decode(decoder);
1398         sourceCode.m_startOffset = m_startOffset;
1399         sourceCode.m_endOffset = m_endOffset;
1400     }
1401 
1402 private:
<a name="89" id="anc89"></a><span class="line-modified">1403     CachedPtr&lt;CachedSourceProvider&gt; m_provider;</span>
1404     int m_startOffset;
1405     int m_endOffset;
1406 };
1407 
1408 
1409 class CachedUnlinkedSourceCode : public CachedUnlinkedSourceCodeShape&lt;UnlinkedSourceCode&gt; { };
1410 
1411 class CachedSourceCode : public CachedUnlinkedSourceCodeShape&lt;SourceCode&gt; {
1412     using Base = CachedUnlinkedSourceCodeShape&lt;SourceCode&gt;;
1413 
1414 public:
1415     void encode(Encoder&amp; encoder, const SourceCode&amp; sourceCode)
1416     {
1417         Base::encode(encoder, sourceCode);
1418         m_firstLine = sourceCode.firstLine().zeroBasedInt();
1419         m_startColumn = sourceCode.startColumn().zeroBasedInt();
1420     }
1421 
1422     void decode(Decoder&amp; decoder, SourceCode&amp; sourceCode) const
1423     {
1424         Base::decode(decoder, sourceCode);
1425         sourceCode.m_firstLine = OrdinalNumber::fromZeroBasedInt(m_firstLine);
1426         sourceCode.m_startColumn = OrdinalNumber::fromZeroBasedInt(m_startColumn);
1427     }
1428 
1429 private:
1430     int m_firstLine;
1431     int m_startColumn;
1432 };
1433 
<a name="90" id="anc90"></a>




























1434 class CachedFunctionExecutableRareData : public CachedObject&lt;UnlinkedFunctionExecutable::RareData&gt; {
1435 public:
1436     void encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable::RareData&amp; rareData)
1437     {
1438         m_classSource.encode(encoder, rareData.m_classSource);
<a name="91" id="anc91"></a>
1439     }
1440 
1441     UnlinkedFunctionExecutable::RareData* decode(Decoder&amp; decoder) const
1442     {
1443         UnlinkedFunctionExecutable::RareData* rareData = new UnlinkedFunctionExecutable::RareData { };
1444         m_classSource.decode(decoder, rareData-&gt;m_classSource);
<a name="92" id="anc92"></a>

1445         return rareData;
1446     }
1447 
1448 private:
<a name="93" id="anc93"></a><span class="line-modified">1449     CachedSourceCode m_classSource;</span>

1450 };
1451 
1452 class CachedFunctionExecutable : public CachedObject&lt;UnlinkedFunctionExecutable&gt; {
<a name="94" id="anc94"></a>

1453 public:
1454     void encode(Encoder&amp;, const UnlinkedFunctionExecutable&amp;);
1455     UnlinkedFunctionExecutable* decode(Decoder&amp;) const;
1456 
1457     unsigned firstLineOffset() const { return m_firstLineOffset; }
1458     unsigned lineCount() const { return m_lineCount; }
1459     unsigned unlinkedFunctionNameStart() const { return m_unlinkedFunctionNameStart; }
1460     unsigned unlinkedBodyStartColumn() const { return m_unlinkedBodyStartColumn; }
1461     unsigned unlinkedBodyEndColumn() const { return m_unlinkedBodyEndColumn; }
1462     unsigned startOffset() const { return m_startOffset; }
1463     unsigned sourceLength() const { return m_sourceLength; }
1464     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1465     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1466     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1467     unsigned parameterCount() const { return m_parameterCount; }
1468 
<a name="95" id="anc95"></a><span class="line-modified">1469     CodeFeatures features() const { return m_features; }</span>
1470     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1471 
1472     unsigned isInStrictContext() const { return m_isInStrictContext; }
<a name="96" id="anc96"></a><span class="line-modified">1473     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }</span>
1474     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1475     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1476     unsigned constructAbility() const { return m_constructAbility; }
1477     unsigned constructorKind() const { return m_constructorKind; }
1478     unsigned functionMode() const { return m_functionMode; }
1479     unsigned scriptMode() const { return m_scriptMode; }
1480     unsigned superBinding() const { return m_superBinding; }
1481     unsigned derivedContextType() const { return m_derivedContextType; }
1482 
1483     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1484     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
<a name="97" id="anc97"></a><span class="line-removed">1485     Identifier inferredName(Decoder&amp; decoder) const { return m_inferredName.decode(decoder); }</span>
1486 
<a name="98" id="anc98"></a><span class="line-modified">1487     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>



1488 
1489 private:
<a name="99" id="anc99"></a><span class="line-modified">1490     unsigned m_firstLineOffset;</span>
<span class="line-modified">1491     unsigned m_lineCount;</span>
<span class="line-modified">1492     unsigned m_unlinkedFunctionNameStart;</span>
<span class="line-removed">1493     unsigned m_unlinkedBodyStartColumn;</span>
<span class="line-removed">1494     unsigned m_unlinkedBodyEndColumn;</span>
<span class="line-removed">1495     unsigned m_startOffset;</span>
<span class="line-removed">1496     unsigned m_sourceLength;</span>
<span class="line-removed">1497     unsigned m_parametersStartOffset;</span>
<span class="line-removed">1498     unsigned m_typeProfilingStartOffset;</span>
<span class="line-removed">1499     unsigned m_typeProfilingEndOffset;</span>
<span class="line-removed">1500     unsigned m_parameterCount;</span>
<span class="line-removed">1501     CodeFeatures m_features;</span>
<span class="line-removed">1502     SourceParseMode m_sourceParseMode;</span>
1503     unsigned m_isInStrictContext : 1;
<a name="100" id="anc100"></a><span class="line-modified">1504     unsigned m_hasCapturedVariables : 1;</span>
1505     unsigned m_isBuiltinFunction : 1;
<a name="101" id="anc101"></a>
1506     unsigned m_isBuiltinDefaultClassConstructor : 1;
<a name="102" id="anc102"></a>
1507     unsigned m_constructAbility: 1;
<a name="103" id="anc103"></a><span class="line-modified">1508     unsigned m_constructorKind : 2;</span>
<span class="line-modified">1509     unsigned m_functionMode : 2; // FunctionMode</span>
1510     unsigned m_scriptMode: 1; // JSParserScriptMode
<a name="104" id="anc104"></a>
1511     unsigned m_superBinding : 1;
<a name="105" id="anc105"></a>






1512     unsigned m_derivedContextType: 2;
1513 
<a name="106" id="anc106"></a><span class="line-modified">1514     CachedOptional&lt;CachedFunctionExecutableRareData&gt; m_rareData;</span>
1515 
1516     CachedIdentifier m_name;
1517     CachedIdentifier m_ecmaName;
<a name="107" id="anc107"></a><span class="line-removed">1518     CachedIdentifier m_inferredName;</span>
<span class="line-removed">1519 </span>
<span class="line-removed">1520     CachedVariableEnvironment m_parentScopeTDZVariables;</span>
1521 
1522     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1523     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1524 };
1525 
<a name="108" id="anc108"></a>














1526 template&lt;typename CodeBlockType&gt;
1527 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1528 public:
1529     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1530     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1531 
1532     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1533 
1534     VirtualRegister thisRegister() const { return m_thisRegister; }
1535     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1536 
1537     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }
1538     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }
1539 
1540     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1541 
1542     unsigned usesEval() const { return m_usesEval; }
1543     unsigned isStrictMode() const { return m_isStrictMode; }
1544     unsigned isConstructor() const { return m_isConstructor; }
1545     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1546     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1547     unsigned superBinding() const { return m_superBinding; }
1548     unsigned scriptMode() const { return m_scriptMode; }
1549     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1550     unsigned isClassContext() const { return m_isClassContext; }
<a name="109" id="anc109"></a><span class="line-removed">1551     unsigned wasCompiledWithDebuggingOpcodes() const { return m_wasCompiledWithDebuggingOpcodes; }</span>
1552     unsigned constructorKind() const { return m_constructorKind; }
1553     unsigned derivedContextType() const { return m_derivedContextType; }
1554     unsigned evalContextType() const { return m_evalContextType; }
1555     unsigned hasTailCalls() const { return m_hasTailCalls; }
1556     unsigned lineCount() const { return m_lineCount; }
1557     unsigned endColumn() const { return m_endColumn; }
1558 
1559     int numVars() const { return m_numVars; }
1560     int numCalleeLocals() const { return m_numCalleeLocals; }
1561     int numParameters() const { return m_numParameters; }
1562 
1563     CodeFeatures features() const { return m_features; }
1564     SourceParseMode parseMode() const { return m_parseMode; }
<a name="110" id="anc110"></a>
1565     unsigned codeType() const { return m_codeType; }
1566 
<a name="111" id="anc111"></a><span class="line-modified">1567     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decodeAsPtr(decoder); }</span>
1568 
1569 private:
1570     VirtualRegister m_thisRegister;
1571     VirtualRegister m_scopeRegister;
1572     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;
1573 
1574     unsigned m_usesEval : 1;
1575     unsigned m_isStrictMode : 1;
1576     unsigned m_isConstructor : 1;
1577     unsigned m_hasCapturedVariables : 1;
1578     unsigned m_isBuiltinFunction : 1;
1579     unsigned m_superBinding : 1;
1580     unsigned m_scriptMode: 1;
1581     unsigned m_isArrowFunctionContext : 1;
1582     unsigned m_isClassContext : 1;
<a name="112" id="anc112"></a><span class="line-removed">1583     unsigned m_wasCompiledWithDebuggingOpcodes : 1;</span>
1584     unsigned m_constructorKind : 2;
1585     unsigned m_derivedContextType : 2;
1586     unsigned m_evalContextType : 2;
1587     unsigned m_hasTailCalls : 1;
1588     unsigned m_codeType : 2;
1589 
1590     CodeFeatures m_features;
1591     SourceParseMode m_parseMode;
<a name="113" id="anc113"></a>
1592 
1593     unsigned m_lineCount;
1594     unsigned m_endColumn;
1595 
1596     int m_numVars;
1597     int m_numCalleeLocals;
1598     int m_numParameters;
1599 
1600     CachedMetadataTable m_metadata;
1601 
<a name="114" id="anc114"></a><span class="line-modified">1602     CachedOptional&lt;CachedCodeBlockRareData&gt; m_rareData;</span>
1603 
1604     CachedString m_sourceURLDirective;
1605     CachedString m_sourceMappingURLDirective;
1606 
1607     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1608     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
1609     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;
1610     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1611     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1612     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1613     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1614 
1615     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1616     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1617     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1618 };
1619 
1620 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1621     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1622 
1623 public:
1624     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1625     {
1626         Base::encode(encoder, codeBlock);
1627         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1628         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1629     }
1630 
1631     UnlinkedProgramCodeBlock* decode(Decoder&amp; decoder) const
1632     {
1633         UnlinkedProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedProgramCodeBlock(decoder, *this);
1634         codeBlock-&gt;finishCreation(decoder.vm());
1635         Base::decode(decoder, *codeBlock);
1636         m_varDeclarations.decode(decoder, codeBlock-&gt;m_varDeclarations);
1637         m_lexicalDeclarations.decode(decoder, codeBlock-&gt;m_lexicalDeclarations);
1638         return codeBlock;
1639     }
1640 
1641 private:
1642     CachedVariableEnvironment m_varDeclarations;
1643     CachedVariableEnvironment m_lexicalDeclarations;
1644 };
1645 
1646 class CachedModuleCodeBlock : public CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt; {
1647     using Base = CachedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;;
1648 
1649 public:
1650     void encode(Encoder&amp; encoder, const UnlinkedModuleProgramCodeBlock&amp; codeBlock)
1651     {
1652         Base::encode(encoder, codeBlock);
1653         m_moduleEnvironmentSymbolTableConstantRegisterOffset = codeBlock.m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1654     }
1655 
1656     UnlinkedModuleProgramCodeBlock* decode(Decoder&amp; decoder) const
1657     {
1658         UnlinkedModuleProgramCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedModuleProgramCodeBlock&gt;(decoder.vm().heap)) UnlinkedModuleProgramCodeBlock(decoder, *this);
1659         codeBlock-&gt;finishCreation(decoder.vm());
1660         Base::decode(decoder, *codeBlock);
1661         codeBlock-&gt;m_moduleEnvironmentSymbolTableConstantRegisterOffset = m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1662         return codeBlock;
1663     }
1664 
1665 private:
1666     int m_moduleEnvironmentSymbolTableConstantRegisterOffset;
1667 };
1668 
1669 class CachedEvalCodeBlock : public CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt; {
1670     using Base = CachedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;;
1671 
1672 public:
1673     void encode(Encoder&amp; encoder, const UnlinkedEvalCodeBlock&amp; codeBlock)
1674     {
1675         Base::encode(encoder, codeBlock);
1676         m_variables.encode(encoder, codeBlock.m_variables);
1677         m_functionHoistingCandidates.encode(encoder, codeBlock.m_functionHoistingCandidates);
1678     }
1679 
1680     UnlinkedEvalCodeBlock* decode(Decoder&amp; decoder) const
1681     {
1682         UnlinkedEvalCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedEvalCodeBlock&gt;(decoder.vm().heap)) UnlinkedEvalCodeBlock(decoder, *this);
1683         codeBlock-&gt;finishCreation(decoder.vm());
1684         Base::decode(decoder, *codeBlock);
1685         m_variables.decode(decoder, codeBlock-&gt;m_variables);
1686         m_functionHoistingCandidates.decode(decoder, codeBlock-&gt;m_functionHoistingCandidates);
1687         return codeBlock;
1688     }
1689 
1690 private:
1691     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_variables;
1692     CachedVector&lt;CachedIdentifier, 0, UnsafeVectorOverflow&gt; m_functionHoistingCandidates;
1693 };
1694 
1695 class CachedFunctionCodeBlock : public CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt; {
1696     using Base = CachedCodeBlock&lt;UnlinkedFunctionCodeBlock&gt;;
1697 
1698 public:
1699     void encode(Encoder&amp; encoder, const UnlinkedFunctionCodeBlock&amp; codeBlock)
1700     {
1701         Base::encode(encoder, codeBlock);
1702     }
1703 
1704     UnlinkedFunctionCodeBlock* decode(Decoder&amp; decoder) const
1705     {
1706         UnlinkedFunctionCodeBlock* codeBlock = new (NotNull, allocateCell&lt;UnlinkedFunctionCodeBlock&gt;(decoder.vm().heap)) UnlinkedFunctionCodeBlock(decoder, *this);
1707         codeBlock-&gt;finishCreation(decoder.vm());
1708         Base::decode(decoder, *codeBlock);
1709         return codeBlock;
1710     }
1711 };
1712 
1713 ALWAYS_INLINE UnlinkedFunctionCodeBlock::UnlinkedFunctionCodeBlock(Decoder&amp; decoder, const CachedFunctionCodeBlock&amp; cachedCodeBlock)
1714     : Base(decoder, decoder.vm().unlinkedFunctionCodeBlockStructure.get(), cachedCodeBlock)
1715 {
1716 }
1717 
1718 template&lt;typename T&gt;
1719 struct CachedCodeBlockTypeImpl;
1720 
1721 enum CachedCodeBlockTag {
1722     CachedProgramCodeBlockTag,
1723     CachedModuleCodeBlockTag,
1724     CachedEvalCodeBlockTag,
1725 };
1726 
<a name="115" id="anc115"></a>















1727 template&lt;&gt;
1728 struct CachedCodeBlockTypeImpl&lt;UnlinkedProgramCodeBlock&gt; {
1729     using type = CachedProgramCodeBlock;
1730     static constexpr CachedCodeBlockTag tag = CachedProgramCodeBlockTag;
1731 };
1732 
1733 template&lt;&gt;
1734 struct CachedCodeBlockTypeImpl&lt;UnlinkedModuleProgramCodeBlock&gt; {
1735     using type = CachedModuleCodeBlock;
1736     static constexpr CachedCodeBlockTag tag = CachedModuleCodeBlockTag;
1737 };
1738 
1739 template&lt;&gt;
1740 struct CachedCodeBlockTypeImpl&lt;UnlinkedEvalCodeBlock&gt; {
1741     using type = CachedEvalCodeBlock;
1742     static constexpr CachedCodeBlockTag tag = CachedEvalCodeBlockTag;
1743 };
1744 
1745 template&lt;typename T&gt;
1746 using CachedCodeBlockType = typename CachedCodeBlockTypeImpl&lt;T&gt;::type;
1747 
1748 template&lt;typename CodeBlockType&gt;
1749 ALWAYS_INLINE UnlinkedCodeBlock::UnlinkedCodeBlock(Decoder&amp; decoder, Structure* structure, const CachedCodeBlock&lt;CodeBlockType&gt;&amp; cachedCodeBlock)
1750     : Base(decoder.vm(), structure)
1751     , m_thisRegister(cachedCodeBlock.thisRegister())
1752     , m_scopeRegister(cachedCodeBlock.scopeRegister())
1753 
1754     , m_usesEval(cachedCodeBlock.usesEval())
1755     , m_isStrictMode(cachedCodeBlock.isStrictMode())
1756     , m_isConstructor(cachedCodeBlock.isConstructor())
1757     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
1758     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
1759     , m_superBinding(cachedCodeBlock.superBinding())
1760     , m_scriptMode(cachedCodeBlock.scriptMode())
1761     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
1762     , m_isClassContext(cachedCodeBlock.isClassContext())
<a name="116" id="anc116"></a><span class="line-modified">1763     , m_wasCompiledWithDebuggingOpcodes(cachedCodeBlock.wasCompiledWithDebuggingOpcodes())</span>
1764     , m_constructorKind(cachedCodeBlock.constructorKind())
1765     , m_derivedContextType(cachedCodeBlock.derivedContextType())
1766     , m_evalContextType(cachedCodeBlock.evalContextType())
<a name="117" id="anc117"></a><span class="line-removed">1767     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())</span>
1768     , m_codeType(cachedCodeBlock.codeType())
1769 
<a name="118" id="anc118"></a>


1770     , m_features(cachedCodeBlock.features())
1771     , m_parseMode(cachedCodeBlock.parseMode())
<a name="119" id="anc119"></a>
1772 
1773     , m_lineCount(cachedCodeBlock.lineCount())
1774     , m_endColumn(cachedCodeBlock.endColumn())
1775     , m_numVars(cachedCodeBlock.numVars())
1776     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
1777     , m_numParameters(cachedCodeBlock.numParameters())
1778 
1779     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
1780     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
1781 
1782     , m_metadata(cachedCodeBlock.metadata(decoder))
1783     , m_instructions(cachedCodeBlock.instructions(decoder))
1784 
1785     , m_rareData(cachedCodeBlock.rareData(decoder))
1786 {
1787 }
1788 
1789 template&lt;typename CodeBlockType&gt;
1790 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
1791 {
1792     for (unsigned i = LinkTimeConstantCount; i--;)
1793         codeBlock.m_linkTimeConstants[i] = m_linkTimeConstants[i];
1794 
1795     m_propertyAccessInstructions.decode(decoder, codeBlock.m_propertyAccessInstructions);
1796     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
1797     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
1798     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
1799     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
1800     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
1801     m_identifiers.decode(decoder, codeBlock.m_identifiers);
1802     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
1803     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
1804 }
1805 
1806 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
1807     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
1808 {
1809 }
1810 
1811 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
1812     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
1813 {
1814 }
1815 
1816 ALWAYS_INLINE UnlinkedEvalCodeBlock::UnlinkedEvalCodeBlock(Decoder&amp; decoder, const CachedEvalCodeBlock&amp; cachedCodeBlock)
1817     : Base(decoder, decoder.vm().unlinkedEvalCodeBlockStructure.get(), cachedCodeBlock)
1818 {
1819 }
1820 
1821 ALWAYS_INLINE void CachedFunctionExecutable::encode(Encoder&amp; encoder, const UnlinkedFunctionExecutable&amp; executable)
1822 {
<a name="120" id="anc120"></a>


1823     m_firstLineOffset = executable.m_firstLineOffset;
1824     m_lineCount = executable.m_lineCount;
1825     m_unlinkedFunctionNameStart = executable.m_unlinkedFunctionNameStart;
1826     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
1827     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
1828     m_startOffset = executable.m_startOffset;
1829     m_sourceLength = executable.m_sourceLength;
1830     m_parametersStartOffset = executable.m_parametersStartOffset;
1831     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
1832     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
1833     m_parameterCount = executable.m_parameterCount;
1834 
<a name="121" id="anc121"></a><span class="line-removed">1835     m_features = executable.m_features;</span>
1836     m_sourceParseMode = executable.m_sourceParseMode;
1837 
1838     m_isInStrictContext = executable.m_isInStrictContext;
<a name="122" id="anc122"></a><span class="line-removed">1839     m_hasCapturedVariables = executable.m_hasCapturedVariables;</span>
1840     m_isBuiltinFunction = executable.m_isBuiltinFunction;
1841     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
1842     m_constructAbility = executable.m_constructAbility;
1843     m_constructorKind = executable.m_constructorKind;
1844     m_functionMode = executable.m_functionMode;
1845     m_scriptMode = executable.m_scriptMode;
1846     m_superBinding = executable.m_superBinding;
1847     m_derivedContextType = executable.m_derivedContextType;
1848 
<a name="123" id="anc123"></a><span class="line-modified">1849     m_rareData.encode(encoder, executable.m_rareData);</span>
1850 
1851     m_name.encode(encoder, executable.name());
1852     m_ecmaName.encode(encoder, executable.ecmaName());
<a name="124" id="anc124"></a><span class="line-removed">1853     m_inferredName.encode(encoder, executable.inferredName());</span>
<span class="line-removed">1854 </span>
<span class="line-removed">1855     m_parentScopeTDZVariables.encode(encoder, executable.parentScopeTDZVariables());</span>
1856 
1857     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
1858     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
<a name="125" id="anc125"></a>


1859 }
1860 
1861 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
1862 {
<a name="126" id="anc126"></a><span class="line-modified">1863     VariableEnvironment env;</span>
<span class="line-removed">1864     m_parentScopeTDZVariables.decode(decoder, env);</span>
<span class="line-removed">1865 </span>
<span class="line-removed">1866     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, env, *this);</span>
1867     executable-&gt;finishCreation(decoder.vm());
<a name="127" id="anc127"></a><span class="line-removed">1868 </span>
<span class="line-removed">1869     m_unlinkedCodeBlockForCall.decode(decoder, executable-&gt;m_unlinkedCodeBlockForCall, executable);</span>
<span class="line-removed">1870     m_unlinkedCodeBlockForConstruct.decode(decoder, executable-&gt;m_unlinkedCodeBlockForConstruct, executable);</span>
<span class="line-removed">1871 </span>
1872     return executable;
1873 }
1874 
<a name="128" id="anc128"></a><span class="line-modified">1875 ALWAYS_INLINE UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(Decoder&amp; decoder, VariableEnvironment&amp; parentScopeTDZVariables, const CachedFunctionExecutable&amp; cachedExecutable)</span>
1876     : Base(decoder.vm(), decoder.vm().unlinkedFunctionExecutableStructure.get())
1877     , m_firstLineOffset(cachedExecutable.firstLineOffset())
<a name="129" id="anc129"></a>
1878     , m_lineCount(cachedExecutable.lineCount())
<a name="130" id="anc130"></a>
1879     , m_unlinkedFunctionNameStart(cachedExecutable.unlinkedFunctionNameStart())
<a name="131" id="anc131"></a>
1880     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
<a name="132" id="anc132"></a>
1881     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
<a name="133" id="anc133"></a>
1882     , m_startOffset(cachedExecutable.startOffset())
<a name="134" id="anc134"></a>
1883     , m_sourceLength(cachedExecutable.sourceLength())
<a name="135" id="anc135"></a>
1884     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
<a name="136" id="anc136"></a>
1885     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
1886     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
1887     , m_parameterCount(cachedExecutable.parameterCount())
1888     , m_features(cachedExecutable.features())
1889     , m_sourceParseMode(cachedExecutable.sourceParseMode())
<a name="137" id="anc137"></a><span class="line-removed">1890     , m_isInStrictContext(cachedExecutable.isInStrictContext())</span>
<span class="line-removed">1891     , m_hasCapturedVariables(cachedExecutable.hasCapturedVariables())</span>
<span class="line-removed">1892     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())</span>
<span class="line-removed">1893     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())</span>
<span class="line-removed">1894     , m_constructAbility(cachedExecutable.constructAbility())</span>
1895     , m_constructorKind(cachedExecutable.constructorKind())
1896     , m_functionMode(cachedExecutable.functionMode())
<a name="138" id="anc138"></a><span class="line-removed">1897     , m_scriptMode(cachedExecutable.scriptMode())</span>
<span class="line-removed">1898     , m_superBinding(cachedExecutable.superBinding())</span>
1899     , m_derivedContextType(cachedExecutable.derivedContextType())
<a name="139" id="anc139"></a>


1900 
1901     , m_name(cachedExecutable.name(decoder))
1902     , m_ecmaName(cachedExecutable.ecmaName(decoder))
<a name="140" id="anc140"></a><span class="line-removed">1903     , m_inferredName(cachedExecutable.inferredName(decoder))</span>
<span class="line-removed">1904 </span>
<span class="line-removed">1905     , m_parentScopeTDZVariables(decoder.vm().m_compactVariableMap-&gt;get(parentScopeTDZVariables))</span>
1906 
1907     , m_rareData(cachedExecutable.rareData(decoder))
1908 {
<a name="141" id="anc141"></a>


























1909 }
1910 
1911 template&lt;typename CodeBlockType&gt;
1912 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::encode(Encoder&amp; encoder, const UnlinkedCodeBlock&amp; codeBlock)
1913 {
1914     m_thisRegister = codeBlock.m_thisRegister;
1915     m_scopeRegister = codeBlock.m_scopeRegister;
1916     m_usesEval = codeBlock.m_usesEval;
1917     m_isStrictMode = codeBlock.m_isStrictMode;
1918     m_isConstructor = codeBlock.m_isConstructor;
1919     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
1920     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
1921     m_superBinding = codeBlock.m_superBinding;
1922     m_scriptMode = codeBlock.m_scriptMode;
1923     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
1924     m_isClassContext = codeBlock.m_isClassContext;
<a name="142" id="anc142"></a><span class="line-modified">1925     m_wasCompiledWithDebuggingOpcodes = codeBlock.m_wasCompiledWithDebuggingOpcodes;</span>
1926     m_constructorKind = codeBlock.m_constructorKind;
1927     m_derivedContextType = codeBlock.m_derivedContextType;
1928     m_evalContextType = codeBlock.m_evalContextType;
<a name="143" id="anc143"></a><span class="line-removed">1929     m_hasTailCalls = codeBlock.m_hasTailCalls;</span>
1930     m_lineCount = codeBlock.m_lineCount;
1931     m_endColumn = codeBlock.m_endColumn;
1932     m_numVars = codeBlock.m_numVars;
1933     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
1934     m_numParameters = codeBlock.m_numParameters;
1935     m_features = codeBlock.m_features;
1936     m_parseMode = codeBlock.m_parseMode;
<a name="144" id="anc144"></a>
1937     m_codeType = codeBlock.m_codeType;
1938 
1939     for (unsigned i = LinkTimeConstantCount; i--;)
1940         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];
1941 
1942     m_metadata.encode(encoder, codeBlock.m_metadata.get());
<a name="145" id="anc145"></a><span class="line-modified">1943     m_rareData.encode(encoder, codeBlock.m_rareData);</span>
1944 
1945     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
1946     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());
1947 
1948     m_instructions.encode(encoder, codeBlock.m_instructions.get());
1949     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);
1950     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
1951     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
1952     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
1953     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
1954     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
1955 
1956     m_identifiers.encode(encoder, codeBlock.m_identifiers);
1957     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
1958     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
1959 }
1960 
1961 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
1962 public:
1963     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
1964     {
1965         m_sourceCode.encode(encoder, key.m_sourceCode);
1966         m_name.encode(encoder, key.m_name);
1967         m_flags = key.m_flags.m_flags;
1968         m_hash = key.hash();
1969         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
1970     }
1971 
1972     void decode(Decoder&amp; decoder, SourceCodeKey&amp; key) const
1973     {
1974         m_sourceCode.decode(decoder, key.m_sourceCode);
1975         m_name.decode(decoder, key.m_name);
1976         key.m_flags.m_flags = m_flags;
1977         key.m_hash = m_hash;
1978         key.m_functionConstructorParametersEndPosition = m_functionConstructorParametersEndPosition;
1979     }
1980 
1981 private:
1982     CachedUnlinkedSourceCode m_sourceCode;
1983     CachedString m_name;
1984     unsigned m_flags;
1985     unsigned m_hash;
1986     int m_functionConstructorParametersEndPosition;
1987 };
1988 
1989 class GenericCacheEntry {
1990 public:
1991     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
<a name="146" id="anc146"></a>
1992 
1993 protected:
1994     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
1995         : m_tag(tag)
1996     {
1997         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
1998     }
1999 
2000     CachedCodeBlockTag tag() const { return m_tag; }
2001 
<a name="147" id="anc147"></a>








2002 private:
2003     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };
2004     CachedString m_bootSessionUUID;
2005     CachedCodeBlockTag m_tag;
2006 };
2007 
2008 template&lt;typename UnlinkedCodeBlockType&gt;
2009 class CacheEntry : public GenericCacheEntry {
2010 public:
2011     CacheEntry(Encoder&amp; encoder)
2012         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2013     {
2014     }
2015 
2016     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2017     {
2018         m_key.encode(encoder, pair.first);
2019         m_codeBlock.encode(encoder, pair.second);
2020     }
2021 
2022 private:
2023     friend GenericCacheEntry;
2024 
<a name="148" id="anc148"></a>






2025     bool decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlockType*&gt;&amp; result) const
2026     {
2027         ASSERT(tag() == CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag);
2028         SourceCodeKey decodedKey;
2029         m_key.decode(decoder, decodedKey);
2030         result = { WTFMove(decodedKey), m_codeBlock.decode(decoder) };
2031         return true;
2032     }
2033 
2034     CachedSourceCodeKey m_key;
2035     CachedPtr&lt;CachedCodeBlockType&lt;UnlinkedCodeBlockType&gt;&gt; m_codeBlock;
2036 };
2037 
2038 bool GenericCacheEntry::decode(Decoder&amp; decoder, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp; result) const
2039 {
<a name="149" id="anc149"></a><span class="line-modified">2040     if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
<span class="line-removed">2041         return false;</span>
<span class="line-removed">2042     if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())</span>
2043         return false;
2044 
2045     switch (m_tag) {
2046     case CachedProgramCodeBlockTag:
<a name="150" id="anc150"></a><span class="line-modified">2047         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2048     case CachedModuleCodeBlockTag:
<a name="151" id="anc151"></a><span class="line-modified">2049         return reinterpret_cast&lt;const CacheEntry&lt;UnlinkedModuleProgramCodeBlock&gt;*&gt;(this)-&gt;decode(decoder, reinterpret_cast&lt;std::pair&lt;SourceCodeKey, UnlinkedModuleProgramCodeBlock*&gt;&amp;&gt;(result));</span>
2050     case CachedEvalCodeBlockTag:
2051         // We do not cache eval code blocks
2052         RELEASE_ASSERT_NOT_REACHED();
2053     }
2054     RELEASE_ASSERT_NOT_REACHED();
2055 #if COMPILER(MSVC)
2056     // Without this, MSVC will complain that this path does not return a value.
2057     return false;
2058 #endif
2059 }
2060 
<a name="152" id="anc152"></a>

















2061 template&lt;typename UnlinkedCodeBlockType&gt;
2062 void encodeCodeBlock(Encoder&amp; encoder, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)
2063 {
2064     auto* entry = encoder.template malloc&lt;CacheEntry&lt;UnlinkedCodeBlockType&gt;&gt;(encoder);
<a name="153" id="anc153"></a><span class="line-modified">2065     entry-&gt;encode(encoder,  { key, jsCast&lt;const UnlinkedCodeBlockType*&gt;(codeBlock) });</span>
2066 }
2067 
<a name="154" id="anc154"></a><span class="line-modified">2068 std::pair&lt;MallocPtr&lt;uint8_t&gt;, size_t&gt; encodeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const UnlinkedCodeBlock* codeBlock)</span>
2069 {
2070     const ClassInfo* classInfo = codeBlock-&gt;classInfo(vm);
2071 
<a name="155" id="anc155"></a><span class="line-modified">2072     Encoder encoder(vm);</span>
2073     if (classInfo == UnlinkedProgramCodeBlock::info())
2074         encodeCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(encoder, key, codeBlock);
2075     else if (classInfo == UnlinkedModuleProgramCodeBlock::info())
2076         encodeCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(encoder, key, codeBlock);
2077     else
2078         ASSERT(classInfo == UnlinkedEvalCodeBlock::info());
2079 
<a name="156" id="anc156"></a><span class="line-modified">2080     return encoder.release();</span>













2081 }
2082 
<a name="157" id="anc157"></a><span class="line-modified">2083 UnlinkedCodeBlock* decodeCodeBlockImpl(VM&amp; vm, const SourceCodeKey&amp; key, const void* buffer, size_t size)</span>
2084 {
<a name="158" id="anc158"></a><span class="line-modified">2085     const auto* cachedEntry = reinterpret_cast&lt;const GenericCacheEntry*&gt;(buffer);</span>
<span class="line-modified">2086     Decoder decoder(vm, buffer, size);</span>
2087     std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt; entry;
2088     {
2089         DeferGC deferGC(vm.heap);
<a name="159" id="anc159"></a><span class="line-modified">2090         if (!cachedEntry-&gt;decode(decoder, entry))</span>
2091             return nullptr;
2092     }
2093 
2094     if (entry.first != key)
2095         return nullptr;
2096     return entry.second;
2097 }
2098 
<a name="160" id="anc160"></a>

















2099 } // namespace JSC
<a name="161" id="anc161"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="161" type="hidden" />
</body>
</html>