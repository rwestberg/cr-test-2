<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPHeaderMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 
  36 #include &quot;HTTPHeaderNames.h&quot;
  37 #include &lt;wtf/DateMath.h&gt;
  38 #include &lt;wtf/Language.h&gt;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  40 #include &lt;wtf/text/CString.h&gt;</span>
  41 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-removed">  42 #include &lt;wtf/text/WTFString.h&gt;</span>
  43 #include &lt;wtf/unicode/CharacterNames.h&gt;
  44 
  45 
  46 namespace WebCore {
  47 
  48 // true if there is more to parse, after incrementing pos past whitespace.
  49 // Note: Might return pos == str.length()
  50 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  51 {
  52     unsigned len = str.length();
  53 
  54     while (pos &lt; len &amp;&amp; (str[pos] == &#39;\t&#39; || str[pos] == &#39; &#39;))
  55         ++pos;
  56 
  57     return pos &lt; len;
  58 }
  59 
  60 // Returns true if the function can match the whole token (case insensitive)
  61 // incrementing pos on match, otherwise leaving pos unchanged.
  62 // Note: Might return pos == str.length()
</pre>
<hr />
<pre>
  81 // True if the expected equals sign is seen and there is more to follow.
  82 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  83 {
  84     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  85 }
  86 
  87 // True if a value present, incrementing pos to next space or semicolon, if any.
  88 // Note: might return pos == str.length().
  89 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  90 {
  91     unsigned start = pos;
  92     unsigned len = str.length();
  93     while (pos &lt; len) {
  94         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
  95             break;
  96         ++pos;
  97     }
  98     return pos != start;
  99 }
 100 












 101 // See RFC 7230, Section 3.1.2.
 102 bool isValidReasonPhrase(const String&amp; value)
 103 {
 104     for (unsigned i = 0; i &lt; value.length(); ++i) {
 105         UChar c = value[i];
<span class="line-modified"> 106         if (c == 0x7F || c &gt; 0xFF || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))</span>
 107             return false;
 108     }
 109     return true;
 110 }
 111 
 112 // See https://fetch.spec.whatwg.org/#concept-header
 113 bool isValidHTTPHeaderValue(const String&amp; value)
 114 {
 115     UChar c = value[0];
 116     if (c == &#39; &#39; || c == &#39;\t&#39;)
 117         return false;
 118     c = value[value.length() - 1];
 119     if (c == &#39; &#39; || c == &#39;\t&#39;)
 120         return false;
 121     for (unsigned i = 0; i &lt; value.length(); ++i) {
 122         c = value[i];
<span class="line-modified"> 123         ASSERT(c &lt;= 0xFF);</span>
 124         if (c == 0x00 || c == 0x0A || c == 0x0D)
 125             return false;
 126     }
 127     return true;
 128 }
 129 
 130 // See RFC 7230, Section 3.2.6.
 131 static bool isDelimiterCharacter(const UChar c)
 132 {
 133     // DQUOTE and &quot;(),/:;&lt;=&gt;?@[\]{}&quot;
 134     return (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;:&#39; || c == &#39;;&#39;
 135         || c == &#39;&lt;&#39; || c == &#39;=&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39; || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39;
 136         || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39;);
 137 }
 138 





























 139 // See RFC 7231, Section 5.3.2.
 140 bool isValidAcceptHeaderValue(const String&amp; value)
 141 {
 142     for (unsigned i = 0; i &lt; value.length(); ++i) {
 143         UChar c = value[i];
 144 
 145         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 146         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 147             continue;
 148 
<span class="line-modified"> 149         ASSERT(c &lt;= 0xFF);</span>
 150         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 151             return false;
 152 
 153         if (isDelimiterCharacter(c))
 154             return false;
 155     }
 156 
 157     return true;
 158 }
 159 
 160 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 161 bool isValidLanguageHeaderValue(const String&amp; value)
 162 {
 163     for (unsigned i = 0; i &lt; value.length(); ++i) {
 164         UChar c = value[i];
 165         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 166             continue;
 167         return false;
 168     }
 169 
 170     // FIXME: Validate further by splitting into language tags and optional quality
 171     // values (q=) and then check each language tag.
 172     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 173     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 174     return true;
 175 }
 176 







 177 // See RFC 7230, Section 3.2.6.
 178 bool isValidHTTPToken(const String&amp; value)
 179 {
 180     if (value.isEmpty())
 181         return false;
 182     auto valueStringView = StringView(value);
 183     for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified"> 184         if (c &lt;= 0x20 || c &gt;= 0x7F</span>
<span class="line-modified"> 185             || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;&lt;&#39; || c == &#39;&gt;&#39; || c == &#39;@&#39;</span>
<span class="line-modified"> 186             || c == &#39;,&#39; || c == &#39;;&#39; || c == &#39;:&#39; || c == &#39;\\&#39; || c == &#39;&quot;&#39;</span>
<span class="line-modified"> 187             || c == &#39;/&#39; || c == &#39;[&#39; || c == &#39;]&#39; || c == &#39;?&#39; || c == &#39;=&#39;</span>
<span class="line-modified"> 188             || c == &#39;{&#39; || c == &#39;}&#39;)</span>















































 189         return false;
















 190     }






















 191     return true;
 192 }
 193 























 194 static const size_t maxInputSampleSize = 128;
 195 static String trimInputSample(const char* p, size_t length)
 196 {
 197     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 198     if (length &gt; maxInputSampleSize)
 199         s.append(horizontalEllipsis);
 200     return s;
 201 }
 202 
 203 bool parseHTTPRefresh(const String&amp; refresh, double&amp; delay, String&amp; url)
 204 {
 205     unsigned len = refresh.length();
 206     unsigned pos = 0;
 207 
 208     if (!skipWhiteSpace(refresh, pos))
 209         return false;
 210 
 211     while (pos != len &amp;&amp; refresh[pos] != &#39;,&#39; &amp;&amp; refresh[pos] != &#39;;&#39;)
 212         ++pos;
 213 
</pre>
<hr />
<pre>
 469             reportURL = header.substring(startPos, pos - startPos);
 470             failurePosition = startPos; // If later semantic check deems unacceptable.
 471         } else {
 472             failureReason = failureReasonInvalidDirective;
 473             failurePosition = pos;
 474             return XSSProtectionDisposition::Invalid;
 475         }
 476     }
 477 }
 478 
 479 ContentTypeOptionsDisposition parseContentTypeOptionsHeader(StringView header)
 480 {
 481     StringView leftToken = header.left(header.find(&#39;,&#39;));
 482     if (equalLettersIgnoringASCIICase(stripLeadingAndTrailingHTTPSpaces(leftToken), &quot;nosniff&quot;))
 483         return ContentTypeOptionsNosniff;
 484     return ContentTypeOptionsNone;
 485 }
 486 
 487 // For example: &quot;HTTP/1.1 200 OK&quot; =&gt; &quot;OK&quot;.
 488 // Note that HTTP/2 does not include a reason phrase, so we return the empty atom.
<span class="line-modified"> 489 AtomicString extractReasonPhraseFromHTTPStatusLine(const String&amp; statusLine)</span>
 490 {
 491     StringView view = statusLine;
 492     size_t spacePos = view.find(&#39; &#39;);
 493 
 494     // Remove status code from the status line.
 495     spacePos = view.find(&#39; &#39;, spacePos + 1);
 496     if (spacePos == notFound)
 497         return emptyAtom();
 498 
<span class="line-modified"> 499     return view.substring(spacePos + 1).toAtomicString();</span>
 500 }
 501 
 502 XFrameOptionsDisposition parseXFrameOptionsHeader(const String&amp; header)
 503 {
 504     XFrameOptionsDisposition result = XFrameOptionsNone;
 505 
 506     if (header.isEmpty())
 507         return result;
 508 
 509     for (auto&amp; currentHeader : header.split(&#39;,&#39;)) {
 510         currentHeader = currentHeader.stripWhiteSpace();
 511         XFrameOptionsDisposition currentValue = XFrameOptionsNone;
 512         if (equalLettersIgnoringASCIICase(currentHeader, &quot;deny&quot;))
 513             currentValue = XFrameOptionsDeny;
 514         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;sameorigin&quot;))
 515             currentValue = XFrameOptionsSameOrigin;
 516         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;allowall&quot;))
 517             currentValue = XFrameOptionsAllowAll;
 518         else
 519             currentValue = XFrameOptionsInvalid;
</pre>
<hr />
<pre>
 712                 if (name.size() &lt; 1)
 713                     failureReason = &quot;Unexpected start character in header name&quot;;
 714                 else
 715                     failureReason = makeString(&quot;Unexpected character in header name at &quot;, trimInputSample(name.data(), name.size()));
 716                 return 0;
 717             }
 718             name.append(*p);
 719             if (!foundFirstNameChar) {
 720                 namePtr = p;
 721                 foundFirstNameChar = true;
 722             }
 723             continue;
 724         }
 725         if (*p == &#39;:&#39;) {
 726             ++p;
 727             break;
 728         }
 729     }
 730 
 731     nameSize = name.size();
<span class="line-modified"> 732     nameStr = StringView(reinterpret_cast&lt;const LChar*&gt;(namePtr), nameSize);</span>
 733 
 734     for (; p &lt; end &amp;&amp; *p == 0x20; p++) { }
 735 
 736     for (; p &lt; end; p++) {
 737         switch (*p) {
 738         case &#39;\r&#39;:
 739             break;
 740         case &#39;\n&#39;:
 741             if (strict) {
 742                 failureReason = makeString(&quot;Unexpected LF in header value at &quot;, trimInputSample(value.data(), value.size()));
 743                 return 0;
 744             }
 745             break;
 746         default:
 747             value.append(*p);
 748         }
 749         if (*p == &#39;\r&#39; || (!strict &amp;&amp; *p == &#39;\n&#39;)) {
 750             ++p;
 751             break;
 752         }
</pre>
<hr />
<pre>
 843     default:
 844         break;
 845     }
 846     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
 847 }
 848 
 849 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
 850 {
 851 #ifndef ASSERT_DISABLED
 852     HTTPHeaderName headerName;
 853     ASSERT(!findHTTPHeaderName(name, headerName));
 854 #endif
 855     return accessControlExposeHeaderSet.contains(name);
 856 }
 857 
 858 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
 859 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
 860 {
 861     switch (name) {
 862     case HTTPHeaderName::Accept:
<span class="line-modified"> 863         return isValidAcceptHeaderValue(value);</span>


 864     case HTTPHeaderName::AcceptLanguage:
 865     case HTTPHeaderName::ContentLanguage:
<span class="line-modified"> 866         return isValidLanguageHeaderValue(value);</span>


 867     case HTTPHeaderName::ContentType: {
 868         // Preflight is required for MIME types that can not be sent via form submission.
 869         String mimeType = extractMIMETypeFromMediaType(value);
<span class="line-modified"> 870         return equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;);</span>


 871     }
 872     default:
 873         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
 874         return false;
 875     }

 876 }
 877 
 878 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
 879 String normalizeHTTPMethod(const String&amp; method)
 880 {
 881     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
 882     for (auto value : methods) {
 883         if (equalIgnoringASCIICase(method, value.characters())) {
 884             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
 885             if (method == value)
 886                 break;
 887             return value;
 888         }
 889     }
 890     return method;
 891 }
 892 
 893 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
 894 {
 895     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
</pre>
</td>
<td>
<hr />
<pre>
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 
  36 #include &quot;HTTPHeaderNames.h&quot;
  37 #include &lt;wtf/DateMath.h&gt;
  38 #include &lt;wtf/Language.h&gt;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">  40 #include &lt;wtf/Optional.h&gt;</span>
  41 #include &lt;wtf/text/StringBuilder.h&gt;

  42 #include &lt;wtf/unicode/CharacterNames.h&gt;
  43 
  44 
  45 namespace WebCore {
  46 
  47 // true if there is more to parse, after incrementing pos past whitespace.
  48 // Note: Might return pos == str.length()
  49 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  50 {
  51     unsigned len = str.length();
  52 
  53     while (pos &lt; len &amp;&amp; (str[pos] == &#39;\t&#39; || str[pos] == &#39; &#39;))
  54         ++pos;
  55 
  56     return pos &lt; len;
  57 }
  58 
  59 // Returns true if the function can match the whole token (case insensitive)
  60 // incrementing pos on match, otherwise leaving pos unchanged.
  61 // Note: Might return pos == str.length()
</pre>
<hr />
<pre>
  80 // True if the expected equals sign is seen and there is more to follow.
  81 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  82 {
  83     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  84 }
  85 
  86 // True if a value present, incrementing pos to next space or semicolon, if any.
  87 // Note: might return pos == str.length().
  88 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  89 {
  90     unsigned start = pos;
  91     unsigned len = str.length();
  92     while (pos &lt; len) {
  93         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
  94             break;
  95         ++pos;
  96     }
  97     return pos != start;
  98 }
  99 
<span class="line-added"> 100 // True if characters which satisfy the predicate are present, incrementing</span>
<span class="line-added"> 101 // &quot;pos&quot; to the next character which does not satisfy the predicate.</span>
<span class="line-added"> 102 // Note: might return pos == str.length().</span>
<span class="line-added"> 103 static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)</span>
<span class="line-added"> 104 {</span>
<span class="line-added"> 105     const unsigned start = pos;</span>
<span class="line-added"> 106     const unsigned len = str.length();</span>
<span class="line-added"> 107     while (pos &lt; len &amp;&amp; predicate(str[pos]))</span>
<span class="line-added"> 108         ++pos;</span>
<span class="line-added"> 109     return pos != start;</span>
<span class="line-added"> 110 }</span>
<span class="line-added"> 111 </span>
 112 // See RFC 7230, Section 3.1.2.
 113 bool isValidReasonPhrase(const String&amp; value)
 114 {
 115     for (unsigned i = 0; i &lt; value.length(); ++i) {
 116         UChar c = value[i];
<span class="line-modified"> 117         if (c == 0x7F || !isLatin1(c) || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))</span>
 118             return false;
 119     }
 120     return true;
 121 }
 122 
 123 // See https://fetch.spec.whatwg.org/#concept-header
 124 bool isValidHTTPHeaderValue(const String&amp; value)
 125 {
 126     UChar c = value[0];
 127     if (c == &#39; &#39; || c == &#39;\t&#39;)
 128         return false;
 129     c = value[value.length() - 1];
 130     if (c == &#39; &#39; || c == &#39;\t&#39;)
 131         return false;
 132     for (unsigned i = 0; i &lt; value.length(); ++i) {
 133         c = value[i];
<span class="line-modified"> 134         ASSERT(isLatin1(c));</span>
 135         if (c == 0x00 || c == 0x0A || c == 0x0D)
 136             return false;
 137     }
 138     return true;
 139 }
 140 
 141 // See RFC 7230, Section 3.2.6.
 142 static bool isDelimiterCharacter(const UChar c)
 143 {
 144     // DQUOTE and &quot;(),/:;&lt;=&gt;?@[\]{}&quot;
 145     return (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;:&#39; || c == &#39;;&#39;
 146         || c == &#39;&lt;&#39; || c == &#39;=&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39; || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39;
 147         || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39;);
 148 }
 149 
<span class="line-added"> 150 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 151 static inline bool isVisibleCharacter(const UChar c)</span>
<span class="line-added"> 152 {</span>
<span class="line-added"> 153     // VCHAR = %x21-7E</span>
<span class="line-added"> 154     return (c &gt;= 0x21 &amp;&amp; c &lt;= 0x7E);</span>
<span class="line-added"> 155 }</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 158 static inline bool isOctectInFieldContentCharacter(const UChar c)</span>
<span class="line-added"> 159 {</span>
<span class="line-added"> 160     // obs-text = %x80-FF</span>
<span class="line-added"> 161     return (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF);</span>
<span class="line-added"> 162 }</span>
<span class="line-added"> 163 </span>
<span class="line-added"> 164 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 165 static bool isCommentTextCharacter(const UChar c)</span>
<span class="line-added"> 166 {</span>
<span class="line-added"> 167     // ctext = HTAB / SP</span>
<span class="line-added"> 168     //       / %x21-27 ; &#39;!&#39;-&#39;&#39;&#39;</span>
<span class="line-added"> 169     //       / %x2A-5B ; &#39;*&#39;-&#39;[&#39;</span>
<span class="line-added"> 170     //       / %x5D-7E ; &#39;]&#39;-&#39;~&#39;</span>
<span class="line-added"> 171     //       / obs-text</span>
<span class="line-added"> 172     return (c == &#39;\t&#39; || c == &#39; &#39;</span>
<span class="line-added"> 173         || (c &gt;= 0x21 &amp;&amp; c &lt;= 0x27)</span>
<span class="line-added"> 174         || (c &gt;= 0x2A &amp;&amp; c &lt;= 0x5B)</span>
<span class="line-added"> 175         || (c &gt;= 0x5D &amp;&amp; c &lt;= 0x7E)</span>
<span class="line-added"> 176         || isOctectInFieldContentCharacter(c));</span>
<span class="line-added"> 177 }</span>
<span class="line-added"> 178 </span>
 179 // See RFC 7231, Section 5.3.2.
 180 bool isValidAcceptHeaderValue(const String&amp; value)
 181 {
 182     for (unsigned i = 0; i &lt; value.length(); ++i) {
 183         UChar c = value[i];
 184 
 185         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 186         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 187             continue;
 188 
<span class="line-modified"> 189         ASSERT(isLatin1(c));</span>
 190         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 191             return false;
 192 
 193         if (isDelimiterCharacter(c))
 194             return false;
 195     }
 196 
 197     return true;
 198 }
 199 
 200 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 201 bool isValidLanguageHeaderValue(const String&amp; value)
 202 {
 203     for (unsigned i = 0; i &lt; value.length(); ++i) {
 204         UChar c = value[i];
 205         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 206             continue;
 207         return false;
 208     }
 209 
 210     // FIXME: Validate further by splitting into language tags and optional quality
 211     // values (q=) and then check each language tag.
 212     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 213     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 214     return true;
 215 }
 216 
<span class="line-added"> 217 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 218 static inline bool isHTTPTokenCharacter(const UChar c)</span>
<span class="line-added"> 219 {</span>
<span class="line-added"> 220     // Any VCHAR, except delimiters</span>
<span class="line-added"> 221     return c &gt; 0x20 &amp;&amp; c &lt; 0x7F &amp;&amp; !isDelimiterCharacter(c);</span>
<span class="line-added"> 222 }</span>
<span class="line-added"> 223 </span>
 224 // See RFC 7230, Section 3.2.6.
 225 bool isValidHTTPToken(const String&amp; value)
 226 {
 227     if (value.isEmpty())
 228         return false;
 229     auto valueStringView = StringView(value);
 230     for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified"> 231         if (!isHTTPTokenCharacter(c))</span>
<span class="line-modified"> 232             return false;</span>
<span class="line-modified"> 233     }</span>
<span class="line-modified"> 234     return true;</span>
<span class="line-modified"> 235 }</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237 // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.</span>
<span class="line-added"> 238 // Note: Might return pos == str.length()</span>
<span class="line-added"> 239 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)</span>
<span class="line-added"> 240 {</span>
<span class="line-added"> 241     if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {</span>
<span class="line-added"> 242         ++pos;</span>
<span class="line-added"> 243         return true;</span>
<span class="line-added"> 244     }</span>
<span class="line-added"> 245     return false;</span>
<span class="line-added"> 246 }</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248 // True if the &quot;expected&quot; character is at the given position, incrementing &quot;pos&quot; by one.</span>
<span class="line-added"> 249 // Note: Might return pos == str.length()</span>
<span class="line-added"> 250 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, const UChar expected)</span>
<span class="line-added"> 251 {</span>
<span class="line-added"> 252     return skipCharacter(value, pos, [expected](const UChar c) {</span>
<span class="line-added"> 253         return c == expected;</span>
<span class="line-added"> 254     });</span>
<span class="line-added"> 255 }</span>
<span class="line-added"> 256 </span>
<span class="line-added"> 257 // True if a quoted pair is present, incrementing &quot;pos&quot; to the position after the quoted pair.</span>
<span class="line-added"> 258 // Note: Might return pos == str.length()</span>
<span class="line-added"> 259 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 260 static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;</span>
<span class="line-added"> 261 static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)</span>
<span class="line-added"> 262 {</span>
<span class="line-added"> 263     // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )</span>
<span class="line-added"> 264     if (!skipCharacter(value, pos, QuotedPairStartCharacter))</span>
<span class="line-added"> 265         return false;</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267     return skipCharacter(value, pos, &#39;\t&#39;)</span>
<span class="line-added"> 268         || skipCharacter(value, pos, &#39; &#39;)</span>
<span class="line-added"> 269         || skipCharacter(value, pos, isVisibleCharacter)</span>
<span class="line-added"> 270         || skipCharacter(value, pos, isOctectInFieldContentCharacter);</span>
<span class="line-added"> 271 }</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273 // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.</span>
<span class="line-added"> 274 // Note: Might return pos == str.length()</span>
<span class="line-added"> 275 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 276 static constexpr auto CommentStartCharacter = &#39;(&#39;;</span>
<span class="line-added"> 277 static constexpr auto CommentEndCharacter = &#39;)&#39;;</span>
<span class="line-added"> 278 static bool skipComment(const String&amp; value, unsigned&amp; pos)</span>
<span class="line-added"> 279 {</span>
<span class="line-added"> 280     // comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;</span>
<span class="line-added"> 281     // ctext   = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text</span>
<span class="line-added"> 282     if (!skipCharacter(value, pos, CommentStartCharacter))</span>
 283         return false;
<span class="line-added"> 284 </span>
<span class="line-added"> 285     const unsigned end = value.length();</span>
<span class="line-added"> 286     while (pos &lt; end &amp;&amp; value[pos] != CommentEndCharacter) {</span>
<span class="line-added"> 287         switch (value[pos]) {</span>
<span class="line-added"> 288         case CommentStartCharacter:</span>
<span class="line-added"> 289             if (!skipComment(value, pos))</span>
<span class="line-added"> 290                 return false;</span>
<span class="line-added"> 291             break;</span>
<span class="line-added"> 292         case QuotedPairStartCharacter:</span>
<span class="line-added"> 293             if (!skipQuotedPair(value, pos))</span>
<span class="line-added"> 294                 return false;</span>
<span class="line-added"> 295             break;</span>
<span class="line-added"> 296         default:</span>
<span class="line-added"> 297             if (!skipWhile(value, pos, isCommentTextCharacter))</span>
<span class="line-added"> 298                 return false;</span>
<span class="line-added"> 299         }</span>
 300     }
<span class="line-added"> 301     return skipCharacter(value, pos, CommentEndCharacter);</span>
<span class="line-added"> 302 }</span>
<span class="line-added"> 303 </span>
<span class="line-added"> 304 // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.</span>
<span class="line-added"> 305 // Note: Might return pos == str.length()</span>
<span class="line-added"> 306 // See RFC 7230, Section 3.2.6.</span>
<span class="line-added"> 307 static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)</span>
<span class="line-added"> 308 {</span>
<span class="line-added"> 309     return skipWhile(value, pos, isHTTPTokenCharacter);</span>
<span class="line-added"> 310 }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312 // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.</span>
<span class="line-added"> 313 // Note: Might return pos == str.length()</span>
<span class="line-added"> 314 // See RFC 7231, Section 5.5.3.</span>
<span class="line-added"> 315 static bool skipUserAgentProduct(const String&amp; value, unsigned&amp; pos)</span>
<span class="line-added"> 316 {</span>
<span class="line-added"> 317     // product         = token [&quot;/&quot; product-version]</span>
<span class="line-added"> 318     // product-version = token</span>
<span class="line-added"> 319     if (!skipHTTPToken(value, pos))</span>
<span class="line-added"> 320         return false;</span>
<span class="line-added"> 321     if (skipCharacter(value, pos, &#39;/&#39;))</span>
<span class="line-added"> 322         return skipHTTPToken(value, pos);</span>
 323     return true;
 324 }
 325 
<span class="line-added"> 326 // See RFC 7231, Section 5.5.3</span>
<span class="line-added"> 327 bool isValidUserAgentHeaderValue(const String&amp; value)</span>
<span class="line-added"> 328 {</span>
<span class="line-added"> 329     // User-Agent = product *( RWS ( product / comment ) )</span>
<span class="line-added"> 330     unsigned pos = 0;</span>
<span class="line-added"> 331     if (!skipUserAgentProduct(value, pos))</span>
<span class="line-added"> 332         return false;</span>
<span class="line-added"> 333 </span>
<span class="line-added"> 334     while (pos &lt; value.length()) {</span>
<span class="line-added"> 335         if (!skipWhiteSpace(value, pos))</span>
<span class="line-added"> 336             return false;</span>
<span class="line-added"> 337         if (value[pos] == CommentStartCharacter) {</span>
<span class="line-added"> 338             if (!skipComment(value, pos))</span>
<span class="line-added"> 339                 return false;</span>
<span class="line-added"> 340         } else {</span>
<span class="line-added"> 341             if (!skipUserAgentProduct(value, pos))</span>
<span class="line-added"> 342                 return false;</span>
<span class="line-added"> 343         }</span>
<span class="line-added"> 344     }</span>
<span class="line-added"> 345 </span>
<span class="line-added"> 346     return pos == value.length();</span>
<span class="line-added"> 347 }</span>
<span class="line-added"> 348 </span>
 349 static const size_t maxInputSampleSize = 128;
 350 static String trimInputSample(const char* p, size_t length)
 351 {
 352     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 353     if (length &gt; maxInputSampleSize)
 354         s.append(horizontalEllipsis);
 355     return s;
 356 }
 357 
 358 bool parseHTTPRefresh(const String&amp; refresh, double&amp; delay, String&amp; url)
 359 {
 360     unsigned len = refresh.length();
 361     unsigned pos = 0;
 362 
 363     if (!skipWhiteSpace(refresh, pos))
 364         return false;
 365 
 366     while (pos != len &amp;&amp; refresh[pos] != &#39;,&#39; &amp;&amp; refresh[pos] != &#39;;&#39;)
 367         ++pos;
 368 
</pre>
<hr />
<pre>
 624             reportURL = header.substring(startPos, pos - startPos);
 625             failurePosition = startPos; // If later semantic check deems unacceptable.
 626         } else {
 627             failureReason = failureReasonInvalidDirective;
 628             failurePosition = pos;
 629             return XSSProtectionDisposition::Invalid;
 630         }
 631     }
 632 }
 633 
 634 ContentTypeOptionsDisposition parseContentTypeOptionsHeader(StringView header)
 635 {
 636     StringView leftToken = header.left(header.find(&#39;,&#39;));
 637     if (equalLettersIgnoringASCIICase(stripLeadingAndTrailingHTTPSpaces(leftToken), &quot;nosniff&quot;))
 638         return ContentTypeOptionsNosniff;
 639     return ContentTypeOptionsNone;
 640 }
 641 
 642 // For example: &quot;HTTP/1.1 200 OK&quot; =&gt; &quot;OK&quot;.
 643 // Note that HTTP/2 does not include a reason phrase, so we return the empty atom.
<span class="line-modified"> 644 AtomString extractReasonPhraseFromHTTPStatusLine(const String&amp; statusLine)</span>
 645 {
 646     StringView view = statusLine;
 647     size_t spacePos = view.find(&#39; &#39;);
 648 
 649     // Remove status code from the status line.
 650     spacePos = view.find(&#39; &#39;, spacePos + 1);
 651     if (spacePos == notFound)
 652         return emptyAtom();
 653 
<span class="line-modified"> 654     return view.substring(spacePos + 1).toAtomString();</span>
 655 }
 656 
 657 XFrameOptionsDisposition parseXFrameOptionsHeader(const String&amp; header)
 658 {
 659     XFrameOptionsDisposition result = XFrameOptionsNone;
 660 
 661     if (header.isEmpty())
 662         return result;
 663 
 664     for (auto&amp; currentHeader : header.split(&#39;,&#39;)) {
 665         currentHeader = currentHeader.stripWhiteSpace();
 666         XFrameOptionsDisposition currentValue = XFrameOptionsNone;
 667         if (equalLettersIgnoringASCIICase(currentHeader, &quot;deny&quot;))
 668             currentValue = XFrameOptionsDeny;
 669         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;sameorigin&quot;))
 670             currentValue = XFrameOptionsSameOrigin;
 671         else if (equalLettersIgnoringASCIICase(currentHeader, &quot;allowall&quot;))
 672             currentValue = XFrameOptionsAllowAll;
 673         else
 674             currentValue = XFrameOptionsInvalid;
</pre>
<hr />
<pre>
 867                 if (name.size() &lt; 1)
 868                     failureReason = &quot;Unexpected start character in header name&quot;;
 869                 else
 870                     failureReason = makeString(&quot;Unexpected character in header name at &quot;, trimInputSample(name.data(), name.size()));
 871                 return 0;
 872             }
 873             name.append(*p);
 874             if (!foundFirstNameChar) {
 875                 namePtr = p;
 876                 foundFirstNameChar = true;
 877             }
 878             continue;
 879         }
 880         if (*p == &#39;:&#39;) {
 881             ++p;
 882             break;
 883         }
 884     }
 885 
 886     nameSize = name.size();
<span class="line-modified"> 887     nameStr = StringView(namePtr, nameSize);</span>
 888 
 889     for (; p &lt; end &amp;&amp; *p == 0x20; p++) { }
 890 
 891     for (; p &lt; end; p++) {
 892         switch (*p) {
 893         case &#39;\r&#39;:
 894             break;
 895         case &#39;\n&#39;:
 896             if (strict) {
 897                 failureReason = makeString(&quot;Unexpected LF in header value at &quot;, trimInputSample(value.data(), value.size()));
 898                 return 0;
 899             }
 900             break;
 901         default:
 902             value.append(*p);
 903         }
 904         if (*p == &#39;\r&#39; || (!strict &amp;&amp; *p == &#39;\n&#39;)) {
 905             ++p;
 906             break;
 907         }
</pre>
<hr />
<pre>
 998     default:
 999         break;
1000     }
1001     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
1002 }
1003 
1004 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
1005 {
1006 #ifndef ASSERT_DISABLED
1007     HTTPHeaderName headerName;
1008     ASSERT(!findHTTPHeaderName(name, headerName));
1009 #endif
1010     return accessControlExposeHeaderSet.contains(name);
1011 }
1012 
1013 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
1014 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
1015 {
1016     switch (name) {
1017     case HTTPHeaderName::Accept:
<span class="line-modified">1018         if (!isValidAcceptHeaderValue(value))</span>
<span class="line-added">1019             return false;</span>
<span class="line-added">1020         break;</span>
1021     case HTTPHeaderName::AcceptLanguage:
1022     case HTTPHeaderName::ContentLanguage:
<span class="line-modified">1023         if (!isValidLanguageHeaderValue(value))</span>
<span class="line-added">1024             return false;</span>
<span class="line-added">1025         break;</span>
1026     case HTTPHeaderName::ContentType: {
1027         // Preflight is required for MIME types that can not be sent via form submission.
1028         String mimeType = extractMIMETypeFromMediaType(value);
<span class="line-modified">1029         if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))</span>
<span class="line-added">1030             return false;</span>
<span class="line-added">1031         break;</span>
1032     }
1033     default:
1034         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
1035         return false;
1036     }
<span class="line-added">1037     return value.length() &lt;= 128;</span>
1038 }
1039 
1040 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
1041 String normalizeHTTPMethod(const String&amp; method)
1042 {
1043     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
1044     for (auto value : methods) {
1045         if (equalIgnoringASCIICase(method, value.characters())) {
1046             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
1047             if (method == value)
1048                 break;
1049             return value;
1050         }
1051     }
1052     return method;
1053 }
1054 
1055 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
1056 {
1057     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
</pre>
</td>
</tr>
</table>
<center><a href="HTTPHeaderMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>