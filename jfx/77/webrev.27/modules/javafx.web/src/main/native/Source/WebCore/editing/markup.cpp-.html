<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008, 2009, 2010, 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2011 Igalia S.L.
   5  * Copyright (C) 2011 Motorola Mobility. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  * 1. Redistributions of source code must retain the above copyright
  11  *    notice, this list of conditions and the following disclaimer.
  12  * 2. Redistributions in binary form must reproduce the above copyright
  13  *    notice, this list of conditions and the following disclaimer in the
  14  *    documentation and/or other materials provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;markup.h&quot;
  31 
  32 #include &quot;ArchiveResource.h&quot;
  33 #include &quot;CSSPrimitiveValue.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValue.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;CacheStorageProvider.h&quot;
  38 #include &quot;ChildListMutationScope.h&quot;
  39 #include &quot;Comment.h&quot;
  40 #include &quot;ComposedTreeIterator.h&quot;
  41 #include &quot;DocumentFragment.h&quot;
  42 #include &quot;DocumentLoader.h&quot;
  43 #include &quot;DocumentType.h&quot;
  44 #include &quot;Editing.h&quot;
  45 #include &quot;Editor.h&quot;
  46 #include &quot;EditorClient.h&quot;
  47 #include &quot;ElementIterator.h&quot;
  48 #include &quot;EmptyClients.h&quot;
  49 #include &quot;File.h&quot;
  50 #include &quot;Frame.h&quot;
  51 #include &quot;FrameLoader.h&quot;
  52 #include &quot;HTMLAttachmentElement.h&quot;
  53 #include &quot;HTMLBRElement.h&quot;
  54 #include &quot;HTMLBodyElement.h&quot;
  55 #include &quot;HTMLDivElement.h&quot;
  56 #include &quot;HTMLHeadElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLImageElement.h&quot;
  59 #include &quot;HTMLNames.h&quot;
  60 #include &quot;HTMLStyleElement.h&quot;
  61 #include &quot;HTMLTableElement.h&quot;
  62 #include &quot;HTMLTextAreaElement.h&quot;
  63 #include &quot;HTMLTextFormControlElement.h&quot;
  64 #include &quot;LibWebRTCProvider.h&quot;
  65 #include &quot;MarkupAccumulator.h&quot;
  66 #include &quot;NodeList.h&quot;
  67 #include &quot;Page.h&quot;
  68 #include &quot;PageConfiguration.h&quot;
  69 #include &quot;Range.h&quot;
  70 #include &quot;RenderBlock.h&quot;
  71 #include &quot;RuntimeEnabledFeatures.h&quot;
  72 #include &quot;Settings.h&quot;
  73 #include &quot;SocketProvider.h&quot;
  74 #include &quot;StyleProperties.h&quot;
  75 #include &quot;TextIterator.h&quot;
  76 #include &quot;TypedElementDescendantIterator.h&quot;
  77 #include &quot;VisibleSelection.h&quot;
  78 #include &quot;VisibleUnits.h&quot;
  79 #include &lt;wtf/StdLibExtras.h&gt;
  80 #include &lt;wtf/URL.h&gt;
  81 #include &lt;wtf/URLParser.h&gt;
  82 #include &lt;wtf/text/StringBuilder.h&gt;
  83 
  84 namespace WebCore {
  85 
  86 using namespace HTMLNames;
  87 
  88 static bool propertyMissingOrEqualToNone(StyleProperties*, CSSPropertyID);
  89 
  90 class AttributeChange {
  91 public:
  92     AttributeChange()
  93         : m_name(nullAtom(), nullAtom(), nullAtom())
  94     {
  95     }
  96 
  97     AttributeChange(Element* element, const QualifiedName&amp; name, const String&amp; value)
  98         : m_element(element), m_name(name), m_value(value)
  99     {
 100     }
 101 
 102     void apply()
 103     {
 104         m_element-&gt;setAttribute(m_name, m_value);
 105     }
 106 
 107 private:
 108     RefPtr&lt;Element&gt; m_element;
 109     QualifiedName m_name;
 110     String m_value;
 111 };
 112 
 113 static void completeURLs(DocumentFragment* fragment, const String&amp; baseURL)
 114 {
 115     Vector&lt;AttributeChange&gt; changes;
 116 
 117     URL parsedBaseURL({ }, baseURL);
 118 
 119     for (auto&amp; element : descendantsOfType&lt;Element&gt;(*fragment)) {
 120         if (!element.hasAttributes())
 121             continue;
 122         for (const Attribute&amp; attribute : element.attributesIterator()) {
 123             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty())
 124                 changes.append(AttributeChange(&amp;element, attribute.name(), element.completeURLsInAttributeValue(parsedBaseURL, attribute)));
 125         }
 126     }
 127 
 128     for (auto&amp; change : changes)
 129         change.apply();
 130 }
 131 
 132 void replaceSubresourceURLs(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, HashMap&lt;AtomicString, AtomicString&gt;&amp;&amp; replacementMap)
 133 {
 134     Vector&lt;AttributeChange&gt; changes;
 135     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 136         if (!element.hasAttributes())
 137             continue;
 138         for (const Attribute&amp; attribute : element.attributesIterator()) {
 139             // FIXME: This won&#39;t work for srcset.
 140             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 141                 auto replacement = replacementMap.get(attribute.value());
 142                 if (!replacement.isNull())
 143                     changes.append({ &amp;element, attribute.name(), replacement });
 144             }
 145         }
 146     }
 147     for (auto&amp; change : changes)
 148         change.apply();
 149 }
 150 
 151 struct ElementAttribute {
 152     Ref&lt;Element&gt; element;
 153     QualifiedName attributeName;
 154 };
 155 
 156 void removeSubresourceURLAttributes(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, WTF::Function&lt;bool(const URL&amp;)&gt; shouldRemoveURL)
 157 {
 158     Vector&lt;ElementAttribute&gt; attributesToRemove;
 159     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 160         if (!element.hasAttributes())
 161             continue;
 162         for (const Attribute&amp; attribute : element.attributesIterator()) {
 163             // FIXME: This won&#39;t work for srcset.
 164             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 165                 URL url({ }, attribute.value());
 166                 if (shouldRemoveURL(url))
 167                     attributesToRemove.append({ element, attribute.name() });
 168             }
 169         }
 170     }
 171     for (auto&amp; item : attributesToRemove)
 172         item.element-&gt;removeAttribute(item.attributeName);
 173 }
 174 
 175 std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
 176 {
 177     auto pageConfiguration = pageConfigurationWithEmptyClients();
 178 
 179     auto page = std::make_unique&lt;Page&gt;(WTFMove(pageConfiguration));
 180     page-&gt;settings().setMediaEnabled(false);
 181     page-&gt;settings().setScriptEnabled(false);
 182     page-&gt;settings().setPluginsEnabled(false);
 183     page-&gt;settings().setAcceleratedCompositingEnabled(false);
 184 
 185     Frame&amp; frame = page-&gt;mainFrame();
 186     frame.setView(FrameView::create(frame));
 187     frame.init();
 188 
 189     FrameLoader&amp; loader = frame.loader();
 190     static char markup[] = &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 191     ASSERT(loader.activeDocumentLoader());
 192     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();
 193     writer.setMIMEType(&quot;text/html&quot;);
 194     writer.begin();
 195     writer.insertDataSynchronously(String(markup));
 196     writer.end();
 197     RELEASE_ASSERT(page-&gt;mainFrame().document()-&gt;body());
 198 
 199     return page;
 200 }
 201 
 202 String sanitizeMarkup(const String&amp; rawHTML, MSOListQuirks msoListQuirks, Optional&lt;WTF::Function&lt;void(DocumentFragment&amp;)&gt;&gt; fragmentSanitizer)
 203 {
 204     auto page = createPageForSanitizingWebContent();
 205     Document* stagingDocument = page-&gt;mainFrame().document();
 206     ASSERT(stagingDocument);
 207 
 208     auto fragment = createFragmentFromMarkup(*stagingDocument, rawHTML, emptyString(), DisallowScriptingAndPluginContent);
 209 
 210     if (fragmentSanitizer)
 211         (*fragmentSanitizer)(fragment);
 212 
 213     return sanitizedMarkupForFragmentInDocument(WTFMove(fragment), *stagingDocument, msoListQuirks, rawHTML);
 214 }
 215 
 216 enum class MSOListMode { Preserve, DoNotPreserve };
 217 class StyledMarkupAccumulator final : public MarkupAccumulator {
 218 public:
 219     enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
 220 
 221     StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
 222         AnnotateForInterchange, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);
 223 
 224     Node* serializeNodes(const Position&amp; start, const Position&amp; end);
 225     void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
 226     void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
 227     String takeResults();
 228 
 229     bool needRelativeStyleWrapper() const { return m_needRelativeStyleWrapper; }
 230     bool needClearingDiv() const { return m_needClearingDiv; }
 231 
 232     using MarkupAccumulator::appendString;
 233 
 234     ContainerNode* parentNode(Node&amp; node)
 235     {
 236         if (UNLIKELY(m_useComposedTree))
 237             return node.parentInComposedTree();
 238         return node.parentOrShadowHostNode();
 239     }
 240 
 241 private:
 242     void appendStyleNodeOpenTag(StringBuilder&amp;, StyleProperties*, Document&amp;, bool isBlock = false);
 243     const String&amp; styleNodeCloseTag(bool isBlock = false);
 244 
 245     String renderedTextRespectingRange(const Text&amp;);
 246     String textContentRespectingRange(const Text&amp;);
 247 
 248     bool shouldPreserveMSOListStyleForElement(const Element&amp;);
 249 
 250     void appendStartTag(StringBuilder&amp; out, const Element&amp;, bool addDisplayInline, RangeFullySelectsNode);
 251     void appendEndTag(StringBuilder&amp; out, const Element&amp;) override;
 252     void appendCustomAttributes(StringBuilder&amp;, const Element&amp;, Namespaces*) override;
 253 
 254     void appendText(StringBuilder&amp; out, const Text&amp;) override;
 255     void appendStartTag(StringBuilder&amp; out, const Element&amp; element, Namespaces*) override
 256     {
 257         appendStartTag(out, element, false, DoesFullySelectNode);
 258     }
 259 
 260     Node* firstChild(Node&amp; node)
 261     {
 262         if (UNLIKELY(m_useComposedTree))
 263             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 264         return node.firstChild();
 265     }
 266 
 267     Node* nextSibling(Node&amp; node)
 268     {
 269         if (UNLIKELY(m_useComposedTree))
 270             return nextSiblingInComposedTreeIgnoringUserAgentShadow(node);
 271         return node.nextSibling();
 272     }
 273 
 274     Node* nextSkippingChildren(Node&amp; node)
 275     {
 276         if (UNLIKELY(m_useComposedTree))
 277             return nextSkippingChildrenInComposedTreeIgnoringUserAgentShadow(node);
 278         return NodeTraversal::nextSkippingChildren(node);
 279     }
 280 
 281     bool hasChildNodes(Node&amp; node)
 282     {
 283         if (UNLIKELY(m_useComposedTree))
 284             return firstChildInComposedTreeIgnoringUserAgentShadow(node);
 285         return node.hasChildNodes();
 286     }
 287 
 288     bool isDescendantOf(Node&amp; node, Node&amp; possibleAncestor)
 289     {
 290         if (UNLIKELY(m_useComposedTree))
 291             return node.isDescendantOrShadowDescendantOf(&amp;possibleAncestor);
 292         return node.isDescendantOf(&amp;possibleAncestor);
 293     }
 294 
 295     enum class NodeTraversalMode { EmitString, DoNotEmitString };
 296     Node* traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode);
 297 
 298     bool appendNodeToPreserveMSOList(Node&amp;);
 299 
 300     bool shouldAnnotate()
 301     {
 302         return m_annotate == AnnotateForInterchange::Yes;
 303     }
 304 
 305     bool shouldApplyWrappingStyle(const Node&amp; node) const
 306     {
 307         return m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode() == node.parentNode() &amp;&amp; m_wrappingStyle &amp;&amp; m_wrappingStyle-&gt;style();
 308     }
 309 
 310     Position m_start;
 311     Position m_end;
 312     Vector&lt;String&gt; m_reversedPrecedingMarkup;
 313     const AnnotateForInterchange m_annotate;
 314     RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
 315     RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
 316     bool m_useComposedTree;
 317     bool m_needsPositionStyleConversion;
 318     bool m_needRelativeStyleWrapper { false };
 319     bool m_needClearingDiv { false };
 320     bool m_shouldPreserveMSOList;
 321     bool m_inMSOList { false };
 322 };
 323 
 324 inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
 325     AnnotateForInterchange annotate, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)
 326     : MarkupAccumulator(nodes, urlsToResolve)
 327     , m_start(start)
 328     , m_end(end)
 329     , m_annotate(annotate)
 330     , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
 331     , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
 332     , m_needsPositionStyleConversion(needsPositionStyleConversion)
 333     , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
 334 {
 335 }
 336 
 337 void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
 338 {
 339     StringBuilder markup;
 340     if (is&lt;Element&gt;(node))
 341         appendStartTag(markup, downcast&lt;Element&gt;(node), convertBlocksToInlines &amp;&amp; isBlock(&amp;node), rangeFullySelectsNode);
 342     else
 343         appendNonElementNode(markup, node, nullptr);
 344     m_reversedPrecedingMarkup.append(markup.toString());
 345     endAppendingNode(node);
 346     if (m_nodes)
 347         m_nodes-&gt;append(&amp;node);
 348 }
 349 
 350 void StyledMarkupAccumulator::wrapWithStyleNode(StyleProperties* style, Document&amp; document, bool isBlock)
 351 {
 352     StringBuilder openTag;
 353     appendStyleNodeOpenTag(openTag, style, document, isBlock);
 354     m_reversedPrecedingMarkup.append(openTag.toString());
 355     appendString(styleNodeCloseTag(isBlock));
 356 }
 357 
 358 void StyledMarkupAccumulator::appendStyleNodeOpenTag(StringBuilder&amp; out, StyleProperties* style, Document&amp; document, bool isBlock)
 359 {
 360     // wrappingStyleForSerialization should have removed -webkit-text-decorations-in-effect
 361     ASSERT(propertyMissingOrEqualToNone(style, CSSPropertyWebkitTextDecorationsInEffect));
 362     if (isBlock)
 363         out.appendLiteral(&quot;&lt;div style=\&quot;&quot;);
 364     else
 365         out.appendLiteral(&quot;&lt;span style=\&quot;&quot;);
 366     appendAttributeValue(out, style-&gt;asText(), document.isHTMLDocument());
 367     out.appendLiteral(&quot;\&quot;&gt;&quot;);
 368 }
 369 
 370 const String&amp; StyledMarkupAccumulator::styleNodeCloseTag(bool isBlock)
 371 {
 372     static NeverDestroyed&lt;const String&gt; divClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/div&gt;&quot;));
 373     static NeverDestroyed&lt;const String&gt; styleSpanClose(MAKE_STATIC_STRING_IMPL(&quot;&lt;/span&gt;&quot;));
 374     return isBlock ? divClose : styleSpanClose;
 375 }
 376 
 377 String StyledMarkupAccumulator::takeResults()
 378 {
 379     StringBuilder result;
 380     result.reserveCapacity(totalLength(m_reversedPrecedingMarkup) + length());
 381 
 382     for (size_t i = m_reversedPrecedingMarkup.size(); i &gt; 0; --i)
 383         result.append(m_reversedPrecedingMarkup[i - 1]);
 384 
 385     concatenateMarkup(result);
 386 
 387     // We remove &#39;\0&#39; characters because they are not visibly rendered to the user.
 388     return result.toString().replaceWithLiteral(&#39;\0&#39;, &quot;&quot;);
 389 }
 390 
 391 void StyledMarkupAccumulator::appendText(StringBuilder&amp; out, const Text&amp; text)
 392 {
 393     const bool parentIsTextarea = is&lt;HTMLTextAreaElement&gt;(text.parentElement());
 394     const bool wrappingSpan = shouldApplyWrappingStyle(text) &amp;&amp; !parentIsTextarea;
 395     if (wrappingSpan) {
 396         RefPtr&lt;EditingStyle&gt; wrappingStyle = m_wrappingStyle-&gt;copy();
 397         // FIXME: &lt;rdar://problem/5371536&gt; Style rules that match pasted content can change it&#39;s appearance
 398         // Make sure spans are inline style in paste side e.g. span { display: block }.
 399         wrappingStyle-&gt;forceInline();
 400         // FIXME: Should this be included in forceInline?
 401         wrappingStyle-&gt;style()-&gt;setProperty(CSSPropertyFloat, CSSValueNone);
 402 
 403         appendStyleNodeOpenTag(out, wrappingStyle-&gt;style(), text.document());
 404     }
 405 
 406     if (!shouldAnnotate() || parentIsTextarea) {
 407         auto content = textContentRespectingRange(text);
 408         appendCharactersReplacingEntities(out, content, 0, content.length(), entityMaskForText(text));
 409     } else {
 410         const bool useRenderedText = !enclosingElementWithTag(firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text)), selectTag);
 411         String content = useRenderedText ? renderedTextRespectingRange(text) : textContentRespectingRange(text);
 412         StringBuilder buffer;
 413         appendCharactersReplacingEntities(buffer, content, 0, content.length(), EntityMaskInPCDATA);
 414         out.append(convertHTMLTextToInterchangeFormat(buffer.toString(), &amp;text));
 415     }
 416 
 417     if (wrappingSpan)
 418         out.append(styleNodeCloseTag());
 419 }
 420 
 421 String StyledMarkupAccumulator::renderedTextRespectingRange(const Text&amp; text)
 422 {
 423     TextIteratorBehavior behavior = TextIteratorDefaultBehavior;
 424     Position start = &amp;text == m_start.containerNode() ? m_start : firstPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 425     Position end;
 426     if (&amp;text == m_end.containerNode())
 427         end = m_end;
 428     else {
 429         end = lastPositionInNode(const_cast&lt;Text*&gt;(&amp;text));
 430         if (!m_end.isNull())
 431             behavior = TextIteratorBehavesAsIfNodesFollowing;
 432     }
 433 
 434     return plainText(Range::create(text.document(), start, end).ptr(), behavior);
 435 }
 436 
 437 String StyledMarkupAccumulator::textContentRespectingRange(const Text&amp; text)
 438 {
 439     if (m_start.isNull() &amp;&amp; m_end.isNull())
 440         return text.data();
 441 
 442     unsigned start = 0;
 443     unsigned end = std::numeric_limits&lt;unsigned&gt;::max();
 444     if (&amp;text == m_start.containerNode())
 445         start = m_start.offsetInContainerNode();
 446     if (&amp;text == m_end.containerNode())
 447         end = m_end.offsetInContainerNode();
 448     ASSERT(start &lt; end);
 449     return text.data().substring(start, end - start);
 450 }
 451 
 452 void StyledMarkupAccumulator::appendCustomAttributes(StringBuilder&amp; out, const Element&amp; element, Namespaces* namespaces)
 453 {
 454 #if ENABLE(ATTACHMENT_ELEMENT)
 455     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 456         return;
 457 
 458     if (is&lt;HTMLAttachmentElement&gt;(element)) {
 459         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
 460         appendAttribute(out, element, { webkitattachmentidAttr, attachment.uniqueIdentifier() }, namespaces);
 461         if (auto* file = attachment.file()) {
 462             // These attributes are only intended for File deserialization, and are removed from the generated attachment
 463             // element after we&#39;ve deserialized and set its backing File, in restoreAttachmentElementsInFragment.
 464             appendAttribute(out, element, { webkitattachmentpathAttr, file-&gt;path() }, namespaces);
 465             appendAttribute(out, element, { webkitattachmentbloburlAttr, file-&gt;url().string() }, namespaces);
 466         }
 467     } else if (is&lt;HTMLImageElement&gt;(element)) {
 468         if (auto attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement())
 469             appendAttribute(out, element, { webkitattachmentidAttr, attachment-&gt;uniqueIdentifier() }, namespaces);
 470     }
 471 #else
 472     UNUSED_PARAM(out);
 473     UNUSED_PARAM(element);
 474     UNUSED_PARAM(namespaces);
 475 #endif
 476 }
 477 
 478 bool StyledMarkupAccumulator::shouldPreserveMSOListStyleForElement(const Element&amp; element)
 479 {
 480     if (m_inMSOList)
 481         return true;
 482     if (m_shouldPreserveMSOList) {
 483         auto style = element.getAttribute(styleAttr);
 484         return style.startsWith(&quot;mso-list:&quot;) || style.contains(&quot;;mso-list:&quot;) || style.contains(&quot;\nmso-list:&quot;);
 485     }
 486     return false;
 487 }
 488 
 489 void StyledMarkupAccumulator::appendStartTag(StringBuilder&amp; out, const Element&amp; element, bool addDisplayInline, RangeFullySelectsNode rangeFullySelectsNode)
 490 {
 491     const bool documentIsHTML = element.document().isHTMLDocument();
 492     const bool isSlotElement = is&lt;HTMLSlotElement&gt;(element);
 493     if (UNLIKELY(isSlotElement))
 494         out.append(&quot;&lt;span&quot;);
 495     else
 496         appendOpenTag(out, element, nullptr);
 497 
 498     appendCustomAttributes(out, element, nullptr);
 499 
 500     const bool shouldAnnotateOrForceInline = element.isHTMLElement() &amp;&amp; (shouldAnnotate() || addDisplayInline);
 501     bool shouldOverrideStyleAttr = (shouldAnnotateOrForceInline || shouldApplyWrappingStyle(element) || isSlotElement) &amp;&amp; !shouldPreserveMSOListStyleForElement(element);
 502     if (element.hasAttributes()) {
 503         for (const Attribute&amp; attribute : element.attributesIterator()) {
 504             // We&#39;ll handle the style attribute separately, below.
 505             if (attribute.name() == styleAttr &amp;&amp; shouldOverrideStyleAttr)
 506                 continue;
 507             if (element.isEventHandlerAttribute(attribute) || element.isJavaScriptURLAttribute(attribute))
 508                 continue;
 509             appendAttribute(out, element, attribute, 0);
 510         }
 511     }
 512 
 513     if (shouldOverrideStyleAttr) {
 514         RefPtr&lt;EditingStyle&gt; newInlineStyle;
 515 
 516         if (shouldApplyWrappingStyle(element)) {
 517             newInlineStyle = m_wrappingStyle-&gt;copy();
 518             newInlineStyle-&gt;removePropertiesInElementDefaultStyle(*const_cast&lt;Element*&gt;(&amp;element));
 519             newInlineStyle-&gt;removeStyleConflictingWithStyleOfNode(*const_cast&lt;Element*&gt;(&amp;element));
 520         } else
 521             newInlineStyle = EditingStyle::create();
 522 
 523         if (isSlotElement)
 524             newInlineStyle-&gt;addDisplayContents();
 525 
 526         if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
 527             newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
 528 
 529         if (shouldAnnotateOrForceInline) {
 530             if (shouldAnnotate())
 531                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)));
 532 
 533             if (addDisplayInline)
 534                 newInlineStyle-&gt;forceInline();
 535 
 536             if (m_needsPositionStyleConversion) {
 537                 m_needRelativeStyleWrapper |= newInlineStyle-&gt;convertPositionStyle();
 538                 m_needClearingDiv |= newInlineStyle-&gt;isFloating();
 539             }
 540 
 541             // If the node is not fully selected by the range, then we don&#39;t want to keep styles that affect its relationship to the nodes around it
 542             // only the ones that affect it and the nodes within it.
 543             if (rangeFullySelectsNode == DoesNotFullySelectNode &amp;&amp; newInlineStyle-&gt;style())
 544                 newInlineStyle-&gt;style()-&gt;removeProperty(CSSPropertyFloat);
 545         }
 546 
 547         if (!newInlineStyle-&gt;isEmpty()) {
 548             out.appendLiteral(&quot; style=\&quot;&quot;);
 549             appendAttributeValue(out, newInlineStyle-&gt;style()-&gt;asText(), documentIsHTML);
 550             out.append(&#39;\&quot;&#39;);
 551         }
 552     }
 553 
 554     appendCloseTag(out, element);
 555 }
 556 
 557 void StyledMarkupAccumulator::appendEndTag(StringBuilder&amp; out, const Element&amp; element)
 558 {
 559     if (UNLIKELY(is&lt;HTMLSlotElement&gt;(element)))
 560         out.append(&quot;&lt;/span&gt;&quot;);
 561     else
 562         MarkupAccumulator::appendEndTag(out, element);
 563 }
 564 
 565 Node* StyledMarkupAccumulator::serializeNodes(const Position&amp; start, const Position&amp; end)
 566 {
 567     ASSERT(comparePositions(start, end) &lt;= 0);
 568     auto startNode = start.firstNode();
 569     Node* pastEnd = end.computeNodeAfterPosition();
 570     if (!pastEnd &amp;&amp; end.containerNode())
 571         pastEnd = nextSkippingChildren(*end.containerNode());
 572 
 573     if (!m_highestNodeToBeSerialized) {
 574         Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
 575         m_highestNodeToBeSerialized = lastClosed;
 576     }
 577 
 578     if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
 579         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate());
 580 
 581     return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
 582 }
 583 
 584 Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
 585 {
 586     const bool shouldEmit = traversalMode == NodeTraversalMode::EmitString;
 587 
 588     m_inMSOList = false;
 589 
 590     unsigned depth = 0;
 591     auto enterNode = [&amp;] (Node&amp; node) {
 592         if (UNLIKELY(m_shouldPreserveMSOList) &amp;&amp; shouldEmit) {
 593             if (appendNodeToPreserveMSOList(node))
 594                 return false;
 595         }
 596 
 597         bool isDisplayContents = is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 598         if (!node.renderer() &amp;&amp; !isDisplayContents &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(&amp;node), selectTag))
 599             return false;
 600 
 601         ++depth;
 602         if (shouldEmit)
 603             startAppendingNode(node);
 604 
 605         return true;
 606     };
 607 
 608     Node* lastClosed = nullptr;
 609     auto exitNode = [&amp;] (Node&amp; node) {
 610         bool closing = depth;
 611         if (depth)
 612             --depth;
 613         if (shouldEmit) {
 614             if (closing)
 615                 endAppendingNode(node);
 616             else
 617                 wrapWithNode(node);
 618         }
 619         lastClosed = &amp;node;
 620     };
 621 
 622     Node* lastNode = nullptr;
 623     Node* next = nullptr;
 624     for (auto* n = startNode; n != pastEnd; lastNode = n, n = next) {
 625 
 626         Vector&lt;Node*, 8&gt; exitedAncestors;
 627         next = nullptr;
 628         if (auto* child = firstChild(*n))
 629             next = child;
 630         else if (auto* sibling = nextSibling(*n))
 631             next = sibling;
 632         else {
 633             for (auto* ancestor = parentNode(*n); ancestor; ancestor = parentNode(*ancestor)) {
 634                 exitedAncestors.append(ancestor);
 635                 if (auto* sibling = nextSibling(*ancestor)) {
 636                     next = sibling;
 637                     break;
 638                 }
 639             }
 640         }
 641         ASSERT(next || !pastEnd);
 642 
 643         if (isBlock(n) &amp;&amp; canHaveChildrenForEditing(*n) &amp;&amp; next == pastEnd) {
 644             // Don&#39;t write out empty block containers that aren&#39;t fully selected.
 645             continue;
 646         }
 647 
 648         if (!enterNode(*n)) {
 649             next = nextSkippingChildren(*n);
 650             // Don&#39;t skip over pastEnd.
 651             if (pastEnd &amp;&amp; isDescendantOf(*pastEnd, *n))
 652                 next = pastEnd;
 653             ASSERT(next || !pastEnd);
 654         } else {
 655             if (!hasChildNodes(*n))
 656                 exitNode(*n);
 657         }
 658 
 659         for (auto* ancestor : exitedAncestors) {
 660             if (!depth &amp;&amp; next == pastEnd)
 661                 break;
 662             exitNode(*ancestor);
 663         }
 664     }
 665 
 666     ASSERT(lastNode || !depth);
 667     if (depth) {
 668         for (auto* ancestor = parentNode(pastEnd ? *pastEnd : *lastNode); ancestor &amp;&amp; depth; ancestor = parentNode(*ancestor))
 669             exitNode(*ancestor);
 670     }
 671 
 672     return lastClosed;
 673 }
 674 
 675 bool StyledMarkupAccumulator::appendNodeToPreserveMSOList(Node&amp; node)
 676 {
 677     if (is&lt;Comment&gt;(node)) {
 678         auto&amp; commentNode = downcast&lt;Comment&gt;(node);
 679         if (!m_inMSOList &amp;&amp; commentNode.data() == &quot;[if !supportLists]&quot;)
 680             m_inMSOList = true;
 681         else if (m_inMSOList &amp;&amp; commentNode.data() == &quot;[endif]&quot;)
 682             m_inMSOList = false;
 683         else
 684             return false;
 685         startAppendingNode(commentNode);
 686         return true;
 687     }
 688     if (is&lt;HTMLStyleElement&gt;(node)) {
 689         auto* firstChild = node.firstChild();
 690         if (!is&lt;Text&gt;(firstChild))
 691             return false;
 692 
 693         auto&amp; textChild = downcast&lt;Text&gt;(*firstChild);
 694         auto&amp; styleContent = textChild.data();
 695 
 696         const auto msoStyleDefinitionsStart = styleContent.find(&quot;/* Style Definitions */&quot;);
 697         const auto msoListDefinitionsStart = styleContent.find(&quot;/* List Definitions */&quot;);
 698         const auto lastListItem = styleContent.reverseFind(&quot;\n@list&quot;);
 699         if (msoListDefinitionsStart == notFound || lastListItem == notFound)
 700             return false;
 701         const auto start = msoStyleDefinitionsStart != notFound &amp;&amp; msoStyleDefinitionsStart &lt; msoListDefinitionsStart ? msoStyleDefinitionsStart : msoListDefinitionsStart;
 702 
 703         const auto msoListDefinitionsEnd = styleContent.find(&quot;;}\n&quot;, lastListItem);
 704         if (msoListDefinitionsEnd == notFound || start &gt;= msoListDefinitionsEnd)
 705             return false;
 706 
 707         appendString(&quot;&lt;head&gt;&lt;style class=\&quot;&quot; WebKitMSOListQuirksStyle &quot;\&quot;&gt;\n&lt;!--\n&quot;);
 708         appendStringView(StringView(textChild.data()).substring(start, msoListDefinitionsEnd - start + 3));
 709         appendString(&quot;\n--&gt;\n&lt;/style&gt;&lt;/head&gt;&quot;);
 710 
 711         return true;
 712     }
 713     return false;
 714 }
 715 
 716 static Node* ancestorToRetainStructureAndAppearanceForBlock(Node* commonAncestorBlock)
 717 {
 718     if (!commonAncestorBlock)
 719         return nullptr;
 720 
 721     if (commonAncestorBlock-&gt;hasTagName(tbodyTag) || commonAncestorBlock-&gt;hasTagName(trTag)) {
 722         ContainerNode* table = commonAncestorBlock-&gt;parentNode();
 723         while (table &amp;&amp; !is&lt;HTMLTableElement&gt;(*table))
 724             table = table-&gt;parentNode();
 725 
 726         return table;
 727     }
 728 
 729     if (isNonTableCellHTMLBlockElement(commonAncestorBlock))
 730         return commonAncestorBlock;
 731 
 732     return nullptr;
 733 }
 734 
 735 static inline Node* ancestorToRetainStructureAndAppearance(Node* commonAncestor)
 736 {
 737     return ancestorToRetainStructureAndAppearanceForBlock(enclosingBlock(commonAncestor));
 738 }
 739 
 740 static bool propertyMissingOrEqualToNone(StyleProperties* style, CSSPropertyID propertyID)
 741 {
 742     if (!style)
 743         return false;
 744     RefPtr&lt;CSSValue&gt; value = style-&gt;getPropertyCSSValue(propertyID);
 745     if (!value)
 746         return true;
 747     if (!is&lt;CSSPrimitiveValue&gt;(*value))
 748         return false;
 749     return downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() == CSSValueNone;
 750 }
 751 
 752 static bool needInterchangeNewlineAfter(const VisiblePosition&amp; v)
 753 {
 754     VisiblePosition next = v.next();
 755     Node* upstreamNode = next.deepEquivalent().upstream().deprecatedNode();
 756     Node* downstreamNode = v.deepEquivalent().downstream().deprecatedNode();
 757     // Add an interchange newline if a paragraph break is selected and a br won&#39;t already be added to the markup to represent it.
 758     return isEndOfParagraph(v) &amp;&amp; isStartOfParagraph(next) &amp;&amp; !(upstreamNode-&gt;hasTagName(brTag) &amp;&amp; upstreamNode == downstreamNode);
 759 }
 760 
 761 static RefPtr&lt;EditingStyle&gt; styleFromMatchedRulesAndInlineDecl(Node&amp; node)
 762 {
 763     if (!is&lt;HTMLElement&gt;(node))
 764         return nullptr;
 765 
 766     auto&amp; element = downcast&lt;HTMLElement&gt;(node);
 767     auto style = EditingStyle::create(element.inlineStyle());
 768     style-&gt;mergeStyleFromRules(element);
 769     return WTFMove(style);
 770 }
 771 
 772 static bool isElementPresentational(const Node* node)
 773 {
 774     return node-&gt;hasTagName(uTag) || node-&gt;hasTagName(sTag) || node-&gt;hasTagName(strikeTag)
 775         || node-&gt;hasTagName(iTag) || node-&gt;hasTagName(emTag) || node-&gt;hasTagName(bTag) || node-&gt;hasTagName(strongTag);
 776 }
 777 
 778 static Node* highestAncestorToWrapMarkup(const Position&amp; start, const Position&amp; end, Node&amp; commonAncestor, AnnotateForInterchange annotate)
 779 {
 780     Node* specialCommonAncestor = nullptr;
 781     if (annotate == AnnotateForInterchange::Yes) {
 782         // Include ancestors that aren&#39;t completely inside the range but are required to retain
 783         // the structure and appearance of the copied markup.
 784         specialCommonAncestor = ancestorToRetainStructureAndAppearance(&amp;commonAncestor);
 785 
 786         if (auto* parentListNode = enclosingNodeOfType(start, isListItem)) {
 787             if (!editingIgnoresContent(*parentListNode) &amp;&amp; VisibleSelection::selectionFromContentsOfNode(parentListNode) == VisibleSelection(start, end)) {
 788                 specialCommonAncestor = parentListNode-&gt;parentNode();
 789                 while (specialCommonAncestor &amp;&amp; !isListHTMLElement(specialCommonAncestor))
 790                     specialCommonAncestor = specialCommonAncestor-&gt;parentNode();
 791             }
 792         }
 793 
 794         // Retain the Mail quote level by including all ancestor mail block quotes.
 795         if (Node* highestMailBlockquote = highestEnclosingNodeOfType(start, isMailBlockquote, CanCrossEditingBoundary))
 796             specialCommonAncestor = highestMailBlockquote;
 797     }
 798 
 799     auto* checkAncestor = specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor;
 800     if (checkAncestor-&gt;renderer() &amp;&amp; checkAncestor-&gt;renderer()-&gt;containingBlock()) {
 801         Node* newSpecialCommonAncestor = highestEnclosingNodeOfType(firstPositionInNode(checkAncestor), &amp;isElementPresentational, CanCrossEditingBoundary, checkAncestor-&gt;renderer()-&gt;containingBlock()-&gt;element());
 802         if (newSpecialCommonAncestor)
 803             specialCommonAncestor = newSpecialCommonAncestor;
 804     }
 805 
 806     // If a single tab is selected, commonAncestor will be a text node inside a tab span.
 807     // If two or more tabs are selected, commonAncestor will be the tab span.
 808     // In either case, if there is a specialCommonAncestor already, it will necessarily be above
 809     // any tab span that needs to be included.
 810     if (!specialCommonAncestor &amp;&amp; isTabSpanTextNode(&amp;commonAncestor))
 811         specialCommonAncestor = commonAncestor.parentNode();
 812     if (!specialCommonAncestor &amp;&amp; isTabSpanNode(&amp;commonAncestor))
 813         specialCommonAncestor = &amp;commonAncestor;
 814 
 815     if (auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor), aTag))
 816         specialCommonAncestor = enclosingAnchor;
 817 
 818     return specialCommonAncestor;
 819 }
 820 
 821 static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
 822     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, MSOListMode msoListMode)
 823 {
 824     static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
 825 
 826     if (!comparePositions(start, end))
 827         return emptyString();
 828 
 829     RefPtr&lt;Node&gt; commonAncestor = commonShadowIncludingAncestor(start, end);
 830     if (!commonAncestor)
 831         return emptyString();
 832 
 833     auto&amp; document = *start.document();
 834     document.updateLayoutIgnorePendingStylesheets();
 835 
 836     VisiblePosition visibleStart { start };
 837     VisiblePosition visibleEnd { end };
 838 
 839     auto body = makeRefPtr(enclosingElementWithTag(firstPositionInNode(commonAncestor.get()), bodyTag));
 840     RefPtr&lt;Element&gt; fullySelectedRoot;
 841     // FIXME: Do this for all fully selected blocks, not just the body.
 842     if (body &amp;&amp; VisiblePosition(firstPositionInNode(body.get())) == visibleStart &amp;&amp; VisiblePosition(lastPositionInNode(body.get())) == visibleEnd)
 843         fullySelectedRoot = body;
 844     bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
 845 
 846     Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
 847 
 848     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, msoListMode, needsPositionStyleConversion, specialCommonAncestor);
 849 
 850     Position startAdjustedForInterchangeNewline = start;
 851     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
 852         if (visibleStart == visibleEnd.previous())
 853             return interchangeNewlineString;
 854 
 855         accumulator.appendString(interchangeNewlineString);
 856         startAdjustedForInterchangeNewline = visibleStart.next().deepEquivalent();
 857 
 858         if (comparePositions(startAdjustedForInterchangeNewline, end) &gt;= 0)
 859             return interchangeNewlineString;
 860     }
 861 
 862     Node* lastClosed = accumulator.serializeNodes(startAdjustedForInterchangeNewline, end);
 863 
 864     if (specialCommonAncestor &amp;&amp; lastClosed) {
 865         // Also include all of the ancestors of lastClosed up to this special ancestor.
 866         for (ContainerNode* ancestor = accumulator.parentNode(*lastClosed); ancestor; ancestor = accumulator.parentNode(*ancestor)) {
 867             if (ancestor == fullySelectedRoot &amp;&amp; convertBlocksToInlines == ConvertBlocksToInlines::No) {
 868                 RefPtr&lt;EditingStyle&gt; fullySelectedRootStyle = styleFromMatchedRulesAndInlineDecl(*fullySelectedRoot);
 869 
 870                 // Bring the background attribute over, but not as an attribute because a background attribute on a div
 871                 // appears to have no effect.
 872                 if ((!fullySelectedRootStyle || !fullySelectedRootStyle-&gt;style() || !fullySelectedRootStyle-&gt;style()-&gt;getPropertyCSSValue(CSSPropertyBackgroundImage))
 873                     &amp;&amp; fullySelectedRoot-&gt;hasAttributeWithoutSynchronization(backgroundAttr))
 874                     fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyBackgroundImage, &quot;url(&#39;&quot; + fullySelectedRoot-&gt;getAttribute(backgroundAttr) + &quot;&#39;)&quot;);
 875 
 876                 if (fullySelectedRootStyle-&gt;style()) {
 877                     // Reset the CSS properties to avoid an assertion error in addStyleMarkup().
 878                     // This assertion is caused at least when we select all text of a &lt;body&gt; element whose
 879                     // &#39;text-decoration&#39; property is &quot;inherit&quot;, and copy it.
 880                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyTextDecoration))
 881                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyTextDecoration, CSSValueNone);
 882                     if (!propertyMissingOrEqualToNone(fullySelectedRootStyle-&gt;style(), CSSPropertyWebkitTextDecorationsInEffect))
 883                         fullySelectedRootStyle-&gt;style()-&gt;setProperty(CSSPropertyWebkitTextDecorationsInEffect, CSSValueNone);
 884                     accumulator.wrapWithStyleNode(fullySelectedRootStyle-&gt;style(), document, true);
 885                 }
 886             } else {
 887                 // Since this node and all the other ancestors are not in the selection we want to set RangeFullySelectsNode to DoesNotFullySelectNode
 888                 // so that styles that affect the exterior of the node are not included.
 889                 accumulator.wrapWithNode(*ancestor, convertBlocksToInlines == ConvertBlocksToInlines::Yes, StyledMarkupAccumulator::DoesNotFullySelectNode);
 890             }
 891             if (nodes)
 892                 nodes-&gt;append(ancestor);
 893 
 894             if (ancestor == specialCommonAncestor)
 895                 break;
 896         }
 897     }
 898 
 899     if (accumulator.needRelativeStyleWrapper() &amp;&amp; needsPositionStyleConversion) {
 900         if (accumulator.needClearingDiv())
 901             accumulator.appendString(&quot;&lt;div style=\&quot;clear: both;\&quot;&gt;&lt;/div&gt;&quot;);
 902         RefPtr&lt;EditingStyle&gt; positionRelativeStyle = styleFromMatchedRulesAndInlineDecl(*body);
 903         positionRelativeStyle-&gt;style()-&gt;setProperty(CSSPropertyPosition, CSSValueRelative);
 904         accumulator.wrapWithStyleNode(positionRelativeStyle-&gt;style(), document, true);
 905     }
 906 
 907     // FIXME: The interchange newline should be placed in the block that it&#39;s in, not after all of the content, unconditionally.
 908     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleEnd.previous()))
 909         accumulator.appendString(interchangeNewlineString);
 910 
 911     return accumulator.takeResults();
 912 }
 913 
 914 String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
 915 {
 916     return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
 917         annotate, convertBlocksToInlines, MSOListMode::DoNotPreserve);
 918 }
 919 
 920 String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
 921 {
 922     return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
 923         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, MSOListMode::DoNotPreserve);
 924 }
 925 
 926 
 927 static bool shouldPreserveMSOLists(const String&amp; markup)
 928 {
 929     if (!markup.startsWith(&quot;&lt;html xmlns:&quot;))
 930         return false;
 931     auto tagClose = markup.find(&#39;&gt;&#39;);
 932     if (tagClose == notFound)
 933         return false;
 934     auto htmlTag = markup.substring(0, tagClose);
 935     return htmlTag.contains(&quot;xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;&quot;)
 936         &amp;&amp; htmlTag.contains(&quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;&quot;);
 937 }
 938 
 939 String sanitizedMarkupForFragmentInDocument(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, Document&amp; document, MSOListQuirks msoListQuirks, const String&amp; originalMarkup)
 940 {
 941     MSOListMode msoListMode = msoListQuirks == MSOListQuirks::CheckIfNeeded &amp;&amp; shouldPreserveMSOLists(originalMarkup)
 942         ? MSOListMode::Preserve : MSOListMode::DoNotPreserve;
 943 
 944     auto bodyElement = makeRefPtr(document.body());
 945     ASSERT(bodyElement);
 946     bodyElement-&gt;appendChild(fragment.get());
 947 
 948     // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
 949     auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
 950         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  msoListMode);
 951 
 952     if (msoListMode == MSOListMode::Preserve) {
 953         StringBuilder builder;
 954         builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
 955             &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
 956             &quot;xmlns:m=\&quot;http://schemas.microsoft.com/office/2004/12/omml\&quot;\n&quot;
 957             &quot;xmlns=\&quot;http://www.w3.org/TR/REC-html40\&quot;&gt;&quot;);
 958         builder.append(result);
 959         builder.appendLiteral(&quot;&lt;/html&gt;&quot;);
 960         return builder.toString();
 961     }
 962 
 963     return result;
 964 }
 965 
 966 static void restoreAttachmentElementsInFragment(DocumentFragment&amp; fragment)
 967 {
 968 #if ENABLE(ATTACHMENT_ELEMENT)
 969     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 970         return;
 971 
 972     // When creating a fragment we must strip the webkit-attachment-path attribute after restoring the File object.
 973     Vector&lt;Ref&lt;HTMLAttachmentElement&gt;&gt; attachments;
 974     for (auto&amp; attachment : descendantsOfType&lt;HTMLAttachmentElement&gt;(fragment))
 975         attachments.append(attachment);
 976 
 977     for (auto&amp; attachment : attachments) {
 978         attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
 979 
 980         auto attachmentPath = attachment-&gt;attachmentPath();
 981         auto blobURL = attachment-&gt;blobURL();
 982         if (!attachmentPath.isEmpty())
 983             attachment-&gt;setFile(File::create(attachmentPath));
 984         else if (!blobURL.isEmpty())
 985             attachment-&gt;setFile(File::deserialize({ }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));
 986 
 987         // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
 988         attachment-&gt;removeAttribute(webkitattachmentidAttr);
 989         attachment-&gt;removeAttribute(webkitattachmentpathAttr);
 990         attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
 991     }
 992 
 993     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
 994     for (auto&amp; image : descendantsOfType&lt;HTMLImageElement&gt;(fragment))
 995         images.append(image);
 996 
 997     for (auto&amp; image : images) {
 998         auto attachmentIdentifier = image-&gt;attributeWithoutSynchronization(webkitattachmentidAttr);
 999         if (attachmentIdentifier.isEmpty())
1000             continue;
1001 
1002         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, *fragment.ownerDocument());
1003         attachment-&gt;setUniqueIdentifier(attachmentIdentifier);
1004         image-&gt;setAttachmentElement(WTFMove(attachment));
1005         image-&gt;removeAttribute(webkitattachmentidAttr);
1006     }
1007 #else
1008     UNUSED_PARAM(fragment);
1009 #endif
1010 }
1011 
1012 Ref&lt;DocumentFragment&gt; createFragmentFromMarkup(Document&amp; document, const String&amp; markup, const String&amp; baseURL, ParserContentPolicy parserContentPolicy)
1013 {
1014     // We use a fake body element here to trick the HTML parser into using the InBody insertion mode.
1015     auto fakeBody = HTMLBodyElement::create(document);
1016     auto fragment = DocumentFragment::create(document);
1017 
1018     fragment-&gt;parseHTML(markup, fakeBody.ptr(), parserContentPolicy);
1019     restoreAttachmentElementsInFragment(fragment);
1020     if (!baseURL.isEmpty() &amp;&amp; baseURL != WTF::blankURL() &amp;&amp; baseURL != document.baseURL())
1021         completeURLs(fragment.ptr(), baseURL);
1022 
1023     return fragment;
1024 }
1025 
1026 String serializeFragment(const Node&amp; node, SerializedNodes root, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, Vector&lt;QualifiedName&gt;* tagNamesToSkip, SerializationSyntax serializationSyntax)
1027 {
1028     MarkupAccumulator accumulator(nodes, urlsToResolve, serializationSyntax);
1029     return accumulator.serializeNodes(const_cast&lt;Node&amp;&gt;(node), root, tagNamesToSkip);
1030 }
1031 
1032 static void fillContainerFromString(ContainerNode&amp; paragraph, const String&amp; string)
1033 {
1034     Document&amp; document = paragraph.document();
1035 
1036     if (string.isEmpty()) {
1037         paragraph.appendChild(createBlockPlaceholderElement(document));
1038         return;
1039     }
1040 
1041     ASSERT(string.find(&#39;\n&#39;) == notFound);
1042 
1043     Vector&lt;String&gt; tabList = string.splitAllowingEmptyEntries(&#39;\t&#39;);
1044     String tabText = emptyString();
1045     bool first = true;
1046     size_t numEntries = tabList.size();
1047     for (size_t i = 0; i &lt; numEntries; ++i) {
1048         const String&amp; s = tabList[i];
1049 
1050         // append the non-tab textual part
1051         if (!s.isEmpty()) {
1052             if (!tabText.isEmpty()) {
1053                 paragraph.appendChild(createTabSpanElement(document, tabText));
1054                 tabText = emptyString();
1055             }
1056             Ref&lt;Node&gt; textNode = document.createTextNode(stringWithRebalancedWhitespace(s, first, i + 1 == numEntries));
1057             paragraph.appendChild(textNode);
1058         }
1059 
1060         // there is a tab after every entry, except the last entry
1061         // (if the last character is a tab, the list gets an extra empty entry)
1062         if (i + 1 != numEntries)
1063             tabText.append(&#39;\t&#39;);
1064         else if (!tabText.isEmpty())
1065             paragraph.appendChild(createTabSpanElement(document, tabText));
1066 
1067         first = false;
1068     }
1069 }
1070 
1071 bool isPlainTextMarkup(Node* node)
1072 {
1073     ASSERT(node);
1074     if (!is&lt;HTMLDivElement&gt;(*node))
1075         return false;
1076 
1077     HTMLDivElement&amp; element = downcast&lt;HTMLDivElement&gt;(*node);
1078     if (element.hasAttributes())
1079         return false;
1080 
1081     Node* firstChild = element.firstChild();
1082     if (!firstChild)
1083         return false;
1084 
1085     Node* secondChild = firstChild-&gt;nextSibling();
1086     if (!secondChild)
1087         return firstChild-&gt;isTextNode() || firstChild-&gt;firstChild();
1088 
1089     if (secondChild-&gt;nextSibling())
1090         return false;
1091 
1092     return isTabSpanTextNode(firstChild-&gt;firstChild()) &amp;&amp; secondChild-&gt;isTextNode();
1093 }
1094 
1095 static bool contextPreservesNewline(const Range&amp; context)
1096 {
1097     VisiblePosition position(context.startPosition());
1098     Node* container = position.deepEquivalent().containerNode();
1099     if (!container || !container-&gt;renderer())
1100         return false;
1101 
1102     return container-&gt;renderer()-&gt;style().preserveNewline();
1103 }
1104 
1105 Ref&lt;DocumentFragment&gt; createFragmentFromText(Range&amp; context, const String&amp; text)
1106 {
1107     Document&amp; document = context.ownerDocument();
1108     Ref&lt;DocumentFragment&gt; fragment = document.createDocumentFragment();
1109 
1110     if (text.isEmpty())
1111         return fragment;
1112 
1113     String string = text;
1114     string.replace(&quot;\r\n&quot;, &quot;\n&quot;);
1115     string.replace(&#39;\r&#39;, &#39;\n&#39;);
1116 
1117     auto createHTMLBRElement = [&amp;document]() {
1118         auto element = HTMLBRElement::create(document);
1119         element-&gt;setAttributeWithoutSynchronization(classAttr, AppleInterchangeNewline);
1120         return element;
1121     };
1122 
1123     if (contextPreservesNewline(context)) {
1124         fragment-&gt;appendChild(document.createTextNode(string));
1125         if (string.endsWith(&#39;\n&#39;)) {
1126             fragment-&gt;appendChild(createHTMLBRElement());
1127         }
1128         return fragment;
1129     }
1130 
1131     // A string with no newlines gets added inline, rather than being put into a paragraph.
1132     if (string.find(&#39;\n&#39;) == notFound) {
1133         fillContainerFromString(fragment, string);
1134         return fragment;
1135     }
1136 
1137     if (string.length() == 1 &amp;&amp; string[0] == &#39;\n&#39;) {
1138         // This is a single newline char, thus just create one HTMLBRElement.
1139         fragment-&gt;appendChild(createHTMLBRElement());
1140         return fragment;
1141     }
1142 
1143     // Break string into paragraphs. Extra line breaks turn into empty paragraphs.
1144     Node* blockNode = enclosingBlock(context.firstNode());
1145     Element* block = downcast&lt;Element&gt;(blockNode);
1146     bool useClonesOfEnclosingBlock = blockNode
1147         &amp;&amp; blockNode-&gt;isElementNode()
1148         &amp;&amp; !block-&gt;hasTagName(bodyTag)
1149         &amp;&amp; !block-&gt;hasTagName(htmlTag)
1150         &amp;&amp; block != editableRootForPosition(context.startPosition());
1151     bool useLineBreak = enclosingTextFormControl(context.startPosition());
1152 
1153     Vector&lt;String&gt; list = string.splitAllowingEmptyEntries(&#39;\n&#39;);
1154     size_t numLines = list.size();
1155     for (size_t i = 0; i &lt; numLines; ++i) {
1156         const String&amp; s = list[i];
1157 
1158         RefPtr&lt;Element&gt; element;
1159         if (s.isEmpty() &amp;&amp; i + 1 == numLines) {
1160             // For last line, use the &quot;magic BR&quot; rather than a P.
1161             element = createHTMLBRElement();
1162         } else if (useLineBreak) {
1163             element = HTMLBRElement::create(document);
1164             fillContainerFromString(fragment, s);
1165         } else {
1166             if (useClonesOfEnclosingBlock)
1167                 element = block-&gt;cloneElementWithoutChildren(document);
1168             else
1169                 element = createDefaultParagraphElement(document);
1170             fillContainerFromString(*element, s);
1171         }
1172         fragment-&gt;appendChild(*element);
1173     }
1174     return fragment;
1175 }
1176 
1177 String documentTypeString(const Document&amp; document)
1178 {
1179     DocumentType* documentType = document.doctype();
1180     if (!documentType)
1181         return emptyString();
1182     return serializeFragment(*documentType, SerializedNodes::SubtreeIncludingNode);
1183 }
1184 
1185 String urlToMarkup(const URL&amp; url, const String&amp; title)
1186 {
1187     StringBuilder markup;
1188     markup.appendLiteral(&quot;&lt;a href=\&quot;&quot;);
1189     markup.append(url.string());
1190     markup.appendLiteral(&quot;\&quot;&gt;&quot;);
1191     MarkupAccumulator::appendCharactersReplacingEntities(markup, title, 0, title.length(), EntityMaskInPCDATA);
1192     markup.appendLiteral(&quot;&lt;/a&gt;&quot;);
1193     return markup.toString();
1194 }
1195 
1196 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createFragmentForInnerOuterHTML(Element&amp; contextElement, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1197 {
1198     auto* document = &amp;contextElement.document();
1199     if (contextElement.hasTagName(templateTag))
1200         document = &amp;document-&gt;ensureTemplateDocument();
1201     auto fragment = DocumentFragment::create(*document);
1202 
1203     if (document-&gt;isHTMLDocument()) {
1204         fragment-&gt;parseHTML(markup, &amp;contextElement, parserContentPolicy);
1205         return WTFMove(fragment);
1206     }
1207 
1208     bool wasValid = fragment-&gt;parseXML(markup, &amp;contextElement, parserContentPolicy);
1209     if (!wasValid)
1210         return Exception { SyntaxError };
1211     return WTFMove(fragment);
1212 }
1213 
1214 RefPtr&lt;DocumentFragment&gt; createFragmentForTransformToFragment(Document&amp; outputDoc, const String&amp; sourceString, const String&amp; sourceMIMEType)
1215 {
1216     RefPtr&lt;DocumentFragment&gt; fragment = outputDoc.createDocumentFragment();
1217 
1218     if (sourceMIMEType == &quot;text/html&quot;) {
1219         // As far as I can tell, there isn&#39;t a spec for how transformToFragment is supposed to work.
1220         // Based on the documentation I can find, it looks like we want to start parsing the fragment in the InBody insertion mode.
1221         // Unfortunately, that&#39;s an implementation detail of the parser.
1222         // We achieve that effect here by passing in a fake body element as context for the fragment.
1223         auto fakeBody = HTMLBodyElement::create(outputDoc);
1224         fragment-&gt;parseHTML(sourceString, fakeBody.ptr());
1225     } else if (sourceMIMEType == &quot;text/plain&quot;)
1226         fragment-&gt;parserAppendChild(Text::create(outputDoc, sourceString));
1227     else {
1228         bool successfulParse = fragment-&gt;parseXML(sourceString, 0);
1229         if (!successfulParse)
1230             return nullptr;
1231     }
1232 
1233     // FIXME: Do we need to mess with URLs here?
1234 
1235     return fragment;
1236 }
1237 
1238 Ref&lt;DocumentFragment&gt; createFragmentForImageAndURL(Document&amp; document, const String&amp; url)
1239 {
1240     auto imageElement = HTMLImageElement::create(document);
1241     imageElement-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, url);
1242 
1243     auto fragment = document.createDocumentFragment();
1244     fragment-&gt;appendChild(imageElement);
1245 
1246     return fragment;
1247 }
1248 
1249 static Vector&lt;Ref&lt;HTMLElement&gt;&gt; collectElementsToRemoveFromFragment(ContainerNode&amp; container)
1250 {
1251     Vector&lt;Ref&lt;HTMLElement&gt;&gt; toRemove;
1252     for (auto&amp; element : childrenOfType&lt;HTMLElement&gt;(container)) {
1253         if (is&lt;HTMLHtmlElement&gt;(element)) {
1254             toRemove.append(element);
1255             collectElementsToRemoveFromFragment(element);
1256             continue;
1257         }
1258         if (is&lt;HTMLHeadElement&gt;(element) || is&lt;HTMLBodyElement&gt;(element))
1259             toRemove.append(element);
1260     }
1261     return toRemove;
1262 }
1263 
1264 static void removeElementFromFragmentPreservingChildren(DocumentFragment&amp; fragment, HTMLElement&amp; element)
1265 {
1266     RefPtr&lt;Node&gt; nextChild;
1267     for (RefPtr&lt;Node&gt; child = element.firstChild(); child; child = nextChild) {
1268         nextChild = child-&gt;nextSibling();
1269         element.removeChild(*child);
1270         fragment.insertBefore(*child, &amp;element);
1271     }
1272     fragment.removeChild(element);
1273 }
1274 
1275 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; createContextualFragment(Element&amp; element, const String&amp; markup, ParserContentPolicy parserContentPolicy)
1276 {
1277     auto result = createFragmentForInnerOuterHTML(element, markup, parserContentPolicy);
1278     if (result.hasException())
1279         return result.releaseException();
1280 
1281     auto fragment = result.releaseReturnValue();
1282 
1283     // We need to pop &lt;html&gt; and &lt;body&gt; elements and remove &lt;head&gt; to
1284     // accommodate folks passing complete HTML documents to make the
1285     // child of an element.
1286     auto toRemove = collectElementsToRemoveFromFragment(fragment);
1287     for (auto&amp; element : toRemove)
1288         removeElementFromFragmentPreservingChildren(fragment, element);
1289 
1290     return WTFMove(fragment);
1291 }
1292 
1293 static inline bool hasOneChild(ContainerNode&amp; node)
1294 {
1295     Node* firstChild = node.firstChild();
1296     return firstChild &amp;&amp; !firstChild-&gt;nextSibling();
1297 }
1298 
1299 static inline bool hasOneTextChild(ContainerNode&amp; node)
1300 {
1301     return hasOneChild(node) &amp;&amp; node.firstChild()-&gt;isTextNode();
1302 }
1303 
1304 static inline bool hasMutationEventListeners(const Document&amp; document)
1305 {
1306     return document.hasListenerType(Document::DOMSUBTREEMODIFIED_LISTENER)
1307         || document.hasListenerType(Document::DOMNODEINSERTED_LISTENER)
1308         || document.hasListenerType(Document::DOMNODEREMOVED_LISTENER)
1309         || document.hasListenerType(Document::DOMNODEREMOVEDFROMDOCUMENT_LISTENER)
1310         || document.hasListenerType(Document::DOMCHARACTERDATAMODIFIED_LISTENER);
1311 }
1312 
1313 // We can use setData instead of replacing Text node as long as script can&#39;t observe the difference.
1314 static inline bool canUseSetDataOptimization(const Text&amp; containerChild, const ChildListMutationScope&amp; mutationScope)
1315 {
1316     bool authorScriptMayHaveReference = containerChild.refCount();
1317     return !authorScriptMayHaveReference &amp;&amp; !mutationScope.canObserve() &amp;&amp; !hasMutationEventListeners(containerChild.document());
1318 }
1319 
1320 ExceptionOr&lt;void&gt; replaceChildrenWithFragment(ContainerNode&amp; container, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
1321 {
1322     Ref&lt;ContainerNode&gt; containerNode(container);
1323     ChildListMutationScope mutation(containerNode);
1324 
1325     if (!fragment-&gt;firstChild()) {
1326         containerNode-&gt;removeChildren();
1327         return { };
1328     }
1329 
1330     auto* containerChild = containerNode-&gt;firstChild();
1331     if (containerChild &amp;&amp; !containerChild-&gt;nextSibling()) {
1332         if (is&lt;Text&gt;(*containerChild) &amp;&amp; hasOneTextChild(fragment) &amp;&amp; canUseSetDataOptimization(downcast&lt;Text&gt;(*containerChild), mutation)) {
1333             ASSERT(!fragment-&gt;firstChild()-&gt;refCount());
1334             downcast&lt;Text&gt;(*containerChild).setData(downcast&lt;Text&gt;(*fragment-&gt;firstChild()).data());
1335             return { };
1336         }
1337 
1338         return containerNode-&gt;replaceChild(fragment, *containerChild);
1339     }
1340 
1341     containerNode-&gt;removeChildren();
1342     return containerNode-&gt;appendChild(fragment);
1343 }
1344 
1345 }
    </pre>
  </body>
</html>