<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/EventNames.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventNames.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventNames.in.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/EventNames.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 19,14 ***</span>
   *
   */
  
  #pragma once
  
  #include &quot;ThreadGlobalData.h&quot;
  #include &lt;array&gt;
  #include &lt;functional&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomicString.h&gt;</span>
  
  namespace WebCore {
  
  #if !defined(ADDITIONAL_DOM_EVENT_NAMES_FOR_EACH)
  #define ADDITIONAL_DOM_EVENT_NAMES_FOR_EACH(macro)
<span class="line-new-header">--- 19,20 ---</span>
   *
   */
  
  #pragma once
  
<span class="line-added">+ #include &quot;Document.h&quot;</span>
<span class="line-added">+ #include &quot;Quirks.h&quot;</span>
  #include &quot;ThreadGlobalData.h&quot;
  #include &lt;array&gt;
  #include &lt;functional&gt;
<span class="line-modified">! #include &lt;wtf/text/AtomString.h&gt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added">+ #endif</span>
  
  namespace WebCore {
  
  #if !defined(ADDITIONAL_DOM_EVENT_NAMES_FOR_EACH)
  #define ADDITIONAL_DOM_EVENT_NAMES_FOR_EACH(macro)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,24 ***</span>
      macro(DOMNodeInsertedIntoDocument) \
      macro(DOMNodeRemoved) \
      macro(DOMNodeRemovedFromDocument) \
      macro(DOMSubtreeModified) \
      macro(abort) \
<span class="line-removed">-     macro(accessiblecontextmenu) \</span>
<span class="line-removed">-     macro(accessibleclick) \</span>
<span class="line-removed">-     macro(accessibledecrement) \</span>
<span class="line-removed">-     macro(accessibledismiss) \</span>
<span class="line-removed">-     macro(accessiblefocus) \</span>
<span class="line-removed">-     macro(accessibleincrement) \</span>
<span class="line-removed">-     macro(accessiblescrollintoview) \</span>
<span class="line-removed">-     macro(accessiblesetvalue) \</span>
<span class="line-removed">-     macro(accessibleselect) \</span>
      macro(activate) \
      macro(active) \
      macro(addsourcebuffer) \
      macro(addstream) \
      macro(addtrack) \
      macro(animationcancel) \
      macro(animationend) \
      macro(animationiteration) \
      macro(animationstart) \
      macro(audioend) \
<span class="line-new-header">--- 49,16 ---</span>
      macro(DOMNodeInsertedIntoDocument) \
      macro(DOMNodeRemoved) \
      macro(DOMNodeRemovedFromDocument) \
      macro(DOMSubtreeModified) \
      macro(abort) \
      macro(activate) \
      macro(active) \
      macro(addsourcebuffer) \
      macro(addstream) \
      macro(addtrack) \
<span class="line-added">+     macro(afterprint) \</span>
      macro(animationcancel) \
      macro(animationend) \
      macro(animationiteration) \
      macro(animationstart) \
      macro(audioend) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,10 ***</span>
<span class="line-new-header">--- 69,11 ---</span>
      macro(beforecopy) \
      macro(beforecut) \
      macro(beforeinput) \
      macro(beforeload) \
      macro(beforepaste) \
<span class="line-added">+     macro(beforeprint) \</span>
      macro(beforeunload) \
      macro(beginEvent) \
      macro(blocked) \
      macro(blur) \
      macro(boundary) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,11 ***</span>
<span class="line-new-header">--- 199,15 ---</span>
      macro(playing) \
      macro(pointerlockchange) \
      macro(pointerlockerror) \
      macro(pointercancel) \
      macro(pointerdown) \
<span class="line-added">+     macro(pointerenter) \</span>
<span class="line-added">+     macro(pointerleave) \</span>
      macro(pointermove) \
<span class="line-added">+     macro(pointerout) \</span>
<span class="line-added">+     macro(pointerover) \</span>
      macro(pointerup) \
      macro(popstate) \
      macro(previoustrack) \
      macro(progress) \
      macro(ratechange) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,11 ***</span>
      macro(webglcontextrestored) \
      macro(webkitAnimationEnd) \
      macro(webkitAnimationIteration) \
      macro(webkitAnimationStart) \
      macro(webkitBeforeTextInserted) \
<span class="line-removed">-     macro(webkitEditableContentChanged) \</span>
      macro(webkitTransitionEnd) \
      macro(webkitbeginfullscreen) \
      macro(webkitcurrentplaybacktargetiswirelesschanged) \
      macro(webkitendfullscreen) \
      macro(webkitfullscreenchange) \
<span class="line-new-header">--- 295,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,40 ***</span>
  
  struct EventNames {
      WTF_MAKE_NONCOPYABLE(EventNames); WTF_MAKE_FAST_ALLOCATED;
  
  public:
<span class="line-modified">! #define DOM_EVENT_NAMES_DECLARE(name) const AtomicString name##Event;</span>
      DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_DECLARE)
  #undef DOM_EVENT_NAMES_DECLARE
  
<span class="line-modified">!     // FIXME: The friend declaration to std::make_unique below does not work in windows port.</span>
      //
      // template&lt;class T, class... Args&gt;
<span class="line-modified">!     // friend typename std::_Unique_if&lt;T&gt;::_Single_object std::make_unique(Args&amp;&amp;...);</span>
      //
      // This create function should be deleted later and is only for keeping EventNames as private.
<span class="line-modified">!     // std::make_unique should be used instead.</span>
      //
      template&lt;class... Args&gt;
      static std::unique_ptr&lt;EventNames&gt; create(Args&amp;&amp;... args)
      {
          return std::unique_ptr&lt;EventNames&gt;(new EventNames(std::forward&lt;Args&gt;(args)...));
      }
  
      // FIXME: Inelegant to call these both event names and event types.
      // We should choose one term and stick to it.
<span class="line-modified">!     bool isWheelEventType(const AtomicString&amp; eventType) const;</span>
<span class="line-modified">!     bool isGestureEventType(const AtomicString&amp; eventType) const;</span>
<span class="line-modified">!     bool isTouchEventType(const AtomicString&amp; eventType) const;</span>
<span class="line-modified">!     bool isTouchScrollBlockingEventType(const AtomicString&amp; eventType) const;</span>
  #if ENABLE(GAMEPAD)
<span class="line-modified">!     bool isGamepadEventType(const AtomicString&amp; eventType) const;</span>
  #endif
  
<span class="line-modified">!     std::array&lt;std::reference_wrapper&lt;const AtomicString&gt;, 9&gt; touchAndPointerEventNames() const;</span>
<span class="line-modified">!     std::array&lt;std::reference_wrapper&lt;const AtomicString&gt;, 3&gt; gestureEventNames() const;</span>
  
  private:
      EventNames(); // Private to prevent accidental call to EventNames() instead of eventNames().
      friend class ThreadGlobalData; // Allow ThreadGlobalData to create the per-thread EventNames object.
  
<span class="line-new-header">--- 333,41 ---</span>
  
  struct EventNames {
      WTF_MAKE_NONCOPYABLE(EventNames); WTF_MAKE_FAST_ALLOCATED;
  
  public:
<span class="line-modified">! #define DOM_EVENT_NAMES_DECLARE(name) const AtomString name##Event;</span>
      DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_DECLARE)
  #undef DOM_EVENT_NAMES_DECLARE
  
<span class="line-modified">!     // FIXME: The friend declaration to makeUnique below does not work in windows port.</span>
      //
      // template&lt;class T, class... Args&gt;
<span class="line-modified">!     // friend typename std::_Unique_if&lt;T&gt;::_Single_object makeUnique(Args&amp;&amp;...);</span>
      //
      // This create function should be deleted later and is only for keeping EventNames as private.
<span class="line-modified">!     // makeUnique should be used instead.</span>
      //
      template&lt;class... Args&gt;
      static std::unique_ptr&lt;EventNames&gt; create(Args&amp;&amp;... args)
      {
          return std::unique_ptr&lt;EventNames&gt;(new EventNames(std::forward&lt;Args&gt;(args)...));
      }
  
      // FIXME: Inelegant to call these both event names and event types.
      // We should choose one term and stick to it.
<span class="line-modified">!     bool isWheelEventType(const AtomString&amp; eventType) const;</span>
<span class="line-modified">!     bool isGestureEventType(const AtomString&amp; eventType) const;</span>
<span class="line-modified">!     bool isTouchRelatedEventType(const Document&amp;, const AtomString&amp; eventType) const;</span>
<span class="line-modified">!     bool isTouchScrollBlockingEventType(const AtomString&amp; eventType) const;</span>
  #if ENABLE(GAMEPAD)
<span class="line-modified">!     bool isGamepadEventType(const AtomString&amp; eventType) const;</span>
  #endif
  
<span class="line-modified">!     std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 13&gt; touchRelatedEventNames() const;</span>
<span class="line-modified">!     std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 16&gt; extendedTouchRelatedEventNames() const;</span>
<span class="line-added">+     std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 3&gt; gestureEventNames() const;</span>
  
  private:
      EventNames(); // Private to prevent accidental call to EventNames() instead of eventNames().
      friend class ThreadGlobalData; // Allow ThreadGlobalData to create the per-thread EventNames object.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,53 ***</span>
  inline const EventNames&amp; eventNames()
  {
      return threadGlobalData().eventNames();
  }
  
<span class="line-modified">! inline bool EventNames::isGestureEventType(const AtomicString&amp; eventType) const</span>
  {
      return eventType == gesturestartEvent || eventType == gesturechangeEvent || eventType == gestureendEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isTouchScrollBlockingEventType(const AtomicString&amp; eventType) const</span>
  {
      return eventType == touchstartEvent
          || eventType == touchmoveEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isTouchEventType(const AtomicString&amp; eventType) const</span>
  {
      return eventType == touchstartEvent
          || eventType == touchmoveEvent
          || eventType == touchendEvent
          || eventType == touchcancelEvent
          || eventType == touchforcechangeEvent
          || eventType == pointerdownEvent
          || eventType == pointermoveEvent
          || eventType == pointerupEvent
          || eventType == pointercancelEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isWheelEventType(const AtomicString&amp; eventType) const</span>
  {
      return eventType == wheelEvent
          || eventType == mousewheelEvent;
  }
  
<span class="line-modified">! inline std::array&lt;std::reference_wrapper&lt;const AtomicString&gt;, 9&gt; EventNames::touchAndPointerEventNames() const</span>
  {
<span class="line-modified">!     return { { touchstartEvent, touchmoveEvent, touchendEvent, touchcancelEvent, touchforcechangeEvent, pointerdownEvent, pointermoveEvent, pointerupEvent, pointercancelEvent } };</span>
  }
  
<span class="line-modified">! inline std::array&lt;std::reference_wrapper&lt;const AtomicString&gt;, 3&gt; EventNames::gestureEventNames() const</span>
  {
      return { { gesturestartEvent, gesturechangeEvent, gestureendEvent } };
  }
  
  #if ENABLE(GAMEPAD)
  
<span class="line-modified">! inline bool EventNames::isGamepadEventType(const AtomicString&amp; eventType) const</span>
  {
      return eventType == gamepadconnectedEvent
          || eventType == gamepaddisconnectedEvent;
  }
  
<span class="line-new-header">--- 379,69 ---</span>
  inline const EventNames&amp; eventNames()
  {
      return threadGlobalData().eventNames();
  }
  
<span class="line-modified">! inline bool EventNames::isGestureEventType(const AtomString&amp; eventType) const</span>
  {
      return eventType == gesturestartEvent || eventType == gesturechangeEvent || eventType == gestureendEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isTouchScrollBlockingEventType(const AtomString&amp; eventType) const</span>
  {
      return eventType == touchstartEvent
          || eventType == touchmoveEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isTouchRelatedEventType(const Document&amp; document, const AtomString&amp; eventType) const</span>
  {
<span class="line-added">+ #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-added">+     if (document.quirks().shouldDispatchSimulatedMouseEvents()) {</span>
<span class="line-added">+         if (eventType == mousedownEvent || eventType == mousemoveEvent || eventType == mouseupEvent)</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     UNUSED_PARAM(document);</span>
      return eventType == touchstartEvent
          || eventType == touchmoveEvent
          || eventType == touchendEvent
          || eventType == touchcancelEvent
          || eventType == touchforcechangeEvent
<span class="line-added">+         || eventType == pointeroverEvent</span>
<span class="line-added">+         || eventType == pointerenterEvent</span>
          || eventType == pointerdownEvent
          || eventType == pointermoveEvent
          || eventType == pointerupEvent
<span class="line-added">+         || eventType == pointeroutEvent</span>
<span class="line-added">+         || eventType == pointerleaveEvent</span>
          || eventType == pointercancelEvent;
  }
  
<span class="line-modified">! inline bool EventNames::isWheelEventType(const AtomString&amp; eventType) const</span>
  {
      return eventType == wheelEvent
          || eventType == mousewheelEvent;
  }
  
<span class="line-modified">! inline std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 13&gt; EventNames::touchRelatedEventNames() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return { { touchstartEvent, touchmoveEvent, touchendEvent, touchcancelEvent, touchforcechangeEvent, pointeroverEvent, pointerenterEvent, pointerdownEvent, pointermoveEvent, pointerupEvent, pointeroutEvent, pointerleaveEvent, pointercancelEvent } };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 16&gt; EventNames::extendedTouchRelatedEventNames() const</span>
  {
<span class="line-modified">!     return { { touchstartEvent, touchmoveEvent, touchendEvent, touchcancelEvent, touchforcechangeEvent, pointeroverEvent, pointerenterEvent, pointerdownEvent, pointermoveEvent, pointerupEvent, pointeroutEvent, pointerleaveEvent, pointercancelEvent, mousedownEvent, mousemoveEvent, mouseupEvent } };</span>
  }
  
<span class="line-modified">! inline std::array&lt;std::reference_wrapper&lt;const AtomString&gt;, 3&gt; EventNames::gestureEventNames() const</span>
  {
      return { { gesturestartEvent, gesturechangeEvent, gestureendEvent } };
  }
  
  #if ENABLE(GAMEPAD)
  
<span class="line-modified">! inline bool EventNames::isGamepadEventType(const AtomString&amp; eventType) const</span>
  {
      return eventType == gamepadconnectedEvent
          || eventType == gamepaddisconnectedEvent;
  }
  
</pre>
<center><a href="EventNames.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventNames.in.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>