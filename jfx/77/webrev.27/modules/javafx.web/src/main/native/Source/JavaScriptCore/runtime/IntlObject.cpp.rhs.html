<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
  3  * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
<a name="1" id="anc1"></a><span class="line-modified">  4  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25  * THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;IntlObject.h&quot;
 30 
 31 #if ENABLE(INTL)
 32 
 33 #include &quot;Error.h&quot;
 34 #include &quot;FunctionPrototype.h&quot;
 35 #include &quot;IntlCanonicalizeLanguage.h&quot;
 36 #include &quot;IntlCollatorConstructor.h&quot;
 37 #include &quot;IntlCollatorPrototype.h&quot;
 38 #include &quot;IntlDateTimeFormatConstructor.h&quot;
 39 #include &quot;IntlDateTimeFormatPrototype.h&quot;
 40 #include &quot;IntlNumberFormatConstructor.h&quot;
 41 #include &quot;IntlNumberFormatPrototype.h&quot;
 42 #include &quot;IntlPluralRulesConstructor.h&quot;
 43 #include &quot;IntlPluralRulesPrototype.h&quot;
 44 #include &quot;JSCInlines.h&quot;
 45 #include &quot;JSCJSValueInlines.h&quot;
 46 #include &quot;Lookup.h&quot;
 47 #include &quot;ObjectPrototype.h&quot;
 48 #include &quot;Options.h&quot;
 49 #include &lt;unicode/uloc.h&gt;
 50 #include &lt;unicode/unumsys.h&gt;
 51 #include &lt;wtf/Assertions.h&gt;
 52 #include &lt;wtf/Language.h&gt;
 53 #include &lt;wtf/NeverDestroyed.h&gt;
 54 #include &lt;wtf/text/StringBuilder.h&gt;
 55 
 56 namespace JSC {
 57 
 58 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
 59 
 60 static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState*);
 61 
 62 static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
 63 {
 64     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 65     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 66     return IntlCollatorConstructor::create(vm, IntlCollatorConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlCollatorPrototype*&gt;(globalObject-&gt;collatorStructure()-&gt;storedPrototypeObject()));
 67 }
 68 
 69 static JSValue createNumberFormatConstructor(VM&amp; vm, JSObject* object)
 70 {
 71     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 72     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 73     return IntlNumberFormatConstructor::create(vm, IntlNumberFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlNumberFormatPrototype*&gt;(globalObject-&gt;numberFormatStructure()-&gt;storedPrototypeObject()));
 74 }
 75 
 76 static JSValue createDateTimeFormatConstructor(VM&amp; vm, JSObject* object)
 77 {
 78     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 79     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 80     return IntlDateTimeFormatConstructor::create(vm, IntlDateTimeFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlDateTimeFormatPrototype*&gt;(globalObject-&gt;dateTimeFormatStructure()-&gt;storedPrototypeObject()));
 81 }
 82 
 83 static JSValue createPluralRulesConstructor(VM&amp; vm, JSObject* object)
 84 {
 85     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
 86     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
 87     return IntlPluralRulesConstructor::create(vm, IntlPluralRulesConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlPluralRulesPrototype*&gt;(globalObject-&gt;pluralRulesStructure()-&gt;storedPrototypeObject()));
 88 }
 89 
 90 }
 91 
 92 #include &quot;IntlObject.lut.h&quot;
 93 
 94 namespace JSC {
 95 
 96 /* Source for IntlObject.lut.h
 97 @begin intlObjectTable
 98   getCanonicalLocales   intlObjectFuncGetCanonicalLocales            DontEnum|Function 1
 99   Collator              createCollatorConstructor                    DontEnum|PropertyCallback
100   DateTimeFormat        createDateTimeFormatConstructor              DontEnum|PropertyCallback
101   NumberFormat          createNumberFormatConstructor                DontEnum|PropertyCallback
<a name="2" id="anc2"></a><span class="line-added">102   PluralRules           createPluralRulesConstructor                 DontEnum|PropertyCallback</span>
103 @end
104 */
105 
106 struct MatcherResult {
107     String locale;
108     String extension;
109     size_t extensionIndex { 0 };
110 };
111 
112 const ClassInfo IntlObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, &amp;intlObjectTable, nullptr, CREATE_METHOD_TABLE(IntlObject) };
113 
114 IntlObject::IntlObject(VM&amp; vm, Structure* structure)
115     : JSNonFinalObject(vm, structure)
116 {
117 }
118 
119 IntlObject* IntlObject::create(VM&amp; vm, Structure* structure)
120 {
121     IntlObject* object = new (NotNull, allocateCell&lt;IntlObject&gt;(vm.heap)) IntlObject(vm, structure);
122     object-&gt;finishCreation(vm);
123     return object;
124 }
125 
<a name="3" id="anc3"></a>










126 Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
127 {
128     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
129 }
130 
131 String convertICULocaleToBCP47LanguageTag(const char* localeID)
132 {
133     UErrorCode status = U_ZERO_ERROR;
134     Vector&lt;char, 32&gt; buffer(32);
135     auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
136     if (status == U_BUFFER_OVERFLOW_ERROR) {
137         buffer.grow(length);
138         status = U_ZERO_ERROR;
139         uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
140     }
141     if (!U_FAILURE(status))
142         return String(buffer.data(), length);
143     return String();
144 }
145 
146 bool intlBooleanOption(ExecState&amp; state, JSValue options, PropertyName property, bool&amp; usesFallback)
147 {
148     // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
149     // https://tc39.github.io/ecma402/#sec-getoption
150 
151     VM&amp; vm = state.vm();
152     auto scope = DECLARE_THROW_SCOPE(vm);
153 
154     JSObject* opts = options.toObject(&amp;state);
155     RETURN_IF_EXCEPTION(scope, false);
156 
157     JSValue value = opts-&gt;get(&amp;state, property);
158     RETURN_IF_EXCEPTION(scope, false);
159 
160     if (!value.isUndefined()) {
161         bool booleanValue = value.toBoolean(&amp;state);
162         usesFallback = false;
163         return booleanValue;
164     }
165 
166     // Because fallback can be undefined, we let the caller handle it instead.
167     usesFallback = true;
168     return false;
169 }
170 
171 String intlStringOption(ExecState&amp; state, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)
172 {
173     // GetOption (options, property, type=&quot;string&quot;, values, fallback)
174     // https://tc39.github.io/ecma402/#sec-getoption
175 
176     VM&amp; vm = state.vm();
177     auto scope = DECLARE_THROW_SCOPE(vm);
178 
179     JSObject* opts = options.toObject(&amp;state);
180     RETURN_IF_EXCEPTION(scope, String());
181 
182     JSValue value = opts-&gt;get(&amp;state, property);
183     RETURN_IF_EXCEPTION(scope, String());
184 
185     if (!value.isUndefined()) {
186         String stringValue = value.toWTFString(&amp;state);
187         RETURN_IF_EXCEPTION(scope, String());
188 
189         if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
190             throwException(&amp;state, scope, createRangeError(&amp;state, notFound));
191             return { };
192         }
193         return stringValue;
194     }
195 
196     return fallback;
197 }
198 
199 unsigned intlNumberOption(ExecState&amp; state, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
200 {
201     // GetNumberOption (options, property, minimum, maximum, fallback)
202     // https://tc39.github.io/ecma402/#sec-getnumberoption
203 
204     VM&amp; vm = state.vm();
205     auto scope = DECLARE_THROW_SCOPE(vm);
206 
207     JSObject* opts = options.toObject(&amp;state);
208     RETURN_IF_EXCEPTION(scope, 0);
209 
210     JSValue value = opts-&gt;get(&amp;state, property);
211     RETURN_IF_EXCEPTION(scope, 0);
212 
213     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(state, value, property, minimum, maximum, fallback));
214 }
215 
216 unsigned intlDefaultNumberOption(ExecState&amp; state, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
217 {
218     // DefaultNumberOption (value, minimum, maximum, fallback)
219     // https://tc39.github.io/ecma402/#sec-defaultnumberoption
220 
221     VM&amp; vm = state.vm();
222     auto scope = DECLARE_THROW_SCOPE(vm);
223 
224     if (!value.isUndefined()) {
225         double doubleValue = value.toNumber(&amp;state);
226         RETURN_IF_EXCEPTION(scope, 0);
227 
228         if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
229             throwException(&amp;state, scope, createRangeError(&amp;state, *property.publicName() + &quot; is out of range&quot;));
230             return 0;
231         }
232         return static_cast&lt;unsigned&gt;(doubleValue);
233     }
234     return fallback;
235 }
236 
237 static String privateUseLangTag(const Vector&lt;String&gt;&amp; parts, size_t startIndex)
238 {
239     size_t numParts = parts.size();
240     size_t currentIndex = startIndex;
241 
242     // Check for privateuse.
243     // privateuse = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
244     StringBuilder privateuse;
245     while (currentIndex &lt; numParts) {
246         const String&amp; singleton = parts[currentIndex];
247         unsigned singletonLength = singleton.length();
248         bool isValid = (singletonLength == 1 &amp;&amp; (singleton == &quot;x&quot; || singleton == &quot;X&quot;));
249         if (!isValid)
250             break;
251 
252         if (currentIndex != startIndex)
253             privateuse.append(&#39;-&#39;);
254 
255         ++currentIndex;
256         unsigned numExtParts = 0;
257         privateuse.append(&#39;x&#39;);
258         while (currentIndex &lt; numParts) {
259             const String&amp; extPart = parts[currentIndex];
260             unsigned extPartLength = extPart.length();
261 
262             bool isValid = (extPartLength &gt;= 1 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
263             if (!isValid)
264                 break;
265 
266             ++currentIndex;
267             ++numExtParts;
268             privateuse.append(&#39;-&#39;);
269             privateuse.append(extPart.convertToASCIILowercase());
270         }
271 
272         // Requires at least one production.
273         if (!numExtParts)
274             return String();
275     }
276 
277     // Leftovers makes it invalid.
278     if (currentIndex &lt; numParts)
279         return String();
280 
281     return privateuse.toString();
282 }
283 
284 static String preferredLanguage(const String&amp; language)
285 {
286     auto preferred = intlPreferredLanguageTag(language);
287     if (!preferred.isNull())
288         return preferred;
289     return language;
290 }
291 
292 static String preferredRegion(const String&amp; region)
293 {
294     auto preferred = intlPreferredRegionTag(region);
295     if (!preferred.isNull())
296         return preferred;
297     return region;
298 
299 }
300 
301 static String canonicalLangTag(const Vector&lt;String&gt;&amp; parts)
302 {
303     ASSERT(!parts.isEmpty());
304 
305     // Follows the grammar at https://www.rfc-editor.org/rfc/bcp/bcp47.txt
306     // langtag = language [&quot;-&quot; script] [&quot;-&quot; region] *(&quot;-&quot; variant) *(&quot;-&quot; extension) [&quot;-&quot; privateuse]
307 
308     size_t numParts = parts.size();
309     // Check for language.
310     // language = 2*3ALPHA [&quot;-&quot; extlang] / 4ALPHA / 5*8ALPHA
311     size_t currentIndex = 0;
312     const String&amp; language = parts[currentIndex];
313     unsigned languageLength = language.length();
314     bool canHaveExtlang = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 3;
315     bool isValidLanguage = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 8 &amp;&amp; language.isAllSpecialCharacters&lt;isASCIIAlpha&gt;();
316     if (!isValidLanguage)
317         return String();
318 
319     ++currentIndex;
320     StringBuilder canonical;
321 
322     const String langtag = preferredLanguage(language.convertToASCIILowercase());
323     canonical.append(langtag);
324 
325     // Check for extlang.
326     // extlang = 3ALPHA *2(&quot;-&quot; 3ALPHA)
327     if (canHaveExtlang) {
328         for (unsigned times = 0; times &lt; 3 &amp;&amp; currentIndex &lt; numParts; ++times) {
329             const String&amp; extlang = parts[currentIndex];
330             unsigned extlangLength = extlang.length();
331             if (extlangLength == 3 &amp;&amp; extlang.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
332                 ++currentIndex;
333                 auto extlangLower = extlang.convertToASCIILowercase();
334                 if (!times &amp;&amp; intlPreferredExtlangTag(extlangLower) == langtag) {
335                     canonical.clear();
336                     canonical.append(extlangLower);
337                     continue;
338                 }
339                 canonical.append(&#39;-&#39;);
340                 canonical.append(extlangLower);
341             } else
342                 break;
343         }
344     }
345 
346     // Check for script.
347     // script = 4ALPHA
348     if (currentIndex &lt; numParts) {
349         const String&amp; script = parts[currentIndex];
350         unsigned scriptLength = script.length();
351         if (scriptLength == 4 &amp;&amp; script.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
352             ++currentIndex;
353             canonical.append(&#39;-&#39;);
354             canonical.append(toASCIIUpper(script[0]));
355             canonical.append(script.substring(1, 3).convertToASCIILowercase());
356         }
357     }
358 
359     // Check for region.
360     // region = 2ALPHA / 3DIGIT
361     if (currentIndex &lt; numParts) {
362         const String&amp; region = parts[currentIndex];
363         unsigned regionLength = region.length();
364         bool isValidRegion = (
365             (regionLength == 2 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIAlpha&gt;())
366             || (regionLength == 3 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIDigit&gt;())
367         );
368         if (isValidRegion) {
369             ++currentIndex;
370             canonical.append(&#39;-&#39;);
371             canonical.append(preferredRegion(region.convertToASCIIUppercase()));
372         }
373     }
374 
375     // Check for variant.
376     // variant = 5*8alphanum / (DIGIT 3alphanum)
377     HashSet&lt;String&gt; subtags;
378     while (currentIndex &lt; numParts) {
379         const String&amp; variant = parts[currentIndex];
380         unsigned variantLength = variant.length();
381         bool isValidVariant = (
382             (variantLength &gt;= 5 &amp;&amp; variantLength &lt;= 8 &amp;&amp; variant.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
383             || (variantLength == 4 &amp;&amp; isASCIIDigit(variant[0]) &amp;&amp; variant.substring(1, 3).isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
384         );
385         if (!isValidVariant)
386             break;
387 
388         // Cannot include duplicate subtags (case insensitive).
389         String lowerVariant = variant.convertToASCIILowercase();
390         if (!subtags.add(lowerVariant).isNewEntry)
391             return String();
392 
393         ++currentIndex;
394 
395         // Reordering variant subtags is not required in the spec.
396         canonical.append(&#39;-&#39;);
397         canonical.append(lowerVariant);
398     }
399 
400     // Check for extension.
401     // extension = singleton 1*(&quot;-&quot; (2*8alphanum))
402     // singleton = alphanum except x or X
403     subtags.clear();
404     Vector&lt;String&gt; extensions;
405     while (currentIndex &lt; numParts) {
406         const String&amp; possibleSingleton = parts[currentIndex];
407         unsigned singletonLength = possibleSingleton.length();
408         bool isValidSingleton = (singletonLength == 1 &amp;&amp; possibleSingleton != &quot;x&quot; &amp;&amp; possibleSingleton != &quot;X&quot; &amp;&amp; isASCIIAlphanumeric(possibleSingleton[0]));
409         if (!isValidSingleton)
410             break;
411 
412         // Cannot include duplicate singleton (case insensitive).
413         String singleton = possibleSingleton.convertToASCIILowercase();
414         if (!subtags.add(singleton).isNewEntry)
415             return String();
416 
417         ++currentIndex;
418         int numExtParts = 0;
419         StringBuilder extension;
420         extension.append(singleton);
421         while (currentIndex &lt; numParts) {
422             const String&amp; extPart = parts[currentIndex];
423             unsigned extPartLength = extPart.length();
424 
425             bool isValid = (extPartLength &gt;= 2 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
426             if (!isValid)
427                 break;
428 
429             ++currentIndex;
430             ++numExtParts;
431             extension.append(&#39;-&#39;);
432             extension.append(extPart.convertToASCIILowercase());
433         }
434 
435         // Requires at least one production.
436         if (!numExtParts)
437             return String();
438 
439         extensions.append(extension.toString());
440     }
441 
442     // Add extensions to canonical sorted by singleton.
443     std::sort(
444         extensions.begin(),
445         extensions.end(),
446         [] (const String&amp; a, const String&amp; b) -&gt; bool {
447             return a[0] &lt; b[0];
448         }
449     );
450     size_t numExtenstions = extensions.size();
451     for (size_t i = 0; i &lt; numExtenstions; ++i) {
452         canonical.append(&#39;-&#39;);
453         canonical.append(extensions[i]);
454     }
455 
456     // Check for privateuse.
457     if (currentIndex &lt; numParts) {
458         String privateuse = privateUseLangTag(parts, currentIndex);
459         if (privateuse.isNull())
460             return String();
461         canonical.append(&#39;-&#39;);
462         canonical.append(privateuse);
463     }
464 
465     const String tag = canonical.toString();
466     const String preferred = intlRedundantLanguageTag(tag);
467     if (!preferred.isNull())
468         return preferred;
469     return tag;
470 }
471 
472 static String canonicalizeLanguageTag(const String&amp; locale)
473 {
474     // IsStructurallyValidLanguageTag (locale)
475     // CanonicalizeLanguageTag (locale)
476     // These are done one after another in CanonicalizeLocaleList, so they are combined here to reduce duplication.
477     // https://www.rfc-editor.org/rfc/bcp/bcp47.txt
478 
479     // Language-Tag = langtag / privateuse / grandfathered
480     String grandfather = intlGrandfatheredLanguageTag(locale.convertToASCIILowercase());
481     if (!grandfather.isNull())
482         return grandfather;
483 
484     Vector&lt;String&gt; parts = locale.splitAllowingEmptyEntries(&#39;-&#39;);
485     if (!parts.isEmpty()) {
486         String langtag = canonicalLangTag(parts);
487         if (!langtag.isNull())
488             return langtag;
489 
490         String privateuse = privateUseLangTag(parts, 0);
491         if (!privateuse.isNull())
492             return privateuse;
493     }
494 
495     return String();
496 }
497 
498 Vector&lt;String&gt; canonicalizeLocaleList(ExecState&amp; state, JSValue locales)
499 {
500     // CanonicalizeLocaleList (locales)
501     // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
502 
503     VM&amp; vm = state.vm();
504     auto scope = DECLARE_THROW_SCOPE(vm);
505 
506     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);
507     Vector&lt;String&gt; seen;
508 
509     if (locales.isUndefined())
510         return seen;
511 
512     JSObject* localesObject;
513     if (locales.isString()) {
514         JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
515         if (!localesArray) {
516             throwOutOfMemoryError(&amp;state, scope);
517             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
518         }
519         localesArray-&gt;push(&amp;state, locales);
520         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
521 
522         localesObject = localesArray;
523     } else {
524         localesObject = locales.toObject(&amp;state);
525         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
526     }
527 
528     // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
529     JSValue lengthProperty = localesObject-&gt;get(&amp;state, vm.propertyNames-&gt;length);
530     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
531 
532     double length = lengthProperty.toLength(&amp;state);
533     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
534 
535     HashSet&lt;String&gt; seenSet;
536     for (double k = 0; k &lt; length; ++k) {
537         bool kPresent = localesObject-&gt;hasProperty(&amp;state, k);
538         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
539 
540         if (kPresent) {
541             JSValue kValue = localesObject-&gt;get(&amp;state, k);
542             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
543 
544             if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
545                 throwTypeError(&amp;state, scope, &quot;locale value must be a string or object&quot;_s);
546                 return Vector&lt;String&gt;();
547             }
548 
549             JSString* tag = kValue.toString(&amp;state);
550             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
551 
<a name="4" id="anc4"></a><span class="line-modified">552             auto tagValue = tag-&gt;value(&amp;state);</span>
<span class="line-added">553             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());</span>
<span class="line-added">554 </span>
<span class="line-added">555             String canonicalizedTag = canonicalizeLanguageTag(tagValue);</span>
556             if (canonicalizedTag.isNull()) {
<a name="5" id="anc5"></a><span class="line-modified">557                 throwException(&amp;state, scope, createRangeError(&amp;state, &quot;invalid language tag: &quot; + tagValue));</span>
558                 return Vector&lt;String&gt;();
559             }
560 
561             if (seenSet.add(canonicalizedTag).isNewEntry)
562                 seen.append(canonicalizedTag);
563         }
564     }
565 
566     return seen;
567 }
568 
569 String bestAvailableLocale(const HashSet&lt;String&gt;&amp; availableLocales, const String&amp; locale)
570 {
571     // BestAvailableLocale (availableLocales, locale)
572     // https://tc39.github.io/ecma402/#sec-bestavailablelocale
573 
574     String candidate = locale;
575     while (!candidate.isEmpty()) {
576         if (availableLocales.contains(candidate))
577             return candidate;
578 
579         size_t pos = candidate.reverseFind(&#39;-&#39;);
580         if (pos == notFound)
581             return String();
582 
583         if (pos &gt;= 2 &amp;&amp; candidate[pos - 2] == &#39;-&#39;)
584             pos -= 2;
585 
586         candidate = candidate.substring(0, pos);
587     }
588 
589     return String();
590 }
591 
592 String defaultLocale(ExecState&amp; state)
593 {
594     // DefaultLocale ()
595     // https://tc39.github.io/ecma402/#sec-defaultlocale
596 
597     // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
598     // be determined by WebCore-specific logic like some WK settings. Usually this will return the
599     // same thing as userPreferredLanguages()[0].
600     VM&amp; vm = state.vm();
601     if (auto defaultLanguage = state.jsCallee()-&gt;globalObject(vm)-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {
602         String locale = canonicalizeLanguageTag(defaultLanguage());
603         if (!locale.isEmpty())
604             return locale;
605     }
606 
607     Vector&lt;String&gt; languages = userPreferredLanguages();
608     for (const auto&amp; language : languages) {
609         String locale = canonicalizeLanguageTag(language);
610         if (!locale.isEmpty())
611             return locale;
612     }
613 
614     // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
615     // has configured some other language, but being wrong is better than crashing.
616     String locale = convertICULocaleToBCP47LanguageTag(uloc_getDefault());
617     if (!locale.isEmpty())
618         return locale;
619 
620     return &quot;en&quot;_s;
621 }
622 
623 String removeUnicodeLocaleExtension(const String&amp; locale)
624 {
625     Vector&lt;String&gt; parts = locale.split(&#39;-&#39;);
626     StringBuilder builder;
627     size_t partsSize = parts.size();
628     bool atPrivate = false;
629     if (partsSize &gt; 0)
630         builder.append(parts[0]);
631     for (size_t p = 1; p &lt; partsSize; ++p) {
632         if (parts[p] == &quot;x&quot;)
633             atPrivate = true;
634         if (!atPrivate &amp;&amp; parts[p] == &quot;u&quot; &amp;&amp; p + 1 &lt; partsSize) {
635             // Skip the u- and anything that follows until another singleton.
636             // While the next part is part of the unicode extension, skip it.
637             while (p + 1 &lt; partsSize &amp;&amp; parts[p + 1].length() &gt; 1)
638                 ++p;
639         } else {
640             builder.append(&#39;-&#39;);
641             builder.append(parts[p]);
642         }
643     }
644     return builder.toString();
645 }
646 
647 static MatcherResult lookupMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
648 {
649     // LookupMatcher (availableLocales, requestedLocales)
650     // https://tc39.github.io/ecma402/#sec-lookupmatcher
651 
652     String locale;
653     String noExtensionsLocale;
654     String availableLocale;
655     for (size_t i = 0; i &lt; requestedLocales.size() &amp;&amp; availableLocale.isNull(); ++i) {
656         locale = requestedLocales[i];
657         noExtensionsLocale = removeUnicodeLocaleExtension(locale);
658         availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
659     }
660 
661     MatcherResult result;
662     if (!availableLocale.isEmpty()) {
663         result.locale = availableLocale;
664         if (locale != noExtensionsLocale) {
665             size_t extensionIndex = locale.find(&quot;-u-&quot;);
666             RELEASE_ASSERT(extensionIndex != notFound);
667 
668             size_t extensionLength = locale.length() - extensionIndex;
669             size_t end = extensionIndex + 3;
670             while (end &lt; locale.length()) {
671                 end = locale.find(&#39;-&#39;, end);
672                 if (end == notFound)
673                     break;
674                 if (end + 2 &lt; locale.length() &amp;&amp; locale[end + 2] == &#39;-&#39;) {
675                     extensionLength = end - extensionIndex;
676                     break;
677                 }
678                 end++;
679             }
680             result.extension = locale.substring(extensionIndex, extensionLength);
681             result.extensionIndex = extensionIndex;
682         }
683     } else
684         result.locale = defaultLocale(state);
685     return result;
686 }
687 
688 static MatcherResult bestFitMatcher(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
689 {
690     // BestFitMatcher (availableLocales, requestedLocales)
691     // https://tc39.github.io/ecma402/#sec-bestfitmatcher
692 
693     // FIXME: Implement something better than lookup.
694     return lookupMatcher(state, availableLocales, requestedLocales);
695 }
696 
697 static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
698 {
699     // UnicodeExtensionSubtags (extension)
700     // https://tc39.github.io/ecma402/#sec-unicodeextensionsubtags
701 
702     auto extensionLength = extension.length();
703     if (extensionLength &lt; 3)
704         return;
705 
706     size_t subtagStart = 3; // Skip initial -u-.
707     size_t valueStart = 3;
708     bool isLeading = true;
709     for (size_t index = subtagStart; index &lt; extensionLength; ++index) {
710         if (extension[index] == &#39;-&#39;) {
711             if (index - subtagStart == 2) {
712                 // Tag is a key, first append prior key&#39;s value if there is one.
713                 if (subtagStart - valueStart &gt; 1)
714                     subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
715                 subtags.append(extension.substring(subtagStart, index - subtagStart));
716                 valueStart = index + 1;
717                 isLeading = false;
718             } else if (isLeading) {
719                 // Leading subtags before first key.
720                 subtags.append(extension.substring(subtagStart, index - subtagStart));
721                 valueStart = index + 1;
722             }
723             subtagStart = index + 1;
724         }
725     }
726     if (extensionLength - subtagStart == 2) {
727         // Trailing an extension key, first append prior key&#39;s value if there is one.
728         if (subtagStart - valueStart &gt; 1)
729             subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
730         valueStart = subtagStart;
731     }
732     // Append final key&#39;s value.
733     subtags.append(extension.substring(valueStart, extensionLength - valueStart));
734 }
735 
736 HashMap&lt;String, String&gt; resolveLocale(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))
737 {
738     // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
739     // https://tc39.github.io/ecma402/#sec-resolvelocale
740 
741     const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
742     MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
743         ? lookupMatcher(state, availableLocales, requestedLocales)
744         : bestFitMatcher(state, availableLocales, requestedLocales);
745 
746     String foundLocale = matcherResult.locale;
747 
748     Vector&lt;String&gt; extensionSubtags;
749     if (!matcherResult.extension.isNull())
750         unicodeExtensionSubTags(matcherResult.extension, extensionSubtags);
751 
752     HashMap&lt;String, String&gt; result;
753     result.add(&quot;dataLocale&quot;_s, foundLocale);
754 
755     String supportedExtension = &quot;-u&quot;_s;
756     for (size_t keyIndex = 0; keyIndex &lt; relevantExtensionKeyCount; ++keyIndex) {
757         const char* key = relevantExtensionKeys[keyIndex];
758         Vector&lt;String&gt; keyLocaleData = localeData(foundLocale, keyIndex);
759         ASSERT(!keyLocaleData.isEmpty());
760 
761         String value = keyLocaleData[0];
762         String supportedExtensionAddition;
763 
764         if (!extensionSubtags.isEmpty()) {
765             size_t keyPos = extensionSubtags.find(key);
766             if (keyPos != notFound) {
767                 if (keyPos + 1 &lt; extensionSubtags.size() &amp;&amp; extensionSubtags[keyPos + 1].length() &gt; 2) {
768                     const String&amp; requestedValue = extensionSubtags[keyPos + 1];
769                     if (keyLocaleData.contains(requestedValue)) {
770                         value = requestedValue;
771                         supportedExtensionAddition = makeString(&#39;-&#39;, key, &#39;-&#39;, value);
772                     }
773                 } else if (keyLocaleData.contains(static_cast&lt;String&gt;(&quot;true&quot;_s))) {
774                     value = &quot;true&quot;_s;
775                 }
776             }
777         }
778 
779         HashMap&lt;String, String&gt;::const_iterator iterator = options.find(key);
780         if (iterator != options.end()) {
781             const String&amp; optionsValue = iterator-&gt;value;
782             // Undefined should not get added to the options, it won&#39;t displace the extension.
783             // Null will remove the extension.
784             if ((optionsValue.isNull() || keyLocaleData.contains(optionsValue)) &amp;&amp; optionsValue != value) {
785                 value = optionsValue;
786                 supportedExtensionAddition = String();
787             }
788         }
789         result.add(key, value);
790         supportedExtension.append(supportedExtensionAddition);
791     }
792 
793     if (supportedExtension.length() &gt; 2) {
794         String preExtension = foundLocale.substring(0, matcherResult.extensionIndex);
795         String postExtension = foundLocale.substring(matcherResult.extensionIndex);
796         foundLocale = preExtension + supportedExtension + postExtension;
797     }
798 
799     result.add(&quot;locale&quot;_s, foundLocale);
800     return result;
801 }
802 
803 static JSArray* lookupSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
804 {
805     // LookupSupportedLocales (availableLocales, requestedLocales)
806     // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
807 
808     VM&amp; vm = state.vm();
809     auto scope = DECLARE_THROW_SCOPE(vm);
810 
811     size_t len = requestedLocales.size();
812     JSGlobalObject* globalObject = state.jsCallee()-&gt;globalObject(vm);
813     JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
814     if (!subset) {
815         throwOutOfMemoryError(&amp;state, scope);
816         return nullptr;
817     }
818 
819     unsigned index = 0;
820     for (size_t k = 0; k &lt; len; ++k) {
821         const String&amp; locale = requestedLocales[k];
822         String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
823         String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
824         if (!availableLocale.isNull()) {
<a name="6" id="anc6"></a><span class="line-modified">825             subset-&gt;putDirectIndex(&amp;state, index++, jsString(vm, locale));</span>
826             RETURN_IF_EXCEPTION(scope, nullptr);
827         }
828     }
829 
830     return subset;
831 }
832 
833 static JSArray* bestFitSupportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
834 {
835     // BestFitSupportedLocales (availableLocales, requestedLocales)
836     // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
837 
838     // FIXME: Implement something better than lookup.
839     return lookupSupportedLocales(state, availableLocales, requestedLocales);
840 }
841 
842 JSValue supportedLocales(ExecState&amp; state, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)
843 {
844     // SupportedLocales (availableLocales, requestedLocales, options)
845     // https://tc39.github.io/ecma402/#sec-supportedlocales
846 
847     VM&amp; vm = state.vm();
848     auto scope = DECLARE_THROW_SCOPE(vm);
849     String matcher;
850 
851     if (!options.isUndefined()) {
852         matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
853         RETURN_IF_EXCEPTION(scope, JSValue());
854     } else
855         matcher = &quot;best fit&quot;_s;
856 
857     JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
858         ? bestFitSupportedLocales(state, availableLocales, requestedLocales)
859         : lookupSupportedLocales(state, availableLocales, requestedLocales);
860     RETURN_IF_EXCEPTION(scope, JSValue());
861 
<a name="7" id="anc7"></a><span class="line-modified">862     PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);</span>
863     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, &amp;state, keys, EnumerationMode());
864     RETURN_IF_EXCEPTION(scope, JSValue());
865 
866     PropertyDescriptor desc;
867     desc.setConfigurable(false);
868     desc.setWritable(false);
869 
870     size_t len = keys.size();
871     for (size_t i = 0; i &lt; len; ++i) {
872         supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, keys[i], desc, true);
873         RETURN_IF_EXCEPTION(scope, JSValue());
874     }
875     supportedLocales-&gt;defineOwnProperty(supportedLocales, &amp;state, vm.propertyNames-&gt;length, desc, true);
876     RETURN_IF_EXCEPTION(scope, JSValue());
877 
878     return supportedLocales;
879 }
880 
881 Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
882 {
883     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
884     Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
885 
886     if (UNLIKELY(availableNumberingSystems.isEmpty())) {
887         static Lock cachedNumberingSystemsMutex;
888         std::lock_guard&lt;Lock&gt; lock(cachedNumberingSystemsMutex);
889         if (availableNumberingSystems.isEmpty()) {
890             UErrorCode status = U_ZERO_ERROR;
891             UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);
892             ASSERT(U_SUCCESS(status));
893 
894             int32_t resultLength;
895             // Numbering system names are always ASCII, so use char[].
896             while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {
897                 ASSERT(U_SUCCESS(status));
898                 auto numsys = unumsys_openByName(result, &amp;status);
899                 ASSERT(U_SUCCESS(status));
900                 // Only support algorithmic if it is the default fot the locale, handled below.
901                 if (!unumsys_isAlgorithmic(numsys))
902                     availableNumberingSystems.append(String(result, resultLength));
903                 unumsys_close(numsys);
904             }
905             uenum_close(numberingSystemNames);
906         }
907     }
908 
909     UErrorCode status = U_ZERO_ERROR;
910     UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
911     ASSERT(U_SUCCESS(status));
912     String defaultSystemName(unumsys_getName(defaultSystem));
913     unumsys_close(defaultSystem);
914 
915     Vector&lt;String&gt; numberingSystems({ defaultSystemName });
916     numberingSystems.appendVector(availableNumberingSystems);
917     return numberingSystems;
918 }
919 
920 EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(ExecState* state)
921 {
922     // Intl.getCanonicalLocales(locales)
923     // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
924 
925     VM&amp; vm = state-&gt;vm();
926     auto scope = DECLARE_THROW_SCOPE(vm);
927 
928     Vector&lt;String&gt; localeList = canonicalizeLocaleList(*state, state-&gt;argument(0));
929     RETURN_IF_EXCEPTION(scope, encodedJSValue());
930     auto length = localeList.size();
931 
932     JSGlobalObject* globalObject = state-&gt;jsCallee()-&gt;globalObject(vm);
933     JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
934     if (!localeArray) {
935         throwOutOfMemoryError(state, scope);
936         return encodedJSValue();
937     }
938 
939     for (size_t i = 0; i &lt; length; ++i) {
<a name="8" id="anc8"></a><span class="line-modified">940         localeArray-&gt;putDirectIndex(state, i, jsString(vm, localeList[i]));</span>
941         RETURN_IF_EXCEPTION(scope, encodedJSValue());
942     }
943     return JSValue::encode(localeArray);
944 }
945 
946 } // namespace JSC
947 
948 #endif // ENABLE(INTL)
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>