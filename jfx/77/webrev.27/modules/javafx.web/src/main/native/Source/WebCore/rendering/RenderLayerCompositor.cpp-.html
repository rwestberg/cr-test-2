<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2010 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerCompositor.h&quot;
  29 
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CSSPropertyNames.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;ChromeClient.h&quot;
  35 #include &quot;DocumentTimeline.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameView.h&quot;
  38 #include &quot;GraphicsLayer.h&quot;
  39 #include &quot;HTMLCanvasElement.h&quot;
  40 #include &quot;HTMLIFrameElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HitTestResult.h&quot;
  43 #include &quot;InspectorInstrumentation.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeList.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PageOverlayController.h&quot;
  48 #include &quot;RenderEmbeddedObject.h&quot;
  49 #include &quot;RenderFragmentedFlow.h&quot;
  50 #include &quot;RenderFullScreen.h&quot;
  51 #include &quot;RenderGeometryMap.h&quot;
  52 #include &quot;RenderIFrame.h&quot;
  53 #include &quot;RenderLayerBacking.h&quot;
  54 #include &quot;RenderReplica.h&quot;
  55 #include &quot;RenderVideo.h&quot;
  56 #include &quot;RenderView.h&quot;
  57 #include &quot;RuntimeEnabledFeatures.h&quot;
  58 #include &quot;ScrollingConstraints.h&quot;
  59 #include &quot;ScrollingCoordinator.h&quot;
  60 #include &quot;Settings.h&quot;
  61 #include &quot;TiledBacking.h&quot;
  62 #include &quot;TransformState.h&quot;
  63 #include &lt;wtf/HexNumber.h&gt;
  64 #include &lt;wtf/MemoryPressureHandler.h&gt;
  65 #include &lt;wtf/SetForScope.h&gt;
  66 #include &lt;wtf/text/CString.h&gt;
  67 #include &lt;wtf/text/StringBuilder.h&gt;
  68 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  69 #include &lt;wtf/text/TextStream.h&gt;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 #include &quot;LegacyTileCache.h&quot;
  73 #include &quot;RenderScrollbar.h&quot;
  74 #endif
  75 
  76 #if PLATFORM(MAC)
  77 #include &quot;LocalDefaultSystemAppearance.h&quot;
  78 #endif
  79 
  80 #if ENABLE(TREE_DEBUGGING)
  81 #include &quot;RenderTreeAsText.h&quot;
  82 #endif
  83 
  84 #if ENABLE(3D_TRANSFORMS)
  85 // This symbol is used to determine from a script whether 3D rendering is enabled (via &#39;nm&#39;).
  86 WEBCORE_EXPORT bool WebCoreHas3DRendering = true;
  87 #endif
  88 
  89 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY)
  90 #define USE_COMPOSITING_FOR_SMALL_CANVASES 1
  91 #endif
  92 
  93 namespace WebCore {
  94 
  95 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
  96 static const int canvasAreaThresholdRequiringCompositing = 50 * 100;
  97 #endif
  98 // During page loading delay layer flushes up to this many seconds to allow them coalesce, reducing workload.
  99 #if PLATFORM(IOS_FAMILY)
 100 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 101 static const Seconds throttledLayerFlushDelay { 1.5_s };
 102 #else
 103 static const Seconds throttledLayerFlushInitialDelay { 500_ms };
 104 static const Seconds throttledLayerFlushDelay { 500_ms };
 105 #endif
 106 
 107 using namespace HTMLNames;
 108 
 109 struct ScrollingTreeState {
 110     Optional&lt;ScrollingNodeID&gt; parentNodeID;
 111     size_t nextChildIndex { 0 };
 112 };
 113 
 114 class OverlapMapContainer {
 115 public:
 116     void add(const LayoutRect&amp; bounds)
 117     {
 118         m_layerRects.append(bounds);
 119         m_boundingBox.unite(bounds);
 120     }
 121 
 122     bool overlapsLayers(const LayoutRect&amp; bounds) const
 123     {
 124         // Checking with the bounding box will quickly reject cases when
 125         // layers are created for lists of items going in one direction and
 126         // never overlap with each other.
 127         if (!bounds.intersects(m_boundingBox))
 128             return false;
 129         for (const auto&amp; layerRect : m_layerRects) {
 130             if (layerRect.intersects(bounds))
 131                 return true;
 132         }
 133         return false;
 134     }
 135 
 136     void unite(const OverlapMapContainer&amp; otherContainer)
 137     {
 138         m_layerRects.appendVector(otherContainer.m_layerRects);
 139         m_boundingBox.unite(otherContainer.m_boundingBox);
 140     }
 141 private:
 142     Vector&lt;LayoutRect&gt; m_layerRects;
 143     LayoutRect m_boundingBox;
 144 };
 145 
 146 class RenderLayerCompositor::OverlapMap {
 147     WTF_MAKE_NONCOPYABLE(OverlapMap);
 148 public:
 149     OverlapMap()
 150         : m_geometryMap(UseTransforms)
 151     {
 152         // Begin assuming the root layer will be composited so that there is
 153         // something on the stack. The root layer should also never get an
 154         // popCompositingContainer call.
 155         pushCompositingContainer();
 156     }
 157 
 158     void add(const LayoutRect&amp; bounds)
 159     {
 160         // Layers do not contribute to overlap immediately--instead, they will
 161         // contribute to overlap as soon as their composited ancestor has been
 162         // recursively processed and popped off the stack.
 163         ASSERT(m_overlapStack.size() &gt;= 2);
 164         m_overlapStack[m_overlapStack.size() - 2].add(bounds);
 165         m_isEmpty = false;
 166     }
 167 
 168     bool overlapsLayers(const LayoutRect&amp; bounds) const
 169     {
 170         return m_overlapStack.last().overlapsLayers(bounds);
 171     }
 172 
 173     bool isEmpty() const
 174     {
 175         return m_isEmpty;
 176     }
 177 
 178     void pushCompositingContainer()
 179     {
 180         m_overlapStack.append(OverlapMapContainer());
 181     }
 182 
 183     void popCompositingContainer()
 184     {
 185         m_overlapStack[m_overlapStack.size() - 2].unite(m_overlapStack.last());
 186         m_overlapStack.removeLast();
 187     }
 188 
 189     const RenderGeometryMap&amp; geometryMap() const { return m_geometryMap; }
 190     RenderGeometryMap&amp; geometryMap() { return m_geometryMap; }
 191 
 192 private:
 193     struct RectList {
 194         Vector&lt;LayoutRect&gt; rects;
 195         LayoutRect boundingRect;
 196 
 197         void append(const LayoutRect&amp; rect)
 198         {
 199             rects.append(rect);
 200             boundingRect.unite(rect);
 201         }
 202 
 203         void append(const RectList&amp; rectList)
 204         {
 205             rects.appendVector(rectList.rects);
 206             boundingRect.unite(rectList.boundingRect);
 207         }
 208 
 209         bool intersects(const LayoutRect&amp; rect) const
 210         {
 211             if (!rects.size() || !boundingRect.intersects(rect))
 212                 return false;
 213 
 214             for (const auto&amp; currentRect : rects) {
 215                 if (currentRect.intersects(rect))
 216                     return true;
 217             }
 218             return false;
 219         }
 220     };
 221 
 222     Vector&lt;OverlapMapContainer&gt; m_overlapStack;
 223     RenderGeometryMap m_geometryMap;
 224     bool m_isEmpty { true };
 225 };
 226 
 227 struct RenderLayerCompositor::CompositingState {
 228     CompositingState(RenderLayer* compAncestor, bool testOverlap = true)
 229         : compositingAncestor(compAncestor)
 230         , testingOverlap(testOverlap)
 231     {
 232     }
 233 
 234     CompositingState(const CompositingState&amp; other)
 235         : compositingAncestor(other.compositingAncestor)
 236         , subtreeIsCompositing(other.subtreeIsCompositing)
 237         , testingOverlap(other.testingOverlap)
 238         , fullPaintOrderTraversalRequired(other.fullPaintOrderTraversalRequired)
 239         , descendantsRequireCompositingUpdate(other.descendantsRequireCompositingUpdate)
 240         , ancestorHasTransformAnimation(other.ancestorHasTransformAnimation)
 241 #if ENABLE(CSS_COMPOSITING)
 242         , hasNotIsolatedCompositedBlendingDescendants(other.hasNotIsolatedCompositedBlendingDescendants)
 243 #endif
 244 #if ENABLE(TREE_DEBUGGING)
 245         , depth(other.depth + 1)
 246 #endif
 247     {
 248     }
 249 
 250     RenderLayer* compositingAncestor;
 251     bool subtreeIsCompositing { false };
 252     bool testingOverlap { true };
 253     bool fullPaintOrderTraversalRequired { false };
 254     bool descendantsRequireCompositingUpdate { false };
 255     bool ancestorHasTransformAnimation { false };
 256 #if ENABLE(CSS_COMPOSITING)
 257     bool hasNotIsolatedCompositedBlendingDescendants { false };
 258 #endif
 259 #if ENABLE(TREE_DEBUGGING)
 260     int depth { 0 };
 261 #endif
 262 };
 263 
 264 struct RenderLayerCompositor::OverlapExtent {
 265     LayoutRect bounds;
 266     bool extentComputed { false };
 267     bool hasTransformAnimation { false };
 268     bool animationCausesExtentUncertainty { false };
 269 
 270     bool knownToBeHaveExtentUncertainty() const { return extentComputed &amp;&amp; animationCausesExtentUncertainty; }
 271 };
 272 
 273 #if !LOG_DISABLED
 274 static inline bool compositingLogEnabled()
 275 {
 276     return LogCompositing.state == WTFLogChannelOn;
 277 }
 278 #endif
 279 
 280 RenderLayerCompositor::RenderLayerCompositor(RenderView&amp; renderView)
 281     : m_renderView(renderView)
 282     , m_updateCompositingLayersTimer(*this, &amp;RenderLayerCompositor::updateCompositingLayersTimerFired)
 283     , m_layerFlushTimer(*this, &amp;RenderLayerCompositor::layerFlushTimerFired)
 284 {
 285 #if PLATFORM(IOS_FAMILY)
 286     if (m_renderView.frameView().platformWidget())
 287         m_legacyScrollingLayerCoordinator = std::make_unique&lt;LegacyWebKitScrollingLayerCoordinator&gt;(page().chrome().client(), isMainFrameCompositor());
 288 #endif
 289 }
 290 
 291 RenderLayerCompositor::~RenderLayerCompositor()
 292 {
 293     // Take care that the owned GraphicsLayers are deleted first as their destructors may call back here.
 294     m_clipLayer = nullptr;
 295     m_scrolledContentsLayer = nullptr;
 296     ASSERT(m_rootLayerAttachment == RootLayerUnattached);
 297 }
 298 
 299 void RenderLayerCompositor::enableCompositingMode(bool enable /* = true */)
 300 {
 301     if (enable != m_compositing) {
 302         m_compositing = enable;
 303 
 304         if (m_compositing) {
 305             ensureRootLayer();
 306             notifyIFramesOfCompositingChange();
 307         } else
 308             destroyRootLayer();
 309 
 310 
 311         m_renderView.layer()-&gt;setNeedsPostLayoutCompositingUpdate();
 312     }
 313 }
 314 
 315 void RenderLayerCompositor::cacheAcceleratedCompositingFlags()
 316 {
 317     auto&amp; settings = m_renderView.settings();
 318     bool hasAcceleratedCompositing = settings.acceleratedCompositingEnabled();
 319 
 320     // We allow the chrome to override the settings, in case the page is rendered
 321     // on a chrome that doesn&#39;t allow accelerated compositing.
 322     if (hasAcceleratedCompositing) {
 323         m_compositingTriggers = page().chrome().client().allowedCompositingTriggers();
 324         hasAcceleratedCompositing = m_compositingTriggers;
 325     }
 326 
 327     bool showDebugBorders = settings.showDebugBorders();
 328     bool showRepaintCounter = settings.showRepaintCounter();
 329     bool acceleratedDrawingEnabled = settings.acceleratedDrawingEnabled();
 330     bool displayListDrawingEnabled = settings.displayListDrawingEnabled();
 331 
 332     // forceCompositingMode for subframes can only be computed after layout.
 333     bool forceCompositingMode = m_forceCompositingMode;
 334     if (isMainFrameCompositor())
 335         forceCompositingMode = m_renderView.settings().forceCompositingMode() &amp;&amp; hasAcceleratedCompositing;
 336 
 337     if (hasAcceleratedCompositing != m_hasAcceleratedCompositing || showDebugBorders != m_showDebugBorders || showRepaintCounter != m_showRepaintCounter || forceCompositingMode != m_forceCompositingMode) {
 338         if (auto* rootLayer = m_renderView.layer()) {
 339             rootLayer-&gt;setNeedsCompositingConfigurationUpdate();
 340             rootLayer-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
 341         }
 342     }
 343 
 344     bool debugBordersChanged = m_showDebugBorders != showDebugBorders;
 345     m_hasAcceleratedCompositing = hasAcceleratedCompositing;
 346     m_forceCompositingMode = forceCompositingMode;
 347     m_showDebugBorders = showDebugBorders;
 348     m_showRepaintCounter = showRepaintCounter;
 349     m_acceleratedDrawingEnabled = acceleratedDrawingEnabled;
 350     m_displayListDrawingEnabled = displayListDrawingEnabled;
 351 
 352     if (debugBordersChanged) {
 353         if (m_layerForHorizontalScrollbar)
 354             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 355 
 356         if (m_layerForVerticalScrollbar)
 357             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
 358 
 359         if (m_layerForScrollCorner)
 360             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
 361     }
 362 
 363     if (updateCompositingPolicy())
 364         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 365 }
 366 
 367 void RenderLayerCompositor::cacheAcceleratedCompositingFlagsAfterLayout()
 368 {
 369     cacheAcceleratedCompositingFlags();
 370 
 371     if (isMainFrameCompositor())
 372         return;
 373 
 374     RequiresCompositingData queryData;
 375     bool forceCompositingMode = m_hasAcceleratedCompositing &amp;&amp; m_renderView.settings().forceCompositingMode() &amp;&amp; requiresCompositingForScrollableFrame(queryData);
 376     if (forceCompositingMode != m_forceCompositingMode) {
 377         m_forceCompositingMode = forceCompositingMode;
 378         rootRenderLayer().setDescendantsNeedCompositingRequirementsTraversal();
 379     }
 380 }
 381 
 382 bool RenderLayerCompositor::updateCompositingPolicy()
 383 {
 384     if (!usesCompositing())
 385         return false;
 386 
 387     auto currentPolicy = m_compositingPolicy;
 388     if (page().compositingPolicyOverride()) {
 389         m_compositingPolicy = page().compositingPolicyOverride().value();
 390         return m_compositingPolicy != currentPolicy;
 391     }
 392 
 393     auto memoryPolicy = MemoryPressureHandler::currentMemoryUsagePolicy();
 394     m_compositingPolicy = memoryPolicy == WTF::MemoryUsagePolicy::Unrestricted ? CompositingPolicy::Normal : CompositingPolicy::Conservative;
 395     return m_compositingPolicy != currentPolicy;
 396 }
 397 
 398 bool RenderLayerCompositor::canRender3DTransforms() const
 399 {
 400     return hasAcceleratedCompositing() &amp;&amp; (m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger);
 401 }
 402 
 403 void RenderLayerCompositor::willRecalcStyle()
 404 {
 405     cacheAcceleratedCompositingFlags();
 406 }
 407 
 408 bool RenderLayerCompositor::didRecalcStyleWithNoPendingLayout()
 409 {
 410     return updateCompositingLayers(CompositingUpdateType::AfterStyleChange);
 411 }
 412 
 413 void RenderLayerCompositor::customPositionForVisibleRectComputation(const GraphicsLayer* graphicsLayer, FloatPoint&amp; position) const
 414 {
 415     if (graphicsLayer != m_scrolledContentsLayer.get())
 416         return;
 417 
 418     FloatPoint scrollPosition = -position;
 419 
 420     if (m_renderView.frameView().scrollBehaviorForFixedElements() == StickToDocumentBounds)
 421         scrollPosition = m_renderView.frameView().constrainScrollPositionForOverhang(roundedIntPoint(scrollPosition));
 422 
 423     position = -scrollPosition;
 424 }
 425 
 426 void RenderLayerCompositor::notifyFlushRequired(const GraphicsLayer* layer)
 427 {
 428     scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
 429 }
 430 
 431 void RenderLayerCompositor::scheduleLayerFlushNow()
 432 {
 433     m_hasPendingLayerFlush = false;
 434     page().chrome().client().scheduleCompositingLayerFlush();
 435 }
 436 
 437 void RenderLayerCompositor::scheduleLayerFlush(bool canThrottle)
 438 {
 439     ASSERT(!m_flushingLayers);
 440 
 441     if (canThrottle)
 442         startInitialLayerFlushTimerIfNeeded();
 443 
 444     if (canThrottle &amp;&amp; isThrottlingLayerFlushes()) {
 445         m_hasPendingLayerFlush = true;
 446         return;
 447     }
 448     scheduleLayerFlushNow();
 449 }
 450 
 451 FloatRect RenderLayerCompositor::visibleRectForLayerFlushing() const
 452 {
 453     const FrameView&amp; frameView = m_renderView.frameView();
 454 #if PLATFORM(IOS_FAMILY)
 455     return frameView.exposedContentRect();
 456 #else
 457     // Having a m_scrolledContentsLayer indicates that we&#39;re doing scrolling via GraphicsLayers.
 458     FloatRect visibleRect = m_scrolledContentsLayer ? FloatRect({ }, frameView.sizeForVisibleContent()) : frameView.visibleContentRect();
 459 
 460     if (frameView.viewExposedRect())
 461         visibleRect.intersect(frameView.viewExposedRect().value());
 462 
 463     return visibleRect;
 464 #endif
 465 }
 466 
 467 void RenderLayerCompositor::flushPendingLayerChanges(bool isFlushRoot)
 468 {
 469     // FrameView::flushCompositingStateIncludingSubframes() flushes each subframe,
 470     // but GraphicsLayer::flushCompositingState() will cross frame boundaries
 471     // if the GraphicsLayers are connected (the RootLayerAttachedViaEnclosingFrame case).
 472     // As long as we&#39;re not the root of the flush, we can bail.
 473     if (!isFlushRoot &amp;&amp; rootLayerAttachment() == RootLayerAttachedViaEnclosingFrame)
 474         return;
 475 
 476     if (rootLayerAttachment() == RootLayerUnattached) {
 477 #if PLATFORM(IOS_FAMILY)
 478         startLayerFlushTimerIfNeeded();
 479 #endif
 480         m_shouldFlushOnReattach = true;
 481         return;
 482     }
 483 
 484     auto&amp; frameView = m_renderView.frameView();
 485     AnimationUpdateBlock animationUpdateBlock(&amp;frameView.frame().animation());
 486 
 487     ASSERT(!m_flushingLayers);
 488     {
 489         SetForScope&lt;bool&gt; flushingLayersScope(m_flushingLayers, true);
 490 
 491         if (auto* rootLayer = rootGraphicsLayer()) {
 492             FloatRect visibleRect = visibleRectForLayerFlushing();
 493             LOG_WITH_STREAM(Compositing,  stream &lt;&lt; &quot;\nRenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; flushPendingLayerChanges (is root &quot; &lt;&lt; isFlushRoot &lt;&lt; &quot;) visible rect &quot; &lt;&lt; visibleRect);
 494             rootLayer-&gt;flushCompositingState(visibleRect);
 495         }
 496 
 497         ASSERT(m_flushingLayers);
 498     }
 499 
 500 #if PLATFORM(IOS_FAMILY)
 501     updateScrollCoordinatedLayersAfterFlushIncludingSubframes();
 502 
 503     if (isFlushRoot)
 504         page().chrome().client().didFlushCompositingLayers();
 505 #endif
 506 
 507     ++m_layerFlushCount;
 508     startLayerFlushTimerIfNeeded();
 509 }
 510 
 511 #if PLATFORM(IOS_FAMILY)
 512 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlushIncludingSubframes()
 513 {
 514     updateScrollCoordinatedLayersAfterFlush();
 515 
 516     auto&amp; frame = m_renderView.frameView().frame();
 517     for (Frame* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().traverseNext(&amp;frame)) {
 518         auto* view = subframe-&gt;contentRenderer();
 519         if (!view)
 520             continue;
 521 
 522         view-&gt;compositor().updateScrollCoordinatedLayersAfterFlush();
 523     }
 524 }
 525 
 526 void RenderLayerCompositor::updateScrollCoordinatedLayersAfterFlush()
 527 {
 528     if (m_legacyScrollingLayerCoordinator) {
 529         m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
 530         m_legacyScrollingLayerCoordinator-&gt;registerScrollingLayersNeedingUpdate();
 531     }
 532 }
 533 #endif
 534 
 535 void RenderLayerCompositor::didChangePlatformLayerForLayer(RenderLayer&amp; layer, const GraphicsLayer*)
 536 {
 537 #if PLATFORM(IOS_FAMILY)
 538     if (m_legacyScrollingLayerCoordinator)
 539         m_legacyScrollingLayerCoordinator-&gt;didChangePlatformLayerForLayer(layer);
 540 #endif
 541 
 542     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
 543     if (!scrollingCoordinator)
 544         return;
 545 
 546     auto* backing = layer.backing();
 547     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
 548         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 549 
 550     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling)) {
 551         // FIXME: would be nice to not have to special-case the root.
 552         ScrollingCoordinator::NodeLayers nodeLayers;
 553         if (layer.isRenderViewLayer())
 554             nodeLayers = { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() };
 555         else
 556             nodeLayers = { layer.backing()-&gt;graphicsLayer(), backing-&gt;scrollContainerLayer(), backing-&gt;scrolledContentsLayer() };
 557 
 558         scrollingCoordinator-&gt;setNodeLayers(nodeID, nodeLayers);
 559     }
 560 
 561     if (auto nodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 562         scrollingCoordinator-&gt;setNodeLayers(nodeID, { backing-&gt;graphicsLayer() });
 563 }
 564 
 565 void RenderLayerCompositor::didPaintBacking(RenderLayerBacking*)
 566 {
 567     auto&amp; frameView = m_renderView.frameView();
 568     frameView.setLastPaintTime(MonotonicTime::now());
 569     if (frameView.milestonesPendingPaint())
 570         frameView.firePaintRelatedMilestonesIfNeeded();
 571 }
 572 
 573 void RenderLayerCompositor::didChangeVisibleRect()
 574 {
 575     auto* rootLayer = rootGraphicsLayer();
 576     if (!rootLayer)
 577         return;
 578 
 579     FloatRect visibleRect = visibleRectForLayerFlushing();
 580     bool requiresFlush = rootLayer-&gt;visibleRectChangeRequiresFlush(visibleRect);
 581     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor::didChangeVisibleRect &quot; &lt;&lt; visibleRect &lt;&lt; &quot; requiresFlush &quot; &lt;&lt; requiresFlush);
 582     if (requiresFlush)
 583         scheduleLayerFlushNow();
 584 }
 585 
 586 void RenderLayerCompositor::notifyFlushBeforeDisplayRefresh(const GraphicsLayer*)
 587 {
 588     if (!m_layerUpdater) {
 589         PlatformDisplayID displayID = page().chrome().displayID();
 590         m_layerUpdater = std::make_unique&lt;GraphicsLayerUpdater&gt;(*this, displayID);
 591     }
 592 
 593     m_layerUpdater-&gt;scheduleUpdate();
 594 }
 595 
 596 void RenderLayerCompositor::flushLayersSoon(GraphicsLayerUpdater&amp;)
 597 {
 598     scheduleLayerFlush(true);
 599 }
 600 
 601 void RenderLayerCompositor::layerTiledBackingUsageChanged(const GraphicsLayer* graphicsLayer, bool usingTiledBacking)
 602 {
 603     if (usingTiledBacking) {
 604         ++m_layersWithTiledBackingCount;
 605         graphicsLayer-&gt;tiledBacking()-&gt;setIsInWindow(page().isInWindow());
 606     } else {
 607         ASSERT(m_layersWithTiledBackingCount &gt; 0);
 608         --m_layersWithTiledBackingCount;
 609     }
 610 }
 611 
 612 void RenderLayerCompositor::scheduleCompositingLayerUpdate()
 613 {
 614     if (!m_updateCompositingLayersTimer.isActive())
 615         m_updateCompositingLayersTimer.startOneShot(0_s);
 616 }
 617 
 618 void RenderLayerCompositor::updateCompositingLayersTimerFired()
 619 {
 620     updateCompositingLayers(CompositingUpdateType::AfterLayout);
 621 }
 622 
 623 void RenderLayerCompositor::cancelCompositingLayerUpdate()
 624 {
 625     m_updateCompositingLayersTimer.stop();
 626 }
 627 
 628 static Optional&lt;ScrollingNodeID&gt; frameHostingNodeForFrame(Frame&amp; frame)
 629 {
 630     if (!frame.document() || !frame.view())
 631         return { };
 632 
 633     // Find the frame&#39;s enclosing layer in our render tree.
 634     auto* ownerElement = frame.document()-&gt;ownerElement();
 635     if (!ownerElement)
 636         return { };
 637 
 638     auto* frameRenderer = ownerElement-&gt;renderer();
 639     if (!frameRenderer || !is&lt;RenderWidget&gt;(frameRenderer))
 640         return { };
 641 
 642     auto&amp; widgetRenderer = downcast&lt;RenderWidget&gt;(*frameRenderer);
 643     if (!widgetRenderer.hasLayer() || !widgetRenderer.layer()-&gt;isComposited()) {
 644         LOG(Scrolling, &quot;frameHostingNodeForFrame: frame renderer has no layer or is not composited.&quot;);
 645         return { };
 646     }
 647 
 648     if (auto frameHostingNodeID = widgetRenderer.layer()-&gt;backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
 649         return frameHostingNodeID;
 650 
 651     return { };
 652 }
 653 
 654 // Returns true on a successful update.
 655 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 656 {
 657     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
 658 
 659 #if ENABLE(TREE_DEBUGGING)
 660     if (compositingLogEnabled())
 661         showPaintOrderTree(m_renderView.layer());
 662 #endif
 663 
 664     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
 665         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 666 
 667     m_updateCompositingLayersTimer.stop();
 668 
 669     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
 670 
 671     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
 672     if (!m_renderView.document().visualUpdatesAllowed())
 673         return false;
 674 
 675     // Avoid updating the layers with old values. Compositing layers will be updated after the layout is finished.
 676     // This happens when m_updateCompositingLayersTimer fires before layout is updated.
 677     if (m_renderView.needsLayout()) {
 678         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; - m_renderView.needsLayout, bailing &quot;);
 679         return false;
 680     }
 681 
 682     if (!m_compositing &amp;&amp; (m_forceCompositingMode || (isMainFrameCompositor() &amp;&amp; page().pageOverlayController().overlayCount())))
 683         enableCompositingMode(true);
 684 
 685     bool isPageScroll = !updateRoot || updateRoot == &amp;rootRenderLayer();
 686     updateRoot = &amp;rootRenderLayer();
 687 
 688     if (updateType == CompositingUpdateType::OnScroll || updateType == CompositingUpdateType::OnCompositedScroll) {
 689         // We only get here if we didn&#39;t scroll on the scrolling thread, so this update needs to re-position viewport-constrained layers.
 690         if (m_renderView.settings().acceleratedCompositingForFixedPositionEnabled() &amp;&amp; isPageScroll) {
 691             if (auto* viewportConstrainedObjects = m_renderView.frameView().viewportConstrainedObjects()) {
 692                 for (auto* renderer : *viewportConstrainedObjects) {
 693                     if (auto* layer = renderer-&gt;layer())
 694                         layer-&gt;setNeedsCompositingGeometryUpdate();
 695                 }
 696             }
 697         }
 698 
 699         // Scrolling can affect overlap. FIXME: avoid for page scrolling.
 700         updateRoot-&gt;setDescendantsNeedCompositingRequirementsTraversal();
 701     }
 702 
 703     if (!updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !m_compositing) {
 704         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; no compositing work to do&quot;);
 705         return true;
 706     }
 707 
 708     if (!updateRoot-&gt;needsAnyCompositingTraversal()) {
 709         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot; updateRoot has no dirty child and doesn&#39;t need update&quot;);
 710         return true;
 711     }
 712 
 713     ++m_compositingUpdateCount;
 714 
 715     AnimationUpdateBlock animationUpdateBlock(&amp;m_renderView.frameView().frame().animation());
 716 
 717     SetForScope&lt;bool&gt; postLayoutChange(m_inPostLayoutUpdate, true);
 718 
 719 #if !LOG_DISABLED
 720     MonotonicTime startTime;
 721     if (compositingLogEnabled()) {
 722         ++m_rootLayerUpdateCount;
 723         startTime = MonotonicTime::now();
 724     }
 725 
 726     if (compositingLogEnabled()) {
 727         m_obligateCompositedLayerCount = 0;
 728         m_secondaryCompositedLayerCount = 0;
 729         m_obligatoryBackingStoreBytes = 0;
 730         m_secondaryBackingStoreBytes = 0;
 731 
 732         auto&amp; frame = m_renderView.frameView().frame();
 733         bool isMainFrame = isMainFrameCompositor();
 734         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;\nUpdate &quot; &lt;&lt; m_rootLayerUpdateCount &lt;&lt; &quot; of &quot; &lt;&lt; (isMainFrame ? &quot;main frame&quot; : frame.tree().uniqueName().string().utf8().data()) &lt;&lt; &quot; - compositing policy is &quot; &lt;&lt; m_compositingPolicy);
 735     }
 736 #endif
 737 
 738     // FIXME: optimize root-only update.
 739     if (updateRoot-&gt;hasDescendantNeedingCompositingRequirementsTraversal() || updateRoot-&gt;needsCompositingRequirementsTraversal()) {
 740         CompositingState compositingState(updateRoot);
 741         OverlapMap overlapMap;
 742 
 743         bool descendantHas3DTransform = false;
 744         computeCompositingRequirements(nullptr, rootRenderLayer(), overlapMap, compositingState, descendantHas3DTransform);
 745     }
 746 
 747     LOG(Compositing, &quot;\nRenderLayerCompositor::updateCompositingLayers - mid&quot;);
 748 #if ENABLE(TREE_DEBUGGING)
 749     if (compositingLogEnabled())
 750         showPaintOrderTree(m_renderView.layer());
 751 #endif
 752 
 753     if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
 754         ScrollingTreeState scrollingTreeState = { 0, 0 };
 755         if (!m_renderView.frame().isMainFrame())
 756             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 757 
 758         Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
 759         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);
 760 
 761         // Host the document layer in the RenderView&#39;s root layer.
 762         appendDocumentOverlayLayers(childList);
 763         // Even when childList is empty, don&#39;t drop out of compositing mode if there are
 764         // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 765         if (childList.isEmpty() &amp;&amp; !needsCompositingForContentOrOverlays())
 766             destroyRootLayer();
 767         else if (m_rootContentsLayer)
 768             m_rootContentsLayer-&gt;setChildren(WTFMove(childList));
 769     }
 770 
 771 #if !LOG_DISABLED
 772     if (compositingLogEnabled()) {
 773         MonotonicTime endTime = MonotonicTime::now();
 774         LOG(Compositing, &quot;Total layers   primary   secondary   obligatory backing (KB)   secondary backing(KB)   total backing (KB)  update time (ms)\n&quot;);
 775 
 776         LOG(Compositing, &quot;%8d %11d %9d %20.2f %22.2f %22.2f %18.2f\n&quot;,
 777             m_obligateCompositedLayerCount + m_secondaryCompositedLayerCount, m_obligateCompositedLayerCount,
 778             m_secondaryCompositedLayerCount, m_obligatoryBackingStoreBytes / 1024, m_secondaryBackingStoreBytes / 1024, (m_obligatoryBackingStoreBytes + m_secondaryBackingStoreBytes) / 1024, (endTime - startTime).milliseconds());
 779     }
 780 #endif
 781 
 782     // FIXME: Only do if dirty.
 783     updateRootLayerPosition();
 784 
 785 #if ENABLE(TREE_DEBUGGING)
 786     if (compositingLogEnabled()) {
 787         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - post&quot;);
 788         showPaintOrderTree(m_renderView.layer());
 789         LOG(Compositing, &quot;RenderLayerCompositor::updateCompositingLayers - GraphicsLayers post, contentLayersCount %d&quot;, m_contentLayersCount);
 790         showGraphicsLayerTree(m_rootContentsLayer.get());
 791     }
 792 #endif
 793 
 794     InspectorInstrumentation::layerTreeDidChange(&amp;page());
 795 
 796     return true;
 797 }
 798 
 799 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)
 800 {
 801     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal() &amp;&amp; !layer.needsCompositingRequirementsTraversal() &amp;&amp; !compositingState.fullPaintOrderTraversalRequired &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
 802         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, descendantHas3DTransform);
 803         return;
 804     }
 805 
 806 #if ENABLE(TREE_DEBUGGING)
 807     LOG(Compositing, &quot;%*p computeCompositingRequirements&quot;, 12 + compositingState.depth * 2, &amp;layer);
 808 #endif
 809 
 810     // FIXME: maybe we can avoid updating all remaining layers in paint order.
 811     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
 812     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 813 
 814     layer.updateDescendantDependentFlags();
 815     layer.updateLayerListsIfNeeded();
 816 
 817     layer.setHasCompositingDescendant(false);
 818 
 819     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
 820     RequiresCompositingData queryData;
 821     bool willBeComposited = layer.isComposited();
 822     if (layer.needsPostLayoutCompositingUpdate() || compositingState.fullPaintOrderTraversalRequired || compositingState.descendantsRequireCompositingUpdate) {
 823         layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::None);
 824         willBeComposited = needsToBeComposited(layer, queryData);
 825     }
 826 
 827     compositingState.fullPaintOrderTraversalRequired |= layer.subsequentLayersNeedCompositingRequirementsTraversal();
 828 
 829     OverlapExtent layerExtent;
 830     // Use the fact that we&#39;re composited as a hint to check for an animating transform.
 831     // FIXME: Maybe needsToBeComposited() should return a bitmask of reasons, to avoid the need to recompute things.
 832     if (willBeComposited &amp;&amp; !layer.isRenderViewLayer())
 833         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
 834 
 835     bool respectTransforms = !layerExtent.hasTransformAnimation;
 836     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
 837 
 838     RenderLayer::IndirectCompositingReason compositingReason = compositingState.subtreeIsCompositing ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None;
 839 
 840     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
 841     if (!willBeComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap) {
 842         computeExtent(overlapMap, layer, layerExtent);
 843         // If we&#39;re testing for overlap, we only need to composite if we overlap something that is already composited.
 844         compositingReason = overlapMap.overlapsLayers(layerExtent.bounds) ? RenderLayer::IndirectCompositingReason::Overlap : RenderLayer::IndirectCompositingReason::None;
 845     }
 846 
 847 #if ENABLE(VIDEO)
 848     // Video is special. It&#39;s the only RenderLayer type that can both have
 849     // RenderLayer children and whose children can&#39;t use its backing to render
 850     // into. These children (the controls) always need to be promoted into their
 851     // own layers to draw on top of the accelerated video.
 852     if (compositingState.compositingAncestor &amp;&amp; compositingState.compositingAncestor-&gt;renderer().isVideo())
 853         compositingReason = RenderLayer::IndirectCompositingReason::Overlap;
 854 #endif
 855 
 856     if (compositingReason != RenderLayer::IndirectCompositingReason::None)
 857         layer.setIndirectCompositingReason(compositingReason);
 858 
 859     // Check if the computed indirect reason will force the layer to become composited.
 860     if (!willBeComposited &amp;&amp; layer.mustCompositeForIndirectReasons() &amp;&amp; canBeComposited(layer))
 861         willBeComposited = true;
 862 
 863     // The children of this layer don&#39;t need to composite, unless there is
 864     // a compositing layer among them, so start by inheriting the compositing
 865     // ancestor with subtreeIsCompositing set to false.
 866     CompositingState childState(compositingState);
 867     childState.subtreeIsCompositing = false;
 868 #if ENABLE(CSS_COMPOSITING)
 869     childState.hasNotIsolatedCompositedBlendingDescendants = false;
 870 #endif
 871 
 872     if (willBeComposited) {
 873         // Tell the parent it has compositing descendants.
 874         compositingState.subtreeIsCompositing = true;
 875         // This layer now acts as the ancestor for kids.
 876         childState.compositingAncestor = &amp;layer;
 877 
 878         overlapMap.pushCompositingContainer();
 879         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 880         // animation running behind this layer, meaning they can rely on the overlap map testing again.
 881         childState.testingOverlap = true;
 882 
 883         computeExtent(overlapMap, layer, layerExtent);
 884         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
 885         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
 886         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
 887     }
 888 
 889 #if !ASSERT_DISABLED
 890     LayerListMutationDetector mutationChecker(layer);
 891 #endif
 892 
 893     bool anyDescendantHas3DTransform = false;
 894 
 895     for (auto* childLayer : layer.negativeZOrderLayers()) {
 896         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
 897 
 898         // If we have to make a layer for this child, make one now so we can have a contents layer
 899         // (since we need to ensure that the -ve z-order child renders underneath our contents).
 900         if (!willBeComposited &amp;&amp; childState.subtreeIsCompositing) {
 901             // make layer compositing
 902             layer.setIndirectCompositingReason(RenderLayer::IndirectCompositingReason::BackgroundLayer);
 903             childState.compositingAncestor = &amp;layer;
 904             overlapMap.pushCompositingContainer();
 905             // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
 906             // animation running behind this layer, meaning they can rely on the overlap map testing again
 907             childState.testingOverlap = true;
 908             willBeComposited = true;
 909         }
 910     }
 911 
 912     for (auto* childLayer : layer.normalFlowLayers())
 913         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
 914 
 915     for (auto* childLayer : layer.positiveZOrderLayers())
 916         computeCompositingRequirements(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
 917 
 918     // If we just entered compositing mode, the root will have become composited (as long as accelerated compositing is enabled).
 919     if (layer.isRenderViewLayer()) {
 920         if (usesCompositing() &amp;&amp; m_hasAcceleratedCompositing)
 921             willBeComposited = true;
 922     }
 923 
 924     // All layers (even ones that aren&#39;t being composited) need to get added to
 925     // the overlap map. Layers that do not composite will draw into their
 926     // compositing ancestor&#39;s backing, and so are still considered for overlap.
 927     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds
 928     // include descendants, so we don&#39;t need to add them all to the overlap map.
 929     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())
 930         addToOverlapMap(overlapMap, layer, layerExtent);
 931 
 932 #if ENABLE(CSS_COMPOSITING)
 933     layer.setHasNotIsolatedCompositedBlendingDescendants(childState.hasNotIsolatedCompositedBlendingDescendants);
 934     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
 935 #endif
 936     // Now check for reasons to become composited that depend on the state of descendant layers.
 937     RenderLayer::IndirectCompositingReason indirectCompositingReason;
 938     if (!willBeComposited &amp;&amp; canBeComposited(layer)
 939         &amp;&amp; requiresCompositingForIndirectReason(layer.renderer(), childState.subtreeIsCompositing, anyDescendantHas3DTransform, indirectCompositingReason)) {
 940         layer.setIndirectCompositingReason(indirectCompositingReason);
 941         childState.compositingAncestor = &amp;layer;
 942         overlapMap.pushCompositingContainer();
 943         addToOverlapMapRecursive(overlapMap, layer);
 944         willBeComposited = true;
 945     }
 946 
 947     if (layer.reflectionLayer()) {
 948         // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
 949         layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? RenderLayer::IndirectCompositingReason::Stacking : RenderLayer::IndirectCompositingReason::None);
 950     }
 951 
 952     // Subsequent layers in the parent stacking context also need to composite.
 953     compositingState.subtreeIsCompositing |= childState.subtreeIsCompositing;
 954     compositingState.fullPaintOrderTraversalRequired |= childState.fullPaintOrderTraversalRequired;
 955 
 956     // Set the flag to say that this layer has compositing children.
 957     layer.setHasCompositingDescendant(childState.subtreeIsCompositing);
 958 
 959     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.
 960     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
 961 
 962     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.
 963     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because
 964     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.
 965     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())
 966         compositingState.testingOverlap = false;
 967 
 968     if (isCompositedClippingLayer) {
 969         if (!willBeComposited) {
 970             childState.compositingAncestor = &amp;layer;
 971             overlapMap.pushCompositingContainer();
 972             addToOverlapMapRecursive(overlapMap, layer);
 973             willBeComposited = true;
 974         }
 975     }
 976 
 977 #if ENABLE(CSS_COMPOSITING)
 978     if ((willBeComposited &amp;&amp; layer.hasBlendMode())
 979         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))
 980         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;
 981 #endif
 982 
 983     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())
 984         overlapMap.popCompositingContainer();
 985 
 986     // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
 987     // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
 988     // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
 989     RequiresCompositingData rootLayerQueryData;
 990     if (layer.isRenderViewLayer() &amp;&amp; !childState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
 991         // Don&#39;t drop out of compositing on iOS, because we may flash. See &lt;rdar://problem/8348337&gt;.
 992 #if !PLATFORM(IOS_FAMILY)
 993         enableCompositingMode(false);
 994         willBeComposited = false;
 995 #endif
 996     }
 997 
 998     ASSERT(willBeComposited == needsToBeComposited(layer, queryData));
 999 
1000     // Create or destroy backing here. However, we can&#39;t update geometry because layers above us may become composited
1001     // during post-order traversal (e.g. for clipping).
1002     if (updateBacking(layer, queryData, CompositingChangeRepaintNow, willBeComposited ? BackingRequired::Yes : BackingRequired::No)) {
1003         layer.setNeedsCompositingLayerConnection();
1004         // Child layers need to get a geometry update to recompute their position.
1005         layer.setChildrenNeedCompositingGeometryUpdate();
1006         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
1007         layer.setNeedsCompositingGeometryUpdateOnAncestors();
1008     }
1009 
1010     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
1011         layer.setNeedsCompositingLayerConnection();
1012 
1013     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1014 
1015     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
1016     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
1017         layer.setChildrenNeedCompositingGeometryUpdate();
1018         layer.setNeedsCompositingLayerConnection();
1019     }
1020 
1021 #if ENABLE(TREE_DEBUGGING)
1022     LOG(Compositing, &quot;%*p computeCompositingRequirements - willBeComposited %d&quot;, 12 + compositingState.depth * 2, &amp;layer, willBeComposited);
1023 #endif
1024 
1025     layer.clearCompositingRequirementsTraversalState();
1026 
1027     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1028 }
1029 
1030 // We have to traverse unchanged layers to fill in the overlap map.
1031 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, OverlapMap&amp; overlapMap, CompositingState&amp; compositingState, bool&amp; descendantHas3DTransform)
1032 {
1033     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
1034     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
1035     ASSERT(!layer.needsCompositingRequirementsTraversal());
1036 
1037 #if ENABLE(TREE_DEBUGGING)
1038     LOG(Compositing, &quot;%*p traverseUnchangedSubtree&quot;, 12 + compositingState.depth * 2, &amp;layer);
1039 #endif
1040 
1041     layer.updateDescendantDependentFlags();
1042     layer.updateLayerListsIfNeeded();
1043 
1044     bool layerIsComposited = layer.isComposited();
1045 
1046     OverlapExtent layerExtent;
1047     if (layerIsComposited &amp;&amp; !layer.isRenderViewLayer())
1048         layerExtent.hasTransformAnimation = isRunningTransformAnimation(layer.renderer());
1049 
1050     bool respectTransforms = !layerExtent.hasTransformAnimation;
1051     overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer, respectTransforms);
1052 
1053     // If we know for sure the layer is going to be composited, don&#39;t bother looking it up in the overlap map
1054     if (!layerIsComposited &amp;&amp; !overlapMap.isEmpty() &amp;&amp; compositingState.testingOverlap)
1055         computeExtent(overlapMap, layer, layerExtent);
1056 
1057     CompositingState childState(compositingState);
1058     childState.subtreeIsCompositing = false;
1059 #if ENABLE(CSS_COMPOSITING)
1060     childState.hasNotIsolatedCompositedBlendingDescendants = false;
1061 #endif
1062 
1063     if (layerIsComposited) {
1064         // Tell the parent it has compositing descendants.
1065         compositingState.subtreeIsCompositing = true;
1066         // This layer now acts as the ancestor for kids.
1067         childState.compositingAncestor = &amp;layer;
1068 
1069         overlapMap.pushCompositingContainer();
1070         // This layer is going to be composited, so children can safely ignore the fact that there&#39;s an
1071         // animation running behind this layer, meaning they can rely on the overlap map testing again.
1072         childState.testingOverlap = true;
1073 
1074         computeExtent(overlapMap, layer, layerExtent);
1075         childState.ancestorHasTransformAnimation |= layerExtent.hasTransformAnimation;
1076         // Too hard to compute animated bounds if both us and some ancestor is animating transform.
1077         layerExtent.animationCausesExtentUncertainty |= layerExtent.hasTransformAnimation &amp;&amp; compositingState.ancestorHasTransformAnimation;
1078     }
1079 
1080 #if !ASSERT_DISABLED
1081     LayerListMutationDetector mutationChecker(layer);
1082 #endif
1083 
1084     bool anyDescendantHas3DTransform = false;
1085 
1086     for (auto* childLayer : layer.negativeZOrderLayers()) {
1087         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
1088         if (childState.subtreeIsCompositing)
1089             ASSERT(layerIsComposited);
1090     }
1091 
1092     for (auto* childLayer : layer.normalFlowLayers())
1093         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
1094 
1095     for (auto* childLayer : layer.positiveZOrderLayers())
1096         traverseUnchangedSubtree(&amp;layer, *childLayer, overlapMap, childState, anyDescendantHas3DTransform);
1097 
1098     // All layers (even ones that aren&#39;t being composited) need to get added to
1099     // the overlap map. Layers that do not composite will draw into their
1100     // compositing ancestor&#39;s backing, and so are still considered for overlap.
1101     // FIXME: When layerExtent has taken animation bounds into account, we also know that the bounds
1102     // include descendants, so we don&#39;t need to add them all to the overlap map.
1103     if (childState.compositingAncestor &amp;&amp; !childState.compositingAncestor-&gt;isRenderViewLayer())
1104         addToOverlapMap(overlapMap, layer, layerExtent);
1105 
1106     // Subsequent layers in the parent stacking context also need to composite.
1107     if (childState.subtreeIsCompositing)
1108         compositingState.subtreeIsCompositing = true;
1109 
1110     // Set the flag to say that this layer has compositing children.
1111     ASSERT(layer.hasCompositingDescendant() == childState.subtreeIsCompositing);
1112 
1113     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that again.
1114     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);
1115 
1116     // Turn overlap testing off for later layers if it&#39;s already off, or if we have an animating transform.
1117     // Note that if the layer clips its descendants, there&#39;s no reason to propagate the child animation to the parent layers. That&#39;s because
1118     // we know for sure the animation is contained inside the clipping rectangle, which is already added to the overlap map.
1119     if ((!childState.testingOverlap &amp;&amp; !isCompositedClippingLayer) || layerExtent.knownToBeHaveExtentUncertainty())
1120         compositingState.testingOverlap = false;
1121 
1122     if (isCompositedClippingLayer)
1123         ASSERT(layerIsComposited);
1124 
1125 #if ENABLE(CSS_COMPOSITING)
1126     if ((layerIsComposited &amp;&amp; layer.hasBlendMode())
1127         || (layer.hasNotIsolatedCompositedBlendingDescendants() &amp;&amp; !layer.isolatesCompositedBlending()))
1128         compositingState.hasNotIsolatedCompositedBlendingDescendants = true;
1129 #endif
1130 
1131     if (childState.compositingAncestor == &amp;layer &amp;&amp; !layer.isRenderViewLayer())
1132         overlapMap.popCompositingContainer();
1133 
1134     descendantHas3DTransform |= anyDescendantHas3DTransform || layer.has3DTransform();
1135 
1136     ASSERT(!layer.needsCompositingRequirementsTraversal());
1137 
1138     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1139 }
1140 
1141 void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)
1142 {
1143     layer.updateDescendantDependentFlags();
1144     layer.updateLayerListsIfNeeded();
1145 
1146     bool layerNeedsUpdate = !updateLevel.isEmpty();
1147     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
1148         updateLevel.add(UpdateLevel::AllDescendants);
1149 
1150     ScrollingTreeState stateForDescendants = scrollingTreeState;
1151 
1152     auto* layerBacking = layer.backing();
1153     if (layerBacking) {
1154         updateLevel.remove(UpdateLevel::CompositedChildren);
1155 
1156         // We updated the composited bounds in RenderLayerBacking::updateAfterLayout(), but it may have changed
1157         // based on which descendants are now composited.
1158         if (layerBacking-&gt;updateCompositedBounds()) {
1159             layer.setNeedsCompositingGeometryUpdate();
1160             // Our geometry can affect descendants.
1161             updateLevel.add(UpdateLevel::CompositedChildren);
1162         }
1163 
1164         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
1165             if (layerBacking-&gt;updateConfiguration()) {
1166                 layerNeedsUpdate = true; // We also need to update geometry.
1167                 layer.setNeedsCompositingLayerConnection();
1168             }
1169 
1170             layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1171         }
1172 
1173         OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
1174         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate() || layer.needsScrollingTreeUpdate()) {
1175             layerBacking-&gt;updateGeometry();
1176             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
1177         }
1178 
1179         if (auto* reflection = layer.reflectionLayer()) {
1180             if (auto* reflectionBacking = reflection-&gt;backing()) {
1181                 reflectionBacking-&gt;updateCompositedBounds();
1182                 reflectionBacking-&gt;updateGeometry();
1183                 reflectionBacking-&gt;updateAfterDescendants();
1184             }
1185         }
1186 
1187         if (!layer.parent())
1188             updateRootLayerPosition();
1189 
1190         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
1191         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
1192         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, layerBacking-&gt;coordinatedScrollingRoles(), scrollingNodeChanges);
1193         stateForDescendants.nextChildIndex = 0;
1194 
1195 #if !LOG_DISABLED
1196         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);
1197 #else
1198         UNUSED_PARAM(depth);
1199 #endif
1200     }
1201 
1202     if (layer.childrenNeedCompositingGeometryUpdate())
1203         updateLevel.add(UpdateLevel::CompositedChildren);
1204 
1205     // If this layer has backing, then we are collecting its children, otherwise appending
1206     // to the compositing child list of an enclosing layer.
1207     Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; layerChildren;
1208     auto&amp; childList = layerBacking ? layerChildren : childLayersOfEnclosingLayer;
1209 
1210     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
1211         || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
1212 
1213     bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
1214 
1215 #if !ASSERT_DISABLED
1216     LayerListMutationDetector mutationChecker(layer);
1217 #endif
1218 
1219     auto appendForegroundLayerIfNecessary = [&amp;] () {
1220         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
1221         if (layer.negativeZOrderLayers().size()) {
1222             if (layerBacking &amp;&amp; layerBacking-&gt;foregroundLayer())
1223                 childList.append(*layerBacking-&gt;foregroundLayer());
1224         }
1225     };
1226 
1227     if (requireDescendantTraversal) {
1228         for (auto* renderLayer : layer.negativeZOrderLayers())
1229             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1230 
1231         appendForegroundLayerIfNecessary();
1232 
1233         for (auto* renderLayer : layer.normalFlowLayers())
1234             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1235 
1236         for (auto* renderLayer : layer.positiveZOrderLayers())
1237             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
1238     } else if (requiresChildRebuild)
1239         appendForegroundLayerIfNecessary();
1240 
1241     if (layerBacking) {
1242         if (requireDescendantTraversal || requiresChildRebuild) {
1243             bool parented = false;
1244             if (is&lt;RenderWidget&gt;(layer.renderer()))
1245                 parented = parentFrameContentLayers(downcast&lt;RenderWidget&gt;(layer.renderer()));
1246 
1247             if (!parented)
1248                 layerBacking-&gt;parentForSublayers()-&gt;setChildren(WTFMove(layerChildren));
1249 
1250             // If the layer has a clipping layer the overflow controls layers will be siblings of the clipping layer.
1251             // Otherwise, the overflow control layers are normal children.
1252             if (!layerBacking-&gt;hasClippingLayer() &amp;&amp; !layerBacking-&gt;hasScrollingLayer()) {
1253                 if (auto* overflowControlLayer = layerBacking-&gt;layerForHorizontalScrollbar())
1254                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1255 
1256                 if (auto* overflowControlLayer = layerBacking-&gt;layerForVerticalScrollbar())
1257                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1258 
1259                 if (auto* overflowControlLayer = layerBacking-&gt;layerForScrollCorner())
1260                     layerBacking-&gt;parentForSublayers()-&gt;addChild(*overflowControlLayer);
1261             }
1262         }
1263 
1264         childLayersOfEnclosingLayer.append(*layerBacking-&gt;childForSuperlayers());
1265 
1266         layerBacking-&gt;updateAfterDescendants();
1267     }
1268 
1269     layer.clearUpdateBackingOrHierarchyTraversalState();
1270 }
1271 
1272 void RenderLayerCompositor::appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childList)
1273 {
1274     if (!isMainFrameCompositor() || !m_compositing)
1275         return;
1276 
1277     if (!page().pageOverlayController().hasDocumentOverlays())
1278         return;
1279 
1280     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
1281     childList.append(WTFMove(overlayHost));
1282 }
1283 
1284 bool RenderLayerCompositor::needsCompositingForContentOrOverlays() const
1285 {
1286     return m_contentLayersCount + page().pageOverlayController().overlayCount();
1287 }
1288 
1289 void RenderLayerCompositor::layerBecameComposited(const RenderLayer&amp; layer)
1290 {
1291     if (&amp;layer != m_renderView.layer())
1292         ++m_contentLayersCount;
1293 }
1294 
1295 void RenderLayerCompositor::layerBecameNonComposited(const RenderLayer&amp; layer)
1296 {
1297     // Inform the inspector that the given RenderLayer was destroyed.
1298     // FIXME: &quot;destroyed&quot; is a misnomer.
1299     InspectorInstrumentation::renderLayerDestroyed(&amp;page(), layer);
1300 
1301     if (&amp;layer != m_renderView.layer()) {
1302         ASSERT(m_contentLayersCount &gt; 0);
1303         --m_contentLayersCount;
1304     }
1305 }
1306 
1307 #if !LOG_DISABLED
1308 void RenderLayerCompositor::logLayerInfo(const RenderLayer&amp; layer, const char* phase, int depth)
1309 {
1310     if (!compositingLogEnabled())
1311         return;
1312 
1313     auto* backing = layer.backing();
1314     RequiresCompositingData queryData;
1315     if (requiresCompositingLayer(layer, queryData) || layer.isRenderViewLayer()) {
1316         ++m_obligateCompositedLayerCount;
1317         m_obligatoryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1318     } else {
1319         ++m_secondaryCompositedLayerCount;
1320         m_secondaryBackingStoreBytes += backing-&gt;backingStoreMemoryEstimate();
1321     }
1322 
1323     LayoutRect absoluteBounds = backing-&gt;compositedBounds();
1324     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
1325 
1326     StringBuilder logString;
1327     logString.append(makeString(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;));
1328 
1329     if (!layer.renderer().style().hasAutoZIndex())
1330         logString.append(makeString(&quot; z-index: &quot;, layer.renderer().style().zIndex()));
1331 
1332     logString.appendLiteral(&quot; (&quot;);
1333     logString.append(logReasonsForCompositing(layer));
1334     logString.appendLiteral(&quot;) &quot;);
1335 
1336     if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1337         logString.append(&#39;[&#39;);
1338         bool prependSpace = false;
1339         if (backing-&gt;graphicsLayer()-&gt;contentsOpaque()) {
1340             logString.appendLiteral(&quot;opaque&quot;);
1341             prependSpace = true;
1342         }
1343 
1344         if (backing-&gt;paintsIntoCompositedAncestor()) {
1345             if (prependSpace)
1346                 logString.appendLiteral(&quot;, &quot;);
1347             logString.appendLiteral(&quot;paints into ancestor&quot;);
1348             prependSpace = true;
1349         }
1350 
1351         if (backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
1352             if (prependSpace)
1353                 logString.appendLiteral(&quot;, &quot;);
1354             if (backing-&gt;foregroundLayer() &amp;&amp; backing-&gt;backgroundLayer()) {
1355                 logString.appendLiteral(&quot;+foreground+background&quot;);
1356                 prependSpace = true;
1357             } else if (backing-&gt;foregroundLayer()) {
1358                 logString.appendLiteral(&quot;+foreground&quot;);
1359                 prependSpace = true;
1360             } else {
1361                 logString.appendLiteral(&quot;+background&quot;);
1362                 prependSpace = true;
1363             }
1364         }
1365 
1366         if (backing-&gt;paintsSubpixelAntialiasedText()) {
1367             if (prependSpace)
1368                 logString.appendLiteral(&quot;, &quot;);
1369             logString.appendLiteral(&quot;texty&quot;);
1370         }
1371 
1372         logString.appendLiteral(&quot;] &quot;);
1373     }
1374 
1375     logString.append(layer.name());
1376 
1377     logString.appendLiteral(&quot; - &quot;);
1378     logString.append(phase);
1379 
1380     LOG(Compositing, &quot;%s&quot;, logString.toString().utf8().data());
1381 }
1382 #endif
1383 
1384 static bool clippingChanged(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
1385 {
1386     return oldStyle.overflowX() != newStyle.overflowX() || oldStyle.overflowY() != newStyle.overflowY()
1387         || oldStyle.hasClip() != newStyle.hasClip() || oldStyle.clip() != newStyle.clip();
1388 }
1389 
1390 static bool styleAffectsLayerGeometry(const RenderStyle&amp; style)
1391 {
1392     return style.hasClip() || style.clipPath() || style.hasBorderRadius();
1393 }
1394 
1395 void RenderLayerCompositor::layerStyleChanged(StyleDifference diff, RenderLayer&amp; layer, const RenderStyle* oldStyle)
1396 {
1397     if (diff == StyleDifference::Equal)
1398         return;
1399 
1400     // Create or destroy backing here so that code that runs during layout can reliably use isComposited() (though this
1401     // is only true for layers composited for direct reasons).
1402     // Also, it allows us to avoid a tree walk in updateCompositingLayers() when no layer changed its compositing state.
1403     RequiresCompositingData queryData;
1404     queryData.layoutUpToDate = LayoutUpToDate::No;
1405 
1406     bool layerChanged = updateBacking(layer, queryData, CompositingChangeRepaintNow);
1407     if (layerChanged) {
1408         layer.setChildrenNeedCompositingGeometryUpdate();
1409         layer.setNeedsCompositingLayerConnection();
1410         layer.setSubsequentLayersNeedCompositingRequirementsTraversal();
1411         // Ancestor layers that composited for indirect reasons (things listed in styleChangeMayAffectIndirectCompositingReasons()) need to get updated.
1412         // This could be optimized by only setting this flag on layers with the relevant styles.
1413         layer.setNeedsPostLayoutCompositingUpdateOnAncestors();
1414     }
1415 
1416     if (queryData.reevaluateAfterLayout)
1417         layer.setNeedsPostLayoutCompositingUpdate();
1418 
1419     if (diff &gt;= StyleDifference::LayoutPositionedMovementOnly &amp;&amp; hasContentCompositingLayers()) {
1420         layer.setNeedsPostLayoutCompositingUpdate();
1421         layer.setNeedsCompositingGeometryUpdate();
1422     }
1423 
1424     auto* backing = layer.backing();
1425     if (!backing)
1426         return;
1427 
1428     backing-&gt;updateConfigurationAfterStyleChange();
1429 
1430     const auto&amp; newStyle = layer.renderer().style();
1431 
1432     if (diff &gt;= StyleDifference::Repaint) {
1433         // Visibility change may affect geometry of the enclosing composited layer.
1434         if (oldStyle &amp;&amp; oldStyle-&gt;visibility() != newStyle.visibility())
1435             layer.setNeedsCompositingGeometryUpdate();
1436 
1437         // We&#39;ll get a diff of Repaint when things like clip-path change; these might affect layer or inner-layer geometry.
1438         if (layer.isComposited() &amp;&amp; oldStyle) {
1439             if (styleAffectsLayerGeometry(*oldStyle) || styleAffectsLayerGeometry(newStyle))
1440                 layer.setNeedsCompositingGeometryUpdate();
1441         }
1442     }
1443 
1444     // This is necessary to get iframe layers hooked up in response to scheduleInvalidateStyleAndLayerComposition().
1445     if (diff == StyleDifference::RecompositeLayer &amp;&amp; layer.isComposited() &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer()))
1446         layer.setNeedsCompositingConfigurationUpdate();
1447 
1448     if (diff &gt;= StyleDifference::RecompositeLayer &amp;&amp; oldStyle) {
1449         if (oldStyle-&gt;transform() != newStyle.transform()) {
1450             // FIXME: transform changes really need to trigger layout. See RenderElement::adjustStyleDifference().
1451             layer.setNeedsPostLayoutCompositingUpdate();
1452             layer.setNeedsCompositingGeometryUpdate();
1453         }
1454     }
1455 
1456     if (diff &gt;= StyleDifference::Layout) {
1457         // FIXME: only set flags here if we know we have a composited descendant, but we might not know at this point.
1458         if (oldStyle &amp;&amp; clippingChanged(*oldStyle, newStyle)) {
1459             if (layer.isStackingContext()) {
1460                 layer.setNeedsPostLayoutCompositingUpdate(); // Layer needs to become composited if it has composited descendants.
1461                 layer.setNeedsCompositingConfigurationUpdate(); // If already composited, layer needs to create/destroy clipping layer.
1462             } else {
1463                 // Descendant (in containing block order) compositing layers need to re-evaluate their clipping,
1464                 // but they might be siblings in z-order so go up to our stacking context.
1465                 if (auto* stackingContext = layer.stackingContext())
1466                     stackingContext-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1467             }
1468         }
1469 
1470         // These properties trigger compositing if some descendant is composited.
1471         if (oldStyle &amp;&amp; styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1472             layer.setNeedsPostLayoutCompositingUpdate();
1473 
1474         layer.setNeedsCompositingGeometryUpdate();
1475     }
1476 }
1477 
1478 bool RenderLayerCompositor::needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp; layer, const RenderStyle* oldStyle) const
1479 {
1480     // Needed for scroll bars.
1481     if (layer.isRenderViewLayer())
1482         return true;
1483 
1484     if (!oldStyle)
1485         return false;
1486 
1487     const RenderStyle&amp; newStyle = layer.renderer().style();
1488     // Visibility change may affect geometry of the enclosing composited layer.
1489     if (oldStyle-&gt;visibility() != newStyle.visibility())
1490         return true;
1491 
1492     // We don&#39;t have any direct reasons for this style change to affect layer composition. Test if it might affect things indirectly.
1493     if (styleChangeMayAffectIndirectCompositingReasons(*oldStyle, newStyle))
1494         return true;
1495 
1496     return false;
1497 }
1498 
1499 bool RenderLayerCompositor::canCompositeClipPath(const RenderLayer&amp; layer)
1500 {
1501     ASSERT(layer.isComposited());
1502     ASSERT(layer.renderer().style().clipPath());
1503 
1504     if (layer.renderer().hasMask())
1505         return false;
1506 
1507     auto&amp; clipPath = *layer.renderer().style().clipPath();
1508     return (clipPath.type() != ClipPathOperation::Shape || clipPath.type() == ClipPathOperation::Shape) &amp;&amp; GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape);
1509 }
1510 
1511 // FIXME: remove and never ask questions about reflection layers.
1512 static RenderLayerModelObject&amp; rendererForCompositingTests(const RenderLayer&amp; layer)
1513 {
1514     auto* renderer = &amp;layer.renderer();
1515 
1516     // The compositing state of a reflection should match that of its reflected layer.
1517     if (layer.isReflection())
1518         renderer = downcast&lt;RenderLayerModelObject&gt;(renderer-&gt;parent()); // The RenderReplica&#39;s parent is the object being reflected.
1519 
1520     return *renderer;
1521 }
1522 
1523 void RenderLayerCompositor::updateRootContentLayerClipping()
1524 {
1525     m_rootContentsLayer-&gt;setMasksToBounds(!m_renderView.settings().backgroundShouldExtendBeyondPage());
1526 }
1527 
1528 bool RenderLayerCompositor::updateBacking(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint, BackingRequired backingRequired)
1529 {
1530     bool layerChanged = false;
1531     if (backingRequired == BackingRequired::Unknown)
1532         backingRequired = needsToBeComposited(layer, queryData) ? BackingRequired::Yes : BackingRequired::No;
1533     else {
1534         // Need to fetch viewportConstrainedNotCompositedReason, but without doing all the work that needsToBeComposited does.
1535         requiresCompositingForPosition(rendererForCompositingTests(layer), layer, queryData);
1536     }
1537 
1538     if (backingRequired == BackingRequired::Yes) {
1539         enableCompositingMode();
1540 
1541         if (!layer.backing()) {
1542             // If we need to repaint, do so before making backing
1543             if (shouldRepaint == CompositingChangeRepaintNow)
1544                 repaintOnCompositingChange(layer);
1545 
1546             layer.ensureBacking();
1547 
1548             if (layer.isRenderViewLayer() &amp;&amp; useCoordinatedScrollingForLayer(layer)) {
1549                 auto&amp; frameView = m_renderView.frameView();
1550                 if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1551                     scrollingCoordinator-&gt;frameViewRootLayerDidChange(frameView);
1552 #if ENABLE(RUBBER_BANDING)
1553                 updateLayerForHeader(frameView.headerHeight());
1554                 updateLayerForFooter(frameView.footerHeight());
1555 #endif
1556                 updateRootContentLayerClipping();
1557 
1558                 if (auto* tiledBacking = layer.backing()-&gt;tiledBacking())
1559                     tiledBacking-&gt;setTopContentInset(frameView.topContentInset());
1560             }
1561 
1562             // This layer and all of its descendants have cached repaints rects that are relative to
1563             // the repaint container, so change when compositing changes; we need to update them here.
1564             if (layer.parent())
1565                 layer.computeRepaintRectsIncludingDescendants();
1566 
1567             layer.setNeedsCompositingGeometryUpdate();
1568             layer.setNeedsCompositingConfigurationUpdate();
1569             layer.setNeedsCompositingPaintOrderChildrenUpdate();
1570 
1571             layerChanged = true;
1572         }
1573     } else {
1574         if (layer.backing()) {
1575             // If we&#39;re removing backing on a reflection, clear the source GraphicsLayer&#39;s pointer to
1576             // its replica GraphicsLayer. In practice this should never happen because reflectee and reflection
1577             // are both either composited, or not composited.
1578             if (layer.isReflection()) {
1579                 auto* sourceLayer = downcast&lt;RenderLayerModelObject&gt;(*layer.renderer().parent()).layer();
1580                 if (auto* backing = sourceLayer-&gt;backing()) {
1581                     ASSERT(backing-&gt;graphicsLayer()-&gt;replicaLayer() == layer.backing()-&gt;graphicsLayer());
1582                     backing-&gt;graphicsLayer()-&gt;setReplicatedByLayer(nullptr);
1583                 }
1584             }
1585 
1586             layer.clearBacking();
1587             layerChanged = true;
1588 
1589             // This layer and all of its descendants have cached repaints rects that are relative to
1590             // the repaint container, so change when compositing changes; we need to update them here.
1591             layer.computeRepaintRectsIncludingDescendants();
1592 
1593             // If we need to repaint, do so now that we&#39;ve removed the backing
1594             if (shouldRepaint == CompositingChangeRepaintNow)
1595                 repaintOnCompositingChange(layer);
1596         }
1597     }
1598 
1599 #if ENABLE(VIDEO)
1600     if (layerChanged &amp;&amp; is&lt;RenderVideo&gt;(layer.renderer())) {
1601         // If it&#39;s a video, give the media player a chance to hook up to the layer.
1602         downcast&lt;RenderVideo&gt;(layer.renderer()).acceleratedRenderingStateChanged();
1603     }
1604 #endif
1605 
1606     if (layerChanged &amp;&amp; is&lt;RenderWidget&gt;(layer.renderer())) {
1607         auto* innerCompositor = frameContentsCompositor(downcast&lt;RenderWidget&gt;(layer.renderer()));
1608         if (innerCompositor &amp;&amp; innerCompositor-&gt;usesCompositing())
1609             innerCompositor-&gt;updateRootLayerAttachment();
1610     }
1611 
1612     if (layerChanged)
1613         layer.clearClipRectsIncludingDescendants(PaintingClipRects);
1614 
1615     // If a fixed position layer gained/lost a backing or the reason not compositing it changed,
1616     // the scrolling coordinator needs to recalculate whether it can do fast scrolling.
1617     if (layer.renderer().isFixedPositioned()) {
1618         if (layer.viewportConstrainedNotCompositedReason() != queryData.nonCompositedForPositionReason) {
1619             layer.setViewportConstrainedNotCompositedReason(queryData.nonCompositedForPositionReason);
1620             layerChanged = true;
1621         }
1622         if (layerChanged) {
1623             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1624                 scrollingCoordinator-&gt;frameViewFixedObjectsDidChange(m_renderView.frameView());
1625         }
1626     } else
1627         layer.setViewportConstrainedNotCompositedReason(RenderLayer::NoNotCompositedReason);
1628 
1629     if (layer.backing())
1630         layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
1631 
1632     return layerChanged;
1633 }
1634 
1635 bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)
1636 {
1637     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
1638 
1639     // See if we need content or clipping layers. Methods called here should assume
1640     // that the compositing state of descendant layers has not been updated yet.
1641     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration())
1642         layerChanged = true;
1643 
1644     return layerChanged;
1645 }
1646 
1647 void RenderLayerCompositor::repaintOnCompositingChange(RenderLayer&amp; layer)
1648 {
1649     // If the renderer is not attached yet, no need to repaint.
1650     if (&amp;layer.renderer() != &amp;m_renderView &amp;&amp; !layer.renderer().parent())
1651         return;
1652 
1653     auto* repaintContainer = layer.renderer().containerForRepaint();
1654     if (!repaintContainer)
1655         repaintContainer = &amp;m_renderView;
1656 
1657     layer.repaintIncludingNonCompositingDescendants(repaintContainer);
1658     if (repaintContainer == &amp;m_renderView) {
1659         // The contents of this layer may be moving between the window
1660         // and a GraphicsLayer, so we need to make sure the window system
1661         // synchronizes those changes on the screen.
1662         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1663     }
1664 }
1665 
1666 // This method assumes that layout is up-to-date, unlike repaintOnCompositingChange().
1667 void RenderLayerCompositor::repaintInCompositedAncestor(RenderLayer&amp; layer, const LayoutRect&amp; rect)
1668 {
1669     auto* compositedAncestor = layer.enclosingCompositingLayerForRepaint(ExcludeSelf);
1670     if (!compositedAncestor)
1671         return;
1672 
1673     ASSERT(compositedAncestor-&gt;backing());
1674     LayoutRect repaintRect = rect;
1675     repaintRect.move(layer.offsetFromAncestor(compositedAncestor));
1676     compositedAncestor-&gt;setBackingNeedsRepaintInRect(repaintRect);
1677 
1678     // The contents of this layer may be moving from a GraphicsLayer to the window,
1679     // so we need to make sure the window system synchronizes those changes on the screen.
1680     if (compositedAncestor-&gt;isRenderViewLayer())
1681         m_renderView.frameView().setNeedsOneShotDrawingSynchronization();
1682 }
1683 
1684 // FIXME: remove.
1685 void RenderLayerCompositor::layerWasAdded(RenderLayer&amp;, RenderLayer&amp;)
1686 {
1687 }
1688 
1689 void RenderLayerCompositor::layerWillBeRemoved(RenderLayer&amp; parent, RenderLayer&amp; child)
1690 {
1691     if (!child.isComposited() || parent.renderer().renderTreeBeingDestroyed())
1692         return;
1693 
1694     repaintInCompositedAncestor(child, child.backing()-&gt;compositedBounds()); // FIXME: do via dirty bits?
1695 
1696     child.setNeedsCompositingLayerConnection();
1697 }
1698 
1699 RenderLayer* RenderLayerCompositor::enclosingNonStackingClippingLayer(const RenderLayer&amp; layer) const
1700 {
1701     for (auto* parent = layer.parent(); parent; parent = parent-&gt;parent()) {
1702         if (parent-&gt;isStackingContext())
1703             return nullptr;
1704         if (parent-&gt;renderer().hasClipOrOverflowClip())
1705             return parent;
1706     }
1707     return nullptr;
1708 }
1709 
1710 void RenderLayerCompositor::computeExtent(const OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent) const
1711 {
1712     if (extent.extentComputed)
1713         return;
1714 
1715     LayoutRect layerBounds;
1716     if (extent.hasTransformAnimation)
1717         extent.animationCausesExtentUncertainty = !layer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(layerBounds);
1718     else
1719         layerBounds = layer.overlapBounds();
1720 
1721     // In the animating transform case, we avoid double-accounting for the transform because
1722     // we told pushMappingsToAncestor() to ignore transforms earlier.
1723     extent.bounds = enclosingLayoutRect(overlapMap.geometryMap().absoluteRect(layerBounds));
1724 
1725     // Empty rects never intersect, but we need them to for the purposes of overlap testing.
1726     if (extent.bounds.isEmpty())
1727         extent.bounds.setSize(LayoutSize(1, 1));
1728 
1729 
1730     RenderLayerModelObject&amp; renderer = layer.renderer();
1731     if (renderer.isFixedPositioned() &amp;&amp; renderer.container() == &amp;m_renderView) {
1732         // Because fixed elements get moved around without re-computing overlap, we have to compute an overlap
1733         // rect that covers all the locations that the fixed element could move to.
1734         // FIXME: need to handle sticky too.
1735         extent.bounds = m_renderView.frameView().fixedScrollableAreaBoundsInflatedForScrolling(extent.bounds);
1736     }
1737 
1738     extent.extentComputed = true;
1739 }
1740 
1741 void RenderLayerCompositor::addToOverlapMap(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, OverlapExtent&amp; extent)
1742 {
1743     if (layer.isRenderViewLayer())
1744         return;
1745 
1746     computeExtent(overlapMap, layer, extent);
1747 
1748     LayoutRect clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
1749 
1750     // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.
1751     if (!m_renderView.settings().delegatesPageScaling())
1752         clipRect.scale(pageScaleFactor());
1753     clipRect.intersect(extent.bounds);
1754     overlapMap.add(clipRect);
1755 }
1756 
1757 void RenderLayerCompositor::addToOverlapMapRecursive(OverlapMap&amp; overlapMap, const RenderLayer&amp; layer, const RenderLayer* ancestorLayer)
1758 {
1759     if (!canBeComposited(layer))
1760         return;
1761 
1762     // A null ancestorLayer is an indication that &#39;layer&#39; has already been pushed.
1763     if (ancestorLayer)
1764         overlapMap.geometryMap().pushMappingsToAncestor(&amp;layer, ancestorLayer);
1765 
1766     OverlapExtent layerExtent;
1767     addToOverlapMap(overlapMap, layer, layerExtent);
1768 
1769 #if !ASSERT_DISABLED
1770     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
1771 #endif
1772 
1773     for (auto* renderLayer : layer.negativeZOrderLayers())
1774         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1775 
1776     for (auto* renderLayer : layer.normalFlowLayers())
1777         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1778 
1779     for (auto* renderLayer : layer.positiveZOrderLayers())
1780         addToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
1781 
1782     if (ancestorLayer)
1783         overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
1784 }
1785 
1786 #if ENABLE(VIDEO)
1787 bool RenderLayerCompositor::canAccelerateVideoRendering(RenderVideo&amp; video) const
1788 {
1789     if (!m_hasAcceleratedCompositing)
1790         return false;
1791 
1792     return video.supportsAcceleratedRendering();
1793 }
1794 #endif
1795 
1796 void RenderLayerCompositor::frameViewDidChangeLocation(const IntPoint&amp; contentsOffset)
1797 {
1798     if (m_overflowControlsHostLayer)
1799         m_overflowControlsHostLayer-&gt;setPosition(contentsOffset);
1800 }
1801 
1802 void RenderLayerCompositor::frameViewDidChangeSize()
1803 {
1804     if (auto* layer = m_renderView.layer())
1805         layer-&gt;setNeedsCompositingGeometryUpdate();
1806 
1807     if (m_scrolledContentsLayer) {
1808         updateScrollLayerClipping();
1809         frameViewDidScroll();
1810         updateOverflowControlsLayers();
1811 
1812 #if ENABLE(RUBBER_BANDING)
1813         if (m_layerForOverhangAreas) {
1814             auto&amp; frameView = m_renderView.frameView();
1815             m_layerForOverhangAreas-&gt;setSize(frameView.frameRect().size());
1816             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, frameView.topContentInset()));
1817         }
1818 #endif
1819     }
1820 }
1821 
1822 bool RenderLayerCompositor::hasCoordinatedScrolling() const
1823 {
1824     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
1825     return scrollingCoordinator &amp;&amp; scrollingCoordinator-&gt;coordinatesScrollingForFrameView(m_renderView.frameView());
1826 }
1827 
1828 void RenderLayerCompositor::updateScrollLayerPosition()
1829 {
1830     ASSERT(!hasCoordinatedScrolling());
1831     ASSERT(m_scrolledContentsLayer);
1832 
1833     auto&amp; frameView = m_renderView.frameView();
1834     IntPoint scrollPosition = frameView.scrollPosition();
1835 
1836     m_scrolledContentsLayer-&gt;setPosition(FloatPoint(-scrollPosition.x(), -scrollPosition.y()));
1837 
1838     if (auto* fixedBackgroundLayer = fixedRootBackgroundLayer())
1839         fixedBackgroundLayer-&gt;setPosition(frameView.scrollPositionForFixedPosition());
1840 }
1841 
1842 void RenderLayerCompositor::updateScrollLayerClipping()
1843 {
1844     auto* layerForClipping = this-&gt;layerForClipping();
1845     if (!layerForClipping)
1846         return;
1847 
1848     layerForClipping-&gt;setSize(m_renderView.frameView().sizeForVisibleContent());
1849     layerForClipping-&gt;setPosition(positionForClipLayer());
1850 }
1851 
1852 FloatPoint RenderLayerCompositor::positionForClipLayer() const
1853 {
1854     auto&amp; frameView = m_renderView.frameView();
1855 
1856     return FloatPoint(
1857         frameView.shouldPlaceBlockDirectionScrollbarOnLeft() ? frameView.horizontalScrollbarIntrusion() : 0,
1858         FrameView::yPositionForInsetClipLayer(frameView.scrollPosition(), frameView.topContentInset()));
1859 }
1860 
1861 void RenderLayerCompositor::frameViewDidScroll()
1862 {
1863     if (!m_scrolledContentsLayer)
1864         return;
1865 
1866     // If there&#39;s a scrolling coordinator that manages scrolling for this frame view,
1867     // it will also manage updating the scroll layer position.
1868     if (hasCoordinatedScrolling()) {
1869         // We have to schedule a flush in order for the main TiledBacking to update its tile coverage.
1870         scheduleLayerFlushNow();
1871         return;
1872     }
1873 
1874     updateScrollLayerPosition();
1875 }
1876 
1877 void RenderLayerCompositor::frameViewDidAddOrRemoveScrollbars()
1878 {
1879     updateOverflowControlsLayers();
1880 }
1881 
1882 void RenderLayerCompositor::frameViewDidLayout()
1883 {
1884     if (auto* renderViewBacking = m_renderView.layer()-&gt;backing())
1885         renderViewBacking-&gt;adjustTiledBackingCoverage();
1886 }
1887 
1888 void RenderLayerCompositor::rootLayerConfigurationChanged()
1889 {
1890     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
1891     if (renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking()) {
1892         m_renderView.layer()-&gt;setNeedsCompositingConfigurationUpdate();
1893         scheduleCompositingLayerUpdate();
1894     }
1895 }
1896 
1897 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
1898 {
1899     updateCompositingLayers(CompositingUpdateType::AfterLayout);
1900 
1901     if (!m_rootContentsLayer)
1902         return String();
1903 
1904     flushPendingLayerChanges(true);
1905 
1906     LayerTreeAsTextBehavior layerTreeBehavior = LayerTreeAsTextBehaviorNormal;
1907     if (flags &amp; LayerTreeFlagsIncludeDebugInfo)
1908         layerTreeBehavior |= LayerTreeAsTextDebug;
1909     if (flags &amp; LayerTreeFlagsIncludeVisibleRects)
1910         layerTreeBehavior |= LayerTreeAsTextIncludeVisibleRects;
1911     if (flags &amp; LayerTreeFlagsIncludeTileCaches)
1912         layerTreeBehavior |= LayerTreeAsTextIncludeTileCaches;
1913     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
1914         layerTreeBehavior |= LayerTreeAsTextIncludeRepaintRects;
1915     if (flags &amp; LayerTreeFlagsIncludePaintingPhases)
1916         layerTreeBehavior |= LayerTreeAsTextIncludePaintingPhases;
1917     if (flags &amp; LayerTreeFlagsIncludeContentLayers)
1918         layerTreeBehavior |= LayerTreeAsTextIncludeContentLayers;
1919     if (flags &amp; LayerTreeFlagsIncludeAcceleratesDrawing)
1920         layerTreeBehavior |= LayerTreeAsTextIncludeAcceleratesDrawing;
1921     if (flags &amp; LayerTreeFlagsIncludeBackingStoreAttached)
1922         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
1923     if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
1924         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
1925 
1926     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
1927     // similar between platforms.
1928     String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
1929 
1930     // Dump an empty layer tree only if the only composited layer is the main frame&#39;s tiled backing,
1931     // so that tests expecting us to drop out of accelerated compositing when there are no layers succeed.
1932     if (!hasContentCompositingLayers() &amp;&amp; documentUsesTiledBacking() &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeTileCaches) &amp;&amp; !(layerTreeBehavior &amp; LayerTreeAsTextIncludeRootLayerProperties))
1933         layerTreeText = emptyString();
1934 
1935     // The true root layer is not included in the dump, so if we want to report
1936     // its repaint rects, they must be included here.
1937     if (flags &amp; LayerTreeFlagsIncludeRepaintRects)
1938         return m_renderView.frameView().trackedRepaintRectsAsText() + layerTreeText;
1939 
1940     return layerTreeText;
1941 }
1942 
1943 static RenderView* frameContentsRenderView(RenderWidget&amp; renderer)
1944 {
1945     if (auto* contentDocument = renderer.frameOwnerElement().contentDocument())
1946         return contentDocument-&gt;renderView();
1947 
1948     return nullptr;
1949 }
1950 
1951 RenderLayerCompositor* RenderLayerCompositor::frameContentsCompositor(RenderWidget&amp; renderer)
1952 {
1953     if (auto* view = frameContentsRenderView(renderer))
1954         return &amp;view-&gt;compositor();
1955 
1956     return nullptr;
1957 }
1958 
1959 bool RenderLayerCompositor::parentFrameContentLayers(RenderWidget&amp; renderer)
1960 {
1961     auto* innerCompositor = frameContentsCompositor(renderer);
1962     if (!innerCompositor || !innerCompositor-&gt;usesCompositing() || innerCompositor-&gt;rootLayerAttachment() != RootLayerAttachedViaEnclosingFrame)
1963         return false;
1964 
1965     auto* layer = renderer.layer();
1966     if (!layer-&gt;isComposited())
1967         return false;
1968 
1969     auto* backing = layer-&gt;backing();
1970     auto* hostingLayer = backing-&gt;parentForSublayers();
1971     auto* rootLayer = innerCompositor-&gt;rootGraphicsLayer();
1972     if (hostingLayer-&gt;children().size() != 1 || hostingLayer-&gt;children()[0].ptr() != rootLayer) {
1973         hostingLayer-&gt;removeAllChildren();
1974         hostingLayer-&gt;addChild(*rootLayer);
1975     }
1976 
1977     if (auto frameHostingNodeID = backing-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting)) {
1978         auto* contentsRenderView = frameContentsRenderView(renderer);
1979         if (auto frameRootScrollingNodeID = contentsRenderView-&gt;frameView().scrollingNodeID()) {
1980             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
1981                 scrollingCoordinator-&gt;insertNode(ScrollingNodeType::Subframe, frameRootScrollingNodeID, frameHostingNodeID, 0);
1982         }
1983     }
1984 
1985     // FIXME: Why always return true and not just when the layers changed?
1986     return true;
1987 }
1988 
1989 void RenderLayerCompositor::repaintCompositedLayers()
1990 {
1991     recursiveRepaintLayer(rootRenderLayer());
1992 }
1993 
1994 void RenderLayerCompositor::recursiveRepaintLayer(RenderLayer&amp; layer)
1995 {
1996     layer.updateLayerListsIfNeeded();
1997 
1998     // FIXME: This method does not work correctly with transforms.
1999     if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
2000         layer.setBackingNeedsRepaint();
2001 
2002 #if !ASSERT_DISABLED
2003     LayerListMutationDetector mutationChecker(layer);
2004 #endif
2005 
2006     if (layer.hasCompositingDescendant()) {
2007         for (auto* renderLayer : layer.negativeZOrderLayers())
2008             recursiveRepaintLayer(*renderLayer);
2009 
2010         for (auto* renderLayer : layer.positiveZOrderLayers())
2011             recursiveRepaintLayer(*renderLayer);
2012     }
2013 
2014     for (auto* renderLayer : layer.normalFlowLayers())
2015         recursiveRepaintLayer(*renderLayer);
2016 }
2017 
2018 RenderLayer&amp; RenderLayerCompositor::rootRenderLayer() const
2019 {
2020     return *m_renderView.layer();
2021 }
2022 
2023 GraphicsLayer* RenderLayerCompositor::rootGraphicsLayer() const
2024 {
2025     if (m_overflowControlsHostLayer)
2026         return m_overflowControlsHostLayer.get();
2027     return m_rootContentsLayer.get();
2028 }
2029 
2030 void RenderLayerCompositor::setIsInWindow(bool isInWindow)
2031 {
2032     LOG(Compositing, &quot;RenderLayerCompositor %p setIsInWindow %d&quot;, this, isInWindow);
2033 
2034     if (!usesCompositing())
2035         return;
2036 
2037     if (auto* rootLayer = rootGraphicsLayer()) {
2038         GraphicsLayer::traverse(*rootLayer, [isInWindow](GraphicsLayer&amp; layer) {
2039             layer.setIsInWindow(isInWindow);
2040         });
2041     }
2042 
2043     if (isInWindow) {
2044         if (m_rootLayerAttachment != RootLayerUnattached)
2045             return;
2046 
2047         RootLayerAttachment attachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
2048         attachRootLayer(attachment);
2049 #if PLATFORM(IOS_FAMILY)
2050         if (m_legacyScrollingLayerCoordinator) {
2051             m_legacyScrollingLayerCoordinator-&gt;registerAllViewportConstrainedLayers(*this);
2052             m_legacyScrollingLayerCoordinator-&gt;registerAllScrollingLayers();
2053         }
2054 #endif
2055     } else {
2056         if (m_rootLayerAttachment == RootLayerUnattached)
2057             return;
2058 
2059         detachRootLayer();
2060 #if PLATFORM(IOS_FAMILY)
2061         if (m_legacyScrollingLayerCoordinator) {
2062             m_legacyScrollingLayerCoordinator-&gt;unregisterAllViewportConstrainedLayers();
2063             m_legacyScrollingLayerCoordinator-&gt;unregisterAllScrollingLayers();
2064         }
2065 #endif
2066     }
2067 }
2068 
2069 void RenderLayerCompositor::clearBackingForLayerIncludingDescendants(RenderLayer&amp; layer)
2070 {
2071     if (layer.isComposited())
2072         layer.clearBacking();
2073 
2074     for (auto* childLayer = layer.firstChild(); childLayer; childLayer = childLayer-&gt;nextSibling())
2075         clearBackingForLayerIncludingDescendants(*childLayer);
2076 }
2077 
2078 void RenderLayerCompositor::clearBackingForAllLayers()
2079 {
2080     clearBackingForLayerIncludingDescendants(*m_renderView.layer());
2081 }
2082 
2083 void RenderLayerCompositor::updateRootLayerPosition()
2084 {
2085     if (m_rootContentsLayer) {
2086         m_rootContentsLayer-&gt;setSize(m_renderView.frameView().contentsSize());
2087         m_rootContentsLayer-&gt;setPosition(m_renderView.frameView().positionForRootContentLayer());
2088         m_rootContentsLayer-&gt;setAnchorPoint(FloatPoint3D());
2089     }
2090 
2091     updateScrollLayerClipping();
2092 
2093 #if ENABLE(RUBBER_BANDING)
2094     if (m_contentShadowLayer &amp;&amp; m_rootContentsLayer) {
2095         m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
2096         m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
2097     }
2098 
2099     updateLayerForTopOverhangArea(m_layerForTopOverhangArea != nullptr);
2100     updateLayerForBottomOverhangArea(m_layerForBottomOverhangArea != nullptr);
2101     updateLayerForHeader(m_layerForHeader != nullptr);
2102     updateLayerForFooter(m_layerForFooter != nullptr);
2103 #endif
2104 }
2105 
2106 bool RenderLayerCompositor::has3DContent() const
2107 {
2108     return layerHas3DContent(rootRenderLayer());
2109 }
2110 
2111 bool RenderLayerCompositor::needsToBeComposited(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2112 {
2113     if (!canBeComposited(layer))
2114         return false;
2115 
2116     return requiresCompositingLayer(layer, queryData) || layer.mustCompositeForIndirectReasons() || (usesCompositing() &amp;&amp; layer.isRenderViewLayer());
2117 }
2118 
2119 // Note: this specifies whether the RL needs a compositing layer for intrinsic reasons.
2120 // Use needsToBeComposited() to determine if a RL actually needs a compositing layer.
2121 // FIXME: is clipsCompositingDescendants() an intrinsic reason?
2122 bool RenderLayerCompositor::requiresCompositingLayer(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2123 {
2124     auto&amp; renderer = rendererForCompositingTests(layer);
2125 
2126     // The root layer always has a compositing layer, but it may not have backing.
2127     return requiresCompositingForTransform(renderer)
2128         || requiresCompositingForAnimation(renderer)
2129         || clipsCompositingDescendants(*renderer.layer())
2130         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
2131         || requiresCompositingForCanvas(renderer)
2132         || requiresCompositingForFilters(renderer)
2133         || requiresCompositingForWillChange(renderer)
2134         || requiresCompositingForBackfaceVisibility(renderer)
2135         || requiresCompositingForVideo(renderer)
2136         || requiresCompositingForFrame(renderer, queryData)
2137         || requiresCompositingForPlugin(renderer, queryData)
2138         || requiresCompositingForEditableImage(renderer)
2139         || requiresCompositingForOverflowScrolling(*renderer.layer(), queryData);
2140 }
2141 
2142 bool RenderLayerCompositor::canBeComposited(const RenderLayer&amp; layer) const
2143 {
2144     if (m_hasAcceleratedCompositing &amp;&amp; layer.isSelfPaintingLayer()) {
2145         if (!layer.isInsideFragmentedFlow())
2146             return true;
2147 
2148         // CSS Regions flow threads do not need to be composited as we use composited RenderFragmentContainers
2149         // to render the background of the RenderFragmentedFlow.
2150         if (layer.isRenderFragmentedFlow())
2151             return false;
2152 
2153         return true;
2154     }
2155     return false;
2156 }
2157 
2158 #if ENABLE(FULLSCREEN_API)
2159 enum class FullScreenDescendant { Yes, No, NotApplicable };
2160 static FullScreenDescendant isDescendantOfFullScreenLayer(const RenderLayer&amp; layer)
2161 {
2162     auto&amp; document = layer.renderer().document();
2163 
2164     if (!document.webkitIsFullScreen() || !document.fullScreenRenderer())
2165         return FullScreenDescendant::NotApplicable;
2166 
2167     auto* fullScreenLayer = document.fullScreenRenderer()-&gt;layer();
2168     if (!fullScreenLayer) {
2169         ASSERT_NOT_REACHED();
2170         return FullScreenDescendant::NotApplicable;
2171     }
2172 
2173     return layer.isDescendantOf(*fullScreenLayer) ? FullScreenDescendant::Yes : FullScreenDescendant::No;
2174 }
2175 #endif
2176 
2177 bool RenderLayerCompositor::requiresOwnBackingStore(const RenderLayer&amp; layer, const RenderLayer* compositingAncestorLayer, const LayoutRect&amp; layerCompositedBoundsInAncestor, const LayoutRect&amp; ancestorCompositedBounds) const
2178 {
2179     auto&amp; renderer = layer.renderer();
2180 
2181     if (compositingAncestorLayer
2182         &amp;&amp; !(compositingAncestorLayer-&gt;backing()-&gt;graphicsLayer()-&gt;drawsContent()
2183             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoWindow()
2184             || compositingAncestorLayer-&gt;backing()-&gt;paintsIntoCompositedAncestor()))
2185         return true;
2186 
2187     RequiresCompositingData queryData;
2188     if (layer.isRenderViewLayer()
2189         || layer.transform() // note: excludes perspective and transformStyle3D.
2190         || requiresCompositingForAnimation(renderer)
2191         || requiresCompositingForPosition(renderer, layer, queryData)
2192         || requiresCompositingForCanvas(renderer)
2193         || requiresCompositingForFilters(renderer)
2194         || requiresCompositingForWillChange(renderer)
2195         || requiresCompositingForBackfaceVisibility(renderer)
2196         || requiresCompositingForVideo(renderer)
2197         || requiresCompositingForFrame(renderer, queryData)
2198         || requiresCompositingForPlugin(renderer, queryData)
2199         || requiresCompositingForEditableImage(renderer)
2200         || requiresCompositingForOverflowScrolling(layer, queryData)
2201         || needsContentsCompositingLayer(layer)
2202         || renderer.isTransparent()
2203         || renderer.hasMask()
2204         || renderer.hasReflection()
2205         || renderer.hasFilter()
2206         || renderer.hasBackdropFilter())
2207         return true;
2208 
2209     if (layer.mustCompositeForIndirectReasons()) {
2210         RenderLayer::IndirectCompositingReason reason = layer.indirectCompositingReason();
2211         return reason == RenderLayer::IndirectCompositingReason::Overlap
2212             || reason == RenderLayer::IndirectCompositingReason::Stacking
2213             || reason == RenderLayer::IndirectCompositingReason::BackgroundLayer
2214             || reason == RenderLayer::IndirectCompositingReason::GraphicalEffect
2215             || reason == RenderLayer::IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
2216     }
2217 
2218     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
2219         return true;
2220 
2221     return false;
2222 }
2223 
2224 OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
2225 {
2226     OptionSet&lt;CompositingReason&gt; reasons;
2227 
2228     if (!layer.isComposited())
2229         return reasons;
2230 
2231     RequiresCompositingData queryData;
2232 
2233     auto&amp; renderer = rendererForCompositingTests(layer);
2234 
2235     if (requiresCompositingForTransform(renderer))
2236         reasons.add(CompositingReason::Transform3D);
2237 
2238     if (requiresCompositingForVideo(renderer))
2239         reasons.add(CompositingReason::Video);
2240     else if (requiresCompositingForCanvas(renderer))
2241         reasons.add(CompositingReason::Canvas);
2242     else if (requiresCompositingForPlugin(renderer, queryData))
2243         reasons.add(CompositingReason::Plugin);
2244     else if (requiresCompositingForFrame(renderer, queryData))
2245         reasons.add(CompositingReason::IFrame);
2246     else if (requiresCompositingForEditableImage(renderer))
2247         reasons.add(CompositingReason::EmbeddedView);
2248 
2249     if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
2250         reasons.add(CompositingReason::BackfaceVisibilityHidden);
2251 
2252     if (clipsCompositingDescendants(*renderer.layer()))
2253         reasons.add(CompositingReason::ClipsCompositingDescendants);
2254 
2255     if (requiresCompositingForAnimation(renderer))
2256         reasons.add(CompositingReason::Animation);
2257 
2258     if (requiresCompositingForFilters(renderer))
2259         reasons.add(CompositingReason::Filters);
2260 
2261     if (requiresCompositingForWillChange(renderer))
2262         reasons.add(CompositingReason::WillChange);
2263 
2264     if (requiresCompositingForPosition(renderer, *renderer.layer(), queryData))
2265         reasons.add(renderer.isFixedPositioned() ? CompositingReason::PositionFixed : CompositingReason::PositionSticky);
2266 
2267     if (requiresCompositingForOverflowScrolling(*renderer.layer(), queryData))
2268         reasons.add(CompositingReason::OverflowScrollingTouch);
2269 
2270     switch (renderer.layer()-&gt;indirectCompositingReason()) {
2271     case RenderLayer::IndirectCompositingReason::None:
2272         break;
2273     case RenderLayer::IndirectCompositingReason::Stacking:
2274         reasons.add(CompositingReason::Stacking);
2275         break;
2276     case RenderLayer::IndirectCompositingReason::Overlap:
2277         reasons.add(CompositingReason::Overlap);
2278         break;
2279     case RenderLayer::IndirectCompositingReason::BackgroundLayer:
2280         reasons.add(CompositingReason::NegativeZIndexChildren);
2281         break;
2282     case RenderLayer::IndirectCompositingReason::GraphicalEffect:
2283         if (renderer.hasTransform())
2284             reasons.add(CompositingReason::TransformWithCompositedDescendants);
2285 
2286         if (renderer.isTransparent())
2287             reasons.add(CompositingReason::OpacityWithCompositedDescendants);
2288 
2289         if (renderer.hasMask())
2290             reasons.add(CompositingReason::MaskWithCompositedDescendants);
2291 
2292         if (renderer.hasReflection())
2293             reasons.add(CompositingReason::ReflectionWithCompositedDescendants);
2294 
2295         if (renderer.hasFilter() || renderer.hasBackdropFilter())
2296             reasons.add(CompositingReason::FilterWithCompositedDescendants);
2297 
2298 #if ENABLE(CSS_COMPOSITING)
2299         if (layer.isolatesCompositedBlending())
2300             reasons.add(CompositingReason::IsolatesCompositedBlendingDescendants);
2301 
2302         if (layer.hasBlendMode())
2303             reasons.add(CompositingReason::BlendingWithCompositedDescendants);
2304 #endif
2305         break;
2306     case RenderLayer::IndirectCompositingReason::Perspective:
2307         reasons.add(CompositingReason::Perspective);
2308         break;
2309     case RenderLayer::IndirectCompositingReason::Preserve3D:
2310         reasons.add(CompositingReason::Preserve3D);
2311         break;
2312     }
2313 
2314     if (usesCompositing() &amp;&amp; renderer.layer()-&gt;isRenderViewLayer())
2315         reasons.add(CompositingReason::Root);
2316 
2317     return reasons;
2318 }
2319 
2320 #if !LOG_DISABLED
2321 const char* RenderLayerCompositor::logReasonsForCompositing(const RenderLayer&amp; layer)
2322 {
2323     OptionSet&lt;CompositingReason&gt; reasons = reasonsForCompositing(layer);
2324 
2325     if (reasons &amp; CompositingReason::Transform3D)
2326         return &quot;3D transform&quot;;
2327 
2328     if (reasons &amp; CompositingReason::Video)
2329         return &quot;video&quot;;
2330 
2331     if (reasons &amp; CompositingReason::Canvas)
2332         return &quot;canvas&quot;;
2333 
2334     if (reasons &amp; CompositingReason::Plugin)
2335         return &quot;plugin&quot;;
2336 
2337     if (reasons &amp; CompositingReason::IFrame)
2338         return &quot;iframe&quot;;
2339 
2340     if (reasons &amp; CompositingReason::BackfaceVisibilityHidden)
2341         return &quot;backface-visibility: hidden&quot;;
2342 
2343     if (reasons &amp; CompositingReason::ClipsCompositingDescendants)
2344         return &quot;clips compositing descendants&quot;;
2345 
2346     if (reasons &amp; CompositingReason::Animation)
2347         return &quot;animation&quot;;
2348 
2349     if (reasons &amp; CompositingReason::Filters)
2350         return &quot;filters&quot;;
2351 
2352     if (reasons &amp; CompositingReason::PositionFixed)
2353         return &quot;position: fixed&quot;;
2354 
2355     if (reasons &amp; CompositingReason::PositionSticky)
2356         return &quot;position: sticky&quot;;
2357 
2358     if (reasons &amp; CompositingReason::OverflowScrollingTouch)
2359         return &quot;-webkit-overflow-scrolling: touch&quot;;
2360 
2361     if (reasons &amp; CompositingReason::Stacking)
2362         return &quot;stacking&quot;;
2363 
2364     if (reasons &amp; CompositingReason::Overlap)
2365         return &quot;overlap&quot;;
2366 
2367     if (reasons &amp; CompositingReason::NegativeZIndexChildren)
2368         return &quot;negative z-index children&quot;;
2369 
2370     if (reasons &amp; CompositingReason::TransformWithCompositedDescendants)
2371         return &quot;transform with composited descendants&quot;;
2372 
2373     if (reasons &amp; CompositingReason::OpacityWithCompositedDescendants)
2374         return &quot;opacity with composited descendants&quot;;
2375 
2376     if (reasons &amp; CompositingReason::MaskWithCompositedDescendants)
2377         return &quot;mask with composited descendants&quot;;
2378 
2379     if (reasons &amp; CompositingReason::ReflectionWithCompositedDescendants)
2380         return &quot;reflection with composited descendants&quot;;
2381 
2382     if (reasons &amp; CompositingReason::FilterWithCompositedDescendants)
2383         return &quot;filter with composited descendants&quot;;
2384 
2385 #if ENABLE(CSS_COMPOSITING)
2386     if (reasons &amp; CompositingReason::BlendingWithCompositedDescendants)
2387         return &quot;blending with composited descendants&quot;;
2388 
2389     if (reasons &amp; CompositingReason::IsolatesCompositedBlendingDescendants)
2390         return &quot;isolates composited blending descendants&quot;;
2391 #endif
2392 
2393     if (reasons &amp; CompositingReason::Perspective)
2394         return &quot;perspective&quot;;
2395 
2396     if (reasons &amp; CompositingReason::Preserve3D)
2397         return &quot;preserve-3d&quot;;
2398 
2399     if (reasons &amp; CompositingReason::Root)
2400         return &quot;root&quot;;
2401 
2402     return &quot;&quot;;
2403 }
2404 #endif
2405 
2406 // Return true if the given layer has some ancestor in the RenderLayer hierarchy that clips,
2407 // up to the enclosing compositing ancestor. This is required because compositing layers are parented
2408 // according to the z-order hierarchy, yet clipping goes down the renderer hierarchy.
2409 // Thus, a RenderLayer can be clipped by a RenderLayer that is an ancestor in the renderer hierarchy,
2410 // but a sibling in the z-order hierarchy.
2411 // FIXME: can we do this without a tree walk?
2412 bool RenderLayerCompositor::clippedByAncestor(RenderLayer&amp; layer) const
2413 {
2414     ASSERT(layer.isComposited());
2415     if (!layer.parent())
2416         return false;
2417 
2418     // On first pass in WK1, the root may not have become composited yet.
2419     auto* compositingAncestor = layer.ancestorCompositingLayer();
2420     if (!compositingAncestor)
2421         return false;
2422 
2423     // If the compositingAncestor clips, that will be taken care of by clipsCompositingDescendants(),
2424     // so we only care about clipping between its first child that is our ancestor (the computeClipRoot),
2425     // and layer. The exception is when the compositingAncestor isolates composited blending children,
2426     // in this case it is not allowed to clipsCompositingDescendants() and each of its children
2427     // will be clippedByAncestor()s, including the compositingAncestor.
2428     auto* computeClipRoot = compositingAncestor;
2429     if (!compositingAncestor-&gt;isolatesCompositedBlending()) {
2430         computeClipRoot = nullptr;
2431         auto* parent = &amp;layer;
2432         while (parent) {
2433             auto* next = parent-&gt;parent();
2434             if (next == compositingAncestor) {
2435                 computeClipRoot = parent;
2436                 break;
2437             }
2438             parent = next;
2439         }
2440 
2441         if (!computeClipRoot || computeClipRoot == &amp;layer)
2442             return false;
2443     }
2444 
2445     return !layer.backgroundClipRect(RenderLayer::ClipRectsContext(computeClipRoot, TemporaryClipRects)).isInfinite(); // FIXME: Incorrect for CSS regions.
2446 }
2447 
2448 // Return true if the given layer is a stacking context and has compositing child
2449 // layers that it needs to clip. In this case we insert a clipping GraphicsLayer
2450 // into the hierarchy between this layer and its children in the z-order hierarchy.
2451 bool RenderLayerCompositor::clipsCompositingDescendants(const RenderLayer&amp; layer) const
2452 {
2453     return layer.hasCompositingDescendant() &amp;&amp; layer.renderer().hasClipOrOverflowClip() &amp;&amp; !layer.isolatesCompositedBlending();
2454 }
2455 
2456 bool RenderLayerCompositor::requiresCompositingForAnimation(RenderLayerModelObject&amp; renderer) const
2457 {
2458     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2459         return false;
2460 
2461     if (auto* element = renderer.element()) {
2462         if (auto* timeline = element-&gt;document().existingTimeline()) {
2463             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))
2464                 return true;
2465         }
2466     }
2467 
2468     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
2469         return false;
2470 
2471     auto&amp; animController = renderer.animation();
2472     return (animController.isRunningAnimationOnRenderer(renderer, CSSPropertyOpacity)
2473         &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))
2474         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyFilter)
2475 #if ENABLE(FILTERS_LEVEL_2)
2476         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyWebkitBackdropFilter)
2477 #endif
2478         || animController.isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2479 }
2480 
2481 bool RenderLayerCompositor::requiresCompositingForTransform(RenderLayerModelObject&amp; renderer) const
2482 {
2483     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2484         return false;
2485 
2486     // Note that we ask the renderer if it has a transform, because the style may have transforms,
2487     // but the renderer may be an inline that doesn&#39;t suppport them.
2488     if (!renderer.hasTransform())
2489         return false;
2490 
2491     switch (m_compositingPolicy) {
2492     case CompositingPolicy::Normal:
2493         return renderer.style().transform().has3DOperation();
2494     case CompositingPolicy::Conservative:
2495         // Continue to allow pages to avoid the very slow software filter path.
2496         if (renderer.style().transform().has3DOperation() &amp;&amp; renderer.hasFilter())
2497             return true;
2498         return renderer.style().transform().isRepresentableIn2D() ? false : true;
2499     }
2500     return false;
2501 }
2502 
2503 bool RenderLayerCompositor::requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp; renderer) const
2504 {
2505     if (!(m_compositingTriggers &amp; ChromeClient::ThreeDTransformTrigger))
2506         return false;
2507 
2508     if (renderer.style().backfaceVisibility() != BackfaceVisibility::Hidden)
2509         return false;
2510 
2511     if (renderer.layer()-&gt;has3DTransformedAncestor())
2512         return true;
2513 
2514     // FIXME: workaround for webkit.org/b/132801
2515     auto* stackingContext = renderer.layer()-&gt;stackingContext();
2516     if (stackingContext &amp;&amp; stackingContext-&gt;renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D)
2517         return true;
2518 
2519     return false;
2520 }
2521 
2522 bool RenderLayerCompositor::requiresCompositingForVideo(RenderLayerModelObject&amp; renderer) const
2523 {
2524     if (!(m_compositingTriggers &amp; ChromeClient::VideoTrigger))
2525         return false;
2526 
2527 #if ENABLE(VIDEO)
2528     if (!is&lt;RenderVideo&gt;(renderer))
2529         return false;
2530 
2531     auto&amp; video = downcast&lt;RenderVideo&gt;(renderer);
2532     if ((video.requiresImmediateCompositing() || video.shouldDisplayVideo()) &amp;&amp; canAccelerateVideoRendering(video))
2533         return true;
2534 #else
2535     UNUSED_PARAM(renderer);
2536 #endif
2537     return false;
2538 }
2539 
2540 bool RenderLayerCompositor::requiresCompositingForCanvas(RenderLayerModelObject&amp; renderer) const
2541 {
2542     if (!(m_compositingTriggers &amp; ChromeClient::CanvasTrigger))
2543         return false;
2544 
2545     if (!renderer.isCanvas())
2546         return false;
2547 
2548     bool isCanvasLargeEnoughToForceCompositing = true;
2549 #if !USE(COMPOSITING_FOR_SMALL_CANVASES)
2550     auto* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer.element());
2551     auto canvasArea = canvas-&gt;size().area&lt;RecordOverflow&gt;();
2552     isCanvasLargeEnoughToForceCompositing = !canvasArea.hasOverflowed() &amp;&amp; canvasArea.unsafeGet() &gt;= canvasAreaThresholdRequiringCompositing;
2553 #endif
2554 
2555     CanvasCompositingStrategy compositingStrategy = canvasCompositingStrategy(renderer);
2556     if (compositingStrategy == CanvasAsLayerContents)
2557         return true;
2558 
2559     if (m_compositingPolicy == CompositingPolicy::Normal)
2560         return compositingStrategy == CanvasPaintedToLayer &amp;&amp; isCanvasLargeEnoughToForceCompositing;
2561 
2562     return false;
2563 }
2564 
2565 bool RenderLayerCompositor::requiresCompositingForFilters(RenderLayerModelObject&amp; renderer) const
2566 {
2567 #if ENABLE(FILTERS_LEVEL_2)
2568     if (renderer.hasBackdropFilter())
2569         return true;
2570 #endif
2571 
2572     if (!(m_compositingTriggers &amp; ChromeClient::FilterTrigger))
2573         return false;
2574 
2575     return renderer.hasFilter();
2576 }
2577 
2578 bool RenderLayerCompositor::requiresCompositingForWillChange(RenderLayerModelObject&amp; renderer) const
2579 {
2580     if (!renderer.style().willChange() || !renderer.style().willChange()-&gt;canTriggerCompositing())
2581         return false;
2582 
2583 #if ENABLE(FULLSCREEN_API)
2584     // FIXME: does this require layout?
2585     if (renderer.layer() &amp;&amp; isDescendantOfFullScreenLayer(*renderer.layer()) == FullScreenDescendant::No)
2586         return false;
2587 #endif
2588 
2589     if (m_compositingPolicy == CompositingPolicy::Conservative)
2590         return false;
2591 
2592     if (is&lt;RenderBox&gt;(renderer))
2593         return true;
2594 
2595     return renderer.style().willChange()-&gt;canTriggerCompositingOnInline();
2596 }
2597 
2598 bool RenderLayerCompositor::requiresCompositingForPlugin(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2599 {
2600     if (!(m_compositingTriggers &amp; ChromeClient::PluginTrigger))
2601         return false;
2602 
2603     bool isCompositedPlugin = is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2604     if (!isCompositedPlugin)
2605         return false;
2606 
2607     auto&amp; pluginRenderer = downcast&lt;RenderWidget&gt;(renderer);
2608     if (pluginRenderer.style().visibility() != Visibility::Visible)
2609         return false;
2610 
2611     // If we can&#39;t reliably know the size of the plugin yet, don&#39;t change compositing state.
2612     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2613         queryData.reevaluateAfterLayout = true;
2614         return pluginRenderer.isComposited();
2615     }
2616 
2617     // Don&#39;t go into compositing mode if height or width are zero, or size is 1x1.
2618     IntRect contentBox = snappedIntRect(pluginRenderer.contentBoxRect());
2619     return (contentBox.height() * contentBox.width() &gt; 1);
2620 }
2621 
2622 bool RenderLayerCompositor::requiresCompositingForEditableImage(RenderLayerModelObject&amp; renderer) const
2623 {
2624     if (!renderer.isRenderImage())
2625         return false;
2626 
2627     auto&amp; image = downcast&lt;RenderImage&gt;(renderer);
2628     if (!image.isEditableImage())
2629         return false;
2630 
2631     return true;
2632 }
2633 
2634 bool RenderLayerCompositor::requiresCompositingForFrame(RenderLayerModelObject&amp; renderer, RequiresCompositingData&amp; queryData) const
2635 {
2636     if (!is&lt;RenderWidget&gt;(renderer))
2637         return false;
2638 
2639     auto&amp; frameRenderer = downcast&lt;RenderWidget&gt;(renderer);
2640     if (frameRenderer.style().visibility() != Visibility::Visible)
2641         return false;
2642 
2643     if (!frameRenderer.requiresAcceleratedCompositing())
2644         return false;
2645 
2646     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2647         queryData.reevaluateAfterLayout = true;
2648         return frameRenderer.isComposited();
2649     }
2650 
2651     // Don&#39;t go into compositing mode if height or width are zero.
2652     return !snappedIntRect(frameRenderer.contentBoxRect()).isEmpty();
2653 }
2654 
2655 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
2656 {
2657     if (isMainFrameCompositor())
2658         return false;
2659 
2660 #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
2661     if (!m_renderView.settings().asyncFrameScrollingEnabled())
2662         return false;
2663 #endif
2664 
2665     if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
2666         return false;
2667 
2668     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2669         queryData.reevaluateAfterLayout = true;
2670         return m_renderView.isComposited();
2671     }
2672 
2673     return m_renderView.frameView().isScrollable();
2674 }
2675 
2676 bool RenderLayerCompositor::requiresCompositingForPosition(RenderLayerModelObject&amp; renderer, const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2677 {
2678     // position:fixed elements that create their own stacking context (e.g. have an explicit z-index,
2679     // opacity, transform) can get their own composited layer. A stacking context is required otherwise
2680     // z-index and clipping will be broken.
2681     if (!renderer.isPositioned())
2682         return false;
2683 
2684 #if ENABLE(FULLSCREEN_API)
2685     if (isDescendantOfFullScreenLayer(layer) == FullScreenDescendant::No)
2686         return false;
2687 #endif
2688 
2689     auto position = renderer.style().position();
2690     bool isFixed = renderer.isOutOfFlowPositioned() &amp;&amp; position == PositionType::Fixed;
2691     if (isFixed &amp;&amp; !layer.isStackingContext())
2692         return false;
2693 
2694     bool isSticky = renderer.isInFlowPositioned() &amp;&amp; position == PositionType::Sticky;
2695     if (!isFixed &amp;&amp; !isSticky)
2696         return false;
2697 
2698     // FIXME: acceleratedCompositingForFixedPositionEnabled should probably be renamed acceleratedCompositingForViewportConstrainedPositionEnabled().
2699     if (!m_renderView.settings().acceleratedCompositingForFixedPositionEnabled())
2700         return false;
2701 
2702     if (isSticky)
2703         return isAsyncScrollableStickyLayer(layer);
2704 
2705     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2706         queryData.reevaluateAfterLayout = true;
2707         return layer.isComposited();
2708     }
2709 
2710     auto container = renderer.container();
2711     ASSERT(container);
2712 
2713     // Don&#39;t promote fixed position elements that are descendants of a non-view container, e.g. transformed elements.
2714     // They will stay fixed wrt the container rather than the enclosing frame.j
2715     if (container != &amp;m_renderView) {
2716         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNonViewContainer;
2717         return false;
2718     }
2719 
2720     bool paintsContent = layer.isVisuallyNonEmpty() || layer.hasVisibleDescendant();
2721     if (!paintsContent) {
2722         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForNoVisibleContent;
2723         return false;
2724     }
2725 
2726     bool intersectsViewport = fixedLayerIntersectsViewport(layer);
2727     if (!intersectsViewport) {
2728         queryData.nonCompositedForPositionReason = RenderLayer::NotCompositedForBoundsOutOfView;
2729         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; is outside the viewport&quot;);
2730         return false;
2731     }
2732 
2733     return true;
2734 }
2735 
2736 bool RenderLayerCompositor::requiresCompositingForOverflowScrolling(const RenderLayer&amp; layer, RequiresCompositingData&amp; queryData) const
2737 {
2738     if (!layer.canUseCompositedScrolling())
2739         return false;
2740 
2741     if (queryData.layoutUpToDate == LayoutUpToDate::No) {
2742         queryData.reevaluateAfterLayout = true;
2743         return layer.isComposited();
2744     }
2745 
2746     return layer.hasCompositedScrollableOverflow();
2747 }
2748 
2749 // FIXME: why doesn&#39;t this handle the clipping cases?
2750 bool RenderLayerCompositor::requiresCompositingForIndirectReason(RenderLayerModelObject&amp; renderer, bool hasCompositedDescendants, bool has3DTransformedDescendants, RenderLayer::IndirectCompositingReason&amp; reason) const
2751 {
2752     auto&amp; layer = *downcast&lt;RenderBoxModelObject&gt;(renderer).layer();
2753 
2754     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
2755     // via compositing so that they also apply to those composited descendants.
2756     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
2757         reason = RenderLayer::IndirectCompositingReason::GraphicalEffect;
2758         return true;
2759     }
2760 
2761     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
2762     // will be affected by the preserve-3d or perspective.
2763     if (has3DTransformedDescendants) {
2764         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
2765             reason = RenderLayer::IndirectCompositingReason::Preserve3D;
2766             return true;
2767         }
2768 
2769         if (renderer.style().hasPerspective()) {
2770             reason = RenderLayer::IndirectCompositingReason::Perspective;
2771             return true;
2772         }
2773     }
2774 
2775     reason = RenderLayer::IndirectCompositingReason::None;
2776     return false;
2777 }
2778 
2779 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
2780 {
2781     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
2782         return true;
2783     if (newStyle.isolation() != oldStyle.isolation())
2784         return true;
2785     if (newStyle.hasTransform() != oldStyle.hasTransform())
2786         return true;
2787     if (newStyle.boxReflect() != oldStyle.boxReflect())
2788         return true;
2789     if (newStyle.transformStyle3D() != oldStyle.transformStyle3D())
2790         return true;
2791     if (newStyle.hasPerspective() != oldStyle.hasPerspective())
2792         return true;
2793 
2794     return false;
2795 }
2796 
2797 bool RenderLayerCompositor::isAsyncScrollableStickyLayer(const RenderLayer&amp; layer, const RenderLayer** enclosingAcceleratedOverflowLayer) const
2798 {
2799     ASSERT(layer.renderer().isStickilyPositioned());
2800 
2801     auto* enclosingOverflowLayer = layer.enclosingOverflowClipLayer(ExcludeSelf);
2802 
2803 #if PLATFORM(IOS_FAMILY)
2804     if (enclosingOverflowLayer &amp;&amp; enclosingOverflowLayer-&gt;hasCompositedScrollableOverflow()) {
2805         if (enclosingAcceleratedOverflowLayer)
2806             *enclosingAcceleratedOverflowLayer = enclosingOverflowLayer;
2807         return true;
2808     }
2809 #else
2810     UNUSED_PARAM(enclosingAcceleratedOverflowLayer);
2811 #endif
2812     // If the layer is inside normal overflow, it&#39;s not async-scrollable.
2813     if (enclosingOverflowLayer)
2814         return false;
2815 
2816     // No overflow ancestor, so see if the frame supports async scrolling.
2817     if (hasCoordinatedScrolling())
2818         return true;
2819 
2820 #if PLATFORM(IOS_FAMILY)
2821     // iOS WK1 has fixed/sticky support in the main frame via WebFixedPositionContent.
2822     return isMainFrameCompositor();
2823 #else
2824     return false;
2825 #endif
2826 }
2827 
2828 bool RenderLayerCompositor::isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp; layer) const
2829 {
2830     if (layer.renderer().isStickilyPositioned())
2831         return isAsyncScrollableStickyLayer(layer);
2832 
2833     if (layer.renderer().style().position() != PositionType::Fixed)
2834         return false;
2835 
2836     // FIXME: Handle fixed inside of a transform, which should not behave as fixed.
2837     for (auto* stackingContext = layer.stackingContext(); stackingContext; stackingContext = stackingContext-&gt;stackingContext()) {
2838         if (stackingContext-&gt;isComposited() &amp;&amp; stackingContext-&gt;renderer().isFixedPositioned())
2839             return false;
2840     }
2841 
2842     return true;
2843 }
2844 
2845 bool RenderLayerCompositor::fixedLayerIntersectsViewport(const RenderLayer&amp; layer) const
2846 {
2847     ASSERT(layer.renderer().style().position() == PositionType::Fixed);
2848 
2849     // Fixed position elements that are invisible in the current view don&#39;t get their own layer.
2850     // FIXME: We shouldn&#39;t have to check useFixedLayout() here; one of the viewport rects needs to give the correct answer.
2851     LayoutRect viewBounds;
2852     if (m_renderView.frameView().useFixedLayout())
2853         viewBounds = m_renderView.unscaledDocumentRect();
2854     else
2855         viewBounds = m_renderView.frameView().rectForFixedPositionLayout();
2856 
2857     LayoutRect layerBounds = layer.calculateLayerBounds(&amp;layer, LayoutSize(), { RenderLayer::UseLocalClipRectIfPossible, RenderLayer::IncludeFilterOutsets, RenderLayer::UseFragmentBoxesExcludingCompositing,
2858         RenderLayer::ExcludeHiddenDescendants, RenderLayer::DontConstrainForMask, RenderLayer::IncludeCompositedDescendants });
2859     // Map to m_renderView to ignore page scale.
2860     FloatRect absoluteBounds = layer.renderer().localToContainerQuad(FloatRect(layerBounds), &amp;m_renderView).boundingBox();
2861     return viewBounds.intersects(enclosingIntRect(absoluteBounds));
2862 }
2863 
2864 bool RenderLayerCompositor::useCoordinatedScrollingForLayer(const RenderLayer&amp; layer) const
2865 {
2866     if (layer.isRenderViewLayer() &amp;&amp; hasCoordinatedScrolling())
2867         return true;
2868 
2869     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2870         return scrollingCoordinator-&gt;coordinatesScrollingForOverflowLayer(layer);
2871 
2872     return false;
2873 }
2874 
2875 bool RenderLayerCompositor::isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp; layer) const
2876 {
2877     if (!is&lt;RenderWidget&gt;(layer.renderer()))
2878         return false;
2879 
2880     auto* contentDocument = downcast&lt;RenderWidget&gt;(layer.renderer()).frameOwnerElement().contentDocument();
2881     if (!contentDocument)
2882         return false;
2883 
2884     auto* view = contentDocument-&gt;renderView();
2885     if (!view)
2886         return false;
2887 
2888     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
2889         return scrollingCoordinator-&gt;coordinatesScrollingForFrameView(view-&gt;frameView());
2890 
2891     return false;
2892 }
2893 
2894 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
2895 {
2896     if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
2897         return false;
2898 
2899     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2900         if (auto* element = renderer.element()) {
2901             if (auto* timeline = element-&gt;document().existingTimeline())
2902                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2903         }
2904         return false;
2905     }
2906     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
2907 }
2908 
2909 // If an element has negative z-index children, those children render in front of the
2910 // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
2911 bool RenderLayerCompositor::needsContentsCompositingLayer(const RenderLayer&amp; layer) const
2912 {
2913     return layer.hasNegativeZOrderLayers();
2914 }
2915 
2916 bool RenderLayerCompositor::requiresScrollLayer(RootLayerAttachment attachment) const
2917 {
2918     auto&amp; frameView = m_renderView.frameView();
2919 
2920     // This applies when the application UI handles scrolling, in which case RenderLayerCompositor doesn&#39;t need to manage it.
2921     if (frameView.delegatesScrolling() &amp;&amp; isMainFrameCompositor())
2922         return false;
2923 
2924     // We need to handle our own scrolling if we&#39;re:
2925     return !m_renderView.frameView().platformWidget() // viewless (i.e. non-Mac, or Mac in WebKit2)
2926         || attachment == RootLayerAttachedViaEnclosingFrame; // a composited frame on Mac
2927 }
2928 
2929 void paintScrollbar(Scrollbar* scrollbar, GraphicsContext&amp; context, const IntRect&amp; clip)
2930 {
2931     if (!scrollbar)
2932         return;
2933 
2934     context.save();
2935     const IntRect&amp; scrollbarRect = scrollbar-&gt;frameRect();
2936     context.translate(-scrollbarRect.location());
2937     IntRect transformedClip = clip;
2938     transformedClip.moveBy(scrollbarRect.location());
2939     scrollbar-&gt;paint(context, transformedClip);
2940     context.restore();
2941 }
2942 
2943 void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, GraphicsLayerPaintingPhase, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)
2944 {
2945 #if PLATFORM(MAC)
2946     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
2947 #endif
2948 
2949     IntRect pixelSnappedRectForIntegralPositionedItems = snappedIntRect(LayoutRect(clip));
2950     if (graphicsLayer == layerForHorizontalScrollbar())
2951         paintScrollbar(m_renderView.frameView().horizontalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
2952     else if (graphicsLayer == layerForVerticalScrollbar())
2953         paintScrollbar(m_renderView.frameView().verticalScrollbar(), context, pixelSnappedRectForIntegralPositionedItems);
2954     else if (graphicsLayer == layerForScrollCorner()) {
2955         const IntRect&amp; scrollCorner = m_renderView.frameView().scrollCornerRect();
2956         context.save();
2957         context.translate(-scrollCorner.location());
2958         IntRect transformedClip = pixelSnappedRectForIntegralPositionedItems;
2959         transformedClip.moveBy(scrollCorner.location());
2960         m_renderView.frameView().paintScrollCorner(context, transformedClip);
2961         context.restore();
2962     }
2963 }
2964 
2965 bool RenderLayerCompositor::supportsFixedRootBackgroundCompositing() const
2966 {
2967     auto* renderViewBacking = m_renderView.layer()-&gt;backing();
2968     return renderViewBacking &amp;&amp; renderViewBacking-&gt;isFrameLayerWithTiledBacking();
2969 }
2970 
2971 bool RenderLayerCompositor::needsFixedRootBackgroundLayer(const RenderLayer&amp; layer) const
2972 {
2973     if (!layer.isRenderViewLayer())
2974         return false;
2975 
2976     if (m_renderView.settings().fixedBackgroundsPaintRelativeToDocument())
2977         return false;
2978 
2979     return supportsFixedRootBackgroundCompositing() &amp;&amp; m_renderView.rootBackgroundIsEntirelyFixed();
2980 }
2981 
2982 GraphicsLayer* RenderLayerCompositor::fixedRootBackgroundLayer() const
2983 {
2984     // Get the fixed root background from the RenderView layer&#39;s backing.
2985     auto* viewLayer = m_renderView.layer();
2986     if (!viewLayer)
2987         return nullptr;
2988 
2989     if (viewLayer-&gt;isComposited() &amp;&amp; viewLayer-&gt;backing()-&gt;backgroundLayerPaintsFixedRootBackground())
2990         return viewLayer-&gt;backing()-&gt;backgroundLayer();
2991 
2992     return nullptr;
2993 }
2994 
2995 void RenderLayerCompositor::resetTrackedRepaintRects()
2996 {
2997     if (auto* rootLayer = rootGraphicsLayer()) {
2998         GraphicsLayer::traverse(*rootLayer, [](GraphicsLayer&amp; layer) {
2999             layer.resetTrackedRepaints();
3000         });
3001     }
3002 }
3003 
3004 float RenderLayerCompositor::deviceScaleFactor() const
3005 {
3006 #if PLATFORM(JAVA)
3007     // Java port does device scale factor in the lower level.
3008     return GraphicsLayerClient::deviceScaleFactor();
3009 #else
3010     return m_renderView.document().deviceScaleFactor();
3011 #endif
3012 }
3013 
3014 float RenderLayerCompositor::pageScaleFactor() const
3015 {
3016     return page().pageScaleFactor();
3017 }
3018 
3019 float RenderLayerCompositor::zoomedOutPageScaleFactor() const
3020 {
3021     return page().zoomedOutPageScaleFactor();
3022 }
3023 
3024 float RenderLayerCompositor::contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const
3025 {
3026 #if PLATFORM(IOS_FAMILY)
3027     LegacyTileCache* tileCache = nullptr;
3028     if (auto* frameView = page().mainFrame().view())
3029         tileCache = frameView-&gt;legacyTileCache();
3030 
3031     if (!tileCache)
3032         return 1;
3033 
3034     return tileCache-&gt;tileControllerShouldUseLowScaleTiles() ? 0.125 : 1;
3035 #else
3036     return 1;
3037 #endif
3038 }
3039 
3040 bool RenderLayerCompositor::documentUsesTiledBacking() const
3041 {
3042     auto* layer = m_renderView.layer();
3043     if (!layer)
3044         return false;
3045 
3046     auto* backing = layer-&gt;backing();
3047     if (!backing)
3048         return false;
3049 
3050     return backing-&gt;isFrameLayerWithTiledBacking();
3051 }
3052 
3053 bool RenderLayerCompositor::isMainFrameCompositor() const
3054 {
3055     return m_renderView.frameView().frame().isMainFrame();
3056 }
3057 
3058 bool RenderLayerCompositor::shouldCompositeOverflowControls() const
3059 {
3060     auto&amp; frameView = m_renderView.frameView();
3061 
3062     if (!frameView.managesScrollbars())
3063         return false;
3064 
3065     if (documentUsesTiledBacking())
3066         return true;
3067 
3068     if (m_overflowControlsHostLayer &amp;&amp; isMainFrameCompositor())
3069         return true;
3070 
3071 #if !USE(COORDINATED_GRAPHICS)
3072     if (!frameView.hasOverlayScrollbars())
3073         return false;
3074 #endif
3075 
3076     return true;
3077 }
3078 
3079 bool RenderLayerCompositor::requiresHorizontalScrollbarLayer() const
3080 {
3081     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().horizontalScrollbar();
3082 }
3083 
3084 bool RenderLayerCompositor::requiresVerticalScrollbarLayer() const
3085 {
3086     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().verticalScrollbar();
3087 }
3088 
3089 bool RenderLayerCompositor::requiresScrollCornerLayer() const
3090 {
3091     return shouldCompositeOverflowControls() &amp;&amp; m_renderView.frameView().isScrollCornerVisible();
3092 }
3093 
3094 #if ENABLE(RUBBER_BANDING)
3095 bool RenderLayerCompositor::requiresOverhangAreasLayer() const
3096 {
3097     if (!isMainFrameCompositor())
3098         return false;
3099 
3100     // We do want a layer if we&#39;re using tiled drawing and can scroll.
3101     if (documentUsesTiledBacking() &amp;&amp; m_renderView.frameView().hasOpaqueBackground() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3102         return true;
3103 
3104     return false;
3105 }
3106 
3107 bool RenderLayerCompositor::requiresContentShadowLayer() const
3108 {
3109     if (!isMainFrameCompositor())
3110         return false;
3111 
3112 #if PLATFORM(COCOA)
3113     if (viewHasTransparentBackground())
3114         return false;
3115 
3116     // If the background is going to extend, then it doesn&#39;t make sense to have a shadow layer.
3117     if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3118         return false;
3119 
3120     // On Mac, we want a content shadow layer if we&#39;re using tiled drawing and can scroll.
3121     if (documentUsesTiledBacking() &amp;&amp; !m_renderView.frameView().prohibitsScrolling())
3122         return true;
3123 #endif
3124 
3125     return false;
3126 }
3127 
3128 GraphicsLayer* RenderLayerCompositor::updateLayerForTopOverhangArea(bool wantsLayer)
3129 {
3130     if (!isMainFrameCompositor())
3131         return nullptr;
3132 
3133     if (!wantsLayer) {
3134         GraphicsLayer::unparentAndClear(m_layerForTopOverhangArea);
3135         return nullptr;
3136     }
3137 
3138     if (!m_layerForTopOverhangArea) {
3139         m_layerForTopOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3140         m_layerForTopOverhangArea-&gt;setName(&quot;top overhang&quot;);
3141         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForTopOverhangArea, m_rootContentsLayer.get());
3142     }
3143 
3144     return m_layerForTopOverhangArea.get();
3145 }
3146 
3147 GraphicsLayer* RenderLayerCompositor::updateLayerForBottomOverhangArea(bool wantsLayer)
3148 {
3149     if (!isMainFrameCompositor())
3150         return nullptr;
3151 
3152     if (!wantsLayer) {
3153         GraphicsLayer::unparentAndClear(m_layerForBottomOverhangArea);
3154         return nullptr;
3155     }
3156 
3157     if (!m_layerForBottomOverhangArea) {
3158         m_layerForBottomOverhangArea = GraphicsLayer::create(graphicsLayerFactory(), *this);
3159         m_layerForBottomOverhangArea-&gt;setName(&quot;bottom overhang&quot;);
3160         m_scrolledContentsLayer-&gt;addChildBelow(*m_layerForBottomOverhangArea, m_rootContentsLayer.get());
3161     }
3162 
3163     m_layerForBottomOverhangArea-&gt;setPosition(FloatPoint(0, m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight()
3164         + m_renderView.frameView().footerHeight() + m_renderView.frameView().topContentInset()));
3165     return m_layerForBottomOverhangArea.get();
3166 }
3167 
3168 GraphicsLayer* RenderLayerCompositor::updateLayerForHeader(bool wantsLayer)
3169 {
3170     if (!isMainFrameCompositor())
3171         return nullptr;
3172 
3173     if (!wantsLayer) {
3174         if (m_layerForHeader) {
3175             GraphicsLayer::unparentAndClear(m_layerForHeader);
3176 
3177             // The ScrollingTree knows about the header layer, and the position of the root layer is affected
3178             // by the header layer, so if we remove the header, we need to tell the scrolling tree.
3179             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3180                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3181         }
3182         return nullptr;
3183     }
3184 
3185     if (!m_layerForHeader) {
3186         m_layerForHeader = GraphicsLayer::create(graphicsLayerFactory(), *this);
3187         m_layerForHeader-&gt;setName(&quot;header&quot;);
3188         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForHeader, m_rootContentsLayer.get());
3189         m_renderView.frameView().addPaintPendingMilestones(DidFirstFlushForHeaderLayer);
3190     }
3191 
3192     m_layerForHeader-&gt;setPosition(FloatPoint(0,
3193         FrameView::yPositionForHeaderLayer(m_renderView.frameView().scrollPosition(), m_renderView.frameView().topContentInset())));
3194     m_layerForHeader-&gt;setAnchorPoint(FloatPoint3D());
3195     m_layerForHeader-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().headerHeight()));
3196 
3197     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3198         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3199 
3200     page().chrome().client().didAddHeaderLayer(*m_layerForHeader);
3201 
3202     return m_layerForHeader.get();
3203 }
3204 
3205 GraphicsLayer* RenderLayerCompositor::updateLayerForFooter(bool wantsLayer)
3206 {
3207     if (!isMainFrameCompositor())
3208         return nullptr;
3209 
3210     if (!wantsLayer) {
3211         if (m_layerForFooter) {
3212             GraphicsLayer::unparentAndClear(m_layerForFooter);
3213 
3214             // The ScrollingTree knows about the footer layer, and the total scrollable size is affected
3215             // by the footer layer, so if we remove the footer, we need to tell the scrolling tree.
3216             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3217                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3218         }
3219         return nullptr;
3220     }
3221 
3222     if (!m_layerForFooter) {
3223         m_layerForFooter = GraphicsLayer::create(graphicsLayerFactory(), *this);
3224         m_layerForFooter-&gt;setName(&quot;footer&quot;);
3225         m_scrolledContentsLayer-&gt;addChildAbove(*m_layerForFooter, m_rootContentsLayer.get());
3226     }
3227 
3228     float totalContentHeight = m_rootContentsLayer-&gt;size().height() + m_renderView.frameView().headerHeight() + m_renderView.frameView().footerHeight();
3229     m_layerForFooter-&gt;setPosition(FloatPoint(0, FrameView::yPositionForFooterLayer(m_renderView.frameView().scrollPosition(),
3230         m_renderView.frameView().topContentInset(), totalContentHeight, m_renderView.frameView().footerHeight())));
3231     m_layerForFooter-&gt;setAnchorPoint(FloatPoint3D());
3232     m_layerForFooter-&gt;setSize(FloatSize(m_renderView.frameView().visibleWidth(), m_renderView.frameView().footerHeight()));
3233 
3234     if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3235         scrollingCoordinator-&gt;frameViewRootLayerDidChange(m_renderView.frameView());
3236 
3237     page().chrome().client().didAddFooterLayer(*m_layerForFooter);
3238 
3239     return m_layerForFooter.get();
3240 }
3241 
3242 #endif
3243 
3244 bool RenderLayerCompositor::viewHasTransparentBackground(Color* backgroundColor) const
3245 {
3246     if (m_renderView.frameView().isTransparent()) {
3247         if (backgroundColor)
3248             *backgroundColor = Color(); // Return an invalid color.
3249         return true;
3250     }
3251 
3252     Color documentBackgroundColor = m_renderView.frameView().documentBackgroundColor();
3253     if (!documentBackgroundColor.isValid())
3254         documentBackgroundColor = m_renderView.frameView().baseBackgroundColor();
3255 
3256     ASSERT(documentBackgroundColor.isValid());
3257 
3258     if (backgroundColor)
3259         *backgroundColor = documentBackgroundColor;
3260 
3261     return !documentBackgroundColor.isOpaque();
3262 }
3263 
3264 // We can&#39;t rely on getting layerStyleChanged() for a style change that affects the root background, because the style change may
3265 // be on the body which has no RenderLayer.
3266 void RenderLayerCompositor::rootOrBodyStyleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle)
3267 {
3268     if (!usesCompositing())
3269         return;
3270 
3271     Color oldBackgroundColor;
3272     if (oldStyle)
3273         oldBackgroundColor = oldStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
3274 
3275     if (oldBackgroundColor != renderer.style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor))
3276         rootBackgroundColorOrTransparencyChanged();
3277 
3278     bool hadFixedBackground = oldStyle &amp;&amp; oldStyle-&gt;hasEntirelyFixedBackground();
3279     if (hadFixedBackground != renderer.style().hasEntirelyFixedBackground())
3280         rootLayerConfigurationChanged();
3281 }
3282 
3283 void RenderLayerCompositor::rootBackgroundColorOrTransparencyChanged()
3284 {
3285     if (!usesCompositing())
3286         return;
3287 
3288     Color backgroundColor;
3289     bool isTransparent = viewHasTransparentBackground(&amp;backgroundColor);
3290 
3291     Color extendedBackgroundColor = m_renderView.settings().backgroundShouldExtendBeyondPage() ? backgroundColor : Color();
3292 
3293     bool transparencyChanged = m_viewBackgroundIsTransparent != isTransparent;
3294     bool backgroundColorChanged = m_viewBackgroundColor != backgroundColor;
3295     bool extendedBackgroundColorChanged = m_rootExtendedBackgroundColor != extendedBackgroundColor;
3296 
3297     if (!transparencyChanged &amp;&amp; !backgroundColorChanged &amp;&amp; !extendedBackgroundColorChanged)
3298         return;
3299 
3300     LOG(Compositing, &quot;RenderLayerCompositor %p rootBackgroundColorOrTransparencyChanged. isTransparent=%d&quot;, this, isTransparent);
3301 
3302     m_viewBackgroundIsTransparent = isTransparent;
3303     m_viewBackgroundColor = backgroundColor;
3304     m_rootExtendedBackgroundColor = extendedBackgroundColor;
3305 
3306     if (extendedBackgroundColorChanged) {
3307         page().chrome().client().pageExtendedBackgroundColorDidChange(m_rootExtendedBackgroundColor);
3308 
3309 #if ENABLE(RUBBER_BANDING)
3310         if (m_layerForOverhangAreas) {
3311             m_layerForOverhangAreas-&gt;setBackgroundColor(m_rootExtendedBackgroundColor);
3312 
3313             if (!m_rootExtendedBackgroundColor.isValid())
3314                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3315         }
3316 #endif
3317     }
3318 
3319     rootLayerConfigurationChanged();
3320 }
3321 
3322 void RenderLayerCompositor::updateOverflowControlsLayers()
3323 {
3324 #if ENABLE(RUBBER_BANDING)
3325     if (requiresOverhangAreasLayer()) {
3326         if (!m_layerForOverhangAreas) {
3327             m_layerForOverhangAreas = GraphicsLayer::create(graphicsLayerFactory(), *this);
3328             m_layerForOverhangAreas-&gt;setName(&quot;overhang areas&quot;);
3329             m_layerForOverhangAreas-&gt;setDrawsContent(false);
3330 
3331             float topContentInset = m_renderView.frameView().topContentInset();
3332             IntSize overhangAreaSize = m_renderView.frameView().frameRect().size();
3333             overhangAreaSize.setHeight(overhangAreaSize.height() - topContentInset);
3334             m_layerForOverhangAreas-&gt;setSize(overhangAreaSize);
3335             m_layerForOverhangAreas-&gt;setPosition(FloatPoint(0, topContentInset));
3336             m_layerForOverhangAreas-&gt;setAnchorPoint(FloatPoint3D());
3337 
3338             if (m_renderView.settings().backgroundShouldExtendBeyondPage())
3339                 m_layerForOverhangAreas-&gt;setBackgroundColor(m_renderView.frameView().documentBackgroundColor());
3340             else
3341                 m_layerForOverhangAreas-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingOverhang);
3342 
3343             // We want the overhang areas layer to be positioned below the frame contents,
3344             // so insert it below the clip layer.
3345             m_overflowControlsHostLayer-&gt;addChildBelow(*m_layerForOverhangAreas, layerForClipping());
3346         }
3347     } else
3348         GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3349 
3350     if (requiresContentShadowLayer()) {
3351         if (!m_contentShadowLayer) {
3352             m_contentShadowLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3353             m_contentShadowLayer-&gt;setName(&quot;content shadow&quot;);
3354             m_contentShadowLayer-&gt;setSize(m_rootContentsLayer-&gt;size());
3355             m_contentShadowLayer-&gt;setPosition(m_rootContentsLayer-&gt;position());
3356             m_contentShadowLayer-&gt;setAnchorPoint(FloatPoint3D());
3357             m_contentShadowLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::ScrollingShadow);
3358 
3359             m_scrolledContentsLayer-&gt;addChildBelow(*m_contentShadowLayer, m_rootContentsLayer.get());
3360         }
3361     } else
3362         GraphicsLayer::unparentAndClear(m_contentShadowLayer);
3363 #endif
3364 
3365     if (requiresHorizontalScrollbarLayer()) {
3366         if (!m_layerForHorizontalScrollbar) {
3367             m_layerForHorizontalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3368             m_layerForHorizontalScrollbar-&gt;setCanDetachBackingStore(false);
3369             m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3370             m_layerForHorizontalScrollbar-&gt;setName(&quot;horizontal scrollbar container&quot;);
3371 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3372             m_layerForHorizontalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3373 #endif
3374             m_overflowControlsHostLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
3375 
3376             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3377                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3378         }
3379     } else if (m_layerForHorizontalScrollbar) {
3380         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3381 
3382         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3383             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3384     }
3385 
3386     if (requiresVerticalScrollbarLayer()) {
3387         if (!m_layerForVerticalScrollbar) {
3388             m_layerForVerticalScrollbar = GraphicsLayer::create(graphicsLayerFactory(), *this);
3389             m_layerForVerticalScrollbar-&gt;setCanDetachBackingStore(false);
3390             m_layerForVerticalScrollbar-&gt;setShowDebugBorder(m_showDebugBorders);
3391             m_layerForVerticalScrollbar-&gt;setName(&quot;vertical scrollbar container&quot;);
3392 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3393             m_layerForVerticalScrollbar-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3394 #endif
3395             m_overflowControlsHostLayer-&gt;addChild(*m_layerForVerticalScrollbar);
3396 
3397             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3398                 scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3399         }
3400     } else if (m_layerForVerticalScrollbar) {
3401         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3402 
3403         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3404             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3405     }
3406 
3407     if (requiresScrollCornerLayer()) {
3408         if (!m_layerForScrollCorner) {
3409             m_layerForScrollCorner = GraphicsLayer::create(graphicsLayerFactory(), *this);
3410             m_layerForScrollCorner-&gt;setCanDetachBackingStore(false);
3411             m_layerForScrollCorner-&gt;setShowDebugBorder(m_showDebugBorders);
3412             m_layerForScrollCorner-&gt;setName(&quot;scroll corner&quot;);
3413 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
3414             m_layerForScrollCorner-&gt;setAcceleratesDrawing(acceleratedDrawingEnabled());
3415 #endif
3416             m_overflowControlsHostLayer-&gt;addChild(*m_layerForScrollCorner);
3417         }
3418     } else
3419         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3420 
3421     m_renderView.frameView().positionScrollbarLayers();
3422 }
3423 
3424 void RenderLayerCompositor::ensureRootLayer()
3425 {
3426     RootLayerAttachment expectedAttachment = isMainFrameCompositor() ? RootLayerAttachedViaChromeClient : RootLayerAttachedViaEnclosingFrame;
3427     if (expectedAttachment == m_rootLayerAttachment)
3428          return;
3429 
3430     if (!m_rootContentsLayer) {
3431         m_rootContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3432         m_rootContentsLayer-&gt;setName(&quot;content root&quot;);
3433         IntRect overflowRect = snappedIntRect(m_renderView.layoutOverflowRect());
3434         m_rootContentsLayer-&gt;setSize(FloatSize(overflowRect.maxX(), overflowRect.maxY()));
3435         m_rootContentsLayer-&gt;setPosition(FloatPoint());
3436 
3437 #if PLATFORM(IOS_FAMILY)
3438         // Page scale is applied above this on iOS, so we&#39;ll just say that our root layer applies it.
3439         auto&amp; frame = m_renderView.frameView().frame();
3440         if (frame.isMainFrame())
3441             m_rootContentsLayer-&gt;setAppliesPageScale();
3442 #endif
3443 
3444         // Need to clip to prevent transformed content showing outside this frame
3445         updateRootContentLayerClipping();
3446     }
3447 
3448     if (requiresScrollLayer(expectedAttachment)) {
3449         if (!m_overflowControlsHostLayer) {
3450             ASSERT(!m_scrolledContentsLayer);
3451             ASSERT(!m_clipLayer);
3452 
3453             // Create a layer to host the clipping layer and the overflow controls layers.
3454             m_overflowControlsHostLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3455             m_overflowControlsHostLayer-&gt;setName(&quot;overflow controls host&quot;);
3456 
3457             m_scrolledContentsLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3458             m_scrolledContentsLayer-&gt;setName(&quot;scrolled contents&quot;);
3459             m_scrolledContentsLayer-&gt;setAnchorPoint({ });
3460 
3461 #if PLATFORM(IOS_FAMILY)
3462             if (m_renderView.settings().asyncFrameScrollingEnabled()) {
3463                 m_scrollContainerLayer = GraphicsLayer::create(graphicsLayerFactory(), *this, GraphicsLayer::Type::ScrollContainer);
3464 
3465                 m_scrollContainerLayer-&gt;setName(&quot;scroll container&quot;);
3466                 m_scrollContainerLayer-&gt;setMasksToBounds(true);
3467                 m_scrollContainerLayer-&gt;setAnchorPoint({ });
3468 
3469                 m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
3470                 m_overflowControlsHostLayer-&gt;addChild(*m_scrollContainerLayer);
3471             }
3472 #endif
3473             if (!m_scrollContainerLayer) {
3474                 m_clipLayer = GraphicsLayer::create(graphicsLayerFactory(), *this);
3475                 m_clipLayer-&gt;setName(&quot;frame clipping&quot;);
3476                 m_clipLayer-&gt;setMasksToBounds(true);
3477                 m_clipLayer-&gt;setAnchorPoint({ });
3478 
3479                 m_clipLayer-&gt;addChild(*m_scrolledContentsLayer);
3480                 m_overflowControlsHostLayer-&gt;addChild(*m_clipLayer);
3481             }
3482 
3483             m_scrolledContentsLayer-&gt;addChild(*m_rootContentsLayer);
3484 
3485             updateScrollLayerClipping();
3486             updateOverflowControlsLayers();
3487 
3488             if (hasCoordinatedScrolling())
3489                 scheduleLayerFlush(true);
3490             else
3491                 updateScrollLayerPosition();
3492         }
3493     } else {
3494         if (m_overflowControlsHostLayer) {
3495             GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3496             GraphicsLayer::unparentAndClear(m_clipLayer);
3497             GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3498             GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
3499         }
3500     }
3501 
3502     // Check to see if we have to change the attachment
3503     if (m_rootLayerAttachment != RootLayerUnattached)
3504         detachRootLayer();
3505 
3506     attachRootLayer(expectedAttachment);
3507 }
3508 
3509 void RenderLayerCompositor::destroyRootLayer()
3510 {
3511     if (!m_rootContentsLayer)
3512         return;
3513 
3514     detachRootLayer();
3515 
3516 #if ENABLE(RUBBER_BANDING)
3517     GraphicsLayer::unparentAndClear(m_layerForOverhangAreas);
3518 #endif
3519 
3520     if (m_layerForHorizontalScrollbar) {
3521         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
3522         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3523             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), HorizontalScrollbar);
3524         if (auto* horizontalScrollbar = m_renderView.frameView().verticalScrollbar())
3525             m_renderView.frameView().invalidateScrollbar(*horizontalScrollbar, IntRect(IntPoint(0, 0), horizontalScrollbar-&gt;frameRect().size()));
3526     }
3527 
3528     if (m_layerForVerticalScrollbar) {
3529         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
3530         if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3531             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_renderView.frameView(), VerticalScrollbar);
3532         if (auto* verticalScrollbar = m_renderView.frameView().verticalScrollbar())
3533             m_renderView.frameView().invalidateScrollbar(*verticalScrollbar, IntRect(IntPoint(0, 0), verticalScrollbar-&gt;frameRect().size()));
3534     }
3535 
3536     if (m_layerForScrollCorner) {
3537         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
3538         m_renderView.frameView().invalidateScrollCorner(m_renderView.frameView().scrollCornerRect());
3539     }
3540 
3541     if (m_overflowControlsHostLayer) {
3542         GraphicsLayer::unparentAndClear(m_overflowControlsHostLayer);
3543         GraphicsLayer::unparentAndClear(m_clipLayer);
3544         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
3545         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
3546     }
3547     ASSERT(!m_scrolledContentsLayer);
3548     GraphicsLayer::unparentAndClear(m_rootContentsLayer);
3549 
3550     m_layerUpdater = nullptr;
3551 }
3552 
3553 void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
3554 {
3555     if (!m_rootContentsLayer)
3556         return;
3557 
3558     LOG(Compositing, &quot;RenderLayerCompositor %p attachRootLayer %d&quot;, this, attachment);
3559 
3560     switch (attachment) {
3561         case RootLayerUnattached:
3562             ASSERT_NOT_REACHED();
3563             break;
3564         case RootLayerAttachedViaChromeClient: {
3565             auto&amp; frame = m_renderView.frameView().frame();
3566             page().chrome().client().attachRootGraphicsLayer(frame, rootGraphicsLayer());
3567             break;
3568         }
3569         case RootLayerAttachedViaEnclosingFrame: {
3570             // The layer will get hooked up via RenderLayerBacking::updateConfiguration()
3571             // for the frame&#39;s renderer in the parent document.
3572             if (auto* ownerElement = m_renderView.document().ownerElement())
3573                 ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
3574             break;
3575         }
3576     }
3577 
3578     m_rootLayerAttachment = attachment;
3579     rootLayerAttachmentChanged();
3580 
3581     if (m_shouldFlushOnReattach) {
3582         scheduleLayerFlushNow();
3583         m_shouldFlushOnReattach = false;
3584     }
3585 }
3586 
3587 void RenderLayerCompositor::detachRootLayer()
3588 {
3589     if (!m_rootContentsLayer || m_rootLayerAttachment == RootLayerUnattached)
3590         return;
3591 
3592     switch (m_rootLayerAttachment) {
3593     case RootLayerAttachedViaEnclosingFrame: {
3594         // The layer will get unhooked up via RenderLayerBacking::updateConfiguration()
3595         // for the frame&#39;s renderer in the parent document.
3596         if (m_overflowControlsHostLayer)
3597             m_overflowControlsHostLayer-&gt;removeFromParent();
3598         else
3599             m_rootContentsLayer-&gt;removeFromParent();
3600 
3601         if (auto* ownerElement = m_renderView.document().ownerElement())
3602             ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
3603 
3604         if (auto frameRootScrollingNodeID = m_renderView.frameView().scrollingNodeID()) {
3605             if (auto* scrollingCoordinator = this-&gt;scrollingCoordinator())
3606                 scrollingCoordinator-&gt;unparentNode(frameRootScrollingNodeID);
3607         }
3608         break;
3609     }
3610     case RootLayerAttachedViaChromeClient: {
3611         auto&amp; frame = m_renderView.frameView().frame();
3612         page().chrome().client().attachRootGraphicsLayer(frame, nullptr);
3613     }
3614     break;
3615     case RootLayerUnattached:
3616         break;
3617     }
3618 
3619     m_rootLayerAttachment = RootLayerUnattached;
3620     rootLayerAttachmentChanged();
3621 }
3622 
3623 void RenderLayerCompositor::updateRootLayerAttachment()
3624 {
3625     ensureRootLayer();
3626 }
3627 
3628 void RenderLayerCompositor::rootLayerAttachmentChanged()
3629 {
3630     // The document-relative page overlay layer (which is pinned to the main frame&#39;s layer tree)
3631     // is moved between different RenderLayerCompositors&#39; layer trees, and needs to be
3632     // reattached whenever we swap in a new RenderLayerCompositor.
3633     if (m_rootLayerAttachment == RootLayerUnattached)
3634         return;
3635 
3636     auto&amp; frame = m_renderView.frameView().frame();
3637 
3638     // The attachment can affect whether the RenderView layer&#39;s paintsIntoWindow() behavior,
3639     // so call updateDrawsContent() to update that.
3640     auto* layer = m_renderView.layer();
3641     if (auto* backing = layer ? layer-&gt;backing() : nullptr)
3642         backing-&gt;updateDrawsContent();
3643 
3644     if (!frame.isMainFrame())
3645         return;
3646 
3647     Ref&lt;GraphicsLayer&gt; overlayHost = page().pageOverlayController().layerWithDocumentOverlays();
3648     m_rootContentsLayer-&gt;addChild(WTFMove(overlayHost));
3649 }
3650 
3651 void RenderLayerCompositor::notifyIFramesOfCompositingChange()
3652 {
3653     // Compositing affects the answer to RenderIFrame::requiresAcceleratedCompositing(), so
3654     // we need to schedule a style recalc in our parent document.
3655     if (auto* ownerElement = m_renderView.document().ownerElement())
3656         ownerElement-&gt;scheduleInvalidateStyleAndLayerComposition();
3657 }
3658 
3659 bool RenderLayerCompositor::layerHas3DContent(const RenderLayer&amp; layer) const
3660 {
3661     const RenderStyle&amp; style = layer.renderer().style();
3662 
3663     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
3664         return true;
3665 
3666     const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
3667 
3668 #if !ASSERT_DISABLED
3669     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
3670 #endif
3671 
3672     for (auto* renderLayer : layer.negativeZOrderLayers()) {
3673         if (layerHas3DContent(*renderLayer))
3674             return true;
3675     }
3676 
3677     for (auto* renderLayer : layer.positiveZOrderLayers()) {
3678         if (layerHas3DContent(*renderLayer))
3679             return true;
3680     }
3681 
3682     for (auto* renderLayer : layer.normalFlowLayers()) {
3683         if (layerHas3DContent(*renderLayer))
3684             return true;
3685     }
3686 
3687     return false;
3688 }
3689 
3690 void RenderLayerCompositor::deviceOrPageScaleFactorChanged()
3691 {
3692     // Page scale will only be applied at to the RenderView and sublayers, but the device scale factor
3693     // needs to be applied at the level of rootGraphicsLayer().
3694     if (auto* rootLayer = rootGraphicsLayer())
3695         rootLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
3696 }
3697 
3698 void RenderLayerCompositor::removeFromScrollCoordinatedLayers(RenderLayer&amp; layer)
3699 {
3700 #if PLATFORM(IOS_FAMILY)
3701     if (m_legacyScrollingLayerCoordinator)
3702         m_legacyScrollingLayerCoordinator-&gt;removeLayer(layer);
3703 #endif
3704 
3705     detachScrollCoordinatedLayer(layer, { ScrollCoordinationRole::Scrolling, ScrollCoordinationRole::ViewportConstrained, ScrollCoordinationRole::FrameHosting });
3706 }
3707 
3708 FixedPositionViewportConstraints RenderLayerCompositor::computeFixedViewportConstraints(RenderLayer&amp; layer) const
3709 {
3710     ASSERT(layer.isComposited());
3711 
3712     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
3713 
3714     FixedPositionViewportConstraints constraints;
3715     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
3716     constraints.setViewportRectAtLastLayout(m_renderView.frameView().rectForFixedPositionLayout());
3717     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
3718 
3719     const RenderStyle&amp; style = layer.renderer().style();
3720     if (!style.left().isAuto())
3721         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
3722 
3723     if (!style.right().isAuto())
3724         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeRight);
3725 
3726     if (!style.top().isAuto())
3727         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
3728 
3729     if (!style.bottom().isAuto())
3730         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeBottom);
3731 
3732     // If left and right are auto, use left.
3733     if (style.left().isAuto() &amp;&amp; style.right().isAuto())
3734         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeLeft);
3735 
3736     // If top and bottom are auto, use top.
3737     if (style.top().isAuto() &amp;&amp; style.bottom().isAuto())
3738         constraints.addAnchorEdge(ViewportConstraints::AnchorEdgeTop);
3739 
3740     return constraints;
3741 }
3742 
3743 StickyPositionViewportConstraints RenderLayerCompositor::computeStickyViewportConstraints(RenderLayer&amp; layer) const
3744 {
3745     ASSERT(layer.isComposited());
3746 #if !PLATFORM(IOS_FAMILY)
3747     // We should never get here for stickies constrained by an enclosing clipping layer.
3748     // FIXME: Why does this assertion fail on iOS?
3749     ASSERT(!layer.enclosingOverflowClipLayer(ExcludeSelf));
3750 #endif
3751 
3752     auto&amp; renderer = downcast&lt;RenderBoxModelObject&gt;(layer.renderer());
3753 
3754     StickyPositionViewportConstraints constraints;
3755     renderer.computeStickyPositionConstraints(constraints, renderer.constrainingRectForStickyPosition());
3756 
3757     auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
3758     constraints.setLayerPositionAtLastLayout(graphicsLayer-&gt;position());
3759     constraints.setStickyOffsetAtLastLayout(renderer.stickyPositionOffset());
3760     constraints.setAlignmentOffset(graphicsLayer-&gt;pixelAlignmentOffset());
3761 
3762     return constraints;
3763 }
3764 
3765 static inline ScrollCoordinationRole scrollCoordinationRoleForNodeType(ScrollingNodeType nodeType)
3766 {
3767     switch (nodeType) {
3768     case ScrollingNodeType::MainFrame:
3769     case ScrollingNodeType::Subframe:
3770     case ScrollingNodeType::Overflow:
3771         return ScrollCoordinationRole::Scrolling;
3772     case ScrollingNodeType::FrameHosting:
3773         return ScrollCoordinationRole::FrameHosting;
3774     case ScrollingNodeType::Fixed:
3775     case ScrollingNodeType::Sticky:
3776         return ScrollCoordinationRole::ViewportConstrained;
3777     }
3778     ASSERT_NOT_REACHED();
3779     return ScrollCoordinationRole::Scrolling;
3780 }
3781 
3782 ScrollingNodeID RenderLayerCompositor::attachScrollingNode(RenderLayer&amp; layer, ScrollingNodeType nodeType, ScrollingTreeState&amp; treeState)
3783 {
3784     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3785     auto* backing = layer.backing();
3786     // Crash logs suggest that backing can be null here, but we don&#39;t know how: rdar://problem/18545452.
3787     ASSERT(backing);
3788     if (!backing)
3789         return 0;
3790 
3791     ASSERT(treeState.parentNodeID || nodeType == ScrollingNodeType::Subframe);
3792     ASSERT_IMPLIES(nodeType == ScrollingNodeType::MainFrame, !treeState.parentNodeID.value());
3793 
3794     ScrollCoordinationRole role = scrollCoordinationRoleForNodeType(nodeType);
3795     ScrollingNodeID nodeID = backing-&gt;scrollingNodeIDForRole(role);
3796     if (!nodeID)
3797         nodeID = scrollingCoordinator-&gt;uniqueScrollingNodeID();
3798 
3799     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; attachScrollingNode &quot; &lt;&lt; nodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; backing-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) type &quot; &lt;&lt; nodeType &lt;&lt; &quot; parent &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
3800 
3801     if (nodeType == ScrollingNodeType::Subframe &amp;&amp; !treeState.parentNodeID)
3802         nodeID = scrollingCoordinator-&gt;createNode(nodeType, nodeID);
3803     else {
3804         auto newNodeID = scrollingCoordinator-&gt;insertNode(nodeType, nodeID, treeState.parentNodeID.valueOr(0), treeState.nextChildIndex);
3805         if (newNodeID != nodeID) {
3806             // We&#39;ll get a new nodeID if the type changed (and not if the node is new).
3807             scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(nodeID);
3808             m_scrollingNodeToLayerMap.remove(nodeID);
3809         }
3810         nodeID = newNodeID;
3811     }
3812 
3813     ASSERT(nodeID);
3814     if (!nodeID)
3815         return 0;
3816 
3817     backing-&gt;setScrollingNodeIDForRole(nodeID, role);
3818     m_scrollingNodeToLayerMap.add(nodeID, &amp;layer);
3819 
3820     ++treeState.nextChildIndex;
3821     return nodeID;
3822 }
3823 
3824 void RenderLayerCompositor::detachScrollCoordinatedLayerWithRole(RenderLayer&amp; layer, ScrollingCoordinator&amp; scrollingCoordinator, ScrollCoordinationRole role)
3825 {
3826     auto nodeID = layer.backing()-&gt;scrollingNodeIDForRole(role);
3827     if (!nodeID)
3828         return;
3829 
3830     auto childNodes = scrollingCoordinator.childrenOfNode(nodeID);
3831     for (auto childNodeID : childNodes) {
3832         // FIXME: The child might be in a child frame. Need to do something that crosses frame boundaries.
3833         if (auto* layer = m_scrollingNodeToLayerMap.get(childNodeID))
3834             layer-&gt;setNeedsScrollingTreeUpdate();
3835     }
3836 
3837     m_scrollingNodeToLayerMap.remove(nodeID);
3838 }
3839 
3840 void RenderLayerCompositor::detachScrollCoordinatedLayer(RenderLayer&amp; layer, OptionSet&lt;ScrollCoordinationRole&gt; roles)
3841 {
3842     auto* backing = layer.backing();
3843     if (!backing)
3844         return;
3845 
3846     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3847 
3848     if (roles.contains(ScrollCoordinationRole::Scrolling))
3849         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Scrolling);
3850 
3851     if (roles.contains(ScrollCoordinationRole::FrameHosting))
3852         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::FrameHosting);
3853 
3854     if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
3855         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::ViewportConstrained);
3856 
3857     backing-&gt;detachFromScrollingCoordinator(roles);
3858 }
3859 
3860 ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollCoordinationRole&gt; roles, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
3861 {
3862     bool isViewportConstrained = roles.contains(ScrollCoordinationRole::ViewportConstrained);
3863 #if PLATFORM(IOS_FAMILY)
3864     if (m_legacyScrollingLayerCoordinator) {
3865         if (isViewportConstrained)
3866             m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
3867         else
3868             m_legacyScrollingLayerCoordinator-&gt;removeViewportConstrainedLayer(layer);
3869     }
3870 #endif
3871 
3872     // GraphicsLayers need to know whether they are viewport-constrained.
3873     layer.backing()-&gt;setIsScrollCoordinatedWithViewportConstrainedRole(isViewportConstrained);
3874 
3875     if (!hasCoordinatedScrolling()) {
3876         // If this frame isn&#39;t coordinated, it cannot contain any scrolling tree nodes.
3877         return 0;
3878     }
3879 
3880     auto newNodeID = treeState.parentNodeID.valueOr(0);
3881 
3882     ScrollingTreeState viewportConstrainedChildTreeState;
3883     ScrollingTreeState* currentTreeState = &amp;treeState;
3884 
3885     // If a node plays both roles, fixed/sticky is always the ancestor node of scrolling/frame hosting.
3886     if (roles.contains(ScrollCoordinationRole::ViewportConstrained)) {
3887         newNodeID = updateScrollingNodeForViewportConstrainedRole(layer, *currentTreeState, changes);
3888         // ViewportConstrained nodes are the parent of same-layer scrolling nodes, so adjust the ScrollingTreeState.
3889         viewportConstrainedChildTreeState.parentNodeID = newNodeID;
3890         currentTreeState = &amp;viewportConstrainedChildTreeState;
3891     } else
3892         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::ViewportConstrained);
3893 
3894     if (roles.contains(ScrollCoordinationRole::Scrolling))
3895         newNodeID = updateScrollingNodeForScrollingRole(layer, *currentTreeState, changes);
3896     else
3897         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Scrolling);
3898 
3899     if (roles.contains(ScrollCoordinationRole::FrameHosting))
3900         newNodeID = updateScrollingNodeForFrameHostingRole(layer, *currentTreeState, changes);
3901     else
3902         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::FrameHosting);
3903 
3904     return newNodeID;
3905 }
3906 
3907 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
3908 {
3909     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
3910 
3911     auto nodeType = ScrollingNodeType::Fixed;
3912     if (layer.renderer().style().position() == PositionType::Sticky)
3913         nodeType = ScrollingNodeType::Sticky;
3914     else
3915         ASSERT(layer.renderer().isFixedPositioned());
3916 
3917     auto newNodeID = attachScrollingNode(layer, nodeType, treeState);
3918     if (!newNodeID) {
3919         ASSERT_NOT_REACHED();
3920         return treeState.parentNodeID.valueOr(0);
3921     }
3922 
3923     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Registering ViewportConstrained &quot; &lt;&lt; nodeType &lt;&lt; &quot; node &quot; &lt;&lt; newNodeID &lt;&lt; &quot; (layer &quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;) as child of &quot; &lt;&lt; treeState.parentNodeID.valueOr(0));
3924 
3925     if (changes &amp; ScrollingNodeChangeFlags::Layer)
3926         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
3927 
3928     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
3929         switch (nodeType) {
3930         case ScrollingNodeType::Fixed:
3931             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeFixedViewportConstraints(layer));
3932             break;
3933         case ScrollingNodeType::Sticky:
3934             scrollingCoordinator-&gt;setViewportConstraintedNodeGeometry(newNodeID, computeStickyViewportConstraints(layer));
3935             break;
3936         case ScrollingNodeType::MainFrame:
3937         case ScrollingNodeType::Subframe:
3938         case ScrollingNodeType::FrameHosting:
3939         case ScrollingNodeType::Overflow:
3940             break;
3941         }
3942     }
3943 
3944     return newNodeID;
3945 }
3946 
3947 void RenderLayerCompositor::computeFrameScrollingGeometry(ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const
3948 {
3949     auto&amp; frameView = m_renderView.frameView();
3950 
3951     if (m_renderView.frame().isMainFrame())
3952         scrollingGeometry.parentRelativeScrollableRect = frameView.frameRect();
3953     else
3954         scrollingGeometry.parentRelativeScrollableRect = LayoutRect({ }, LayoutSize(frameView.size()));
3955 
3956     scrollingGeometry.scrollOrigin = frameView.scrollOrigin();
3957     scrollingGeometry.scrollableAreaSize = frameView.visibleContentRect().size();
3958     scrollingGeometry.contentSize = frameView.totalContentsSize();
3959     scrollingGeometry.reachableContentSize = frameView.totalContentsSize();
3960 #if ENABLE(CSS_SCROLL_SNAP)
3961     frameView.updateSnapOffsets();
3962     updateScrollSnapPropertiesWithFrameView(frameView);
3963 #endif
3964 }
3965 
3966 void RenderLayerCompositor::computeFrameHostingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const
3967 {
3968     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
3969     if (ancestorLayer) {
3970         LayoutRect scrollableRect;
3971         if (is&lt;RenderBox&gt;(layer.renderer()))
3972             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();
3973 
3974         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.
3975         scrollableRect.setLocation(offset);
3976         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;
3977     }
3978 }
3979 
3980 void RenderLayerCompositor::computeOverflowScrollingGeometry(const RenderLayer&amp; layer, const RenderLayer* ancestorLayer, ScrollingCoordinator::ScrollingGeometry&amp; scrollingGeometry) const
3981 {
3982     // FIXME: ancestorLayer needs to be always non-null, so should become a reference.
3983     if (ancestorLayer) {
3984         LayoutRect scrollableRect;
3985         if (is&lt;RenderBox&gt;(layer.renderer()))
3986             scrollableRect = downcast&lt;RenderBox&gt;(layer.renderer()).paddingBoxRect();
3987 
3988         auto offset = layer.convertToLayerCoords(ancestorLayer, scrollableRect.location()); // FIXME: broken for columns.
3989         scrollableRect.setLocation(offset);
3990         scrollingGeometry.parentRelativeScrollableRect = scrollableRect;
3991     }
3992 
3993     scrollingGeometry.scrollOrigin = layer.scrollOrigin();
3994     scrollingGeometry.scrollPosition = layer.scrollPosition();
3995     scrollingGeometry.scrollableAreaSize = layer.visibleSize();
3996     scrollingGeometry.contentSize = layer.contentsSize();
3997     scrollingGeometry.reachableContentSize = layer.scrollableContentsSize();
3998 #if ENABLE(CSS_SCROLL_SNAP)
3999     if (auto* offsets = layer.horizontalSnapOffsets())
4000         scrollingGeometry.horizontalSnapOffsets = *offsets;
4001     if (auto* offsets = layer.verticalSnapOffsets())
4002         scrollingGeometry.verticalSnapOffsets = *offsets;
4003     if (auto* ranges = layer.horizontalSnapOffsetRanges())
4004         scrollingGeometry.horizontalSnapOffsetRanges = *ranges;
4005     if (auto* ranges = layer.verticalSnapOffsetRanges())
4006         scrollingGeometry.verticalSnapOffsetRanges = *ranges;
4007     scrollingGeometry.currentHorizontalSnapPointIndex = layer.currentHorizontalSnapPointIndex();
4008     scrollingGeometry.currentVerticalSnapPointIndex = layer.currentVerticalSnapPointIndex();
4009 #endif
4010 }
4011 
4012 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForScrollingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4013 {
4014     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4015 
4016     ScrollingNodeID newNodeID = 0;
4017 
4018     if (layer.isRenderViewLayer()) {
4019         FrameView&amp; frameView = m_renderView.frameView();
4020         ASSERT_UNUSED(frameView, scrollingCoordinator-&gt;coordinatesScrollingForFrameView(frameView));
4021 
4022         newNodeID = attachScrollingNode(*m_renderView.layer(), m_renderView.frame().isMainFrame() ? ScrollingNodeType::MainFrame : ScrollingNodeType::Subframe, treeState);
4023 
4024         if (!newNodeID) {
4025             ASSERT_NOT_REACHED();
4026             return treeState.parentNodeID.valueOr(0);
4027         }
4028 
4029         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4030             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { nullptr, scrollContainerLayer(), scrolledContentsLayer(), fixedRootBackgroundLayer(), clipLayer(), rootContentsLayer() });
4031 
4032         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry) {
4033             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;
4034             computeFrameScrollingGeometry(scrollingGeometry);
4035             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);
4036         }
4037     } else {
4038         newNodeID = attachScrollingNode(layer, ScrollingNodeType::Overflow, treeState);
4039         if (!newNodeID) {
4040             ASSERT_NOT_REACHED();
4041             return treeState.parentNodeID.valueOr(0);
4042         }
4043 
4044         if (changes &amp; ScrollingNodeChangeFlags::Layer)
4045             scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer(), layer.backing()-&gt;scrollContainerLayer(), layer.backing()-&gt;scrolledContentsLayer() });
4046 
4047         if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4048             RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4049             ScrollingCoordinator::ScrollingGeometry scrollingGeometry;
4050             computeOverflowScrollingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);
4051             scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);
4052         }
4053     }
4054 
4055     return newNodeID;
4056 }
4057 
4058 ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForFrameHostingRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)
4059 {
4060     auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
4061 
4062     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::FrameHosting, treeState);
4063     if (!newNodeID) {
4064         ASSERT_NOT_REACHED();
4065         return treeState.parentNodeID.valueOr(0);
4066     }
4067 
4068     if (changes &amp; ScrollingNodeChangeFlags::Layer)
4069         scrollingCoordinator-&gt;setNodeLayers(newNodeID, { layer.backing()-&gt;graphicsLayer() });
4070 
4071     if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
4072         RenderLayer* scrollingAncestorLayer = m_scrollingNodeToLayerMap.get(treeState.parentNodeID.value());
4073         ScrollingCoordinator::ScrollingGeometry scrollingGeometry;
4074         computeFrameHostingGeometry(layer, scrollingAncestorLayer, scrollingGeometry);
4075         scrollingCoordinator-&gt;setScrollingNodeGeometry(newNodeID, scrollingGeometry);
4076     }
4077 
4078     return newNodeID;
4079 }
4080 
4081 ScrollableArea* RenderLayerCompositor::scrollableAreaForScrollLayerID(ScrollingNodeID nodeID) const
4082 {
4083     if (!nodeID)
4084         return nullptr;
4085 
4086     return m_scrollingNodeToLayerMap.get(nodeID);
4087 }
4088 
4089 void RenderLayerCompositor::willRemoveScrollingLayerWithBacking(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4090 {
4091     if (scrollingCoordinator())
4092         return;
4093 
4094 #if PLATFORM(IOS_FAMILY)
4095     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
4096     if (m_legacyScrollingLayerCoordinator)
4097         m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
4098 #else
4099     UNUSED_PARAM(layer);
4100     UNUSED_PARAM(backing);
4101 #endif
4102 }
4103 
4104 // FIXME: This should really be called from the updateBackingAndHierarchy.
4105 void RenderLayerCompositor::didAddScrollingLayer(RenderLayer&amp; layer)
4106 {
4107     if (scrollingCoordinator())
4108         return;
4109 
4110 #if PLATFORM(IOS_FAMILY)
4111     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
4112     if (m_legacyScrollingLayerCoordinator)
4113         m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
4114 #else
4115     UNUSED_PARAM(layer);
4116 #endif
4117 }
4118 
4119 void RenderLayerCompositor::windowScreenDidChange(PlatformDisplayID displayID)
4120 {
4121     if (m_layerUpdater)
4122         m_layerUpdater-&gt;screenDidChange(displayID);
4123 }
4124 
4125 ScrollingCoordinator* RenderLayerCompositor::scrollingCoordinator() const
4126 {
4127     return page().scrollingCoordinator();
4128 }
4129 
4130 GraphicsLayerFactory* RenderLayerCompositor::graphicsLayerFactory() const
4131 {
4132     return page().chrome().client().graphicsLayerFactory();
4133 }
4134 
4135 void RenderLayerCompositor::setLayerFlushThrottlingEnabled(bool enabled)
4136 {
4137     m_layerFlushThrottlingEnabled = enabled;
4138     if (m_layerFlushThrottlingEnabled)
4139         return;
4140     m_layerFlushTimer.stop();
4141     if (!m_hasPendingLayerFlush)
4142         return;
4143     scheduleLayerFlushNow();
4144 }
4145 
4146 void RenderLayerCompositor::disableLayerFlushThrottlingTemporarilyForInteraction()
4147 {
4148     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4149         return;
4150     m_layerFlushThrottlingTemporarilyDisabledForInteraction = true;
4151 }
4152 
4153 bool RenderLayerCompositor::isThrottlingLayerFlushes() const
4154 {
4155     if (!m_layerFlushThrottlingEnabled)
4156         return false;
4157     if (!m_layerFlushTimer.isActive())
4158         return false;
4159     if (m_layerFlushThrottlingTemporarilyDisabledForInteraction)
4160         return false;
4161     return true;
4162 }
4163 
4164 void RenderLayerCompositor::startLayerFlushTimerIfNeeded()
4165 {
4166     m_layerFlushThrottlingTemporarilyDisabledForInteraction = false;
4167     m_layerFlushTimer.stop();
4168     if (!m_layerFlushThrottlingEnabled)
4169         return;
4170     m_layerFlushTimer.startOneShot(throttledLayerFlushDelay);
4171 }
4172 
4173 void RenderLayerCompositor::startInitialLayerFlushTimerIfNeeded()
4174 {
4175     if (!m_layerFlushThrottlingEnabled)
4176         return;
4177     if (m_layerFlushTimer.isActive())
4178         return;
4179     m_layerFlushTimer.startOneShot(throttledLayerFlushInitialDelay);
4180 }
4181 
4182 void RenderLayerCompositor::layerFlushTimerFired()
4183 {
4184     if (!m_hasPendingLayerFlush)
4185         return;
4186     scheduleLayerFlushNow();
4187 }
4188 
4189 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
4190 RefPtr&lt;DisplayRefreshMonitor&gt; RenderLayerCompositor::createDisplayRefreshMonitor(PlatformDisplayID displayID) const
4191 {
4192     if (auto monitor = page().chrome().client().createDisplayRefreshMonitor(displayID))
4193         return monitor;
4194 
4195     return DisplayRefreshMonitor::createDefaultDisplayRefreshMonitor(displayID);
4196 }
4197 #endif
4198 
4199 #if ENABLE(CSS_SCROLL_SNAP)
4200 void RenderLayerCompositor::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView) const
4201 {
4202     if (auto* coordinator = scrollingCoordinator())
4203         coordinator-&gt;updateScrollSnapPropertiesWithFrameView(frameView);
4204 }
4205 #endif
4206 
4207 Page&amp; RenderLayerCompositor::page() const
4208 {
4209     return m_renderView.page();
4210 }
4211 
4212 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingUpdateType updateType)
4213 {
4214     switch (updateType) {
4215     case CompositingUpdateType::AfterStyleChange: ts &lt;&lt; &quot;after style change&quot;; break;
4216     case CompositingUpdateType::AfterLayout: ts &lt;&lt; &quot;after layout&quot;; break;
4217     case CompositingUpdateType::OnScroll: ts &lt;&lt; &quot;on scroll&quot;; break;
4218     case CompositingUpdateType::OnCompositedScroll: ts &lt;&lt; &quot;on composited scroll&quot;; break;
4219     }
4220     return ts;
4221 }
4222 
4223 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CompositingPolicy compositingPolicy)
4224 {
4225     switch (compositingPolicy) {
4226     case CompositingPolicy::Normal: ts &lt;&lt; &quot;normal&quot;; break;
4227     case CompositingPolicy::Conservative: ts &lt;&lt; &quot;conservative&quot;; break;
4228     }
4229     return ts;
4230 }
4231 
4232 #if PLATFORM(IOS_FAMILY)
4233 typedef HashMap&lt;PlatformLayer*, std::unique_ptr&lt;ViewportConstraints&gt;&gt; LayerMap;
4234 typedef HashMap&lt;PlatformLayer*, PlatformLayer*&gt; StickyContainerMap;
4235 
4236 void LegacyWebKitScrollingLayerCoordinator::registerAllViewportConstrainedLayers(RenderLayerCompositor&amp; compositor)
4237 {
4238     if (!m_coordinateViewportConstrainedLayers)
4239         return;
4240 
4241     LayerMap layerMap;
4242     StickyContainerMap stickyContainerMap;
4243 
4244     for (auto* layer : m_viewportConstrainedLayers) {
4245         ASSERT(layer-&gt;isComposited());
4246 
4247         std::unique_ptr&lt;ViewportConstraints&gt; constraints;
4248         if (layer-&gt;renderer().isStickilyPositioned()) {
4249             constraints = std::make_unique&lt;StickyPositionViewportConstraints&gt;(compositor.computeStickyViewportConstraints(*layer));
4250             const RenderLayer* enclosingTouchScrollableLayer = nullptr;
4251             if (compositor.isAsyncScrollableStickyLayer(*layer, &amp;enclosingTouchScrollableLayer) &amp;&amp; enclosingTouchScrollableLayer) {
4252                 ASSERT(enclosingTouchScrollableLayer-&gt;isComposited());
4253                 // what
4254                 stickyContainerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), enclosingTouchScrollableLayer-&gt;backing()-&gt;scrollContainerLayer()-&gt;platformLayer());
4255             }
4256         } else if (layer-&gt;renderer().isFixedPositioned())
4257             constraints = std::make_unique&lt;FixedPositionViewportConstraints&gt;(compositor.computeFixedViewportConstraints(*layer));
4258         else
4259             continue;
4260 
4261         layerMap.add(layer-&gt;backing()-&gt;graphicsLayer()-&gt;platformLayer(), WTFMove(constraints));
4262     }
4263 
4264     m_chromeClient.updateViewportConstrainedLayers(layerMap, stickyContainerMap);
4265 }
4266 
4267 void LegacyWebKitScrollingLayerCoordinator::unregisterAllViewportConstrainedLayers()
4268 {
4269     if (!m_coordinateViewportConstrainedLayers)
4270         return;
4271 
4272     LayerMap layerMap;
4273     m_chromeClient.updateViewportConstrainedLayers(layerMap, { });
4274 }
4275 
4276 static bool scrollbarHasDisplayNone(Scrollbar* scrollbar)
4277 {
4278     if (!scrollbar || !scrollbar-&gt;isCustomScrollbar())
4279         return false;
4280 
4281     std::unique_ptr&lt;RenderStyle&gt; scrollbarStyle = static_cast&lt;RenderScrollbar*&gt;(scrollbar)-&gt;getScrollbarPseudoStyle(ScrollbarBGPart, PseudoId::Scrollbar);
4282     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;
4283 }
4284 
4285 void LegacyWebKitScrollingLayerCoordinator::updateScrollingLayer(RenderLayer&amp; layer)
4286 {
4287     auto* backing = layer.backing();
4288     ASSERT(backing);
4289 
4290     bool allowHorizontalScrollbar = !scrollbarHasDisplayNone(layer.horizontalScrollbar());
4291     bool allowVerticalScrollbar = !scrollbarHasDisplayNone(layer.verticalScrollbar());
4292     m_chromeClient.addOrUpdateScrollingLayer(layer.renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer(),
4293         layer.scrollableContentsSize(), allowHorizontalScrollbar, allowVerticalScrollbar);
4294 }
4295 
4296 void LegacyWebKitScrollingLayerCoordinator::registerAllScrollingLayers()
4297 {
4298     for (auto* layer : m_scrollingLayers)
4299         updateScrollingLayer(*layer);
4300 }
4301 
4302 void LegacyWebKitScrollingLayerCoordinator::registerScrollingLayersNeedingUpdate()
4303 {
4304     for (auto* layer : m_scrollingLayersNeedingUpdate)
4305         updateScrollingLayer(*layer);
4306 
4307     m_scrollingLayersNeedingUpdate.clear();
4308 }
4309 
4310 void LegacyWebKitScrollingLayerCoordinator::unregisterAllScrollingLayers()
4311 {
4312     for (auto* layer : m_scrollingLayers) {
4313         auto* backing = layer-&gt;backing();
4314         ASSERT(backing);
4315         m_chromeClient.removeScrollingLayer(layer-&gt;renderer().element(), backing-&gt;scrollContainerLayer()-&gt;platformLayer(), backing-&gt;scrolledContentsLayer()-&gt;platformLayer());
4316     }
4317 }
4318 
4319 void LegacyWebKitScrollingLayerCoordinator::addScrollingLayer(RenderLayer&amp; layer)
4320 {
4321     m_scrollingLayers.add(&amp;layer);
4322     m_scrollingLayersNeedingUpdate.add(&amp;layer);
4323 }
4324 
4325 void LegacyWebKitScrollingLayerCoordinator::removeScrollingLayer(RenderLayer&amp; layer, RenderLayerBacking&amp; backing)
4326 {
4327     m_scrollingLayersNeedingUpdate.remove(&amp;layer);
4328     if (m_scrollingLayers.remove(&amp;layer)) {
4329         auto* scrollContainerLayer = backing.scrollContainerLayer()-&gt;platformLayer();
4330         auto* scrolledContentsLayer = backing.scrolledContentsLayer()-&gt;platformLayer();
4331         m_chromeClient.removeScrollingLayer(layer.renderer().element(), scrollContainerLayer, scrolledContentsLayer);
4332     }
4333 }
4334 
4335 void LegacyWebKitScrollingLayerCoordinator::removeLayer(RenderLayer&amp; layer)
4336 {
4337     removeScrollingLayer(layer, *layer.backing());
4338 
4339     // We&#39;ll put the new set of layers to the client via registerAllViewportConstrainedLayers() at flush time.
4340     m_viewportConstrainedLayers.remove(&amp;layer);
4341 }
4342 
4343 void LegacyWebKitScrollingLayerCoordinator::addViewportConstrainedLayer(RenderLayer&amp; layer)
4344 {
4345     m_viewportConstrainedLayers.add(&amp;layer);
4346 }
4347 
4348 void LegacyWebKitScrollingLayerCoordinator::removeViewportConstrainedLayer(RenderLayer&amp; layer)
4349 {
4350     m_viewportConstrainedLayers.remove(&amp;layer);
4351 }
4352 
4353 void LegacyWebKitScrollingLayerCoordinator::didChangePlatformLayerForLayer(RenderLayer&amp; layer)
4354 {
4355     if (m_scrollingLayers.contains(&amp;layer))
4356         m_scrollingLayersNeedingUpdate.add(&amp;layer);
4357 }
4358 
4359 #endif
4360 
4361 } // namespace WebCore
4362 
4363 #if ENABLE(TREE_DEBUGGING)
4364 void showGraphicsLayerTreeForCompositor(WebCore::RenderLayerCompositor&amp; compositor)
4365 {
4366     showGraphicsLayerTree(compositor.rootGraphicsLayer());
4367 }
4368 #endif
    </pre>
  </body>
</html>