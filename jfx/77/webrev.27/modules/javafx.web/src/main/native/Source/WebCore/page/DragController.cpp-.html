<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007-2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DragController.h&quot;
  28 
  29 #include &quot;HTMLAnchorElement.h&quot;
  30 #include &quot;SVGAElement.h&quot;
  31 
  32 #if ENABLE(DRAG_SUPPORT)
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;DataTransfer.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;DocumentFragment.h&quot;
  38 #include &quot;DragActions.h&quot;
  39 #include &quot;DragClient.h&quot;
  40 #include &quot;DragData.h&quot;
  41 #include &quot;DragImage.h&quot;
  42 #include &quot;DragState.h&quot;
  43 #include &quot;Editing.h&quot;
  44 #include &quot;Editor.h&quot;
  45 #include &quot;EditorClient.h&quot;
  46 #include &quot;ElementAncestorIterator.h&quot;
  47 #include &quot;EventHandler.h&quot;
  48 #include &quot;File.h&quot;
  49 #include &quot;FloatRect.h&quot;
  50 #include &quot;FocusController.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoadRequest.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameSelection.h&quot;
  55 #include &quot;FrameView.h&quot;
  56 #include &quot;HTMLAttachmentElement.h&quot;
  57 #include &quot;HTMLImageElement.h&quot;
  58 #include &quot;HTMLInputElement.h&quot;
  59 #include &quot;HTMLParserIdioms.h&quot;
  60 #include &quot;HTMLPlugInElement.h&quot;
  61 #include &quot;HitTestRequest.h&quot;
  62 #include &quot;HitTestResult.h&quot;
  63 #include &quot;Image.h&quot;
  64 #include &quot;ImageOrientation.h&quot;
  65 #include &quot;MoveSelectionCommand.h&quot;
  66 #include &quot;Page.h&quot;
  67 #include &quot;Pasteboard.h&quot;
  68 #include &quot;PlatformKeyboardEvent.h&quot;
  69 #include &quot;PluginDocument.h&quot;
  70 #include &quot;PluginViewBase.h&quot;
  71 #include &quot;Position.h&quot;
  72 #include &quot;PromisedAttachmentInfo.h&quot;
  73 #include &quot;RenderAttachment.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderImage.h&quot;
  76 #include &quot;RenderView.h&quot;
  77 #include &quot;ReplaceSelectionCommand.h&quot;
  78 #include &quot;ResourceRequest.h&quot;
  79 #include &quot;SecurityOrigin.h&quot;
  80 #include &quot;Settings.h&quot;
  81 #include &quot;ShadowRoot.h&quot;
  82 #include &quot;StyleProperties.h&quot;
  83 #include &quot;Text.h&quot;
  84 #include &quot;TextEvent.h&quot;
  85 #include &quot;VisiblePosition.h&quot;
  86 #include &quot;markup.h&quot;
  87 
  88 #if ENABLE(DATA_INTERACTION)
  89 #include &quot;SelectionRect.h&quot;
  90 #endif
  91 
  92 #include &lt;wtf/RefPtr.h&gt;
  93 #include &lt;wtf/SetForScope.h&gt;
  94 #endif
  95 
  96 #if ENABLE(DATA_DETECTION)
  97 #include &quot;DataDetection.h&quot;
  98 #endif
  99 
 100 namespace WebCore {
 101 
 102 bool isDraggableLink(const Element&amp; element)
 103 {
 104     if (is&lt;HTMLAnchorElement&gt;(element)) {
 105         auto&amp; anchorElement = downcast&lt;HTMLAnchorElement&gt;(element);
 106         if (!anchorElement.isLiveLink())
 107             return false;
 108 #if ENABLE(DATA_DETECTION)
 109         return !DataDetection::isDataDetectorURL(anchorElement.href());
 110 #else
 111         return true;
 112 #endif
 113     }
 114     if (is&lt;SVGAElement&gt;(element))
 115         return element.isLink();
 116     return false;
 117 }
 118 
 119 #if ENABLE(DRAG_SUPPORT)
 120 
 121 static PlatformMouseEvent createMouseEvent(const DragData&amp; dragData)
 122 {
 123     bool shiftKey = false;
 124     bool ctrlKey = false;
 125     bool altKey = false;
 126     bool metaKey = false;
 127 
 128     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
 129 
 130     return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
 131                               LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
 132                               metaKey, WallTime::now(), ForceAtClick, NoTap);
 133 }
 134 
 135 DragController::DragController(Page&amp; page, DragClient&amp; client)
 136     : m_page(page)
 137     , m_client(client)
 138     , m_numberOfItemsToBeAccepted(0)
 139     , m_dragHandlingMethod(DragHandlingMethod::None)
 140     , m_dragDestinationAction(DragDestinationActionNone)
 141     , m_dragSourceAction(DragSourceActionNone)
 142     , m_didInitiateDrag(false)
 143     , m_sourceDragOperation(DragOperationNone)
 144 {
 145 }
 146 
 147 DragController::~DragController()
 148 {
 149     m_client.dragControllerDestroyed();
 150 }
 151 
 152 static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 153 {
 154     chosePlainText = false;
 155 
 156     Document&amp; document = context.ownerDocument();
 157     if (dragData.containsCompatibleContent()) {
 158         if (auto fragment = frame.editor().webContentFromPasteboard(*Pasteboard::createForDragAndDrop(dragData), context, allowPlainText, chosePlainText))
 159             return fragment;
 160 
 161         if (dragData.containsURL(DragData::DoNotConvertFilenames)) {
 162             String title;
 163             String url = dragData.asURL(DragData::DoNotConvertFilenames, &amp;title);
 164             if (!url.isEmpty()) {
 165                 auto anchor = HTMLAnchorElement::create(document);
 166                 anchor-&gt;setHref(url);
 167                 if (title.isEmpty()) {
 168                     // Try the plain text first because the url might be normalized or escaped.
 169                     if (dragData.containsPlainText())
 170                         title = dragData.asPlainText();
 171                     if (title.isEmpty())
 172                         title = url;
 173                 }
 174                 anchor-&gt;appendChild(document.createTextNode(title));
 175                 auto fragment = document.createDocumentFragment();
 176                 fragment-&gt;appendChild(anchor);
 177                 return WTFMove(fragment);
 178             }
 179         }
 180     }
 181     if (allowPlainText &amp;&amp; dragData.containsPlainText()) {
 182         chosePlainText = true;
 183         return createFragmentFromText(context, dragData.asPlainText()).ptr();
 184     }
 185 
 186     return nullptr;
 187 }
 188 
 189 #if !PLATFORM(IOS_FAMILY)
 190 
 191 DragOperation DragController::platformGenericDragOperation()
 192 {
 193     return DragOperationMove;
 194 }
 195 
 196 #endif
 197 
 198 bool DragController::dragIsMove(FrameSelection&amp; selection, const DragData&amp; dragData)
 199 {
 200     const VisibleSelection&amp; visibleSelection = selection.selection();
 201     return m_documentUnderMouse == m_dragInitiator &amp;&amp; visibleSelection.isContentEditable() &amp;&amp; visibleSelection.isRange() &amp;&amp; !isCopyKeyDown(dragData);
 202 }
 203 
 204 void DragController::clearDragCaret()
 205 {
 206     m_page.dragCaretController().clear();
 207 }
 208 
 209 void DragController::dragEnded()
 210 {
 211     m_dragInitiator = nullptr;
 212     m_didInitiateDrag = false;
 213     m_documentUnderMouse = nullptr;
 214     clearDragCaret();
 215 
 216     m_client.dragEnded();
 217 }
 218 
 219 DragOperation DragController::dragEntered(const DragData&amp; dragData)
 220 {
 221     return dragEnteredOrUpdated(dragData);
 222 }
 223 
 224 void DragController::dragExited(const DragData&amp; dragData)
 225 {
 226     auto&amp; mainFrame = m_page.mainFrame();
 227     if (mainFrame.view())
 228         mainFrame.eventHandler().cancelDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 229     mouseMovedIntoDocument(nullptr);
 230     if (m_fileInputElementUnderMouse)
 231         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 232     m_fileInputElementUnderMouse = nullptr;
 233 }
 234 
 235 DragOperation DragController::dragUpdated(const DragData&amp; dragData)
 236 {
 237     return dragEnteredOrUpdated(dragData);
 238 }
 239 
 240 inline static bool dragIsHandledByDocument(DragHandlingMethod dragHandlingMethod)
 241 {
 242     return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
 243 }
 244 
 245 bool DragController::performDragOperation(const DragData&amp; dragData)
 246 {
 247     SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
 248     TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
 249 
 250     m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 251 
 252     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
 253     if (m_documentUnderMouse)
 254         shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
 255 
 256     if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
 257         m_client.willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);
 258         Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 259         bool preventedDefault = false;
 260         if (mainFrame-&gt;view())
 261             preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 262         if (preventedDefault) {
 263             clearDragCaret();
 264             m_documentUnderMouse = nullptr;
 265             return true;
 266         }
 267     }
 268 
 269     if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
 270         m_client.didConcludeEditDrag();
 271         m_documentUnderMouse = nullptr;
 272         clearDragCaret();
 273         return true;
 274     }
 275 
 276     m_documentUnderMouse = nullptr;
 277     clearDragCaret();
 278 
 279     if (operationForLoad(dragData) == DragOperationNone)
 280         return false;
 281 
 282     auto urlString = dragData.asURL();
 283     if (urlString.isEmpty())
 284         return false;
 285 
 286     m_client.willPerformDragDestinationAction(DragDestinationActionLoad, dragData);
 287     FrameLoadRequest frameLoadRequest { m_page.mainFrame(), { urlString }, shouldOpenExternalURLsPolicy };
 288     frameLoadRequest.setIsRequestFromClientOrUserInput();
 289     m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
 290     return true;
 291 }
 292 
 293 void DragController::mouseMovedIntoDocument(Document* newDocument)
 294 {
 295     if (m_documentUnderMouse == newDocument)
 296         return;
 297 
 298     // If we were over another document clear the selection
 299     if (m_documentUnderMouse)
 300         clearDragCaret();
 301     m_documentUnderMouse = newDocument;
 302 }
 303 
 304 DragOperation DragController::dragEnteredOrUpdated(const DragData&amp; dragData)
 305 {
 306     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(dragData.clientPosition()));
 307 
 308     m_dragDestinationAction = dragData.dragDestinationAction();
 309     if (m_dragDestinationAction == DragDestinationActionNone) {
 310         clearDragCaret(); // FIXME: Why not call mouseMovedIntoDocument(nullptr)?
 311         return DragOperationNone;
 312     }
 313 
 314     DragOperation dragOperation = DragOperationNone;
 315     m_dragHandlingMethod = tryDocumentDrag(dragData, m_dragDestinationAction, dragOperation);
 316     if (m_dragHandlingMethod == DragHandlingMethod::None &amp;&amp; (m_dragDestinationAction &amp; DragDestinationActionLoad)) {
 317         dragOperation = operationForLoad(dragData);
 318         if (dragOperation != DragOperationNone)
 319             m_dragHandlingMethod = DragHandlingMethod::PageLoad;
 320     } else if (m_dragHandlingMethod == DragHandlingMethod::SetColor)
 321         dragOperation = DragOperationCopy;
 322 
 323     updateSupportedTypeIdentifiersForDragHandlingMethod(m_dragHandlingMethod, dragData);
 324     return dragOperation;
 325 }
 326 
 327 static HTMLInputElement* asFileInput(Node&amp; node)
 328 {
 329     if (!is&lt;HTMLInputElement&gt;(node))
 330         return nullptr;
 331 
 332     auto* inputElement = &amp;downcast&lt;HTMLInputElement&gt;(node);
 333 
 334     // If this is a button inside of the a file input, move up to the file input.
 335     if (inputElement-&gt;isTextButton() &amp;&amp; is&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode())) {
 336         auto&amp; host = *downcast&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode()).host();
 337         inputElement = is&lt;HTMLInputElement&gt;(host) ? &amp;downcast&lt;HTMLInputElement&gt;(host) : nullptr;
 338     }
 339 
 340     return inputElement &amp;&amp; inputElement-&gt;isFileUpload() ? inputElement : nullptr;
 341 }
 342 
 343 #if ENABLE(INPUT_TYPE_COLOR)
 344 
 345 static bool isEnabledColorInput(Node&amp; node)
 346 {
 347     if (!is&lt;HTMLInputElement&gt;(node))
 348     return false;
 349     auto&amp; input = downcast&lt;HTMLInputElement&gt;(node);
 350     return input.isColorControl() &amp;&amp; !input.isDisabledFormControl();
 351 }
 352 
 353 static bool isInShadowTreeOfEnabledColorInput(Node&amp; node)
 354 {
 355     auto* host = node.shadowHost();
 356     return host &amp;&amp; isEnabledColorInput(*host);
 357 }
 358 
 359 #endif
 360 
 361 // This can return null if an empty document is loaded.
 362 static Element* elementUnderMouse(Document* documentUnderMouse, const IntPoint&amp; p)
 363 {
 364     Frame* frame = documentUnderMouse-&gt;frame();
 365     float zoomFactor = frame ? frame-&gt;pageZoomFactor() : 1;
 366     LayoutPoint point(p.x() * zoomFactor, p.y() * zoomFactor);
 367 
 368     HitTestResult result(point);
 369     documentUnderMouse-&gt;hitTest(HitTestRequest(), result);
 370 
 371     auto* node = result.innerNode();
 372     if (!node)
 373         return nullptr;
 374     // FIXME: Use parentElementInComposedTree here.
 375     auto* element = is&lt;Element&gt;(*node) ? &amp;downcast&lt;Element&gt;(*node) : node-&gt;parentElement();
 376     auto* host = element-&gt;shadowHost();
 377     return host ? host : element;
 378 }
 379 
 380 #if !ENABLE(DATA_INTERACTION)
 381 
 382 void DragController::updateSupportedTypeIdentifiersForDragHandlingMethod(DragHandlingMethod, const DragData&amp;) const
 383 {
 384 }
 385 
 386 #endif
 387 
 388 DragHandlingMethod DragController::tryDocumentDrag(const DragData&amp; dragData, DragDestinationAction actionMask, DragOperation&amp; dragOperation)
 389 {
 390     if (!m_documentUnderMouse)
 391         return DragHandlingMethod::None;
 392 
 393     if (m_dragInitiator &amp;&amp; !m_documentUnderMouse-&gt;securityOrigin().canReceiveDragData(m_dragInitiator-&gt;securityOrigin()))
 394         return DragHandlingMethod::None;
 395 
 396     bool isHandlingDrag = false;
 397     if (actionMask &amp; DragDestinationActionDHTML) {
 398         isHandlingDrag = tryDHTMLDrag(dragData, dragOperation);
 399         // Do not continue if m_documentUnderMouse has been reset by tryDHTMLDrag.
 400         // tryDHTMLDrag fires dragenter event. The event listener that listens
 401         // to this event may create a nested message loop (open a modal dialog),
 402         // which could process dragleave event and reset m_documentUnderMouse in
 403         // dragExited.
 404         if (!m_documentUnderMouse)
 405             return DragHandlingMethod::None;
 406     }
 407 
 408     // It&#39;s unclear why this check is after tryDHTMLDrag.
 409     // We send drag events in tryDHTMLDrag and that may be the reason.
 410     RefPtr&lt;FrameView&gt; frameView = m_documentUnderMouse-&gt;view();
 411     if (!frameView)
 412         return DragHandlingMethod::None;
 413 
 414     if (isHandlingDrag) {
 415         clearDragCaret();
 416         m_numberOfItemsToBeAccepted = dragData.numberOfFiles();
 417         return DragHandlingMethod::NonDefault;
 418     }
 419 
 420     if ((actionMask &amp; DragDestinationActionEdit) &amp;&amp; canProcessDrag(dragData)) {
 421         if (dragData.containsColor()) {
 422             dragOperation = DragOperationGeneric;
 423             return DragHandlingMethod::SetColor;
 424         }
 425 
 426         IntPoint point = frameView-&gt;windowToContents(dragData.clientPosition());
 427         Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 428         if (!element)
 429             return DragHandlingMethod::None;
 430 
 431         HTMLInputElement* elementAsFileInput = asFileInput(*element);
 432         if (m_fileInputElementUnderMouse != elementAsFileInput) {
 433             if (m_fileInputElementUnderMouse)
 434                 m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 435             m_fileInputElementUnderMouse = elementAsFileInput;
 436         }
 437 
 438         if (!m_fileInputElementUnderMouse)
 439             m_page.dragCaretController().setCaretPosition(m_documentUnderMouse-&gt;frame()-&gt;visiblePositionForPoint(point));
 440         else
 441             clearDragCaret();
 442 
 443         Frame* innerFrame = element-&gt;document().frame();
 444         dragOperation = dragIsMove(innerFrame-&gt;selection(), dragData) ? DragOperationMove : DragOperationCopy;
 445         m_numberOfItemsToBeAccepted = 0;
 446 
 447         unsigned numberOfFiles = dragData.numberOfFiles();
 448         if (m_fileInputElementUnderMouse) {
 449             if (m_fileInputElementUnderMouse-&gt;isDisabledFormControl())
 450                 m_numberOfItemsToBeAccepted = 0;
 451             else if (m_fileInputElementUnderMouse-&gt;multiple())
 452                 m_numberOfItemsToBeAccepted = numberOfFiles;
 453             else if (numberOfFiles &gt; 1)
 454                 m_numberOfItemsToBeAccepted = 0;
 455             else
 456                 m_numberOfItemsToBeAccepted = 1;
 457 
 458             if (!m_numberOfItemsToBeAccepted)
 459                 dragOperation = DragOperationNone;
 460             m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(m_numberOfItemsToBeAccepted);
 461         } else {
 462             // We are not over a file input element. The dragged item(s) will only
 463             // be loaded into the view the number of dragged items is 1.
 464             m_numberOfItemsToBeAccepted = numberOfFiles != 1 ? 0 : 1;
 465         }
 466 
 467         if (m_fileInputElementUnderMouse)
 468             return DragHandlingMethod::UploadFile;
 469 
 470         if (m_page.dragCaretController().isContentRichlyEditable())
 471             return DragHandlingMethod::EditRichText;
 472 
 473         return DragHandlingMethod::EditPlainText;
 474     }
 475 
 476     // We are not over an editable region. Make sure we&#39;re clearing any prior drag cursor.
 477     clearDragCaret();
 478     if (m_fileInputElementUnderMouse)
 479         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 480     m_fileInputElementUnderMouse = nullptr;
 481     return DragHandlingMethod::None;
 482 }
 483 
 484 DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
 485 {
 486     m_dragSourceAction = m_client.dragSourceActionMaskForPoint(rootViewPoint);
 487     return m_dragSourceAction;
 488 }
 489 
 490 DragOperation DragController::operationForLoad(const DragData&amp; dragData)
 491 {
 492     Document* document = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 493 
 494     bool pluginDocumentAcceptsDrags = false;
 495 
 496     if (is&lt;PluginDocument&gt;(document)) {
 497         const Widget* widget = downcast&lt;PluginDocument&gt;(*document).pluginWidget();
 498         const PluginViewBase* pluginView = is&lt;PluginViewBase&gt;(widget) ? downcast&lt;PluginViewBase&gt;(widget) : nullptr;
 499 
 500         if (pluginView)
 501             pluginDocumentAcceptsDrags = pluginView-&gt;shouldAllowNavigationFromDrags();
 502     }
 503 
 504     if (document &amp;&amp; (m_didInitiateDrag || (is&lt;PluginDocument&gt;(*document) &amp;&amp; !pluginDocumentAcceptsDrags) || document-&gt;hasEditableStyle()))
 505         return DragOperationNone;
 506     return dragOperation(dragData);
 507 }
 508 
 509 static bool setSelectionToDragCaret(Frame* frame, VisibleSelection&amp; dragCaret, RefPtr&lt;Range&gt;&amp; range, const IntPoint&amp; point)
 510 {
 511     Ref&lt;Frame&gt; protector(*frame);
 512     frame-&gt;selection().setSelection(dragCaret);
 513     if (frame-&gt;selection().selection().isNone()) {
 514         dragCaret = frame-&gt;visiblePositionForPoint(point);
 515         frame-&gt;selection().setSelection(dragCaret);
 516         range = dragCaret.toNormalizedRange();
 517     }
 518     return !frame-&gt;selection().isNone() &amp;&amp; frame-&gt;selection().selection().isContentEditable();
 519 }
 520 
 521 bool DragController::dispatchTextInputEventFor(Frame* innerFrame, const DragData&amp; dragData)
 522 {
 523     ASSERT(m_page.dragCaretController().hasCaret());
 524     String text = m_page.dragCaretController().isContentRichlyEditable() ? emptyString() : dragData.asPlainText();
 525     Element* target = innerFrame-&gt;editor().findEventTargetFrom(m_page.dragCaretController().caretPosition());
 526     // FIXME: What guarantees target is not null?
 527     auto event = TextEvent::createForDrop(&amp;innerFrame-&gt;windowProxy(), text);
 528     target-&gt;dispatchEvent(event);
 529     return !event-&gt;defaultPrevented();
 530 }
 531 
 532 bool DragController::concludeEditDrag(const DragData&amp; dragData)
 533 {
 534     RefPtr&lt;HTMLInputElement&gt; fileInput = m_fileInputElementUnderMouse;
 535     if (m_fileInputElementUnderMouse) {
 536         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 537         m_fileInputElementUnderMouse = nullptr;
 538     }
 539 
 540     if (!m_documentUnderMouse)
 541         return false;
 542 
 543     IntPoint point = m_documentUnderMouse-&gt;view()-&gt;windowToContents(dragData.clientPosition());
 544     Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 545     if (!element)
 546         return false;
 547     RefPtr&lt;Frame&gt; innerFrame = element-&gt;document().frame();
 548     ASSERT(innerFrame);
 549 
 550     if (m_page.dragCaretController().hasCaret() &amp;&amp; !dispatchTextInputEventFor(innerFrame.get(), dragData))
 551         return true;
 552 
 553     if (dragData.containsColor()) {
 554         Color color = dragData.asColor();
 555         if (!color.isValid())
 556             return false;
 557 #if ENABLE(INPUT_TYPE_COLOR)
 558         if (isEnabledColorInput(*element)) {
 559             auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
 560             input.setValue(color.serialized(), DispatchInputAndChangeEvent);
 561             return true;
 562         }
 563 #endif
 564         auto innerRange = innerFrame-&gt;selection().toNormalizedRange();
 565         if (!innerRange)
 566             return false;
 567         auto style = MutableStyleProperties::create();
 568         style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
 569         if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
 570             return false;
 571         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 572         innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
 573         return true;
 574     }
 575 
 576     if (dragData.containsFiles() &amp;&amp; fileInput) {
 577         // fileInput should be the element we hit tested for, unless it was made
 578         // display:none in a drop event handler.
 579         ASSERT(fileInput == element || !fileInput-&gt;renderer());
 580         if (fileInput-&gt;isDisabledFormControl())
 581             return false;
 582 
 583         return fileInput-&gt;receiveDroppedFiles(dragData);
 584     }
 585 
 586     if (!m_page.dragController().canProcessDrag(dragData))
 587         return false;
 588 
 589     VisibleSelection dragCaret = m_page.dragCaretController().caretPosition();
 590     RefPtr&lt;Range&gt; range = dragCaret.toNormalizedRange();
 591     RefPtr&lt;Element&gt; rootEditableElement = innerFrame-&gt;selection().selection().rootEditableElement();
 592 
 593     // For range to be null a WebKit client must have done something bad while
 594     // manually controlling drag behaviour
 595     if (!range)
 596         return false;
 597 
 598     ResourceCacheValidationSuppressor validationSuppressor(range-&gt;ownerDocument().cachedResourceLoader());
 599     auto&amp; editor = innerFrame-&gt;editor();
 600     bool isMove = dragIsMove(innerFrame-&gt;selection(), dragData);
 601     if (isMove || dragCaret.isContentRichlyEditable()) {
 602         bool chosePlainText = false;
 603         RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
 604         if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
 605             return false;
 606 
 607         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 608 
 609         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 610             return true;
 611 
 612         if (isMove) {
 613             // NSTextView behavior is to always smart delete on moving a selection,
 614             // but only to smart insert if the selection granularity is word granularity.
 615             bool smartDelete = editor.smartInsertDeleteEnabled();
 616             bool smartInsert = smartDelete &amp;&amp; innerFrame-&gt;selection().granularity() == WordGranularity &amp;&amp; dragData.canSmartReplace();
 617             MoveSelectionCommand::create(fragment.releaseNonNull(), dragCaret.base(), smartInsert, smartDelete)-&gt;apply();
 618         } else {
 619             if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point)) {
 620                 OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::PreventNesting };
 621                 if (dragData.canSmartReplace())
 622                     options.add(ReplaceSelectionCommand::SmartReplace);
 623                 if (chosePlainText)
 624                     options.add(ReplaceSelectionCommand::MatchStyle);
 625                 ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.releaseNonNull(), options, EditAction::InsertFromDrop)-&gt;apply();
 626             }
 627         }
 628     } else {
 629         String text = dragData.asPlainText();
 630         if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
 631             return false;
 632 
 633         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 634         RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
 635         if (!fragment)
 636             return false;
 637 
 638         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 639             return true;
 640 
 641         if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point))
 642             ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.get(), { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MatchStyle, ReplaceSelectionCommand::PreventNesting }, EditAction::InsertFromDrop)-&gt;apply();
 643     }
 644 
 645     if (rootEditableElement) {
 646         if (Frame* frame = rootEditableElement-&gt;document().frame())
 647             frame-&gt;eventHandler().updateDragStateAfterEditDragIfNeeded(*rootEditableElement);
 648     }
 649 
 650     return true;
 651 }
 652 
 653 bool DragController::canProcessDrag(const DragData&amp; dragData)
 654 {
 655     IntPoint point = m_page.mainFrame().view()-&gt;windowToContents(dragData.clientPosition());
 656     HitTestResult result = HitTestResult(point);
 657     if (!m_page.mainFrame().contentRenderer())
 658         return false;
 659 
 660     result = m_page.mainFrame().eventHandler().hitTestResultAtPoint(point, HitTestRequest::ReadOnly | HitTestRequest::Active);
 661 
 662     auto* dragNode = result.innerNonSharedNode();
 663     if (!dragNode)
 664         return false;
 665 
 666     DragData::DraggingPurpose dragPurpose = DragData::DraggingPurpose::ForEditing;
 667     if (asFileInput(*dragNode))
 668         dragPurpose = DragData::DraggingPurpose::ForFileUpload;
 669 #if ENABLE(INPUT_TYPE_COLOR)
 670     else if (isEnabledColorInput(*dragNode) || isInShadowTreeOfEnabledColorInput(*dragNode))
 671         dragPurpose = DragData::DraggingPurpose::ForColorControl;
 672 #endif
 673 
 674     if (!dragData.containsCompatibleContent(dragPurpose))
 675         return false;
 676 
 677     if (dragPurpose == DragData::DraggingPurpose::ForFileUpload)
 678         return true;
 679 
 680 #if ENABLE(INPUT_TYPE_COLOR)
 681     if (dragPurpose == DragData::DraggingPurpose::ForColorControl)
 682         return true;
 683 #endif
 684 
 685     if (is&lt;HTMLPlugInElement&gt;(*dragNode)) {
 686         if (!downcast&lt;HTMLPlugInElement&gt;(*dragNode).canProcessDrag() &amp;&amp; !dragNode-&gt;hasEditableStyle())
 687             return false;
 688     } else if (!dragNode-&gt;hasEditableStyle())
 689         return false;
 690 
 691     if (m_didInitiateDrag &amp;&amp; m_documentUnderMouse == m_dragInitiator &amp;&amp; result.isSelected())
 692         return false;
 693 
 694     return true;
 695 }
 696 
 697 static DragOperation defaultOperationForDrag(DragOperation srcOpMask)
 698 {
 699     // This is designed to match IE&#39;s operation fallback for the case where
 700     // the page calls preventDefault() in a drag event but doesn&#39;t set dropEffect.
 701     if (srcOpMask == DragOperationEvery)
 702         return DragOperationCopy;
 703     if (srcOpMask == DragOperationNone)
 704         return DragOperationNone;
 705     if (srcOpMask &amp; DragOperationMove)
 706         return DragOperationMove;
 707     if (srcOpMask &amp; DragOperationGeneric)
 708         return DragController::platformGenericDragOperation();
 709     if (srcOpMask &amp; DragOperationCopy)
 710         return DragOperationCopy;
 711     if (srcOpMask &amp; DragOperationLink)
 712         return DragOperationLink;
 713 
 714     // FIXME: Does IE really return &quot;generic&quot; even if no operations were allowed by the source?
 715     return DragOperationGeneric;
 716 }
 717 
 718 bool DragController::tryDHTMLDrag(const DragData&amp; dragData, DragOperation&amp; operation)
 719 {
 720     ASSERT(m_documentUnderMouse);
 721     Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 722     RefPtr&lt;FrameView&gt; viewProtector = mainFrame-&gt;view();
 723     if (!viewProtector)
 724         return false;
 725 
 726     DragOperation sourceOperation = dragData.draggingSourceOperationMask();
 727     auto targetResponse = mainFrame-&gt;eventHandler().updateDragAndDrop(createMouseEvent(dragData), [&amp;dragData]() { return Pasteboard::createForDragAndDrop(dragData); }, sourceOperation, dragData.containsFiles());
 728     if (!targetResponse.accept)
 729         return false;
 730 
 731     if (!targetResponse.operation)
 732         operation = defaultOperationForDrag(sourceOperation);
 733     else if (!(sourceOperation &amp; targetResponse.operation.value())) // The element picked an operation which is not supported by the source
 734         operation = DragOperationNone;
 735     else
 736         operation = targetResponse.operation.value();
 737 
 738     return true;
 739 }
 740 
 741 static bool imageElementIsDraggable(const HTMLImageElement&amp; image, const Frame&amp; sourceFrame)
 742 {
 743     if (sourceFrame.settings().loadsImagesAutomatically())
 744         return true;
 745 
 746     auto* renderer = image.renderer();
 747     if (!is&lt;RenderImage&gt;(renderer))
 748         return false;
 749 
 750     auto* cachedImage = downcast&lt;RenderImage&gt;(*renderer).cachedImage();
 751     return cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred() &amp;&amp; cachedImage-&gt;imageForRenderer(renderer);
 752 }
 753 
 754 #if ENABLE(ATTACHMENT_ELEMENT)
 755 
 756 static RefPtr&lt;HTMLAttachmentElement&gt; enclosingAttachmentElement(Element&amp; element)
 757 {
 758     if (is&lt;HTMLAttachmentElement&gt;(element))
 759         return downcast&lt;HTMLAttachmentElement&gt;(&amp;element);
 760 
 761     if (is&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement()))
 762         return downcast&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement());
 763 
 764     return { };
 765 }
 766 
 767 #endif
 768 
 769 Element* DragController::draggableElement(const Frame* sourceFrame, Element* startElement, const IntPoint&amp; dragOrigin, DragState&amp; state) const
 770 {
 771     state.type = (sourceFrame-&gt;selection().contains(dragOrigin)) ? DragSourceActionSelection : DragSourceActionNone;
 772     if (!startElement)
 773         return nullptr;
 774 #if ENABLE(ATTACHMENT_ELEMENT)
 775     if (auto attachment = enclosingAttachmentElement(*startElement)) {
 776         auto selection = sourceFrame-&gt;selection().selection();
 777         bool isSingleAttachmentSelection = selection.start() == Position(attachment.get(), Position::PositionIsBeforeAnchor) &amp;&amp; selection.end() == Position(attachment.get(), Position::PositionIsAfterAnchor);
 778         bool isAttachmentElementInCurrentSelection = false;
 779         if (auto selectedRange = selection.toNormalizedRange()) {
 780             auto compareResult = selectedRange-&gt;compareNode(*attachment);
 781             isAttachmentElementInCurrentSelection = !compareResult.hasException() &amp;&amp; compareResult.releaseReturnValue() == Range::NODE_INSIDE;
 782         }
 783 
 784         if (!isAttachmentElementInCurrentSelection || isSingleAttachmentSelection) {
 785             state.type = DragSourceActionAttachment;
 786             return attachment.get();
 787         }
 788     }
 789 #endif
 790 
 791     for (auto* element = startElement; element; element = element-&gt;parentOrShadowHostElement()) {
 792         auto* renderer = element-&gt;renderer();
 793         if (!renderer)
 794             continue;
 795 
 796         UserDrag dragMode = renderer-&gt;style().userDrag();
 797         if ((m_dragSourceAction &amp; DragSourceActionDHTML) &amp;&amp; dragMode == UserDrag::Element) {
 798             state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionDHTML);
 799             return element;
 800         }
 801         if (dragMode == UserDrag::Auto) {
 802             if ((m_dragSourceAction &amp; DragSourceActionImage)
 803                 &amp;&amp; is&lt;HTMLImageElement&gt;(*element)
 804                 &amp;&amp; imageElementIsDraggable(downcast&lt;HTMLImageElement&gt;(*element), *sourceFrame)) {
 805                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionImage);
 806                 return element;
 807             }
 808             if ((m_dragSourceAction &amp; DragSourceActionLink) &amp;&amp; isDraggableLink(*element)) {
 809                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionLink);
 810                 return element;
 811             }
 812 #if ENABLE(ATTACHMENT_ELEMENT)
 813             if ((m_dragSourceAction &amp; DragSourceActionAttachment)
 814                 &amp;&amp; is&lt;HTMLAttachmentElement&gt;(*element)
 815                 &amp;&amp; downcast&lt;HTMLAttachmentElement&gt;(*element).file()) {
 816                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionAttachment);
 817                 return element;
 818             }
 819 #endif
 820 #if ENABLE(INPUT_TYPE_COLOR)
 821             if ((m_dragSourceAction &amp; DragSourceActionColor) &amp;&amp; isEnabledColorInput(*element)) {
 822                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionColor);
 823                 return element;
 824             }
 825 #endif
 826         }
 827     }
 828 
 829     // We either have nothing to drag or we have a selection and we&#39;re not over a draggable element.
 830     return (state.type &amp; DragSourceActionSelection) ? startElement : nullptr;
 831 }
 832 
 833 static CachedImage* getCachedImage(Element&amp; element)
 834 {
 835     RenderObject* renderer = element.renderer();
 836     if (!is&lt;RenderImage&gt;(renderer))
 837         return nullptr;
 838     auto&amp; image = downcast&lt;RenderImage&gt;(*renderer);
 839     return image.cachedImage();
 840 }
 841 
 842 static Image* getImage(Element&amp; element)
 843 {
 844     CachedImage* cachedImage = getCachedImage(element);
 845     // Don&#39;t use cachedImage-&gt;imageForRenderer() here as that may return BitmapImages for cached SVG Images.
 846     // Users of getImage() want access to the SVGImage, in order to figure out the filename extensions,
 847     // which would be empty when asking the cached BitmapImages.
 848     return (cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred()) ?
 849         cachedImage-&gt;image() : nullptr;
 850 }
 851 
 852 static void selectElement(Element&amp; element)
 853 {
 854     RefPtr&lt;Range&gt; range = element.document().createRange();
 855     range-&gt;selectNode(element);
 856     element.document().frame()-&gt;selection().setSelection(VisibleSelection(*range, DOWNSTREAM));
 857 }
 858 
 859 static IntPoint dragLocForDHTMLDrag(const IntPoint&amp; mouseDraggedPoint, const IntPoint&amp; dragOrigin, const IntPoint&amp; dragImageOffset, bool isLinkImage)
 860 {
 861     // dragImageOffset is the cursor position relative to the lower-left corner of the image.
 862 #if PLATFORM(MAC)
 863     // We add in the Y dimension because we are a flipped view, so adding moves the image down.
 864     const int yOffset = dragImageOffset.y();
 865 #else
 866     const int yOffset = -dragImageOffset.y();
 867 #endif
 868 
 869     if (isLinkImage)
 870         return IntPoint(mouseDraggedPoint.x() - dragImageOffset.x(), mouseDraggedPoint.y() + yOffset);
 871 
 872     return IntPoint(dragOrigin.x() - dragImageOffset.x(), dragOrigin.y() + yOffset);
 873 }
 874 
 875 static FloatPoint dragImageAnchorPointForSelectionDrag(Frame&amp; frame, const IntPoint&amp; mouseDraggedPoint)
 876 {
 877     IntRect draggingRect = enclosingIntRect(frame.selection().selectionBounds());
 878 
 879     float x = (mouseDraggedPoint.x() - draggingRect.x()) / (float)draggingRect.width();
 880     float y = (mouseDraggedPoint.y() - draggingRect.y()) / (float)draggingRect.height();
 881 
 882     return FloatPoint { x, y };
 883 }
 884 
 885 static IntPoint dragLocForSelectionDrag(Frame&amp; src)
 886 {
 887     IntRect draggingRect = enclosingIntRect(src.selection().selectionBounds());
 888     int xpos = draggingRect.maxX();
 889     xpos = draggingRect.x() &lt; xpos ? draggingRect.x() : xpos;
 890     int ypos = draggingRect.maxY();
 891 #if PLATFORM(COCOA)
 892     // Deal with flipped coordinates on Mac
 893     ypos = draggingRect.y() &gt; ypos ? draggingRect.y() : ypos;
 894 #else
 895     ypos = draggingRect.y() &lt; ypos ? draggingRect.y() : ypos;
 896 #endif
 897     return IntPoint(xpos, ypos);
 898 }
 899 
 900 bool DragController::startDrag(Frame&amp; src, const DragState&amp; state, DragOperation srcOp, const PlatformMouseEvent&amp; dragEvent, const IntPoint&amp; dragOrigin, HasNonDefaultPasteboardData hasData)
 901 {
 902     if (!src.view() || !src.contentRenderer() || !state.source)
 903         return false;
 904 
 905     Ref&lt;Frame&gt; protector(src);
 906     HitTestResult hitTestResult = src.eventHandler().hitTestResultAtPoint(dragOrigin, HitTestRequest::ReadOnly | HitTestRequest::Active);
 907 
 908     bool sourceContainsHitNode = state.source-&gt;containsIncludingShadowDOM(hitTestResult.innerNode());
 909     if (!sourceContainsHitNode) {
 910         // The original node being dragged isn&#39;t under the drag origin anymore... maybe it was
 911         // hidden or moved out from under the cursor. Regardless, we don&#39;t want to start a drag on
 912         // something that&#39;s not actually under the drag origin.
 913         return false;
 914     }
 915 
 916     URL linkURL = hitTestResult.absoluteLinkURL();
 917     URL imageURL = hitTestResult.absoluteImageURL();
 918 
 919     IntPoint mouseDraggedPoint = src.view()-&gt;windowToContents(dragEvent.position());
 920 
 921     m_draggingImageURL = URL();
 922     m_sourceDragOperation = srcOp;
 923 
 924     DragImage dragImage;
 925     IntPoint dragLoc(0, 0);
 926     IntPoint dragImageOffset(0, 0);
 927 
 928     ASSERT(state.dataTransfer);
 929 
 930     DataTransfer&amp; dataTransfer = *state.dataTransfer;
 931     if (state.type == DragSourceActionDHTML) {
 932         dragImage = DragImage { dataTransfer.createDragImage(dragImageOffset) };
 933         // We allow DHTML/JS to set the drag image, even if its a link, image or text we&#39;re dragging.
 934         // This is in the spirit of the IE API, which allows overriding of pasteboard data and DragOp.
 935         if (dragImage) {
 936             dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, !linkURL.isEmpty());
 937             m_dragOffset = dragImageOffset;
 938         }
 939     }
 940 
 941     if (state.type == DragSourceActionSelection || !imageURL.isEmpty() || !linkURL.isEmpty()) {
 942         // Selection, image, and link drags receive a default set of allowed drag operations that
 943         // follows from:
 944         // http://trac.webkit.org/browser/trunk/WebKit/mac/WebView/WebHTMLView.mm?rev=48526#L3430
 945         m_sourceDragOperation = static_cast&lt;DragOperation&gt;(m_sourceDragOperation | DragOperationGeneric | DragOperationCopy);
 946     }
 947 
 948     ASSERT(state.source);
 949     Element&amp; element = *state.source;
 950 
 951     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || m_client.useLegacyDragClient();
 952 
 953     IntRect dragImageBounds;
 954     Image* image = getImage(element);
 955     if (state.type == DragSourceActionSelection) {
 956         PasteboardWriterData pasteboardWriterData;
 957 
 958         if (hasData == HasNonDefaultPasteboardData::No) {
 959             if (src.selection().selection().isNone()) {
 960                 // The page may have cleared out the selection in the dragstart handler, in which case we should bail
 961                 // out of the drag, since there is no content to write to the pasteboard.
 962                 return false;
 963             }
 964 
 965             // FIXME: This entire block is almost identical to the code in Editor::copy, and the code should be shared.
 966             RefPtr&lt;Range&gt; selectionRange = src.selection().toNormalizedRange();
 967             ASSERT(selectionRange);
 968 
 969             src.editor().willWriteSelectionToPasteboard(selectionRange.get());
 970 
 971             if (enclosingTextFormControl(src.selection().selection().start())) {
 972                 if (mustUseLegacyDragClient)
 973                     dataTransfer.pasteboard().writePlainText(src.editor().selectedTextForDataTransfer(), Pasteboard::CannotSmartReplace);
 974                 else {
 975                     PasteboardWriterData::PlainText plainText;
 976                     plainText.canSmartCopyOrDelete = false;
 977                     plainText.text = src.editor().selectedTextForDataTransfer();
 978                     pasteboardWriterData.setPlainText(WTFMove(plainText));
 979                 }
 980             } else {
 981                 if (mustUseLegacyDragClient) {
 982 #if PLATFORM(COCOA) || PLATFORM(GTK)
 983                     src.editor().writeSelectionToPasteboard(dataTransfer.pasteboard());
 984 #else
 985                     // FIXME: Convert all other platforms to match Mac and delete this.
 986                     dataTransfer.pasteboard().writeSelection(*selectionRange, src.editor().canSmartCopyOrDelete(), src, IncludeImageAltTextForDataTransfer);
 987 #endif
 988                 } else {
 989 #if PLATFORM(COCOA)
 990                     src.editor().writeSelection(pasteboardWriterData);
 991 #endif
 992                 }
 993             }
 994 
 995             src.editor().didWriteSelectionToPasteboard();
 996         }
 997         m_client.willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);
 998         if (!dragImage) {
 999             TextIndicatorData textIndicator;
1000             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1001             if (textIndicator.contentImage)
1002                 dragImage.setIndicatorData(textIndicator);
1003             dragLoc = dragLocForSelectionDrag(src);
1004             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1005         }
1006 
1007         if (!dragImage)
1008             return false;
1009 
1010         if (mustUseLegacyDragClient) {
1011             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1012             return true;
1013         }
1014 
1015         DragItem dragItem;
1016         dragItem.imageAnchorPoint = dragImageAnchorPointForSelectionDrag(src, mouseDraggedPoint);
1017         dragItem.image = WTFMove(dragImage);
1018         dragItem.data = WTFMove(pasteboardWriterData);
1019 
1020         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1021 
1022         return true;
1023     }
1024 
1025     if (!src.document()-&gt;securityOrigin().canDisplay(linkURL)) {
1026         src.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to drag local resource: &quot; + linkURL.stringCenterEllipsizedToLength());
1027         return false;
1028     }
1029 
1030     if (!imageURL.isEmpty() &amp;&amp; image &amp;&amp; !image-&gt;isNull() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionImage)) {
1031         // We shouldn&#39;t be starting a drag for an image that can&#39;t provide an extension.
1032         // This is an early detection for problems encountered later upon drop.
1033         ASSERT(!image-&gt;filenameExtension().isEmpty());
1034 
1035 #if ENABLE(ATTACHMENT_ELEMENT)
1036         auto attachmentInfo = promisedAttachmentInfo(src, element);
1037 #else
1038         PromisedAttachmentInfo attachmentInfo;
1039 #endif
1040 
1041         if (hasData == HasNonDefaultPasteboardData::No) {
1042             m_draggingImageURL = imageURL;
1043             if (element.isContentRichlyEditable())
1044                 selectElement(element);
1045             if (!attachmentInfo)
1046                 declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
1047         }
1048 
1049         m_client.willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);
1050 
1051         if (!dragImage)
1052             doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
1053         else {
1054             // DHTML defined drag image
1055             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(attachmentInfo));
1056         }
1057 
1058         return true;
1059     }
1060 
1061     if (!linkURL.isEmpty() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionLink)) {
1062         PasteboardWriterData pasteboardWriterData;
1063 
1064         String textContentWithSimplifiedWhiteSpace = hitTestResult.textContent().simplifyWhiteSpace();
1065 
1066         if (hasData == HasNonDefaultPasteboardData::No) {
1067             // Simplify whitespace so the title put on the dataTransfer resembles what the user sees
1068             // on the web page. This includes replacing newlines with spaces.
1069             if (mustUseLegacyDragClient)
1070                 src.editor().copyURL(linkURL, textContentWithSimplifiedWhiteSpace, dataTransfer.pasteboard());
1071             else
1072                 pasteboardWriterData.setURLData(src.editor().pasteboardWriterURL(linkURL, textContentWithSimplifiedWhiteSpace));
1073         } else {
1074             // Make sure the pasteboard also contains trustworthy link data
1075             // but don&#39;t overwrite more general pasteboard types.
1076             PasteboardURL pasteboardURL;
1077             pasteboardURL.url = linkURL;
1078             pasteboardURL.title = hitTestResult.textContent();
1079             dataTransfer.pasteboard().writeTrustworthyWebURLsPboardType(pasteboardURL);
1080         }
1081 
1082         const VisibleSelection&amp; sourceSelection = src.selection().selection();
1083         if (sourceSelection.isCaret() &amp;&amp; sourceSelection.isContentEditable()) {
1084             // a user can initiate a drag on a link without having any text
1085             // selected.  In this case, we should expand the selection to
1086             // the enclosing anchor element
1087             Position pos = sourceSelection.base();
1088             Node* node = enclosingAnchorElement(pos);
1089             if (node)
1090                 src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
1091         }
1092 
1093         m_client.willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);
1094         if (!dragImage) {
1095             TextIndicatorData textIndicator;
1096             dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
1097             if (dragImage) {
1098                 m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
1099                 dragLoc = IntPoint(dragOrigin.x() + m_dragOffset.x(), dragOrigin.y() + m_dragOffset.y());
1100                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1101                 if (textIndicator.contentImage)
1102                     dragImage.setIndicatorData(textIndicator);
1103             }
1104         }
1105 
1106         if (mustUseLegacyDragClient) {
1107             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1108             return true;
1109         }
1110 
1111         DragItem dragItem;
1112         dragItem.imageAnchorPoint = dragImage ? anchorPointForLinkDragImage(dragImage.get()) : FloatPoint();
1113         dragItem.image = WTFMove(dragImage);
1114         dragItem.data = WTFMove(pasteboardWriterData);
1115 
1116         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1117 
1118         return true;
1119     }
1120 
1121 #if ENABLE(ATTACHMENT_ELEMENT)
1122     if (is&lt;HTMLAttachmentElement&gt;(element) &amp;&amp; m_dragSourceAction &amp; DragSourceActionAttachment) {
1123         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
1124         auto* attachmentRenderer = attachment.renderer();
1125 
1126         src.editor().setIgnoreSelectionChanges(true);
1127         auto previousSelection = src.selection().selection();
1128         selectElement(element);
1129 
1130         PromisedAttachmentInfo promisedAttachment;
1131         if (hasData == HasNonDefaultPasteboardData::No) {
1132             promisedAttachment = promisedAttachmentInfo(src, attachment);
1133             auto&amp; editor = src.editor();
1134             if (!promisedAttachment &amp;&amp; editor.client()) {
1135 #if PLATFORM(COCOA)
1136                 // Otherwise, if no file URL is specified, call out to the injected bundle to populate the pasteboard with data.
1137                 editor.willWriteSelectionToPasteboard(src.selection().toNormalizedRange().get());
1138                 editor.writeSelectionToPasteboard(dataTransfer.pasteboard());
1139                 editor.didWriteSelectionToPasteboard();
1140 #endif
1141             }
1142         }
1143 
1144         m_client.willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);
1145 
1146         if (!dragImage) {
1147             TextIndicatorData textIndicator;
1148             if (attachmentRenderer)
1149                 attachmentRenderer-&gt;setShouldDrawBorder(false);
1150             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1151             if (attachmentRenderer)
1152                 attachmentRenderer-&gt;setShouldDrawBorder(true);
1153             if (textIndicator.contentImage)
1154                 dragImage.setIndicatorData(textIndicator);
1155             dragLoc = dragLocForSelectionDrag(src);
1156             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1157         }
1158         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(promisedAttachment));
1159         if (!element.isContentRichlyEditable())
1160             src.selection().setSelection(previousSelection);
1161         src.editor().setIgnoreSelectionChanges(false);
1162         return true;
1163     }
1164 #endif
1165 
1166 #if ENABLE(INPUT_TYPE_COLOR)
1167     bool isColorControl = is&lt;HTMLInputElement&gt;(state.source) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*state.source).isColorControl();
1168     if (isColorControl &amp;&amp; m_dragSourceAction &amp; DragSourceActionColor) {
1169         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*state.source);
1170         auto color = input.valueAsColor();
1171 
1172         Path visiblePath;
1173         dragImage = DragImage { createDragImageForColor(color, input.boundsInRootViewSpace(), input.document().page()-&gt;pageScaleFactor(), visiblePath) };
1174         dragImage.setVisiblePath(visiblePath);
1175         dataTransfer.pasteboard().write(color);
1176         dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
1177         dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
1178 
1179         m_client.willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);
1180         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1181         return true;
1182     }
1183 #endif
1184 
1185     if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
1186         ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
1187         m_client.willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);
1188         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1189         return true;
1190     }
1191 
1192     return false;
1193 }
1194 
1195 void DragController::doImageDrag(Element&amp; element, const IntPoint&amp; dragOrigin, const IntRect&amp; layoutRect, Frame&amp; frame, IntPoint&amp; dragImageOffset, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; attachmentInfo)
1196 {
1197     IntPoint mouseDownPoint = dragOrigin;
1198     DragImage dragImage;
1199     IntPoint scaledOrigin;
1200 
1201     if (!element.renderer())
1202         return;
1203 
1204     ImageOrientationDescription orientationDescription(element.renderer()-&gt;shouldRespectImageOrientation(), element.renderer()-&gt;style().imageOrientation());
1205 
1206     Image* image = getImage(element);
1207     if (image &amp;&amp; !layoutRect.isEmpty() &amp;&amp; shouldUseCachedImageForDragImage(*image) &amp;&amp; (dragImage = DragImage { createDragImageFromImage(image, element.renderer() ? orientationDescription : ImageOrientationDescription()) })) {
1208         dragImage = DragImage { fitDragImageToMaxSize(dragImage.get(), layoutRect.size(), maxDragImageSize()) };
1209         IntSize fittedSize = dragImageSize(dragImage.get());
1210 
1211         dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1212         dragImage = DragImage { dissolveDragImageToFraction(dragImage.get(), DragImageAlpha) };
1213 
1214         // Properly orient the drag image and orient it differently if it&#39;s smaller than the original.
1215         float scale = fittedSize.width() / (float)layoutRect.width();
1216         float dx = scale * (layoutRect.x() - mouseDownPoint.x());
1217         float originY = layoutRect.y();
1218 #if PLATFORM(COCOA)
1219         // Compensate for accursed flipped coordinates in Cocoa.
1220         originY += layoutRect.height();
1221 #endif
1222         float dy = scale * (originY - mouseDownPoint.y());
1223         scaledOrigin = IntPoint((int)(dx + 0.5), (int)(dy + 0.5));
1224     } else {
1225         if (CachedImage* cachedImage = getCachedImage(element)) {
1226             dragImage = DragImage { createDragImageIconForCachedImageFilename(cachedImage-&gt;response().suggestedFilename()) };
1227             if (dragImage) {
1228                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1229                 scaledOrigin = IntPoint(DragIconRightInset - dragImageSize(dragImage.get()).width(), DragIconBottomInset);
1230             }
1231         }
1232     }
1233 
1234     if (!dragImage)
1235         return;
1236 
1237     dragImageOffset = mouseDownPoint + scaledOrigin;
1238     doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
1239 }
1240 
1241 void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
1242 {
1243     ASSERT(!m_client.useLegacyDragClient());
1244 
1245     m_didInitiateDrag = true;
1246     m_dragInitiator = frame.document();
1247 
1248     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1249     Ref&lt;Frame&gt; mainFrameProtector(m_page.mainFrame());
1250     RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
1251 
1252     auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
1253     auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
1254 
1255     m_client.beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);
1256 }
1257 
1258 void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
1259 {
1260     m_didInitiateDrag = true;
1261     m_dragInitiator = frame.document();
1262     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1263     Ref&lt;Frame&gt; frameProtector(m_page.mainFrame());
1264     RefPtr&lt;FrameView&gt; viewProtector = frameProtector-&gt;view();
1265 
1266     DragItem item;
1267     item.image = WTFMove(image);
1268     item.sourceAction = state.type;
1269     item.promisedAttachmentInfo = WTFMove(promisedAttachmentInfo);
1270 
1271     auto eventPositionInRootViewCoordinates = frame.view()-&gt;contentsToRootView(eventPos);
1272     auto dragLocationInRootViewCoordinates = frame.view()-&gt;contentsToRootView(dragLoc);
1273     item.eventPositionInContentCoordinates = viewProtector-&gt;rootViewToContents(eventPositionInRootViewCoordinates);
1274     item.dragLocationInContentCoordinates = viewProtector-&gt;rootViewToContents(dragLocationInRootViewCoordinates);
1275     item.dragLocationInWindowCoordinates = viewProtector-&gt;contentsToWindow(item.dragLocationInContentCoordinates);
1276     if (auto element = state.source) {
1277         auto dataTransferImageElement = state.dataTransfer-&gt;dragImageElement();
1278         if (state.type == DragSourceActionDHTML) {
1279             // If the drag image has been customized, fall back to positioning the preview relative to the drag event location.
1280             IntSize dragPreviewSize;
1281             if (dataTransferImageElement)
1282                 dragPreviewSize = dataTransferImageElement-&gt;boundsInRootViewSpace().size();
1283             else {
1284                 dragPreviewSize = dragImageSize(item.image.get());
1285                 if (auto* page = frame.page())
1286                     dragPreviewSize.scale(1 / page-&gt;deviceScaleFactor());
1287             }
1288             item.dragPreviewFrameInRootViewCoordinates = { dragLocationInRootViewCoordinates, WTFMove(dragPreviewSize) };
1289         } else {
1290             // We can position the preview using the bounds of the drag source element.
1291             item.dragPreviewFrameInRootViewCoordinates = element-&gt;boundsInRootViewSpace();
1292         }
1293 
1294         RefPtr&lt;Element&gt; link;
1295         if (element-&gt;isLink())
1296             link = element;
1297         else {
1298             for (auto&amp; currentElement : elementLineage(element.get())) {
1299                 if (currentElement.isLink()) {
1300                     link = &amp;currentElement;
1301                     break;
1302                 }
1303             }
1304         }
1305         if (link) {
1306             auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
1307             item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
1308             item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
1309         }
1310     }
1311     m_client.startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());
1312     // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
1313     if (!frameProtector-&gt;page())
1314         return;
1315 
1316     cleanupAfterSystemDrag();
1317 }
1318 
1319 // Manual drag caret manipulation
1320 void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
1321 {
1322     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
1323     if (!m_documentUnderMouse)
1324         return;
1325     Frame* frame = m_documentUnderMouse-&gt;frame();
1326     FrameView* frameView = frame-&gt;view();
1327     if (!frameView)
1328         return;
1329     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
1330 
1331     m_page.dragCaretController().setCaretPosition(frame-&gt;visiblePositionForPoint(framePoint));
1332 }
1333 
1334 bool DragController::shouldUseCachedImageForDragImage(const Image&amp; image) const
1335 {
1336 #if ENABLE(DATA_INTERACTION)
1337     UNUSED_PARAM(image);
1338     return true;
1339 #else
1340     return image.size().height() * image.size().width() &lt;= MaxOriginalImageArea;
1341 #endif
1342 }
1343 
1344 #if !PLATFORM(COCOA)
1345 
1346 String DragController::platformContentTypeForBlobType(const String&amp; type) const
1347 {
1348     return type;
1349 }
1350 
1351 #endif
1352 
1353 #if ENABLE(ATTACHMENT_ELEMENT)
1354 
1355 PromisedAttachmentInfo DragController::promisedAttachmentInfo(Frame&amp; frame, Element&amp; element)
1356 {
1357     auto* client = frame.editor().client();
1358     if (!client || !client-&gt;supportsClientSideAttachmentData())
1359         return { };
1360 
1361     RefPtr&lt;HTMLAttachmentElement&gt; attachment;
1362     if (is&lt;HTMLAttachmentElement&gt;(element))
1363         attachment = &amp;downcast&lt;HTMLAttachmentElement&gt;(element);
1364     else if (is&lt;HTMLImageElement&gt;(element))
1365         attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement();
1366 
1367     if (!attachment)
1368         return { };
1369 
1370     Vector&lt;String&gt; additionalTypes;
1371     Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt; additionalData;
1372 #if PLATFORM(COCOA)
1373     frame.editor().getPasteboardTypesAndDataForAttachment(element, additionalTypes, additionalData);
1374 #endif
1375 
1376     if (auto* file = attachment-&gt;file())
1377         return { file-&gt;url(), platformContentTypeForBlobType(file-&gt;type()), file-&gt;name(), { }, WTFMove(additionalTypes), WTFMove(additionalData) };
1378 
1379     return { { }, { }, { }, attachment-&gt;uniqueIdentifier(), WTFMove(additionalTypes), WTFMove(additionalData) };
1380 }
1381 
1382 #endif // ENABLE(ATTACHMENT_ELEMENT)
1383 
1384 #endif // ENABLE(DRAG_SUPPORT)
1385 
1386 } // namespace WebCore
    </pre>
  </body>
</html>