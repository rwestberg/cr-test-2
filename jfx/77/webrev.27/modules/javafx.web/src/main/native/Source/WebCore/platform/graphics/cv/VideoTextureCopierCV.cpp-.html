<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;VideoTextureCopierCV.h&quot;
 28 
 29 #if HAVE(CORE_VIDEO)
 30 
 31 #include &quot;FourCC.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;TextureCacheCV.h&quot;
 34 #include &lt;pal/spi/cocoa/IOSurfaceSPI.h&gt;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 #include &lt;wtf/StdMap.h&gt;
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 #if USE(OPENGL_ES)
 40 #include &lt;OpenGLES/ES3/glext.h&gt;
 41 #endif
 42 
 43 #include &quot;CoreVideoSoftLink.h&quot;
 44 
 45 namespace WebCore {
 46 
 47 #if HAVE(IOSURFACE)
 48 enum class PixelRange {
 49     Unknown,
 50     Video,
 51     Full,
 52 };
 53 
 54 enum class TransferFunction {
 55     Unknown,
 56     kITU_R_709_2,
 57     kITU_R_601_4,
 58     kSMPTE_240M_1995,
 59     kDCI_P3,
 60     kP3_D65,
 61     kITU_R_2020,
 62 };
 63 
 64 #if PLATFORM(MAC) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &lt; 101300
 65 enum {
 66     kCVPixelFormatType_ARGB2101010LEPacked = &#39;l10r&#39;,
 67     kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange = &#39;x420&#39;,
 68     kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange = &#39;x422&#39;,
 69     kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange = &#39;x444&#39;,
 70     kCVPixelFormatType_420YpCbCr10BiPlanarFullRange  = &#39;xf20&#39;,
 71     kCVPixelFormatType_422YpCbCr10BiPlanarFullRange  = &#39;xf22&#39;,
 72     kCVPixelFormatType_444YpCbCr10BiPlanarFullRange  = &#39;xf44&#39;,
 73 };
 74 #endif
 75 
 76 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
 77 {
 78     switch (pixelFormat) {
 79     case kCVPixelFormatType_4444AYpCbCr8:
 80     case kCVPixelFormatType_4444AYpCbCr16:
 81     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
 82     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
 83     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
 84     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
 85     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
 86         return PixelRange::Video;
 87     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
 88     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
 89     case kCVPixelFormatType_422YpCbCr8FullRange:
 90     case kCVPixelFormatType_ARGB2101010LEPacked:
 91     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
 92     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
 93     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
 94         return PixelRange::Full;
 95     default:
 96         return PixelRange::Unknown;
 97     }
 98 }
 99 
100 static TransferFunction transferFunctionFromString(CFStringRef string)
101 {
102     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
103         return TransferFunction::kITU_R_709_2;
104     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
105         return TransferFunction::kITU_R_601_4;
106     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
107         return TransferFunction::kSMPTE_240M_1995;
108     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
109         return TransferFunction::kDCI_P3;
110     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
111         return TransferFunction::kP3_D65;
112     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
113         return TransferFunction::kITU_R_2020;
114     return TransferFunction::Unknown;
115 }
116 
117 struct GLfloatColor {
118     union {
119         struct {
120             GLfloat r;
121             GLfloat g;
122             GLfloat b;
123         } rgb;
124         struct {
125             GLfloat y;
126             GLfloat cb;
127             GLfloat cr;
128         } ycbcr;
129     };
130 
131     constexpr GLfloatColor(GLfloat r, GLfloat g, GLfloat b)
132         : rgb { r, g, b }
133     {
134     }
135 
136     constexpr GLfloatColor(int r, int g, int b, GLfloat scale)
137         : rgb { r / scale, g / scale, b / scale}
138     {
139     }
140 
141     static constexpr GLfloat abs(GLfloat value)
142     {
143         return value &gt;= 0 ? value : -value;
144     }
145 
146     constexpr bool isApproximatelyEqualTo(const GLfloatColor&amp; color, GLfloat maxDelta) const
147     {
148         return abs(rgb.r - color.rgb.r) &lt; abs(maxDelta)
149             &amp;&amp; abs(rgb.g - color.rgb.g) &lt; abs(maxDelta)
150             &amp;&amp; abs(rgb.b - color.rgb.b) &lt; abs(maxDelta);
151     }
152 };
153 
154 struct GLfloatColors {
155     static constexpr GLfloatColor black   {0, 0, 0};
156     static constexpr GLfloatColor white   {1, 1, 1};
157     static constexpr GLfloatColor red     {1, 0, 0};
158     static constexpr GLfloatColor green   {0, 1, 0};
159     static constexpr GLfloatColor blue    {0, 0, 1};
160     static constexpr GLfloatColor cyan    {0, 1, 1};
161     static constexpr GLfloatColor magenta {1, 0, 1};
162     static constexpr GLfloatColor yellow  {1, 1, 0};
163 };
164 
165 struct YCbCrMatrix {
166     union {
167         GLfloat rows[4][4];
168         GLfloat data[16];
169     };
170 
171     constexpr YCbCrMatrix(PixelRange, GLfloat cbCoefficient, GLfloat crCoefficient);
172 
173     operator Vector&lt;GLfloat&gt;() const
174     {
175         Vector&lt;GLfloat&gt; vector;
176         vector.append(data, 16);
177         return vector;
178     }
179 
180     constexpr GLfloatColor operator*(const GLfloatColor&amp;) const;
181 };
182 
183 constexpr YCbCrMatrix::YCbCrMatrix(PixelRange range, GLfloat cbCoefficient, GLfloat crCoefficient)
184     : rows { }
185 {
186     // The conversion from YCbCr -&gt; RGB generally takes the form:
187     // Y = Kr * R + Kg * G + Kb * B
188     // Cb = (B - Y) / (2 * (1 - Kb))
189     // Cr = (R - Y) / (2 * (1 - Kr))
190     // Where the values of Kb and Kr are defined in a specification and Kg is derived from: Kr + Kg + Kb = 1
191     //
192     // Solving the above equations for R, B, and G derives the following:
193     // R = Y + (2 * (1 - Kr)) * Cr
194     // B = Y + (2 * (1 - Kb)) * Cb
195     // G = Y - (2 * (1 - Kb)) * (Kb / Kg) * Cb - ((1 - Kr) * 2) * (Kr / Kg) * Cr
196     //
197     // When the color values are Video range, Y has a range of [16, 235] with a width of 219, and Cb &amp; Cr have
198     // a range of [16, 240] with a width of 224. When the color values are Full range, Y, Cb, and Cr all have
199     // a range of [0, 255] with a width of 256.
200 
201     GLfloat cgCoefficient = 1 - cbCoefficient - crCoefficient;
202     GLfloat yScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 219.f;
203     GLfloat cbcrScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 224.f;
204 
205     rows[0][0] = yScalingFactor;
206     rows[0][1] = 0;
207     rows[0][2] = cbcrScalingFactor * 2 * (1 - crCoefficient);
208     rows[0][3] = 0;
209 
210     rows[1][0] = yScalingFactor;
211     rows[1][1] = -cbcrScalingFactor * 2 * (1 - cbCoefficient) * (cbCoefficient / cgCoefficient);
212     rows[1][2] = -cbcrScalingFactor * 2 * (1 - crCoefficient) * (crCoefficient / cgCoefficient);
213     rows[1][3] = 0;
214 
215     rows[2][0] = yScalingFactor;
216     rows[2][1] = cbcrScalingFactor * 2 * (1 - cbCoefficient);
217     rows[2][2] = 0;
218     rows[2][3] = 0;
219 
220     rows[3][0] = 0;
221     rows[3][1] = 0;
222     rows[3][2] = 0;
223     rows[3][3] = 1;
224 
225     // Configure the final column of the matrix to convert Cb and Cr to [-128, 128]
226     // and, in the case of video-range, to convert Y to [16, 240]:
227     for (auto rowNumber = 0; rowNumber &lt; 3; ++rowNumber) {
228         auto&amp; row = rows[rowNumber];
229         auto&amp; x = row[0];
230         auto&amp; y = row[1];
231         auto&amp; z = row[2];
232         auto&amp; w = row[3];
233 
234         w -= (y + z) * 128 / 255;
235         if (range == PixelRange::Video)
236             w -= x * 16 / 255;
237     }
238 }
239 
240 constexpr GLfloatColor YCbCrMatrix::operator*(const GLfloatColor&amp; color) const
241 {
242     return GLfloatColor(
243         rows[0][0] * color.rgb.r + rows[0][1] * color.rgb.g + rows[0][2] * color.rgb.b + rows[0][3],
244         rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
245         rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
246     );
247 }
248 
249 static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunction transferFunction)
250 {
251     using MapKey = std::pair&lt;PixelRange, TransferFunction&gt;;
252     using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
253 
254     static NeverDestroyed&lt;MatrixMap&gt; matrices;
255     static dispatch_once_t onceToken;
256 
257     // Matrices are derived from the components in the ITU R.601 rev 4 specification
258     // https://www.itu.int/rec/R-REC-BT.601
259     constexpr static YCbCrMatrix r601VideoMatrix { PixelRange::Video, 0.114f, 0.299f };
260     constexpr static YCbCrMatrix r601FullMatrix { PixelRange::Full, 0.114f, 0.299f };
261 
262     static_assert((r601VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 video matrix does not produce black color&quot;);
263     static_assert((r601VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 video matrix does not produce white color&quot;);
264     static_assert((r601VideoMatrix * GLfloatColor(81,  90,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 video matrix does not produce red color&quot;);
265     static_assert((r601VideoMatrix * GLfloatColor(145, 54,  34,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 video matrix does not produce green color&quot;);
266     static_assert((r601VideoMatrix * GLfloatColor(41,  240, 110, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 video matrix does not produce blue color&quot;);
267     static_assert((r601VideoMatrix * GLfloatColor(210, 16,  146, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 video matrix does not produce yellow color&quot;);
268     static_assert((r601VideoMatrix * GLfloatColor(106, 202, 222, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 video matrix does not produce magenta color&quot;);
269     static_assert((r601VideoMatrix * GLfloatColor(170, 166, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 video matrix does not produce cyan color&quot;);
270 
271     static_assert((r601FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 full matrix does not produce black color&quot;);
272     static_assert((r601FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 full matrix does not produce white color&quot;);
273     static_assert((r601FullMatrix * GLfloatColor(76,  85,  255, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 full matrix does not produce red color&quot;);
274     static_assert((r601FullMatrix * GLfloatColor(150, 44,  21,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 full matrix does not produce green color&quot;);
275     static_assert((r601FullMatrix * GLfloatColor(29,  255, 107, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 full matrix does not produce blue color&quot;);
276     static_assert((r601FullMatrix * GLfloatColor(226, 0,   149, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 full matrix does not produce yellow color&quot;);
277     static_assert((r601FullMatrix * GLfloatColor(105, 212, 235, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 full matrix does not produce magenta color&quot;);
278     static_assert((r601FullMatrix * GLfloatColor(179, 171, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 full matrix does not produce cyan color&quot;);
279 
280     // Matrices are derived from the components in the ITU R.709 rev 2 specification
281     // https://www.itu.int/rec/R-REC-BT.709-2-199510-S
282     constexpr static YCbCrMatrix r709VideoMatrix { PixelRange::Video, 0.0722, 0.2126 };
283     constexpr static YCbCrMatrix r709FullMatrix { PixelRange::Full, 0.0722, 0.2126 };
284 
285     static_assert((r709VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 video matrix does not produce black color&quot;);
286     static_assert((r709VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 video matrix does not produce white color&quot;);
287     static_assert((r709VideoMatrix * GLfloatColor(63,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 video matrix does not produce red color&quot;);
288     static_assert((r709VideoMatrix * GLfloatColor(173, 42,  26,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 video matrix does not produce green color&quot;);
289     static_assert((r709VideoMatrix * GLfloatColor(32,  240, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 video matrix does not produce blue color&quot;);
290     static_assert((r709VideoMatrix * GLfloatColor(219, 16,  138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 video matrix does not produce yellow color&quot;);
291     static_assert((r709VideoMatrix * GLfloatColor(78,  214, 230, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 video matrix does not produce magenta color&quot;);
292     static_assert((r709VideoMatrix * GLfloatColor(188, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 video matrix does not produce cyan color&quot;);
293 
294     static_assert((r709FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 full matrix does not produce black color&quot;);
295     static_assert((r709FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 full matrix does not produce white color&quot;);
296     static_assert((r709FullMatrix * GLfloatColor(54,  99,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 full matrix does not produce red color&quot;);
297     static_assert((r709FullMatrix * GLfloatColor(182, 30,  12,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 full matrix does not produce green color&quot;);
298     static_assert((r709FullMatrix * GLfloatColor(18,  256, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 full matrix does not produce blue color&quot;);
299     static_assert((r709FullMatrix * GLfloatColor(237, 1,   140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 full matrix does not produce yellow color&quot;);
300     static_assert((r709FullMatrix * GLfloatColor(73,  226, 244, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 full matrix does not produce magenta color&quot;);
301     static_assert((r709FullMatrix * GLfloatColor(201, 157, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 full matrix does not produce cyan color&quot;);
302 
303     // Matrices are derived from the components in the ITU-R BT.2020-2 specification
304     // https://www.itu.int/rec/R-REC-BT.2020
305     constexpr static YCbCrMatrix bt2020VideoMatrix { PixelRange::Video, 0.0593, 0.2627 };
306     constexpr static YCbCrMatrix bt2020FullMatrix { PixelRange::Full, 0.0593, 0.2627 };
307 
308     static_assert((bt2020VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce black color&quot;);
309     static_assert((bt2020VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce white color&quot;);
310     static_assert((bt2020VideoMatrix * GLfloatColor(74,  97,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 video matrix does not produce red color&quot;);
311     static_assert((bt2020VideoMatrix * GLfloatColor(164, 47,  25,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce green color&quot;);
312     static_assert((bt2020VideoMatrix * GLfloatColor(29,  240, 119, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce blue color&quot;);
313     static_assert((bt2020VideoMatrix * GLfloatColor(222, 16,  137, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 video matrix does not produce yellow color&quot;);
314     static_assert((bt2020VideoMatrix * GLfloatColor(87,  209, 231, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 video matrix does not produce magenta color&quot;);
315     static_assert((bt2020VideoMatrix * GLfloatColor(177, 159, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce cyan color&quot;);
316 
317     static_assert((bt2020FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce black color&quot;);
318     static_assert((bt2020FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce white color&quot;);
319     static_assert((bt2020FullMatrix * GLfloatColor(67,  92,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 full matrix does not produce red color&quot;);
320     static_assert((bt2020FullMatrix * GLfloatColor(173, 36,  11,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce green color&quot;);
321     static_assert((bt2020FullMatrix * GLfloatColor(15,  256, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce blue color&quot;);
322     static_assert((bt2020FullMatrix * GLfloatColor(240, 0,   138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 full matrix does not produce yellow color&quot;);
323     static_assert((bt2020FullMatrix * GLfloatColor(82,  220, 245, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 full matrix does not produce magenta color&quot;);
324     static_assert((bt2020FullMatrix * GLfloatColor(188, 164, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce cyan color&quot;);
325 
326     // Matrices are derived from the components in the SMPTE 240M-1999 specification
327     // http://ieeexplore.ieee.org/document/7291461/
328     constexpr static YCbCrMatrix smpte240MVideoMatrix { PixelRange::Video, 0.087, 0.212 };
329     constexpr static YCbCrMatrix smpte240MFullMatrix { PixelRange::Full, 0.087, 0.212 };
330 
331     static_assert((smpte240MVideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce black color&quot;);
332     static_assert((smpte240MVideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce white color&quot;);
333     static_assert((smpte240MVideoMatrix * GLfloatColor(62,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce red color&quot;);
334     static_assert((smpte240MVideoMatrix * GLfloatColor(170, 42,  28,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce green color&quot;);
335     static_assert((smpte240MVideoMatrix * GLfloatColor(35,  240, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce blue color&quot;);
336     static_assert((smpte240MVideoMatrix * GLfloatColor(216, 16,  140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce yellow color&quot;);
337     static_assert((smpte240MVideoMatrix * GLfloatColor(81,  214, 228, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce magenta color&quot;);
338     static_assert((smpte240MVideoMatrix * GLfloatColor(189, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce cyan color&quot;);
339 
340     static_assert((smpte240MFullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce black color&quot;);
341     static_assert((smpte240MFullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce white color&quot;);
342     static_assert((smpte240MFullMatrix * GLfloatColor(54,  98,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce red color&quot;);
343     static_assert((smpte240MFullMatrix * GLfloatColor(179, 30,  15,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce green color&quot;);
344     static_assert((smpte240MFullMatrix * GLfloatColor(22,  256, 114, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce blue color&quot;);
345     static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
346     static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
347     static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
348 
349     dispatch_once(&amp;onceToken, ^{
350         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_601_4), r601VideoMatrix);
351         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_601_4), r601FullMatrix);
352         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_709_2), r709VideoMatrix);
353         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_709_2), r709FullMatrix);
354         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_2020), bt2020VideoMatrix);
355         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_2020), bt2020FullMatrix);
356         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kSMPTE_240M_1995), smpte240MVideoMatrix);
357         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kSMPTE_240M_1995), smpte240MFullMatrix);
358     });
359 
360     // We should never be asked to handle a Pixel Format whose range value is unknown.
361     ASSERT(range != PixelRange::Unknown);
362     if (range == PixelRange::Unknown)
363         range = PixelRange::Full;
364 
365     auto iterator = matrices.get().find({range, transferFunction});
366 
367     // Assume unknown transfer functions are r.601:
368     if (iterator == matrices.get().end())
369         iterator = matrices.get().find({range, TransferFunction::kITU_R_601_4});
370 
371     ASSERT(iterator != matrices.get().end());
372     return iterator-&gt;second;
373 }
374 #endif // HAVE(IOSURFACE)
375 
376 VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContext3D&amp; context)
377     : m_sharedContext(context)
378     , m_context(GraphicsContext3D::createShared(context))
379     , m_framebuffer(context.createFramebuffer())
380 {
381 }
382 
383 VideoTextureCopierCV::~VideoTextureCopierCV()
384 {
385     if (m_vertexBuffer)
386         m_context-&gt;deleteProgram(m_vertexBuffer);
387     if (m_program)
388         m_context-&gt;deleteProgram(m_program);
389     if (m_yuvVertexBuffer)
390         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
391     if (m_yuvProgram)
392         m_context-&gt;deleteProgram(m_yuvProgram);
393     m_context-&gt;deleteFramebuffer(m_framebuffer);
394 }
395 
396 #if !LOG_DISABLED
397 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
398 #define STRINGIFY_PAIR(e) e, #e
399 static StringMap&amp; enumToStringMap()
400 {
401     static NeverDestroyed&lt;StringMap&gt; map;
402     if (map.get().empty()) {
403         StringMap stringMap;
404         map.get().emplace(STRINGIFY_PAIR(GL_RGB));
405         map.get().emplace(STRINGIFY_PAIR(GL_RGBA));
406         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE_ALPHA));
407         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE));
408         map.get().emplace(STRINGIFY_PAIR(GL_ALPHA));
409         map.get().emplace(STRINGIFY_PAIR(GL_R8));
410         map.get().emplace(STRINGIFY_PAIR(GL_R16F));
411         map.get().emplace(STRINGIFY_PAIR(GL_R32F));
412         map.get().emplace(STRINGIFY_PAIR(GL_R8UI));
413         map.get().emplace(STRINGIFY_PAIR(GL_R8I));
414         map.get().emplace(STRINGIFY_PAIR(GL_R16UI));
415         map.get().emplace(STRINGIFY_PAIR(GL_R16I));
416         map.get().emplace(STRINGIFY_PAIR(GL_R32UI));
417         map.get().emplace(STRINGIFY_PAIR(GL_R32I));
418         map.get().emplace(STRINGIFY_PAIR(GL_RG8));
419         map.get().emplace(STRINGIFY_PAIR(GL_RG16F));
420         map.get().emplace(STRINGIFY_PAIR(GL_RG32F));
421         map.get().emplace(STRINGIFY_PAIR(GL_RG8UI));
422         map.get().emplace(STRINGIFY_PAIR(GL_RG8I));
423         map.get().emplace(STRINGIFY_PAIR(GL_RG16UI));
424         map.get().emplace(STRINGIFY_PAIR(GL_RG16I));
425         map.get().emplace(STRINGIFY_PAIR(GL_RG32UI));
426         map.get().emplace(STRINGIFY_PAIR(GL_RG32I));
427         map.get().emplace(STRINGIFY_PAIR(GL_RGB8));
428         map.get().emplace(STRINGIFY_PAIR(GL_SRGB8));
429         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8));
430         map.get().emplace(STRINGIFY_PAIR(GL_SRGB8_ALPHA8));
431         map.get().emplace(STRINGIFY_PAIR(GL_RGBA4));
432         map.get().emplace(STRINGIFY_PAIR(GL_RGB10_A2));
433         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT16));
434         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT24));
435         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT32F));
436         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH24_STENCIL8));
437         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH32F_STENCIL8));
438         map.get().emplace(STRINGIFY_PAIR(GL_RGB));
439         map.get().emplace(STRINGIFY_PAIR(GL_RGBA));
440         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE_ALPHA));
441         map.get().emplace(STRINGIFY_PAIR(GL_LUMINANCE));
442         map.get().emplace(STRINGIFY_PAIR(GL_ALPHA));
443         map.get().emplace(STRINGIFY_PAIR(GL_RED));
444         map.get().emplace(STRINGIFY_PAIR(GL_RG_INTEGER));
445         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_STENCIL));
446         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_BYTE));
447         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_5_6_5));
448         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_4_4_4_4));
449         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT_5_5_5_1));
450         map.get().emplace(STRINGIFY_PAIR(GL_BYTE));
451         map.get().emplace(STRINGIFY_PAIR(GL_HALF_FLOAT));
452         map.get().emplace(STRINGIFY_PAIR(GL_FLOAT));
453         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_SHORT));
454         map.get().emplace(STRINGIFY_PAIR(GL_SHORT));
455         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT));
456         map.get().emplace(STRINGIFY_PAIR(GL_INT));
457         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_2_10_10_10_REV));
458         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_24_8));
459         map.get().emplace(STRINGIFY_PAIR(GL_FLOAT_32_UNSIGNED_INT_24_8_REV));
460 
461 #if USE(OPENGL_ES)
462         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
463         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
464         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
465         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
466         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
467         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
468         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
469         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
470         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
471         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
472         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
473         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
474         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
475         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
476         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
477         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
478         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
479         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
480         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8UI));
481         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8I));
482         map.get().emplace(STRINGIFY_PAIR(GL_RGB10_A2UI));
483         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16UI));
484         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16I));
485         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32I));
486         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32UI));
487         map.get().emplace(STRINGIFY_PAIR(GL_RGB5_A1));
488         map.get().emplace(STRINGIFY_PAIR(GL_RG));
489         map.get().emplace(STRINGIFY_PAIR(GL_RGBA_INTEGER));
490         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT));
491         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_10F_11F_11F_REV));
492         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_5_9_9_9_REV));
493 #endif
494     }
495     return map.get();
496 }
497 
498 #endif
499 
500 bool VideoTextureCopierCV::initializeContextObjects()
501 {
502     StringBuilder vertexShaderSource;
503     vertexShaderSource.appendLiteral(&quot;attribute vec4 a_position;\n&quot;);
504     vertexShaderSource.appendLiteral(&quot;uniform int u_flipY;\n&quot;);
505     vertexShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
506     vertexShaderSource.appendLiteral(&quot;void main() {\n&quot;);
507     vertexShaderSource.appendLiteral(&quot;    v_texturePosition = vec2((a_position.x + 1.0) / 2.0, (a_position.y + 1.0) / 2.0);\n&quot;);
508     vertexShaderSource.appendLiteral(&quot;    if (u_flipY == 1) {\n&quot;);
509     vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
510     vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
511     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
512     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
513 
514     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
515     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
516     m_context-&gt;compileShaderDirect(vertexShader);
517 
518     GC3Dint value = 0;
519     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
520     if (!value) {
521         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
522         m_context-&gt;deleteShader(vertexShader);
523         return false;
524     }
525 
526     StringBuilder fragmentShaderSource;
527 
528 #if USE(OPENGL_ES)
529     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
530     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
531 #else
532     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
533 #endif
534     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
535     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
536     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
537     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
538     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
539     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
540 #if USE(OPENGL_ES)
541     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
542 #else
543     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
544 #endif
545     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
546     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
547     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
548     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
549     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
550     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
551     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
552     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
553     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
554 
555     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
556     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
557     m_context-&gt;compileShaderDirect(fragmentShader);
558 
559     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);
560     if (!value) {
561         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
562         m_context-&gt;deleteShader(vertexShader);
563         m_context-&gt;deleteShader(fragmentShader);
564         return false;
565     }
566 
567     m_program = m_context-&gt;createProgram();
568     m_context-&gt;attachShader(m_program, vertexShader);
569     m_context-&gt;attachShader(m_program, fragmentShader);
570     m_context-&gt;linkProgram(m_program);
571 
572     m_context-&gt;getProgramiv(m_program, GraphicsContext3D::LINK_STATUS, &amp;value);
573     if (!value) {
574         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
575         m_context-&gt;deleteShader(vertexShader);
576         m_context-&gt;deleteShader(fragmentShader);
577         m_context-&gt;deleteProgram(m_program);
578         m_program = 0;
579         return false;
580     }
581 
582     m_textureUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_texture&quot;_s);
583     m_textureDimensionsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_textureDimensions&quot;_s);
584     m_flipYUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_flipY&quot;_s);
585     m_swapColorChannelsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_swapColorChannels&quot;_s);
586     m_premultiplyUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_premultiply&quot;_s);
587     m_positionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_program, &quot;a_position&quot;_s);
588 
589     m_context-&gt;detachShader(m_program, vertexShader);
590     m_context-&gt;detachShader(m_program, fragmentShader);
591     m_context-&gt;deleteShader(vertexShader);
592     m_context-&gt;deleteShader(fragmentShader);
593 
594     LOG(WebGL, &quot;Uniform and Attribute locations: u_texture = %d, u_textureDimensions = %d, u_flipY = %d, u_premultiply = %d, a_position = %d&quot;, m_textureUniformLocation, m_textureDimensionsUniformLocation, m_flipYUniformLocation, m_premultiplyUniformLocation, m_positionAttributeLocation);
595     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
596 
597     m_vertexBuffer = m_context-&gt;createBuffer();
598     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
599 
600     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);
601     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContext3D::STATIC_DRAW);
602 
603     return true;
604 }
605 
606 bool VideoTextureCopierCV::initializeUVContextObjects()
607 {
608     String vertexShaderSource {
609         &quot;attribute vec2 a_position;\n&quot;
610         &quot;uniform vec2 u_yTextureSize;\n&quot;
611         &quot;uniform vec2 u_uvTextureSize;\n&quot;
612         &quot;uniform int u_flipY;\n&quot;
613         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
614         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
615         &quot;void main() {\n&quot;
616         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
617         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
618         &quot;   if (u_flipY == 1) {\n&quot;
619         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
620         &quot;   }\n&quot;
621 #if USE(OPENGL_ES)
622         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
623         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
624 #else
625         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
626         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
627 #endif
628         &quot;}\n&quot;_s
629     };
630 
631     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);
632     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
633     m_context-&gt;compileShaderDirect(vertexShader);
634 
635     GC3Dint status = 0;
636     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
637     if (!status) {
638         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
639         m_context-&gt;deleteShader(vertexShader);
640         return false;
641     }
642 
643     String fragmentShaderSource {
644 #if USE(OPENGL_ES)
645         &quot;precision mediump float;\n&quot;
646         &quot;#define SAMPLERTYPE sampler2D\n&quot;
647         &quot;#define TEXTUREFUNC texture2D\n&quot;
648 #else
649         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
650         &quot;#define TEXTUREFUNC texture2DRect\n&quot;
651 #endif
652         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
653         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
654         &quot;uniform mat4 u_colorMatrix;\n&quot;
655         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
656         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
657         &quot;void main() {\n&quot;
658         &quot;    vec4 yuv;\n&quot;
659         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
660         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
661         &quot;    yuv.a = 1.0;\n&quot;
662         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
663         &quot;}\n&quot;_s
664     };
665 
666     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);
667     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
668     m_context-&gt;compileShaderDirect(fragmentShader);
669 
670     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);
671     if (!status) {
672         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
673         m_context-&gt;deleteShader(vertexShader);
674         m_context-&gt;deleteShader(fragmentShader);
675         return false;
676     }
677 
678     m_yuvProgram = m_context-&gt;createProgram();
679     m_context-&gt;attachShader(m_yuvProgram, vertexShader);
680     m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
681     m_context-&gt;linkProgram(m_yuvProgram);
682 
683     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContext3D::LINK_STATUS, &amp;status);
684     if (!status) {
685         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
686         m_context-&gt;deleteShader(vertexShader);
687         m_context-&gt;deleteShader(fragmentShader);
688         m_context-&gt;deleteProgram(m_yuvProgram);
689         m_yuvProgram = 0;
690         return false;
691     }
692 
693     m_yTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTexture&quot;_s);
694     m_uvTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTexture&quot;_s);
695     m_colorMatrixUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_colorMatrix&quot;_s);
696     m_yuvFlipYUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_flipY&quot;_s);
697     m_yTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTextureSize&quot;_s);
698     m_uvTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTextureSize&quot;_s);
699     m_yuvPositionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_yuvProgram, &quot;a_position&quot;_s);
700 
701     m_context-&gt;detachShader(m_yuvProgram, vertexShader);
702     m_context-&gt;detachShader(m_yuvProgram, fragmentShader);
703     m_context-&gt;deleteShader(vertexShader);
704     m_context-&gt;deleteShader(fragmentShader);
705 
706     m_yuvVertexBuffer = m_context-&gt;createBuffer();
707     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
708 
709     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_yuvVertexBuffer);
710     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContext3D::STATIC_DRAW);
711     m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
712     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);
713 
714     return true;
715 }
716 
717 bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
718 {
719     if (!m_textureCache) {
720         m_textureCache = TextureCacheCV::create(m_context);
721         if (!m_textureCache)
722             return false;
723     }
724 
725     if (auto texture = m_textureCache-&gt;textureFromImage(image, outputTarget, level, internalFormat, format, type)) {
726         bool swapColorChannels = false;
727 #if USE(OPENGL_ES)
728         // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
729         swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
730 #endif
731         return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
732     }
733 
734 #if HAVE(IOSURFACE)
735     // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
736     OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
737     if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
738         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Asked to copy an unsupported pixel format (&#39;%s&#39;).&quot;, this, FourCC(pixelFormat).toString().utf8().data());
739         return false;
740     }
741 
742     IOSurfaceRef surface = CVPixelBufferGetIOSurface(image);
743     if (!surface)
744         return false;
745 
746     auto newSurfaceSeed = IOSurfaceGetSeed(surface);
747     if (flipY == m_lastFlipY
748         &amp;&amp; surface == m_lastSurface
749         &amp;&amp; newSurfaceSeed == m_lastSurfaceSeed
750         &amp;&amp; lastTextureSeed(outputTexture) == m_context-&gt;textureSeed(outputTexture)) {
751         // If the texture hasn&#39;t been modified since the last time we copied to it, and the
752         // image hasn&#39;t been modified since the last time it was copied, this is a no-op.
753         return true;
754     }
755 
756     if (!m_yuvProgram) {
757         if (!initializeUVContextObjects()) {
758             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
759             return false;
760         }
761     }
762 
763     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
764 
765     // Allocate memory for the output texture.
766     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);
767     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
768     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
769     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
770     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
771     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
772 
773     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
774     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
775     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
776         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
777         return false;
778     }
779 
780     m_context-&gt;useProgram(m_yuvProgram);
781     m_context-&gt;viewport(0, 0, width, height);
782 
783     // Bind and set up the textures for the video source.
784     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
785     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
786     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
787     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
788 
789 #if USE(OPENGL_ES)
790     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;
791 #else
792     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;
793 #endif
794     auto uvTexture = m_context-&gt;createTexture();
795     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);
796     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
797     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
798     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
799     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
800     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
801     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GL_RG, uvPlaneWidth, uvPlaneHeight, GL_RG, GL_UNSIGNED_BYTE, surface, 1)) {
802         m_context-&gt;deleteTexture(uvTexture);
803         return false;
804     }
805 
806     auto yTexture = m_context-&gt;createTexture();
807     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
808     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
809     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
810     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
811     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
812     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
813     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GL_LUMINANCE, yPlaneWidth, yPlaneHeight, GL_LUMINANCE, GL_UNSIGNED_BYTE, surface, 0)) {
814         m_context-&gt;deleteTexture(yTexture);
815         m_context-&gt;deleteTexture(uvTexture);
816         return false;
817     }
818 
819     // Configure the drawing parameters.
820     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
821     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
822     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
823     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
824     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
825 
826     auto range = pixelRangeFromPixelFormat(pixelFormat);
827     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
828     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
829     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
830 
831     // Do the actual drawing.
832     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
833 
834 #if USE(OPENGL_ES)
835     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
836     // two EAGL contexts.
837     m_context-&gt;flush();
838 #endif
839 
840     // Clean-up.
841     m_context-&gt;deleteTexture(yTexture);
842     m_context-&gt;deleteTexture(uvTexture);
843 
844     m_lastSurface = surface;
845     m_lastSurfaceSeed = newSurfaceSeed;
846     m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
847     m_lastFlipY = flipY;
848 
849     return true;
850 #else
851     return false;
852 #endif // HAVE(IOSURFACE)
853 }
854 
855 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
856 {
857     if (!inputVideoTexture)
858         return false;
859 
860     GLfloat lowerLeft[2] = { 0, 0 };
861     GLfloat lowerRight[2] = { 0, 0 };
862     GLfloat upperRight[2] = { 0, 0 };
863     GLfloat upperLeft[2] = { 0, 0 };
864 #if USE(OPENGL_ES)
865     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);
866     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);
867     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
868 #else
869     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);
870     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);
871     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
872 #endif
873 
874     if (lowerLeft[1] &lt; upperRight[1])
875         flipY = !flipY;
876 
877     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
878 }
879 
880 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)
881 {
882     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
883 
884     if (!m_program) {
885         if (!initializeContextObjects()) {
886             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
887             return false;
888         }
889     }
890 
891     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);
892 
893     // Allocate memory for the output texture.
894     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);
895     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
896     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
897     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
898     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
899     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);
900 
901     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);
902     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);
903     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
904         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
905         return false;
906     }
907 
908     m_context-&gt;useProgram(m_program);
909     m_context-&gt;viewport(0, 0, width, height);
910 
911     // Bind and set up the texture for the video source.
912     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);
913     m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
914     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);
915     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);
916     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);
917     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);
918 
919     // Configure the drawing parameters.
920     m_context-&gt;uniform1i(m_textureUniformLocation, 0);
921 #if USE(OPENGL_ES)
922     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
923 #else
924     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, width, height);
925 #endif
926 
927     m_context-&gt;uniform1i(m_flipYUniformLocation, flipY);
928     m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
929     m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
930 
931     // Do the actual drawing.
932     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
933     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);
934     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);
935     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);
936 
937 #if USE(OPENGL_ES)
938     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
939     // two EAGL contexts.
940     m_context-&gt;flush();
941 #endif
942 
943     // Clean-up.
944     m_context-&gt;bindTexture(videoTextureTarget, 0);
945     m_context-&gt;bindTexture(outputTarget, outputTexture);
946 
947     return true;
948 }
949 
950 }
951 
952 #endif // HAVE(CORE_VIDEO)
    </pre>
  </body>
</html>