<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;CCallHelpers.h&quot;
  29 #include &quot;CPU.h&quot;
  30 #include &quot;FPRInfo.h&quot;
  31 #include &quot;GPRInfo.h&quot;
  32 #include &quot;InitializeThreading.h&quot;
  33 #include &quot;LinkBuffer.h&quot;
  34 #include &quot;ProbeContext.h&quot;
  35 #include &quot;StackAlignment.h&quot;
  36 #include &lt;limits&gt;
  37 #include &lt;wtf/Compiler.h&gt;
  38 #include &lt;wtf/DataLog.h&gt;
  39 #include &lt;wtf/Function.h&gt;
  40 #include &lt;wtf/Lock.h&gt;
  41 #include &lt;wtf/NumberOfCores.h&gt;
  42 #include &lt;wtf/PtrTag.h&gt;
  43 #include &lt;wtf/Threading.h&gt;
  44 #include &lt;wtf/text/StringCommon.h&gt;
  45 
  46 // We don&#39;t have a NO_RETURN_DUE_TO_EXIT, nor should we. That&#39;s ridiculous.
  47 static bool hiddenTruthBecauseNoReturnIsStupid() { return true; }
  48 
  49 static void usage()
  50 {
  51     dataLog(&quot;Usage: testmasm [&lt;filter&gt;]\n&quot;);
  52     if (hiddenTruthBecauseNoReturnIsStupid())
  53         exit(1);
  54 }
  55 
  56 #if ENABLE(JIT)
  57 
  58 #if ENABLE(MASM_PROBE)
  59 namespace WTF {
  60 
  61 static void printInternal(PrintStream&amp; out, void* value)
  62 {
  63     out.printf(&quot;%p&quot;, value);
  64 }
  65 
  66 } // namespace WTF
  67 #endif // ENABLE(MASM_PROBE)
  68 
  69 namespace JSC {
  70 namespace Probe {
  71 
  72 JS_EXPORT_PRIVATE void* probeStateForContext(Probe::Context&amp;);
  73 
  74 } // namespace Probe
  75 } // namespace JSC
  76 
  77 using namespace JSC;
  78 
  79 namespace {
  80 
  81 #if ENABLE(MASM_PROBE)
  82 using CPUState = Probe::CPUState;
  83 #endif
  84 
  85 Lock crashLock;
  86 
  87 typedef WTF::Function&lt;void(CCallHelpers&amp;)&gt; Generator;
  88 
  89 template&lt;typename T&gt; T nextID(T id) { return static_cast&lt;T&gt;(id + 1); }
  90 
  91 #define TESTWORD64 0x0c0defefebeef000
  92 #define TESTWORD32 0x0beef000
  93 
  94 #define testWord32(x) (TESTWORD32 + static_cast&lt;uint32_t&gt;(x))
  95 #define testWord64(x) (TESTWORD64 + static_cast&lt;uint64_t&gt;(x))
  96 
  97 #if USE(JSVALUE64)
  98 #define testWord(x) testWord64(x)
  99 #else
 100 #define testWord(x) testWord32(x)
 101 #endif
 102 
 103 // Nothing fancy for now; we just use the existing WTF assertion machinery.
 104 #define CHECK_EQ(_actual, _expected) do {                               \
 105         if ((_actual) == (_expected))                                   \
 106             break;                                                      \
 107         crashLock.lock();                                               \
 108         dataLog(&quot;FAILED while testing &quot; #_actual &quot;: expected: &quot;, _expected, &quot;, actual: &quot;, _actual, &quot;\n&quot;); \
 109         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;CHECK_EQ(&quot;#_actual &quot;, &quot; #_expected &quot;)&quot;); \
 110         CRASH();                                                        \
 111     } while (false)
 112 
 113 #define CHECK_NOT_EQ(_actual, _expected) do {                               \
 114         if ((_actual) != (_expected))                                   \
 115             break;                                                      \
 116         crashLock.lock();                                               \
 117         dataLog(&quot;FAILED while testing &quot; #_actual &quot;: expected not: &quot;, _expected, &quot;, actual: &quot;, _actual, &quot;\n&quot;); \
 118         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;CHECK_NOT_EQ(&quot;#_actual &quot;, &quot; #_expected &quot;)&quot;); \
 119         CRASH();                                                        \
 120     } while (false)
 121 
 122 #if ENABLE(MASM_PROBE)
 123 bool isPC(MacroAssembler::RegisterID id)
 124 {
 125 #if CPU(ARM_THUMB2)
 126     return id == ARMRegisters::pc;
 127 #else
 128     UNUSED_PARAM(id);
 129     return false;
 130 #endif
 131 }
 132 
 133 bool isSP(MacroAssembler::RegisterID id)
 134 {
 135     return id == MacroAssembler::stackPointerRegister;
 136 }
 137 
 138 bool isFP(MacroAssembler::RegisterID id)
 139 {
 140     return id == MacroAssembler::framePointerRegister;
 141 }
 142 
 143 bool isSpecialGPR(MacroAssembler::RegisterID id)
 144 {
 145     if (isPC(id) || isSP(id) || isFP(id))
 146         return true;
 147 #if CPU(ARM64)
 148     if (id == ARM64Registers::x18)
 149         return true;
 150 #elif CPU(MIPS)
 151     if (id == MIPSRegisters::zero || id == MIPSRegisters::k0 || id == MIPSRegisters::k1)
 152         return true;
 153 #endif
 154     return false;
 155 }
 156 #endif // ENABLE(MASM_PROBE)
 157 
 158 MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt; compile(Generator&amp;&amp; generate)
 159 {
 160     CCallHelpers jit;
 161     generate(jit);
 162     LinkBuffer linkBuffer(jit, nullptr);
 163     return FINALIZE_CODE(linkBuffer, JSEntryPtrTag, &quot;testmasm compilation&quot;);
 164 }
 165 
 166 template&lt;typename T, typename... Arguments&gt;
 167 T invoke(const MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt;&amp; code, Arguments... arguments)
 168 {
 169     void* executableAddress = untagCFunctionPtr&lt;JSEntryPtrTag&gt;(code.code().executableAddress());
 170     T (*function)(Arguments...) = bitwise_cast&lt;T(*)(Arguments...)&gt;(executableAddress);
 171     return function(arguments...);
 172 }
 173 
 174 template&lt;typename T, typename... Arguments&gt;
 175 T compileAndRun(Generator&amp;&amp; generator, Arguments... arguments)
 176 {
 177     return invoke&lt;T&gt;(compile(WTFMove(generator)), arguments...);
 178 }
 179 
 180 void testSimple()
 181 {
 182     CHECK_EQ(compileAndRun&lt;int&gt;([] (CCallHelpers&amp; jit) {
 183         jit.emitFunctionPrologue();
 184         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
 185         jit.emitFunctionEpilogue();
 186         jit.ret();
 187     }), 42);
 188 }
 189 
 190 void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
 191 {
 192     CHECK_EQ(compileAndRun&lt;size_t&gt;([=] (CCallHelpers&amp; jit) {
 193         jit.emitFunctionPrologue();
 194         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(pointer)), GPRInfo::regT0);
 195         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(length)), GPRInfo::regT1);
 196         jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
 197         jit.emitFunctionEpilogue();
 198         jit.ret();
 199     }), pointer + offset + (static_cast&lt;size_t&gt;(1) &lt;&lt; static_cast&lt;int&gt;(scale)) * length);
 200 }
 201 
 202 // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
 203 // Nan, should either yield 0 in dest or fail.
 204 void testBranchTruncateDoubleToInt32(double val, int32_t expected)
 205 {
 206     const uint64_t valAsUInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;val);
 207 #if CPU(BIG_ENDIAN)
 208     const bool isBigEndian = true;
 209 #else
 210     const bool isBigEndian = false;
 211 #endif
 212     CHECK_EQ(compileAndRun&lt;int&gt;([&amp;] (CCallHelpers&amp; jit) {
 213         jit.emitFunctionPrologue();
 214         jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
 215         if (isBigEndian) {
 216             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 217                 MacroAssembler::stackPointerRegister);
 218             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 219                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 220         } else {
 221             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 222                 MacroAssembler::stackPointerRegister);
 223             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 224                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 225         }
 226         jit.loadDouble(MacroAssembler::stackPointerRegister, FPRInfo::fpRegT0);
 227 
 228         MacroAssembler::Jump done;
 229         done = jit.branchTruncateDoubleToInt32(FPRInfo::fpRegT0, GPRInfo::returnValueGPR, MacroAssembler::BranchIfTruncateSuccessful);
 230 
 231         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 232 
 233         done.link(&amp;jit);
 234         jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
 235         jit.emitFunctionEpilogue();
 236         jit.ret();
 237     }), expected);
 238 }
 239 
 240 
 241 static Vector&lt;double&gt; doubleOperands()
 242 {
 243     return Vector&lt;double&gt; {
 244         0,
 245         -0,
 246         1,
 247         -1,
 248         42,
 249         -42,
 250         std::numeric_limits&lt;double&gt;::max(),
 251         std::numeric_limits&lt;double&gt;::min(),
 252         std::numeric_limits&lt;double&gt;::lowest(),
 253         std::numeric_limits&lt;double&gt;::quiet_NaN(),
 254         std::numeric_limits&lt;double&gt;::infinity(),
 255         -std::numeric_limits&lt;double&gt;::infinity(),
 256     };
 257 }
 258 
 259 
 260 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 261 static Vector&lt;float&gt; floatOperands()
 262 {
 263     return Vector&lt;float&gt; {
 264         0,
 265         -0,
 266         1,
 267         -1,
 268         42,
 269         -42,
 270         std::numeric_limits&lt;float&gt;::max(),
 271         std::numeric_limits&lt;float&gt;::min(),
 272         std::numeric_limits&lt;float&gt;::lowest(),
 273         std::numeric_limits&lt;float&gt;::quiet_NaN(),
 274         std::numeric_limits&lt;float&gt;::infinity(),
 275         -std::numeric_limits&lt;float&gt;::infinity(),
 276     };
 277 }
 278 #endif
 279 
 280 static Vector&lt;int32_t&gt; int32Operands()
 281 {
 282     return Vector&lt;int32_t&gt; {
 283         0,
 284         1,
 285         -1,
 286         2,
 287         -2,
 288         42,
 289         -42,
 290         64,
 291         std::numeric_limits&lt;int32_t&gt;::max(),
 292         std::numeric_limits&lt;int32_t&gt;::min(),
 293     };
 294 }
 295 
 296 #if CPU(X86_64)
 297 static Vector&lt;int64_t&gt; int64Operands()
 298 {
 299     return Vector&lt;int64_t&gt; {
 300         0,
 301         1,
 302         -1,
 303         2,
 304         -2,
 305         42,
 306         -42,
 307         64,
 308         std::numeric_limits&lt;int32_t&gt;::max(),
 309         std::numeric_limits&lt;int32_t&gt;::min(),
 310         std::numeric_limits&lt;int64_t&gt;::max(),
 311         std::numeric_limits&lt;int64_t&gt;::min(),
 312     };
 313 }
 314 #endif
 315 
 316 #if CPU(X86_64)
 317 void testBranchTestBit32RegReg()
 318 {
 319     for (uint32_t value : int32Operands()) {
 320         auto test = compile([=] (CCallHelpers&amp; jit) {
 321             jit.emitFunctionPrologue();
 322 
 323             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 324             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 325             auto done = jit.jump();
 326             branch.link(&amp;jit);
 327             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 328             done.link(&amp;jit);
 329 
 330             jit.emitFunctionEpilogue();
 331             jit.ret();
 332         });
 333 
 334         for (uint32_t value2 : int32Operands())
 335             CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);
 336     }
 337 }
 338 
 339 void testBranchTestBit32RegImm()
 340 {
 341     for (uint32_t value : int32Operands()) {
 342         auto test = compile([=] (CCallHelpers&amp; jit) {
 343             jit.emitFunctionPrologue();
 344 
 345             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 346             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 347             auto done = jit.jump();
 348             branch.link(&amp;jit);
 349             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 350             done.link(&amp;jit);
 351 
 352             jit.emitFunctionEpilogue();
 353             jit.ret();
 354         });
 355 
 356         for (uint32_t value2 : int32Operands())
 357             CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);
 358     }
 359 }
 360 
 361 void testBranchTestBit32AddrImm()
 362 {
 363     for (uint32_t value : int32Operands()) {
 364         auto test = compile([=] (CCallHelpers&amp; jit) {
 365             jit.emitFunctionPrologue();
 366 
 367             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 368             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 369             auto done = jit.jump();
 370             branch.link(&amp;jit);
 371             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 372             done.link(&amp;jit);
 373 
 374             jit.emitFunctionEpilogue();
 375             jit.ret();
 376         });
 377 
 378         for (uint32_t value2 : int32Operands())
 379             CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);
 380     }
 381 }
 382 
 383 void testBranchTestBit64RegReg()
 384 {
 385     for (uint64_t value : int64Operands()) {
 386         auto test = compile([=] (CCallHelpers&amp; jit) {
 387             jit.emitFunctionPrologue();
 388 
 389             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 390             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 391             auto done = jit.jump();
 392             branch.link(&amp;jit);
 393             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 394             done.link(&amp;jit);
 395 
 396             jit.emitFunctionEpilogue();
 397             jit.ret();
 398         });
 399 
 400         for (uint64_t value2 : int64Operands())
 401             CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);
 402     }
 403 }
 404 
 405 void testBranchTestBit64RegImm()
 406 {
 407     for (uint64_t value : int64Operands()) {
 408         auto test = compile([=] (CCallHelpers&amp; jit) {
 409             jit.emitFunctionPrologue();
 410 
 411             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 412             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 413             auto done = jit.jump();
 414             branch.link(&amp;jit);
 415             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 416             done.link(&amp;jit);
 417 
 418             jit.emitFunctionEpilogue();
 419             jit.ret();
 420         });
 421 
 422         for (uint64_t value2 : int64Operands())
 423             CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);
 424     }
 425 }
 426 
 427 void testBranchTestBit64AddrImm()
 428 {
 429     for (uint64_t value : int64Operands()) {
 430         auto test = compile([=] (CCallHelpers&amp; jit) {
 431             jit.emitFunctionPrologue();
 432 
 433             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 434             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 435             auto done = jit.jump();
 436             branch.link(&amp;jit);
 437             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 438             done.link(&amp;jit);
 439 
 440             jit.emitFunctionEpilogue();
 441             jit.ret();
 442         });
 443 
 444         for (uint64_t value2 : int64Operands())
 445             CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);
 446     }
 447 }
 448 
 449 #endif
 450 
 451 void testCompareDouble(MacroAssembler::DoubleCondition condition)
 452 {
 453     double arg1 = 0;
 454     double arg2 = 0;
 455 
 456     auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 457         jit.emitFunctionPrologue();
 458 
 459         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 460         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 461         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 462         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 463 
 464         jit.emitFunctionEpilogue();
 465         jit.ret();
 466     });
 467 
 468     auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 469         jit.emitFunctionPrologue();
 470 
 471         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 472         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 473         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 474         auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 475         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 476         jump.link(&amp;jit);
 477 
 478         jit.emitFunctionEpilogue();
 479         jit.ret();
 480     });
 481 
 482     auto operands = doubleOperands();
 483     for (auto a : operands) {
 484         for (auto b : operands) {
 485             arg1 = a;
 486             arg2 = b;
 487             CHECK_EQ(invoke&lt;int&gt;(compareDouble), invoke&lt;int&gt;(compareDoubleGeneric));
 488         }
 489     }
 490 }
 491 
 492 void testMul32WithImmediates()
 493 {
 494     for (auto immediate : int32Operands()) {
 495         auto mul = compile([=] (CCallHelpers&amp; jit) {
 496             jit.emitFunctionPrologue();
 497 
 498             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 499 
 500             jit.emitFunctionEpilogue();
 501             jit.ret();
 502         });
 503 
 504         for (auto value : int32Operands())
 505             CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
 506     }
 507 }
 508 
 509 #if CPU(ARM64)
 510 void testMul32SignExtend()
 511 {
 512     for (auto value : int32Operands()) {
 513         auto mul = compile([=] (CCallHelpers&amp; jit) {
 514             jit.emitFunctionPrologue();
 515 
 516             jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
 517 
 518             jit.emitFunctionEpilogue();
 519             jit.ret();
 520         });
 521 
 522         for (auto value2 : int32Operands())
 523             CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));
 524     }
 525 }
 526 #endif
 527 
 528 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 529 void testCompareFloat(MacroAssembler::DoubleCondition condition)
 530 {
 531     float arg1 = 0;
 532     float arg2 = 0;
 533 
 534     auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 535         jit.emitFunctionPrologue();
 536 
 537         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 538         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 539         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 540         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 541 
 542         jit.emitFunctionEpilogue();
 543         jit.ret();
 544     });
 545 
 546     auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
 547         jit.emitFunctionPrologue();
 548 
 549         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 550         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 551         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 552         auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 553         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 554         jump.link(&amp;jit);
 555 
 556         jit.emitFunctionEpilogue();
 557         jit.ret();
 558     });
 559 
 560     auto operands = floatOperands();
 561     for (auto a : operands) {
 562         for (auto b : operands) {
 563             arg1 = a;
 564             arg2 = b;
 565             CHECK_EQ(invoke&lt;int&gt;(compareFloat), invoke&lt;int&gt;(compareFloatGeneric));
 566         }
 567     }
 568 }
 569 #endif
 570 
 571 #if ENABLE(MASM_PROBE)
 572 void testProbeReadsArgumentRegisters()
 573 {
 574     bool probeWasCalled = false;
 575     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 576         jit.emitFunctionPrologue();
 577 
 578         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 579         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 580 
 581         jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
 582         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 583         jit.move(CCallHelpers::TrustedImm32(testWord32(1)), GPRInfo::argumentGPR0);
 584         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 585 #if USE(JSVALUE64)
 586         jit.move(CCallHelpers::TrustedImm64(testWord(0)), GPRInfo::argumentGPR0);
 587         jit.move(CCallHelpers::TrustedImm64(testWord(1)), GPRInfo::argumentGPR1);
 588         jit.move(CCallHelpers::TrustedImm64(testWord(2)), GPRInfo::argumentGPR2);
 589         jit.move(CCallHelpers::TrustedImm64(testWord(3)), GPRInfo::argumentGPR3);
 590 #else
 591         jit.move(CCallHelpers::TrustedImm32(testWord(0)), GPRInfo::argumentGPR0);
 592         jit.move(CCallHelpers::TrustedImm32(testWord(1)), GPRInfo::argumentGPR1);
 593         jit.move(CCallHelpers::TrustedImm32(testWord(2)), GPRInfo::argumentGPR2);
 594         jit.move(CCallHelpers::TrustedImm32(testWord(3)), GPRInfo::argumentGPR3);
 595 #endif
 596 
 597         jit.probe([&amp;] (Probe::Context&amp; context) {
 598             auto&amp; cpu = context.cpu;
 599             probeWasCalled = true;
 600             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 601             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 602             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 603             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 604 
 605             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT0), testWord32(0));
 606             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT1), testWord32(1));
 607         });
 608 
 609         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 610         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 611 
 612         jit.emitFunctionEpilogue();
 613         jit.ret();
 614     });
 615     CHECK_EQ(probeWasCalled, true);
 616 }
 617 
 618 void testProbeWritesArgumentRegisters()
 619 {
 620     // This test relies on testProbeReadsArgumentRegisters() having already validated
 621     // that we can read from argument registers. We&#39;ll use that ability to validate
 622     // that our writes did take effect.
 623     unsigned probeCallCount = 0;
 624     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 625         jit.emitFunctionPrologue();
 626 
 627         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 628         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 629 
 630         // Pre-initialize with non-expected values.
 631 #if USE(JSVALUE64)
 632         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR0);
 633         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR1);
 634         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR2);
 635         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR3);
 636 #else
 637         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR0);
 638         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR1);
 639         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR2);
 640         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR3);
 641 #endif
 642         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 643         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 644 
 645         // Write expected values.
 646         jit.probe([&amp;] (Probe::Context&amp; context) {
 647             auto&amp; cpu = context.cpu;
 648             probeCallCount++;
 649             cpu.gpr(GPRInfo::argumentGPR0) = testWord(0);
 650             cpu.gpr(GPRInfo::argumentGPR1) = testWord(1);
 651             cpu.gpr(GPRInfo::argumentGPR2) = testWord(2);
 652             cpu.gpr(GPRInfo::argumentGPR3) = testWord(3);
 653 
 654             cpu.fpr(FPRInfo::fpRegT0) = bitwise_cast&lt;double&gt;(testWord64(0));
 655             cpu.fpr(FPRInfo::fpRegT1) = bitwise_cast&lt;double&gt;(testWord64(1));
 656         });
 657 
 658         // Validate that expected values were written.
 659         jit.probe([&amp;] (Probe::Context&amp; context) {
 660             auto&amp; cpu = context.cpu;
 661             probeCallCount++;
 662             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 663             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 664             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 665             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 666 
 667             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT0), testWord64(0));
 668             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT1), testWord64(1));
 669         });
 670 
 671         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 672         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 673 
 674         jit.emitFunctionEpilogue();
 675         jit.ret();
 676     });
 677     CHECK_EQ(probeCallCount, 2);
 678 }
 679 
 680 static NEVER_INLINE NOT_TAIL_CALLED int testFunctionToTrashGPRs(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)
 681 {
 682     if (j &gt; 0)
 683         return testFunctionToTrashGPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, g ^ a, h - b, i, j - 1);
 684     return a + 1;
 685 }
 686 static NEVER_INLINE NOT_TAIL_CALLED double testFunctionToTrashFPRs(double a, double b, double c, double d, double e, double f, double g, double h, double i, double j)
 687 {
 688     if (j &gt; 0)
 689         return testFunctionToTrashFPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, pow(g, a), h - b, i, j - 1);
 690     return a + 1;
 691 }
 692 
 693 void testProbePreservesGPRS()
 694 {
 695     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 696     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 697     // to validate that the probe preserves register values.
 698     unsigned probeCallCount = 0;
 699     CPUState originalState;
 700 
 701     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 702         jit.emitFunctionPrologue();
 703 
 704         // Write expected values into the registers (except for sp, fp, and pc).
 705         jit.probe([&amp;] (Probe::Context&amp; context) {
 706             auto&amp; cpu = context.cpu;
 707             probeCallCount++;
 708             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 709                 originalState.gpr(id) = cpu.gpr(id);
 710                 if (isSpecialGPR(id))
 711                     continue;
 712                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 713             }
 714             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 715                 originalState.fpr(id) = cpu.fpr(id);
 716                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 717             }
 718         });
 719 
 720         // Invoke the probe to call a lot of functions and trash register values.
 721         jit.probe([&amp;] (Probe::Context&amp;) {
 722             probeCallCount++;
 723             CHECK_EQ(testFunctionToTrashGPRs(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), 10);
 724             CHECK_EQ(testFunctionToTrashFPRs(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), 10);
 725         });
 726 
 727         // Validate that the registers have the expected values.
 728         jit.probe([&amp;] (Probe::Context&amp; context) {
 729             auto&amp; cpu = context.cpu;
 730             probeCallCount++;
 731             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 732                 if (isSP(id) || isFP(id)) {
 733                     CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 734                     continue;
 735                 }
 736                 if (isSpecialGPR(id))
 737                     continue;
 738                 CHECK_EQ(cpu.gpr(id), testWord(id));
 739             }
 740             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 741 #if CPU(MIPS)
 742                 if (!(id &amp; 1))
 743 #endif
 744                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), testWord64(id));
 745         });
 746 
 747         // Restore the original state.
 748         jit.probe([&amp;] (Probe::Context&amp; context) {
 749             auto&amp; cpu = context.cpu;
 750             probeCallCount++;
 751             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 752                 if (isSpecialGPR(id))
 753                     continue;
 754                 cpu.gpr(id) = originalState.gpr(id);
 755             }
 756             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 757                 cpu.fpr(id) = originalState.fpr(id);
 758         });
 759 
 760         // Validate that the original state was restored.
 761         jit.probe([&amp;] (Probe::Context&amp; context) {
 762             auto&amp; cpu = context.cpu;
 763             probeCallCount++;
 764             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 765                 if (isSpecialGPR(id))
 766                     continue;
 767                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 768             }
 769             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 770 #if CPU(MIPS)
 771                 if (!(id &amp; 1))
 772 #endif
 773                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 774         });
 775 
 776         jit.emitFunctionEpilogue();
 777         jit.ret();
 778     });
 779     CHECK_EQ(probeCallCount, 5);
 780 }
 781 
 782 void testProbeModifiesStackPointer(WTF::Function&lt;void*(Probe::Context&amp;)&gt; computeModifiedStackPointer)
 783 {
 784     unsigned probeCallCount = 0;
 785     CPUState originalState;
 786     void* originalSP { nullptr };
 787     void* modifiedSP { nullptr };
 788 #if !(CPU(MIPS))
 789     uintptr_t modifiedFlags { 0 };
 790 #endif
 791 
 792 #if CPU(X86) || CPU(X86_64)
 793     auto flagsSPR = X86Registers::eflags;
 794     uintptr_t flagsMask = 0xc5;
 795 #elif CPU(ARM_THUMB2)
 796     auto flagsSPR = ARMRegisters::apsr;
 797     uintptr_t flagsMask = 0xf8000000;
 798 #elif CPU(ARM64)
 799     auto flagsSPR = ARM64Registers::nzcv;
 800     uintptr_t flagsMask = 0xf0000000;
 801 #endif
 802 
 803     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 804         jit.emitFunctionPrologue();
 805 
 806         // Preserve original stack pointer and modify the sp, and
 807         // write expected values into other registers (except for fp, and pc).
 808         jit.probe([&amp;] (Probe::Context&amp; context) {
 809             auto&amp; cpu = context.cpu;
 810             probeCallCount++;
 811             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 812                 originalState.gpr(id) = cpu.gpr(id);
 813                 if (isSpecialGPR(id))
 814                     continue;
 815                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 816             }
 817             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 818                 originalState.fpr(id) = cpu.fpr(id);
 819                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 820             }
 821 
 822 #if !(CPU(MIPS))
 823             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
 824             modifiedFlags = originalState.spr(flagsSPR) ^ flagsMask;
 825             cpu.spr(flagsSPR) = modifiedFlags;
 826 #endif
 827 
 828             originalSP = cpu.sp();
 829             modifiedSP = computeModifiedStackPointer(context);
 830             cpu.sp() = modifiedSP;
 831         });
 832 
 833         // Validate that the registers have the expected values.
 834         jit.probe([&amp;] (Probe::Context&amp; context) {
 835             auto&amp; cpu = context.cpu;
 836             probeCallCount++;
 837             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 838                 if (isFP(id)) {
 839                     CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 840                     continue;
 841                 }
 842                 if (isSpecialGPR(id))
 843                     continue;
 844                 CHECK_EQ(cpu.gpr(id), testWord(id));
 845             }
 846             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 847 #if CPU(MIPS)
 848                 if (!(id &amp; 1))
 849 #endif
 850                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), testWord64(id));
 851 #if !(CPU(MIPS))
 852             CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, modifiedFlags &amp; flagsMask);
 853 #endif
 854             CHECK_EQ(cpu.sp(), modifiedSP);
 855         });
 856 
 857         // Restore the original state.
 858         jit.probe([&amp;] (Probe::Context&amp; context) {
 859             auto&amp; cpu = context.cpu;
 860             probeCallCount++;
 861             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 862                 if (isSpecialGPR(id))
 863                     continue;
 864                 cpu.gpr(id) = originalState.gpr(id);
 865             }
 866             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 867                 cpu.fpr(id) = originalState.fpr(id);
 868 #if !(CPU(MIPS))
 869             cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
 870 #endif
 871             cpu.sp() = originalSP;
 872         });
 873 
 874         // Validate that the original state was restored.
 875         jit.probe([&amp;] (Probe::Context&amp; context) {
 876             auto&amp; cpu = context.cpu;
 877             probeCallCount++;
 878             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 879                 if (isSpecialGPR(id))
 880                     continue;
 881                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 882             }
 883             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 884 #if CPU(MIPS)
 885                 if (!(id &amp; 1))
 886 #endif
 887                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 888 #if !(CPU(MIPS))
 889             CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, originalState.spr(flagsSPR) &amp; flagsMask);
 890 #endif
 891             CHECK_EQ(cpu.sp(), originalSP);
 892         });
 893 
 894         jit.emitFunctionEpilogue();
 895         jit.ret();
 896     });
 897     CHECK_EQ(probeCallCount, 4);
 898 }
 899 
 900 void testProbeModifiesStackPointerToInsideProbeStateOnStack()
 901 {
 902     size_t increment = sizeof(uintptr_t);
 903 #if CPU(ARM64)
 904     // The ARM64 probe uses ldp and stp which require 16 byte alignment.
 905     increment = 2 * sizeof(uintptr_t);
 906 #endif
 907     for (size_t offset = 0; offset &lt; sizeof(Probe::State); offset += increment) {
 908         testProbeModifiesStackPointer([=] (Probe::Context&amp; context) -&gt; void* {
 909             return reinterpret_cast&lt;uint8_t*&gt;(probeStateForContext(context)) + offset;
 910 
 911         });
 912     }
 913 }
 914 
 915 void testProbeModifiesStackPointerToNBytesBelowSP()
 916 {
 917     size_t increment = sizeof(uintptr_t);
 918 #if CPU(ARM64)
 919     // The ARM64 probe uses ldp and stp which require 16 byte alignment.
 920     increment = 2 * sizeof(uintptr_t);
 921 #endif
 922     for (size_t offset = 0; offset &lt; 1 * KB; offset += increment) {
 923         testProbeModifiesStackPointer([=] (Probe::Context&amp; context) -&gt; void* {
 924             return context.cpu.sp&lt;uint8_t*&gt;() - offset;
 925         });
 926     }
 927 }
 928 
 929 void testProbeModifiesProgramCounter()
 930 {
 931     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 932     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 933     // to validate that the probe preserves register values.
 934     unsigned probeCallCount = 0;
 935     bool continuationWasReached = false;
 936 
 937     MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt; continuation = compile([&amp;] (CCallHelpers&amp; jit) {
 938         // Validate that we reached the continuation.
 939         jit.probe([&amp;] (Probe::Context&amp;) {
 940             probeCallCount++;
 941             continuationWasReached = true;
 942         });
 943 
 944         jit.emitFunctionEpilogue();
 945         jit.ret();
 946     });
 947 
 948     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 949         jit.emitFunctionPrologue();
 950 
 951         // Write expected values into the registers.
 952         jit.probe([&amp;] (Probe::Context&amp; context) {
 953             probeCallCount++;
 954             context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
 955         });
 956 
 957         jit.breakpoint(); // We should never get here.
 958     });
 959     CHECK_EQ(probeCallCount, 2);
 960     CHECK_EQ(continuationWasReached, true);
 961 }
 962 
 963 void testProbeModifiesStackValues()
 964 {
 965     unsigned probeCallCount = 0;
 966     CPUState originalState;
 967     void* originalSP { nullptr };
 968     void* newSP { nullptr };
 969 #if !CPU(MIPS)
 970     uintptr_t modifiedFlags { 0 };
 971 #endif
 972     size_t numberOfExtraEntriesToWrite { 10 }; // ARM64 requires that this be 2 word aligned.
 973 
 974 #if CPU(X86) || CPU(X86_64)
 975     MacroAssembler::SPRegisterID flagsSPR = X86Registers::eflags;
 976     uintptr_t flagsMask = 0xc5;
 977 #elif CPU(ARM_THUMB2)
 978     MacroAssembler::SPRegisterID flagsSPR = ARMRegisters::apsr;
 979     uintptr_t flagsMask = 0xf8000000;
 980 #elif CPU(ARM64)
 981     MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
 982     uintptr_t flagsMask = 0xf0000000;
 983 #endif
 984 
 985     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
 986         jit.emitFunctionPrologue();
 987 
 988         // Write expected values into the registers.
 989         jit.probe([&amp;] (Probe::Context&amp; context) {
 990             auto&amp; cpu = context.cpu;
 991             auto&amp; stack = context.stack();
 992             probeCallCount++;
 993 
 994             // Preserve the original CPU state.
 995             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 996                 originalState.gpr(id) = cpu.gpr(id);
 997                 if (isSpecialGPR(id))
 998                     continue;
 999                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
1000             }
1001             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
1002                 originalState.fpr(id) = cpu.fpr(id);
1003                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
1004             }
1005 #if !(CPU(MIPS))
1006             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
1007             modifiedFlags = originalState.spr(flagsSPR) ^ flagsMask;
1008             cpu.spr(flagsSPR) = modifiedFlags;
1009 #endif
1010 
1011             // Ensure that we&#39;ll be writing over the regions of the stack where the Probe::State is.
1012             originalSP = cpu.sp();
1013             newSP = reinterpret_cast&lt;uintptr_t*&gt;(probeStateForContext(context)) - numberOfExtraEntriesToWrite;
1014             cpu.sp() = newSP;
1015 
1016             // Fill the stack with values.
1017             uintptr_t* p = reinterpret_cast&lt;uintptr_t*&gt;(newSP);
1018             int count = 0;
1019             stack.set&lt;double&gt;(p++, 1.234567);
1020             if (is32Bit())
1021                 p++; // On 32-bit targets, a double takes up 2 uintptr_t.
1022             while (p &lt; reinterpret_cast&lt;uintptr_t*&gt;(originalSP))
1023                 stack.set&lt;uintptr_t&gt;(p++, testWord(count++));
1024         });
1025 
1026         // Validate that the registers and stack have the expected values.
1027         jit.probe([&amp;] (Probe::Context&amp; context) {
1028             auto&amp; cpu = context.cpu;
1029             auto&amp; stack = context.stack();
1030             probeCallCount++;
1031 
1032             // Validate the register values.
1033             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
1034                 if (isFP(id)) {
1035                     CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
1036                     continue;
1037                 }
1038                 if (isSpecialGPR(id))
1039                     continue;
1040                 CHECK_EQ(cpu.gpr(id), testWord(id));
1041             }
1042             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
1043 #if CPU(MIPS)
1044                 if (!(id &amp; 1))
1045 #endif
1046                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), testWord64(id));
1047 #if !(CPU(MIPS))
1048             CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, modifiedFlags &amp; flagsMask);
1049 #endif
1050             CHECK_EQ(cpu.sp(), newSP);
1051 
1052             // Validate the stack values.
1053             uintptr_t* p = reinterpret_cast&lt;uintptr_t*&gt;(newSP);
1054             int count = 0;
1055             CHECK_EQ(stack.get&lt;double&gt;(p++), 1.234567);
1056             if (is32Bit())
1057                 p++; // On 32-bit targets, a double takes up 2 uintptr_t.
1058             while (p &lt; reinterpret_cast&lt;uintptr_t*&gt;(originalSP))
1059                 CHECK_EQ(stack.get&lt;uintptr_t&gt;(p++), testWord(count++));
1060         });
1061 
1062         // Restore the original state.
1063         jit.probe([&amp;] (Probe::Context&amp; context) {
1064             auto&amp; cpu = context.cpu;
1065             probeCallCount++;
1066             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
1067                 if (isSpecialGPR(id))
1068                     continue;
1069                 cpu.gpr(id) = originalState.gpr(id);
1070             }
1071             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
1072                 cpu.fpr(id) = originalState.fpr(id);
1073 #if !(CPU(MIPS))
1074             cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
1075 #endif
1076             cpu.sp() = originalSP;
1077         });
1078 
1079         jit.emitFunctionEpilogue();
1080         jit.ret();
1081     });
1082 
1083     CHECK_EQ(probeCallCount, 3);
1084 }
1085 #endif // ENABLE(MASM_PROBE)
1086 
1087 void testByteSwap()
1088 {
1089 #if CPU(X86_64) || CPU(ARM64)
1090     auto byteSwap16 = compile([] (CCallHelpers&amp; jit) {
1091         jit.emitFunctionPrologue();
1092         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1093         jit.byteSwap16(GPRInfo::returnValueGPR);
1094         jit.emitFunctionEpilogue();
1095         jit.ret();
1096     });
1097     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x2211));
1098     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff));
1099 
1100     auto byteSwap32 = compile([] (CCallHelpers&amp; jit) {
1101         jit.emitFunctionPrologue();
1102         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1103         jit.byteSwap32(GPRInfo::returnValueGPR);
1104         jit.emitFunctionEpilogue();
1105         jit.ret();
1106     });
1107     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
1108     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
1109 
1110     auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
1111         jit.emitFunctionPrologue();
1112         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1113         jit.byteSwap64(GPRInfo::returnValueGPR);
1114         jit.emitFunctionEpilogue();
1115         jit.ret();
1116     });
1117     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
1118     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
1119 #endif
1120 }
1121 
1122 void testMoveDoubleConditionally32()
1123 {
1124 #if CPU(X86_64) | CPU(ARM64)
1125     double arg1 = 0;
1126     double arg2 = 0;
1127     const double zero = -0;
1128 
1129     const double chosenDouble = 6.00000059604644775390625;
1130     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1131 
1132     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
1133         jit.emitFunctionPrologue();
1134         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1135         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1136         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1137 
1138         jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
1139         jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1140 
1141         jit.emitFunctionEpilogue();
1142         jit.ret();
1143     });
1144 
1145     arg1 = chosenDouble;
1146     arg2 = 43;
1147     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1148 
1149     arg1 = 43;
1150     arg2 = chosenDouble;
1151     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1152 
1153 #endif
1154 }
1155 
1156 void testMoveDoubleConditionally64()
1157 {
1158 #if CPU(X86_64) | CPU(ARM64)
1159     double arg1 = 0;
1160     double arg2 = 0;
1161     const double zero = -0;
1162 
1163     const double chosenDouble = 6.00000059604644775390625;
1164     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1165 
1166     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
1167         jit.emitFunctionPrologue();
1168         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1169         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1170         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1171 
1172         jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
1173         jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1174 
1175         jit.emitFunctionEpilogue();
1176         jit.ret();
1177     });
1178 
1179     arg1 = chosenDouble;
1180     arg2 = 43;
1181     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1182 
1183     arg1 = 43;
1184     arg2 = chosenDouble;
1185     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1186 
1187 #endif
1188 }
1189 
1190 static void testCagePreservesPACFailureBit()
1191 {
1192 #if GIGACAGE_ENABLED
1193     ASSERT(!Gigacage::isDisablingPrimitiveGigacageDisabled());
1194     auto cage = compile([] (CCallHelpers&amp; jit) {
1195         jit.emitFunctionPrologue();
1196         jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
1197         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1198         jit.emitFunctionEpilogue();
1199         jit.ret();
1200     });
1201 
1202     void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
1203     void* taggedPtr = tagArrayPtr(ptr, 1);
1204     ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
1205     void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
1206     CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
1207     void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
1208 
1209     if (isARM64E()) {
1210         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1211         CHECK_NOT_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1212         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedNotCagedPtr, 1), untagArrayPtr(taggedPtr, 2));
1213     } else
1214         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1215 
1216     CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);
1217 
1218     auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {
1219         jit.emitFunctionPrologue();
1220         jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
1221         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1222         jit.emitFunctionEpilogue();
1223         jit.ret();
1224     });
1225 
1226     CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);
1227     if (isARM64E()) {
1228         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1229         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedNotCagedPtr);
1230         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), notCagedPtr);
1231         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedPtr);
1232         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), ptr);
1233     }
1234 
1235     Gigacage::free(Gigacage::Primitive, ptr);
1236 #endif
1237 }
1238 
1239 #define RUN(test) do {                          \
1240         if (!shouldRun(#test))                  \
1241             break;                              \
1242         numberOfTests++;                        \
1243         tasks.append(                           \
1244             createSharedTask&lt;void()&gt;(           \
1245                 [&amp;] () {                        \
1246                     dataLog(#test &quot;...\n&quot;);     \
1247                     test;                       \
1248                     dataLog(#test &quot;: OK!\n&quot;);   \
1249                 }));                            \
1250     } while (false);
1251 
1252 void run(const char* filter)
1253 {
1254     JSC::initializeThreading();
1255     unsigned numberOfTests = 0;
1256 
1257     Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt; tasks;
1258 
1259     auto shouldRun = [&amp;] (const char* testName) -&gt; bool {
1260         return !filter || WTF::findIgnoringASCIICaseWithoutLength(testName, filter) != WTF::notFound;
1261     };
1262 
1263     RUN(testSimple());
1264     RUN(testGetEffectiveAddress(0xff00, 42, 8, CCallHelpers::TimesEight));
1265     RUN(testGetEffectiveAddress(0xff00, -200, -300, CCallHelpers::TimesEight));
1266     RUN(testBranchTruncateDoubleToInt32(0, 0));
1267     RUN(testBranchTruncateDoubleToInt32(42, 42));
1268     RUN(testBranchTruncateDoubleToInt32(42.7, 42));
1269     RUN(testBranchTruncateDoubleToInt32(-1234, -1234));
1270     RUN(testBranchTruncateDoubleToInt32(-1234.56, -1234));
1271     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::infinity(), 0));
1272     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::infinity(), 0));
1273     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::quiet_NaN(), 0));
1274     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::signaling_NaN(), 0));
1275     RUN(testBranchTruncateDoubleToInt32(std::numeric_limits&lt;double&gt;::max(), 0));
1276     RUN(testBranchTruncateDoubleToInt32(-std::numeric_limits&lt;double&gt;::max(), 0));
1277     // We run this last one to make sure that we don&#39;t use flags that were not
1278     // reset to check a conversion result
1279     RUN(testBranchTruncateDoubleToInt32(123, 123));
1280 
1281     RUN(testCompareDouble(MacroAssembler::DoubleEqual));
1282     RUN(testCompareDouble(MacroAssembler::DoubleNotEqual));
1283     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThan));
1284     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqual));
1285     RUN(testCompareDouble(MacroAssembler::DoubleLessThan));
1286     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqual));
1287     RUN(testCompareDouble(MacroAssembler::DoubleEqualOrUnordered));
1288     RUN(testCompareDouble(MacroAssembler::DoubleNotEqualOrUnordered));
1289     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrUnordered));
1290     RUN(testCompareDouble(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
1291     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrUnordered));
1292     RUN(testCompareDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1293     RUN(testMul32WithImmediates());
1294 
1295 #if CPU(X86_64)
1296     RUN(testBranchTestBit32RegReg());
1297     RUN(testBranchTestBit32RegImm());
1298     RUN(testBranchTestBit32AddrImm());
1299     RUN(testBranchTestBit64RegReg());
1300     RUN(testBranchTestBit64RegImm());
1301     RUN(testBranchTestBit64AddrImm());
1302 #endif
1303 
1304 #if CPU(ARM64)
1305     RUN(testMul32SignExtend());
1306 #endif
1307 
1308 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
1309     RUN(testCompareFloat(MacroAssembler::DoubleEqual));
1310     RUN(testCompareFloat(MacroAssembler::DoubleNotEqual));
1311     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThan));
1312     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqual));
1313     RUN(testCompareFloat(MacroAssembler::DoubleLessThan));
1314     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqual));
1315     RUN(testCompareFloat(MacroAssembler::DoubleEqualOrUnordered));
1316     RUN(testCompareFloat(MacroAssembler::DoubleNotEqualOrUnordered));
1317     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrUnordered));
1318     RUN(testCompareFloat(MacroAssembler::DoubleGreaterThanOrEqualOrUnordered));
1319     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrUnordered));
1320     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1321 #endif
1322 
1323 #if ENABLE(MASM_PROBE)
1324     RUN(testProbeReadsArgumentRegisters());
1325     RUN(testProbeWritesArgumentRegisters());
1326     RUN(testProbePreservesGPRS());
1327     RUN(testProbeModifiesStackPointerToInsideProbeStateOnStack());
1328     RUN(testProbeModifiesStackPointerToNBytesBelowSP());
1329     RUN(testProbeModifiesProgramCounter());
1330     RUN(testProbeModifiesStackValues());
1331 #endif // ENABLE(MASM_PROBE)
1332 
1333     RUN(testByteSwap());
1334     RUN(testMoveDoubleConditionally32());
1335     RUN(testMoveDoubleConditionally64());
1336 
1337     RUN(testCagePreservesPACFailureBit());
1338 
1339     if (tasks.isEmpty())
1340         usage();
1341 
1342     Lock lock;
1343 
1344     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
1345     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
1346         threads.append(
1347             Thread::create(
1348                 &quot;testmasm thread&quot;,
1349                 [&amp;] () {
1350                     for (;;) {
1351                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
1352                         {
1353                             LockHolder locker(lock);
1354                             if (tasks.isEmpty())
1355                                 return;
1356                             task = tasks.takeFirst();
1357                         }
1358 
1359                         task-&gt;run();
1360                     }
1361                 }));
1362     }
1363 
1364     for (auto&amp; thread : threads)
1365         thread-&gt;waitForCompletion();
1366     crashLock.lock();
1367     dataLog(&quot;Completed &quot;, numberOfTests, &quot; tests\n&quot;);
1368 }
1369 
1370 } // anonymous namespace
1371 
1372 #else // not ENABLE(JIT)
1373 
1374 static void run(const char*)
1375 {
1376     dataLog(&quot;JIT is not enabled.\n&quot;);
1377 }
1378 
1379 #endif // ENABLE(JIT)
1380 
1381 int main(int argc, char** argv)
1382 {
1383     const char* filter = nullptr;
1384     switch (argc) {
1385     case 1:
1386         break;
1387     case 2:
1388         filter = argv[1];
1389         break;
1390     default:
1391         usage();
1392         break;
1393     }
1394 
1395     run(filter);
1396     return 0;
1397 }
1398 
1399 #if OS(WINDOWS)
1400 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
1401 {
1402     return main(argc, const_cast&lt;char**&gt;(argv));
1403 }
1404 #endif
    </pre>
  </body>
</html>