<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../offlineasm/x86.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2010, 2013, 2016 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  61 
  62     struct AssignmentInfo {
  63         AssignmentInfo() {}
  64         AssignmentInfo(ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int initAssignments, Operator op)
  65             : m_node(node)
  66             , m_start(start)
  67             , m_divot(divot)
  68             , m_initAssignments(initAssignments)
  69             , m_op(op)
  70         {
  71             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
  72             ASSERT(m_start.offset &gt;= m_start.lineStartOffset);
  73         }
  74         ExpressionNode* m_node;
  75         JSTextPosition m_start;
  76         JSTextPosition m_divot;
  77         int m_initAssignments;
  78         Operator m_op;
  79     };
  80 public:
<span class="line-modified">  81     ASTBuilder(VM* vm, ParserArena&amp; parserArena, SourceCode* sourceCode)</span>
  82         : m_vm(vm)
  83         , m_parserArena(parserArena)
  84         , m_sourceCode(sourceCode)
  85         , m_evalCount(0)
  86     {
  87     }
  88 
  89     struct BinaryExprContext {
  90         BinaryExprContext(ASTBuilder&amp;) {}
  91     };
  92     struct UnaryExprContext {
  93         UnaryExprContext(ASTBuilder&amp;) {}
  94     };
  95 
  96     typedef ExpressionNode* Expression;
  97     typedef JSC::SourceElements* SourceElements;
  98     typedef ArgumentsNode* Arguments;
  99     typedef CommaNode* Comma;
 100     typedef PropertyNode* Property;
 101     typedef PropertyListNode* PropertyList;
</pre>
<hr />
<pre>
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
 125     static const bool CreatesAST = true;
 126     static const bool NeedsFreeVariableInfo = true;
 127     static const bool CanUseFunctionCache = true;
 128     static const int  DontBuildKeywords = 0;
 129     static const int  DontBuildStrings = 0;
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
<span class="line-modified"> 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth);</span>
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 150     ExpressionNode* makeAddNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 151     ExpressionNode* makeSubNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 152     ExpressionNode* makeBitXOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 153     ExpressionNode* makeBitAndNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 154     ExpressionNode* makeBitOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);

 155     ExpressionNode* makeLeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 156     ExpressionNode* makeRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 157     ExpressionNode* makeURightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 158 
 159     ExpressionNode* createLogicalNot(const JSTokenLocation&amp; location, ExpressionNode* expr)
 160     {
 161         if (expr-&gt;isNumber())
 162             return createBoolean(location, isZeroOrUnordered(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
 163 
 164         return new (m_parserArena) LogicalNotNode(location, expr);
 165     }
 166     ExpressionNode* createUnaryPlus(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) UnaryPlusNode(location, expr); }
 167     ExpressionNode* createVoid(const JSTokenLocation&amp; location, ExpressionNode* expr)
 168     {
 169         incConstants();
 170         return new (m_parserArena) VoidNode(location, expr);
 171     }
 172     ExpressionNode* createThisExpr(const JSTokenLocation&amp; location)
 173     {
 174         usesThis();
</pre>
<hr />
<pre>
 178     {
 179         return new (m_parserArena) SuperNode(location);
 180     }
 181     ExpressionNode* createImportExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 182     {
 183         auto* node = new (m_parserArena) ImportNode(location, expr);
 184         setExceptionLocation(node, start, divot, end);
 185         return node;
 186     }
 187     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 188     {
 189         usesNewTarget();
 190         return new (m_parserArena) NewTargetNode(location);
 191     }
 192     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 193     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 194     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 195     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 196     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 197     {
<span class="line-modified"> 198         if (m_vm-&gt;propertyNames-&gt;arguments == ident)</span>
 199             usesArguments();
 200 
 201         if (ident.isSymbol()) {
<span class="line-modified"> 202             if (BytecodeIntrinsicNode::EmitterType emitter = m_vm-&gt;bytecodeIntrinsicRegistry().lookup(ident))</span>
 203                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);
 204         }
 205 
 206         return new (m_parserArena) ResolveNode(location, ident, start);
 207     }
 208     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 209     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 210 
 211     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 212     {
 213         if (elisions)
 214             incConstants();
 215         return new (m_parserArena) ArrayNode(location, elisions);
 216     }
 217 
 218     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 219     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 220     {
 221         if (elisions)
 222             incConstants();
</pre>
<hr />
<pre>
 314 
 315     TemplateExpressionListNode* createTemplateExpressionList(TemplateExpressionListNode* templateExpressionListNode, ExpressionNode* expression)
 316     {
 317         return new (m_parserArena) TemplateExpressionListNode(templateExpressionListNode, expression);
 318     }
 319 
 320     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList)
 321     {
 322         return new (m_parserArena) TemplateLiteralNode(location, templateStringList);
 323     }
 324 
 325     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList, TemplateExpressionListNode* templateExpressionList)
 326     {
 327         return new (m_parserArena) TemplateLiteralNode(location, templateStringList, templateExpressionList);
 328     }
 329 
 330     ExpressionNode* createTaggedTemplate(const JSTokenLocation&amp; location, ExpressionNode* base, TemplateLiteralNode* templateLiteral, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 331     {
 332         auto node = new (m_parserArena) TaggedTemplateNode(location, base, templateLiteral);
 333         setExceptionLocation(node, start, divot, end);

 334         return node;
 335     }
 336 
 337     ExpressionNode* createRegExp(const JSTokenLocation&amp; location, const Identifier&amp; pattern, const Identifier&amp; flags, const JSTextPosition&amp; start)
 338     {
 339         if (Yarr::hasError(Yarr::checkSyntax(pattern.string(), flags.string())))
 340             return 0;
 341         RegExpNode* node = new (m_parserArena) RegExpNode(location, pattern, flags);
 342         int size = pattern.length() + 2; // + 2 for the two /&#39;s
 343         JSTextPosition end = start + size;
 344         setExceptionLocation(node, start, end, end);
 345         return node;
 346     }
 347 
 348     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, ArgumentsNode* arguments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 349     {
 350         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr, arguments);
 351         setExceptionLocation(node, start, divot, end);
 352         return node;
 353     }
 354 
 355     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 356     {
 357         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr);
 358         setExceptionLocation(node, start, end, end);
 359         return node;
 360     }
 361 






 362     ExpressionNode* createConditionalExpr(const JSTokenLocation&amp; location, ExpressionNode* condition, ExpressionNode* lhs, ExpressionNode* rhs)
 363     {
 364         return new (m_parserArena) ConditionalNode(location, condition, lhs, rhs);
 365     }
 366 
 367     ExpressionNode* createAssignResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, ExpressionNode* rhs, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end, AssignmentContext assignmentContext)
 368     {
 369         if (rhs-&gt;isBaseFuncExprNode()) {
 370             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(rhs)-&gt;metadata();
 371             metadata-&gt;setEcmaName(ident);
<span class="line-removed"> 372             metadata-&gt;setInferredName(ident);</span>
 373         } else if (rhs-&gt;isClassExprNode())
 374             static_cast&lt;ClassExprNode*&gt;(rhs)-&gt;setEcmaName(ident);
 375         AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, ident, rhs, assignmentContext);
 376         setExceptionLocation(node, start, divot, end);
 377         return node;
 378     }
 379 
 380     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 381     {
 382         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 383     }
 384 
 385     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 386     {
 387         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 388         setExceptionLocation(node, start, divot, end);
 389         return node;
 390     }
 391 
 392     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
</pre>
<hr />
<pre>
 399 
 400     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 401         ExpressionNode* parentClass, PropertyListNode* classElements)
 402     {
 403         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 404         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 405     }
 406 
 407     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 408     {
 409         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 410             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 411         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 412         return result;
 413     }
 414 
 415     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 416     {
 417         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 418         if (!name.isNull())
<span class="line-modified"> 419             result-&gt;metadata()-&gt;setInferredName(name);</span>
 420         return result;
 421     }
 422 
 423     ExpressionNode* createAsyncFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, SourceParseMode parseMode)
 424     {
 425         if (parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 426             SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 427             FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 428             functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 429             return result;
 430         }
 431         return createFunctionExpr(location, functionInfo);
 432     }
 433 
 434     ExpressionNode* createMethodDefinition(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 435     {
 436         MethodDefinitionNode* result = new (m_parserArena) MethodDefinitionNode(location, *functionInfo.name, functionInfo.body,
 437             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 438         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 439         return result;
</pre>
<hr />
<pre>
 457     ExpressionNode* createArrowFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 458     {
 459         usesArrowFunction();
 460         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 461         ArrowFuncExprNode* result = new (m_parserArena) ArrowFuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 462         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 463         return result;
 464     }
 465 
 466     ArgumentsNode* createArguments() { return new (m_parserArena) ArgumentsNode(); }
 467     ArgumentsNode* createArguments(ArgumentListNode* args) { return new (m_parserArena) ArgumentsNode(args); }
 468     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, arg); }
 469     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ArgumentListNode* args, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, args, arg); }
 470 
 471     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 472         const Identifier* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 473     {
 474         ASSERT(name);
 475         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 476         functionInfo.body-&gt;setEcmaName(*name);
<span class="line-removed"> 477         functionInfo.body-&gt;setInferredName(*name);</span>
 478         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 479         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 480         return new (m_parserArena) PropertyNode(*name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 481     }
 482 
 483     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 484         ExpressionNode* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 485     {
 486         ASSERT(name);
 487         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 488         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 489         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 490         return new (m_parserArena) PropertyNode(name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 491     }
 492 
<span class="line-modified"> 493     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(VM* vm, ParserArena&amp; parserArena, const JSTokenLocation&amp; location, PropertyNode::Type type, bool,</span>
 494         double name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 495     {
 496         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 497         const Identifier&amp; ident = parserArena.identifierArena().makeNumericIdentifier(vm, name);
 498         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 499         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, vm-&gt;propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 500         return new (m_parserArena) PropertyNode(ident, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 501     }
 502 
 503     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 504     {
 505         if (inferName == InferName::Allowed) {
 506             if (node-&gt;isBaseFuncExprNode()) {
 507                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 508                 metadata-&gt;setEcmaName(*propertyName);
<span class="line-removed"> 509                 metadata-&gt;setInferredName(*propertyName);</span>
 510             } else if (node-&gt;isClassExprNode())
 511                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 512         }
 513         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 514     }
 515     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 516     {
 517         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 518     }
<span class="line-modified"> 519     PropertyNode* createProperty(VM* vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)</span>
 520     {
 521         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 522     }
 523     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
 524     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 525     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 526 
 527     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 528     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 529     ElementNode* createElementList(ArgumentListNode* elems)
 530     {
 531         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 532         ElementNode* tail = head;
 533         elems = elems-&gt;m_next;
 534         while (elems) {
 535             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 536             elems = elems-&gt;m_next;
 537         }
 538         return head;
 539     }
 540 
 541     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 542     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 543     {
 544         list-&gt;append(pattern, defaultValue);
 545         tryInferNameInPattern(pattern, defaultValue);
 546     }
 547 
 548     CaseClauseNode* createClause(ExpressionNode* expr, JSC::SourceElements* statements) { return new (m_parserArena) CaseClauseNode(expr, statements); }
 549     ClauseListNode* createClauseList(CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(clause); }
 550     ClauseListNode* createClauseList(ClauseListNode* tail, CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(tail, clause); }
 551 
 552     StatementNode* createFuncDeclStatement(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 553     {
 554         FuncDeclNode* decl = new (m_parserArena) FuncDeclNode(location, *functionInfo.name, functionInfo.body,
 555             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
<span class="line-modified"> 556         if (*functionInfo.name == m_vm-&gt;propertyNames-&gt;arguments)</span>
 557             usesArguments();
 558         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 559         return decl;
 560     }
 561 
 562     StatementNode* createClassDeclStatement(const JSTokenLocation&amp; location, ClassExprNode* classExpression,
 563         const JSTextPosition&amp; classStart, const JSTextPosition&amp; classEnd, unsigned startLine, unsigned endLine)
 564     {
 565         ExpressionNode* assign = createAssignResolve(location, classExpression-&gt;name(), classExpression, classStart, classStart + 1, classEnd, AssignmentContext::DeclarationStatement);
 566         ClassDeclNode* decl = new (m_parserArena) ClassDeclNode(location, assign);
 567         decl-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 568         return decl;
 569     }
 570 
 571     StatementNode* createBlockStatement(const JSTokenLocation&amp; location, JSC::SourceElements* elements, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 572     {
 573         BlockNode* block = new (m_parserArena) BlockNode(location, elements, lexicalVariables, WTFMove(functionStack));
 574         block-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 575         return block;
 576     }
</pre>
<hr />
<pre>
 612 
 613     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 614     {
 615         ForOfNode* result = new (m_parserArena) ForOfNode(isForAwait, location, lhs, iter, statements, lexicalVariables);
 616         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 617         setExceptionLocation(result, eStart, eDivot, eEnd);
 618         return result;
 619     }
 620 
 621     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 622     {
 623         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 624         return createForOfLoop(isForAwait, location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 625     }
 626 
 627     bool isBindingNode(const DestructuringPattern&amp; pattern)
 628     {
 629         return pattern-&gt;isBindingNode();
 630     }
 631 
<span class="line-modified"> 632     bool isAssignmentLocation(const Expression&amp; pattern)</span>
 633     {
<span class="line-modified"> 634         return pattern-&gt;isAssignmentLocation();</span>





 635     }
 636 
 637     bool isObjectLiteral(const Expression&amp; node)
 638     {
 639         return node-&gt;isObjectLiteral();
 640     }
 641 
 642     bool isArrayLiteral(const Expression&amp; node)
 643     {
 644         return node-&gt;isArrayLiteral();
 645     }
 646 
 647     bool isObjectOrArrayLiteral(const Expression&amp; node)
 648     {
 649         return isObjectLiteral(node) || isArrayLiteral(node);
 650     }
 651 





 652     bool shouldSkipPauseLocation(StatementNode* statement) const
 653     {
 654         return !statement || statement-&gt;isLabel();
 655     }
 656 
 657     StatementNode* createEmptyStatement(const JSTokenLocation&amp; location) { return new (m_parserArena) EmptyStatementNode(location); }
 658 
 659     StatementNode* createDeclarationStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, int start, int end)
 660     {
 661         StatementNode* result;
 662         result = new (m_parserArena) DeclarationStatement(location, expr);
 663         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 664         return result;
 665     }
 666 
 667     ExpressionNode* createEmptyVarExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 668     {
 669         return new (m_parserArena) EmptyVarExpression(location, identifier);
 670     }
 671 
</pre>
<hr />
<pre>
1097         if (!defaultValue)
1098             return;
1099 
1100         if (pattern-&gt;isBindingNode()) {
1101             const Identifier&amp; ident = static_cast&lt;BindingNode*&gt;(pattern)-&gt;boundProperty();
1102             tryInferNameInPatternWithIdentifier(ident, defaultValue);
1103         } else if (pattern-&gt;isAssignmentElementNode()) {
1104             const ExpressionNode* assignmentTarget = static_cast&lt;AssignmentElementNode*&gt;(pattern)-&gt;assignmentTarget();
1105             if (assignmentTarget-&gt;isResolveNode()) {
1106                 const Identifier&amp; ident = static_cast&lt;const ResolveNode*&gt;(assignmentTarget)-&gt;identifier();
1107                 tryInferNameInPatternWithIdentifier(ident, defaultValue);
1108             }
1109         }
1110     }
1111 
1112     void tryInferNameInPatternWithIdentifier(const Identifier&amp; ident, ExpressionNode* defaultValue)
1113     {
1114         if (defaultValue-&gt;isBaseFuncExprNode()) {
1115             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(defaultValue)-&gt;metadata();
1116             metadata-&gt;setEcmaName(ident);
<span class="line-removed">1117             metadata-&gt;setInferredName(ident);</span>
1118         } else if (defaultValue-&gt;isClassExprNode())
1119             static_cast&lt;ClassExprNode*&gt;(defaultValue)-&gt;setEcmaName(ident);
1120     }
1121 
<span class="line-modified">1122     VM* m_vm;</span>
1123     ParserArena&amp; m_parserArena;
1124     SourceCode* m_sourceCode;
1125     Scope m_scope;
1126     Vector&lt;BinaryOperand, 10, UnsafeVectorOverflow&gt; m_binaryOperandStack;
1127     Vector&lt;AssignmentInfo, 10, UnsafeVectorOverflow&gt; m_assignmentInfoStack;
1128     Vector&lt;std::pair&lt;int, int&gt;, 10, UnsafeVectorOverflow&gt; m_binaryOperatorStack;
1129     Vector&lt;std::pair&lt;int, JSTextPosition&gt;, 10, UnsafeVectorOverflow&gt; m_unaryTokenStack;
1130     int m_evalCount;
1131 };
1132 
1133 ExpressionNode* ASTBuilder::makeTypeOfNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1134 {
1135     if (expr-&gt;isResolveNode()) {
1136         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1137         return new (m_parserArena) TypeOfResolveNode(location, resolve-&gt;identifier());
1138     }
1139     return new (m_parserArena) TypeOfValueNode(location, expr);
1140 }
1141 
1142 ExpressionNode* ASTBuilder::makeDeleteNode(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1143 {









1144     if (!expr-&gt;isLocation())
1145         return new (m_parserArena) DeleteValueNode(location, expr);
1146     if (expr-&gt;isResolveNode()) {
1147         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1148         return new (m_parserArena) DeleteResolveNode(location, resolve-&gt;identifier(), divot, start, end);
1149     }
1150     if (expr-&gt;isBracketAccessorNode()) {
1151         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(expr);
1152         return new (m_parserArena) DeleteBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), divot, start, end);
1153     }
1154     ASSERT(expr-&gt;isDotAccessorNode());
1155     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expr);
1156     return new (m_parserArena) DeleteDotNode(location, dot-&gt;base(), dot-&gt;identifier(), divot, start, end);
1157 }
1158 
1159 ExpressionNode* ASTBuilder::makeNegateNode(const JSTokenLocation&amp; location, ExpressionNode* n)
1160 {
1161     if (n-&gt;isNumber()) {
1162         const NumberNode&amp; numberNode = static_cast&lt;const NumberNode&amp;&gt;(*n);
1163         return createNumberFromUnaryOperation(location, -numberNode.value(), numberNode);
</pre>
<hr />
<pre>
1321 ExpressionNode* ASTBuilder::makeBitAndNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1322 {
1323     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1324         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1325         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1326         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &amp; toInt32(numberExpr2.value()));
1327     }
1328     return new (m_parserArena) BitAndNode(location, expr1, expr2, rightHasAssignments);
1329 }
1330 
1331 ExpressionNode* ASTBuilder::makeBitXOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1332 {
1333     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1334         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1335         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1336         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) ^ toInt32(numberExpr2.value()));
1337     }
1338     return new (m_parserArena) BitXOrNode(location, expr1, expr2, rightHasAssignments);
1339 }
1340 
<span class="line-modified">1341 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth)</span>














1342 {
1343     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1344     if (func-&gt;isSuperNode())
1345         usesSuperCall();
1346 
1347     if (func-&gt;isBytecodeIntrinsicNode()) {

1348         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
1349         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant)
1350             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;emitter(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);
1351     }













1352     if (!func-&gt;isLocation())
1353         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1354     if (func-&gt;isResolveNode()) {
1355         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1356         const Identifier&amp; identifier = resolve-&gt;identifier();
<span class="line-modified">1357         if (identifier == m_vm-&gt;propertyNames-&gt;eval) {</span>
1358             usesEval();
1359             return new (m_parserArena) EvalFunctionCallNode(location, args, divot, divotStart, divotEnd);
1360         }
1361         return new (m_parserArena) FunctionCallResolveNode(location, identifier, args, divot, divotStart, divotEnd);
1362     }
1363     if (func-&gt;isBracketAccessorNode()) {
1364         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(func);
1365         FunctionCallBracketNode* node = new (m_parserArena) FunctionCallBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), bracket-&gt;subscriptHasAssignments(), args, divot, divotStart, divotEnd);
1366         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1367         return node;
1368     }
1369     ASSERT(func-&gt;isDotAccessorNode());
1370     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(func);
1371     FunctionCallDotNode* node = nullptr;
<span class="line-modified">1372     if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().callPrivateName()))</span>
1373         node = new (m_parserArena) CallFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
<span class="line-modified">1374     else if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().applyPublicName() || dot-&gt;identifier() == m_vm-&gt;propertyNames-&gt;builtinNames().applyPrivateName())) {</span>
1375         // FIXME: This check is only needed because we haven&#39;t taught the bytecode generator to inline
1376         // Reflect.apply yet. See https://bugs.webkit.org/show_bug.cgi?id=190668.
1377         if (!dot-&gt;base()-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(dot-&gt;base())-&gt;identifier() != &quot;Reflect&quot;)
1378             node = new (m_parserArena) ApplyFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1379     }
1380     if (!node)
1381         node = new (m_parserArena) FunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd);
1382     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1383     return node;
1384 }
1385 
1386 ExpressionNode* ASTBuilder::makeBinaryNode(const JSTokenLocation&amp; location, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; lhs, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; rhs)
1387 {
1388     switch (token) {



1389     case OR:
1390         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalOr);
1391 
1392     case AND:
1393         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalAnd);
1394 
1395     case BITOR:
1396         return makeBitOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1397 
1398     case BITXOR:
1399         return makeBitXOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1400 
1401     case BITAND:
1402         return makeBitAndNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1403 
1404     case EQEQ:
1405         return new (m_parserArena) EqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1406 
1407     case NE:
1408         return new (m_parserArena) NotEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
</pre>
<hr />
<pre>
1453         return makeSubNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1454 
1455     case TIMES:
1456         return makeMultNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1457 
1458     case DIVIDE:
1459         return makeDivNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1460 
1461     case MOD:
1462         return makeModNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1463 
1464     case POW:
1465         return makePowNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1466     }
1467     CRASH();
1468     return 0;
1469 }
1470 
1471 ExpressionNode* ASTBuilder::makeAssignNode(const JSTokenLocation&amp; location, ExpressionNode* loc, Operator op, ExpressionNode* expr, bool locHasAssignments, bool exprHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1472 {
<span class="line-modified">1473     if (!loc-&gt;isLocation())</span>

1474         return new (m_parserArena) AssignErrorNode(location, divot, start, end);

1475 
1476     if (loc-&gt;isResolveNode()) {
1477         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(loc);
1478         if (op == OpEqual) {
1479             if (expr-&gt;isBaseFuncExprNode()) {
1480                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata();
1481                 metadata-&gt;setEcmaName(resolve-&gt;identifier());
<span class="line-removed">1482                 metadata-&gt;setInferredName(resolve-&gt;identifier());</span>
1483             } else if (expr-&gt;isClassExprNode())
1484                 static_cast&lt;ClassExprNode*&gt;(expr)-&gt;setEcmaName(resolve-&gt;identifier());
1485             AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, resolve-&gt;identifier(), expr, AssignmentContext::AssignmentExpression);
1486             setExceptionLocation(node, start, divot, end);
1487             return node;
1488         }
1489         return new (m_parserArena) ReadModifyResolveNode(location, resolve-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1490     }
1491     if (loc-&gt;isBracketAccessorNode()) {
1492         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(loc);
1493         if (op == OpEqual)
1494             return new (m_parserArena) AssignBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), expr, locHasAssignments, exprHasAssignments, bracket-&gt;divot(), start, end);
1495         ReadModifyBracketNode* node = new (m_parserArena) ReadModifyBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), op, expr, locHasAssignments, exprHasAssignments, divot, start, end);
1496         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1497         return node;
1498     }
1499     ASSERT(loc-&gt;isDotAccessorNode());
1500     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(loc);
<span class="line-modified">1501     if (op == OpEqual) {</span>
<span class="line-removed">1502         if (expr-&gt;isBaseFuncExprNode()) {</span>
<span class="line-removed">1503             // We don&#39;t also set the ecma name here because ES6 specifies that the</span>
<span class="line-removed">1504             // function should not pick up the name of the dot-&gt;identifier().</span>
<span class="line-removed">1505             static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata()-&gt;setInferredName(dot-&gt;identifier());</span>
<span class="line-removed">1506         }</span>
1507         return new (m_parserArena) AssignDotNode(location, dot-&gt;base(), dot-&gt;identifier(), expr, exprHasAssignments, dot-&gt;divot(), start, end);
<span class="line-removed">1508     }</span>
1509 
1510     ReadModifyDotNode* node = new (m_parserArena) ReadModifyDotNode(location, dot-&gt;base(), dot-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1511     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1512     return node;
1513 }
1514 
1515 ExpressionNode* ASTBuilder::makePrefixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1516 {
1517     return new (m_parserArena) PrefixNode(location, expr, op, divot, start, end);
1518 }
1519 
1520 ExpressionNode* ASTBuilder::makePostfixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1521 {
1522     return new (m_parserArena) PostfixNode(location, expr, op, divot, start, end);
1523 }
1524 
1525 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2010-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
  61 
  62     struct AssignmentInfo {
  63         AssignmentInfo() {}
  64         AssignmentInfo(ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int initAssignments, Operator op)
  65             : m_node(node)
  66             , m_start(start)
  67             , m_divot(divot)
  68             , m_initAssignments(initAssignments)
  69             , m_op(op)
  70         {
  71             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);
  72             ASSERT(m_start.offset &gt;= m_start.lineStartOffset);
  73         }
  74         ExpressionNode* m_node;
  75         JSTextPosition m_start;
  76         JSTextPosition m_divot;
  77         int m_initAssignments;
  78         Operator m_op;
  79     };
  80 public:
<span class="line-modified">  81     ASTBuilder(VM&amp; vm, ParserArena&amp; parserArena, SourceCode* sourceCode)</span>
  82         : m_vm(vm)
  83         , m_parserArena(parserArena)
  84         , m_sourceCode(sourceCode)
  85         , m_evalCount(0)
  86     {
  87     }
  88 
  89     struct BinaryExprContext {
  90         BinaryExprContext(ASTBuilder&amp;) {}
  91     };
  92     struct UnaryExprContext {
  93         UnaryExprContext(ASTBuilder&amp;) {}
  94     };
  95 
  96     typedef ExpressionNode* Expression;
  97     typedef JSC::SourceElements* SourceElements;
  98     typedef ArgumentsNode* Arguments;
  99     typedef CommaNode* Comma;
 100     typedef PropertyNode* Property;
 101     typedef PropertyListNode* PropertyList;
</pre>
<hr />
<pre>
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
 125     static const bool CreatesAST = true;
 126     static const bool NeedsFreeVariableInfo = true;
 127     static const bool CanUseFunctionCache = true;
 128     static const int  DontBuildKeywords = 0;
 129     static const int  DontBuildStrings = 0;
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
<span class="line-modified"> 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);</span>
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 150     ExpressionNode* makeAddNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 151     ExpressionNode* makeSubNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 152     ExpressionNode* makeBitXOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 153     ExpressionNode* makeBitAndNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 154     ExpressionNode* makeBitOrNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
<span class="line-added"> 155     ExpressionNode* makeCoalesceNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right);</span>
 156     ExpressionNode* makeLeftShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 157     ExpressionNode* makeRightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 158     ExpressionNode* makeURightShiftNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 159 
 160     ExpressionNode* createLogicalNot(const JSTokenLocation&amp; location, ExpressionNode* expr)
 161     {
 162         if (expr-&gt;isNumber())
 163             return createBoolean(location, isZeroOrUnordered(static_cast&lt;NumberNode*&gt;(expr)-&gt;value()));
 164 
 165         return new (m_parserArena) LogicalNotNode(location, expr);
 166     }
 167     ExpressionNode* createUnaryPlus(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) UnaryPlusNode(location, expr); }
 168     ExpressionNode* createVoid(const JSTokenLocation&amp; location, ExpressionNode* expr)
 169     {
 170         incConstants();
 171         return new (m_parserArena) VoidNode(location, expr);
 172     }
 173     ExpressionNode* createThisExpr(const JSTokenLocation&amp; location)
 174     {
 175         usesThis();
</pre>
<hr />
<pre>
 179     {
 180         return new (m_parserArena) SuperNode(location);
 181     }
 182     ExpressionNode* createImportExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 183     {
 184         auto* node = new (m_parserArena) ImportNode(location, expr);
 185         setExceptionLocation(node, start, divot, end);
 186         return node;
 187     }
 188     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 189     {
 190         usesNewTarget();
 191         return new (m_parserArena) NewTargetNode(location);
 192     }
 193     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 194     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 195     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 196     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 197     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 198     {
<span class="line-modified"> 199         if (m_vm.propertyNames-&gt;arguments == ident)</span>
 200             usesArguments();
 201 
 202         if (ident.isSymbol()) {
<span class="line-modified"> 203             if (BytecodeIntrinsicNode::EmitterType emitter = m_vm.bytecodeIntrinsicRegistry().lookup(ident))</span>
 204                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);
 205         }
 206 
 207         return new (m_parserArena) ResolveNode(location, ident, start);
 208     }
 209     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 210     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 211 
 212     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 213     {
 214         if (elisions)
 215             incConstants();
 216         return new (m_parserArena) ArrayNode(location, elisions);
 217     }
 218 
 219     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 220     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 221     {
 222         if (elisions)
 223             incConstants();
</pre>
<hr />
<pre>
 315 
 316     TemplateExpressionListNode* createTemplateExpressionList(TemplateExpressionListNode* templateExpressionListNode, ExpressionNode* expression)
 317     {
 318         return new (m_parserArena) TemplateExpressionListNode(templateExpressionListNode, expression);
 319     }
 320 
 321     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList)
 322     {
 323         return new (m_parserArena) TemplateLiteralNode(location, templateStringList);
 324     }
 325 
 326     TemplateLiteralNode* createTemplateLiteral(const JSTokenLocation&amp; location, TemplateStringListNode* templateStringList, TemplateExpressionListNode* templateExpressionList)
 327     {
 328         return new (m_parserArena) TemplateLiteralNode(location, templateStringList, templateExpressionList);
 329     }
 330 
 331     ExpressionNode* createTaggedTemplate(const JSTokenLocation&amp; location, ExpressionNode* base, TemplateLiteralNode* templateLiteral, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 332     {
 333         auto node = new (m_parserArena) TaggedTemplateNode(location, base, templateLiteral);
 334         setExceptionLocation(node, start, divot, end);
<span class="line-added"> 335         setEndOffset(node, end.offset);</span>
 336         return node;
 337     }
 338 
 339     ExpressionNode* createRegExp(const JSTokenLocation&amp; location, const Identifier&amp; pattern, const Identifier&amp; flags, const JSTextPosition&amp; start)
 340     {
 341         if (Yarr::hasError(Yarr::checkSyntax(pattern.string(), flags.string())))
 342             return 0;
 343         RegExpNode* node = new (m_parserArena) RegExpNode(location, pattern, flags);
 344         int size = pattern.length() + 2; // + 2 for the two /&#39;s
 345         JSTextPosition end = start + size;
 346         setExceptionLocation(node, start, end, end);
 347         return node;
 348     }
 349 
 350     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, ArgumentsNode* arguments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 351     {
 352         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr, arguments);
 353         setExceptionLocation(node, start, divot, end);
 354         return node;
 355     }
 356 
 357     ExpressionNode* createNewExpr(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 358     {
 359         NewExprNode* node = new (m_parserArena) NewExprNode(location, expr);
 360         setExceptionLocation(node, start, end, end);
 361         return node;
 362     }
 363 
<span class="line-added"> 364     ExpressionNode* createOptionalChain(const JSTokenLocation&amp; location, ExpressionNode* base, ExpressionNode* expr, bool isOutermost)</span>
<span class="line-added"> 365     {</span>
<span class="line-added"> 366         base-&gt;setIsOptionalChainBase();</span>
<span class="line-added"> 367         return new (m_parserArena) OptionalChainNode(location, expr, isOutermost);</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369 </span>
 370     ExpressionNode* createConditionalExpr(const JSTokenLocation&amp; location, ExpressionNode* condition, ExpressionNode* lhs, ExpressionNode* rhs)
 371     {
 372         return new (m_parserArena) ConditionalNode(location, condition, lhs, rhs);
 373     }
 374 
 375     ExpressionNode* createAssignResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, ExpressionNode* rhs, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end, AssignmentContext assignmentContext)
 376     {
 377         if (rhs-&gt;isBaseFuncExprNode()) {
 378             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(rhs)-&gt;metadata();
 379             metadata-&gt;setEcmaName(ident);

 380         } else if (rhs-&gt;isClassExprNode())
 381             static_cast&lt;ClassExprNode*&gt;(rhs)-&gt;setEcmaName(ident);
 382         AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, ident, rhs, assignmentContext);
 383         setExceptionLocation(node, start, divot, end);
 384         return node;
 385     }
 386 
 387     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 388     {
 389         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 390     }
 391 
 392     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 393     {
 394         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 395         setExceptionLocation(node, start, divot, end);
 396         return node;
 397     }
 398 
 399     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
</pre>
<hr />
<pre>
 406 
 407     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 408         ExpressionNode* parentClass, PropertyListNode* classElements)
 409     {
 410         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 411         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 412     }
 413 
 414     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 415     {
 416         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 417             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 418         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 419         return result;
 420     }
 421 
 422     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 423     {
 424         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 425         if (!name.isNull())
<span class="line-modified"> 426             result-&gt;metadata()-&gt;setEcmaName(name);</span>
 427         return result;
 428     }
 429 
 430     ExpressionNode* createAsyncFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, SourceParseMode parseMode)
 431     {
 432         if (parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 433             SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 434             FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 435             functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 436             return result;
 437         }
 438         return createFunctionExpr(location, functionInfo);
 439     }
 440 
 441     ExpressionNode* createMethodDefinition(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 442     {
 443         MethodDefinitionNode* result = new (m_parserArena) MethodDefinitionNode(location, *functionInfo.name, functionInfo.body,
 444             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 445         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 446         return result;
</pre>
<hr />
<pre>
 464     ExpressionNode* createArrowFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 465     {
 466         usesArrowFunction();
 467         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.body-&gt;isArrowFunctionBodyExpression() ? functionInfo.endOffset - 1 : functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
 468         ArrowFuncExprNode* result = new (m_parserArena) ArrowFuncExprNode(location, *functionInfo.name, functionInfo.body, source);
 469         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 470         return result;
 471     }
 472 
 473     ArgumentsNode* createArguments() { return new (m_parserArena) ArgumentsNode(); }
 474     ArgumentsNode* createArguments(ArgumentListNode* args) { return new (m_parserArena) ArgumentsNode(args); }
 475     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, arg); }
 476     ArgumentListNode* createArgumentsList(const JSTokenLocation&amp; location, ArgumentListNode* args, ExpressionNode* arg) { return new (m_parserArena) ArgumentListNode(location, args, arg); }
 477 
 478     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 479         const Identifier* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 480     {
 481         ASSERT(name);
 482         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 483         functionInfo.body-&gt;setEcmaName(*name);

 484         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 485         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 486         return new (m_parserArena) PropertyNode(*name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 487     }
 488 
 489     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(const JSTokenLocation&amp; location, PropertyNode::Type type, bool,
 490         ExpressionNode* name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 491     {
 492         ASSERT(name);
 493         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 494         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 495         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, m_vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 496         return new (m_parserArena) PropertyNode(name, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 497     }
 498 
<span class="line-modified"> 499     NEVER_INLINE PropertyNode* createGetterOrSetterProperty(VM&amp; vm, ParserArena&amp; parserArena, const JSTokenLocation&amp; location, PropertyNode::Type type, bool,</span>
 500         double name, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, ClassElementTag tag)
 501     {
 502         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 503         const Identifier&amp; ident = parserArena.identifierArena().makeNumericIdentifier(vm, name);
 504         SourceCode source = m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn);
<span class="line-modified"> 505         MethodDefinitionNode* methodDef = new (m_parserArena) MethodDefinitionNode(location, vm.propertyNames-&gt;nullIdentifier, functionInfo.body, source);</span>
 506         return new (m_parserArena) PropertyNode(ident, methodDef, type, PropertyNode::Unknown, SuperBinding::Needed, tag);
 507     }
 508 
 509     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 510     {
 511         if (inferName == InferName::Allowed) {
 512             if (node-&gt;isBaseFuncExprNode()) {
 513                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 514                 metadata-&gt;setEcmaName(*propertyName);

 515             } else if (node-&gt;isClassExprNode())
 516                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 517         }
 518         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 519     }
 520     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 521     {
 522         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 523     }
<span class="line-modified"> 524     PropertyNode* createProperty(VM&amp; vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)</span>
 525     {
 526         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 527     }
 528     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
 529     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 530     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 531 
 532     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 533     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 534     ElementNode* createElementList(ArgumentListNode* elems)
 535     {
 536         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 537         ElementNode* tail = head;
 538         elems = elems-&gt;m_next;
 539         while (elems) {
 540             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 541             elems = elems-&gt;m_next;
 542         }
 543         return head;
 544     }
 545 
 546     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 547     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 548     {
 549         list-&gt;append(pattern, defaultValue);
 550         tryInferNameInPattern(pattern, defaultValue);
 551     }
 552 
 553     CaseClauseNode* createClause(ExpressionNode* expr, JSC::SourceElements* statements) { return new (m_parserArena) CaseClauseNode(expr, statements); }
 554     ClauseListNode* createClauseList(CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(clause); }
 555     ClauseListNode* createClauseList(ClauseListNode* tail, CaseClauseNode* clause) { return new (m_parserArena) ClauseListNode(tail, clause); }
 556 
 557     StatementNode* createFuncDeclStatement(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 558     {
 559         FuncDeclNode* decl = new (m_parserArena) FuncDeclNode(location, *functionInfo.name, functionInfo.body,
 560             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
<span class="line-modified"> 561         if (*functionInfo.name == m_vm.propertyNames-&gt;arguments)</span>
 562             usesArguments();
 563         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 564         return decl;
 565     }
 566 
 567     StatementNode* createClassDeclStatement(const JSTokenLocation&amp; location, ClassExprNode* classExpression,
 568         const JSTextPosition&amp; classStart, const JSTextPosition&amp; classEnd, unsigned startLine, unsigned endLine)
 569     {
 570         ExpressionNode* assign = createAssignResolve(location, classExpression-&gt;name(), classExpression, classStart, classStart + 1, classEnd, AssignmentContext::DeclarationStatement);
 571         ClassDeclNode* decl = new (m_parserArena) ClassDeclNode(location, assign);
 572         decl-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 573         return decl;
 574     }
 575 
 576     StatementNode* createBlockStatement(const JSTokenLocation&amp; location, JSC::SourceElements* elements, int startLine, int endLine, VariableEnvironment&amp; lexicalVariables, DeclarationStacks::FunctionStack&amp;&amp; functionStack)
 577     {
 578         BlockNode* block = new (m_parserArena) BlockNode(location, elements, lexicalVariables, WTFMove(functionStack));
 579         block-&gt;setLoc(startLine, endLine, location.startOffset, location.lineStartOffset);
 580         return block;
 581     }
</pre>
<hr />
<pre>
 617 
 618     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, ExpressionNode* lhs, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp;, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 619     {
 620         ForOfNode* result = new (m_parserArena) ForOfNode(isForAwait, location, lhs, iter, statements, lexicalVariables);
 621         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 622         setExceptionLocation(result, eStart, eDivot, eEnd);
 623         return result;
 624     }
 625 
 626     StatementNode* createForOfLoop(bool isForAwait, const JSTokenLocation&amp; location, DestructuringPatternNode* pattern, ExpressionNode* iter, StatementNode* statements, const JSTokenLocation&amp; declLocation, const JSTextPosition&amp; eStart, const JSTextPosition&amp; eDivot, const JSTextPosition&amp; eEnd, int start, int end, VariableEnvironment&amp; lexicalVariables)
 627     {
 628         auto lexpr = new (m_parserArena) DestructuringAssignmentNode(declLocation, pattern, nullptr);
 629         return createForOfLoop(isForAwait, location, lexpr, iter, statements, declLocation, eStart, eDivot, eEnd, start, end, lexicalVariables);
 630     }
 631 
 632     bool isBindingNode(const DestructuringPattern&amp; pattern)
 633     {
 634         return pattern-&gt;isBindingNode();
 635     }
 636 
<span class="line-modified"> 637     bool isLocation(const Expression&amp; node)</span>
 638     {
<span class="line-modified"> 639         return node-&gt;isLocation();</span>
<span class="line-added"> 640     }</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642     bool isAssignmentLocation(const Expression&amp; node)</span>
<span class="line-added"> 643     {</span>
<span class="line-added"> 644         return node-&gt;isAssignmentLocation();</span>
 645     }
 646 
 647     bool isObjectLiteral(const Expression&amp; node)
 648     {
 649         return node-&gt;isObjectLiteral();
 650     }
 651 
 652     bool isArrayLiteral(const Expression&amp; node)
 653     {
 654         return node-&gt;isArrayLiteral();
 655     }
 656 
 657     bool isObjectOrArrayLiteral(const Expression&amp; node)
 658     {
 659         return isObjectLiteral(node) || isArrayLiteral(node);
 660     }
 661 
<span class="line-added"> 662     bool isFunctionCall(const Expression&amp; node)</span>
<span class="line-added"> 663     {</span>
<span class="line-added"> 664         return node-&gt;isFunctionCall();</span>
<span class="line-added"> 665     }</span>
<span class="line-added"> 666 </span>
 667     bool shouldSkipPauseLocation(StatementNode* statement) const
 668     {
 669         return !statement || statement-&gt;isLabel();
 670     }
 671 
 672     StatementNode* createEmptyStatement(const JSTokenLocation&amp; location) { return new (m_parserArena) EmptyStatementNode(location); }
 673 
 674     StatementNode* createDeclarationStatement(const JSTokenLocation&amp; location, ExpressionNode* expr, int start, int end)
 675     {
 676         StatementNode* result;
 677         result = new (m_parserArena) DeclarationStatement(location, expr);
 678         result-&gt;setLoc(start, end, location.startOffset, location.lineStartOffset);
 679         return result;
 680     }
 681 
 682     ExpressionNode* createEmptyVarExpression(const JSTokenLocation&amp; location, const Identifier&amp; identifier)
 683     {
 684         return new (m_parserArena) EmptyVarExpression(location, identifier);
 685     }
 686 
</pre>
<hr />
<pre>
1112         if (!defaultValue)
1113             return;
1114 
1115         if (pattern-&gt;isBindingNode()) {
1116             const Identifier&amp; ident = static_cast&lt;BindingNode*&gt;(pattern)-&gt;boundProperty();
1117             tryInferNameInPatternWithIdentifier(ident, defaultValue);
1118         } else if (pattern-&gt;isAssignmentElementNode()) {
1119             const ExpressionNode* assignmentTarget = static_cast&lt;AssignmentElementNode*&gt;(pattern)-&gt;assignmentTarget();
1120             if (assignmentTarget-&gt;isResolveNode()) {
1121                 const Identifier&amp; ident = static_cast&lt;const ResolveNode*&gt;(assignmentTarget)-&gt;identifier();
1122                 tryInferNameInPatternWithIdentifier(ident, defaultValue);
1123             }
1124         }
1125     }
1126 
1127     void tryInferNameInPatternWithIdentifier(const Identifier&amp; ident, ExpressionNode* defaultValue)
1128     {
1129         if (defaultValue-&gt;isBaseFuncExprNode()) {
1130             auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(defaultValue)-&gt;metadata();
1131             metadata-&gt;setEcmaName(ident);

1132         } else if (defaultValue-&gt;isClassExprNode())
1133             static_cast&lt;ClassExprNode*&gt;(defaultValue)-&gt;setEcmaName(ident);
1134     }
1135 
<span class="line-modified">1136     VM&amp; m_vm;</span>
1137     ParserArena&amp; m_parserArena;
1138     SourceCode* m_sourceCode;
1139     Scope m_scope;
1140     Vector&lt;BinaryOperand, 10, UnsafeVectorOverflow&gt; m_binaryOperandStack;
1141     Vector&lt;AssignmentInfo, 10, UnsafeVectorOverflow&gt; m_assignmentInfoStack;
1142     Vector&lt;std::pair&lt;int, int&gt;, 10, UnsafeVectorOverflow&gt; m_binaryOperatorStack;
1143     Vector&lt;std::pair&lt;int, JSTextPosition&gt;, 10, UnsafeVectorOverflow&gt; m_unaryTokenStack;
1144     int m_evalCount;
1145 };
1146 
1147 ExpressionNode* ASTBuilder::makeTypeOfNode(const JSTokenLocation&amp; location, ExpressionNode* expr)
1148 {
1149     if (expr-&gt;isResolveNode()) {
1150         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1151         return new (m_parserArena) TypeOfResolveNode(location, resolve-&gt;identifier());
1152     }
1153     return new (m_parserArena) TypeOfValueNode(location, expr);
1154 }
1155 
1156 ExpressionNode* ASTBuilder::makeDeleteNode(const JSTokenLocation&amp; location, ExpressionNode* expr, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1157 {
<span class="line-added">1158     if (expr-&gt;isOptionalChain()) {</span>
<span class="line-added">1159         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr);</span>
<span class="line-added">1160         if (optionalChain-&gt;expr()-&gt;isLocation()) {</span>
<span class="line-added">1161             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());</span>
<span class="line-added">1162             optionalChain-&gt;setExpr(makeDeleteNode(location, optionalChain-&gt;expr(), start, divot, end));</span>
<span class="line-added">1163             return optionalChain;</span>
<span class="line-added">1164         }</span>
<span class="line-added">1165     }</span>
<span class="line-added">1166 </span>
1167     if (!expr-&gt;isLocation())
1168         return new (m_parserArena) DeleteValueNode(location, expr);
1169     if (expr-&gt;isResolveNode()) {
1170         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(expr);
1171         return new (m_parserArena) DeleteResolveNode(location, resolve-&gt;identifier(), divot, start, end);
1172     }
1173     if (expr-&gt;isBracketAccessorNode()) {
1174         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(expr);
1175         return new (m_parserArena) DeleteBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), divot, start, end);
1176     }
1177     ASSERT(expr-&gt;isDotAccessorNode());
1178     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expr);
1179     return new (m_parserArena) DeleteDotNode(location, dot-&gt;base(), dot-&gt;identifier(), divot, start, end);
1180 }
1181 
1182 ExpressionNode* ASTBuilder::makeNegateNode(const JSTokenLocation&amp; location, ExpressionNode* n)
1183 {
1184     if (n-&gt;isNumber()) {
1185         const NumberNode&amp; numberNode = static_cast&lt;const NumberNode&amp;&gt;(*n);
1186         return createNumberFromUnaryOperation(location, -numberNode.value(), numberNode);
</pre>
<hr />
<pre>
1344 ExpressionNode* ASTBuilder::makeBitAndNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1345 {
1346     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1347         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1348         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1349         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) &amp; toInt32(numberExpr2.value()));
1350     }
1351     return new (m_parserArena) BitAndNode(location, expr1, expr2, rightHasAssignments);
1352 }
1353 
1354 ExpressionNode* ASTBuilder::makeBitXOrNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2, bool rightHasAssignments)
1355 {
1356     if (expr1-&gt;isNumber() &amp;&amp; expr2-&gt;isNumber()) {
1357         const NumberNode&amp; numberExpr1 = static_cast&lt;NumberNode&amp;&gt;(*expr1);
1358         const NumberNode&amp; numberExpr2 = static_cast&lt;NumberNode&amp;&gt;(*expr2);
1359         return createIntegerLikeNumber(location, toInt32(numberExpr1.value()) ^ toInt32(numberExpr2.value()));
1360     }
1361     return new (m_parserArena) BitXOrNode(location, expr1, expr2, rightHasAssignments);
1362 }
1363 
<span class="line-modified">1364 ExpressionNode* ASTBuilder::makeCoalesceNode(const JSTokenLocation&amp; location, ExpressionNode* expr1, ExpressionNode* expr2)</span>
<span class="line-added">1365 {</span>
<span class="line-added">1366     // Optimization for `x?.y ?? z`.</span>
<span class="line-added">1367     if (expr1-&gt;isOptionalChain()) {</span>
<span class="line-added">1368         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr1);</span>
<span class="line-added">1369         if (!optionalChain-&gt;expr()-&gt;isDeleteNode()) {</span>
<span class="line-added">1370             constexpr bool hasAbsorbedOptionalChain = true;</span>
<span class="line-added">1371             return new (m_parserArena) CoalesceNode(location, optionalChain-&gt;expr(), expr2, hasAbsorbedOptionalChain);</span>
<span class="line-added">1372         }</span>
<span class="line-added">1373     }</span>
<span class="line-added">1374     constexpr bool hasAbsorbedOptionalChain = false;</span>
<span class="line-added">1375     return new (m_parserArena) CoalesceNode(location, expr1, expr2, hasAbsorbedOptionalChain);</span>
<span class="line-added">1376 }</span>
<span class="line-added">1377 </span>
<span class="line-added">1378 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall)</span>
1379 {
1380     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1381     if (func-&gt;isSuperNode())
1382         usesSuperCall();
1383 
1384     if (func-&gt;isBytecodeIntrinsicNode()) {
<span class="line-added">1385         ASSERT(!isOptionalCall);</span>
1386         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
1387         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant)
1388             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;emitter(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);
1389     }
<span class="line-added">1390 </span>
<span class="line-added">1391     if (func-&gt;isOptionalChain()) {</span>
<span class="line-added">1392         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(func);</span>
<span class="line-added">1393         if (optionalChain-&gt;expr()-&gt;isLocation()) {</span>
<span class="line-added">1394             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());</span>
<span class="line-added">1395             // We must take care to preserve our `this` value in cases like `a?.b?.()` and `(a?.b)()`, respectively.</span>
<span class="line-added">1396             if (isOptionalCall)</span>
<span class="line-added">1397                 return makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall);</span>
<span class="line-added">1398             optionalChain-&gt;setExpr(makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall));</span>
<span class="line-added">1399             return optionalChain;</span>
<span class="line-added">1400         }</span>
<span class="line-added">1401     }</span>
<span class="line-added">1402 </span>
1403     if (!func-&gt;isLocation())
1404         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1405     if (func-&gt;isResolveNode()) {
1406         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1407         const Identifier&amp; identifier = resolve-&gt;identifier();
<span class="line-modified">1408         if (identifier == m_vm.propertyNames-&gt;eval) {</span>
1409             usesEval();
1410             return new (m_parserArena) EvalFunctionCallNode(location, args, divot, divotStart, divotEnd);
1411         }
1412         return new (m_parserArena) FunctionCallResolveNode(location, identifier, args, divot, divotStart, divotEnd);
1413     }
1414     if (func-&gt;isBracketAccessorNode()) {
1415         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(func);
1416         FunctionCallBracketNode* node = new (m_parserArena) FunctionCallBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), bracket-&gt;subscriptHasAssignments(), args, divot, divotStart, divotEnd);
1417         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1418         return node;
1419     }
1420     ASSERT(func-&gt;isDotAccessorNode());
1421     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(func);
1422     FunctionCallDotNode* node = nullptr;
<span class="line-modified">1423     if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().callPrivateName()))</span>
1424         node = new (m_parserArena) CallFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
<span class="line-modified">1425     else if (!previousBaseWasSuper &amp;&amp; (dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPublicName() || dot-&gt;identifier() == m_vm.propertyNames-&gt;builtinNames().applyPrivateName())) {</span>
1426         // FIXME: This check is only needed because we haven&#39;t taught the bytecode generator to inline
1427         // Reflect.apply yet. See https://bugs.webkit.org/show_bug.cgi?id=190668.
1428         if (!dot-&gt;base()-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(dot-&gt;base())-&gt;identifier() != &quot;Reflect&quot;)
1429             node = new (m_parserArena) ApplyFunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd, callOrApplyChildDepth);
1430     }
1431     if (!node)
1432         node = new (m_parserArena) FunctionCallDotNode(location, dot-&gt;base(), dot-&gt;identifier(), args, divot, divotStart, divotEnd);
1433     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1434     return node;
1435 }
1436 
1437 ExpressionNode* ASTBuilder::makeBinaryNode(const JSTokenLocation&amp; location, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; lhs, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; rhs)
1438 {
1439     switch (token) {
<span class="line-added">1440     case COALESCE:</span>
<span class="line-added">1441         return makeCoalesceNode(location, lhs.first, rhs.first);</span>
<span class="line-added">1442 </span>
1443     case OR:
1444         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalOr);
1445 
1446     case AND:
1447         return new (m_parserArena) LogicalOpNode(location, lhs.first, rhs.first, OpLogicalAnd);
1448 
1449     case BITOR:
1450         return makeBitOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1451 
1452     case BITXOR:
1453         return makeBitXOrNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1454 
1455     case BITAND:
1456         return makeBitAndNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1457 
1458     case EQEQ:
1459         return new (m_parserArena) EqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1460 
1461     case NE:
1462         return new (m_parserArena) NotEqualNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
</pre>
<hr />
<pre>
1507         return makeSubNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1508 
1509     case TIMES:
1510         return makeMultNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1511 
1512     case DIVIDE:
1513         return makeDivNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1514 
1515     case MOD:
1516         return makeModNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1517 
1518     case POW:
1519         return makePowNode(location, lhs.first, rhs.first, rhs.second.hasAssignment);
1520     }
1521     CRASH();
1522     return 0;
1523 }
1524 
1525 ExpressionNode* ASTBuilder::makeAssignNode(const JSTokenLocation&amp; location, ExpressionNode* loc, Operator op, ExpressionNode* expr, bool locHasAssignments, bool exprHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1526 {
<span class="line-modified">1527     if (!loc-&gt;isLocation()) {</span>
<span class="line-added">1528         ASSERT(loc-&gt;isFunctionCall());</span>
1529         return new (m_parserArena) AssignErrorNode(location, divot, start, end);
<span class="line-added">1530     }</span>
1531 
1532     if (loc-&gt;isResolveNode()) {
1533         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(loc);
1534         if (op == OpEqual) {
1535             if (expr-&gt;isBaseFuncExprNode()) {
1536                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(expr)-&gt;metadata();
1537                 metadata-&gt;setEcmaName(resolve-&gt;identifier());

1538             } else if (expr-&gt;isClassExprNode())
1539                 static_cast&lt;ClassExprNode*&gt;(expr)-&gt;setEcmaName(resolve-&gt;identifier());
1540             AssignResolveNode* node = new (m_parserArena) AssignResolveNode(location, resolve-&gt;identifier(), expr, AssignmentContext::AssignmentExpression);
1541             setExceptionLocation(node, start, divot, end);
1542             return node;
1543         }
1544         return new (m_parserArena) ReadModifyResolveNode(location, resolve-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1545     }
1546     if (loc-&gt;isBracketAccessorNode()) {
1547         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(loc);
1548         if (op == OpEqual)
1549             return new (m_parserArena) AssignBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), expr, locHasAssignments, exprHasAssignments, bracket-&gt;divot(), start, end);
1550         ReadModifyBracketNode* node = new (m_parserArena) ReadModifyBracketNode(location, bracket-&gt;base(), bracket-&gt;subscript(), op, expr, locHasAssignments, exprHasAssignments, divot, start, end);
1551         node-&gt;setSubexpressionInfo(bracket-&gt;divot(), bracket-&gt;divotEnd().offset);
1552         return node;
1553     }
1554     ASSERT(loc-&gt;isDotAccessorNode());
1555     DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(loc);
<span class="line-modified">1556     if (op == OpEqual)</span>





1557         return new (m_parserArena) AssignDotNode(location, dot-&gt;base(), dot-&gt;identifier(), expr, exprHasAssignments, dot-&gt;divot(), start, end);

1558 
1559     ReadModifyDotNode* node = new (m_parserArena) ReadModifyDotNode(location, dot-&gt;base(), dot-&gt;identifier(), op, expr, exprHasAssignments, divot, start, end);
1560     node-&gt;setSubexpressionInfo(dot-&gt;divot(), dot-&gt;divotEnd().offset);
1561     return node;
1562 }
1563 
1564 ExpressionNode* ASTBuilder::makePrefixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1565 {
1566     return new (m_parserArena) PrefixNode(location, expr, op, divot, start, end);
1567 }
1568 
1569 ExpressionNode* ASTBuilder::makePostfixNode(const JSTokenLocation&amp; location, ExpressionNode* expr, Operator op, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
1570 {
1571     return new (m_parserArena) PostfixNode(location, expr, op, divot, start, end);
1572 }
1573 
1574 }
</pre>
</td>
</tr>
</table>
<center><a href="../offlineasm/x86.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>