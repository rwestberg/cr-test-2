<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #pragma once
  32 
  33 #include &quot;CodeBlock.h&quot;
  34 #include &quot;Instruction.h&quot;
  35 #include &quot;Interpreter.h&quot;
  36 #include &quot;JSAsyncGeneratorFunction.h&quot;
  37 #include &quot;JSBigInt.h&quot;
  38 #include &quot;JSGeneratorFunction.h&quot;
  39 #include &quot;JSTemplateObjectDescriptor.h&quot;
  40 #include &quot;Label.h&quot;
  41 #include &quot;LabelScope.h&quot;
  42 #include &quot;Nodes.h&quot;
  43 #include &quot;ParserError.h&quot;
  44 #include &quot;ProfileTypeBytecodeFlag.h&quot;
  45 #include &quot;RegisterID.h&quot;
  46 #include &quot;StaticPropertyAnalyzer.h&quot;
  47 #include &quot;SymbolTable.h&quot;
  48 #include &quot;UnlinkedCodeBlock.h&quot;
  49 #include &lt;functional&gt;
  50 #include &lt;wtf/CheckedArithmetic.h&gt;
  51 #include &lt;wtf/HashFunctions.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  52 #include &lt;wtf/Optional.h&gt;</span>
  53 #include &lt;wtf/SegmentedVector.h&gt;
  54 #include &lt;wtf/SetForScope.h&gt;
  55 #include &lt;wtf/Vector.h&gt;
  56 
  57 namespace JSC {
  58 
  59     class JSImmutableButterfly;
  60     class Identifier;
  61     class IndexedForInContext;
  62     class StructureForInContext;
  63 
  64     enum ExpectedFunction {
  65         NoExpectedFunction,
  66         ExpectObjectConstructor,
  67         ExpectArrayConstructor
  68     };
  69 
  70     enum class EmitAwait { Yes, No };
  71 
  72     enum class DebuggableCall { Yes, No };
  73     enum class ThisResolutionType { Local, Scoped };
  74 
  75     class CallArguments {
  76     public:
  77         CallArguments(BytecodeGenerator&amp;, ArgumentsNode*, unsigned additionalArguments = 0);
  78 
  79         RegisterID* thisRegister() { return m_argv[0].get(); }
  80         RegisterID* argumentRegister(unsigned i) { return m_argv[i + 1].get(); }
  81         unsigned stackOffset() { return -m_argv[0]-&gt;index() + CallFrame::headerSizeInRegisters; }
  82         unsigned argumentCountIncludingThis() { return m_argv.size() - m_padding; }
  83         ArgumentsNode* argumentsNode() { return m_argumentsNode; }
  84 
  85     private:
  86         ArgumentsNode* m_argumentsNode;
  87         Vector&lt;RefPtr&lt;RegisterID&gt;, 8, UnsafeVectorOverflow&gt; m_argv;
  88         unsigned m_padding;
  89     };
  90 
  91     // https://tc39.github.io/ecma262/#sec-completion-record-specification-type
  92     //
  93     // For the Break and Continue cases, instead of using the Break and Continue enum values
  94     // below, we use the unique jumpID of the break and continue statement as the encoding
  95     // for the CompletionType value. emitFinallyCompletion() uses this jumpID value later
  96     // to determine the appropriate jump target to jump to after executing the relevant finally
  97     // blocks. The jumpID is computed as:
  98     //     jumpID = bytecodeOffset (of the break/continue node) + CompletionType::NumberOfTypes.
  99     // Hence, there won&#39;t be any collision between jumpIDs and CompletionType enums.
 100     enum class CompletionType : int {
 101         Normal,
<a name="3" id="anc3"></a>


 102         Throw,
<a name="4" id="anc4"></a><span class="line-modified"> 103         Return,</span>
 104         NumberOfTypes
 105     };
 106 
 107     inline CompletionType bytecodeOffsetToJumpID(unsigned offset)
 108     {
 109         int jumpIDAsInt = offset + static_cast&lt;int&gt;(CompletionType::NumberOfTypes);
 110         ASSERT(jumpIDAsInt &gt;= static_cast&lt;int&gt;(CompletionType::NumberOfTypes));
 111         return static_cast&lt;CompletionType&gt;(jumpIDAsInt);
 112     }
 113 
 114     struct FinallyJump {
 115         FinallyJump(CompletionType jumpID, int targetLexicalScopeIndex, Label&amp; targetLabel)
 116             : jumpID(jumpID)
 117             , targetLexicalScopeIndex(targetLexicalScopeIndex)
 118             , targetLabel(targetLabel)
 119         { }
 120 
 121         CompletionType jumpID;
 122         int targetLexicalScopeIndex;
 123         Ref&lt;Label&gt; targetLabel;
 124     };
 125 
<a name="5" id="anc5"></a><span class="line-modified"> 126     class FinallyContext {</span>
<span class="line-added"> 127     public:</span>
 128         FinallyContext() { }
<a name="6" id="anc6"></a><span class="line-modified"> 129         FinallyContext(BytecodeGenerator&amp;, Label&amp; finallyLabel);</span>





 130 
 131         FinallyContext* outerContext() const { return m_outerContext; }
 132         Label* finallyLabel() const { return m_finallyLabel; }
 133 
<a name="7" id="anc7"></a><span class="line-added"> 134         RegisterID* completionTypeRegister() const { return m_completionRecord.typeRegister.get(); }</span>
<span class="line-added"> 135         RegisterID* completionValueRegister() const { return m_completionRecord.valueRegister.get(); }</span>
<span class="line-added"> 136 </span>
 137         uint32_t numberOfBreaksOrContinues() const { return m_numberOfBreaksOrContinues.unsafeGet(); }
 138         void incNumberOfBreaksOrContinues() { m_numberOfBreaksOrContinues++; }
 139 
 140         bool handlesReturns() const { return m_handlesReturns; }
 141         void setHandlesReturns() { m_handlesReturns = true; }
 142 
 143         void registerJump(CompletionType jumpID, int lexicalScopeIndex, Label&amp; targetLabel)
 144         {
 145             m_jumps.append(FinallyJump(jumpID, lexicalScopeIndex, targetLabel));
 146         }
 147 
 148         size_t numberOfJumps() const { return m_jumps.size(); }
 149         FinallyJump&amp; jumps(size_t i) { return m_jumps[i]; }
 150 
 151     private:
 152         FinallyContext* m_outerContext { nullptr };
 153         Label* m_finallyLabel { nullptr };
 154         Checked&lt;uint32_t, WTF::CrashOnOverflow&gt; m_numberOfBreaksOrContinues;
 155         bool m_handlesReturns { false };
 156         Vector&lt;FinallyJump&gt; m_jumps;
<a name="8" id="anc8"></a><span class="line-added"> 157         struct {</span>
<span class="line-added"> 158             RefPtr&lt;RegisterID&gt; typeRegister;</span>
<span class="line-added"> 159             RefPtr&lt;RegisterID&gt; valueRegister;</span>
<span class="line-added"> 160         } m_completionRecord;</span>
 161     };
 162 
 163     struct ControlFlowScope {
 164         typedef uint8_t Type;
 165         enum {
 166             Label,
 167             Finally
 168         };
<a name="9" id="anc9"></a><span class="line-modified"> 169         ControlFlowScope(Type type, int lexicalScopeIndex, FinallyContext* finallyContext = nullptr)</span>
 170             : type(type)
 171             , lexicalScopeIndex(lexicalScopeIndex)
<a name="10" id="anc10"></a><span class="line-modified"> 172             , finallyContext(finallyContext)</span>
 173         { }
 174 
 175         bool isLabelScope() const { return type == Label; }
 176         bool isFinallyScope() const { return type == Finally; }
 177 
 178         Type type;
 179         int lexicalScopeIndex;
<a name="11" id="anc11"></a><span class="line-modified"> 180         FinallyContext* finallyContext;</span>
 181     };
 182 
 183     class ForInContext : public RefCounted&lt;ForInContext&gt; {
 184         WTF_MAKE_FAST_ALLOCATED;
 185         WTF_MAKE_NONCOPYABLE(ForInContext);
 186     public:
 187         virtual ~ForInContext() = default;
 188 
 189         bool isValid() const { return m_isValid; }
 190         void invalidate() { m_isValid = false; }
 191 
 192         enum class Type : uint8_t {
 193             IndexedForIn,
 194             StructureForIn
 195         };
 196 
 197         Type type() const { return m_type; }
 198         bool isIndexedForInContext() const { return m_type == Type::IndexedForIn; }
 199         bool isStructureForInContext() const { return m_type == Type::StructureForIn; }
 200 
 201         IndexedForInContext&amp; asIndexedForInContext()
 202         {
 203             ASSERT(isIndexedForInContext());
 204             return *reinterpret_cast&lt;IndexedForInContext*&gt;(this);
 205         }
 206 
 207         StructureForInContext&amp; asStructureForInContext()
 208         {
 209             ASSERT(isStructureForInContext());
 210             return *reinterpret_cast&lt;StructureForInContext*&gt;(this);
 211         }
 212 
 213         RegisterID* local() const { return m_localRegister.get(); }
 214 
 215     protected:
 216         ForInContext(RegisterID* localRegister, Type type, unsigned bodyBytecodeStartOffset)
 217             : m_localRegister(localRegister)
 218             , m_type(type)
 219             , m_bodyBytecodeStartOffset(bodyBytecodeStartOffset)
 220         { }
 221 
 222         unsigned bodyBytecodeStartOffset() const { return m_bodyBytecodeStartOffset; }
 223 
 224         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 225 
 226     private:
 227         RefPtr&lt;RegisterID&gt; m_localRegister;
 228         bool m_isValid { true };
 229         Type m_type;
 230         unsigned m_bodyBytecodeStartOffset;
 231     };
 232 
 233     class StructureForInContext : public ForInContext {
 234         using Base = ForInContext;
 235     public:
 236         using GetInst = std::tuple&lt;unsigned, int&gt;;
 237 
 238         StructureForInContext(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister, unsigned bodyBytecodeStartOffset)
 239             : ForInContext(localRegister, Type::StructureForIn, bodyBytecodeStartOffset)
 240             , m_indexRegister(indexRegister)
 241             , m_propertyRegister(propertyRegister)
 242             , m_enumeratorRegister(enumeratorRegister)
 243         {
 244         }
 245 
 246         RegisterID* index() const { return m_indexRegister.get(); }
 247         RegisterID* property() const { return m_propertyRegister.get(); }
 248         RegisterID* enumerator() const { return m_enumeratorRegister.get(); }
 249 
 250         void addGetInst(unsigned instIndex, int propertyRegIndex)
 251         {
 252             m_getInsts.append(GetInst { instIndex, propertyRegIndex });
 253         }
 254 
 255         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 256 
 257     private:
 258         RefPtr&lt;RegisterID&gt; m_indexRegister;
 259         RefPtr&lt;RegisterID&gt; m_propertyRegister;
 260         RefPtr&lt;RegisterID&gt; m_enumeratorRegister;
 261         Vector&lt;GetInst&gt; m_getInsts;
 262     };
 263 
 264     class IndexedForInContext : public ForInContext {
 265         using Base = ForInContext;
 266     public:
 267         IndexedForInContext(RegisterID* localRegister, RegisterID* indexRegister, unsigned bodyBytecodeStartOffset)
 268             : ForInContext(localRegister, Type::IndexedForIn, bodyBytecodeStartOffset)
 269             , m_indexRegister(indexRegister)
 270         {
 271         }
 272 
 273         RegisterID* index() const { return m_indexRegister.get(); }
 274 
 275         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlock*, unsigned bodyBytecodeEndOffset);
 276         void addGetInst(unsigned instIndex, int propertyIndex) { m_getInsts.append({ instIndex, propertyIndex }); }
 277 
 278     private:
 279         RefPtr&lt;RegisterID&gt; m_indexRegister;
 280         Vector&lt;std::pair&lt;unsigned, int&gt;&gt; m_getInsts;
 281     };
 282 
 283     struct TryData {
 284         Ref&lt;Label&gt; target;
 285         HandlerType handlerType;
 286     };
 287 
 288     struct TryContext {
 289         Ref&lt;Label&gt; start;
 290         TryData* tryData;
 291     };
 292 
 293     class Variable {
 294     public:
 295         enum VariableKind { NormalVariable, SpecialVariable };
 296 
 297         Variable()
 298             : m_offset()
 299             , m_local(nullptr)
 300             , m_attributes(0)
 301             , m_kind(NormalVariable)
 302             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 303             , m_isLexicallyScoped(false)
 304         {
 305         }
 306 
 307         Variable(const Identifier&amp; ident)
 308             : m_ident(ident)
 309             , m_local(nullptr)
 310             , m_attributes(0)
 311             , m_kind(NormalVariable) // This is somewhat meaningless here for this kind of Variable.
 312             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 313             , m_isLexicallyScoped(false)
 314         {
 315         }
 316 
 317         Variable(const Identifier&amp; ident, VarOffset offset, RegisterID* local, unsigned attributes, VariableKind kind, int symbolTableConstantIndex, bool isLexicallyScoped)
 318             : m_ident(ident)
 319             , m_offset(offset)
 320             , m_local(local)
 321             , m_attributes(attributes)
 322             , m_kind(kind)
 323             , m_symbolTableConstantIndex(symbolTableConstantIndex)
 324             , m_isLexicallyScoped(isLexicallyScoped)
 325         {
 326         }
 327 
 328         // If it&#39;s unset, then it is a non-locally-scoped variable. If it is set, then it could be
 329         // a stack variable, a scoped variable in a local scope, or a variable captured in the
 330         // direct arguments object.
 331         bool isResolved() const { return !!m_offset; }
 332         int symbolTableConstantIndex() const { ASSERT(isResolved() &amp;&amp; !isSpecial()); return m_symbolTableConstantIndex; }
 333 
 334         const Identifier&amp; ident() const { return m_ident; }
 335 
 336         VarOffset offset() const { return m_offset; }
 337         bool isLocal() const { return m_offset.isStack(); }
 338         RegisterID* local() const { return m_local; }
 339 
 340         bool isReadOnly() const { return m_attributes &amp; PropertyAttribute::ReadOnly; }
 341         bool isSpecial() const { return m_kind != NormalVariable; }
 342         bool isConst() const { return isReadOnly() &amp;&amp; m_isLexicallyScoped; }
 343         void setIsReadOnly() { m_attributes |= PropertyAttribute::ReadOnly; }
 344 
 345         void dump(PrintStream&amp;) const;
 346 
 347     private:
 348         Identifier m_ident;
 349         VarOffset m_offset;
 350         RegisterID* m_local;
 351         unsigned m_attributes;
 352         VariableKind m_kind;
 353         int m_symbolTableConstantIndex;
 354         bool m_isLexicallyScoped;
 355     };
 356 
 357     struct TryRange {
 358         Ref&lt;Label&gt; start;
 359         Ref&lt;Label&gt; end;
 360         TryData* tryData;
 361     };
 362 
 363     class BytecodeGenerator {
 364         WTF_MAKE_FAST_ALLOCATED;
 365         WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
 366 
 367         friend class BoundLabel;
<a name="12" id="anc12"></a><span class="line-added"> 368         friend class FinallyContext;</span>
 369         friend class Label;
 370         friend class IndexedForInContext;
 371         friend class StructureForInContext;
 372     public:
 373         typedef DeclarationStacks::FunctionStack FunctionStack;
 374 
<a name="13" id="anc13"></a><span class="line-modified"> 375         BytecodeGenerator(VM&amp;, ProgramNode*, UnlinkedProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 376         BytecodeGenerator(VM&amp;, FunctionNode*, UnlinkedFunctionCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 377         BytecodeGenerator(VM&amp;, EvalNode*, UnlinkedEvalCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
<span class="line-modified"> 378         BytecodeGenerator(VM&amp;, ModuleProgramNode*, UnlinkedModuleProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);</span>
 379 
 380         ~BytecodeGenerator();
 381 
<a name="14" id="anc14"></a><span class="line-modified"> 382         VM&amp; vm() const { return m_vm; }</span>
 383         ParserArena&amp; parserArena() const { return m_scopeNode-&gt;parserArena(); }
<a name="15" id="anc15"></a><span class="line-modified"> 384         const CommonIdentifiers&amp; propertyNames() const { return *m_vm.propertyNames; }</span>
 385 
 386         bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 387         DerivedContextType derivedContextType() const { return m_derivedContextType; }
 388         bool usesArrowFunction() const { return m_scopeNode-&gt;usesArrowFunction(); }
 389         bool needsToUpdateArrowFunctionContext() const { return m_needsToUpdateArrowFunctionContext; }
 390         bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
 391         bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
 392         ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 393         SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 394         JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
 395 
 396         template&lt;typename Node, typename UnlinkedCodeBlock&gt;
<a name="16" id="anc16"></a><span class="line-modified"> 397         static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* environment)</span>
 398         {
 399             MonotonicTime before;
 400             if (UNLIKELY(Options::reportBytecodeCompileTimes()))
 401                 before = MonotonicTime::now();
 402 
 403             DeferGC deferGC(vm.heap);
<a name="17" id="anc17"></a><span class="line-modified"> 404             auto bytecodeGenerator = makeUnique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, codeGenerationMode, environment);</span>
 405             auto result = bytecodeGenerator-&gt;generate();
 406 
 407             if (UNLIKELY(Options::reportBytecodeCompileTimes())) {
 408                 MonotonicTime after = MonotonicTime::now();
 409                 dataLogLn(result.isValid() ? &quot;Failed to compile #&quot; : &quot;Compiled #&quot;, CodeBlockHash(sourceCode, unlinkedCodeBlock-&gt;isConstructor() ? CodeForConstruct : CodeForCall), &quot; into bytecode &quot;, bytecodeGenerator-&gt;instructions().size(), &quot; instructions in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
 410             }
 411             return result;
 412         }
 413 
 414         bool isArgumentNumber(const Identifier&amp;, int);
 415 
 416         Variable variable(const Identifier&amp;, ThisResolutionType = ThisResolutionType::Local);
 417 
 418         enum ExistingVariableMode { VerifyExisting, IgnoreExisting };
 419         void createVariable(const Identifier&amp;, VarKind, SymbolTable*, ExistingVariableMode = VerifyExisting); // Creates the variable, or asserts that the already-created variable is sufficiently compatible.
 420 
 421         // Returns the register storing &quot;this&quot;
 422         RegisterID* thisRegister() { return &amp;m_thisRegister; }
 423         RegisterID* argumentsRegister() { return m_argumentsRegister; }
 424         RegisterID* newTarget()
 425         {
<a name="18" id="anc18"></a><span class="line-added"> 426             ASSERT(m_newTargetRegister);</span>
 427             return m_newTargetRegister;
 428         }
 429 
 430         RegisterID* scopeRegister() { return m_scopeRegister; }
 431 
 432         RegisterID* generatorRegister() { return m_generatorRegister; }
 433 
 434         RegisterID* promiseCapabilityRegister() { return m_promiseCapabilityRegister; }
 435 
 436         // Returns the next available temporary register. Registers returned by
 437         // newTemporary require a modified form of reference counting: any
 438         // register with a refcount of 0 is considered &quot;available&quot;, meaning that
 439         // the next instruction may overwrite it.
 440         RegisterID* newTemporary();
 441 
 442         // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
 443         // &quot;suggestion&quot; is a temporary. This function is helpful in situations
 444         // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
 445         // the next instruction to overwrite it anyway.
 446         RegisterID* newTemporaryOr(RegisterID* suggestion) { return suggestion-&gt;isTemporary() ? suggestion : newTemporary(); }
 447 
 448         // Functions for handling of dst register
 449 
 450         RegisterID* ignoredResult() { return &amp;m_ignoredResultRegister; }
 451 
 452         // This will be allocated in the temporary region of registers, but it will
 453         // not be marked as a temporary. This will ensure that finalDestination() does
 454         // not overwrite a block scope variable that it mistakes as a temporary. These
 455         // registers can be (and are) reclaimed when the lexical scope they belong to
 456         // is no longer on the symbol table stack.
 457         RegisterID* newBlockScopeVariable();
 458 
 459         // Returns a place to write intermediate values of an operation
 460         // which reuses dst if it is safe to do so.
 461         RegisterID* tempDestination(RegisterID* dst)
 462         {
 463             return (dst &amp;&amp; dst != ignoredResult() &amp;&amp; dst-&gt;isTemporary()) ? dst : newTemporary();
 464         }
 465 
 466         // Returns the place to write the final output of an operation.
 467         RegisterID* finalDestination(RegisterID* originalDst, RegisterID* tempDst = 0)
 468         {
 469             if (originalDst &amp;&amp; originalDst != ignoredResult())
 470                 return originalDst;
 471             ASSERT(tempDst != ignoredResult());
 472             if (tempDst &amp;&amp; tempDst-&gt;isTemporary())
 473                 return tempDst;
 474             return newTemporary();
 475         }
 476 
 477         RegisterID* destinationForAssignResult(RegisterID* dst)
 478         {
 479             if (dst &amp;&amp; dst != ignoredResult())
 480                 return dst-&gt;isTemporary() ? dst : newTemporary();
 481             return 0;
 482         }
 483 
 484         // Moves src to dst if dst is not null and is different from src, otherwise just returns src.
 485         RegisterID* move(RegisterID* dst, RegisterID* src)
 486         {
 487             return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
 488         }
 489 
 490         Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
 491         Ref&lt;Label&gt; newLabel();
 492         Ref&lt;Label&gt; newEmittedLabel();
 493 
 494         void emitNode(RegisterID* dst, StatementNode* n)
 495         {
 496             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 497             return emitNodeInTailPosition(dst, n);
 498         }
 499 
 500         void emitNodeInTailPosition(RegisterID* dst, StatementNode* n)
 501         {
 502             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 503             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<a name="19" id="anc19"></a><span class="line-modified"> 504             if (UNLIKELY(!m_vm.isSafeToRecurse())) {</span>
 505                 emitThrowExpressionTooDeepException();
 506                 return;
 507             }
 508             if (UNLIKELY(n-&gt;needsDebugHook()))
 509                 emitDebugHook(n);
 510             n-&gt;emitBytecode(*this, dst);
 511         }
 512 
 513         void recordOpcode(OpcodeID);
 514 
 515         ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
 516         {
 517             return m_codeBlock-&gt;metadata().addEntry(opcodeID);
 518         }
 519 
 520         void emitNode(StatementNode* n)
 521         {
 522             emitNode(nullptr, n);
 523         }
 524 
 525         void emitNodeInTailPosition(StatementNode* n)
 526         {
 527             emitNodeInTailPosition(nullptr, n);
 528         }
 529 
 530         RegisterID* emitNode(RegisterID* dst, ExpressionNode* n)
 531         {
 532             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 533             return emitNodeInTailPosition(dst, n);
 534         }
 535 
 536         RegisterID* emitNodeInTailPosition(RegisterID* dst, ExpressionNode* n)
 537         {
 538             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 539             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
<a name="20" id="anc20"></a><span class="line-modified"> 540             if (UNLIKELY(!m_vm.isSafeToRecurse()))</span>
 541                 return emitThrowExpressionTooDeepException();
 542             if (UNLIKELY(n-&gt;needsDebugHook()))
 543                 emitDebugHook(n);
 544             return n-&gt;emitBytecode(*this, dst);
 545         }
 546 
 547         RegisterID* emitNode(ExpressionNode* n)
 548         {
 549             return emitNode(nullptr, n);
 550         }
 551 
 552         RegisterID* emitNodeInTailPosition(ExpressionNode* n)
 553         {
 554             return emitNodeInTailPosition(nullptr, n);
 555         }
 556 
 557         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype)
 558         {
 559             ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
<a name="21" id="anc21"></a><span class="line-modified"> 560             if (UNLIKELY(!m_vm.isSafeToRecurse()))</span>
 561                 return emitThrowExpressionTooDeepException();
 562             if (UNLIKELY(n-&gt;needsDebugHook()))
 563                 emitDebugHook(n);
 564             return n-&gt;emitBytecode(*this, constructor, prototype);
 565         }
 566 
 567         RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
 568         {
 569             if (node-&gt;isString()) {
 570                 if (Optional&lt;uint32_t&gt; index = parseIndex(static_cast&lt;StringNode*&gt;(node)-&gt;value()))
 571                     return emitLoad(dst, jsNumber(index.value()));
 572             }
 573             return emitNode(dst, node);
 574         }
 575 
 576         RegisterID* emitNodeForProperty(ExpressionNode* n)
 577         {
 578             return emitNodeForProperty(nullptr, n);
 579         }
 580 
 581         void emitNodeInConditionContext(ExpressionNode* n, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 582         {
<a name="22" id="anc22"></a><span class="line-modified"> 583             if (UNLIKELY(!m_vm.isSafeToRecurse())) {</span>
 584                 emitThrowExpressionTooDeepException();
 585                 return;
 586             }
 587             n-&gt;emitBytecodeInConditionContext(*this, trueTarget, falseTarget, fallThroughMode);
 588         }
 589 
 590         void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 591         {
 592             ASSERT(divot.offset &gt;= divotStart.offset);
 593             ASSERT(divotEnd.offset &gt;= divot.offset);
 594 
 595             int sourceOffset = m_scopeNode-&gt;source().startOffset();
 596             unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
 597 
 598             int divotOffset = divot.offset - sourceOffset;
 599             int startOffset = divot.offset - divotStart.offset;
 600             int endOffset = divotEnd.offset - divot.offset;
 601 
 602             unsigned line = divot.line;
 603             ASSERT(line &gt;= firstLine);
 604             line -= firstLine;
 605 
 606             int lineStart = divot.lineStartOffset;
 607             if (lineStart &gt; sourceOffset)
 608                 lineStart -= sourceOffset;
 609             else
 610                 lineStart = 0;
 611 
 612             if (divotOffset &lt; lineStart)
 613                 return;
 614 
 615             unsigned column = divotOffset - lineStart;
 616 
 617             unsigned instructionOffset = instructions().size();
 618             if (!m_isBuiltinFunction)
 619                 m_codeBlock-&gt;addExpressionInfo(instructionOffset, divotOffset, startOffset, endOffset, line, column);
 620         }
 621 
 622 
 623         ALWAYS_INLINE bool leftHandSideNeedsCopy(bool rightHasAssignments, bool rightIsPure)
 624         {
 625             return (m_codeType != FunctionCode || rightHasAssignments) &amp;&amp; !rightIsPure;
 626         }
 627 
 628         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSide(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 629         {
 630             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 631                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 632                 emitNode(dst.get(), n);
 633                 return dst;
 634             }
 635 
 636             return emitNode(n);
 637         }
 638 
 639         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSideForProperty(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 640         {
 641             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 642                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 643                 emitNodeForProperty(dst.get(), n);
 644                 return dst;
 645             }
 646 
 647             return emitNodeForProperty(n);
 648         }
 649 
 650         void hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName);
 651 
 652     private:
 653         void emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 654     public:
 655 
 656         // This doesn&#39;t emit expression info. If using this, make sure you shouldn&#39;t be emitting text offset.
 657         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag);
 658         // These variables are associated with variables in a program. They could be Locals, LocalClosureVar, or ClosureVar.
 659         void emitProfileType(RegisterID* registerToProfile, const Variable&amp;, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 660 
 661         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 662         // These are not associated with variables and don&#39;t have a global id.
 663         void emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 664 
 665         void emitProfileControlFlow(int);
 666 
 667         RegisterID* emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp;);
 668         RegisterID* ensureThis();
 669         void emitLoadThisFromArrowFunctionLexicalEnvironment();
 670         RegisterID* emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 671 
 672         unsigned addConstantIndex();
 673         RegisterID* emitLoad(RegisterID* dst, bool);
 674         RegisterID* emitLoad(RegisterID* dst, const Identifier&amp;);
 675         RegisterID* emitLoad(RegisterID* dst, JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
 676         RegisterID* emitLoad(RegisterID* dst, IdentifierSet&amp; excludedList);
 677 
 678         template&lt;typename UnaryOp, typename = std::enable_if_t&lt;UnaryOp::opcodeID != op_negate&gt;&gt;
 679         RegisterID* emitUnaryOp(RegisterID* dst, RegisterID* src)
 680         {
 681             UnaryOp::emit(this, dst, src);
 682             return dst;
 683         }
 684 
 685         RegisterID* emitUnaryOp(OpcodeID, RegisterID* dst, RegisterID* src, OperandTypes);
 686 
 687         template&lt;typename BinaryOp&gt;
 688         std::enable_if_t&lt;
 689             BinaryOp::opcodeID != op_add
 690             &amp;&amp; BinaryOp::opcodeID != op_mul
 691             &amp;&amp; BinaryOp::opcodeID != op_sub
 692             &amp;&amp; BinaryOp::opcodeID != op_div,
 693             RegisterID*&gt;
 694         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes)
 695         {
 696             BinaryOp::emit(this, dst, src1, src2);
 697             return dst;
 698         }
 699 
 700         template&lt;typename BinaryOp&gt;
 701         std::enable_if_t&lt;
 702             BinaryOp::opcodeID == op_add
 703             || BinaryOp::opcodeID == op_mul
 704             || BinaryOp::opcodeID == op_sub
 705             || BinaryOp::opcodeID == op_div,
 706             RegisterID*&gt;
 707         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
 708         {
 709             BinaryOp::emit(this, dst, src1, src2, types);
 710             return dst;
 711         }
 712 
 713         RegisterID* emitBinaryOp(OpcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes);
 714 
 715         template&lt;typename EqOp&gt;
<a name="23" id="anc23"></a><span class="line-modified"> 716         RegisterID* emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)</span>
<span class="line-added"> 717         {</span>
<span class="line-added"> 718             if (!emitEqualityOpImpl(dst, src1, src2))</span>
<span class="line-added"> 719                 EqOp::emit(this, dst, src1, src2);</span>
<span class="line-added"> 720             return dst;</span>
<span class="line-added"> 721         }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723         bool emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2);</span>
<span class="line-added"> 724 </span>
 725         RegisterID* emitCreateThis(RegisterID* dst);
 726         void emitTDZCheck(RegisterID* target);
 727         bool needsTDZCheck(const Variable&amp;);
 728         void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
 729         void liftTDZCheckIfPossible(const Variable&amp;);
 730         RegisterID* emitNewObject(RegisterID* dst);
 731         RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
 732         RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
 733         // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
 734         RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
 735         RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
 736 
 737         RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
 738         RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
 739         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource);
 740         RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
 741         RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
 742         RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
 743 
 744         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
 745 
 746         RegisterID* moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant);
 747         RegisterID* moveEmptyValue(RegisterID* dst);
 748 
 749         RegisterID* emitToNumber(RegisterID* dst, RegisterID* src);
 750         RegisterID* emitToString(RegisterID* dst, RegisterID* src);
 751         RegisterID* emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message);
 752         RegisterID* emitInc(RegisterID* srcDst);
 753         RegisterID* emitDec(RegisterID* srcDst);
 754 
 755         RegisterID* emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue);
 756         RegisterID* emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype);
 757         RegisterID* emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue);
 758         RegisterID* emitTypeOf(RegisterID* dst, RegisterID* src);
 759         RegisterID* emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base);
 760         RegisterID* emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 761 
 762         RegisterID* emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 763         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 764         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property);
 765         RegisterID* emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 766         RegisterID* emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value);
 767         RegisterID* emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value);
 768         RegisterID* emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType);
 769         RegisterID* emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp;);
 770         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 771         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property);
 772         RegisterID* emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 773         RegisterID* emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value);
 774         RegisterID* emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 775         RegisterID* emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 776 
 777         void emitSuperSamplerBegin();
 778         void emitSuperSamplerEnd();
 779 
 780         RegisterID* emitIdWithProfile(RegisterID* src, SpeculatedType profile);
 781         void emitUnreachable();
 782 
 783         void emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* getter);
 784         void emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* setter);
 785         void emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter);
 786         void emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* getter);
 787         void emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* setter);
 788 
 789         RegisterID* emitGetArgument(RegisterID* dst, int32_t index);
 790 
 791         // Initialize object with generator fields (@generatorThis, @generatorNext, @generatorState, @generatorFrame)
 792         void emitPutGeneratorFields(RegisterID* nextFunction);
 793 
 794         void emitPutAsyncGeneratorFields(RegisterID* nextFunction);
 795 
 796         ExpectedFunction expectedFunctionForIdentifier(const Identifier&amp;);
 797         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 798         RegisterID* emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 799         RegisterID* emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 800         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 801         RegisterID* emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 802         RegisterID* emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 803 
 804         enum PropertyDescriptorOption {
 805             PropertyConfigurable = 1,
 806             PropertyWritable     = 1 &lt;&lt; 1,
 807             PropertyEnumerable   = 1 &lt;&lt; 2,
 808         };
 809         void emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
 810             RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp;);
 811 
 812         void emitEnumeration(ThrowableExpressionData* enumerationNode, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* = nullptr, RegisterID* forLoopSymbolTable = nullptr);
 813 
 814         RegisterID* emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode*);
 815         RegisterID* emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property);
 816 
 817         enum class ReturnFrom { Normal, Finally };
 818         RegisterID* emitReturn(RegisterID* src, ReturnFrom = ReturnFrom::Normal);
 819         RegisterID* emitEnd(RegisterID* src);
 820 
 821         RegisterID* emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 822         RegisterID* emitStrcat(RegisterID* dst, RegisterID* src, int count);
 823         void emitToPrimitive(RegisterID* dst, RegisterID* src);
 824 
 825         ResolveType resolveType();
 826         RegisterID* emitResolveConstantLocal(RegisterID* dst, const Variable&amp;);
 827         RegisterID* emitResolveScope(RegisterID* dst, const Variable&amp;);
 828         RegisterID* emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp;, ResolveMode);
 829         RegisterID* emitPutToScope(RegisterID* scope, const Variable&amp;, RegisterID* value, ResolveMode, InitializationMode);
 830 
 831         RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
 832 
 833         RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
 834 
 835         void emitLabel(Label&amp;);
 836         void emitLoopHint();
 837         void emitJump(Label&amp; target);
 838         void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
 839         void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
 840         void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
 841         void emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target);
 842 
 843         template&lt;typename BinOp, typename JmpOp&gt;
 844         bool fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands = false);
 845 
 846         template&lt;typename UnaryOp, typename JmpOp&gt;
 847         bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
 848 
 849         void emitEnter();
<a name="24" id="anc24"></a>
 850 
 851         RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 852         RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
 853         RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 854         RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
 855         RegisterID* emitGetEnumerableLength(RegisterID* dst, RegisterID* base);
 856         RegisterID* emitGetStructurePropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length);
 857         RegisterID* emitGetGenericPropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length, RegisterID* structureEnumerator);
 858         RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 859         RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 860         RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
 861 
 862         RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
 863         RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
 864         RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
 865         RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
 866         RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
 867         RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
 868         RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
 869         RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
 870         RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
 871         RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
 872         RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
 873         RegisterID* emitIsDerivedArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, DerivedArrayType); }
 874         void emitRequireObjectCoercible(RegisterID* value, const String&amp; error);
 875 
 876         RegisterID* emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, JSC::EmitAwait = JSC::EmitAwait::No);
 877         RegisterID* emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node);
 878         void emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait = EmitAwait::No);
 879 
 880         RegisterID* emitRestParameter(RegisterID* result, unsigned numParametersToSkip);
 881 
 882         bool emitReadOnlyExceptionIfNeeded(const Variable&amp;);
 883 
 884         // Start a try block. &#39;start&#39; must have been emitted.
 885         TryData* pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType);
 886         // End a try block. &#39;end&#39; must have been emitted.
 887         void popTry(TryData*, Label&amp; end);
<a name="25" id="anc25"></a><span class="line-modified"> 888 </span>
<span class="line-added"> 889         void emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);</span>
<span class="line-added"> 890         void emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData*);</span>
 891 
 892     private:
 893         static const int CurrentLexicalScopeIndex = -2;
 894         static const int OutermostLexicalScopeIndex = -1;
 895 
 896         int currentLexicalScopeIndex() const
 897         {
 898             int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
 899             ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
 900             ASSERT(size &gt;= 0);
 901             if (!size)
 902                 return OutermostLexicalScopeIndex;
 903             return size - 1;
 904         }
 905 
<a name="26" id="anc26"></a><span class="line-added"> 906         void emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);</span>
<span class="line-added"> 907 </span>
 908     public:
 909         void restoreScopeRegister();
 910         void restoreScopeRegister(int lexicalScopeIndex);
 911 
 912         int labelScopeDepthToLexicalScopeIndex(int labelScopeDepth);
 913 
 914         void emitThrow(RegisterID*);
 915         RegisterID* emitArgumentCount(RegisterID*);
 916 
 917         void emitThrowStaticError(ErrorType, RegisterID*);
 918         void emitThrowStaticError(ErrorType, const Identifier&amp; message);
 919         void emitThrowReferenceError(const String&amp; message);
 920         void emitThrowTypeError(const String&amp; message);
 921         void emitThrowTypeError(const Identifier&amp; message);
 922         void emitThrowRangeError(const Identifier&amp; message);
 923         void emitThrowOutOfMemoryError();
 924 
 925         void emitPushCatchScope(VariableEnvironment&amp;);
 926         void emitPopCatchScope(VariableEnvironment&amp;);
 927 
 928         RegisterID* emitGetIterator(RegisterID*, ThrowableExpressionData*);
 929         RegisterID* emitGetAsyncIterator(RegisterID*, ThrowableExpressionData*);
 930 
 931         void emitAwait(RegisterID*);
 932         void emitGetScope();
 933         RegisterID* emitPushWithScope(RegisterID* objectScope);
 934         void emitPopWithScope();
 935         void emitPutThisToArrowFunctionContextScope();
 936         void emitPutNewTargetToArrowFunctionContextScope();
 937         void emitPutDerivedConstructorToArrowFunctionContextScope();
 938         RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 939 
 940         void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
 941         void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
 942         void emitDebugHook(StatementNode*);
 943         void emitDebugHook(ExpressionNode*);
 944         void emitWillLeaveCallFrameDebugHook();
 945 
<a name="27" id="anc27"></a><span class="line-modified"> 946         void emitLoad(RegisterID* completionTypeRegister, CompletionType type)</span>


































 947         {
<a name="28" id="anc28"></a><span class="line-modified"> 948             emitLoad(completionTypeRegister, JSValue(static_cast&lt;int&gt;(type)));</span>
 949         }
 950 
 951         template&lt;typename CompareOp&gt;
 952         void emitJumpIf(RegisterID* completionTypeRegister, CompletionType, Label&amp; jumpTarget);
 953 
 954         bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
 955         bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
<a name="29" id="anc29"></a><span class="line-modified"> 956         void emitFinallyCompletion(FinallyContext&amp;, Label&amp; normalCompletionLabel);</span>




 957 
 958     public:
<a name="30" id="anc30"></a><span class="line-modified"> 959         void pushFinallyControlFlowScope(FinallyContext&amp;);</span>
<span class="line-modified"> 960         void popFinallyControlFlowScope();</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962         void pushOptionalChainTarget();</span>
<span class="line-added"> 963         void popOptionalChainTarget();</span>
<span class="line-added"> 964         void popOptionalChainTarget(RegisterID* dst, bool isDelete);</span>
<span class="line-added"> 965         void emitOptionalCheck(RegisterID* src);</span>
 966 
 967         void pushIndexedForInScope(RegisterID* local, RegisterID* index);
 968         void popIndexedForInScope(RegisterID* local);
 969         void pushStructureForInScope(RegisterID* local, RegisterID* index, RegisterID* property, RegisterID* enumerator);
 970         void popStructureForInScope(RegisterID* local);
 971 
 972         LabelScope* breakTarget(const Identifier&amp;);
 973         LabelScope* continueTarget(const Identifier&amp;);
 974 
 975         void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
 976         void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
 977 
 978         void emitYieldPoint(RegisterID*, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason);
 979 
 980         void emitGeneratorStateLabel();
 981         void emitGeneratorStateChange(int32_t state);
 982         RegisterID* emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason = JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);
 983         RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
 984         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State)]; }
 985         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Value)]; }
 986         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::ResumeMode)]; }
 987         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame)]; }
 988 
 989         CodeType codeType() const { return m_codeType; }
 990 
 991         bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
 992 
<a name="31" id="anc31"></a><span class="line-modified"> 993         bool shouldEmitDebugHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger) &amp;&amp; !m_isBuiltinFunction; }</span>
<span class="line-added"> 994         bool shouldEmitTypeProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }</span>
<span class="line-added"> 995         bool shouldEmitControlFlowProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }</span>
 996 
 997         bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
 998 
 999         SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
1000 
1001         bool isBuiltinFunction() const { return m_isBuiltinFunction; }
1002 
1003         OpcodeID lastOpcodeID() const { return m_lastOpcodeID; }
1004 
1005         bool isDerivedConstructorContext() { return m_derivedContextType == DerivedContextType::DerivedConstructorContext; }
1006         bool isDerivedClassContext() { return m_derivedContextType == DerivedContextType::DerivedMethodContext; }
1007         bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
1008 
1009         enum class TDZCheckOptimization { Optimize, DoNotOptimize };
1010         enum class NestedScopeType { IsNested, IsNotNested };
1011     private:
1012         enum class TDZRequirement { UnderTDZ, NotUnderTDZ };
1013         enum class ScopeType { CatchScope, LetConstScope, FunctionNameScope };
1014         enum class ScopeRegisterType { Var, Block };
1015         void pushLexicalScopeInternal(VariableEnvironment&amp;, TDZCheckOptimization, NestedScopeType, RegisterID** constantSymbolTableResult, TDZRequirement, ScopeType, ScopeRegisterType);
1016         void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
1017         void popLexicalScopeInternal(VariableEnvironment&amp;);
1018         template&lt;typename LookUpVarKindFunctor&gt;
1019         bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
1020         void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
1021         void emitPopScope(RegisterID* dst, RegisterID* scope);
1022         RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
1023         void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
1024         void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
1025 
1026         bool isNewTargetUsedInInnerArrowFunction();
1027         bool isArgumentsUsedInInnerArrowFunction();
1028 
1029         void emitToThis();
1030 
1031         RegisterID* emitMove(RegisterID* dst, RegisterID* src);
1032 
<a name="32" id="anc32"></a><span class="line-added">1033         bool canDoPeepholeOptimization() const { return m_lastOpcodeID != op_end; }</span>
<span class="line-added">1034 </span>
1035     public:
1036         bool isSuperUsedInInnerArrowFunction();
1037         bool isSuperCallUsedInInnerArrowFunction();
1038         bool isThisUsedInInnerArrowFunction();
1039         void pushLexicalScope(VariableEnvironmentNode*, TDZCheckOptimization, NestedScopeType = NestedScopeType::IsNotNested, RegisterID** constantSymbolTableResult = nullptr, bool shouldInitializeBlockScopedFunctions = true);
1040         void popLexicalScope(VariableEnvironmentNode*);
1041         void prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode*, RegisterID* loopSymbolTable);
1042         int labelScopeDepth() const;
1043         UnlinkedArrayProfile newArrayProfile();
1044 
1045     private:
1046         ParserError generate();
1047         void reclaimFreeRegisters();
1048         Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
1049 
1050         RegisterID* kill(RegisterID* dst)
1051         {
1052             m_staticPropertyAnalyzer.kill(dst);
1053             return dst;
1054         }
1055 
1056         void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
1057         ALWAYS_INLINE void rewind();
1058 
1059         void allocateCalleeSaveSpace();
1060         void allocateAndEmitScope();
1061 
1062         template&lt;typename JumpOp&gt;
1063         void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
1064 
1065         using BigIntMapEntry = std::tuple&lt;UniquedStringImpl*, uint8_t, bool&gt;;
1066 
1067         using NumberMap = HashMap&lt;double, JSValue&gt;;
1068         using IdentifierStringMap = HashMap&lt;UniquedStringImpl*, JSString*, IdentifierRepHash&gt;;
1069         using IdentifierBigIntMap = HashMap&lt;BigIntMapEntry, JSBigInt*&gt;;
<a name="33" id="anc33"></a><span class="line-modified">1070         using TemplateObjectDescriptorSet = HashSet&lt;Ref&lt;TemplateObjectDescriptor&gt;&gt;;</span>
<span class="line-added">1071         using TemplateDescriptorMap = HashMap&lt;uint64_t, JSTemplateObjectDescriptor*, WTF::IntHash&lt;uint64_t&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;uint64_t&gt;&gt;;</span>
1072 
1073         // Helper for emitCall() and emitConstruct(). This works because the set of
1074         // expected functions have identical behavior for both call and construct
1075         // (i.e. &quot;Object()&quot; is identical to &quot;new Object()&quot;).
1076         ExpectedFunction emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, Label&amp; done);
1077 
1078         template&lt;typename CallOp&gt;
1079         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1080 
1081         RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
1082         RegisterID* newRegister();
1083 
1084         // Adds an anonymous local var slot. To give this slot a name, add it to symbolTable().
1085         RegisterID* addVar()
1086         {
1087             ++m_codeBlock-&gt;m_numVars;
1088             RegisterID* result = newRegister();
1089             ASSERT(VirtualRegister(result-&gt;index()).toLocal() == m_codeBlock-&gt;m_numVars - 1);
1090             result-&gt;ref(); // We should never free this slot.
1091             return result;
1092         }
1093 
1094         // Initializes the stack form the parameter; does nothing for the symbol table.
1095         RegisterID* initializeNextParameter();
1096         UniquedStringImpl* visibleNameForParameter(DestructuringPatternNode*);
1097 
1098         RegisterID&amp; registerFor(VirtualRegister reg)
1099         {
1100             if (reg.isLocal())
1101                 return m_calleeLocals[reg.toLocal()];
1102 
1103             if (reg.offset() == CallFrameSlot::callee)
1104                 return m_calleeRegister;
1105 
1106             ASSERT(m_parameters.size());
1107             return m_parameters[reg.toArgument()];
1108         }
1109 
1110         bool hasConstant(const Identifier&amp;) const;
1111         unsigned addConstant(const Identifier&amp;);
1112         RegisterID* addConstantValue(JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
1113         RegisterID* addConstantEmptyValue();
1114 
1115         UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
1116         {
1117             DerivedContextType newDerivedContextType = DerivedContextType::None;
1118 
1119             if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
1120                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext())
1121                     newDerivedContextType = DerivedContextType::DerivedConstructorContext;
1122                 else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
1123                     newDerivedContextType = DerivedContextType::DerivedMethodContext;
1124             }
1125 
<a name="34" id="anc34"></a><span class="line-modified">1126             Optional&lt;CompactVariableMap::Handle&gt; optionalVariablesUnderTDZ = getVariablesUnderTDZ();</span>
1127 
1128             // FIXME: These flags, ParserModes and propagation to XXXCodeBlocks should be reorganized.
1129             // https://bugs.webkit.org/show_bug.cgi?id=151547
1130             SourceParseMode parseMode = metadata-&gt;parseMode();
1131             ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
1132             if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
1133                 constructAbility = ConstructAbility::CanConstruct;
1134 
<a name="35" id="anc35"></a><span class="line-modified">1135             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(optionalVariablesUnderTDZ), newDerivedContextType);</span>
1136         }
1137 
<a name="36" id="anc36"></a><span class="line-modified">1138         Optional&lt;CompactVariableMap::Handle&gt; getVariablesUnderTDZ();</span>
1139 
1140         RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1141         template&lt;typename CallOp&gt;
1142         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1143 
1144         void emitLogShadowChickenPrologueIfNecessary();
1145         void emitLogShadowChickenTailIfNecessary();
1146 
1147         void initializeParameters(FunctionParameters&amp;);
1148         void initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables);
1149         void initializeDefaultParameterValuesAndSetupFunctionScopeStack(FunctionParameters&amp;, bool isSimpleParameterList, FunctionNode*, SymbolTable*, int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope);
1150         void initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable = nullptr, bool canReuseLexicalEnvironment = false);
1151         bool needsDerivedConstructorInArrowFunctionLexicalEnvironment();
1152 
1153         enum class TDZNecessityLevel {
1154             NotNeeded,
1155             Optimize,
1156             DoNotOptimize
1157         };
1158         typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, TDZNecessityLevel, IdentifierRepHash&gt; TDZMap;
1159 
1160     public:
1161         JSString* addStringConstant(const Identifier&amp;);
1162         JSValue addBigIntConstant(const Identifier&amp;, uint8_t radix, bool sign);
<a name="37" id="anc37"></a><span class="line-modified">1163         RegisterID* addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp;, int);</span>
1164 
1165         const InstructionStream&amp; instructions() const { return m_writer; }
1166 
1167         RegisterID* emitThrowExpressionTooDeepException();
1168 
1169         void write(uint8_t byte) { m_writer.write(byte); }
<a name="38" id="anc38"></a><span class="line-added">1170         void write(uint16_t h) { m_writer.write(h); }</span>
1171         void write(uint32_t i) { m_writer.write(i); }
<a name="39" id="anc39"></a><span class="line-modified">1172         void write(int8_t byte) { m_writer.write(static_cast&lt;uint8_t&gt;(byte)); }</span>
<span class="line-added">1173         void write(int16_t h) { m_writer.write(static_cast&lt;uint16_t&gt;(h)); }</span>
<span class="line-added">1174         void write(int32_t i) { m_writer.write(static_cast&lt;uint32_t&gt;(i)); }</span>
<span class="line-added">1175         void alignWideOpcode16();</span>
<span class="line-added">1176         void alignWideOpcode32();</span>
1177 
1178         class PreservedTDZStack {
1179         private:
1180             Vector&lt;TDZMap&gt; m_preservedTDZStack;
1181             friend class BytecodeGenerator;
1182         };
1183 
1184         void preserveTDZStack(PreservedTDZStack&amp;);
1185         void restoreTDZStack(const PreservedTDZStack&amp;);
1186 
1187         template&lt;typename Func&gt;
1188         void withWriter(InstructionStreamWriter&amp; writer, const Func&amp; fn)
1189         {
1190             auto prevLastOpcodeID = m_lastOpcodeID;
1191             auto prevLastInstruction = m_lastInstruction;
1192             m_writer.swap(writer);
1193             m_lastOpcodeID = op_end;
1194             m_lastInstruction = m_writer.ref();
1195             fn();
1196             m_writer.swap(writer);
1197             m_lastOpcodeID = prevLastOpcodeID;
1198             m_lastInstruction = prevLastInstruction;
1199         }
1200 
1201     private:
1202         InstructionStreamWriter m_writer;
1203 
<a name="40" id="anc40"></a><span class="line-modified">1204         OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;</span>
1205 
1206         struct LexicalScopeStackEntry {
1207             SymbolTable* m_symbolTable;
1208             RegisterID* m_scope;
1209             bool m_isWithScope;
1210             int m_symbolTableConstantIndex;
1211         };
1212         Vector&lt;LexicalScopeStackEntry&gt; m_lexicalScopeStack;
1213 
1214         Vector&lt;TDZMap&gt; m_TDZStack;
1215         Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
1216         void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
1217 
1218         ScopeNode* const m_scopeNode;
1219         Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;
1220 
1221         // Some of these objects keep pointers to one another. They are arranged
1222         // to ensure a sane destruction order that avoids references to freed memory.
1223         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
1224         RegisterID m_ignoredResultRegister;
1225         RegisterID m_thisRegister;
1226         RegisterID m_calleeRegister;
1227         RegisterID* m_scopeRegister { nullptr };
1228         RegisterID* m_topMostScope { nullptr };
1229         RegisterID* m_argumentsRegister { nullptr };
1230         RegisterID* m_lexicalEnvironmentRegister { nullptr };
1231         RegisterID* m_generatorRegister { nullptr };
1232         RegisterID* m_emptyValueRegister { nullptr };
1233         RegisterID* m_newTargetRegister { nullptr };
1234         RegisterID* m_isDerivedConstuctor { nullptr };
1235         RegisterID* m_linkTimeConstantRegisters[LinkTimeConstantCount];
1236         RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
1237         RegisterID* m_promiseCapabilityRegister { nullptr };
1238 
<a name="41" id="anc41"></a>


1239         FinallyContext* m_currentFinallyContext { nullptr };
1240 
1241         SegmentedVector&lt;RegisterID*, 16&gt; m_localRegistersForCalleeSaveRegisters;
1242         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;
1243         SegmentedVector&lt;RegisterID, 32&gt; m_calleeLocals;
1244         SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
1245         SegmentedVector&lt;Label, 32&gt; m_labels;
1246         SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
1247         unsigned m_finallyDepth { 0 };
<a name="42" id="anc42"></a><span class="line-modified">1248         unsigned m_localScopeDepth { 0 };</span>
1249         const CodeType m_codeType;
1250 
<a name="43" id="anc43"></a><span class="line-modified">1251         unsigned localScopeDepth() const;</span>
1252         void pushLocalControlFlowScope();
1253         void popLocalControlFlowScope();
1254 
1255         // FIXME: Restore overflow checking with UnsafeVectorOverflow once SegmentVector supports it.
1256         // https://bugs.webkit.org/show_bug.cgi?id=165980
1257         SegmentedVector&lt;ControlFlowScope, 16&gt; m_controlFlowScopeStack;
1258         Vector&lt;SwitchInfo&gt; m_switchContextStack;
1259         Vector&lt;Ref&lt;ForInContext&gt;&gt; m_forInContextStack;
1260         Vector&lt;TryContext&gt; m_tryContextStack;
1261         unsigned m_yieldPoints { 0 };
1262 
1263         Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
1264         int m_generatorFrameSymbolTableIndex { 0 };
1265 
1266         enum FunctionVariableType : uint8_t { NormalFunctionVariable, TopLevelFunctionVariable };
1267         Vector&lt;std::pair&lt;FunctionMetadataNode*, FunctionVariableType&gt;&gt; m_functionsToInitialize;
1268         bool m_needToInitializeArguments { false };
1269         RestParameterNode* m_restParameter { nullptr };
1270 
1271         Vector&lt;TryRange&gt; m_tryRanges;
1272         SegmentedVector&lt;TryData, 8&gt; m_tryData;
1273 
<a name="44" id="anc44"></a><span class="line-added">1274         Vector&lt;Ref&lt;Label&gt;&gt; m_optionalChainTargetStack;</span>
<span class="line-added">1275 </span>
1276         int m_nextConstantOffset { 0 };
1277 
1278         typedef HashMap&lt;FunctionMetadataNode*, unsigned&gt; FunctionOffsetMap;
1279         FunctionOffsetMap m_functionOffsets;
1280 
1281         // Constant pool
1282         IdentifierMap m_identifierMap;
1283 
1284         typedef HashMap&lt;EncodedJSValueWithRepresentation, unsigned, EncodedJSValueWithRepresentationHash, EncodedJSValueWithRepresentationHashTraits&gt; JSValueMap;
1285         JSValueMap m_jsValueMap;
1286         IdentifierStringMap m_stringMap;
1287         IdentifierBigIntMap m_bigIntMap;
<a name="45" id="anc45"></a><span class="line-modified">1288         TemplateObjectDescriptorSet m_templateObjectDescriptorSet;</span>
<span class="line-added">1289         TemplateDescriptorMap m_templateDescriptorMap;</span>
1290 
1291         StaticPropertyAnalyzer m_staticPropertyAnalyzer;
1292 
<a name="46" id="anc46"></a><span class="line-modified">1293         VM&amp; m_vm;</span>
1294 
1295         OpcodeID m_lastOpcodeID = op_end;
1296         InstructionStream::MutableRef m_lastInstruction { m_writer.ref() };
1297 
1298         bool m_usesExceptions { false };
1299         bool m_expressionTooDeep { false };
1300         bool m_isBuiltinFunction { false };
1301         bool m_usesNonStrictEval { false };
1302         bool m_inTailPosition { false };
1303         bool m_needsToUpdateArrowFunctionContext;
<a name="47" id="anc47"></a><span class="line-added">1304         bool m_hasCachedVariablesUnderTDZ { false };</span>
1305         DerivedContextType m_derivedContextType { DerivedContextType::None };
1306 
1307         CompactVariableMap::Handle m_cachedVariablesUnderTDZ;
1308 
<a name="48" id="anc48"></a><span class="line-modified">1309         struct CatchEntry {</span>
<span class="line-modified">1310             TryData* tryData;</span>
<span class="line-added">1311             VirtualRegister exceptionRegister;</span>
<span class="line-added">1312             VirtualRegister thrownValueRegister;</span>
<span class="line-added">1313             VirtualRegister completionTypeRegister;</span>
<span class="line-added">1314         };</span>
<span class="line-added">1315         Vector&lt;CatchEntry&gt; m_exceptionHandlersToEmit;</span>
1316     };
1317 
<a name="49" id="anc49"></a>
1318 } // namespace JSC
1319 
1320 namespace WTF {
1321 
1322 void printInternal(PrintStream&amp;, JSC::Variable::VariableKind);
1323 
1324 } // namespace WTF
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>