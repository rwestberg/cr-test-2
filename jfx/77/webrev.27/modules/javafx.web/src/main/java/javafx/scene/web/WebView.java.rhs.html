<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/WebView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import com.sun.java.scene.web.WebViewHelper;
  29 import javafx.beans.property.BooleanProperty;
  30 import javafx.beans.property.DoubleProperty;
  31 import javafx.beans.property.ObjectProperty;
  32 import javafx.beans.property.ReadOnlyDoubleProperty;
  33 import javafx.beans.property.ReadOnlyDoubleWrapper;
  34 import javafx.collections.ObservableList;
  35 import javafx.css.CssMetaData;
  36 import javafx.css.Styleable;
  37 import javafx.css.StyleableBooleanProperty;
  38 import javafx.css.StyleableDoubleProperty;
  39 import javafx.css.StyleableObjectProperty;
  40 import javafx.css.StyleableProperty;
  41 import javafx.event.EventHandler;
  42 import javafx.event.EventType;
  43 import javafx.geometry.NodeOrientation;
  44 import javafx.geometry.Point2D;
  45 import javafx.scene.Node;
  46 import javafx.scene.Parent;
  47 import javafx.scene.Scene;
  48 import javafx.scene.input.DataFormat;
  49 import javafx.scene.input.DragEvent;
  50 import javafx.scene.input.Dragboard;
  51 import javafx.scene.input.InputMethodEvent;
  52 import javafx.scene.input.KeyEvent;
  53 import javafx.scene.input.MouseButton;
  54 import javafx.scene.input.MouseEvent;
  55 import javafx.scene.input.ScrollEvent;
  56 import javafx.scene.input.TransferMode;
  57 import javafx.scene.text.FontSmoothingType;
  58 import javafx.stage.Stage;
  59 import javafx.stage.Window;
  60 import java.util.ArrayList;
  61 import java.util.Collections;
  62 import java.util.HashMap;
  63 import java.util.LinkedList;
  64 import java.util.List;
  65 import java.util.Map;
  66 import javafx.css.converter.BooleanConverter;
  67 import javafx.css.converter.EnumConverter;
  68 import javafx.css.converter.SizeConverter;
  69 import com.sun.javafx.geom.BaseBounds;
  70 import com.sun.javafx.geom.PickRay;
  71 import com.sun.javafx.geom.transform.BaseTransform;
  72 import com.sun.javafx.scene.DirtyBits;
  73 import com.sun.javafx.scene.NodeHelper;
  74 import com.sun.javafx.scene.SceneHelper;
  75 import com.sun.javafx.scene.input.PickResultChooser;
  76 import com.sun.javafx.sg.prism.NGNode;
  77 import com.sun.javafx.sg.prism.web.NGWebView;
  78 import com.sun.javafx.tk.TKPulseListener;
  79 import com.sun.javafx.tk.Toolkit;
  80 import com.sun.javafx.webkit.InputMethodClientImpl;
  81 import com.sun.javafx.webkit.KeyCodeMap;
  82 import com.sun.webkit.WebPage;
  83 import com.sun.webkit.event.WCFocusEvent;
  84 import com.sun.webkit.event.WCInputMethodEvent;
  85 import com.sun.webkit.event.WCKeyEvent;
  86 import com.sun.webkit.event.WCMouseEvent;
  87 import com.sun.webkit.event.WCMouseWheelEvent;
  88 
  89 /**
  90  * {@code WebView} is a {@link javafx.scene.Node} that manages a
  91  * {@link WebEngine} and displays its content. The associated {@code WebEngine}
  92  * is created automatically at construction time and cannot be changed
  93  * afterwards. {@code WebView} handles mouse and some keyboard events, and
  94  * manages scrolling automatically, so there&#39;s no need to put it into a
  95  * {@code ScrollPane}.
  96  *
  97  * &lt;p&gt;{@code WebView} objects must be created and accessed solely from the
  98  * FX thread.
  99  * @since JavaFX 2.0
 100  */
 101 final public class WebView extends Parent {
 102 
 103     private static final Map&lt;Object, Integer&gt; idMap = new HashMap&lt;Object, Integer&gt;();
 104 
 105     private static final boolean DEFAULT_CONTEXT_MENU_ENABLED = true;
 106     private static final FontSmoothingType DEFAULT_FONT_SMOOTHING_TYPE = FontSmoothingType.LCD;
 107     private static final double DEFAULT_ZOOM = 1.0;
 108     private static final double DEFAULT_FONT_SCALE = 1.0;
 109     private static final double DEFAULT_MIN_WIDTH = 0;
 110     private static final double DEFAULT_MIN_HEIGHT = 0;
 111     private static final double DEFAULT_PREF_WIDTH = 800;
 112     private static final double DEFAULT_PREF_HEIGHT = 600;
 113     private static final double DEFAULT_MAX_WIDTH = Double.MAX_VALUE;
 114     private static final double DEFAULT_MAX_HEIGHT = Double.MAX_VALUE;
 115 
 116     private final WebPage page;
 117     private final WebEngine engine;
 118     private volatile InputMethodClientImpl imClient;
 119 
 120     /**
 121      * The stage pulse listener registered with the toolkit.
 122      * This field guarantees that the listener will exist throughout
 123      * the whole lifetime of the WebView node. This field is necessary
 124      * because the toolkit references its stage pulse listeners weakly.
 125      */
 126     private final TKPulseListener stagePulseListener;
 127 
 128     /**
 129      * Returns the {@code WebEngine} object.
 130      * @return the WebEngine
 131      */
 132     public final WebEngine getEngine() {
 133         return engine;
 134     }
 135 
 136     private final ReadOnlyDoubleWrapper width = new ReadOnlyDoubleWrapper(this, &quot;width&quot;);
 137 
 138     public final double getWidth() {
 139         return width.get();
 140     }
 141 
 142     /**
 143      * Width of this {@code WebView}.
 144      * @return the width property
 145      */
 146     public ReadOnlyDoubleProperty widthProperty() {
 147         return width.getReadOnlyProperty();
 148     }
 149 
 150     private final ReadOnlyDoubleWrapper height = new ReadOnlyDoubleWrapper(this, &quot;height&quot;);
 151 
 152     public final double getHeight() {
 153         return height.get();
 154     }
 155 
 156     /**
 157      * Height of this {@code WebView}.
 158      * @return the height property
 159      */
 160     public ReadOnlyDoubleProperty heightProperty() {
 161         return height.getReadOnlyProperty();
 162     }
 163 
 164     /*
 165      * Zoom factor applied to the entire page contents.
 166      */
 167     private DoubleProperty zoom;
 168 
 169     public final void setZoom(double value) {
 170         WebEngine.checkThread();
 171         zoomProperty().set(value);
 172     }
 173 
 174     public final double getZoom() {
 175         return (this.zoom != null)
 176                 ? this.zoom.get()
 177                 : DEFAULT_ZOOM;
 178     }
 179 
 180     /**
 181      * The current zoom factor applied to the entire page contents.
 182      *
 183      * @return the zoom property
 184      * @defaultValue 1.0
 185      *
 186      * @since JavaFX 8.0
 187      */
 188     public final DoubleProperty zoomProperty() {
 189         if (zoom == null) {
 190             zoom = new StyleableDoubleProperty(DEFAULT_ZOOM) {
 191                 @Override public void invalidated() {
 192                     Toolkit.getToolkit().checkFxUserThread();
 193                     page.setZoomFactor((float) get(), false);
 194                 }
 195 
 196                 @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 197                     return StyleableProperties.ZOOM;
 198                 }
 199                 @Override public Object getBean() {
 200                     return WebView.this;
 201                 }
 202                 @Override public String getName() {
 203                     return &quot;zoom&quot;;
 204                 }
 205             };
 206         }
 207         return zoom;
 208     }
 209 
 210     /**
 211      * Specifies scale factor applied to font. This setting affects
 212      * text content but not images and fixed size elements.
 213      *
 214      * @defaultValue 1.0
 215      */
 216     private DoubleProperty fontScale;
 217 
 218     public final void setFontScale(double value) {
 219         WebEngine.checkThread();
 220         fontScaleProperty().set(value);
 221     }
 222 
 223     public final double getFontScale() {
 224         return (this.fontScale != null)
 225                 ? this.fontScale.get()
 226                 : DEFAULT_FONT_SCALE;
 227     }
 228 
 229     public DoubleProperty fontScaleProperty() {
 230         if (fontScale == null) {
 231             fontScale = new StyleableDoubleProperty(DEFAULT_FONT_SCALE) {
 232                 @Override public void invalidated() {
 233                     Toolkit.getToolkit().checkFxUserThread();
 234                     page.setZoomFactor((float)get(), true);
 235                 }
 236                 @Override public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 237                     return StyleableProperties.FONT_SCALE;
 238                 }
 239                 @Override public Object getBean() {
 240                     return WebView.this;
 241                 }
 242                 @Override public String getName() {
 243                     return &quot;fontScale&quot;;
 244                 }
 245             };
 246         }
 247         return fontScale;
 248     }
 249 
 250     {
 251         // To initialize the class helper at the begining each constructor of this class
 252         WebViewHelper.initHelper(this);
 253     }
 254     /**
 255      * Creates a {@code WebView} object.
 256      */
 257     public WebView() {
 258         setNodeOrientation(NodeOrientation.LEFT_TO_RIGHT);
 259         getStyleClass().add(&quot;web-view&quot;);
 260         engine = new WebEngine();
 261         engine.setView(this);
 262         page = engine.getPage();
 263         page.setFontSmoothingType(DEFAULT_FONT_SMOOTHING_TYPE.ordinal());
 264 
 265         registerEventHandlers();
 266         stagePulseListener = () -&gt; {
 267             handleStagePulse();
 268         };
 269         focusedProperty().addListener((ov, t, t1) -&gt; {
 270             if (page != null) {
 271                 // Traversal direction is not currently available in FX.
 272                 WCFocusEvent focusEvent = new WCFocusEvent(
 273                     isFocused() ? WCFocusEvent.FOCUS_GAINED
 274                             : WCFocusEvent.FOCUS_LOST,
 275                 WCFocusEvent.UNKNOWN);
 276                 page.dispatchFocusEvent(focusEvent);
 277             }
 278         });
 279         setFocusTraversable(true);
 280         Toolkit.getToolkit().addStageTkPulseListener(stagePulseListener);
 281     }
 282 
 283     // Resizing support. Allows arbitrary growing and shrinking.
 284     // Designed after javafx.scene.control.Control
 285 
 286     @Override public boolean isResizable() {
 287         return true;
 288     }
 289 
 290     @Override public void resize(double width, double height) {
 291         if ((width != this.width.get()) || (height != this.height.get())) {
 292             this.width.set(width);
 293             this.height.set(height);
 294             NodeHelper.markDirty(this, DirtyBits.NODE_GEOMETRY);
 295             NodeHelper.geomChanged(this);
 296         }
 297     }
 298 
 299     /**
 300      * Called during layout to determine the minimum width for this node.
 301      *
 302      * @return the minimum width that this node should be resized to during layout
 303      */
 304     @Override public final double minWidth(double height) {
 305         final double result = getMinWidth();
 306         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 307     }
 308 
 309     /**
 310      * Called during layout to determine the minimum height for this node.
 311      *
 312      * @return the minimum height that this node should be resized to during layout
 313      */
 314     @Override public final double minHeight(double width) {
 315         final double result = getMinHeight();
 316         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 317     }
 318 
 319 
 320     /**
 321      * Called during layout to determine the preferred width for this node.
 322      *
 323      * @return the preferred width that this node should be resized to during layout
 324      */
 325     @Override public final double prefWidth(double height) {
 326         final double result = getPrefWidth();
 327         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 328     }
 329 
 330     /**
 331      * Called during layout to determine the preferred height for this node.
 332      *
 333      * @return the preferred height that this node should be resized to during layout
 334      */
 335     @Override public final double prefHeight(double width) {
 336         final double result = getPrefHeight();
 337         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 338     }
 339     /**
 340      * Called during layout to determine the maximum width for this node.
 341      *
 342      * @return the maximum width that this node should be resized to during layout
 343      */
 344     @Override public final double maxWidth(double height) {
 345         final double result = getMaxWidth();
 346         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 347     }
 348 
 349     /**
 350      * Called during layout to determine the maximum height for this node.
 351      *
 352      * @return the maximum height that this node should be resized to during layout
 353      */
 354     @Override public final double maxHeight(double width) {
 355         final double result = getMaxHeight();
 356         return Double.isNaN(result) || result &lt; 0 ? 0 : result;
 357     }
 358 
 359     /**
 360      * Minimum width property.
 361      * @return the minWidth property
 362      */
 363     public DoubleProperty minWidthProperty() {
 364         if (minWidth == null) {
 365             minWidth = new StyleableDoubleProperty(DEFAULT_MIN_WIDTH) {
 366                 @Override
 367                 public void invalidated() {
 368                     if (getParent() != null) {
 369                         getParent().requestLayout();
 370                     }
 371                 }
 372                 @Override
 373                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 374                     return StyleableProperties.MIN_WIDTH;
 375                 }
 376                 @Override
 377                 public Object getBean() {
 378                     return WebView.this;
 379                 }
 380                 @Override
 381                 public String getName() {
 382                     return &quot;minWidth&quot;;
 383                 }
 384             };
 385         }
 386         return minWidth;
 387     }
 388     private DoubleProperty minWidth;
 389 
 390     public final void setMinWidth(double value) {
 391         minWidthProperty().set(value);
 392     }
 393 
 394     public final double getMinWidth() {
 395         return (this.minWidth != null)
 396                 ? this.minWidth.get()
 397                 : DEFAULT_MIN_WIDTH;
 398     }
 399 
 400     /**
 401      * Minimum height property.
 402      * @return the minHeight property
 403      */
 404     public DoubleProperty minHeightProperty() {
 405         if (minHeight == null) {
 406             minHeight = new StyleableDoubleProperty(DEFAULT_MIN_HEIGHT) {
 407                 @Override
 408                 public void invalidated() {
 409                     if (getParent() != null) {
 410                         getParent().requestLayout();
 411                     }
 412                 }
 413                 @Override
 414                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 415                     return StyleableProperties.MIN_HEIGHT;
 416                 }
 417                 @Override
 418                 public Object getBean() {
 419                     return WebView.this;
 420                 }
 421                 @Override
 422                 public String getName() {
 423                     return &quot;minHeight&quot;;
 424                 }
 425             };
 426         }
 427         return minHeight;
 428     }
 429     private DoubleProperty minHeight;
 430 
 431     public final void setMinHeight(double value) {
 432         minHeightProperty().set(value);
 433     }
 434 
 435     public final double getMinHeight() {
 436         return (this.minHeight != null)
 437                 ? this.minHeight.get()
 438                 : DEFAULT_MIN_HEIGHT;
 439     }
 440 
 441     /**
 442      * Convenience method for setting minimum width and height.
 443      * @param minWidth the minimum width
 444      * @param minHeight the minimum height
 445      */
 446     public void setMinSize(double minWidth, double minHeight) {
 447         setMinWidth(minWidth);
 448         setMinHeight(minHeight);
 449     }
 450 
 451     /**
 452      * Preferred width property.
 453      * @return the prefWidth property
 454      */
 455     public DoubleProperty prefWidthProperty() {
 456         if (prefWidth == null) {
 457             prefWidth = new StyleableDoubleProperty(DEFAULT_PREF_WIDTH) {
 458                 @Override
 459                 public void invalidated() {
 460                     if (getParent() != null) {
 461                         getParent().requestLayout();
 462                     }
 463                 }
 464                 @Override
 465                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 466                     return StyleableProperties.PREF_WIDTH;
 467                 }
 468                 @Override
 469                 public Object getBean() {
 470                     return WebView.this;
 471                 }
 472                 @Override
 473                 public String getName() {
 474                     return &quot;prefWidth&quot;;
 475                 }
 476             };
 477         }
 478         return prefWidth;
 479     }
 480     private DoubleProperty prefWidth;
 481 
 482     public final void setPrefWidth(double value) {
 483         prefWidthProperty().set(value);
 484     }
 485 
 486     public final double getPrefWidth() {
 487         return (this.prefWidth != null)
 488                 ? this.prefWidth.get()
 489                 : DEFAULT_PREF_WIDTH;
 490     }
 491 
 492     /**
 493      * Preferred height property.
 494      * @return the prefHeight property
 495      */
 496     public DoubleProperty prefHeightProperty() {
 497         if (prefHeight == null) {
 498             prefHeight = new StyleableDoubleProperty(DEFAULT_PREF_HEIGHT) {
 499                 @Override
 500                 public void invalidated() {
 501                     if (getParent() != null) {
 502                         getParent().requestLayout();
 503                     }
 504                 }
 505                 @Override
 506                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 507                     return StyleableProperties.PREF_HEIGHT;
 508                 }
 509                 @Override
 510                 public Object getBean() {
 511                     return WebView.this;
 512                 }
 513                 @Override
 514                 public String getName() {
 515                     return &quot;prefHeight&quot;;
 516                 }
 517             };
 518         }
 519         return prefHeight;
 520     }
 521     private DoubleProperty prefHeight;
 522 
 523     public final void setPrefHeight(double value) {
 524         prefHeightProperty().set(value);
 525     }
 526 
 527     public final double getPrefHeight() {
 528         return (this.prefHeight != null)
 529                 ? this.prefHeight.get()
 530                 : DEFAULT_PREF_HEIGHT;
 531     }
 532 
 533     /**
 534      * Convenience method for setting preferred width and height.
 535      * @param prefWidth the preferred width
 536      * @param prefHeight the preferred height
 537      */
 538     public void setPrefSize(double prefWidth, double prefHeight) {
 539         setPrefWidth(prefWidth);
 540         setPrefHeight(prefHeight);
 541     }
 542 
 543     /**
 544      * Maximum width property.
 545      * @return the maxWidth property
 546      */
 547     public DoubleProperty maxWidthProperty() {
 548         if (maxWidth == null) {
 549             maxWidth = new StyleableDoubleProperty(DEFAULT_MAX_WIDTH) {
 550                 @Override
 551                 public void invalidated() {
 552                     if (getParent() != null) {
 553                         getParent().requestLayout();
 554                     }
 555                 }
 556                 @Override
 557                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 558                     return StyleableProperties.MAX_WIDTH;
 559                 }
 560                 @Override
 561                 public Object getBean() {
 562                     return WebView.this;
 563                 }
 564                 @Override
 565                 public String getName() {
 566                     return &quot;maxWidth&quot;;
 567                 }
 568             };
 569         }
 570         return maxWidth;
 571     }
 572     private DoubleProperty maxWidth;
 573 
 574     public final void setMaxWidth(double value) {
 575         maxWidthProperty().set(value);
 576     }
 577 
 578     public final double getMaxWidth() {
 579         return (this.maxWidth != null)
 580                 ? this.maxWidth.get()
 581                 : DEFAULT_MAX_WIDTH;
 582     }
 583 
 584     /**
 585      * Maximum height property.
 586      * @return the maxHeight property
 587      */
 588     public DoubleProperty maxHeightProperty() {
 589         if (maxHeight == null) {
 590             maxHeight = new StyleableDoubleProperty(DEFAULT_MAX_HEIGHT) {
 591                 @Override
 592                 public void invalidated() {
 593                     if (getParent() != null) {
 594                         getParent().requestLayout();
 595                     }
 596                 }
 597                 @Override
 598                 public CssMetaData&lt;WebView, Number&gt; getCssMetaData() {
 599                     return StyleableProperties.MAX_HEIGHT;
 600                 }
 601                 @Override
 602                 public Object getBean() {
 603                     return WebView.this;
 604                 }
 605                 @Override
 606                 public String getName() {
 607                     return &quot;maxHeight&quot;;
 608                 }
 609             };
 610         }
 611         return maxHeight;
 612     }
 613     private DoubleProperty maxHeight;
 614 
 615     public final void setMaxHeight(double value) {
 616         maxHeightProperty().set(value);
 617     }
 618 
 619     public final double getMaxHeight() {
 620         return (this.maxHeight != null)
 621                 ? this.maxHeight.get()
 622                 : DEFAULT_MAX_HEIGHT;
 623     }
 624 
 625     /**
 626      * Convenience method for setting maximum width and height.
 627      * @param maxWidth the maximum width
 628      * @param maxHeight the maximum height
 629      */
 630     public void setMaxSize(double maxWidth, double maxHeight) {
 631         setMaxWidth(maxWidth);
 632         setMaxHeight(maxHeight);
 633     }
 634 
 635 
 636     /**
 637      * Specifies a requested font smoothing type : gray or LCD.
 638      *
 639      * The width of the bounding box is defined by the widest row.
 640      *
 641      * Note: LCD mode doesn&#39;t apply in numerous cases, such as various
 642      * compositing modes, where effects are applied and very large glyphs.
 643      *
 644      * @defaultValue FontSmoothingType.LCD
 645      * @since JavaFX 2.2
 646      */
 647     private ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingType;
 648 
 649     public final void setFontSmoothingType(FontSmoothingType value) {
 650         fontSmoothingTypeProperty().set(value);
 651     }
 652 
 653     public final FontSmoothingType getFontSmoothingType() {
 654         return (this.fontSmoothingType != null)
 655                 ? this.fontSmoothingType.get()
 656                 : DEFAULT_FONT_SMOOTHING_TYPE;
 657     }
 658 
 659     public final ObjectProperty&lt;FontSmoothingType&gt; fontSmoothingTypeProperty() {
 660         if (this.fontSmoothingType == null) {
 661             this.fontSmoothingType = new StyleableObjectProperty&lt;FontSmoothingType&gt;(DEFAULT_FONT_SMOOTHING_TYPE) {
 662                 @Override
 663                 public void invalidated() {
 664                     Toolkit.getToolkit().checkFxUserThread();
 665                     page.setFontSmoothingType(get().ordinal());
 666                 }
 667                 @Override
 668                 public CssMetaData&lt;WebView, FontSmoothingType&gt; getCssMetaData() {
 669                     return StyleableProperties.FONT_SMOOTHING_TYPE;
 670                 }
 671                 @Override
 672                 public Object getBean() {
 673                     return WebView.this;
 674                 }
 675                 @Override
 676                 public String getName() {
 677                     return &quot;fontSmoothingType&quot;;
 678                 }
 679             };
 680         }
 681         return this.fontSmoothingType;
 682     }
 683 
 684     /**
 685      * Specifies whether context menu is enabled.
 686      *
 687      * @defaultValue true
 688      * @since JavaFX 2.2
 689      */
 690     private BooleanProperty contextMenuEnabled;
 691 
 692     public final void setContextMenuEnabled(boolean value) {
 693         contextMenuEnabledProperty().set(value);
 694     }
 695 
 696     public final boolean isContextMenuEnabled() {
 697         return contextMenuEnabled == null
 698                 ? DEFAULT_CONTEXT_MENU_ENABLED
 699                 : contextMenuEnabled.get();
 700     }
 701 
 702     public final BooleanProperty contextMenuEnabledProperty() {
 703         if (contextMenuEnabled == null) {
 704             contextMenuEnabled = new StyleableBooleanProperty(DEFAULT_CONTEXT_MENU_ENABLED) {
 705                 @Override public void invalidated() {
 706                     Toolkit.getToolkit().checkFxUserThread();
 707                     page.setContextMenuEnabled(get());
 708                 }
 709 
 710                 @Override public CssMetaData&lt;WebView, Boolean&gt; getCssMetaData() {
 711                     return StyleableProperties.CONTEXT_MENU_ENABLED;
 712                 }
 713 
 714                 @Override public Object getBean() {
 715                     return WebView.this;
 716                 }
 717 
 718                 @Override public String getName() {
 719                     return &quot;contextMenuEnabled&quot;;
 720                 }
 721             };
 722         }
 723         return contextMenuEnabled;
 724     }
 725 
 726     /**
 727      * Super-lazy instantiation pattern from Bill Pugh.
 728      */
 729     private static final class StyleableProperties {
 730 
 731         private static final CssMetaData&lt;WebView, Boolean&gt; CONTEXT_MENU_ENABLED
 732                 = new CssMetaData&lt;WebView, Boolean&gt;(
 733                 &quot;-fx-context-menu-enabled&quot;,
 734                 BooleanConverter.getInstance(),
 735                 DEFAULT_CONTEXT_MENU_ENABLED)
 736         {
 737             @Override public boolean isSettable(WebView view) {
 738                 return view.contextMenuEnabled == null || !view.contextMenuEnabled.isBound();
 739             }
 740             @Override public StyleableProperty&lt;Boolean&gt; getStyleableProperty(WebView view) {
 741                 return (StyleableProperty&lt;Boolean&gt;)view.contextMenuEnabledProperty();
 742             }
 743         };
 744 
 745         private static final CssMetaData&lt;WebView, FontSmoothingType&gt; FONT_SMOOTHING_TYPE
 746                 = new CssMetaData&lt;WebView, FontSmoothingType&gt;(
 747                 &quot;-fx-font-smoothing-type&quot;,
 748                 new EnumConverter&lt;FontSmoothingType&gt;(FontSmoothingType.class),
 749                 DEFAULT_FONT_SMOOTHING_TYPE) {
 750             @Override
 751             public boolean isSettable(WebView view) {
 752                 return view.fontSmoothingType == null || !view.fontSmoothingType.isBound();
 753             }
 754             @Override
 755             public StyleableProperty&lt;FontSmoothingType&gt; getStyleableProperty(WebView view) {
 756                 return (StyleableProperty&lt;FontSmoothingType&gt;)view.fontSmoothingTypeProperty();
 757             }
 758         };
 759 
 760         private static final CssMetaData&lt;WebView, Number&gt; ZOOM
 761                 = new CssMetaData&lt;WebView, Number&gt;(
 762                 &quot;-fx-zoom&quot;,
 763                 SizeConverter.getInstance(),
 764                 DEFAULT_ZOOM) {
 765             @Override public boolean isSettable(WebView view) {
 766                 return view.zoom == null || !view.zoom.isBound();
 767             }
 768             @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 769                 return (StyleableProperty&lt;Number&gt;)view.zoomProperty();
 770             }
 771         };
 772 
 773         private static final CssMetaData&lt;WebView, Number&gt; FONT_SCALE
 774                 = new CssMetaData&lt;WebView, Number&gt;(
 775                 &quot;-fx-font-scale&quot;,
 776                 SizeConverter.getInstance(),
 777                 DEFAULT_FONT_SCALE) {
 778             @Override
 779             public boolean isSettable(WebView view) {
 780                 return view.fontScale == null || !view.fontScale.isBound();
 781             }
 782             @Override
 783             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 784                 return (StyleableProperty&lt;Number&gt;)view.fontScaleProperty();
 785             }
 786         };
 787 
 788         private static final CssMetaData&lt;WebView, Number&gt; MIN_WIDTH
 789                 = new CssMetaData&lt;WebView, Number&gt;(
 790                 &quot;-fx-min-width&quot;,
 791                 SizeConverter.getInstance(),
 792                 DEFAULT_MIN_WIDTH) {
 793             @Override
 794             public boolean isSettable(WebView view) {
 795                 return view.minWidth == null || !view.minWidth.isBound();
 796             }
 797             @Override
 798             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 799                 return (StyleableProperty&lt;Number&gt;)view.minWidthProperty();
 800             }
 801         };
 802 
 803         private static final CssMetaData&lt;WebView, Number&gt; MIN_HEIGHT
 804                 = new CssMetaData&lt;WebView, Number&gt;(
 805                 &quot;-fx-min-height&quot;,
 806                 SizeConverter.getInstance(),
 807                 DEFAULT_MIN_HEIGHT) {
 808             @Override
 809             public boolean isSettable(WebView view) {
 810                 return view.minHeight == null || !view.minHeight.isBound();
 811             }
 812             @Override
 813             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 814                 return (StyleableProperty&lt;Number&gt;)view.minHeightProperty();
 815             }
 816         };
 817 
 818         private static final CssMetaData&lt;WebView, Number&gt; MAX_WIDTH
 819                 = new CssMetaData&lt;WebView, Number&gt;(
 820                 &quot;-fx-max-width&quot;,
 821                 SizeConverter.getInstance(),
 822                 DEFAULT_MAX_WIDTH) {
 823             @Override
 824             public boolean isSettable(WebView view) {
 825                 return view.maxWidth == null || !view.maxWidth.isBound();
 826             }
 827             @Override
 828             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 829                 return (StyleableProperty&lt;Number&gt;)view.maxWidthProperty();
 830             }
 831         };
 832 
 833         private static final CssMetaData&lt;WebView, Number&gt; MAX_HEIGHT
 834                 = new CssMetaData&lt;WebView, Number&gt;(
 835                 &quot;-fx-max-height&quot;,
 836                 SizeConverter.getInstance(),
 837                 DEFAULT_MAX_HEIGHT) {
 838             @Override
 839             public boolean isSettable(WebView view) {
 840                 return view.maxHeight == null || !view.maxHeight.isBound();
 841             }
 842             @Override
 843             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 844                 return (StyleableProperty&lt;Number&gt;)view.maxHeightProperty();
 845             }
 846         };
 847 
 848         private static final CssMetaData&lt;WebView, Number&gt; PREF_WIDTH
 849                 = new CssMetaData&lt;WebView, Number&gt;(
 850                 &quot;-fx-pref-width&quot;,
 851                 SizeConverter.getInstance(),
 852                 DEFAULT_PREF_WIDTH) {
 853             @Override
 854             public boolean isSettable(WebView view) {
 855                 return view.prefWidth == null || !view.prefWidth.isBound();
 856             }
 857             @Override
 858             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 859                 return (StyleableProperty&lt;Number&gt;)view.prefWidthProperty();
 860             }
 861         };
 862 
 863         private static final CssMetaData&lt;WebView, Number&gt; PREF_HEIGHT
 864                 = new CssMetaData&lt;WebView, Number&gt;(
 865                 &quot;-fx-pref-height&quot;,
 866                 SizeConverter.getInstance(),
 867                 DEFAULT_PREF_HEIGHT) {
 868             @Override
 869             public boolean isSettable(WebView view) {
 870                 return view.prefHeight == null || !view.prefHeight.isBound();
 871             }
 872             @Override
 873             public StyleableProperty&lt;Number&gt; getStyleableProperty(WebView view) {
 874                 return (StyleableProperty&lt;Number&gt;)view.prefHeightProperty();
 875             }
 876         };
 877 
 878         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 879 
 880         static {
 881             List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables
 882                     = new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Parent.getClassCssMetaData());
 883             styleables.add(CONTEXT_MENU_ENABLED);
 884             styleables.add(FONT_SMOOTHING_TYPE);
 885             styleables.add(ZOOM);
 886             styleables.add(FONT_SCALE);
 887             styleables.add(MIN_WIDTH);
 888             styleables.add(PREF_WIDTH);
 889             styleables.add(MAX_WIDTH);
 890             styleables.add(MIN_HEIGHT);
 891             styleables.add(PREF_HEIGHT);
 892             styleables.add(MAX_HEIGHT);
 893             STYLEABLES = Collections.unmodifiableList(styleables);
 894          }
 895     }
 896 
 897     /**
 898      * @return The CssMetaData associated with this class, which may include the
 899      * CssMetaData of its superclasses.
 900      * @since JavaFX 8.0
 901      */
 902     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 903         return StyleableProperties.STYLEABLES;
 904     }
 905 
 906     /**
 907      * {@inheritDoc}
 908      * @since JavaFX 8.0
 909      */
 910     @Override
 911     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 912         return getClassCssMetaData();
 913     }
 914 
 915     // event handling
 916 
 917     // To handle stage pulse we need to know if currently webview and
 918     // tree is visible or not
 919     private boolean isTreeReallyVisible() {
 920         if (getScene() == null) {
 921             return false;
 922         }
 923 
 924         final Window window = getScene().getWindow();
 925 
 926         if (window == null) {
 927             return false;
 928         }
 929 
 930         boolean iconified = (window instanceof Stage) ? ((Stage)window).isIconified() : false;
 931 
 932         return NodeHelper.isTreeVisible(this)
 933                &amp;&amp; window.isShowing()
 934                &amp;&amp; window.getWidth() &gt; 0
 935                &amp;&amp; window.getHeight() &gt; 0
 936                &amp;&amp; !iconified;
 937     }
 938 
 939     private void handleStagePulse() {
 940         // The stage pulse occurs before the scene pulse.
 941         // Here the page content is updated before CSS/Layout/Sync pass
 942         // is initiated by the scene pulse. The update may
 943         // change the WebView children and, if so, the children should be
 944         // processed right away during the scene pulse.
 945 
 946         // The WebView node does not render its pending render queues
 947         // while it is invisible. Therefore, we should not schedule new
 948         // render queues while the WebView is invisible to prevent
 949         // the list of render queues from growing infinitely.
 950         // Also, if and when the WebView becomes invisible, the currently
 951         // pending render queues, if any, become obsolete and should be
 952         // discarded.
 953 
 954         if (page == null) return;
 955 
 956         boolean reallyVisible = isTreeReallyVisible();
 957 
 958         if (reallyVisible) {
 959             if (page.isDirty()) {
 960                 SceneHelper.setAllowPGAccess(true);
 961                 final NGWebView peer = NodeHelper.getPeer(this);
 962                 peer.update(); // creates new render queues
 963                 if (page.isRepaintPending()) {
 964                     NodeHelper.markDirty(this, DirtyBits.WEBVIEW_VIEW);
 965                 }
 966                 SceneHelper.setAllowPGAccess(false);
 967             }
 968         } else {
 969             page.dropRenderFrames();
 970         }
 971     }
 972 
 973     private void processMouseEvent(MouseEvent ev) {
 974         if (page == null) {
 975             return;
 976         }
 977 
 978         // RT-24511
 979         EventType&lt;? extends MouseEvent&gt; type = ev.getEventType();
 980         double x = ev.getX();
 981         double y = ev.getY();
 982         double screenX = ev.getScreenX();
 983         double screenY = ev.getScreenY();
 984         if (type == MouseEvent.MOUSE_EXITED) {
 985             type = MouseEvent.MOUSE_MOVED;
 986             x = Short.MIN_VALUE;
 987             y = Short.MIN_VALUE;
 988             Point2D screenPoint = localToScreen(x, y);
 989             if (screenPoint == null) {
 990                 return;
 991             }
 992             screenX = screenPoint.getX();
 993             screenY = screenPoint.getY();
 994         }
 995 
 996         final Integer id = idMap.get(type);
<a name="2" id="anc2"></a><span class="line-modified"> 997         final Integer button = idMap.get(ev.getButton());</span>
<span class="line-added"> 998         if (id == null || button == null) {</span>
 999             // not supported by webkit
1000             return;
1001         }
1002         WCMouseEvent mouseEvent =
<a name="3" id="anc3"></a><span class="line-modified">1003                 new WCMouseEvent(id, button,</span>
1004                     ev.getClickCount(), (int) x, (int) y,
1005                     (int) screenX, (int) screenY,
1006                     System.currentTimeMillis(),
1007                     ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
1008                     ev.isMetaDown(), ev.isPopupTrigger());
1009         page.dispatchMouseEvent(mouseEvent);
1010         ev.consume();
1011     }
1012 
1013     private void processScrollEvent(ScrollEvent ev) {
1014         if (page == null) {
1015             return;
1016         }
1017         double dx = - ev.getDeltaX() * getFontScale() * getScaleX();
1018         double dy = - ev.getDeltaY() * getFontScale() * getScaleY();
1019         WCMouseWheelEvent wheelEvent =
1020                 new WCMouseWheelEvent((int)ev.getX(), (int)ev.getY(),
1021                     (int)ev.getScreenX(), (int)ev.getScreenY(),
1022                     System.currentTimeMillis(),
1023                     ev.isShiftDown(), ev.isControlDown(), ev.isAltDown(),
1024                     ev.isMetaDown(), (float)dx, (float)dy);
1025         page.dispatchMouseWheelEvent(wheelEvent);
1026         ev.consume();
1027     }
1028 
1029     private void processKeyEvent(KeyEvent ev) {
1030         if (page == null) return;
1031 
1032         String text = null;
1033         String keyIdentifier = null;
1034         int windowsVirtualKeyCode = 0;
1035         if(ev.getEventType() == KeyEvent.KEY_TYPED) {
1036             text = ev.getCharacter();
1037         } else {
1038             KeyCodeMap.Entry keyCodeEntry = KeyCodeMap.lookup(ev.getCode());
1039             keyIdentifier = keyCodeEntry.getKeyIdentifier();
1040             windowsVirtualKeyCode = keyCodeEntry.getWindowsVirtualKeyCode();
1041         }
1042 
1043         WCKeyEvent keyEvent = new WCKeyEvent(
1044                 idMap.get(ev.getEventType()),
1045                 text,
1046                 keyIdentifier,
1047                 windowsVirtualKeyCode,
1048                 ev.isShiftDown(), ev.isControlDown(),
1049                 ev.isAltDown(), ev.isMetaDown(), System.currentTimeMillis());
1050         if (page.dispatchKeyEvent(keyEvent)) {
1051             ev.consume();
1052         }
1053     }
1054 
1055     private InputMethodClientImpl getInputMethodClient() {
1056          if (imClient == null) {
1057              synchronized (this) {
1058                  if (imClient == null) {
1059                      imClient = new InputMethodClientImpl(this, page);
1060                  }
1061              }
1062          }
1063          return imClient;
1064     }
1065 
1066     private void processInputMethodEvent(InputMethodEvent ie) {
1067         if (page == null) {
1068             return;
1069         }
1070 
1071         if (!getInputMethodClient().getInputMethodState()) {
1072             ie.consume();
1073             return;
1074         }
1075 
1076         WCInputMethodEvent imEvent = InputMethodClientImpl.convertToWCInputMethodEvent(ie);
1077         if (page.dispatchInputMethodEvent(imEvent)) {
1078             ie.consume();
1079             return;
1080         }
1081     }
1082 
1083     private static final int WK_DND_ACTION_NONE = 0x0;
1084     private static final int WK_DND_ACTION_COPY = 0x1;
1085     private static final int WK_DND_ACTION_MOVE = 0x2;
1086     private static final int WK_DND_ACTION_LINK = 0x40000000;
1087 
1088     private static int getWKDndEventType(EventType  et) {
1089         int commandId = 0;
1090         if (et == DragEvent.DRAG_ENTERED)
1091             commandId = WebPage.DND_DST_ENTER;
1092         else if (et == DragEvent.DRAG_EXITED)
1093             commandId = WebPage.DND_DST_EXIT;
1094         else if (et == DragEvent.DRAG_OVER)
1095             commandId = WebPage.DND_DST_OVER;
1096         else if (et == DragEvent.DRAG_DROPPED)
1097             commandId = WebPage.DND_DST_DROP;
1098         return commandId;
1099     }
1100 
1101     private static int getWKDndAction(TransferMode... tms) {
1102         int dndActionId = WK_DND_ACTION_NONE;
1103         for (TransferMode tm : tms) {
1104            if (tm == TransferMode.COPY)
1105                dndActionId |=  WK_DND_ACTION_COPY;
1106            else if (tm == TransferMode.MOVE)
1107                dndActionId |=  WK_DND_ACTION_MOVE;
1108            else if (tm == TransferMode.LINK)
1109                dndActionId |=  WK_DND_ACTION_LINK;
1110         }
1111         return dndActionId;
1112     }
1113 
1114     private static TransferMode[] getFXDndAction(int wkDndAction) {
1115         LinkedList&lt;TransferMode&gt; tms = new LinkedList&lt;TransferMode&gt;();
1116         if ((wkDndAction &amp; WK_DND_ACTION_COPY) != 0)
1117             tms.add(TransferMode.COPY);
1118         if ((wkDndAction &amp; WK_DND_ACTION_MOVE) != 0)
1119             tms.add(TransferMode.MOVE);
1120         if ((wkDndAction &amp; WK_DND_ACTION_LINK) != 0)
1121             tms.add(TransferMode.LINK);
1122         return tms.toArray(new TransferMode[0]);
1123     }
1124 
1125     private void registerEventHandlers() {
1126         addEventHandler(KeyEvent.ANY,
1127                 event -&gt; {
1128                     processKeyEvent(event);
1129                 });
1130         addEventHandler(MouseEvent.ANY,
1131                 event -&gt; {
1132                     processMouseEvent(event);
1133                     if (event.isDragDetect() &amp;&amp; !page.isDragConfirmed()) {
1134                         //postpone drag recognition:
1135                         //Webkit cannot resolve here is it a drag
1136                         //or selection.
1137                         event.setDragDetect(false);
1138                     }
1139                 });
1140         addEventHandler(ScrollEvent.SCROLL,
1141                 event -&gt; {
1142                     processScrollEvent(event);
1143                 });
1144         setOnInputMethodTextChanged(
1145                 event -&gt; {
1146                     processInputMethodEvent(event);
1147                 });
1148 
1149         //Drop target implementation:
1150         EventHandler&lt;DragEvent&gt; destHandler = event -&gt; {
1151             try {
1152                 Dragboard db = event.getDragboard();
1153                 LinkedList&lt;String&gt; mimes = new LinkedList&lt;String&gt;();
1154                 LinkedList&lt;String&gt; values = new LinkedList&lt;String&gt;();
1155                 for (DataFormat df : db.getContentTypes()) {
1156                     //TODO: extend to non-string serialized values.
1157                     //Please, look at the native code.
1158                     Object content = db.getContent(df);
1159                     if (content != null) {
1160                         for (String mime : df.getIdentifiers()) {
1161                             mimes.add(mime);
1162                             values.add(content.toString());
1163                         }
1164                     }
1165                 }
1166                 if (!mimes.isEmpty()) {
1167                     int wkDndEventType = getWKDndEventType(event.getEventType());
1168                     int wkDndAction = page.dispatchDragOperation(
1169                         wkDndEventType,
1170                         mimes.toArray(new String[0]), values.toArray(new String[0]),
1171                         (int)event.getX(), (int)event.getY(),
1172                         (int)event.getScreenX(), (int)event.getScreenY(),
1173                         getWKDndAction(db.getTransferModes().toArray(new TransferMode[0])));
1174 
1175                     //we cannot accept nothing on drop (we skip FX exception)
1176                     if (!(wkDndEventType == WebPage.DND_DST_DROP &amp;&amp; wkDndAction == WK_DND_ACTION_NONE)) {
1177                         event.acceptTransferModes(getFXDndAction(wkDndAction));
1178                     }
1179                     event.consume();
1180                 }
1181             } catch (SecurityException ex) {
1182                 // Just ignore the exception
1183                 //ex.printStackTrace();
1184             }
1185         };
1186         setOnDragEntered(destHandler);
1187         setOnDragExited(destHandler);
1188         setOnDragOver(destHandler);
1189         setOnDragDropped(destHandler);
1190 
1191         //Drag source implementation:
1192         setOnDragDetected(event -&gt; {
1193                if (page.isDragConfirmed()) {
1194                    page.confirmStartDrag();
1195                    event.consume();
1196                }
1197            });
1198         setOnDragDone(event -&gt; {
1199                 page.dispatchDragOperation(
1200                     WebPage.DND_SRC_DROP,
1201                     null, null,
1202                     (int)event.getX(), (int)event.getY(),
1203                     (int)event.getScreenX(), (int)event.getScreenY(),
1204                     getWKDndAction(event.getAcceptedTransferMode()));
1205                 event.consume();
1206             });
1207 
1208         setInputMethodRequests(getInputMethodClient());
1209     }
1210 
1211     /*
1212      * Note: This method MUST only be called via its accessor method.
1213      */
1214     private void doPickNodeLocal(PickRay pickRay, PickResultChooser result) {
1215         NodeHelper.intersects(this, pickRay, result);
1216     }
1217 
1218     @Override protected ObservableList&lt;Node&gt; getChildren() {
1219         return super.getChildren();
1220     }
1221 
1222     // Node stuff
1223 
1224     /*
1225      * Note: This method MUST only be called via its accessor method.
1226      */
1227     private NGNode doCreatePeer() {
1228         return new NGWebView();
1229     }
1230 
1231     /*
1232      * Note: This method MUST only be called via its accessor method.
1233      */
1234     private BaseBounds doComputeGeomBounds(BaseBounds bounds, BaseTransform tx) {
1235         bounds.deriveWithNewBounds(0, 0, 0, (float) getWidth(), (float)getHeight(), 0);
1236         tx.transform(bounds, bounds);
1237         return bounds;
1238     }
1239 
1240     /*
1241      * Note: This method MUST only be called via its accessor method.
1242      */
1243     private void doTransformsChanged() {
1244     }
1245 
1246     /*
1247      * Note: This method MUST only be called via its accessor method.
1248      */
1249     private boolean doComputeContains(double localX, double localY) {
1250         // Note: Local bounds contain test is already done by the caller. (Node.contains()).
1251         return true;
1252     }
1253 
1254     /*
1255      * Note: This method MUST only be called via its accessor method.
1256      */
1257     private void doUpdatePeer() {
1258         final NGWebView peer = NodeHelper.getPeer(this);
1259 
1260         if (NodeHelper.isDirty(this, DirtyBits.NODE_CONTENTS)) {
1261             peer.setPage(page);
1262         }
1263         if (NodeHelper.isDirty(this, DirtyBits.NODE_GEOMETRY)) {
1264             peer.resize((float)getWidth(), (float)getHeight());
1265         }
1266         if (NodeHelper.isDirty(this, DirtyBits.WEBVIEW_VIEW)) {
1267             peer.requestRender();
1268         }
1269     }
1270 
1271     static {
1272         WebViewHelper.setWebViewAccessor(new WebViewHelper.WebViewAccessor() {
1273             @Override
1274             public NGNode doCreatePeer(Node node) {
1275                 return ((WebView) node).doCreatePeer();
1276             }
1277 
1278             @Override
1279             public void doUpdatePeer(Node node) {
1280                 ((WebView) node).doUpdatePeer();
1281             }
1282 
1283             @Override
1284             public void doTransformsChanged(Node node) {
1285                 ((WebView) node).doTransformsChanged();
1286             }
1287 
1288             @Override
1289             public BaseBounds doComputeGeomBounds(Node node,
1290                     BaseBounds bounds, BaseTransform tx) {
1291                 return ((WebView) node).doComputeGeomBounds(bounds, tx);
1292             }
1293 
1294             @Override
1295             public boolean doComputeContains(Node node, double localX, double localY) {
1296                 return ((WebView) node).doComputeContains(localX, localY);
1297             }
1298 
1299             @Override
1300             public void doPickNodeLocal(Node node, PickRay localPickRay,
1301                     PickResultChooser result) {
1302                 ((WebView) node).doPickNodeLocal(localPickRay, result);
1303             }
1304         });
1305 
1306         idMap.put(MouseButton.NONE, WCMouseEvent.NOBUTTON);
1307         idMap.put(MouseButton.PRIMARY, WCMouseEvent.BUTTON1);
1308         idMap.put(MouseButton.MIDDLE, WCMouseEvent.BUTTON2);
1309         idMap.put(MouseButton.SECONDARY, WCMouseEvent.BUTTON3);
1310 
1311         idMap.put(MouseEvent.MOUSE_PRESSED, WCMouseEvent.MOUSE_PRESSED);
1312         idMap.put(MouseEvent.MOUSE_RELEASED, WCMouseEvent.MOUSE_RELEASED);
1313         idMap.put(MouseEvent.MOUSE_MOVED, WCMouseEvent.MOUSE_MOVED);
1314         idMap.put(MouseEvent.MOUSE_DRAGGED, WCMouseEvent.MOUSE_DRAGGED);
1315 
1316         idMap.put(KeyEvent.KEY_PRESSED, WCKeyEvent.KEY_PRESSED);
1317         idMap.put(KeyEvent.KEY_RELEASED, WCKeyEvent.KEY_RELEASED);
1318         idMap.put(KeyEvent.KEY_TYPED, WCKeyEvent.KEY_TYPED);
1319     }
1320 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>