diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
@@ -21,11 +21,10 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 #include "glass_window.h"
-#include "glass_general.h"
 #include "glass_key.h"
 #include "glass_screen.h"
 #include "glass_dnd.h"
 
 #include <com_sun_glass_events_WindowEvent.h>
@@ -38,10 +37,11 @@
 #include <X11/extensions/shape.h>
 #include <cairo.h>
 #include <cairo-xlib.h>
 #include <gdk/gdkx.h>
 #include <gdk/gdk.h>
+
 #ifdef GLASS_GTK3
 #include <gtk/gtkx.h>
 #endif
 
 #include <string.h>
@@ -49,96 +49,292 @@
 #include <algorithm>
 
 #define MOUSE_BACK_BTN 8
 #define MOUSE_FORWARD_BTN 9
 
-WindowContext * WindowContextBase::sm_grab_window = NULL;
-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;
+static gboolean ctx_configure_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_configure();
+    return FALSE;
+}
 
-GdkWindow* WindowContextBase::get_gdk_window(){
-    return gdk_window;
+static gboolean ctx_property_notify_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_property_notify(&event->property);
+    return TRUE;
 }
 
-jobject WindowContextBase::get_jview() {
-    return jview;
+static gboolean ctx_focus_change_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_focus(&event->focus_change);
+    return TRUE;
 }
 
-jobject WindowContextBase::get_jwindow() {
-    return jwindow;
+static gboolean ctx_delete_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_delete();
+    return TRUE;
+}
+
+static gboolean ctx_window_state_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_state(&event->window_state);
+    return FALSE;
+}
+
+static gboolean ctx_device_button_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_button(&event->button);
+    return TRUE;
+}
+
+static gboolean ctx_device_motion_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    gdk_event_request_motions(&event->motion);
+    ((WindowContext *) user_data)->process_mouse_motion(&event->motion);
+    return TRUE;
+}
+
+static gboolean ctx_device_scroll_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_scroll(&event->scroll);
+    return TRUE;
+}
+
+static gboolean ctx_enter_or_leave_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_cross(&event->crossing);
+    return TRUE;
+}
+
+static gboolean ctx_key_press_or_release_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_key(&event->key);
+    return TRUE;
+}
+
+static gboolean ctx_map_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_map();
+    return TRUE;
+}
+
+static void ctx_screen_changed_callback(GtkWidget *widget,
+                                        GdkScreen *previous_screen,
+                                        gpointer user_data) {
+    ((WindowContext *) user_data)->process_screen_changed();
+}
+
+static void connect_signals(GtkWidget *gtk_widget, WindowContext *ctx) {
+    g_signal_connect(gtk_widget, "configure-event", G_CALLBACK(ctx_configure_callback), ctx);
+    g_signal_connect(gtk_widget, "property-notify-event", G_CALLBACK(ctx_property_notify_callback), ctx);
+    g_signal_connect(gtk_widget, "focus-in-event", G_CALLBACK(ctx_focus_change_callback), ctx);
+    g_signal_connect(gtk_widget, "focus-out-event", G_CALLBACK(ctx_focus_change_callback), ctx);
+    g_signal_connect(gtk_widget, "delete-event", G_CALLBACK(ctx_delete_callback), ctx);
+    g_signal_connect(gtk_widget, "window-state-event", G_CALLBACK(ctx_window_state_callback), ctx);
+    g_signal_connect(gtk_widget, "button-press-event", G_CALLBACK(ctx_device_button_callback), ctx);
+    g_signal_connect(gtk_widget, "button-release-event", G_CALLBACK(ctx_device_button_callback), ctx);
+    g_signal_connect(gtk_widget, "motion-notify-event", G_CALLBACK(ctx_device_motion_callback), ctx);
+    g_signal_connect(gtk_widget, "scroll-event", G_CALLBACK(ctx_device_scroll_callback), ctx);
+    g_signal_connect(gtk_widget, "enter-notify-event", G_CALLBACK(ctx_enter_or_leave_callback), ctx);
+    g_signal_connect(gtk_widget, "leave-notify-event", G_CALLBACK(ctx_enter_or_leave_callback), ctx);
+    g_signal_connect(gtk_widget, "key-press-event", G_CALLBACK(ctx_key_press_or_release_callback), ctx);
+    g_signal_connect(gtk_widget, "key-release-event", G_CALLBACK(ctx_key_press_or_release_callback), ctx);
+    g_signal_connect(gtk_widget, "map-event", G_CALLBACK(ctx_map_callback), ctx);
+    g_signal_connect(gtk_widget, "screen-changed", G_CALLBACK(ctx_screen_changed_callback), ctx);
+}
+
+
+void destroy_and_delete_ctx(WindowContext *ctx) {
+    if (ctx) {
+        ctx->process_destroy();
+
+        if (!ctx->get_events_count()) {
+            delete ctx;
+        }
+        // else: ctx will be deleted in EventsCounterHelper after completing
+        // an event processing
+    }
+}
+
+static inline jint gtk_button_number_to_mouse_button(guint button) {
+    switch (button) {
+        case 1:
+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;
+        case 2:
+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;
+        case 3:
+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
+        case MOUSE_BACK_BTN:
+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;
+        case MOUSE_FORWARD_BTN:
+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
+        default:
+            // Other buttons are not supported by quantum and are not reported by other platforms
+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;
+    }
+}
+
+////////////////////////////// WindowContext /////////////////////////////////
+
+static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
+static GdkAtom atom_net_wm_frame_extents = gdk_atom_intern_static_string("_NET_FRAME_EXTENTS");
+
+WindowContext * WindowContext::sm_mouse_drag_window = NULL;
+WindowContext * WindowContext::sm_grab_window = NULL;
+
+WindowContext::WindowContext(jobject _jwindow, WindowContext *_owner, long _screen,
+                                   WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
+        screen(_screen),
+        frame_type(_frame_type),
+        window_type(type),
+        owner(_owner),
+        jview(NULL),
+        map_received(false),
+        visible_received(false),
+        on_top(false),
+        is_fullscreen(false),
+        is_iconified(false),
+        is_maximized(false),
+        is_mouse_entered(false),
+        can_be_deleted(false),
+        events_processing_cnt(0),
+        pointer_device(NULL) {
+
+    jwindow = mainEnv->NewGlobalRef(_jwindow);
+
+    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
+
+    if (gchar * app_name = get_application_name()) {
+        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
+        g_free(app_name);
+    }
+
+    if (owner) {
+        owner->add_child(this);
+        if (on_top_inherited()) {
+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        }
+    }
+
+    if (type == UTILITY) {
+        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
+    }
+
+    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
+
+    if (xvisualID != 0) {
+        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
+        glass_gtk_window_configure_from_visual(gtk_widget, visual);
+    }
+
+    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
+    gtk_widget_set_app_paintable(gtk_widget, TRUE);
+
+    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
+    gtk_window_set_title(GTK_WINDOW(gtk_widget), "");
+
+    gdk_window = gtk_widget_get_window(gtk_widget);
+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
+
+    glass_dnd_attach_context(this);
+
+    gdk_windowManagerFunctions = wmf;
+    if (wmf) {
+        gdk_window_set_functions(gdk_window, wmf);
+    }
+
+    if (frame_type != TITLED) {
+        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
+    }
+
+    connect_signals(gtk_widget, this);
+}
+
+void WindowContext::paint(void *data, jint width, jint height) {
+#if GTK_CHECK_VERSION(3, 0, 0)
+    cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
+#if GTK_CHECK_VERSION(3, 22, 0)
+    GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
+    cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
+#else
+    gdk_window_begin_paint_region(gdk_window, region);
+    cairo_t* context = gdk_cairo_create(gdk_window);
+#endif
+#else
+    cairo_t *context = gdk_cairo_create(gdk_window);
+#endif
+
+    if (bg_color.is_set) {
+        cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
+                                (frame_type == TRANSPARENT) ? 0 : 1);
+        cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
+        cairo_paint(context);
+    }
+
+    cairo_surface_t *cairo_surface;
+    cairo_surface = cairo_image_surface_create_for_data(
+            (unsigned char *) data,
+            CAIRO_FORMAT_ARGB32,
+            width, height, width * 4);
+
+    cairo_set_source_surface(context, cairo_surface, 0, 0);
+
+    applyShapeMask(data, width, height);
+    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
+    cairo_paint(context);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 22, 0)
+    gdk_window_end_draw_frame(gdk_window, dcontext);
+    cairo_region_destroy(region);
+#else
+    gdk_window_end_paint(gdk_window);
+    cairo_region_destroy(region);
+    cairo_destroy(context);
+#endif
+#else
+    cairo_destroy(context);
+#endif
+
+    cairo_surface_destroy(cairo_surface);
 }
 
-bool WindowContextBase::isEnabled() {
+bool WindowContext::isEnabled() {
     if (jwindow) {
         bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));
         LOG_EXCEPTION(mainEnv)
         return result;
     } else {
         return false;
     }
 }
 
-void WindowContextBase::notify_state(jint glass_state) {
-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {
-        if (is_maximized) {
-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;
-        }
-
-        int w, h;
-        glass_gdk_window_get_size(gdk_window, &w, &h);
-        if (jview) {
-            mainEnv->CallVoidMethod(jview,
-                    jViewNotifyRepaint,
-                    0, 0, w, h);
-            CHECK_JNI_EXCEPTION(mainEnv);
-        }
-    }
+GdkWindow *WindowContext::get_gdk_window() {
+    return gdk_window;
+}
 
-    if (jwindow) {
-       mainEnv->CallVoidMethod(jwindow,
-               jGtkWindowNotifyStateChanged,
-               glass_state);
-       CHECK_JNI_EXCEPTION(mainEnv);
-    }
+GtkWidget *WindowContext::get_gtk_widget() {
+    return gtk_widget;
 }
 
-void WindowContextBase::process_state(GdkEventWindowState* event) {
-    if (event->changed_mask &
-            (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {
+GtkWindow *WindowContext::get_gtk_window() {
+    return GTK_WINDOW(gtk_widget);
+}
 
-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {
-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;
-        }
-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {
-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
-        }
+WindowGeometry WindowContext::get_geometry() {
+    return geometry;
+}
 
-        jint stateChangeEvent;
+jobject WindowContext::get_jwindow() {
+    return jwindow;
+}
 
-        if (is_iconified) {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;
-        } else if (is_maximized) {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;
-        } else {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;
-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {
-                // in this case - the window manager will not support the programatic
-                // request to iconify - so we need to restore it now.
-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);
-            }
-        }
+jobject WindowContext::get_jview() {
+    return jview;
+}
 
-        notify_state(stateChangeEvent);
-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {
-        notify_on_top( event->new_window_state & GDK_WINDOW_STATE_ABOVE);
-    }
+void WindowContext::process_map() {
+    map_received = true;
+    apply_geometry();
 }
 
-void WindowContextBase::process_focus(GdkEventFocus* event) {
-    if (!event->in && WindowContextBase::sm_mouse_drag_window == this) {
+void WindowContext::process_focus(GdkEventFocus *event) {
+    if (!event->in && WindowContext::sm_mouse_drag_window == this) {
         ungrab_mouse_drag_focus();
     }
-    if (!event->in && WindowContextBase::sm_grab_window == this) {
+
+    if (!event->in && WindowContext::sm_grab_window == this) {
         ungrab_focus();
     }
 
     if (xim.enabled && xim.ic) {
         if (event->in) {
@@ -149,60 +345,97 @@
     }
 
     if (jwindow) {
         if (!event->in || isEnabled()) {
             mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,
-                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED : com_sun_glass_events_WindowEvent_FOCUS_LOST);
+                                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED
+                                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);
             CHECK_JNI_EXCEPTION(mainEnv)
         } else {
             mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusDisabled);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::increment_events_counter() {
-    ++events_processing_cnt;
-}
+void WindowContext::process_property_notify(GdkEventProperty *event) {
+    if (event->window == gdk_window) {
+        if (event->atom == atom_net_wm_state) {
+            process_net_wm_property();
+        } else if (event->atom == atom_net_wm_frame_extents) {
+            if (frame_type != TITLED) {
+                return;
+            }
 
-void WindowContextBase::decrement_events_counter() {
-    --events_processing_cnt;
-}
+            int top, left, bottom, right;
 
-size_t WindowContextBase::get_events_count() {
-    return events_processing_cnt;
-}
+            if (get_frame_extents_property(&top, &left, &bottom, &right)) {
+                if (top + left + bottom + right > 0) {
+                    geometry.frame_extents_received = true;
+                    geometry.adjust_w = left + right;
+                    geometry.adjust_h = top + bottom;
+                    geometry.view_x = left;
+                    geometry.view_y = top;
 
-bool WindowContextBase::is_dead() {
-    return can_be_deleted;
-}
+                    save_cached_extents();
 
-void destroy_and_delete_ctx(WindowContext* ctx) {
-    if (ctx) {
-        ctx->process_destroy();
+                    // set bounds again to set to correct window size that must
+                    // be the total width and height accounting extents
+                    // this is ignored if size is "content size" instead of "window size"
+                    if (geometry.window_size_set) {
+                        set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
+                    }
 
-        if (!ctx->get_events_count()) {
-            delete ctx;
+                    // force position notify so java will know about view_y and view_x
+                    size_position_notify(false, true);
+                }
+            }
         }
-        // else: ctx will be deleted in EventsCounterHelper after completing
-        // an event processing
     }
 }
 
-void WindowContextBase::process_destroy() {
-    if (WindowContextBase::sm_mouse_drag_window == this) {
+void WindowContext::process_configure() {
+    calculate_adjustments();
+
+    gint x, y, w, h, gtk_w, gtk_h;
+
+    gtk_window_get_position(GTK_WINDOW(gtk_widget), &x, &y);
+    gtk_window_get_size(GTK_WINDOW(gtk_widget), &gtk_w, &gtk_h);
+    w = gtk_w + geometry.adjust_w;
+    h = gtk_h + geometry.adjust_h;
+
+    gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
+    gboolean size_changed = geometry.current_w != w || geometry.current_h != h
+                            || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
+
+    geometry.current_x = x;
+    geometry.current_y = y;
+    geometry.current_w = w;
+    geometry.current_h = h;
+    geometry.current_cw = gtk_w;
+    geometry.current_ch = gtk_h;
+
+    size_position_notify(size_changed, pos_changed);
+}
+
+void WindowContext::process_destroy() {
+    if (owner) {
+        owner->remove_child(this);
+    }
+
+    if (WindowContext::sm_mouse_drag_window == this) {
         ungrab_mouse_drag_focus();
     }
 
-    if (WindowContextBase::sm_grab_window == this) {
+    if (WindowContext::sm_grab_window == this) {
         ungrab_focus();
     }
 
-    std::set<WindowContextTop*>::iterator it;
+    std::set<WindowContext *>::iterator it;
     for (it = children.begin(); it != children.end(); ++it) {
         // FIX JDK-8226537: this method calls set_owner(NULL) which prevents
-        // WindowContextTop::process_destroy() to call remove_child() (because children
+        // WindowContext::process_destroy() to call remove_child() (because children
         // is being iterated here) but also prevents gtk_window_set_transient_for from
         // being called - this causes the crash on gnome.
         gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);
         (*it)->set_owner(NULL);
         destroy_and_delete_ctx(*it);
@@ -225,44 +458,30 @@
     }
 
     can_be_deleted = true;
 }
 
-void WindowContextBase::process_delete() {
+void WindowContext::process_delete() {
     if (jwindow && isEnabled()) {
+        gtk_widget_hide_on_delete(gtk_widget);
         mainEnv->CallVoidMethod(jwindow, jWindowNotifyClose);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-void WindowContextBase::process_expose(GdkEventExpose* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);
+void WindowContext::process_expose(GdkEventExpose *event) {
+    if (jview && is_visible()) {
+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y,
+                                event->area.width, event->area.height);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-static inline jint gtk_button_number_to_mouse_button(guint button) {
-    switch (button) {
-        case 1:
-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;
-        case 2:
-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;
-        case 3:
-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
-        case MOUSE_BACK_BTN:
-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;
-        case MOUSE_FORWARD_BTN:
-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
-        default:
-            // Other buttons are not supported by quantum and are not reported by other platforms
-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;
-    }
-}
-
-void WindowContextBase::process_mouse_button(GdkEventButton* event) {
+void WindowContext::process_mouse_button(GdkEventButton *event) {
     bool press = event->type == GDK_BUTTON_PRESS;
+    bool release = event->type == GDK_BUTTON_RELEASE;
+
     guint state = event->state;
     guint mask = 0;
 
     // We need to add/remove current mouse button from the modifier flags
     // as X lib state represents the state just prior to the event and
@@ -289,27 +508,16 @@
         state |= mask;
     } else {
         state &= ~mask;
     }
 
-    if (press) {
-        GdkDevice* device = event->device;
-
-        if (glass_gdk_device_is_grabbed(device)
-                && (glass_gdk_device_get_window_at_position(device, NULL, NULL)
-                == NULL)) {
-            ungrab_focus();
-            return;
-        }
-    }
-
     // Upper layers expects from us Windows behavior:
     // all mouse events should be delivered to window where drag begins
     // and no exit/enter event should be reported during this drag.
     // We can grab mouse pointer for these needs.
     if (press) {
-        grab_mouse_drag_focus();
+        grab_mouse_drag_focus(NULL, true);
     } else {
         if ((event->state & MOUSE_BUTTONS_MASK)
             && !(state & MOUSE_BUTTONS_MASK)) { // all buttons released
             ungrab_mouse_drag_focus();
         } else if (event->button == 8 || event->button == 9) {
@@ -323,30 +531,30 @@
 
     jint button = gtk_button_number_to_mouse_button(event->button);
 
     if (jview && button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {
         mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
-                button,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                gdk_modifier_mask_to_glass(state),
-                (event->button == 3 && press) ? JNI_TRUE : JNI_FALSE,
-                JNI_FALSE);
+                                press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
+                                button,
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                gdk_modifier_mask_to_glass(state),
+                                (event->button == 3 && press) ? JNI_TRUE : JNI_FALSE,
+                                JNI_FALSE);
         CHECK_JNI_EXCEPTION(mainEnv)
 
         if (jview && event->button == 3 && press) {
             mainEnv->CallVoidMethod(jview, jViewNotifyMenu,
-                    (jint)event->x, (jint)event->y,
-                    (jint)event->x_root, (jint)event->y_root,
-                    JNI_FALSE);
+                                    (jint) event->x, (jint) event->y,
+                                    (jint) event->x_root, (jint) event->y_root,
+                                    JNI_FALSE);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {
+void WindowContext::process_mouse_motion(GdkEventMotion *event) {
     jint glass_modifier = gdk_modifier_mask_to_glass(event->state);
     jint isDrag = glass_modifier & (
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY |
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE |
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY |
@@ -366,22 +574,22 @@
         button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
     }
 
     if (jview) {
         mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                isDrag ? com_sun_glass_events_MouseEvent_DRAG : com_sun_glass_events_MouseEvent_MOVE,
-                button,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                glass_modifier,
-                JNI_FALSE,
-                JNI_FALSE);
+                                isDrag ? com_sun_glass_events_MouseEvent_DRAG : com_sun_glass_events_MouseEvent_MOVE,
+                                button,
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                glass_modifier,
+                                JNI_FALSE,
+                                JNI_FALSE);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {
+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {
     jdouble dx = 0;
     jdouble dy = 0;
 
     // converting direction to change in pixels
     switch (event->direction) {
@@ -408,46 +616,47 @@
         dy = dx;
         dx = t;
     }
     if (jview) {
         mainEnv->CallVoidMethod(jview, jViewNotifyScroll,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                dx, dy,
-                gdk_modifier_mask_to_glass(event->state),
-                (jint) 0, (jint) 0,
-                (jint) 0, (jint) 0,
-                (jdouble) 40.0, (jdouble) 40.0);
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                dx, dy,
+                                gdk_modifier_mask_to_glass(event->state),
+                                (jint) 0, (jint) 0,
+                                (jint) 0, (jint) 0,
+                                (jdouble) 40.0, (jdouble) 40.0);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
-
 }
 
-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {
+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {
     bool enter = event->type == GDK_ENTER_NOTIFY;
+
     if (jview) {
         guint state = event->state;
         if (enter) { // workaround for RT-21590
             state &= ~MOUSE_BUTTONS_MASK;
         }
 
         if (enter != is_mouse_entered) {
             is_mouse_entered = enter;
             mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                    enter ? com_sun_glass_events_MouseEvent_ENTER : com_sun_glass_events_MouseEvent_EXIT,
-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                    (jint) event->x, (jint) event->y,
-                    (jint) event->x_root, (jint) event->y_root,
-                    gdk_modifier_mask_to_glass(state),
-                    JNI_FALSE,
-                    JNI_FALSE);
+                                    enter ? com_sun_glass_events_MouseEvent_ENTER
+                                          : com_sun_glass_events_MouseEvent_EXIT,
+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                    (jint) event->x, (jint) event->y,
+                                    (jint) event->x_root, (jint) event->y_root,
+                                    gdk_modifier_mask_to_glass(state),
+                                    JNI_FALSE,
+                                    JNI_FALSE);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::process_key(GdkEventKey* event) {
+void WindowContext::process_key(GdkEventKey *event) {
     bool press = event->type == GDK_KEY_PRESS;
     jint glassKey = get_glass_key(event);
     jint glassModifier = gdk_modifier_mask_to_glass(event->state);
     if (press) {
         glassModifier |= glass_key_to_modifier(glassKey);
@@ -486,608 +695,107 @@
         jChars = mainEnv->NewCharArray(0);
     }
     if (jview) {
         if (press) {
             mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                    com_sun_glass_events_KeyEvent_PRESS,
-                    glassKey,
-                    jChars,
-                    glassModifier);
+                                    com_sun_glass_events_KeyEvent_PRESS,
+                                    glassKey,
+                                    jChars,
+                                    glassModifier);
             CHECK_JNI_EXCEPTION(mainEnv)
 
             if (jview && key > 0) { // TYPED events should only be sent for printable characters.
                 mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                        com_sun_glass_events_KeyEvent_TYPED,
-                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,
-                        jChars,
-                        glassModifier);
+                                        com_sun_glass_events_KeyEvent_TYPED,
+                                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,
+                                        jChars,
+                                        glassModifier);
                 CHECK_JNI_EXCEPTION(mainEnv)
             }
         } else {
             mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                    com_sun_glass_events_KeyEvent_RELEASE,
-                    glassKey,
-                    jChars,
-                    glassModifier);
+                                    com_sun_glass_events_KeyEvent_RELEASE,
+                                    glassKey,
+                                    jChars,
+                                    glassModifier);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::paint(void* data, jint width, jint height)
-{
-    if (!is_visible()) {
-        return;
-    }
-#ifdef GLASS_GTK3
-    cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
-    gdk_window_begin_paint_region(gdk_window, region);
-#endif
-    cairo_t* context;
-    context = gdk_cairo_create(gdk_window);
-
-    cairo_surface_t* cairo_surface;
-    cairo_surface = cairo_image_surface_create_for_data(
-            (unsigned char*)data,
-            CAIRO_FORMAT_ARGB32,
-            width, height, width * 4);
-
-    applyShapeMask(data, width, height);
+void WindowContext::process_state(GdkEventWindowState *event) {
+    if (event->changed_mask &
+        (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {
 
-    cairo_set_source_surface(context, cairo_surface, 0, 0);
-    cairo_set_operator (context, CAIRO_OPERATOR_SOURCE);
-    cairo_paint(context);
-#ifdef GLASS_GTK3
-    gdk_window_end_paint(gdk_window);
-    cairo_region_destroy(region);
-#endif
-
-    cairo_destroy(context);
-    cairo_surface_destroy(cairo_surface);
-}
-
-void WindowContextBase::add_child(WindowContextTop* child) {
-    children.insert(child);
-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());
-}
-
-void WindowContextBase::remove_child(WindowContextTop* child) {
-    children.erase(child);
-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);
-}
-
-void WindowContextBase::show_or_hide_children(bool show) {
-    std::set<WindowContextTop*>::iterator it;
-    for (it = children.begin(); it != children.end(); ++it) {
-        (*it)->set_minimized(!show);
-        (*it)->show_or_hide_children(show);
-    }
-}
-
-void WindowContextBase::reparent_children(WindowContext* parent) {
-    std::set<WindowContextTop*>::iterator it;
-    for (it = children.begin(); it != children.end(); ++it) {
-        (*it)->set_owner(parent);
-        parent->add_child(*it);
-    }
-    children.clear();
-}
-
-void WindowContextBase::set_visible(bool visible) {
-    if (visible) {
-        gtk_widget_show_all(gtk_widget);
-    } else {
-        gtk_widget_hide(gtk_widget);
-        if (jview && is_mouse_entered) {
-            is_mouse_entered = false;
-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                    com_sun_glass_events_MouseEvent_EXIT,
-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                    0, 0,
-                    0, 0,
-                    0,
-                    JNI_FALSE,
-                    JNI_FALSE);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
-    }
-}
-
-bool WindowContextBase::is_visible() {
-    return gtk_widget_get_visible(gtk_widget);
-}
-
-bool WindowContextBase::set_view(jobject view) {
-
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                com_sun_glass_events_MouseEvent_EXIT,
-                com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                0, 0,
-                0, 0,
-                0,
-                JNI_FALSE,
-                JNI_FALSE);
-        mainEnv->DeleteGlobalRef(jview);
-    }
-
-    if (view) {
-        jview = mainEnv->NewGlobalRef(view);
-    } else {
-        jview = NULL;
-    }
-    return TRUE;
-}
-
-bool WindowContextBase::grab_mouse_drag_focus() {
-    if (glass_gdk_mouse_devices_grab_with_cursor(
-            gdk_window, gdk_window_get_cursor(gdk_window), FALSE)) {
-        WindowContextBase::sm_mouse_drag_window = this;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void WindowContextBase::ungrab_mouse_drag_focus() {
-    WindowContextBase::sm_mouse_drag_window = NULL;
-    glass_gdk_mouse_devices_ungrab();
-    if (WindowContextBase::sm_grab_window) {
-        WindowContextBase::sm_grab_window->grab_focus();
-    }
-}
-
-bool WindowContextBase::grab_focus() {
-    if (WindowContextBase::sm_mouse_drag_window
-            || glass_gdk_mouse_devices_grab(gdk_window)) {
-        WindowContextBase::sm_grab_window = this;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void WindowContextBase::ungrab_focus() {
-    if (!WindowContextBase::sm_mouse_drag_window) {
-        glass_gdk_mouse_devices_ungrab();
-    }
-    WindowContextBase::sm_grab_window = NULL;
-
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-}
-
-void WindowContextBase::set_cursor(GdkCursor* cursor) {
-    if (!is_in_drag()) {
-        if (WindowContextBase::sm_mouse_drag_window) {
-            glass_gdk_mouse_devices_grab_with_cursor(
-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);
-        } else if (WindowContextBase::sm_grab_window) {
-            glass_gdk_mouse_devices_grab_with_cursor(
-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);
+        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {
+            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;
         }
-    }
-    gdk_window_set_cursor(gdk_window, cursor);
-}
-
-void WindowContextBase::set_background(float r, float g, float b) {
-#ifdef GLASS_GTK3
-    GdkRGBA rgba = {0, 0, 0, 1.};
-    rgba.red = r;
-    rgba.green = g;
-    rgba.blue = b;
-    gdk_window_set_background_rgba(gdk_window, &rgba);
-#else
-    GdkColor color;
-    color.red   = (guint16) (r * 65535);
-    color.green = (guint16) (g * 65535);
-    color.blue  = (guint16) (b * 65535);
-    gtk_widget_modify_bg(gtk_widget, GTK_STATE_NORMAL, &color);
-#endif
-}
-
-WindowContextBase::~WindowContextBase() {
-    if (xim.ic) {
-        XDestroyIC(xim.ic);
-        xim.ic = NULL;
-    }
-    if (xim.im) {
-        XCloseIM(xim.im);
-        xim.im = NULL;
-    }
-
-    gtk_widget_destroy(gtk_widget);
-}
-
-////////////////////////////// WindowContextTop /////////////////////////////////
-WindowFrameExtents WindowContextTop::normal_extents = {28, 1, 1, 1};
-WindowFrameExtents WindowContextTop::utility_extents = {28, 1, 1, 1};
-
-
-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,
-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
-            WindowContextBase(),
-            screen(_screen),
-            frame_type(_frame_type),
-            window_type(type),
-            owner(_owner),
-            geometry(),
-            resizable(),
-            frame_extents_initialized(),
-            map_received(false),
-            location_assigned(false),
-            size_assigned(false),
-            on_top(false),
-            requested_bounds()
-{
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
-
-    gtk_widget =  gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
-
-    if (gchar* app_name = get_application_name()) {
-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
-        g_free(app_name);
-    }
-
-    if (owner) {
-        owner->add_child(this);
-        if (on_top_inherited()) {
-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {
+            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
         }
-    }
-
-    if (type == UTILITY) {
-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
-    }
-
-//    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);
-//    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);
-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
-
-    if (xvisualID != 0) {
-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
-        glass_gtk_window_configure_from_visual(gtk_widget, visual);
-    }
-
-    gtk_widget_set_size_request(gtk_widget, 0, 0);
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
-    if (frame_type != TITLED) {
-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
-    }
-
-    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
-    gtk_window_set_title(GTK_WINDOW(gtk_widget), "");
-
-    gdk_window = gtk_widget_get_window(gtk_widget);
-
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-
-    gdk_window_register_dnd(gdk_window);
-
-    gdk_windowManagerFunctions = wmf;
-    if (wmf) {
-        gdk_window_set_functions(gdk_window, wmf);
-    }
-
-    if (frame_type == TITLED) {
-        request_frame_extents();
-    }
-}
-
-// Applied to a temporary full screen window to prevent sending events to Java
-void WindowContextTop::detach_from_java() {
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
-        jview = NULL;
-    }
-    if (jwindow) {
-        mainEnv->DeleteGlobalRef(jwindow);
-        jwindow = NULL;
-    }
-}
-
-static GdkAtom
-get_net_frame_extents_atom() {
-    static const char * extents_str = "_NET_FRAME_EXTENTS";
-    return gdk_atom_intern(extents_str, TRUE);
-}
-
-void
-WindowContextTop::request_frame_extents() {
-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));
-    Atom rfeAtom = XInternAtom(display, "_NET_REQUEST_FRAME_EXTENTS", True);
-    if (rfeAtom != None) {
-        XClientMessageEvent clientMessage;
-        memset(&clientMessage, 0, sizeof(clientMessage));
-
-        clientMessage.type = ClientMessage;
-        clientMessage.window = GDK_WINDOW_XID(gdk_window);
-        clientMessage.message_type = rfeAtom;
-        clientMessage.format = 32;
-
-        XSendEvent(display, XDefaultRootWindow(display), False,
-                   SubstructureRedirectMask | SubstructureNotifyMask,
-                   (XEvent *) &clientMessage);
-        XFlush(display);
-    }
-}
-
-void WindowContextTop::activate_window() {
-    Display *display = GDK_DISPLAY_XDISPLAY (gdk_window_get_display (gdk_window));
-    Atom navAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
-    if (navAtom != None) {
-        XClientMessageEvent clientMessage;
-        memset(&clientMessage, 0, sizeof(clientMessage));
-
-        clientMessage.type = ClientMessage;
-        clientMessage.window = GDK_WINDOW_XID(gdk_window);
-        clientMessage.message_type = navAtom;
-        clientMessage.format = 32;
-        clientMessage.data.l[0] = 1;
-        clientMessage.data.l[1] = gdk_x11_get_server_time(gdk_window);
-        clientMessage.data.l[2] = 0;
-
-        XSendEvent(display, XDefaultRootWindow(display), False,
-                   SubstructureRedirectMask | SubstructureNotifyMask,
-                   (XEvent *) &clientMessage);
-        XFlush(display);
-    }
-}
-
-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {
-    if (window_type == NORMAL) {
-        normal_extents = ex;
-    } else {
-        utility_extents = ex;
-    }
-}
-
-WindowFrameExtents WindowContextTop::get_cached_extents() {
-    return window_type == NORMAL ? normal_extents : utility_extents;
-}
 
+        jint stateChangeEvent;
 
-bool WindowContextTop::update_frame_extents() {
-    bool changed = false;
-    int top, left, bottom, right;
-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {
-        changed = geometry.extents.top != top
-                    || geometry.extents.left != left
-                    || geometry.extents.bottom != bottom
-                    || geometry.extents.right != right;
-        if (changed) {
-            geometry.extents.top = top;
-            geometry.extents.left = left;
-            geometry.extents.bottom = bottom;
-            geometry.extents.right = right;
-            if (!is_null_extents()) {
-                set_cached_extents(geometry.extents);
+        if (is_iconified) {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;
+        } else if (is_maximized) {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;
+        } else {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;
+            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {
+                // in this case - the window manager will not support the programatic
+                // request to iconify - so we need to restore it now.
+                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);
             }
         }
-    }
-    return changed;
-}
-
-bool
-WindowContextTop::get_frame_extents_property(int *top, int *left,
-        int *bottom, int *right) {
-    unsigned long *extents;
 
-    if (gdk_property_get(gdk_window,
-            get_net_frame_extents_atom(),
-            gdk_atom_intern("CARDINAL", FALSE),
-            0,
-            sizeof (unsigned long) * 4,
-            FALSE,
-            NULL,
-            NULL,
-            NULL,
-            (guchar**) & extents)) {
-        *left = extents [0];
-        *right = extents [1];
-        *top = extents [2];
-        *bottom = extents [3];
-
-        g_free(extents);
-        return true;
-    }
-
-    return false;
-}
-
-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {
-     return (windowGeometry->final_width.type != BOUNDSTYPE_WINDOW)
-                   ? windowGeometry->final_width.value
-                         + windowGeometry->extents.left
-                         + windowGeometry->extents.right
-                   : windowGeometry->final_width.value;
-}
-
-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_height.type != BOUNDSTYPE_WINDOW)
-                   ? windowGeometry->final_height.value
-                         + windowGeometry->extents.top
-                         + windowGeometry->extents.bottom
-                   : windowGeometry->final_height.value;
-}
-
-static int geometry_get_content_width(WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_width.type != BOUNDSTYPE_CONTENT)
-                   ? windowGeometry->final_width.value
-                         - windowGeometry->extents.left
-                         - windowGeometry->extents.right
-                   : windowGeometry->final_width.value;
-}
-static int geometry_get_content_height(WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_height.type != BOUNDSTYPE_CONTENT)
-                   ? windowGeometry->final_height.value
-                         - windowGeometry->extents.top
-                         - windowGeometry->extents.bottom
-                   : windowGeometry->final_height.value;
-}
-
-static int geometry_get_window_x(const WindowGeometry *windowGeometry) {
-    float value = windowGeometry->refx;
-    if (windowGeometry->gravity_x != 0) {
-        value -= geometry_get_window_width(windowGeometry)
-                     * windowGeometry->gravity_x;
-    }
-    return (int) value;
-}
-
-static int geometry_get_window_y(const WindowGeometry *windowGeometry) {
-    float value = windowGeometry->refy;
-    if (windowGeometry->gravity_y != 0) {
-        value -= geometry_get_window_height(windowGeometry)
-                     * windowGeometry->gravity_y;
-    }
-    return (int) value;
-}
-
-static void geometry_set_window_x(WindowGeometry *windowGeometry, int value) {
-    float newValue = value;
-    if (windowGeometry->gravity_x != 0) {
-        newValue += geometry_get_window_width(windowGeometry)
-                * windowGeometry->gravity_x;
-    }
-    windowGeometry->refx = newValue;
-}
-
-static void geometry_set_window_y(WindowGeometry *windowGeometry, int value) {
-    float newValue = value;
-    if (windowGeometry->gravity_y != 0) {
-        newValue += geometry_get_window_height(windowGeometry)
-                * windowGeometry->gravity_y;
+        notify_state(stateChangeEvent);
+    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {
+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);
     }
-    windowGeometry->refy = newValue;
 }
 
-void WindowContextTop::process_net_wm_property() {
+void WindowContext::process_net_wm_property() {
     // Workaround for https://bugs.launchpad.net/unity/+bug/998073
 
     static GdkAtom atom_atom = gdk_atom_intern_static_string("ATOM");
     static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
     static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string("_NET_WM_STATE_HIDDEN");
     static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string("_NET_WM_STATE_ABOVE");
 
     gint length;
-
-    glong* atoms = NULL;
+    glong *atoms = NULL;
 
     if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,
-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {
+                         0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar * *) & atoms)) {
 
         bool is_hidden = false;
         bool is_above = false;
         for (gint i = 0; i < (gint)(length / sizeof(glong)); i++) {
-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {
+            if (atom_net_wm_state_hidden == (GdkAtom) atoms[i]) {
                 is_hidden = true;
-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {
+            } else if (atom_net_wm_state_above == (GdkAtom) atoms[i]) {
                 is_above = true;
             }
         }
 
         g_free(atoms);
 
         if (is_iconified != is_hidden) {
             is_iconified = is_hidden;
 
             notify_state((is_hidden)
-                    ? com_sun_glass_events_WindowEvent_MINIMIZE
-                    : com_sun_glass_events_WindowEvent_RESTORE);
+                         ? com_sun_glass_events_WindowEvent_MINIMIZE
+                         : com_sun_glass_events_WindowEvent_RESTORE);
         }
 
         notify_on_top(is_above);
     }
 }
 
-void WindowContextTop::process_property_notify(GdkEventProperty* event) {
-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
-
-    if (event->atom == atom_net_wm_state && event->window == gdk_window) {
-        process_net_wm_property();
-    }
-}
-
-void WindowContextTop::process_configure(GdkEventConfigure* event) {
-    gint x, y, w, h;
-    bool updateWindowConstraints = false;
-    if (gtk_window_get_decorated(GTK_WINDOW(gtk_widget))) {
-        GdkRectangle frame;
-        gint top, left, bottom, right;
-
-        gdk_window_get_frame_extents(gdk_window, &frame);
-#ifdef GLASS_GTK3
-        gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-        gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-        x = frame.x;
-        y = frame.y;
-        geometry.current_width = frame.width;
-        geometry.current_height = frame.height;
-
-        if (update_frame_extents()) {
-            updateWindowConstraints = true;
-            if (!frame_extents_initialized && !is_null_extents()) {
-                frame_extents_initialized = true;
-                set_bounds(0, 0, false, false,
-                    requested_bounds.width, requested_bounds.height,
-                    requested_bounds.client_width, requested_bounds.client_height
-                );
-            }
-        }
-    } else {
-        x = event->x;
-        y = event->y;
-        w = event->width;
-        h = event->height;
-    }
-
-    if (size_assigned && w <= 1 && h <= 1 && (geometry.final_width.value > 1 ||
-                                             geometry.final_height.value > 1)) {
-        // skip artifact
-        return;
-   }
-
-    // JDK-8232811: to avoid conflicting events, update the geometry only after window pops.
-    if (map_received) {
-        geometry.final_width.value = w;
-        geometry.final_width.type = BOUNDSTYPE_CONTENT;
-        geometry.final_height.value = h;
-        geometry.final_height.type = BOUNDSTYPE_CONTENT;
-    }
-
-    geometry_set_window_x(&geometry, x);
-    geometry_set_window_y(&geometry, y);
-
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-        mainEnv->CallVoidMethod(jview, jViewNotifyView,
-                com_sun_glass_events_ViewEvent_MOVE);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-                (is_maximized)
-                    ? com_sun_glass_events_WindowEvent_MAXIMIZE
-                    : com_sun_glass_events_WindowEvent_RESIZE,
-                geometry.current_width,
-                geometry.current_height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, x, y);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-
-    glong to_screen = getScreenPtrForLocation(x, y);
+void WindowContext::process_screen_changed() {
+    glong to_screen = getScreenPtrForLocation(geometry.current_x, geometry.current_y);
     if (to_screen != -1) {
         if (to_screen != screen) {
             if (jwindow) {
                 //notify screen changed
                 jobject jScreen = createJavaScreen(mainEnv, to_screen);
@@ -1095,235 +803,144 @@
                 CHECK_JNI_EXCEPTION(mainEnv)
             }
             screen = to_screen;
         }
     }
+}
 
-    if (resizable.request != REQUEST_NONE) {
-        set_window_resizable(resizable.request == REQUEST_RESIZABLE);
-        resizable.request = REQUEST_NONE;
-    } else if (!resizable.value) {
-        set_window_resizable(false);
-    } else if (updateWindowConstraints) {
-        update_window_constraints();
-    }
-}
-
-void WindowContextTop::update_window_constraints() {
-    if (resizable.value) {
-        GdkGeometry geom = {
-            (resizable.minw == -1) ? 1
-                    : resizable.minw - geometry.extents.left - geometry.extents.right,
-            (resizable.minh == -1) ? 1
-                    : resizable.minh - geometry.extents.top - geometry.extents.bottom,
-            (resizable.maxw == -1) ? 100000
-                    : resizable.maxw - geometry.extents.left - geometry.extents.right,
-            (resizable.maxh == -1) ? 100000
-                    : resizable.maxh - geometry.extents.top - geometry.extents.bottom,
-            0, 0, 0, 0, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
-        };
-        gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom,
-                static_cast<GdkWindowHints> (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
-    }
-}
-
-void WindowContextTop::set_window_resizable(bool res) {
-    if(!res) {
-        int w = geometry_get_content_width(&geometry);
-        int h = geometry_get_content_height(&geometry);
-        if (w == -1 && h == -1) {
-            gtk_window_get_size(GTK_WINDOW(gtk_widget), &w, &h);
+void WindowContext::notify_on_top(bool top) {
+    // Do not report effective (i.e. native) values to the FX, only if the user sets it manually
+    if (top != effective_on_top() && jwindow) {
+        if (on_top_inherited() && !top) {
+            // Disallow user's "on top" handling on windows that inherited the property
+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        } else {
+            on_top = top;
+            update_ontop_tree(top);
+            mainEnv->CallVoidMethod(jwindow,
+                                    jWindowNotifyLevelChanged,
+                                    top ? com_sun_glass_ui_Window_Level_FLOATING
+                                        : com_sun_glass_ui_Window_Level_NORMAL);
+            CHECK_JNI_EXCEPTION(mainEnv);
         }
-        GdkGeometry geom = {w, h, w, h, 0, 0, 0, 0, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST};
-        gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom,
-                static_cast<GdkWindowHints>(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
-        resizable.value = false;
-    } else {
-        resizable.value = true;
-        update_window_constraints();
     }
 }
 
-void WindowContextTop::set_resizable(bool res) {
-    resizable.prev = false;
-    gint w, h;
-    gtk_window_get_size(GTK_WINDOW(gtk_widget), &w, &h);
-    if (map_received || w > 1 || h > 1) {
-        set_window_resizable(res);
-    } else {
-        //Since window is not ready yet set only request for change of resizable.
-        resizable.request  = res ? REQUEST_RESIZABLE : REQUEST_NOT_RESIZABLE;
+void WindowContext::notify_repaint() {
+    int w, h;
+    glass_gdk_window_get_size(gdk_window, &w, &h);
+    if (jview) {
+        mainEnv->CallVoidMethod(jview,
+                                jViewNotifyRepaint,
+                                0, 0, w, h);
+        CHECK_JNI_EXCEPTION(mainEnv);
     }
 }
 
-void WindowContextTop::set_visible(bool visible)
-{
-    if (visible) {
-        if (!size_assigned) {
-            set_bounds(0, 0, false, false, 320, 200, -1, -1);
-        }
-        if (!location_assigned) {
-            set_bounds(0, 0, true, true, -1, -1, -1, -1);
+void WindowContext::notify_state(jint glass_state) {
+    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {
+        if (is_maximized) {
+            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;
         }
+
+        notify_repaint();
     }
-    WindowContextBase::set_visible(visible);
-    //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
-    if (visible && jwindow && isEnabled()) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
+
+    if (jwindow) {
+        mainEnv->CallVoidMethod(jwindow,
+                                jGtkWindowNotifyStateChanged,
+                                glass_state);
         CHECK_JNI_EXCEPTION(mainEnv);
     }
 }
 
-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-    requested_bounds.width = w;
-    requested_bounds.height = h;
-    requested_bounds.client_width = cw;
-    requested_bounds.client_height = ch;
-
-    if (!frame_extents_initialized && frame_type == TITLED) {
-        update_frame_extents();
-        if (is_null_extents()) {
-            if (!is_null_extents(get_cached_extents())) {
-                geometry.extents = get_cached_extents();
-            }
-        } else {
-            frame_extents_initialized = true;
-        }
+bool WindowContext::set_view(jobject view) {
+    if (jview) {
+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
+                                com_sun_glass_events_MouseEvent_EXIT,
+                                com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                0, 0,
+                                0, 0,
+                                0,
+                                JNI_FALSE,
+                                JNI_FALSE);
+        mainEnv->DeleteGlobalRef(jview);
     }
 
-    XWindowChanges windowChanges;
-    unsigned int windowChangesMask = 0;
-    if (w > 0) {
-        geometry.final_width.value = w;
-        geometry.final_width.type = BOUNDSTYPE_WINDOW;
-        geometry.current_width = geometry_get_window_width(&geometry);
-        windowChanges.width = geometry_get_content_width(&geometry);
-        windowChangesMask |= CWWidth;
-    } else if (cw > 0) {
-        geometry.final_width.value = cw;
-        geometry.final_width.type = BOUNDSTYPE_CONTENT;
-        geometry.current_width = geometry_get_window_width(&geometry);
-        windowChanges.width = geometry_get_content_width(&geometry);
-        windowChangesMask |= CWWidth;
-    }
-
-    if (h > 0) {
-        geometry.final_height.value = h;
-        geometry.final_height.type = BOUNDSTYPE_WINDOW;
-        geometry.current_height = geometry_get_window_height(&geometry);
-        windowChanges.height = geometry_get_content_height(&geometry);
-        windowChangesMask |= CWHeight;
-    } else if (ch > 0) {
-        geometry.final_height.value = ch;
-        geometry.final_height.type = BOUNDSTYPE_CONTENT;
-        geometry.current_height = geometry_get_window_height(&geometry);
-        windowChanges.height = geometry_get_content_height(&geometry);
-        windowChangesMask |= CWHeight;
+    if (view) {
+        jview = mainEnv->NewGlobalRef(view);
+    } else {
+        jview = NULL;
     }
+    return TRUE;
+}
 
-    if (xSet || ySet) {
-        if (xSet) {
-            geometry.refx = x + geometry.current_width * geometry.gravity_x;
-        }
-
-        windowChanges.x = geometry_get_window_x(&geometry);
-        windowChangesMask |= CWX;
-
-        if (ySet) {
-            geometry.refy = y + geometry.current_height * geometry.gravity_y;
+void WindowContext::set_visible(bool visible) {
+    if (visible) {
+        gtk_widget_show_all(gtk_widget);
+    } else {
+        gtk_widget_hide(gtk_widget);
+        if (jview && is_mouse_entered) {
+            is_mouse_entered = false;
+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
+                                    com_sun_glass_events_MouseEvent_EXIT,
+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                    0, 0,
+                                    0, 0,
+                                    0,
+                                    JNI_FALSE,
+                                    JNI_FALSE);
+            CHECK_JNI_EXCEPTION(mainEnv)
         }
-
-        windowChanges.y = geometry_get_window_y(&geometry);
-        windowChangesMask |= CWY;
-
-        location_assigned = true;
     }
 
-    if (w > 0 || h > 0 || cw > 0 || ch > 0) size_assigned = true;
-
-    window_configure(&windowChanges, windowChangesMask);
-
-}
-
-void WindowContextTop::process_map() {
-    map_received = true;
-}
-
-void WindowContextTop::window_configure(XWindowChanges *windowChanges,
-        unsigned int windowChangesMask) {
-    if (windowChangesMask == 0) {
-        return;
+    if (visible) {
+        visible_received = TRUE;
     }
 
-    if (windowChangesMask & (CWX | CWY)) {
-        gint newX, newY;
-        gtk_window_get_position(GTK_WINDOW(gtk_widget), &newX, &newY);
-
-        if (windowChangesMask & CWX) {
-            newX = windowChanges->x;
-        }
-        if (windowChangesMask & CWY) {
-            newY = windowChanges->y;
-        }
-        gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+    //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
+    if (visible && jwindow && isEnabled()) {
+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
+        CHECK_JNI_EXCEPTION(mainEnv);
     }
+}
 
-    if (windowChangesMask & (CWWidth | CWHeight)) {
-        gint newWidth, newHeight;
-        gtk_window_get_size(GTK_WINDOW(gtk_widget), &newWidth, &newHeight);
-
-        if (windowChangesMask & CWWidth) {
-            newWidth = windowChanges->width;
-        }
-        if (windowChangesMask & CWHeight) {
-            newHeight = windowChanges->height;
-        }
-
-        if (!resizable.value) {
-            GdkGeometry geom;
-            GdkWindowHints hints = (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE);
-            geom.min_width = geom.max_width = newWidth;
-            geom.min_height = geom.max_height = newHeight;
-            gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom, hints);
-        }
-        gtk_window_resize(GTK_WINDOW(gtk_widget), newWidth, newHeight);
-
-        //JDK-8193502: Moved here from WindowContextBase::set_view because set_view is called
-        //first and the size is not set yet. This also guarantees that the size will be correct
-        //see: gtk_window_get_size doc for more context.
-        if (jview) {
-            mainEnv->CallVoidMethod(jview, jViewNotifyResize, newWidth, newHeight);
-            CHECK_JNI_EXCEPTION(mainEnv);
+void WindowContext::set_cursor(GdkCursor *cursor) {
+    if (!is_in_drag()) {
+        if (WindowContext::sm_mouse_drag_window) {
+            grab_mouse_drag_focus(cursor, false);
+        } else if (WindowContext::sm_grab_window) {
+            grab_mouse_drag_focus(cursor, true);
         }
     }
+
+    gdk_window_set_cursor(gdk_window, cursor);
 }
 
-void WindowContextTop::applyShapeMask(void* data, uint width, uint height)
-{
-    if (frame_type != TRANSPARENT) {
-        return;
+void WindowContext::set_level(int level) {
+    if (level == com_sun_glass_ui_Window_Level_NORMAL) {
+        on_top = false;
+    } else if (level == com_sun_glass_ui_Window_Level_FLOATING
+               || level == com_sun_glass_ui_Window_Level_TOPMOST) {
+        on_top = true;
     }
+    // We need to emulate always on top behaviour on child windows
 
-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
+    if (!on_top_inherited()) {
+        update_ontop_tree(on_top);
+    }
 }
 
-void WindowContextTop::ensure_window_size() {
-    gint w, h;
-#ifdef GLASS_GTK3
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-    if (size_assigned && (geometry.final_width.value != w
-                       || geometry.final_height.value != h)) {
-
-        gdk_window_resize(gdk_window, geometry.final_width.value,
-                                      geometry.final_height.value);
-    }
+void WindowContext::set_background(float r, float g, float b) {
+    bg_color.red = r;
+    bg_color.green = g;
+    bg_color.blue = b;
+    bg_color.is_set = true;
+    notify_repaint();
 }
 
-void WindowContextTop::set_minimized(bool minimize) {
+void WindowContext::set_minimized(bool minimize) {
     is_iconified = minimize;
     if (minimize) {
         if (frame_type == TRANSPARENT) {
             // https://bugs.launchpad.net/ubuntu/+source/unity/+bug/1245571
             glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));
@@ -1339,601 +956,522 @@
     } else {
         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
         activate_window();
     }
 }
-void WindowContextTop::set_maximized(bool maximize) {
+
+void WindowContext::set_maximized(bool maximize) {
     is_maximized = maximize;
     if (maximize) {
-        ensure_window_size();
+        // enable the functionality
+        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
+        gdk_window_set_functions(gdk_window, wmf);
+
         gtk_window_maximize(GTK_WINDOW(gtk_widget));
     } else {
         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
     }
 }
 
-void WindowContextTop::enter_fullscreen() {
-    ensure_window_size();
-    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
-}
-
-void WindowContextTop::exit_fullscreen() {
-    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));
-}
-
-void WindowContextTop::request_focus() {
-    //JDK-8212060: Window show and then move glitch.
-    //The WindowContextBase::set_visible will take care of showing the window.
-    //The below code will only handle later request_focus.
-    if (is_visible()) {
-        gtk_window_present(GTK_WINDOW(gtk_widget));
-    }
-}
+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
+    calculate_adjustments();
 
-void WindowContextTop::set_focusable(bool focusable) {
-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);
-}
+    // newW / newH always content sizes compatible with GTK+
+    // if window has no decoration, adjustments will be ZERO
+    int newW = w > 0 ? w - geometry.adjust_w : cw;
+    int newH = h > 0 ? h - geometry.adjust_h : ch;
 
-void WindowContextTop::set_title(const char* title) {
-    gtk_window_set_title(GTK_WINDOW(gtk_widget),title);
-}
+    gboolean size_changed = FALSE;
+    gboolean pos_changed = FALSE;
 
-void WindowContextTop::set_alpha(double alpha) {
-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);
-}
+    geometry.window_size_set = (w > 0 || h > 0);
 
-void WindowContextTop::set_enabled(bool enabled) {
-    if (enabled) {
-        if (resizable.prev) {
-            set_window_resizable(true);
-        }
-    } else {
-        if (resizable.value) {
-            set_window_resizable(false);
-            resizable.prev = true;
-        } else if (resizable.request == REQUEST_RESIZABLE) {
-            resizable.request = REQUEST_NOT_RESIZABLE;
-            resizable.prev = true;
-        }
-    }
-}
-
-void WindowContextTop::set_minimum_size(int w, int h) {
-    resizable.minw = w;
-    resizable.minh = h;
-    update_window_constraints();
-}
-
-void WindowContextTop::set_maximum_size(int w, int h) {
-    resizable.maxw = w;
-    resizable.maxh = h;
-    update_window_constraints();
-}
-
-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {
-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);
-}
-
-void WindowContextTop::restack(bool restack) {
-    gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
-}
-
-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {
-    if (modal) {
-        //gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);
-        if (parent) {
-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());
-        }
-    }
-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);
-}
-
-GtkWindow *WindowContextTop::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget);
-}
-
-WindowFrameExtents WindowContextTop::get_frame_extents() {
-    return geometry.extents;
-}
-
-void WindowContextTop::set_gravity(float x, float y) {
-    int oldX = geometry_get_window_x(&geometry);
-    int oldY = geometry_get_window_y(&geometry);
-    geometry.gravity_x = x;
-    geometry.gravity_y = y;
-    geometry_set_window_x(&geometry, oldX);
-    geometry_set_window_y(&geometry, oldY);
-}
-
-void WindowContextTop::update_ontop_tree(bool on_top) {
-    bool effective_on_top = on_top || this->on_top;
-    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);
-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {
-        (*it)->update_ontop_tree(effective_on_top);
-    }
-}
-
-bool WindowContextTop::on_top_inherited() {
-    WindowContext* o = owner;
-    while (o) {
-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);
-        if (!topO) break;
-        if (topO->on_top) {
-            return true;
-        }
-        o = topO->owner;
-    }
-    return false;
-}
-
-bool WindowContextTop::effective_on_top() {
-    if (owner) {
-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);
-        return (topO && topO->effective_on_top()) || on_top;
-    }
-    return on_top;
-}
+    if (newW > 0 && newH > 0) {
+        size_changed = TRUE;
 
-void WindowContextTop::notify_on_top(bool top) {
-    // Do not report effective (i.e. native) values to the FX, only if the user sets it manually
-    if (top != effective_on_top() && jwindow) {
-        if (on_top_inherited() && !top) {
-            // Disallow user's "on top" handling on windows that inherited the property
-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        geometry.current_cw = newW;
+        geometry.current_ch = newH;
+        geometry.current_w = newW + geometry.adjust_w;
+        geometry.current_h = newH + geometry.adjust_h;
+
+        if (visible_received) {
+            // update constraints if not resized by the user interface so it will
+            // let gtk_window_resize succeed, because it's bound to geometry constraints
+            apply_geometry();
+            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
         } else {
-            on_top = top;
-            update_ontop_tree(top);
-            mainEnv->CallVoidMethod(jwindow,
-                    jWindowNotifyLevelChanged,
-                    top ? com_sun_glass_ui_Window_Level_FLOATING :  com_sun_glass_ui_Window_Level_NORMAL);
-            CHECK_JNI_EXCEPTION(mainEnv);
+            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
         }
     }
-}
 
-void WindowContextTop::set_level(int level) {
-    if (level == com_sun_glass_ui_Window_Level_NORMAL) {
-        on_top = false;
-    } else if (level == com_sun_glass_ui_Window_Level_FLOATING
-            || level == com_sun_glass_ui_Window_Level_TOPMOST) {
-        on_top = true;
+    if (xSet || ySet) {
+        int newX = (xSet) ? x : geometry.current_x;
+        int newY = (ySet) ? y : geometry.current_y;
+
+        if (newX != geometry.current_x || newY != geometry.current_y) {
+            pos_changed = TRUE;
+            geometry.current_x = newX;
+            geometry.current_y = newY;
+            gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+        }
     }
-    // We need to emulate always on top behaviour on child windows
 
-    if (!on_top_inherited()) {
-        update_ontop_tree(on_top);
+    size_position_notify(size_changed, pos_changed);
+}
+
+void WindowContext::set_resizable(bool res) {
+    if (res != geometry.resizable) {
+        geometry.resizable = res;
+        apply_geometry();
     }
 }
 
-void WindowContextTop::set_owner(WindowContext * owner_ctx) {
-    owner = owner_ctx;
+void WindowContext::set_focusable(bool focusable) {
+    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);
 }
 
-void WindowContextTop::process_destroy() {
-    if (owner) {
-        owner->remove_child(this);
-    }
+void WindowContext::set_title(const char *title) {
+    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);
+}
 
-    WindowContextBase::process_destroy();
+void WindowContext::set_alpha(double alpha) {
+    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble) alpha);
 }
 
-////////////////////////////// WindowContextPlug ////////////////////////////////
+void WindowContext::set_enabled(bool enabled) {
+    if (enabled != geometry.enabled) {
+        gtk_widget_set_sensitive(gtk_widget, enabled);
+        geometry.enabled = enabled;
+        apply_geometry();
+    }
+}
 
-static gboolean plug_configure(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
-    (void)widget;
+void WindowContext::set_minimum_size(int w, int h) {
+    gboolean changed = geometry.minw != w || geometry.minh != h;
 
-    if (event->type == GDK_CONFIGURE) {
-        ((WindowContextPlug*)user_data)->process_gtk_configure(&event->configure);
+    if (!changed) {
+        return;
     }
-    return FALSE;
-}
 
-WindowContextPlug::WindowContextPlug(jobject _jwindow, void* _owner) :
-        WindowContextBase(),
-        parent()
-{
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
+    geometry.minw = w;
+    geometry.minh = h;
 
-    gtk_widget = gtk_plug_new((Window)PTR_TO_JLONG(_owner));
+    apply_geometry();
+}
 
-    g_signal_connect(G_OBJECT(gtk_widget), "configure-event", G_CALLBACK(plug_configure), this);
+void WindowContext::set_maximum_size(int w, int h) {
+    gboolean changed = geometry.maxw != w || geometry.maxh != h;
 
-    gtk_widget_set_size_request(gtk_widget, 0, 0);
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
+    if (!changed) {
+        return;
+    }
 
-    gtk_widget_realize(gtk_widget);
-    gdk_window = gtk_widget_get_window(gtk_widget);
+    geometry.maxw = w;
+    geometry.maxh = h;
 
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-    gdk_window_register_dnd(gdk_window);
+    apply_geometry();
+}
 
-    gtk_container = gtk_fixed_new();
-    gtk_container_add (GTK_CONTAINER(gtk_widget), gtk_container);
-    gtk_widget_realize(gtk_container);
+void WindowContext::set_icon(GdkPixbuf *pixbuf) {
+    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);
 }
 
-GtkWindow *WindowContextPlug::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget);
+void WindowContext::set_modal(bool modal, WindowContext *parent) {
+    if (modal) {
+        //gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);
+        if (parent) {
+            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());
+        }
+    }
+    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);
 }
 
-void WindowContextPlug::process_configure(GdkEventConfigure* event) {
-    (void)event;
+void WindowContext::set_gravity(float x, float y) {
+    geometry.gravity_x = x;
+    geometry.gravity_y = y;
+}
 
-    //Note: process_gtk_configure is used, so there's no need to handle GDK events
+void WindowContext::set_owner(WindowContext *owner_ctx) {
+    owner = owner_ctx;
 }
 
-void WindowContextPlug::process_gtk_configure(GdkEventConfigure* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+void WindowContext::add_child(WindowContext *child) {
+    children.insert(child);
+    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());
+}
 
-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-            com_sun_glass_events_WindowEvent_RESIZE,
-            event->width,
-            event->height);
-    CHECK_JNI_EXCEPTION(mainEnv)
+void WindowContext::remove_child(WindowContext *child) {
+    children.erase(child);
+    gtk_window_set_transient_for(child->get_gtk_window(), NULL);
+}
 
-    if (!embedded_children.empty()) {
-        WindowContextChild* child = embedded_children.back();
-        child->process_configure(event);
+void WindowContext::show_or_hide_children(bool show) {
+    std::set<WindowContext *>::iterator it;
+    for (it = children.begin(); it != children.end(); ++it) {
+        (*it)->set_minimized(!show);
+        (*it)->show_or_hide_children(show);
     }
 }
 
-bool WindowContextPlug::set_view(jobject view) {
-    // probably never called for applet window
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
-    }
+bool WindowContext::is_visible() {
+    return gtk_widget_get_visible(gtk_widget);
+}
 
-    if (view) {
-        gint width, height;
-        jview = mainEnv->NewGlobalRef(view);
-        gtk_window_get_size(GTK_WINDOW(gtk_widget), &width, &height);
-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);
-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)
+bool WindowContext::is_dead() {
+    return can_be_deleted;
+}
+
+bool WindowContext::grab_focus() {
+    if (WindowContext::sm_mouse_drag_window
+            || grab_mouse_drag_focus(NULL, true)) {
+        WindowContext::sm_grab_window = this;
+        return true;
     } else {
-        jview = NULL;
+        return false;
     }
-    return TRUE;
 }
 
-void WindowContextPlug::window_configure(XWindowChanges *windowChanges,
-        unsigned int windowChangesMask) {
-    if (windowChangesMask == 0) {
-        return;
+void WindowContext::ungrab_focus() {
+    if (!WindowContext::sm_mouse_drag_window) {
+        ungrab_mouse_drag_focus();
     }
 
-    if (windowChangesMask & (CWX | CWY)) {
-        gint newX, newY;
-        gtk_window_get_position(GTK_WINDOW(gtk_widget), &newX, &newY);
+    WindowContext::sm_grab_window = NULL;
 
-        if (windowChangesMask & CWX) {
-            newX = windowChanges->x;
-        }
-        if (windowChangesMask & CWY) {
-            newY = windowChanges->y;
-        }
-        gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+    if (jwindow) {
+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
+        CHECK_JNI_EXCEPTION(mainEnv)
     }
+}
 
-    if (windowChangesMask & (CWWidth | CWHeight)) {
-        gint newWidth, newHeight;
-        gtk_window_get_size(GTK_WINDOW(gtk_widget),
-                &newWidth, &newHeight);
+void WindowContext::restack(bool restack) {
+    gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
+}
 
-        if (windowChangesMask & CWWidth) {
-            newWidth = windowChanges->width;
-        }
-        if (windowChangesMask & CWHeight) {
-            newHeight = windowChanges->height;
-        };
-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);
+void WindowContext::request_focus() {
+    //JDK-8212060: Window show and then move glitch.
+    //The WindowContext::set_visible will take care of showing the window.
+    //The below code will only handle later request_focus.
+    if (is_visible()) {
+        gtk_window_present(GTK_WINDOW(gtk_widget));
     }
 }
 
-void WindowContextPlug::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-    XWindowChanges windowChanges;
-    unsigned int windowChangesMask = 0;
-
-    if (xSet) {
-        windowChanges.x = x;
-        windowChangesMask |= CWX;
-    }
+void WindowContext::enter_fullscreen() {
+    is_fullscreen = TRUE;
+    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
+}
 
-    if (ySet) {
-        windowChanges.y = y;
-        windowChangesMask |= CWY;
-    }
+void WindowContext::exit_fullscreen() {
+    is_fullscreen = FALSE;
+    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));
+}
 
-    if (w > 0) {
-        windowChanges.width = w;
-        windowChangesMask |= CWWidth;
-    } else if (cw > 0) {
-        windowChanges.width = cw;
-        windowChangesMask |= CWWidth;
+// Applied to a temporary full screen window to prevent sending events to Java
+void WindowContext::detach_from_java() {
+    if (jview) {
+        mainEnv->DeleteGlobalRef(jview);
+        jview = NULL;
     }
-
-    if (h > 0) {
-        windowChanges.height = h;
-        windowChangesMask |= CWHeight;
-    } else if (ch > 0) {
-        windowChanges.height = ch;
-        windowChangesMask |= CWHeight;
+    if (jwindow) {
+        mainEnv->DeleteGlobalRef(jwindow);
+        jwindow = NULL;
     }
-
-    window_configure(&windowChanges, windowChangesMask);
 }
-////////////////////////////// WindowContextChild ////////////////////////////////
 
-void WindowContextChild::process_mouse_button(GdkEventButton* event) {
-    WindowContextBase::process_mouse_button(event);
-   // gtk_window_set_focus (GTK_WINDOW (gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW)), NULL);
-    gtk_widget_grab_focus(gtk_widget);
+void WindowContext::increment_events_counter() {
+    ++events_processing_cnt;
 }
 
-static gboolean child_focus_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data)
-{
-    (void)widget;
-
-    WindowContext *ctx = (WindowContext *)user_data;
-    ctx->process_focus(&event->focus_change);
-    return TRUE;
+void WindowContext::decrement_events_counter() {
+    --events_processing_cnt;
 }
 
-WindowContextChild::WindowContextChild(jobject _jwindow,
-                                       void* _owner,
-                                       GtkWidget *parent_widget,
-                                       WindowContextPlug *parent_ctx) :
-        WindowContextBase(),
-        parent(),
-        full_screen_window(),
-        view()
-{
-    (void)_owner;
-
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
-    gtk_widget = gtk_drawing_area_new();
-    parent = parent_ctx;
+size_t WindowContext::get_events_count() {
+    return events_processing_cnt;
+}
 
-    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
+///////////////////////// PROTECTED
 
-    if (xvisualID != 0) {
-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
-        glass_gtk_window_configure_from_visual(gtk_widget, visual);
+void WindowContext::applyShapeMask(void *data, uint width, uint height) {
+    if (frame_type != TRANSPARENT) {
+        return;
     }
 
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
-    gtk_container_add (GTK_CONTAINER(parent_widget), gtk_widget);
-    gtk_widget_realize(gtk_widget);
-    gdk_window = gtk_widget_get_window(gtk_widget);
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-    gdk_window_register_dnd(gdk_window);
-    g_signal_connect(gtk_widget, "focus-in-event", G_CALLBACK(child_focus_callback), this);
-    g_signal_connect(gtk_widget, "focus-out-event", G_CALLBACK(child_focus_callback), this);
+    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
 }
 
-void WindowContextChild::set_visible(bool visible) {
-    std::vector<WindowContextChild*> &embedded_children =
-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+///////////////////////// PRIVATE
 
-    if (visible) {
-        embedded_children.push_back(this);
-    } else {
-        std::vector<WindowContextChild*>::iterator pos
-                = std::find(embedded_children.begin(), embedded_children.end(), this);
-        if (pos != embedded_children.end()) {
-            embedded_children.erase((pos));
-        }
+// This function calculate the deltas between window and window + decoration (titleblar, borders).
+// Only useful if the window manager does not support the frame extents extension - in this case
+// it uses GDK calculation, that is primary based on _NET_FRAME_EXTENTS but will try harder
+// if that's not available.
+void WindowContext::calculate_adjustments() {
+    if (frame_type != TITLED || geometry.frame_extents_received) {
+        return;
     }
 
-    WindowContextBase::set_visible(visible);
-}
+    gint x, y;
+    gdk_window_get_origin(gdk_window, &x, &y);
 
-GtkWindow *WindowContextChild::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW));
-}
+    gint rx, ry;
+    gdk_window_get_root_origin(gdk_window, &rx, &ry);
 
-void WindowContextChild::process_configure(GdkEventConfigure* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+    if (rx != x || ry != y) {
+        // the left extends are correct - the right one is guessed to be the same
+        geometry.adjust_w = (rx - x) * 2;
+        // guess that bottom size is the same as left and right
+        geometry.adjust_h = (ry - y) + (rx - x);
 
-    gtk_widget_set_size_request(gtk_widget, event->width, event->height);
+        // those will be correct
+        geometry.view_x = (rx - x);
+        geometry.view_y = (ry - y);
 
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-                com_sun_glass_events_WindowEvent_RESIZE,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
+        save_cached_extents();
+    } else {
+        CachedExtents c = (window_type == NORMAL) ? normal_extents : utility_extents;
+        geometry.adjust_w = c.adjust_w;
+        geometry.adjust_h = c.adjust_h;
+        geometry.view_x = c.view_x;
+        geometry.view_y = c.view_y;
     }
+
+    apply_geometry();
 }
 
-bool WindowContextChild::set_view(jobject view) {
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
+void WindowContext::save_cached_extents() {
+    if (frame_type != TITLED) {
+        return;
     }
 
-    if (view) {
-        gint width, height;
-        jview = mainEnv->NewGlobalRef(view);
-        GtkAllocation ws;
-        gtk_widget_get_allocation(gtk_widget, &ws);
-        width = ws.width;
-        height = ws.height;
-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);
-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)
+    if (window_type == NORMAL) {
+        normal_extents.adjust_w = geometry.adjust_w;
+        normal_extents.adjust_h = geometry.adjust_h;
+        normal_extents.view_x = geometry.view_x;
+        normal_extents.view_y = geometry.view_y;
     } else {
-        jview = NULL;
+        utility_extents.adjust_w = geometry.adjust_w;
+        utility_extents.adjust_h = geometry.adjust_h;
+        utility_extents.view_x = geometry.view_x;
+        utility_extents.view_y = geometry.view_y;
     }
-    return TRUE;
 }
 
-void WindowContextChild::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-
-    if (x > 0 || y > 0 || xSet || ySet) {
-        gint newX, newY;
-        gdk_window_get_origin(gdk_window, &newX, &newY);
-        if (jwindow) {
-            mainEnv->CallVoidMethod(jwindow,
-                    jWindowNotifyMove,
-                    newX, newY);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
+void WindowContext::apply_geometry() {
+    if (!map_received) {
+        return;
     }
 
-    // As we have no frames, there's no difference between the calls
-    if ((cw | ch) > 0) {
-        w = cw; h = ch;
-    }
+    GdkGeometry gdk_geometry;
+    gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
 
-    if (w > 0 || h > 0) {
-        gint newWidth, newHeight;
-        GtkAllocation ws;
-        gtk_widget_get_allocation(gtk_widget, &ws);
-        newWidth = ws.width;
-        newHeight = ws.height;
+    if ((!geometry.resizable || !geometry.enabled) && !(is_maximized || is_fullscreen)) {
+        // not resizeable
+        int w = (geometry.current_w - geometry.adjust_w) > 0
+                ? geometry.current_w - geometry.adjust_w
+                : geometry.current_cw;
 
-        if (w > 0) {
-            newWidth = w;
-        }
-        if (h > 0) {
-            newHeight = h;
-        }
-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);
-        // FIXME: hack to set correct size to view
-        if (jview) {
-            mainEnv->CallVoidMethod(jview,
-                    jViewNotifyResize,
-                    newWidth, newHeight);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
-    }
-}
+        int h = (geometry.current_h - geometry.adjust_h) > 0
+                ? geometry.current_h - geometry.adjust_h
+                : geometry.current_ch;
 
-int WindowContextChild::getEmbeddedX() {
-    int x;
-    gdk_window_get_origin(gdk_window, &x, NULL);
-    return x;
-}
+        gdk_geometry.min_width = gdk_geometry.max_width = w;
+        gdk_geometry.min_height = gdk_geometry.max_height = h;
+    } else {
+        gdk_geometry.min_width = (geometry.minw - geometry.adjust_w) > 0
+                                 ? geometry.minw - geometry.adjust_w : 1;
+        gdk_geometry.min_height = (geometry.minh - geometry.adjust_h) > 0
+                                  ? geometry.minh - geometry.adjust_h : 1;
 
-int WindowContextChild::getEmbeddedY() {
-    int y;
-    gdk_window_get_origin(gdk_window, NULL, &y);
-    return y;
+        gdk_geometry.max_width = (geometry.maxw - geometry.adjust_w > 0)
+                                 ? geometry.maxw - geometry.adjust_w : G_MAXINT;
+        gdk_geometry.max_height = (geometry.maxh - geometry.adjust_h > 0)
+                                  ? geometry.maxh - geometry.adjust_h : G_MAXINT;
+    }
 
+    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &gdk_geometry,
+                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));
 }
 
-void WindowContextChild::restack(bool toFront) {
-    std::vector<WindowContextChild*> &embedded_children =
-                dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+bool WindowContext::get_frame_extents_property(int *top, int *left,
+                                               int *bottom, int *right) {
+    unsigned long *extents;
 
-    std::vector<WindowContextChild*>::iterator pos
-        = std::find(embedded_children.begin(), embedded_children.end(), this);
+    if (gdk_property_get(gdk_window,
+                         atom_net_wm_frame_extents,
+                         gdk_atom_intern("CARDINAL", FALSE),
+                         0,
+                         sizeof(unsigned long) * 4,
+                         FALSE,
+                         NULL,
+                         NULL,
+                         NULL,
+                         (guchar * *) & extents)) {
+        *left = extents[0];
+        *right = extents[1];
+        *top = extents[2];
+        *bottom = extents[3];
 
-    embedded_children.erase(pos);
-    if (toFront) {
-        embedded_children.push_back(this);
-    } else {
-        embedded_children.insert(embedded_children.begin(), this);
+        g_free(extents);
+        return true;
     }
 
-    gdk_window_restack(gdk_window, NULL, toFront ? TRUE : FALSE);
+    return false;
 }
 
-void WindowContextChild::enter_fullscreen() {
-    if (full_screen_window) {
-        return;
-    }
+void WindowContext::activate_window() {
+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));
+    Atom navAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
+    if (navAtom != None) {
+        XClientMessageEvent clientMessage;
+        memset(&clientMessage, 0, sizeof(clientMessage));
 
-    full_screen_window = new WindowContextTop(jwindow, NULL, 0L, UNTITLED,
-                                                NORMAL, (GdkWMFunction) 0);
-    int x, y, w, h;
-    gdk_window_get_origin(gdk_window, &x, &y);
-#ifdef GLASS_GTK3
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-    full_screen_window->set_bounds(x, y, true, true, w, h, -1, -1);
+        clientMessage.type = ClientMessage;
+        clientMessage.window = GDK_WINDOW_XID(gdk_window);
+        clientMessage.message_type = navAtom;
+        clientMessage.format = 32;
+        clientMessage.data.l[0] = 1;
+        clientMessage.data.l[1] = gdk_x11_get_server_time(gdk_window);
+        clientMessage.data.l[2] = 0;
 
-    if (WindowContextBase::sm_grab_window == this) {
-        ungrab_focus();
+        XSendEvent(display, XDefaultRootWindow(display), False,
+                   SubstructureRedirectMask | SubstructureNotifyMask,
+                   (XEvent * ) & clientMessage);
+        XFlush(display);
     }
+}
 
-    reparent_children(full_screen_window);
+void WindowContext::size_position_notify(bool size_changed, bool pos_changed) {
+    if (jview) {
+        if (size_changed) {
+            mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.current_cw, geometry.current_ch);
+            CHECK_JNI_EXCEPTION(mainEnv);
+        }
 
-    full_screen_window->set_visible(true);
-    full_screen_window->enter_fullscreen();
+        if (pos_changed) {
+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_MOVE);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
+    }
 
     if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)full_screen_window);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+        if (size_changed || is_maximized) {
+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
+                                    (is_maximized)
+                                    ? com_sun_glass_events_WindowEvent_MAXIMIZE
+                                    : com_sun_glass_events_WindowEvent_RESIZE,
+                                    geometry.current_w, geometry.current_h);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
 
-    if (jview) {
-        this->view = (GlassView*)mainEnv->GetLongField(jview, jViewPtr);
+        if (pos_changed) {
+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.current_x, geometry.current_y);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
+    }
+}
 
-        this->view->current_window = full_screen_window;
-        this->view->embedded_window = this;
-        full_screen_window->set_view(jview);
-        this->set_view(NULL);
+void WindowContext::update_ontop_tree(bool on_top) {
+    bool effective_on_top = on_top || this->on_top;
+    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);
+    for (std::set<WindowContext *>::iterator it = children.begin(); it != children.end(); ++it) {
+        (*it)->update_ontop_tree(effective_on_top);
     }
 }
 
-void WindowContextChild::exit_fullscreen() {
-    if (!full_screen_window) {
-        return;
+bool WindowContext::on_top_inherited() {
+    WindowContext *o = owner;
+    while (o) {
+        WindowContext *topO = dynamic_cast<WindowContext *>(o);
+        if (!topO) break;
+        if (topO->on_top) {
+            return true;
+        }
+        o = topO->owner;
     }
+    return false;
+}
 
-    if (WindowContextBase::sm_grab_window == this) {
-        ungrab_focus();
+bool WindowContext::effective_on_top() {
+    if (owner) {
+        WindowContext *topO = dynamic_cast<WindowContext *>(owner);
+        return (topO && topO->effective_on_top()) || on_top;
     }
+    return on_top;
+}
 
-    full_screen_window->reparent_children(this);
+GdkDevice * WindowContext::get_pointer_device() {
+    GdkDevice * device;
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    device = gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget)));
+#else
+    device = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget));
+#endif
+#else
+    // gtk2
+    device = gdk_display_get_core_pointer(gtk_widget_get_display(gtk_widget));
+#endif
 
-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)NULL);
-    CHECK_JNI_EXCEPTION(mainEnv)
+    return device;
+}
 
-    if (this->view) {
-        this->view->current_window = this;
-        this->view->embedded_window = NULL;
+bool WindowContext::grab_mouse_drag_focus(GdkCursor *cursor, bool owner_events) {
+    if (is_grab_disabled()) {
+        return false;
     }
-    this->set_view(full_screen_window->get_jview());
-
-    full_screen_window->detach_from_java();
 
-    full_screen_window->set_view(NULL);
+    ungrab_mouse_drag_focus();
 
-    full_screen_window->set_visible(false);
+    pointer_device = get_pointer_device();
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    GdkGrabStatus status = gdk_seat_grab(gdk_device_get_seat(pointer_device), gdk_window,
+                                          GDK_SEAT_CAPABILITY_ALL_POINTING, owner_events, cursor, NULL, NULL, NULL);
+#else
+    GdkGrabStatus status = gdk_device_grab(pointer_device, gdk_window, GDK_OWNERSHIP_WINDOW, owner_events,
+                                            GDK_ALL_EVENTS_MASK, cursor, GDK_CURRENT_TIME);
+#endif
+#else
+    GdkGrabStatus status = gdk_pointer_grab(gdk_window, owner_events, GDK_ALL_EVENTS_MASK, NULL, cursor, GDK_CURRENT_TIME);
+#endif
+    WindowContext::sm_mouse_drag_window = this;
 
-    destroy_and_delete_ctx(full_screen_window);
-    full_screen_window = NULL;
-    this->view = NULL;
+    return (status == GDK_GRAB_SUCCESS) ? true : false;
 }
 
-void WindowContextChild::process_destroy() {
-    if (full_screen_window) {
-        destroy_and_delete_ctx(full_screen_window);
+void WindowContext::ungrab_mouse_drag_focus() {
+    if (!pointer_device) {
+        return;
     }
 
-    std::vector<WindowContextChild*> &embedded_children =
-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+//#ifdef GLASS_GTK3
+//#if GTK_CHECK_VERSION(3, 20, 0)
+//    gdk_seat_ungrab(gdk_device_get_seat(pointer_device));
+//#else
+//    gdk_device_ungrab(pointer_device, GDK_CURRENT_TIME);
+//#endif
+//#else
+    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+//#endif
+    pointer_device = NULL;
+
+    WindowContext::sm_mouse_drag_window = NULL;
+
+    if (WindowContext::sm_grab_window) {
+        WindowContext::sm_grab_window->grab_focus();
+    }
+}
 
-    std::vector<WindowContextChild*>::iterator pos
-                = std::find(embedded_children.begin(), embedded_children.end(), this);
-    if (pos != embedded_children.end()) {
-        embedded_children.erase((pos));
+WindowContext::~WindowContext() {
+    if (xim.ic) {
+        XDestroyIC(xim.ic);
+        xim.ic = NULL;
+    }
+    if (xim.im) {
+        XCloseIM(xim.im);
+        xim.im = NULL;
     }
 
-    WindowContextBase::process_destroy();
+    gtk_widget_destroy(gtk_widget);
 }
