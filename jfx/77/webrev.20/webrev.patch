diff a/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkWindow.java b/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkWindow.java
--- a/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkWindow.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkWindow.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -198,26 +198,12 @@
 
     @Override
     protected void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet, int w, int h, int cw, int ch, float xGravity, float yGravity) {
         _setGravity(ptr, xGravity, yGravity);
         setBoundsImpl(ptr, x, y, xSet, ySet, w, h, cw, ch);
-
-        if ((w <= 0) && (cw > 0) || (h <= 0) && (ch > 0)) {
-            final int[] extarr = new int[4];
-            getFrameExtents(ptr, extarr);
-
-            // TODO: ((w <= 0) && (cw <= 0)) || ((h <= 0) && (ch <= 0))
-            notifyResize(WindowEvent.RESIZE,
-                         ((w <= 0) && (cw > 0)) ? cw + extarr[0] + extarr[1]
-                                                : w,
-                         ((h <= 0) && (ch > 0)) ? ch + extarr[2] + extarr[3]
-                                                : h);
-        }
     }
 
-    private native void getFrameExtents(long ptr, int[] extarr);
-
     @Override
     protected void _requestInput(long ptr, String text, int type, double width, double height,
                                     double Mxx, double Mxy, double Mxz, double Mxt,
                                     double Myx, double Myy, double Myz, double Myt,
                                     double Mzx, double Mzy, double Mzz, double Mzt) {
diff a/modules/javafx.graphics/src/main/native-glass/gtk/GlassApplication.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/GlassApplication.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/GlassApplication.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/GlassApplication.cpp
@@ -410,11 +410,11 @@
         case GDK_FOCUS_CHANGE:
             return TRUE;
             break;
     }//switch
 
-    if (ctx != NULL ) {
+    if (ctx != NULL) {
         return ctx->isEnabled();
     }
     return TRUE;
 }
 
@@ -433,92 +433,21 @@
         return;
     }
 
     glass_evloop_call_hooks(event);
 
-    if (ctx != NULL && dynamic_cast<WindowContextPlug*>(ctx) && ctx->get_gtk_window()) {
-        WindowContextPlug* ctx_plug = dynamic_cast<WindowContextPlug*>(ctx);
-        if (!ctx_plug->embedded_children.empty()) {
-            // forward to child
-            ctx = (WindowContext*) ctx_plug->embedded_children.back();
-            window = ctx->get_gdk_window();
-        }
-    }
-
     if (ctx != NULL) {
         EventsCounterHelper helper(ctx);
-        try {
-            switch (event->type) {
-                case GDK_PROPERTY_NOTIFY:
-                    ctx->process_property_notify(&event->property);
-                    gtk_main_do_event(event);
-                    break;
-                case GDK_CONFIGURE:
-                    ctx->process_configure(&event->configure);
-                    gtk_main_do_event(event);
-                    break;
-                case GDK_FOCUS_CHANGE:
-                    ctx->process_focus(&event->focus_change);
-                    gtk_main_do_event(event);
-                    break;
-                case GDK_DESTROY:
-                    destroy_and_delete_ctx(ctx);
-                    gtk_main_do_event(event);
-                    break;
-                case GDK_DELETE:
-                    ctx->process_delete();
-                    break;
-                case GDK_EXPOSE:
-                case GDK_DAMAGE:
-                    ctx->process_expose(&event->expose);
-                    break;
-                case GDK_WINDOW_STATE:
-                    ctx->process_state(&event->window_state);
-                    gtk_main_do_event(event);
-                    break;
-                case GDK_BUTTON_PRESS:
-                case GDK_BUTTON_RELEASE:
-                    ctx->process_mouse_button(&event->button);
-                    break;
-                case GDK_MOTION_NOTIFY:
-                    ctx->process_mouse_motion(&event->motion);
-                    gdk_event_request_motions(&event->motion);
-                    break;
-                case GDK_SCROLL:
-                    ctx->process_mouse_scroll(&event->scroll);
-                    break;
-                case GDK_ENTER_NOTIFY:
-                case GDK_LEAVE_NOTIFY:
-                    ctx->process_mouse_cross(&event->crossing);
-                    break;
-                case GDK_KEY_PRESS:
-                case GDK_KEY_RELEASE:
-                    ctx->process_key(&event->key);
-                    break;
-                case GDK_DROP_START:
-                case GDK_DRAG_ENTER:
-                case GDK_DRAG_LEAVE:
-                case GDK_DRAG_MOTION:
-                    process_dnd_target(ctx, &event->dnd);
-                    break;
-                case GDK_MAP:
-                    ctx->process_map();
-                    // fall-through
-                case GDK_UNMAP:
-                case GDK_CLIENT_EVENT:
-                case GDK_VISIBILITY_NOTIFY:
-                case GDK_SETTING:
-                case GDK_OWNER_CHANGE:
-                    gtk_main_do_event(event);
-                    break;
-                default:
-                    break;
-            }
-        } catch (jni_exception&) {
+
+        if (event->type == GDK_EXPOSE) {
+            ctx->process_expose(&event->expose);
+        } else if (event->type == GDK_DRAG_LEAVE) {
+            dnd_drag_leave_callback(ctx);
+        } else {
+            gtk_main_do_event(event);
         }
     } else {
-
         if (window == gdk_screen_get_root_window(gdk_screen_get_default())) {
             if (event->any.type == GDK_PROPERTY_NOTIFY) {
                 if (event->property.atom == gdk_atom_intern_static_string("_NET_WORKAREA")
                         || event->property.atom == gdk_atom_intern_static_string("_NET_CURRENT_DESKTOP")) {
                     screen_settings_changed(gdk_screen_get_default(), NULL);
diff a/modules/javafx.graphics/src/main/native-glass/gtk/GlassCursor.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/GlassCursor.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/GlassCursor.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/GlassCursor.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,149 +29,187 @@
 #include <jni.h>
 
 #include "com_sun_glass_ui_Cursor.h"
 #include "glass_general.h"
 
+#ifndef GLASS_GTK3
+static GdkCursor* find_best_cursor(const gchar* options, GdkCursorType type) {
+    gchar **opts = g_strsplit(options, ",", -1);
+    gint size = g_strv_length(opts);
+
+    GdkCursor *cursor = NULL;
+
+    for (int i = 0; i < size; i++) {
+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), opts[i]);
+
+        if (cursor != NULL) {
+            break;
+        }
+    }
+
+    g_strfreev(opts);
+
+    if (cursor != NULL) {
+        return cursor;
+    }
+
+    return gdk_cursor_new_for_display(gdk_display_get_default(), type);
+}
+
 GdkCursor* get_native_cursor(int type)
 {
     GdkCursor *cursor = NULL;
     switch (type) {
         case com_sun_glass_ui_Cursor_CURSOR_DEFAULT:
-            cursor = gdk_cursor_new(GDK_LEFT_PTR);
+            cursor = find_best_cursor("default", GDK_LEFT_PTR);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_TEXT:
-            cursor = gdk_cursor_new(GDK_XTERM);
+            cursor = find_best_cursor("text", GDK_XTERM);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_CROSSHAIR:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "cross");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "crosshair");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_CROSSHAIR);
+            cursor = find_best_cursor("cross,crosshair", GDK_CROSSHAIR);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_CLOSED_HAND:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "closedhand");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_HAND2);
+            cursor = find_best_cursor("closedhand", GDK_HAND2);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_OPEN_HAND:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "openhand");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_HAND2);
+            cursor = find_best_cursor("openhand", GDK_HAND2);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_POINTING_HAND:
             cursor = gdk_cursor_new(GDK_HAND2);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UP:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "n-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ns-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_ver");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_TOP_SIDE);
+            cursor = find_best_cursor("n-resize,ns-resize,size_ver", GDK_TOP_SIDE);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_DOWN:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "s-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ns-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_ver");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_BOTTOM_SIDE);
+            cursor = find_best_cursor("s-resize,ns-resize,size_ver", GDK_BOTTOM_SIDE);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UPDOWN:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ns-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_ver");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_SB_V_DOUBLE_ARROW);
+            cursor = find_best_cursor("ns-resize,ew-resize,size_ver", GDK_SB_V_DOUBLE_ARROW);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFT:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "w-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ew-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_hor");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_LEFT_SIDE);
+            cursor = find_best_cursor("w-resize,ew-resize,size_hor", GDK_LEFT_SIDE);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_RIGHT:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "e-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ew-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_hor");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_RIGHT_SIDE);
+            cursor = find_best_cursor("e-resize,ew-resize,size_hor", GDK_RIGHT_SIDE);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFTRIGHT:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ew-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_hor");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_SB_H_DOUBLE_ARROW);
+            cursor = find_best_cursor("ew-resize,size_hor", GDK_SB_H_DOUBLE_ARROW);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHWEST:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "sw-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "nesw-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_bdiag");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);
+            cursor = find_best_cursor("sw-resize,nesw-resize,size_bdiag", GDK_BOTTOM_LEFT_CORNER);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHEAST:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "ne-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "nesw-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_bdiag");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);
+            cursor = find_best_cursor("ne-resize,nesw-resize,size_bdiag", GDK_TOP_RIGHT_CORNER);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHEAST:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "se-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "nwse-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_fdiag");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);
+            cursor = find_best_cursor("se-resize,nwse-resize,size_fdiag", GDK_BOTTOM_RIGHT_CORNER);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHWEST:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "nw-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "nwse-resize");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "size_fdiag");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_TOP_LEFT_CORNER);
+            cursor = find_best_cursor("nw-resize,nwse-resize,size_fdiag", GDK_TOP_LEFT_CORNER);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_MOVE:
-            cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "fleur");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "move");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "all-scroll");
-            if (cursor == NULL)
-                cursor = gdk_cursor_new(GDK_SIZING);
+            cursor = find_best_cursor("fleur,move,alt-scroll", GDK_SIZING);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_WAIT:
-            cursor = gdk_cursor_new(GDK_WATCH);
+            cursor = find_best_cursor("wait", GDK_WATCH);
             break;
         case com_sun_glass_ui_Cursor_CURSOR_DISAPPEAR:
         case com_sun_glass_ui_Cursor_CURSOR_NONE:
-            cursor = gdk_cursor_new(GDK_BLANK_CURSOR);
+            cursor = find_best_cursor("none", GDK_BLANK_CURSOR);
             break;
         default:
-            cursor = gdk_cursor_new(GDK_LEFT_PTR);
+            cursor = find_best_cursor("default", GDK_LEFT_PTR);
             break;
     }
 
+    if (cursor == NULL) {
+        cursor = find_best_cursor("default", GDK_LEFT_PTR);
+    }
+
+    return cursor;
+}
+#else
+GdkCursor* get_native_cursor(int type)
+{
+    gchar* cursor_name = NULL;
+
+    switch (type) {
+        case com_sun_glass_ui_Cursor_CURSOR_DEFAULT:
+            cursor_name = g_strdup("default");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_TEXT:
+            cursor_name = g_strdup("text");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_CROSSHAIR:
+            cursor_name = g_strdup("crosshair");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_CLOSED_HAND:
+            cursor_name = g_strdup("grabbing");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_OPEN_HAND:
+            cursor_name = g_strdup("grab");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_POINTING_HAND:
+            cursor_name = g_strdup("pointer");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UP:
+            cursor_name = g_strdup("n-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_DOWN:
+            cursor_name = g_strdup("s-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_UPDOWN:
+            cursor_name = g_strdup("ns-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFT:
+            cursor_name = g_strdup("w-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_RIGHT:
+            cursor_name = g_strdup("e-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_LEFTRIGHT:
+            cursor_name = g_strdup("ew-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHWEST:
+            cursor_name = g_strdup("sw-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHEAST:
+            cursor_name = g_strdup("ne-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_SOUTHEAST:
+            cursor_name = g_strdup("se-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_RESIZE_NORTHWEST:
+            cursor_name = g_strdup("nw-resize");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_MOVE:
+            cursor_name = g_strdup("move");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_WAIT:
+            cursor_name = g_strdup("wait");
+            break;
+        case com_sun_glass_ui_Cursor_CURSOR_DISAPPEAR:
+        case com_sun_glass_ui_Cursor_CURSOR_NONE:
+            cursor_name = g_strdup("none");
+            break;
+        default:
+            cursor_name = g_strdup("default");
+            break;
+    }
+
+    GdkCursor* cursor = gdk_cursor_new_from_name(gdk_display_get_default(), cursor_name);
+
+    if (cursor == NULL) {
+        cursor = gdk_cursor_new_from_name(gdk_display_get_default(), "default");
+    }
+
+    g_free(cursor_name);
+
     return cursor;
 }
+#endif
 
 extern "C" {
 
 /*
  * Class:     com_sun_glass_ui_gtk_GtkCursor
diff a/modules/javafx.graphics/src/main/native-glass/gtk/GlassView.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/GlassView.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/GlassView.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/GlassView.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -100,11 +100,11 @@
     (void)env;
     (void)obj;
 
     GlassView* view = JLONG_TO_GLASSVIEW(ptr);
     if (view && view->current_window) {
-        return view->current_window->get_frame_extents().left;
+        return view->current_window->get_geometry().view_x;
     }
     return 0;
 }
 
 /*
@@ -118,11 +118,11 @@
     (void)env;
     (void)obj;
 
     GlassView* view = JLONG_TO_GLASSVIEW(ptr);
     if (view && view->current_window) {
-        return view->current_window->get_frame_extents().top;
+        return view->current_window->get_geometry().view_y;
     }
     return 0;
 }
 
 /*
diff a/modules/javafx.graphics/src/main/native-glass/gtk/GlassWindow.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/GlassWindow.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/GlassWindow.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/GlassWindow.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -82,11 +82,11 @@
 {
     (void)env;
 
     WindowContext* parent = JLONG_TO_WINDOW_CTX(owner);
 
-    WindowContext* ctx = new WindowContextTop(obj,
+    WindowContext* ctx = new WindowContext(obj,
             parent,
             screen,
             glass_mask_to_window_frame_type(mask),
             glass_mask_to_window_type(mask),
             glass_mask_to_wm_function(mask)
@@ -103,40 +103,11 @@
 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1createChildWindow
   (JNIEnv * env, jobject obj , jlong owner)
 {
     (void)env;
 
-    GdkWindow *parent_window = NULL;
-    GtkWidget *parent_widget = NULL;
-    WindowContextPlug *parent_ctx = NULL;
-    WindowContext *ctx = NULL;
-
-    parent_window = gdk_x11_window_lookup_for_display(
-                        gdk_display_get_default(),
-                        (Window)PTR_TO_JLONG(owner));
-
-    if (parent_window != NULL) {
-        parent_ctx = (WindowContextPlug *)g_object_get_data(G_OBJECT(parent_window), GDK_WINDOW_DATA_CONTEXT);
-        // HACK: do not use get_gtk_window()
-        // the method is intended to return GtkWindow that can be used for FileChooser
-        // (OK, that's also a hack, but still...)
-        if (parent_ctx != NULL) {
-            parent_widget = GTK_WIDGET(parent_ctx->get_gtk_window());
-        }
-    }
-
-    if (parent_widget == NULL) {
-        // If 'owner' is a bad handle, then the child window is created unparented
-        ctx = new WindowContextPlug(obj, JLONG_TO_PTR(owner));
-    } else {
-        ctx = new WindowContextChild(obj,
-                        JLONG_TO_PTR(owner),
-                        parent_ctx->gtk_container,
-                        parent_ctx);
-    }
-
-    return PTR_TO_JLONG(ctx);
+    return 0;
 }
 
 /*
  * Class:     com_sun_glass_ui_gtk_GtkWindow
  * Method:    _close
@@ -428,12 +399,10 @@
     (void)env;
     (void)obj;
 
     WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);
     if (w == 0 || h == 0) return JNI_FALSE;
-    if (w == -1) w = G_MAXSHORT;
-    if (h == -1) h = G_MAXSHORT;
 
     ctx->set_maximum_size(w, h);
     return JNI_TRUE;
 }
 
@@ -588,28 +557,10 @@
     (void)obj;
 
     WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);
     return GDK_WINDOW_XID(ctx->get_gdk_window());
 }
-/*
- * Class:     com_sun_glass_ui_gtk_GtkWindow
- * Method:    getFrameExtents
- * Signature: (J[I)V
- */
-JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow_getFrameExtents
-    (JNIEnv * env, jobject obj, jlong ptr, jintArray extarr)
-{
-    (void)obj;
-
-    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);
-    WindowFrameExtents extents = ctx->get_frame_extents();
-
-    env->SetIntArrayRegion(extarr, 0, 1, &extents.left);
-    env->SetIntArrayRegion(extarr, 1, 1, &extents.right);
-    env->SetIntArrayRegion(extarr, 2, 1, &extents.top);
-    env->SetIntArrayRegion(extarr, 3, 1, &extents.bottom);
-}
 
 /*
  * Class:     com_sun_glass_ui_gtk_GtkWindow
  * Method:    _setGravity
  * Signature: (JFF)V
@@ -634,14 +585,10 @@
 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedX
   (JNIEnv *env, jobject obj, jlong ptr) {
     (void)env;
     (void)obj;
 
-    if (ptr) {
-        WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);
-        return (jint) ctx->getEmbeddedX();
-    }
     return 0;
 }
 
 /*
  * Class:     com_sun_glass_ui_gtk_GtkWindow
@@ -651,13 +598,9 @@
 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1getEmbeddedY
   (JNIEnv *env, jobject obj, jlong ptr) {
     (void)env;
     (void)obj;
 
-    if (ptr) {
-        WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);
-        return (jint) ctx->getEmbeddedY();
-    }
     return 0;
 }
 
 } // extern "C"
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.cpp
@@ -20,10 +20,11 @@
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+
 #include "glass_dnd.h"
 #include "glass_general.h"
 #include "glass_evloop.h"
 
 #include "com_sun_glass_events_DndEvent.h"
@@ -35,614 +36,506 @@
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
 #include <gdk/gdkkeysyms.h>
 
 /************************* COMMON *********************************************/
-static jint translate_gdk_action_to_glass(GdkDragAction action)
-{
+static jint translate_gdk_action_to_glass(GdkDragAction action) {
     jint result = 0;
-    result |= (action & GDK_ACTION_COPY)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;
-    result |= (action & GDK_ACTION_MOVE)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;
-    result |= (action & GDK_ACTION_LINK)? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;
+    result |= (action & GDK_ACTION_COPY) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY : 0;
+    result |= (action & GDK_ACTION_MOVE) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE : 0;
+    result |= (action & GDK_ACTION_LINK) ? com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE : 0;
     return result;
 }
 
-static GdkDragAction translate_glass_action_to_gdk(jint action)
-{
+static GdkDragAction translate_glass_action_to_gdk(jint action) {
     int result = 0;
-    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY)? GDK_ACTION_COPY : 0;
-    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE)? GDK_ACTION_MOVE : 0;
-    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE)? GDK_ACTION_LINK : 0;
+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_COPY) ? GDK_ACTION_COPY : 0;
+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_MOVE) ? GDK_ACTION_MOVE : 0;
+    result |= (action & com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_REFERENCE) ? GDK_ACTION_LINK : 0;
     return static_cast<GdkDragAction>(result);
 }
 
-static gboolean target_atoms_initialized = FALSE;
-static GdkAtom TARGET_UTF8_STRING_ATOM;
-static GdkAtom TARGET_MIME_TEXT_PLAIN_ATOM;
-static GdkAtom TARGET_COMPOUND_TEXT_ATOM;
-static GdkAtom TARGET_STRING_ATOM;
-
-static GdkAtom TARGET_MIME_URI_LIST_ATOM;
-
-static GdkAtom TARGET_MIME_PNG_ATOM;
-static GdkAtom TARGET_MIME_JPEG_ATOM;
-static GdkAtom TARGET_MIME_TIFF_ATOM;
-static GdkAtom TARGET_MIME_BMP_ATOM;
-
-static void init_target_atoms()
-{
-    if (target_atoms_initialized) {
-        return;
-    }
-    TARGET_UTF8_STRING_ATOM = gdk_atom_intern_static_string("UTF8_STRING");
-    TARGET_MIME_TEXT_PLAIN_ATOM = gdk_atom_intern_static_string("text/plain");
-    TARGET_COMPOUND_TEXT_ATOM = gdk_atom_intern_static_string("COMPOUND_TEXT");
-    TARGET_STRING_ATOM = gdk_atom_intern_static_string("STRING");
-
-    TARGET_MIME_URI_LIST_ATOM = gdk_atom_intern_static_string("text/uri-list");
-
-    TARGET_MIME_PNG_ATOM = gdk_atom_intern_static_string("image/png");
-    TARGET_MIME_JPEG_ATOM = gdk_atom_intern_static_string("image/jpeg");
-    TARGET_MIME_TIFF_ATOM = gdk_atom_intern_static_string("image/tiff");
-    TARGET_MIME_BMP_ATOM = gdk_atom_intern_static_string("image/bmp");
-
-    target_atoms_initialized = TRUE;
-}
-
-static gboolean target_is_text(GdkAtom target)
-{
-    init_target_atoms();
-
-    return (target == TARGET_UTF8_STRING_ATOM ||
-            target == TARGET_STRING_ATOM ||
-            target == TARGET_MIME_TEXT_PLAIN_ATOM/* ||
-            target == TARGET_COMPOUND_TEXT_ATOM*/);
-}
-
-static gboolean target_is_uri(GdkAtom target)
-{
-    init_target_atoms();
-    return target == TARGET_MIME_URI_LIST_ATOM;
-}
-
-static gboolean target_is_image(GdkAtom target)
-{
-    init_target_atoms();
-    return (target == TARGET_MIME_PNG_ATOM ||
-            target == TARGET_MIME_JPEG_ATOM ||
-            target == TARGET_MIME_TIFF_ATOM ||
-            target == TARGET_MIME_BMP_ATOM);
-}
-
-static void clear_global_ref(gpointer data)
-{
-    mainEnv->DeleteGlobalRef((jobject)data);
+static void clear_global_ref(gpointer data) {
+    mainEnv->DeleteGlobalRef((jobject) data);
 }
 
 static void dnd_set_performed_action(jint performed_action);
+
 static jint dnd_get_performed_action();
 
-/************************* TARGET *********************************************/
-struct selection_data_ctx {
-    gboolean received;
-    guchar *data;
-    GdkAtom type;
-    gint format;
-    gint length;
+enum {
+    TARGET_TEXT,
+    TARGET_IMAGE,
+    TARGET_URI,
+    TARGET_RAW
 };
 
-static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx);
+/************************* TARGET *********************************************/
 
 static struct {
     GdkDragContext *ctx;
+    GtkSelectionData *data;
     gboolean just_entered;
     jobjectArray mimes;
-    gint dx, dy;
-} enter_ctx = {NULL, FALSE, NULL, 0, 0};
+} target_ctx = {NULL, NULL, FALSE, NULL};
 
 gboolean is_dnd_owner = FALSE;
-
 GtkWidget *drag_widget = NULL;
 
 gboolean is_in_drag() {
     return drag_widget != NULL;
 }
 
-static void reset_enter_ctx() {
-    if (enter_ctx.mimes != NULL) {
-        mainEnv->DeleteGlobalRef(enter_ctx.mimes);
+static void reset_target_ctx() {
+    if (target_ctx.mimes != NULL) {
+        mainEnv->DeleteGlobalRef(target_ctx.mimes);
     }
 
-    memset(&enter_ctx, 0, sizeof(enter_ctx));
+    memset(&target_ctx, 0, sizeof(target_ctx));
 }
 
-static void process_dnd_target_drag_enter(WindowContext *ctx, GdkEventDND *event)
-{
-    reset_enter_ctx();
-    enter_ctx.ctx = event->context;
-    enter_ctx.just_entered = TRUE;
-    gdk_window_get_origin(ctx->get_gdk_window(), &enter_ctx.dx, &enter_ctx.dy);
-    is_dnd_owner = is_in_drag();
-}
+static gboolean dnd_drag_motion_callback(GtkWidget *widget,
+                                         GdkDragContext *context,
+                                         gint x,
+                                         gint y,
+                                         guint time,
+                                         gpointer user_data) {
+
+    WindowContext *ctx = (WindowContext *) user_data;
 
-static void process_dnd_target_drag_motion(WindowContext *ctx, GdkEventDND *event)
-{
-    if (!enter_ctx.ctx) {
-        gdk_drag_status(event->context, static_cast<GdkDragAction>(0), GDK_CURRENT_TIME);
-        return; // Do not process motion events if no enter event was received
+    if (target_ctx.ctx == NULL || (target_ctx.ctx != context && !target_ctx.just_entered)) {
+        reset_target_ctx();
+        is_dnd_owner = is_in_drag();
+        target_ctx.ctx = context;
+        target_ctx.just_entered = TRUE;
     }
-    jmethodID method = enter_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;
-    GdkDragAction suggested = gdk_drag_context_get_suggested_action(event->context);
+
+    gint x_abs, y_abs;
+    gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &x_abs, &y_abs);
+
+    jmethodID method = target_ctx.just_entered ? jViewNotifyDragEnter : jViewNotifyDragOver;
+
+    GdkDragAction suggested = gdk_drag_context_get_suggested_action(context);
     GdkDragAction result = translate_glass_action_to_gdk(mainEnv->CallIntMethod(ctx->get_jview(), method,
-            (jint)event->x_root - enter_ctx.dx, (jint)event->y_root - enter_ctx.dy,
-            (jint)event->x_root, (jint)event->y_root,
-            translate_gdk_action_to_glass(suggested)));
-    CHECK_JNI_EXCEPTION(mainEnv)
+                                                                                (jint) x, (jint) y,
+                                                                                (jint) x_abs, (jint) y_abs,
+                                                                                translate_gdk_action_to_glass(
+                                                                                        suggested)));
+    CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)
 
-    if (enter_ctx.just_entered) {
-        enter_ctx.just_entered = FALSE;
+    if (target_ctx.just_entered) {
+        target_ctx.just_entered = FALSE;
     }
-    gdk_drag_status(event->context, result, GDK_CURRENT_TIME);
+
+    gdk_drag_status(context, result, GDK_CURRENT_TIME);
+
+    return (gboolean) result;
 }
 
-static void process_dnd_target_drag_leave(WindowContext *ctx, GdkEventDND *event)
-{
-    (void)event;
+static gboolean dnd_drag_drop_callback(GtkWidget *widget,
+                                       GdkDragContext *context,
+                                       gint x,
+                                       gint y,
+                                       guint time,
+                                       gpointer user_data) {
+    if (target_ctx.ctx == NULL || target_ctx.just_entered) {
+        return FALSE; // Do not process drop events if no enter event and subsequent motion event were received
+    }
 
-    mainEnv->CallVoidMethod(ctx->get_jview(), jViewNotifyDragLeave, NULL);
-    CHECK_JNI_EXCEPTION(mainEnv)
+    GdkAtom target = gtk_drag_dest_find_target(widget, context, NULL);
+
+    if (target == GDK_NONE) {
+        // used for RAW
+        target = gdk_atom_intern_static_string("");
+    }
+
+    gtk_drag_get_data(widget, context, target, GDK_CURRENT_TIME);
+
+    return TRUE;
 }
 
-static void process_dnd_target_drop_start(WindowContext *ctx, GdkEventDND *event)
-{
-    if (!enter_ctx.ctx || enter_ctx.just_entered) {
-        gdk_drop_finish(event->context, FALSE, GDK_CURRENT_TIME);
-        gdk_drop_reply(event->context, FALSE, GDK_CURRENT_TIME);
-        return; // Do not process drop events if no enter event and subsequent motion event were received
+static void dnd_on_drag_data_received_callback(GtkWidget *widget,
+                                               GdkDragContext *context,
+                                               gint x,
+                                               gint y,
+                                               GtkSelectionData *data,
+                                               guint info,
+                                               guint time,
+                                               gpointer user_data) {
+    WindowContext *ctx = (WindowContext *) user_data;
+
+    if (gtk_selection_data_get_length(data) == 0) {
+        gtk_drag_finish(context, FALSE, FALSE, GDK_CURRENT_TIME);
+        reset_target_ctx();
+        return;
     }
-    GdkDragAction selected = gdk_drag_context_get_selected_action(event->context);
 
+    gint x_abs, y_abs;
+    gdk_window_get_origin(gdk_drag_context_get_dest_window(context), &x_abs, &y_abs);
+    GdkDragAction selected = gdk_drag_context_get_selected_action(context);
+    target_ctx.data = data;
+
+    // Delay the notify for when we have the data
     mainEnv->CallIntMethod(ctx->get_jview(), jViewNotifyDragDrop,
-            (jint)event->x_root - enter_ctx.dx, (jint)event->y_root - enter_ctx.dy,
-            (jint)event->x_root, (jint)event->y_root,
-            translate_gdk_action_to_glass(selected));
+                           (jint) x, (jint) y,
+                           (jint) x_abs, (jint) y_abs,
+                           translate_gdk_action_to_glass(selected));
     LOG_EXCEPTION(mainEnv)
 
-    gdk_drop_finish(event->context, TRUE, GDK_CURRENT_TIME);
-    gdk_drop_reply(event->context, TRUE, GDK_CURRENT_TIME);
+    gtk_drag_finish(context, selected, selected == GDK_ACTION_MOVE, GDK_CURRENT_TIME);
+}
+
+void dnd_drag_leave_callback(WindowContext *ctx) {
+    mainEnv->CallVoidMethod(ctx->get_jview(), jViewNotifyDragLeave, NULL);
+    CHECK_JNI_EXCEPTION(mainEnv)
+
+    reset_target_ctx();
+}
+
+void glass_dnd_attach_context(WindowContext *ctx) {
+    gtk_drag_dest_set(ctx->get_gtk_widget(), (GtkDestDefaults) 0, NULL, 0,
+                      (GdkDragAction)(GDK_ACTION_COPY | GDK_ACTION_MOVE | GDK_ACTION_LINK));
+
+    GtkTargetList *target_list = gtk_target_list_new(NULL, 0);
+    gtk_target_list_add_image_targets(target_list, TARGET_IMAGE, TRUE);
+    gtk_target_list_add_uri_targets(target_list, TARGET_URI);
+    gtk_target_list_add_text_targets(target_list, TARGET_TEXT);
+    gtk_target_list_add(target_list, gdk_atom_intern_static_string(""), 0, TARGET_RAW);
+
+    gtk_drag_dest_set_target_list(ctx->get_gtk_widget(), target_list);
+
+    g_signal_connect(ctx->get_gtk_widget(), "drag-motion", G_CALLBACK(dnd_drag_motion_callback), ctx);
+    g_signal_connect(ctx->get_gtk_widget(), "drag-drop", G_CALLBACK(dnd_drag_drop_callback), ctx);
+    g_signal_connect(ctx->get_gtk_widget(), "drag-data-received", G_CALLBACK(dnd_on_drag_data_received_callback), ctx);
 }
 
-static gboolean check_state_in_drag(JNIEnv *env)
-{
-    if (!enter_ctx.ctx) {
+static gboolean check_state_in_drag(JNIEnv *env) {
+    if (!target_ctx.ctx) {
         jclass jc = env->FindClass("java/lang/IllegalStateException");
         if (!env->ExceptionCheck()) {
             env->ThrowNew(jc,
-                    "Cannot get supported actions. Drag pointer haven't entered the application window");
+                          "Cannot get supported actions. Drag pointer haven't entered the application window");
         }
         return TRUE;
     }
     return FALSE;
 }
 
-// Events coming from application that are related to us being a DnD target
-void process_dnd_target(WindowContext *ctx, GdkEventDND *event)
-{
-    switch (event->type) {
-        case GDK_DRAG_ENTER:
-            process_dnd_target_drag_enter(ctx, event);
-            break;
-        case GDK_DRAG_MOTION:
-            process_dnd_target_drag_motion(ctx, event);
-            break;
-        case GDK_DRAG_LEAVE:
-            process_dnd_target_drag_leave(ctx, event);
-            break;
-        case GDK_DROP_START:
-            process_dnd_target_drop_start(ctx, event);
-            break;
-        default:
-            break;
+static GdkAtom *get_target_ctx_target_atoms(gint *size) {
+    GList *targets = gdk_drag_context_list_targets(target_ctx.ctx);
+    gint s = (gint) g_list_length(targets);
+    GdkAtom *atoms = (GdkAtom *) g_try_malloc0(sizeof(GdkAtom) * s);
+
+    int i = 0;
+    for (; targets != NULL; targets = targets->next) {
+        atoms[i++] = (GdkAtom) targets->data;
     }
+
+    *size = s;
+
+    g_list_free(targets);
+    return atoms;
 }
 
-jobjectArray dnd_target_get_mimes(JNIEnv *env)
-{
+jobjectArray dnd_target_get_mimes(JNIEnv *env) {
     if (check_state_in_drag(env)) {
         return NULL;
     }
-    if (!enter_ctx.mimes) {
-        GList* targets = gdk_drag_context_list_targets(enter_ctx.ctx);
+
+    if (!target_ctx.mimes) {
         jobject set = env->NewObject(jHashSetCls, jHashSetInit, NULL);
         EXCEPTION_OCCURED(env);
 
-        while (targets) {
-            GdkAtom target = GDK_POINTER_TO_ATOM(targets->data);
-            gchar *name = gdk_atom_name(target);
+        gboolean was_set = FALSE;
+        gint size;
+        GdkAtom *targets = get_target_ctx_target_atoms(&size);
 
-            if (target_is_text(target)) {
-                jstring jStr = env->NewStringUTF("text/plain");
-                EXCEPTION_OCCURED(env);
-                env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
-                EXCEPTION_OCCURED(env);
-            }
+        if (gtk_targets_include_image(targets, size, TRUE)) {
+            jstring jStr = env->NewStringUTF("application/x-java-rawimage");
+            EXCEPTION_OCCURED(env);
+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
+            EXCEPTION_OCCURED(env);
+            was_set = TRUE;
+        }
+        if (gtk_targets_include_uri(targets, size)) {
+            // it's a possibility
+            jstring jStr = env->NewStringUTF("application/x-java-file-list");
+            EXCEPTION_OCCURED(env);
+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
+            EXCEPTION_OCCURED(env);
 
-            if (target_is_image(target)) {
-                jstring jStr = env->NewStringUTF("application/x-java-rawimage");
-                EXCEPTION_OCCURED(env);
-                env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
-                EXCEPTION_OCCURED(env);
-            }
+            jstring jStr2 = env->NewStringUTF("text/uri-list");
+            EXCEPTION_OCCURED(env);
+            env->CallBooleanMethod(set, jSetAdd, jStr2, NULL);
+            EXCEPTION_OCCURED(env);
+            was_set = TRUE;
+        } else if (gtk_targets_include_text(targets, size)) {
+            jstring jStr = env->NewStringUTF("text/plain");
+            EXCEPTION_OCCURED(env);
+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
+            EXCEPTION_OCCURED(env);
+            was_set = TRUE;
+        }
 
-            if (target_is_uri(target)) {
-                selection_data_ctx ctx;
-                if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &ctx)) {
-                    gchar** uris = g_uri_list_extract_uris((gchar *) ctx.data);
-                    guint size = g_strv_length(uris);
-                    guint files_cnt = get_files_count(uris);
-                    if (files_cnt) {
-                        jstring jStr = env->NewStringUTF("application/x-java-file-list");
-                        EXCEPTION_OCCURED(env);
-                        env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
-                        EXCEPTION_OCCURED(env);
-                    }
-                    if (size - files_cnt) {
-                        jstring jStr = env->NewStringUTF("text/uri-list");
-                        EXCEPTION_OCCURED(env);
-                        env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
-                        EXCEPTION_OCCURED(env);
-                    }
-                    g_strfreev(uris);
-                }
-                g_free(ctx.data);
-            } else {
-                jstring jStr = env->NewStringUTF(name);
-                EXCEPTION_OCCURED(env);
-                env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
-                EXCEPTION_OCCURED(env);
-            }
+        g_free(targets);
+
+        if (!was_set) {
+            GdkAtom target = gtk_selection_data_get_target(target_ctx.data);
+            gchar *name = gdk_atom_name(target);
 
+            jstring jStr = env->NewStringUTF(name);
+            EXCEPTION_OCCURED(env);
+            env->CallBooleanMethod(set, jSetAdd, jStr, NULL);
+            EXCEPTION_OCCURED(env);
             g_free(name);
-            targets = targets->next;
         }
-        enter_ctx.mimes = env->NewObjectArray(env->CallIntMethod(set, jSetSize, NULL),
-                jStringCls, NULL);
+
+        target_ctx.mimes = env->NewObjectArray(env->CallIntMethod(set, jSetSize, NULL),
+                                               jStringCls, NULL);
         EXCEPTION_OCCURED(env);
-        enter_ctx.mimes = (jobjectArray)env->CallObjectMethod(set, jSetToArray, enter_ctx.mimes, NULL);
-        enter_ctx.mimes = (jobjectArray)env->NewGlobalRef(enter_ctx.mimes);
+        target_ctx.mimes = (jobjectArray) env->CallObjectMethod(set, jSetToArray, target_ctx.mimes, NULL);
+        target_ctx.mimes = (jobjectArray) env->NewGlobalRef(target_ctx.mimes);
     }
-    return enter_ctx.mimes;
+
+    return target_ctx.mimes;
 }
 
-jint dnd_target_get_supported_actions(JNIEnv *env)
-{
+jint dnd_target_get_supported_actions(JNIEnv *env) {
     if (check_state_in_drag(env)) {
         return 0;
     }
-    return translate_gdk_action_to_glass(gdk_drag_context_get_actions(enter_ctx.ctx));
+    return translate_gdk_action_to_glass(gdk_drag_context_get_actions(target_ctx.ctx));
 }
 
-static void wait_for_selection_data_hook(GdkEvent * event, void * data)
-{
-    selection_data_ctx *ctx = (selection_data_ctx*)data;
-    GdkWindow *dest = glass_gdk_drag_context_get_dest_window(enter_ctx.ctx);
-    if (event->type == GDK_SELECTION_NOTIFY &&
-            event->selection.window == dest) {
-        if (event->selection.property) { // if 0, that we received negative response
-            ctx->length = gdk_selection_property_get(dest, &(ctx->data), &(ctx->type), &(ctx->format));
-        }
-        ctx->received = TRUE;
-    }
-}
-
-static gboolean dnd_target_receive_data(JNIEnv *env, GdkAtom target, selection_data_ctx *selection_ctx)
-{
-    GevlHookRegistration hookReg;
+static jobject dnd_target_get_string(JNIEnv *env) {
+    jobject result = NULL;
 
-    memset(selection_ctx, 0, sizeof(selection_data_ctx));
+    GdkAtom atom = gtk_selection_data_get_data_type(target_ctx.data);
+    guchar *data = gtk_selection_data_get_text(target_ctx.data);
 
-    gdk_selection_convert(glass_gdk_drag_context_get_dest_window(enter_ctx.ctx), gdk_drag_get_selection(enter_ctx.ctx), target,
-                          GDK_CURRENT_TIME);
+    if (data) {
+        result = env->NewStringUTF((char *) data);
+        EXCEPTION_OCCURED(env);
 
-    hookReg =
-            glass_evloop_hook_add(
-                    (GevlHookFunction) wait_for_selection_data_hook,
-                    selection_ctx);
-    if (HANDLE_MEM_ALLOC_ERROR(env, hookReg,
-                               "Failed to allocate event hook")) {
-        return TRUE;
+        g_free(data);
     }
 
-    do {
-        gtk_main_iteration();
-    } while (!(selection_ctx->received));
-
-
-    glass_evloop_hook_remove(hookReg);
-    return selection_ctx->data != NULL;
+    return result;
 }
 
-static jobject dnd_target_get_string(JNIEnv *env)
-{
+static jobject dnd_target_get_list(JNIEnv *env, gboolean files) {
     jobject result = NULL;
-    selection_data_ctx ctx;
+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);
+    gchar **data = gtk_selection_data_get_uris(target_ctx.data);
 
-    if (dnd_target_receive_data(env, TARGET_UTF8_STRING_ATOM, &ctx)) {
-        result = env->NewStringUTF((char *)ctx.data);
-        EXCEPTION_OCCURED(env);
-        g_free(ctx.data);
-    }
-    if (!result && dnd_target_receive_data(env, TARGET_MIME_TEXT_PLAIN_ATOM, &ctx)) {
-        result = env->NewStringUTF((char *)ctx.data);
-        EXCEPTION_OCCURED(env);
-        g_free(ctx.data);
-    }
-    // TODO find out how to convert from compound text
-    // if (!result && dnd_target_receive_data(env, TARGET_COMPOUND_TEXT_ATOM, &ctx)) {
-    // }
-    if (!result && dnd_target_receive_data(env, TARGET_STRING_ATOM, &ctx)) {
-        gchar *str;
-        str = g_convert( (gchar *)ctx.data, -1, "UTF-8", "ISO-8859-1", NULL, NULL, NULL);
-        if (str != NULL) {
-            result = env->NewStringUTF(str);
-            EXCEPTION_OCCURED(env);
-            g_free(str);
-        }
-        g_free(ctx.data);
+    if (data) {
+        result = uris_to_java(env, data, files);
+        // uris_to_java frees it
+        //g_strfreev(data);
     }
+
     return result;
 }
 
-static jobject dnd_target_get_list(JNIEnv *env, gboolean files)
-{
+static jobject dnd_target_get_image(JNIEnv *env) {
     jobject result = NULL;
-    selection_data_ctx ctx;
 
-    if (dnd_target_receive_data(env, TARGET_MIME_URI_LIST_ATOM, &ctx)) {
-        result = uris_to_java(env, g_uri_list_extract_uris((gchar *)ctx.data), files);
-        g_free(ctx.data);
-    }
+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);
+    GdkPixbuf *buf = gtk_selection_data_get_pixbuf(target_ctx.data);
 
-    return result;
-}
+    if (buf == NULL) {
+        return NULL;
+    }
 
-static jobject dnd_target_get_image(JNIEnv *env)
-{
-    GdkPixbuf *buf;
-    GInputStream *stream;
-    jobject result = NULL;
-    GdkAtom targets[] = {
-        TARGET_MIME_PNG_ATOM,
-        TARGET_MIME_JPEG_ATOM,
-        TARGET_MIME_TIFF_ATOM,
-        TARGET_MIME_BMP_ATOM,
-        0};
-    GdkAtom *cur_target = targets;
-    selection_data_ctx ctx;
-
-    while(*cur_target != 0 && result == NULL) {
-        if (dnd_target_receive_data(env, *cur_target, &ctx)) {
-            stream = g_memory_input_stream_new_from_data(ctx.data, ctx.length * (ctx.format / 8),
-                    (GDestroyNotify)g_free);
-            buf = gdk_pixbuf_new_from_stream(stream, NULL, NULL);
-            if (buf) {
-                int w;
-                int h;
-                int stride;
-                guchar *data;
-                jbyteArray data_array;
-                jobject buffer;
-
-                if (!gdk_pixbuf_get_has_alpha(buf)) {
-                    GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);
-                    g_object_unref(buf);
-                    buf = tmp_buf;
-                }
+    gint length = gtk_selection_data_get_length(target_ctx.data);
 
-                w = gdk_pixbuf_get_width(buf);
-                h = gdk_pixbuf_get_height(buf);
-                stride = gdk_pixbuf_get_rowstride(buf);
-                data = gdk_pixbuf_get_pixels(buf);
-
-                //Actually, we are converting RGBA to BGRA, but that's the same operation
-                data = (guchar*) convert_BGRA_to_RGBA((int*) data, stride, h);
-                data_array = env->NewByteArray(stride * h);
-                EXCEPTION_OCCURED(env);
-                env->SetByteArrayRegion(data_array, 0, stride*h, (jbyte*) data);
-                EXCEPTION_OCCURED(env);
-
-                buffer = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);
-                EXCEPTION_OCCURED(env);
-                result = env->NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);
-                EXCEPTION_OCCURED(env);
-
-                g_object_unref(buf);
-                g_free(data); // data from convert_BGRA_to_RGBA
-            }
-            g_object_unref(stream);
-        }
-        ++cur_target;
+    if (!gdk_pixbuf_get_has_alpha(buf)) {
+        GdkPixbuf *tmp_buf = gdk_pixbuf_add_alpha(buf, FALSE, 0, 0, 0);
+        g_object_unref(buf);
+        buf = tmp_buf;
     }
+
+    gint w, h, stride;
+    guchar *cdata;
+    jbyteArray data_array;
+    jobject buffer;
+
+    w = gdk_pixbuf_get_width(buf);
+    h = gdk_pixbuf_get_height(buf);
+    stride = gdk_pixbuf_get_rowstride(buf);
+
+    cdata = gdk_pixbuf_get_pixels(buf);
+
+    //Actually, we are converting RGBA to BGRA, but that's the same operation
+    cdata = (guchar *) convert_BGRA_to_RGBA((int *) cdata, stride, h);
+    data_array = env->NewByteArray(stride * h);
+    EXCEPTION_OCCURED(env);
+    env->SetByteArrayRegion(data_array, 0, stride * h, (jbyte *) cdata);
+    EXCEPTION_OCCURED(env);
+
+    buffer = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, data_array);
+    EXCEPTION_OCCURED(env);
+    result = env->NewObject(jGtkPixelsCls, jGtkPixelsInit, w, h, buffer);
+    EXCEPTION_OCCURED(env);
+
+    g_object_unref(buf);
+    g_free(cdata);
+
     return result;
 }
 
-static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data)
-{
-    selection_data_ctx ctx;
+static jobject dnd_target_get_raw(JNIEnv *env, GdkAtom target, gboolean string_data) {
     jobject result = NULL;
-    if (dnd_target_receive_data(env, target, &ctx)) {
-        if (string_data) {
-             result = env->NewStringUTF((char *)ctx.data);
-             EXCEPTION_OCCURED(env);
-        } else {
-            jsize length = ctx.length * (ctx.format / 8);
-            jbyteArray array = env->NewByteArray(length);
-            EXCEPTION_OCCURED(env);
-            env->SetByteArrayRegion(array, 0, length, (const jbyte*)ctx.data);
-            EXCEPTION_OCCURED(env);
-            result = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);
-            EXCEPTION_OCCURED(env);
-        }
+    GdkAtom atom = gtk_selection_data_get_selection(target_ctx.data);
+    const guchar *data = gtk_selection_data_get_data(target_ctx.data);
+
+    if (string_data) {
+        result = env->NewStringUTF((char *) data);
+        EXCEPTION_OCCURED(env);
+    } else {
+        gint length = gtk_selection_data_get_length(target_ctx.data);
+
+        jbyteArray array = env->NewByteArray((jsize) length);
+        EXCEPTION_OCCURED(env);
+        env->SetByteArrayRegion(array, 0, length, (const jbyte *) data);
+        EXCEPTION_OCCURED(env);
+        result = env->CallStaticObjectMethod(jByteBufferCls, jByteBufferWrap, array);
+        EXCEPTION_OCCURED(env);
     }
-    g_free(ctx.data);
+
     return result;
 }
 
-jobject dnd_target_get_data(JNIEnv *env, jstring mime)
-{
+jobject dnd_target_get_data(JNIEnv *env, jstring mime) {
+    jobject ret = NULL;
+
     if (check_state_in_drag(env)) {
         return NULL;
     }
-    const char *cmime = env->GetStringUTFChars(mime, NULL);
-    jobject ret = NULL;
 
-    init_target_atoms();
+    const char *cmime = env->GetStringUTFChars(mime, NULL);
 
     if (g_strcmp0(cmime, "text/plain") == 0) {
         ret = dnd_target_get_string(env);
     } else if (g_strcmp0(cmime, "text/uri-list") == 0) {
         ret = dnd_target_get_list(env, FALSE);
     } else if (g_str_has_prefix(cmime, "text/")) {
         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), TRUE);
     } else if (g_strcmp0(cmime, "application/x-java-file-list") == 0) {
         ret = dnd_target_get_list(env, TRUE);
-    } else if (g_strcmp0(cmime, "application/x-java-rawimage") == 0 ) {
+    } else if (g_strcmp0(cmime, "application/x-java-rawimage") == 0) {
         ret = dnd_target_get_image(env);
     } else {
         ret = dnd_target_get_raw(env, gdk_atom_intern(cmime, FALSE), FALSE);
     }
+
     LOG_EXCEPTION(env)
     env->ReleaseStringUTFChars(mime, cmime);
 
     return ret;
 }
 
 /************************* SOURCE *********************************************/
 
 static jint dnd_performed_action;
 
-const char * const SOURCE_DND_DATA = "fx-dnd-data";
+const char *const SOURCE_DND_DATA = "fx-dnd-data";
 
-static void dnd_set_performed_action(jint performed_action)
-{
+static void dnd_set_performed_action(jint performed_action) {
     dnd_performed_action = performed_action;
 }
 
-static jint dnd_get_performed_action()
-{
+static jint dnd_get_performed_action() {
     return dnd_performed_action;
 }
 
-static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer)
-{
+static void pixbufDestroyNotifyFunc(guchar *pixels, gpointer) {
     if (pixels != NULL) {
         g_free(pixels);
     }
 }
 
-static jobject dnd_source_get_data(GtkWidget *widget, const char *key)
-{
-    jobject data = (jobject)g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);
+static jobject dnd_source_get_data(GtkWidget *widget, const char *key) {
+    jobject data = (jobject) g_object_get_data(G_OBJECT(widget), SOURCE_DND_DATA);
     jstring string = mainEnv->NewStringUTF(key);
     EXCEPTION_OCCURED(mainEnv);
     jobject result = mainEnv->CallObjectMethod(data, jMapGet, string, NULL);
 
     return (EXCEPTION_OCCURED(mainEnv)) ? NULL : result;
 }
 
-static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags)
-{
+static void add_gtk_target_from_jstring(JNIEnv *env, GtkTargetList **list, jstring string, guint flags) {
     const char *gstring = env->GetStringUTFChars(string, NULL);
 
     if (g_strcmp0(gstring, "text/plain") == 0) {
-        gtk_target_list_add(*list, TARGET_UTF8_STRING_ATOM, flags, 0);
-        gtk_target_list_add(*list, TARGET_MIME_TEXT_PLAIN_ATOM, flags, 0);
-        gtk_target_list_add(*list, TARGET_STRING_ATOM, flags, 0);
-        //gtk_target_list_add(*list, TARGET_COMPOUND_TEXT_ATOM, flags, ??);
+        gtk_target_list_add_text_targets(*list, TARGET_TEXT);
     } else if (g_strcmp0(gstring, "application/x-java-rawimage") == 0) {
-        gtk_target_list_add(*list, TARGET_MIME_PNG_ATOM, flags, 0);
-        gtk_target_list_add(*list, TARGET_MIME_JPEG_ATOM, flags, 0);
-        gtk_target_list_add(*list, TARGET_MIME_TIFF_ATOM, flags, 0);
-        gtk_target_list_add(*list, TARGET_MIME_BMP_ATOM, flags, 0);
+        gtk_target_list_add_image_targets(*list, TARGET_IMAGE, TRUE);
     } else if (g_strcmp0(gstring, "application/x-java-file-list") == 0) {
-        gtk_target_list_add(*list, TARGET_MIME_URI_LIST_ATOM, flags, 0);
+        gtk_target_list_add_uri_targets(*list, TARGET_URI);
     } else if (g_strcmp0(gstring, "application/x-java-drag-image") == 0
-        || g_strcmp0(gstring, "application/x-java-drag-image-offset") == 0) {
+               || g_strcmp0(gstring, "application/x-java-drag-image-offset") == 0) {
         // do nothing - those are DragView information
     } else {
         GdkAtom atom = gdk_atom_intern(gstring, FALSE);
-        gtk_target_list_add(*list, atom, flags, 0);
+        gtk_target_list_add(*list, atom, flags, TARGET_RAW);
     }
 
     env->ReleaseStringUTFChars(string, gstring);
 }
 
-static GtkTargetList* data_to_gtk_target_list(JNIEnv *env, jobject data)
-{
+static GtkTargetList *data_to_gtk_target_list(JNIEnv *env, jobject data) {
     guint flags = GTK_TARGET_OTHER_APP | GTK_TARGET_SAME_APP;
 
     jobject keys;
     jobject keysIterator;
     jstring next;
 
-    GtkTargetList *tlist = gtk_target_list_new (NULL, 0);
-
-    init_target_atoms();
+    GtkTargetList *tlist = gtk_target_list_new(NULL, 0);
 
     gint added_count = 0;
 
     keys = env->CallObjectMethod(data, jMapKeySet, NULL);
     JNI_EXCEPTION_TO_CPP(env)
     keysIterator = env->CallObjectMethod(keys, jIterableIterator, NULL);
     JNI_EXCEPTION_TO_CPP(env)
     while (env->CallBooleanMethod(keysIterator, jIteratorHasNext) == JNI_TRUE) {
-        next = (jstring)env->CallObjectMethod(keysIterator, jIteratorNext, NULL);
+        next = (jstring) env->CallObjectMethod(keysIterator, jIteratorNext, NULL);
         JNI_EXCEPTION_TO_CPP(env)
         add_gtk_target_from_jstring(env, &tlist, next, flags);
     }
 
     return tlist;
 }
 
-static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)
-{
+static gboolean dnd_source_set_string(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {
     gboolean is_data_set;
 
-    jstring string = (jstring)dnd_source_get_data(widget, "text/plain");
+    jstring string = (jstring) dnd_source_get_data(widget, "text/plain");
     if (!string) {
         return FALSE;
     }
 
     const char *cstring = mainEnv->GetStringUTFChars(string, NULL);
-    if (cstring) {
-        if (atom == TARGET_MIME_TEXT_PLAIN_ATOM) {
-            gchar *res_str = g_convert((gchar *) cstring, -1, "ISO-8859-1", "UTF-8", NULL, NULL, NULL);
-            if (res_str) {
-                is_data_set = gtk_selection_data_set_text(data, res_str, strlen(res_str));
-                g_free(res_str);
-            }
-        } else {
-            gint size = strlen(cstring);
-            is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);
-        }
-    }
+    gint size = strlen(cstring);
+    is_data_set = gtk_selection_data_set_text(data, (gchar *) cstring, size);
 
     mainEnv->ReleaseStringUTFChars(string, cstring);
 
     return is_data_set;
 }
 
-static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)
-{
+static gboolean dnd_source_set_image(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {
     jobject pixels = dnd_source_get_data(widget, "application/x-java-rawimage");
     if (!pixels) {
+        g_warning("DND source failed to set image\n");
         return FALSE;
     }
 
     gchar *buffer;
     gsize size;
-    const char * type;
+    const char *type;
     GdkPixbuf *pixbuf = NULL;
     gboolean is_data_set;
 
     mainEnv->CallVoidMethod(pixels, jPixelsAttachData, PTR_TO_JLONG(&pixbuf));
 
@@ -653,13 +546,12 @@
     g_object_unref(pixbuf);
 
     return is_data_set;
 }
 
-static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom)
-{
-    const gchar* url = NULL;
+static gboolean dnd_source_set_uri(GtkWidget *widget, GtkSelectionData *data, GdkAtom atom) {
+    const gchar *url = NULL;
     jstring jurl = NULL;
 
     jobjectArray files_array = NULL;
     gsize files_cnt = 0;
 
@@ -674,18 +566,18 @@
     if (!url && !files_cnt) {
         return FALSE;
     }
 
     gboolean is_data_set;
-    GString* res = g_string_new (NULL); //http://www.ietf.org/rfc/rfc2483.txt
+    GString *res = g_string_new(NULL); //http://www.ietf.org/rfc/rfc2483.txt
 
     if (files_cnt > 0) {
         for (gsize i = 0; i < files_cnt; ++i) {
             jstring string = (jstring) mainEnv->GetObjectArrayElement(files_array, i);
             EXCEPTION_OCCURED(mainEnv);
-            const gchar* file = mainEnv->GetStringUTFChars(string, NULL);
-            gchar* uri = g_filename_to_uri(file, NULL, NULL);
+            const gchar *file = mainEnv->GetStringUTFChars(string, NULL);
+            gchar *uri = g_filename_to_uri(file, NULL, NULL);
 
             g_string_append(res, uri);
             g_string_append(res, URI_LIST_LINE_BREAK);
 
             g_free(uri);
@@ -707,26 +599,25 @@
     g_free(uri[0]);
 
     return is_data_set;
 }
 
-static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom)
-{
+static gboolean dnd_source_set_raw(GtkWidget *widget, GtkSelectionData *sel_data, GdkAtom atom) {
     gchar *target_name = gdk_atom_name(atom);
     jobject data = dnd_source_get_data(widget, target_name);
     gboolean is_data_set = FALSE;
     if (data) {
         if (mainEnv->IsInstanceOf(data, jStringCls)) {
-            const char *cstring = mainEnv->GetStringUTFChars((jstring)data, NULL);
+            const char *cstring = mainEnv->GetStringUTFChars((jstring) data, NULL);
             if (cstring) {
                 is_data_set = gtk_selection_data_set_text(sel_data, (gchar *) cstring, strlen(cstring));
-                mainEnv->ReleaseStringUTFChars((jstring)data, cstring);
+                mainEnv->ReleaseStringUTFChars((jstring) data, cstring);
             }
         } else if (mainEnv->IsInstanceOf(data, jByteBufferCls)) {
-            jbyteArray byteArray = (jbyteArray)mainEnv->CallObjectMethod(data, jByteBufferArray);
+            jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(data, jByteBufferArray);
             if (!EXCEPTION_OCCURED(mainEnv)) {
-                jbyte* raw = mainEnv->GetByteArrayElements(byteArray, NULL);
+                jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);
                 if (raw) {
                     jsize nraw = mainEnv->GetArrayLength(byteArray);
                     gtk_selection_data_set(sel_data, atom, 8, (guchar *) raw, nraw);
                     mainEnv->ReleaseByteArrayElements(byteArray, raw, JNI_ABORT);
                     is_data_set = TRUE;
@@ -748,24 +639,22 @@
     return FALSE;
 }
 
 static void dnd_end_callback(GtkWidget *widget,
                              GdkDragContext *context,
-                             gpointer user_data)
-{
+                             gpointer user_data) {
     if (drag_widget) {
         GdkDragAction action = gdk_drag_context_get_selected_action(context);
         dnd_set_performed_action(translate_gdk_action_to_glass(action));
     }
     gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
 }
 
 static gboolean dnd_drag_failed_callback(GtkWidget *widget,
-                                     GdkDragContext *context,
-                                     GtkDragResult result,
-                                     gpointer user_data)
-{
+                                         GdkDragContext *context,
+                                         GtkDragResult result,
+                                         gpointer user_data) {
     dnd_set_performed_action(com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE);
     gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
 
     return FALSE;
 }
@@ -773,62 +662,61 @@
 static void dnd_data_get_callback(GtkWidget *widget,
                                   GdkDragContext *context,
                                   GtkSelectionData *data,
                                   guint info,
                                   guint time,
-                                  gpointer user_data)
-{
+                                  gpointer user_data) {
     GdkAtom atom = gtk_selection_data_get_target(data);
 
-    if (target_is_text(atom)) {
-        dnd_source_set_string(widget, data, atom);
-    } else if (target_is_image(atom)) {
-        dnd_source_set_image(widget, data, atom);
-    } else if (target_is_uri(atom)) {
-        dnd_source_set_uri(widget, data, atom);
-    } else {
-        dnd_source_set_raw(widget, data, atom);
+    switch (info) {
+        case TARGET_TEXT:
+            dnd_source_set_string(widget, data, atom);
+            break;
+        case TARGET_IMAGE:
+            dnd_source_set_image(widget, data, atom);
+            break;
+        case TARGET_URI:
+            dnd_source_set_uri(widget, data, atom);
+            break;
+        default:
+            dnd_source_set_raw(widget, data, atom);
     }
 }
 
 static void dnd_drag_begin_callback(GtkWidget *widget,
                                     GdkDragContext *context,
-                                    gpointer user_data)
-{
+                                    gpointer user_data) {
     DragView::set_drag_view(widget, context);
 }
 
-static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported)
-{
+static void dnd_source_push_data(JNIEnv *env, jobject data, jint supported) {
     if (supported == 0) {
         return; // No supported actions, do nothing
     }
 
     data = env->NewGlobalRef(data);
 
     GdkDragAction actions = translate_glass_action_to_gdk(supported);
 
     // this widget is used only to pass events and will
     // be destroyed on drag end
-    drag_widget = gtk_window_new(GTK_WINDOW_POPUP);
-    gtk_window_resize(GTK_WINDOW(drag_widget), 1, 1);
-    gtk_window_move(GTK_WINDOW(drag_widget), -200, -200);
+    drag_widget = gtk_invisible_new();
     gtk_widget_show(drag_widget);
 
     g_object_set_data_full(G_OBJECT(drag_widget), SOURCE_DND_DATA, data, clear_global_ref);
 
     g_signal_connect(drag_widget, "drag-begin",
-        G_CALLBACK(dnd_drag_begin_callback), NULL);
+                     G_CALLBACK(dnd_drag_begin_callback), NULL);
 
     g_signal_connect(drag_widget, "drag-failed",
-        G_CALLBACK(dnd_drag_failed_callback), NULL);
+                     G_CALLBACK(dnd_drag_failed_callback), NULL);
 
     g_signal_connect(drag_widget, "drag-data-get",
-        G_CALLBACK(dnd_data_get_callback), NULL);
+                     G_CALLBACK(dnd_data_get_callback), NULL);
 
     g_signal_connect(drag_widget, "drag-end",
-        G_CALLBACK(dnd_end_callback), NULL);
+                     G_CALLBACK(dnd_end_callback), NULL);
 
     GtkTargetList *tlist = data_to_gtk_target_list(env, data);
 
     GdkDragContext *context;
 
@@ -844,15 +732,14 @@
 #endif
 
     gtk_target_list_unref(tlist);
 }
 
-jint execute_dnd(JNIEnv *env, jobject data, jint supported)
-{
+jint execute_dnd(JNIEnv *env, jobject data, jint supported) {
     try {
         dnd_source_push_data(env, data, supported);
-    } catch (jni_exception&) {
+    } catch (jni_exception &) {
         gdk_threads_add_idle((GSourceFunc) dnd_destroy_drag_widget_callback, NULL);
         return com_sun_glass_ui_gtk_GtkDnDClipboard_ACTION_NONE;
     }
 
     while (is_in_drag()) {
@@ -860,25 +747,24 @@
     }
 
     return dnd_get_performed_action();
 }
 
- /******************** DRAG VIEW ***************************/
- DragView::View* DragView::view = NULL;
+/******************** DRAG VIEW ***************************/
+DragView::View *DragView::view = NULL;
 
- gboolean DragView::get_drag_image_offset(GtkWidget *widget, int* x, int* y)
- {
+gboolean DragView::get_drag_image_offset(GtkWidget *widget, int *x, int *y) {
     gboolean offset_set = FALSE;
     jobject bb = dnd_source_get_data(widget, "application/x-java-drag-image-offset");
     if (bb) {
-        jbyteArray byteArray = (jbyteArray)mainEnv->CallObjectMethod(bb, jByteBufferArray);
+        jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(bb, jByteBufferArray);
         if (!EXCEPTION_OCCURED(mainEnv)) {
-            jbyte* raw = mainEnv->GetByteArrayElements(byteArray, NULL);
+            jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);
             jsize nraw = mainEnv->GetArrayLength(byteArray);
 
             if ((size_t) nraw >= sizeof(jint) * 2) {
-                jint* r = (jint*) raw;
+                jint *r = (jint *) raw;
                 *x = BSWAP_32(r[0]);
                 *y = BSWAP_32(r[1]);
                 offset_set = TRUE;
             }
 
@@ -886,35 +772,34 @@
         }
     }
     return offset_set;
 }
 
-GdkPixbuf* DragView::get_drag_image(GtkWidget *widget, gboolean* is_raw_image, gint* width, gint* height)
-{
+GdkPixbuf *DragView::get_drag_image(GtkWidget *widget, gboolean *is_raw_image, gint *width, gint *height) {
     GdkPixbuf *pixbuf = NULL;
     gboolean is_raw = FALSE;
 
     jobject drag_image = dnd_source_get_data(widget, "application/x-java-drag-image");
 
     if (drag_image) {
         jbyteArray byteArray = (jbyteArray) mainEnv->CallObjectMethod(drag_image, jByteBufferArray);
         if (!EXCEPTION_OCCURED(mainEnv)) {
 
-            jbyte* raw = mainEnv->GetByteArrayElements(byteArray, NULL);
+            jbyte *raw = mainEnv->GetByteArrayElements(byteArray, NULL);
             jsize nraw = mainEnv->GetArrayLength(byteArray);
 
             int w = 0, h = 0;
             int whsz = sizeof(jint) * 2; // Pixels are stored right after two ints
             // in this byteArray: width and height
             if (nraw > whsz) {
-                jint* int_raw = (jint*) raw;
+                jint *int_raw = (jint *) raw;
                 w = BSWAP_32(int_raw[0]);
                 h = BSWAP_32(int_raw[1]);
 
                 // We should have enough pixels for requested width and height
-                if ((nraw - whsz) / 4 - w * h >= 0 ) {
-                    guchar* data = (guchar*) g_try_malloc0(nraw - whsz);
+                if ((nraw - whsz) / 4 - w * h >= 0) {
+                    guchar *data = (guchar *) g_try_malloc0(nraw - whsz);
                     if (data) {
                         memcpy(data, (raw + whsz), nraw - whsz);
                         pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,
                                                           w, h, w * 4, pixbufDestroyNotifyFunc, NULL);
                     }
@@ -939,12 +824,12 @@
 
     int w = gdk_pixbuf_get_width(pixbuf);
     int h = gdk_pixbuf_get_height(pixbuf);
 
     if (w > DRAG_IMAGE_MAX_WIDTH || h > DRAG_IMAGE_MAX_HEIGH) {
-        double rw = DRAG_IMAGE_MAX_WIDTH / (double)w;
-        double rh =  DRAG_IMAGE_MAX_HEIGH / (double)h;
+        double rw = DRAG_IMAGE_MAX_WIDTH / (double) w;
+        double rh = DRAG_IMAGE_MAX_HEIGH / (double) h;
         double r = MIN(rw, rh);
 
         int new_w = w * r;
         int new_h = h * r;
 
@@ -964,55 +849,51 @@
     *height = h;
 
     return pixbuf;
 }
 
-void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context)
-{
+void DragView::set_drag_view(GtkWidget *widget, GdkDragContext *context) {
     gboolean is_raw_image = FALSE;
     gint w = 0, h = 0;
-    GdkPixbuf* pixbuf = get_drag_image(widget, &is_raw_image, &w, &h);
+    GdkPixbuf *pixbuf = get_drag_image(widget, &is_raw_image, &w, &h);
 
     if (GDK_IS_PIXBUF(pixbuf)) {
         gint offset_x = w / 2;
         gint offset_y = h / 2;
 
         gboolean is_offset_set = get_drag_image_offset(widget, &offset_x, &offset_y);
 
         DragView::view = new DragView::View(context, pixbuf, w, h, is_raw_image,
-            is_offset_set, offset_x, offset_y);
+                                            is_offset_set, offset_x, offset_y);
     }
 }
 
-static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view)
-{
-    (void)widget;
-    (void)previous_screen;
+static void on_screen_changed(GtkWidget *widget, GdkScreen *previous_screen, gpointer view) {
+    (void) widget;
+    (void) previous_screen;
 
-    ((DragView::View*) view)->screen_changed();
+    ((DragView::View *) view)->screen_changed();
 }
 
-static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view)
-{
-    (void)widget;
-    (void)event;
+static gboolean on_expose(GtkWidget *widget, GdkEventExpose *event, gpointer view) {
+    (void) widget;
+    (void) event;
 
-    ((DragView::View*) view)->expose();
+    ((DragView::View *) view)->expose();
     return FALSE;
 }
 
-DragView::View::View(GdkDragContext* _context, GdkPixbuf* _pixbuf, gint _width, gint _height,
+DragView::View::View(GdkDragContext *_context, GdkPixbuf *_pixbuf, gint _width, gint _height,
                      gboolean _is_raw_image, gboolean _is_offset_set, gint _offset_x, gint _offset_y) :
-    context(_context),
-    pixbuf(_pixbuf),
-    width(_width),
-    height(_height),
-    is_raw_image(_is_raw_image),
-    is_offset_set(_is_offset_set),
-    offset_x(_offset_x),
-    offset_y(_offset_y)
-{
+        context(_context),
+        pixbuf(_pixbuf),
+        width(_width),
+        height(_height),
+        is_raw_image(_is_raw_image),
+        is_offset_set(_is_offset_set),
+        offset_x(_offset_x),
+        offset_y(_offset_y) {
 #ifdef GLASS_GTK3
     gtk_drag_set_icon_pixbuf(context, pixbuf, offset_x, offset_y);
 #else
     widget = gtk_window_new(GTK_WINDOW_POPUP);
     gtk_window_set_type_hint(GTK_WINDOW(widget), GDK_WINDOW_TYPE_HINT_DND);
@@ -1031,12 +912,11 @@
     gtk_widget_show_all(widget);
     gtk_drag_set_icon_widget(context, widget, offset_x, offset_y);
 #endif
 }
 
-void DragView::View::screen_changed()
-{
+void DragView::View::screen_changed() {
     GdkScreen *screen = gtk_widget_get_screen(widget);
 
     glass_configure_window_transparency(widget, true);
 
     if (!gdk_screen_is_composited(screen)) {
@@ -1045,21 +925,20 @@
             offset_y = 1;
         }
     }
 }
 
-void DragView::View::expose()
-{
+void DragView::View::expose() {
     cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));
 
-    cairo_surface_t* cairo_surface;
+    cairo_surface_t *cairo_surface;
 
-    guchar* pixels = is_raw_image
-            ? (guchar*) convert_BGRA_to_RGBA((const int*) gdk_pixbuf_get_pixels(pixbuf),
-                                                gdk_pixbuf_get_rowstride(pixbuf),
-                                                height)
-            : gdk_pixbuf_get_pixels(pixbuf);
+    guchar *pixels = is_raw_image
+                     ? (guchar *) convert_BGRA_to_RGBA((const int *) gdk_pixbuf_get_pixels(pixbuf),
+                                                       gdk_pixbuf_get_rowstride(pixbuf),
+                                                       height)
+                     : gdk_pixbuf_get_pixels(pixbuf);
 
     cairo_surface = cairo_image_surface_create_for_data(
             pixels,
             CAIRO_FORMAT_ARGB32,
             width, height, width * 4);
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.h b/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.h
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.h
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_dnd.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -29,16 +29,17 @@
 #include "glass_window.h"
 #include <jni.h>
 
 #include <gtk/gtk.h>
 
-void process_dnd_target(WindowContext *, GdkEventDND *);
+void glass_dnd_attach_context(WindowContext *ctx);
+void dnd_drag_leave_callback(WindowContext* ctx);
+
 jint dnd_target_get_supported_actions(JNIEnv *);
 jobjectArray dnd_target_get_mimes(JNIEnv *);
 jobject dnd_target_get_data(JNIEnv *, jstring);
 
-void process_dnd_source(GdkWindow *, GdkEvent *);
 jint execute_dnd(JNIEnv *, jobject, jint);
 
 gboolean is_in_drag();
 
 #define DRAG_IMAGE_MAX_WIDTH 320
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.cpp
@@ -503,21 +503,18 @@
     return result;
 }
 
 //***************************************************************************
 
-typedef struct _DeviceGrabContext {
-    GdkWindow * window;
-    gboolean grabbed;
-} DeviceGrabContext;
 
 gboolean disableGrab = FALSE;
 static gboolean configure_transparent_window(GtkWidget *window);
 static void configure_opaque_window(GtkWidget *window);
 
-static void grab_mouse_device(GdkDevice *device, DeviceGrabContext *context);
-static void ungrab_mouse_device(GdkDevice *device);
+gboolean is_grab_disabled() {
+    return disableGrab;
+}
 
 gint glass_gdk_visual_get_depth (GdkVisual * visual)
 {
     // gdk_visual_get_depth is GTK 2.2 +
     return gdk_visual_get_depth(visual);
@@ -531,71 +528,10 @@
 #else
         return gdk_window_get_screen(gdkWindow);
 #endif
 }
 
-gboolean
-glass_gdk_mouse_devices_grab(GdkWindow *gdkWindow) {
-#ifdef GLASS_GTK3_DISABLED
-//this GTK 3 approach has synchronization issues covered in JDK-8176844
-// As the approach is also deprecated in GTK 3.20+, revert back to using GTK 2 mechanism
-
-        if (disableGrab) {
-            return TRUE;
-        }
-        DeviceGrabContext context;
-        GList *devices = gdk_device_manager_list_devices (
-                             gdk_display_get_device_manager(
-                                 gdk_display_get_default()),
-                                 GDK_DEVICE_TYPE_MASTER);
-
-        context.window = gdkWindow;
-        context.grabbed = FALSE;
-        g_list_foreach(devices, (GFunc) grab_mouse_device, &context);
-        g_list_free(devices);
-
-        return context.grabbed;
-#else
-    return glass_gdk_mouse_devices_grab_with_cursor(gdkWindow, NULL, TRUE);
-#endif
-}
-
-gboolean
-glass_gdk_mouse_devices_grab_with_cursor(GdkWindow *gdkWindow, GdkCursor *cursor, gboolean owner_events) {
-    if (disableGrab) {
-        return TRUE;
-    }
-    GdkGrabStatus status = gdk_pointer_grab(gdkWindow, owner_events, (GdkEventMask)
-                                            (GDK_POINTER_MOTION_MASK
-                                                | GDK_POINTER_MOTION_HINT_MASK
-                                                | GDK_BUTTON_MOTION_MASK
-                                                | GDK_BUTTON1_MOTION_MASK
-                                                | GDK_BUTTON2_MOTION_MASK
-                                                | GDK_BUTTON3_MOTION_MASK
-                                                | GDK_BUTTON_PRESS_MASK
-                                                | GDK_BUTTON_RELEASE_MASK),
-                                            NULL, cursor, GDK_CURRENT_TIME);
-
-    return (status == GDK_GRAB_SUCCESS) ? TRUE : FALSE;
-}
-
-void
-glass_gdk_mouse_devices_ungrab() {
-#ifdef GLASS_GTK3_DISABLED
-//this GTK 3 approach has synchronization issues covered in JDK-8176844
-// As the approach is also deprecated in GTK 3.20+, revert back to using GTK 2 mechanism
-        GList *devices = gdk_device_manager_list_devices(
-                             gdk_display_get_device_manager(
-                                 gdk_display_get_default()),
-                                 GDK_DEVICE_TYPE_MASTER);
-        g_list_foreach(devices, (GFunc) ungrab_mouse_device, NULL);
-        g_list_free(devices);
-#else
-        gdk_pointer_ungrab(GDK_CURRENT_TIME);
-#endif
-}
-
 void
 glass_gdk_master_pointer_get_position(gint *x, gint *y) {
 #ifdef GLASS_GTK3
         gdk_device_get_position(gdk_device_manager_get_client_pointer(
                                     gdk_display_get_device_manager(
@@ -603,30 +539,10 @@
 #else
         gdk_display_get_pointer(gdk_display_get_default(), NULL, x, y, NULL);
 #endif
 }
 
-gboolean
-glass_gdk_device_is_grabbed(GdkDevice *device) {
-#ifdef GLASS_GTK3
-        return gdk_display_device_is_grabbed(gdk_display_get_default(), device);
-#else
-        (void) device;
-        return gdk_display_pointer_is_grabbed(gdk_display_get_default());
-#endif
-}
-
-void
-glass_gdk_device_ungrab(GdkDevice *device) {
-#ifdef GLASS_GTK3
-        gdk_device_ungrab(device, GDK_CURRENT_TIME);
-#else
-        (void) device;
-        gdk_pointer_ungrab(GDK_CURRENT_TIME);
-#endif
-}
-
 GdkWindow *
 glass_gdk_device_get_window_at_position(GdkDevice *device, gint *x, gint *y) {
 #ifdef GLASS_GTK3
         return gdk_device_get_window_at_position(device, x, y);
 #else
@@ -731,53 +647,10 @@
 
     configure_opaque_window(window);
     return FALSE;
 }
 
-static void
-grab_mouse_device(GdkDevice *device, DeviceGrabContext *context) {
-    GdkInputSource source = gdk_device_get_source(device);
-    if (source == GDK_SOURCE_MOUSE) {
-#ifdef GLASS_GTK3
-        GdkGrabStatus status = gdk_device_grab(device,
-                                               context->window,
-                                               GDK_OWNERSHIP_NONE,
-                                               TRUE,
-                                               GDK_ALL_EVENTS_MASK,
-                                               NULL,
-                                               GDK_CURRENT_TIME);
-#else
-        GdkGrabStatus status = GDK_GRAB_SUCCESS;
-/* FIXME reachable by 2?
-        GdkGrabStatus status = gdk_device_grab(device,
-                                               context->window,
-                                               GDK_OWNERSHIP_NONE,
-                                               TRUE,
-                                               GDK_ALL_EVENTS_MASK,
-                                               NULL,
-                                               GDK_CURRENT_TIME);
-                                       */
-#endif
-        if (status == GDK_GRAB_SUCCESS) {
-            context->grabbed = TRUE;
-        }
-    }
-}
-
-static void
-ungrab_mouse_device(GdkDevice *device) {
-#ifdef GLASS_GTK3
-    GdkInputSource source = gdk_device_get_source(device);
-    if (source == GDK_SOURCE_MOUSE) {
-        gdk_device_ungrab(device, GDK_CURRENT_TIME);
-    }
-#else
-    (void) device;
-    // not used on the GTK2 path
-#endif
-}
-
 GdkPixbuf *
 glass_pixbuf_from_window(GdkWindow *window,
     gint srcx, gint srcy,
     gint width, gint height)
 {
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.h b/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.h
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.h
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_general.h
@@ -119,10 +119,11 @@
     } RunnableContext;
 
     extern char const * const GDK_WINDOW_DATA_CONTEXT;
 
     GdkCursor* get_native_cursor(int type);
+    gboolean is_grab_disabled();
 
     // JNI global references
     extern jclass jStringCls; // java.lang.String
 
     extern jclass jByteBufferCls; //java.nio.ByteBuffer
@@ -273,34 +274,13 @@
 glass_gdk_visual_get_depth (GdkVisual * visual);
 
 GdkScreen *
 glass_gdk_window_get_screen(GdkWindow * gdkWindow);
 
-gboolean
-glass_gdk_mouse_devices_grab(GdkWindow * gdkWindow);
-
-gboolean
-glass_gdk_mouse_devices_grab_with_cursor(GdkWindow * gdkWindow, GdkCursor *cursor, gboolean owner_events);
-
-void
-glass_gdk_mouse_devices_ungrab();
-
-void
-glass_gdk_master_pointer_grab(GdkEvent *event, GdkWindow *window, GdkCursor *cursor);
-
-void
-glass_gdk_master_pointer_ungrab(GdkEvent *event);
-
 void
 glass_gdk_master_pointer_get_position(gint *x, gint *y);
 
-gboolean
-glass_gdk_device_is_grabbed(GdkDevice *device);
-
-void
-glass_gdk_device_ungrab(GdkDevice *device);
-
 GdkWindow *
 glass_gdk_device_get_window_at_position(
                GdkDevice *device, gint *x, gint *y);
 
 void
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.cpp
@@ -21,11 +21,10 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 #include "glass_window.h"
-#include "glass_general.h"
 #include "glass_key.h"
 #include "glass_screen.h"
 #include "glass_dnd.h"
 
 #include <com_sun_glass_events_WindowEvent.h>
@@ -38,10 +37,11 @@
 #include <X11/extensions/shape.h>
 #include <cairo.h>
 #include <cairo-xlib.h>
 #include <gdk/gdkx.h>
 #include <gdk/gdk.h>
+
 #ifdef GLASS_GTK3
 #include <gtk/gtkx.h>
 #endif
 
 #include <string.h>
@@ -49,96 +49,292 @@
 #include <algorithm>
 
 #define MOUSE_BACK_BTN 8
 #define MOUSE_FORWARD_BTN 9
 
-WindowContext * WindowContextBase::sm_grab_window = NULL;
-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;
+static gboolean ctx_configure_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_configure();
+    return FALSE;
+}
 
-GdkWindow* WindowContextBase::get_gdk_window(){
-    return gdk_window;
+static gboolean ctx_property_notify_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_property_notify(&event->property);
+    return TRUE;
 }
 
-jobject WindowContextBase::get_jview() {
-    return jview;
+static gboolean ctx_focus_change_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_focus(&event->focus_change);
+    return TRUE;
 }
 
-jobject WindowContextBase::get_jwindow() {
-    return jwindow;
+static gboolean ctx_delete_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_delete();
+    return TRUE;
+}
+
+static gboolean ctx_window_state_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_state(&event->window_state);
+    return FALSE;
+}
+
+static gboolean ctx_device_button_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_button(&event->button);
+    return TRUE;
+}
+
+static gboolean ctx_device_motion_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    gdk_event_request_motions(&event->motion);
+    ((WindowContext *) user_data)->process_mouse_motion(&event->motion);
+    return TRUE;
+}
+
+static gboolean ctx_device_scroll_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_scroll(&event->scroll);
+    return TRUE;
+}
+
+static gboolean ctx_enter_or_leave_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_mouse_cross(&event->crossing);
+    return TRUE;
+}
+
+static gboolean ctx_key_press_or_release_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_key(&event->key);
+    return TRUE;
+}
+
+static gboolean ctx_map_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
+    ((WindowContext *) user_data)->process_map();
+    return TRUE;
+}
+
+static void ctx_screen_changed_callback(GtkWidget *widget,
+                                        GdkScreen *previous_screen,
+                                        gpointer user_data) {
+    ((WindowContext *) user_data)->process_screen_changed();
+}
+
+static void connect_signals(GtkWidget *gtk_widget, WindowContext *ctx) {
+    g_signal_connect(gtk_widget, "configure-event", G_CALLBACK(ctx_configure_callback), ctx);
+    g_signal_connect(gtk_widget, "property-notify-event", G_CALLBACK(ctx_property_notify_callback), ctx);
+    g_signal_connect(gtk_widget, "focus-in-event", G_CALLBACK(ctx_focus_change_callback), ctx);
+    g_signal_connect(gtk_widget, "focus-out-event", G_CALLBACK(ctx_focus_change_callback), ctx);
+    g_signal_connect(gtk_widget, "delete-event", G_CALLBACK(ctx_delete_callback), ctx);
+    g_signal_connect(gtk_widget, "window-state-event", G_CALLBACK(ctx_window_state_callback), ctx);
+    g_signal_connect(gtk_widget, "button-press-event", G_CALLBACK(ctx_device_button_callback), ctx);
+    g_signal_connect(gtk_widget, "button-release-event", G_CALLBACK(ctx_device_button_callback), ctx);
+    g_signal_connect(gtk_widget, "motion-notify-event", G_CALLBACK(ctx_device_motion_callback), ctx);
+    g_signal_connect(gtk_widget, "scroll-event", G_CALLBACK(ctx_device_scroll_callback), ctx);
+    g_signal_connect(gtk_widget, "enter-notify-event", G_CALLBACK(ctx_enter_or_leave_callback), ctx);
+    g_signal_connect(gtk_widget, "leave-notify-event", G_CALLBACK(ctx_enter_or_leave_callback), ctx);
+    g_signal_connect(gtk_widget, "key-press-event", G_CALLBACK(ctx_key_press_or_release_callback), ctx);
+    g_signal_connect(gtk_widget, "key-release-event", G_CALLBACK(ctx_key_press_or_release_callback), ctx);
+    g_signal_connect(gtk_widget, "map-event", G_CALLBACK(ctx_map_callback), ctx);
+    g_signal_connect(gtk_widget, "screen-changed", G_CALLBACK(ctx_screen_changed_callback), ctx);
+}
+
+
+void destroy_and_delete_ctx(WindowContext *ctx) {
+    if (ctx) {
+        ctx->process_destroy();
+
+        if (!ctx->get_events_count()) {
+            delete ctx;
+        }
+        // else: ctx will be deleted in EventsCounterHelper after completing
+        // an event processing
+    }
+}
+
+static inline jint gtk_button_number_to_mouse_button(guint button) {
+    switch (button) {
+        case 1:
+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;
+        case 2:
+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;
+        case 3:
+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
+        case MOUSE_BACK_BTN:
+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;
+        case MOUSE_FORWARD_BTN:
+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
+        default:
+            // Other buttons are not supported by quantum and are not reported by other platforms
+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;
+    }
+}
+
+////////////////////////////// WindowContext /////////////////////////////////
+
+static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
+static GdkAtom atom_net_wm_frame_extents = gdk_atom_intern_static_string("_NET_FRAME_EXTENTS");
+
+WindowContext * WindowContext::sm_mouse_drag_window = NULL;
+WindowContext * WindowContext::sm_grab_window = NULL;
+
+WindowContext::WindowContext(jobject _jwindow, WindowContext *_owner, long _screen,
+                                   WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
+        screen(_screen),
+        frame_type(_frame_type),
+        window_type(type),
+        owner(_owner),
+        jview(NULL),
+        map_received(false),
+        visible_received(false),
+        on_top(false),
+        is_fullscreen(false),
+        is_iconified(false),
+        is_maximized(false),
+        is_mouse_entered(false),
+        can_be_deleted(false),
+        events_processing_cnt(0),
+        pointer_device(NULL) {
+
+    jwindow = mainEnv->NewGlobalRef(_jwindow);
+
+    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
+
+    if (gchar * app_name = get_application_name()) {
+        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
+        g_free(app_name);
+    }
+
+    if (owner) {
+        owner->add_child(this);
+        if (on_top_inherited()) {
+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        }
+    }
+
+    if (type == UTILITY) {
+        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
+    }
+
+    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
+
+    if (xvisualID != 0) {
+        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
+        glass_gtk_window_configure_from_visual(gtk_widget, visual);
+    }
+
+    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
+    gtk_widget_set_app_paintable(gtk_widget, TRUE);
+
+    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
+    gtk_window_set_title(GTK_WINDOW(gtk_widget), "");
+
+    gdk_window = gtk_widget_get_window(gtk_widget);
+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
+
+    glass_dnd_attach_context(this);
+
+    gdk_windowManagerFunctions = wmf;
+    if (wmf) {
+        gdk_window_set_functions(gdk_window, wmf);
+    }
+
+    if (frame_type != TITLED) {
+        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
+    }
+
+    connect_signals(gtk_widget, this);
+}
+
+void WindowContext::paint(void *data, jint width, jint height) {
+#if GTK_CHECK_VERSION(3, 0, 0)
+    cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
+#if GTK_CHECK_VERSION(3, 22, 0)
+    GdkDrawingContext *dcontext = gdk_window_begin_draw_frame(gdk_window, region);
+    cairo_t *context = gdk_drawing_context_get_cairo_context(dcontext);
+#else
+    gdk_window_begin_paint_region(gdk_window, region);
+    cairo_t* context = gdk_cairo_create(gdk_window);
+#endif
+#else
+    cairo_t *context = gdk_cairo_create(gdk_window);
+#endif
+
+    if (bg_color.is_set) {
+        cairo_set_source_rgba(context, bg_color.red, bg_color.green, bg_color.blue,
+                                (frame_type == TRANSPARENT) ? 0 : 1);
+        cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
+        cairo_paint(context);
+    }
+
+    cairo_surface_t *cairo_surface;
+    cairo_surface = cairo_image_surface_create_for_data(
+            (unsigned char *) data,
+            CAIRO_FORMAT_ARGB32,
+            width, height, width * 4);
+
+    cairo_set_source_surface(context, cairo_surface, 0, 0);
+
+    applyShapeMask(data, width, height);
+    cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
+    cairo_paint(context);
+
+#if GTK_CHECK_VERSION(3, 0, 0)
+#if GTK_CHECK_VERSION(3, 22, 0)
+    gdk_window_end_draw_frame(gdk_window, dcontext);
+    cairo_region_destroy(region);
+#else
+    gdk_window_end_paint(gdk_window);
+    cairo_region_destroy(region);
+    cairo_destroy(context);
+#endif
+#else
+    cairo_destroy(context);
+#endif
+
+    cairo_surface_destroy(cairo_surface);
 }
 
-bool WindowContextBase::isEnabled() {
+bool WindowContext::isEnabled() {
     if (jwindow) {
         bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));
         LOG_EXCEPTION(mainEnv)
         return result;
     } else {
         return false;
     }
 }
 
-void WindowContextBase::notify_state(jint glass_state) {
-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {
-        if (is_maximized) {
-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;
-        }
-
-        int w, h;
-        glass_gdk_window_get_size(gdk_window, &w, &h);
-        if (jview) {
-            mainEnv->CallVoidMethod(jview,
-                    jViewNotifyRepaint,
-                    0, 0, w, h);
-            CHECK_JNI_EXCEPTION(mainEnv);
-        }
-    }
+GdkWindow *WindowContext::get_gdk_window() {
+    return gdk_window;
+}
 
-    if (jwindow) {
-       mainEnv->CallVoidMethod(jwindow,
-               jGtkWindowNotifyStateChanged,
-               glass_state);
-       CHECK_JNI_EXCEPTION(mainEnv);
-    }
+GtkWidget *WindowContext::get_gtk_widget() {
+    return gtk_widget;
 }
 
-void WindowContextBase::process_state(GdkEventWindowState* event) {
-    if (event->changed_mask &
-            (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {
+GtkWindow *WindowContext::get_gtk_window() {
+    return GTK_WINDOW(gtk_widget);
+}
 
-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {
-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;
-        }
-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {
-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
-        }
+WindowGeometry WindowContext::get_geometry() {
+    return geometry;
+}
 
-        jint stateChangeEvent;
+jobject WindowContext::get_jwindow() {
+    return jwindow;
+}
 
-        if (is_iconified) {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;
-        } else if (is_maximized) {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;
-        } else {
-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;
-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {
-                // in this case - the window manager will not support the programatic
-                // request to iconify - so we need to restore it now.
-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);
-            }
-        }
+jobject WindowContext::get_jview() {
+    return jview;
+}
 
-        notify_state(stateChangeEvent);
-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {
-        notify_on_top( event->new_window_state & GDK_WINDOW_STATE_ABOVE);
-    }
+void WindowContext::process_map() {
+    map_received = true;
+    apply_geometry();
 }
 
-void WindowContextBase::process_focus(GdkEventFocus* event) {
-    if (!event->in && WindowContextBase::sm_mouse_drag_window == this) {
+void WindowContext::process_focus(GdkEventFocus *event) {
+    if (!event->in && WindowContext::sm_mouse_drag_window == this) {
         ungrab_mouse_drag_focus();
     }
-    if (!event->in && WindowContextBase::sm_grab_window == this) {
+
+    if (!event->in && WindowContext::sm_grab_window == this) {
         ungrab_focus();
     }
 
     if (xim.enabled && xim.ic) {
         if (event->in) {
@@ -149,60 +345,94 @@
     }
 
     if (jwindow) {
         if (!event->in || isEnabled()) {
             mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,
-                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED : com_sun_glass_events_WindowEvent_FOCUS_LOST);
+                                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED
+                                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);
             CHECK_JNI_EXCEPTION(mainEnv)
         } else {
             mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusDisabled);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::increment_events_counter() {
-    ++events_processing_cnt;
-}
+void WindowContext::process_property_notify(GdkEventProperty *event) {
+    if (event->window == gdk_window) {
+        if (event->atom == atom_net_wm_state) {
+            process_net_wm_property();
+        } else if (event->atom == atom_net_wm_frame_extents) {
+            if (frame_type != TITLED) {
+                return;
+            }
 
-void WindowContextBase::decrement_events_counter() {
-    --events_processing_cnt;
+            int top, left, bottom, right;
+
+            if (get_frame_extents_property(&top, &left, &bottom, &right)) {
+                if (top + left + bottom + right > 0) {
+                    geometry.frame_extents_received = true;
+                    geometry.adjust_w = left + right;
+                    geometry.adjust_h = top + bottom;
+                    geometry.view_x = left;
+                    geometry.view_y = top;
+
+                    save_cached_extents();
+
+                    // set bounds again to set to correct window size that must
+                    // be the total width and height accounting extents
+                    // this is ignored if size is "content size" instead of "window size"
+                    if (geometry.window_size_set) {
+                        set_bounds(0, 0, false, false, geometry.current_w, geometry.current_h, -1, -1);
+                    }
+                }
+            }
+        }
+    }
 }
 
-size_t WindowContextBase::get_events_count() {
-    return events_processing_cnt;
-}
+void WindowContext::process_configure() {
+    calculate_adjustments();
 
-bool WindowContextBase::is_dead() {
-    return can_be_deleted;
-}
+    gint x, y, w, h, gtk_w, gtk_h;
 
-void destroy_and_delete_ctx(WindowContext* ctx) {
-    if (ctx) {
-        ctx->process_destroy();
+    gtk_window_get_position(GTK_WINDOW(gtk_widget), &x, &y);
+    gtk_window_get_size(GTK_WINDOW(gtk_widget), &gtk_w, &gtk_h);
+    w = gtk_w + geometry.adjust_w;
+    h = gtk_h + geometry.adjust_h;
 
-        if (!ctx->get_events_count()) {
-            delete ctx;
-        }
-        // else: ctx will be deleted in EventsCounterHelper after completing
-        // an event processing
-    }
+    gboolean pos_changed = geometry.current_x != x || geometry.current_y != y;
+    gboolean size_changed = geometry.current_w != w || geometry.current_h != h
+                            || geometry.current_cw != gtk_w || geometry.current_ch != gtk_h;
+
+    geometry.current_x = x;
+    geometry.current_y = y;
+    geometry.current_w = w;
+    geometry.current_h = h;
+    geometry.current_cw = gtk_w;
+    geometry.current_ch = gtk_h;
+
+    size_position_notify(size_changed, pos_changed);
 }
 
-void WindowContextBase::process_destroy() {
-    if (WindowContextBase::sm_mouse_drag_window == this) {
+void WindowContext::process_destroy() {
+    if (owner) {
+        owner->remove_child(this);
+    }
+
+    if (WindowContext::sm_mouse_drag_window == this) {
         ungrab_mouse_drag_focus();
     }
 
-    if (WindowContextBase::sm_grab_window == this) {
+    if (WindowContext::sm_grab_window == this) {
         ungrab_focus();
     }
 
-    std::set<WindowContextTop*>::iterator it;
+    std::set<WindowContext *>::iterator it;
     for (it = children.begin(); it != children.end(); ++it) {
         // FIX JDK-8226537: this method calls set_owner(NULL) which prevents
-        // WindowContextTop::process_destroy() to call remove_child() (because children
+        // WindowContext::process_destroy() to call remove_child() (because children
         // is being iterated here) but also prevents gtk_window_set_transient_for from
         // being called - this causes the crash on gnome.
         gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);
         (*it)->set_owner(NULL);
         destroy_and_delete_ctx(*it);
@@ -225,44 +455,30 @@
     }
 
     can_be_deleted = true;
 }
 
-void WindowContextBase::process_delete() {
+void WindowContext::process_delete() {
     if (jwindow && isEnabled()) {
+        gtk_widget_hide_on_delete(gtk_widget);
         mainEnv->CallVoidMethod(jwindow, jWindowNotifyClose);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-void WindowContextBase::process_expose(GdkEventExpose* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);
+void WindowContext::process_expose(GdkEventExpose *event) {
+    if (jview && is_visible()) {
+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y,
+                                event->area.width, event->area.height);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-static inline jint gtk_button_number_to_mouse_button(guint button) {
-    switch (button) {
-        case 1:
-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;
-        case 2:
-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;
-        case 3:
-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;
-        case MOUSE_BACK_BTN:
-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;
-        case MOUSE_FORWARD_BTN:
-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
-        default:
-            // Other buttons are not supported by quantum and are not reported by other platforms
-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;
-    }
-}
-
-void WindowContextBase::process_mouse_button(GdkEventButton* event) {
+void WindowContext::process_mouse_button(GdkEventButton *event) {
     bool press = event->type == GDK_BUTTON_PRESS;
+    bool release = event->type == GDK_BUTTON_RELEASE;
+
     guint state = event->state;
     guint mask = 0;
 
     // We need to add/remove current mouse button from the modifier flags
     // as X lib state represents the state just prior to the event and
@@ -289,27 +505,16 @@
         state |= mask;
     } else {
         state &= ~mask;
     }
 
-    if (press) {
-        GdkDevice* device = event->device;
-
-        if (glass_gdk_device_is_grabbed(device)
-                && (glass_gdk_device_get_window_at_position(device, NULL, NULL)
-                == NULL)) {
-            ungrab_focus();
-            return;
-        }
-    }
-
     // Upper layers expects from us Windows behavior:
     // all mouse events should be delivered to window where drag begins
     // and no exit/enter event should be reported during this drag.
     // We can grab mouse pointer for these needs.
     if (press) {
-        grab_mouse_drag_focus();
+        grab_mouse_drag_focus(NULL, true);
     } else {
         if ((event->state & MOUSE_BUTTONS_MASK)
             && !(state & MOUSE_BUTTONS_MASK)) { // all buttons released
             ungrab_mouse_drag_focus();
         } else if (event->button == 8 || event->button == 9) {
@@ -323,30 +528,30 @@
 
     jint button = gtk_button_number_to_mouse_button(event->button);
 
     if (jview && button != com_sun_glass_events_MouseEvent_BUTTON_NONE) {
         mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
-                button,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                gdk_modifier_mask_to_glass(state),
-                (event->button == 3 && press) ? JNI_TRUE : JNI_FALSE,
-                JNI_FALSE);
+                                press ? com_sun_glass_events_MouseEvent_DOWN : com_sun_glass_events_MouseEvent_UP,
+                                button,
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                gdk_modifier_mask_to_glass(state),
+                                (event->button == 3 && press) ? JNI_TRUE : JNI_FALSE,
+                                JNI_FALSE);
         CHECK_JNI_EXCEPTION(mainEnv)
 
         if (jview && event->button == 3 && press) {
             mainEnv->CallVoidMethod(jview, jViewNotifyMenu,
-                    (jint)event->x, (jint)event->y,
-                    (jint)event->x_root, (jint)event->y_root,
-                    JNI_FALSE);
+                                    (jint) event->x, (jint) event->y,
+                                    (jint) event->x_root, (jint) event->y_root,
+                                    JNI_FALSE);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {
+void WindowContext::process_mouse_motion(GdkEventMotion *event) {
     jint glass_modifier = gdk_modifier_mask_to_glass(event->state);
     jint isDrag = glass_modifier & (
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_PRIMARY |
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_MIDDLE |
             com_sun_glass_events_KeyEvent_MODIFIER_BUTTON_SECONDARY |
@@ -366,22 +571,22 @@
         button = com_sun_glass_events_MouseEvent_BUTTON_FORWARD;
     }
 
     if (jview) {
         mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                isDrag ? com_sun_glass_events_MouseEvent_DRAG : com_sun_glass_events_MouseEvent_MOVE,
-                button,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                glass_modifier,
-                JNI_FALSE,
-                JNI_FALSE);
+                                isDrag ? com_sun_glass_events_MouseEvent_DRAG : com_sun_glass_events_MouseEvent_MOVE,
+                                button,
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                glass_modifier,
+                                JNI_FALSE,
+                                JNI_FALSE);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
 }
 
-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {
+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {
     jdouble dx = 0;
     jdouble dy = 0;
 
     // converting direction to change in pixels
     switch (event->direction) {
@@ -408,46 +613,47 @@
         dy = dx;
         dx = t;
     }
     if (jview) {
         mainEnv->CallVoidMethod(jview, jViewNotifyScroll,
-                (jint) event->x, (jint) event->y,
-                (jint) event->x_root, (jint) event->y_root,
-                dx, dy,
-                gdk_modifier_mask_to_glass(event->state),
-                (jint) 0, (jint) 0,
-                (jint) 0, (jint) 0,
-                (jdouble) 40.0, (jdouble) 40.0);
+                                (jint) event->x, (jint) event->y,
+                                (jint) event->x_root, (jint) event->y_root,
+                                dx, dy,
+                                gdk_modifier_mask_to_glass(event->state),
+                                (jint) 0, (jint) 0,
+                                (jint) 0, (jint) 0,
+                                (jdouble) 40.0, (jdouble) 40.0);
         CHECK_JNI_EXCEPTION(mainEnv)
     }
-
 }
 
-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {
+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {
     bool enter = event->type == GDK_ENTER_NOTIFY;
+
     if (jview) {
         guint state = event->state;
         if (enter) { // workaround for RT-21590
             state &= ~MOUSE_BUTTONS_MASK;
         }
 
         if (enter != is_mouse_entered) {
             is_mouse_entered = enter;
             mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                    enter ? com_sun_glass_events_MouseEvent_ENTER : com_sun_glass_events_MouseEvent_EXIT,
-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                    (jint) event->x, (jint) event->y,
-                    (jint) event->x_root, (jint) event->y_root,
-                    gdk_modifier_mask_to_glass(state),
-                    JNI_FALSE,
-                    JNI_FALSE);
+                                    enter ? com_sun_glass_events_MouseEvent_ENTER
+                                          : com_sun_glass_events_MouseEvent_EXIT,
+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                    (jint) event->x, (jint) event->y,
+                                    (jint) event->x_root, (jint) event->y_root,
+                                    gdk_modifier_mask_to_glass(state),
+                                    JNI_FALSE,
+                                    JNI_FALSE);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::process_key(GdkEventKey* event) {
+void WindowContext::process_key(GdkEventKey *event) {
     bool press = event->type == GDK_KEY_PRESS;
     jint glassKey = get_glass_key(event);
     jint glassModifier = gdk_modifier_mask_to_glass(event->state);
     if (press) {
         glassModifier |= glass_key_to_modifier(glassKey);
@@ -486,608 +692,107 @@
         jChars = mainEnv->NewCharArray(0);
     }
     if (jview) {
         if (press) {
             mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                    com_sun_glass_events_KeyEvent_PRESS,
-                    glassKey,
-                    jChars,
-                    glassModifier);
+                                    com_sun_glass_events_KeyEvent_PRESS,
+                                    glassKey,
+                                    jChars,
+                                    glassModifier);
             CHECK_JNI_EXCEPTION(mainEnv)
 
             if (jview && key > 0) { // TYPED events should only be sent for printable characters.
                 mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                        com_sun_glass_events_KeyEvent_TYPED,
-                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,
-                        jChars,
-                        glassModifier);
+                                        com_sun_glass_events_KeyEvent_TYPED,
+                                        com_sun_glass_events_KeyEvent_VK_UNDEFINED,
+                                        jChars,
+                                        glassModifier);
                 CHECK_JNI_EXCEPTION(mainEnv)
             }
         } else {
             mainEnv->CallVoidMethod(jview, jViewNotifyKey,
-                    com_sun_glass_events_KeyEvent_RELEASE,
-                    glassKey,
-                    jChars,
-                    glassModifier);
+                                    com_sun_glass_events_KeyEvent_RELEASE,
+                                    glassKey,
+                                    jChars,
+                                    glassModifier);
             CHECK_JNI_EXCEPTION(mainEnv)
         }
     }
 }
 
-void WindowContextBase::paint(void* data, jint width, jint height)
-{
-    if (!is_visible()) {
-        return;
-    }
-#ifdef GLASS_GTK3
-    cairo_region_t *region = gdk_window_get_clip_region(gdk_window);
-    gdk_window_begin_paint_region(gdk_window, region);
-#endif
-    cairo_t* context;
-    context = gdk_cairo_create(gdk_window);
-
-    cairo_surface_t* cairo_surface;
-    cairo_surface = cairo_image_surface_create_for_data(
-            (unsigned char*)data,
-            CAIRO_FORMAT_ARGB32,
-            width, height, width * 4);
-
-    applyShapeMask(data, width, height);
+void WindowContext::process_state(GdkEventWindowState *event) {
+    if (event->changed_mask &
+        (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {
 
-    cairo_set_source_surface(context, cairo_surface, 0, 0);
-    cairo_set_operator (context, CAIRO_OPERATOR_SOURCE);
-    cairo_paint(context);
-#ifdef GLASS_GTK3
-    gdk_window_end_paint(gdk_window);
-    cairo_region_destroy(region);
-#endif
-
-    cairo_destroy(context);
-    cairo_surface_destroy(cairo_surface);
-}
-
-void WindowContextBase::add_child(WindowContextTop* child) {
-    children.insert(child);
-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());
-}
-
-void WindowContextBase::remove_child(WindowContextTop* child) {
-    children.erase(child);
-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);
-}
-
-void WindowContextBase::show_or_hide_children(bool show) {
-    std::set<WindowContextTop*>::iterator it;
-    for (it = children.begin(); it != children.end(); ++it) {
-        (*it)->set_minimized(!show);
-        (*it)->show_or_hide_children(show);
-    }
-}
-
-void WindowContextBase::reparent_children(WindowContext* parent) {
-    std::set<WindowContextTop*>::iterator it;
-    for (it = children.begin(); it != children.end(); ++it) {
-        (*it)->set_owner(parent);
-        parent->add_child(*it);
-    }
-    children.clear();
-}
-
-void WindowContextBase::set_visible(bool visible) {
-    if (visible) {
-        gtk_widget_show_all(gtk_widget);
-    } else {
-        gtk_widget_hide(gtk_widget);
-        if (jview && is_mouse_entered) {
-            is_mouse_entered = false;
-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                    com_sun_glass_events_MouseEvent_EXIT,
-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                    0, 0,
-                    0, 0,
-                    0,
-                    JNI_FALSE,
-                    JNI_FALSE);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
-    }
-}
-
-bool WindowContextBase::is_visible() {
-    return gtk_widget_get_visible(gtk_widget);
-}
-
-bool WindowContextBase::set_view(jobject view) {
-
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
-                com_sun_glass_events_MouseEvent_EXIT,
-                com_sun_glass_events_MouseEvent_BUTTON_NONE,
-                0, 0,
-                0, 0,
-                0,
-                JNI_FALSE,
-                JNI_FALSE);
-        mainEnv->DeleteGlobalRef(jview);
-    }
-
-    if (view) {
-        jview = mainEnv->NewGlobalRef(view);
-    } else {
-        jview = NULL;
-    }
-    return TRUE;
-}
-
-bool WindowContextBase::grab_mouse_drag_focus() {
-    if (glass_gdk_mouse_devices_grab_with_cursor(
-            gdk_window, gdk_window_get_cursor(gdk_window), FALSE)) {
-        WindowContextBase::sm_mouse_drag_window = this;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void WindowContextBase::ungrab_mouse_drag_focus() {
-    WindowContextBase::sm_mouse_drag_window = NULL;
-    glass_gdk_mouse_devices_ungrab();
-    if (WindowContextBase::sm_grab_window) {
-        WindowContextBase::sm_grab_window->grab_focus();
-    }
-}
-
-bool WindowContextBase::grab_focus() {
-    if (WindowContextBase::sm_mouse_drag_window
-            || glass_gdk_mouse_devices_grab(gdk_window)) {
-        WindowContextBase::sm_grab_window = this;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void WindowContextBase::ungrab_focus() {
-    if (!WindowContextBase::sm_mouse_drag_window) {
-        glass_gdk_mouse_devices_ungrab();
-    }
-    WindowContextBase::sm_grab_window = NULL;
-
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-}
-
-void WindowContextBase::set_cursor(GdkCursor* cursor) {
-    if (!is_in_drag()) {
-        if (WindowContextBase::sm_mouse_drag_window) {
-            glass_gdk_mouse_devices_grab_with_cursor(
-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);
-        } else if (WindowContextBase::sm_grab_window) {
-            glass_gdk_mouse_devices_grab_with_cursor(
-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);
+        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {
+            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;
         }
-    }
-    gdk_window_set_cursor(gdk_window, cursor);
-}
-
-void WindowContextBase::set_background(float r, float g, float b) {
-#ifdef GLASS_GTK3
-    GdkRGBA rgba = {0, 0, 0, 1.};
-    rgba.red = r;
-    rgba.green = g;
-    rgba.blue = b;
-    gdk_window_set_background_rgba(gdk_window, &rgba);
-#else
-    GdkColor color;
-    color.red   = (guint16) (r * 65535);
-    color.green = (guint16) (g * 65535);
-    color.blue  = (guint16) (b * 65535);
-    gtk_widget_modify_bg(gtk_widget, GTK_STATE_NORMAL, &color);
-#endif
-}
-
-WindowContextBase::~WindowContextBase() {
-    if (xim.ic) {
-        XDestroyIC(xim.ic);
-        xim.ic = NULL;
-    }
-    if (xim.im) {
-        XCloseIM(xim.im);
-        xim.im = NULL;
-    }
-
-    gtk_widget_destroy(gtk_widget);
-}
-
-////////////////////////////// WindowContextTop /////////////////////////////////
-WindowFrameExtents WindowContextTop::normal_extents = {28, 1, 1, 1};
-WindowFrameExtents WindowContextTop::utility_extents = {28, 1, 1, 1};
-
-
-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,
-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :
-            WindowContextBase(),
-            screen(_screen),
-            frame_type(_frame_type),
-            window_type(type),
-            owner(_owner),
-            geometry(),
-            resizable(),
-            frame_extents_initialized(),
-            map_received(false),
-            location_assigned(false),
-            size_assigned(false),
-            on_top(false),
-            requested_bounds()
-{
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
-
-    gtk_widget =  gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);
-
-    if (gchar* app_name = get_application_name()) {
-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);
-        g_free(app_name);
-    }
-
-    if (owner) {
-        owner->add_child(this);
-        if (on_top_inherited()) {
-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {
+            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;
         }
-    }
-
-    if (type == UTILITY) {
-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);
-    }
-
-//    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);
-//    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);
-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
-
-    if (xvisualID != 0) {
-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
-        glass_gtk_window_configure_from_visual(gtk_widget, visual);
-    }
-
-    gtk_widget_set_size_request(gtk_widget, 0, 0);
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
-    if (frame_type != TITLED) {
-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);
-    }
-
-    glass_gtk_configure_transparency_and_realize(gtk_widget, frame_type == TRANSPARENT);
-    gtk_window_set_title(GTK_WINDOW(gtk_widget), "");
-
-    gdk_window = gtk_widget_get_window(gtk_widget);
-
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-
-    gdk_window_register_dnd(gdk_window);
-
-    gdk_windowManagerFunctions = wmf;
-    if (wmf) {
-        gdk_window_set_functions(gdk_window, wmf);
-    }
-
-    if (frame_type == TITLED) {
-        request_frame_extents();
-    }
-}
-
-// Applied to a temporary full screen window to prevent sending events to Java
-void WindowContextTop::detach_from_java() {
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
-        jview = NULL;
-    }
-    if (jwindow) {
-        mainEnv->DeleteGlobalRef(jwindow);
-        jwindow = NULL;
-    }
-}
-
-static GdkAtom
-get_net_frame_extents_atom() {
-    static const char * extents_str = "_NET_FRAME_EXTENTS";
-    return gdk_atom_intern(extents_str, TRUE);
-}
-
-void
-WindowContextTop::request_frame_extents() {
-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));
-    Atom rfeAtom = XInternAtom(display, "_NET_REQUEST_FRAME_EXTENTS", True);
-    if (rfeAtom != None) {
-        XClientMessageEvent clientMessage;
-        memset(&clientMessage, 0, sizeof(clientMessage));
-
-        clientMessage.type = ClientMessage;
-        clientMessage.window = GDK_WINDOW_XID(gdk_window);
-        clientMessage.message_type = rfeAtom;
-        clientMessage.format = 32;
-
-        XSendEvent(display, XDefaultRootWindow(display), False,
-                   SubstructureRedirectMask | SubstructureNotifyMask,
-                   (XEvent *) &clientMessage);
-        XFlush(display);
-    }
-}
-
-void WindowContextTop::activate_window() {
-    Display *display = GDK_DISPLAY_XDISPLAY (gdk_window_get_display (gdk_window));
-    Atom navAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
-    if (navAtom != None) {
-        XClientMessageEvent clientMessage;
-        memset(&clientMessage, 0, sizeof(clientMessage));
-
-        clientMessage.type = ClientMessage;
-        clientMessage.window = GDK_WINDOW_XID(gdk_window);
-        clientMessage.message_type = navAtom;
-        clientMessage.format = 32;
-        clientMessage.data.l[0] = 1;
-        clientMessage.data.l[1] = gdk_x11_get_server_time(gdk_window);
-        clientMessage.data.l[2] = 0;
-
-        XSendEvent(display, XDefaultRootWindow(display), False,
-                   SubstructureRedirectMask | SubstructureNotifyMask,
-                   (XEvent *) &clientMessage);
-        XFlush(display);
-    }
-}
-
-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {
-    if (window_type == NORMAL) {
-        normal_extents = ex;
-    } else {
-        utility_extents = ex;
-    }
-}
-
-WindowFrameExtents WindowContextTop::get_cached_extents() {
-    return window_type == NORMAL ? normal_extents : utility_extents;
-}
 
+        jint stateChangeEvent;
 
-bool WindowContextTop::update_frame_extents() {
-    bool changed = false;
-    int top, left, bottom, right;
-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {
-        changed = geometry.extents.top != top
-                    || geometry.extents.left != left
-                    || geometry.extents.bottom != bottom
-                    || geometry.extents.right != right;
-        if (changed) {
-            geometry.extents.top = top;
-            geometry.extents.left = left;
-            geometry.extents.bottom = bottom;
-            geometry.extents.right = right;
-            if (!is_null_extents()) {
-                set_cached_extents(geometry.extents);
+        if (is_iconified) {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;
+        } else if (is_maximized) {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;
+        } else {
+            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;
+            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {
+                // in this case - the window manager will not support the programatic
+                // request to iconify - so we need to restore it now.
+                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);
             }
         }
-    }
-    return changed;
-}
 
-bool
-WindowContextTop::get_frame_extents_property(int *top, int *left,
-        int *bottom, int *right) {
-    unsigned long *extents;
-
-    if (gdk_property_get(gdk_window,
-            get_net_frame_extents_atom(),
-            gdk_atom_intern("CARDINAL", FALSE),
-            0,
-            sizeof (unsigned long) * 4,
-            FALSE,
-            NULL,
-            NULL,
-            NULL,
-            (guchar**) & extents)) {
-        *left = extents [0];
-        *right = extents [1];
-        *top = extents [2];
-        *bottom = extents [3];
-
-        g_free(extents);
-        return true;
-    }
-
-    return false;
-}
-
-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {
-     return (windowGeometry->final_width.type != BOUNDSTYPE_WINDOW)
-                   ? windowGeometry->final_width.value
-                         + windowGeometry->extents.left
-                         + windowGeometry->extents.right
-                   : windowGeometry->final_width.value;
-}
-
-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_height.type != BOUNDSTYPE_WINDOW)
-                   ? windowGeometry->final_height.value
-                         + windowGeometry->extents.top
-                         + windowGeometry->extents.bottom
-                   : windowGeometry->final_height.value;
-}
-
-static int geometry_get_content_width(WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_width.type != BOUNDSTYPE_CONTENT)
-                   ? windowGeometry->final_width.value
-                         - windowGeometry->extents.left
-                         - windowGeometry->extents.right
-                   : windowGeometry->final_width.value;
-}
-static int geometry_get_content_height(WindowGeometry *windowGeometry) {
-    return (windowGeometry->final_height.type != BOUNDSTYPE_CONTENT)
-                   ? windowGeometry->final_height.value
-                         - windowGeometry->extents.top
-                         - windowGeometry->extents.bottom
-                   : windowGeometry->final_height.value;
-}
-
-static int geometry_get_window_x(const WindowGeometry *windowGeometry) {
-    float value = windowGeometry->refx;
-    if (windowGeometry->gravity_x != 0) {
-        value -= geometry_get_window_width(windowGeometry)
-                     * windowGeometry->gravity_x;
-    }
-    return (int) value;
-}
-
-static int geometry_get_window_y(const WindowGeometry *windowGeometry) {
-    float value = windowGeometry->refy;
-    if (windowGeometry->gravity_y != 0) {
-        value -= geometry_get_window_height(windowGeometry)
-                     * windowGeometry->gravity_y;
-    }
-    return (int) value;
-}
-
-static void geometry_set_window_x(WindowGeometry *windowGeometry, int value) {
-    float newValue = value;
-    if (windowGeometry->gravity_x != 0) {
-        newValue += geometry_get_window_width(windowGeometry)
-                * windowGeometry->gravity_x;
-    }
-    windowGeometry->refx = newValue;
-}
-
-static void geometry_set_window_y(WindowGeometry *windowGeometry, int value) {
-    float newValue = value;
-    if (windowGeometry->gravity_y != 0) {
-        newValue += geometry_get_window_height(windowGeometry)
-                * windowGeometry->gravity_y;
+        notify_state(stateChangeEvent);
+    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {
+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);
     }
-    windowGeometry->refy = newValue;
 }
 
-void WindowContextTop::process_net_wm_property() {
+void WindowContext::process_net_wm_property() {
     // Workaround for https://bugs.launchpad.net/unity/+bug/998073
 
     static GdkAtom atom_atom = gdk_atom_intern_static_string("ATOM");
     static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
     static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string("_NET_WM_STATE_HIDDEN");
     static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string("_NET_WM_STATE_ABOVE");
 
     gint length;
-
-    glong* atoms = NULL;
+    glong *atoms = NULL;
 
     if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,
-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {
+                         0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar * *) & atoms)) {
 
         bool is_hidden = false;
         bool is_above = false;
         for (gint i = 0; i < (gint)(length / sizeof(glong)); i++) {
-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {
+            if (atom_net_wm_state_hidden == (GdkAtom) atoms[i]) {
                 is_hidden = true;
-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {
+            } else if (atom_net_wm_state_above == (GdkAtom) atoms[i]) {
                 is_above = true;
             }
         }
 
         g_free(atoms);
 
         if (is_iconified != is_hidden) {
             is_iconified = is_hidden;
 
             notify_state((is_hidden)
-                    ? com_sun_glass_events_WindowEvent_MINIMIZE
-                    : com_sun_glass_events_WindowEvent_RESTORE);
+                         ? com_sun_glass_events_WindowEvent_MINIMIZE
+                         : com_sun_glass_events_WindowEvent_RESTORE);
         }
 
         notify_on_top(is_above);
     }
 }
 
-void WindowContextTop::process_property_notify(GdkEventProperty* event) {
-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string("_NET_WM_STATE");
-
-    if (event->atom == atom_net_wm_state && event->window == gdk_window) {
-        process_net_wm_property();
-    }
-}
-
-void WindowContextTop::process_configure(GdkEventConfigure* event) {
-    gint x, y, w, h;
-    bool updateWindowConstraints = false;
-    if (gtk_window_get_decorated(GTK_WINDOW(gtk_widget))) {
-        GdkRectangle frame;
-        gint top, left, bottom, right;
-
-        gdk_window_get_frame_extents(gdk_window, &frame);
-#ifdef GLASS_GTK3
-        gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-        gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-        x = frame.x;
-        y = frame.y;
-        geometry.current_width = frame.width;
-        geometry.current_height = frame.height;
-
-        if (update_frame_extents()) {
-            updateWindowConstraints = true;
-            if (!frame_extents_initialized && !is_null_extents()) {
-                frame_extents_initialized = true;
-                set_bounds(0, 0, false, false,
-                    requested_bounds.width, requested_bounds.height,
-                    requested_bounds.client_width, requested_bounds.client_height
-                );
-            }
-        }
-    } else {
-        x = event->x;
-        y = event->y;
-        w = event->width;
-        h = event->height;
-    }
-
-    if (size_assigned && w <= 1 && h <= 1 && (geometry.final_width.value > 1 ||
-                                             geometry.final_height.value > 1)) {
-        // skip artifact
-        return;
-   }
-
-    // JDK-8232811: to avoid conflicting events, update the geometry only after window pops.
-    if (map_received) {
-        geometry.final_width.value = w;
-        geometry.final_width.type = BOUNDSTYPE_CONTENT;
-        geometry.final_height.value = h;
-        geometry.final_height.type = BOUNDSTYPE_CONTENT;
-    }
-
-    geometry_set_window_x(&geometry, x);
-    geometry_set_window_y(&geometry, y);
-
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-        mainEnv->CallVoidMethod(jview, jViewNotifyView,
-                com_sun_glass_events_ViewEvent_MOVE);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-                (is_maximized)
-                    ? com_sun_glass_events_WindowEvent_MAXIMIZE
-                    : com_sun_glass_events_WindowEvent_RESIZE,
-                geometry.current_width,
-                geometry.current_height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, x, y);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
-
-    glong to_screen = getScreenPtrForLocation(x, y);
+void WindowContext::process_screen_changed() {
+    glong to_screen = getScreenPtrForLocation(geometry.current_x, geometry.current_y);
     if (to_screen != -1) {
         if (to_screen != screen) {
             if (jwindow) {
                 //notify screen changed
                 jobject jScreen = createJavaScreen(mainEnv, to_screen);
@@ -1095,235 +800,144 @@
                 CHECK_JNI_EXCEPTION(mainEnv)
             }
             screen = to_screen;
         }
     }
+}
 
-    if (resizable.request != REQUEST_NONE) {
-        set_window_resizable(resizable.request == REQUEST_RESIZABLE);
-        resizable.request = REQUEST_NONE;
-    } else if (!resizable.value) {
-        set_window_resizable(false);
-    } else if (updateWindowConstraints) {
-        update_window_constraints();
-    }
-}
-
-void WindowContextTop::update_window_constraints() {
-    if (resizable.value) {
-        GdkGeometry geom = {
-            (resizable.minw == -1) ? 1
-                    : resizable.minw - geometry.extents.left - geometry.extents.right,
-            (resizable.minh == -1) ? 1
-                    : resizable.minh - geometry.extents.top - geometry.extents.bottom,
-            (resizable.maxw == -1) ? 100000
-                    : resizable.maxw - geometry.extents.left - geometry.extents.right,
-            (resizable.maxh == -1) ? 100000
-                    : resizable.maxh - geometry.extents.top - geometry.extents.bottom,
-            0, 0, 0, 0, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
-        };
-        gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom,
-                static_cast<GdkWindowHints> (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
-    }
-}
-
-void WindowContextTop::set_window_resizable(bool res) {
-    if(!res) {
-        int w = geometry_get_content_width(&geometry);
-        int h = geometry_get_content_height(&geometry);
-        if (w == -1 && h == -1) {
-            gtk_window_get_size(GTK_WINDOW(gtk_widget), &w, &h);
+void WindowContext::notify_on_top(bool top) {
+    // Do not report effective (i.e. native) values to the FX, only if the user sets it manually
+    if (top != effective_on_top() && jwindow) {
+        if (on_top_inherited() && !top) {
+            // Disallow user's "on top" handling on windows that inherited the property
+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        } else {
+            on_top = top;
+            update_ontop_tree(top);
+            mainEnv->CallVoidMethod(jwindow,
+                                    jWindowNotifyLevelChanged,
+                                    top ? com_sun_glass_ui_Window_Level_FLOATING
+                                        : com_sun_glass_ui_Window_Level_NORMAL);
+            CHECK_JNI_EXCEPTION(mainEnv);
         }
-        GdkGeometry geom = {w, h, w, h, 0, 0, 0, 0, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST};
-        gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom,
-                static_cast<GdkWindowHints>(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));
-        resizable.value = false;
-    } else {
-        resizable.value = true;
-        update_window_constraints();
     }
 }
 
-void WindowContextTop::set_resizable(bool res) {
-    resizable.prev = false;
-    gint w, h;
-    gtk_window_get_size(GTK_WINDOW(gtk_widget), &w, &h);
-    if (map_received || w > 1 || h > 1) {
-        set_window_resizable(res);
-    } else {
-        //Since window is not ready yet set only request for change of resizable.
-        resizable.request  = res ? REQUEST_RESIZABLE : REQUEST_NOT_RESIZABLE;
+void WindowContext::notify_repaint() {
+    int w, h;
+    glass_gdk_window_get_size(gdk_window, &w, &h);
+    if (jview) {
+        mainEnv->CallVoidMethod(jview,
+                                jViewNotifyRepaint,
+                                0, 0, w, h);
+        CHECK_JNI_EXCEPTION(mainEnv);
     }
 }
 
-void WindowContextTop::set_visible(bool visible)
-{
-    if (visible) {
-        if (!size_assigned) {
-            set_bounds(0, 0, false, false, 320, 200, -1, -1);
-        }
-        if (!location_assigned) {
-            set_bounds(0, 0, true, true, -1, -1, -1, -1);
+void WindowContext::notify_state(jint glass_state) {
+    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {
+        if (is_maximized) {
+            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;
         }
+
+        notify_repaint();
     }
-    WindowContextBase::set_visible(visible);
-    //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
-    if (visible && jwindow && isEnabled()) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
+
+    if (jwindow) {
+        mainEnv->CallVoidMethod(jwindow,
+                                jGtkWindowNotifyStateChanged,
+                                glass_state);
         CHECK_JNI_EXCEPTION(mainEnv);
     }
 }
 
-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-    requested_bounds.width = w;
-    requested_bounds.height = h;
-    requested_bounds.client_width = cw;
-    requested_bounds.client_height = ch;
-
-    if (!frame_extents_initialized && frame_type == TITLED) {
-        update_frame_extents();
-        if (is_null_extents()) {
-            if (!is_null_extents(get_cached_extents())) {
-                geometry.extents = get_cached_extents();
-            }
-        } else {
-            frame_extents_initialized = true;
-        }
+bool WindowContext::set_view(jobject view) {
+    if (jview) {
+        mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
+                                com_sun_glass_events_MouseEvent_EXIT,
+                                com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                0, 0,
+                                0, 0,
+                                0,
+                                JNI_FALSE,
+                                JNI_FALSE);
+        mainEnv->DeleteGlobalRef(jview);
     }
 
-    XWindowChanges windowChanges;
-    unsigned int windowChangesMask = 0;
-    if (w > 0) {
-        geometry.final_width.value = w;
-        geometry.final_width.type = BOUNDSTYPE_WINDOW;
-        geometry.current_width = geometry_get_window_width(&geometry);
-        windowChanges.width = geometry_get_content_width(&geometry);
-        windowChangesMask |= CWWidth;
-    } else if (cw > 0) {
-        geometry.final_width.value = cw;
-        geometry.final_width.type = BOUNDSTYPE_CONTENT;
-        geometry.current_width = geometry_get_window_width(&geometry);
-        windowChanges.width = geometry_get_content_width(&geometry);
-        windowChangesMask |= CWWidth;
-    }
-
-    if (h > 0) {
-        geometry.final_height.value = h;
-        geometry.final_height.type = BOUNDSTYPE_WINDOW;
-        geometry.current_height = geometry_get_window_height(&geometry);
-        windowChanges.height = geometry_get_content_height(&geometry);
-        windowChangesMask |= CWHeight;
-    } else if (ch > 0) {
-        geometry.final_height.value = ch;
-        geometry.final_height.type = BOUNDSTYPE_CONTENT;
-        geometry.current_height = geometry_get_window_height(&geometry);
-        windowChanges.height = geometry_get_content_height(&geometry);
-        windowChangesMask |= CWHeight;
+    if (view) {
+        jview = mainEnv->NewGlobalRef(view);
+    } else {
+        jview = NULL;
     }
+    return TRUE;
+}
 
-    if (xSet || ySet) {
-        if (xSet) {
-            geometry.refx = x + geometry.current_width * geometry.gravity_x;
-        }
-
-        windowChanges.x = geometry_get_window_x(&geometry);
-        windowChangesMask |= CWX;
-
-        if (ySet) {
-            geometry.refy = y + geometry.current_height * geometry.gravity_y;
+void WindowContext::set_visible(bool visible) {
+    if (visible) {
+        gtk_widget_show_all(gtk_widget);
+    } else {
+        gtk_widget_hide(gtk_widget);
+        if (jview && is_mouse_entered) {
+            is_mouse_entered = false;
+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,
+                                    com_sun_glass_events_MouseEvent_EXIT,
+                                    com_sun_glass_events_MouseEvent_BUTTON_NONE,
+                                    0, 0,
+                                    0, 0,
+                                    0,
+                                    JNI_FALSE,
+                                    JNI_FALSE);
+            CHECK_JNI_EXCEPTION(mainEnv)
         }
-
-        windowChanges.y = geometry_get_window_y(&geometry);
-        windowChangesMask |= CWY;
-
-        location_assigned = true;
     }
 
-    if (w > 0 || h > 0 || cw > 0 || ch > 0) size_assigned = true;
-
-    window_configure(&windowChanges, windowChangesMask);
-
-}
-
-void WindowContextTop::process_map() {
-    map_received = true;
-}
-
-void WindowContextTop::window_configure(XWindowChanges *windowChanges,
-        unsigned int windowChangesMask) {
-    if (windowChangesMask == 0) {
-        return;
+    if (visible) {
+        visible_received = TRUE;
     }
 
-    if (windowChangesMask & (CWX | CWY)) {
-        gint newX, newY;
-        gtk_window_get_position(GTK_WINDOW(gtk_widget), &newX, &newY);
-
-        if (windowChangesMask & CWX) {
-            newX = windowChanges->x;
-        }
-        if (windowChangesMask & CWY) {
-            newY = windowChanges->y;
-        }
-        gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+    //JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order
+    if (visible && jwindow && isEnabled()) {
+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
+        CHECK_JNI_EXCEPTION(mainEnv);
     }
+}
 
-    if (windowChangesMask & (CWWidth | CWHeight)) {
-        gint newWidth, newHeight;
-        gtk_window_get_size(GTK_WINDOW(gtk_widget), &newWidth, &newHeight);
-
-        if (windowChangesMask & CWWidth) {
-            newWidth = windowChanges->width;
-        }
-        if (windowChangesMask & CWHeight) {
-            newHeight = windowChanges->height;
-        }
-
-        if (!resizable.value) {
-            GdkGeometry geom;
-            GdkWindowHints hints = (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE);
-            geom.min_width = geom.max_width = newWidth;
-            geom.min_height = geom.max_height = newHeight;
-            gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &geom, hints);
-        }
-        gtk_window_resize(GTK_WINDOW(gtk_widget), newWidth, newHeight);
-
-        //JDK-8193502: Moved here from WindowContextBase::set_view because set_view is called
-        //first and the size is not set yet. This also guarantees that the size will be correct
-        //see: gtk_window_get_size doc for more context.
-        if (jview) {
-            mainEnv->CallVoidMethod(jview, jViewNotifyResize, newWidth, newHeight);
-            CHECK_JNI_EXCEPTION(mainEnv);
+void WindowContext::set_cursor(GdkCursor *cursor) {
+    if (!is_in_drag()) {
+        if (WindowContext::sm_mouse_drag_window) {
+            grab_mouse_drag_focus(cursor, false);
+        } else if (WindowContext::sm_grab_window) {
+            grab_mouse_drag_focus(cursor, true);
         }
     }
+
+    gdk_window_set_cursor(gdk_window, cursor);
 }
 
-void WindowContextTop::applyShapeMask(void* data, uint width, uint height)
-{
-    if (frame_type != TRANSPARENT) {
-        return;
+void WindowContext::set_level(int level) {
+    if (level == com_sun_glass_ui_Window_Level_NORMAL) {
+        on_top = false;
+    } else if (level == com_sun_glass_ui_Window_Level_FLOATING
+               || level == com_sun_glass_ui_Window_Level_TOPMOST) {
+        on_top = true;
     }
+    // We need to emulate always on top behaviour on child windows
 
-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
+    if (!on_top_inherited()) {
+        update_ontop_tree(on_top);
+    }
 }
 
-void WindowContextTop::ensure_window_size() {
-    gint w, h;
-#ifdef GLASS_GTK3
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-    if (size_assigned && (geometry.final_width.value != w
-                       || geometry.final_height.value != h)) {
-
-        gdk_window_resize(gdk_window, geometry.final_width.value,
-                                      geometry.final_height.value);
-    }
+void WindowContext::set_background(float r, float g, float b) {
+    bg_color.red = r;
+    bg_color.green = g;
+    bg_color.blue = b;
+    bg_color.is_set = true;
+    notify_repaint();
 }
 
-void WindowContextTop::set_minimized(bool minimize) {
+void WindowContext::set_minimized(bool minimize) {
     is_iconified = minimize;
     if (minimize) {
         if (frame_type == TRANSPARENT) {
             // https://bugs.launchpad.net/ubuntu/+source/unity/+bug/1245571
             glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));
@@ -1339,601 +953,522 @@
     } else {
         gtk_window_deiconify(GTK_WINDOW(gtk_widget));
         activate_window();
     }
 }
-void WindowContextTop::set_maximized(bool maximize) {
+
+void WindowContext::set_maximized(bool maximize) {
     is_maximized = maximize;
     if (maximize) {
-        ensure_window_size();
+        // enable the functionality
+        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);
+        gdk_window_set_functions(gdk_window, wmf);
+
         gtk_window_maximize(GTK_WINDOW(gtk_widget));
     } else {
         gtk_window_unmaximize(GTK_WINDOW(gtk_widget));
     }
 }
 
-void WindowContextTop::enter_fullscreen() {
-    ensure_window_size();
-    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
-}
-
-void WindowContextTop::exit_fullscreen() {
-    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));
-}
-
-void WindowContextTop::request_focus() {
-    //JDK-8212060: Window show and then move glitch.
-    //The WindowContextBase::set_visible will take care of showing the window.
-    //The below code will only handle later request_focus.
-    if (is_visible()) {
-        gtk_window_present(GTK_WINDOW(gtk_widget));
-    }
-}
+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
+    calculate_adjustments();
 
-void WindowContextTop::set_focusable(bool focusable) {
-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);
-}
+    // newW / newH always content sizes compatible with GTK+
+    // if window has no decoration, adjustments will be ZERO
+    int newW = w > 0 ? w - geometry.adjust_w : cw;
+    int newH = h > 0 ? h - geometry.adjust_h : ch;
 
-void WindowContextTop::set_title(const char* title) {
-    gtk_window_set_title(GTK_WINDOW(gtk_widget),title);
-}
+    gboolean size_changed = FALSE;
+    gboolean pos_changed = FALSE;
 
-void WindowContextTop::set_alpha(double alpha) {
-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);
-}
+    geometry.window_size_set = (w > 0 || h > 0);
 
-void WindowContextTop::set_enabled(bool enabled) {
-    if (enabled) {
-        if (resizable.prev) {
-            set_window_resizable(true);
-        }
-    } else {
-        if (resizable.value) {
-            set_window_resizable(false);
-            resizable.prev = true;
-        } else if (resizable.request == REQUEST_RESIZABLE) {
-            resizable.request = REQUEST_NOT_RESIZABLE;
-            resizable.prev = true;
-        }
-    }
-}
-
-void WindowContextTop::set_minimum_size(int w, int h) {
-    resizable.minw = w;
-    resizable.minh = h;
-    update_window_constraints();
-}
-
-void WindowContextTop::set_maximum_size(int w, int h) {
-    resizable.maxw = w;
-    resizable.maxh = h;
-    update_window_constraints();
-}
-
-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {
-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);
-}
-
-void WindowContextTop::restack(bool restack) {
-    gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
-}
-
-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {
-    if (modal) {
-        //gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);
-        if (parent) {
-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());
-        }
-    }
-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);
-}
-
-GtkWindow *WindowContextTop::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget);
-}
-
-WindowFrameExtents WindowContextTop::get_frame_extents() {
-    return geometry.extents;
-}
-
-void WindowContextTop::set_gravity(float x, float y) {
-    int oldX = geometry_get_window_x(&geometry);
-    int oldY = geometry_get_window_y(&geometry);
-    geometry.gravity_x = x;
-    geometry.gravity_y = y;
-    geometry_set_window_x(&geometry, oldX);
-    geometry_set_window_y(&geometry, oldY);
-}
-
-void WindowContextTop::update_ontop_tree(bool on_top) {
-    bool effective_on_top = on_top || this->on_top;
-    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);
-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {
-        (*it)->update_ontop_tree(effective_on_top);
-    }
-}
-
-bool WindowContextTop::on_top_inherited() {
-    WindowContext* o = owner;
-    while (o) {
-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);
-        if (!topO) break;
-        if (topO->on_top) {
-            return true;
-        }
-        o = topO->owner;
-    }
-    return false;
-}
-
-bool WindowContextTop::effective_on_top() {
-    if (owner) {
-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);
-        return (topO && topO->effective_on_top()) || on_top;
-    }
-    return on_top;
-}
+    if (newW > 0 && newH > 0) {
+        size_changed = TRUE;
 
-void WindowContextTop::notify_on_top(bool top) {
-    // Do not report effective (i.e. native) values to the FX, only if the user sets it manually
-    if (top != effective_on_top() && jwindow) {
-        if (on_top_inherited() && !top) {
-            // Disallow user's "on top" handling on windows that inherited the property
-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);
+        geometry.current_cw = newW;
+        geometry.current_ch = newH;
+        geometry.current_w = newW + geometry.adjust_w;
+        geometry.current_h = newH + geometry.adjust_h;
+
+        if (visible_received) {
+            // update constraints if not resized by the user interface so it will
+            // let gtk_window_resize succeed, because it's bound to geometry constraints
+            apply_geometry();
+            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);
         } else {
-            on_top = top;
-            update_ontop_tree(top);
-            mainEnv->CallVoidMethod(jwindow,
-                    jWindowNotifyLevelChanged,
-                    top ? com_sun_glass_ui_Window_Level_FLOATING :  com_sun_glass_ui_Window_Level_NORMAL);
-            CHECK_JNI_EXCEPTION(mainEnv);
+            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);
         }
     }
-}
 
-void WindowContextTop::set_level(int level) {
-    if (level == com_sun_glass_ui_Window_Level_NORMAL) {
-        on_top = false;
-    } else if (level == com_sun_glass_ui_Window_Level_FLOATING
-            || level == com_sun_glass_ui_Window_Level_TOPMOST) {
-        on_top = true;
+    if (xSet || ySet) {
+        int newX = (xSet) ? x : geometry.current_x;
+        int newY = (ySet) ? y : geometry.current_y;
+
+        if (newX != geometry.current_x || newY != geometry.current_y) {
+            pos_changed = TRUE;
+            geometry.current_x = newX;
+            geometry.current_y = newY;
+            gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+        }
     }
-    // We need to emulate always on top behaviour on child windows
 
-    if (!on_top_inherited()) {
-        update_ontop_tree(on_top);
+    size_position_notify(size_changed, pos_changed);
+}
+
+void WindowContext::set_resizable(bool res) {
+    if (res != geometry.resizable) {
+        geometry.resizable = res;
+        apply_geometry();
     }
 }
 
-void WindowContextTop::set_owner(WindowContext * owner_ctx) {
-    owner = owner_ctx;
+void WindowContext::set_focusable(bool focusable) {
+    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);
 }
 
-void WindowContextTop::process_destroy() {
-    if (owner) {
-        owner->remove_child(this);
-    }
+void WindowContext::set_title(const char *title) {
+    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);
+}
 
-    WindowContextBase::process_destroy();
+void WindowContext::set_alpha(double alpha) {
+    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble) alpha);
 }
 
-////////////////////////////// WindowContextPlug ////////////////////////////////
+void WindowContext::set_enabled(bool enabled) {
+    if (enabled != geometry.enabled) {
+        gtk_widget_set_sensitive(gtk_widget, enabled);
+        geometry.enabled = enabled;
+        apply_geometry();
+    }
+}
 
-static gboolean plug_configure(GtkWidget *widget, GdkEvent *event, gpointer user_data) {
-    (void)widget;
+void WindowContext::set_minimum_size(int w, int h) {
+    gboolean changed = geometry.minw != w || geometry.minh != h;
 
-    if (event->type == GDK_CONFIGURE) {
-        ((WindowContextPlug*)user_data)->process_gtk_configure(&event->configure);
+    if (!changed) {
+        return;
     }
-    return FALSE;
-}
 
-WindowContextPlug::WindowContextPlug(jobject _jwindow, void* _owner) :
-        WindowContextBase(),
-        parent()
-{
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
+    geometry.minw = w;
+    geometry.minh = h;
 
-    gtk_widget = gtk_plug_new((Window)PTR_TO_JLONG(_owner));
+    apply_geometry();
+}
 
-    g_signal_connect(G_OBJECT(gtk_widget), "configure-event", G_CALLBACK(plug_configure), this);
+void WindowContext::set_maximum_size(int w, int h) {
+    gboolean changed = geometry.maxw != w || geometry.maxh != h;
 
-    gtk_widget_set_size_request(gtk_widget, 0, 0);
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
+    if (!changed) {
+        return;
+    }
 
-    gtk_widget_realize(gtk_widget);
-    gdk_window = gtk_widget_get_window(gtk_widget);
+    geometry.maxw = w;
+    geometry.maxh = h;
 
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-    gdk_window_register_dnd(gdk_window);
+    apply_geometry();
+}
 
-    gtk_container = gtk_fixed_new();
-    gtk_container_add (GTK_CONTAINER(gtk_widget), gtk_container);
-    gtk_widget_realize(gtk_container);
+void WindowContext::set_icon(GdkPixbuf *pixbuf) {
+    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);
 }
 
-GtkWindow *WindowContextPlug::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget);
+void WindowContext::set_modal(bool modal, WindowContext *parent) {
+    if (modal) {
+        //gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);
+        if (parent) {
+            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());
+        }
+    }
+    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);
 }
 
-void WindowContextPlug::process_configure(GdkEventConfigure* event) {
-    (void)event;
+void WindowContext::set_gravity(float x, float y) {
+    geometry.gravity_x = x;
+    geometry.gravity_y = y;
+}
 
-    //Note: process_gtk_configure is used, so there's no need to handle GDK events
+void WindowContext::set_owner(WindowContext *owner_ctx) {
+    owner = owner_ctx;
 }
 
-void WindowContextPlug::process_gtk_configure(GdkEventConfigure* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+void WindowContext::add_child(WindowContext *child) {
+    children.insert(child);
+    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());
+}
 
-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-            com_sun_glass_events_WindowEvent_RESIZE,
-            event->width,
-            event->height);
-    CHECK_JNI_EXCEPTION(mainEnv)
+void WindowContext::remove_child(WindowContext *child) {
+    children.erase(child);
+    gtk_window_set_transient_for(child->get_gtk_window(), NULL);
+}
 
-    if (!embedded_children.empty()) {
-        WindowContextChild* child = embedded_children.back();
-        child->process_configure(event);
+void WindowContext::show_or_hide_children(bool show) {
+    std::set<WindowContext *>::iterator it;
+    for (it = children.begin(); it != children.end(); ++it) {
+        (*it)->set_minimized(!show);
+        (*it)->show_or_hide_children(show);
     }
 }
 
-bool WindowContextPlug::set_view(jobject view) {
-    // probably never called for applet window
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
-    }
+bool WindowContext::is_visible() {
+    return gtk_widget_get_visible(gtk_widget);
+}
 
-    if (view) {
-        gint width, height;
-        jview = mainEnv->NewGlobalRef(view);
-        gtk_window_get_size(GTK_WINDOW(gtk_widget), &width, &height);
-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);
-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)
+bool WindowContext::is_dead() {
+    return can_be_deleted;
+}
+
+bool WindowContext::grab_focus() {
+    if (WindowContext::sm_mouse_drag_window
+            || grab_mouse_drag_focus(NULL, true)) {
+        WindowContext::sm_grab_window = this;
+        return true;
     } else {
-        jview = NULL;
+        return false;
     }
-    return TRUE;
 }
 
-void WindowContextPlug::window_configure(XWindowChanges *windowChanges,
-        unsigned int windowChangesMask) {
-    if (windowChangesMask == 0) {
-        return;
+void WindowContext::ungrab_focus() {
+    if (!WindowContext::sm_mouse_drag_window) {
+        ungrab_mouse_drag_focus();
     }
 
-    if (windowChangesMask & (CWX | CWY)) {
-        gint newX, newY;
-        gtk_window_get_position(GTK_WINDOW(gtk_widget), &newX, &newY);
+    WindowContext::sm_grab_window = NULL;
 
-        if (windowChangesMask & CWX) {
-            newX = windowChanges->x;
-        }
-        if (windowChangesMask & CWY) {
-            newY = windowChanges->y;
-        }
-        gtk_window_move(GTK_WINDOW(gtk_widget), newX, newY);
+    if (jwindow) {
+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocusUngrab);
+        CHECK_JNI_EXCEPTION(mainEnv)
     }
+}
 
-    if (windowChangesMask & (CWWidth | CWHeight)) {
-        gint newWidth, newHeight;
-        gtk_window_get_size(GTK_WINDOW(gtk_widget),
-                &newWidth, &newHeight);
+void WindowContext::restack(bool restack) {
+    gdk_window_restack(gdk_window, NULL, restack ? TRUE : FALSE);
+}
 
-        if (windowChangesMask & CWWidth) {
-            newWidth = windowChanges->width;
-        }
-        if (windowChangesMask & CWHeight) {
-            newHeight = windowChanges->height;
-        };
-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);
+void WindowContext::request_focus() {
+    //JDK-8212060: Window show and then move glitch.
+    //The WindowContext::set_visible will take care of showing the window.
+    //The below code will only handle later request_focus.
+    if (is_visible()) {
+        gtk_window_present(GTK_WINDOW(gtk_widget));
     }
 }
 
-void WindowContextPlug::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-    XWindowChanges windowChanges;
-    unsigned int windowChangesMask = 0;
-
-    if (xSet) {
-        windowChanges.x = x;
-        windowChangesMask |= CWX;
-    }
+void WindowContext::enter_fullscreen() {
+    is_fullscreen = TRUE;
+    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));
+}
 
-    if (ySet) {
-        windowChanges.y = y;
-        windowChangesMask |= CWY;
-    }
+void WindowContext::exit_fullscreen() {
+    is_fullscreen = FALSE;
+    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));
+}
 
-    if (w > 0) {
-        windowChanges.width = w;
-        windowChangesMask |= CWWidth;
-    } else if (cw > 0) {
-        windowChanges.width = cw;
-        windowChangesMask |= CWWidth;
+// Applied to a temporary full screen window to prevent sending events to Java
+void WindowContext::detach_from_java() {
+    if (jview) {
+        mainEnv->DeleteGlobalRef(jview);
+        jview = NULL;
     }
-
-    if (h > 0) {
-        windowChanges.height = h;
-        windowChangesMask |= CWHeight;
-    } else if (ch > 0) {
-        windowChanges.height = ch;
-        windowChangesMask |= CWHeight;
+    if (jwindow) {
+        mainEnv->DeleteGlobalRef(jwindow);
+        jwindow = NULL;
     }
-
-    window_configure(&windowChanges, windowChangesMask);
 }
-////////////////////////////// WindowContextChild ////////////////////////////////
 
-void WindowContextChild::process_mouse_button(GdkEventButton* event) {
-    WindowContextBase::process_mouse_button(event);
-   // gtk_window_set_focus (GTK_WINDOW (gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW)), NULL);
-    gtk_widget_grab_focus(gtk_widget);
+void WindowContext::increment_events_counter() {
+    ++events_processing_cnt;
 }
 
-static gboolean child_focus_callback(GtkWidget *widget, GdkEvent *event, gpointer user_data)
-{
-    (void)widget;
-
-    WindowContext *ctx = (WindowContext *)user_data;
-    ctx->process_focus(&event->focus_change);
-    return TRUE;
+void WindowContext::decrement_events_counter() {
+    --events_processing_cnt;
 }
 
-WindowContextChild::WindowContextChild(jobject _jwindow,
-                                       void* _owner,
-                                       GtkWidget *parent_widget,
-                                       WindowContextPlug *parent_ctx) :
-        WindowContextBase(),
-        parent(),
-        full_screen_window(),
-        view()
-{
-    (void)_owner;
-
-    jwindow = mainEnv->NewGlobalRef(_jwindow);
-    gtk_widget = gtk_drawing_area_new();
-    parent = parent_ctx;
+size_t WindowContext::get_events_count() {
+    return events_processing_cnt;
+}
 
-    glong xvisualID = (glong) mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);
+///////////////////////// PROTECTED
 
-    if (xvisualID != 0) {
-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);
-        glass_gtk_window_configure_from_visual(gtk_widget, visual);
+void WindowContext::applyShapeMask(void *data, uint width, uint height) {
+    if (frame_type != TRANSPARENT) {
+        return;
     }
 
-    gtk_widget_set_events(gtk_widget, GDK_ALL_EVENTS_MASK);
-    gtk_widget_set_can_focus(GTK_WIDGET(gtk_widget), TRUE);
-    gtk_widget_set_app_paintable(gtk_widget, TRUE);
-    gtk_container_add (GTK_CONTAINER(parent_widget), gtk_widget);
-    gtk_widget_realize(gtk_widget);
-    gdk_window = gtk_widget_get_window(gtk_widget);
-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);
-    gdk_window_register_dnd(gdk_window);
-    g_signal_connect(gtk_widget, "focus-in-event", G_CALLBACK(child_focus_callback), this);
-    g_signal_connect(gtk_widget, "focus-out-event", G_CALLBACK(child_focus_callback), this);
+    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);
 }
 
-void WindowContextChild::set_visible(bool visible) {
-    std::vector<WindowContextChild*> &embedded_children =
-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+///////////////////////// PRIVATE
 
-    if (visible) {
-        embedded_children.push_back(this);
-    } else {
-        std::vector<WindowContextChild*>::iterator pos
-                = std::find(embedded_children.begin(), embedded_children.end(), this);
-        if (pos != embedded_children.end()) {
-            embedded_children.erase((pos));
-        }
+// This function calculate the deltas between window and window + decoration (titleblar, borders).
+// Only useful if the window manager does not support the frame extents extension - in this case
+// it uses GDK calculation, that is primary based on _NET_FRAME_EXTENTS but will try harder
+// if that's not available.
+void WindowContext::calculate_adjustments() {
+    if (frame_type != TITLED || geometry.frame_extents_received) {
+        return;
     }
 
-    WindowContextBase::set_visible(visible);
-}
+    gint x, y;
+    gdk_window_get_origin(gdk_window, &x, &y);
 
-GtkWindow *WindowContextChild::get_gtk_window() {
-    return GTK_WINDOW(gtk_widget_get_ancestor(gtk_widget, GTK_TYPE_WINDOW));
-}
+    gint rx, ry;
+    gdk_window_get_root_origin(gdk_window, &rx, &ry);
 
-void WindowContextChild::process_configure(GdkEventConfigure* event) {
-    if (jview) {
-        mainEnv->CallVoidMethod(jview, jViewNotifyResize,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+    if (rx != x || ry != y) {
+        // the left extends are correct - the right one is guessed to be the same
+        geometry.adjust_w = (rx - x) * 2;
+        // guess that bottom size is the same as left and right
+        geometry.adjust_h = (ry - y) + (rx - x);
 
-    gtk_widget_set_size_request(gtk_widget, event->width, event->height);
+        // those will be correct
+        geometry.view_x = (rx - x);
+        geometry.view_y = (ry - y);
 
-    if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
-                com_sun_glass_events_WindowEvent_RESIZE,
-                event->width,
-                event->height);
-        CHECK_JNI_EXCEPTION(mainEnv)
+        save_cached_extents();
+    } else {
+        CachedExtents c = (window_type == NORMAL) ? normal_extents : utility_extents;
+        geometry.adjust_w = c.adjust_w;
+        geometry.adjust_h = c.adjust_h;
+        geometry.view_x = c.view_x;
+        geometry.view_y = c.view_y;
     }
+
+    apply_geometry();
 }
 
-bool WindowContextChild::set_view(jobject view) {
-    if (jview) {
-        mainEnv->DeleteGlobalRef(jview);
+void WindowContext::save_cached_extents() {
+    if (frame_type != TITLED) {
+        return;
     }
 
-    if (view) {
-        gint width, height;
-        jview = mainEnv->NewGlobalRef(view);
-        GtkAllocation ws;
-        gtk_widget_get_allocation(gtk_widget, &ws);
-        width = ws.width;
-        height = ws.height;
-        mainEnv->CallVoidMethod(view, jViewNotifyResize, width, height);
-        CHECK_JNI_EXCEPTION_RET(mainEnv, FALSE)
+    if (window_type == NORMAL) {
+        normal_extents.adjust_w = geometry.adjust_w;
+        normal_extents.adjust_h = geometry.adjust_h;
+        normal_extents.view_x = geometry.view_x;
+        normal_extents.view_y = geometry.view_y;
     } else {
-        jview = NULL;
+        utility_extents.adjust_w = geometry.adjust_w;
+        utility_extents.adjust_h = geometry.adjust_h;
+        utility_extents.view_x = geometry.view_x;
+        utility_extents.view_y = geometry.view_y;
     }
-    return TRUE;
 }
 
-void WindowContextChild::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch) {
-
-    if (x > 0 || y > 0 || xSet || ySet) {
-        gint newX, newY;
-        gdk_window_get_origin(gdk_window, &newX, &newY);
-        if (jwindow) {
-            mainEnv->CallVoidMethod(jwindow,
-                    jWindowNotifyMove,
-                    newX, newY);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
+void WindowContext::apply_geometry() {
+    if (!map_received) {
+        return;
     }
 
-    // As we have no frames, there's no difference between the calls
-    if ((cw | ch) > 0) {
-        w = cw; h = ch;
-    }
+    GdkGeometry gdk_geometry;
+    gdk_geometry.win_gravity = GDK_GRAVITY_NORTH_WEST;
 
-    if (w > 0 || h > 0) {
-        gint newWidth, newHeight;
-        GtkAllocation ws;
-        gtk_widget_get_allocation(gtk_widget, &ws);
-        newWidth = ws.width;
-        newHeight = ws.height;
+    if ((!geometry.resizable || !geometry.enabled) && !(is_maximized || is_fullscreen)) {
+        // not resizeable
+        int w = (geometry.current_w - geometry.adjust_w) > 0
+                ? geometry.current_w - geometry.adjust_w
+                : geometry.current_cw;
 
-        if (w > 0) {
-            newWidth = w;
-        }
-        if (h > 0) {
-            newHeight = h;
-        }
-        gtk_widget_set_size_request(gtk_widget, newWidth, newHeight);
-        // FIXME: hack to set correct size to view
-        if (jview) {
-            mainEnv->CallVoidMethod(jview,
-                    jViewNotifyResize,
-                    newWidth, newHeight);
-            CHECK_JNI_EXCEPTION(mainEnv)
-        }
-    }
-}
+        int h = (geometry.current_h - geometry.adjust_h) > 0
+                ? geometry.current_h - geometry.adjust_h
+                : geometry.current_ch;
 
-int WindowContextChild::getEmbeddedX() {
-    int x;
-    gdk_window_get_origin(gdk_window, &x, NULL);
-    return x;
-}
+        gdk_geometry.min_width = gdk_geometry.max_width = w;
+        gdk_geometry.min_height = gdk_geometry.max_height = h;
+    } else {
+        gdk_geometry.min_width = (geometry.minw - geometry.adjust_w) > 0
+                                 ? geometry.minw - geometry.adjust_w : 1;
+        gdk_geometry.min_height = (geometry.minh - geometry.adjust_h) > 0
+                                  ? geometry.minh - geometry.adjust_h : 1;
 
-int WindowContextChild::getEmbeddedY() {
-    int y;
-    gdk_window_get_origin(gdk_window, NULL, &y);
-    return y;
+        gdk_geometry.max_width = (geometry.maxw - geometry.adjust_w > 0)
+                                 ? geometry.maxw - geometry.adjust_w : G_MAXINT;
+        gdk_geometry.max_height = (geometry.maxh - geometry.adjust_h > 0)
+                                  ? geometry.maxh - geometry.adjust_h : G_MAXINT;
+    }
 
+    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &gdk_geometry,
+                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE | GDK_HINT_WIN_GRAVITY));
 }
 
-void WindowContextChild::restack(bool toFront) {
-    std::vector<WindowContextChild*> &embedded_children =
-                dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+bool WindowContext::get_frame_extents_property(int *top, int *left,
+                                               int *bottom, int *right) {
+    unsigned long *extents;
 
-    std::vector<WindowContextChild*>::iterator pos
-        = std::find(embedded_children.begin(), embedded_children.end(), this);
+    if (gdk_property_get(gdk_window,
+                         atom_net_wm_frame_extents,
+                         gdk_atom_intern("CARDINAL", FALSE),
+                         0,
+                         sizeof(unsigned long) * 4,
+                         FALSE,
+                         NULL,
+                         NULL,
+                         NULL,
+                         (guchar * *) & extents)) {
+        *left = extents[0];
+        *right = extents[1];
+        *top = extents[2];
+        *bottom = extents[3];
 
-    embedded_children.erase(pos);
-    if (toFront) {
-        embedded_children.push_back(this);
-    } else {
-        embedded_children.insert(embedded_children.begin(), this);
+        g_free(extents);
+        return true;
     }
 
-    gdk_window_restack(gdk_window, NULL, toFront ? TRUE : FALSE);
+    return false;
 }
 
-void WindowContextChild::enter_fullscreen() {
-    if (full_screen_window) {
-        return;
-    }
+void WindowContext::activate_window() {
+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));
+    Atom navAtom = XInternAtom(display, "_NET_ACTIVE_WINDOW", True);
+    if (navAtom != None) {
+        XClientMessageEvent clientMessage;
+        memset(&clientMessage, 0, sizeof(clientMessage));
 
-    full_screen_window = new WindowContextTop(jwindow, NULL, 0L, UNTITLED,
-                                                NORMAL, (GdkWMFunction) 0);
-    int x, y, w, h;
-    gdk_window_get_origin(gdk_window, &x, &y);
-#ifdef GLASS_GTK3
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h);
-#else
-    gdk_window_get_geometry(gdk_window, NULL, NULL, &w, &h, NULL);
-#endif
-    full_screen_window->set_bounds(x, y, true, true, w, h, -1, -1);
+        clientMessage.type = ClientMessage;
+        clientMessage.window = GDK_WINDOW_XID(gdk_window);
+        clientMessage.message_type = navAtom;
+        clientMessage.format = 32;
+        clientMessage.data.l[0] = 1;
+        clientMessage.data.l[1] = gdk_x11_get_server_time(gdk_window);
+        clientMessage.data.l[2] = 0;
 
-    if (WindowContextBase::sm_grab_window == this) {
-        ungrab_focus();
+        XSendEvent(display, XDefaultRootWindow(display), False,
+                   SubstructureRedirectMask | SubstructureNotifyMask,
+                   (XEvent * ) & clientMessage);
+        XFlush(display);
     }
+}
 
-    reparent_children(full_screen_window);
+void WindowContext::size_position_notify(bool size_changed, bool pos_changed) {
+    if (jview) {
+        if (size_changed) {
+            mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.current_cw, geometry.current_ch);
+            CHECK_JNI_EXCEPTION(mainEnv);
+        }
 
-    full_screen_window->set_visible(true);
-    full_screen_window->enter_fullscreen();
+        if (pos_changed) {
+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_MOVE);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
+    }
 
     if (jwindow) {
-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)full_screen_window);
-        CHECK_JNI_EXCEPTION(mainEnv)
-    }
+        if (size_changed || is_maximized) {
+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,
+                                    (is_maximized)
+                                    ? com_sun_glass_events_WindowEvent_MAXIMIZE
+                                    : com_sun_glass_events_WindowEvent_RESIZE,
+                                    geometry.current_w, geometry.current_h);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
 
-    if (jview) {
-        this->view = (GlassView*)mainEnv->GetLongField(jview, jViewPtr);
+        if (pos_changed) {
+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.current_x, geometry.current_y);
+            CHECK_JNI_EXCEPTION(mainEnv)
+        }
+    }
+}
 
-        this->view->current_window = full_screen_window;
-        this->view->embedded_window = this;
-        full_screen_window->set_view(jview);
-        this->set_view(NULL);
+void WindowContext::update_ontop_tree(bool on_top) {
+    bool effective_on_top = on_top || this->on_top;
+    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);
+    for (std::set<WindowContext *>::iterator it = children.begin(); it != children.end(); ++it) {
+        (*it)->update_ontop_tree(effective_on_top);
     }
 }
 
-void WindowContextChild::exit_fullscreen() {
-    if (!full_screen_window) {
-        return;
+bool WindowContext::on_top_inherited() {
+    WindowContext *o = owner;
+    while (o) {
+        WindowContext *topO = dynamic_cast<WindowContext *>(o);
+        if (!topO) break;
+        if (topO->on_top) {
+            return true;
+        }
+        o = topO->owner;
     }
+    return false;
+}
 
-    if (WindowContextBase::sm_grab_window == this) {
-        ungrab_focus();
+bool WindowContext::effective_on_top() {
+    if (owner) {
+        WindowContext *topO = dynamic_cast<WindowContext *>(owner);
+        return (topO && topO->effective_on_top()) || on_top;
     }
+    return on_top;
+}
 
-    full_screen_window->reparent_children(this);
+GdkDevice * WindowContext::get_pointer_device() {
+    GdkDevice * device;
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    device = gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(gtk_widget)));
+#else
+    device = gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget));
+#endif
+#else
+    // gtk2
+    device = gdk_display_get_core_pointer(gtk_widget_get_display(gtk_widget));
+#endif
 
-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyDelegatePtr, (jlong)NULL);
-    CHECK_JNI_EXCEPTION(mainEnv)
+    return device;
+}
 
-    if (this->view) {
-        this->view->current_window = this;
-        this->view->embedded_window = NULL;
+bool WindowContext::grab_mouse_drag_focus(GdkCursor *cursor, bool owner_events) {
+    if (is_grab_disabled()) {
+        return false;
     }
-    this->set_view(full_screen_window->get_jview());
-
-    full_screen_window->detach_from_java();
 
-    full_screen_window->set_view(NULL);
+    ungrab_mouse_drag_focus();
 
-    full_screen_window->set_visible(false);
+    pointer_device = get_pointer_device();
+#ifdef GLASS_GTK3
+#if GTK_CHECK_VERSION(3, 20, 0)
+    GdkGrabStatus status = gdk_seat_grab(gdk_device_get_seat(pointer_device), gdk_window,
+                                          GDK_SEAT_CAPABILITY_ALL_POINTING, owner_events, cursor, NULL, NULL, NULL);
+#else
+    GdkGrabStatus status = gdk_device_grab(pointer_device, gdk_window, GDK_OWNERSHIP_WINDOW, owner_events,
+                                            GDK_ALL_EVENTS_MASK, cursor, GDK_CURRENT_TIME);
+#endif
+#else
+    GdkGrabStatus status = gdk_pointer_grab(gdk_window, owner_events, GDK_ALL_EVENTS_MASK, NULL, cursor, GDK_CURRENT_TIME);
+#endif
+    WindowContext::sm_mouse_drag_window = this;
 
-    destroy_and_delete_ctx(full_screen_window);
-    full_screen_window = NULL;
-    this->view = NULL;
+    return (status == GDK_GRAB_SUCCESS) ? true : false;
 }
 
-void WindowContextChild::process_destroy() {
-    if (full_screen_window) {
-        destroy_and_delete_ctx(full_screen_window);
+void WindowContext::ungrab_mouse_drag_focus() {
+    if (!pointer_device) {
+        return;
     }
 
-    std::vector<WindowContextChild*> &embedded_children =
-            dynamic_cast<WindowContextPlug*>(parent)->embedded_children;
+//#ifdef GLASS_GTK3
+//#if GTK_CHECK_VERSION(3, 20, 0)
+//    gdk_seat_ungrab(gdk_device_get_seat(pointer_device));
+//#else
+//    gdk_device_ungrab(pointer_device, GDK_CURRENT_TIME);
+//#endif
+//#else
+    gdk_pointer_ungrab(GDK_CURRENT_TIME);
+//#endif
+    pointer_device = NULL;
+
+    WindowContext::sm_mouse_drag_window = NULL;
+
+    if (WindowContext::sm_grab_window) {
+        WindowContext::sm_grab_window->grab_focus();
+    }
+}
 
-    std::vector<WindowContextChild*>::iterator pos
-                = std::find(embedded_children.begin(), embedded_children.end(), this);
-    if (pos != embedded_children.end()) {
-        embedded_children.erase((pos));
+WindowContext::~WindowContext() {
+    if (xim.ic) {
+        XDestroyIC(xim.ic);
+        xim.ic = NULL;
+    }
+    if (xim.im) {
+        XCloseIM(xim.im);
+        xim.im = NULL;
     }
 
-    WindowContextBase::process_destroy();
+    gtk_widget_destroy(gtk_widget);
 }
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,10 +31,11 @@
 #include <jni.h>
 #include <set>
 #include <vector>
 
 #include "glass_view.h"
+#include "glass_general.h"
 
 enum WindowFrameType {
     TITLED,
     UNTITLED,
     TRANSPARENT
@@ -50,420 +51,233 @@
     REQUEST_NONE,
     REQUEST_RESIZABLE,
     REQUEST_NOT_RESIZABLE
 };
 
-struct WindowFrameExtents {
-    int top;
-    int left;
-    int bottom;
-    int right;
+static const guint MOUSE_BUTTONS_MASK = (guint)(GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);
+
+struct BgColor {
+    BgColor() : red(0), green(0), blue(0), is_set(FALSE) {}
+
+    float red;
+    float green;
+    float blue;
+    bool is_set;
 };
 
-static const guint MOUSE_BUTTONS_MASK = (guint) (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);
+struct CachedExtents {
+    int adjust_w;
+    int adjust_h;
 
-enum BoundsType {
-    BOUNDSTYPE_CONTENT,
-    BOUNDSTYPE_WINDOW
+    // The position of the view relative to the window
+    int view_x;
+    int view_y;
 };
 
+static CachedExtents normal_extents = {0, 0, 0, 0};
+static CachedExtents utility_extents = {0, 0, 0, 0};
+
 struct WindowGeometry {
-    WindowGeometry(): final_width(), final_height(),
-    refx(), refy(), gravity_x(), gravity_y(), current_width(), current_height(), extents() {}
-    // estimate of the final width the window will get after all pending
-    // configure requests are processed by the window manager
-    struct {
-        int value;
-        BoundsType type;
-    } final_width;
-
-    struct {
-        int value;
-        BoundsType type;
-    } final_height;
-
-    float refx;
-    float refy;
+    WindowGeometry() : current_x(0),
+                       current_y(0),
+                       current_w(0),
+                       current_h(0),
+                       current_cw(0),
+                       current_ch(0),
+                       adjust_w(0),
+                       adjust_h(0),
+                       view_x(0),
+                       view_y(0),
+                       frame_extents_received(false),
+                       gravity_x(1.00),
+                       gravity_y(1.00),
+                       enabled(true),
+                       resizable(true),
+                       minw(-1),
+                       minh(-1),
+                       maxw(-1),
+                       maxh(-1),
+                       window_size_set(false) {}
+
+    int current_x; // current position X
+    int current_y; // current position Y
+    int current_w; // current window width
+    int current_h; // current window height
+    int current_cw; // current content (view) width
+    int current_ch; // current content (view) height
+
+    // Used to ajust window sizes because gtk doest not account frame extents as part
+    // of the window size and JavaFx does.
+    int adjust_w;
+    int adjust_h;
+
+    // The position of the view relative to the window
+    int view_x;
+    int view_y;
+
+    // If WM supports _NET_REQUEST_FRAME_EXTENTS and it was received
+    bool frame_extents_received;
+
+    // Currently not used
     float gravity_x;
     float gravity_y;
 
-    // the last width which was configured or obtained from configure
-    // notification
-    int current_width;
+    bool enabled;
+    bool resizable;
 
-    // the last height which was configured or obtained from configure
-    // notification
-    int current_height;
+    int minw;
+    int minh;
 
-    WindowFrameExtents extents;
+    int maxw;
+    int maxh;
 
+    // if the window size was set (instead of content size) - this is used to
+    // "fix" the window size accouting extents.
+    bool window_size_set;
 };
 
-class WindowContextChild;
-class WindowContextTop;
-
 class WindowContext {
-public:
-    virtual bool isEnabled() = 0;
-    virtual bool hasIME() = 0;
-    virtual bool filterIME(GdkEvent *) = 0;
-    virtual void enableOrResetIME() = 0;
-    virtual void disableIME() = 0;
-    virtual void paint(void* data, jint width, jint height) = 0;
-    virtual WindowFrameExtents get_frame_extents() = 0;
-
-    virtual void enter_fullscreen() = 0;
-    virtual void exit_fullscreen() = 0;
-    virtual void show_or_hide_children(bool) = 0;
-    virtual void set_visible(bool) = 0;
-    virtual bool is_visible() = 0;
-    virtual void set_bounds(int, int, bool, bool, int, int, int, int) = 0;
-    virtual void set_resizable(bool) = 0;
-    virtual void request_focus() = 0;
-    virtual void set_focusable(bool)= 0;
-    virtual bool grab_focus() = 0;
-    virtual bool grab_mouse_drag_focus() = 0;
-    virtual void ungrab_focus() = 0;
-    virtual void ungrab_mouse_drag_focus() = 0;
-    virtual void set_title(const char*) = 0;
-    virtual void set_alpha(double) = 0;
-    virtual void set_enabled(bool) = 0;
-    virtual void set_minimum_size(int, int) = 0;
-    virtual void set_maximum_size(int, int) = 0;
-    virtual void set_minimized(bool) = 0;
-    virtual void set_maximized(bool) = 0;
-    virtual void set_icon(GdkPixbuf*) = 0;
-    virtual void restack(bool) = 0;
-    virtual void set_cursor(GdkCursor*) = 0;
-    virtual void set_modal(bool, WindowContext* parent = NULL) = 0;
-    virtual void set_gravity(float, float) = 0;
-    virtual void set_level(int) = 0;
-    virtual void set_background(float, float, float) = 0;
-
-    virtual void process_property_notify(GdkEventProperty*) = 0;
-    virtual void process_configure(GdkEventConfigure*) = 0;
-    virtual void process_map() = 0;
-    virtual void process_focus(GdkEventFocus*) = 0;
-    virtual void process_destroy() = 0;
-    virtual void process_delete() = 0;
-    virtual void process_expose(GdkEventExpose*) = 0;
-    virtual void process_mouse_button(GdkEventButton*) = 0;
-    virtual void process_mouse_motion(GdkEventMotion*) = 0;
-    virtual void process_mouse_scroll(GdkEventScroll*) = 0;
-    virtual void process_mouse_cross(GdkEventCrossing*) = 0;
-    virtual void process_key(GdkEventKey*) = 0;
-    virtual void process_state(GdkEventWindowState*) = 0;
-
-    virtual void notify_state(jint) = 0;
-    virtual void notify_on_top(bool) {}
-
-    virtual void add_child(WindowContextTop* child) = 0;
-    virtual void remove_child(WindowContextTop* child) = 0;
-    virtual bool set_view(jobject) = 0;
-
-    virtual GdkWindow *get_gdk_window() = 0;
-    virtual GtkWindow *get_gtk_window() = 0;
-    virtual jobject get_jview() = 0;
-    virtual jobject get_jwindow() = 0;
-
-    virtual int getEmbeddedX() = 0;
-    virtual int getEmbeddedY() = 0;
-
-
-    virtual void increment_events_counter() = 0;
-    virtual void decrement_events_counter() = 0;
-    virtual size_t get_events_count() = 0;
-    virtual bool is_dead() = 0;
-    virtual ~WindowContext() {}
-};
+private:
+    jlong screen;
+    WindowFrameType frame_type;
+    WindowType window_type;
+    struct WindowContext *owner;
+    jobject jwindow;
+    jobject jview;
 
-class WindowContextBase: public WindowContext {
+    bool map_received;
+    bool visible_received;
+    bool on_top;
+    bool is_fullscreen;
+    bool is_iconified;
+    bool is_maximized;
+    bool is_mouse_entered;
+    bool can_be_deleted;
 
-    struct _XIM{
+    struct _XIM {
         XIM im;
         XIC ic;
         bool enabled;
-    } xim;
+    } xim = { NULL, NULL, FALSE};
 
     size_t events_processing_cnt;
-    bool can_be_deleted;
-protected:
-    std::set<WindowContextTop*> children;
-    jobject jwindow;
-    jobject jview;
-    GtkWidget* gtk_widget;
-    GdkWindow* gdk_window;
-    GdkWMFunction gdk_windowManagerFunctions;
-
-    bool is_iconified;
-    bool is_maximized;
-    bool is_mouse_entered;
 
-    /*
-     * sm_grab_window points to WindowContext holding a mouse grab.
-     * It is mostly used for popup windows.
-     */
-    static WindowContext* sm_grab_window;
+    WindowGeometry geometry;
+    GtkWindowGroup *win_group; // this is used for window grabs
+    std::set<WindowContext *> children;
+    GdkWMFunction gdk_windowManagerFunctions;
+    GtkWidget *gtk_widget;
+    GdkWindow *gdk_window;
+    BgColor bg_color;
+    GdkDevice *pointer_device;
 
-    /*
-     * sm_mouse_drag_window points to a WindowContext from which a mouse drag started.
-     * This WindowContext holding a mouse grab during this drag. After releasing
-     * all mouse buttons sm_mouse_drag_window becomes NULL and sm_grab_window's
-     * mouse grab should be restored if present.
-     *
-     * This is done in order to mimic Windows behavior:
-     * All mouse events should be delivered to a window from which mouse drag
-     * started, until all mouse buttons released. No mouse ENTER/EXIT events
-     * should be reported during this drag.
-     */
     static WindowContext* sm_mouse_drag_window;
+    static WindowContext* sm_grab_window;
 public:
-    bool isEnabled();
+    WindowContext(jobject, WindowContext *, long, WindowFrameType, WindowType, GdkWMFunction);
+
     bool hasIME();
     bool filterIME(GdkEvent *);
     void enableOrResetIME();
     void disableIME();
+
     void paint(void*, jint, jint);
+    bool isEnabled();
+
     GdkWindow *get_gdk_window();
+    GtkWidget *get_gtk_widget();
+    GtkWindow *get_gtk_window();
+    WindowGeometry get_geometry();
     jobject get_jwindow();
     jobject get_jview();
 
-    void add_child(WindowContextTop*);
-    void remove_child(WindowContextTop*);
-    void show_or_hide_children(bool);
-    void reparent_children(WindowContext* parent);
-    void set_visible(bool);
-    bool is_visible();
-    bool set_view(jobject);
-    bool grab_focus();
-    bool grab_mouse_drag_focus();
-    void ungrab_focus();
-    void ungrab_mouse_drag_focus();
-    void set_cursor(GdkCursor*);
-    void set_level(int) {}
-    void set_background(float, float, float);
-
-    void process_map() {}
+    void process_map();
     void process_focus(GdkEventFocus*);
+    void process_property_notify(GdkEventProperty *);
+    void process_configure();
     void process_destroy();
     void process_delete();
     void process_expose(GdkEventExpose*);
     void process_mouse_button(GdkEventButton*);
     void process_mouse_motion(GdkEventMotion*);
     void process_mouse_scroll(GdkEventScroll*);
     void process_mouse_cross(GdkEventCrossing*);
     void process_key(GdkEventKey*);
     void process_state(GdkEventWindowState*);
+    void process_net_wm_property();
+    void process_screen_changed();
 
+    void notify_on_top(bool);
+    void notify_repaint();
     void notify_state(jint);
 
-    int getEmbeddedX() { return 0; }
-    int getEmbeddedY() { return 0; }
-
-    void increment_events_counter();
-    void decrement_events_counter();
-    size_t get_events_count();
-    bool is_dead();
-
-    ~WindowContextBase();
-protected:
-    virtual void applyShapeMask(void*, uint width, uint height) = 0;
-private:
-    bool im_filter_keypress(GdkEventKey*);
-};
-
-class WindowContextPlug: public WindowContextBase {
-    WindowContext* parent;
-public:
     bool set_view(jobject);
-    void set_bounds(int, int, bool, bool, int, int, int, int);
-    //WindowFrameExtents get_frame_extents() { return WindowFrameExtents{0, 0, 0, 0}; };
-    WindowFrameExtents get_frame_extents() { WindowFrameExtents ext = {0, 0, 0, 0}; return ext;}
-
-    void enter_fullscreen() {}
-    void exit_fullscreen() {}
-    void set_resizable(bool) {}
-    void request_focus() {}
-    void set_focusable(bool) {}
-    void set_title(const char*) {}
-    void set_alpha(double) {}
-    void set_enabled(bool) {}
-    void set_minimum_size(int, int) {}
-    void set_maximum_size(int, int) {}
-    void set_minimized(bool) {}
-    void set_maximized(bool) {}
-    void set_icon(GdkPixbuf*) {}
-    void restack(bool) {}
-    void set_modal(bool, WindowContext*) {}
-    void set_gravity(float, float) {}
-    void process_property_notify(GdkEventProperty*) {}
-    void process_configure(GdkEventConfigure*);
-    void process_gtk_configure(GdkEventConfigure*);
-
-    void applyShapeMask(void*, uint width, uint height) {
-        (void)width;
-        (void)height;
-    }
-    GtkWindow *get_gtk_window(); // TODO, get window from parent
-
-    WindowContextPlug(jobject, void*);
-    GtkWidget* gtk_container;
-    std::vector<WindowContextChild *> embedded_children;
-private:
-    //HACK: remove once set_bounds is implemented correctly
-    void window_configure(XWindowChanges *, unsigned int);
-    WindowContextPlug(WindowContextPlug&);
-    WindowContextPlug& operator= (const WindowContextPlug&);
-};
-
-class WindowContextChild: public WindowContextBase {
-    WindowContextPlug* parent;
-    WindowContextTop* full_screen_window;
-    GlassView* view; // not null while in Full Screen
-public:
-    void process_mouse_button(GdkEventButton*);
-    bool set_view(jobject);
-    void set_bounds(int, int, bool, bool, int, int, int, int);
-    //WindowFrameExtents get_frame_extents() { return WindowFrameExtents{0, 0, 0, 0}; };
-    WindowFrameExtents get_frame_extents() { WindowFrameExtents ext = {0, 0, 0, 0}; return ext;}
-
-    void enter_fullscreen();
-    void exit_fullscreen();
-    void set_resizable(bool) {}
-    void request_focus() {}
-    void set_focusable(bool) {}
-    void set_title(const char*) {}
-    void set_alpha(double) {}
-    void set_enabled(bool) {}
-    void set_minimum_size(int, int) {}
-    void set_maximum_size(int, int) {}
-    void set_minimized(bool) {}
-    void set_maximized(bool) {}
-    void set_icon(GdkPixbuf*) {}
-    void restack(bool);
-    void set_modal(bool, WindowContext*) {}
-    void set_gravity(float, float) {}
-    void process_property_notify(GdkEventProperty*) {}
-    void process_configure(GdkEventConfigure*);
-    void process_destroy();
-    void set_visible(bool visible);
-
-    int getEmbeddedX();
-    int getEmbeddedY();
-
-    void applyShapeMask(void*, uint width, uint height) {
-        (void)width;
-        (void)height;
-    }
-    GtkWindow *get_gtk_window(); // TODO, get window from parent
-
-    WindowContextChild(jobject, void*, GtkWidget *parent_widget, WindowContextPlug *parent_context);
-private:
-    WindowContextChild(WindowContextChild&);
-    WindowContextChild& operator= (const WindowContextChild&);
-};
-
-class WindowContextTop: public WindowContextBase {
-    jlong screen;
-    WindowFrameType frame_type;
-    WindowType window_type;
-    struct WindowContext *owner;
-    WindowGeometry geometry;
-    struct _Resizable{// we can't use set/get gtk_window_resizable function
-        _Resizable(): request(REQUEST_NONE), value(true), prev(false),
-                minw(-1), minh(-1), maxw(-1), maxh(-1){}
-        request_type request; //request for future setResizable
-        bool value; //actual value of resizable for a window
-        bool prev; //former resizable value (used in setEnabled for parents of modal window)
-        int minw, minh, maxw, maxh; //minimum and maximum window width/height;
-    } resizable;
-
-    bool frame_extents_initialized;
-    bool map_received;
-    bool location_assigned;
-    bool size_assigned;
-    bool on_top;
-
-    struct _Size {
-        int width, height;
-        int client_width, client_height;
-    } requested_bounds;
-
-    bool is_null_extents() { return is_null_extents(geometry.extents); }
-
-    bool is_null_extents(WindowFrameExtents ex) {
-        return !ex.top && !ex.left && !ex.bottom && !ex.right;
-    }
-
-    static WindowFrameExtents normal_extents;
-    static WindowFrameExtents utility_extents;
-public:
-    WindowContextTop(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);
-    void process_map();
-    void process_property_notify(GdkEventProperty*);
-    void process_configure(GdkEventConfigure*);
-    void process_destroy();
-    void process_net_wm_property();
-
-    WindowFrameExtents get_frame_extents();
-
+    void set_visible(bool);
+    void set_cursor(GdkCursor*);
+    void set_level(int);
+    void set_background(float, float, float);
     void set_minimized(bool);
     void set_maximized(bool);
     void set_bounds(int, int, bool, bool, int, int, int, int);
     void set_resizable(bool);
-    void request_focus();
     void set_focusable(bool);
-    void set_title(const char*);
+    void set_title(const char *);
     void set_alpha(double);
     void set_enabled(bool);
     void set_minimum_size(int, int);
     void set_maximum_size(int, int);
-    void set_icon(GdkPixbuf*);
-    void restack(bool);
-    void set_modal(bool, WindowContext* parent = NULL);
+    void set_icon(GdkPixbuf *);
+    void set_modal(bool, WindowContext *parent = NULL);
     void set_gravity(float, float);
-    void set_level(int);
-    void set_visible(bool);
-    void notify_on_top(bool);
-
+    void set_owner(WindowContext *);
+    void add_child(WindowContext *);
+    void remove_child(WindowContext *);
+    void show_or_hide_children(bool);
+    bool is_visible();
+    bool is_dead();
+    bool grab_focus();
+    void ungrab_focus();
+    void restack(bool);
+    void request_focus();
     void enter_fullscreen();
     void exit_fullscreen();
-
-    void set_owner(WindowContext*);
-
-    GtkWindow *get_gtk_window();
     void detach_from_java();
+    void increment_events_counter();
+    void decrement_events_counter();
+    size_t get_events_count();
+    ~WindowContext();
+
 protected:
-    void applyShapeMask(void*, uint width, uint height);
+    void applyShapeMask(void *, uint width, uint height);
+
 private:
+    bool im_filter_keypress(GdkEventKey*);
+    void calculate_adjustments();
+    void save_cached_extents();
+    void apply_geometry();
     bool get_frame_extents_property(int *, int *, int *, int *);
-    void request_frame_extents();
     void activate_window();
-    bool update_frame_extents();
-    void set_cached_extents(WindowFrameExtents ex);
-    WindowFrameExtents get_cached_extents();
-    void window_configure(XWindowChanges *, unsigned int);
-    void update_window_constraints();
-    void set_window_resizable(bool);
+    void size_position_notify(bool, bool);
     void update_ontop_tree(bool);
     bool on_top_inherited();
     bool effective_on_top();
-    void ensure_window_size();
-    WindowContextTop(WindowContextTop&);
-    WindowContextTop& operator= (const WindowContextTop&);
+    GdkDevice * get_pointer_device();
+    bool grab_mouse_drag_focus(GdkCursor *cursor, bool owner_events);
+    void ungrab_mouse_drag_focus();
 };
 
-void destroy_and_delete_ctx(WindowContext* ctx);
+void destroy_and_delete_ctx(WindowContext *ctx);
 
 class EventsCounterHelper {
 private:
-    WindowContext* ctx;
+    WindowContext *ctx;
 public:
-    explicit EventsCounterHelper(WindowContext* context) {
+    explicit EventsCounterHelper(WindowContext *context) {
         ctx = context;
         ctx->increment_events_counter();
     }
+
     ~EventsCounterHelper() {
         ctx->decrement_events_counter();
         if (ctx->is_dead() && ctx->get_events_count() == 0) {
             delete ctx;
         }
diff a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window_ime.cpp b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window_ime.cpp
--- a/modules/javafx.graphics/src/main/native-glass/gtk/glass_window_ime.cpp
+++ b/modules/javafx.graphics/src/main/native-glass/gtk/glass_window_ime.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,11 +28,11 @@
 #include "glass_general.h"
 
 #include <cstring>
 #include <cstdlib>
 
-bool WindowContextBase::hasIME() {
+bool WindowContext::hasIME() {
     return xim.enabled;
 }
 
 static XKeyPressedEvent convert_event(GdkEventKey *event) {
     XKeyPressedEvent result;
@@ -49,11 +49,11 @@
     result.same_screen = True;
 
     return result;
 }
 
-bool WindowContextBase::im_filter_keypress(GdkEventKey* event) {
+bool WindowContext::im_filter_keypress(GdkEventKey* event) {
     static size_t buf_len = 12;
     static char *buffer = NULL;
 
     if (buffer == NULL) {
         buffer = (char*)malloc(buf_len * sizeof (char));
@@ -105,11 +105,11 @@
     }
 
     return TRUE;
 }
 
-bool WindowContextBase::filterIME(GdkEvent * event) {
+bool WindowContext::filterIME(GdkEvent * event) {
     if (!hasIME()) {
         return false;
     }
 
     switch (event->type) {
@@ -218,11 +218,11 @@
     XFree(styles);
 
     return result;
 }
 
-void WindowContextBase::enableOrResetIME() {
+void WindowContext::enableOrResetIME() {
     Display *display = gdk_x11_display_get_xdisplay(gdk_window_get_display(gdk_window));
     if (xim.im == NULL || xim.ic == NULL) {
         xim.im = XOpenIM(display, NULL, NULL, NULL);
         if (xim.im == NULL) {
             return;
@@ -266,10 +266,10 @@
     XSetICFocus(xim.ic);
 
     xim.enabled = TRUE;
 }
 
-void WindowContextBase::disableIME() {
+void WindowContext::disableIME() {
     if (xim.ic != NULL) {
         XUnsetICFocus(xim.ic);
     }
 }
