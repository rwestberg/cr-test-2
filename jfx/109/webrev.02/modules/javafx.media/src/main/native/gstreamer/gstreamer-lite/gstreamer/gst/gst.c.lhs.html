<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gst.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gst.c: Initialization and non-pipeline operations
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gst
  25  * @title: GStreamer
  26  * @short_description: Media library supporting arbitrary formats and filter
  27  *                     graphs.
  28  *
  29  * GStreamer is a framework for constructing graphs of various filters
  30  * (termed elements here) that will handle streaming media.  Any discrete
  31  * (packetizable) media type is supported, with provisions for automatically
  32  * determining source type.  Formatting/framing information is provided with
  33  * a powerful negotiation framework.  Plugins are heavily used to provide for
  34  * all elements, allowing one to construct plugins outside of the GST
  35  * library, even released binary-only if license require (please don&#39;t).
  36  * GStreamer covers a wide range of use cases including: playback, recording,
  37  * editing, serving streams, voice over ip and video calls.
  38  *
  39  * The &lt;application&gt;GStreamer&lt;/application&gt; library should be initialized with
  40  * gst_init() before it can be used. You should pass pointers to the main argc
  41  * and argv variables so that GStreamer can process its own command line
  42  * options, as shown in the following example.
  43  *
  44  * ## Initializing the gstreamer library
  45  *
  46  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  47  * int
  48  * main (int argc, char *argv[])
  49  * {
  50  *   // initialize the GStreamer library
  51  *   gst_init (&amp;amp;argc, &amp;amp;argv);
  52  *   ...
  53  * }
  54  * ]|
  55  *
  56  * It&#39;s allowed to pass two %NULL pointers to gst_init() in case you don&#39;t want
  57  * to pass the command line args to GStreamer.
  58  *
  59  * You can also use GOption to initialize your own parameters as shown in
  60  * the next code fragment:
  61  *
  62  * ## Initializing own parameters when initializing gstreamer
  63  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  64  * static gboolean stats = FALSE;
  65  * ...
  66  * int
  67  * main (int argc, char *argv[])
  68  * {
  69  *  GOptionEntry options[] = {
  70  *   {&quot;tags&quot;, &#39;t&#39;, 0, G_OPTION_ARG_NONE, &amp;amp;tags,
  71  *       N_(&quot;Output tags (also known as metadata)&quot;), NULL},
  72  *   {NULL}
  73  *  };
  74  *  ctx = g_option_context_new (&quot;[ADDITIONAL ARGUMENTS]&quot;);
  75  *  g_option_context_add_main_entries (ctx, options, GETTEXT_PACKAGE);
  76  *  g_option_context_add_group (ctx, gst_init_get_option_group ());
  77  *  if (!g_option_context_parse (ctx, &amp;amp;argc, &amp;amp;argv, &amp;amp;err)) {
  78  *    g_print (&quot;Error initializing: &amp;percnt;s\n&quot;, GST_STR_NULL (err-&gt;message));
  79  *    exit (1);
  80  *  }
  81  *  g_option_context_free (ctx);
  82  * ...
  83  * }
  84  * ]|
  85  *
  86  * Use gst_version() to query the library version at runtime or use the
  87  * GST_VERSION_* macros to find the version at compile time. Optionally
  88  * gst_version_string() returns a printable string.
  89  *
  90  * The gst_deinit() call is used to clean up all internal resources used
  91  * by GStreamer. It is mostly used in unit tests to check for leaks.
  92  */
  93 
  94 #include &quot;gst_private.h&quot;
  95 #include &quot;gstconfig.h&quot;
  96 #include &lt;stdlib.h&gt;
  97 #include &lt;stdio.h&gt;
  98 #include &lt;sys/types.h&gt;
  99 #ifdef HAVE_SYS_UTSNAME_H
 100 #include &lt;sys/utsname.h&gt;
 101 #endif
 102 #ifdef HAVE_UNISTD_H
 103 #include &lt;unistd.h&gt;
 104 #endif
 105 #ifdef G_OS_WIN32
 106 #define WIN32_LEAN_AND_MEAN     /* prevents from including too many things */
 107 #include &lt;windows.h&gt;            /* GetStdHandle, windows console */
 108 #endif
 109 #if defined (__APPLE__)
 110 #include &quot;TargetConditionals.h&quot;
 111 #if !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 112 #include &lt;libproc.h&gt;            /* proc_pidpath, PROC_PIDPATHINFO_MAXSIZE */
 113 #endif
 114 #endif
 115 
 116 #if defined(GSTREAMER_LITE)
 117 #include &quot;gstplugins-lite.h&quot;
 118 #endif // GSTREAMER_LITE
 119 
 120 #include &quot;gst-i18n-lib.h&quot;
 121 #include &lt;locale.h&gt;             /* for LC_ALL */
 122 
 123 #include &quot;gst.h&quot;
 124 
<a name="1" id="anc1"></a>






 125 #define GST_CAT_DEFAULT GST_CAT_GST_INIT
 126 
 127 #define MAX_PATH_SPLIT  16
 128 #define GST_PLUGIN_SEPARATOR &quot;,&quot;
 129 
 130 static gboolean gst_initialized = FALSE;
 131 static gboolean gst_deinitialized = FALSE;
 132 
 133 GstClockTime _priv_gst_start_time;
 134 
 135 #ifdef G_OS_WIN32
 136 HMODULE _priv_gst_dll_handle = NULL;
 137 #endif
 138 
 139 #ifndef GST_DISABLE_REGISTRY
 140 GList *_priv_gst_plugin_paths = NULL;   /* for delayed processing in init_post */
 141 
 142 extern gboolean _priv_gst_disable_registry;
 143 extern gboolean _priv_gst_disable_registry_update;
 144 #endif
 145 
 146 gchar *_gst_executable_path = NULL;
 147 
 148 #ifndef GST_DISABLE_GST_DEBUG
 149 const gchar *priv_gst_dump_dot_dir;
 150 #endif
 151 
 152 /* defaults */
 153 
 154 /* set to TRUE when segfaults need to be left as is */
 155 static gboolean _gst_disable_segtrap = FALSE;
 156 
 157 static gboolean init_pre (GOptionContext * context, GOptionGroup * group,
 158     gpointer data, GError ** error);
 159 static gboolean init_post (GOptionContext * context, GOptionGroup * group,
 160     gpointer data, GError ** error);
 161 #ifndef GST_DISABLE_OPTION_PARSING
 162 static gboolean parse_goption_arg (const gchar * s_opt,
 163     const gchar * arg, gpointer data, GError ** err);
 164 #endif
 165 
 166 GSList *_priv_gst_preload_plugins = NULL;
 167 
 168 const gchar g_log_domain_gstreamer[] = &quot;GStreamer&quot;;
 169 
 170 static void
 171 debug_log_handler (const gchar * log_domain,
 172     GLogLevelFlags log_level, const gchar * message, gpointer user_data)
 173 {
 174   g_log_default_handler (log_domain, log_level, message, user_data);
 175   /* FIXME: do we still need this ? fatal errors these days are all
 176    * other than core errors */
 177   /* g_on_error_query (NULL); */
 178 }
 179 
 180 enum
 181 {
 182   ARG_VERSION = 1,
 183   ARG_FATAL_WARNINGS,
 184 #ifndef GST_DISABLE_GST_DEBUG
 185   ARG_DEBUG_LEVEL,
 186   ARG_DEBUG,
 187   ARG_DEBUG_DISABLE,
 188   ARG_DEBUG_NO_COLOR,
 189   ARG_DEBUG_COLOR_MODE,
 190   ARG_DEBUG_HELP,
 191 #endif
 192   ARG_PLUGIN_SPEW,
 193   ARG_PLUGIN_PATH,
 194   ARG_PLUGIN_LOAD,
 195   ARG_SEGTRAP_DISABLE,
 196   ARG_REGISTRY_UPDATE_DISABLE,
 197   ARG_REGISTRY_FORK_DISABLE
 198 };
 199 
 200 /* debug-spec ::= category-spec [, category-spec]*
 201  * category-spec ::= category:val | val
 202  * category ::= [^:]+
 203  * val ::= [0-5]
 204  */
 205 
 206 #ifndef GSTREAMER_LITE
 207 #ifdef G_OS_WIN32
 208 /* Note: DllMain is only called when DLLs are loaded or unloaded, so this will
 209  * never be called if libgstreamer-1.0 is linked statically. Do not add any code
 210  * here to, say, initialize variables or set things up since that will only
 211  * happen for dynamically-built GStreamer.
 212  *
 213  * Also, ideally this should not be defined when GStreamer is built statically.
 214  * i.e., it should be conditional on #ifdef DLL_EXPORT. It will be ignored, but
 215  * if other libraries make the same mistake of defining it when building
 216  * statically, there will be a symbol collision during linking. Fixing this
 217  * requires one to build two object files: one for static linking and another
 218  * for dynamic linking. */
 219 BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
 220 BOOL WINAPI
 221 DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 222 {
 223   if (fdwReason == DLL_PROCESS_ATTACH)
 224     _priv_gst_dll_handle = (HMODULE) hinstDLL;
 225   return TRUE;
 226 }
 227 
 228 #endif
 229 #endif // GSTREAMER_LITE
 230 
 231 /**
 232  * gst_init_get_option_group: (skip)
 233  *
 234  * Returns a #GOptionGroup with GStreamer&#39;s argument specifications. The
 235  * group is set up to use standard GOption callbacks, so when using this
 236  * group in combination with GOption parsing methods, all argument parsing
 237  * and initialization is automated.
 238  *
 239  * This function is useful if you want to integrate GStreamer with other
 240  * libraries that use GOption (see g_option_context_add_group() ).
 241  *
 242  * If you use this function, you should make sure you initialise the GLib
 243  * threading system as one of the very first things in your program
 244  * (see the example at the beginning of this section).
 245  *
 246  * Returns: (transfer full) (nullable): a pointer to GStreamer&#39;s option group.
 247  */
 248 
 249 GOptionGroup *
 250 gst_init_get_option_group (void)
 251 {
 252 #ifndef GST_DISABLE_OPTION_PARSING
 253   GOptionGroup *group;
 254   static const GOptionEntry gst_args[] = {
 255     {&quot;gst-version&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 256         (gpointer) parse_goption_arg, N_(&quot;Print the GStreamer version&quot;), NULL},
 257     {&quot;gst-fatal-warnings&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 258         (gpointer) parse_goption_arg, N_(&quot;Make all warnings fatal&quot;), NULL},
 259 #ifndef GST_DISABLE_GST_DEBUG
 260     {&quot;gst-debug-help&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 261           (gpointer) parse_goption_arg,
 262           N_(&quot;Print available debug categories and exit&quot;),
 263         NULL},
 264     {&quot;gst-debug-level&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 265           (gpointer) parse_goption_arg,
 266           N_(&quot;Default debug level from 1 (only error) to 9 (anything) or &quot;
 267               &quot;0 for no output&quot;),
 268         N_(&quot;LEVEL&quot;)},
 269     {&quot;gst-debug&quot;, 0, 0, G_OPTION_ARG_CALLBACK, (gpointer) parse_goption_arg,
 270           N_(&quot;Comma-separated list of category_name:level pairs to set &quot;
 271               &quot;specific levels for the individual categories. Example: &quot;
 272               &quot;GST_AUTOPLUG:5,GST_ELEMENT_*:3&quot;),
 273         N_(&quot;LIST&quot;)},
 274     {&quot;gst-debug-no-color&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 275           (gpointer) parse_goption_arg, N_(&quot;Disable colored debugging output&quot;),
 276         NULL},
 277     {&quot;gst-debug-color-mode&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 278           (gpointer) parse_goption_arg,
 279           N_(&quot;Changes coloring mode of the debug log. &quot;
 280               &quot;Possible modes: off, on, disable, auto, unix&quot;),
 281         NULL},
 282     {&quot;gst-debug-disable&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 283         (gpointer) parse_goption_arg, N_(&quot;Disable debugging&quot;), NULL},
 284 #endif
 285     {&quot;gst-plugin-spew&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 286           (gpointer) parse_goption_arg,
 287           N_(&quot;Enable verbose plugin loading diagnostics&quot;),
 288         NULL},
 289     {&quot;gst-plugin-path&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 290           (gpointer) parse_goption_arg,
 291         N_(&quot;Colon-separated paths containing plugins&quot;), N_(&quot;PATHS&quot;)},
 292     {&quot;gst-plugin-load&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 293           (gpointer) parse_goption_arg,
 294           N_(&quot;Comma-separated list of plugins to preload in addition to the &quot;
 295               &quot;list stored in environment variable GST_PLUGIN_PATH&quot;),
 296         N_(&quot;PLUGINS&quot;)},
 297     {&quot;gst-disable-segtrap&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 298           (gpointer) parse_goption_arg,
 299           N_(&quot;Disable trapping of segmentation faults during plugin loading&quot;),
 300         NULL},
 301     {&quot;gst-disable-registry-update&quot;, 0, G_OPTION_FLAG_NO_ARG,
 302           G_OPTION_ARG_CALLBACK,
 303           (gpointer) parse_goption_arg,
 304           N_(&quot;Disable updating the registry&quot;),
 305         NULL},
 306     {&quot;gst-disable-registry-fork&quot;, 0, G_OPTION_FLAG_NO_ARG,
 307           G_OPTION_ARG_CALLBACK,
 308           (gpointer) parse_goption_arg,
 309           N_(&quot;Disable spawning a helper process while scanning the registry&quot;),
 310         NULL},
 311     {NULL}
 312   };
 313 
 314   group = g_option_group_new (&quot;gst&quot;, _(&quot;GStreamer Options&quot;),
 315       _(&quot;Show GStreamer Options&quot;), NULL, NULL);
 316   g_option_group_set_parse_hooks (group, (GOptionParseFunc) init_pre,
 317       (GOptionParseFunc) init_post);
 318 
 319   g_option_group_add_entries (group, gst_args);
 320   g_option_group_set_translation_domain (group, GETTEXT_PACKAGE);
 321 
 322   return group;
 323 #else
 324   return NULL;
 325 #endif
 326 }
 327 
 328 #if defined(__linux__)
 329 static void
 330 find_executable_path (void)
 331 {
 332   GError *error = NULL;
 333 
 334   if (_gst_executable_path)
 335     return;
 336 
 337   _gst_executable_path = g_file_read_link (&quot;/proc/self/exe&quot;, &amp;error);
 338   if (error)
 339     g_error_free (error);
 340 }
 341 #elif defined(G_OS_WIN32)
 342 static void
 343 find_executable_path (void)
 344 {
 345   char buffer[MAX_PATH];
 346 
 347   if (!GetModuleFileName (NULL, buffer, MAX_PATH))
 348     return;
 349 
 350   _gst_executable_path = g_strdup (buffer);
 351 }
 352 #elif defined(__APPLE__) &amp;&amp; !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 353 static void
 354 find_executable_path (void)
 355 {
 356   int ret;
 357   pid_t pid;
 358   char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
 359 
 360   pid = getpid ();
 361   ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));
 362   if (ret &gt; 0)
 363     _gst_executable_path = g_strdup (pathbuf);
 364 }
 365 #else
 366 static void
 367 find_executable_path (void)
 368 {
 369   GST_FIXME (&quot;Couldn&#39;t look up executable path, add support for this platform&quot;);
 370 }
 371 #endif
 372 
 373 /**
 374  * gst_get_main_executable_path:
 375  *
 376  * This helper is mostly helpful for plugins that need to
 377  * inspect the folder of the main executable to determine
 378  * their set of features.
 379  *
 380  * When a plugin is initialized from the gst-plugin-scanner
 381  * external process, the returned path will be the same as from the
 382  * parent process.
 383  *
 384  * Returns: (transfer none) (nullable): The path of the executable that
 385  *   initialized GStreamer, or %NULL if it could not be determined.
 386  *
 387  * Since: 1.14
 388  */
 389 const gchar *
 390 gst_get_main_executable_path (void)
 391 {
 392   return _gst_executable_path;
 393 }
 394 
 395 /**
 396  * gst_init_check:
 397  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 398  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 399  * @err: pointer to a #GError to which a message will be posted on error
 400  *
 401  * Initializes the GStreamer library, setting up internal path lists,
 402  * registering built-in elements, and loading standard plugins.
 403  *
 404  * This function will return %FALSE if GStreamer could not be initialized
 405  * for some reason.  If you want your program to fail fatally,
 406  * use gst_init() instead.
 407  *
 408  * Returns: %TRUE if GStreamer could be initialized.
 409  */
 410 gboolean
 411 gst_init_check (int *argc, char **argv[], GError ** err)
 412 {
 413   static GMutex init_lock;
 414 #ifndef GST_DISABLE_OPTION_PARSING
 415   GOptionGroup *group;
 416   GOptionContext *ctx;
 417 #endif
 418   gboolean res;
 419 
 420   g_mutex_lock (&amp;init_lock);
 421 
 422 #ifdef GSTREAMER_LITE
 423 #ifdef ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 424   #include &lt;crtdbg.h&gt;
 425 
 426   _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
 427   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
 428 #endif // ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 429 #endif // GSTREAMER_LITE
 430 
 431   if (gst_initialized) {
 432     GST_DEBUG (&quot;already initialized gst&quot;);
 433     g_mutex_unlock (&amp;init_lock);
 434     return TRUE;
 435   }
 436 #ifndef GST_DISABLE_OPTION_PARSING
 437   ctx = g_option_context_new (&quot;- GStreamer initialization&quot;);
 438   g_option_context_set_ignore_unknown_options (ctx, TRUE);
 439   g_option_context_set_help_enabled (ctx, FALSE);
 440   group = gst_init_get_option_group ();
 441   g_option_context_add_group (ctx, group);
 442   res = g_option_context_parse (ctx, argc, argv, err);
 443   g_option_context_free (ctx);
 444 #else
 445   init_pre (NULL, NULL, NULL, NULL);
 446   init_post (NULL, NULL, NULL, NULL);
 447   res = TRUE;
 448 #endif
 449 
 450   gst_initialized = res;
 451 
 452   g_mutex_unlock (&amp;init_lock);
 453 
 454   return res;
 455 }
 456 
 457 /**
 458  * gst_init:
 459  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 460  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 461  *
 462  * Initializes the GStreamer library, setting up internal path lists,
 463  * registering built-in elements, and loading standard plugins.
 464  *
 465  * Unless the plugin registry is disabled at compile time, the registry will be
 466  * loaded. By default this will also check if the registry cache needs to be
 467  * updated and rescan all plugins if needed. See gst_update_registry() for
 468  * details and section
 469  * &lt;link linkend=&quot;gst-running&quot;&gt;Running GStreamer Applications&lt;/link&gt;
 470  * for how to disable automatic registry updates.
 471  *
 472  * &gt; This function will terminate your program if it was unable to initialize
 473  * &gt; GStreamer for some reason.  If you want your program to fall back,
 474  * &gt; use gst_init_check() instead.
 475  *
 476  * WARNING: This function does not work in the same way as corresponding
 477  * functions in other glib-style libraries, such as gtk_init\(\). In
 478  * particular, unknown command line options cause this function to
 479  * abort program execution.
 480  */
 481 void
 482 gst_init (int *argc, char **argv[])
 483 {
 484   GError *err = NULL;
 485 
 486   if (!gst_init_check (argc, argv, &amp;err)) {
 487     g_print (&quot;Could not initialize GStreamer: %s\n&quot;,
 488         err ? err-&gt;message : &quot;unknown error occurred&quot;);
 489     if (err) {
 490       g_error_free (err);
 491     }
 492     exit (1);
 493   }
 494 }
 495 
 496 /**
 497  * gst_is_initialized:
 498  *
 499  * Use this function to check if GStreamer has been initialized with gst_init()
 500  * or gst_init_check().
 501  *
 502  * Returns: %TRUE if initialization has been done, %FALSE otherwise.
 503  */
 504 gboolean
 505 gst_is_initialized (void)
 506 {
 507   return gst_initialized;
 508 }
 509 
 510 #ifndef GST_DISABLE_OPTION_PARSING
 511 #  ifndef GST_DISABLE_REGISTRY
 512 static void
 513 add_path_func (gpointer data, gpointer user_data)
 514 {
 515   GST_INFO (&quot;Adding plugin path: \&quot;%s\&quot;, will scan later&quot;, (gchar *) data);
 516   _priv_gst_plugin_paths =
 517       g_list_append (_priv_gst_plugin_paths, g_strdup (data));
 518 }
 519 #  endif
 520 #endif
 521 
 522 #ifndef GST_DISABLE_OPTION_PARSING
 523 static void
 524 prepare_for_load_plugin_func (gpointer data, gpointer user_data)
 525 {
 526   _priv_gst_preload_plugins =
 527       g_slist_prepend (_priv_gst_preload_plugins, g_strdup (data));
 528 }
 529 #endif
 530 
 531 #ifndef GST_DISABLE_OPTION_PARSING
 532 static void
 533 split_and_iterate (const gchar * stringlist, const gchar * separator,
 534     GFunc iterator, gpointer user_data)
 535 {
 536   gchar **strings;
 537   gint j = 0;
 538   gchar *lastlist = g_strdup (stringlist);
 539 
 540   while (lastlist) {
 541     strings = g_strsplit (lastlist, separator, MAX_PATH_SPLIT);
 542     g_free (lastlist);
 543     lastlist = NULL;
 544 
 545     while (strings[j]) {
 546       iterator (strings[j], user_data);
 547       if (++j == MAX_PATH_SPLIT) {
 548         lastlist = g_strdup (strings[j]);
 549         j = 0;
 550         break;
 551       }
 552     }
 553     g_strfreev (strings);
 554   }
 555 }
 556 #endif
 557 
 558 /* we have no fail cases yet, but maybe in the future */
 559 static gboolean
 560 init_pre (GOptionContext * context, GOptionGroup * group, gpointer data,
 561     GError ** error)
 562 {
 563   gchar *libdir;
 564   if (gst_initialized) {
 565     GST_DEBUG (&quot;already initialized&quot;);
 566     return TRUE;
 567   }
 568 
 569 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
 570   // We still need to call it due too bug in GLib
 571   g_type_init ();
 572 #endif // GSTREAMER_LITE
 573 
 574   find_executable_path ();
 575 
 576   _priv_gst_start_time = gst_util_get_timestamp ();
 577 
 578 #ifndef GST_DISABLE_GST_DEBUG
 579   _priv_gst_debug_init ();
 580   priv_gst_dump_dot_dir = g_getenv (&quot;GST_DEBUG_DUMP_DOT_DIR&quot;);
 581 #endif
 582 
 583 #ifdef ENABLE_NLS
 584   bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
 585   bind_textdomain_codeset (GETTEXT_PACKAGE, &quot;UTF-8&quot;);
 586 #endif /* ENABLE_NLS */
 587 
 588 #ifndef GSTREAMER_LITE
 589   /* This is the earliest we can make stuff show up in the logs.
 590    * So give some useful info about GStreamer here */
 591 #ifdef G_OS_WIN32
 592   {
 593     gchar *basedir =
 594         g_win32_get_package_installation_directory_of_module
 595         (_priv_gst_dll_handle);
 596 
 597     libdir = g_build_filename (basedir,
 598 #ifdef _DEBUG
 599         &quot;debug&quot;
 600 #endif
 601         &quot;lib&quot;, NULL);
 602     g_free (basedir);
 603   }
 604 #else
 605   libdir = g_strdup (LIBDIR);
 606 #endif
 607   GST_INFO (&quot;Initializing GStreamer Core Library version %s&quot;, VERSION);
 608   GST_INFO (&quot;Using library installed in %s&quot;, libdir);
 609   g_free (libdir);
 610 #endif // GSTREAMER_LITE
 611 
 612 #ifndef GST_DISABLE_REGISTRY
 613   {
 614     const gchar *disable_registry;
 615     if ((disable_registry = g_getenv (&quot;GST_REGISTRY_DISABLE&quot;))) {
 616       _priv_gst_disable_registry = (strcmp (disable_registry, &quot;yes&quot;) == 0);
 617     }
 618   }
 619 #endif
 620 
 621   /* Print some basic system details if possible (OS/architecture) */
 622 #ifdef HAVE_SYS_UTSNAME_H
 623   {
 624     struct utsname sys_details;
 625 
 626     if (uname (&amp;sys_details) == 0) {
 627       GST_INFO (&quot;%s %s %s %s %s&quot;, sys_details.sysname,
 628           sys_details.nodename, sys_details.release, sys_details.version,
 629           sys_details.machine);
 630     }
 631   }
 632 #endif
 633 
 634 #ifndef G_ATOMIC_LOCK_FREE
 635   GST_CAT_WARNING (GST_CAT_PERFORMANCE, &quot;GLib atomic operations are NOT &quot;
 636       &quot;implemented using real hardware atomic operations!&quot;);
 637 #endif
 638 
 639   return TRUE;
 640 }
 641 
 642 static gboolean
 643 gst_register_core_elements (GstPlugin * plugin)
 644 {
 645   /* register some standard builtin types */
 646   if (!gst_element_register (plugin, &quot;bin&quot;, GST_RANK_PRIMARY,
 647           GST_TYPE_BIN) ||
 648       !gst_element_register (plugin, &quot;pipeline&quot;, GST_RANK_PRIMARY,
 649           GST_TYPE_PIPELINE)
 650       )
 651     g_assert_not_reached ();
 652 
 653   return TRUE;
 654 }
 655 
 656 /*
 657  * this bit handles:
 658  * - initialization of threads if we use them
 659  * - log handler
 660  * - initial output
 661  * - initializes gst_format
 662  * - registers a bunch of types for gst_objects
 663  *
 664  * - we don&#39;t have cases yet where this fails, but in the future
 665  *   we might and then it&#39;s nice to be able to return that
 666  */
 667 static gboolean
 668 init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
 669     GError ** error)
 670 {
 671   GLogLevelFlags llf;
 672 
 673   if (gst_initialized) {
 674     GST_DEBUG (&quot;already initialized&quot;);
 675     return TRUE;
 676   }
 677 
 678   llf = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL;
 679   g_log_set_handler (g_log_domain_gstreamer, llf, debug_log_handler, NULL);
 680 
 681   _priv_gst_mini_object_initialize ();
 682   _priv_gst_quarks_initialize ();
 683   _priv_gst_allocator_initialize ();
 684   _priv_gst_memory_initialize ();
 685   _priv_gst_format_initialize ();
 686   _priv_gst_query_initialize ();
 687   _priv_gst_structure_initialize ();
 688   _priv_gst_caps_initialize ();
 689   _priv_gst_caps_features_initialize ();
 690   _priv_gst_meta_initialize ();
 691   _priv_gst_message_initialize ();
 692 
 693   g_type_class_ref (gst_object_get_type ());
 694   g_type_class_ref (gst_pad_get_type ());
 695   g_type_class_ref (gst_element_factory_get_type ());
 696   g_type_class_ref (gst_element_get_type ());
 697   g_type_class_ref (gst_tracer_factory_get_type ());
 698   g_type_class_ref (gst_type_find_factory_get_type ());
 699   g_type_class_ref (gst_bin_get_type ());
 700   g_type_class_ref (gst_bus_get_type ());
 701   g_type_class_ref (gst_task_get_type ());
 702   g_type_class_ref (gst_clock_get_type ());
 703   g_type_class_ref (gst_debug_color_mode_get_type ());
 704 
 705   gst_uri_handler_get_type ();
 706 
 707   g_type_class_ref (gst_object_flags_get_type ());
 708   g_type_class_ref (gst_bin_flags_get_type ());
 709   g_type_class_ref (gst_buffer_flags_get_type ());
 710   g_type_class_ref (gst_buffer_copy_flags_get_type ());
 711   g_type_class_ref (gst_bus_flags_get_type ());
 712   g_type_class_ref (gst_bus_sync_reply_get_type ());
 713   g_type_class_ref (gst_caps_flags_get_type ());
 714   g_type_class_ref (gst_clock_return_get_type ());
 715   g_type_class_ref (gst_clock_entry_type_get_type ());
 716   g_type_class_ref (gst_clock_flags_get_type ());
 717   g_type_class_ref (gst_clock_type_get_type ());
 718   g_type_class_ref (gst_debug_graph_details_get_type ());
 719   g_type_class_ref (gst_state_get_type ());
 720   g_type_class_ref (gst_state_change_return_get_type ());
 721   g_type_class_ref (gst_state_change_get_type ());
 722   g_type_class_ref (gst_element_flags_get_type ());
 723   g_type_class_ref (gst_tracer_value_scope_get_type ());
 724   g_type_class_ref (gst_tracer_value_flags_get_type ());
 725   g_type_class_ref (gst_core_error_get_type ());
 726   g_type_class_ref (gst_library_error_get_type ());
 727   g_type_class_ref (gst_resource_error_get_type ());
 728   g_type_class_ref (gst_stream_error_get_type ());
 729   g_type_class_ref (gst_event_type_flags_get_type ());
 730   g_type_class_ref (gst_event_type_get_type ());
 731   g_type_class_ref (gst_seek_type_get_type ());
 732   g_type_class_ref (gst_seek_flags_get_type ());
 733   g_type_class_ref (gst_qos_type_get_type ());
 734   g_type_class_ref (gst_format_get_type ());
 735   g_type_class_ref (gst_debug_level_get_type ());
 736   g_type_class_ref (gst_debug_color_flags_get_type ());
 737   g_type_class_ref (gst_iterator_result_get_type ());
 738   g_type_class_ref (gst_iterator_item_get_type ());
 739   g_type_class_ref (gst_message_type_get_type ());
 740   g_type_class_ref (gst_mini_object_flags_get_type ());
 741   g_type_class_ref (gst_pad_link_return_get_type ());
 742   g_type_class_ref (gst_pad_link_check_get_type ());
 743   g_type_class_ref (gst_flow_return_get_type ());
 744   g_type_class_ref (gst_pad_mode_get_type ());
 745   g_type_class_ref (gst_pad_direction_get_type ());
 746   g_type_class_ref (gst_pad_flags_get_type ());
 747   g_type_class_ref (gst_pad_presence_get_type ());
 748   g_type_class_ref (gst_pad_template_flags_get_type ());
 749   g_type_class_ref (gst_pipeline_flags_get_type ());
 750   g_type_class_ref (gst_plugin_error_get_type ());
 751   g_type_class_ref (gst_plugin_flags_get_type ());
 752   g_type_class_ref (gst_plugin_dependency_flags_get_type ());
 753   g_type_class_ref (gst_rank_get_type ());
 754   g_type_class_ref (gst_query_type_flags_get_type ());
 755   g_type_class_ref (gst_query_type_get_type ());
 756   g_type_class_ref (gst_buffering_mode_get_type ());
 757   g_type_class_ref (gst_stream_status_type_get_type ());
 758   g_type_class_ref (gst_structure_change_type_get_type ());
 759   g_type_class_ref (gst_tag_merge_mode_get_type ());
 760   g_type_class_ref (gst_tag_flag_get_type ());
 761   g_type_class_ref (gst_tag_scope_get_type ());
 762   g_type_class_ref (gst_task_pool_get_type ());
 763   g_type_class_ref (gst_task_state_get_type ());
 764   g_type_class_ref (gst_toc_entry_type_get_type ());
 765   g_type_class_ref (gst_type_find_probability_get_type ());
 766   g_type_class_ref (gst_uri_error_get_type ());
 767   g_type_class_ref (gst_uri_type_get_type ());
 768   g_type_class_ref (gst_parse_error_get_type ());
 769   g_type_class_ref (gst_parse_flags_get_type ());
 770   g_type_class_ref (gst_search_mode_get_type ());
 771   g_type_class_ref (gst_progress_type_get_type ());
 772   g_type_class_ref (gst_buffer_pool_acquire_flags_get_type ());
 773   g_type_class_ref (gst_memory_flags_get_type ());
 774   g_type_class_ref (gst_map_flags_get_type ());
 775   g_type_class_ref (gst_caps_intersect_mode_get_type ());
 776   g_type_class_ref (gst_pad_probe_type_get_type ());
 777   g_type_class_ref (gst_pad_probe_return_get_type ());
 778   g_type_class_ref (gst_segment_flags_get_type ());
 779   g_type_class_ref (gst_scheduling_flags_get_type ());
 780   g_type_class_ref (gst_meta_flags_get_type ());
 781   g_type_class_ref (gst_toc_entry_type_get_type ());
 782   g_type_class_ref (gst_toc_scope_get_type ());
 783   g_type_class_ref (gst_toc_loop_type_get_type ());
 784   g_type_class_ref (gst_control_binding_get_type ());
 785   g_type_class_ref (gst_control_source_get_type ());
 786   g_type_class_ref (gst_lock_flags_get_type ());
 787   g_type_class_ref (gst_allocator_flags_get_type ());
 788   g_type_class_ref (gst_stream_flags_get_type ());
 789   g_type_class_ref (gst_stream_type_get_type ());
 790   g_type_class_ref (gst_stack_trace_flags_get_type ());
 791 #ifndef GSTREAMER_LITE
 792   g_type_class_ref (gst_promise_result_get_type ());
 793 #endif // GSTREAMER_LITE
 794 
 795   _priv_gst_event_initialize ();
 796   _priv_gst_buffer_initialize ();
 797   _priv_gst_buffer_list_initialize ();
 798   _priv_gst_sample_initialize ();
 799   _priv_gst_context_initialize ();
 800   _priv_gst_date_time_initialize ();
 801   _priv_gst_value_initialize ();
 802   _priv_gst_tag_initialize ();
 803   _priv_gst_toc_initialize ();
 804 
 805   g_type_class_ref (gst_param_spec_fraction_get_type ());
 806   gst_parse_context_get_type ();
 807 
 808   _priv_gst_plugin_initialize ();
 809 
 810   /* register core plugins */
 811   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 812       &quot;staticelements&quot;, &quot;core elements linked into the GStreamer library&quot;,
 813       gst_register_core_elements, VERSION, GST_LICENSE, PACKAGE,
 814       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 815 
 816 #if defined(GSTREAMER_LITE)
 817   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 818       &quot;gstplugins-lite&quot;, &quot;gstplugins-lite&quot;,
 819       lite_plugins_init, VERSION, GST_LICENSE, PACKAGE,
 820       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
<a name="2" id="anc2"></a>









 821 #endif // GSTREAMER_LITE
 822 
 823   /*
 824    * Any errors happening below this point are non-fatal, we therefore mark
 825    * gstreamer as being initialized, since it is the case from a plugin point of
 826    * view.
 827    *
 828    * If anything fails, it will be put back to %FALSE in gst_init_check().
 829    * This allows some special plugins that would call gst_init() to not cause a
 830    * looping effect (i.e. initializing GStreamer twice).
 831    */
 832   gst_initialized = TRUE;
 833 
 834   if (!gst_update_registry ())
 835     return FALSE;
 836 
 837   GST_INFO (&quot;GLib runtime version: %d.%d.%d&quot;, glib_major_version,
 838       glib_minor_version, glib_micro_version);
 839   GST_INFO (&quot;GLib headers version: %d.%d.%d&quot;, GLIB_MAJOR_VERSION,
 840       GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);
 841   GST_INFO (&quot;initialized GStreamer successfully&quot;);
 842 
 843 #ifndef GST_DISABLE_GST_DEBUG
 844   _priv_gst_tracing_init ();
 845 #endif
 846 
 847   return TRUE;
 848 }
 849 
 850 #ifndef GST_DISABLE_OPTION_PARSING
 851 #  ifndef GST_DISABLE_GST_DEBUG
 852 static gboolean
 853 select_all (GstPlugin * plugin, gpointer user_data)
 854 {
 855   return TRUE;
 856 }
 857 
 858 static gint
 859 sort_by_category_name (gconstpointer a, gconstpointer b)
 860 {
 861   return strcmp (gst_debug_category_get_name ((GstDebugCategory *) a),
 862       gst_debug_category_get_name ((GstDebugCategory *) b));
 863 }
 864 
 865 static void
 866 gst_debug_help (void)
 867 {
 868   GSList *list, *walk;
 869   GList *list2, *g;
 870 
 871   /* Need to ensure the registry is loaded to get debug categories */
 872   if (!init_post (NULL, NULL, NULL, NULL))
 873     exit (1);
 874 
 875   list2 = gst_registry_plugin_filter (gst_registry_get (),
 876       select_all, FALSE, NULL);
 877 
 878   /* FIXME this is gross.  why don&#39;t debug have categories PluginFeatures? */
 879   for (g = list2; g; g = g_list_next (g)) {
 880     GstPlugin *plugin = GST_PLUGIN_CAST (g-&gt;data);
 881     GList *features, *orig_features;
 882 
 883     if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED))
 884       continue;
 885 
 886     gst_plugin_load (plugin);
 887     /* Now create one of each feature so the class_init functions
 888      * are called, as that&#39;s where most debug categories are
 889      * registered. FIXME: If debug categories were a plugin feature,
 890      * this would be unneeded */
 891     orig_features = features =
 892         gst_registry_get_feature_list_by_plugin (gst_registry_get (),
 893         gst_plugin_get_name (plugin));
 894     while (features) {
 895       GstPluginFeature *feature;
 896 
 897       if (G_UNLIKELY (features-&gt;data == NULL))
 898         goto next;
 899 
 900       feature = GST_PLUGIN_FEATURE (features-&gt;data);
 901       if (GST_IS_ELEMENT_FACTORY (feature)) {
 902         GstElementFactory *factory;
 903         GstElement *e;
 904 
 905         factory = GST_ELEMENT_FACTORY (feature);
 906         e = gst_element_factory_create (factory, NULL);
 907         if (e)
 908           gst_object_unref (e);
 909       }
 910 
 911     next:
 912       features = g_list_next (features);
 913     }
 914 
 915     gst_plugin_feature_list_free (orig_features);
 916   }
 917   g_list_free (list2);
 918 
 919   list = gst_debug_get_all_categories ();
 920   walk = list = g_slist_sort (list, sort_by_category_name);
 921 
 922   g_print (&quot;\n&quot;);
 923   g_print (&quot;name                  level    description\n&quot;);
 924   g_print (&quot;---------------------+--------+--------------------------------\n&quot;);
 925 
 926   while (walk) {
 927     gboolean on_unix;
 928     GstDebugCategory *cat = (GstDebugCategory *) walk-&gt;data;
 929     GstDebugColorMode coloring = gst_debug_get_color_mode ();
 930 #ifdef G_OS_UNIX
 931     on_unix = TRUE;
 932 #else
 933     on_unix = FALSE;
 934 #endif
 935 
 936     if (GST_DEBUG_COLOR_MODE_UNIX == coloring
 937         || (on_unix &amp;&amp; GST_DEBUG_COLOR_MODE_ON == coloring)) {
 938       gchar *color = gst_debug_construct_term_color (cat-&gt;color);
 939 
 940       g_print (&quot;%s%-20s\033[00m  %1d %s  %s%s\033[00m\n&quot;,
 941           color,
 942           gst_debug_category_get_name (cat),
 943           gst_debug_category_get_threshold (cat),
 944           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 945           color, gst_debug_category_get_description (cat));
 946       g_free (color);
 947     } else if (GST_DEBUG_COLOR_MODE_ON == coloring &amp;&amp; !on_unix) {
 948 #ifdef G_OS_WIN32
 949       gint color = gst_debug_construct_win_color (cat-&gt;color);
 950       const gint clear = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
 951 
 952       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 953       g_print (&quot;%-20s&quot;, gst_debug_category_get_name (cat));
 954       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 955       g_print (&quot; %1d %s &quot;, gst_debug_category_get_threshold (cat),
 956           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)));
 957       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 958       g_print (&quot;%s&quot;, gst_debug_category_get_description (cat));
 959       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 960       g_print (&quot;\n&quot;);
 961 #endif /* G_OS_WIN32 */
 962     } else {
 963       g_print (&quot;%-20s  %1d %s  %s\n&quot;, gst_debug_category_get_name (cat),
 964           gst_debug_category_get_threshold (cat),
 965           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 966           gst_debug_category_get_description (cat));
 967     }
 968     walk = g_slist_next (walk);
 969   }
 970   g_slist_free (list);
 971   g_print (&quot;\n&quot;);
 972 }
 973 #  endif /* GST_DISABLE_OPTION_PARSING */
 974 #endif /* GST_DISABLE_GST_DEBUG */
 975 
 976 #ifndef GST_DISABLE_OPTION_PARSING
 977 static gboolean
 978 parse_one_option (gint opt, const gchar * arg, GError ** err)
 979 {
 980   switch (opt) {
 981     case ARG_VERSION:
 982       g_print (&quot;GStreamer Core Library version %s\n&quot;, PACKAGE_VERSION);
 983       exit (0);
 984     case ARG_FATAL_WARNINGS:{
 985       GLogLevelFlags fatal_mask;
 986 
 987       fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
 988       fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
 989       g_log_set_always_fatal (fatal_mask);
 990       break;
 991     }
 992 #ifndef GST_DISABLE_GST_DEBUG
 993     case ARG_DEBUG_LEVEL:{
 994       GstDebugLevel tmp = GST_LEVEL_NONE;
 995 
 996       tmp = (GstDebugLevel) strtol (arg, NULL, 0);
 997       if (((guint) tmp) &lt; GST_LEVEL_COUNT) {
 998         gst_debug_set_default_threshold (tmp);
 999       }
1000       break;
1001     }
1002     case ARG_DEBUG:
1003       gst_debug_set_threshold_from_string (arg, FALSE);
1004       break;
1005     case ARG_DEBUG_NO_COLOR:
1006       gst_debug_set_colored (FALSE);
1007       break;
1008     case ARG_DEBUG_COLOR_MODE:
1009       gst_debug_set_color_mode_from_string (arg);
1010       break;
1011     case ARG_DEBUG_DISABLE:
1012       gst_debug_set_active (FALSE);
1013       break;
1014     case ARG_DEBUG_HELP:
1015       gst_debug_help ();
1016       exit (0);
1017 #endif
1018     case ARG_PLUGIN_SPEW:
1019       break;
1020     case ARG_PLUGIN_PATH:
1021 #ifndef GST_DISABLE_REGISTRY
1022       if (!_priv_gst_disable_registry)
1023         split_and_iterate (arg, G_SEARCHPATH_SEPARATOR_S, add_path_func, NULL);
1024 #endif /* GST_DISABLE_REGISTRY */
1025       break;
1026     case ARG_PLUGIN_LOAD:
1027       split_and_iterate (arg, &quot;,&quot;, prepare_for_load_plugin_func, NULL);
1028       break;
1029     case ARG_SEGTRAP_DISABLE:
1030       _gst_disable_segtrap = TRUE;
1031       break;
1032     case ARG_REGISTRY_UPDATE_DISABLE:
1033 #ifndef GST_DISABLE_REGISTRY
1034       if (!_priv_gst_disable_registry)
1035         _priv_gst_disable_registry_update = TRUE;
1036 #endif
1037       break;
1038     case ARG_REGISTRY_FORK_DISABLE:
1039       gst_registry_fork_set_enabled (FALSE);
1040       break;
1041     default:
1042       g_set_error (err, G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
1043           _(&quot;Unknown option&quot;));
1044       return FALSE;
1045   }
1046 
1047   return TRUE;
1048 }
1049 
1050 static gboolean
1051 parse_goption_arg (const gchar * opt,
1052     const gchar * arg, gpointer data, GError ** err)
1053 {
1054   static const struct
1055   {
1056     const gchar *opt;
1057     int val;
1058   } options[] = {
1059     {
1060     &quot;--gst-version&quot;, ARG_VERSION}, {
1061     &quot;--gst-fatal-warnings&quot;, ARG_FATAL_WARNINGS},
1062 #ifndef GST_DISABLE_GST_DEBUG
1063     {
1064     &quot;--gst-debug-level&quot;, ARG_DEBUG_LEVEL}, {
1065     &quot;--gst-debug&quot;, ARG_DEBUG}, {
1066     &quot;--gst-debug-disable&quot;, ARG_DEBUG_DISABLE}, {
1067     &quot;--gst-debug-no-color&quot;, ARG_DEBUG_NO_COLOR}, {
1068     &quot;--gst-debug-color-mode&quot;, ARG_DEBUG_COLOR_MODE}, {
1069     &quot;--gst-debug-help&quot;, ARG_DEBUG_HELP},
1070 #endif
1071     {
1072     &quot;--gst-plugin-spew&quot;, ARG_PLUGIN_SPEW}, {
1073     &quot;--gst-plugin-path&quot;, ARG_PLUGIN_PATH}, {
1074     &quot;--gst-plugin-load&quot;, ARG_PLUGIN_LOAD}, {
1075     &quot;--gst-disable-segtrap&quot;, ARG_SEGTRAP_DISABLE}, {
1076     &quot;--gst-disable-registry-update&quot;, ARG_REGISTRY_UPDATE_DISABLE}, {
1077     &quot;--gst-disable-registry-fork&quot;, ARG_REGISTRY_FORK_DISABLE}, {
1078     NULL}
1079   };
1080   gint val = 0, n;
1081 
1082   for (n = 0; options[n].opt; n++) {
1083     if (!strcmp (opt, options[n].opt)) {
1084       val = options[n].val;
1085       break;
1086     }
1087   }
1088 
1089   return parse_one_option (val, arg, err);
1090 }
1091 #endif
1092 
1093 /**
1094  * gst_deinit:
1095  *
1096  * Clean up any resources created by GStreamer in gst_init().
1097  *
1098  * It is normally not needed to call this function in a normal application
1099  * as the resources will automatically be freed when the program terminates.
1100  * This function is therefore mostly used by testsuites and other memory
1101  * profiling tools.
1102  *
1103  * After this call GStreamer (including this method) should not be used anymore.
1104  */
1105 void
1106 gst_deinit (void)
1107 {
1108   GstBinClass *bin_class;
1109   GstClock *clock;
1110 
1111   if (!gst_initialized)
1112     return;
1113 
1114   GST_INFO (&quot;deinitializing GStreamer&quot;);
1115 
1116   if (gst_deinitialized) {
1117     GST_DEBUG (&quot;already deinitialized&quot;);
1118     return;
1119   }
1120   g_thread_pool_set_max_unused_threads (0);
1121   bin_class = (GstBinClass *) g_type_class_peek (gst_bin_get_type ());
1122   if (bin_class &amp;&amp; bin_class-&gt;pool != NULL) {
1123     g_thread_pool_free (bin_class-&gt;pool, FALSE, TRUE);
1124     bin_class-&gt;pool = NULL;
1125   }
1126   gst_task_cleanup_all ();
1127 
1128   g_slist_foreach (_priv_gst_preload_plugins, (GFunc) g_free, NULL);
1129   g_slist_free (_priv_gst_preload_plugins);
1130   _priv_gst_preload_plugins = NULL;
1131 
1132 #ifndef GST_DISABLE_REGISTRY
1133   g_list_foreach (_priv_gst_plugin_paths, (GFunc) g_free, NULL);
1134   g_list_free (_priv_gst_plugin_paths);
1135   _priv_gst_plugin_paths = NULL;
1136 #endif
1137 
1138   if (_gst_executable_path) {
1139     g_free (_gst_executable_path);
1140     _gst_executable_path = NULL;
1141   }
1142 
1143   clock = gst_system_clock_obtain ();
1144   gst_object_unref (clock);
1145   gst_object_unref (clock);
1146 
1147   _priv_gst_registry_cleanup ();
1148   _priv_gst_allocator_cleanup ();
1149 
1150   /* We want to destroy tracers as late as possible for the leaks tracer
1151    * but still need to keep the caps system alive as it may have to use
1152    * gst_caps_to_string() to display leaked caps. */
1153 #ifndef GST_DISABLE_GST_DEBUG
1154   _priv_gst_tracing_deinit ();
1155 #endif
1156 
1157   _priv_gst_caps_features_cleanup ();
1158   _priv_gst_caps_cleanup ();
1159   _priv_gst_debug_cleanup ();
1160 
1161   g_type_class_unref (g_type_class_peek (gst_object_get_type ()));
1162   g_type_class_unref (g_type_class_peek (gst_pad_get_type ()));
1163   g_type_class_unref (g_type_class_peek (gst_element_factory_get_type ()));
1164   g_type_class_unref (g_type_class_peek (gst_element_get_type ()));
1165   g_type_class_unref (g_type_class_peek (gst_tracer_factory_get_type ()));
1166   g_type_class_unref (g_type_class_peek (gst_type_find_factory_get_type ()));
1167   g_type_class_unref (g_type_class_peek (gst_bin_get_type ()));
1168   g_type_class_unref (g_type_class_peek (gst_bus_get_type ()));
1169   g_type_class_unref (g_type_class_peek (gst_task_get_type ()));
1170   g_type_class_unref (g_type_class_peek (gst_object_flags_get_type ()));
1171   g_type_class_unref (g_type_class_peek (gst_bin_flags_get_type ()));
1172   g_type_class_unref (g_type_class_peek (gst_buffer_flags_get_type ()));
1173   g_type_class_unref (g_type_class_peek (gst_buffer_copy_flags_get_type ()));
1174   g_type_class_unref (g_type_class_peek (gst_bus_flags_get_type ()));
1175   g_type_class_unref (g_type_class_peek (gst_bus_sync_reply_get_type ()));
1176   g_type_class_unref (g_type_class_peek (gst_caps_flags_get_type ()));
1177   g_type_class_unref (g_type_class_peek (gst_clock_type_get_type ()));
1178   g_type_class_unref (g_type_class_peek (gst_clock_return_get_type ()));
1179   g_type_class_unref (g_type_class_peek (gst_clock_entry_type_get_type ()));
1180   g_type_class_unref (g_type_class_peek (gst_clock_flags_get_type ()));
1181   g_type_class_unref (g_type_class_peek (gst_debug_graph_details_get_type ()));
1182   g_type_class_unref (g_type_class_peek (gst_state_get_type ()));
1183   g_type_class_unref (g_type_class_peek (gst_state_change_return_get_type ()));
1184   g_type_class_unref (g_type_class_peek (gst_state_change_get_type ()));
1185   g_type_class_unref (g_type_class_peek (gst_element_flags_get_type ()));
1186   g_type_class_unref (g_type_class_peek (gst_tracer_value_scope_get_type ()));
1187   g_type_class_unref (g_type_class_peek (gst_tracer_value_flags_get_type ()));
1188   g_type_class_unref (g_type_class_peek (gst_core_error_get_type ()));
1189   g_type_class_unref (g_type_class_peek (gst_library_error_get_type ()));
1190   g_type_class_unref (g_type_class_peek (gst_plugin_dependency_flags_get_type
1191           ()));
1192   g_type_class_unref (g_type_class_peek (gst_parse_flags_get_type ()));
1193   g_type_class_unref (g_type_class_peek (gst_resource_error_get_type ()));
1194   g_type_class_unref (g_type_class_peek (gst_search_mode_get_type ()));
1195   g_type_class_unref (g_type_class_peek (gst_stream_error_get_type ()));
1196   g_type_class_unref (g_type_class_peek (gst_stream_status_type_get_type ()));
1197   g_type_class_unref (g_type_class_peek (gst_structure_change_type_get_type
1198           ()));
1199   g_type_class_unref (g_type_class_peek (gst_event_type_flags_get_type ()));
1200   g_type_class_unref (g_type_class_peek (gst_event_type_get_type ()));
1201   g_type_class_unref (g_type_class_peek (gst_seek_type_get_type ()));
1202   g_type_class_unref (g_type_class_peek (gst_seek_flags_get_type ()));
1203   g_type_class_unref (g_type_class_peek (gst_qos_type_get_type ()));
1204   g_type_class_unref (g_type_class_peek (gst_format_get_type ()));
1205   g_type_class_unref (g_type_class_peek (gst_debug_level_get_type ()));
1206   g_type_class_unref (g_type_class_peek (gst_debug_color_flags_get_type ()));
1207   g_type_class_unref (g_type_class_peek (gst_iterator_result_get_type ()));
1208   g_type_class_unref (g_type_class_peek (gst_iterator_item_get_type ()));
1209   g_type_class_unref (g_type_class_peek (gst_message_type_get_type ()));
1210   g_type_class_unref (g_type_class_peek (gst_meta_flags_get_type ()));
1211   g_type_class_unref (g_type_class_peek (gst_mini_object_flags_get_type ()));
1212   g_type_class_unref (g_type_class_peek (gst_pad_link_return_get_type ()));
1213   g_type_class_unref (g_type_class_peek (gst_pad_link_check_get_type ()));
1214   g_type_class_unref (g_type_class_peek (gst_flow_return_get_type ()));
1215   g_type_class_unref (g_type_class_peek (gst_pad_mode_get_type ()));
1216   g_type_class_unref (g_type_class_peek (gst_pad_direction_get_type ()));
1217   g_type_class_unref (g_type_class_peek (gst_pad_flags_get_type ()));
1218   g_type_class_unref (g_type_class_peek (gst_pad_presence_get_type ()));
1219   g_type_class_unref (g_type_class_peek (gst_pad_template_flags_get_type ()));
1220   g_type_class_unref (g_type_class_peek (gst_pipeline_flags_get_type ()));
1221   g_type_class_unref (g_type_class_peek (gst_plugin_error_get_type ()));
1222   g_type_class_unref (g_type_class_peek (gst_plugin_flags_get_type ()));
1223   g_type_class_unref (g_type_class_peek (gst_rank_get_type ()));
1224   g_type_class_unref (g_type_class_peek (gst_query_type_flags_get_type ()));
1225   g_type_class_unref (g_type_class_peek (gst_query_type_get_type ()));
1226   g_type_class_unref (g_type_class_peek (gst_buffering_mode_get_type ()));
1227   g_type_class_unref (g_type_class_peek (gst_tag_merge_mode_get_type ()));
1228   g_type_class_unref (g_type_class_peek (gst_tag_flag_get_type ()));
1229   g_type_class_unref (g_type_class_peek (gst_tag_scope_get_type ()));
1230   g_type_class_unref (g_type_class_peek (gst_task_state_get_type ()));
1231   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1232   g_type_class_unref (g_type_class_peek (gst_toc_scope_get_type ()));
1233   g_type_class_unref (g_type_class_peek (gst_type_find_probability_get_type
1234           ()));
1235   g_type_class_unref (g_type_class_peek (gst_uri_type_get_type ()));
1236   g_type_class_unref (g_type_class_peek (gst_uri_error_get_type ()));
1237   g_type_class_unref (g_type_class_peek (gst_parse_error_get_type ()));
1238   g_type_class_unref (g_type_class_peek (gst_param_spec_fraction_get_type ()));
1239   g_type_class_unref (g_type_class_peek (gst_progress_type_get_type ()));
1240   g_type_class_unref (g_type_class_peek (gst_buffer_pool_acquire_flags_get_type
1241           ()));
1242   g_type_class_unref (g_type_class_peek (gst_memory_flags_get_type ()));
1243   g_type_class_unref (g_type_class_peek (gst_map_flags_get_type ()));
1244   g_type_class_unref (g_type_class_peek (gst_caps_intersect_mode_get_type ()));
1245   g_type_class_unref (g_type_class_peek (gst_pad_probe_type_get_type ()));
1246   g_type_class_unref (g_type_class_peek (gst_pad_probe_return_get_type ()));
1247   g_type_class_unref (g_type_class_peek (gst_segment_flags_get_type ()));
1248   g_type_class_unref (g_type_class_peek (gst_scheduling_flags_get_type ()));
1249   g_type_class_unref (g_type_class_peek (gst_stream_type_get_type ()));
1250 
1251   g_type_class_unref (g_type_class_peek (gst_control_binding_get_type ()));
1252   g_type_class_unref (g_type_class_peek (gst_control_source_get_type ()));
1253   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1254   g_type_class_unref (g_type_class_peek (gst_toc_loop_type_get_type ()));
1255   g_type_class_unref (g_type_class_peek (gst_lock_flags_get_type ()));
1256   g_type_class_unref (g_type_class_peek (gst_allocator_flags_get_type ()));
1257   g_type_class_unref (g_type_class_peek (gst_stream_flags_get_type ()));
1258   g_type_class_unref (g_type_class_peek (gst_debug_color_mode_get_type ()));
1259   g_type_class_unref (g_type_class_peek (gst_stack_trace_flags_get_type ()));
1260 #ifndef GSTREAMER_LITE
1261   g_type_class_unref (g_type_class_peek (gst_promise_result_get_type ()));
1262 #endif // GSTREAMER_LITE
1263 
1264   gst_deinitialized = TRUE;
1265   GST_INFO (&quot;deinitialized GStreamer&quot;);
1266 }
1267 
1268 /**
1269  * gst_version:
1270  * @major: (out): pointer to a guint to store the major version number
1271  * @minor: (out): pointer to a guint to store the minor version number
1272  * @micro: (out): pointer to a guint to store the micro version number
1273  * @nano:  (out): pointer to a guint to store the nano version number
1274  *
1275  * Gets the version number of the GStreamer library.
1276  */
1277 void
1278 gst_version (guint * major, guint * minor, guint * micro, guint * nano)
1279 {
1280   g_return_if_fail (major);
1281   g_return_if_fail (minor);
1282   g_return_if_fail (micro);
1283   g_return_if_fail (nano);
1284 
1285   *major = GST_VERSION_MAJOR;
1286   *minor = GST_VERSION_MINOR;
1287   *micro = GST_VERSION_MICRO;
1288   *nano = GST_VERSION_NANO;
1289 }
1290 
1291 /**
1292  * gst_version_string:
1293  *
1294  * This function returns a string that is useful for describing this version
1295  * of GStreamer to the outside world: user agent strings, logging, ...
1296  *
1297  * Returns: (transfer full): a newly allocated string describing this version
1298  *     of GStreamer.
1299  */
1300 
1301 gchar *
1302 gst_version_string (void)
1303 {
1304   guint major, minor, micro, nano;
1305 
1306   gst_version (&amp;major, &amp;minor, &amp;micro, &amp;nano);
1307   if (nano == 0)
1308     return g_strdup_printf (&quot;GStreamer %d.%d.%d&quot;, major, minor, micro);
1309   else if (nano == 1)
1310     return g_strdup_printf (&quot;GStreamer %d.%d.%d (GIT)&quot;, major, minor, micro);
1311   else
1312     return g_strdup_printf (&quot;GStreamer %d.%d.%d (prerelease)&quot;, major, minor,
1313         micro);
1314 }
1315 
1316 /**
1317  * gst_segtrap_is_enabled:
1318  *
1319  * Some functions in the GStreamer core might install a custom SIGSEGV handler
1320  * to better catch and report errors to the application. Currently this feature
1321  * is enabled by default when loading plugins.
1322  *
1323  * Applications might want to disable this behaviour with the
1324  * gst_segtrap_set_enabled() function. This is typically done if the application
1325  * wants to install its own handler without GStreamer interfering.
1326  *
1327  * Returns: %TRUE if GStreamer is allowed to install a custom SIGSEGV handler.
1328  */
1329 gboolean
1330 gst_segtrap_is_enabled (void)
1331 {
1332   /* yeps, it&#39;s enabled when it&#39;s not disabled */
1333   return !_gst_disable_segtrap;
1334 }
1335 
1336 /**
1337  * gst_segtrap_set_enabled:
1338  * @enabled: whether a custom SIGSEGV handler should be installed.
1339  *
1340  * Applications might want to disable/enable the SIGSEGV handling of
1341  * the GStreamer core. See gst_segtrap_is_enabled() for more information.
1342  */
1343 void
1344 gst_segtrap_set_enabled (gboolean enabled)
1345 {
1346   _gst_disable_segtrap = !enabled;
1347 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>