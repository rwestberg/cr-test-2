<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gst.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gst.c: Initialization and non-pipeline operations
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gst
  25  * @title: GStreamer
  26  * @short_description: Media library supporting arbitrary formats and filter
  27  *                     graphs.
  28  *
  29  * GStreamer is a framework for constructing graphs of various filters
  30  * (termed elements here) that will handle streaming media.  Any discrete
  31  * (packetizable) media type is supported, with provisions for automatically
  32  * determining source type.  Formatting/framing information is provided with
  33  * a powerful negotiation framework.  Plugins are heavily used to provide for
  34  * all elements, allowing one to construct plugins outside of the GST
  35  * library, even released binary-only if license require (please don&#39;t).
  36  * GStreamer covers a wide range of use cases including: playback, recording,
  37  * editing, serving streams, voice over ip and video calls.
  38  *
  39  * The &lt;application&gt;GStreamer&lt;/application&gt; library should be initialized with
  40  * gst_init() before it can be used. You should pass pointers to the main argc
  41  * and argv variables so that GStreamer can process its own command line
  42  * options, as shown in the following example.
  43  *
  44  * ## Initializing the gstreamer library
  45  *
  46  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  47  * int
  48  * main (int argc, char *argv[])
  49  * {
  50  *   // initialize the GStreamer library
  51  *   gst_init (&amp;amp;argc, &amp;amp;argv);
  52  *   ...
  53  * }
  54  * ]|
  55  *
  56  * It&#39;s allowed to pass two %NULL pointers to gst_init() in case you don&#39;t want
  57  * to pass the command line args to GStreamer.
  58  *
  59  * You can also use GOption to initialize your own parameters as shown in
  60  * the next code fragment:
  61  *
  62  * ## Initializing own parameters when initializing gstreamer
  63  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  64  * static gboolean stats = FALSE;
  65  * ...
  66  * int
  67  * main (int argc, char *argv[])
  68  * {
  69  *  GOptionEntry options[] = {
  70  *   {&quot;tags&quot;, &#39;t&#39;, 0, G_OPTION_ARG_NONE, &amp;amp;tags,
  71  *       N_(&quot;Output tags (also known as metadata)&quot;), NULL},
  72  *   {NULL}
  73  *  };
  74  *  ctx = g_option_context_new (&quot;[ADDITIONAL ARGUMENTS]&quot;);
  75  *  g_option_context_add_main_entries (ctx, options, GETTEXT_PACKAGE);
  76  *  g_option_context_add_group (ctx, gst_init_get_option_group ());
  77  *  if (!g_option_context_parse (ctx, &amp;amp;argc, &amp;amp;argv, &amp;amp;err)) {
  78  *    g_print (&quot;Error initializing: &amp;percnt;s\n&quot;, GST_STR_NULL (err-&gt;message));
  79  *    exit (1);
  80  *  }
  81  *  g_option_context_free (ctx);
  82  * ...
  83  * }
  84  * ]|
  85  *
  86  * Use gst_version() to query the library version at runtime or use the
  87  * GST_VERSION_* macros to find the version at compile time. Optionally
  88  * gst_version_string() returns a printable string.
  89  *
  90  * The gst_deinit() call is used to clean up all internal resources used
  91  * by GStreamer. It is mostly used in unit tests to check for leaks.
  92  */
  93 
  94 #include &quot;gst_private.h&quot;
  95 #include &quot;gstconfig.h&quot;
  96 #include &lt;stdlib.h&gt;
  97 #include &lt;stdio.h&gt;
  98 #include &lt;sys/types.h&gt;
  99 #ifdef HAVE_SYS_UTSNAME_H
 100 #include &lt;sys/utsname.h&gt;
 101 #endif
 102 #ifdef HAVE_UNISTD_H
 103 #include &lt;unistd.h&gt;
 104 #endif
 105 #ifdef G_OS_WIN32
 106 #define WIN32_LEAN_AND_MEAN     /* prevents from including too many things */
 107 #include &lt;windows.h&gt;            /* GetStdHandle, windows console */
 108 #endif
 109 #if defined (__APPLE__)
 110 #include &quot;TargetConditionals.h&quot;
 111 #if !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 112 #include &lt;libproc.h&gt;            /* proc_pidpath, PROC_PIDPATHINFO_MAXSIZE */
 113 #endif
 114 #endif
 115 
 116 #if defined(GSTREAMER_LITE)
 117 #include &quot;gstplugins-lite.h&quot;
 118 #endif // GSTREAMER_LITE
 119 
 120 #include &quot;gst-i18n-lib.h&quot;
 121 #include &lt;locale.h&gt;             /* for LC_ALL */
 122 
 123 #include &quot;gst.h&quot;
 124 
 125 #ifdef GSTREAMER_LITE
 126 #ifdef STATIC_BUILD
 127 gboolean fxplugins_init (GstPlugin * plugin);
 128 gboolean fxavplugins_init (GstPlugin * plugin);
 129 #endif // STATIC_BUILD
 130 #endif // GSTREAMER_LITE
 131 
 132 #define GST_CAT_DEFAULT GST_CAT_GST_INIT
 133 
 134 #define MAX_PATH_SPLIT  16
 135 #define GST_PLUGIN_SEPARATOR &quot;,&quot;
 136 
 137 static gboolean gst_initialized = FALSE;
 138 static gboolean gst_deinitialized = FALSE;
 139 
 140 GstClockTime _priv_gst_start_time;
 141 
 142 #ifdef G_OS_WIN32
 143 HMODULE _priv_gst_dll_handle = NULL;
 144 #endif
 145 
 146 #ifndef GST_DISABLE_REGISTRY
 147 GList *_priv_gst_plugin_paths = NULL;   /* for delayed processing in init_post */
 148 
 149 extern gboolean _priv_gst_disable_registry;
 150 extern gboolean _priv_gst_disable_registry_update;
 151 #endif
 152 
 153 gchar *_gst_executable_path = NULL;
 154 
 155 #ifndef GST_DISABLE_GST_DEBUG
 156 const gchar *priv_gst_dump_dot_dir;
 157 #endif
 158 
 159 /* defaults */
 160 
 161 /* set to TRUE when segfaults need to be left as is */
 162 static gboolean _gst_disable_segtrap = FALSE;
 163 
 164 static gboolean init_pre (GOptionContext * context, GOptionGroup * group,
 165     gpointer data, GError ** error);
 166 static gboolean init_post (GOptionContext * context, GOptionGroup * group,
 167     gpointer data, GError ** error);
 168 #ifndef GST_DISABLE_OPTION_PARSING
 169 static gboolean parse_goption_arg (const gchar * s_opt,
 170     const gchar * arg, gpointer data, GError ** err);
 171 #endif
 172 
 173 GSList *_priv_gst_preload_plugins = NULL;
 174 
 175 const gchar g_log_domain_gstreamer[] = &quot;GStreamer&quot;;
 176 
 177 static void
 178 debug_log_handler (const gchar * log_domain,
 179     GLogLevelFlags log_level, const gchar * message, gpointer user_data)
 180 {
 181   g_log_default_handler (log_domain, log_level, message, user_data);
 182   /* FIXME: do we still need this ? fatal errors these days are all
 183    * other than core errors */
 184   /* g_on_error_query (NULL); */
 185 }
 186 
 187 enum
 188 {
 189   ARG_VERSION = 1,
 190   ARG_FATAL_WARNINGS,
 191 #ifndef GST_DISABLE_GST_DEBUG
 192   ARG_DEBUG_LEVEL,
 193   ARG_DEBUG,
 194   ARG_DEBUG_DISABLE,
 195   ARG_DEBUG_NO_COLOR,
 196   ARG_DEBUG_COLOR_MODE,
 197   ARG_DEBUG_HELP,
 198 #endif
 199   ARG_PLUGIN_SPEW,
 200   ARG_PLUGIN_PATH,
 201   ARG_PLUGIN_LOAD,
 202   ARG_SEGTRAP_DISABLE,
 203   ARG_REGISTRY_UPDATE_DISABLE,
 204   ARG_REGISTRY_FORK_DISABLE
 205 };
 206 
 207 /* debug-spec ::= category-spec [, category-spec]*
 208  * category-spec ::= category:val | val
 209  * category ::= [^:]+
 210  * val ::= [0-5]
 211  */
 212 
 213 #ifndef GSTREAMER_LITE
 214 #ifdef G_OS_WIN32
 215 /* Note: DllMain is only called when DLLs are loaded or unloaded, so this will
 216  * never be called if libgstreamer-1.0 is linked statically. Do not add any code
 217  * here to, say, initialize variables or set things up since that will only
 218  * happen for dynamically-built GStreamer.
 219  *
 220  * Also, ideally this should not be defined when GStreamer is built statically.
 221  * i.e., it should be conditional on #ifdef DLL_EXPORT. It will be ignored, but
 222  * if other libraries make the same mistake of defining it when building
 223  * statically, there will be a symbol collision during linking. Fixing this
 224  * requires one to build two object files: one for static linking and another
 225  * for dynamic linking. */
 226 BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
 227 BOOL WINAPI
 228 DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 229 {
 230   if (fdwReason == DLL_PROCESS_ATTACH)
 231     _priv_gst_dll_handle = (HMODULE) hinstDLL;
 232   return TRUE;
 233 }
 234 
 235 #endif
 236 #endif // GSTREAMER_LITE
 237 
 238 /**
 239  * gst_init_get_option_group: (skip)
 240  *
 241  * Returns a #GOptionGroup with GStreamer&#39;s argument specifications. The
 242  * group is set up to use standard GOption callbacks, so when using this
 243  * group in combination with GOption parsing methods, all argument parsing
 244  * and initialization is automated.
 245  *
 246  * This function is useful if you want to integrate GStreamer with other
 247  * libraries that use GOption (see g_option_context_add_group() ).
 248  *
 249  * If you use this function, you should make sure you initialise the GLib
 250  * threading system as one of the very first things in your program
 251  * (see the example at the beginning of this section).
 252  *
 253  * Returns: (transfer full) (nullable): a pointer to GStreamer&#39;s option group.
 254  */
 255 
 256 GOptionGroup *
 257 gst_init_get_option_group (void)
 258 {
 259 #ifndef GST_DISABLE_OPTION_PARSING
 260   GOptionGroup *group;
 261   static const GOptionEntry gst_args[] = {
 262     {&quot;gst-version&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 263         (gpointer) parse_goption_arg, N_(&quot;Print the GStreamer version&quot;), NULL},
 264     {&quot;gst-fatal-warnings&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 265         (gpointer) parse_goption_arg, N_(&quot;Make all warnings fatal&quot;), NULL},
 266 #ifndef GST_DISABLE_GST_DEBUG
 267     {&quot;gst-debug-help&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 268           (gpointer) parse_goption_arg,
 269           N_(&quot;Print available debug categories and exit&quot;),
 270         NULL},
 271     {&quot;gst-debug-level&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 272           (gpointer) parse_goption_arg,
 273           N_(&quot;Default debug level from 1 (only error) to 9 (anything) or &quot;
 274               &quot;0 for no output&quot;),
 275         N_(&quot;LEVEL&quot;)},
 276     {&quot;gst-debug&quot;, 0, 0, G_OPTION_ARG_CALLBACK, (gpointer) parse_goption_arg,
 277           N_(&quot;Comma-separated list of category_name:level pairs to set &quot;
 278               &quot;specific levels for the individual categories. Example: &quot;
 279               &quot;GST_AUTOPLUG:5,GST_ELEMENT_*:3&quot;),
 280         N_(&quot;LIST&quot;)},
 281     {&quot;gst-debug-no-color&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 282           (gpointer) parse_goption_arg, N_(&quot;Disable colored debugging output&quot;),
 283         NULL},
 284     {&quot;gst-debug-color-mode&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 285           (gpointer) parse_goption_arg,
 286           N_(&quot;Changes coloring mode of the debug log. &quot;
 287               &quot;Possible modes: off, on, disable, auto, unix&quot;),
 288         NULL},
 289     {&quot;gst-debug-disable&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 290         (gpointer) parse_goption_arg, N_(&quot;Disable debugging&quot;), NULL},
 291 #endif
 292     {&quot;gst-plugin-spew&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 293           (gpointer) parse_goption_arg,
 294           N_(&quot;Enable verbose plugin loading diagnostics&quot;),
 295         NULL},
 296     {&quot;gst-plugin-path&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 297           (gpointer) parse_goption_arg,
 298         N_(&quot;Colon-separated paths containing plugins&quot;), N_(&quot;PATHS&quot;)},
 299     {&quot;gst-plugin-load&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 300           (gpointer) parse_goption_arg,
 301           N_(&quot;Comma-separated list of plugins to preload in addition to the &quot;
 302               &quot;list stored in environment variable GST_PLUGIN_PATH&quot;),
 303         N_(&quot;PLUGINS&quot;)},
 304     {&quot;gst-disable-segtrap&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 305           (gpointer) parse_goption_arg,
 306           N_(&quot;Disable trapping of segmentation faults during plugin loading&quot;),
 307         NULL},
 308     {&quot;gst-disable-registry-update&quot;, 0, G_OPTION_FLAG_NO_ARG,
 309           G_OPTION_ARG_CALLBACK,
 310           (gpointer) parse_goption_arg,
 311           N_(&quot;Disable updating the registry&quot;),
 312         NULL},
 313     {&quot;gst-disable-registry-fork&quot;, 0, G_OPTION_FLAG_NO_ARG,
 314           G_OPTION_ARG_CALLBACK,
 315           (gpointer) parse_goption_arg,
 316           N_(&quot;Disable spawning a helper process while scanning the registry&quot;),
 317         NULL},
 318     {NULL}
 319   };
 320 
 321   group = g_option_group_new (&quot;gst&quot;, _(&quot;GStreamer Options&quot;),
 322       _(&quot;Show GStreamer Options&quot;), NULL, NULL);
 323   g_option_group_set_parse_hooks (group, (GOptionParseFunc) init_pre,
 324       (GOptionParseFunc) init_post);
 325 
 326   g_option_group_add_entries (group, gst_args);
 327   g_option_group_set_translation_domain (group, GETTEXT_PACKAGE);
 328 
 329   return group;
 330 #else
 331   return NULL;
 332 #endif
 333 }
 334 
 335 #if defined(__linux__)
 336 static void
 337 find_executable_path (void)
 338 {
 339   GError *error = NULL;
 340 
 341   if (_gst_executable_path)
 342     return;
 343 
 344   _gst_executable_path = g_file_read_link (&quot;/proc/self/exe&quot;, &amp;error);
 345   if (error)
 346     g_error_free (error);
 347 }
 348 #elif defined(G_OS_WIN32)
 349 static void
 350 find_executable_path (void)
 351 {
 352   char buffer[MAX_PATH];
 353 
 354   if (!GetModuleFileName (NULL, buffer, MAX_PATH))
 355     return;
 356 
 357   _gst_executable_path = g_strdup (buffer);
 358 }
 359 #elif defined(__APPLE__) &amp;&amp; !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 360 static void
 361 find_executable_path (void)
 362 {
 363   int ret;
 364   pid_t pid;
 365   char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
 366 
 367   pid = getpid ();
 368   ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));
 369   if (ret &gt; 0)
 370     _gst_executable_path = g_strdup (pathbuf);
 371 }
 372 #else
 373 static void
 374 find_executable_path (void)
 375 {
 376   GST_FIXME (&quot;Couldn&#39;t look up executable path, add support for this platform&quot;);
 377 }
 378 #endif
 379 
 380 /**
 381  * gst_get_main_executable_path:
 382  *
 383  * This helper is mostly helpful for plugins that need to
 384  * inspect the folder of the main executable to determine
 385  * their set of features.
 386  *
 387  * When a plugin is initialized from the gst-plugin-scanner
 388  * external process, the returned path will be the same as from the
 389  * parent process.
 390  *
 391  * Returns: (transfer none) (nullable): The path of the executable that
 392  *   initialized GStreamer, or %NULL if it could not be determined.
 393  *
 394  * Since: 1.14
 395  */
 396 const gchar *
 397 gst_get_main_executable_path (void)
 398 {
 399   return _gst_executable_path;
 400 }
 401 
 402 /**
 403  * gst_init_check:
 404  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 405  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 406  * @err: pointer to a #GError to which a message will be posted on error
 407  *
 408  * Initializes the GStreamer library, setting up internal path lists,
 409  * registering built-in elements, and loading standard plugins.
 410  *
 411  * This function will return %FALSE if GStreamer could not be initialized
 412  * for some reason.  If you want your program to fail fatally,
 413  * use gst_init() instead.
 414  *
 415  * Returns: %TRUE if GStreamer could be initialized.
 416  */
 417 gboolean
 418 gst_init_check (int *argc, char **argv[], GError ** err)
 419 {
 420   static GMutex init_lock;
 421 #ifndef GST_DISABLE_OPTION_PARSING
 422   GOptionGroup *group;
 423   GOptionContext *ctx;
 424 #endif
 425   gboolean res;
 426 
 427   g_mutex_lock (&amp;init_lock);
 428 
 429 #ifdef GSTREAMER_LITE
 430 #ifdef ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 431   #include &lt;crtdbg.h&gt;
 432 
 433   _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
 434   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
 435 #endif // ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 436 #endif // GSTREAMER_LITE
 437 
 438   if (gst_initialized) {
 439     GST_DEBUG (&quot;already initialized gst&quot;);
 440     g_mutex_unlock (&amp;init_lock);
 441     return TRUE;
 442   }
 443 #ifndef GST_DISABLE_OPTION_PARSING
 444   ctx = g_option_context_new (&quot;- GStreamer initialization&quot;);
 445   g_option_context_set_ignore_unknown_options (ctx, TRUE);
 446   g_option_context_set_help_enabled (ctx, FALSE);
 447   group = gst_init_get_option_group ();
 448   g_option_context_add_group (ctx, group);
 449   res = g_option_context_parse (ctx, argc, argv, err);
 450   g_option_context_free (ctx);
 451 #else
 452   init_pre (NULL, NULL, NULL, NULL);
 453   init_post (NULL, NULL, NULL, NULL);
 454   res = TRUE;
 455 #endif
 456 
 457   gst_initialized = res;
 458 
 459   g_mutex_unlock (&amp;init_lock);
 460 
 461   return res;
 462 }
 463 
 464 /**
 465  * gst_init:
 466  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 467  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 468  *
 469  * Initializes the GStreamer library, setting up internal path lists,
 470  * registering built-in elements, and loading standard plugins.
 471  *
 472  * Unless the plugin registry is disabled at compile time, the registry will be
 473  * loaded. By default this will also check if the registry cache needs to be
 474  * updated and rescan all plugins if needed. See gst_update_registry() for
 475  * details and section
 476  * &lt;link linkend=&quot;gst-running&quot;&gt;Running GStreamer Applications&lt;/link&gt;
 477  * for how to disable automatic registry updates.
 478  *
 479  * &gt; This function will terminate your program if it was unable to initialize
 480  * &gt; GStreamer for some reason.  If you want your program to fall back,
 481  * &gt; use gst_init_check() instead.
 482  *
 483  * WARNING: This function does not work in the same way as corresponding
 484  * functions in other glib-style libraries, such as gtk_init\(\). In
 485  * particular, unknown command line options cause this function to
 486  * abort program execution.
 487  */
 488 void
 489 gst_init (int *argc, char **argv[])
 490 {
 491   GError *err = NULL;
 492 
 493   if (!gst_init_check (argc, argv, &amp;err)) {
 494     g_print (&quot;Could not initialize GStreamer: %s\n&quot;,
 495         err ? err-&gt;message : &quot;unknown error occurred&quot;);
 496     if (err) {
 497       g_error_free (err);
 498     }
 499     exit (1);
 500   }
 501 }
 502 
 503 /**
 504  * gst_is_initialized:
 505  *
 506  * Use this function to check if GStreamer has been initialized with gst_init()
 507  * or gst_init_check().
 508  *
 509  * Returns: %TRUE if initialization has been done, %FALSE otherwise.
 510  */
 511 gboolean
 512 gst_is_initialized (void)
 513 {
 514   return gst_initialized;
 515 }
 516 
 517 #ifndef GST_DISABLE_OPTION_PARSING
 518 #  ifndef GST_DISABLE_REGISTRY
 519 static void
 520 add_path_func (gpointer data, gpointer user_data)
 521 {
 522   GST_INFO (&quot;Adding plugin path: \&quot;%s\&quot;, will scan later&quot;, (gchar *) data);
 523   _priv_gst_plugin_paths =
 524       g_list_append (_priv_gst_plugin_paths, g_strdup (data));
 525 }
 526 #  endif
 527 #endif
 528 
 529 #ifndef GST_DISABLE_OPTION_PARSING
 530 static void
 531 prepare_for_load_plugin_func (gpointer data, gpointer user_data)
 532 {
 533   _priv_gst_preload_plugins =
 534       g_slist_prepend (_priv_gst_preload_plugins, g_strdup (data));
 535 }
 536 #endif
 537 
 538 #ifndef GST_DISABLE_OPTION_PARSING
 539 static void
 540 split_and_iterate (const gchar * stringlist, const gchar * separator,
 541     GFunc iterator, gpointer user_data)
 542 {
 543   gchar **strings;
 544   gint j = 0;
 545   gchar *lastlist = g_strdup (stringlist);
 546 
 547   while (lastlist) {
 548     strings = g_strsplit (lastlist, separator, MAX_PATH_SPLIT);
 549     g_free (lastlist);
 550     lastlist = NULL;
 551 
 552     while (strings[j]) {
 553       iterator (strings[j], user_data);
 554       if (++j == MAX_PATH_SPLIT) {
 555         lastlist = g_strdup (strings[j]);
 556         j = 0;
 557         break;
 558       }
 559     }
 560     g_strfreev (strings);
 561   }
 562 }
 563 #endif
 564 
 565 /* we have no fail cases yet, but maybe in the future */
 566 static gboolean
 567 init_pre (GOptionContext * context, GOptionGroup * group, gpointer data,
 568     GError ** error)
 569 {
 570   gchar *libdir;
 571   if (gst_initialized) {
 572     GST_DEBUG (&quot;already initialized&quot;);
 573     return TRUE;
 574   }
 575 
 576 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
 577   // We still need to call it due too bug in GLib
 578   g_type_init ();
 579 #endif // GSTREAMER_LITE
 580 
 581   find_executable_path ();
 582 
 583   _priv_gst_start_time = gst_util_get_timestamp ();
 584 
 585 #ifndef GST_DISABLE_GST_DEBUG
 586   _priv_gst_debug_init ();
 587   priv_gst_dump_dot_dir = g_getenv (&quot;GST_DEBUG_DUMP_DOT_DIR&quot;);
 588 #endif
 589 
 590 #ifdef ENABLE_NLS
 591   bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
 592   bind_textdomain_codeset (GETTEXT_PACKAGE, &quot;UTF-8&quot;);
 593 #endif /* ENABLE_NLS */
 594 
 595 #ifndef GSTREAMER_LITE
 596   /* This is the earliest we can make stuff show up in the logs.
 597    * So give some useful info about GStreamer here */
 598 #ifdef G_OS_WIN32
 599   {
 600     gchar *basedir =
 601         g_win32_get_package_installation_directory_of_module
 602         (_priv_gst_dll_handle);
 603 
 604     libdir = g_build_filename (basedir,
 605 #ifdef _DEBUG
 606         &quot;debug&quot;
 607 #endif
 608         &quot;lib&quot;, NULL);
 609     g_free (basedir);
 610   }
 611 #else
 612   libdir = g_strdup (LIBDIR);
 613 #endif
 614   GST_INFO (&quot;Initializing GStreamer Core Library version %s&quot;, VERSION);
 615   GST_INFO (&quot;Using library installed in %s&quot;, libdir);
 616   g_free (libdir);
 617 #endif // GSTREAMER_LITE
 618 
 619 #ifndef GST_DISABLE_REGISTRY
 620   {
 621     const gchar *disable_registry;
 622     if ((disable_registry = g_getenv (&quot;GST_REGISTRY_DISABLE&quot;))) {
 623       _priv_gst_disable_registry = (strcmp (disable_registry, &quot;yes&quot;) == 0);
 624     }
 625   }
 626 #endif
 627 
 628   /* Print some basic system details if possible (OS/architecture) */
 629 #ifdef HAVE_SYS_UTSNAME_H
 630   {
 631     struct utsname sys_details;
 632 
 633     if (uname (&amp;sys_details) == 0) {
 634       GST_INFO (&quot;%s %s %s %s %s&quot;, sys_details.sysname,
 635           sys_details.nodename, sys_details.release, sys_details.version,
 636           sys_details.machine);
 637     }
 638   }
 639 #endif
 640 
 641 #ifndef G_ATOMIC_LOCK_FREE
 642   GST_CAT_WARNING (GST_CAT_PERFORMANCE, &quot;GLib atomic operations are NOT &quot;
 643       &quot;implemented using real hardware atomic operations!&quot;);
 644 #endif
 645 
 646   return TRUE;
 647 }
 648 
 649 static gboolean
 650 gst_register_core_elements (GstPlugin * plugin)
 651 {
 652   /* register some standard builtin types */
 653   if (!gst_element_register (plugin, &quot;bin&quot;, GST_RANK_PRIMARY,
 654           GST_TYPE_BIN) ||
 655       !gst_element_register (plugin, &quot;pipeline&quot;, GST_RANK_PRIMARY,
 656           GST_TYPE_PIPELINE)
 657       )
 658     g_assert_not_reached ();
 659 
 660   return TRUE;
 661 }
 662 
 663 /*
 664  * this bit handles:
 665  * - initialization of threads if we use them
 666  * - log handler
 667  * - initial output
 668  * - initializes gst_format
 669  * - registers a bunch of types for gst_objects
 670  *
 671  * - we don&#39;t have cases yet where this fails, but in the future
 672  *   we might and then it&#39;s nice to be able to return that
 673  */
 674 static gboolean
 675 init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
 676     GError ** error)
 677 {
 678   GLogLevelFlags llf;
 679 
 680   if (gst_initialized) {
 681     GST_DEBUG (&quot;already initialized&quot;);
 682     return TRUE;
 683   }
 684 
 685   llf = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL;
 686   g_log_set_handler (g_log_domain_gstreamer, llf, debug_log_handler, NULL);
 687 
 688   _priv_gst_mini_object_initialize ();
 689   _priv_gst_quarks_initialize ();
 690   _priv_gst_allocator_initialize ();
 691   _priv_gst_memory_initialize ();
 692   _priv_gst_format_initialize ();
 693   _priv_gst_query_initialize ();
 694   _priv_gst_structure_initialize ();
 695   _priv_gst_caps_initialize ();
 696   _priv_gst_caps_features_initialize ();
 697   _priv_gst_meta_initialize ();
 698   _priv_gst_message_initialize ();
 699 
 700   g_type_class_ref (gst_object_get_type ());
 701   g_type_class_ref (gst_pad_get_type ());
 702   g_type_class_ref (gst_element_factory_get_type ());
 703   g_type_class_ref (gst_element_get_type ());
 704   g_type_class_ref (gst_tracer_factory_get_type ());
 705   g_type_class_ref (gst_type_find_factory_get_type ());
 706   g_type_class_ref (gst_bin_get_type ());
 707   g_type_class_ref (gst_bus_get_type ());
 708   g_type_class_ref (gst_task_get_type ());
 709   g_type_class_ref (gst_clock_get_type ());
 710   g_type_class_ref (gst_debug_color_mode_get_type ());
 711 
 712   gst_uri_handler_get_type ();
 713 
 714   g_type_class_ref (gst_object_flags_get_type ());
 715   g_type_class_ref (gst_bin_flags_get_type ());
 716   g_type_class_ref (gst_buffer_flags_get_type ());
 717   g_type_class_ref (gst_buffer_copy_flags_get_type ());
 718   g_type_class_ref (gst_bus_flags_get_type ());
 719   g_type_class_ref (gst_bus_sync_reply_get_type ());
 720   g_type_class_ref (gst_caps_flags_get_type ());
 721   g_type_class_ref (gst_clock_return_get_type ());
 722   g_type_class_ref (gst_clock_entry_type_get_type ());
 723   g_type_class_ref (gst_clock_flags_get_type ());
 724   g_type_class_ref (gst_clock_type_get_type ());
 725   g_type_class_ref (gst_debug_graph_details_get_type ());
 726   g_type_class_ref (gst_state_get_type ());
 727   g_type_class_ref (gst_state_change_return_get_type ());
 728   g_type_class_ref (gst_state_change_get_type ());
 729   g_type_class_ref (gst_element_flags_get_type ());
 730   g_type_class_ref (gst_tracer_value_scope_get_type ());
 731   g_type_class_ref (gst_tracer_value_flags_get_type ());
 732   g_type_class_ref (gst_core_error_get_type ());
 733   g_type_class_ref (gst_library_error_get_type ());
 734   g_type_class_ref (gst_resource_error_get_type ());
 735   g_type_class_ref (gst_stream_error_get_type ());
 736   g_type_class_ref (gst_event_type_flags_get_type ());
 737   g_type_class_ref (gst_event_type_get_type ());
 738   g_type_class_ref (gst_seek_type_get_type ());
 739   g_type_class_ref (gst_seek_flags_get_type ());
 740   g_type_class_ref (gst_qos_type_get_type ());
 741   g_type_class_ref (gst_format_get_type ());
 742   g_type_class_ref (gst_debug_level_get_type ());
 743   g_type_class_ref (gst_debug_color_flags_get_type ());
 744   g_type_class_ref (gst_iterator_result_get_type ());
 745   g_type_class_ref (gst_iterator_item_get_type ());
 746   g_type_class_ref (gst_message_type_get_type ());
 747   g_type_class_ref (gst_mini_object_flags_get_type ());
 748   g_type_class_ref (gst_pad_link_return_get_type ());
 749   g_type_class_ref (gst_pad_link_check_get_type ());
 750   g_type_class_ref (gst_flow_return_get_type ());
 751   g_type_class_ref (gst_pad_mode_get_type ());
 752   g_type_class_ref (gst_pad_direction_get_type ());
 753   g_type_class_ref (gst_pad_flags_get_type ());
 754   g_type_class_ref (gst_pad_presence_get_type ());
 755   g_type_class_ref (gst_pad_template_flags_get_type ());
 756   g_type_class_ref (gst_pipeline_flags_get_type ());
 757   g_type_class_ref (gst_plugin_error_get_type ());
 758   g_type_class_ref (gst_plugin_flags_get_type ());
 759   g_type_class_ref (gst_plugin_dependency_flags_get_type ());
 760   g_type_class_ref (gst_rank_get_type ());
 761   g_type_class_ref (gst_query_type_flags_get_type ());
 762   g_type_class_ref (gst_query_type_get_type ());
 763   g_type_class_ref (gst_buffering_mode_get_type ());
 764   g_type_class_ref (gst_stream_status_type_get_type ());
 765   g_type_class_ref (gst_structure_change_type_get_type ());
 766   g_type_class_ref (gst_tag_merge_mode_get_type ());
 767   g_type_class_ref (gst_tag_flag_get_type ());
 768   g_type_class_ref (gst_tag_scope_get_type ());
 769   g_type_class_ref (gst_task_pool_get_type ());
 770   g_type_class_ref (gst_task_state_get_type ());
 771   g_type_class_ref (gst_toc_entry_type_get_type ());
 772   g_type_class_ref (gst_type_find_probability_get_type ());
 773   g_type_class_ref (gst_uri_error_get_type ());
 774   g_type_class_ref (gst_uri_type_get_type ());
 775   g_type_class_ref (gst_parse_error_get_type ());
 776   g_type_class_ref (gst_parse_flags_get_type ());
 777   g_type_class_ref (gst_search_mode_get_type ());
 778   g_type_class_ref (gst_progress_type_get_type ());
 779   g_type_class_ref (gst_buffer_pool_acquire_flags_get_type ());
 780   g_type_class_ref (gst_memory_flags_get_type ());
 781   g_type_class_ref (gst_map_flags_get_type ());
 782   g_type_class_ref (gst_caps_intersect_mode_get_type ());
 783   g_type_class_ref (gst_pad_probe_type_get_type ());
 784   g_type_class_ref (gst_pad_probe_return_get_type ());
 785   g_type_class_ref (gst_segment_flags_get_type ());
 786   g_type_class_ref (gst_scheduling_flags_get_type ());
 787   g_type_class_ref (gst_meta_flags_get_type ());
 788   g_type_class_ref (gst_toc_entry_type_get_type ());
 789   g_type_class_ref (gst_toc_scope_get_type ());
 790   g_type_class_ref (gst_toc_loop_type_get_type ());
 791   g_type_class_ref (gst_control_binding_get_type ());
 792   g_type_class_ref (gst_control_source_get_type ());
 793   g_type_class_ref (gst_lock_flags_get_type ());
 794   g_type_class_ref (gst_allocator_flags_get_type ());
 795   g_type_class_ref (gst_stream_flags_get_type ());
 796   g_type_class_ref (gst_stream_type_get_type ());
 797   g_type_class_ref (gst_stack_trace_flags_get_type ());
 798 #ifndef GSTREAMER_LITE
 799   g_type_class_ref (gst_promise_result_get_type ());
 800 #endif // GSTREAMER_LITE
 801 
 802   _priv_gst_event_initialize ();
 803   _priv_gst_buffer_initialize ();
 804   _priv_gst_buffer_list_initialize ();
 805   _priv_gst_sample_initialize ();
 806   _priv_gst_context_initialize ();
 807   _priv_gst_date_time_initialize ();
 808   _priv_gst_value_initialize ();
 809   _priv_gst_tag_initialize ();
 810   _priv_gst_toc_initialize ();
 811 
 812   g_type_class_ref (gst_param_spec_fraction_get_type ());
 813   gst_parse_context_get_type ();
 814 
 815   _priv_gst_plugin_initialize ();
 816 
 817   /* register core plugins */
 818   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 819       &quot;staticelements&quot;, &quot;core elements linked into the GStreamer library&quot;,
 820       gst_register_core_elements, VERSION, GST_LICENSE, PACKAGE,
 821       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 822 
 823 #if defined(GSTREAMER_LITE)
 824   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 825       &quot;gstplugins-lite&quot;, &quot;gstplugins-lite&quot;,
 826       lite_plugins_init, VERSION, GST_LICENSE, PACKAGE,
 827       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 828 #ifdef STATIC_BUILD
 829   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 830       &quot;fxplugins&quot;, &quot;fxplugin&quot;,
 831       fxplugins_init, VERSION, GST_LICENSE, PACKAGE,
 832       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 833   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 834      &quot;fxavplugins&quot;, &quot;fxavplugin&quot;,
 835       fxavplugins_init, VERSION, GST_LICENSE, PACKAGE,
 836       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 837 #endif // STATIC_BUILD
 838 #endif // GSTREAMER_LITE
 839 
 840   /*
 841    * Any errors happening below this point are non-fatal, we therefore mark
 842    * gstreamer as being initialized, since it is the case from a plugin point of
 843    * view.
 844    *
 845    * If anything fails, it will be put back to %FALSE in gst_init_check().
 846    * This allows some special plugins that would call gst_init() to not cause a
 847    * looping effect (i.e. initializing GStreamer twice).
 848    */
 849   gst_initialized = TRUE;
 850 
 851   if (!gst_update_registry ())
 852     return FALSE;
 853 
 854   GST_INFO (&quot;GLib runtime version: %d.%d.%d&quot;, glib_major_version,
 855       glib_minor_version, glib_micro_version);
 856   GST_INFO (&quot;GLib headers version: %d.%d.%d&quot;, GLIB_MAJOR_VERSION,
 857       GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);
 858   GST_INFO (&quot;initialized GStreamer successfully&quot;);
 859 
 860 #ifndef GST_DISABLE_GST_DEBUG
 861   _priv_gst_tracing_init ();
 862 #endif
 863 
 864   return TRUE;
 865 }
 866 
 867 #ifndef GST_DISABLE_OPTION_PARSING
 868 #  ifndef GST_DISABLE_GST_DEBUG
 869 static gboolean
 870 select_all (GstPlugin * plugin, gpointer user_data)
 871 {
 872   return TRUE;
 873 }
 874 
 875 static gint
 876 sort_by_category_name (gconstpointer a, gconstpointer b)
 877 {
 878   return strcmp (gst_debug_category_get_name ((GstDebugCategory *) a),
 879       gst_debug_category_get_name ((GstDebugCategory *) b));
 880 }
 881 
 882 static void
 883 gst_debug_help (void)
 884 {
 885   GSList *list, *walk;
 886   GList *list2, *g;
 887 
 888   /* Need to ensure the registry is loaded to get debug categories */
 889   if (!init_post (NULL, NULL, NULL, NULL))
 890     exit (1);
 891 
 892   list2 = gst_registry_plugin_filter (gst_registry_get (),
 893       select_all, FALSE, NULL);
 894 
 895   /* FIXME this is gross.  why don&#39;t debug have categories PluginFeatures? */
 896   for (g = list2; g; g = g_list_next (g)) {
 897     GstPlugin *plugin = GST_PLUGIN_CAST (g-&gt;data);
 898     GList *features, *orig_features;
 899 
 900     if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED))
 901       continue;
 902 
 903     gst_plugin_load (plugin);
 904     /* Now create one of each feature so the class_init functions
 905      * are called, as that&#39;s where most debug categories are
 906      * registered. FIXME: If debug categories were a plugin feature,
 907      * this would be unneeded */
 908     orig_features = features =
 909         gst_registry_get_feature_list_by_plugin (gst_registry_get (),
 910         gst_plugin_get_name (plugin));
 911     while (features) {
 912       GstPluginFeature *feature;
 913 
 914       if (G_UNLIKELY (features-&gt;data == NULL))
 915         goto next;
 916 
 917       feature = GST_PLUGIN_FEATURE (features-&gt;data);
 918       if (GST_IS_ELEMENT_FACTORY (feature)) {
 919         GstElementFactory *factory;
 920         GstElement *e;
 921 
 922         factory = GST_ELEMENT_FACTORY (feature);
 923         e = gst_element_factory_create (factory, NULL);
 924         if (e)
 925           gst_object_unref (e);
 926       }
 927 
 928     next:
 929       features = g_list_next (features);
 930     }
 931 
 932     gst_plugin_feature_list_free (orig_features);
 933   }
 934   g_list_free (list2);
 935 
 936   list = gst_debug_get_all_categories ();
 937   walk = list = g_slist_sort (list, sort_by_category_name);
 938 
 939   g_print (&quot;\n&quot;);
 940   g_print (&quot;name                  level    description\n&quot;);
 941   g_print (&quot;---------------------+--------+--------------------------------\n&quot;);
 942 
 943   while (walk) {
 944     gboolean on_unix;
 945     GstDebugCategory *cat = (GstDebugCategory *) walk-&gt;data;
 946     GstDebugColorMode coloring = gst_debug_get_color_mode ();
 947 #ifdef G_OS_UNIX
 948     on_unix = TRUE;
 949 #else
 950     on_unix = FALSE;
 951 #endif
 952 
 953     if (GST_DEBUG_COLOR_MODE_UNIX == coloring
 954         || (on_unix &amp;&amp; GST_DEBUG_COLOR_MODE_ON == coloring)) {
 955       gchar *color = gst_debug_construct_term_color (cat-&gt;color);
 956 
 957       g_print (&quot;%s%-20s\033[00m  %1d %s  %s%s\033[00m\n&quot;,
 958           color,
 959           gst_debug_category_get_name (cat),
 960           gst_debug_category_get_threshold (cat),
 961           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 962           color, gst_debug_category_get_description (cat));
 963       g_free (color);
 964     } else if (GST_DEBUG_COLOR_MODE_ON == coloring &amp;&amp; !on_unix) {
 965 #ifdef G_OS_WIN32
 966       gint color = gst_debug_construct_win_color (cat-&gt;color);
 967       const gint clear = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
 968 
 969       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 970       g_print (&quot;%-20s&quot;, gst_debug_category_get_name (cat));
 971       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 972       g_print (&quot; %1d %s &quot;, gst_debug_category_get_threshold (cat),
 973           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)));
 974       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 975       g_print (&quot;%s&quot;, gst_debug_category_get_description (cat));
 976       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 977       g_print (&quot;\n&quot;);
 978 #endif /* G_OS_WIN32 */
 979     } else {
 980       g_print (&quot;%-20s  %1d %s  %s\n&quot;, gst_debug_category_get_name (cat),
 981           gst_debug_category_get_threshold (cat),
 982           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 983           gst_debug_category_get_description (cat));
 984     }
 985     walk = g_slist_next (walk);
 986   }
 987   g_slist_free (list);
 988   g_print (&quot;\n&quot;);
 989 }
 990 #  endif /* GST_DISABLE_OPTION_PARSING */
 991 #endif /* GST_DISABLE_GST_DEBUG */
 992 
 993 #ifndef GST_DISABLE_OPTION_PARSING
 994 static gboolean
 995 parse_one_option (gint opt, const gchar * arg, GError ** err)
 996 {
 997   switch (opt) {
 998     case ARG_VERSION:
 999       g_print (&quot;GStreamer Core Library version %s\n&quot;, PACKAGE_VERSION);
1000       exit (0);
1001     case ARG_FATAL_WARNINGS:{
1002       GLogLevelFlags fatal_mask;
1003 
1004       fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
1005       fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
1006       g_log_set_always_fatal (fatal_mask);
1007       break;
1008     }
1009 #ifndef GST_DISABLE_GST_DEBUG
1010     case ARG_DEBUG_LEVEL:{
1011       GstDebugLevel tmp = GST_LEVEL_NONE;
1012 
1013       tmp = (GstDebugLevel) strtol (arg, NULL, 0);
1014       if (((guint) tmp) &lt; GST_LEVEL_COUNT) {
1015         gst_debug_set_default_threshold (tmp);
1016       }
1017       break;
1018     }
1019     case ARG_DEBUG:
1020       gst_debug_set_threshold_from_string (arg, FALSE);
1021       break;
1022     case ARG_DEBUG_NO_COLOR:
1023       gst_debug_set_colored (FALSE);
1024       break;
1025     case ARG_DEBUG_COLOR_MODE:
1026       gst_debug_set_color_mode_from_string (arg);
1027       break;
1028     case ARG_DEBUG_DISABLE:
1029       gst_debug_set_active (FALSE);
1030       break;
1031     case ARG_DEBUG_HELP:
1032       gst_debug_help ();
1033       exit (0);
1034 #endif
1035     case ARG_PLUGIN_SPEW:
1036       break;
1037     case ARG_PLUGIN_PATH:
1038 #ifndef GST_DISABLE_REGISTRY
1039       if (!_priv_gst_disable_registry)
1040         split_and_iterate (arg, G_SEARCHPATH_SEPARATOR_S, add_path_func, NULL);
1041 #endif /* GST_DISABLE_REGISTRY */
1042       break;
1043     case ARG_PLUGIN_LOAD:
1044       split_and_iterate (arg, &quot;,&quot;, prepare_for_load_plugin_func, NULL);
1045       break;
1046     case ARG_SEGTRAP_DISABLE:
1047       _gst_disable_segtrap = TRUE;
1048       break;
1049     case ARG_REGISTRY_UPDATE_DISABLE:
1050 #ifndef GST_DISABLE_REGISTRY
1051       if (!_priv_gst_disable_registry)
1052         _priv_gst_disable_registry_update = TRUE;
1053 #endif
1054       break;
1055     case ARG_REGISTRY_FORK_DISABLE:
1056       gst_registry_fork_set_enabled (FALSE);
1057       break;
1058     default:
1059       g_set_error (err, G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
1060           _(&quot;Unknown option&quot;));
1061       return FALSE;
1062   }
1063 
1064   return TRUE;
1065 }
1066 
1067 static gboolean
1068 parse_goption_arg (const gchar * opt,
1069     const gchar * arg, gpointer data, GError ** err)
1070 {
1071   static const struct
1072   {
1073     const gchar *opt;
1074     int val;
1075   } options[] = {
1076     {
1077     &quot;--gst-version&quot;, ARG_VERSION}, {
1078     &quot;--gst-fatal-warnings&quot;, ARG_FATAL_WARNINGS},
1079 #ifndef GST_DISABLE_GST_DEBUG
1080     {
1081     &quot;--gst-debug-level&quot;, ARG_DEBUG_LEVEL}, {
1082     &quot;--gst-debug&quot;, ARG_DEBUG}, {
1083     &quot;--gst-debug-disable&quot;, ARG_DEBUG_DISABLE}, {
1084     &quot;--gst-debug-no-color&quot;, ARG_DEBUG_NO_COLOR}, {
1085     &quot;--gst-debug-color-mode&quot;, ARG_DEBUG_COLOR_MODE}, {
1086     &quot;--gst-debug-help&quot;, ARG_DEBUG_HELP},
1087 #endif
1088     {
1089     &quot;--gst-plugin-spew&quot;, ARG_PLUGIN_SPEW}, {
1090     &quot;--gst-plugin-path&quot;, ARG_PLUGIN_PATH}, {
1091     &quot;--gst-plugin-load&quot;, ARG_PLUGIN_LOAD}, {
1092     &quot;--gst-disable-segtrap&quot;, ARG_SEGTRAP_DISABLE}, {
1093     &quot;--gst-disable-registry-update&quot;, ARG_REGISTRY_UPDATE_DISABLE}, {
1094     &quot;--gst-disable-registry-fork&quot;, ARG_REGISTRY_FORK_DISABLE}, {
1095     NULL}
1096   };
1097   gint val = 0, n;
1098 
1099   for (n = 0; options[n].opt; n++) {
1100     if (!strcmp (opt, options[n].opt)) {
1101       val = options[n].val;
1102       break;
1103     }
1104   }
1105 
1106   return parse_one_option (val, arg, err);
1107 }
1108 #endif
1109 
1110 /**
1111  * gst_deinit:
1112  *
1113  * Clean up any resources created by GStreamer in gst_init().
1114  *
1115  * It is normally not needed to call this function in a normal application
1116  * as the resources will automatically be freed when the program terminates.
1117  * This function is therefore mostly used by testsuites and other memory
1118  * profiling tools.
1119  *
1120  * After this call GStreamer (including this method) should not be used anymore.
1121  */
1122 void
1123 gst_deinit (void)
1124 {
1125   GstBinClass *bin_class;
1126   GstClock *clock;
1127 
1128   if (!gst_initialized)
1129     return;
1130 
1131   GST_INFO (&quot;deinitializing GStreamer&quot;);
1132 
1133   if (gst_deinitialized) {
1134     GST_DEBUG (&quot;already deinitialized&quot;);
1135     return;
1136   }
1137   g_thread_pool_set_max_unused_threads (0);
1138   bin_class = (GstBinClass *) g_type_class_peek (gst_bin_get_type ());
1139   if (bin_class &amp;&amp; bin_class-&gt;pool != NULL) {
1140     g_thread_pool_free (bin_class-&gt;pool, FALSE, TRUE);
1141     bin_class-&gt;pool = NULL;
1142   }
1143   gst_task_cleanup_all ();
1144 
1145   g_slist_foreach (_priv_gst_preload_plugins, (GFunc) g_free, NULL);
1146   g_slist_free (_priv_gst_preload_plugins);
1147   _priv_gst_preload_plugins = NULL;
1148 
1149 #ifndef GST_DISABLE_REGISTRY
1150   g_list_foreach (_priv_gst_plugin_paths, (GFunc) g_free, NULL);
1151   g_list_free (_priv_gst_plugin_paths);
1152   _priv_gst_plugin_paths = NULL;
1153 #endif
1154 
1155   if (_gst_executable_path) {
1156     g_free (_gst_executable_path);
1157     _gst_executable_path = NULL;
1158   }
1159 
1160   clock = gst_system_clock_obtain ();
1161   gst_object_unref (clock);
1162   gst_object_unref (clock);
1163 
1164   _priv_gst_registry_cleanup ();
1165   _priv_gst_allocator_cleanup ();
1166 
1167   /* We want to destroy tracers as late as possible for the leaks tracer
1168    * but still need to keep the caps system alive as it may have to use
1169    * gst_caps_to_string() to display leaked caps. */
1170 #ifndef GST_DISABLE_GST_DEBUG
1171   _priv_gst_tracing_deinit ();
1172 #endif
1173 
1174   _priv_gst_caps_features_cleanup ();
1175   _priv_gst_caps_cleanup ();
1176   _priv_gst_debug_cleanup ();
1177 
1178   g_type_class_unref (g_type_class_peek (gst_object_get_type ()));
1179   g_type_class_unref (g_type_class_peek (gst_pad_get_type ()));
1180   g_type_class_unref (g_type_class_peek (gst_element_factory_get_type ()));
1181   g_type_class_unref (g_type_class_peek (gst_element_get_type ()));
1182   g_type_class_unref (g_type_class_peek (gst_tracer_factory_get_type ()));
1183   g_type_class_unref (g_type_class_peek (gst_type_find_factory_get_type ()));
1184   g_type_class_unref (g_type_class_peek (gst_bin_get_type ()));
1185   g_type_class_unref (g_type_class_peek (gst_bus_get_type ()));
1186   g_type_class_unref (g_type_class_peek (gst_task_get_type ()));
1187   g_type_class_unref (g_type_class_peek (gst_object_flags_get_type ()));
1188   g_type_class_unref (g_type_class_peek (gst_bin_flags_get_type ()));
1189   g_type_class_unref (g_type_class_peek (gst_buffer_flags_get_type ()));
1190   g_type_class_unref (g_type_class_peek (gst_buffer_copy_flags_get_type ()));
1191   g_type_class_unref (g_type_class_peek (gst_bus_flags_get_type ()));
1192   g_type_class_unref (g_type_class_peek (gst_bus_sync_reply_get_type ()));
1193   g_type_class_unref (g_type_class_peek (gst_caps_flags_get_type ()));
1194   g_type_class_unref (g_type_class_peek (gst_clock_type_get_type ()));
1195   g_type_class_unref (g_type_class_peek (gst_clock_return_get_type ()));
1196   g_type_class_unref (g_type_class_peek (gst_clock_entry_type_get_type ()));
1197   g_type_class_unref (g_type_class_peek (gst_clock_flags_get_type ()));
1198   g_type_class_unref (g_type_class_peek (gst_debug_graph_details_get_type ()));
1199   g_type_class_unref (g_type_class_peek (gst_state_get_type ()));
1200   g_type_class_unref (g_type_class_peek (gst_state_change_return_get_type ()));
1201   g_type_class_unref (g_type_class_peek (gst_state_change_get_type ()));
1202   g_type_class_unref (g_type_class_peek (gst_element_flags_get_type ()));
1203   g_type_class_unref (g_type_class_peek (gst_tracer_value_scope_get_type ()));
1204   g_type_class_unref (g_type_class_peek (gst_tracer_value_flags_get_type ()));
1205   g_type_class_unref (g_type_class_peek (gst_core_error_get_type ()));
1206   g_type_class_unref (g_type_class_peek (gst_library_error_get_type ()));
1207   g_type_class_unref (g_type_class_peek (gst_plugin_dependency_flags_get_type
1208           ()));
1209   g_type_class_unref (g_type_class_peek (gst_parse_flags_get_type ()));
1210   g_type_class_unref (g_type_class_peek (gst_resource_error_get_type ()));
1211   g_type_class_unref (g_type_class_peek (gst_search_mode_get_type ()));
1212   g_type_class_unref (g_type_class_peek (gst_stream_error_get_type ()));
1213   g_type_class_unref (g_type_class_peek (gst_stream_status_type_get_type ()));
1214   g_type_class_unref (g_type_class_peek (gst_structure_change_type_get_type
1215           ()));
1216   g_type_class_unref (g_type_class_peek (gst_event_type_flags_get_type ()));
1217   g_type_class_unref (g_type_class_peek (gst_event_type_get_type ()));
1218   g_type_class_unref (g_type_class_peek (gst_seek_type_get_type ()));
1219   g_type_class_unref (g_type_class_peek (gst_seek_flags_get_type ()));
1220   g_type_class_unref (g_type_class_peek (gst_qos_type_get_type ()));
1221   g_type_class_unref (g_type_class_peek (gst_format_get_type ()));
1222   g_type_class_unref (g_type_class_peek (gst_debug_level_get_type ()));
1223   g_type_class_unref (g_type_class_peek (gst_debug_color_flags_get_type ()));
1224   g_type_class_unref (g_type_class_peek (gst_iterator_result_get_type ()));
1225   g_type_class_unref (g_type_class_peek (gst_iterator_item_get_type ()));
1226   g_type_class_unref (g_type_class_peek (gst_message_type_get_type ()));
1227   g_type_class_unref (g_type_class_peek (gst_meta_flags_get_type ()));
1228   g_type_class_unref (g_type_class_peek (gst_mini_object_flags_get_type ()));
1229   g_type_class_unref (g_type_class_peek (gst_pad_link_return_get_type ()));
1230   g_type_class_unref (g_type_class_peek (gst_pad_link_check_get_type ()));
1231   g_type_class_unref (g_type_class_peek (gst_flow_return_get_type ()));
1232   g_type_class_unref (g_type_class_peek (gst_pad_mode_get_type ()));
1233   g_type_class_unref (g_type_class_peek (gst_pad_direction_get_type ()));
1234   g_type_class_unref (g_type_class_peek (gst_pad_flags_get_type ()));
1235   g_type_class_unref (g_type_class_peek (gst_pad_presence_get_type ()));
1236   g_type_class_unref (g_type_class_peek (gst_pad_template_flags_get_type ()));
1237   g_type_class_unref (g_type_class_peek (gst_pipeline_flags_get_type ()));
1238   g_type_class_unref (g_type_class_peek (gst_plugin_error_get_type ()));
1239   g_type_class_unref (g_type_class_peek (gst_plugin_flags_get_type ()));
1240   g_type_class_unref (g_type_class_peek (gst_rank_get_type ()));
1241   g_type_class_unref (g_type_class_peek (gst_query_type_flags_get_type ()));
1242   g_type_class_unref (g_type_class_peek (gst_query_type_get_type ()));
1243   g_type_class_unref (g_type_class_peek (gst_buffering_mode_get_type ()));
1244   g_type_class_unref (g_type_class_peek (gst_tag_merge_mode_get_type ()));
1245   g_type_class_unref (g_type_class_peek (gst_tag_flag_get_type ()));
1246   g_type_class_unref (g_type_class_peek (gst_tag_scope_get_type ()));
1247   g_type_class_unref (g_type_class_peek (gst_task_state_get_type ()));
1248   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1249   g_type_class_unref (g_type_class_peek (gst_toc_scope_get_type ()));
1250   g_type_class_unref (g_type_class_peek (gst_type_find_probability_get_type
1251           ()));
1252   g_type_class_unref (g_type_class_peek (gst_uri_type_get_type ()));
1253   g_type_class_unref (g_type_class_peek (gst_uri_error_get_type ()));
1254   g_type_class_unref (g_type_class_peek (gst_parse_error_get_type ()));
1255   g_type_class_unref (g_type_class_peek (gst_param_spec_fraction_get_type ()));
1256   g_type_class_unref (g_type_class_peek (gst_progress_type_get_type ()));
1257   g_type_class_unref (g_type_class_peek (gst_buffer_pool_acquire_flags_get_type
1258           ()));
1259   g_type_class_unref (g_type_class_peek (gst_memory_flags_get_type ()));
1260   g_type_class_unref (g_type_class_peek (gst_map_flags_get_type ()));
1261   g_type_class_unref (g_type_class_peek (gst_caps_intersect_mode_get_type ()));
1262   g_type_class_unref (g_type_class_peek (gst_pad_probe_type_get_type ()));
1263   g_type_class_unref (g_type_class_peek (gst_pad_probe_return_get_type ()));
1264   g_type_class_unref (g_type_class_peek (gst_segment_flags_get_type ()));
1265   g_type_class_unref (g_type_class_peek (gst_scheduling_flags_get_type ()));
1266   g_type_class_unref (g_type_class_peek (gst_stream_type_get_type ()));
1267 
1268   g_type_class_unref (g_type_class_peek (gst_control_binding_get_type ()));
1269   g_type_class_unref (g_type_class_peek (gst_control_source_get_type ()));
1270   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1271   g_type_class_unref (g_type_class_peek (gst_toc_loop_type_get_type ()));
1272   g_type_class_unref (g_type_class_peek (gst_lock_flags_get_type ()));
1273   g_type_class_unref (g_type_class_peek (gst_allocator_flags_get_type ()));
1274   g_type_class_unref (g_type_class_peek (gst_stream_flags_get_type ()));
1275   g_type_class_unref (g_type_class_peek (gst_debug_color_mode_get_type ()));
1276   g_type_class_unref (g_type_class_peek (gst_stack_trace_flags_get_type ()));
1277 #ifndef GSTREAMER_LITE
1278   g_type_class_unref (g_type_class_peek (gst_promise_result_get_type ()));
1279 #endif // GSTREAMER_LITE
1280 
1281   gst_deinitialized = TRUE;
1282   GST_INFO (&quot;deinitialized GStreamer&quot;);
1283 }
1284 
1285 /**
1286  * gst_version:
1287  * @major: (out): pointer to a guint to store the major version number
1288  * @minor: (out): pointer to a guint to store the minor version number
1289  * @micro: (out): pointer to a guint to store the micro version number
1290  * @nano:  (out): pointer to a guint to store the nano version number
1291  *
1292  * Gets the version number of the GStreamer library.
1293  */
1294 void
1295 gst_version (guint * major, guint * minor, guint * micro, guint * nano)
1296 {
1297   g_return_if_fail (major);
1298   g_return_if_fail (minor);
1299   g_return_if_fail (micro);
1300   g_return_if_fail (nano);
1301 
1302   *major = GST_VERSION_MAJOR;
1303   *minor = GST_VERSION_MINOR;
1304   *micro = GST_VERSION_MICRO;
1305   *nano = GST_VERSION_NANO;
1306 }
1307 
1308 /**
1309  * gst_version_string:
1310  *
1311  * This function returns a string that is useful for describing this version
1312  * of GStreamer to the outside world: user agent strings, logging, ...
1313  *
1314  * Returns: (transfer full): a newly allocated string describing this version
1315  *     of GStreamer.
1316  */
1317 
1318 gchar *
1319 gst_version_string (void)
1320 {
1321   guint major, minor, micro, nano;
1322 
1323   gst_version (&amp;major, &amp;minor, &amp;micro, &amp;nano);
1324   if (nano == 0)
1325     return g_strdup_printf (&quot;GStreamer %d.%d.%d&quot;, major, minor, micro);
1326   else if (nano == 1)
1327     return g_strdup_printf (&quot;GStreamer %d.%d.%d (GIT)&quot;, major, minor, micro);
1328   else
1329     return g_strdup_printf (&quot;GStreamer %d.%d.%d (prerelease)&quot;, major, minor,
1330         micro);
1331 }
1332 
1333 /**
1334  * gst_segtrap_is_enabled:
1335  *
1336  * Some functions in the GStreamer core might install a custom SIGSEGV handler
1337  * to better catch and report errors to the application. Currently this feature
1338  * is enabled by default when loading plugins.
1339  *
1340  * Applications might want to disable this behaviour with the
1341  * gst_segtrap_set_enabled() function. This is typically done if the application
1342  * wants to install its own handler without GStreamer interfering.
1343  *
1344  * Returns: %TRUE if GStreamer is allowed to install a custom SIGSEGV handler.
1345  */
1346 gboolean
1347 gst_segtrap_is_enabled (void)
1348 {
1349   /* yeps, it&#39;s enabled when it&#39;s not disabled */
1350   return !_gst_disable_segtrap;
1351 }
1352 
1353 /**
1354  * gst_segtrap_set_enabled:
1355  * @enabled: whether a custom SIGSEGV handler should be installed.
1356  *
1357  * Applications might want to disable/enable the SIGSEGV handling of
1358  * the GStreamer core. See gst_segtrap_is_enabled() for more information.
1359  */
1360 void
1361 gst_segtrap_set_enabled (gboolean enabled)
1362 {
1363   _gst_disable_segtrap = !enabled;
1364 }
    </pre>
  </body>
</html>