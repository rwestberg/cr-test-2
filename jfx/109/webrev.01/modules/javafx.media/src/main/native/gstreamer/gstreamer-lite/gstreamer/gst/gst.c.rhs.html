<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gst.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gst.c: Initialization and non-pipeline operations
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gst
  25  * @title: GStreamer
  26  * @short_description: Media library supporting arbitrary formats and filter
  27  *                     graphs.
  28  *
  29  * GStreamer is a framework for constructing graphs of various filters
  30  * (termed elements here) that will handle streaming media.  Any discrete
  31  * (packetizable) media type is supported, with provisions for automatically
  32  * determining source type.  Formatting/framing information is provided with
  33  * a powerful negotiation framework.  Plugins are heavily used to provide for
  34  * all elements, allowing one to construct plugins outside of the GST
  35  * library, even released binary-only if license require (please don&#39;t).
  36  * GStreamer covers a wide range of use cases including: playback, recording,
  37  * editing, serving streams, voice over ip and video calls.
  38  *
  39  * The &lt;application&gt;GStreamer&lt;/application&gt; library should be initialized with
  40  * gst_init() before it can be used. You should pass pointers to the main argc
  41  * and argv variables so that GStreamer can process its own command line
  42  * options, as shown in the following example.
  43  *
  44  * ## Initializing the gstreamer library
  45  *
  46  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  47  * int
  48  * main (int argc, char *argv[])
  49  * {
  50  *   // initialize the GStreamer library
  51  *   gst_init (&amp;amp;argc, &amp;amp;argv);
  52  *   ...
  53  * }
  54  * ]|
  55  *
  56  * It&#39;s allowed to pass two %NULL pointers to gst_init() in case you don&#39;t want
  57  * to pass the command line args to GStreamer.
  58  *
  59  * You can also use GOption to initialize your own parameters as shown in
  60  * the next code fragment:
  61  *
  62  * ## Initializing own parameters when initializing gstreamer
  63  * |[ &lt;!-- language=&quot;C&quot; --&gt;
  64  * static gboolean stats = FALSE;
  65  * ...
  66  * int
  67  * main (int argc, char *argv[])
  68  * {
  69  *  GOptionEntry options[] = {
  70  *   {&quot;tags&quot;, &#39;t&#39;, 0, G_OPTION_ARG_NONE, &amp;amp;tags,
  71  *       N_(&quot;Output tags (also known as metadata)&quot;), NULL},
  72  *   {NULL}
  73  *  };
  74  *  ctx = g_option_context_new (&quot;[ADDITIONAL ARGUMENTS]&quot;);
  75  *  g_option_context_add_main_entries (ctx, options, GETTEXT_PACKAGE);
  76  *  g_option_context_add_group (ctx, gst_init_get_option_group ());
  77  *  if (!g_option_context_parse (ctx, &amp;amp;argc, &amp;amp;argv, &amp;amp;err)) {
  78  *    g_print (&quot;Error initializing: &amp;percnt;s\n&quot;, GST_STR_NULL (err-&gt;message));
  79  *    exit (1);
  80  *  }
  81  *  g_option_context_free (ctx);
  82  * ...
  83  * }
  84  * ]|
  85  *
  86  * Use gst_version() to query the library version at runtime or use the
  87  * GST_VERSION_* macros to find the version at compile time. Optionally
  88  * gst_version_string() returns a printable string.
  89  *
  90  * The gst_deinit() call is used to clean up all internal resources used
  91  * by GStreamer. It is mostly used in unit tests to check for leaks.
  92  */
  93 
  94 #include &quot;gst_private.h&quot;
  95 #include &quot;gstconfig.h&quot;
  96 #include &lt;stdlib.h&gt;
  97 #include &lt;stdio.h&gt;
  98 #include &lt;sys/types.h&gt;
  99 #ifdef HAVE_SYS_UTSNAME_H
 100 #include &lt;sys/utsname.h&gt;
 101 #endif
 102 #ifdef HAVE_UNISTD_H
 103 #include &lt;unistd.h&gt;
 104 #endif
 105 #ifdef G_OS_WIN32
 106 #define WIN32_LEAN_AND_MEAN     /* prevents from including too many things */
 107 #include &lt;windows.h&gt;            /* GetStdHandle, windows console */
 108 #endif
 109 #if defined (__APPLE__)
 110 #include &quot;TargetConditionals.h&quot;
 111 #if !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 112 #include &lt;libproc.h&gt;            /* proc_pidpath, PROC_PIDPATHINFO_MAXSIZE */
 113 #endif
 114 #endif
 115 
 116 #if defined(GSTREAMER_LITE)
 117 #include &quot;gstplugins-lite.h&quot;
 118 #endif // GSTREAMER_LITE
 119 
 120 #include &quot;gst-i18n-lib.h&quot;
 121 #include &lt;locale.h&gt;             /* for LC_ALL */
 122 
 123 #include &quot;gst.h&quot;
 124 
<a name="1" id="anc1"></a><span class="line-added"> 125 #ifdef STATIC_BUILD</span>
<span class="line-added"> 126 gboolean fxplugins_init (GstPlugin * plugin);</span>
<span class="line-added"> 127 gboolean fxavplugins_init (GstPlugin * plugin);</span>
<span class="line-added"> 128 #endif</span>
<span class="line-added"> 129 </span>
 130 #define GST_CAT_DEFAULT GST_CAT_GST_INIT
 131 
 132 #define MAX_PATH_SPLIT  16
 133 #define GST_PLUGIN_SEPARATOR &quot;,&quot;
 134 
 135 static gboolean gst_initialized = FALSE;
 136 static gboolean gst_deinitialized = FALSE;
 137 
 138 GstClockTime _priv_gst_start_time;
 139 
 140 #ifdef G_OS_WIN32
 141 HMODULE _priv_gst_dll_handle = NULL;
 142 #endif
 143 
 144 #ifndef GST_DISABLE_REGISTRY
 145 GList *_priv_gst_plugin_paths = NULL;   /* for delayed processing in init_post */
 146 
 147 extern gboolean _priv_gst_disable_registry;
 148 extern gboolean _priv_gst_disable_registry_update;
 149 #endif
 150 
 151 gchar *_gst_executable_path = NULL;
 152 
 153 #ifndef GST_DISABLE_GST_DEBUG
 154 const gchar *priv_gst_dump_dot_dir;
 155 #endif
 156 
 157 /* defaults */
 158 
 159 /* set to TRUE when segfaults need to be left as is */
 160 static gboolean _gst_disable_segtrap = FALSE;
 161 
 162 static gboolean init_pre (GOptionContext * context, GOptionGroup * group,
 163     gpointer data, GError ** error);
 164 static gboolean init_post (GOptionContext * context, GOptionGroup * group,
 165     gpointer data, GError ** error);
 166 #ifndef GST_DISABLE_OPTION_PARSING
 167 static gboolean parse_goption_arg (const gchar * s_opt,
 168     const gchar * arg, gpointer data, GError ** err);
 169 #endif
 170 
 171 GSList *_priv_gst_preload_plugins = NULL;
 172 
 173 const gchar g_log_domain_gstreamer[] = &quot;GStreamer&quot;;
 174 
 175 static void
 176 debug_log_handler (const gchar * log_domain,
 177     GLogLevelFlags log_level, const gchar * message, gpointer user_data)
 178 {
 179   g_log_default_handler (log_domain, log_level, message, user_data);
 180   /* FIXME: do we still need this ? fatal errors these days are all
 181    * other than core errors */
 182   /* g_on_error_query (NULL); */
 183 }
 184 
 185 enum
 186 {
 187   ARG_VERSION = 1,
 188   ARG_FATAL_WARNINGS,
 189 #ifndef GST_DISABLE_GST_DEBUG
 190   ARG_DEBUG_LEVEL,
 191   ARG_DEBUG,
 192   ARG_DEBUG_DISABLE,
 193   ARG_DEBUG_NO_COLOR,
 194   ARG_DEBUG_COLOR_MODE,
 195   ARG_DEBUG_HELP,
 196 #endif
 197   ARG_PLUGIN_SPEW,
 198   ARG_PLUGIN_PATH,
 199   ARG_PLUGIN_LOAD,
 200   ARG_SEGTRAP_DISABLE,
 201   ARG_REGISTRY_UPDATE_DISABLE,
 202   ARG_REGISTRY_FORK_DISABLE
 203 };
 204 
 205 /* debug-spec ::= category-spec [, category-spec]*
 206  * category-spec ::= category:val | val
 207  * category ::= [^:]+
 208  * val ::= [0-5]
 209  */
 210 
 211 #ifndef GSTREAMER_LITE
 212 #ifdef G_OS_WIN32
 213 /* Note: DllMain is only called when DLLs are loaded or unloaded, so this will
 214  * never be called if libgstreamer-1.0 is linked statically. Do not add any code
 215  * here to, say, initialize variables or set things up since that will only
 216  * happen for dynamically-built GStreamer.
 217  *
 218  * Also, ideally this should not be defined when GStreamer is built statically.
 219  * i.e., it should be conditional on #ifdef DLL_EXPORT. It will be ignored, but
 220  * if other libraries make the same mistake of defining it when building
 221  * statically, there will be a symbol collision during linking. Fixing this
 222  * requires one to build two object files: one for static linking and another
 223  * for dynamic linking. */
 224 BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
 225 BOOL WINAPI
 226 DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 227 {
 228   if (fdwReason == DLL_PROCESS_ATTACH)
 229     _priv_gst_dll_handle = (HMODULE) hinstDLL;
 230   return TRUE;
 231 }
 232 
 233 #endif
 234 #endif // GSTREAMER_LITE
 235 
 236 /**
 237  * gst_init_get_option_group: (skip)
 238  *
 239  * Returns a #GOptionGroup with GStreamer&#39;s argument specifications. The
 240  * group is set up to use standard GOption callbacks, so when using this
 241  * group in combination with GOption parsing methods, all argument parsing
 242  * and initialization is automated.
 243  *
 244  * This function is useful if you want to integrate GStreamer with other
 245  * libraries that use GOption (see g_option_context_add_group() ).
 246  *
 247  * If you use this function, you should make sure you initialise the GLib
 248  * threading system as one of the very first things in your program
 249  * (see the example at the beginning of this section).
 250  *
 251  * Returns: (transfer full) (nullable): a pointer to GStreamer&#39;s option group.
 252  */
 253 
 254 GOptionGroup *
 255 gst_init_get_option_group (void)
 256 {
 257 #ifndef GST_DISABLE_OPTION_PARSING
 258   GOptionGroup *group;
 259   static const GOptionEntry gst_args[] = {
 260     {&quot;gst-version&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 261         (gpointer) parse_goption_arg, N_(&quot;Print the GStreamer version&quot;), NULL},
 262     {&quot;gst-fatal-warnings&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 263         (gpointer) parse_goption_arg, N_(&quot;Make all warnings fatal&quot;), NULL},
 264 #ifndef GST_DISABLE_GST_DEBUG
 265     {&quot;gst-debug-help&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 266           (gpointer) parse_goption_arg,
 267           N_(&quot;Print available debug categories and exit&quot;),
 268         NULL},
 269     {&quot;gst-debug-level&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 270           (gpointer) parse_goption_arg,
 271           N_(&quot;Default debug level from 1 (only error) to 9 (anything) or &quot;
 272               &quot;0 for no output&quot;),
 273         N_(&quot;LEVEL&quot;)},
 274     {&quot;gst-debug&quot;, 0, 0, G_OPTION_ARG_CALLBACK, (gpointer) parse_goption_arg,
 275           N_(&quot;Comma-separated list of category_name:level pairs to set &quot;
 276               &quot;specific levels for the individual categories. Example: &quot;
 277               &quot;GST_AUTOPLUG:5,GST_ELEMENT_*:3&quot;),
 278         N_(&quot;LIST&quot;)},
 279     {&quot;gst-debug-no-color&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 280           (gpointer) parse_goption_arg, N_(&quot;Disable colored debugging output&quot;),
 281         NULL},
 282     {&quot;gst-debug-color-mode&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 283           (gpointer) parse_goption_arg,
 284           N_(&quot;Changes coloring mode of the debug log. &quot;
 285               &quot;Possible modes: off, on, disable, auto, unix&quot;),
 286         NULL},
 287     {&quot;gst-debug-disable&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 288         (gpointer) parse_goption_arg, N_(&quot;Disable debugging&quot;), NULL},
 289 #endif
 290     {&quot;gst-plugin-spew&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 291           (gpointer) parse_goption_arg,
 292           N_(&quot;Enable verbose plugin loading diagnostics&quot;),
 293         NULL},
 294     {&quot;gst-plugin-path&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 295           (gpointer) parse_goption_arg,
 296         N_(&quot;Colon-separated paths containing plugins&quot;), N_(&quot;PATHS&quot;)},
 297     {&quot;gst-plugin-load&quot;, 0, 0, G_OPTION_ARG_CALLBACK,
 298           (gpointer) parse_goption_arg,
 299           N_(&quot;Comma-separated list of plugins to preload in addition to the &quot;
 300               &quot;list stored in environment variable GST_PLUGIN_PATH&quot;),
 301         N_(&quot;PLUGINS&quot;)},
 302     {&quot;gst-disable-segtrap&quot;, 0, G_OPTION_FLAG_NO_ARG, G_OPTION_ARG_CALLBACK,
 303           (gpointer) parse_goption_arg,
 304           N_(&quot;Disable trapping of segmentation faults during plugin loading&quot;),
 305         NULL},
 306     {&quot;gst-disable-registry-update&quot;, 0, G_OPTION_FLAG_NO_ARG,
 307           G_OPTION_ARG_CALLBACK,
 308           (gpointer) parse_goption_arg,
 309           N_(&quot;Disable updating the registry&quot;),
 310         NULL},
 311     {&quot;gst-disable-registry-fork&quot;, 0, G_OPTION_FLAG_NO_ARG,
 312           G_OPTION_ARG_CALLBACK,
 313           (gpointer) parse_goption_arg,
 314           N_(&quot;Disable spawning a helper process while scanning the registry&quot;),
 315         NULL},
 316     {NULL}
 317   };
 318 
 319   group = g_option_group_new (&quot;gst&quot;, _(&quot;GStreamer Options&quot;),
 320       _(&quot;Show GStreamer Options&quot;), NULL, NULL);
 321   g_option_group_set_parse_hooks (group, (GOptionParseFunc) init_pre,
 322       (GOptionParseFunc) init_post);
 323 
 324   g_option_group_add_entries (group, gst_args);
 325   g_option_group_set_translation_domain (group, GETTEXT_PACKAGE);
 326 
 327   return group;
 328 #else
 329   return NULL;
 330 #endif
 331 }
 332 
 333 #if defined(__linux__)
 334 static void
 335 find_executable_path (void)
 336 {
 337   GError *error = NULL;
 338 
 339   if (_gst_executable_path)
 340     return;
 341 
 342   _gst_executable_path = g_file_read_link (&quot;/proc/self/exe&quot;, &amp;error);
 343   if (error)
 344     g_error_free (error);
 345 }
 346 #elif defined(G_OS_WIN32)
 347 static void
 348 find_executable_path (void)
 349 {
 350   char buffer[MAX_PATH];
 351 
 352   if (!GetModuleFileName (NULL, buffer, MAX_PATH))
 353     return;
 354 
 355   _gst_executable_path = g_strdup (buffer);
 356 }
 357 #elif defined(__APPLE__) &amp;&amp; !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_EMBEDDED
 358 static void
 359 find_executable_path (void)
 360 {
 361   int ret;
 362   pid_t pid;
 363   char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
 364 
 365   pid = getpid ();
 366   ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));
 367   if (ret &gt; 0)
 368     _gst_executable_path = g_strdup (pathbuf);
 369 }
 370 #else
 371 static void
 372 find_executable_path (void)
 373 {
 374   GST_FIXME (&quot;Couldn&#39;t look up executable path, add support for this platform&quot;);
 375 }
 376 #endif
 377 
 378 /**
 379  * gst_get_main_executable_path:
 380  *
 381  * This helper is mostly helpful for plugins that need to
 382  * inspect the folder of the main executable to determine
 383  * their set of features.
 384  *
 385  * When a plugin is initialized from the gst-plugin-scanner
 386  * external process, the returned path will be the same as from the
 387  * parent process.
 388  *
 389  * Returns: (transfer none) (nullable): The path of the executable that
 390  *   initialized GStreamer, or %NULL if it could not be determined.
 391  *
 392  * Since: 1.14
 393  */
 394 const gchar *
 395 gst_get_main_executable_path (void)
 396 {
 397   return _gst_executable_path;
 398 }
 399 
 400 /**
 401  * gst_init_check:
 402  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 403  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 404  * @err: pointer to a #GError to which a message will be posted on error
 405  *
 406  * Initializes the GStreamer library, setting up internal path lists,
 407  * registering built-in elements, and loading standard plugins.
 408  *
 409  * This function will return %FALSE if GStreamer could not be initialized
 410  * for some reason.  If you want your program to fail fatally,
 411  * use gst_init() instead.
 412  *
 413  * Returns: %TRUE if GStreamer could be initialized.
 414  */
 415 gboolean
 416 gst_init_check (int *argc, char **argv[], GError ** err)
 417 {
 418   static GMutex init_lock;
 419 #ifndef GST_DISABLE_OPTION_PARSING
 420   GOptionGroup *group;
 421   GOptionContext *ctx;
 422 #endif
 423   gboolean res;
 424 
 425   g_mutex_lock (&amp;init_lock);
 426 
 427 #ifdef GSTREAMER_LITE
 428 #ifdef ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 429   #include &lt;crtdbg.h&gt;
 430 
 431   _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
 432   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
 433 #endif // ENABLE_VISUAL_STUDIO_MEMORY_LEAKS_DETECTION
 434 #endif // GSTREAMER_LITE
 435 
 436   if (gst_initialized) {
 437     GST_DEBUG (&quot;already initialized gst&quot;);
 438     g_mutex_unlock (&amp;init_lock);
 439     return TRUE;
 440   }
 441 #ifndef GST_DISABLE_OPTION_PARSING
 442   ctx = g_option_context_new (&quot;- GStreamer initialization&quot;);
 443   g_option_context_set_ignore_unknown_options (ctx, TRUE);
 444   g_option_context_set_help_enabled (ctx, FALSE);
 445   group = gst_init_get_option_group ();
 446   g_option_context_add_group (ctx, group);
 447   res = g_option_context_parse (ctx, argc, argv, err);
 448   g_option_context_free (ctx);
 449 #else
 450   init_pre (NULL, NULL, NULL, NULL);
 451   init_post (NULL, NULL, NULL, NULL);
 452   res = TRUE;
 453 #endif
 454 
 455   gst_initialized = res;
 456 
 457   g_mutex_unlock (&amp;init_lock);
 458 
 459   return res;
 460 }
 461 
 462 /**
 463  * gst_init:
 464  * @argc: (inout) (allow-none): pointer to application&#39;s argc
 465  * @argv: (inout) (array length=argc) (allow-none): pointer to application&#39;s argv
 466  *
 467  * Initializes the GStreamer library, setting up internal path lists,
 468  * registering built-in elements, and loading standard plugins.
 469  *
 470  * Unless the plugin registry is disabled at compile time, the registry will be
 471  * loaded. By default this will also check if the registry cache needs to be
 472  * updated and rescan all plugins if needed. See gst_update_registry() for
 473  * details and section
 474  * &lt;link linkend=&quot;gst-running&quot;&gt;Running GStreamer Applications&lt;/link&gt;
 475  * for how to disable automatic registry updates.
 476  *
 477  * &gt; This function will terminate your program if it was unable to initialize
 478  * &gt; GStreamer for some reason.  If you want your program to fall back,
 479  * &gt; use gst_init_check() instead.
 480  *
 481  * WARNING: This function does not work in the same way as corresponding
 482  * functions in other glib-style libraries, such as gtk_init\(\). In
 483  * particular, unknown command line options cause this function to
 484  * abort program execution.
 485  */
 486 void
 487 gst_init (int *argc, char **argv[])
 488 {
 489   GError *err = NULL;
 490 
 491   if (!gst_init_check (argc, argv, &amp;err)) {
 492     g_print (&quot;Could not initialize GStreamer: %s\n&quot;,
 493         err ? err-&gt;message : &quot;unknown error occurred&quot;);
 494     if (err) {
 495       g_error_free (err);
 496     }
 497     exit (1);
 498   }
 499 }
 500 
 501 /**
 502  * gst_is_initialized:
 503  *
 504  * Use this function to check if GStreamer has been initialized with gst_init()
 505  * or gst_init_check().
 506  *
 507  * Returns: %TRUE if initialization has been done, %FALSE otherwise.
 508  */
 509 gboolean
 510 gst_is_initialized (void)
 511 {
 512   return gst_initialized;
 513 }
 514 
 515 #ifndef GST_DISABLE_OPTION_PARSING
 516 #  ifndef GST_DISABLE_REGISTRY
 517 static void
 518 add_path_func (gpointer data, gpointer user_data)
 519 {
 520   GST_INFO (&quot;Adding plugin path: \&quot;%s\&quot;, will scan later&quot;, (gchar *) data);
 521   _priv_gst_plugin_paths =
 522       g_list_append (_priv_gst_plugin_paths, g_strdup (data));
 523 }
 524 #  endif
 525 #endif
 526 
 527 #ifndef GST_DISABLE_OPTION_PARSING
 528 static void
 529 prepare_for_load_plugin_func (gpointer data, gpointer user_data)
 530 {
 531   _priv_gst_preload_plugins =
 532       g_slist_prepend (_priv_gst_preload_plugins, g_strdup (data));
 533 }
 534 #endif
 535 
 536 #ifndef GST_DISABLE_OPTION_PARSING
 537 static void
 538 split_and_iterate (const gchar * stringlist, const gchar * separator,
 539     GFunc iterator, gpointer user_data)
 540 {
 541   gchar **strings;
 542   gint j = 0;
 543   gchar *lastlist = g_strdup (stringlist);
 544 
 545   while (lastlist) {
 546     strings = g_strsplit (lastlist, separator, MAX_PATH_SPLIT);
 547     g_free (lastlist);
 548     lastlist = NULL;
 549 
 550     while (strings[j]) {
 551       iterator (strings[j], user_data);
 552       if (++j == MAX_PATH_SPLIT) {
 553         lastlist = g_strdup (strings[j]);
 554         j = 0;
 555         break;
 556       }
 557     }
 558     g_strfreev (strings);
 559   }
 560 }
 561 #endif
 562 
 563 /* we have no fail cases yet, but maybe in the future */
 564 static gboolean
 565 init_pre (GOptionContext * context, GOptionGroup * group, gpointer data,
 566     GError ** error)
 567 {
 568   gchar *libdir;
 569   if (gst_initialized) {
 570     GST_DEBUG (&quot;already initialized&quot;);
 571     return TRUE;
 572   }
 573 
 574 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
 575   // We still need to call it due too bug in GLib
 576   g_type_init ();
 577 #endif // GSTREAMER_LITE
 578 
 579   find_executable_path ();
 580 
 581   _priv_gst_start_time = gst_util_get_timestamp ();
 582 
 583 #ifndef GST_DISABLE_GST_DEBUG
 584   _priv_gst_debug_init ();
 585   priv_gst_dump_dot_dir = g_getenv (&quot;GST_DEBUG_DUMP_DOT_DIR&quot;);
 586 #endif
 587 
 588 #ifdef ENABLE_NLS
 589   bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
 590   bind_textdomain_codeset (GETTEXT_PACKAGE, &quot;UTF-8&quot;);
 591 #endif /* ENABLE_NLS */
 592 
 593 #ifndef GSTREAMER_LITE
 594   /* This is the earliest we can make stuff show up in the logs.
 595    * So give some useful info about GStreamer here */
 596 #ifdef G_OS_WIN32
 597   {
 598     gchar *basedir =
 599         g_win32_get_package_installation_directory_of_module
 600         (_priv_gst_dll_handle);
 601 
 602     libdir = g_build_filename (basedir,
 603 #ifdef _DEBUG
 604         &quot;debug&quot;
 605 #endif
 606         &quot;lib&quot;, NULL);
 607     g_free (basedir);
 608   }
 609 #else
 610   libdir = g_strdup (LIBDIR);
 611 #endif
 612   GST_INFO (&quot;Initializing GStreamer Core Library version %s&quot;, VERSION);
 613   GST_INFO (&quot;Using library installed in %s&quot;, libdir);
 614   g_free (libdir);
 615 #endif // GSTREAMER_LITE
 616 
 617 #ifndef GST_DISABLE_REGISTRY
 618   {
 619     const gchar *disable_registry;
 620     if ((disable_registry = g_getenv (&quot;GST_REGISTRY_DISABLE&quot;))) {
 621       _priv_gst_disable_registry = (strcmp (disable_registry, &quot;yes&quot;) == 0);
 622     }
 623   }
 624 #endif
 625 
 626   /* Print some basic system details if possible (OS/architecture) */
 627 #ifdef HAVE_SYS_UTSNAME_H
 628   {
 629     struct utsname sys_details;
 630 
 631     if (uname (&amp;sys_details) == 0) {
 632       GST_INFO (&quot;%s %s %s %s %s&quot;, sys_details.sysname,
 633           sys_details.nodename, sys_details.release, sys_details.version,
 634           sys_details.machine);
 635     }
 636   }
 637 #endif
 638 
 639 #ifndef G_ATOMIC_LOCK_FREE
 640   GST_CAT_WARNING (GST_CAT_PERFORMANCE, &quot;GLib atomic operations are NOT &quot;
 641       &quot;implemented using real hardware atomic operations!&quot;);
 642 #endif
 643 
 644   return TRUE;
 645 }
 646 
 647 static gboolean
 648 gst_register_core_elements (GstPlugin * plugin)
 649 {
 650   /* register some standard builtin types */
 651   if (!gst_element_register (plugin, &quot;bin&quot;, GST_RANK_PRIMARY,
 652           GST_TYPE_BIN) ||
 653       !gst_element_register (plugin, &quot;pipeline&quot;, GST_RANK_PRIMARY,
 654           GST_TYPE_PIPELINE)
 655       )
 656     g_assert_not_reached ();
 657 
 658   return TRUE;
 659 }
 660 
 661 /*
 662  * this bit handles:
 663  * - initialization of threads if we use them
 664  * - log handler
 665  * - initial output
 666  * - initializes gst_format
 667  * - registers a bunch of types for gst_objects
 668  *
 669  * - we don&#39;t have cases yet where this fails, but in the future
 670  *   we might and then it&#39;s nice to be able to return that
 671  */
 672 static gboolean
 673 init_post (GOptionContext * context, GOptionGroup * group, gpointer data,
 674     GError ** error)
 675 {
 676   GLogLevelFlags llf;
 677 
 678   if (gst_initialized) {
 679     GST_DEBUG (&quot;already initialized&quot;);
 680     return TRUE;
 681   }
 682 
 683   llf = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL;
 684   g_log_set_handler (g_log_domain_gstreamer, llf, debug_log_handler, NULL);
 685 
 686   _priv_gst_mini_object_initialize ();
 687   _priv_gst_quarks_initialize ();
 688   _priv_gst_allocator_initialize ();
 689   _priv_gst_memory_initialize ();
 690   _priv_gst_format_initialize ();
 691   _priv_gst_query_initialize ();
 692   _priv_gst_structure_initialize ();
 693   _priv_gst_caps_initialize ();
 694   _priv_gst_caps_features_initialize ();
 695   _priv_gst_meta_initialize ();
 696   _priv_gst_message_initialize ();
 697 
 698   g_type_class_ref (gst_object_get_type ());
 699   g_type_class_ref (gst_pad_get_type ());
 700   g_type_class_ref (gst_element_factory_get_type ());
 701   g_type_class_ref (gst_element_get_type ());
 702   g_type_class_ref (gst_tracer_factory_get_type ());
 703   g_type_class_ref (gst_type_find_factory_get_type ());
 704   g_type_class_ref (gst_bin_get_type ());
 705   g_type_class_ref (gst_bus_get_type ());
 706   g_type_class_ref (gst_task_get_type ());
 707   g_type_class_ref (gst_clock_get_type ());
 708   g_type_class_ref (gst_debug_color_mode_get_type ());
 709 
 710   gst_uri_handler_get_type ();
 711 
 712   g_type_class_ref (gst_object_flags_get_type ());
 713   g_type_class_ref (gst_bin_flags_get_type ());
 714   g_type_class_ref (gst_buffer_flags_get_type ());
 715   g_type_class_ref (gst_buffer_copy_flags_get_type ());
 716   g_type_class_ref (gst_bus_flags_get_type ());
 717   g_type_class_ref (gst_bus_sync_reply_get_type ());
 718   g_type_class_ref (gst_caps_flags_get_type ());
 719   g_type_class_ref (gst_clock_return_get_type ());
 720   g_type_class_ref (gst_clock_entry_type_get_type ());
 721   g_type_class_ref (gst_clock_flags_get_type ());
 722   g_type_class_ref (gst_clock_type_get_type ());
 723   g_type_class_ref (gst_debug_graph_details_get_type ());
 724   g_type_class_ref (gst_state_get_type ());
 725   g_type_class_ref (gst_state_change_return_get_type ());
 726   g_type_class_ref (gst_state_change_get_type ());
 727   g_type_class_ref (gst_element_flags_get_type ());
 728   g_type_class_ref (gst_tracer_value_scope_get_type ());
 729   g_type_class_ref (gst_tracer_value_flags_get_type ());
 730   g_type_class_ref (gst_core_error_get_type ());
 731   g_type_class_ref (gst_library_error_get_type ());
 732   g_type_class_ref (gst_resource_error_get_type ());
 733   g_type_class_ref (gst_stream_error_get_type ());
 734   g_type_class_ref (gst_event_type_flags_get_type ());
 735   g_type_class_ref (gst_event_type_get_type ());
 736   g_type_class_ref (gst_seek_type_get_type ());
 737   g_type_class_ref (gst_seek_flags_get_type ());
 738   g_type_class_ref (gst_qos_type_get_type ());
 739   g_type_class_ref (gst_format_get_type ());
 740   g_type_class_ref (gst_debug_level_get_type ());
 741   g_type_class_ref (gst_debug_color_flags_get_type ());
 742   g_type_class_ref (gst_iterator_result_get_type ());
 743   g_type_class_ref (gst_iterator_item_get_type ());
 744   g_type_class_ref (gst_message_type_get_type ());
 745   g_type_class_ref (gst_mini_object_flags_get_type ());
 746   g_type_class_ref (gst_pad_link_return_get_type ());
 747   g_type_class_ref (gst_pad_link_check_get_type ());
 748   g_type_class_ref (gst_flow_return_get_type ());
 749   g_type_class_ref (gst_pad_mode_get_type ());
 750   g_type_class_ref (gst_pad_direction_get_type ());
 751   g_type_class_ref (gst_pad_flags_get_type ());
 752   g_type_class_ref (gst_pad_presence_get_type ());
 753   g_type_class_ref (gst_pad_template_flags_get_type ());
 754   g_type_class_ref (gst_pipeline_flags_get_type ());
 755   g_type_class_ref (gst_plugin_error_get_type ());
 756   g_type_class_ref (gst_plugin_flags_get_type ());
 757   g_type_class_ref (gst_plugin_dependency_flags_get_type ());
 758   g_type_class_ref (gst_rank_get_type ());
 759   g_type_class_ref (gst_query_type_flags_get_type ());
 760   g_type_class_ref (gst_query_type_get_type ());
 761   g_type_class_ref (gst_buffering_mode_get_type ());
 762   g_type_class_ref (gst_stream_status_type_get_type ());
 763   g_type_class_ref (gst_structure_change_type_get_type ());
 764   g_type_class_ref (gst_tag_merge_mode_get_type ());
 765   g_type_class_ref (gst_tag_flag_get_type ());
 766   g_type_class_ref (gst_tag_scope_get_type ());
 767   g_type_class_ref (gst_task_pool_get_type ());
 768   g_type_class_ref (gst_task_state_get_type ());
 769   g_type_class_ref (gst_toc_entry_type_get_type ());
 770   g_type_class_ref (gst_type_find_probability_get_type ());
 771   g_type_class_ref (gst_uri_error_get_type ());
 772   g_type_class_ref (gst_uri_type_get_type ());
 773   g_type_class_ref (gst_parse_error_get_type ());
 774   g_type_class_ref (gst_parse_flags_get_type ());
 775   g_type_class_ref (gst_search_mode_get_type ());
 776   g_type_class_ref (gst_progress_type_get_type ());
 777   g_type_class_ref (gst_buffer_pool_acquire_flags_get_type ());
 778   g_type_class_ref (gst_memory_flags_get_type ());
 779   g_type_class_ref (gst_map_flags_get_type ());
 780   g_type_class_ref (gst_caps_intersect_mode_get_type ());
 781   g_type_class_ref (gst_pad_probe_type_get_type ());
 782   g_type_class_ref (gst_pad_probe_return_get_type ());
 783   g_type_class_ref (gst_segment_flags_get_type ());
 784   g_type_class_ref (gst_scheduling_flags_get_type ());
 785   g_type_class_ref (gst_meta_flags_get_type ());
 786   g_type_class_ref (gst_toc_entry_type_get_type ());
 787   g_type_class_ref (gst_toc_scope_get_type ());
 788   g_type_class_ref (gst_toc_loop_type_get_type ());
 789   g_type_class_ref (gst_control_binding_get_type ());
 790   g_type_class_ref (gst_control_source_get_type ());
 791   g_type_class_ref (gst_lock_flags_get_type ());
 792   g_type_class_ref (gst_allocator_flags_get_type ());
 793   g_type_class_ref (gst_stream_flags_get_type ());
 794   g_type_class_ref (gst_stream_type_get_type ());
 795   g_type_class_ref (gst_stack_trace_flags_get_type ());
 796 #ifndef GSTREAMER_LITE
 797   g_type_class_ref (gst_promise_result_get_type ());
 798 #endif // GSTREAMER_LITE
 799 
 800   _priv_gst_event_initialize ();
 801   _priv_gst_buffer_initialize ();
 802   _priv_gst_buffer_list_initialize ();
 803   _priv_gst_sample_initialize ();
 804   _priv_gst_context_initialize ();
 805   _priv_gst_date_time_initialize ();
 806   _priv_gst_value_initialize ();
 807   _priv_gst_tag_initialize ();
 808   _priv_gst_toc_initialize ();
 809 
 810   g_type_class_ref (gst_param_spec_fraction_get_type ());
 811   gst_parse_context_get_type ();
 812 
 813   _priv_gst_plugin_initialize ();
 814 
 815   /* register core plugins */
 816   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 817       &quot;staticelements&quot;, &quot;core elements linked into the GStreamer library&quot;,
 818       gst_register_core_elements, VERSION, GST_LICENSE, PACKAGE,
 819       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
 820 
 821 #if defined(GSTREAMER_LITE)
 822   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,
 823       &quot;gstplugins-lite&quot;, &quot;gstplugins-lite&quot;,
 824       lite_plugins_init, VERSION, GST_LICENSE, PACKAGE,
 825       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
<a name="2" id="anc2"></a><span class="line-added"> 826 #ifdef STATIC_BUILD</span>
<span class="line-added"> 827   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,</span>
<span class="line-added"> 828       &quot;fxplugins&quot;, &quot;fxplugin&quot;,</span>
<span class="line-added"> 829       fxplugins_init, VERSION, GST_LICENSE, PACKAGE,</span>
<span class="line-added"> 830       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);</span>
<span class="line-added"> 831   gst_plugin_register_static (GST_VERSION_MAJOR, GST_VERSION_MINOR,</span>
<span class="line-added"> 832      &quot;fxavplugins&quot;, &quot;fxavplugin&quot;,</span>
<span class="line-added"> 833       fxavplugins_init, VERSION, GST_LICENSE, PACKAGE,</span>
<span class="line-added"> 834       GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);</span>
<span class="line-added"> 835 #endif // STATIC_BUILD</span>
 836 #endif // GSTREAMER_LITE
 837 
 838   /*
 839    * Any errors happening below this point are non-fatal, we therefore mark
 840    * gstreamer as being initialized, since it is the case from a plugin point of
 841    * view.
 842    *
 843    * If anything fails, it will be put back to %FALSE in gst_init_check().
 844    * This allows some special plugins that would call gst_init() to not cause a
 845    * looping effect (i.e. initializing GStreamer twice).
 846    */
 847   gst_initialized = TRUE;
 848 
 849   if (!gst_update_registry ())
 850     return FALSE;
 851 
 852   GST_INFO (&quot;GLib runtime version: %d.%d.%d&quot;, glib_major_version,
 853       glib_minor_version, glib_micro_version);
 854   GST_INFO (&quot;GLib headers version: %d.%d.%d&quot;, GLIB_MAJOR_VERSION,
 855       GLIB_MINOR_VERSION, GLIB_MICRO_VERSION);
 856   GST_INFO (&quot;initialized GStreamer successfully&quot;);
 857 
 858 #ifndef GST_DISABLE_GST_DEBUG
 859   _priv_gst_tracing_init ();
 860 #endif
 861 
 862   return TRUE;
 863 }
 864 
 865 #ifndef GST_DISABLE_OPTION_PARSING
 866 #  ifndef GST_DISABLE_GST_DEBUG
 867 static gboolean
 868 select_all (GstPlugin * plugin, gpointer user_data)
 869 {
 870   return TRUE;
 871 }
 872 
 873 static gint
 874 sort_by_category_name (gconstpointer a, gconstpointer b)
 875 {
 876   return strcmp (gst_debug_category_get_name ((GstDebugCategory *) a),
 877       gst_debug_category_get_name ((GstDebugCategory *) b));
 878 }
 879 
 880 static void
 881 gst_debug_help (void)
 882 {
 883   GSList *list, *walk;
 884   GList *list2, *g;
 885 
 886   /* Need to ensure the registry is loaded to get debug categories */
 887   if (!init_post (NULL, NULL, NULL, NULL))
 888     exit (1);
 889 
 890   list2 = gst_registry_plugin_filter (gst_registry_get (),
 891       select_all, FALSE, NULL);
 892 
 893   /* FIXME this is gross.  why don&#39;t debug have categories PluginFeatures? */
 894   for (g = list2; g; g = g_list_next (g)) {
 895     GstPlugin *plugin = GST_PLUGIN_CAST (g-&gt;data);
 896     GList *features, *orig_features;
 897 
 898     if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED))
 899       continue;
 900 
 901     gst_plugin_load (plugin);
 902     /* Now create one of each feature so the class_init functions
 903      * are called, as that&#39;s where most debug categories are
 904      * registered. FIXME: If debug categories were a plugin feature,
 905      * this would be unneeded */
 906     orig_features = features =
 907         gst_registry_get_feature_list_by_plugin (gst_registry_get (),
 908         gst_plugin_get_name (plugin));
 909     while (features) {
 910       GstPluginFeature *feature;
 911 
 912       if (G_UNLIKELY (features-&gt;data == NULL))
 913         goto next;
 914 
 915       feature = GST_PLUGIN_FEATURE (features-&gt;data);
 916       if (GST_IS_ELEMENT_FACTORY (feature)) {
 917         GstElementFactory *factory;
 918         GstElement *e;
 919 
 920         factory = GST_ELEMENT_FACTORY (feature);
 921         e = gst_element_factory_create (factory, NULL);
 922         if (e)
 923           gst_object_unref (e);
 924       }
 925 
 926     next:
 927       features = g_list_next (features);
 928     }
 929 
 930     gst_plugin_feature_list_free (orig_features);
 931   }
 932   g_list_free (list2);
 933 
 934   list = gst_debug_get_all_categories ();
 935   walk = list = g_slist_sort (list, sort_by_category_name);
 936 
 937   g_print (&quot;\n&quot;);
 938   g_print (&quot;name                  level    description\n&quot;);
 939   g_print (&quot;---------------------+--------+--------------------------------\n&quot;);
 940 
 941   while (walk) {
 942     gboolean on_unix;
 943     GstDebugCategory *cat = (GstDebugCategory *) walk-&gt;data;
 944     GstDebugColorMode coloring = gst_debug_get_color_mode ();
 945 #ifdef G_OS_UNIX
 946     on_unix = TRUE;
 947 #else
 948     on_unix = FALSE;
 949 #endif
 950 
 951     if (GST_DEBUG_COLOR_MODE_UNIX == coloring
 952         || (on_unix &amp;&amp; GST_DEBUG_COLOR_MODE_ON == coloring)) {
 953       gchar *color = gst_debug_construct_term_color (cat-&gt;color);
 954 
 955       g_print (&quot;%s%-20s\033[00m  %1d %s  %s%s\033[00m\n&quot;,
 956           color,
 957           gst_debug_category_get_name (cat),
 958           gst_debug_category_get_threshold (cat),
 959           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 960           color, gst_debug_category_get_description (cat));
 961       g_free (color);
 962     } else if (GST_DEBUG_COLOR_MODE_ON == coloring &amp;&amp; !on_unix) {
 963 #ifdef G_OS_WIN32
 964       gint color = gst_debug_construct_win_color (cat-&gt;color);
 965       const gint clear = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
 966 
 967       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 968       g_print (&quot;%-20s&quot;, gst_debug_category_get_name (cat));
 969       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 970       g_print (&quot; %1d %s &quot;, gst_debug_category_get_threshold (cat),
 971           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)));
 972       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), color);
 973       g_print (&quot;%s&quot;, gst_debug_category_get_description (cat));
 974       SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), clear);
 975       g_print (&quot;\n&quot;);
 976 #endif /* G_OS_WIN32 */
 977     } else {
 978       g_print (&quot;%-20s  %1d %s  %s\n&quot;, gst_debug_category_get_name (cat),
 979           gst_debug_category_get_threshold (cat),
 980           gst_debug_level_get_name (gst_debug_category_get_threshold (cat)),
 981           gst_debug_category_get_description (cat));
 982     }
 983     walk = g_slist_next (walk);
 984   }
 985   g_slist_free (list);
 986   g_print (&quot;\n&quot;);
 987 }
 988 #  endif /* GST_DISABLE_OPTION_PARSING */
 989 #endif /* GST_DISABLE_GST_DEBUG */
 990 
 991 #ifndef GST_DISABLE_OPTION_PARSING
 992 static gboolean
 993 parse_one_option (gint opt, const gchar * arg, GError ** err)
 994 {
 995   switch (opt) {
 996     case ARG_VERSION:
 997       g_print (&quot;GStreamer Core Library version %s\n&quot;, PACKAGE_VERSION);
 998       exit (0);
 999     case ARG_FATAL_WARNINGS:{
1000       GLogLevelFlags fatal_mask;
1001 
1002       fatal_mask = g_log_set_always_fatal (G_LOG_FATAL_MASK);
1003       fatal_mask |= G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL;
1004       g_log_set_always_fatal (fatal_mask);
1005       break;
1006     }
1007 #ifndef GST_DISABLE_GST_DEBUG
1008     case ARG_DEBUG_LEVEL:{
1009       GstDebugLevel tmp = GST_LEVEL_NONE;
1010 
1011       tmp = (GstDebugLevel) strtol (arg, NULL, 0);
1012       if (((guint) tmp) &lt; GST_LEVEL_COUNT) {
1013         gst_debug_set_default_threshold (tmp);
1014       }
1015       break;
1016     }
1017     case ARG_DEBUG:
1018       gst_debug_set_threshold_from_string (arg, FALSE);
1019       break;
1020     case ARG_DEBUG_NO_COLOR:
1021       gst_debug_set_colored (FALSE);
1022       break;
1023     case ARG_DEBUG_COLOR_MODE:
1024       gst_debug_set_color_mode_from_string (arg);
1025       break;
1026     case ARG_DEBUG_DISABLE:
1027       gst_debug_set_active (FALSE);
1028       break;
1029     case ARG_DEBUG_HELP:
1030       gst_debug_help ();
1031       exit (0);
1032 #endif
1033     case ARG_PLUGIN_SPEW:
1034       break;
1035     case ARG_PLUGIN_PATH:
1036 #ifndef GST_DISABLE_REGISTRY
1037       if (!_priv_gst_disable_registry)
1038         split_and_iterate (arg, G_SEARCHPATH_SEPARATOR_S, add_path_func, NULL);
1039 #endif /* GST_DISABLE_REGISTRY */
1040       break;
1041     case ARG_PLUGIN_LOAD:
1042       split_and_iterate (arg, &quot;,&quot;, prepare_for_load_plugin_func, NULL);
1043       break;
1044     case ARG_SEGTRAP_DISABLE:
1045       _gst_disable_segtrap = TRUE;
1046       break;
1047     case ARG_REGISTRY_UPDATE_DISABLE:
1048 #ifndef GST_DISABLE_REGISTRY
1049       if (!_priv_gst_disable_registry)
1050         _priv_gst_disable_registry_update = TRUE;
1051 #endif
1052       break;
1053     case ARG_REGISTRY_FORK_DISABLE:
1054       gst_registry_fork_set_enabled (FALSE);
1055       break;
1056     default:
1057       g_set_error (err, G_OPTION_ERROR, G_OPTION_ERROR_UNKNOWN_OPTION,
1058           _(&quot;Unknown option&quot;));
1059       return FALSE;
1060   }
1061 
1062   return TRUE;
1063 }
1064 
1065 static gboolean
1066 parse_goption_arg (const gchar * opt,
1067     const gchar * arg, gpointer data, GError ** err)
1068 {
1069   static const struct
1070   {
1071     const gchar *opt;
1072     int val;
1073   } options[] = {
1074     {
1075     &quot;--gst-version&quot;, ARG_VERSION}, {
1076     &quot;--gst-fatal-warnings&quot;, ARG_FATAL_WARNINGS},
1077 #ifndef GST_DISABLE_GST_DEBUG
1078     {
1079     &quot;--gst-debug-level&quot;, ARG_DEBUG_LEVEL}, {
1080     &quot;--gst-debug&quot;, ARG_DEBUG}, {
1081     &quot;--gst-debug-disable&quot;, ARG_DEBUG_DISABLE}, {
1082     &quot;--gst-debug-no-color&quot;, ARG_DEBUG_NO_COLOR}, {
1083     &quot;--gst-debug-color-mode&quot;, ARG_DEBUG_COLOR_MODE}, {
1084     &quot;--gst-debug-help&quot;, ARG_DEBUG_HELP},
1085 #endif
1086     {
1087     &quot;--gst-plugin-spew&quot;, ARG_PLUGIN_SPEW}, {
1088     &quot;--gst-plugin-path&quot;, ARG_PLUGIN_PATH}, {
1089     &quot;--gst-plugin-load&quot;, ARG_PLUGIN_LOAD}, {
1090     &quot;--gst-disable-segtrap&quot;, ARG_SEGTRAP_DISABLE}, {
1091     &quot;--gst-disable-registry-update&quot;, ARG_REGISTRY_UPDATE_DISABLE}, {
1092     &quot;--gst-disable-registry-fork&quot;, ARG_REGISTRY_FORK_DISABLE}, {
1093     NULL}
1094   };
1095   gint val = 0, n;
1096 
1097   for (n = 0; options[n].opt; n++) {
1098     if (!strcmp (opt, options[n].opt)) {
1099       val = options[n].val;
1100       break;
1101     }
1102   }
1103 
1104   return parse_one_option (val, arg, err);
1105 }
1106 #endif
1107 
1108 /**
1109  * gst_deinit:
1110  *
1111  * Clean up any resources created by GStreamer in gst_init().
1112  *
1113  * It is normally not needed to call this function in a normal application
1114  * as the resources will automatically be freed when the program terminates.
1115  * This function is therefore mostly used by testsuites and other memory
1116  * profiling tools.
1117  *
1118  * After this call GStreamer (including this method) should not be used anymore.
1119  */
1120 void
1121 gst_deinit (void)
1122 {
1123   GstBinClass *bin_class;
1124   GstClock *clock;
1125 
1126   if (!gst_initialized)
1127     return;
1128 
1129   GST_INFO (&quot;deinitializing GStreamer&quot;);
1130 
1131   if (gst_deinitialized) {
1132     GST_DEBUG (&quot;already deinitialized&quot;);
1133     return;
1134   }
1135   g_thread_pool_set_max_unused_threads (0);
1136   bin_class = (GstBinClass *) g_type_class_peek (gst_bin_get_type ());
1137   if (bin_class &amp;&amp; bin_class-&gt;pool != NULL) {
1138     g_thread_pool_free (bin_class-&gt;pool, FALSE, TRUE);
1139     bin_class-&gt;pool = NULL;
1140   }
1141   gst_task_cleanup_all ();
1142 
1143   g_slist_foreach (_priv_gst_preload_plugins, (GFunc) g_free, NULL);
1144   g_slist_free (_priv_gst_preload_plugins);
1145   _priv_gst_preload_plugins = NULL;
1146 
1147 #ifndef GST_DISABLE_REGISTRY
1148   g_list_foreach (_priv_gst_plugin_paths, (GFunc) g_free, NULL);
1149   g_list_free (_priv_gst_plugin_paths);
1150   _priv_gst_plugin_paths = NULL;
1151 #endif
1152 
1153   if (_gst_executable_path) {
1154     g_free (_gst_executable_path);
1155     _gst_executable_path = NULL;
1156   }
1157 
1158   clock = gst_system_clock_obtain ();
1159   gst_object_unref (clock);
1160   gst_object_unref (clock);
1161 
1162   _priv_gst_registry_cleanup ();
1163   _priv_gst_allocator_cleanup ();
1164 
1165   /* We want to destroy tracers as late as possible for the leaks tracer
1166    * but still need to keep the caps system alive as it may have to use
1167    * gst_caps_to_string() to display leaked caps. */
1168 #ifndef GST_DISABLE_GST_DEBUG
1169   _priv_gst_tracing_deinit ();
1170 #endif
1171 
1172   _priv_gst_caps_features_cleanup ();
1173   _priv_gst_caps_cleanup ();
1174   _priv_gst_debug_cleanup ();
1175 
1176   g_type_class_unref (g_type_class_peek (gst_object_get_type ()));
1177   g_type_class_unref (g_type_class_peek (gst_pad_get_type ()));
1178   g_type_class_unref (g_type_class_peek (gst_element_factory_get_type ()));
1179   g_type_class_unref (g_type_class_peek (gst_element_get_type ()));
1180   g_type_class_unref (g_type_class_peek (gst_tracer_factory_get_type ()));
1181   g_type_class_unref (g_type_class_peek (gst_type_find_factory_get_type ()));
1182   g_type_class_unref (g_type_class_peek (gst_bin_get_type ()));
1183   g_type_class_unref (g_type_class_peek (gst_bus_get_type ()));
1184   g_type_class_unref (g_type_class_peek (gst_task_get_type ()));
1185   g_type_class_unref (g_type_class_peek (gst_object_flags_get_type ()));
1186   g_type_class_unref (g_type_class_peek (gst_bin_flags_get_type ()));
1187   g_type_class_unref (g_type_class_peek (gst_buffer_flags_get_type ()));
1188   g_type_class_unref (g_type_class_peek (gst_buffer_copy_flags_get_type ()));
1189   g_type_class_unref (g_type_class_peek (gst_bus_flags_get_type ()));
1190   g_type_class_unref (g_type_class_peek (gst_bus_sync_reply_get_type ()));
1191   g_type_class_unref (g_type_class_peek (gst_caps_flags_get_type ()));
1192   g_type_class_unref (g_type_class_peek (gst_clock_type_get_type ()));
1193   g_type_class_unref (g_type_class_peek (gst_clock_return_get_type ()));
1194   g_type_class_unref (g_type_class_peek (gst_clock_entry_type_get_type ()));
1195   g_type_class_unref (g_type_class_peek (gst_clock_flags_get_type ()));
1196   g_type_class_unref (g_type_class_peek (gst_debug_graph_details_get_type ()));
1197   g_type_class_unref (g_type_class_peek (gst_state_get_type ()));
1198   g_type_class_unref (g_type_class_peek (gst_state_change_return_get_type ()));
1199   g_type_class_unref (g_type_class_peek (gst_state_change_get_type ()));
1200   g_type_class_unref (g_type_class_peek (gst_element_flags_get_type ()));
1201   g_type_class_unref (g_type_class_peek (gst_tracer_value_scope_get_type ()));
1202   g_type_class_unref (g_type_class_peek (gst_tracer_value_flags_get_type ()));
1203   g_type_class_unref (g_type_class_peek (gst_core_error_get_type ()));
1204   g_type_class_unref (g_type_class_peek (gst_library_error_get_type ()));
1205   g_type_class_unref (g_type_class_peek (gst_plugin_dependency_flags_get_type
1206           ()));
1207   g_type_class_unref (g_type_class_peek (gst_parse_flags_get_type ()));
1208   g_type_class_unref (g_type_class_peek (gst_resource_error_get_type ()));
1209   g_type_class_unref (g_type_class_peek (gst_search_mode_get_type ()));
1210   g_type_class_unref (g_type_class_peek (gst_stream_error_get_type ()));
1211   g_type_class_unref (g_type_class_peek (gst_stream_status_type_get_type ()));
1212   g_type_class_unref (g_type_class_peek (gst_structure_change_type_get_type
1213           ()));
1214   g_type_class_unref (g_type_class_peek (gst_event_type_flags_get_type ()));
1215   g_type_class_unref (g_type_class_peek (gst_event_type_get_type ()));
1216   g_type_class_unref (g_type_class_peek (gst_seek_type_get_type ()));
1217   g_type_class_unref (g_type_class_peek (gst_seek_flags_get_type ()));
1218   g_type_class_unref (g_type_class_peek (gst_qos_type_get_type ()));
1219   g_type_class_unref (g_type_class_peek (gst_format_get_type ()));
1220   g_type_class_unref (g_type_class_peek (gst_debug_level_get_type ()));
1221   g_type_class_unref (g_type_class_peek (gst_debug_color_flags_get_type ()));
1222   g_type_class_unref (g_type_class_peek (gst_iterator_result_get_type ()));
1223   g_type_class_unref (g_type_class_peek (gst_iterator_item_get_type ()));
1224   g_type_class_unref (g_type_class_peek (gst_message_type_get_type ()));
1225   g_type_class_unref (g_type_class_peek (gst_meta_flags_get_type ()));
1226   g_type_class_unref (g_type_class_peek (gst_mini_object_flags_get_type ()));
1227   g_type_class_unref (g_type_class_peek (gst_pad_link_return_get_type ()));
1228   g_type_class_unref (g_type_class_peek (gst_pad_link_check_get_type ()));
1229   g_type_class_unref (g_type_class_peek (gst_flow_return_get_type ()));
1230   g_type_class_unref (g_type_class_peek (gst_pad_mode_get_type ()));
1231   g_type_class_unref (g_type_class_peek (gst_pad_direction_get_type ()));
1232   g_type_class_unref (g_type_class_peek (gst_pad_flags_get_type ()));
1233   g_type_class_unref (g_type_class_peek (gst_pad_presence_get_type ()));
1234   g_type_class_unref (g_type_class_peek (gst_pad_template_flags_get_type ()));
1235   g_type_class_unref (g_type_class_peek (gst_pipeline_flags_get_type ()));
1236   g_type_class_unref (g_type_class_peek (gst_plugin_error_get_type ()));
1237   g_type_class_unref (g_type_class_peek (gst_plugin_flags_get_type ()));
1238   g_type_class_unref (g_type_class_peek (gst_rank_get_type ()));
1239   g_type_class_unref (g_type_class_peek (gst_query_type_flags_get_type ()));
1240   g_type_class_unref (g_type_class_peek (gst_query_type_get_type ()));
1241   g_type_class_unref (g_type_class_peek (gst_buffering_mode_get_type ()));
1242   g_type_class_unref (g_type_class_peek (gst_tag_merge_mode_get_type ()));
1243   g_type_class_unref (g_type_class_peek (gst_tag_flag_get_type ()));
1244   g_type_class_unref (g_type_class_peek (gst_tag_scope_get_type ()));
1245   g_type_class_unref (g_type_class_peek (gst_task_state_get_type ()));
1246   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1247   g_type_class_unref (g_type_class_peek (gst_toc_scope_get_type ()));
1248   g_type_class_unref (g_type_class_peek (gst_type_find_probability_get_type
1249           ()));
1250   g_type_class_unref (g_type_class_peek (gst_uri_type_get_type ()));
1251   g_type_class_unref (g_type_class_peek (gst_uri_error_get_type ()));
1252   g_type_class_unref (g_type_class_peek (gst_parse_error_get_type ()));
1253   g_type_class_unref (g_type_class_peek (gst_param_spec_fraction_get_type ()));
1254   g_type_class_unref (g_type_class_peek (gst_progress_type_get_type ()));
1255   g_type_class_unref (g_type_class_peek (gst_buffer_pool_acquire_flags_get_type
1256           ()));
1257   g_type_class_unref (g_type_class_peek (gst_memory_flags_get_type ()));
1258   g_type_class_unref (g_type_class_peek (gst_map_flags_get_type ()));
1259   g_type_class_unref (g_type_class_peek (gst_caps_intersect_mode_get_type ()));
1260   g_type_class_unref (g_type_class_peek (gst_pad_probe_type_get_type ()));
1261   g_type_class_unref (g_type_class_peek (gst_pad_probe_return_get_type ()));
1262   g_type_class_unref (g_type_class_peek (gst_segment_flags_get_type ()));
1263   g_type_class_unref (g_type_class_peek (gst_scheduling_flags_get_type ()));
1264   g_type_class_unref (g_type_class_peek (gst_stream_type_get_type ()));
1265 
1266   g_type_class_unref (g_type_class_peek (gst_control_binding_get_type ()));
1267   g_type_class_unref (g_type_class_peek (gst_control_source_get_type ()));
1268   g_type_class_unref (g_type_class_peek (gst_toc_entry_type_get_type ()));
1269   g_type_class_unref (g_type_class_peek (gst_toc_loop_type_get_type ()));
1270   g_type_class_unref (g_type_class_peek (gst_lock_flags_get_type ()));
1271   g_type_class_unref (g_type_class_peek (gst_allocator_flags_get_type ()));
1272   g_type_class_unref (g_type_class_peek (gst_stream_flags_get_type ()));
1273   g_type_class_unref (g_type_class_peek (gst_debug_color_mode_get_type ()));
1274   g_type_class_unref (g_type_class_peek (gst_stack_trace_flags_get_type ()));
1275 #ifndef GSTREAMER_LITE
1276   g_type_class_unref (g_type_class_peek (gst_promise_result_get_type ()));
1277 #endif // GSTREAMER_LITE
1278 
1279   gst_deinitialized = TRUE;
1280   GST_INFO (&quot;deinitialized GStreamer&quot;);
1281 }
1282 
1283 /**
1284  * gst_version:
1285  * @major: (out): pointer to a guint to store the major version number
1286  * @minor: (out): pointer to a guint to store the minor version number
1287  * @micro: (out): pointer to a guint to store the micro version number
1288  * @nano:  (out): pointer to a guint to store the nano version number
1289  *
1290  * Gets the version number of the GStreamer library.
1291  */
1292 void
1293 gst_version (guint * major, guint * minor, guint * micro, guint * nano)
1294 {
1295   g_return_if_fail (major);
1296   g_return_if_fail (minor);
1297   g_return_if_fail (micro);
1298   g_return_if_fail (nano);
1299 
1300   *major = GST_VERSION_MAJOR;
1301   *minor = GST_VERSION_MINOR;
1302   *micro = GST_VERSION_MICRO;
1303   *nano = GST_VERSION_NANO;
1304 }
1305 
1306 /**
1307  * gst_version_string:
1308  *
1309  * This function returns a string that is useful for describing this version
1310  * of GStreamer to the outside world: user agent strings, logging, ...
1311  *
1312  * Returns: (transfer full): a newly allocated string describing this version
1313  *     of GStreamer.
1314  */
1315 
1316 gchar *
1317 gst_version_string (void)
1318 {
1319   guint major, minor, micro, nano;
1320 
1321   gst_version (&amp;major, &amp;minor, &amp;micro, &amp;nano);
1322   if (nano == 0)
1323     return g_strdup_printf (&quot;GStreamer %d.%d.%d&quot;, major, minor, micro);
1324   else if (nano == 1)
1325     return g_strdup_printf (&quot;GStreamer %d.%d.%d (GIT)&quot;, major, minor, micro);
1326   else
1327     return g_strdup_printf (&quot;GStreamer %d.%d.%d (prerelease)&quot;, major, minor,
1328         micro);
1329 }
1330 
1331 /**
1332  * gst_segtrap_is_enabled:
1333  *
1334  * Some functions in the GStreamer core might install a custom SIGSEGV handler
1335  * to better catch and report errors to the application. Currently this feature
1336  * is enabled by default when loading plugins.
1337  *
1338  * Applications might want to disable this behaviour with the
1339  * gst_segtrap_set_enabled() function. This is typically done if the application
1340  * wants to install its own handler without GStreamer interfering.
1341  *
1342  * Returns: %TRUE if GStreamer is allowed to install a custom SIGSEGV handler.
1343  */
1344 gboolean
1345 gst_segtrap_is_enabled (void)
1346 {
1347   /* yeps, it&#39;s enabled when it&#39;s not disabled */
1348   return !_gst_disable_segtrap;
1349 }
1350 
1351 /**
1352  * gst_segtrap_set_enabled:
1353  * @enabled: whether a custom SIGSEGV handler should be installed.
1354  *
1355  * Applications might want to disable/enable the SIGSEGV handling of
1356  * the GStreamer core. See gst_segtrap_is_enabled() for more information.
1357  */
1358 void
1359 gst_segtrap_set_enabled (gboolean enabled)
1360 {
1361   _gst_disable_segtrap = !enabled;
1362 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>