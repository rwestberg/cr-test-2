<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/TableViewBehaviorBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.scene.control.behavior;
  27 
  28 import com.sun.javafx.scene.control.SizeLimitedList;
  29 import javafx.collections.ListChangeListener;
  30 import javafx.collections.ObservableList;
  31 import javafx.collections.WeakListChangeListener;
  32 import javafx.event.EventHandler;
  33 import javafx.geometry.NodeOrientation;
  34 import javafx.scene.control.*;
  35 import com.sun.javafx.scene.control.inputmap.InputMap;
  36 import com.sun.javafx.scene.control.inputmap.KeyBinding;
  37 import javafx.scene.input.KeyEvent;
  38 import javafx.scene.input.MouseEvent;
  39 import javafx.util.Callback;
  40 import java.util.ArrayList;
  41 import java.util.List;
  42 import com.sun.javafx.PlatformUtil;
  43 import static javafx.scene.input.KeyCode.*;
  44 import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
  45 
  46 public abstract class TableViewBehaviorBase&lt;C extends Control, T, TC extends TableColumnBase&lt;T,?&gt;&gt; extends BehaviorBase&lt;C&gt; {
  47 
  48     /**************************************************************************
  49      *                                                                        *
  50      * Internal fields                                                        *
  51      *                                                                        *
  52      *************************************************************************/
  53 
  54     private final InputMap&lt;C&gt; tableViewInputMap;
  55 
  56     protected boolean isShortcutDown = false;
  57     protected boolean isShiftDown = false;
  58     private boolean selectionPathDeviated = false;
  59     protected boolean selectionChanging = false;
  60 
  61     private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
  62         if (!e.isConsumed()) {
  63             // RT-12751: we want to keep an eye on the user holding down the shift key,
  64             // so that we know when they enter/leave multiple selection mode. This
  65             // changes what happens when certain key combinations are pressed.
  66             isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
  67             isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
  68         }
  69     };
  70 
  71     private final SizeLimitedList&lt;TablePositionBase&gt; selectionHistory = new SizeLimitedList&lt;&gt;(10);
  72 
  73     protected final ListChangeListener&lt;TablePositionBase&gt; selectedCellsListener = c -&gt; {
  74         while (c.next()) {
  75             if (c.wasReplaced()) {
  76                 if (TreeTableCellBehavior.hasDefaultAnchor(getNode())) {
  77                     TreeTableCellBehavior.removeAnchor(getNode());
  78                 }
  79             }
  80 
  81             if (! c.wasAdded()) {
  82                 continue;
  83             }
  84 
  85             TableSelectionModel sm = getSelectionModel();
  86             if (sm == null) return;
  87 
  88             TablePositionBase anchor = getAnchor();
  89             boolean cellSelectionEnabled = sm.isCellSelectionEnabled();
  90 
  91             int addedSize = c.getAddedSize();
  92             List&lt;TablePositionBase&gt; addedSubList = (List&lt;TablePositionBase&gt;) c.getAddedSubList();
  93 
  94             for (TablePositionBase tpb : addedSubList) {
  95                 if (! selectionHistory.contains(tpb)) {
  96                     selectionHistory.add(tpb);
  97                 }
  98             }
  99 
 100             // newest selection
 101             if (addedSize &gt; 0 &amp;&amp; ! hasAnchor()) {
 102                 TablePositionBase tp = addedSubList.get(addedSize - 1);
 103                 setAnchor(tp);
 104             }
 105 
 106             if (anchor != null &amp;&amp; cellSelectionEnabled &amp;&amp; ! selectionPathDeviated) {
 107                 // check if the selection is on the same row or column,
 108                 // otherwise set selectionPathDeviated to true
 109                 for (int i = 0; i &lt; addedSize; i++) {
 110                     TablePositionBase tp = addedSubList.get(i);
 111                     if (anchor.getRow() != -1 &amp;&amp; tp.getRow() != anchor.getRow() &amp;&amp; tp.getColumn() != anchor.getColumn()) {
 112                         setSelectionPathDeviated(true);
 113                         break;
 114                     }
 115                 }
 116             }
 117         }
 118     };
 119 
 120     protected final WeakListChangeListener&lt;TablePositionBase&gt; weakSelectedCellsListener =
 121             new WeakListChangeListener&lt;TablePositionBase&gt;(selectedCellsListener);
 122 
 123 
 124 
 125     /**************************************************************************
 126      *                                                                        *
 127      * Constructors                                                           *
 128      *                                                                        *
 129      *************************************************************************/
 130 
 131     public TableViewBehaviorBase(C control) {
 132         super(control);
 133 
 134 
 135         // create a map for TableView(Base)-specific mappings
 136         tableViewInputMap = createInputMap();
 137 
 138         boolean rtl = isRTL();
 139 
 140         KeyMapping enterKeyActivateMapping, escapeKeyCancelEditMapping;
 141         addDefaultMapping(tableViewInputMap,
 142                 new KeyMapping(TAB, FocusTraversalInputMap::traverseNext),
 143                 new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
 144 
 145                 new KeyMapping(HOME, e -&gt; selectFirstRow()),
 146                 new KeyMapping(END, e -&gt; selectLastRow()),
 147 
 148                 new KeyMapping(PAGE_UP, e -&gt; scrollUp()),
 149                 new KeyMapping(PAGE_DOWN, e -&gt; scrollDown()),
 150 
 151 
 152                 new KeyMapping(LEFT, (rtl? e -&gt; selectRightCell() : e -&gt; selectLeftCell())),
 153                 new KeyMapping(KP_LEFT, (rtl? e -&gt; selectRightCell() : e -&gt; selectLeftCell())),
 154                 new KeyMapping(RIGHT, (rtl? e -&gt; selectLeftCell() : e -&gt; selectRightCell())),
 155                 new KeyMapping(KP_RIGHT, (rtl? e -&gt; selectLeftCell() :e -&gt; selectRightCell())),
 156 
 157                 new KeyMapping(UP, e -&gt; selectPreviousRow()),
 158                 new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
 159                 new KeyMapping(DOWN, e -&gt; selectNextRow()),
 160                 new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),
 161 
 162                 new KeyMapping(LEFT, (rtl? FocusTraversalInputMap::traverseRight : FocusTraversalInputMap::traverseLeft)),
 163                 new KeyMapping(KP_LEFT, (rtl? FocusTraversalInputMap::traverseRight : FocusTraversalInputMap::traverseLeft)),
 164                 new KeyMapping(RIGHT, (rtl? FocusTraversalInputMap::traverseLeft : FocusTraversalInputMap::traverseRight)),
 165                 new KeyMapping(KP_RIGHT, (rtl? FocusTraversalInputMap::traverseLeft : FocusTraversalInputMap::traverseRight)),
 166                 new KeyMapping(UP, FocusTraversalInputMap::traverseUp),
 167                 new KeyMapping(KP_UP, FocusTraversalInputMap::traverseUp),
 168                 new KeyMapping(DOWN, FocusTraversalInputMap::traverseDown),
 169                 new KeyMapping(KP_DOWN, FocusTraversalInputMap::traverseDown),
 170 
 171                 new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
 172                 new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
 173                 new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
 174                 new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),
 175 
 176                 new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPrevious()),
 177                 new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPrevious()),
 178                 new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNext()),
 179                 new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNext()),
 180 
 181                 new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
 182                 new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),
 183 
 184                 new KeyMapping(new KeyBinding(LEFT).shift(), (rtl? e -&gt; alsoSelectRightCell() : e -&gt; alsoSelectLeftCell())),
 185                 new KeyMapping(new KeyBinding(KP_LEFT).shift(), (rtl? e -&gt; alsoSelectRightCell() : e -&gt; alsoSelectLeftCell())),
 186                 new KeyMapping(new KeyBinding(RIGHT).shift(), (rtl? e -&gt; alsoSelectLeftCell() : e -&gt; alsoSelectRightCell())),
 187                 new KeyMapping(new KeyBinding(KP_RIGHT).shift(), (rtl? e -&gt; alsoSelectLeftCell() : e -&gt; alsoSelectRightCell())),
 188 
 189                 new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
 190                 new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),
 191                 new KeyMapping(new KeyBinding(RIGHT).shortcut(), (rtl? e -&gt; focusLeftCell() : e -&gt; focusRightCell())),
 192                 new KeyMapping(new KeyBinding(KP_RIGHT).shortcut(), (rtl? e -&gt; focusLeftCell() : e -&gt; focusRightCell())),
 193                 new KeyMapping(new KeyBinding(LEFT).shortcut(), (rtl? e -&gt; focusRightCell() : e -&gt; focusLeftCell())),
 194                 new KeyMapping(new KeyBinding(KP_LEFT).shortcut(), (rtl? e -&gt; focusRightCell() : e -&gt; focusLeftCell())),
 195 
 196                 new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
 197                 new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
 198                 new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
 199                 new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
 200                 new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),
 201 
 202                 new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
 203                 new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
 204                 new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), (rtl? e -&gt; discontinuousSelectNextColumn() : e -&gt; discontinuousSelectPreviousColumn())),
 205                 new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), (rtl? e -&gt; discontinuousSelectPreviousColumn() : e -&gt; discontinuousSelectNextColumn())),
 206                 new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
 207                 new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
 208                 new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
 209                 new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow()),
 210 
 211                 enterKeyActivateMapping = new KeyMapping(ENTER, this::activate),
 212                 new KeyMapping(SPACE, this::activate),
 213                 new KeyMapping(F2, this::activate),
 214                 escapeKeyCancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),
 215 
 216                 new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
 217         );
 218 
 219         enterKeyActivateMapping.setAutoConsume(false);
 220         escapeKeyCancelEditMapping.setAutoConsume(false);
 221 
 222         // create OS-specific child mappings
 223         // --- mac OS
 224         InputMap&lt;C&gt; macInputMap = new InputMap&lt;&gt;(control);
 225         macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
 226         addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
 227         addDefaultChildMap(tableViewInputMap, macInputMap);
 228 
 229         // --- all other platforms
 230         InputMap&lt;C&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
 231         otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
 232         addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
 233         addDefaultChildMap(tableViewInputMap, otherOsInputMap);
 234 
 235         // set up other listeners
 236         // We make this an event _filter_ so that we can determine the state
 237         // of the shift key before the event handlers get a shot at the event.
 238         control.addEventFilter(KeyEvent.ANY, keyEventListener);
 239     }
 240 
 241 
 242 
 243     /**************************************************************************
 244      *                                                                        *
 245      * Abstract API                                                           *
 246      *                                                                        *
 247      *************************************************************************/
 248 
 249     /** {@inheritDoc} */
 250     @Override public InputMap&lt;C&gt; getInputMap() {
 251         return tableViewInputMap;
 252     }
 253 
 254     /**
 255      * Call to record the current anchor position
 256      */
 257     protected void setAnchor(TablePositionBase tp) {
 258         TableCellBehaviorBase.setAnchor(getNode(), tp, false);
 259         setSelectionPathDeviated(false);
 260     }
 261 
 262     /**
 263      * Will return the current anchor position.
 264      */
 265     protected TablePositionBase getAnchor() {
 266         return TableCellBehaviorBase.getAnchor(getNode(), getFocusedCell());
 267     }
 268 
 269     /**
 270      * Returns true if there is an anchor set, and false if not anchor is set.
 271      */
 272     protected boolean hasAnchor() {
 273         return TableCellBehaviorBase.hasNonDefaultAnchor(getNode());
 274     }
 275 
 276     /**
 277      * Returns the number of items in the underlying data model.
 278      */
 279     protected abstract int getItemCount();
 280 
 281     /**
 282      * Returns the focus model for the underlying UI control (which must extend
 283      * from TableFocusModel).
 284      */
 285     protected abstract TableFocusModel getFocusModel();
 286 
 287     /**
 288      * Returns the selection model for the underlying UI control (which must extend
 289      * from TableSelectionModel).
 290      */
 291     protected abstract TableSelectionModel&lt;T&gt; getSelectionModel();
 292 
 293     /**
 294      * Returns an observable list of all cells that are currently selected in
 295      * the selection model of the underlying control.
 296      */
 297     protected abstract ObservableList&lt;? extends TablePositionBase/*&lt;C,TC&gt;*/&gt; getSelectedCells();
 298 
 299     /**
 300      * Returns the focused cell from the focus model of the underlying control.
 301      */
 302     protected abstract TablePositionBase getFocusedCell();
 303 
 304     /**
 305      * Returns the position of the given table column in the visible leaf columns
 306      * list of the underlying control.
 307      */
 308     protected abstract int getVisibleLeafIndex(TableColumnBase tc);
 309 
 310     /**
 311      * Returns the column at the given index in the visible leaf columns list of
 312      * the underlying control.
 313      */
 314     protected abstract TableColumnBase getVisibleLeafColumn(int index);
 315 
 316     /**
 317      * Returns true if the control (i.e. TableView / TreeTableView) is editable
 318      */
 319     protected abstract boolean isControlEditable();
 320 
 321     /**
 322      * Begins the edit process in the underlying control for the given row/column
 323      * position.
 324      */
 325     protected abstract void editCell(int row, TableColumnBase tc);
 326 
 327     /**
 328      * Returns an observable list of all visible leaf columns in the underlying
 329      * control.
 330      */
 331     protected abstract ObservableList&lt;? extends TableColumnBase&gt; getVisibleLeafColumns();
 332 
 333     /**
 334      * Creates a TablePositionBase instance using the underlying controls
 335      * concrete implementation for the given row/column intersection.
 336      */
 337     protected abstract TablePositionBase&lt;TC&gt; getTablePosition(int row, TableColumnBase&lt;T,?&gt; tc);
 338 
 339 
 340 
 341     /**************************************************************************
 342      *                                                                        *
 343      * Public API                                                             *
 344      *                                                                        *
 345      *************************************************************************/
 346 
 347     /*
 348      * Anchor is created upon
 349      * - initial selection of an item (by mouse or keyboard)
 350      *
 351      * Anchor is changed when you
 352      * - move the selection to an item by UP/DOWN/LEFT/RIGHT arrow keys
 353      * - select an item by mouse click
 354      * - add/remove an item to/from an existing selection by CTRL+SPACE shortcut
 355      * - add/remove an items to/from an existing selection by CTRL+mouse click
 356      *
 357      * Note that if an item is removed from an existing selection by
 358      * CTRL+SPACE/CTRL+mouse click, anchor still remains on this item even
 359      * though it is not selected.
 360      *
 361      * Anchor is NOT changed when you
 362      * - create linear multi-selection by SHIFT+UP/DOWN/LEFT/RIGHT arrow keys
 363      * - create linear multi-selection by SHIFT+SPACE arrow keys
 364      * - create linear multi-selection by SHIFT+mouse click
 365      *
 366      * In case there is a discontinuous selection in the list, creating linear
 367      * multi-selection between anchor and focused item will cancel the
 368      * discontinuous selection. It means that only items that are located between
 369      * anchor and focused item will be selected.
 370      */
 371     protected void setAnchor(int row, TableColumnBase col) {
 372         setAnchor(row == -1 &amp;&amp; col == null ? null : getTablePosition(row, col));
 373     }
 374 
 375     private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
 376     public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }
 377 
 378     private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
 379     public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }
 380 
 381     private Runnable onFocusPreviousRow;
 382     public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }
 383 
 384     private Runnable onFocusNextRow;
 385     public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }
 386 
 387     private Runnable onSelectPreviousRow;
 388     public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }
 389 
 390     private Runnable onSelectNextRow;
 391     public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }
 392 
 393     private Runnable onMoveToFirstCell;
 394     public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }
 395 
 396     private Runnable onMoveToLastCell;
 397     public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }
 398 
 399     private Runnable onSelectRightCell;
 400     public void setOnSelectRightCell(Runnable r) { onSelectRightCell = r; }
 401 
 402     private Runnable onSelectLeftCell;
 403     public void setOnSelectLeftCell(Runnable r) { onSelectLeftCell = r; }
 404 
 405     private Runnable onFocusRightCell;
 406     public void setOnFocusRightCell(Runnable r) { onFocusRightCell = r; }
 407 
 408     private Runnable onFocusLeftCell;
 409     public void setOnFocusLeftCell(Runnable r) { onFocusLeftCell = r; }
 410 
 411     public void mousePressed(MouseEvent e) {
 412 //        // FIXME can&#39;t assume (yet) cells.get(0) is necessarily the lead cell
 413 //        ObservableList&lt;? extends TablePositionBase&gt; cells = getSelectedCells();
 414 //        setAnchor(cells.isEmpty() ? null : cells.get(0));
 415 
 416         if (!getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
 417             getNode().requestFocus();
 418         }
 419     }
 420 
 421     protected boolean isRTL() {
 422         return (getNode().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
 423     }
 424 
 425 
 426     /**************************************************************************
 427      *                                                                        *
 428      * Private implementation                                                 *
 429      *                                                                        *
 430      *************************************************************************/
 431 
 432     private void setSelectionPathDeviated(boolean selectionPathDeviated) {
 433         this.selectionPathDeviated = selectionPathDeviated;
 434     }
 435 
 436     protected void scrollUp() {
 437         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 438         if (sm == null || getSelectedCells().isEmpty()) return;
 439 
 440         TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);
 441 
 442         int newSelectedIndex = -1;
 443         if (onScrollPageUp != null) {
 444             newSelectedIndex = onScrollPageUp.call(false);
 445         }
 446         if (newSelectedIndex == -1) return;
 447 
 448         sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
 449     }
 450 
 451     protected void scrollDown() {
 452         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 453         if (sm == null || getSelectedCells().isEmpty()) return;
 454 
 455         TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);
 456 
 457         int newSelectedIndex = -1;
 458         if (onScrollPageDown != null) {
 459             newSelectedIndex = onScrollPageDown.call(false);
 460         }
 461         if (newSelectedIndex == -1) return;
 462 
 463         sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
 464     }
 465 
 466     protected void focusFirstRow() {
 467         TableFocusModel fm = getFocusModel();
 468         if (fm == null) return;
 469 
 470         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 471         fm.focus(0, tc);
 472 
 473         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 474     }
 475 
 476     protected void focusLastRow() {
 477         TableFocusModel fm = getFocusModel();
 478         if (fm == null) return;
 479 
 480         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 481         fm.focus(getItemCount() - 1, tc);
 482 
 483         if (onMoveToLastCell != null) onMoveToLastCell.run();
 484     }
 485 
 486     protected void focusPreviousRow() {
 487         TableSelectionModel sm = getSelectionModel();
 488         if (sm == null) return;
 489 
 490         TableFocusModel fm = getFocusModel();
 491         if (fm == null) return;
 492 
 493         if (sm.isCellSelectionEnabled()) {
 494             fm.focusAboveCell();
 495         } else {
 496             fm.focusPrevious();
 497         }
 498 
 499         if (! isShortcutDown || getAnchor() == null) {
 500             setAnchor(fm.getFocusedIndex(), null);
 501         }
 502 
 503         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
 504     }
 505 
 506     protected void focusNextRow() {
 507         TableSelectionModel sm = getSelectionModel();
 508         if (sm == null) return;
 509 
 510         TableFocusModel fm = getFocusModel();
 511         if (fm == null) return;
 512 
 513         if (sm.isCellSelectionEnabled()) {
 514             fm.focusBelowCell();
 515         } else {
 516             fm.focusNext();
 517         }
 518 
 519         if (! isShortcutDown || getAnchor() == null) {
 520             setAnchor(fm.getFocusedIndex(), null);
 521         }
 522 
 523         if (onFocusNextRow != null) onFocusNextRow.run();
 524     }
 525 
 526     protected void focusLeftCell() {
 527         TableSelectionModel sm = getSelectionModel();
 528         if (sm == null) return;
 529 
 530         TableFocusModel fm = getFocusModel();
 531         if (fm == null) return;
 532 
 533         fm.focusLeftCell();
 534         if (onFocusLeftCell != null) onFocusLeftCell.run();
 535     }
 536 
 537     protected void focusRightCell() {
 538         TableSelectionModel sm = getSelectionModel();
 539         if (sm == null) return;
 540 
 541         TableFocusModel fm = getFocusModel();
 542         if (fm == null) return;
 543 
 544         fm.focusRightCell();
 545         if (onFocusRightCell != null) onFocusRightCell.run();
 546     }
 547 
 548     protected void focusPageUp() {
 549         int newFocusIndex = onScrollPageUp.call(true);
 550 
 551         TableFocusModel fm = getFocusModel();
 552         if (fm == null) return;
 553         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 554         fm.focus(newFocusIndex, tc);
 555     }
 556 
 557     protected void focusPageDown() {
 558         int newFocusIndex = onScrollPageDown.call(true);
 559 
 560         TableFocusModel fm = getFocusModel();
 561         if (fm == null) return;
 562         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 563         fm.focus(newFocusIndex, tc);
 564     }
 565 
 566     protected void clearSelection() {
 567         TableSelectionModel sm = getSelectionModel();
 568         if (sm == null) return;
 569 
 570         sm.clearSelection();
 571     }
 572 
 573     protected void clearSelectionOutsideRange(int start, int end, TableColumnBase&lt;T,?&gt; column) {
 574         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 575         if (sm == null) return;
 576 
 577         int min = Math.min(start, end);
 578         int max = Math.max(start, end);
 579 
 580         List&lt;Integer&gt; indices = new ArrayList&lt;Integer&gt;(sm.getSelectedIndices());
 581 
 582         selectionChanging = true;
 583         for (int i = 0; i &lt; indices.size(); i++) {
 584             int index = indices.get(i);
 585             if (index &lt; min || index &gt; max) {
 586                 sm.clearSelection(index, column);
 587             }
 588         }
 589         selectionChanging = false;
 590     }
 591 
 592     protected void alsoSelectPrevious() {
 593         TableSelectionModel sm = getSelectionModel();
 594         if (sm == null) return;
 595 
 596         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
 597             selectPreviousRow();
 598             return;
 599         }
 600 
 601         TableFocusModel fm = getFocusModel();
 602         if (fm == null) return;
 603 
 604         if (sm.isCellSelectionEnabled()) {
 605             updateCellVerticalSelection(-1, () -&gt; {
 606                 getSelectionModel().selectAboveCell();
 607             });
 608         } else {
 609             if (isShiftDown &amp;&amp; hasAnchor()) {
 610                 updateRowSelection(-1);
 611             } else {
 612                 sm.selectPrevious();
 613             }
 614         }
 615         onSelectPreviousRow.run();
 616     }
 617 
 618     protected void alsoSelectNext() {
 619         TableSelectionModel sm = getSelectionModel();
 620         if (sm == null) return;
 621 
 622         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
 623             selectNextRow();
 624             return;
 625         }
 626 
 627         TableFocusModel fm = getFocusModel();
 628         if (fm == null) return;
 629 
 630         if (sm.isCellSelectionEnabled()) {
 631             updateCellVerticalSelection(1, () -&gt; {
 632                 getSelectionModel().selectBelowCell();
 633             });
 634         } else {
 635             if (isShiftDown &amp;&amp; hasAnchor()) {
 636                 updateRowSelection(1);
 637             } else {
 638                 sm.selectNext();
 639             }
 640         }
 641         onSelectNextRow.run();
 642     }
 643 
 644     protected void alsoSelectLeftCell() {
 645         TableSelectionModel sm = getSelectionModel();
 646         if (sm == null || !sm.isCellSelectionEnabled()) return;
 647 
 648         updateCellHorizontalSelection(-1, () -&gt; getSelectionModel().selectLeftCell());
 649         onSelectLeftCell.run();
 650     }
 651 
 652     protected void alsoSelectRightCell() {
 653         TableSelectionModel sm = getSelectionModel();
 654         if (sm == null || !sm.isCellSelectionEnabled()) return;
 655 
 656         updateCellHorizontalSelection(1, () -&gt; getSelectionModel().selectRightCell());
 657         onSelectRightCell.run();
 658     }
 659 
 660     protected void updateRowSelection(int delta) {
 661         TableSelectionModel sm = getSelectionModel();
 662         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 663 
 664         TableFocusModel fm = getFocusModel();
 665         if (fm == null) return;
 666 
 667         int newRow = fm.getFocusedIndex() + delta;
 668         TablePositionBase anchor = getAnchor();
 669 
 670         if (! hasAnchor()) {
 671             setAnchor(getFocusedCell());
 672         }
 673 
 674         if (sm.getSelectedIndices().size() &gt; 1) {
 675             clearSelectionOutsideRange(anchor.getRow(), newRow, null);
 676         }
 677 
 678         if (anchor.getRow() &gt; newRow) {
 679             sm.selectRange(anchor.getRow(), newRow - 1);
 680         } else {
 681             sm.selectRange(anchor.getRow(), newRow + 1);
 682         }
 683     }
 684 
 685     protected void updateCellVerticalSelection(int delta, Runnable defaultAction) {
 686         TableSelectionModel sm = getSelectionModel();
 687         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 688 
 689         TableFocusModel fm = getFocusModel();
 690         if (fm == null) return;
 691 
 692         final TablePositionBase focusedCell = getFocusedCell();
 693         final int focusedCellRow = focusedCell.getRow();
 694 
 695         if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow + delta, focusedCell.getTableColumn())) {
 696             int newFocusOwner = focusedCellRow + delta;
 697 
 698             // work out if we&#39;re backtracking
 699             boolean backtracking = false;
 700             if (selectionHistory.size() &gt;= 2) {
 701                 TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectionHistory.get(1);
 702                 backtracking = secondToLastSelectedCell.getRow() == newFocusOwner &amp;&amp;
 703                         secondToLastSelectedCell.getColumn() == focusedCell.getColumn();
 704             }
 705 
 706             // if the selection path has deviated from the anchor row / column, then we need to see if we&#39;re moving
 707             // backwards to the previous selection or not (as it determines what cell row we clear out)
 708             int cellRowToClear = selectionPathDeviated ?
 709                     (backtracking ? focusedCellRow : newFocusOwner) :
 710                     focusedCellRow;
 711 
 712             sm.clearSelection(cellRowToClear, focusedCell.getTableColumn());
 713             fm.focus(newFocusOwner, focusedCell.getTableColumn());
 714         } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
 715             int newRow = fm.getFocusedIndex() + delta;
 716 
 717             // we don&#39;t let the newRow go outside the bounds of the data
 718             newRow = Math.max(Math.min(getItemCount() - 1, newRow), 0);
 719 
 720             int start = Math.min(getAnchor().getRow(), newRow);
 721             int end = Math.max(getAnchor().getRow(), newRow);
 722 
 723             if (sm.getSelectedIndices().size() &gt; 1) {
 724                 clearSelectionOutsideRange(start, end, focusedCell.getTableColumn());
 725             }
 726 
 727             for (int _row = start; _row &lt;= end; _row++) {
 728                 if (sm.isSelected(_row, focusedCell.getTableColumn())) {
 729                     continue;
 730                 }
 731                 sm.select(_row, focusedCell.getTableColumn());
 732             }
 733             fm.focus(newRow, focusedCell.getTableColumn());
 734         } else {
 735             final int focusIndex = fm.getFocusedIndex();
 736             if (! sm.isSelected(focusIndex, focusedCell.getTableColumn())) {
 737                 sm.select(focusIndex, focusedCell.getTableColumn());
 738             }
 739             defaultAction.run();
 740         }
 741     }
 742 
 743     protected void updateCellHorizontalSelection(int delta, Runnable defaultAction) {
 744         TableSelectionModel sm = getSelectionModel();
 745         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 746 
 747         TableFocusModel fm = getFocusModel();
 748         if (fm == null) return;
 749 
 750         final TablePositionBase focusedCell = getFocusedCell();
 751         if (focusedCell == null || focusedCell.getTableColumn() == null) return;
 752 
 753         boolean atEnd = false;
 754         TableColumnBase adjacentColumn = getColumn(focusedCell.getTableColumn(), delta);
 755         if (adjacentColumn == null) {
 756             // if adjacentColumn is null, we use the focusedCell column, as we are
 757             // most probably at the very beginning or end of the row
 758             adjacentColumn = focusedCell.getTableColumn();
 759             atEnd = true;
 760         }
 761 
 762         final int focusedCellRow = focusedCell.getRow();
 763 
 764         if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow, adjacentColumn)) {
 765             if (atEnd) {
 766                 return;
 767             }
 768 
 769             // work out if we&#39;re backtracking
 770             boolean backtracking = false;
 771             ObservableList&lt;? extends TablePositionBase&gt; selectedCells = getSelectedCells();
 772             if (selectedCells.size() &gt;= 2) {
 773                 TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectedCells.get(selectedCells.size() - 2);
 774                 backtracking = secondToLastSelectedCell.getRow() == focusedCellRow &amp;&amp;
 775                         secondToLastSelectedCell.getTableColumn().equals(adjacentColumn);
 776             }
 777 
 778             // if the selection path has deviated from the anchor row / column, then we need to see if we&#39;re moving
 779             // backwards to the previous selection or not (as it determines what cell column we clear out)
 780             TableColumnBase&lt;?,?&gt; cellColumnToClear = selectionPathDeviated ?
 781                     (backtracking ? focusedCell.getTableColumn() : adjacentColumn) :
 782                     focusedCell.getTableColumn();
 783 
 784             sm.clearSelection(focusedCellRow, cellColumnToClear);
 785             fm.focus(focusedCellRow, adjacentColumn);
 786         } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
 787             final int anchorColumn = getAnchor().getColumn();
 788 
 789             // we don&#39;t let the newColumn go outside the bounds of the data
 790             int newColumn = getVisibleLeafIndex(focusedCell.getTableColumn()) + delta;
 791             newColumn = Math.max(Math.min(getVisibleLeafColumns().size() - 1, newColumn), 0);
 792 
 793             int start = Math.min(anchorColumn, newColumn);
 794             int end = Math.max(anchorColumn, newColumn);
 795 
 796             for (int _col = start; _col &lt;= end; _col++) {
 797                 sm.select(focusedCell.getRow(), getColumn(_col));
 798             }
 799             fm.focus(focusedCell.getRow(), getColumn(newColumn));
 800         } else {
 801             defaultAction.run();
 802         }
 803     }
 804 
 805     protected TableColumnBase getColumn(int index) {
 806         return getVisibleLeafColumn(index);
 807     }
 808 
 809     protected TableColumnBase getColumn(TableColumnBase tc, int delta) {
 810         return getVisibleLeafColumn(getVisibleLeafIndex(tc) + delta);
 811     }
 812 
 813     protected void selectFirstRow() {
 814         TableSelectionModel sm = getSelectionModel();
 815         if (sm == null) return;
 816 
 817         ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
 818         TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
 819         sm.clearAndSelect(0, selectedColumn);
 820 
 821         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 822     }
 823 
 824     protected void selectLastRow() {
 825         TableSelectionModel sm = getSelectionModel();
 826         if (sm == null) return;
 827 
 828         ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
 829         TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
 830         sm.clearAndSelect(getItemCount() - 1, selectedColumn);
 831 
 832         if (onMoveToLastCell != null) onMoveToLastCell.run();
 833     }
 834 
 835     protected void selectPreviousRow() {
 836         selectCell(-1, 0);
 837         if (onSelectPreviousRow != null) onSelectPreviousRow.run();
 838     }
 839 
 840     protected void selectNextRow() {
 841         selectCell(1, 0);
 842         if (onSelectNextRow != null) onSelectNextRow.run();
 843     }
 844 
 845     protected void selectLeftCell() {
 846         selectCell(0, -1);
 847         if (onSelectLeftCell != null) onSelectLeftCell.run();
 848     }
 849 
 850     protected void selectRightCell() {
 851         selectCell(0, 1);
 852         if (onSelectRightCell != null) onSelectRightCell.run();
 853     }
 854 
 855     protected void selectCell(int rowDiff, int columnDiff) {
 856         TableSelectionModel sm = getSelectionModel();
 857         if (sm == null) return;
 858 
 859         TableFocusModel fm = getFocusModel();
 860         if (fm == null) return;
 861 
 862         TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
 863         int currentRow = focusedCell.getRow();
 864         int currentColumn = getVisibleLeafIndex(focusedCell.getTableColumn());
 865 
 866         if (rowDiff &gt; 0 &amp;&amp; currentRow &gt;= getItemCount() - 1) return;
 867         else if (columnDiff &lt; 0 &amp;&amp; currentColumn &lt;= 0) return;
 868         else if (columnDiff &gt; 0 &amp;&amp; currentColumn &gt;= getVisibleLeafColumns().size() - 1) return;
 869         else if (columnDiff &gt; 0 &amp;&amp; currentColumn == -1) return;
 870 
 871         TableColumnBase tc = focusedCell.getTableColumn();
 872         tc = getColumn(tc, columnDiff);
 873 
 874         //JDK-8222214: Moved this &quot;if&quot; here because the first row might be focused and not selected, so
 875         // this makes sure it gets selected when the users presses UP. If not it ends calling
 876         // VirtualFlow.scrollTo(-1) at and the content of the TableView disappears.
 877         int row = (currentRow &lt;= 0 &amp;&amp; rowDiff &lt;= 0) ? 0 : focusedCell.getRow() + rowDiff;
 878         sm.clearAndSelect(row, tc);
 879         setAnchor(row, tc);
 880     }
 881 
 882     protected void cancelEdit(KeyEvent e) {
 883         if (isControlEditable()) {
 884             editCell(-1, null);
 885             e.consume();
 886         }
 887     }
 888 
 889     protected void activate(KeyEvent e) {
 890         TableSelectionModel sm = getSelectionModel();
 891         if (sm == null) return;
 892 
 893         TableFocusModel fm = getFocusModel();
 894         if (fm == null) return;
 895 
 896         TablePositionBase&lt;TC&gt; cell = getFocusedCell();
 897         sm.select(cell.getRow(), cell.getTableColumn());
 898         setAnchor(cell);
 899 
 900         // check if we are editable
 901         boolean isEditable = isControlEditable() &amp;&amp; cell.getTableColumn().isEditable();
 902 
 903         // edit this row also
 904         if (isEditable &amp;&amp; cell.getRow() &gt;= 0) {
 905             editCell(cell.getRow(), cell.getTableColumn());
 906             e.consume();
 907         }
 908     }
 909 
 910     protected void selectAllToFocus(boolean setAnchorToFocusIndex) {
 911         TableSelectionModel sm = getSelectionModel();
 912         if (sm == null) return;
 913 
 914         TableFocusModel fm = getFocusModel();
 915         if (fm == null) return;
 916 
 917         TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
 918         int focusRow = focusedCell.getRow();
 919 
 920         TablePositionBase&lt;TC&gt; anchor = getAnchor();
 921         int anchorRow = anchor.getRow();
 922 
 923         sm.clearSelection();
 924         if (! sm.isCellSelectionEnabled()) {
 925             int startPos = anchorRow;
 926             int endPos = anchorRow &gt; focusRow ? focusRow - 1 : focusRow + 1;
 927             sm.selectRange(startPos, endPos);
 928         } else {
 929             // we add all cells/rows between the current selection focus and
 930             // the anchor (inclusive) to the current selection.
 931             // We want focus to end up on the current focus position.
 932             sm.selectRange(anchor.getRow(), anchor.getTableColumn(),
 933                            focusedCell.getRow(), focusedCell.getTableColumn());
 934         }
 935 
 936         setAnchor(setAnchorToFocusIndex ? focusedCell : anchor);
 937     }
 938 
 939     protected void selectAll() {
 940         TableSelectionModel sm = getSelectionModel();
 941         if (sm == null) return;
 942         sm.selectAll();
 943     }
 944 
 945     protected void selectAllToFirstRow() {
 946         TableSelectionModel sm = getSelectionModel();
 947         if (sm == null) return;
 948 
 949         TableFocusModel fm = getFocusModel();
 950         if (fm == null) return;
 951 
 952         final boolean isSingleSelection = sm.getSelectionMode() == SelectionMode.SINGLE;
 953         final TablePositionBase focusedCell = getFocusedCell();
 954         final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
 955         int leadIndex = focusedCell.getRow();
 956 
 957         if (isShiftDown) {
 958             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
 959         }
 960 
 961         sm.clearSelection();
 962         if (! sm.isCellSelectionEnabled()) {
 963             // we are going from 0 to one before the focused cell as that is
 964             // the requirement of selectRange, so we call focus on the 0th row
 965             if (isSingleSelection) {
 966                 sm.select(0);
 967             } else {
 968                 sm.selectRange(leadIndex, -1);
 969             }
 970             fm.focus(0);
 971         } else {
 972             if (isSingleSelection) {
 973                 sm.select(0, column);
 974             } else {
 975                 sm.selectRange(leadIndex, column, -1, column);
 976             }
 977             fm.focus(0, column);
 978         }
 979 
 980         if (isShiftDown) {
 981             setAnchor(leadIndex, column);
 982         }
 983 
 984         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 985     }
 986 
 987     protected void selectAllToLastRow() {
 988         TableSelectionModel sm = getSelectionModel();
 989         if (sm == null) return;
 990 
 991         TableFocusModel fm = getFocusModel();
 992         if (fm == null) return;
 993 
 994         final int itemCount = getItemCount();
 995         final TablePositionBase focusedCell = getFocusedCell();
 996         final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
 997         int leadIndex = focusedCell.getRow();
 998 
 999         if (isShiftDown) {
1000             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
1001         }
1002 
1003         sm.clearSelection();
1004         if (! sm.isCellSelectionEnabled()) {
1005             sm.selectRange(leadIndex, itemCount);
1006         } else {
1007             sm.selectRange(leadIndex, column, itemCount - 1, column);
1008         }
1009 
1010         if (isShiftDown) {
1011             setAnchor(leadIndex, column);
1012         }
1013 
1014         if (onMoveToLastCell != null) onMoveToLastCell.run();
1015     }
1016 
1017     protected void selectAllPageUp() {
1018         TableSelectionModel sm = getSelectionModel();
1019         if (sm == null) return;
1020 
1021         TableFocusModel fm = getFocusModel();
1022         if (fm == null) return;
1023 
1024         int leadIndex = fm.getFocusedIndex();
1025         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1026         if (isShiftDown) {
1027             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
1028             setAnchor(leadIndex, col);
1029         }
1030 
1031         int leadSelectedIndex = onScrollPageUp.call(false);
1032 
1033         selectionChanging = true;
1034         if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
1035             if (sm.isCellSelectionEnabled()) {
1036                 sm.select(leadSelectedIndex, col);
1037             } else {
1038                 sm.select(leadSelectedIndex);
1039             }
1040         } else {
1041             sm.clearSelection();
1042             if (sm.isCellSelectionEnabled()) {
1043                 sm.selectRange(leadIndex, col, leadSelectedIndex, col);
1044             } else {
1045                 // fix for RT-34407
1046                 int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
1047                 sm.selectRange(leadIndex, leadSelectedIndex + adjust);
1048             }
1049         }
1050         selectionChanging = false;
1051     }
1052 
1053     protected void selectAllPageDown() {
1054         TableSelectionModel sm = getSelectionModel();
1055         if (sm == null) return;
1056 
1057         TableFocusModel fm = getFocusModel();
1058         if (fm == null) return;
1059 
1060         int leadIndex = fm.getFocusedIndex();
1061         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1062         if (isShiftDown) {
1063             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
1064             setAnchor(leadIndex, col);
1065         }
1066 
1067         int leadSelectedIndex = onScrollPageDown.call(false);
1068 
1069         selectionChanging = true;
1070         if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
1071             if (sm.isCellSelectionEnabled()) {
1072                 sm.select(leadSelectedIndex, col);
1073             } else {
1074                 sm.select(leadSelectedIndex);
1075             }
1076         } else {
1077             sm.clearSelection();
1078 
1079             if (sm.isCellSelectionEnabled()) {
1080                 sm.selectRange(leadIndex, col, leadSelectedIndex, col);
1081             } else {
1082                 // fix for RT-34407
1083                 int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
1084                 sm.selectRange(leadIndex, leadSelectedIndex + adjust);
1085             }
1086         }
1087         selectionChanging = false;
1088     }
1089 
1090     protected void toggleFocusOwnerSelection() {
1091         TableSelectionModel sm = getSelectionModel();
1092         if (sm == null) return;
1093 
1094         TableFocusModel fm = getFocusModel();
1095         if (fm == null) return;
1096 
1097         TablePositionBase focusedCell = getFocusedCell();
1098 
1099         if (sm.isSelected(focusedCell.getRow(), focusedCell.getTableColumn())) {
1100             sm.clearSelection(focusedCell.getRow(), focusedCell.getTableColumn());
1101             fm.focus(focusedCell.getRow(), focusedCell.getTableColumn());
1102         } else {
1103             sm.select(focusedCell.getRow(), focusedCell.getTableColumn());
1104         }
1105 
1106         setAnchor(focusedCell.getRow(), focusedCell.getTableColumn());
1107     }
1108 
1109     // This functionality was added, but then removed when it was realised by
1110     // UX that TableView should not include &#39;spreadsheet-like&#39; functionality.
1111     // When / if we ever introduce this kind of control, this functionality can
1112     // be re-enabled then.
1113     /*
1114     protected void moveToLeftMostColumn() {
1115         // Functionality as described in RT-12752
1116         if (onMoveToLeftMostColumn != null) onMoveToLeftMostColumn.run();
1117 
1118         TableSelectionModel sm = getSelectionModel();
1119         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1120 
1121         TableFocusModel fm = getFocusModel();
1122         if (fm == null) return;
1123 
1124         TablePosition focusedCell = fm.getFocusedCell();
1125 
1126         TableColumn endColumn = getNode().getVisibleLeafColumn(0);
1127         sm.clearAndSelect(focusedCell.getRow(), endColumn);
1128     }
1129 
1130     protected void moveToRightMostColumn() {
1131         // Functionality as described in RT-12752
1132         if (onMoveToRightMostColumn != null) onMoveToRightMostColumn.run();
1133 
1134         TableSelectionModel sm = getSelectionModel();
1135         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1136 
1137         TableFocusModel fm = getFocusModel();
1138         if (fm == null) return;
1139 
1140         TablePosition focusedCell = fm.getFocusedCell();
1141 
1142         TableColumn endColumn = getNode().getVisibleLeafColumn(getNode().getVisibleLeafColumns().size() - 1);
1143         sm.clearAndSelect(focusedCell.getRow(), endColumn);
1144     }
1145      */
1146 
1147 
1148     /**************************************************************************
1149      * Discontinuous Selection                                                *
1150      *************************************************************************/
1151 
1152     protected void discontinuousSelectPreviousRow() {
1153         TableSelectionModel sm = getSelectionModel();
1154         if (sm == null) return;
1155 
1156         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
1157             selectPreviousRow();
1158             return;
1159         }
1160 
1161         TableFocusModel fm = getFocusModel();
1162         if (fm == null) return;
1163 
1164         int focusIndex = fm.getFocusedIndex();
1165         final int newFocusIndex = focusIndex - 1;
1166         if (newFocusIndex &lt; 0) return;
1167 
1168         int startIndex = focusIndex;
1169         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1170         if (isShiftDown) {
1171             startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
1172         }
1173 
1174         if (! sm.isCellSelectionEnabled()) {
1175             sm.selectRange(newFocusIndex, startIndex + 1);
1176             fm.focus(newFocusIndex);
1177         } else {
1178             for (int i = newFocusIndex; i &lt; startIndex + 1; i++) {
1179                 sm.select(i, col);
1180             }
1181             fm.focus(newFocusIndex, col);
1182         }
1183 
1184         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
1185     }
1186 
1187     protected void discontinuousSelectNextRow() {
1188         TableSelectionModel sm = getSelectionModel();
1189         if (sm == null) return;
1190 
1191         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
1192             selectNextRow();
1193             return;
1194         }
1195 
1196         TableFocusModel fm = getFocusModel();
1197         if (fm == null) return;
1198 
1199         int focusIndex = fm.getFocusedIndex();
1200         final int newFocusIndex = focusIndex + 1;
1201         if (newFocusIndex &gt;= getItemCount()) return;
1202 
1203         int startIndex = focusIndex;
1204         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1205         if (isShiftDown) {
1206             startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
1207         }
1208 
1209         if (! sm.isCellSelectionEnabled()) {
1210             sm.selectRange(startIndex, newFocusIndex + 1);
1211             fm.focus(newFocusIndex);
1212         } else {
1213             for (int i = startIndex; i &lt; newFocusIndex + 1; i++) {
1214                 sm.select(i, col);
1215             }
1216             fm.focus(newFocusIndex, col);
1217         }
1218 
1219         if (onFocusNextRow != null) onFocusNextRow.run();
1220     }
1221 
1222     protected void discontinuousSelectPreviousColumn() {
1223         TableSelectionModel sm = getSelectionModel();
1224         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1225 
1226         TableFocusModel fm = getFocusModel();
1227         if (fm == null) return;
1228 
1229         TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), -1);
1230         sm.select(fm.getFocusedIndex(), tc);
1231     }
1232 
1233     protected void discontinuousSelectNextColumn() {
1234         TableSelectionModel sm = getSelectionModel();
1235         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1236 
1237         TableFocusModel fm = getFocusModel();
1238         if (fm == null) return;
1239 
1240         TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), 1);
1241         sm.select(fm.getFocusedIndex(), tc);
1242     }
1243 
1244     protected void discontinuousSelectPageUp() {
1245         TableSelectionModel sm = getSelectionModel();
1246         if (sm == null) return;
1247 
1248         TableFocusModel fm = getFocusModel();
1249         if (fm == null) return;
1250 
1251         int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
1252         int leadSelectedIndex = onScrollPageUp.call(false);
1253 
1254         if (! sm.isCellSelectionEnabled()) {
1255             sm.selectRange(anchor, leadSelectedIndex - 1);
1256         }
1257     }
1258 
1259     protected void discontinuousSelectPageDown() {
1260         TableSelectionModel sm = getSelectionModel();
1261         if (sm == null) return;
1262 
1263         TableFocusModel fm = getFocusModel();
1264         if (fm == null) return;
1265 
1266         int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
1267         int leadSelectedIndex = onScrollPageDown.call(false);
1268 
1269         if (! sm.isCellSelectionEnabled()) {
1270             sm.selectRange(anchor, leadSelectedIndex + 1);
1271         }
1272     }
1273 
1274     protected void discontinuousSelectAllToFirstRow() {
1275         TableSelectionModel sm = getSelectionModel();
1276         if (sm == null) return;
1277 
1278         TableFocusModel fm = getFocusModel();
1279         if (fm == null) return;
1280 
1281         int index = fm.getFocusedIndex();
1282 
1283         if (! sm.isCellSelectionEnabled()) {
1284             sm.selectRange(0, index);
1285             fm.focus(0);
1286         } else {
1287             for (int i = 0; i &lt; index; i++) {
1288                 sm.select(i, getFocusedCell().getTableColumn());
1289             }
1290             fm.focus(0, getFocusedCell().getTableColumn());
1291         }
1292 
1293         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
1294     }
1295 
1296     protected void discontinuousSelectAllToLastRow() {
1297         TableSelectionModel sm = getSelectionModel();
1298         if (sm == null) return;
1299 
1300         TableFocusModel fm = getFocusModel();
1301         if (fm == null) return;
1302 
1303         int index = fm.getFocusedIndex() + 1;
1304 
1305         if (! sm.isCellSelectionEnabled()) {
1306             sm.selectRange(index, getItemCount());
1307         } else {
1308             for (int i = index; i &lt; getItemCount(); i++) {
1309                 sm.select(i, getFocusedCell().getTableColumn());
1310             }
1311         }
1312 
1313         if (onMoveToLastCell != null) onMoveToLastCell.run();
1314     }
1315 }
    </pre>
  </body>
</html>