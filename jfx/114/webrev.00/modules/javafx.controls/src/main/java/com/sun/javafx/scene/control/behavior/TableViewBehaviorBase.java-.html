<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/com/sun/javafx/scene/control/behavior/TableViewBehaviorBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.scene.control.behavior;
  27 
  28 import com.sun.javafx.scene.control.SizeLimitedList;
  29 import javafx.collections.ListChangeListener;
  30 import javafx.collections.ObservableList;
  31 import javafx.collections.WeakListChangeListener;
  32 import javafx.event.EventHandler;
  33 import javafx.geometry.NodeOrientation;
  34 import javafx.scene.control.*;
  35 import com.sun.javafx.scene.control.inputmap.InputMap;
  36 import com.sun.javafx.scene.control.inputmap.KeyBinding;
  37 import javafx.scene.input.KeyEvent;
  38 import javafx.scene.input.MouseEvent;
  39 import javafx.util.Callback;
  40 import java.util.ArrayList;
  41 import java.util.List;
  42 import com.sun.javafx.PlatformUtil;
  43 import static javafx.scene.input.KeyCode.*;
  44 import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;
  45 
  46 public abstract class TableViewBehaviorBase&lt;C extends Control, T, TC extends TableColumnBase&lt;T,?&gt;&gt; extends BehaviorBase&lt;C&gt; {
  47 
  48     /**************************************************************************
  49      *                                                                        *
  50      * Internal fields                                                        *
  51      *                                                                        *
  52      *************************************************************************/
  53 
  54     private final InputMap&lt;C&gt; tableViewInputMap;
  55 
  56     protected boolean isShortcutDown = false;
  57     protected boolean isShiftDown = false;
  58     private boolean selectionPathDeviated = false;
  59     protected boolean selectionChanging = false;
  60 
  61     private final EventHandler&lt;KeyEvent&gt; keyEventListener = e -&gt; {
  62         if (!e.isConsumed()) {
  63             // RT-12751: we want to keep an eye on the user holding down the shift key,
  64             // so that we know when they enter/leave multiple selection mode. This
  65             // changes what happens when certain key combinations are pressed.
  66             isShiftDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShiftDown();
  67             isShortcutDown = e.getEventType() == KeyEvent.KEY_PRESSED &amp;&amp; e.isShortcutDown();
  68         }
  69     };
  70 
  71     private final SizeLimitedList&lt;TablePositionBase&gt; selectionHistory = new SizeLimitedList&lt;&gt;(10);
  72 
  73     protected final ListChangeListener&lt;TablePositionBase&gt; selectedCellsListener = c -&gt; {
  74         while (c.next()) {
  75             if (c.wasReplaced()) {
  76                 if (TreeTableCellBehavior.hasDefaultAnchor(getNode())) {
  77                     TreeTableCellBehavior.removeAnchor(getNode());
  78                 }
  79             }
  80 
  81             if (! c.wasAdded()) {
  82                 continue;
  83             }
  84 
  85             TableSelectionModel sm = getSelectionModel();
  86             if (sm == null) return;
  87 
  88             TablePositionBase anchor = getAnchor();
  89             boolean cellSelectionEnabled = sm.isCellSelectionEnabled();
  90 
  91             int addedSize = c.getAddedSize();
  92             List&lt;TablePositionBase&gt; addedSubList = (List&lt;TablePositionBase&gt;) c.getAddedSubList();
  93 
  94             for (TablePositionBase tpb : addedSubList) {
  95                 if (! selectionHistory.contains(tpb)) {
  96                     selectionHistory.add(tpb);
  97                 }
  98             }
  99 
 100             // newest selection
 101             if (addedSize &gt; 0 &amp;&amp; ! hasAnchor()) {
 102                 TablePositionBase tp = addedSubList.get(addedSize - 1);
 103                 setAnchor(tp);
 104             }
 105 
 106             if (anchor != null &amp;&amp; cellSelectionEnabled &amp;&amp; ! selectionPathDeviated) {
 107                 // check if the selection is on the same row or column,
 108                 // otherwise set selectionPathDeviated to true
 109                 for (int i = 0; i &lt; addedSize; i++) {
 110                     TablePositionBase tp = addedSubList.get(i);
 111                     if (anchor.getRow() != -1 &amp;&amp; tp.getRow() != anchor.getRow() &amp;&amp; tp.getColumn() != anchor.getColumn()) {
 112                         setSelectionPathDeviated(true);
 113                         break;
 114                     }
 115                 }
 116             }
 117         }
 118     };
 119 
 120     protected final WeakListChangeListener&lt;TablePositionBase&gt; weakSelectedCellsListener =
 121             new WeakListChangeListener&lt;TablePositionBase&gt;(selectedCellsListener);
 122 
 123 
 124 
 125     /**************************************************************************
 126      *                                                                        *
 127      * Constructors                                                           *
 128      *                                                                        *
 129      *************************************************************************/
 130 
 131     public TableViewBehaviorBase(C control) {
 132         super(control);
 133 
 134 
 135         // create a map for TableView(Base)-specific mappings
 136         tableViewInputMap = createInputMap();
 137 
 138         KeyMapping enterKeyActivateMapping, escapeKeyCancelEditMapping;
 139         addDefaultMapping(tableViewInputMap,
 140                 new KeyMapping(TAB, FocusTraversalInputMap::traverseNext),
 141                 new KeyMapping(new KeyBinding(TAB).shift(), FocusTraversalInputMap::traversePrevious),
 142 
 143                 new KeyMapping(HOME, e -&gt; selectFirstRow()),
 144                 new KeyMapping(END, e -&gt; selectLastRow()),
 145 
 146                 new KeyMapping(PAGE_UP, e -&gt; scrollUp()),
 147                 new KeyMapping(PAGE_DOWN, e -&gt; scrollDown()),
 148 
 149                 new KeyMapping(LEFT, e -&gt; selectLeftCell()),
 150                 new KeyMapping(KP_LEFT, e -&gt; selectLeftCell()),
 151                 new KeyMapping(RIGHT, e -&gt; selectRightCell()),
 152                 new KeyMapping(KP_RIGHT, e -&gt; selectRightCell()),
 153 
 154                 new KeyMapping(UP, e -&gt; selectPreviousRow()),
 155                 new KeyMapping(KP_UP, e -&gt; selectPreviousRow()),
 156                 new KeyMapping(DOWN, e -&gt; selectNextRow()),
 157                 new KeyMapping(KP_DOWN, e -&gt; selectNextRow()),
 158 
 159                 new KeyMapping(LEFT, FocusTraversalInputMap::traverseLeft),
 160                 new KeyMapping(KP_LEFT, FocusTraversalInputMap::traverseLeft),
 161                 new KeyMapping(RIGHT, FocusTraversalInputMap::traverseRight),
 162                 new KeyMapping(KP_RIGHT, FocusTraversalInputMap::traverseRight),
 163                 new KeyMapping(UP, FocusTraversalInputMap::traverseUp),
 164                 new KeyMapping(KP_UP, FocusTraversalInputMap::traverseUp),
 165                 new KeyMapping(DOWN, FocusTraversalInputMap::traverseDown),
 166                 new KeyMapping(KP_DOWN, FocusTraversalInputMap::traverseDown),
 167 
 168                 new KeyMapping(new KeyBinding(HOME).shift(), e -&gt; selectAllToFirstRow()),
 169                 new KeyMapping(new KeyBinding(END).shift(), e -&gt; selectAllToLastRow()),
 170                 new KeyMapping(new KeyBinding(PAGE_UP).shift(), e -&gt; selectAllPageUp()),
 171                 new KeyMapping(new KeyBinding(PAGE_DOWN).shift(), e -&gt; selectAllPageDown()),
 172 
 173                 new KeyMapping(new KeyBinding(UP).shift(), e -&gt; alsoSelectPrevious()),
 174                 new KeyMapping(new KeyBinding(KP_UP).shift(), e -&gt; alsoSelectPrevious()),
 175                 new KeyMapping(new KeyBinding(DOWN).shift(), e -&gt; alsoSelectNext()),
 176                 new KeyMapping(new KeyBinding(KP_DOWN).shift(), e -&gt; alsoSelectNext()),
 177 
 178                 new KeyMapping(new KeyBinding(SPACE).shift(), e -&gt; selectAllToFocus(false)),
 179                 new KeyMapping(new KeyBinding(SPACE).shortcut().shift(), e -&gt; selectAllToFocus(true)),
 180 
 181                 new KeyMapping(new KeyBinding(LEFT).shift(), e -&gt; alsoSelectLeftCell()),
 182                 new KeyMapping(new KeyBinding(KP_LEFT).shift(), e -&gt; alsoSelectLeftCell()),
 183                 new KeyMapping(new KeyBinding(RIGHT).shift(), e -&gt; alsoSelectRightCell()),
 184                 new KeyMapping(new KeyBinding(KP_RIGHT).shift(), e -&gt; alsoSelectRightCell()),
 185 
 186                 new KeyMapping(new KeyBinding(UP).shortcut(), e -&gt; focusPreviousRow()),
 187                 new KeyMapping(new KeyBinding(DOWN).shortcut(), e -&gt; focusNextRow()),
 188                 new KeyMapping(new KeyBinding(RIGHT).shortcut(), e -&gt; focusRightCell()),
 189                 new KeyMapping(new KeyBinding(KP_RIGHT).shortcut(), e -&gt; focusRightCell()),
 190                 new KeyMapping(new KeyBinding(LEFT).shortcut(), e -&gt; focusLeftCell()),
 191                 new KeyMapping(new KeyBinding(KP_LEFT).shortcut(), e -&gt; focusLeftCell()),
 192 
 193                 new KeyMapping(new KeyBinding(A).shortcut(), e -&gt; selectAll()),
 194                 new KeyMapping(new KeyBinding(HOME).shortcut(), e -&gt; focusFirstRow()),
 195                 new KeyMapping(new KeyBinding(END).shortcut(), e -&gt; focusLastRow()),
 196                 new KeyMapping(new KeyBinding(PAGE_UP).shortcut(), e -&gt; focusPageUp()),
 197                 new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut(), e -&gt; focusPageDown()),
 198 
 199                 new KeyMapping(new KeyBinding(UP).shortcut().shift(), e -&gt; discontinuousSelectPreviousRow()),
 200                 new KeyMapping(new KeyBinding(DOWN).shortcut().shift(), e -&gt; discontinuousSelectNextRow()),
 201                 new KeyMapping(new KeyBinding(LEFT).shortcut().shift(), e -&gt; discontinuousSelectPreviousColumn()),
 202                 new KeyMapping(new KeyBinding(RIGHT).shortcut().shift(), e -&gt; discontinuousSelectNextColumn()),
 203                 new KeyMapping(new KeyBinding(PAGE_UP).shortcut().shift(), e -&gt; discontinuousSelectPageUp()),
 204                 new KeyMapping(new KeyBinding(PAGE_DOWN).shortcut().shift(), e -&gt; discontinuousSelectPageDown()),
 205                 new KeyMapping(new KeyBinding(HOME).shortcut().shift(), e -&gt; discontinuousSelectAllToFirstRow()),
 206                 new KeyMapping(new KeyBinding(END).shortcut().shift(), e -&gt; discontinuousSelectAllToLastRow()),
 207 
 208                 enterKeyActivateMapping = new KeyMapping(ENTER, this::activate),
 209                 new KeyMapping(SPACE, this::activate),
 210                 new KeyMapping(F2, this::activate),
 211                 escapeKeyCancelEditMapping = new KeyMapping(ESCAPE, this::cancelEdit),
 212 
 213                 new InputMap.MouseMapping(MouseEvent.MOUSE_PRESSED, this::mousePressed)
 214         );
 215 
 216         enterKeyActivateMapping.setAutoConsume(false);
 217         escapeKeyCancelEditMapping.setAutoConsume(false);
 218 
 219         // create OS-specific child mappings
 220         // --- mac OS
 221         InputMap&lt;C&gt; macInputMap = new InputMap&lt;&gt;(control);
 222         macInputMap.setInterceptor(event -&gt; !PlatformUtil.isMac());
 223         addDefaultMapping(macInputMap, new KeyMapping(new KeyBinding(SPACE).shortcut().ctrl(), e -&gt; toggleFocusOwnerSelection()));
 224         addDefaultChildMap(tableViewInputMap, macInputMap);
 225 
 226         // --- all other platforms
 227         InputMap&lt;C&gt; otherOsInputMap = new InputMap&lt;&gt;(control);
 228         otherOsInputMap.setInterceptor(event -&gt; PlatformUtil.isMac());
 229         addDefaultMapping(otherOsInputMap, new KeyMapping(new KeyBinding(SPACE).ctrl(), e -&gt; toggleFocusOwnerSelection()));
 230         addDefaultChildMap(tableViewInputMap, otherOsInputMap);
 231 
 232         // set up other listeners
 233         // We make this an event _filter_ so that we can determine the state
 234         // of the shift key before the event handlers get a shot at the event.
 235         control.addEventFilter(KeyEvent.ANY, keyEventListener);
 236     }
 237 
 238 
 239 
 240     /**************************************************************************
 241      *                                                                        *
 242      * Abstract API                                                           *
 243      *                                                                        *
 244      *************************************************************************/
 245 
 246     /** {@inheritDoc} */
 247     @Override public InputMap&lt;C&gt; getInputMap() {
 248         return tableViewInputMap;
 249     }
 250 
 251     /**
 252      * Call to record the current anchor position
 253      */
 254     protected void setAnchor(TablePositionBase tp) {
 255         TableCellBehaviorBase.setAnchor(getNode(), tp, false);
 256         setSelectionPathDeviated(false);
 257     }
 258 
 259     /**
 260      * Will return the current anchor position.
 261      */
 262     protected TablePositionBase getAnchor() {
 263         return TableCellBehaviorBase.getAnchor(getNode(), getFocusedCell());
 264     }
 265 
 266     /**
 267      * Returns true if there is an anchor set, and false if not anchor is set.
 268      */
 269     protected boolean hasAnchor() {
 270         return TableCellBehaviorBase.hasNonDefaultAnchor(getNode());
 271     }
 272 
 273     /**
 274      * Returns the number of items in the underlying data model.
 275      */
 276     protected abstract int getItemCount();
 277 
 278     /**
 279      * Returns the focus model for the underlying UI control (which must extend
 280      * from TableFocusModel).
 281      */
 282     protected abstract TableFocusModel getFocusModel();
 283 
 284     /**
 285      * Returns the selection model for the underlying UI control (which must extend
 286      * from TableSelectionModel).
 287      */
 288     protected abstract TableSelectionModel&lt;T&gt; getSelectionModel();
 289 
 290     /**
 291      * Returns an observable list of all cells that are currently selected in
 292      * the selection model of the underlying control.
 293      */
 294     protected abstract ObservableList&lt;? extends TablePositionBase/*&lt;C,TC&gt;*/&gt; getSelectedCells();
 295 
 296     /**
 297      * Returns the focused cell from the focus model of the underlying control.
 298      */
 299     protected abstract TablePositionBase getFocusedCell();
 300 
 301     /**
 302      * Returns the position of the given table column in the visible leaf columns
 303      * list of the underlying control.
 304      */
 305     protected abstract int getVisibleLeafIndex(TableColumnBase tc);
 306 
 307     /**
 308      * Returns the column at the given index in the visible leaf columns list of
 309      * the underlying control.
 310      */
 311     protected abstract TableColumnBase getVisibleLeafColumn(int index);
 312 
 313     /**
 314      * Returns true if the control (i.e. TableView / TreeTableView) is editable
 315      */
 316     protected abstract boolean isControlEditable();
 317 
 318     /**
 319      * Begins the edit process in the underlying control for the given row/column
 320      * position.
 321      */
 322     protected abstract void editCell(int row, TableColumnBase tc);
 323 
 324     /**
 325      * Returns an observable list of all visible leaf columns in the underlying
 326      * control.
 327      */
 328     protected abstract ObservableList&lt;? extends TableColumnBase&gt; getVisibleLeafColumns();
 329 
 330     /**
 331      * Creates a TablePositionBase instance using the underlying controls
 332      * concrete implementation for the given row/column intersection.
 333      */
 334     protected abstract TablePositionBase&lt;TC&gt; getTablePosition(int row, TableColumnBase&lt;T,?&gt; tc);
 335 
 336 
 337 
 338     /**************************************************************************
 339      *                                                                        *
 340      * Public API                                                             *
 341      *                                                                        *
 342      *************************************************************************/
 343 
 344     /*
 345      * Anchor is created upon
 346      * - initial selection of an item (by mouse or keyboard)
 347      *
 348      * Anchor is changed when you
 349      * - move the selection to an item by UP/DOWN/LEFT/RIGHT arrow keys
 350      * - select an item by mouse click
 351      * - add/remove an item to/from an existing selection by CTRL+SPACE shortcut
 352      * - add/remove an items to/from an existing selection by CTRL+mouse click
 353      *
 354      * Note that if an item is removed from an existing selection by
 355      * CTRL+SPACE/CTRL+mouse click, anchor still remains on this item even
 356      * though it is not selected.
 357      *
 358      * Anchor is NOT changed when you
 359      * - create linear multi-selection by SHIFT+UP/DOWN/LEFT/RIGHT arrow keys
 360      * - create linear multi-selection by SHIFT+SPACE arrow keys
 361      * - create linear multi-selection by SHIFT+mouse click
 362      *
 363      * In case there is a discontinuous selection in the list, creating linear
 364      * multi-selection between anchor and focused item will cancel the
 365      * discontinuous selection. It means that only items that are located between
 366      * anchor and focused item will be selected.
 367      */
 368     protected void setAnchor(int row, TableColumnBase col) {
 369         setAnchor(row == -1 &amp;&amp; col == null ? null : getTablePosition(row, col));
 370     }
 371 
 372     private Callback&lt;Boolean, Integer&gt; onScrollPageUp;
 373     public void setOnScrollPageUp(Callback&lt;Boolean, Integer&gt; c) { onScrollPageUp = c; }
 374 
 375     private Callback&lt;Boolean, Integer&gt; onScrollPageDown;
 376     public void setOnScrollPageDown(Callback&lt;Boolean, Integer&gt; c) { onScrollPageDown = c; }
 377 
 378     private Runnable onFocusPreviousRow;
 379     public void setOnFocusPreviousRow(Runnable r) { onFocusPreviousRow = r; }
 380 
 381     private Runnable onFocusNextRow;
 382     public void setOnFocusNextRow(Runnable r) { onFocusNextRow = r; }
 383 
 384     private Runnable onSelectPreviousRow;
 385     public void setOnSelectPreviousRow(Runnable r) { onSelectPreviousRow = r; }
 386 
 387     private Runnable onSelectNextRow;
 388     public void setOnSelectNextRow(Runnable r) { onSelectNextRow = r; }
 389 
 390     private Runnable onMoveToFirstCell;
 391     public void setOnMoveToFirstCell(Runnable r) { onMoveToFirstCell = r; }
 392 
 393     private Runnable onMoveToLastCell;
 394     public void setOnMoveToLastCell(Runnable r) { onMoveToLastCell = r; }
 395 
 396     private Runnable onSelectRightCell;
 397     public void setOnSelectRightCell(Runnable r) { onSelectRightCell = r; }
 398 
 399     private Runnable onSelectLeftCell;
 400     public void setOnSelectLeftCell(Runnable r) { onSelectLeftCell = r; }
 401 
 402     private Runnable onFocusRightCell;
 403     public void setOnFocusRightCell(Runnable r) { onFocusRightCell = r; }
 404 
 405     private Runnable onFocusLeftCell;
 406     public void setOnFocusLeftCell(Runnable r) { onFocusLeftCell = r; }
 407 
 408     public void mousePressed(MouseEvent e) {
 409 //        // FIXME can&#39;t assume (yet) cells.get(0) is necessarily the lead cell
 410 //        ObservableList&lt;? extends TablePositionBase&gt; cells = getSelectedCells();
 411 //        setAnchor(cells.isEmpty() ? null : cells.get(0));
 412 
 413         if (!getNode().isFocused() &amp;&amp; getNode().isFocusTraversable()) {
 414             getNode().requestFocus();
 415         }
 416     }
 417 
 418     protected boolean isRTL() {
 419         return (getNode().getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT);
 420     }
 421 
 422 
 423     /**************************************************************************
 424      *                                                                        *
 425      * Private implementation                                                 *
 426      *                                                                        *
 427      *************************************************************************/
 428 
 429     private void setSelectionPathDeviated(boolean selectionPathDeviated) {
 430         this.selectionPathDeviated = selectionPathDeviated;
 431     }
 432 
 433     protected void scrollUp() {
 434         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 435         if (sm == null || getSelectedCells().isEmpty()) return;
 436 
 437         TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);
 438 
 439         int newSelectedIndex = -1;
 440         if (onScrollPageUp != null) {
 441             newSelectedIndex = onScrollPageUp.call(false);
 442         }
 443         if (newSelectedIndex == -1) return;
 444 
 445         sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
 446     }
 447 
 448     protected void scrollDown() {
 449         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 450         if (sm == null || getSelectedCells().isEmpty()) return;
 451 
 452         TablePositionBase&lt;TC&gt; selectedCell = getSelectedCells().get(0);
 453 
 454         int newSelectedIndex = -1;
 455         if (onScrollPageDown != null) {
 456             newSelectedIndex = onScrollPageDown.call(false);
 457         }
 458         if (newSelectedIndex == -1) return;
 459 
 460         sm.clearAndSelect(newSelectedIndex, selectedCell.getTableColumn());
 461     }
 462 
 463     protected void focusFirstRow() {
 464         TableFocusModel fm = getFocusModel();
 465         if (fm == null) return;
 466 
 467         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 468         fm.focus(0, tc);
 469 
 470         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 471     }
 472 
 473     protected void focusLastRow() {
 474         TableFocusModel fm = getFocusModel();
 475         if (fm == null) return;
 476 
 477         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 478         fm.focus(getItemCount() - 1, tc);
 479 
 480         if (onMoveToLastCell != null) onMoveToLastCell.run();
 481     }
 482 
 483     protected void focusPreviousRow() {
 484         TableSelectionModel sm = getSelectionModel();
 485         if (sm == null) return;
 486 
 487         TableFocusModel fm = getFocusModel();
 488         if (fm == null) return;
 489 
 490         if (sm.isCellSelectionEnabled()) {
 491             fm.focusAboveCell();
 492         } else {
 493             fm.focusPrevious();
 494         }
 495 
 496         if (! isShortcutDown || getAnchor() == null) {
 497             setAnchor(fm.getFocusedIndex(), null);
 498         }
 499 
 500         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
 501     }
 502 
 503     protected void focusNextRow() {
 504         TableSelectionModel sm = getSelectionModel();
 505         if (sm == null) return;
 506 
 507         TableFocusModel fm = getFocusModel();
 508         if (fm == null) return;
 509 
 510         if (sm.isCellSelectionEnabled()) {
 511             fm.focusBelowCell();
 512         } else {
 513             fm.focusNext();
 514         }
 515 
 516         if (! isShortcutDown || getAnchor() == null) {
 517             setAnchor(fm.getFocusedIndex(), null);
 518         }
 519 
 520         if (onFocusNextRow != null) onFocusNextRow.run();
 521     }
 522 
 523     protected void focusLeftCell() {
 524         TableSelectionModel sm = getSelectionModel();
 525         if (sm == null) return;
 526 
 527         TableFocusModel fm = getFocusModel();
 528         if (fm == null) return;
 529 
 530         fm.focusLeftCell();
 531         if (onFocusLeftCell != null) onFocusLeftCell.run();
 532     }
 533 
 534     protected void focusRightCell() {
 535         TableSelectionModel sm = getSelectionModel();
 536         if (sm == null) return;
 537 
 538         TableFocusModel fm = getFocusModel();
 539         if (fm == null) return;
 540 
 541         fm.focusRightCell();
 542         if (onFocusRightCell != null) onFocusRightCell.run();
 543     }
 544 
 545     protected void focusPageUp() {
 546         int newFocusIndex = onScrollPageUp.call(true);
 547 
 548         TableFocusModel fm = getFocusModel();
 549         if (fm == null) return;
 550         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 551         fm.focus(newFocusIndex, tc);
 552     }
 553 
 554     protected void focusPageDown() {
 555         int newFocusIndex = onScrollPageDown.call(true);
 556 
 557         TableFocusModel fm = getFocusModel();
 558         if (fm == null) return;
 559         TableColumnBase tc = getFocusedCell() == null ? null : getFocusedCell().getTableColumn();
 560         fm.focus(newFocusIndex, tc);
 561     }
 562 
 563     protected void clearSelection() {
 564         TableSelectionModel sm = getSelectionModel();
 565         if (sm == null) return;
 566 
 567         sm.clearSelection();
 568     }
 569 
 570     protected void clearSelectionOutsideRange(int start, int end, TableColumnBase&lt;T,?&gt; column) {
 571         TableSelectionModel&lt;T&gt; sm = getSelectionModel();
 572         if (sm == null) return;
 573 
 574         int min = Math.min(start, end);
 575         int max = Math.max(start, end);
 576 
 577         List&lt;Integer&gt; indices = new ArrayList&lt;Integer&gt;(sm.getSelectedIndices());
 578 
 579         selectionChanging = true;
 580         for (int i = 0; i &lt; indices.size(); i++) {
 581             int index = indices.get(i);
 582             if (index &lt; min || index &gt; max) {
 583                 sm.clearSelection(index, column);
 584             }
 585         }
 586         selectionChanging = false;
 587     }
 588 
 589     protected void alsoSelectPrevious() {
 590         TableSelectionModel sm = getSelectionModel();
 591         if (sm == null) return;
 592 
 593         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
 594             selectPreviousRow();
 595             return;
 596         }
 597 
 598         TableFocusModel fm = getFocusModel();
 599         if (fm == null) return;
 600 
 601         if (sm.isCellSelectionEnabled()) {
 602             updateCellVerticalSelection(-1, () -&gt; {
 603                 getSelectionModel().selectAboveCell();
 604             });
 605         } else {
 606             if (isShiftDown &amp;&amp; hasAnchor()) {
 607                 updateRowSelection(-1);
 608             } else {
 609                 sm.selectPrevious();
 610             }
 611         }
 612         onSelectPreviousRow.run();
 613     }
 614 
 615     protected void alsoSelectNext() {
 616         TableSelectionModel sm = getSelectionModel();
 617         if (sm == null) return;
 618 
 619         if (sm.getSelectionMode() == SelectionMode.SINGLE) {
 620             selectNextRow();
 621             return;
 622         }
 623 
 624         TableFocusModel fm = getFocusModel();
 625         if (fm == null) return;
 626 
 627         if (sm.isCellSelectionEnabled()) {
 628             updateCellVerticalSelection(1, () -&gt; {
 629                 getSelectionModel().selectBelowCell();
 630             });
 631         } else {
 632             if (isShiftDown &amp;&amp; hasAnchor()) {
 633                 updateRowSelection(1);
 634             } else {
 635                 sm.selectNext();
 636             }
 637         }
 638         onSelectNextRow.run();
 639     }
 640 
 641     protected void alsoSelectLeftCell() {
 642         TableSelectionModel sm = getSelectionModel();
 643         if (sm == null || !sm.isCellSelectionEnabled()) return;
 644 
 645         updateCellHorizontalSelection(-1, () -&gt; getSelectionModel().selectLeftCell());
 646         onSelectLeftCell.run();
 647     }
 648 
 649     protected void alsoSelectRightCell() {
 650         TableSelectionModel sm = getSelectionModel();
 651         if (sm == null || !sm.isCellSelectionEnabled()) return;
 652 
 653         updateCellHorizontalSelection(1, () -&gt; getSelectionModel().selectRightCell());
 654         onSelectRightCell.run();
 655     }
 656 
 657     protected void updateRowSelection(int delta) {
 658         TableSelectionModel sm = getSelectionModel();
 659         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 660 
 661         TableFocusModel fm = getFocusModel();
 662         if (fm == null) return;
 663 
 664         int newRow = fm.getFocusedIndex() + delta;
 665         TablePositionBase anchor = getAnchor();
 666 
 667         if (! hasAnchor()) {
 668             setAnchor(getFocusedCell());
 669         }
 670 
 671         if (sm.getSelectedIndices().size() &gt; 1) {
 672             clearSelectionOutsideRange(anchor.getRow(), newRow, null);
 673         }
 674 
 675         if (anchor.getRow() &gt; newRow) {
 676             sm.selectRange(anchor.getRow(), newRow - 1);
 677         } else {
 678             sm.selectRange(anchor.getRow(), newRow + 1);
 679         }
 680     }
 681 
 682     protected void updateCellVerticalSelection(int delta, Runnable defaultAction) {
 683         TableSelectionModel sm = getSelectionModel();
 684         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 685 
 686         TableFocusModel fm = getFocusModel();
 687         if (fm == null) return;
 688 
 689         final TablePositionBase focusedCell = getFocusedCell();
 690         final int focusedCellRow = focusedCell.getRow();
 691 
 692         if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow + delta, focusedCell.getTableColumn())) {
 693             int newFocusOwner = focusedCellRow + delta;
 694 
 695             // work out if we&#39;re backtracking
 696             boolean backtracking = false;
 697             if (selectionHistory.size() &gt;= 2) {
 698                 TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectionHistory.get(1);
 699                 backtracking = secondToLastSelectedCell.getRow() == newFocusOwner &amp;&amp;
 700                         secondToLastSelectedCell.getColumn() == focusedCell.getColumn();
 701             }
 702 
 703             // if the selection path has deviated from the anchor row / column, then we need to see if we&#39;re moving
 704             // backwards to the previous selection or not (as it determines what cell row we clear out)
 705             int cellRowToClear = selectionPathDeviated ?
 706                     (backtracking ? focusedCellRow : newFocusOwner) :
 707                     focusedCellRow;
 708 
 709             sm.clearSelection(cellRowToClear, focusedCell.getTableColumn());
 710             fm.focus(newFocusOwner, focusedCell.getTableColumn());
 711         } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
 712             int newRow = fm.getFocusedIndex() + delta;
 713 
 714             // we don&#39;t let the newRow go outside the bounds of the data
 715             newRow = Math.max(Math.min(getItemCount() - 1, newRow), 0);
 716 
 717             int start = Math.min(getAnchor().getRow(), newRow);
 718             int end = Math.max(getAnchor().getRow(), newRow);
 719 
 720             if (sm.getSelectedIndices().size() &gt; 1) {
 721                 clearSelectionOutsideRange(start, end, focusedCell.getTableColumn());
 722             }
 723 
 724             for (int _row = start; _row &lt;= end; _row++) {
 725                 if (sm.isSelected(_row, focusedCell.getTableColumn())) {
 726                     continue;
 727                 }
 728                 sm.select(_row, focusedCell.getTableColumn());
 729             }
 730             fm.focus(newRow, focusedCell.getTableColumn());
 731         } else {
 732             final int focusIndex = fm.getFocusedIndex();
 733             if (! sm.isSelected(focusIndex, focusedCell.getTableColumn())) {
 734                 sm.select(focusIndex, focusedCell.getTableColumn());
 735             }
 736             defaultAction.run();
 737         }
 738     }
 739 
 740     protected void updateCellHorizontalSelection(int delta, Runnable defaultAction) {
 741         TableSelectionModel sm = getSelectionModel();
 742         if (sm == null || sm.getSelectionMode() == SelectionMode.SINGLE) return;
 743 
 744         TableFocusModel fm = getFocusModel();
 745         if (fm == null) return;
 746 
 747         final TablePositionBase focusedCell = getFocusedCell();
 748         if (focusedCell == null || focusedCell.getTableColumn() == null) return;
 749 
 750         boolean atEnd = false;
 751         TableColumnBase adjacentColumn = getColumn(focusedCell.getTableColumn(), delta);
 752         if (adjacentColumn == null) {
 753             // if adjacentColumn is null, we use the focusedCell column, as we are
 754             // most probably at the very beginning or end of the row
 755             adjacentColumn = focusedCell.getTableColumn();
 756             atEnd = true;
 757         }
 758 
 759         final int focusedCellRow = focusedCell.getRow();
 760 
 761         if (isShiftDown &amp;&amp; sm.isSelected(focusedCellRow, adjacentColumn)) {
 762             if (atEnd) {
 763                 return;
 764             }
 765 
 766             // work out if we&#39;re backtracking
 767             boolean backtracking = false;
 768             ObservableList&lt;? extends TablePositionBase&gt; selectedCells = getSelectedCells();
 769             if (selectedCells.size() &gt;= 2) {
 770                 TablePositionBase&lt;TC&gt; secondToLastSelectedCell = selectedCells.get(selectedCells.size() - 2);
 771                 backtracking = secondToLastSelectedCell.getRow() == focusedCellRow &amp;&amp;
 772                         secondToLastSelectedCell.getTableColumn().equals(adjacentColumn);
 773             }
 774 
 775             // if the selection path has deviated from the anchor row / column, then we need to see if we&#39;re moving
 776             // backwards to the previous selection or not (as it determines what cell column we clear out)
 777             TableColumnBase&lt;?,?&gt; cellColumnToClear = selectionPathDeviated ?
 778                     (backtracking ? focusedCell.getTableColumn() : adjacentColumn) :
 779                     focusedCell.getTableColumn();
 780 
 781             sm.clearSelection(focusedCellRow, cellColumnToClear);
 782             fm.focus(focusedCellRow, adjacentColumn);
 783         } else if (isShiftDown &amp;&amp; getAnchor() != null &amp;&amp; ! selectionPathDeviated) {
 784             final int anchorColumn = getAnchor().getColumn();
 785 
 786             // we don&#39;t let the newColumn go outside the bounds of the data
 787             int newColumn = getVisibleLeafIndex(focusedCell.getTableColumn()) + delta;
 788             newColumn = Math.max(Math.min(getVisibleLeafColumns().size() - 1, newColumn), 0);
 789 
 790             int start = Math.min(anchorColumn, newColumn);
 791             int end = Math.max(anchorColumn, newColumn);
 792 
 793             for (int _col = start; _col &lt;= end; _col++) {
 794                 sm.select(focusedCell.getRow(), getColumn(_col));
 795             }
 796             fm.focus(focusedCell.getRow(), getColumn(newColumn));
 797         } else {
 798             defaultAction.run();
 799         }
 800     }
 801 
 802     protected TableColumnBase getColumn(int index) {
 803         return getVisibleLeafColumn(index);
 804     }
 805 
 806     protected TableColumnBase getColumn(TableColumnBase tc, int delta) {
 807         return getVisibleLeafColumn(getVisibleLeafIndex(tc) + delta);
 808     }
 809 
 810     protected void selectFirstRow() {
 811         TableSelectionModel sm = getSelectionModel();
 812         if (sm == null) return;
 813 
 814         ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
 815         TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
 816         sm.clearAndSelect(0, selectedColumn);
 817 
 818         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 819     }
 820 
 821     protected void selectLastRow() {
 822         TableSelectionModel sm = getSelectionModel();
 823         if (sm == null) return;
 824 
 825         ObservableList&lt;? extends TablePositionBase&gt; selection = getSelectedCells();
 826         TableColumnBase&lt;?,?&gt; selectedColumn = selection.size() == 0 ? null : selection.get(0).getTableColumn();
 827         sm.clearAndSelect(getItemCount() - 1, selectedColumn);
 828 
 829         if (onMoveToLastCell != null) onMoveToLastCell.run();
 830     }
 831 
 832     protected void selectPreviousRow() {
 833         selectCell(-1, 0);
 834         if (onSelectPreviousRow != null) onSelectPreviousRow.run();
 835     }
 836 
 837     protected void selectNextRow() {
 838         selectCell(1, 0);
 839         if (onSelectNextRow != null) onSelectNextRow.run();
 840     }
 841 
 842     protected void selectLeftCell() {
 843         selectCell(0, -1);
 844         if (onSelectLeftCell != null) onSelectLeftCell.run();
 845     }
 846 
 847     protected void selectRightCell() {
 848         selectCell(0, 1);
 849         if (onSelectRightCell != null) onSelectRightCell.run();
 850     }
 851 
 852     protected void selectCell(int rowDiff, int columnDiff) {
 853         TableSelectionModel sm = getSelectionModel();
 854         if (sm == null) return;
 855 
 856         TableFocusModel fm = getFocusModel();
 857         if (fm == null) return;
 858 
 859         TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
 860         int currentRow = focusedCell.getRow();
 861         int currentColumn = getVisibleLeafIndex(focusedCell.getTableColumn());
 862 
 863         if (rowDiff &gt; 0 &amp;&amp; currentRow &gt;= getItemCount() - 1) return;
 864         else if (columnDiff &lt; 0 &amp;&amp; currentColumn &lt;= 0) return;
 865         else if (columnDiff &gt; 0 &amp;&amp; currentColumn &gt;= getVisibleLeafColumns().size() - 1) return;
 866         else if (columnDiff &gt; 0 &amp;&amp; currentColumn == -1) return;
 867 
 868         TableColumnBase tc = focusedCell.getTableColumn();
 869         tc = getColumn(tc, columnDiff);
 870 
 871         //JDK-8222214: Moved this &quot;if&quot; here because the first row might be focused and not selected, so
 872         // this makes sure it gets selected when the users presses UP. If not it ends calling
 873         // VirtualFlow.scrollTo(-1) at and the content of the TableView disappears.
 874         int row = (currentRow &lt;= 0 &amp;&amp; rowDiff &lt;= 0) ? 0 : focusedCell.getRow() + rowDiff;
 875         sm.clearAndSelect(row, tc);
 876         setAnchor(row, tc);
 877     }
 878 
 879     protected void cancelEdit(KeyEvent e) {
 880         if (isControlEditable()) {
 881             editCell(-1, null);
 882             e.consume();
 883         }
 884     }
 885 
 886     protected void activate(KeyEvent e) {
 887         TableSelectionModel sm = getSelectionModel();
 888         if (sm == null) return;
 889 
 890         TableFocusModel fm = getFocusModel();
 891         if (fm == null) return;
 892 
 893         TablePositionBase&lt;TC&gt; cell = getFocusedCell();
 894         sm.select(cell.getRow(), cell.getTableColumn());
 895         setAnchor(cell);
 896 
 897         // check if we are editable
 898         boolean isEditable = isControlEditable() &amp;&amp; cell.getTableColumn().isEditable();
 899 
 900         // edit this row also
 901         if (isEditable &amp;&amp; cell.getRow() &gt;= 0) {
 902             editCell(cell.getRow(), cell.getTableColumn());
 903             e.consume();
 904         }
 905     }
 906 
 907     protected void selectAllToFocus(boolean setAnchorToFocusIndex) {
 908         TableSelectionModel sm = getSelectionModel();
 909         if (sm == null) return;
 910 
 911         TableFocusModel fm = getFocusModel();
 912         if (fm == null) return;
 913 
 914         TablePositionBase&lt;TC&gt; focusedCell = getFocusedCell();
 915         int focusRow = focusedCell.getRow();
 916 
 917         TablePositionBase&lt;TC&gt; anchor = getAnchor();
 918         int anchorRow = anchor.getRow();
 919 
 920         sm.clearSelection();
 921         if (! sm.isCellSelectionEnabled()) {
 922             int startPos = anchorRow;
 923             int endPos = anchorRow &gt; focusRow ? focusRow - 1 : focusRow + 1;
 924             sm.selectRange(startPos, endPos);
 925         } else {
 926             // we add all cells/rows between the current selection focus and
 927             // the anchor (inclusive) to the current selection.
 928             // We want focus to end up on the current focus position.
 929             sm.selectRange(anchor.getRow(), anchor.getTableColumn(),
 930                            focusedCell.getRow(), focusedCell.getTableColumn());
 931         }
 932 
 933         setAnchor(setAnchorToFocusIndex ? focusedCell : anchor);
 934     }
 935 
 936     protected void selectAll() {
 937         TableSelectionModel sm = getSelectionModel();
 938         if (sm == null) return;
 939         sm.selectAll();
 940     }
 941 
 942     protected void selectAllToFirstRow() {
 943         TableSelectionModel sm = getSelectionModel();
 944         if (sm == null) return;
 945 
 946         TableFocusModel fm = getFocusModel();
 947         if (fm == null) return;
 948 
 949         final boolean isSingleSelection = sm.getSelectionMode() == SelectionMode.SINGLE;
 950         final TablePositionBase focusedCell = getFocusedCell();
 951         final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
 952         int leadIndex = focusedCell.getRow();
 953 
 954         if (isShiftDown) {
 955             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
 956         }
 957 
 958         sm.clearSelection();
 959         if (! sm.isCellSelectionEnabled()) {
 960             // we are going from 0 to one before the focused cell as that is
 961             // the requirement of selectRange, so we call focus on the 0th row
 962             if (isSingleSelection) {
 963                 sm.select(0);
 964             } else {
 965                 sm.selectRange(leadIndex, -1);
 966             }
 967             fm.focus(0);
 968         } else {
 969             if (isSingleSelection) {
 970                 sm.select(0, column);
 971             } else {
 972                 sm.selectRange(leadIndex, column, -1, column);
 973             }
 974             fm.focus(0, column);
 975         }
 976 
 977         if (isShiftDown) {
 978             setAnchor(leadIndex, column);
 979         }
 980 
 981         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
 982     }
 983 
 984     protected void selectAllToLastRow() {
 985         TableSelectionModel sm = getSelectionModel();
 986         if (sm == null) return;
 987 
 988         TableFocusModel fm = getFocusModel();
 989         if (fm == null) return;
 990 
 991         final int itemCount = getItemCount();
 992         final TablePositionBase focusedCell = getFocusedCell();
 993         final TableColumnBase&lt;?,?&gt; column = getFocusedCell().getTableColumn();
 994         int leadIndex = focusedCell.getRow();
 995 
 996         if (isShiftDown) {
 997             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
 998         }
 999 
1000         sm.clearSelection();
1001         if (! sm.isCellSelectionEnabled()) {
1002             sm.selectRange(leadIndex, itemCount);
1003         } else {
1004             sm.selectRange(leadIndex, column, itemCount - 1, column);
1005         }
1006 
1007         if (isShiftDown) {
1008             setAnchor(leadIndex, column);
1009         }
1010 
1011         if (onMoveToLastCell != null) onMoveToLastCell.run();
1012     }
1013 
1014     protected void selectAllPageUp() {
1015         TableSelectionModel sm = getSelectionModel();
1016         if (sm == null) return;
1017 
1018         TableFocusModel fm = getFocusModel();
1019         if (fm == null) return;
1020 
1021         int leadIndex = fm.getFocusedIndex();
1022         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1023         if (isShiftDown) {
1024             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
1025             setAnchor(leadIndex, col);
1026         }
1027 
1028         int leadSelectedIndex = onScrollPageUp.call(false);
1029 
1030         selectionChanging = true;
1031         if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
1032             if (sm.isCellSelectionEnabled()) {
1033                 sm.select(leadSelectedIndex, col);
1034             } else {
1035                 sm.select(leadSelectedIndex);
1036             }
1037         } else {
1038             sm.clearSelection();
1039             if (sm.isCellSelectionEnabled()) {
1040                 sm.selectRange(leadIndex, col, leadSelectedIndex, col);
1041             } else {
1042                 // fix for RT-34407
1043                 int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
1044                 sm.selectRange(leadIndex, leadSelectedIndex + adjust);
1045             }
1046         }
1047         selectionChanging = false;
1048     }
1049 
1050     protected void selectAllPageDown() {
1051         TableSelectionModel sm = getSelectionModel();
1052         if (sm == null) return;
1053 
1054         TableFocusModel fm = getFocusModel();
1055         if (fm == null) return;
1056 
1057         int leadIndex = fm.getFocusedIndex();
1058         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1059         if (isShiftDown) {
1060             leadIndex = getAnchor() == null ? leadIndex : getAnchor().getRow();
1061             setAnchor(leadIndex, col);
1062         }
1063 
1064         int leadSelectedIndex = onScrollPageDown.call(false);
1065 
1066         selectionChanging = true;
1067         if (sm.getSelectionMode() == null || sm.getSelectionMode() == SelectionMode.SINGLE) {
1068             if (sm.isCellSelectionEnabled()) {
1069                 sm.select(leadSelectedIndex, col);
1070             } else {
1071                 sm.select(leadSelectedIndex);
1072             }
1073         } else {
1074             sm.clearSelection();
1075 
1076             if (sm.isCellSelectionEnabled()) {
1077                 sm.selectRange(leadIndex, col, leadSelectedIndex, col);
1078             } else {
1079                 // fix for RT-34407
1080                 int adjust = leadIndex &lt; leadSelectedIndex ? 1 : -1;
1081                 sm.selectRange(leadIndex, leadSelectedIndex + adjust);
1082             }
1083         }
1084         selectionChanging = false;
1085     }
1086 
1087     protected void toggleFocusOwnerSelection() {
1088         TableSelectionModel sm = getSelectionModel();
1089         if (sm == null) return;
1090 
1091         TableFocusModel fm = getFocusModel();
1092         if (fm == null) return;
1093 
1094         TablePositionBase focusedCell = getFocusedCell();
1095 
1096         if (sm.isSelected(focusedCell.getRow(), focusedCell.getTableColumn())) {
1097             sm.clearSelection(focusedCell.getRow(), focusedCell.getTableColumn());
1098             fm.focus(focusedCell.getRow(), focusedCell.getTableColumn());
1099         } else {
1100             sm.select(focusedCell.getRow(), focusedCell.getTableColumn());
1101         }
1102 
1103         setAnchor(focusedCell.getRow(), focusedCell.getTableColumn());
1104     }
1105 
1106     // This functionality was added, but then removed when it was realised by
1107     // UX that TableView should not include &#39;spreadsheet-like&#39; functionality.
1108     // When / if we ever introduce this kind of control, this functionality can
1109     // be re-enabled then.
1110     /*
1111     protected void moveToLeftMostColumn() {
1112         // Functionality as described in RT-12752
1113         if (onMoveToLeftMostColumn != null) onMoveToLeftMostColumn.run();
1114 
1115         TableSelectionModel sm = getSelectionModel();
1116         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1117 
1118         TableFocusModel fm = getFocusModel();
1119         if (fm == null) return;
1120 
1121         TablePosition focusedCell = fm.getFocusedCell();
1122 
1123         TableColumn endColumn = getNode().getVisibleLeafColumn(0);
1124         sm.clearAndSelect(focusedCell.getRow(), endColumn);
1125     }
1126 
1127     protected void moveToRightMostColumn() {
1128         // Functionality as described in RT-12752
1129         if (onMoveToRightMostColumn != null) onMoveToRightMostColumn.run();
1130 
1131         TableSelectionModel sm = getSelectionModel();
1132         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1133 
1134         TableFocusModel fm = getFocusModel();
1135         if (fm == null) return;
1136 
1137         TablePosition focusedCell = fm.getFocusedCell();
1138 
1139         TableColumn endColumn = getNode().getVisibleLeafColumn(getNode().getVisibleLeafColumns().size() - 1);
1140         sm.clearAndSelect(focusedCell.getRow(), endColumn);
1141     }
1142      */
1143 
1144 
1145     /**************************************************************************
1146      * Discontinuous Selection                                                *
1147      *************************************************************************/
1148 
1149     protected void discontinuousSelectPreviousRow() {
1150         TableSelectionModel sm = getSelectionModel();
1151         if (sm == null) return;
1152 
1153         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
1154             selectPreviousRow();
1155             return;
1156         }
1157 
1158         TableFocusModel fm = getFocusModel();
1159         if (fm == null) return;
1160 
1161         int focusIndex = fm.getFocusedIndex();
1162         final int newFocusIndex = focusIndex - 1;
1163         if (newFocusIndex &lt; 0) return;
1164 
1165         int startIndex = focusIndex;
1166         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1167         if (isShiftDown) {
1168             startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
1169         }
1170 
1171         if (! sm.isCellSelectionEnabled()) {
1172             sm.selectRange(newFocusIndex, startIndex + 1);
1173             fm.focus(newFocusIndex);
1174         } else {
1175             for (int i = newFocusIndex; i &lt; startIndex + 1; i++) {
1176                 sm.select(i, col);
1177             }
1178             fm.focus(newFocusIndex, col);
1179         }
1180 
1181         if (onFocusPreviousRow != null) onFocusPreviousRow.run();
1182     }
1183 
1184     protected void discontinuousSelectNextRow() {
1185         TableSelectionModel sm = getSelectionModel();
1186         if (sm == null) return;
1187 
1188         if (sm.getSelectionMode() != SelectionMode.MULTIPLE) {
1189             selectNextRow();
1190             return;
1191         }
1192 
1193         TableFocusModel fm = getFocusModel();
1194         if (fm == null) return;
1195 
1196         int focusIndex = fm.getFocusedIndex();
1197         final int newFocusIndex = focusIndex + 1;
1198         if (newFocusIndex &gt;= getItemCount()) return;
1199 
1200         int startIndex = focusIndex;
1201         final TableColumnBase col = sm.isCellSelectionEnabled() ? getFocusedCell().getTableColumn() : null;
1202         if (isShiftDown) {
1203             startIndex = getAnchor() == null ? focusIndex : getAnchor().getRow();
1204         }
1205 
1206         if (! sm.isCellSelectionEnabled()) {
1207             sm.selectRange(startIndex, newFocusIndex + 1);
1208             fm.focus(newFocusIndex);
1209         } else {
1210             for (int i = startIndex; i &lt; newFocusIndex + 1; i++) {
1211                 sm.select(i, col);
1212             }
1213             fm.focus(newFocusIndex, col);
1214         }
1215 
1216         if (onFocusNextRow != null) onFocusNextRow.run();
1217     }
1218 
1219     protected void discontinuousSelectPreviousColumn() {
1220         TableSelectionModel sm = getSelectionModel();
1221         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1222 
1223         TableFocusModel fm = getFocusModel();
1224         if (fm == null) return;
1225 
1226         TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), -1);
1227         sm.select(fm.getFocusedIndex(), tc);
1228     }
1229 
1230     protected void discontinuousSelectNextColumn() {
1231         TableSelectionModel sm = getSelectionModel();
1232         if (sm == null || ! sm.isCellSelectionEnabled()) return;
1233 
1234         TableFocusModel fm = getFocusModel();
1235         if (fm == null) return;
1236 
1237         TableColumnBase tc = getColumn(getFocusedCell().getTableColumn(), 1);
1238         sm.select(fm.getFocusedIndex(), tc);
1239     }
1240 
1241     protected void discontinuousSelectPageUp() {
1242         TableSelectionModel sm = getSelectionModel();
1243         if (sm == null) return;
1244 
1245         TableFocusModel fm = getFocusModel();
1246         if (fm == null) return;
1247 
1248         int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
1249         int leadSelectedIndex = onScrollPageUp.call(false);
1250 
1251         if (! sm.isCellSelectionEnabled()) {
1252             sm.selectRange(anchor, leadSelectedIndex - 1);
1253         }
1254     }
1255 
1256     protected void discontinuousSelectPageDown() {
1257         TableSelectionModel sm = getSelectionModel();
1258         if (sm == null) return;
1259 
1260         TableFocusModel fm = getFocusModel();
1261         if (fm == null) return;
1262 
1263         int anchor = hasAnchor() ? getAnchor().getRow() : fm.getFocusedIndex();
1264         int leadSelectedIndex = onScrollPageDown.call(false);
1265 
1266         if (! sm.isCellSelectionEnabled()) {
1267             sm.selectRange(anchor, leadSelectedIndex + 1);
1268         }
1269     }
1270 
1271     protected void discontinuousSelectAllToFirstRow() {
1272         TableSelectionModel sm = getSelectionModel();
1273         if (sm == null) return;
1274 
1275         TableFocusModel fm = getFocusModel();
1276         if (fm == null) return;
1277 
1278         int index = fm.getFocusedIndex();
1279 
1280         if (! sm.isCellSelectionEnabled()) {
1281             sm.selectRange(0, index);
1282             fm.focus(0);
1283         } else {
1284             for (int i = 0; i &lt; index; i++) {
1285                 sm.select(i, getFocusedCell().getTableColumn());
1286             }
1287             fm.focus(0, getFocusedCell().getTableColumn());
1288         }
1289 
1290         if (onMoveToFirstCell != null) onMoveToFirstCell.run();
1291     }
1292 
1293     protected void discontinuousSelectAllToLastRow() {
1294         TableSelectionModel sm = getSelectionModel();
1295         if (sm == null) return;
1296 
1297         TableFocusModel fm = getFocusModel();
1298         if (fm == null) return;
1299 
1300         int index = fm.getFocusedIndex() + 1;
1301 
1302         if (! sm.isCellSelectionEnabled()) {
1303             sm.selectRange(index, getItemCount());
1304         } else {
1305             for (int i = index; i &lt; getItemCount(); i++) {
1306                 sm.select(i, getFocusedCell().getTableColumn());
1307             }
1308         }
1309 
1310         if (onMoveToLastCell != null) onMoveToLastCell.run();
1311     }
1312 }
    </pre>
  </body>
</html>