<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/TextInputControl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.FormatterAccessor;
  29 import javafx.beans.DefaultProperty;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.beans.binding.IntegerBinding;
  33 import javafx.beans.binding.StringBinding;
  34 import javafx.beans.property.BooleanProperty;
  35 import javafx.beans.property.ObjectProperty;
  36 import javafx.beans.property.ObjectPropertyBase;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.property.ReadOnlyBooleanWrapper;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.ReadOnlyStringProperty;
  44 import javafx.beans.property.ReadOnlyStringWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.beans.value.ObservableStringValue;
  50 import javafx.beans.value.ObservableValue;
  51 import javafx.beans.value.WritableValue;
  52 import javafx.css.CssMetaData;
  53 import javafx.css.FontCssMetaData;
  54 import javafx.css.PseudoClass;
  55 import javafx.css.StyleOrigin;
  56 import javafx.css.Styleable;
  57 import javafx.css.StyleableObjectProperty;
  58 import javafx.css.StyleableProperty;
  59 import javafx.scene.AccessibleAction;
  60 import javafx.scene.AccessibleAttribute;
  61 import javafx.scene.input.Clipboard;
  62 import javafx.scene.input.ClipboardContent;
  63 import javafx.scene.text.Font;
  64 
  65 import java.text.BreakIterator;
  66 import java.util.ArrayList;
  67 import java.util.Collections;
  68 import java.util.List;
  69 
  70 import com.sun.javafx.util.Utils;
  71 import com.sun.javafx.binding.ExpressionHelper;
  72 import com.sun.javafx.scene.NodeHelper;
  73 import javafx.util.StringConverter;
  74 
  75 /**
  76  * Abstract base class for text input controls.
  77  * @since JavaFX 2.0
  78  */
  79 @DefaultProperty(&quot;text&quot;)
  80 public abstract class TextInputControl extends Control {
  81     /**
  82      * Interface representing a text input&#39;s content. Since it is an ObservableStringValue,
  83      * you can also bind to, or observe the content.
  84      * @since JavaFX 2.0
  85      */
  86     protected interface Content extends ObservableStringValue {
  87         /**
  88          * Retrieves a subset of the content.
  89          *
  90          * @param start the start
  91          * @param end the end
  92          * @return a subset of the content
  93          */
  94         public String get(int start, int end);
  95 
  96         /**
  97          * Inserts a sequence of characters into the content.
  98          *
  99          * @param index the index
 100          * @param text the text string
 101          * @param notifyListeners the notify listener flag
 102          * @since JavaFX 2.1
 103          */
 104         public void insert(int index, String text, boolean notifyListeners);
 105 
 106         /**
 107          * Removes a sequence of characters from the content.
 108          *
 109          * @param start the start
 110          * @param end the end
 111          * @param notifyListeners the notify listener flag
 112          * @since JavaFX 2.1
 113          */
 114         public void delete(int start, int end, boolean notifyListeners);
 115 
 116         /**
 117          * Returns the number of characters represented by the content.
 118          * @return the number of characters
 119          */
 120         public int length();
 121     }
 122 
 123     /***************************************************************************
 124      *                                                                         *
 125      * Constructors                                                            *
 126      *                                                                         *
 127      **************************************************************************/
 128 
 129     /**
 130      * Creates a new TextInputControl. The content is an immutable property and
 131      * must be specified (as non-null) at the time of construction.
 132      *
 133      * @param content a non-null implementation of Content.
 134      */
 135     protected TextInputControl(final Content content) {
 136         this.content = content;
 137 
 138         // Add a listener so that whenever the Content is changed, we notify
 139         // listeners of the text property that it is invalid.
 140         content.addListener(observable -&gt; {
 141             if (content.length() &gt; 0) {
 142                 text.textIsNull = false;
 143             }
 144             text.controlContentHasChanged();
 145         });
 146 
 147         // Bind the length to be based on the length of the text property
 148         length.bind(new IntegerBinding() {
 149             { bind(text); }
 150             @Override protected int computeValue() {
 151                 String txt = text.get();
 152                 return txt == null ? 0 : txt.length();
 153             }
 154         });
 155 
 156         // Bind the selected text to be based on the selection and text properties
 157         selectedText.bind(new StringBinding() {
 158             { bind(selection, text); }
 159             @Override protected String computeValue() {
 160                 String txt = text.get();
 161                 IndexRange sel = selection.get();
 162                 if (txt == null || sel == null) return &quot;&quot;;
 163 
 164                 int start = sel.getStart();
 165                 int end = sel.getEnd();
 166                 int length = txt.length();
 167                 if (end &gt; start + length) end = length;
 168                 if (start &gt; length-1) start = end = 0;
 169                 return txt.substring(start, end);
 170             }
 171         });
 172 
 173         focusedProperty().addListener((ob, o, n) -&gt; {
 174             if (n) {
 175                 if (getTextFormatter() != null) {
 176                     updateText(getTextFormatter());
 177                 }
 178             } else {
 179                 commitValue();
 180             }
 181         });
 182 
 183         // Specify the default style class
 184         getStyleClass().add(&quot;text-input&quot;);
 185     }
 186 
 187     /***************************************************************************
 188      *                                                                         *
 189      * Properties                                                              *
 190      *                                                                         *
 191      **************************************************************************/
 192 
 193     /**
 194      * The default font to use for text in the TextInputControl. If the TextInputControl&#39;s text is
 195      * rich text then this font may or may not be used depending on the font
 196      * information embedded in the rich text, but in any case where a default
 197      * font is required, this font will be used.
 198      * @return the font property
 199      * @since JavaFX 8.0
 200      */
 201     public final ObjectProperty&lt;Font&gt; fontProperty() {
 202         if (font == null) {
 203             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 204 
 205 
 206                 private boolean fontSetByCss = false;
 207 
 208                 @Override
 209                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 210 
 211                     //
 212                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 213                     //
 214                     try {
 215                         // super.applyStyle calls set which might throw if value is bound.
 216                         // Have to make sure fontSetByCss is reset.
 217                         fontSetByCss = true;
 218                         super.applyStyle(newOrigin, value);
 219                     } catch(Exception e) {
 220                         throw e;
 221                     } finally {
 222                         fontSetByCss = false;
 223                     }
 224 
 225                 }
 226 
 227 
 228                 @Override
 229                 public void set(Font value) {
 230                     final Font oldValue = get();
 231                     if (value == null ? oldValue == null : value.equals(oldValue)) {
 232                         return;
 233                     }
 234                     super.set(value);
 235                 }
 236 
 237                 @Override
 238                 protected void invalidated() {
 239                     // RT-20727 - if font is changed by calling setFont, then
 240                     // css might need to be reapplied since font size affects
 241                     // calculated values for styles with relative values
 242                     if(fontSetByCss == false) {
 243                         NodeHelper.reapplyCSS(TextInputControl.this);
 244                     }
 245                 }
 246 
 247                 @Override
 248                 public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
 249                     return StyleableProperties.FONT;
 250                 }
 251 
 252                 @Override
 253                 public Object getBean() {
 254                     return TextInputControl.this;
 255                 }
 256 
 257                 @Override
 258                 public String getName() {
 259                     return &quot;font&quot;;
 260                 }
 261             };
 262         }
 263         return font;
 264     }
 265 
 266     private ObjectProperty&lt;Font&gt; font;
 267     public final void setFont(Font value) { fontProperty().setValue(value); }
 268     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 269 
 270     /**
 271      * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
 272      * prompt text is displayed.
 273      *
 274      * @defaultValue An empty String
 275      * @since JavaFX 2.2
 276      */
 277     private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
 278         @Override protected void invalidated() {
 279             // Strip out newlines
 280             String txt = get();
 281             if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
 282                 txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
 283                 set(txt);
 284             }
 285         }
 286     };
 287     public final StringProperty promptTextProperty() { return promptText; }
 288     public final String getPromptText() { return promptText.get(); }
 289     public final void setPromptText(String value) { promptText.set(value); }
 290 
 291 
 292     /**
 293      * The property contains currently attached {@link TextFormatter}.
 294      * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
 295      *
 296      * @defaultValue null
 297      * @since JavaFX 8u40
 298      */
 299     private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {
 300 
 301         private TextFormatter&lt;?&gt; oldFormatter = null;
 302 
 303         @Override
 304         public Object getBean() {
 305             return TextInputControl.this;
 306         }
 307 
 308         @Override
 309         public String getName() {
 310             return &quot;textFormatter&quot;;
 311         }
 312 
 313         @Override
 314         protected void invalidated() {
 315             final TextFormatter&lt;?&gt; formatter = get();
 316             try {
 317                 if (formatter != null) {
 318                     try {
 319                         formatter.bindToControl(f -&gt; updateText(f));
 320                     } catch (IllegalStateException e) {
 321                         if (isBound()) {
 322                             unbind();
 323                         }
 324                         set(null);
 325                         throw e;
 326                     }
 327                     if (!isFocused()) {
 328                         updateText(get());
 329                     }
 330                 }
 331 
 332                 if (oldFormatter != null) {
 333                     oldFormatter.unbindFromControl();
 334                 }
 335             } finally {
 336                 oldFormatter = formatter;
 337             }
 338         }
 339     };
 340     public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
 341     public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
 342     public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }
 343 
 344     private final Content content;
 345     /**
 346      * Returns the text input&#39;s content model.
 347      * @return the text input&#39;s content model
 348      */
 349     protected final Content getContent() {
 350         return content;
 351     }
 352 
 353     /**
 354      * The textual content of this TextInputControl.
 355      */
 356     private TextProperty text = new TextProperty();
 357     public final String getText() { return text.get(); }
 358     public final void setText(String value) { text.set(value); }
 359     public final StringProperty textProperty() { return text; }
 360 
 361     /**
 362      * The number of characters in the text input.
 363      */
 364     private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
 365     public final int getLength() { return length.get(); }
 366     public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }
 367 
 368     /**
 369      * Indicates whether this TextInputControl can be edited by the user.
 370      */
 371     private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
 372         @Override protected void invalidated() {
 373             pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
 374         }
 375     };
 376     public final boolean isEditable() { return editable.getValue(); }
 377     public final void setEditable(boolean value) { editable.setValue(value); }
 378     public final BooleanProperty editableProperty() { return editable; }
 379 
 380     /**
 381      * The current selection.
 382      */
 383     private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
 384     public final IndexRange getSelection() { return selection.getValue(); }
 385     public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }
 386 
 387     /**
 388      * Defines the characters in the TextInputControl which are selected
 389      */
 390     private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
 391     public final String getSelectedText() { return selectedText.get(); }
 392     public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }
 393 
 394     /**
 395      * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
 396      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 397      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 398      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 399      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 400      * the anchor might represent the lower or upper bound of the selection.
 401      */
 402     private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
 403     public final int getAnchor() { return anchor.get(); }
 404     public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }
 405 
 406     /**
 407      * The current position of the caret within the text.
 408      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 409      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 410      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 411      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 412      * the caretPosition might represent the lower or upper bound of the selection.
 413      */
 414     private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
 415     public final int getCaretPosition() { return caretPosition.get(); }
 416     public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }
 417 
 418     private UndoRedoChange undoChangeHead = new UndoRedoChange();
 419     private UndoRedoChange undoChange = undoChangeHead;
 420     private boolean createNewUndoRecord = false;
 421 
 422     /**
 423      * The property describes if it&#39;s currently possible to undo the latest change of the content that was done.
 424      * @defaultValue false
 425      * @since JavaFX 8u40
 426      */
 427     private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
 428     public final boolean isUndoable() { return undoable.get(); }
 429     public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }
 430 
 431 
 432     /**
 433      * The property describes if it&#39;s currently possible to redo the latest change of the content that was undone.
 434      * @defaultValue false
 435      * @since JavaFX 8u40
 436      */
 437     private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
 438     public final boolean isRedoable() { return redoable.get(); }
 439     public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }
 440 
 441     /***************************************************************************
 442      *                                                                         *
 443      * Methods                                                                 *
 444      *                                                                         *
 445      **************************************************************************/
 446 
 447     /**
 448      * Returns a subset of the text input&#39;s content.
 449      *
 450      * @param start must be a value between 0 and end - 1.
 451      * @param end must be less than or equal to the length
 452      * @return the subset of the text input&#39;s content
 453      */
 454     public String getText(int start, int end) {
 455         if (start &gt; end) {
 456             throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
 457         }
 458 
 459         if (start &lt; 0
 460             || end &gt; getLength()) {
 461             throw new IndexOutOfBoundsException();
 462         }
 463 
 464         return getContent().get(start, end);
 465     }
 466 
 467     /**
 468      * Appends a sequence of characters to the content.
 469      *
 470      * @param text a non null String
 471      */
 472     public void appendText(String text) {
 473         insertText(getLength(), text);
 474     }
 475 
 476     /**
 477      * Inserts a sequence of characters into the content.
 478      *
 479      * @param index The location to insert the text.
 480      * @param text The text to insert.
 481      */
 482     public void insertText(int index, String text) {
 483         replaceText(index, index, text);
 484     }
 485 
 486     /**
 487      * Removes a range of characters from the content.
 488      *
 489      * @param range The range of text to delete. The range object must not be null.
 490      *
 491      * @see #deleteText(int, int)
 492      */
 493     public void deleteText(IndexRange range) {
 494         replaceText(range, &quot;&quot;);
 495     }
 496 
 497     /**
 498      * Removes a range of characters from the content.
 499      *
 500      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 501      * @param end The ending index in the range, exclusive. This is one-past the last character to
 502      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 503      *            and &amp;lt;= the length of the text.
 504      */
 505     public void deleteText(int start, int end) {
 506         replaceText(start, end, &quot;&quot;);
 507     }
 508 
 509     /**
 510      * Replaces a range of characters with the given text.
 511      *
 512      * @param range The range of text to replace. The range object must not be null.
 513      * @param text The text that is to replace the range. This must not be null.
 514      *
 515      * @see #replaceText(int, int, String)
 516      */
 517     public void replaceText(IndexRange range, String text) {
 518         final int start = range.getStart();
 519         final int end = start + range.getLength();
 520         replaceText(start, end, text);
 521     }
 522 
 523     /**
 524      * Replaces a range of characters with the given text.
 525      *
 526      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 527      * @param end The ending index in the range, exclusive. This is one-past the last character to
 528      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 529      *            and &amp;lt;= the length of the text.
 530      * @param text The text that is to replace the range. This must not be null.
 531      */
 532     public void replaceText(final int start, final int end, final String text) {
 533         if (start &gt; end) {
 534             throw new IllegalArgumentException();
 535         }
 536 
 537         if (text == null) {
 538             throw new NullPointerException();
 539         }
 540 
 541         if (start &lt; 0
 542             || end &gt; getLength()) {
 543             throw new IndexOutOfBoundsException();
 544         }
 545 
 546         if (!this.text.isBound()) {
 547             final int oldLength = getLength();
 548             TextFormatter&lt;?&gt; formatter = getTextFormatter();
 549             TextFormatter.Change change;
 550             if (formatter != null &amp;&amp; formatter.getFilter() != null) {
 551                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
 552                 change = formatter.getFilter().apply(change);
 553                 if (change == null) {
 554                     return;
 555                 }
 556             } else {
 557                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, filterInput(text));
 558             }
 559 
 560             // Update the content
 561             updateContent(change, oldLength == 0);
 562 
 563         }
 564     }
 565 
 566     private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
 567         final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
 568         String oldText = getText(change.start, change.end);
 569         int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
 570         String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
 571         if (newText.equals(oldText)) {
 572             // Undo record not required as there is no change in the text.
 573             return;
 574         }
 575 
 576         /*
 577          * A new undo record is created, if
 578          * 1. createNewUndoRecord is true, currently it is set to true for paste operation
 579          * 2. Text is selected and a character is typed
 580          * 3. This is the first operation to be added to undo record
 581          * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
 582          * 5. Space character is typed
 583          * 6. 2500 milliseconds are elapsed since the undo record was created
 584          * 7. Cursor position is changed and a character is typed
 585          * 8. A range of text is replaced programmatically using replaceText()
 586          * Otherwise, the last undo record is updated or discarded.
 587          */
 588 
 589         int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
 590         boolean isNewSpaceChar = false;
 591         if (newText.equals(&quot; &quot;)) {
 592             if (!UndoRedoChange.isSpaceCharSequence()) {
 593                 isNewSpaceChar = true;
 594                 UndoRedoChange.setSpaceCharSequence(true);
 595             }
 596         } else {
 597             UndoRedoChange.setSpaceCharSequence(false);
 598         }
 599         if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
 600                 isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
 601                 (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
 602             undoChange = undoChange.add(change.start, oldText, newText);
 603         } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
 604             // I know I am deleting, and am located at the end of the range of the current undo record
 605             if (undoChange.newText.length() &gt; 0) {
 606                 undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
 607                 if (undoChange.newText.isEmpty()) {
 608                     // throw away this undo change record
 609                     undoChange = undoChange.discard();
 610                 }
 611             } else {
 612                 if (change.start == endOfUndoChange) {
 613                     undoChange.oldText += oldText;
 614                 } else { // end == endOfUndoChange
 615                     undoChange.oldText = oldText + undoChange.oldText;
 616                     undoChange.start--;
 617                 }
 618             }
 619         } else {
 620             // I know I am adding, and am located at the end of the range of the current undo record
 621             undoChange.newText += newText;
 622         }
 623         updateUndoRedoState();
 624     }
 625 
 626     /**
 627      * Transfers the currently selected range in the text to the clipboard,
 628      * removing the current selection.
 629      */
 630     public void cut() {
 631         copy();
 632         IndexRange selection = getSelection();
 633         deleteText(selection.getStart(), selection.getEnd());
 634     }
 635 
 636     /**
 637      * Transfers the currently selected range in the text to the clipboard,
 638      * leaving the current selection.
 639      */
 640      public void copy() {
 641         final String selectedText = getSelectedText();
 642         if (selectedText.length() &gt; 0) {
 643             final ClipboardContent content = new ClipboardContent();
 644             content.putString(selectedText);
 645             Clipboard.getSystemClipboard().setContent(content);
 646         }
 647     }
 648 
 649     /**
 650      * Transfers the contents in the clipboard into this text,
 651      * replacing the current selection.  If there is no selection, the contents
 652      * in the clipboard is inserted at the current caret position.
 653      */
 654     public void paste() {
 655         final Clipboard clipboard = Clipboard.getSystemClipboard();
 656         if (clipboard.hasString()) {
 657             final String text = clipboard.getString();
 658             if (text != null) {
 659                 createNewUndoRecord = true;
 660                 try {
 661                     replaceSelection(text);
 662                 } finally {
 663                     createNewUndoRecord = false;
 664                 }
 665             }
 666         }
 667     }
 668 
 669     /**
 670      * Moves the selection backward one char in the text. This may have the
 671      * effect of deselecting, depending on the location of the anchor relative
 672      * to the caretPosition. This function effectively just moves the caretPosition.
 673      */
 674     public void selectBackward() {
 675         if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
 676             // because the anchor stays put, by moving the caret to the left
 677             // we ensure that a selection is registered and that it is correct
 678             if (charIterator == null) {
 679                 charIterator = BreakIterator.getCharacterInstance();
 680             }
 681             charIterator.setText(getText());
 682             selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
 683         }
 684     }
 685 
 686     /**
 687      * Moves the selection forward one char in the text. This may have the
 688      * effect of deselecting, depending on the location of the anchor relative
 689      * to the caretPosition. This function effectively just moves the caret forward.
 690      */
 691     public void selectForward() {
 692         final int textLength = getLength();
 693         if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
 694             if (charIterator == null) {
 695                 charIterator = BreakIterator.getCharacterInstance();
 696             }
 697             charIterator.setText(getText());
 698             selectRange(getAnchor(), charIterator.following(getCaretPosition()));
 699         }
 700     }
 701 
 702     /**
 703      * The break iterator instances for navigation over words and complex characters.
 704      */
 705     private BreakIterator charIterator;
 706     private BreakIterator wordIterator;
 707 
 708     /**
 709      * Moves the caret to the beginning of previous word. This function
 710      * also has the effect of clearing the selection.
 711      */
 712     public void previousWord() {
 713         previousWord(false);
 714     }
 715 
 716     /**
 717      * Moves the caret to the beginning of next word. This function
 718      * also has the effect of clearing the selection.
 719      */
 720     public void nextWord() {
 721         nextWord(false);
 722     }
 723 
 724     /**
 725      * Moves the caret to the end of the next word. This function
 726      * also has the effect of clearing the selection.
 727      */
 728     public void endOfNextWord() {
 729         endOfNextWord(false);
 730     }
 731 
 732     /**
 733      * Moves the caret to the beginning of previous word. This does not cause
 734      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 735      * moved to the beginning of previous word.
 736      */
 737     public void selectPreviousWord() {
 738         previousWord(true);
 739     }
 740 
 741     /**
 742      * Moves the caret to the beginning of next word. This does not cause
 743      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 744      * moved to the beginning of next word.
 745      */
 746     public void selectNextWord() {
 747         nextWord(true);
 748     }
 749 
 750     /**
 751      * Moves the caret to the end of the next word. This does not cause
 752      * the selection to be cleared.
 753      */
 754     public void selectEndOfNextWord() {
 755         endOfNextWord(true);
 756     }
 757 
 758     private void previousWord(boolean select) {
 759         final int textLength = getLength();
 760         final String text = getText();
 761         if (textLength &lt;= 0) {
 762             return;
 763         }
 764 
 765         if (wordIterator == null) {
 766             wordIterator = BreakIterator.getWordInstance();
 767         }
 768         wordIterator.setText(text);
 769 
 770         int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));
 771 
 772         // Skip the non-word region, then move/select to the beginning of the word.
 773         while (pos != BreakIterator.DONE &amp;&amp;
 774                !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
 775             pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
 776         }
 777 
 778         // move/select
 779         selectRange(select ? getAnchor() : pos, pos);
 780     }
 781 
 782     private void nextWord(boolean select) {
 783         final int textLength = getLength();
 784         final String text = getText();
 785         if (textLength &lt;= 0) {
 786             return;
 787         }
 788 
 789         if (wordIterator == null) {
 790             wordIterator = BreakIterator.getWordInstance();
 791         }
 792         wordIterator.setText(text);
 793 
 794         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
 795         int current = wordIterator.next();
 796 
 797         // Skip whitespace characters to the beginning of next word, but
 798         // stop at newline. Then move the caret or select a range.
 799         while (current != BreakIterator.DONE) {
 800             for (int p=last; p&lt;=current; p++) {
 801                 char ch = text.charAt(Utils.clamp(0, p, textLength-1));
 802                 // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
 803                 // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
 804                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39;) {
 805                     if (select) {
 806                         selectRange(getAnchor(), p);
 807                     } else {
 808                         selectRange(p, p);
 809                     }
 810                     return;
 811                 }
 812             }
 813             last = current;
 814             current = wordIterator.next();
 815         }
 816 
 817         // move/select to the end
 818         if (select) {
 819             selectRange(getAnchor(), textLength);
 820         } else {
 821             end();
 822         }
 823     }
 824 
 825     private void endOfNextWord(boolean select) {
 826         final int textLength = getLength();
 827         final String text = getText();
 828         if (textLength &lt;= 0) {
 829             return;
 830         }
 831 
 832         if (wordIterator == null) {
 833             wordIterator = BreakIterator.getWordInstance();
 834         }
 835         wordIterator.setText(text);
 836 
 837         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
 838         int current = wordIterator.next();
 839 
 840         // skip the non-word region, then move/select to the end of the word.
 841         while (current != BreakIterator.DONE) {
 842             for (int p=last; p&lt;=current; p++) {
 843                 if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
 844                     if (select) {
 845                         selectRange(getAnchor(), p);
 846                     } else {
 847                         selectRange(p, p);
 848                     }
 849                     return;
 850                 }
 851             }
 852             last = current;
 853             current = wordIterator.next();
 854         }
 855 
 856         // move/select to the end
 857         if (select) {
 858             selectRange(getAnchor(), textLength);
 859         } else {
 860             end();
 861         }
 862     }
 863 
 864     /**
 865      * Selects all text in the text input.
 866      */
 867     public void selectAll() {
 868         selectRange(0, getLength());
 869     }
 870 
 871     /**
 872      * Moves the caret to before the first char of the text. This function
 873      * also has the effect of clearing the selection.
 874      */
 875     public void home() {
 876         // user wants to go to start
 877         selectRange(0, 0);
 878     }
 879 
 880     /**
 881      * Moves the caret to after the last char of the text. This function
 882      * also has the effect of clearing the selection.
 883      */
 884     public void end() {
 885         // user wants to go to end
 886         final int textLength = getLength();
 887         if (textLength &gt; 0) {
 888             selectRange(textLength, textLength);
 889         }
 890     }
 891 
 892     /**
 893      * Moves the caret to before the first char of text. This does not cause
 894      * the selection to be cleared. Rather, the anchor stays put and the
 895      * caretPosition is moved to before the first char.
 896      */
 897     public void selectHome() {
 898         selectRange(getAnchor(), 0);
 899     }
 900 
 901     /**
 902      * Moves the caret to after the last char of text. This does not cause
 903      * the selection to be cleared. Rather, the anchor stays put and the
 904      * caretPosition is moved to after the last char.
 905      */
 906     public void selectEnd() {
 907         final int textLength = getLength();
 908         if (textLength &gt; 0) selectRange(getAnchor(), textLength);
 909     }
 910 
 911     /**
 912      * Deletes the character that precedes the current caret position from the
 913      * text if there is no selection, or deletes the selection if there is one.
 914      * This function returns true if the deletion succeeded, false otherwise.
 915      * @return true if the deletion succeeded, false otherwise
 916      */
 917     public boolean deletePreviousChar() {
 918         boolean failed = true;
 919         if (isEditable() &amp;&amp; !isDisabled()) {
 920             final String text = getText();
 921             final int dot = getCaretPosition();
 922             final int mark = getAnchor();
 923             if (dot != mark) {
 924                 // there is a selection of text to remove
 925                 replaceSelection(&quot;&quot;);
 926                 failed = false;
 927             } else if (dot &gt; 0) {
 928                 // The caret is not at the beginning, so remove some characters.
 929                 // Typically you&#39;d only be removing a single character, but
 930                 // in some cases you must remove two depending on the unicode
 931                 // characters
 932                 // Note: Do not use charIterator here, because we do want to
 933                 // break up clusters when deleting backwards.
 934                 int p = Character.offsetByCodePoints(text, dot, -1);
 935                 deleteText(p, dot);
 936                 failed = false;
 937             }
 938         }
 939         return !failed;
 940     }
 941 
 942     /**
 943      * Deletes the character that follows the current caret position from the
 944      * text if there is no selection, or deletes the selection if there is one.
 945      * This function returns true if the deletion succeeded, false otherwise.
 946      * @return true if the deletion succeeded, false otherwise
 947      */
 948     public boolean deleteNextChar() {
 949         boolean failed = true;
 950         if (isEditable() &amp;&amp; !isDisabled()) {
 951             final int textLength = getLength();
 952             final String text = getText();
 953             final int dot = getCaretPosition();
 954             final int mark = getAnchor();
 955             if (dot != mark) {
 956                 // there is a selection of text to remove
 957                 replaceSelection(&quot;&quot;);
 958                 failed = false;
 959             } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
 960                 // The caret is not at the end, so remove some characters.
 961                 // Typically you&#39;d only be removing a single character, but
 962                 // in some cases you must remove two depending on the unicode
 963                 // characters
 964                 if (charIterator == null) {
 965                     charIterator = BreakIterator.getCharacterInstance();
 966                 }
 967                 charIterator.setText(text);
 968                 int p = charIterator.following(dot);
 969                 deleteText(dot, p);
 970                 failed = false;
 971             }
 972         }
 973         return !failed;
 974     }
 975 
 976     /**
 977      * Moves the caret position forward. If there is no selection, then the
 978      * caret position is moved one character forward. If there is a selection,
 979      * then the caret position is moved to the end of the selection and
 980      * the selection cleared.
 981      */
 982     public void forward() {
 983         // user has moved caret to the right
 984         final int textLength = getLength();
 985         final int dot = getCaretPosition();
 986         final int mark = getAnchor();
 987         if (dot != mark) {
 988             int pos = Math.max(dot, mark);
 989             selectRange(pos, pos);
 990         } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
 991             if (charIterator == null) {
 992                 charIterator = BreakIterator.getCharacterInstance();
 993             }
 994             charIterator.setText(getText());
 995             int pos = charIterator.following(dot);
 996             selectRange(pos, pos);
 997         }
 998         deselect();
 999     }
1000 
1001     /**
1002      * Moves the caret position backward. If there is no selection, then the
1003      * caret position is moved one character backward. If there is a selection,
1004      * then the caret position is moved to the beginning of the selection and
1005      * the selection cleared.
1006      *
1007      * Note: This function is intended to be used by experts, primarily
1008      *       by those implementing new Skins or Behaviors. It is not common
1009      *       for developers or designers to access this function directly.
1010      */
1011     public void backward() {
1012         // user has moved caret to the left
1013         final int textLength = getLength();
1014         final int dot = getCaretPosition();
1015         final int mark = getAnchor();
1016         if (dot != mark) {
1017             int pos = Math.min(dot, mark);
1018             selectRange(pos, pos);
1019         } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
1020             if (charIterator == null) {
1021                 charIterator = BreakIterator.getCharacterInstance();
1022             }
1023             charIterator.setText(getText());
1024             int pos = charIterator.preceding(dot);
1025             selectRange(pos, pos);
1026         }
1027         deselect();
1028     }
1029 
1030     /**
1031      * Positions the caret to the position indicated by {@code pos}. This
1032      * function will also clear the selection.
1033      * @param pos the position
1034      */
1035     public void positionCaret(int pos) {
1036         final int p = Utils.clamp(0, pos, getLength());
1037         selectRange(p, p);
1038     }
1039 
1040     /**
1041      * Positions the caret to the position indicated by {@code pos} and extends
1042      * the selection, if there is one. If there is no selection, then a
1043      * selection is formed where the anchor is at the current caret position
1044      * and the caretPosition is moved to pos.
1045      * @param pos the position
1046      */
1047     public void selectPositionCaret(int pos) {
1048         selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
1049     }
1050 
1051     /**
1052      * Positions the anchor and caretPosition explicitly.
1053      * @param anchor the anchor
1054      * @param caretPosition the caretPosition
1055      */
1056     public void selectRange(int anchor, int caretPosition) {
1057         caretPosition = Utils.clamp(0, caretPosition, getLength());
1058         anchor = Utils.clamp(0, anchor, getLength());
1059 
1060         TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
1061         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1062         if (formatter != null &amp;&amp; formatter.getFilter() != null) {
1063             change = formatter.getFilter().apply(change);
1064             if (change == null) {
1065                 return;
1066             }
1067         }
1068 
1069         updateContent(change, false);
1070     }
1071 
1072     private void doSelectRange(int anchor, int caretPosition) {
1073         this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
1074         this.anchor.set(Utils.clamp(0, anchor, getLength()));
1075         this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
1076         notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1077     }
1078 
1079     /**
1080      * This function will extend the selection to include the specified pos.
1081      * This is different from selectPositionCaret in that it does not simply
1082      * move the caret. Rather, it will reposition the caret and anchor as necessary
1083      * to ensure that pos becomes the new caret and the far other end of the
1084      * selection becomes the anchor.
1085      * @param pos the position
1086      */
1087     public void extendSelection(int pos) {
1088         final int p = Utils.clamp(0, pos, getLength());
1089         final int dot = getCaretPosition();
1090         final int mark = getAnchor();
1091         int start = Math.min(dot, mark);
1092         int end = Math.max(dot, mark);
1093         if (p &lt; start) {
1094             selectRange(end, p);
1095         } else {
1096             selectRange(start, p);
1097         }
1098     }
1099 
1100     /**
1101      * Clears the text.
1102      */
1103     public void clear() {
1104         deselect();
1105         if (!text.isBound()) {
1106             setText(&quot;&quot;);
1107         }
1108     }
1109 
1110     /**
1111      * Clears the selection.
1112      */
1113     public void deselect() {
1114         // set the anchor equal to the caret position, which clears the selection
1115         // while also preserving the caret position
1116         selectRange(getCaretPosition(), getCaretPosition());
1117     }
1118 
1119     /**
1120      * Replaces the selection with the given replacement String. If there is
1121      * no selection, then the replacement text is simply inserted at the current
1122      * caret position. If there was a selection, then the selection is cleared
1123      * and the given replacement text inserted.
1124      * @param replacement the replacement string
1125      */
1126     public void replaceSelection(String replacement) {
1127         replaceText(getSelection(), replacement);
1128     }
1129 
1130     /**
1131      * If possible, undoes the last modification. If {@link #isUndoable()} returns
1132      * false, then calling this method has no effect.
1133      * @since JavaFX 8u40
1134      */
1135     public final void undo() {
1136         if (isUndoable()) {
1137             // Apply reverse change here
1138             final int start = undoChange.start;
1139             final String newText = undoChange.newText;
1140             final String oldText = undoChange.oldText;
1141 
1142             if (newText != null) {
1143                 getContent().delete(start, start + newText.length(), oldText.isEmpty());
1144             }
1145 
1146             if (oldText != null) {
1147                 getContent().insert(start, oldText, true);
1148                 doSelectRange(start, start + oldText.length());
1149             } else {
1150                 doSelectRange(start, start + newText.length());
1151             }
1152 
1153             undoChange = undoChange.prev;
1154         }
1155         updateUndoRedoState();
1156     }
1157 
1158     /**
1159      * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
1160      * false, then calling this method has no effect.
1161      * @since JavaFX 8u40
1162      */
1163     public final void redo() {
1164         if (isRedoable()) {
1165             // Apply change here
1166             undoChange = undoChange.next;
1167             final int start = undoChange.start;
1168             final String newText = undoChange.newText;
1169             final String oldText = undoChange.oldText;
1170 
1171             if (oldText != null) {
1172                 getContent().delete(start, start + oldText.length(), newText.isEmpty());
1173             }
1174 
1175             if (newText != null) {
1176                 getContent().insert(start, newText, true);
1177                 doSelectRange(start + newText.length(), start + newText.length());
1178             } else {
1179                 doSelectRange(start, start);
1180             }
1181         }
1182         updateUndoRedoState();
1183         // else beep ?
1184     }
1185 
1186     // Used by TextArea, although there are probably other better ways of
1187     // doing this.
1188     void textUpdated() { }
1189 
1190     private void resetUndoRedoState() {
1191         undoChange = undoChangeHead;
1192         undoChange.next = null;
1193         updateUndoRedoState();
1194     }
1195 
1196     private void updateUndoRedoState() {
1197         undoable.set(undoChange != undoChangeHead);
1198         redoable.set(undoChange.next != null);
1199     }
1200 
1201     private boolean filterAndSet(String value) {
1202         // Send the new value through the textFormatter, if one exists.
1203         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1204         int length = content.length();
1205         if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
1206             TextFormatter.Change change = new TextFormatter.Change(
1207                     TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
1208             change = formatter.getFilter().apply(change);
1209             if (change == null) {
1210                 return false;
1211             }
1212             replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
1213         } else {
1214             replaceText(0, length, value, 0, 0);
1215         }
1216         return true;
1217     }
1218 
1219     /**
1220      * This is what is ultimately called by every code path that will update
1221      * the content (except for undo / redo). The input into this method has
1222      * already run through the textFormatter where appropriate.
1223      *
1224      * @param start            The start index into the existing text which
1225      *                         will be replaced by the new value
1226      * @param end              The end index into the existing text which will
1227      *                         be replaced by the new value. As with
1228      *                         String.replace this is a lastIndex+1 value
1229      * @param value            The new text value
1230      * @param anchor           The new selection anchor after the change is made
1231      * @param caretPosition    The new selection caretPosition after the change
1232      *                         is made.
1233      * @return The amount of adjustment made to the end / anchor / caretPosition to
1234      *         accommodate for subsequent filtering (such as the filtering of
1235      *         new lines by the TextField)
1236      */
1237     private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
1238         // RT-16566: Need to take into account stripping of chars into the
1239         // final anchor &amp; caret position
1240         int length = getLength();
1241         int adjustmentAmount = 0;
1242         if (end != start) {
1243             getContent().delete(start, end, value.isEmpty());
1244             length -= (end - start);
1245         }
1246         if (value != null) {
1247             getContent().insert(start, value, true);
1248             adjustmentAmount = value.length() - (getLength() - length);
1249             anchor -= adjustmentAmount;
1250             caretPosition -= adjustmentAmount;
1251         }
1252         doSelectRange(anchor, caretPosition);
1253         return adjustmentAmount;
1254     }
1255 
1256     private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
1257         T value = formatter.getValue();
1258         StringConverter&lt;T&gt; converter = formatter.getValueConverter();
1259         if (converter != null) {
1260             String text = converter.toString(value);
1261             if (text == null) text = &quot;&quot;;
1262             replaceText(0, getLength(), text, text.length(), text.length());
1263         }
1264     }
1265 
1266     /**
1267      * Commit the current text and convert it to a value.
1268      * @since JavaFX 8u40
1269      */
1270     public final void commitValue() {
1271         if (getTextFormatter() != null) {
1272             getTextFormatter().updateValue(getText());
1273         }
1274     }
1275 
1276     /**
1277      * If the field is currently being edited, this call will set text to the last commited value.
1278      * @since JavaFX 8u40
1279      */
1280     public final void cancelEdit() {
1281         if (getTextFormatter() != null) {
1282             updateText(getTextFormatter());
1283         }
1284     }
1285 
1286     private FormatterAccessor accessor;
1287 
1288     private FormatterAccessor getFormatterAccessor() {
1289         if (accessor == null) {
1290             accessor = new TextInputControlFromatterAccessor();
1291         }
1292         return accessor;
1293     }
1294 
1295     String filterInput(String text) {
1296         // This method should be overridden by child classes.
1297         // It is overridden in TextField and TextArea as needed.
1298         return text;
1299     }
1300 
1301     /**
1302      * A little utility method for stripping out unwanted characters.
1303      *
1304      * @param txt
1305      * @param stripNewlines
1306      * @param stripTabs
1307      * @return The string after having the unwanted characters stripped out.
1308      */
1309     static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
1310         // Most of the time, when text is inserted, there are no illegal
1311         // characters. So we&#39;ll do a &quot;cheap&quot; check for illegal characters.
1312         // If we find one, we&#39;ll do a longer replace algorithm. In the
1313         // case of illegal characters, this may at worst be an O(2n) solution.
1314         // Strip out any characters that are outside the printed range
1315         if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
1316             StringBuilder s = new StringBuilder(txt.length());
1317             for (int i=0; i&lt;txt.length(); i++) {
1318                 final char c = txt.charAt(i);
1319                 if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
1320                     s.append(c);
1321                 }
1322             }
1323             txt = s.toString();
1324         }
1325         return txt;
1326     }
1327 
1328     static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
1329         for (int i=0; i&lt;txt.length(); i++) {
1330             final char c = txt.charAt(i);
1331             if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
1332         }
1333         return false;
1334     }
1335 
1336     private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
1337         if (c == 0x7F) return true;
1338         if (c == 0xA) return newlineIllegal;
1339         if (c == 0x9) return tabIllegal;
1340         if (c &lt; 0x20) return true;
1341         return false;
1342     }
1343 
1344     // It can be bound, in which case we will force it to be an eager
1345     // binding so that we update the content eagerly
1346     // It can be bidirectionally bound, which basically will just work
1347     // If somebody changes the content directly, it will be notified and
1348     // send an invalidation event.
1349     private class TextProperty extends StringProperty {
1350         // This is used only when the property is bound
1351         private ObservableValue&lt;? extends String&gt; observable = null;
1352         // Added to the observable when bound
1353         private InvalidationListener listener = null;
1354         // Used for event handling
1355         private ExpressionHelper&lt;String&gt; helper = null;
1356         // The developer my set the Text property to null. Although
1357         // the Content must be given an empty String, we must still
1358         // treat the value as though it were null, so that a subsequent
1359         // getText() will return null.
1360         private boolean textIsNull = false;
1361 
1362         @Override public String get() {
1363             // Since we force eager binding and content is always up to date,
1364             // we just need to get it from content and not through the binding
1365             return textIsNull ? null : content.get();
1366         }
1367 
1368         @Override public void set(String value) {
1369             if (isBound()) {
1370                 throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
1371             }
1372             doSet(value);
1373             markInvalid();
1374         }
1375 
1376         /**
1377          * Called whenever the content on the control has changed (as determined
1378          * by a listener on the content).
1379          */
1380         private void controlContentHasChanged() {
1381             markInvalid();
1382             notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
1383         }
1384 
1385         @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
1386             if (observable == null) {
1387                 throw new NullPointerException(&quot;Cannot bind to null&quot;);
1388             }
1389             if (!observable.equals(this.observable)) {
1390                 unbind();
1391                 this.observable = observable;
1392                 if (listener == null) {
1393                     listener = new Listener();
1394                 }
1395                 this.observable.addListener(listener);
1396                 markInvalid();
1397                 doSet(observable.getValue());
1398             }
1399         }
1400 
1401         @Override public void unbind() {
1402             if (observable != null) {
1403                 doSet(observable.getValue());
1404                 observable.removeListener(listener);
1405                 observable = null;
1406             }
1407         }
1408 
1409         @Override public boolean isBound() {
1410             return observable != null;
1411         }
1412 
1413         @Override public void addListener(InvalidationListener listener) {
1414             helper = ExpressionHelper.addListener(helper, this, listener);
1415         }
1416 
1417         @Override public void removeListener(InvalidationListener listener) {
1418             helper = ExpressionHelper.removeListener(helper, listener);
1419         }
1420 
1421         @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
1422             helper = ExpressionHelper.addListener(helper, this, listener);
1423         }
1424 
1425         @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
1426             helper = ExpressionHelper.removeListener(helper, listener);
1427         }
1428 
1429         @Override public Object getBean() {
1430             return TextInputControl.this;
1431         }
1432 
1433         @Override public String getName() {
1434             return &quot;text&quot;;
1435         }
1436 
1437         private void fireValueChangedEvent() {
1438             ExpressionHelper.fireValueChangedEvent(helper);
1439         }
1440 
1441         private void markInvalid() {
1442             fireValueChangedEvent();
1443         }
1444 
1445         /**
1446          * doSet is called whenever the setText() method was called directly
1447          * on the TextInputControl, or when the text property was bound,
1448          * unbound, or reacted to a binding invalidation. It is *not* called
1449          * when modifications to the content happened indirectly, such as
1450          * through the replaceText / replaceSelection methods.
1451          *
1452          * @param value The new value
1453          */
1454         private void doSet(String value) {
1455             // Guard against the null value.
1456             textIsNull = value == null;
1457             if (value == null) value = &quot;&quot;;
1458 
1459             if (!filterAndSet(value)) return;
1460 
1461             if (getTextFormatter() != null) {
1462                 getTextFormatter().updateValue(getText());
1463             }
1464 
1465             textUpdated();
1466 
1467             // If the programmer has directly manipulated the text property
1468             // or has it bound up, then we will clear out any modifications
1469             // from the undo manager as we must suppose that the control is
1470             // being reused, for example, between forms.
1471             resetUndoRedoState();
1472         }
1473 
1474         private class Listener implements InvalidationListener {
1475             @Override
1476             public void invalidated(Observable valueModel) {
1477                 // We now need to force it to be eagerly recomputed
1478                 // because we need to push these changes to the
1479                 // content model. Because changing the model ends
1480                 // up calling invalidate and markInvalid, the
1481                 // listeners will all be notified.
1482                 doSet(observable.getValue());
1483             }
1484         }
1485     }
1486 
1487     /**
1488      * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
1489      * records the old and new text, and the start index. It also has
1490      * the links to the previous and next Changes in the chain. There
1491      * are two special UndoRedoChange objects in this chain representing the
1492      * head and the tail so we can have beforeFirst and afterLast
1493      * behavior as necessary.
1494      */
1495     static class UndoRedoChange {
1496         static long prevRecordTime;
1497         static final long CHANGE_DURATION = 2500; // milliseconds
1498         static boolean spaceCharSequence = false;
1499         int start;
1500         String oldText;
1501         String newText;
1502         UndoRedoChange prev;
1503         UndoRedoChange next;
1504 
1505         UndoRedoChange() { }
1506 
1507         public UndoRedoChange add(int start, String oldText, String newText) {
1508             UndoRedoChange c = new UndoRedoChange();
1509             c.start = start;
1510             c.oldText = oldText;
1511             c.newText = newText;
1512             c.prev = this;
1513             next = c;
1514             prevRecordTime = System.currentTimeMillis();
1515             return c;
1516         }
1517 
1518         static boolean hasChangeDurationElapsed() {
1519             return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
1520         }
1521 
1522         static void setSpaceCharSequence(boolean value) {
1523             spaceCharSequence = value;
1524         }
1525         static boolean isSpaceCharSequence() {
1526             return spaceCharSequence;
1527         }
1528 
1529         public UndoRedoChange discard() {
1530             prev.next = next;
1531             return prev;
1532         }
1533 
1534         // Handy to use when debugging, just put it in undo or redo
1535         // method or replaceText to see what is happening to the undo
1536         // history as it occurs.
1537         void debugPrint() {
1538             UndoRedoChange c = this;
1539             System.out.print(&quot;[&quot;);
1540             while (c != null) {
1541                 System.out.print(c.toString());
1542                 if (c.next != null) System.out.print(&quot;, &quot;);
1543                 c = c.next;
1544             }
1545             System.out.println(&quot;]&quot;);
1546         }
1547 
1548         @Override public String toString() {
1549             if (oldText == null &amp;&amp; newText == null) {
1550                 return &quot;head&quot;;
1551             }
1552             if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1553                 return &quot;added &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1554             } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1555                 return &quot;replaced &#39;&quot; + oldText + &quot;&#39; with &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1556             } else {
1557                 return &quot;deleted &#39;&quot; + oldText + &quot;&#39; at index &quot; + start;
1558             }
1559         }
1560     }
1561 
1562     /***************************************************************************
1563      *                                                                         *
1564      * Stylesheet Handling                                                     *
1565      *                                                                         *
1566      **************************************************************************/
1567 
1568 
1569     private static final PseudoClass PSEUDO_CLASS_READONLY
1570             = PseudoClass.getPseudoClass(&quot;readonly&quot;);
1571 
1572     private static class StyleableProperties {
1573         private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
1574             new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1575 
1576             @Override
1577             public boolean isSettable(TextInputControl n) {
1578                 return n.font == null || !n.font.isBound();
1579             }
1580 
1581             @Override
1582             public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
1583                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
1584             }
1585         };
1586 
1587         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1588         static {
1589             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1590                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1591             styleables.add(FONT);
1592             STYLEABLES = Collections.unmodifiableList(styleables);
1593         }
1594     }
1595 
1596     /**
1597      * @return The CssMetaData associated with this class, which may include the
1598      * CssMetaData of its superclasses.
1599      * @since JavaFX 8.0
1600      */
1601     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1602         return StyleableProperties.STYLEABLES;
1603     }
1604 
1605     /**
1606      * {@inheritDoc}
1607      * @since JavaFX 8.0
1608      */
1609     @Override
1610     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1611         return getClassCssMetaData();
1612     }
1613 
1614 
1615     /***************************************************************************
1616      *                                                                         *
1617      * Accessibility handling                                                  *
1618      *                                                                         *
1619      **************************************************************************/
1620 
1621     /** {@inheritDoc} */
1622     @Override
1623     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1624         switch (attribute) {
1625             case TEXT: {
1626                 String accText = getAccessibleText();
1627                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1628 
1629                 String text = getText();
1630                 if (text == null || text.isEmpty()) {
1631                     text = getPromptText();
1632                 }
1633                 return text;
1634             }
1635             case EDITABLE: return isEditable();
1636             case SELECTION_START: return getSelection().getStart();
1637             case SELECTION_END: return getSelection().getEnd();
1638             case CARET_OFFSET: return getCaretPosition();
1639             case FONT: return getFont();
1640             default: return super.queryAccessibleAttribute(attribute, parameters);
1641         }
1642     }
1643 
1644     /** {@inheritDoc} */
1645     @Override
1646     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1647         switch (action) {
1648             case SET_TEXT: {
1649                 String value = (String) parameters[0];
1650                 if (value != null) setText(value);
1651                 break;
1652             }
1653             case SET_TEXT_SELECTION: {
1654                 Integer start = (Integer) parameters[0];
1655                 Integer end = (Integer) parameters[1];
1656                 if (start != null &amp;&amp; end != null) {
1657                     selectRange(start,  end);
1658                 }
1659                 break;
1660             }
1661             default: super.executeAccessibleAction(action, parameters);
1662         }
1663     }
1664 
1665     private class TextInputControlFromatterAccessor implements FormatterAccessor {
1666         @Override
1667         public int getTextLength() {
1668             return TextInputControl.this.getLength();
1669         }
1670 
1671         @Override
1672         public String getText(int begin, int end) {
1673             return TextInputControl.this.getText(begin, end);
1674         }
1675 
1676         @Override
1677         public int getCaret() {
1678             return TextInputControl.this.getCaretPosition();
1679         }
1680 
1681         @Override
1682         public int getAnchor() {
1683             return TextInputControl.this.getAnchor();
1684         }
1685     }
1686 
1687 }
    </pre>
  </body>
</html>