<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/TextInputControl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.FormatterAccessor;
  29 import javafx.beans.DefaultProperty;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.beans.binding.IntegerBinding;
  33 import javafx.beans.binding.StringBinding;
  34 import javafx.beans.property.BooleanProperty;
  35 import javafx.beans.property.ObjectProperty;
  36 import javafx.beans.property.ObjectPropertyBase;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.property.ReadOnlyBooleanWrapper;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.ReadOnlyStringProperty;
  44 import javafx.beans.property.ReadOnlyStringWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.beans.value.ObservableStringValue;
  50 import javafx.beans.value.ObservableValue;
  51 import javafx.beans.value.WritableValue;
  52 import javafx.css.CssMetaData;
  53 import javafx.css.FontCssMetaData;
  54 import javafx.css.PseudoClass;
  55 import javafx.css.StyleOrigin;
  56 import javafx.css.Styleable;
  57 import javafx.css.StyleableObjectProperty;
  58 import javafx.css.StyleableProperty;
  59 import javafx.scene.AccessibleAction;
  60 import javafx.scene.AccessibleAttribute;
  61 import javafx.scene.input.Clipboard;
  62 import javafx.scene.input.ClipboardContent;
  63 import javafx.scene.text.Font;
  64 
  65 import java.text.BreakIterator;
  66 import java.util.ArrayList;
  67 import java.util.Collections;
  68 import java.util.List;
  69 
  70 import com.sun.javafx.util.Utils;
  71 import com.sun.javafx.binding.ExpressionHelper;
  72 import com.sun.javafx.scene.NodeHelper;
  73 import javafx.util.StringConverter;
  74 
  75 /**
  76  * Abstract base class for text input controls.
  77  * @since JavaFX 2.0
  78  */
  79 @DefaultProperty(&quot;text&quot;)
  80 public abstract class TextInputControl extends Control {
  81     /**
  82      * Interface representing a text input&#39;s content. Since it is an ObservableStringValue,
  83      * you can also bind to, or observe the content.
  84      * @since JavaFX 2.0
  85      */
  86     protected interface Content extends ObservableStringValue {
  87         /**
  88          * Retrieves a subset of the content.
  89          *
  90          * @param start the start
  91          * @param end the end
  92          * @return a subset of the content
  93          */
  94         public String get(int start, int end);
  95 
  96         /**
  97          * Inserts a sequence of characters into the content.
  98          *
  99          * @param index the index
 100          * @param text the text string
 101          * @param notifyListeners the notify listener flag
 102          * @since JavaFX 2.1
 103          */
 104         public void insert(int index, String text, boolean notifyListeners);
 105 
 106         /**
 107          * Removes a sequence of characters from the content.
 108          *
 109          * @param start the start
 110          * @param end the end
 111          * @param notifyListeners the notify listener flag
 112          * @since JavaFX 2.1
 113          */
 114         public void delete(int start, int end, boolean notifyListeners);
 115 
 116         /**
 117          * Returns the number of characters represented by the content.
 118          * @return the number of characters
 119          */
 120         public int length();
 121     }
 122 
 123     /***************************************************************************
 124      *                                                                         *
 125      * Constructors                                                            *
 126      *                                                                         *
 127      **************************************************************************/
 128 
 129     /**
 130      * Creates a new TextInputControl. The content is an immutable property and
 131      * must be specified (as non-null) at the time of construction.
 132      *
 133      * @param content a non-null implementation of Content.
 134      */
 135     protected TextInputControl(final Content content) {
 136         this.content = content;
 137 
 138         // Add a listener so that whenever the Content is changed, we notify
 139         // listeners of the text property that it is invalid.
 140         content.addListener(observable -&gt; {
 141             if (content.length() &gt; 0) {
 142                 text.textIsNull = false;
 143             }
 144             text.controlContentHasChanged();
 145         });
 146 
 147         // Bind the length to be based on the length of the text property
 148         length.bind(new IntegerBinding() {
 149             { bind(text); }
 150             @Override protected int computeValue() {
 151                 String txt = text.get();
 152                 return txt == null ? 0 : txt.length();
 153             }
 154         });
 155 
 156         // Bind the selected text to be based on the selection and text properties
 157         selectedText.bind(new StringBinding() {
 158             { bind(selection, text); }
 159             @Override protected String computeValue() {
 160                 String txt = text.get();
 161                 IndexRange sel = selection.get();
 162                 if (txt == null || sel == null) return &quot;&quot;;
 163 
 164                 int start = sel.getStart();
 165                 int end = sel.getEnd();
 166                 int length = txt.length();
 167                 // Ensure that the last character to get is within the bounds of the txt string
 168                 if (end &gt;= start + length) end = length-1;
 169                 // In case the start is after the whole txt, nothing valid is selected. Thus, return the default.
 170                 if (start &gt;= length) return &quot;&quot;;
 171                 return txt.substring(start, end);
 172             }
 173         });
 174 
 175         focusedProperty().addListener((ob, o, n) -&gt; {
 176             if (n) {
 177                 if (getTextFormatter() != null) {
 178                     updateText(getTextFormatter());
 179                 }
 180             } else {
 181                 commitValue();
 182             }
 183         });
 184 
 185         // Specify the default style class
 186         getStyleClass().add(&quot;text-input&quot;);
 187     }
 188 
 189     /***************************************************************************
 190      *                                                                         *
 191      * Properties                                                              *
 192      *                                                                         *
 193      **************************************************************************/
 194 
 195     /**
 196      * The default font to use for text in the TextInputControl. If the TextInputControl&#39;s text is
 197      * rich text then this font may or may not be used depending on the font
 198      * information embedded in the rich text, but in any case where a default
 199      * font is required, this font will be used.
 200      * @return the font property
 201      * @since JavaFX 8.0
 202      */
 203     public final ObjectProperty&lt;Font&gt; fontProperty() {
 204         if (font == null) {
 205             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 206 
 207 
 208                 private boolean fontSetByCss = false;
 209 
 210                 @Override
 211                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 212 
 213                     //
 214                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 215                     //
 216                     try {
 217                         // super.applyStyle calls set which might throw if value is bound.
 218                         // Have to make sure fontSetByCss is reset.
 219                         fontSetByCss = true;
 220                         super.applyStyle(newOrigin, value);
 221                     } catch(Exception e) {
 222                         throw e;
 223                     } finally {
 224                         fontSetByCss = false;
 225                     }
 226 
 227                 }
 228 
 229 
 230                 @Override
 231                 public void set(Font value) {
 232                     final Font oldValue = get();
 233                     if (value == null ? oldValue == null : value.equals(oldValue)) {
 234                         return;
 235                     }
 236                     super.set(value);
 237                 }
 238 
 239                 @Override
 240                 protected void invalidated() {
 241                     // RT-20727 - if font is changed by calling setFont, then
 242                     // css might need to be reapplied since font size affects
 243                     // calculated values for styles with relative values
 244                     if(fontSetByCss == false) {
 245                         NodeHelper.reapplyCSS(TextInputControl.this);
 246                     }
 247                 }
 248 
 249                 @Override
 250                 public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
 251                     return StyleableProperties.FONT;
 252                 }
 253 
 254                 @Override
 255                 public Object getBean() {
 256                     return TextInputControl.this;
 257                 }
 258 
 259                 @Override
 260                 public String getName() {
 261                     return &quot;font&quot;;
 262                 }
 263             };
 264         }
 265         return font;
 266     }
 267 
 268     private ObjectProperty&lt;Font&gt; font;
 269     public final void setFont(Font value) { fontProperty().setValue(value); }
 270     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 271 
 272     /**
 273      * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
 274      * prompt text is displayed.
 275      *
 276      * @defaultValue An empty String
 277      * @since JavaFX 2.2
 278      */
 279     private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
 280         @Override protected void invalidated() {
 281             // Strip out newlines
 282             String txt = get();
 283             if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
 284                 txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
 285                 set(txt);
 286             }
 287         }
 288     };
 289     public final StringProperty promptTextProperty() { return promptText; }
 290     public final String getPromptText() { return promptText.get(); }
 291     public final void setPromptText(String value) { promptText.set(value); }
 292 
 293 
 294     /**
 295      * The property contains currently attached {@link TextFormatter}.
 296      * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
 297      *
 298      * @defaultValue null
 299      * @since JavaFX 8u40
 300      */
 301     private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {
 302 
 303         private TextFormatter&lt;?&gt; oldFormatter = null;
 304 
 305         @Override
 306         public Object getBean() {
 307             return TextInputControl.this;
 308         }
 309 
 310         @Override
 311         public String getName() {
 312             return &quot;textFormatter&quot;;
 313         }
 314 
 315         @Override
 316         protected void invalidated() {
 317             final TextFormatter&lt;?&gt; formatter = get();
 318             try {
 319                 if (formatter != null) {
 320                     try {
 321                         formatter.bindToControl(f -&gt; updateText(f));
 322                     } catch (IllegalStateException e) {
 323                         if (isBound()) {
 324                             unbind();
 325                         }
 326                         set(null);
 327                         throw e;
 328                     }
 329                     if (!isFocused()) {
 330                         updateText(get());
 331                     }
 332                 }
 333 
 334                 if (oldFormatter != null) {
 335                     oldFormatter.unbindFromControl();
 336                 }
 337             } finally {
 338                 oldFormatter = formatter;
 339             }
 340         }
 341     };
 342     public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
 343     public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
 344     public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }
 345 
 346     private final Content content;
 347     /**
 348      * Returns the text input&#39;s content model.
 349      * @return the text input&#39;s content model
 350      */
 351     protected final Content getContent() {
 352         return content;
 353     }
 354 
 355     /**
 356      * The textual content of this TextInputControl.
 357      */
 358     private TextProperty text = new TextProperty();
 359     public final String getText() { return text.get(); }
 360     public final void setText(String value) { text.set(value); }
 361     public final StringProperty textProperty() { return text; }
 362 
 363     /**
 364      * The number of characters in the text input.
 365      */
 366     private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
 367     public final int getLength() { return length.get(); }
 368     public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }
 369 
 370     /**
 371      * Indicates whether this TextInputControl can be edited by the user.
 372      */
 373     private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
 374         @Override protected void invalidated() {
 375             pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
 376         }
 377     };
 378     public final boolean isEditable() { return editable.getValue(); }
 379     public final void setEditable(boolean value) { editable.setValue(value); }
 380     public final BooleanProperty editableProperty() { return editable; }
 381 
 382     /**
 383      * The current selection.
 384      */
 385     private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
 386     public final IndexRange getSelection() { return selection.getValue(); }
 387     public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }
 388 
 389     /**
 390      * Defines the characters in the TextInputControl which are selected
 391      */
 392     private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
 393     public final String getSelectedText() { return selectedText.get(); }
 394     public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }
 395 
 396     /**
 397      * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
 398      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 399      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 400      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 401      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 402      * the anchor might represent the lower or upper bound of the selection.
 403      */
 404     private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
 405     public final int getAnchor() { return anchor.get(); }
 406     public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }
 407 
 408     /**
 409      * The current position of the caret within the text.
 410      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 411      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 412      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 413      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 414      * the caretPosition might represent the lower or upper bound of the selection.
 415      */
 416     private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
 417     public final int getCaretPosition() { return caretPosition.get(); }
 418     public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }
 419 
 420     private UndoRedoChange undoChangeHead = new UndoRedoChange();
 421     private UndoRedoChange undoChange = undoChangeHead;
 422     private boolean createNewUndoRecord = false;
 423 
 424     /**
 425      * The property describes if it&#39;s currently possible to undo the latest change of the content that was done.
 426      * @defaultValue false
 427      * @since JavaFX 8u40
 428      */
 429     private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
 430     public final boolean isUndoable() { return undoable.get(); }
 431     public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }
 432 
 433 
 434     /**
 435      * The property describes if it&#39;s currently possible to redo the latest change of the content that was undone.
 436      * @defaultValue false
 437      * @since JavaFX 8u40
 438      */
 439     private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
 440     public final boolean isRedoable() { return redoable.get(); }
 441     public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }
 442 
 443     /***************************************************************************
 444      *                                                                         *
 445      * Methods                                                                 *
 446      *                                                                         *
 447      **************************************************************************/
 448 
 449     /**
 450      * Returns a subset of the text input&#39;s content.
 451      *
 452      * @param start must be a value between 0 and end - 1.
 453      * @param end must be less than or equal to the length
 454      * @return the subset of the text input&#39;s content
 455      */
 456     public String getText(int start, int end) {
 457         if (start &gt; end) {
 458             throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
 459         }
 460 
 461         if (start &lt; 0
 462             || end &gt; getLength()) {
 463             throw new IndexOutOfBoundsException();
 464         }
 465 
 466         return getContent().get(start, end);
 467     }
 468 
 469     /**
 470      * Appends a sequence of characters to the content.
 471      *
 472      * @param text a non null String
 473      */
 474     public void appendText(String text) {
 475         insertText(getLength(), text);
 476     }
 477 
 478     /**
 479      * Inserts a sequence of characters into the content.
 480      *
 481      * @param index The location to insert the text.
 482      * @param text The text to insert.
 483      */
 484     public void insertText(int index, String text) {
 485         replaceText(index, index, text);
 486     }
 487 
 488     /**
 489      * Removes a range of characters from the content.
 490      *
 491      * @param range The range of text to delete. The range object must not be null.
 492      *
 493      * @see #deleteText(int, int)
 494      */
 495     public void deleteText(IndexRange range) {
 496         replaceText(range, &quot;&quot;);
 497     }
 498 
 499     /**
 500      * Removes a range of characters from the content.
 501      *
 502      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 503      * @param end The ending index in the range, exclusive. This is one-past the last character to
 504      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 505      *            and &amp;lt;= the length of the text.
 506      */
 507     public void deleteText(int start, int end) {
 508         replaceText(start, end, &quot;&quot;);
 509     }
 510 
 511     /**
 512      * Replaces a range of characters with the given text.
 513      *
 514      * @param range The range of text to replace. The range object must not be null.
 515      * @param text The text that is to replace the range. This must not be null.
 516      *
 517      * @see #replaceText(int, int, String)
 518      */
 519     public void replaceText(IndexRange range, String text) {
 520         final int start = range.getStart();
 521         final int end = start + range.getLength();
 522         replaceText(start, end, text);
 523     }
 524 
 525     /**
 526      * Replaces a range of characters with the given text.
 527      *
 528      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 529      * @param end The ending index in the range, exclusive. This is one-past the last character to
 530      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 531      *            and &amp;lt;= the length of the text.
 532      * @param text The text that is to replace the range. This must not be null.
 533      */
 534     public void replaceText(final int start, final int end, final String text) {
 535         if (start &gt; end) {
 536             throw new IllegalArgumentException();
 537         }
 538 
 539         if (text == null) {
 540             throw new NullPointerException();
 541         }
 542 
 543         if (start &lt; 0
 544             || end &gt; getLength()) {
 545             throw new IndexOutOfBoundsException();
 546         }
 547 
 548         if (!this.text.isBound()) {
 549             final int oldLength = getLength();
 550             TextFormatter&lt;?&gt; formatter = getTextFormatter();
 551             TextFormatter.Change change;
 552             if (formatter != null &amp;&amp; formatter.getFilter() != null) {
 553                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
 554                 change = formatter.getFilter().apply(change);
 555                 if (change == null) {
 556                     return;
 557                 }
 558             } else {
 559                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, filterInput(text));
 560             }
 561 
 562             // Update the content
 563             updateContent(change, oldLength == 0);
 564 
 565         }
 566     }
 567 
 568     private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
 569         final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
 570         String oldText = getText(change.start, change.end);
 571         int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
 572         String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
 573         if (newText.equals(oldText)) {
 574             // Undo record not required as there is no change in the text.
 575             return;
 576         }
 577 
 578         /*
 579          * A new undo record is created, if
 580          * 1. createNewUndoRecord is true, currently it is set to true for paste operation
 581          * 2. Text is selected and a character is typed
 582          * 3. This is the first operation to be added to undo record
 583          * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
 584          * 5. Space character is typed
 585          * 6. 2500 milliseconds are elapsed since the undo record was created
 586          * 7. Cursor position is changed and a character is typed
 587          * 8. A range of text is replaced programmatically using replaceText()
 588          * Otherwise, the last undo record is updated or discarded.
 589          */
 590 
 591         int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
 592         boolean isNewSpaceChar = false;
 593         if (newText.equals(&quot; &quot;)) {
 594             if (!UndoRedoChange.isSpaceCharSequence()) {
 595                 isNewSpaceChar = true;
 596                 UndoRedoChange.setSpaceCharSequence(true);
 597             }
 598         } else {
 599             UndoRedoChange.setSpaceCharSequence(false);
 600         }
 601         if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
 602                 isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
 603                 (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
 604             undoChange = undoChange.add(change.start, oldText, newText);
 605         } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
 606             // I know I am deleting, and am located at the end of the range of the current undo record
 607             if (undoChange.newText.length() &gt; 0) {
 608                 undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
 609                 if (undoChange.newText.isEmpty()) {
 610                     // throw away this undo change record
 611                     undoChange = undoChange.discard();
 612                 }
 613             } else {
 614                 if (change.start == endOfUndoChange) {
 615                     undoChange.oldText += oldText;
 616                 } else { // end == endOfUndoChange
 617                     undoChange.oldText = oldText + undoChange.oldText;
 618                     undoChange.start--;
 619                 }
 620             }
 621         } else {
 622             // I know I am adding, and am located at the end of the range of the current undo record
 623             undoChange.newText += newText;
 624         }
 625         updateUndoRedoState();
 626     }
 627 
 628     /**
 629      * Transfers the currently selected range in the text to the clipboard,
 630      * removing the current selection.
 631      */
 632     public void cut() {
 633         copy();
 634         IndexRange selection = getSelection();
 635         deleteText(selection.getStart(), selection.getEnd());
 636     }
 637 
 638     /**
 639      * Transfers the currently selected range in the text to the clipboard,
 640      * leaving the current selection.
 641      */
 642      public void copy() {
 643         final String selectedText = getSelectedText();
 644         if (selectedText.length() &gt; 0) {
 645             final ClipboardContent content = new ClipboardContent();
 646             content.putString(selectedText);
 647             Clipboard.getSystemClipboard().setContent(content);
 648         }
 649     }
 650 
 651     /**
 652      * Transfers the contents in the clipboard into this text,
 653      * replacing the current selection.  If there is no selection, the contents
 654      * in the clipboard is inserted at the current caret position.
 655      */
 656     public void paste() {
 657         final Clipboard clipboard = Clipboard.getSystemClipboard();
 658         if (clipboard.hasString()) {
 659             final String text = clipboard.getString();
 660             if (text != null) {
 661                 createNewUndoRecord = true;
 662                 try {
 663                     replaceSelection(text);
 664                 } finally {
 665                     createNewUndoRecord = false;
 666                 }
 667             }
 668         }
 669     }
 670 
 671     /**
 672      * Moves the selection backward one char in the text. This may have the
 673      * effect of deselecting, depending on the location of the anchor relative
 674      * to the caretPosition. This function effectively just moves the caretPosition.
 675      */
 676     public void selectBackward() {
 677         if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
 678             // because the anchor stays put, by moving the caret to the left
 679             // we ensure that a selection is registered and that it is correct
 680             if (charIterator == null) {
 681                 charIterator = BreakIterator.getCharacterInstance();
 682             }
 683             charIterator.setText(getText());
 684             selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
 685         }
 686     }
 687 
 688     /**
 689      * Moves the selection forward one char in the text. This may have the
 690      * effect of deselecting, depending on the location of the anchor relative
 691      * to the caretPosition. This function effectively just moves the caret forward.
 692      */
 693     public void selectForward() {
 694         final int textLength = getLength();
 695         if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
 696             if (charIterator == null) {
 697                 charIterator = BreakIterator.getCharacterInstance();
 698             }
 699             charIterator.setText(getText());
 700             selectRange(getAnchor(), charIterator.following(getCaretPosition()));
 701         }
 702     }
 703 
 704     /**
 705      * The break iterator instances for navigation over words and complex characters.
 706      */
 707     private BreakIterator charIterator;
 708     private BreakIterator wordIterator;
 709 
 710     /**
 711      * Moves the caret to the beginning of previous word. This function
 712      * also has the effect of clearing the selection.
 713      */
 714     public void previousWord() {
 715         previousWord(false);
 716     }
 717 
 718     /**
 719      * Moves the caret to the beginning of next word. This function
 720      * also has the effect of clearing the selection.
 721      */
 722     public void nextWord() {
 723         nextWord(false);
 724     }
 725 
 726     /**
 727      * Moves the caret to the end of the next word. This function
 728      * also has the effect of clearing the selection.
 729      */
 730     public void endOfNextWord() {
 731         endOfNextWord(false);
 732     }
 733 
 734     /**
 735      * Moves the caret to the beginning of previous word. This does not cause
 736      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 737      * moved to the beginning of previous word.
 738      */
 739     public void selectPreviousWord() {
 740         previousWord(true);
 741     }
 742 
 743     /**
 744      * Moves the caret to the beginning of next word. This does not cause
 745      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 746      * moved to the beginning of next word.
 747      */
 748     public void selectNextWord() {
 749         nextWord(true);
 750     }
 751 
 752     /**
 753      * Moves the caret to the end of the next word. This does not cause
 754      * the selection to be cleared.
 755      */
 756     public void selectEndOfNextWord() {
 757         endOfNextWord(true);
 758     }
 759 
 760     private void previousWord(boolean select) {
 761         final int textLength = getLength();
 762         final String text = getText();
 763         if (textLength &lt;= 0) {
 764             return;
 765         }
 766 
 767         if (wordIterator == null) {
 768             wordIterator = BreakIterator.getWordInstance();
 769         }
 770         wordIterator.setText(text);
 771 
 772         int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));
 773 
 774         // Skip the non-word region, then move/select to the beginning of the word.
 775         while (pos != BreakIterator.DONE &amp;&amp;
 776                !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
 777             pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
 778         }
 779 
 780         // move/select
 781         selectRange(select ? getAnchor() : pos, pos);
 782     }
 783 
 784     private void nextWord(boolean select) {
 785         final int textLength = getLength();
 786         final String text = getText();
 787         if (textLength &lt;= 0) {
 788             return;
 789         }
 790 
 791         if (wordIterator == null) {
 792             wordIterator = BreakIterator.getWordInstance();
 793         }
 794         wordIterator.setText(text);
 795 
 796         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
 797         int current = wordIterator.next();
 798 
 799         // Skip whitespace characters to the beginning of next word, but
 800         // stop at newline. Then move the caret or select a range.
 801         while (current != BreakIterator.DONE) {
 802             for (int p=last; p&lt;=current; p++) {
 803                 char ch = text.charAt(Utils.clamp(0, p, textLength-1));
 804                 // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
 805                 // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
 806                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39;) {
 807                     if (select) {
 808                         selectRange(getAnchor(), p);
 809                     } else {
 810                         selectRange(p, p);
 811                     }
 812                     return;
 813                 }
 814             }
 815             last = current;
 816             current = wordIterator.next();
 817         }
 818 
 819         // move/select to the end
 820         if (select) {
 821             selectRange(getAnchor(), textLength);
 822         } else {
 823             end();
 824         }
 825     }
 826 
 827     private void endOfNextWord(boolean select) {
 828         final int textLength = getLength();
 829         final String text = getText();
 830         if (textLength &lt;= 0) {
 831             return;
 832         }
 833 
 834         if (wordIterator == null) {
 835             wordIterator = BreakIterator.getWordInstance();
 836         }
 837         wordIterator.setText(text);
 838 
 839         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
 840         int current = wordIterator.next();
 841 
 842         // skip the non-word region, then move/select to the end of the word.
 843         while (current != BreakIterator.DONE) {
 844             for (int p=last; p&lt;=current; p++) {
 845                 if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
 846                     if (select) {
 847                         selectRange(getAnchor(), p);
 848                     } else {
 849                         selectRange(p, p);
 850                     }
 851                     return;
 852                 }
 853             }
 854             last = current;
 855             current = wordIterator.next();
 856         }
 857 
 858         // move/select to the end
 859         if (select) {
 860             selectRange(getAnchor(), textLength);
 861         } else {
 862             end();
 863         }
 864     }
 865 
 866     /**
 867      * Selects all text in the text input.
 868      */
 869     public void selectAll() {
 870         selectRange(0, getLength());
 871     }
 872 
 873     /**
 874      * Moves the caret to before the first char of the text. This function
 875      * also has the effect of clearing the selection.
 876      */
 877     public void home() {
 878         // user wants to go to start
 879         selectRange(0, 0);
 880     }
 881 
 882     /**
 883      * Moves the caret to after the last char of the text. This function
 884      * also has the effect of clearing the selection.
 885      */
 886     public void end() {
 887         // user wants to go to end
 888         final int textLength = getLength();
 889         if (textLength &gt; 0) {
 890             selectRange(textLength, textLength);
 891         }
 892     }
 893 
 894     /**
 895      * Moves the caret to before the first char of text. This does not cause
 896      * the selection to be cleared. Rather, the anchor stays put and the
 897      * caretPosition is moved to before the first char.
 898      */
 899     public void selectHome() {
 900         selectRange(getAnchor(), 0);
 901     }
 902 
 903     /**
 904      * Moves the caret to after the last char of text. This does not cause
 905      * the selection to be cleared. Rather, the anchor stays put and the
 906      * caretPosition is moved to after the last char.
 907      */
 908     public void selectEnd() {
 909         final int textLength = getLength();
 910         if (textLength &gt; 0) selectRange(getAnchor(), textLength);
 911     }
 912 
 913     /**
 914      * Deletes the character that precedes the current caret position from the
 915      * text if there is no selection, or deletes the selection if there is one.
 916      * This function returns true if the deletion succeeded, false otherwise.
 917      * @return true if the deletion succeeded, false otherwise
 918      */
 919     public boolean deletePreviousChar() {
 920         boolean failed = true;
 921         if (isEditable() &amp;&amp; !isDisabled()) {
 922             final String text = getText();
 923             final int dot = getCaretPosition();
 924             final int mark = getAnchor();
 925             if (dot != mark) {
 926                 // there is a selection of text to remove
 927                 replaceSelection(&quot;&quot;);
 928                 failed = false;
 929             } else if (dot &gt; 0) {
 930                 // The caret is not at the beginning, so remove some characters.
 931                 // Typically you&#39;d only be removing a single character, but
 932                 // in some cases you must remove two depending on the unicode
 933                 // characters
 934                 // Note: Do not use charIterator here, because we do want to
 935                 // break up clusters when deleting backwards.
 936                 int p = Character.offsetByCodePoints(text, dot, -1);
 937                 deleteText(p, dot);
 938                 failed = false;
 939             }
 940         }
 941         return !failed;
 942     }
 943 
 944     /**
 945      * Deletes the character that follows the current caret position from the
 946      * text if there is no selection, or deletes the selection if there is one.
 947      * This function returns true if the deletion succeeded, false otherwise.
 948      * @return true if the deletion succeeded, false otherwise
 949      */
 950     public boolean deleteNextChar() {
 951         boolean failed = true;
 952         if (isEditable() &amp;&amp; !isDisabled()) {
 953             final int textLength = getLength();
 954             final String text = getText();
 955             final int dot = getCaretPosition();
 956             final int mark = getAnchor();
 957             if (dot != mark) {
 958                 // there is a selection of text to remove
 959                 replaceSelection(&quot;&quot;);
 960                 failed = false;
 961             } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
 962                 // The caret is not at the end, so remove some characters.
 963                 // Typically you&#39;d only be removing a single character, but
 964                 // in some cases you must remove two depending on the unicode
 965                 // characters
 966                 if (charIterator == null) {
 967                     charIterator = BreakIterator.getCharacterInstance();
 968                 }
 969                 charIterator.setText(text);
 970                 int p = charIterator.following(dot);
 971                 deleteText(dot, p);
 972                 failed = false;
 973             }
 974         }
 975         return !failed;
 976     }
 977 
 978     /**
 979      * Moves the caret position forward. If there is no selection, then the
 980      * caret position is moved one character forward. If there is a selection,
 981      * then the caret position is moved to the end of the selection and
 982      * the selection cleared.
 983      */
 984     public void forward() {
 985         // user has moved caret to the right
 986         final int textLength = getLength();
 987         final int dot = getCaretPosition();
 988         final int mark = getAnchor();
 989         if (dot != mark) {
 990             int pos = Math.max(dot, mark);
 991             selectRange(pos, pos);
 992         } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
 993             if (charIterator == null) {
 994                 charIterator = BreakIterator.getCharacterInstance();
 995             }
 996             charIterator.setText(getText());
 997             int pos = charIterator.following(dot);
 998             selectRange(pos, pos);
 999         }
1000         deselect();
1001     }
1002 
1003     /**
1004      * Moves the caret position backward. If there is no selection, then the
1005      * caret position is moved one character backward. If there is a selection,
1006      * then the caret position is moved to the beginning of the selection and
1007      * the selection cleared.
1008      *
1009      * Note: This function is intended to be used by experts, primarily
1010      *       by those implementing new Skins or Behaviors. It is not common
1011      *       for developers or designers to access this function directly.
1012      */
1013     public void backward() {
1014         // user has moved caret to the left
1015         final int textLength = getLength();
1016         final int dot = getCaretPosition();
1017         final int mark = getAnchor();
1018         if (dot != mark) {
1019             int pos = Math.min(dot, mark);
1020             selectRange(pos, pos);
1021         } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
1022             if (charIterator == null) {
1023                 charIterator = BreakIterator.getCharacterInstance();
1024             }
1025             charIterator.setText(getText());
1026             int pos = charIterator.preceding(dot);
1027             selectRange(pos, pos);
1028         }
1029         deselect();
1030     }
1031 
1032     /**
1033      * Positions the caret to the position indicated by {@code pos}. This
1034      * function will also clear the selection.
1035      * @param pos the position
1036      */
1037     public void positionCaret(int pos) {
1038         final int p = Utils.clamp(0, pos, getLength());
1039         selectRange(p, p);
1040     }
1041 
1042     /**
1043      * Positions the caret to the position indicated by {@code pos} and extends
1044      * the selection, if there is one. If there is no selection, then a
1045      * selection is formed where the anchor is at the current caret position
1046      * and the caretPosition is moved to pos.
1047      * @param pos the position
1048      */
1049     public void selectPositionCaret(int pos) {
1050         selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
1051     }
1052 
1053     /**
1054      * Positions the anchor and caretPosition explicitly.
1055      * @param anchor the anchor
1056      * @param caretPosition the caretPosition
1057      */
1058     public void selectRange(int anchor, int caretPosition) {
1059         caretPosition = Utils.clamp(0, caretPosition, getLength());
1060         anchor = Utils.clamp(0, anchor, getLength());
1061 
1062         TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
1063         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1064         if (formatter != null &amp;&amp; formatter.getFilter() != null) {
1065             change = formatter.getFilter().apply(change);
1066             if (change == null) {
1067                 return;
1068             }
1069         }
1070 
1071         updateContent(change, false);
1072     }
1073 
1074     private void doSelectRange(int anchor, int caretPosition) {
1075         this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
1076         this.anchor.set(Utils.clamp(0, anchor, getLength()));
1077         this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
1078         notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1079     }
1080 
1081     /**
1082      * This function will extend the selection to include the specified pos.
1083      * This is different from selectPositionCaret in that it does not simply
1084      * move the caret. Rather, it will reposition the caret and anchor as necessary
1085      * to ensure that pos becomes the new caret and the far other end of the
1086      * selection becomes the anchor.
1087      * @param pos the position
1088      */
1089     public void extendSelection(int pos) {
1090         final int p = Utils.clamp(0, pos, getLength());
1091         final int dot = getCaretPosition();
1092         final int mark = getAnchor();
1093         int start = Math.min(dot, mark);
1094         int end = Math.max(dot, mark);
1095         if (p &lt; start) {
1096             selectRange(end, p);
1097         } else {
1098             selectRange(start, p);
1099         }
1100     }
1101 
1102     /**
1103      * Clears the text.
1104      */
1105     public void clear() {
1106         deselect();
1107         if (!text.isBound()) {
1108             setText(&quot;&quot;);
1109         }
1110     }
1111 
1112     /**
1113      * Clears the selection.
1114      */
1115     public void deselect() {
1116         // set the anchor equal to the caret position, which clears the selection
1117         // while also preserving the caret position
1118         selectRange(getCaretPosition(), getCaretPosition());
1119     }
1120 
1121     /**
1122      * Replaces the selection with the given replacement String. If there is
1123      * no selection, then the replacement text is simply inserted at the current
1124      * caret position. If there was a selection, then the selection is cleared
1125      * and the given replacement text inserted.
1126      * @param replacement the replacement string
1127      */
1128     public void replaceSelection(String replacement) {
1129         replaceText(getSelection(), replacement);
1130     }
1131 
1132     /**
1133      * If possible, undoes the last modification. If {@link #isUndoable()} returns
1134      * false, then calling this method has no effect.
1135      * @since JavaFX 8u40
1136      */
1137     public final void undo() {
1138         if (isUndoable()) {
1139             // Apply reverse change here
1140             final int start = undoChange.start;
1141             final String newText = undoChange.newText;
1142             final String oldText = undoChange.oldText;
1143 
1144             if (newText != null) {
1145                 getContent().delete(start, start + newText.length(), oldText.isEmpty());
1146             }
1147 
1148             if (oldText != null) {
1149                 getContent().insert(start, oldText, true);
1150                 doSelectRange(start, start + oldText.length());
1151             } else {
1152                 doSelectRange(start, start + newText.length());
1153             }
1154 
1155             undoChange = undoChange.prev;
1156         }
1157         updateUndoRedoState();
1158     }
1159 
1160     /**
1161      * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
1162      * false, then calling this method has no effect.
1163      * @since JavaFX 8u40
1164      */
1165     public final void redo() {
1166         if (isRedoable()) {
1167             // Apply change here
1168             undoChange = undoChange.next;
1169             final int start = undoChange.start;
1170             final String newText = undoChange.newText;
1171             final String oldText = undoChange.oldText;
1172 
1173             if (oldText != null) {
1174                 getContent().delete(start, start + oldText.length(), newText.isEmpty());
1175             }
1176 
1177             if (newText != null) {
1178                 getContent().insert(start, newText, true);
1179                 doSelectRange(start + newText.length(), start + newText.length());
1180             } else {
1181                 doSelectRange(start, start);
1182             }
1183         }
1184         updateUndoRedoState();
1185         // else beep ?
1186     }
1187 
1188     // Used by TextArea, although there are probably other better ways of
1189     // doing this.
1190     void textUpdated() { }
1191 
1192     private void resetUndoRedoState() {
1193         undoChange = undoChangeHead;
1194         undoChange.next = null;
1195         updateUndoRedoState();
1196     }
1197 
1198     private void updateUndoRedoState() {
1199         undoable.set(undoChange != undoChangeHead);
1200         redoable.set(undoChange.next != null);
1201     }
1202 
1203     private boolean filterAndSet(String value) {
1204         // Send the new value through the textFormatter, if one exists.
1205         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1206         int length = content.length();
1207         if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
1208             TextFormatter.Change change = new TextFormatter.Change(
1209                     TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
1210             change = formatter.getFilter().apply(change);
1211             if (change == null) {
1212                 return false;
1213             }
1214             replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
1215         } else {
1216             replaceText(0, length, value, 0, 0);
1217         }
1218         return true;
1219     }
1220 
1221     /**
1222      * This is what is ultimately called by every code path that will update
1223      * the content (except for undo / redo). The input into this method has
1224      * already run through the textFormatter where appropriate.
1225      *
1226      * @param start            The start index into the existing text which
1227      *                         will be replaced by the new value
1228      * @param end              The end index into the existing text which will
1229      *                         be replaced by the new value. As with
1230      *                         String.replace this is a lastIndex+1 value
1231      * @param value            The new text value
1232      * @param anchor           The new selection anchor after the change is made
1233      * @param caretPosition    The new selection caretPosition after the change
1234      *                         is made.
1235      * @return The amount of adjustment made to the end / anchor / caretPosition to
1236      *         accommodate for subsequent filtering (such as the filtering of
1237      *         new lines by the TextField)
1238      */
1239     private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
1240         // RT-16566: Need to take into account stripping of chars into the
1241         // final anchor &amp; caret position
1242         int length = getLength();
1243         int adjustmentAmount = 0;
1244         if (end != start) {
1245             getContent().delete(start, end, value.isEmpty());
1246             length -= (end - start);
1247         }
1248         if (value != null) {
1249             getContent().insert(start, value, true);
1250             adjustmentAmount = value.length() - (getLength() - length);
1251             anchor -= adjustmentAmount;
1252             caretPosition -= adjustmentAmount;
1253         }
1254         doSelectRange(anchor, caretPosition);
1255         return adjustmentAmount;
1256     }
1257 
1258     private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
1259         T value = formatter.getValue();
1260         StringConverter&lt;T&gt; converter = formatter.getValueConverter();
1261         if (converter != null) {
1262             String text = converter.toString(value);
1263             if (text == null) text = &quot;&quot;;
1264             replaceText(0, getLength(), text, text.length(), text.length());
1265         }
1266     }
1267 
1268     /**
1269      * Commit the current text and convert it to a value.
1270      * @since JavaFX 8u40
1271      */
1272     public final void commitValue() {
1273         if (getTextFormatter() != null) {
1274             getTextFormatter().updateValue(getText());
1275         }
1276     }
1277 
1278     /**
1279      * If the field is currently being edited, this call will set text to the last commited value.
1280      * @since JavaFX 8u40
1281      */
1282     public final void cancelEdit() {
1283         if (getTextFormatter() != null) {
1284             updateText(getTextFormatter());
1285         }
1286     }
1287 
1288     private FormatterAccessor accessor;
1289 
1290     private FormatterAccessor getFormatterAccessor() {
1291         if (accessor == null) {
1292             accessor = new TextInputControlFromatterAccessor();
1293         }
1294         return accessor;
1295     }
1296 
1297     String filterInput(String text) {
1298         // This method should be overridden by child classes.
1299         // It is overridden in TextField and TextArea as needed.
1300         return text;
1301     }
1302 
1303     /**
1304      * A little utility method for stripping out unwanted characters.
1305      *
1306      * @param txt
1307      * @param stripNewlines
1308      * @param stripTabs
1309      * @return The string after having the unwanted characters stripped out.
1310      */
1311     static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
1312         // Most of the time, when text is inserted, there are no illegal
1313         // characters. So we&#39;ll do a &quot;cheap&quot; check for illegal characters.
1314         // If we find one, we&#39;ll do a longer replace algorithm. In the
1315         // case of illegal characters, this may at worst be an O(2n) solution.
1316         // Strip out any characters that are outside the printed range
1317         if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
1318             StringBuilder s = new StringBuilder(txt.length());
1319             for (int i=0; i&lt;txt.length(); i++) {
1320                 final char c = txt.charAt(i);
1321                 if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
1322                     s.append(c);
1323                 }
1324             }
1325             txt = s.toString();
1326         }
1327         return txt;
1328     }
1329 
1330     static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
1331         for (int i=0; i&lt;txt.length(); i++) {
1332             final char c = txt.charAt(i);
1333             if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
1334         }
1335         return false;
1336     }
1337 
1338     private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
1339         if (c == 0x7F) return true;
1340         if (c == 0xA) return newlineIllegal;
1341         if (c == 0x9) return tabIllegal;
1342         if (c &lt; 0x20) return true;
1343         return false;
1344     }
1345 
1346     // It can be bound, in which case we will force it to be an eager
1347     // binding so that we update the content eagerly
1348     // It can be bidirectionally bound, which basically will just work
1349     // If somebody changes the content directly, it will be notified and
1350     // send an invalidation event.
1351     private class TextProperty extends StringProperty {
1352         // This is used only when the property is bound
1353         private ObservableValue&lt;? extends String&gt; observable = null;
1354         // Added to the observable when bound
1355         private InvalidationListener listener = null;
1356         // Used for event handling
1357         private ExpressionHelper&lt;String&gt; helper = null;
1358         // The developer my set the Text property to null. Although
1359         // the Content must be given an empty String, we must still
1360         // treat the value as though it were null, so that a subsequent
1361         // getText() will return null.
1362         private boolean textIsNull = false;
1363 
1364         @Override public String get() {
1365             // Since we force eager binding and content is always up to date,
1366             // we just need to get it from content and not through the binding
1367             return textIsNull ? null : content.get();
1368         }
1369 
1370         @Override public void set(String value) {
1371             if (isBound()) {
1372                 throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
1373             }
1374             doSet(value);
1375             markInvalid();
1376         }
1377 
1378         /**
1379          * Called whenever the content on the control has changed (as determined
1380          * by a listener on the content).
1381          */
1382         private void controlContentHasChanged() {
1383             markInvalid();
1384             notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
1385         }
1386 
1387         @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
1388             if (observable == null) {
1389                 throw new NullPointerException(&quot;Cannot bind to null&quot;);
1390             }
1391             if (!observable.equals(this.observable)) {
1392                 unbind();
1393                 this.observable = observable;
1394                 if (listener == null) {
1395                     listener = new Listener();
1396                 }
1397                 this.observable.addListener(listener);
1398                 markInvalid();
1399                 doSet(observable.getValue());
1400             }
1401         }
1402 
1403         @Override public void unbind() {
1404             if (observable != null) {
1405                 doSet(observable.getValue());
1406                 observable.removeListener(listener);
1407                 observable = null;
1408             }
1409         }
1410 
1411         @Override public boolean isBound() {
1412             return observable != null;
1413         }
1414 
1415         @Override public void addListener(InvalidationListener listener) {
1416             helper = ExpressionHelper.addListener(helper, this, listener);
1417         }
1418 
1419         @Override public void removeListener(InvalidationListener listener) {
1420             helper = ExpressionHelper.removeListener(helper, listener);
1421         }
1422 
1423         @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
1424             helper = ExpressionHelper.addListener(helper, this, listener);
1425         }
1426 
1427         @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
1428             helper = ExpressionHelper.removeListener(helper, listener);
1429         }
1430 
1431         @Override public Object getBean() {
1432             return TextInputControl.this;
1433         }
1434 
1435         @Override public String getName() {
1436             return &quot;text&quot;;
1437         }
1438 
1439         private void fireValueChangedEvent() {
1440             ExpressionHelper.fireValueChangedEvent(helper);
1441         }
1442 
1443         private void markInvalid() {
1444             fireValueChangedEvent();
1445         }
1446 
1447         /**
1448          * doSet is called whenever the setText() method was called directly
1449          * on the TextInputControl, or when the text property was bound,
1450          * unbound, or reacted to a binding invalidation. It is *not* called
1451          * when modifications to the content happened indirectly, such as
1452          * through the replaceText / replaceSelection methods.
1453          *
1454          * @param value The new value
1455          */
1456         private void doSet(String value) {
1457             // Guard against the null value.
1458             textIsNull = value == null;
1459             if (value == null) value = &quot;&quot;;
1460 
1461             if (!filterAndSet(value)) return;
1462 
1463             if (getTextFormatter() != null) {
1464                 getTextFormatter().updateValue(getText());
1465             }
1466 
1467             textUpdated();
1468 
1469             // If the programmer has directly manipulated the text property
1470             // or has it bound up, then we will clear out any modifications
1471             // from the undo manager as we must suppose that the control is
1472             // being reused, for example, between forms.
1473             resetUndoRedoState();
1474         }
1475 
1476         private class Listener implements InvalidationListener {
1477             @Override
1478             public void invalidated(Observable valueModel) {
1479                 // We now need to force it to be eagerly recomputed
1480                 // because we need to push these changes to the
1481                 // content model. Because changing the model ends
1482                 // up calling invalidate and markInvalid, the
1483                 // listeners will all be notified.
1484                 doSet(observable.getValue());
1485             }
1486         }
1487     }
1488 
1489     /**
1490      * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
1491      * records the old and new text, and the start index. It also has
1492      * the links to the previous and next Changes in the chain. There
1493      * are two special UndoRedoChange objects in this chain representing the
1494      * head and the tail so we can have beforeFirst and afterLast
1495      * behavior as necessary.
1496      */
1497     static class UndoRedoChange {
1498         static long prevRecordTime;
1499         static final long CHANGE_DURATION = 2500; // milliseconds
1500         static boolean spaceCharSequence = false;
1501         int start;
1502         String oldText;
1503         String newText;
1504         UndoRedoChange prev;
1505         UndoRedoChange next;
1506 
1507         UndoRedoChange() { }
1508 
1509         public UndoRedoChange add(int start, String oldText, String newText) {
1510             UndoRedoChange c = new UndoRedoChange();
1511             c.start = start;
1512             c.oldText = oldText;
1513             c.newText = newText;
1514             c.prev = this;
1515             next = c;
1516             prevRecordTime = System.currentTimeMillis();
1517             return c;
1518         }
1519 
1520         static boolean hasChangeDurationElapsed() {
1521             return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
1522         }
1523 
1524         static void setSpaceCharSequence(boolean value) {
1525             spaceCharSequence = value;
1526         }
1527         static boolean isSpaceCharSequence() {
1528             return spaceCharSequence;
1529         }
1530 
1531         public UndoRedoChange discard() {
1532             prev.next = next;
1533             return prev;
1534         }
1535 
1536         // Handy to use when debugging, just put it in undo or redo
1537         // method or replaceText to see what is happening to the undo
1538         // history as it occurs.
1539         void debugPrint() {
1540             UndoRedoChange c = this;
1541             System.out.print(&quot;[&quot;);
1542             while (c != null) {
1543                 System.out.print(c.toString());
1544                 if (c.next != null) System.out.print(&quot;, &quot;);
1545                 c = c.next;
1546             }
1547             System.out.println(&quot;]&quot;);
1548         }
1549 
1550         @Override public String toString() {
1551             if (oldText == null &amp;&amp; newText == null) {
1552                 return &quot;head&quot;;
1553             }
1554             if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1555                 return &quot;added &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1556             } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1557                 return &quot;replaced &#39;&quot; + oldText + &quot;&#39; with &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1558             } else {
1559                 return &quot;deleted &#39;&quot; + oldText + &quot;&#39; at index &quot; + start;
1560             }
1561         }
1562     }
1563 
1564     /***************************************************************************
1565      *                                                                         *
1566      * Stylesheet Handling                                                     *
1567      *                                                                         *
1568      **************************************************************************/
1569 
1570 
1571     private static final PseudoClass PSEUDO_CLASS_READONLY
1572             = PseudoClass.getPseudoClass(&quot;readonly&quot;);
1573 
1574     private static class StyleableProperties {
1575         private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
1576             new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1577 
1578             @Override
1579             public boolean isSettable(TextInputControl n) {
1580                 return n.font == null || !n.font.isBound();
1581             }
1582 
1583             @Override
1584             public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
1585                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
1586             }
1587         };
1588 
1589         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1590         static {
1591             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1592                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1593             styleables.add(FONT);
1594             STYLEABLES = Collections.unmodifiableList(styleables);
1595         }
1596     }
1597 
1598     /**
1599      * @return The CssMetaData associated with this class, which may include the
1600      * CssMetaData of its superclasses.
1601      * @since JavaFX 8.0
1602      */
1603     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1604         return StyleableProperties.STYLEABLES;
1605     }
1606 
1607     /**
1608      * {@inheritDoc}
1609      * @since JavaFX 8.0
1610      */
1611     @Override
1612     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1613         return getClassCssMetaData();
1614     }
1615 
1616 
1617     /***************************************************************************
1618      *                                                                         *
1619      * Accessibility handling                                                  *
1620      *                                                                         *
1621      **************************************************************************/
1622 
1623     /** {@inheritDoc} */
1624     @Override
1625     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1626         switch (attribute) {
1627             case TEXT: {
1628                 String accText = getAccessibleText();
1629                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1630 
1631                 String text = getText();
1632                 if (text == null || text.isEmpty()) {
1633                     text = getPromptText();
1634                 }
1635                 return text;
1636             }
1637             case EDITABLE: return isEditable();
1638             case SELECTION_START: return getSelection().getStart();
1639             case SELECTION_END: return getSelection().getEnd();
1640             case CARET_OFFSET: return getCaretPosition();
1641             case FONT: return getFont();
1642             default: return super.queryAccessibleAttribute(attribute, parameters);
1643         }
1644     }
1645 
1646     /** {@inheritDoc} */
1647     @Override
1648     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1649         switch (action) {
1650             case SET_TEXT: {
1651                 String value = (String) parameters[0];
1652                 if (value != null) setText(value);
1653                 break;
1654             }
1655             case SET_TEXT_SELECTION: {
1656                 Integer start = (Integer) parameters[0];
1657                 Integer end = (Integer) parameters[1];
1658                 if (start != null &amp;&amp; end != null) {
1659                     selectRange(start,  end);
1660                 }
1661                 break;
1662             }
1663             default: super.executeAccessibleAction(action, parameters);
1664         }
1665     }
1666 
1667     private class TextInputControlFromatterAccessor implements FormatterAccessor {
1668         @Override
1669         public int getTextLength() {
1670             return TextInputControl.this.getLength();
1671         }
1672 
1673         @Override
1674         public String getText(int begin, int end) {
1675             return TextInputControl.this.getText(begin, end);
1676         }
1677 
1678         @Override
1679         public int getCaret() {
1680             return TextInputControl.this.getCaretPosition();
1681         }
1682 
1683         @Override
1684         public int getAnchor() {
1685             return TextInputControl.this.getAnchor();
1686         }
1687     }
1688 
1689 }
    </pre>
  </body>
</html>