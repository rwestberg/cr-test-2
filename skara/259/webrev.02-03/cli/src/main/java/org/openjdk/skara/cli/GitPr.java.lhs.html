<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 import org.openjdk.skara.version.Version;
  35 
  36 import java.io.IOException;
  37 import java.net.URI;
  38 import java.nio.charset.StandardCharsets;
  39 import java.nio.file.*;
  40 import java.util.*;
  41 import java.util.regex.Pattern;
  42 import java.util.concurrent.TimeUnit;
<a name="2" id="anc2"></a><span class="line-removed">  43 import java.util.function.Supplier;</span>
  44 import java.util.logging.Level;
  45 import java.util.regex.Matcher;
<a name="3" id="anc3"></a><span class="line-removed">  46 import java.util.regex.Pattern;</span>
  47 import java.util.stream.Collectors;
  48 
  49 public class GitPr {
<a name="4" id="anc4"></a><span class="line-removed">  50     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;</span>
  51     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  52     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  53         Pattern.compile(&quot;^\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  54 
  55     private static void exit(String fmt, Object...args) {
  56         System.err.println(String.format(fmt, args));
  57         System.exit(1);
  58     }
  59 
<a name="5" id="anc5"></a><span class="line-removed">  60     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {</span>
<span class="line-removed">  61         return () -&gt; {</span>
<span class="line-removed">  62             exit(fmt, args);</span>
<span class="line-removed">  63             return null;</span>
<span class="line-removed">  64         };</span>
<span class="line-removed">  65     }</span>
<span class="line-removed">  66 </span>
  67     private static String gitConfig(String key) {
  68         try {
  69             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  70             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  71             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  72             var p = pb.start();
  73 
  74             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  75             var res = p.waitFor();
  76             if (res != 0) {
  77                 return null;
  78             }
  79 
  80             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  81         } catch (InterruptedException e) {
  82             return null;
  83         } catch (IOException e) {
  84             return null;
  85         }
  86     }
  87 
  88     private static String getOption(String name, Arguments arguments) {
  89         return getOption(name, null, arguments);
  90     }
  91 
  92     private static String getOption(String name, String subsection, Arguments arguments) {
  93         if (arguments.contains(name)) {
  94             return arguments.get(name).asString();
  95         }
  96 
  97         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  98             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  99             if (subsectionSpecific != null) {
 100                 return subsectionSpecific;
 101             }
 102         }
 103 
 104         return gitConfig(&quot;fork.&quot; + name);
 105     }
 106 
 107     private static boolean getSwitch(String name, Arguments arguments) {
 108         return getSwitch(name, null, arguments);
 109     }
 110 
 111     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 112         if (arguments.contains(name)) {
 113             return true;
 114         }
 115 
 116         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 117             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 118             if (subsectionSpecific != null) {
 119                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 120             }
 121         }
 122 
 123         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 124         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 125     }
 126 
 127     private static String rightPad(String s, int length) {
 128         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 129     }
 130 
 131     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 132         var end = &quot; --&gt;&quot;;
 133         var pad = 79 - end.length();
 134         var newLine = &quot;\n&quot;;
 135         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 136     }
 137 
 138     private static String format(Issue issue) {
 139         var parts = issue.id().split(&quot;-&quot;);
 140         var id = parts.length == 2 ? parts[1] : issue.id();
 141         return id + &quot;: &quot; + issue.title();
 142     }
 143 
 144 
 145     private static String pullRequestIdArgument(Arguments arguments, ReadOnlyRepository repo) throws IOException {
 146         if (arguments.at(1).isPresent()) {
 147             return arguments.at(1).asString();
 148         }
 149 
 150         var currentBranch = repo.currentBranch();
 151         if (currentBranch.isPresent()) {
 152             var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 153             if (lines.size() == 1) {
 154                 return lines.get(0);
 155             }
 156         }
 157 
 158         exit(&quot;error: you must provide a pull request id&quot;);
 159         return null;
 160     }
 161 
 162     private static String statusForPullRequest(PullRequest pr) {
 163         var labels = pr.labels();
 164         if (pr.isDraft()) {
 165             return &quot;DRAFT&quot;;
 166         } else if (labels.contains(&quot;rfr&quot;)) {
 167             return &quot;RFR&quot;;
 168         } else if (labels.contains(&quot;ready&quot;)) {
 169             return &quot;READY&quot;;
 170         } else if (labels.contains(&quot;outdated&quot;)) {
 171             return &quot;OUTDATED&quot;;
 172         } else if (labels.contains(&quot;oca&quot;)) {
 173             return &quot;OCA&quot;;
 174         } else if (labels.contains(&quot;integrated&quot;)) {
 175             return &quot;INTEGRATED&quot;;
 176         } else {
 177             var checks = pr.checks(pr.headHash());
 178             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
 179             if (jcheck.isPresent()) {
 180                 var checkStatus = jcheck.get().status();
 181                 if (checkStatus == CheckStatus.IN_PROGRESS) {
 182                     return &quot;CHECKING&quot;;
 183                 } else if (checkStatus == CheckStatus.SUCCESS) {
 184                     return &quot;RFR&quot;;
 185                 } else if (checkStatus == CheckStatus.FAILURE) {
 186                     return &quot;FAILURE&quot;;
 187                 }
 188             } else {
 189                 return &quot;CHECKING&quot;;
 190             }
 191         }
 192 
 193         return &quot;UNKNOWN&quot;;
 194     }
 195 
 196     private static String statusForCheck(Check check) {
 197         var checkStatus = check.status();
 198         if (checkStatus == CheckStatus.IN_PROGRESS) {
 199             return &quot;RUNNING&quot;;
 200         } else if (checkStatus == CheckStatus.SUCCESS) {
 201             return &quot;OK&quot;;
 202         } else if (checkStatus == CheckStatus.FAILURE) {
 203             return &quot;FAILED&quot;;
 204         } else if (checkStatus == CheckStatus.CANCELLED) {
 205             return &quot;CANCELLED&quot;;
 206         }
 207 
 208         return &quot;UNKNOWN&quot;;
 209     }
 210 
 211     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 212         var issueTitleIndex = -1;
 213         var lines = pr.body().split(&quot;\n&quot;);
 214         for (var i = 0; i &lt; lines.length; i++) {
 215             if (lines[i].startsWith(&quot;## Issue&quot;)) {
 216                 issueTitleIndex = i;
 217                 break;
 218             }
 219         }
 220 
 221         if (issueTitleIndex == -1) {
 222             return List.of();
 223         }
 224 
 225         var issues = new ArrayList&lt;String&gt;();
 226         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 227             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 228             if (m.matches()) {
 229                 issues.add(m.group(1));
 230             } else {
 231                 break;
 232             }
 233         }
 234 
 235         return issues;
 236     }
 237 
 238     private static String jbsProjectFromJcheckConf(Repository repo, String targetBranch) throws IOException {
 239         var conf = JCheckConfiguration.from(repo, repo.resolve(targetBranch).orElseThrow(() -&gt;
 240             new IOException(&quot;Could not resolve &#39;&quot; + targetBranch + &quot;&#39; branch&quot;)
 241         ));
 242 
 243         return conf.general().jbs();
 244     }
 245 
 246     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 247         var message = CommitMessageParsers.v1.parse(commit.message());
 248         var issues = message.issues();
 249         if (issues.isEmpty()) {
 250             return getIssue(message.title(), project);
 251         } else if (issues.size() == 1) {
 252             var issue = issues.get(0);
 253             return getIssue(issue.id(), project);
 254         }
 255         return Optional.empty();
 256     }
 257 
 258     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 259         return getIssue(b.name(), project);
 260     }
 261 
 262     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 263         var m = ISSUE_ID_PATTERN.matcher(s);
 264         if (m.matches()) {
 265             var id = m.group(2);
 266             if (project == null) {
 267                 project = m.group(1);
 268             }
 269             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 270             return issueTracker.project(project).issue(id);
 271         }
 272 
 273         return Optional.empty();
 274     }
 275 
 276     private static void await(Process p, Integer... allowedExitCodes) throws IOException {
 277         var allowed = new HashSet&lt;&gt;(Arrays.asList(allowedExitCodes));
 278         allowed.add(0);
 279         try {
 280             var res = p.waitFor();
 281 
 282             if (!allowed.contains(res)) {
 283                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 284             }
 285         } catch (InterruptedException e) {
 286             throw new IOException(e);
 287         }
 288     }
 289 
 290     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 291         String editor = null;
 292         var lines = repo.config(&quot;core.editor&quot;);
 293         if (lines.size() == 1) {
 294             editor = lines.get(0);
 295         }
 296         if (editor == null) {
 297             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 298         }
 299         if (editor == null) {
 300             editor = System.getenv(&quot;EDITOR&quot;);
 301         }
 302         if (editor == null) {
 303             editor = System.getenv(&quot;VISUAL&quot;);
 304         }
 305         if (editor == null) {
 306             editor = &quot;vi&quot;;
 307         }
 308 
<a name="6" id="anc6"></a>



 309         List&lt;String&gt; editorParts = new ArrayList&lt;&gt;();
 310         Matcher em = Pattern.compile(&quot;([^\&quot;]\\S*|\&quot;.+?\&quot;)\\s*&quot;).matcher(editor);
 311         while (em.find()) {
 312             editorParts.add(em.group(1));
 313         }
 314         editorParts.add(file.toString());
 315         var pb = new ProcessBuilder(editorParts);
 316         pb.inheritIO();
 317         var p = pb.start();
 318         try {
 319             return p.waitFor() == 0;
 320         } catch (InterruptedException e) {
 321             throw new IOException(e);
 322         }
 323     }
 324 
 325     private static String projectName(URI uri) {
 326         var name = uri.getPath().toString().substring(1);
 327         if (name.endsWith(&quot;.git&quot;)) {
 328             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 329         }
 330         return name;
 331     }
 332 
 333     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 334         HostedRepository targetRepo = null;
 335 
 336         try {
 337             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 338             targetRepo = host.repository(projectName(upstream)).orElse(null);
 339         } catch (IOException e) {
 340             // do nothing
 341         }
 342 
 343         if (targetRepo == null) {
 344             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 345                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 346             );
 347             var parentRepo = remoteRepo.parent();
 348             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 349         }
 350 
 351         return targetRepo;
 352     }
 353 
 354     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 355         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 356         if (pr == null) {
 357             exit(&quot;error: could not fetch PR information&quot;);
 358         }
 359 
 360         return pr;
 361     }
 362 
 363     private static void show(String ref, Hash hash) throws IOException {
 364         show(ref, hash, null);
 365     }
 366     private static void show(String ref, Hash hash, Path dir) throws IOException {
 367         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 368                                                    &quot;--patch&quot;,
 369                                                    &quot;--find-renames=50%&quot;,
 370                                                    &quot;--find-copies=50%&quot;,
 371                                                    &quot;--find-copies-harder&quot;,
 372                                                    &quot;--abbrev&quot;,
 373                                                    ref + &quot;...&quot; + hash.hex());
 374         if (dir != null) {
 375             pb.directory(dir.toFile());
 376         }
 377         pb.inheritIO();
 378 
 379         // git will return 141 (128 + 13) when it receive SIGPIPE (signal 13) from
 380         // e.g. less when a user exits less when looking at a large diff. Therefore
 381         // must allow 141 as a valid exit code.
 382         await(pb.start(), 141);
 383     }
 384 
 385     private static void gimport() throws IOException {
 386         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 387         pb.inheritIO();
 388         await(pb.start());
 389     }
 390 
 391     private static void hgImport(Path patch) throws IOException {
 392         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 393         pb.inheritIO();
 394         await(pb.start());
 395     }
 396 
 397     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 398         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 399         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 400         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 401         var p = pb.start();
 402         var bytes = p.getInputStream().readAllBytes();
 403         var exited = p.waitFor(1, TimeUnit.MINUTES);
 404         var exitValue = p.exitValue();
 405         if (!exited || exitValue != 0) {
 406             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 407         }
 408 
 409         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 410     }
 411 
 412     private static String hgResolve(String ref) throws IOException, InterruptedException {
 413         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 414         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 415         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 416         var p = pb.start();
 417         var bytes = p.getInputStream().readAllBytes();
 418         var exited = p.waitFor(1, TimeUnit.MINUTES);
 419         var exitValue = p.exitValue();
 420         if (!exited || exitValue != 0) {
 421             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 422         }
 423 
 424         return new String(bytes, StandardCharsets.UTF_8);
 425     }
 426 
 427     private static Path diff(String ref, Hash hash) throws IOException {
 428         return diff(ref, hash, null);
 429     }
 430 
 431     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 432         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 433         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 434                                                    &quot;--patch&quot;,
 435                                                    &quot;--find-renames=50%&quot;,
 436                                                    &quot;--find-copies=50%&quot;,
 437                                                    &quot;--find-copies-harder&quot;,
 438                                                    &quot;--abbrev&quot;,
 439                                                    ref + &quot;...&quot; + hash.hex());
 440         if (dir != null) {
 441             pb.directory(dir.toFile());
 442         }
 443         pb.redirectOutput(patch.toFile());
 444         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 445         await(pb.start());
 446         return patch;
 447     }
 448 
 449     private static void apply(Path patch) throws IOException {
 450         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 451         pb.inheritIO();
 452         await(pb.start());
 453     }
 454 
 455     private static int longest(List&lt;String&gt; strings) {
 456         return strings.stream().mapToInt(String::length).max().orElse(0);
 457     }
 458 
 459     private static String removeTrailing(String s, String trail) {
 460         return s.endsWith(trail) ?
 461             s.substring(0, s.length() - trail.length()) :
 462             s;
 463     }
 464 
 465     public static void main(String[] args) throws IOException, InterruptedException {
 466         var flags = List.of(
 467             Option.shortcut(&quot;u&quot;)
 468                   .fullname(&quot;username&quot;)
 469                   .describe(&quot;NAME&quot;)
 470                   .helptext(&quot;Username on host&quot;)
 471                   .optional(),
 472             Option.shortcut(&quot;r&quot;)
 473                   .fullname(&quot;remote&quot;)
 474                   .describe(&quot;NAME&quot;)
 475                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 476                   .optional(),
 477             Option.shortcut(&quot;b&quot;)
 478                   .fullname(&quot;branch&quot;)
 479                   .describe(&quot;NAME&quot;)
 480                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 481                   .optional(),
 482             Option.shortcut(&quot;&quot;)
 483                   .fullname(&quot;authors&quot;)
 484                   .describe(&quot;LIST&quot;)
 485                   .helptext(&quot;Comma separated list of authors&quot;)
 486                   .optional(),
 487             Option.shortcut(&quot;&quot;)
 488                   .fullname(&quot;assignees&quot;)
 489                   .describe(&quot;LIST&quot;)
 490                   .helptext(&quot;Comma separated list of assignees&quot;)
 491                   .optional(),
 492             Option.shortcut(&quot;&quot;)
 493                   .fullname(&quot;labels&quot;)
 494                   .describe(&quot;LIST&quot;)
 495                   .helptext(&quot;Comma separated list of labels&quot;)
 496                   .optional(),
 497             Option.shortcut(&quot;&quot;)
 498                   .fullname(&quot;issues&quot;)
 499                   .describe(&quot;LIST&quot;)
 500                   .helptext(&quot;Comma separated list of issues&quot;)
 501                   .optional(),
 502             Option.shortcut(&quot;&quot;)
 503                   .fullname(&quot;columns&quot;)
 504                   .describe(&quot;id,title,author,assignees,labels&quot;)
 505                   .helptext(&quot;Comma separated list of columns to show&quot;)
 506                   .optional(),
 507             Switch.shortcut(&quot;&quot;)
 508                   .fullname(&quot;no-decoration&quot;)
 509                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 510                   .optional(),
 511             Switch.shortcut(&quot;&quot;)
 512                   .fullname(&quot;no-draft&quot;)
 513                   .helptext(&quot;Hide all pull requests in draft state&quot;)
 514                   .optional(),
 515             Switch.shortcut(&quot;&quot;)
 516                   .fullname(&quot;ignore-workspace&quot;)
 517                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 518                   .optional(),
 519             Switch.shortcut(&quot;&quot;)
 520                   .fullname(&quot;ignore-local-commits&quot;)
 521                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 522                   .optional(),
 523             Switch.shortcut(&quot;&quot;)
 524                   .fullname(&quot;publish&quot;)
 525                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 526                   .optional(),
 527             Switch.shortcut(&quot;&quot;)
 528                   .fullname(&quot;jcheck&quot;)
 529                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 530                   .optional(),
 531             Switch.shortcut(&quot;&quot;)
 532                   .fullname(&quot;no-token&quot;)
 533                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 534                   .optional(),
 535             Switch.shortcut(&quot;&quot;)
 536                   .fullname(&quot;no-checks&quot;)
 537                   .helptext(&quot;Do not show check status as part of the &#39;git pr status&#39; output&quot;)
 538                   .optional(),
 539             Switch.shortcut(&quot;&quot;)
 540                   .fullname(&quot;mercurial&quot;)
 541                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 542                   .optional(),
 543             Switch.shortcut(&quot;&quot;)
 544                   .fullname(&quot;verbose&quot;)
 545                   .helptext(&quot;Turn on verbose output&quot;)
 546                   .optional(),
 547             Switch.shortcut(&quot;&quot;)
 548                   .fullname(&quot;debug&quot;)
 549                   .helptext(&quot;Turn on debugging output&quot;)
 550                   .optional(),
 551             Switch.shortcut(&quot;&quot;)
 552                   .fullname(&quot;version&quot;)
 553                   .helptext(&quot;Print the version of this tool&quot;)
 554                   .optional());
 555 
 556         var actions = List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;, &quot;integrate&quot;,
 557                               &quot;approve&quot;, &quot;create&quot;, &quot;close&quot;, &quot;update&quot;, &quot;test&quot;, &quot;status&quot;);
 558         var inputs = List.of(
 559             Input.position(0)
 560                  .describe(String.join(&quot;|&quot;, actions))
 561                  .singular()
 562                  .optional(),
 563             Input.position(1)
 564                  .describe(&quot;ID&quot;)
 565                  .singular()
 566                  .optional()
 567         );
 568 
 569         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 570         var arguments = parser.parse(args);
 571 
 572         if (arguments.contains(&quot;version&quot;)) {
 573             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 574             System.exit(0);
 575         }
 576 
 577         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 578             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 579             Logging.setup(level);
 580         }
 581 
 582         HttpProxy.setup();
 583 
 584         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 585         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 586         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 587         var remote = getOption(&quot;remote&quot;, arguments);
 588         if (remote == null) {
 589             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 590         }
 591         var remotePullPath = repo.pullPath(remote);
 592         var username = getOption(&quot;username&quot;, arguments);
 593         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 594         var uri = Remote.toWebURI(remotePullPath);
 595         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 596         var credentials = !shouldUseToken ?
 597             null :
 598             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 599         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 600         var forge = credentials == null ?
 601             Forge.from(forgeURI) :
 602             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 603         if (forge.isEmpty()) {
 604             if (!shouldUseToken) {
 605                 if (arguments.contains(&quot;verbose&quot;)) {
 606                     System.err.println(&quot;&quot;);
 607                 }
 608                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 609                 if (!arguments.contains(&quot;verbose&quot;)) {
 610                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 611                     System.err.println(&quot;&quot;);
 612                 }
 613             }
 614             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 615         }
 616         var host = forge.get();
 617 
 618         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 619         if (action == null) {
 620             var lines = repo.config(&quot;pr.default&quot;);
 621             if (lines.size() == 1) {
 622                 action = lines.get(0);
 623             }
 624         }
 625 
 626         if (action == null) {
 627             System.err.println(&quot;error: you must supply a valid action:&quot;);
 628             for (var a : actions) {
 629                 System.err.println(&quot;       - &quot; + a);
 630             }
 631             System.err.println(&quot;You can also configure a default action by running &#39;git configure --global pr.default &lt;action&gt;&#39;&quot;);
 632             System.exit(1);
 633         }
 634 
 635         if (!shouldUseToken &amp;&amp;
 636             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 637             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 638             System.exit(1);
 639         }
 640 
 641         if (action.equals(&quot;create&quot;)) {
 642             if (isMercurial) {
 643                 var currentBookmark = repo.currentBookmark();
 644                 if (!currentBookmark.isPresent()) {
 645                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 646                     System.err.println(&quot;&quot;);
 647                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 648                     System.err.println(&quot;&quot;);
 649                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 650                     System.err.println(&quot;&quot;);
 651                     System.exit(1);
 652                 }
 653 
 654                 var bookmark = currentBookmark.get();
 655                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 656                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 657                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 658                     System.err.println(&quot;&quot;);
 659                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 660                     System.err.println(&quot;&quot;);
 661                     System.exit(1);
 662                 }
 663 
 664                 var tags = hgTags();
 665                 var upstreams = tags.stream()
 666                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 667                                     .collect(Collectors.toList());
 668                 if (upstreams.isEmpty()) {
 669                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 670                     System.err.println(&quot;&quot;);
 671                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 672                     System.err.println(&quot;&quot;);
 673                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 674                     System.err.println(&quot;&quot;);
 675                     System.exit(1);
 676                 }
 677 
 678                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 679                 for (var tag : tags) {
 680                     tagsAndHashes.put(tag, hgResolve(tag));
 681                 }
 682                 var bookmarkHash = hgResolve(bookmark.name());
 683                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 684                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 685                     System.err.println(&quot;&quot;);
 686 
 687                     if (upstreams.size() == 1) {
 688                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 689                         System.err.println(&quot;&quot;);
 690                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 691                         System.err.println(&quot;&quot;);
 692                     } else {
 693                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 694                         System.err.println(&quot;&quot;);
 695                         for (var upstream : upstreams) {
 696                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 697                         }
 698                         System.err.println(&quot;&quot;);
 699                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 700                         System.err.println(&quot;&quot;);
 701                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 702                         System.err.println(&quot;&quot;);
 703                     }
 704                     System.exit(1);
 705                 }
 706 
 707                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 708                 var targetHash = hgResolve(targetBranch);
 709                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 710                 if (commits.isEmpty()) {
 711                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 712                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 713                     System.exit(1);
 714                 }
 715 
 716                 var diff = repo.diff(repo.head());
 717                 if (!diff.patches().isEmpty()) {
 718                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 719                     System.err.println(&quot;&quot;);
 720                     for (var patch : diff.patches()) {
 721                         var path = patch.target().path().isPresent() ?
 722                             patch.target().path().get() : patch.source().path().get();
 723                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 724                     }
 725                     System.err.println(&quot;&quot;);
 726                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 727                     System.err.println(&quot;&quot;);
 728                     System.err.println(&quot;    hg commit --amend&quot;);
 729                     System.err.println(&quot;    hg git-cleanup&quot;);
 730                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 731                     System.err.println(&quot;    hg gimport&quot;);
 732                     System.err.println(&quot;&quot;);
 733                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 734                     System.err.println(&quot;&quot;);
 735                     System.err.println(&quot;    hg shelve&quot;);
 736                     System.err.println(&quot;&quot;);
 737                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 738                     System.exit(1);
 739                 }
 740 
 741                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 742                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 743                 );
 744                 if (token == null) {
 745                     GitCredentials.approve(credentials);
 746                 }
 747                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 748                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 749 
 750                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 751                 if (commits.size() == 1) {
 752                     var commit = commits.get(0);
 753                     var message = CommitMessageParsers.v1.parse(commit.message());
 754                     Files.writeString(file, message.title() + &quot;\n&quot;);
 755                     if (!message.summaries().isEmpty()) {
 756                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 757                     }
 758                     if (!message.additional().isEmpty()) {
 759                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 760                     }
 761                 } else {
 762                     Files.write(file, List.of(&quot;&quot;));
 763                 }
 764                 Files.write(file, List.of(
 765                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 766                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 767                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 768                     &quot;# the subject from the body.&quot;,
 769                     &quot;#&quot;,
 770                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 771                     ),
 772                     StandardOpenOption.APPEND
 773                 );
 774                 for (var commit : commits) {
 775                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 776                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 777                 }
 778                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 779                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 780                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 781                 var success = spawnEditor(repo, file);
 782                 if (!success) {
 783                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 784                     System.exit(1);
 785                 }
 786                 var lines = Files.readAllLines(file)
 787                                  .stream()
 788                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 789                                  .collect(Collectors.toList());
 790                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 791                 if (isEmpty) {
 792                     System.err.println(&quot;error: no message present, aborting&quot;);
 793                     System.exit(1);
 794                 }
 795 
 796                 var title = lines.get(0);
 797                 List&lt;String&gt; body = null;
 798                 if (lines.size() &gt; 1) {
 799                     body = lines.subList(1, lines.size())
 800                                 .stream()
 801                                 .dropWhile(String::isEmpty)
 802                                 .collect(Collectors.toList());
 803                 } else {
 804                     body = Collections.emptyList();
 805                 }
 806 
 807                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 808                 if (arguments.contains(&quot;assignees&quot;)) {
 809                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 810                     var assignees = usernames.stream()
 811                                              .map(u -&gt; host.user(u))
 812                                              .collect(Collectors.toList());
 813                     pr.setAssignees(assignees);
 814                 }
 815                 System.out.println(pr.webUrl().toString());
 816                 Files.deleteIfExists(file);
 817 
 818                 System.exit(0);
 819             }
 820             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 821                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 822                     System.exit(1);
 823                     return null;
 824             });
 825             if (currentBranch.equals(repo.defaultBranch())) {
 826                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 827                 System.err.println(&quot;&quot;);
 828                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 829                 System.err.println(&quot;&quot;);
 830                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 831                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 832                 System.err.println(&quot;&quot;);
 833                 System.exit(1);
 834             }
 835 
 836             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 837             if (!ignoreWorkspace) {
 838                 var diff = repo.diff(repo.head());
 839                 if (!diff.patches().isEmpty()) {
 840                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 841                     System.err.println(&quot;&quot;);
 842                     for (var patch : diff.patches()) {
 843                         var path = patch.target().path().isPresent() ?
 844                             patch.target().path().get() : patch.source().path().get();
 845                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 846                     }
 847                     System.err.println(&quot;&quot;);
 848                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 849                     System.err.println(&quot;&quot;);
 850                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 851                     System.err.println(&quot;&quot;);
 852                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 853                     System.err.println(&quot;&quot;);
 854                     System.err.println(&quot;    git stash&quot;);
 855                     System.err.println(&quot;&quot;);
 856                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 857                     System.exit(1);
 858                 }
 859             }
 860 
 861             var upstream = repo.upstreamFor(currentBranch);
 862             if (upstream.isEmpty()) {
 863                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 864                 if (shouldPublish) {
 865                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 866                     upstream = repo.upstreamFor(currentBranch);
 867                 } else {
 868                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 869                     System.err.println(&quot;&quot;);
 870                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 871                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 872                     System.err.println(&quot;&quot;);
 873                     System.err.println(&quot;    git publish&quot;);
 874                     System.err.println(&quot;&quot;);
 875                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 876                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 877                     System.err.println(&quot;&quot;);
 878                     System.err.println(&quot;    git fetch &quot; + remote);
 879                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 880                     System.err.println(&quot;&quot;);
 881                     System.exit(1);
 882                 }
 883             }
 884 
 885             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 886             repo.fetch(uri, upstreamRefName);
 887 
 888             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 889             if (!shouldIgnoreLocalCommits) {
 890                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 891                 if (!branchCommits.isEmpty()) {
 892                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 893                     System.err.println(&quot;&quot;);
 894                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 895                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 896                     System.err.println(&quot;&quot;);
 897                     for (var commit : branchCommits) {
 898                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 899                     }
 900                     System.err.println(&quot;&quot;);
 901                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 902                     System.err.println(&quot;&quot;);
 903                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 904                     System.err.println(&quot;&quot;);
 905                     System.exit(1);
 906                 }
 907             }
 908 
 909             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 910                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 911             );
 912             if (token == null) {
 913                 GitCredentials.approve(credentials);
 914             }
 915             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 916                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;)
 917             );
 918 
 919             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 920             if (targetBranch == null) {
 921                 var upstreamBranchNames = repo.remoteBranches(parentRepo.webUrl().toString())
 922                                               .stream()
 923                                               .map(r -&gt; r.name())
 924                                               .collect(Collectors.toSet());
 925                 var remoteBranches = repo.branches(remote);
 926                 var candidates = new ArrayList&lt;Branch&gt;();
 927                 for (var b : remoteBranches) {
 928                     var withoutRemotePrefix = b.name().substring(remote.length() + 1);
 929                     if (upstreamBranchNames.contains(withoutRemotePrefix)) {
 930                         candidates.add(b);
 931                     }
 932                 }
 933 
 934                 var localBranches = repo.branches();
 935                 Branch closest = null;
 936                 var shortestDistance = Integer.MAX_VALUE;
 937                 for (var b : candidates) {
 938                     var from = b.name();
 939                     for (var localBranch : localBranches) {
 940                         var trackingBranch = repo.upstreamFor(localBranch);
 941                         if (trackingBranch.isPresent() &amp;&amp;
 942                             trackingBranch.get().equals(b.name())) {
 943                             from = localBranch.name();
 944                         }
 945                     }
 946                     var distance = repo.commitMetadata(from + &quot;...&quot; + currentBranch.name()).size();
 947                     if (distance &lt; shortestDistance) {
 948                         closest = b;
 949                         shortestDistance = distance;
 950                     }
 951                 }
 952 
 953                 if (closest != null) {
 954                     targetBranch = closest.name().substring(remote.length() + 1);
 955                 } else {
 956                     System.err.println(&quot;error: cannot automatically infer target branch&quot;);
 957                     System.err.println(&quot;       use --branch to specify target branch&quot;);
 958                     System.exit(1);
 959                 }
 960             }
 961             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 962             if (commits.isEmpty()) {
 963                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 964                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 965                 System.exit(1);
 966             }
 967 
 968             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 969             if (shouldRunJCheck) {
 970                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 971                 var err = GitJCheck.run(jcheckArgs);
 972                 if (err != 0) {
 973                     System.exit(err);
 974                 }
 975             }
 976 
 977             var project = jbsProjectFromJcheckConf(repo, targetBranch);
 978             var issue = getIssue(currentBranch, project);
 979             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 980             if (issue.isPresent()) {
 981                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 982             } else if (commits.size() == 1) {
 983                 var commit = commits.get(0);
 984                 issue = getIssue(commit, project);
 985                 if (issue.isPresent()) {
 986                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 987                 } else {
 988                     var message = CommitMessageParsers.v1.parse(commit.message());
 989                     Files.writeString(file, message.title() + &quot;\n&quot;);
 990                     if (!message.summaries().isEmpty()) {
 991                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 992                     }
 993                     if (!message.additional().isEmpty()) {
 994                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 995                     }
 996                 }
 997             } else {
 998                 Files.write(file, List.of(&quot;&quot;));
 999             }
1000 
1001             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
1002             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
1003             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
1004             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
1005             appendPaddedHTMLComment(file, &quot;&quot;);
1006             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
1007             for (var commit : commits) {
1008                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
1009                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
1010                 if (!commit.isMerge()) {
1011                     var diff = commit.parentDiffs().get(0);
1012                     for (var patch : diff.patches()) {
1013                         var status = patch.status();
1014                         if (status.isModified()) {
1015                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
1016                         } else if (status.isAdded()) {
1017                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
1018                         } else if (status.isDeleted()) {
1019                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
1020                         } else if (status.isRenamed()) {
1021                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
1022                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
1023                         } else if (status.isCopied()) {
1024                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
1025                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
1026                         }
1027                     }
1028                 }
1029             }
1030             appendPaddedHTMLComment(file, &quot;&quot;);
1031             if (issue.isPresent()) {
1032                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
1033             }
1034             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
1035             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
1036 
1037             var success = spawnEditor(repo, file);
1038             if (!success) {
1039                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
1040                 System.exit(1);
1041             }
1042             var lines = Files.readAllLines(file)
1043                              .stream()
1044                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
1045                              .collect(Collectors.toList());
1046             var isEmpty = lines.stream().allMatch(String::isEmpty);
1047             if (isEmpty) {
1048                 System.err.println(&quot;error: no message present, aborting&quot;);
1049                 System.exit(1);
1050             }
1051 
1052             var title = lines.get(0);
1053             List&lt;String&gt; body = null;
1054             if (lines.size() &gt; 1) {
1055                 body = lines.subList(1, lines.size())
1056                             .stream()
1057                             .dropWhile(String::isEmpty)
1058                             .collect(Collectors.toList());
1059             } else {
1060                 body = Collections.emptyList();
1061             }
1062 
1063             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
1064             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
1065             if (assigneesOption != null) {
1066                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1067                 var assignees = usernames.stream()
1068                                          .map(u -&gt; host.user(u))
1069                                          .collect(Collectors.toList());
1070                 pr.setAssignees(assignees);
1071             }
1072             System.out.println(pr.webUrl().toString());
1073             Files.deleteIfExists(file);
1074 
1075             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
1076         } else if (action.equals(&quot;integrate&quot;)) {
1077             var id = pullRequestIdArgument(arguments, repo);
1078             var pr = getPullRequest(uri, repo, host, id);
1079             var integrateComment = pr.addComment(&quot;/integrate&quot;);
1080 
1081             var seenIntegrateComment = false;
1082             var expected = &quot;&lt;!-- Jmerge command reply message (&quot; + integrateComment.id() + &quot;) --&gt;&quot;;
1083             for (var i = 0; i &lt; 90; i++) {
1084                 var comments = pr.comments();
1085                 for (var comment : comments) {
1086                     if (!seenIntegrateComment) {
1087                         if (comment.id().equals(integrateComment.id())) {
1088                             seenIntegrateComment = true;
1089                         }
1090                         continue;
1091                     }
1092                     var lines = comment.body().split(&quot;\n&quot;);
1093                     if (lines.length &gt; 0 &amp;&amp; lines[0].equals(expected)) {
1094                         if (lines.length == 3 &amp;&amp; lines[2].startsWith(&quot;Pushed as commit&quot;)) {
1095                             var output = removeTrailing(lines[2], &quot;.&quot;);
1096                             System.out.println(output);
1097                             System.exit(0);
1098                         }
1099                     }
1100                 }
1101 
1102                 Thread.sleep(2000);
1103             }
1104 
1105             System.err.println(&quot;error: timed out waiting for response to /integrate command&quot;);
1106             System.exit(1);
1107         } else if (action.equals(&quot;test&quot;)) {
1108             var id = pullRequestIdArgument(arguments, repo);
1109             var pr = getPullRequest(uri, repo, host, id);
1110             var head = pr.headHash();
1111             var testComment = pr.addComment(&quot;/test&quot;);
1112 
1113             var seenTestComment = false;
1114             for (var i = 0; i &lt; 90; i++) {
1115                 var comments = pr.comments();
1116                 for (var comment : comments) {
1117                     if (!seenTestComment) {
1118                         if (comment.id().equals(testComment.id())) {
1119                             seenTestComment = true;
1120                         }
1121                         continue;
1122                     }
1123                     var lines = comment.body().split(&quot;\n&quot;);
1124                     var n = lines.length;
1125                     if (n &gt; 0) {
1126                         if (n == 4 &amp;&amp;
1127                             lines[0].equals(&quot;&lt;!-- TEST STARTED --&gt;&quot;) &amp;&amp;
1128                             lines[1].startsWith(&quot;&lt;!-- github.com-&quot;) &amp;&amp;
1129                             lines[2].equals(&quot;&lt;!-- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1130                             var output = removeTrailing(lines[3], &quot;.&quot;);
1131                             System.out.println(output);
1132                             System.exit(0);
1133                         } else if (n == 2 &amp;&amp;
1134                                    lines[0].equals(&quot;&lt;!-- TEST ERROR --&gt;&quot;)) {
1135                             var output = removeTrailing(lines[1], &quot;.&quot;);
1136                             System.out.println(output);
1137                             System.exit(1);
1138                         } else if (n == 4 &amp;&amp;
1139                                    lines[0].equals(&quot;&lt;!-- TEST PENDING --&gt;&quot;) &amp;&amp;
1140                                    lines[1].equals(&quot;&lt;!--- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1141                             var output = removeTrailing(lines[3], &quot;.&quot;);
1142                             System.out.println(output);
1143                             System.exit(0);
1144                         }
1145                     }
1146                 }
1147 
1148                 Thread.sleep(2000);
1149             }
1150 
1151         } else if (action.equals(&quot;approve&quot;)) {
1152             var id = arguments.at(1).isPresent() ? arguments.at(1).asString() : null;
1153             if (id == null) {
1154                 exit(&quot;error: you must provide a pull request id&quot;);
1155             }
1156             var pr = getPullRequest(uri, repo, host, id);
1157             pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
1158         } else if (action.equals(&quot;list&quot;)) {
1159             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1160             var prs = remoteRepo.pullRequests();
1161             var ids = new ArrayList&lt;String&gt;();
1162             var titles = new ArrayList&lt;String&gt;();
1163             var authors = new ArrayList&lt;String&gt;();
1164             var assignees = new ArrayList&lt;String&gt;();
1165             var labels = new ArrayList&lt;String&gt;();
1166             var issues = new ArrayList&lt;String&gt;();
1167             var branches = new ArrayList&lt;String&gt;();
1168             var statuses = new ArrayList&lt;String&gt;();
1169             var noDraft = getSwitch(&quot;no-draft&quot;, &quot;list&quot;, arguments);
1170 
1171             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
1172             var filterAuthors = authorsOption == null ?
1173                 Set.of() :
1174                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
1175 
1176             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
1177             var filterAssignees = assigneesOption == null ?
1178                 Set.of() :
1179                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
1180 
1181             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
1182             var filterLabels = labelsOption == null ?
1183                 Set.of() :
1184                 Arrays.asList(labelsOption.split(&quot;,&quot;));
1185 
1186             var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
1187             var filterIssues = issuesOption == null ?
1188                 Set.of() :
1189                 Arrays.asList(issuesOption.split(&quot;,&quot;));
1190 
1191             var columnTitles = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;, &quot;status&quot;);
1192             var columnValues = Map.of(columnTitles.get(0), ids,
1193                                       columnTitles.get(1), titles,
1194                                       columnTitles.get(2), authors,
1195                                       columnTitles.get(3), assignees,
1196                                       columnTitles.get(4), labels,
1197                                       columnTitles.get(5), issues,
1198                                       columnTitles.get(6), branches,
1199                                       columnTitles.get(7), statuses);
1200             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1201             var columns = columnsOption == null ?
1202                 List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;status&quot;) :
1203                 Arrays.asList(columnsOption.split(&quot;,&quot;));
1204 
1205             for (var column : columns) {
1206                 if (!columnTitles.contains(column)) {
1207                     System.err.println(&quot;error: unknown column: &quot; + column);
1208                     System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, columnTitles));
1209                     System.exit(1);
1210                 }
1211             }
1212 
1213             for (var pr : prs) {
1214                 if (pr.isDraft() &amp;&amp; noDraft) {
1215                     continue;
1216                 }
1217 
1218                 var prAuthor = pr.author().userName();
1219                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1220                     continue;
1221                 }
1222 
1223                 var prAssignees = pr.assignees().stream()
1224                                     .map(HostUser::userName)
1225                                     .collect(Collectors.toSet());
1226                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1227                     continue;
1228                 }
1229 
1230                 var prLabels = new HashSet&lt;&gt;(pr.labels());
1231                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1232                     continue;
1233                 }
1234 
1235                 var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1236                 if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1237                     continue;
1238                 }
1239 
1240 
1241                 ids.add(pr.id());
1242                 titles.add(pr.title());
1243                 authors.add(prAuthor);
1244                 assignees.add(String.join(&quot;,&quot;, prAssignees));
1245                 labels.add(String.join(&quot;,&quot;, prLabels));
1246                 issues.add(String.join(&quot;,&quot;, prIssues));
1247 
1248                 if (pr.author().userName().equals(credentials.username()) &amp;&amp;
1249                     pr.sourceRepository().webUrl().equals(uri)) {
1250                     branches.add(pr.sourceRef());
1251                 } else {
1252                     branches.add(&quot;&quot;);
1253                 }
1254 
1255                 if (columns.contains(&quot;status&quot;)) {
1256                     statuses.add(statusForPullRequest(pr).toLowerCase());
1257                 } else {
1258                     statuses.add(&quot;&quot;);
1259                 }
1260             }
1261 
1262 
1263             String fmt = &quot;&quot;;
1264             for (var column : columns.subList(0, columns.size() - 1)) {
1265                 var values = columnValues.get(column);
1266                 var n = Math.max(column.length(), longest(values));
1267                 fmt += &quot;%-&quot; + n + &quot;s    &quot;;
1268             }
1269             fmt += &quot;%s\n&quot;;
1270 
1271             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1272             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1273                 var upperCase = columns.stream()
1274                                        .map(String::toUpperCase)
1275                                        .collect(Collectors.toList());
1276                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1277             }
1278             for (var i = 0; i &lt; ids.size(); i++) {
1279                 final int n = i;
1280                 var row = columns.stream()
1281                                  .map(columnValues::get)
1282                                  .map(values -&gt; values.get(n))
1283                                  .collect(Collectors.toList());
1284                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1285             }
1286         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1287             var prId = arguments.at(1);
1288             if (!prId.isPresent()) {
1289                 exit(&quot;error: missing pull request identifier&quot;);
1290             }
1291 
1292             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1293             var pr = remoteRepo.pullRequest(prId.asString());
1294             var repoUrl = remoteRepo.webUrl();
1295             var prHeadRef = pr.fetchRef();
1296             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1297             if (isHgGit) {
1298                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1299                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1300 
1301                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1302                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1303                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1304 
1305                     if (action.equals(&quot;show&quot;)) {
1306                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1307                     } else {
1308                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1309                         hgImport(patch);
1310                         Files.delete(patch);
1311                     }
1312                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1313                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1314                     var hgGitBranches = hgGitRepo.branches();
1315                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1316                         hgGitRepo.delete(new Branch(hgGitRef));
1317                     }
1318                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1319                     gimport();
1320                     var hgFetchHead = repo.resolve(hgGitRef).get();
1321 
1322                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1323                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1324                     } else if (action.equals(&quot;checkout&quot;)) {
1325                         repo.checkout(hgFetchHead);
1326                         if (arguments.contains(&quot;branch&quot;)) {
1327                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1328                         }
1329                     }
1330                 } else {
1331                     exit(&quot;Unexpected action: &quot; + action);
1332                 }
1333 
1334                 return;
1335             }
1336 
1337             var fetchHead = repo.fetch(repoUrl, pr.fetchRef());
1338             if (action.equals(&quot;fetch&quot;)) {
1339                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1340                 if (branchName != null) {
1341                     repo.branch(fetchHead, branchName);
1342                 } else {
1343                     System.out.println(fetchHead.hex());
1344                 }
1345             } else if (action.equals(&quot;checkout&quot;)) {
1346                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1347                 if (branchName != null) {
1348                     var branch = repo.branch(fetchHead, branchName);
1349                     repo.checkout(branch, false);
1350                 } else {
1351                     repo.checkout(fetchHead, false);
1352                 }
1353             } else if (action.equals(&quot;show&quot;)) {
1354                 show(pr.targetRef(), fetchHead);
1355             } else if (action.equals(&quot;apply&quot;)) {
1356                 var patch = diff(pr.targetRef(), fetchHead);
1357                 apply(patch);
1358                 Files.deleteIfExists(patch);
1359             }
1360         } else if (action.equals(&quot;close&quot;)) {
1361             var prId = arguments.at(1);
1362             if (!prId.isPresent()) {
1363                 exit(&quot;error: missing pull request identifier&quot;);
1364             }
1365 
1366             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1367             var pr = remoteRepo.pullRequest(prId.asString());
1368             pr.setState(PullRequest.State.CLOSED);
1369         } else if (action.equals(&quot;update&quot;)) {
1370             var prId = arguments.at(1);
1371             if (!prId.isPresent()) {
1372                 exit(&quot;error: missing pull request identifier&quot;);
1373             }
1374 
1375             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1376             var pr = remoteRepo.pullRequest(prId.asString());
1377             var assigneesOption = getOption(&quot;assignees&quot;, &quot;update&quot;, arguments);
1378             if (assigneesOption != null) {
1379                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1380                 var assignees = usernames.stream()
1381                     .map(u -&gt; host.user(u))
1382                     .collect(Collectors.toList());
1383                 pr.setAssignees(assignees);
1384             }
1385         } else if (action.equals(&quot;status&quot;)) {
1386             String id = pullRequestIdArgument(arguments, repo);
1387             var pr = getPullRequest(uri, repo, host, id);
1388             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;status&quot;, arguments);
1389             var decoration = noDecoration ? &quot;&quot; : &quot;Status: &quot;;
1390             System.out.println(decoration + statusForPullRequest(pr));
1391 
1392             var noChecks = getSwitch(&quot;no-checks&quot;, &quot;status&quot;, arguments);
1393             if (!noChecks) {
1394                 var checks = pr.checks(pr.headHash());
1395                 var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
1396                 var submit = Optional.ofNullable(checks.get(&quot;submit&quot;));
1397                 var showChecks = jcheck.isPresent() || submit.isPresent();
1398                 if (showChecks) {
1399                     System.out.println(&quot;Checks:&quot;);
1400                     if (jcheck.isPresent()) {
1401                         System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1402                     }
1403                     if (submit.isPresent()) {
1404                         System.out.println(&quot;- submit: &quot; + statusForCheck(submit.get()));
1405                     }
1406                 }
1407             }
1408         } else {
1409             exit(&quot;error: unexpected action: &quot; + action);
1410         }
1411     }
1412 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>