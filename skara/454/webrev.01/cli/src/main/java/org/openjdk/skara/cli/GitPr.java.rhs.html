<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 import org.openjdk.skara.version.Version;
  35 
  36 import java.io.IOException;
  37 import java.net.URI;
  38 import java.nio.charset.StandardCharsets;
  39 import java.nio.file.*;
  40 import java.util.*;
  41 import java.util.regex.Pattern;
  42 import java.util.concurrent.TimeUnit;
  43 import java.util.logging.Level;
  44 import java.util.regex.Matcher;
  45 import java.util.stream.Collectors;
  46 
  47 public class GitPr {
  48     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  49     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  50         Pattern.compile(&quot;^\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  51 
  52     private static void exit(String fmt, Object...args) {
  53         System.err.println(String.format(fmt, args));
  54         System.exit(1);
  55     }
  56 
  57     private static String gitConfig(String key) {
  58         try {
  59             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  60             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  61             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  62             var p = pb.start();
  63 
  64             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  65             var res = p.waitFor();
  66             if (res != 0) {
  67                 return null;
  68             }
  69 
  70             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  71         } catch (InterruptedException e) {
  72             return null;
  73         } catch (IOException e) {
  74             return null;
  75         }
  76     }
  77 
  78     private static String getOption(String name, Arguments arguments) {
  79         return getOption(name, null, arguments);
  80     }
  81 
  82     private static String getOption(String name, String subsection, Arguments arguments) {
  83         if (arguments.contains(name)) {
  84             return arguments.get(name).asString();
  85         }
  86 
  87         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  88             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  89             if (subsectionSpecific != null) {
  90                 return subsectionSpecific;
  91             }
  92         }
  93 
  94         return gitConfig(&quot;fork.&quot; + name);
  95     }
  96 
  97     private static boolean getSwitch(String name, Arguments arguments) {
  98         return getSwitch(name, null, arguments);
  99     }
 100 
 101     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 102         if (arguments.contains(name)) {
 103             return true;
 104         }
 105 
 106         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 107             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 108             if (subsectionSpecific != null) {
 109                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 110             }
 111         }
 112 
 113         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 114         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 115     }
 116 
 117     private static String rightPad(String s, int length) {
 118         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 119     }
 120 
 121     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 122         var end = &quot; --&gt;&quot;;
 123         var pad = 79 - end.length();
 124         var newLine = &quot;\n&quot;;
 125         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 126     }
 127 
 128     private static String format(Issue issue) {
 129         var parts = issue.id().split(&quot;-&quot;);
 130         var id = parts.length == 2 ? parts[1] : issue.id();
 131         return id + &quot;: &quot; + issue.title();
 132     }
 133 
 134 
 135     private static String pullRequestIdArgument(Arguments arguments, ReadOnlyRepository repo) throws IOException {
 136         if (arguments.at(1).isPresent()) {
 137             return arguments.at(1).asString();
 138         }
 139 
 140         var currentBranch = repo.currentBranch();
 141         if (currentBranch.isPresent()) {
 142             var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 143             if (lines.size() == 1) {
 144                 return lines.get(0);
 145             }
 146         }
 147 
 148         exit(&quot;error: you must provide a pull request id&quot;);
 149         return null;
 150     }
 151 
 152     private static String statusForPullRequest(PullRequest pr) {
 153         var labels = pr.labels();
 154         if (pr.isDraft()) {
 155             return &quot;DRAFT&quot;;
 156         } else if (labels.contains(&quot;integrated&quot;)) {
 157             return &quot;INTEGRATED&quot;;
 158         } else if (labels.contains(&quot;ready&quot;)) {
 159             return &quot;READY&quot;;
 160         } else if (labels.contains(&quot;rfr&quot;)) {
 161             return &quot;RFR&quot;;
 162         } else if (labels.contains(&quot;outdated&quot;)) {
 163             return &quot;OUTDATED&quot;;
 164         } else if (labels.contains(&quot;oca&quot;)) {
 165             return &quot;OCA&quot;;
 166         } else {
 167             var checks = pr.checks(pr.headHash());
 168             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
 169             if (jcheck.isPresent()) {
 170                 var checkStatus = jcheck.get().status();
 171                 if (checkStatus == CheckStatus.IN_PROGRESS) {
 172                     return &quot;CHECKING&quot;;
 173                 } else if (checkStatus == CheckStatus.SUCCESS) {
 174                     return &quot;RFR&quot;;
 175                 } else if (checkStatus == CheckStatus.FAILURE) {
 176                     return &quot;FAILURE&quot;;
 177                 }
 178             } else {
 179                 return &quot;CHECKING&quot;;
 180             }
 181         }
 182 
 183         return &quot;UNKNOWN&quot;;
 184     }
 185 
 186     private static String statusForCheck(Check check) {
 187         var checkStatus = check.status();
 188         if (checkStatus == CheckStatus.IN_PROGRESS) {
 189             return &quot;RUNNING&quot;;
 190         } else if (checkStatus == CheckStatus.SUCCESS) {
 191             return &quot;OK&quot;;
 192         } else if (checkStatus == CheckStatus.FAILURE) {
 193             return &quot;FAILED&quot;;
 194         } else if (checkStatus == CheckStatus.CANCELLED) {
 195             return &quot;CANCELLED&quot;;
 196         }
 197 
 198         return &quot;UNKNOWN&quot;;
 199     }
 200 
 201     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 202         var issueTitleIndex = -1;
 203         var lines = pr.body().split(&quot;\n&quot;);
 204         for (var i = 0; i &lt; lines.length; i++) {
 205             if (lines[i].startsWith(&quot;## Issue&quot;)) {
 206                 issueTitleIndex = i;
 207                 break;
 208             }
 209         }
 210 
 211         if (issueTitleIndex == -1) {
 212             return List.of();
 213         }
 214 
 215         var issues = new ArrayList&lt;String&gt;();
 216         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 217             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 218             if (m.matches()) {
 219                 issues.add(m.group(1));
 220             } else {
 221                 break;
 222             }
 223         }
 224 
 225         return issues;
 226     }
 227 
 228     private static String jbsProjectFromJcheckConf(Repository repo, String targetBranch) throws IOException {
 229         var conf = JCheckConfiguration.from(repo, repo.resolve(targetBranch).orElseThrow(() -&gt;
 230             new IOException(&quot;Could not resolve &#39;&quot; + targetBranch + &quot;&#39; branch&quot;)
 231         ));
 232 
 233         return conf.general().jbs();
 234     }
 235 
 236     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 237         var message = CommitMessageParsers.v1.parse(commit.message());
 238         var issues = message.issues();
 239         if (issues.isEmpty()) {
 240             return getIssue(message.title(), project);
 241         } else if (issues.size() == 1) {
 242             var issue = issues.get(0);
 243             return getIssue(issue.id(), project);
 244         }
 245         return Optional.empty();
 246     }
 247 
 248     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 249         return getIssue(b.name(), project);
 250     }
 251 
 252     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 253         var m = ISSUE_ID_PATTERN.matcher(s);
 254         if (m.matches()) {
 255             var id = m.group(2);
 256             if (project == null) {
 257                 project = m.group(1);
 258             }
 259             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 260             return issueTracker.project(project).issue(id);
 261         }
 262 
 263         return Optional.empty();
 264     }
 265 
 266     private static void await(Process p, Integer... allowedExitCodes) throws IOException {
 267         var allowed = new HashSet&lt;&gt;(Arrays.asList(allowedExitCodes));
 268         allowed.add(0);
 269         try {
 270             var res = p.waitFor();
 271 
 272             if (!allowed.contains(res)) {
 273                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 274             }
 275         } catch (InterruptedException e) {
 276             throw new IOException(e);
 277         }
 278     }
 279 
 280     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 281         String editor = null;
 282         var lines = repo.config(&quot;core.editor&quot;);
 283         if (lines.size() == 1) {
 284             editor = lines.get(0);
 285         }
 286         if (editor == null) {
 287             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 288         }
 289         if (editor == null) {
 290             editor = System.getenv(&quot;EDITOR&quot;);
 291         }
 292         if (editor == null) {
 293             editor = System.getenv(&quot;VISUAL&quot;);
 294         }
 295         if (editor == null) {
 296             editor = &quot;vi&quot;;
 297         }
 298 
 299         // As an editor command may have multiple arguments, we need to add each single one
 300         // to the ProcessBuilder. Arguments are split by whitespace and can be quoted.
 301         // e.g. I found core.editor =
 302         // \&quot;C:\\\\Program Files\\\\Notepad++\\\\notepad++.exe\&quot; -multiInst -notabbar -nosession -noPlugin
 303         List&lt;String&gt; editorParts = new ArrayList&lt;&gt;();
 304         Matcher em = Pattern.compile(&quot;\\s*([^\&quot;]\\S*|\&quot;.+?\&quot;)\\s*&quot;).matcher(editor);
 305         while (em.find()) {
 306             editorParts.add(em.group(1));
 307         }
 308         editorParts.add(file.toString());
 309         var pb = new ProcessBuilder(editorParts);
 310         pb.inheritIO();
 311         var p = pb.start();
 312         try {
 313             return p.waitFor() == 0;
 314         } catch (InterruptedException e) {
 315             throw new IOException(e);
 316         }
 317     }
 318 
 319     private static String projectName(URI uri) {
 320         var name = uri.getPath().toString().substring(1);
 321         if (name.endsWith(&quot;.git&quot;)) {
 322             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 323         }
 324         return name;
 325     }
 326 
 327     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 328         HostedRepository targetRepo = null;
 329 
 330         try {
 331             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 332             targetRepo = host.repository(projectName(upstream)).orElse(null);
 333         } catch (IOException e) {
 334             // do nothing
 335         }
 336 
 337         if (targetRepo == null) {
 338             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 339                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 340             );
 341             var parentRepo = remoteRepo.parent();
 342             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 343         }
 344 
 345         return targetRepo;
 346     }
 347 
 348     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 349         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 350         if (pr == null) {
 351             exit(&quot;error: could not fetch PR information&quot;);
 352         }
 353 
 354         return pr;
 355     }
 356 
 357     private static void show(String ref, Hash hash) throws IOException {
 358         show(ref, hash, null);
 359     }
 360     private static void show(String ref, Hash hash, Path dir) throws IOException {
 361         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 362                                                    &quot;--patch&quot;,
 363                                                    &quot;--find-renames=50%&quot;,
 364                                                    &quot;--find-copies=50%&quot;,
 365                                                    &quot;--find-copies-harder&quot;,
 366                                                    &quot;--abbrev&quot;,
 367                                                    ref + &quot;...&quot; + hash.hex());
 368         if (dir != null) {
 369             pb.directory(dir.toFile());
 370         }
 371         pb.inheritIO();
 372 
 373         // git will return 141 (128 + 13) when it receive SIGPIPE (signal 13) from
 374         // e.g. less when a user exits less when looking at a large diff. Therefore
 375         // must allow 141 as a valid exit code.
 376         await(pb.start(), 141);
 377     }
 378 
 379     private static void gimport() throws IOException {
 380         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 381         pb.inheritIO();
 382         await(pb.start());
 383     }
 384 
 385     private static void hgImport(Path patch) throws IOException {
 386         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 387         pb.inheritIO();
 388         await(pb.start());
 389     }
 390 
 391     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 392         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 393         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 394         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 395         var p = pb.start();
 396         var bytes = p.getInputStream().readAllBytes();
 397         var exited = p.waitFor(1, TimeUnit.MINUTES);
 398         var exitValue = p.exitValue();
 399         if (!exited || exitValue != 0) {
 400             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 401         }
 402 
 403         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 404     }
 405 
 406     private static String hgResolve(String ref) throws IOException, InterruptedException {
 407         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 408         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 409         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 410         var p = pb.start();
 411         var bytes = p.getInputStream().readAllBytes();
 412         var exited = p.waitFor(1, TimeUnit.MINUTES);
 413         var exitValue = p.exitValue();
 414         if (!exited || exitValue != 0) {
 415             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 416         }
 417 
 418         return new String(bytes, StandardCharsets.UTF_8);
 419     }
 420 
 421     private static Path diff(String ref, Hash hash) throws IOException {
 422         return diff(ref, hash, null);
 423     }
 424 
 425     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 426         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 427         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 428                                                    &quot;--patch&quot;,
 429                                                    &quot;--find-renames=50%&quot;,
 430                                                    &quot;--find-copies=50%&quot;,
 431                                                    &quot;--find-copies-harder&quot;,
 432                                                    &quot;--abbrev&quot;,
 433                                                    ref + &quot;...&quot; + hash.hex());
 434         if (dir != null) {
 435             pb.directory(dir.toFile());
 436         }
 437         pb.redirectOutput(patch.toFile());
 438         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 439         await(pb.start());
 440         return patch;
 441     }
 442 
 443     private static void apply(Path patch) throws IOException {
 444         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 445         pb.inheritIO();
 446         await(pb.start());
 447     }
 448 
 449     private static int longest(List&lt;String&gt; strings) {
 450         return strings.stream().mapToInt(String::length).max().orElse(0);
 451     }
 452 
 453     private static String removeTrailing(String s, String trail) {
 454         return s.endsWith(trail) ?
 455             s.substring(0, s.length() - trail.length()) :
 456             s;
 457     }
 458 
 459     public static void main(String[] args) throws IOException, InterruptedException {
 460         var flags = List.of(
 461             Option.shortcut(&quot;u&quot;)
 462                   .fullname(&quot;username&quot;)
 463                   .describe(&quot;NAME&quot;)
 464                   .helptext(&quot;Username on host&quot;)
 465                   .optional(),
 466             Option.shortcut(&quot;r&quot;)
 467                   .fullname(&quot;remote&quot;)
 468                   .describe(&quot;NAME&quot;)
 469                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 470                   .optional(),
 471             Option.shortcut(&quot;b&quot;)
 472                   .fullname(&quot;branch&quot;)
 473                   .describe(&quot;NAME&quot;)
 474                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 475                   .optional(),
 476             Option.shortcut(&quot;&quot;)
 477                   .fullname(&quot;authors&quot;)
 478                   .describe(&quot;LIST&quot;)
 479                   .helptext(&quot;Comma separated list of authors&quot;)
 480                   .optional(),
 481             Option.shortcut(&quot;&quot;)
 482                   .fullname(&quot;assignees&quot;)
 483                   .describe(&quot;LIST&quot;)
 484                   .helptext(&quot;Comma separated list of assignees&quot;)
 485                   .optional(),
 486             Option.shortcut(&quot;&quot;)
 487                   .fullname(&quot;labels&quot;)
 488                   .describe(&quot;LIST&quot;)
 489                   .helptext(&quot;Comma separated list of labels&quot;)
 490                   .optional(),
 491             Option.shortcut(&quot;&quot;)
 492                   .fullname(&quot;issues&quot;)
 493                   .describe(&quot;LIST&quot;)
 494                   .helptext(&quot;Comma separated list of issues&quot;)
 495                   .optional(),
 496             Option.shortcut(&quot;&quot;)
 497                   .fullname(&quot;columns&quot;)
 498                   .describe(&quot;id,title,author,assignees,labels&quot;)
 499                   .helptext(&quot;Comma separated list of columns to show&quot;)
 500                   .optional(),
 501             Switch.shortcut(&quot;&quot;)
 502                   .fullname(&quot;no-decoration&quot;)
 503                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 504                   .optional(),
 505             Switch.shortcut(&quot;&quot;)
 506                   .fullname(&quot;no-draft&quot;)
 507                   .helptext(&quot;Hide all pull requests in draft state&quot;)
 508                   .optional(),
<a name="1" id="anc1"></a><span class="line-added"> 509             Switch.shortcut(&quot;&quot;)</span>
<span class="line-added"> 510                   .fullname(&quot;draft&quot;)</span>
<span class="line-added"> 511                   .helptext(&quot;Create a pull request in draft state&quot;)</span>
<span class="line-added"> 512                   .optional(),</span>
 513             Switch.shortcut(&quot;&quot;)
 514                   .fullname(&quot;ignore-workspace&quot;)
 515                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 516                   .optional(),
 517             Switch.shortcut(&quot;&quot;)
 518                   .fullname(&quot;ignore-local-commits&quot;)
 519                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 520                   .optional(),
 521             Switch.shortcut(&quot;&quot;)
 522                   .fullname(&quot;publish&quot;)
 523                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 524                   .optional(),
 525             Switch.shortcut(&quot;&quot;)
 526                   .fullname(&quot;atomic&quot;)
 527                   .helptext(&quot;Integrate the pull request atomically&quot;)
 528                   .optional(),
 529             Switch.shortcut(&quot;&quot;)
 530                   .fullname(&quot;jcheck&quot;)
 531                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 532                   .optional(),
 533             Switch.shortcut(&quot;&quot;)
 534                   .fullname(&quot;no-token&quot;)
 535                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 536                   .optional(),
 537             Switch.shortcut(&quot;&quot;)
 538                   .fullname(&quot;no-checks&quot;)
 539                   .helptext(&quot;Do not show check status as part of the &#39;git pr status&#39; output&quot;)
 540                   .optional(),
 541             Switch.shortcut(&quot;&quot;)
 542                   .fullname(&quot;mercurial&quot;)
 543                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 544                   .optional(),
 545             Switch.shortcut(&quot;&quot;)
 546                   .fullname(&quot;verbose&quot;)
 547                   .helptext(&quot;Turn on verbose output&quot;)
 548                   .optional(),
 549             Switch.shortcut(&quot;&quot;)
 550                   .fullname(&quot;debug&quot;)
 551                   .helptext(&quot;Turn on debugging output&quot;)
 552                   .optional(),
 553             Switch.shortcut(&quot;&quot;)
 554                   .fullname(&quot;version&quot;)
 555                   .helptext(&quot;Print the version of this tool&quot;)
 556                   .optional());
 557 
 558         var actions = List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;, &quot;integrate&quot;,
 559                               &quot;approve&quot;, &quot;create&quot;, &quot;close&quot;, &quot;set&quot;, &quot;test&quot;, &quot;status&quot;);
 560         var inputs = List.of(
 561             Input.position(0)
 562                  .describe(String.join(&quot;|&quot;, actions))
 563                  .singular()
 564                  .optional(),
 565             Input.position(1)
 566                  .describe(&quot;ID&quot;)
 567                  .singular()
 568                  .optional()
 569         );
 570 
 571         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 572         var arguments = parser.parse(args);
 573 
 574         if (arguments.contains(&quot;version&quot;)) {
 575             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 576             System.exit(0);
 577         }
 578 
 579         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 580             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 581             Logging.setup(level);
 582         }
 583 
 584         HttpProxy.setup();
 585 
 586         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 587         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 588         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 589         var remote = getOption(&quot;remote&quot;, arguments);
 590         if (remote == null) {
 591             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 592         }
 593         var remotePullPath = repo.pullPath(remote);
 594         var username = getOption(&quot;username&quot;, arguments);
 595         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 596         var uri = Remote.toWebURI(remotePullPath);
 597         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 598         var credentials = !shouldUseToken ?
 599             null :
 600             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 601         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 602         var forge = credentials == null ?
 603             Forge.from(forgeURI) :
 604             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 605         if (forge.isEmpty()) {
 606             if (!shouldUseToken) {
 607                 if (arguments.contains(&quot;verbose&quot;)) {
 608                     System.err.println(&quot;&quot;);
 609                 }
 610                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 611                 if (!arguments.contains(&quot;verbose&quot;)) {
 612                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 613                     System.err.println(&quot;&quot;);
 614                 }
 615             }
 616             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 617         }
 618         var host = forge.get();
 619 
 620         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 621         if (action == null) {
 622             var lines = repo.config(&quot;pr.default&quot;);
 623             if (lines.size() == 1) {
 624                 action = lines.get(0);
 625             }
 626         }
 627 
 628         if (action == null) {
 629             System.err.println(&quot;error: you must supply a valid action:&quot;);
 630             for (var a : actions) {
 631                 System.err.println(&quot;       - &quot; + a);
 632             }
 633             System.err.println(&quot;You can also configure a default action by running &#39;git configure --global pr.default &lt;action&gt;&#39;&quot;);
 634             System.exit(1);
 635         }
 636 
 637         if (!shouldUseToken &amp;&amp;
 638             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 639             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 640             System.exit(1);
 641         }
 642 
 643         if (action.equals(&quot;create&quot;)) {
 644             if (isMercurial) {
 645                 var currentBookmark = repo.currentBookmark();
 646                 if (!currentBookmark.isPresent()) {
 647                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 648                     System.err.println(&quot;&quot;);
 649                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 650                     System.err.println(&quot;&quot;);
 651                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 652                     System.err.println(&quot;&quot;);
 653                     System.exit(1);
 654                 }
 655 
 656                 var bookmark = currentBookmark.get();
 657                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 658                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 659                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 660                     System.err.println(&quot;&quot;);
 661                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 662                     System.err.println(&quot;&quot;);
 663                     System.exit(1);
 664                 }
 665 
 666                 var tags = hgTags();
 667                 var upstreams = tags.stream()
 668                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 669                                     .collect(Collectors.toList());
 670                 if (upstreams.isEmpty()) {
 671                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 672                     System.err.println(&quot;&quot;);
 673                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 674                     System.err.println(&quot;&quot;);
 675                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 676                     System.err.println(&quot;&quot;);
 677                     System.exit(1);
 678                 }
 679 
 680                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 681                 for (var tag : tags) {
 682                     tagsAndHashes.put(tag, hgResolve(tag));
 683                 }
 684                 var bookmarkHash = hgResolve(bookmark.name());
 685                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 686                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 687                     System.err.println(&quot;&quot;);
 688 
 689                     if (upstreams.size() == 1) {
 690                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 691                         System.err.println(&quot;&quot;);
 692                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 693                         System.err.println(&quot;&quot;);
 694                     } else {
 695                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 696                         System.err.println(&quot;&quot;);
 697                         for (var upstream : upstreams) {
 698                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 699                         }
 700                         System.err.println(&quot;&quot;);
 701                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 702                         System.err.println(&quot;&quot;);
 703                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 704                         System.err.println(&quot;&quot;);
 705                     }
 706                     System.exit(1);
 707                 }
 708 
 709                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 710                 var targetHash = hgResolve(targetBranch);
 711                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 712                 if (commits.isEmpty()) {
 713                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 714                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 715                     System.exit(1);
 716                 }
 717 
 718                 var diff = repo.diff(repo.head());
 719                 if (!diff.patches().isEmpty()) {
 720                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 721                     System.err.println(&quot;&quot;);
 722                     for (var patch : diff.patches()) {
 723                         var path = patch.target().path().isPresent() ?
 724                             patch.target().path().get() : patch.source().path().get();
 725                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 726                     }
 727                     System.err.println(&quot;&quot;);
 728                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 729                     System.err.println(&quot;&quot;);
 730                     System.err.println(&quot;    hg commit --amend&quot;);
 731                     System.err.println(&quot;    hg git-cleanup&quot;);
 732                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 733                     System.err.println(&quot;    hg gimport&quot;);
 734                     System.err.println(&quot;&quot;);
 735                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 736                     System.err.println(&quot;&quot;);
 737                     System.err.println(&quot;    hg shelve&quot;);
 738                     System.err.println(&quot;&quot;);
 739                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 740                     System.exit(1);
 741                 }
 742 
 743                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 744                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 745                 );
 746                 if (token == null) {
 747                     GitCredentials.approve(credentials);
 748                 }
 749                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 750                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 751 
 752                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 753                 if (commits.size() == 1) {
 754                     var commit = commits.get(0);
 755                     var message = CommitMessageParsers.v1.parse(commit.message());
 756                     Files.writeString(file, message.title() + &quot;\n&quot;);
 757                     if (!message.summaries().isEmpty()) {
 758                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 759                     }
 760                     if (!message.additional().isEmpty()) {
 761                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 762                     }
 763                 } else {
 764                     Files.write(file, List.of(&quot;&quot;));
 765                 }
 766                 Files.write(file, List.of(
 767                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 768                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 769                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 770                     &quot;# the subject from the body.&quot;,
 771                     &quot;#&quot;,
 772                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 773                     ),
 774                     StandardOpenOption.APPEND
 775                 );
 776                 for (var commit : commits) {
 777                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 778                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 779                 }
 780                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 781                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 782                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 783                 var success = spawnEditor(repo, file);
 784                 if (!success) {
 785                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 786                     System.exit(1);
 787                 }
 788                 var lines = Files.readAllLines(file)
 789                                  .stream()
 790                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 791                                  .collect(Collectors.toList());
 792                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 793                 if (isEmpty) {
 794                     System.err.println(&quot;error: no message present, aborting&quot;);
 795                     System.exit(1);
 796                 }
 797 
 798                 var title = lines.get(0);
 799                 List&lt;String&gt; body = null;
 800                 if (lines.size() &gt; 1) {
 801                     body = lines.subList(1, lines.size())
 802                                 .stream()
 803                                 .dropWhile(String::isEmpty)
 804                                 .collect(Collectors.toList());
 805                 } else {
 806                     body = Collections.emptyList();
 807                 }
 808 
 809                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 810                 if (arguments.contains(&quot;assignees&quot;)) {
 811                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 812                     var assignees = usernames.stream()
 813                                              .map(u -&gt; host.user(u))
 814                                              .filter(Optional::isPresent)
 815                                              .map(Optional::get)
 816                                              .collect(Collectors.toList());
 817                     pr.setAssignees(assignees);
 818                 }
 819                 System.out.println(pr.webUrl().toString());
 820                 Files.deleteIfExists(file);
 821 
 822                 System.exit(0);
 823             }
 824             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 825                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 826                     System.exit(1);
 827                     return null;
 828             });
 829             if (currentBranch.equals(repo.defaultBranch())) {
 830                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 831                 System.err.println(&quot;&quot;);
 832                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 833                 System.err.println(&quot;&quot;);
 834                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 835                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 836                 System.err.println(&quot;&quot;);
 837                 System.exit(1);
 838             }
 839 
 840             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 841             if (!ignoreWorkspace) {
 842                 var diff = repo.diff(repo.head());
 843                 if (!diff.patches().isEmpty()) {
 844                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 845                     System.err.println(&quot;&quot;);
 846                     for (var patch : diff.patches()) {
 847                         var path = patch.target().path().isPresent() ?
 848                             patch.target().path().get() : patch.source().path().get();
 849                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 850                     }
 851                     System.err.println(&quot;&quot;);
 852                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 853                     System.err.println(&quot;&quot;);
 854                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 855                     System.err.println(&quot;&quot;);
 856                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 857                     System.err.println(&quot;&quot;);
 858                     System.err.println(&quot;    git stash&quot;);
 859                     System.err.println(&quot;&quot;);
 860                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 861                     System.exit(1);
 862                 }
 863             }
 864 
 865             var upstream = repo.upstreamFor(currentBranch);
 866             if (upstream.isEmpty()) {
 867                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 868                 if (shouldPublish) {
 869                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 870                     upstream = repo.upstreamFor(currentBranch);
 871                 } else {
 872                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 873                     System.err.println(&quot;&quot;);
 874                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 875                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 876                     System.err.println(&quot;&quot;);
 877                     System.err.println(&quot;    git publish&quot;);
 878                     System.err.println(&quot;&quot;);
 879                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 880                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 881                     System.err.println(&quot;&quot;);
 882                     System.err.println(&quot;    git fetch &quot; + remote);
 883                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 884                     System.err.println(&quot;&quot;);
 885                     System.exit(1);
 886                 }
 887             }
 888 
 889             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 890             repo.fetch(uri, upstreamRefName);
 891 
 892             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 893             if (!shouldIgnoreLocalCommits) {
 894                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 895                 if (!branchCommits.isEmpty()) {
 896                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 897                     System.err.println(&quot;&quot;);
 898                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 899                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 900                     System.err.println(&quot;&quot;);
 901                     for (var commit : branchCommits) {
 902                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 903                     }
 904                     System.err.println(&quot;&quot;);
 905                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 906                     System.err.println(&quot;&quot;);
 907                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 908                     System.err.println(&quot;&quot;);
 909                     System.exit(1);
 910                 }
 911             }
 912 
 913             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 914                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 915             );
 916             if (token == null) {
 917                 GitCredentials.approve(credentials);
 918             }
 919             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 920                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;)
 921             );
 922 
 923             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 924             if (targetBranch == null) {
 925                 var upstreamBranchNames = repo.remoteBranches(parentRepo.webUrl().toString())
 926                                               .stream()
 927                                               .map(r -&gt; r.name())
 928                                               .collect(Collectors.toSet());
 929                 var remoteBranches = repo.branches(remote);
 930                 var candidates = new ArrayList&lt;Branch&gt;();
 931                 for (var b : remoteBranches) {
 932                     var withoutRemotePrefix = b.name().substring(remote.length() + 1);
 933                     if (upstreamBranchNames.contains(withoutRemotePrefix)) {
 934                         candidates.add(b);
 935                     }
 936                 }
 937 
 938                 var localBranches = repo.branches();
 939                 Branch closest = null;
 940                 var shortestDistance = Integer.MAX_VALUE;
 941                 for (var b : candidates) {
 942                     var from = b.name();
 943                     for (var localBranch : localBranches) {
 944                         var trackingBranch = repo.upstreamFor(localBranch);
 945                         if (trackingBranch.isPresent() &amp;&amp;
 946                             trackingBranch.get().equals(b.name())) {
 947                             from = localBranch.name();
 948                         }
 949                     }
 950                     var distance = repo.commitMetadata(from + &quot;...&quot; + currentBranch.name()).size();
 951                     if (distance &lt; shortestDistance) {
 952                         closest = b;
 953                         shortestDistance = distance;
 954                     }
 955                 }
 956 
 957                 if (closest != null) {
 958                     targetBranch = closest.name().substring(remote.length() + 1);
 959                 } else {
 960                     System.err.println(&quot;error: cannot automatically infer target branch&quot;);
 961                     System.err.println(&quot;       use --branch to specify target branch&quot;);
 962                     System.exit(1);
 963                 }
 964             }
 965             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 966             if (commits.isEmpty()) {
 967                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 968                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 969                 System.exit(1);
 970             }
 971 
 972             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 973             if (shouldRunJCheck) {
 974                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 975                 var err = GitJCheck.run(jcheckArgs);
 976                 if (err != 0) {
 977                     System.exit(err);
 978                 }
 979             }
 980 
 981             var project = jbsProjectFromJcheckConf(repo, targetBranch);
 982             var issue = getIssue(currentBranch, project);
 983             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 984             if (issue.isPresent()) {
 985                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 986             } else if (commits.size() == 1) {
 987                 var commit = commits.get(0);
 988                 issue = getIssue(commit, project);
 989                 if (issue.isPresent()) {
 990                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 991                 } else {
 992                     var message = CommitMessageParsers.v1.parse(commit.message());
 993                     Files.writeString(file, message.title() + &quot;\n&quot;);
 994                     if (!message.summaries().isEmpty()) {
 995                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 996                     }
 997                     if (!message.additional().isEmpty()) {
 998                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 999                     }
1000                 }
1001             } else {
1002                 Files.write(file, List.of(&quot;&quot;));
1003             }
1004 
1005             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
1006             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
1007             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
1008             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
1009             appendPaddedHTMLComment(file, &quot;&quot;);
1010             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
1011             for (var commit : commits) {
1012                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
1013                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
1014                 if (!commit.isMerge()) {
1015                     var diff = commit.parentDiffs().get(0);
1016                     for (var patch : diff.patches()) {
1017                         var status = patch.status();
1018                         if (status.isModified()) {
1019                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
1020                         } else if (status.isAdded()) {
1021                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
1022                         } else if (status.isDeleted()) {
1023                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
1024                         } else if (status.isRenamed()) {
1025                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
1026                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
1027                         } else if (status.isCopied()) {
1028                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
1029                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
1030                         }
1031                     }
1032                 }
1033             }
1034             appendPaddedHTMLComment(file, &quot;&quot;);
1035             if (issue.isPresent()) {
1036                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
1037             }
1038             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
1039             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
1040 
1041             var success = spawnEditor(repo, file);
1042             if (!success) {
1043                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
1044                 System.exit(1);
1045             }
1046             var lines = Files.readAllLines(file)
1047                              .stream()
1048                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
1049                              .collect(Collectors.toList());
1050             var isEmpty = lines.stream().allMatch(String::isEmpty);
1051             if (isEmpty) {
1052                 System.err.println(&quot;error: no message present, aborting&quot;);
1053                 System.exit(1);
1054             }
1055 
1056             var title = lines.get(0);
1057             List&lt;String&gt; body = null;
1058             if (lines.size() &gt; 1) {
1059                 body = lines.subList(1, lines.size())
1060                             .stream()
1061                             .dropWhile(String::isEmpty)
1062                             .collect(Collectors.toList());
1063             } else {
1064                 body = Collections.emptyList();
1065             }
1066 
<a name="2" id="anc2"></a><span class="line-modified">1067             var isDraft = getSwitch(&quot;draft&quot;, &quot;create&quot;, arguments);</span>
<span class="line-added">1068             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body, isDraft);</span>
1069             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
1070             if (assigneesOption != null) {
1071                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1072                 var assignees = usernames.stream()
1073                                          .map(u -&gt; host.user(u))
1074                                          .filter(Optional::isPresent)
1075                                          .map(Optional::get)
1076                                          .collect(Collectors.toList());
1077                 pr.setAssignees(assignees);
1078             }
1079             System.out.println(pr.webUrl().toString());
1080             Files.deleteIfExists(file);
1081 
1082             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
1083         } else if (action.equals(&quot;integrate&quot;)) {
1084             var id = pullRequestIdArgument(arguments, repo);
1085             var pr = getPullRequest(uri, repo, host, id);
1086             var isAtomic = getSwitch(&quot;atomic&quot;, &quot;integrate&quot;, arguments);
1087 
1088             var message = &quot;/integrate&quot;;
1089             if (isAtomic) {
1090                 var targetHash = repo.resolve(pr.targetRef());
1091                 if (!targetHash.isPresent()) {
1092                     exit(&quot;error: cannot resolve target branch &quot; + pr.targetRef());
1093                 }
1094                 var sourceHash = repo.fetch(pr.repository().webUrl(), pr.fetchRef());
1095                 var mergeBase = repo.mergeBase(sourceHash, targetHash.get());
1096                 message += &quot; &quot; + mergeBase.hex();
1097             }
1098 
1099             var integrateComment = pr.addComment(message);
1100 
1101             var seenIntegrateComment = false;
1102             var expected = &quot;&lt;!-- Jmerge command reply message (&quot; + integrateComment.id() + &quot;) --&gt;&quot;;
1103             for (var i = 0; i &lt; 90; i++) {
1104                 var comments = pr.comments();
1105                 for (var comment : comments) {
1106                     if (!seenIntegrateComment) {
1107                         if (comment.id().equals(integrateComment.id())) {
1108                             seenIntegrateComment = true;
1109                         }
1110                         continue;
1111                     }
1112                     var lines = comment.body().split(&quot;\n&quot;);
1113                     if (lines.length &gt; 0 &amp;&amp; lines[0].equals(expected)) {
1114                         for (var line : lines) {
1115                             if (line.startsWith(&quot;Pushed as commit&quot;)) {
1116                                 var output = removeTrailing(line, &quot;.&quot;);
1117                                 System.out.println(output);
1118                                 System.exit(0);
1119                             }
1120                         }
1121                     }
1122                 }
1123 
1124                 Thread.sleep(2000);
1125             }
1126 
1127             System.err.println(&quot;error: timed out waiting for response to /integrate command&quot;);
1128             System.exit(1);
1129         } else if (action.equals(&quot;test&quot;)) {
1130             var id = pullRequestIdArgument(arguments, repo);
1131             var pr = getPullRequest(uri, repo, host, id);
1132             var head = pr.headHash();
1133             var testComment = pr.addComment(&quot;/test&quot;);
1134 
1135             var seenTestComment = false;
1136             for (var i = 0; i &lt; 90; i++) {
1137                 var comments = pr.comments();
1138                 for (var comment : comments) {
1139                     if (!seenTestComment) {
1140                         if (comment.id().equals(testComment.id())) {
1141                             seenTestComment = true;
1142                         }
1143                         continue;
1144                     }
1145                     var lines = comment.body().split(&quot;\n&quot;);
1146                     var n = lines.length;
1147                     if (n &gt; 0) {
1148                         if (n == 4 &amp;&amp;
1149                             lines[0].equals(&quot;&lt;!-- TEST STARTED --&gt;&quot;) &amp;&amp;
1150                             lines[1].startsWith(&quot;&lt;!-- github.com-&quot;) &amp;&amp;
1151                             lines[2].equals(&quot;&lt;!-- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1152                             var output = removeTrailing(lines[3], &quot;.&quot;);
1153                             System.out.println(output);
1154                             System.exit(0);
1155                         } else if (n == 2 &amp;&amp;
1156                                    lines[0].equals(&quot;&lt;!-- TEST ERROR --&gt;&quot;)) {
1157                             var output = removeTrailing(lines[1], &quot;.&quot;);
1158                             System.out.println(output);
1159                             System.exit(1);
1160                         } else if (n == 4 &amp;&amp;
1161                                    lines[0].equals(&quot;&lt;!-- TEST PENDING --&gt;&quot;) &amp;&amp;
1162                                    lines[1].equals(&quot;&lt;!--- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1163                             var output = removeTrailing(lines[3], &quot;.&quot;);
1164                             System.out.println(output);
1165                             System.exit(0);
1166                         }
1167                     }
1168                 }
1169 
1170                 Thread.sleep(2000);
1171             }
1172 
1173         } else if (action.equals(&quot;approve&quot;)) {
1174             var id = arguments.at(1).isPresent() ? arguments.at(1).asString() : null;
1175             if (id == null) {
1176                 exit(&quot;error: you must provide a pull request id&quot;);
1177             }
1178             var pr = getPullRequest(uri, repo, host, id);
1179             pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
1180         } else if (action.equals(&quot;list&quot;)) {
1181             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1182             var prs = remoteRepo.pullRequests();
1183             var ids = new ArrayList&lt;String&gt;();
1184             var titles = new ArrayList&lt;String&gt;();
1185             var authors = new ArrayList&lt;String&gt;();
1186             var assignees = new ArrayList&lt;String&gt;();
1187             var labels = new ArrayList&lt;String&gt;();
1188             var issues = new ArrayList&lt;String&gt;();
1189             var branches = new ArrayList&lt;String&gt;();
1190             var statuses = new ArrayList&lt;String&gt;();
1191             var noDraft = getSwitch(&quot;no-draft&quot;, &quot;list&quot;, arguments);
1192 
1193             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
1194             var filterAuthors = authorsOption == null ?
1195                 Set.of() :
1196                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
1197 
1198             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
1199             var filterAssignees = assigneesOption == null ?
1200                 Set.of() :
1201                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
1202 
1203             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
1204             var filterLabels = labelsOption == null ?
1205                 Set.of() :
1206                 Arrays.asList(labelsOption.split(&quot;,&quot;));
1207 
1208             var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
1209             var filterIssues = issuesOption == null ?
1210                 Set.of() :
1211                 Arrays.asList(issuesOption.split(&quot;,&quot;));
1212 
1213             var columnTitles = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;, &quot;status&quot;);
1214             var columnValues = Map.of(columnTitles.get(0), ids,
1215                                       columnTitles.get(1), titles,
1216                                       columnTitles.get(2), authors,
1217                                       columnTitles.get(3), assignees,
1218                                       columnTitles.get(4), labels,
1219                                       columnTitles.get(5), issues,
1220                                       columnTitles.get(6), branches,
1221                                       columnTitles.get(7), statuses);
1222             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1223             var columns = columnsOption == null ?
1224                 List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;status&quot;) :
1225                 Arrays.asList(columnsOption.split(&quot;,&quot;));
1226 
1227             for (var column : columns) {
1228                 if (!columnTitles.contains(column)) {
1229                     System.err.println(&quot;error: unknown column: &quot; + column);
1230                     System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, columnTitles));
1231                     System.exit(1);
1232                 }
1233             }
1234 
1235             for (var pr : prs) {
1236                 if (pr.isDraft() &amp;&amp; noDraft) {
1237                     continue;
1238                 }
1239 
1240                 var prAuthor = pr.author().userName();
1241                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1242                     continue;
1243                 }
1244 
1245                 var prAssignees = pr.assignees().stream()
1246                                     .map(HostUser::userName)
1247                                     .collect(Collectors.toSet());
1248                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1249                     continue;
1250                 }
1251 
1252                 var prLabels = new HashSet&lt;&gt;(pr.labels());
1253                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1254                     continue;
1255                 }
1256 
1257                 var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1258                 if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1259                     continue;
1260                 }
1261 
1262 
1263                 ids.add(pr.id());
1264                 titles.add(pr.title());
1265                 authors.add(prAuthor);
1266                 assignees.add(String.join(&quot;,&quot;, prAssignees));
1267                 labels.add(String.join(&quot;,&quot;, prLabels));
1268                 issues.add(String.join(&quot;,&quot;, prIssues));
1269 
1270                 if (pr.author().userName().equals(credentials.username()) &amp;&amp;
1271                     pr.sourceRepository().webUrl().equals(uri)) {
1272                     branches.add(pr.sourceRef());
1273                 } else {
1274                     branches.add(&quot;&quot;);
1275                 }
1276 
1277                 if (columns.contains(&quot;status&quot;)) {
1278                     statuses.add(statusForPullRequest(pr).toLowerCase());
1279                 } else {
1280                     statuses.add(&quot;&quot;);
1281                 }
1282             }
1283 
1284 
1285             String fmt = &quot;&quot;;
1286             for (var column : columns.subList(0, columns.size() - 1)) {
1287                 var values = columnValues.get(column);
1288                 var n = Math.max(column.length(), longest(values));
1289                 fmt += &quot;%-&quot; + n + &quot;s    &quot;;
1290             }
1291             fmt += &quot;%s\n&quot;;
1292 
1293             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1294             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1295                 var upperCase = columns.stream()
1296                                        .map(String::toUpperCase)
1297                                        .collect(Collectors.toList());
1298                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1299             }
1300             for (var i = 0; i &lt; ids.size(); i++) {
1301                 final int n = i;
1302                 var row = columns.stream()
1303                                  .map(columnValues::get)
1304                                  .map(values -&gt; values.get(n))
1305                                  .collect(Collectors.toList());
1306                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1307             }
1308         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1309             var prId = arguments.at(1);
1310             if (!prId.isPresent()) {
1311                 exit(&quot;error: missing pull request identifier&quot;);
1312             }
1313 
1314             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1315             var pr = remoteRepo.pullRequest(prId.asString());
1316             var repoUrl = remoteRepo.webUrl();
1317             var prHeadRef = pr.fetchRef();
1318             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1319             if (isHgGit) {
1320                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1321                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1322 
1323                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1324                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1325                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1326 
1327                     if (action.equals(&quot;show&quot;)) {
1328                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1329                     } else {
1330                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1331                         hgImport(patch);
1332                         Files.delete(patch);
1333                     }
1334                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1335                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1336                     var hgGitBranches = hgGitRepo.branches();
1337                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1338                         hgGitRepo.delete(new Branch(hgGitRef));
1339                     }
1340                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1341                     gimport();
1342                     var hgFetchHead = repo.resolve(hgGitRef).get();
1343 
1344                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1345                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1346                     } else if (action.equals(&quot;checkout&quot;)) {
1347                         repo.checkout(hgFetchHead);
1348                         if (arguments.contains(&quot;branch&quot;)) {
1349                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1350                         }
1351                     }
1352                 } else {
1353                     exit(&quot;Unexpected action: &quot; + action);
1354                 }
1355 
1356                 return;
1357             }
1358 
1359             var fetchHead = repo.fetch(repoUrl, pr.fetchRef());
1360             if (action.equals(&quot;fetch&quot;)) {
1361                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1362                 if (branchName != null) {
1363                     repo.branch(fetchHead, branchName);
1364                 } else {
1365                     System.out.println(fetchHead.hex());
1366                 }
1367             } else if (action.equals(&quot;checkout&quot;)) {
1368                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1369                 if (branchName != null) {
1370                     var branch = repo.branch(fetchHead, branchName);
1371                     repo.checkout(branch, false);
1372                 } else {
1373                     repo.checkout(fetchHead, false);
1374                 }
1375             } else if (action.equals(&quot;show&quot;)) {
1376                 show(pr.targetRef(), fetchHead);
1377             } else if (action.equals(&quot;apply&quot;)) {
1378                 var patch = diff(pr.targetRef(), fetchHead);
1379                 apply(patch);
1380                 Files.deleteIfExists(patch);
1381             }
1382         } else if (action.equals(&quot;close&quot;)) {
1383             var prId = arguments.at(1);
1384             if (!prId.isPresent()) {
1385                 exit(&quot;error: missing pull request identifier&quot;);
1386             }
1387 
1388             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1389             var pr = remoteRepo.pullRequest(prId.asString());
1390             pr.setState(PullRequest.State.CLOSED);
1391         } else if (action.equals(&quot;set&quot;)) {
1392             var prId = arguments.at(1);
1393             if (!prId.isPresent()) {
1394                 exit(&quot;error: missing pull request identifier&quot;);
1395             }
1396 
1397             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1398             var pr = remoteRepo.pullRequest(prId.asString());
<a name="3" id="anc3"></a><span class="line-added">1399 </span>
<span class="line-added">1400             var setDraft = getSwitch(&quot;draft&quot;, &quot;set&quot;, arguments);</span>
<span class="line-added">1401             if (!pr.isDraft() &amp;&amp; setDraft) {</span>
<span class="line-added">1402                 exit(&quot;error: cannot transition non-draft pull request to draft&quot;);</span>
<span class="line-added">1403             }</span>
<span class="line-added">1404 </span>
1405             var assigneesOption = getOption(&quot;assignees&quot;, &quot;set&quot;, arguments);
1406             if (assigneesOption != null) {
1407                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1408                 var assignees = usernames.stream()
1409                     .map(u -&gt; host.user(u))
1410                     .filter(Optional::isPresent)
1411                     .map(Optional::get)
1412                     .collect(Collectors.toList());
1413                 pr.setAssignees(assignees);
1414             }
<a name="4" id="anc4"></a><span class="line-added">1415 </span>
<span class="line-added">1416             var setNoDraft = getSwitch(&quot;no-draft&quot;, &quot;set&quot;, arguments);</span>
<span class="line-added">1417             if (setNoDraft) {</span>
<span class="line-added">1418                 pr.makeNotDraft();</span>
<span class="line-added">1419             }</span>
1420         } else if (action.equals(&quot;status&quot;)) {
1421             String id = pullRequestIdArgument(arguments, repo);
1422             var pr = getPullRequest(uri, repo, host, id);
1423             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;status&quot;, arguments);
1424             var decoration = noDecoration ? &quot;&quot; : &quot;Status: &quot;;
1425             System.out.println(decoration + statusForPullRequest(pr));
1426 
1427             var noChecks = getSwitch(&quot;no-checks&quot;, &quot;status&quot;, arguments);
1428             if (!noChecks) {
1429                 var checks = pr.checks(pr.headHash());
1430                 var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
1431                 var submit = Optional.ofNullable(checks.get(&quot;submit&quot;));
1432                 var showChecks = jcheck.isPresent() || submit.isPresent();
1433                 if (showChecks) {
1434                     System.out.println(&quot;Checks:&quot;);
1435                     if (jcheck.isPresent()) {
1436                         System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1437                     }
1438                     if (submit.isPresent()) {
1439                         System.out.println(&quot;- submit: &quot; + statusForCheck(submit.get()));
1440                     }
1441                 }
1442             }
1443         } else {
1444             exit(&quot;error: unexpected action: &quot; + action);
1445         }
1446     }
1447 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>