<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.hg;
  24 
  25 import org.openjdk.skara.process.Process;
  26 import org.openjdk.skara.process.Execution;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.nio.file.*;
  32 import java.time.*;
  33 import java.time.format.DateTimeFormatter;
  34 import java.util.*;
  35 import java.util.logging.Logger;
  36 import java.util.stream.*;
  37 import java.net.URI;
  38 
  39 public class HgRepository implements Repository {
  40     private static final String EXT_PY = &quot;ext.py&quot;;
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.hg&quot;);
  43 
  44     private void copyResource(String name, Path p) throws IOException {
  45         Files.copy(this.getClass().getResourceAsStream(&quot;/&quot; + name), p, StandardCopyOption.REPLACE_EXISTING);
  46     }
  47 
  48     private java.lang.Process start(String... cmd) throws IOException {
  49         return start(Arrays.asList(cmd));
  50     }
  51 
  52     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  53         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  54         var pb = new ProcessBuilder(cmd);
  55         pb.directory(dir.toFile());
  56         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  57         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
  58         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
  59         return pb.start();
  60     }
  61 
  62     private static void stop(java.lang.Process p) throws IOException {
  63         if (p != null &amp;&amp; p.isAlive()) {
  64             var stream = p.getInputStream();
  65             var read = 0;
  66             var buf = new byte[128];
  67             while (read != -1) {
  68                 read = stream.read(buf);
  69             }
  70             try {
  71                 p.waitFor();
  72             } catch (InterruptedException e) {
  73                 throw new IOException(e);
  74             }
  75         }
  76     }
  77 
  78     private Execution capture(List&lt;String&gt; cmd) {
  79         return capture(cmd.toArray(new String[0]));
  80     }
  81 
  82     private Execution capture(String... cmd) {
  83         return capture(dir, cmd);
  84     }
  85 
  86     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  87         return capture(cwd, cmd.toArray(new String[0]));
  88     }
  89     private static Execution capture(Path cwd, String... cmd) {
  90         return Process.capture(cmd)
  91                       .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
  92                       .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
  93                       .workdir(cwd)
  94                       .execute();
  95     }
  96 
  97     private static Execution.Result await(Execution e) throws IOException {
  98         var result = e.await();
  99         if (result.status() != 0) {
 100             if (result.exception().isPresent()) {
 101                 throw new IOException(&quot;Unexpected exit code\n&quot; + result, result.exception().get());
 102             } else {
 103                 throw new IOException(&quot;Unexpected exit code\n&quot; + result);
 104             }
 105         }
 106         return result;
 107     }
 108 
 109     private static void await(java.lang.Process p) throws IOException {
 110         try {
 111             var res = p.waitFor();
 112             if (res != 0) {
 113                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 114             }
 115         } catch (InterruptedException e) {
 116             throw new IOException(e);
 117         }
 118     }
 119 
 120     public HgRepository(Path dir) {
 121         this.dir = dir.toAbsolutePath();
 122     }
 123 
 124     @Override
 125     public List&lt;Branch&gt; branches() throws IOException {
 126         try (var p = capture(&quot;hg&quot;, &quot;branches&quot;)) {
 127             return await(p).stdout()
 128                            .stream()
 129                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 130                            .map(Branch::new)
 131                            .collect(Collectors.toList());
 132         }
 133     }
 134 
 135     @Override
 136     public List&lt;Tag&gt; tags() throws IOException {
 137         try (var p = capture(&quot;hg&quot;, &quot;tags&quot;)) {
 138             return await(p).stdout()
 139                            .stream()
 140                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 141                            .map(Tag::new)
 142                            .collect(Collectors.toList());
 143         }
 144     }
 145 
 146     @Override
 147     public Path root() throws IOException {
 148         try (var p = capture(&quot;hg&quot;, &quot;root&quot;)) {
 149             var res = await(p);
 150             if (res.stdout().size() != 1) {
 151                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 152             }
 153             return Paths.get(res.stdout().get(0));
 154         }
 155     }
 156 
 157     private void checkout(String ref, boolean force) throws IOException {
 158         var cmd = new ArrayList&lt;String&gt;();
 159         cmd.addAll(List.of(&quot;hg&quot;, &quot;update&quot;));
 160         if (!force) {
 161             cmd.add(&quot;--check&quot;);
 162         }
 163         cmd.add(ref);
 164         try (var p = capture(cmd)) {
 165             await(p);
 166         }
 167     }
 168 
 169     @Override
 170     public void checkout(Hash h, boolean force) throws IOException {
 171         checkout(h.hex(), force);
 172     }
 173 
 174     @Override
 175     public void checkout(Branch b, boolean force) throws IOException {
 176         checkout(b.name(), force);
 177     }
 178 
 179     @Override
 180     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 181         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + ref, &quot;--template={node}\n&quot;)) {
 182             var res = p.await();
 183             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 184                 return Optional.of(new Hash(res.stdout().get(0)));
 185             }
 186             return Optional.empty();
 187         }
 188     }
 189 
 190     @Override
 191     public Commits commits() throws IOException {
 192         return commits(null, -1, false);
 193     }
 194 
 195     @Override
 196     public Commits commits(boolean reverse) throws IOException {
 197         return commits(null, -1, reverse);
 198     }
 199 
 200     @Override
 201     public Commits commits(int n) throws IOException {
 202         return commits(null, n, false);
 203     }
 204 
 205     @Override
 206     public Commits commits(int n, boolean reverse) throws IOException {
 207         return commits(null, n, reverse);
 208     }
 209 
 210     @Override
 211     public Commits commits(String range) throws IOException {
 212         return commits(range, -1, false);
 213     }
 214 
 215     @Override
 216     public Commits commits(String range, int n) throws IOException {
 217         return commits(range, n, false);
 218     }
 219 
 220     @Override
 221     public Commits commits(String range, boolean reverse) throws IOException {
 222         return commits(range, -1, reverse);
 223     }
 224 
 225     @Override
 226     public Commits commits(String range, int n,  boolean reverse) throws IOException {
 227         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 228         copyResource(EXT_PY, ext);
 229         return new HgCommits(dir, range, ext, reverse, n);
 230     }
 231 
 232     @Override
 233     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 234         var commits = commits(h.hex()).asList();
 235         if (commits.size() != 1) {
 236             return Optional.empty();
 237         }
 238         return Optional.of(commits.get(0));
 239     }
 240 
 241     @Override
 242     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 243         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 244         return lookup(hash);
 245     }
 246 
 247     @Override
 248     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 249         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 250         return lookup(hash);
 251     }
 252 
 253     @Override
 254     public List&lt;CommitMetadata&gt; commitMetadata(String range) throws IOException {
 255         throw new RuntimeException(&quot;not implemented yet&quot;);
 256     }
 257 
 258     @Override
 259     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 260         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 261         copyResource(EXT_PY, ext);
 262 
 263         var p = start(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.dump=&quot; + ext.toAbsolutePath().toString(), &quot;metadata&quot;);
 264         var reader = new UnixStreamReader(p.getInputStream());
 265         var result = new ArrayList&lt;CommitMetadata&gt;();
 266 
 267         var line = reader.readLine();
 268         while (line != null) {
 269             result.add(HgCommitMetadata.read(reader));
 270             line = reader.readLine();
 271         }
 272 
 273         await(p);
 274         return result;
 275     }
 276 
 277     @Override
 278     public boolean isEmpty() throws IOException {
 279         var numBranches = branches().size();
 280         var numTags = tags().size();
 281 
 282         if (numBranches &gt; 0 || numTags &gt; 1) {
 283             return false;
 284         }
 285 
 286         var tip = resolve(&quot;tip&quot;);
 287         return tip.isEmpty() || tip.get().hex().equals(&quot;0&quot;.repeat(40));
 288     }
 289 
 290     @Override
 291     public boolean isHealthy() throws IOException {
 292         var root = root().toString();
 293         return !(Files.exists(Path.of(root, &quot;.hg&quot;, &quot;wlock&quot;)) ||
 294                  Files.exists(Path.of(root, &quot;.hg&quot;, &quot;store&quot;, &quot;lock&quot;)));
 295     }
 296 
 297     @Override
 298     public void clean() throws IOException {
 299         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 300             p.await();
 301         }
 302 
 303         try (var p = capture(&quot;hg&quot;, &quot;recover&quot;)) {
 304             p.await();
 305         }
 306 
 307         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--ignored&quot;, &quot;--no-status&quot;)) {
 308             var root = root().toString();
 309             for (var filename : await(p).stdout()) {
 310                 Files.delete(Path.of(root, filename));
 311             }
 312         }
 313 
 314         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 315             var root = root().toString();
 316             for (var filename : await(p).stdout()) {
 317                 Files.delete(Path.of(root, filename));
 318             }
 319         }
 320 
 321         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;)) {
 322             await(p);
 323         }
 324     }
 325 
 326     @Override
 327     public void reset(Hash target, boolean hard) throws IOException {
 328         throw new RuntimeException(&quot;Not implemented yet&quot;);
 329     }
 330 
 331     @Override
 332     public Repository reinitialize() throws IOException {
 333         Files.walk(dir)
 334              .map(Path::toFile)
 335              .sorted(Comparator.reverseOrder())
 336              .forEach(File::delete);
 337 
 338         return init();
 339     }
 340 
 341     @Override
 342     public Hash fetch(URI uri, String refspec) throws IOException {
 343         return fetch(uri != null ? uri.toString() : null, refspec);
 344     }
 345 
 346     private Hash fetch(String from, String refspec) throws IOException {
 347         var oldHeads = new HashSet&lt;Hash&gt;(heads());
 348 
 349         var cmd = new ArrayList&lt;String&gt;();
 350         cmd.add(&quot;hg&quot;);
 351         cmd.add(&quot;pull&quot;);
 352         if (refspec != null) {
 353             cmd.add(&quot;--rev&quot;);
 354             cmd.add(refspec);
 355         }
 356         if (from != null) {
 357             cmd.add(from);
 358         }
 359         try (var p = capture(cmd)) {
 360             await(p);
 361         }
 362 
 363         var newHeads = new HashSet&lt;Hash&gt;(heads());
 364         newHeads.removeAll(oldHeads);
 365 
 366         if (newHeads.size() &gt; 1) {
 367             throw new IllegalStateException(&quot;fetching multiple heads is not supported&quot;);
 368         } else if (newHeads.size() == 0) {
 369             // no new head was fetched, return current head
 370             return head();
 371         }
 372         return newHeads.iterator().next();
 373     }
 374 
 375     @Override
 376     public void fetchAll() throws IOException {
 377         var pullPaths = new ArrayList&lt;URI&gt;();
 378         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
 379             var res = await(p);
 380             for (var line : res.stdout()) {
 381                 var parts = line.split(&quot;=&quot;);
 382                 var name = parts[0].trim();
 383                 var uri = parts[1].trim();
 384                 if (!name.endsWith(&quot;-push&quot;)) {
 385                     pullPaths.add(URI.create(uri));
 386                 }
 387             }
 388         }
 389 
 390         for (var uri : pullPaths) {
 391             fetch(uri, null);
 392         }
 393     }
 394 
 395     @Override
 396     public void fetchRemote(String remote) throws IOException {
 397         fetch(remote, null);
 398     }
 399 
 400     @Override
 401     public void delete(Branch b) throws IOException {
 402         throw new RuntimeException(&quot;Branches cannot be deleted in Mercurial&quot;);
 403     }
 404 
 405     @Override
 406     public Repository init() throws IOException {
 407         if (!Files.exists(dir)) {
 408             Files.createDirectories(dir);
 409         }
 410 
 411         try (var p = capture(&quot;hg&quot;, &quot;init&quot;)) {
 412             await(p);
 413             return this;
 414         }
 415     }
 416 
 417     @Override
 418     public void pushAll(URI uri) throws IOException {
 419         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--new-branch&quot;, uri.toString())) {
 420             await(p);
 421         }
 422     }
 423 
 424     @Override
 425     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 426         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;push&quot;, &quot;--rev=&quot; + hash.hex()));
 427         if (force) {
 428             cmd.add(&quot;--force&quot;);
 429         }
 430         cmd.add(uri.toString() + &quot;#&quot; + ref);
 431         try (var p = capture(cmd)) {
 432             await(p);
 433         }
 434     }
 435 
 436     @Override
 437     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 438         // ignore setUpstream, no such concept in Mercurial
 439         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--branch&quot;, branch.name(), remote)) {
 440             await(p);
 441         }
 442     }
 443 
 444     @Override
 445     public boolean isClean() throws IOException {
 446         try (var p = capture(&quot;hg&quot;, &quot;status&quot;)) {
 447             var output = await(p);
 448             return output.stdout().size() == 0;
 449         }
 450     }
 451 
 452     @Override
 453     public boolean exists() throws IOException {
 454         if (!Files.exists(dir)) {
 455             return false;
 456         }
 457 
 458         try {
 459             root();
 460             return true;
 461         } catch (IOException e) {
 462             return false;
 463         }
 464     }
 465 
 466     private void export(String revset, Path to) throws IOException {
 467         var cmd = List.of(&quot;hg&quot;, &quot;export&quot;, &quot;--git&quot;, &quot;--rev&quot;, revset);
 468         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
 469         var pb = new ProcessBuilder(cmd);
 470         pb.directory(dir.toFile());
 471         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
 472         pb.redirectOutput(to.toFile());
 473         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
 474         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
 475         var p = pb.start();
 476         try {
 477             await(p);
 478         } catch (Throwable t) {
 479             if (p.isAlive()) {
 480                 try {
 481                     p.waitFor();
 482                 } catch (InterruptedException e) {
 483                     throw new IOException(e);
 484                 }
 485             }
 486 
 487             throw new IOException(t);
 488         }
 489     }
 490 
 491     @Override
 492     public void squash(Hash h) throws IOException {
 493         var revset = &quot;.:&quot; + h.hex() + &quot; and not .&quot;;
 494         var patch = Files.createTempFile(&quot;squash&quot;, &quot;.patch&quot;);
 495         export(revset, patch);
 496 
 497         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.mq=&quot;, &quot;strip&quot;, &quot;--rev&quot;, revset)) {
 498             await(p);
 499         }
 500 
 501         try (var p = capture(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toString())) {
 502             await(p);
 503         }
 504     }
 505 
 506 
 507     @Override
 508     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 509         return commit(message, authorName, authorEmail, null);
 510     }
 511 
 512     @Override
 513     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 514         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 515         var cmd = new ArrayList&lt;String&gt;();
 516         cmd.addAll(List.of(&quot;hg&quot;, &quot;commit&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user));
 517         if (authorDate != null) {
 518             var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
 519             cmd.add(&quot;--date=&quot; + authorDate.format(formatter));
 520         }
 521         try (var p = capture(cmd)) {
 522             await(p);
 523         }
 524         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 525     }
 526 
 527     @Override
 528     public Hash commit(String message,
 529                        String authorName,
 530                        String authorEmail,
 531                        String committerName,
 532                        String committerEmail) throws IOException {
 533         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 534     }
 535 
 536     @Override
 537     public Hash commit(String message,
 538                        String authorName,
 539                        String authorEmail,
 540                        ZonedDateTime authorDate,
 541                        String committerName,
 542                        String committerEmail,
 543                        ZonedDateTime committerDate) throws IOException {
 544         if (!Objects.equals(authorName, committerName) ||
 545             !Objects.equals(authorEmail, committerEmail) ||
 546             !Objects.equals(authorDate, committerDate)) {
 547             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 548         }
 549 
 550         return commit(message, authorName, authorEmail, authorDate);
 551     }
 552 
 553     @Override
 554     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 555         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 556         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user)) {
 557             await(p);
 558         }
 559         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 560     }
 561 
 562     @Override
 563     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 564         if (!Objects.equals(authorName, committerName) ||
 565             !Objects.equals(authorEmail, committerEmail)) {
 566             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 567         }
 568 
 569         return amend(message, authorName, authorEmail);
 570     }
 571 
 572     @Override
 573     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 574         var user = authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 575         try (var p = capture(&quot;hg&quot;, &quot;tag&quot;,
 576                              &quot;--message&quot;, message,
 577                              &quot;--user&quot;, user,
 578                              &quot;--rev&quot;, hash.hex(),
 579                              name)) {
 580             await(p);
 581         }
 582 
 583         return new Tag(name);
 584     }
 585 
 586     @Override
 587     public Branch branch(Hash hash, String name) throws IOException {
 588         // Model a lightweight branch with a bookmark. Not ideal but the
 589         // closest to git branches.
 590         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--rev&quot;, hash.hex(), name)) {
 591             await(p);
 592         }
 593 
 594         return new Branch(name);
 595     }
 596 
 597     @Override
 598     public void prune(Branch branch, String remote) throws IOException {
 599         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--delete&quot;, branch.name())) {
 600             await(p);
 601         }
 602         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--bookmark&quot;, branch.name(), remote)) {
 603             await(p);
 604         }
 605     }
 606 
 607     @Override
 608     public Hash mergeBase(Hash first, Hash second) throws IOException {
 609         var revset = &quot;ancestor(&quot; + first.hex() + &quot;, &quot; + second.hex() + &quot;)&quot;;
 610         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + revset, &quot;--template={node}\n&quot;)) {
 611             var res = await(p);
 612             if (res.stdout().size() != 1) {
 613                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 614             }
 615             return new Hash(res.stdout().get(0));
 616         }
 617     }
 618 
 619     @Override
 620     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 621         throw new RuntimeException(&quot;Not implemented yet&quot;);
 622     }
 623 
 624     @Override
 625     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 626         var current = currentBranch().orElseThrow(() -&gt;
 627                 new IOException(&quot;No current branch to rebase upon&quot;)
 628         );
 629         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.rebase=&quot;,
 630                              &quot;rebase&quot;, &quot;--dest&quot;, hash.hex(), &quot;--base&quot;, current.name())) {
 631             await(p);
 632         }
 633     }
 634 
 635     @Override
 636     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 637         try (var p = capture(&quot;hg&quot;, &quot;branch&quot;)) {
 638             var res = await(p);
 639             if (res.stdout().size() != 1) {
 640                 return Optional.empty();
 641             }
 642             return Optional.of(new Branch(res.stdout().get(0)));
 643         }
 644     }
 645 
 646     @Override
 647     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 648         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, &quot;.&quot;, &quot;--template&quot;, &quot;{activebookmark}\n&quot;)) {
 649             var res = await(p);
 650             if (res.stdout().size() == 1) {
 651                 return Optional.of(new Bookmark(res.stdout().get(0)));
 652             }
 653             return Optional.empty();
 654         }
 655     }
 656 
 657     @Override
 658     public Branch defaultBranch() throws IOException {
 659         return new Branch(&quot;default&quot;);
 660     }
 661 
 662     @Override
 663     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 664         return Optional.of(new Tag(&quot;tip&quot;));
 665     }
 666 
 667     @Override
 668     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 669         var output = Files.createTempFile(&quot;hg-cat-rev-&quot; + hash.abbreviate(), &quot;.bin&quot;);
 670         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output, &quot;--rev=&quot; + hash.hex(), path.toString())) {
 671             var res = p.await();
 672             if (res.status() == 0 &amp;&amp; Files.exists(output)) {
 673                 var bytes = Files.readAllBytes(output);
 674                 Files.delete(output);
 675                 return Optional.of(bytes);
 676             }
 677 
 678             if (Files.exists(output)) {
 679                 Files.delete(output);
 680             }
 681             return Optional.empty();
 682         }
 683     }
 684 
 685     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 686         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 687         copyResource(EXT_PY, ext);
 688 
 689         var include = new HashSet&lt;&gt;(paths);
 690 
 691         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-tree=&quot; + ext, &quot;ls-tree&quot;, hash.hex())) {
 692             var res = await(p);
 693             var entries = new ArrayList&lt;FileEntry&gt;();
 694             for (var line : res.stdout()) {
 695                 var parts = line.split(&quot;\t&quot;);
 696                 var metadata = parts[0].split(&quot; &quot;);
 697                 var path = Path.of(parts[1]);
 698                 if (include.isEmpty() || include.contains(path)) {
 699                     var entry = new FileEntry(hash,
 700                                               FileType.fromOctal(metadata[0]),
 701                                               new Hash(metadata[2]),
 702                                               path);
 703                     entries.add(entry);
 704                 }
 705             }
 706             return entries;
 707         }
 708     }
 709 
 710     @Override
 711     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 712         if (paths.isEmpty()) {
 713             return allFiles(hash, paths);
 714         }
 715 
 716         var entries = new ArrayList&lt;FileEntry&gt;();
 717         var batchSize = 64;
 718         var start = 0;
 719         while (start &lt; paths.size()) {
 720             var end = start + batchSize;
 721             if (end &gt; paths.size()) {
 722                 end = paths.size();
 723             }
 724             entries.addAll(allFiles(hash, paths.subList(start, end)));
 725             start = end;
 726         }
 727         return entries;
 728     }
 729 
 730     @Override
 731     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 732         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 733         copyResource(EXT_PY, ext);
 734 
 735         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath().toString(),
 736                                                &quot;diff-git-raw&quot;, from.hex(), to.hex())) {
 737             var res = await(p);
 738             var entries = new ArrayList&lt;StatusEntry&gt;();
 739             for (var line : res.stdout()) {
 740                 entries.add(StatusEntry.fromRawLine(line));
 741             }
 742             return entries;
 743         }
 744     }
 745 
 746     @Override
 747     public void dump(FileEntry entry, Path to) throws IOException {
 748         var output = to.toAbsolutePath();
 749         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output.toString(),
 750                                           &quot;--rev=&quot; + entry.commit(),
 751                                           entry.path().toString())) {
 752             await(p);
 753         }
 754     }
 755 
 756     @Override
 757     public void revert(Hash parent) throws IOException {
 758         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;, &quot;--rev&quot;, parent.hex())) {
 759             await(p);
 760         }
 761     }
 762 
 763     @Override
 764     public Diff diff(Hash from) throws IOException {
 765         return diff(from, List.of());
 766     }
 767 
 768     @Override
 769     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {
 770         return diff(from, null, files);
 771     }
 772 
 773     @Override
 774     public Diff diff(Hash from, Hash to) throws IOException {
 775         return diff(from, to, List.of());
 776     }
 777 
 778     @Override
 779     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {
 780         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 781         copyResource(EXT_PY, ext);
 782 
 783         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath(),
 784                                                 &quot;diff-git-raw&quot;, &quot;--patch&quot;, from.hex()));
 785         if (to != null) {
 786             cmd.add(to.hex());
 787         }
 788 
 789         if (files != null) {
 790             var filenames = files.stream().map(Path::toString).collect(Collectors.toList());
 791             cmd.add(&quot;--files=&quot; + String.join(&quot;,&quot;, filenames));
 792         }
 793 
 794         var p = start(cmd);
 795         try {
 796             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 797             await(p);
 798             return new Diff(from, to, patches);
 799         } catch (Throwable t) {
 800             throw new IOException(t);
 801         }
 802     }
 803 
 804     @Override
 805     public Optional&lt;String&gt; username() throws IOException {
 806         var lines = config(&quot;ui.username&quot;);
 807         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 808     }
 809 
 810     @Override
 811     public Hash head() throws IOException {
 812         return resolve(&quot;.&quot;).orElseThrow(() -&gt; new IOException(&quot;. not available&quot;));
 813     }
 814 
 815     private List&lt;Hash&gt; heads() throws IOException {
 816         var heads = new ArrayList&lt;Hash&gt;();
 817         try (var p = capture(&quot;hg&quot;, &quot;heads&quot;, &quot;--template={node}\n&quot;)) {
 818             var res = p.await();
 819             if (res.status() == 0) {
 820                 for (var hash : res.stdout()) {
 821                     heads.add(new Hash(hash));
 822                 }
 823             }
 824         }
 825         return heads;
 826     }
 827 
 828     @Override
 829     public List&lt;String&gt; config(String key) throws IOException {
 830         // Do not use HgRepository.capture() here, want to run *with*
 831         // hg configuration.
 832         try (var p = Process.capture(&quot;hg&quot;, &quot;showconfig&quot;, key)
 833                             .workdir(dir)
 834                             .execute()) {
 835             var res = p.await();
 836             if (res.status() == 1) {
 837                 return List.of();
 838             }
 839             return res.stdout();
 840         }
 841     }
 842 
 843     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 844         if (!Files.exists(p)) {
 845             return Optional.empty();
 846         }
 847 
 848         var r = new HgRepository(p);
 849         return r.exists() ? Optional.of(new HgRepository(r.root())) : Optional.empty();
 850     }
 851 
 852     @Override
 853     public Repository copyTo(Path destination) throws IOException {
 854         var from = root().toAbsolutePath().toString();
 855         var to = destination.toAbsolutePath().toString();
 856         try (var p = capture(&quot;hg&quot;, &quot;clone&quot;, from, to)) {
 857             await(p);
 858         }
 859 
 860         return new HgRepository(destination.toAbsolutePath());
 861     }
 862 
 863     @Override
 864     public void merge(Hash h) throws IOException {
 865         merge(h.hex(), null);
 866     }
 867 
 868     @Override
 869     public void merge(Branch b) throws IOException {
 870         merge(b.name(), null);
 871     }
 872 
 873     @Override
 874     public void merge(Hash h, String strategy) throws IOException {
 875         merge(h.hex(), strategy);
 876     }
 877 
 878     private void merge(String ref, String strategy) throws IOException {
 879         var cmd = new ArrayList&lt;String&gt;();
 880         cmd.addAll(List.of(&quot;hg&quot;, &quot;merge&quot;, &quot;--rev=&quot; + ref));
 881         if (strategy != null) {
 882             cmd.add(&quot;--tool=&quot; + strategy);
 883         }
 884         try (var p = capture(cmd)) {
 885             await(p);
 886         }
 887     }
 888 
 889     @Override
 890     public void abortMerge() throws IOException {
 891         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 892             await(p);
 893         }
 894 
 895         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 896             var res = await(p);
 897             for (var path : res.stdout()) {
 898                 if (path.toString().endsWith(&quot;.orig&quot;)) {
 899                     Files.delete(root().resolve(path));
 900                 }
 901             }
 902         }
 903     }
 904 
 905     @Override
 906     public void addRemote(String name, String path) throws IOException {
 907         setPaths(name, path, path);
 908     }
 909 
 910     @Override
 911     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 912         var hgrc = Path.of(root().toString(), &quot;.hg&quot;, &quot;hgrc&quot;);
 913         if (!Files.exists(hgrc)) {
 914             Files.createFile(hgrc);
 915         }
 916 
 917         var lines = Files.readAllLines(hgrc);
 918         var newLines = new ArrayList&lt;String&gt;();
 919 
 920         var isInPathsSection = false;
 921         var hasPathsSection = false;
 922         for (var line : lines) {
 923             var isSectionHeader = line.startsWith(&quot;[&quot;) &amp;&amp; line.endsWith(&quot;]&quot;);
 924             if (isSectionHeader &amp;&amp; !isInPathsSection) {
 925                 isInPathsSection = line.equals(&quot;[paths]&quot;);
 926                 if (isInPathsSection) {
 927                     newLines.add(line);
 928                     newLines.add(remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath));
 929                     newLines.add(remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 930                     hasPathsSection = true;
 931                     continue;
 932                 }
 933             }
 934 
 935             if (isInPathsSection &amp;&amp; line.startsWith(remote)) {
 936                 if (line.startsWith(remote + &quot;-push&quot;)) {
 937                     // skip
 938                 } else if (line.startsWith(remote + &quot;:pushurl&quot;)) {
 939                     // skip
 940                 } else if (line.startsWith(remote + &quot; &quot;) || line.startsWith(remote + &quot;=&quot;)) {
 941                     // skip
 942                 } else {
 943                     newLines.add(line);
 944                 }
 945             } else {
 946                 newLines.add(line);
 947             }
 948         }
 949 
 950         Files.write(hgrc, newLines, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
 951         if (!hasPathsSection) {
 952             var section = List.of(&quot;[paths]&quot;,
 953                                   remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath),
 954                                   remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 955             Files.write(hgrc, section, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
 956         }
 957     }
 958 
 959     @Override
 960     public String pullPath(String remote) throws IOException {
 961         var lines = config(&quot;paths.&quot; + remote);
 962         if (lines.size() != 1) {
 963             throw new IOException(&quot;Pull path not found for remote: &quot; + remote);
 964         }
 965         return lines.get(0);
 966     }
 967 
 968     @Override
 969     public String pushPath(String remote) throws IOException {
 970         var lines = config(&quot;paths.&quot; + remote + &quot;-push&quot;);
 971         if (lines.size() != 1) {
 972             lines = config(&quot;paths.&quot; + remote + &quot;@push&quot;);
 973         }
 974         if (lines.size() != 1) {
 975             return pullPath(remote);
 976         }
 977         return lines.get(0);
 978     }
 979 
 980     @Override
 981     public boolean isValidRevisionRange(String expression) throws IOException {
 982         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot; &quot;, &quot;--rev&quot;, expression)) {
 983             return p.await().status() == 0;
 984         }
 985     }
 986 
 987     private void setPermissions(Patch.Info target) throws IOException {
 988         if (target.path().isPresent() &amp;&amp; target.type().isPresent()) {
 989             var perms = target.type().get().permissions();
 990             if (perms.isPresent()) {
 991                 Files.setPosixFilePermissions(target.path().get(), perms.get());
 992             }
 993         }
 994     }
 995 
 996     @Override
 997     public void apply(Diff diff, boolean force) throws IOException {
 998         var patchFile = Files.createTempFile(&quot;import&quot;, &quot;.patch&quot;);
 999         diff.toFile(patchFile);
1000         apply(patchFile, force);
1001         Files.delete(patchFile);
1002     }
1003 
1004     @Override
1005     public void apply(Path patchFile, boolean force) throws IOException {
1006         var cmd = new ArrayList&lt;String&gt;();
1007         cmd.addAll(List.of(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;));
1008         if (force) {
1009             cmd.add(&quot;--force&quot;);
1010         }
1011         cmd.add(patchFile.toAbsolutePath().toString());
1012         try (var p = capture(cmd)) {
1013             await(p);
1014         }
1015     }
1016 
1017     @Override
1018     public void copy(Path from, Path to) throws IOException {
1019         try (var p = capture(&quot;hg&quot;, &quot;copy&quot;, from.toString(), to.toString())) {
1020             await(p);
1021         }
1022     }
1023 
1024     @Override
1025     public void move(Path from, Path to) throws IOException {
1026         try (var p = capture(&quot;hg&quot;, &quot;move&quot;, from.toString(), to.toString())) {
1027             await(p);
1028         }
1029     }
1030 
1031     @FunctionalInterface
1032     private static interface Operation {
1033         void execute(List&lt;Path&gt; args) throws IOException;
1034     }
1035 
1036     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
1037         var batchSize = 64;
1038         var start = 0;
1039         while (start &lt; args.size()) {
1040             var end = start + batchSize;
1041             if (end &gt; args.size()) {
1042                 end = args.size();
1043             }
1044             op.execute(args.subList(start, end));
1045             start = end;
1046         }
1047     }
1048 
1049     private void addAll(List&lt;Path&gt; paths) throws IOException {
1050         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;add&quot;));
1051         for (var path : paths) {
1052             cmd.add(path.toString());
1053         }
1054         try (var p = capture(cmd)) {
1055             await(p);
1056         }
1057     }
1058 
1059     private void removeAll(List&lt;Path&gt; paths) throws IOException {
1060         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;rm&quot;));
1061         for (var path : paths) {
1062             cmd.add(path.toString());
1063         }
1064         try (var p = capture(cmd)) {
1065             await(p);
1066         }
1067     }
1068 
1069 
1070     @Override
1071     public void remove(List&lt;Path&gt; paths) throws IOException {
1072         batch(this::removeAll, paths);
1073     }
1074 
1075     @Override
1076     public void add(List&lt;Path&gt; paths) throws IOException {
1077         batch(this::addAll, paths);
1078     }
1079 
1080     @Override
1081     public void addremove() throws IOException {
1082         try (var p = capture(&quot;hg&quot;, &quot;addremove&quot;)) {
1083             await(p);
1084         }
1085     }
1086 
1087     @Override
1088     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1089         // Mercurial doesn&#39;t have the concept of remotes like git,
1090         // a local branch must have the same name (if present) on the remote
1091         return Optional.of(b.name());
1092     }
1093 
1094     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {
1095         var cmd = new ArrayList&lt;String&gt;();
1096         cmd.addAll(List.of(&quot;hg&quot;, &quot;clone&quot;));
1097         if (isBare) {
1098             cmd.add(&quot;--noupdate&quot;);
1099         }
1100         cmd.addAll(List.of(from.toString(), to.toString()));
1101 
1102         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1103             await(p);
1104         }
1105         return new HgRepository(to);
1106     }
1107 
1108     @Override
1109     public void pull() throws IOException {
1110         pull(null, null);
1111     }
1112 
1113     @Override
1114     public void pull(String remote) throws IOException {
1115         pull(remote, null);
1116     }
1117 
1118     @Override
1119     public void pull(String remote, String refspec) throws IOException {
1120         var cmd = new ArrayList&lt;String&gt;();
1121         cmd.addAll(List.of(&quot;hg&quot;, &quot;pull&quot;, &quot;--update&quot;));
1122         if (refspec != null) {
1123             cmd.add(&quot;--branch&quot;);
1124             cmd.add(refspec);
1125         }
1126         if (remote != null) {
1127             cmd.add(remote);
1128         }
1129         try (var p = capture(cmd)) {
1130             await(p);
1131         }
1132     }
1133 
1134     @Override
1135     public boolean contains(Branch b, Hash h) throws IOException {
1136         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot;{branch}&quot;, &quot;-r&quot;, h.hex())) {
1137             var res = await(p);
1138             if (res.stdout().size() != 1) {
1139                 throw new IOException(&quot;Unexpected output: &quot; + String.join(&quot;\n&quot;, res.stdout()));
1140             }
1141             var line = res.stdout().get(0);
1142             return line.equals(b.name());
1143         }
1144     }
1145 
1146     @Override
1147     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1148         var refs = new ArrayList&lt;Reference&gt;();
1149 
1150         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
1151         copyResource(EXT_PY, ext);
1152 
1153         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-remote=&quot; + ext, &quot;ls-remote&quot;, remote)) {
1154             var res = await(p);
1155             for (var line : res.stdout()) {
1156                 var parts = line.split(&quot;\t&quot;);
1157                 refs.add(new Reference(parts[1], new Hash(parts[0])));
1158             }
1159         }
1160         return refs;
1161     }
1162 
1163     @Override
1164     public List&lt;String&gt; remotes() throws IOException {
1165         var remotes = new ArrayList&lt;String&gt;();
1166         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
1167             for (var line : await(p).stdout()) {
1168                 var parts = line.split(&quot; = &quot;);
1169                 var name = parts[0];
1170                 if (name.endsWith(&quot;-push&quot;) || name.endsWith(&quot;:push&quot;)) {
1171                     continue;
1172                 } else {
1173                     remotes.add(name);
1174                 }
1175             }
1176         }
1177         return remotes;
1178     }
1179 
1180     @Override
1181     public void addSubmodule(String pullPath, Path path) throws IOException {
1182         var uri = Files.exists(Path.of(pullPath)) ? Path.of(pullPath).toUri().toString() : pullPath;
1183         HgRepository.clone(URI.create(uri), root().resolve(path).toAbsolutePath(), false);
1184         var hgSub = root().resolve(&quot;.hgsub&quot;);
1185         Files.writeString(hgSub, path.toString() + &quot; = &quot; + pullPath + &quot;\n&quot;,
1186                           StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
1187         add(List.of(hgSub));
1188     }
1189 
1190     @Override
1191     public List&lt;Submodule&gt; submodules() throws IOException {
1192         var hgSub = root().resolve(&quot;.hgsub&quot;);
1193         var hgSubState = root().resolve(&quot;.hgsubstate&quot;);
1194         if (!(Files.exists(hgSub) &amp;&amp; Files.exists(hgSubState))) {
1195             return List.of();
1196         }
1197 
1198         var urls = new HashMap&lt;String, String&gt;();
1199         for (var line : Files.readAllLines(hgSub)) {
1200             var parts = line.split(&quot;=&quot;);
1201             var path = parts[0].trim();
1202             var url = parts[1].trim();
1203             urls.put(path, url);
1204         }
1205 
1206         var hashes = new HashMap&lt;String, String&gt;();
1207         for (var line : Files.readAllLines(hgSubState)) {
1208             var parts = line.split(&quot; &quot;);
1209             var hash = parts[0];
1210             var path = parts[1];
1211             hashes.put(path, hash);
1212         }
1213 
1214         var modules = new ArrayList&lt;Submodule&gt;();
1215         for (var path : urls.keySet()) {
1216             var url = urls.get(path);
1217             var hash = hashes.get(path);
1218             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1219         }
1220 
1221         return modules;
1222     }
1223 
1224     @Override
1225     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1226         var hgtags = root().resolve(&quot;.hgtags&quot;);
1227         if (!Files.exists(hgtags)) {
1228             return Optional.empty();
1229         }
1230         try (var p = capture(&quot;hg&quot;, &quot;annotate&quot;, hgtags.toString())) {
1231             var reversed = new ArrayList&lt;&gt;(await(p).stdout());
1232             Collections.reverse(reversed);
1233             for (var line : reversed) {
1234                 var parts = line.split(&quot; &quot;);
1235                 var tagName = parts[2];
1236                 if (tagName.equals(tag.name())) {
1237                     var target = new Hash(parts[1]);
1238                     var rev = parts[0].substring(0, parts[0].length() - 1).trim(); // skip last &#39;:&#39; and ev. whitespace
1239                     var hash = resolve(rev).orElseThrow(IOException::new);
1240                     var commit = lookup(hash).orElseThrow(IOException::new);
1241                     var message = String.join(&quot;\n&quot;, commit.message()) + &quot;\n&quot;;
1242                     return Optional.of(new Tag.Annotated(tagName, target, commit.author(), commit.date(), message));
1243                 }
1244             }
1245         }
1246         return Optional.empty();
1247     }
1248 
1249     @Override
1250     public void config(String section, String key, String value, boolean global) throws IOException {
1251         var hgrc = global ?
1252             Path.of(System.getProperty(&quot;user.home&quot;), &quot;.hgrc&quot;) :
1253             root().resolve(&quot;.hg&quot;).resolve(&quot;hgrc&quot;);
1254 
1255         var lines = List.of(
1256             &quot;[&quot; + section + &quot;]&quot;,
1257             key + &quot; = &quot; + value
1258         );
1259         if (!Files.exists(hgrc)) {
1260             Files.createFile(hgrc);
1261         }
1262         Files.write(hgrc, lines, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
1263     }
1264 }
    </pre>
  </body>
</html>