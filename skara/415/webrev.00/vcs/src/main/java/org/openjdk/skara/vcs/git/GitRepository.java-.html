<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old vcs/src/main/java/org/openjdk/skara/vcs/git/GitRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.git;
  24 
  25 import org.openjdk.skara.process.*;
  26 import org.openjdk.skara.process.Process;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.net.URI;
  32 import java.nio.file.*;
  33 import java.nio.charset.StandardCharsets;
  34 import java.time.*;
  35 import java.time.format.DateTimeFormatter;
  36 import java.util.*;
  37 import java.util.logging.Logger;
  38 import java.util.stream.Collectors;
  39 
  40 public class GitRepository implements Repository {
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.git&quot;);
  43     private Path cachedRoot = null;
  44 
  45     private java.lang.Process start(String... cmd) throws IOException {
  46         return start(Arrays.asList(cmd));
  47     }
  48 
  49     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  50         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  51         var pb = new ProcessBuilder(cmd);
  52         pb.directory(dir.toFile());
  53         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  54         return pb.start();
  55     }
  56 
  57     private static void stop(java.lang.Process p) throws IOException {
  58         if (p != null &amp;&amp; p.isAlive()) {
  59             var stream = p.getInputStream();
  60             var read = 0;
  61             var buf = new byte[128];
  62             while (read != -1) {
  63                 read = stream.read(buf);
  64             }
  65             try {
  66                 p.waitFor();
  67             } catch (InterruptedException e) {
  68                 throw new IOException(e);
  69             }
  70         }
  71     }
  72 
  73     private Execution capture(List&lt;String&gt; cmd) {
  74         return capture(cmd.toArray(new String[0]));
  75     }
  76 
  77     private Execution capture(String... cmd) {
  78         return capture(dir, cmd);
  79     }
  80 
  81     private static Execution capture(Path cwd, String... cmd) {
  82         return Process.capture(cmd)
  83                       .workdir(cwd)
  84                       .execute();
  85     }
  86 
  87     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  88         return capture(cwd, cmd.toArray(new String[0]));
  89     }
  90 
  91     private static Execution.Result await(Execution e) throws IOException {
  92         var result = e.await();
  93         if (result.status() != 0) {
  94             throw new IOException(&quot;Unexpected exit code\n&quot; + result);
  95         }
  96         return result;
  97     }
  98 
  99     private static void await(java.lang.Process p) throws IOException {
 100         try {
 101             var res = p.waitFor();
 102             if (res != 0) {
 103                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 104             }
 105         } catch (InterruptedException e) {
 106             throw new IOException(e);
 107         }
 108     }
 109 
 110     public GitRepository(Path dir) {
 111         this.dir = dir.toAbsolutePath();
 112     }
 113 
 114     public List&lt;Branch&gt; branches() throws IOException {
 115         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/heads&quot;)) {
 116             return await(p).stdout()
 117                            .stream()
 118                            .map(Branch::new)
 119                            .collect(Collectors.toList());
 120         }
 121     }
 122 
 123     public List&lt;Tag&gt; tags() throws IOException {
 124         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(refname:short)&quot;, &quot;refs/tags&quot;)) {
 125             return await(p).stdout()
 126                            .stream()
 127                            .map(Tag::new)
 128                            .collect(Collectors.toList());
 129         }
 130     }
 131 
 132     @Override
 133     public Commits commits() throws IOException {
 134         return new GitCommits(dir, &quot;--all&quot;, false, -1);
 135     }
 136 
 137     @Override
 138     public Commits commits(int n) throws IOException {
 139         return new GitCommits(dir, &quot;--all&quot;, false, n);
 140     }
 141 
 142     @Override
 143     public Commits commits(boolean reverse) throws IOException {
 144         return new GitCommits(dir, &quot;--all&quot;, reverse, -1);
 145     }
 146 
 147     @Override
 148     public Commits commits(int n, boolean reverse) throws IOException {
 149         return new GitCommits(dir, &quot;--all&quot;, reverse, n);
 150     }
 151 
 152     @Override
 153     public Commits commits(String range) throws IOException {
 154         return new GitCommits(dir, range, false, -1);
 155     }
 156 
 157     @Override
 158     public Commits commits(String range, int n) throws IOException {
 159         return new GitCommits(dir, range, false, n);
 160     }
 161 
 162     @Override
 163     public Commits commits(String range, boolean reverse) throws IOException {
 164         return new GitCommits(dir, range, reverse, -1);
 165     }
 166 
 167     @Override
 168     public Commits commits(String range, int n, boolean reverse) throws IOException {
 169         return new GitCommits(dir, range, reverse, n);
 170     }
 171 
 172     @Override
 173     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 174         var commits = commits(h.hex(), 1).asList();
 175         if (commits.size() != 1) {
 176             return Optional.empty();
 177         }
 178         return Optional.of(commits.get(0));
 179     }
 180 
 181     @Override
 182     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 183         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 184         return lookup(hash);
 185     }
 186 
 187     @Override
 188     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 189         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 190         return lookup(hash);
 191     }
 192 
 193     @Override
 194     public List&lt;CommitMetadata&gt; commitMetadata(String range) throws IOException {
 195         var p = start(&quot;git&quot;, &quot;rev-list&quot;, &quot;--format=&quot; + GitCommitMetadata.FORMAT, &quot;--no-abbrev&quot;, &quot;--reverse&quot;, &quot;--no-color&quot;, range);
 196         var reader = new UnixStreamReader(p.getInputStream());
 197         var result = new ArrayList&lt;CommitMetadata&gt;();
 198 
 199         var line = reader.readLine();
 200         while (line != null) {
 201             if (!line.startsWith(&quot;commit&quot;)) {
 202                 throw new IOException(&quot;Unexpected line: &quot; + line);
 203             }
 204 
 205             result.add(GitCommitMetadata.read(reader));
 206             line = reader.readLine();
 207         }
 208 
 209         await(p);
 210         return result;
 211     }
 212 
 213     @Override
 214     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 215         return commitMetadata(&quot;--all&quot;);
 216     }
 217 
 218     private List&lt;Hash&gt; refs() throws IOException {
 219         try (var p = capture(&quot;git&quot;, &quot;show-ref&quot;, &quot;--hash&quot;, &quot;--abbrev&quot;)) {
 220             var res = p.await();
 221             if (res.status() == -1) {
 222                 if (res.stdout().size() != 0) {
 223                     throw new IOException(&quot;Unexpected output\n&quot; + res);
 224                 }
 225                 return new ArrayList&lt;&gt;();
 226             } else {
 227                 return res.stdout().stream()
 228                           .map(Hash::new)
 229                           .collect(Collectors.toList());
 230             }
 231         }
 232     }
 233 
 234     @Override
 235     public boolean isEmpty() throws IOException {
 236         int numLooseObjects = -1;
 237         int numPackedObjects = -1;
 238 
 239         try (var p = capture(&quot;git&quot;, &quot;count-objects&quot;, &quot;-v&quot;)) {
 240             var res = await(p);
 241             var stdout = res.stdout();
 242 
 243             for (var line : stdout) {
 244                 if (line.startsWith(&quot;count: &quot;)) {
 245                     try {
 246                         numLooseObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 247                     } catch (NumberFormatException e) {
 248                         throw new IOException(&quot;Unexpected &#39;count&#39; value\n&quot; + res, e);
 249                     }
 250 
 251                 } else if (line.startsWith(&quot;in-pack: &quot;)) {
 252                     try {
 253                         numPackedObjects = Integer.parseUnsignedInt(line.split(&quot; &quot;)[1]);
 254                     } catch (NumberFormatException e) {
 255                         throw new IOException(&quot;Unexpected &#39;in-pack&#39; value\n&quot; + res, e);
 256                     }
 257                 }
 258             }
 259         }
 260 
 261         return numLooseObjects == 0 &amp;&amp; numPackedObjects == 0 &amp;&amp; refs().size() == 0;
 262     }
 263 
 264     @Override
 265 
 266     public boolean isHealthy() throws IOException {
 267         try (var p = capture(&quot;git&quot;, &quot;fsck&quot;, &quot;--connectivity-only&quot;)) {
 268             if (p.await().status() != 0) {
 269                 return false;
 270             }
 271         }
 272         return true;
 273     }
 274 
 275     @Override
 276     public void clean() throws IOException {
 277         cachedRoot = null;
 278 
 279         try (var p = capture(&quot;git&quot;, &quot;clean&quot;, &quot;-x&quot;, &quot;-d&quot;, &quot;--force&quot;, &quot;--force&quot;)) {
 280             await(p);
 281         }
 282 
 283         try (var p = capture(&quot;git&quot;, &quot;reset&quot;, &quot;--hard&quot;)) {
 284             await(p);
 285         }
 286 
 287         try (var p = capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--quit&quot;)) {
 288             p.await(); // Don&#39;t care about the result.
 289         }
 290     }
 291 
 292     @Override
 293     public void reset(Hash target, boolean hard) throws IOException {
 294         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;reset&quot;));
 295         if (hard) {
 296            cmd.add(&quot;--hard&quot;);
 297         }
 298         cmd.add(target.hex());
 299 
 300         try (var p = capture(cmd)) {
 301             await(p);
 302         }
 303     }
 304 
 305 
 306     @Override
 307     public void revert(Hash h) throws IOException {
 308         try (var p = capture(&quot;git&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;, h.hex(), &quot;--&quot;, &quot;.&quot;)) {
 309             await(p);
 310         }
 311     }
 312 
 313     @Override
 314     public Repository reinitialize() throws IOException {
 315         cachedRoot = null;
 316 
 317         Files.walk(dir)
 318              .map(Path::toFile)
 319              .sorted(Comparator.reverseOrder())
 320              .forEach(File::delete);
 321 
 322         return init();
 323     }
 324 
 325     @Override
 326     public Hash fetch(URI uri, String refspec) throws IOException {
 327         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--tags&quot;, uri.toString(), refspec)) {
 328             await(p);
 329             return resolve(&quot;FETCH_HEAD&quot;).get();
 330         }
 331     }
 332 
 333     @Override
 334     public void fetchAll() throws IOException {
 335         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--tags&quot;, &quot;--prune&quot;, &quot;--prune-tags&quot;, &quot;--all&quot;)) {
 336             await(p);
 337         }
 338     }
 339 
 340     @Override
 341     public void fetchRemote(String remote) throws IOException {
 342         try (var p = capture(&quot;git&quot;, &quot;fetch&quot;, &quot;--recurse-submodules=on-demand&quot;, &quot;--tags&quot;, &quot;--prune&quot;, &quot;--prune-tags&quot;, remote)) {
 343             await(p);
 344         }
 345     }
 346 
 347     private void checkout(String ref, boolean force) throws IOException {
 348         var cmd = new ArrayList&lt;String&gt;();
 349         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;advice.detachedHead=false&quot;, &quot;checkout&quot;, &quot;--recurse-submodules&quot;));
 350         if (force) {
 351             cmd.add(&quot;--force&quot;);
 352         }
 353         cmd.add(ref);
 354         try (var p = capture(cmd)) {
 355             await(p);
 356         }
 357     }
 358 
 359     @Override
 360     public void checkout(Hash h, boolean force) throws IOException {
 361         checkout(h.hex(), force);
 362     }
 363 
 364     @Override
 365     public void checkout(Branch b, boolean force) throws IOException {
 366         checkout(b.name(), force);
 367     }
 368 
 369     @Override
 370     public Repository init() throws IOException {
 371         cachedRoot = null;
 372 
 373         if (!Files.exists(dir)) {
 374             Files.createDirectories(dir);
 375         }
 376 
 377         try (var p = capture(&quot;git&quot;, &quot;init&quot;)) {
 378             await(p);
 379             return this;
 380         }
 381     }
 382 
 383     @Override
 384     public void pushAll(URI uri) throws IOException {
 385         try (var p = capture(&quot;git&quot;, &quot;push&quot;, &quot;--mirror&quot;, uri.toString())) {
 386             await(p);
 387         }
 388     }
 389 
 390     @Override
 391     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 392         String refspec = force ? &quot;+&quot; : &quot;&quot;;
 393         if (!ref.startsWith(&quot;refs/&quot;)) {
 394             ref = &quot;refs/heads/&quot; + ref;
 395         }
 396         refspec += hash.hex() + &quot;:&quot; + ref;
 397 
 398         try (var p = capture(&quot;git&quot;, &quot;push&quot;, uri.toString(), refspec)) {
 399             await(p);
 400         }
 401     }
 402 
 403     @Override
 404     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 405         var cmd = new ArrayList&lt;String&gt;();
 406         cmd.addAll(List.of(&quot;git&quot;, &quot;push&quot;, remote, branch.name()));
 407         if (setUpstream) {
 408             cmd.add(&quot;--set-upstream&quot;);
 409         }
 410 
 411         try (var p = capture(cmd)) {
 412             await(p);
 413         }
 414     }
 415 
 416     @Override
 417     public boolean isClean() throws IOException {
 418         try (var p = capture(&quot;git&quot;, &quot;status&quot;, &quot;--porcelain&quot;)) {
 419             var output = await(p);
 420             return output.stdout().size() == 0;
 421         }
 422     }
 423 
 424     @Override
 425     public boolean exists() throws IOException {
 426         if (!Files.exists(dir)) {
 427             return false;
 428         }
 429 
 430         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 431             return p.await().status() == 0;
 432         }
 433     }
 434 
 435     @Override
 436     public Path root() throws IOException {
 437         if (cachedRoot != null) {
 438             return cachedRoot;
 439         }
 440 
 441         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--show-toplevel&quot;)) {
 442             var res = p.await();
 443             if (res.status() != 0 || res.stdout().size() != 1) {
 444                 // Perhaps this is a bare repository
 445                 try (var p2 = capture(&quot;git&quot;, &quot;rev-parse&quot;, &quot;--git-dir&quot;)) {
 446                     var res2 = await(p2);
 447                     if (res2.stdout().size() != 1) {
 448                         throw new IOException(&quot;Unexpected output\n&quot; + res2);
 449                     }
 450                     cachedRoot = dir.resolve(Path.of(res2.stdout().get(0)));
 451                     return cachedRoot;
 452                 }
 453             }
 454 
 455             cachedRoot = Path.of(res.stdout().get(0));
 456             return cachedRoot;
 457         }
 458     }
 459 
 460     @Override
 461     public void squash(Hash h) throws IOException {
 462         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--squash&quot;, h.hex())) {
 463             await(p);
 464         }
 465     }
 466 
 467     @FunctionalInterface
 468     private static interface Operation {
 469         void execute(List&lt;Path&gt; args) throws IOException;
 470     }
 471 
 472     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
 473         var batchSize = 64;
 474         var start = 0;
 475         while (start &lt; args.size()) {
 476             var end = start + batchSize;
 477             if (end &gt; args.size()) {
 478                 end = args.size();
 479             }
 480             op.execute(args.subList(start, end));
 481             start = end;
 482         }
 483     }
 484 
 485     private void addAll(List&lt;Path&gt; paths) throws IOException {
 486         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;add&quot;));
 487         for (var path : paths) {
 488             cmd.add(path.toString());
 489         }
 490         try (var p = capture(cmd)) {
 491             await(p);
 492         }
 493     }
 494 
 495     @Override
 496     public void add(List&lt;Path&gt; paths) throws IOException {
 497         batch(this::addAll, paths);
 498     }
 499 
 500     private void removeAll(List&lt;Path&gt; paths) throws IOException {
 501         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;rm&quot;));
 502         for (var path : paths) {
 503             cmd.add(path.toString());
 504         }
 505         try (var p = capture(cmd)) {
 506             await(p);
 507         }
 508     }
 509 
 510     @Override
 511     public void remove(List&lt;Path&gt; paths) throws IOException {
 512         batch(this::removeAll, paths);
 513     }
 514 
 515     @Override
 516     public void delete(Branch b) throws IOException {
 517         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;-D&quot;, b.name())) {
 518             await(p);
 519         }
 520     }
 521 
 522     @Override
 523     public void addremove() throws IOException {
 524         try (var p = capture(&quot;git&quot;, &quot;add&quot;, &quot;--all&quot;)) {
 525             await(p);
 526         }
 527     }
 528 
 529     @Override
 530     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 531         return commit(message, authorName, authorEmail, null);
 532     }
 533 
 534     @Override
 535     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 536         return commit(message, authorName, authorEmail, authorDate, authorName, authorEmail, authorDate);
 537     }
 538 
 539     @Override
 540     public Hash commit(String message,
 541                        String authorName,
 542                        String authorEmail,
 543                        String committerName,
 544                        String committerEmail) throws IOException {
 545         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 546     }
 547 
 548     @Override
 549     public Hash commit(String message,
 550                        String authorName,
 551                        String authorEmail,
 552                        ZonedDateTime authorDate,
 553                        String committerName,
 554                        String committerEmail,
 555                        ZonedDateTime committerDate) throws IOException {
 556         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--message=&quot; + message)
 557                          .workdir(dir)
 558                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 559                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 560                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 561                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 562         if (authorDate != null) {
 563             cmd = cmd.environ(&quot;GIT_AUTHOR_DATE&quot;,
 564                               authorDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 565         }
 566         if (committerDate != null) {
 567             cmd = cmd.environ(&quot;GIT_COMMITTER_DATE&quot;,
 568                               committerDate.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
 569         }
 570         try (var p = cmd.execute()) {
 571             await(p);
 572             return head();
 573         }
 574     }
 575 
 576     @Override
 577     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 578         return amend(message, authorName, authorEmail, null, null);
 579     }
 580 
 581     @Override
 582     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 583         if (committerName == null) {
 584             committerName = authorName;
 585             committerEmail = authorEmail;
 586         }
 587         var cmd = Process.capture(&quot;git&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--reset-author&quot;, &quot;--message=&quot; + message)
 588                          .workdir(dir)
 589                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 590                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 591                          .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 592                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail);
 593         try (var p = cmd.execute()) {
 594             await(p);
 595             return head();
 596         }
 597     }
 598 
 599     @Override
 600     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 601         var cmd = Process.capture(&quot;git&quot;, &quot;tag&quot;, &quot;--annotate&quot;, &quot;--message=&quot; + message, name, hash.hex())
 602                          .workdir(dir)
 603                          .environ(&quot;GIT_AUTHOR_NAME&quot;, authorName)
 604                          .environ(&quot;GIT_AUTHOR_EMAIL&quot;, authorEmail)
 605                          .environ(&quot;GIT_COMMITTER_NAME&quot;, authorName)
 606                          .environ(&quot;GIT_COMMITTER_EMAIL&quot;, authorEmail);
 607         try (var p = cmd.execute()) {
 608             await(p);
 609         }
 610 
 611         return new Tag(name);
 612     }
 613 
 614     @Override
 615     public Branch branch(Hash hash, String name) throws IOException {
 616         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, name, hash.hex())) {
 617             await(p);
 618         }
 619 
 620         return new Branch(name);
 621     }
 622 
 623     @Override
 624     public void prune(Branch branch, String remote) throws IOException {
 625         try (var p = capture(&quot;git&quot;, &quot;push&quot;, &quot;--delete&quot;, remote, branch.name())) {
 626             await(p);
 627         }
 628         try (var p = capture(&quot;git&quot;, &quot;branch&quot;, &quot;--delete&quot;, &quot;--force&quot;, branch.name())) {
 629             await(p);
 630         }
 631     }
 632 
 633     @Override
 634     public Hash mergeBase(Hash first, Hash second) throws IOException {
 635         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, first.hex(), second.hex())) {
 636             var res = await(p);
 637             if (res.stdout().size() != 1) {
 638                  throw new IOException(&quot;Unexpected output\n&quot; + res);
 639             }
 640             return new Hash(res.stdout().get(0));
 641         }
 642     }
 643 
 644     @Override
 645     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 646         try (var p = capture(&quot;git&quot;, &quot;merge-base&quot;, &quot;--is-ancestor&quot;, ancestor.hex(), descendant.hex())) {
 647             var res = p.await();
 648             return res.status() == 0;
 649         }
 650     }
 651 
 652     @Override
 653     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 654         try (var p = Process.capture(&quot;git&quot;, &quot;rebase&quot;, &quot;--onto&quot;, hash.hex(), &quot;--root&quot;, &quot;--rebase-merges&quot;)
 655                             .environ(&quot;GIT_COMMITTER_NAME&quot;, committerName)
 656                             .environ(&quot;GIT_COMMITTER_EMAIL&quot;, committerEmail)
 657                             .workdir(dir)
 658                             .execute()) {
 659             await(p);
 660         }
 661     }
 662 
 663     @Override
 664     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 665         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, ref + &quot;^{commit}&quot;)) {
 666             var res = p.await();
 667             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 668                 return Optional.of(new Hash(res.stdout().get(0)));
 669             }
 670             return Optional.empty();
 671         }
 672     }
 673 
 674     @Override
 675     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 676         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;HEAD&quot;)) {
 677             var res = p.await();
 678             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 679                 return Optional.of(new Branch(res.stdout().get(0)));
 680             }
 681             return Optional.empty();
 682         }
 683     }
 684 
 685     @Override
 686     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 687         throw new RuntimeException(&quot;git does not have bookmarks&quot;);
 688     }
 689 
 690     @Override
 691     public Branch defaultBranch() throws IOException {
 692         try (var p = capture(&quot;git&quot;, &quot;symbolic-ref&quot;, &quot;--short&quot;, &quot;refs/remotes/origin/HEAD&quot;)) {
 693             var res = p.await();
 694             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 695                 var ref = res.stdout().get(0).substring(&quot;origin/&quot;.length());
 696                 return new Branch(ref);
 697             } else {
 698                 return new Branch(&quot;master&quot;);
 699             }
 700         }
 701     }
 702 
 703     @Override
 704     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 705         return Optional.empty();
 706     }
 707 
 708     @Override
 709     public Optional&lt;String&gt; username() throws IOException {
 710         var lines = config(&quot;user.name&quot;);
 711         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 712     }
 713 
 714     private String treeEntry(Path path, Hash hash) throws IOException {
 715         try (var p = Process.capture(&quot;git&quot;, &quot;ls-tree&quot;, hash.hex(), path.toString())
 716                             .workdir(root())
 717                             .execute()) {
 718             var res = await(p);
 719             if (res.stdout().size() == 0) {
 720                 return null;
 721             }
 722             if (res.stdout().size() &gt; 1) {
 723                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 724             }
 725             return res.stdout().get(0);
 726         }
 727     }
 728 
 729     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 730         var cmd = new ArrayList&lt;String&gt;();
 731         cmd.addAll(List.of(&quot;git&quot;, &quot;ls-tree&quot;, &quot;-r&quot;));
 732         cmd.add(hash.hex());
 733         cmd.addAll(paths.stream().map(Path::toString).collect(Collectors.toList()));
 734         try (var p = Process.capture(cmd.toArray(new String[0]))
 735                             .workdir(root())
 736                             .execute()) {
 737             var res = await(p);
 738             var entries = new ArrayList&lt;FileEntry&gt;();
 739             for (var line : res.stdout()) {
 740                 var parts = line.split(&quot;\t&quot;);
 741                 var metadata = parts[0].split(&quot; &quot;);
 742                 var filename = parts[1];
 743 
 744                 var entry = new FileEntry(hash,
 745                                           FileType.fromOctal(metadata[0]),
 746                                           new Hash(metadata[2]),
 747                                           Path.of(filename));
 748                 entries.add(entry);
 749             }
 750             return entries;
 751         }
 752     }
 753 
 754     @Override
 755     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 756         if (paths.isEmpty()) {
 757             return allFiles(hash, paths);
 758         }
 759 
 760         var entries = new ArrayList&lt;FileEntry&gt;();
 761         var batchSize = 64;
 762         var start = 0;
 763         while (start &lt; paths.size()) {
 764             var end = start + batchSize;
 765             if (end &gt; paths.size()) {
 766                 end = paths.size();
 767             }
 768             entries.addAll(allFiles(hash, paths.subList(start, end)));
 769             start = end;
 770         }
 771         return entries;
 772     }
 773 
 774     private Path unpackFile(String blob) throws IOException {
 775         try (var p = capture(&quot;git&quot;, &quot;unpack-file&quot;, blob)) {
 776             var res = await(p);
 777             if (res.stdout().size() != 1) {
 778                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 779             }
 780 
 781             return Path.of(root().toString(), res.stdout().get(0));
 782         }
 783     }
 784 
 785     @Override
 786     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 787         var entries = files(hash, path);
 788         if (entries.size() == 0) {
 789             return Optional.empty();
 790         } else if (entries.size() &gt; 1) {
 791             throw new IOException(&quot;Multiple files match path &quot; + path.toString() + &quot; in commit &quot; + hash.hex());
 792         }
 793 
 794         var entry = entries.get(0);
 795         var type = entry.type();
 796         if (type.isVCSLink()) {
 797             var content = &quot;Subproject commit &quot; + entry.hash().hex() + &quot; &quot; + entry.path().toString();
 798             return Optional.of(content.getBytes(StandardCharsets.UTF_8));
 799         } else if (type.isRegular()) {
 800             var tmp = unpackFile(entry.hash().hex());
 801             var content = Files.readAllBytes(tmp);
 802             Files.delete(tmp);
 803             return Optional.of(content);
 804         }
 805 
 806         return Optional.empty();
 807     }
 808 
 809     @Override
 810     public void dump(FileEntry entry, Path to) throws IOException {
 811         var type = entry.type();
 812         if (type.isRegular()) {
 813             var path = unpackFile(entry.hash().hex());
 814             Files.createDirectories(to.getParent());
 815             Files.move(path, to, StandardCopyOption.REPLACE_EXISTING);
 816         }
 817     }
 818 
 819     @Override
 820     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 821         try (var p = capture(&quot;git&quot;, &quot;diff&quot;, &quot;--raw&quot;, &quot;--find-renames=99%&quot;, &quot;--find-copies=99%&quot;, &quot;--find-copies-harder&quot;, &quot;--no-abbrev&quot;, &quot;--no-color&quot;, from.hex(), to.hex())) {
 822             var res = await(p);
 823             var entries = new ArrayList&lt;StatusEntry&gt;();
 824             for (var line : res.stdout()) {
 825                 entries.add(StatusEntry.fromRawLine(line));
 826             }
 827             return entries;
 828         }
 829     }
 830 
 831     @Override
 832     public Diff diff(Hash from) throws IOException {
 833         return diff(from, List.of());
 834     }
 835 
 836     @Override
 837     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {
 838         return diff(from, null, files);
 839     }
 840 
 841     @Override
 842     public Diff diff(Hash from, Hash to) throws IOException {
 843         return diff(from, to, List.of());
 844     }
 845 
 846     @Override
 847     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {
 848         var cmd = new ArrayList&lt;&gt;(List.of(&quot;git&quot;, &quot;diff&quot;, &quot;--patch&quot;,
 849                                                          &quot;--find-renames=99%&quot;,
 850                                                          &quot;--find-copies=99%&quot;,
 851                                                          &quot;--find-copies-harder&quot;,
 852                                                          &quot;--binary&quot;,
 853                                                          &quot;--raw&quot;,
 854                                                          &quot;--no-abbrev&quot;,
 855                                                          &quot;--unified=0&quot;,
 856                                                          &quot;--no-color&quot;,
 857                                                          from.hex()));
 858         if (to != null) {
 859             cmd.add(to.hex());
 860         }
 861 
 862         if (files != null &amp;&amp; !files.isEmpty()) {
 863             cmd.add(&quot;--&quot;);
 864             for (var file : files) {
 865                 cmd.add(file.toString());
 866             }
 867         }
 868 
 869         var p = start(cmd);
 870         try {
 871             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 872             await(p);
 873             return new Diff(from, to, patches);
 874         } catch (Throwable t) {
 875             stop(p);
 876             throw t;
 877         }
 878     }
 879 
 880     @Override
 881     public List&lt;String&gt; config(String key) throws IOException {
 882         try (var p = capture(&quot;git&quot;, &quot;config&quot;, key)) {
 883             var res = p.await();
 884             return res.status() == 0 ? res.stdout() : List.of();
 885         }
 886     }
 887 
 888     @Override
 889     public Hash head() throws IOException {
 890         return resolve(&quot;HEAD&quot;).orElseThrow(() -&gt; new IllegalStateException(&quot;HEAD ref is not present&quot;));
 891     }
 892 
 893     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 894         if (!Files.exists(p)) {
 895             return Optional.empty();
 896         }
 897 
 898         var r = new GitRepository(p);
 899         return r.exists() ? Optional.of(new GitRepository(r.root())) : Optional.empty();
 900     }
 901 
 902     @Override
 903     public Repository copyTo(Path destination) throws IOException {
 904         try (var p = capture(&quot;git&quot;, &quot;clone&quot;, &quot;--recurse-submodules&quot;, root().toString(), destination.toString())) {
 905             await(p);
 906         }
 907 
 908         return new GitRepository(destination);
 909     }
 910 
 911     @Override
 912     public void merge(Hash h) throws IOException {
 913         merge(h.hex(), null);
 914     }
 915 
 916     @Override
 917     public void merge(Branch b) throws IOException {
 918         merge(b.name(), null);
 919     }
 920 
 921     @Override
 922     public void merge(Hash h, String strategy) throws IOException {
 923         merge(h.hex(), strategy);
 924     }
 925 
 926     private void merge(String ref, String strategy) throws IOException {
 927         var cmd = new ArrayList&lt;String&gt;();
 928         cmd.addAll(List.of(&quot;git&quot;, &quot;-c&quot;, &quot;user.name=unused&quot;, &quot;-c&quot;, &quot;user.email=unused&quot;,
 929                            &quot;merge&quot;, &quot;--no-commit&quot;));
 930         if (strategy != null) {
 931             cmd.add(&quot;-s&quot;);
 932             cmd.add(strategy);
 933         }
 934         cmd.add(ref);
 935         try (var p = capture(cmd)) {
 936             await(p);
 937         }
 938     }
 939 
 940     @Override
 941     public void abortMerge() throws IOException {
 942         try (var p = capture(&quot;git&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 943             await(p);
 944         }
 945     }
 946 
 947     @Override
 948     public void addRemote(String name, String pullPath) throws IOException {
 949         try (var p = capture(&quot;git&quot;, &quot;remote&quot;, &quot;add&quot;, name, pullPath)) {
 950             await(p);
 951         }
 952     }
 953 
 954     @Override
 955     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 956         pullPath = pullPath == null ? &quot;&quot; : pullPath;
 957         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.url&quot;, pullPath)) {
 958             await(p);
 959         }
 960 
 961         pushPath = pushPath == null ? &quot;&quot; : pushPath;
 962         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;remote.&quot; + remote + &quot;.pushurl&quot;, pushPath)) {
 963             await(p);
 964         }
 965     }
 966 
 967     @Override
 968     public String pullPath(String remote) throws IOException {
 969         var lines = config(&quot;remote.&quot; + remote + &quot;.url&quot;);
 970         if (lines.size() != 1) {
 971             throw new IOException(&quot;No pull path found for remote &quot; + remote);
 972         }
 973         return lines.get(0);
 974     }
 975 
 976     @Override
 977     public String pushPath(String remote) throws IOException {
 978         var lines = config(&quot;remote.&quot; + remote + &quot;.pushurl&quot;);
 979         if (lines.size() != 1) {
 980             return pullPath(remote);
 981         }
 982         return lines.get(0);
 983     }
 984 
 985     @Override
 986     public boolean isValidRevisionRange(String expression) throws IOException {
 987         try (var p = capture(&quot;git&quot;, &quot;rev-parse&quot;, expression)) {
 988             return p.await().status() == 0;
 989         }
 990     }
 991 
 992     private void applyPatch(Patch patch) throws IOException {
 993         if (patch.isEmpty()) {
 994             return;
 995         }
 996 
 997         if (patch.isTextual()) {
 998         } else {
 999             throw new IllegalArgumentException(&quot;Cannot handle binary patches yet&quot;);
1000         }
1001     }
1002 
1003     @Override
1004     public void apply(Diff diff, boolean force) throws IOException {
1005         // ignore force, no such concept in git
1006         var patchFile = Files.createTempFile(&quot;apply&quot;, &quot;.patch&quot;);
1007         diff.toFile(patchFile);
1008         apply(patchFile, force);
1009         Files.delete(patchFile);
1010     }
1011 
1012     @Override
1013     public void apply(Path patchFile, boolean force)  throws IOException {
1014         var cmd = new ArrayList&lt;String&gt;();
1015         cmd.addAll(List.of(&quot;git&quot;, &quot;apply&quot;, &quot;--index&quot;, &quot;--unidiff-zero&quot;));
1016         cmd.add(patchFile.toAbsolutePath().toString());
1017         try (var p = capture(cmd)) {
1018             await(p);
1019             Files.delete(patchFile);
1020         }
1021     }
1022 
1023     @Override
1024     public void copy(Path from, Path to) throws IOException {
1025         Files.copy(from, to);
1026         add(to);
1027     }
1028 
1029     @Override
1030     public void move(Path from, Path to) throws IOException {
1031         try (var p = capture(&quot;git&quot;, &quot;mv&quot;, from.toString(), to.toString())) {
1032             await(p);
1033         }
1034     }
1035 
1036     @Override
1037     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1038         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format=%(upstream:short)&quot;, &quot;refs/heads/&quot; + b.name())) {
1039             var lines = await(p).stdout();
1040             return lines.size() == 1 &amp;&amp; !lines.get(0).isEmpty()? Optional.of(lines.get(0)) : Optional.empty();
1041         }
1042     }
1043 
1044     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {
1045         var cmd = new ArrayList&lt;String&gt;();
1046         cmd.addAll(List.of(&quot;git&quot;, &quot;clone&quot;));
1047         if (isBare) {
1048             cmd.add(&quot;--bare&quot;);
1049         } else {
1050             cmd.add(&quot;--recurse-submodules&quot;);
1051         }
1052         cmd.addAll(List.of(from.toString(), to.toString()));
1053         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1054             await(p);
1055         }
1056         return new GitRepository(to);
1057     }
1058 
1059     public static Repository mirror(URI from, Path to) throws IOException {
1060         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
1061         try (var p = capture(cwd, &quot;git&quot;, &quot;clone&quot;, &quot;--mirror&quot;, from.toString(), to.toString())) {
1062             await(p);
1063         }
1064         return new GitRepository(to);
1065     }
1066 
1067     @Override
1068     public void pull() throws IOException {
1069         pull(null, null);
1070     }
1071 
1072     @Override
1073     public void pull(String remote) throws IOException {
1074         pull(remote, null);
1075     }
1076 
1077 
1078     @Override
1079     public void pull(String remote, String refspec) throws IOException {
1080         var cmd = new ArrayList&lt;String&gt;();
1081         cmd.add(&quot;git&quot;);
1082         cmd.add(&quot;pull&quot;);
1083         if (remote != null) {
1084             cmd.add(remote);
1085         }
1086         if (refspec != null) {
1087             cmd.add(refspec);
1088         }
1089         try (var p = capture(cmd)) {
1090             await(p);
1091         }
1092     }
1093 
1094     @Override
1095     public boolean contains(Branch b, Hash h) throws IOException {
1096         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--contains&quot;, h.hex(), &quot;--format&quot;, &quot;%(refname:short)&quot;)) {
1097             var res = await(p);
1098             for (var line : res.stdout()) {
1099                 if (line.equals(b.name())) {
1100                     return true;
1101                 }
1102             }
1103         }
1104 
1105         return false;
1106     }
1107 
1108     @Override
1109     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1110         var refs = new ArrayList&lt;Reference&gt;();
1111         try (var p = capture(&quot;git&quot;, &quot;ls-remote&quot;, &quot;--heads&quot;, &quot;--refs&quot;, remote)) {
1112             for (var line : await(p).stdout()) {
1113                 var parts = line.split(&quot;\t&quot;);
1114                 var name = parts[1].replace(&quot;refs/heads/&quot;, &quot;&quot;);
1115                 refs.add(new Reference(name, new Hash(parts[0])));
1116             }
1117         }
1118         return refs;
1119     }
1120 
1121     @Override
1122     public List&lt;String&gt; remotes() throws IOException {
1123         var remotes = new ArrayList&lt;String&gt;();
1124         try (var p = capture(&quot;git&quot;, &quot;remote&quot;)) {
1125             for (var line : await(p).stdout()) {
1126                 remotes.add(line);
1127             }
1128         }
1129         return remotes;
1130     }
1131 
1132     @Override
1133     public void addSubmodule(String pullPath, Path path) throws IOException {
1134         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;add&quot;, pullPath, path.toString())) {
1135             await(p);
1136         }
1137     }
1138 
1139     @Override
1140     public List&lt;Submodule&gt; submodules() throws IOException {
1141         var gitModules = root().resolve(&quot;.gitmodules&quot;);
1142         if (!Files.exists(gitModules)) {
1143             return List.of();
1144         }
1145 
1146         var urls = new HashMap&lt;String, String&gt;();
1147         var paths = new HashMap&lt;String, String&gt;();
1148         try (var p = capture(&quot;git&quot;, &quot;config&quot;, &quot;--file&quot;, gitModules.toAbsolutePath().toString(),
1149                                               &quot;--list&quot;)) {
1150             for (var line : await(p).stdout()) {
1151                 if (line.startsWith(&quot;submodule.&quot;)) {
1152                     line = line.substring(&quot;submodule.&quot;.length());
1153                     var parts = line.split(&quot;=&quot;);
1154                     var nameAndProperty = parts[0].split(&quot;\\.&quot;);
1155                     var name = nameAndProperty[0];
1156                     var prop = nameAndProperty[1];
1157                     var value = parts[1];
1158                     if (prop.equals(&quot;path&quot;)) {
1159                         paths.put(name, value);
1160                     } else if (prop.equals(&quot;url&quot;)) {
1161                         urls.put(name, value);
1162                     } else {
1163                         throw new IOException(&quot;Unexpected submodule property: &quot; + prop);
1164                     }
1165                 }
1166             }
1167         }
1168 
1169         var hashes = new HashMap&lt;String, String&gt;();
1170         try (var p = capture(&quot;git&quot;, &quot;submodule&quot;, &quot;status&quot;)) {
1171             for (var line : await(p).stdout()) {
1172                 var parts = line.substring(1).split(&quot; &quot;);
1173                 var hash = parts[0];
1174                 var path = parts[1];
1175                 hashes.put(path, hash);
1176             }
1177         }
1178 
1179         var modules = new ArrayList&lt;Submodule&gt;();
1180         for (var name : paths.keySet()) {
1181             var url = urls.get(name);
1182             var path = paths.get(name);
1183             var hash = hashes.get(path);
1184 
1185             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1186         }
1187 
1188         return modules;
1189     }
1190 
1191     @Override
1192     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1193         var ref = &quot;refs/tags/&quot; + tag.name();
1194         var format = &quot;%(refname:short)%0a%(*objectname)%0a%(taggername) %(taggeremail)%0a%(taggerdate:iso-strict)%0a%(contents)&quot;;
1195         try (var p = capture(&quot;git&quot;, &quot;for-each-ref&quot;, &quot;--format&quot;, format, ref)) {
1196             var lines = await(p).stdout();
1197             if (lines.size() &gt;= 4) {
1198                 var name = lines.get(0);
1199                 var target = new Hash(lines.get(1));
1200                 var author = Author.fromString(lines.get(2));
1201 
1202                 var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
1203                 var date = ZonedDateTime.parse(lines.get(3), formatter);
1204                 var message = String.join(&quot;\n&quot;, lines.subList(4, lines.size()));
1205 
1206                 return Optional.of(new Tag.Annotated(name, target, author, date, message));
1207             }
1208             return Optional.empty();
1209         }
1210     }
1211 
1212     @Override
1213     public void config(String section, String key, String value, boolean global) throws IOException {
1214         var cmd = new ArrayList&lt;String&gt;();
1215         cmd.addAll(List.of(&quot;git&quot;, &quot;config&quot;));
1216         if (global) {
1217             cmd.add(&quot;--global&quot;);
1218         }
1219         cmd.add(section + &quot;.&quot; + key);
1220         cmd.add(value);
1221         try (var p = capture(cmd)) {
1222             await(p);
1223         }
1224     }
1225 }
    </pre>
  </body>
</html>