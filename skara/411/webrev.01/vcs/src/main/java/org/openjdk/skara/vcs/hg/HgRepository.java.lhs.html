<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames vcs/src/main/java/org/openjdk/skara/vcs/hg/HgRepository.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.vcs.hg;
  24 
  25 import org.openjdk.skara.process.Process;
  26 import org.openjdk.skara.process.Execution;
  27 import org.openjdk.skara.vcs.*;
  28 import org.openjdk.skara.vcs.tools.*;
  29 
  30 import java.io.*;
  31 import java.nio.file.*;
  32 import java.time.*;
  33 import java.time.format.DateTimeFormatter;
  34 import java.util.*;
  35 import java.util.logging.Logger;
  36 import java.util.stream.*;
  37 import java.net.URI;
  38 
  39 public class HgRepository implements Repository {
  40     private static final String EXT_PY = &quot;ext.py&quot;;
  41     private final Path dir;
  42     private final Logger log = Logger.getLogger(&quot;org.openjdk.skara.vcs.hg&quot;);
  43 
  44     private void copyResource(String name, Path p) throws IOException {
  45         Files.copy(this.getClass().getResourceAsStream(&quot;/&quot; + name), p, StandardCopyOption.REPLACE_EXISTING);
  46     }
  47 
  48     private java.lang.Process start(String... cmd) throws IOException {
  49         return start(Arrays.asList(cmd));
  50     }
  51 
  52     private java.lang.Process start(List&lt;String&gt; cmd) throws IOException {
  53         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
  54         var pb = new ProcessBuilder(cmd);
  55         pb.directory(dir.toFile());
  56         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  57         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
  58         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
  59         return pb.start();
  60     }
  61 
  62     private static void stop(java.lang.Process p) throws IOException {
  63         if (p != null &amp;&amp; p.isAlive()) {
  64             var stream = p.getInputStream();
  65             var read = 0;
  66             var buf = new byte[128];
  67             while (read != -1) {
  68                 read = stream.read(buf);
  69             }
  70             try {
  71                 p.waitFor();
  72             } catch (InterruptedException e) {
  73                 throw new IOException(e);
  74             }
  75         }
  76     }
  77 
  78     private Execution capture(List&lt;String&gt; cmd) {
  79         return capture(cmd.toArray(new String[0]));
  80     }
  81 
  82     private Execution capture(String... cmd) {
  83         return capture(dir, cmd);
  84     }
  85 
  86     private static Execution capture(Path cwd, List&lt;String&gt; cmd) {
  87         return capture(cwd, cmd.toArray(new String[0]));
  88     }
  89     private static Execution capture(Path cwd, String... cmd) {
  90         return Process.capture(cmd)
  91                       .environ(&quot;HGRCPATH&quot;, &quot;&quot;)
  92                       .environ(&quot;HGPLAIN&quot;, &quot;&quot;)
  93                       .workdir(cwd)
  94                       .execute();
  95     }
  96 
  97     private static Execution.Result await(Execution e) throws IOException {
  98         var result = e.await();
  99         if (result.status() != 0) {
 100             if (result.exception().isPresent()) {
 101                 throw new IOException(&quot;Unexpected exit code\n&quot; + result, result.exception().get());
 102             } else {
 103                 throw new IOException(&quot;Unexpected exit code\n&quot; + result);
 104             }
 105         }
 106         return result;
 107     }
 108 
 109     private static void await(java.lang.Process p) throws IOException {
 110         try {
 111             var res = p.waitFor();
 112             if (res != 0) {
 113                 throw new IOException(&quot;Unexpected exit code: &quot; + res);
 114             }
 115         } catch (InterruptedException e) {
 116             throw new IOException(e);
 117         }
 118     }
 119 
 120     public HgRepository(Path dir) {
 121         this.dir = dir.toAbsolutePath();
 122     }
 123 
 124     @Override
 125     public List&lt;Branch&gt; branches() throws IOException {
 126         try (var p = capture(&quot;hg&quot;, &quot;branches&quot;)) {
 127             return await(p).stdout()
 128                            .stream()
 129                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 130                            .map(Branch::new)
 131                            .collect(Collectors.toList());
 132         }
 133     }
 134 
 135     @Override
 136     public List&lt;Branch&gt; branches(String remote) throws IOException {
 137         // Mercurial does not have namespacing of branch names
 138         return branches();
 139     }
 140 
 141     @Override
 142     public List&lt;Tag&gt; tags() throws IOException {
 143         try (var p = capture(&quot;hg&quot;, &quot;tags&quot;)) {
 144             return await(p).stdout()
 145                            .stream()
 146                            .map(line -&gt; line.split(&quot;\\s&quot;)[0])
 147                            .map(Tag::new)
 148                            .collect(Collectors.toList());
 149         }
 150     }
 151 
 152     @Override
 153     public Path root() throws IOException {
 154         try (var p = capture(&quot;hg&quot;, &quot;root&quot;)) {
 155             var res = await(p);
 156             if (res.stdout().size() != 1) {
 157                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 158             }
 159             return Paths.get(res.stdout().get(0));
 160         }
 161     }
 162 
 163     private void checkout(String ref, boolean force) throws IOException {
 164         var cmd = new ArrayList&lt;String&gt;();
 165         cmd.addAll(List.of(&quot;hg&quot;, &quot;update&quot;));
 166         if (!force) {
 167             cmd.add(&quot;--check&quot;);
 168         }
 169         cmd.add(ref);
 170         try (var p = capture(cmd)) {
 171             await(p);
 172         }
 173     }
 174 
 175     @Override
 176     public void checkout(Hash h, boolean force) throws IOException {
 177         checkout(h.hex(), force);
 178     }
 179 
 180     @Override
 181     public void checkout(Branch b, boolean force) throws IOException {
 182         checkout(b.name(), force);
 183     }
 184 
 185     @Override
 186     public Optional&lt;Hash&gt; resolve(String ref) throws IOException {
 187         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + ref, &quot;--template={node}\n&quot;)) {
 188             var res = p.await();
 189             if (res.status() == 0 &amp;&amp; res.stdout().size() == 1) {
 190                 return Optional.of(new Hash(res.stdout().get(0)));
 191             }
 192             return Optional.empty();
 193         }
 194     }
 195 
 196     @Override
 197     public Commits commits() throws IOException {
 198         return commits(null, -1, false);
 199     }
 200 
 201     @Override
 202     public Commits commits(boolean reverse) throws IOException {
 203         return commits(null, -1, reverse);
 204     }
 205 
 206     @Override
 207     public Commits commits(int n) throws IOException {
 208         return commits(null, n, false);
 209     }
 210 
 211     @Override
 212     public Commits commits(int n, boolean reverse) throws IOException {
 213         return commits(null, n, reverse);
 214     }
 215 
 216     @Override
 217     public Commits commits(String range) throws IOException {
 218         return commits(range, -1, false);
 219     }
 220 
 221     @Override
 222     public Commits commits(String range, int n) throws IOException {
 223         return commits(range, n, false);
 224     }
 225 
 226     @Override
 227     public Commits commits(String range, boolean reverse) throws IOException {
 228         return commits(range, -1, reverse);
 229     }
 230 
 231     @Override
 232     public Commits commits(String range, int n,  boolean reverse) throws IOException {
 233         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 234         copyResource(EXT_PY, ext);
 235         return new HgCommits(dir, range, ext, reverse, n);
 236     }
 237 
 238     @Override
 239     public Optional&lt;Commit&gt; lookup(Hash h) throws IOException {
 240         var commits = commits(h.hex()).asList();
 241         if (commits.size() != 1) {
 242             return Optional.empty();
 243         }
 244         return Optional.of(commits.get(0));
 245     }
 246 
 247     @Override
 248     public Optional&lt;Commit&gt; lookup(Branch b) throws IOException {
 249         var hash = resolve(b.name()).orElseThrow(() -&gt; new IOException(&quot;Branch &quot; + b.name() + &quot; not found&quot;));
 250         return lookup(hash);
 251     }
 252 
 253     @Override
 254     public Optional&lt;Commit&gt; lookup(Tag t) throws IOException {
 255         var hash = resolve(t.name()).orElseThrow(() -&gt; new IOException(&quot;Tag &quot; + t.name() + &quot; not found&quot;));
 256         return lookup(hash);
 257     }
 258 
 259     @Override
 260     public List&lt;CommitMetadata&gt; commitMetadata(String range) throws IOException {
 261         throw new RuntimeException(&quot;not implemented yet&quot;);
 262     }
 263 
 264     @Override
 265     public List&lt;CommitMetadata&gt; commitMetadata() throws IOException {
 266         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 267         copyResource(EXT_PY, ext);
 268 
 269         var p = start(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.dump=&quot; + ext.toAbsolutePath().toString(), &quot;metadata&quot;);
 270         var reader = new UnixStreamReader(p.getInputStream());
 271         var result = new ArrayList&lt;CommitMetadata&gt;();
 272 
 273         var line = reader.readLine();
 274         while (line != null) {
 275             result.add(HgCommitMetadata.read(reader));
 276             line = reader.readLine();
 277         }
 278 
 279         await(p);
 280         return result;
 281     }
 282 
 283     @Override
 284     public boolean isEmpty() throws IOException {
 285         var numBranches = branches().size();
 286         var numTags = tags().size();
 287 
 288         if (numBranches &gt; 0 || numTags &gt; 1) {
 289             return false;
 290         }
 291 
 292         var tip = resolve(&quot;tip&quot;);
 293         return tip.isEmpty() || tip.get().hex().equals(&quot;0&quot;.repeat(40));
 294     }
 295 
 296     @Override
 297     public boolean isHealthy() throws IOException {
 298         var root = root().toString();
 299         return !(Files.exists(Path.of(root, &quot;.hg&quot;, &quot;wlock&quot;)) ||
 300                  Files.exists(Path.of(root, &quot;.hg&quot;, &quot;store&quot;, &quot;lock&quot;)));
 301     }
 302 
 303     @Override
 304     public void clean() throws IOException {
 305         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 306             p.await();
 307         }
 308 
 309         try (var p = capture(&quot;hg&quot;, &quot;recover&quot;)) {
 310             p.await();
 311         }
 312 
 313         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--ignored&quot;, &quot;--no-status&quot;)) {
 314             var root = root().toString();
 315             for (var filename : await(p).stdout()) {
 316                 Files.delete(Path.of(root, filename));
 317             }
 318         }
 319 
 320         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 321             var root = root().toString();
 322             for (var filename : await(p).stdout()) {
 323                 Files.delete(Path.of(root, filename));
 324             }
 325         }
 326 
 327         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;)) {
 328             await(p);
 329         }
 330     }
 331 
 332     @Override
 333     public void reset(Hash target, boolean hard) throws IOException {
 334         throw new RuntimeException(&quot;Not implemented yet&quot;);
 335     }
 336 
 337     @Override
 338     public Repository reinitialize() throws IOException {
 339         Files.walk(dir)
 340              .map(Path::toFile)
 341              .sorted(Comparator.reverseOrder())
 342              .forEach(File::delete);
 343 
 344         return init();
 345     }
 346 
 347     @Override
 348     public Hash fetch(URI uri, String refspec) throws IOException {
 349         return fetch(uri != null ? uri.toString() : null, refspec);
 350     }
 351 
 352     private Hash fetch(String from, String refspec) throws IOException {
 353         var oldHeads = new HashSet&lt;Hash&gt;(heads());
 354 
 355         var cmd = new ArrayList&lt;String&gt;();
 356         cmd.add(&quot;hg&quot;);
 357         cmd.add(&quot;pull&quot;);
 358         if (refspec != null) {
 359             cmd.add(&quot;--rev&quot;);
 360             cmd.add(refspec);
 361         }
 362         if (from != null) {
 363             cmd.add(from);
 364         }
 365         try (var p = capture(cmd)) {
 366             await(p);
 367         }
 368 
 369         var newHeads = new HashSet&lt;Hash&gt;(heads());
 370         newHeads.removeAll(oldHeads);
 371 
 372         if (newHeads.size() &gt; 1) {
 373             throw new IllegalStateException(&quot;fetching multiple heads is not supported&quot;);
 374         } else if (newHeads.size() == 0) {
 375             // no new head was fetched, return current head
 376             return head();
 377         }
 378         return newHeads.iterator().next();
 379     }
 380 
 381     @Override
 382     public void fetchAll() throws IOException {
 383         var pullPaths = new ArrayList&lt;URI&gt;();
 384         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
 385             var res = await(p);
 386             for (var line : res.stdout()) {
 387                 var parts = line.split(&quot;=&quot;);
 388                 var name = parts[0].trim();
 389                 var uri = parts[1].trim();
 390                 if (!name.endsWith(&quot;-push&quot;)) {
 391                     pullPaths.add(URI.create(uri));
 392                 }
 393             }
 394         }
 395 
 396         for (var uri : pullPaths) {
 397             fetch(uri, null);
 398         }
 399     }
 400 
 401     @Override
 402     public void fetchRemote(String remote) throws IOException {
 403         fetch(remote, null);
 404     }
 405 
 406     @Override
 407     public void delete(Branch b) throws IOException {
 408         throw new RuntimeException(&quot;Branches cannot be deleted in Mercurial&quot;);
 409     }
 410 
 411     @Override
 412     public Repository init() throws IOException {
 413         if (!Files.exists(dir)) {
 414             Files.createDirectories(dir);
 415         }
 416 
 417         try (var p = capture(&quot;hg&quot;, &quot;init&quot;)) {
 418             await(p);
 419             return this;
 420         }
 421     }
 422 
 423     @Override
 424     public void pushAll(URI uri) throws IOException {
 425         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--new-branch&quot;, uri.toString())) {
 426             await(p);
 427         }
 428     }
 429 
 430     @Override
 431     public void push(Hash hash, URI uri, String ref, boolean force) throws IOException {
 432         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;push&quot;, &quot;--rev=&quot; + hash.hex()));
 433         if (force) {
 434             cmd.add(&quot;--force&quot;);
 435         }
 436         cmd.add(uri.toString() + &quot;#&quot; + ref);
 437         try (var p = capture(cmd)) {
 438             await(p);
 439         }
 440     }
 441 
 442     @Override
 443     public void push(Branch branch, String remote, boolean setUpstream) throws IOException {
 444         // ignore setUpstream, no such concept in Mercurial
 445         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--branch&quot;, branch.name(), remote)) {
 446             await(p);
 447         }
 448     }
 449 
 450     @Override
 451     public boolean isClean() throws IOException {
 452         try (var p = capture(&quot;hg&quot;, &quot;status&quot;)) {
 453             var output = await(p);
 454             return output.stdout().size() == 0;
 455         }
 456     }
 457 
 458     @Override
 459     public boolean exists() throws IOException {
 460         if (!Files.exists(dir)) {
 461             return false;
 462         }
 463 
 464         try {
 465             root();
 466             return true;
 467         } catch (IOException e) {
 468             return false;
 469         }
 470     }
 471 
 472     private void export(String revset, Path to) throws IOException {
 473         var cmd = List.of(&quot;hg&quot;, &quot;export&quot;, &quot;--git&quot;, &quot;--rev&quot;, revset);
 474         log.fine(&quot;Executing &quot; + String.join(&quot; &quot;, cmd));
 475         var pb = new ProcessBuilder(cmd);
 476         pb.directory(dir.toFile());
 477         pb.redirectError(ProcessBuilder.Redirect.DISCARD);
 478         pb.redirectOutput(to.toFile());
 479         pb.environment().put(&quot;HGRCPATH&quot;, &quot;&quot;);
 480         pb.environment().put(&quot;HGPLAIN&quot;, &quot;&quot;);
 481         var p = pb.start();
 482         try {
 483             await(p);
 484         } catch (Throwable t) {
 485             if (p.isAlive()) {
 486                 try {
 487                     p.waitFor();
 488                 } catch (InterruptedException e) {
 489                     throw new IOException(e);
 490                 }
 491             }
 492 
 493             throw new IOException(t);
 494         }
 495     }
 496 
 497     @Override
 498     public void squash(Hash h) throws IOException {
 499         var revset = &quot;.:&quot; + h.hex() + &quot; and not .&quot;;
 500         var patch = Files.createTempFile(&quot;squash&quot;, &quot;.patch&quot;);
 501         export(revset, patch);
 502 
 503         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.mq=&quot;, &quot;strip&quot;, &quot;--rev&quot;, revset)) {
 504             await(p);
 505         }
 506 
 507         try (var p = capture(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toString())) {
 508             await(p);
 509         }
 510     }
 511 
 512 
 513     @Override
 514     public Hash commit(String message, String authorName, String authorEmail)  throws IOException {
 515         return commit(message, authorName, authorEmail, null);
 516     }
 517 
 518     @Override
 519     public Hash commit(String message, String authorName, String authorEmail, ZonedDateTime authorDate)  throws IOException {
 520         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 521         var cmd = new ArrayList&lt;String&gt;();
 522         cmd.addAll(List.of(&quot;hg&quot;, &quot;commit&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user));
 523         if (authorDate != null) {
 524             var formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
 525             cmd.add(&quot;--date=&quot; + authorDate.format(formatter));
 526         }
 527         try (var p = capture(cmd)) {
 528             await(p);
 529         }
 530         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 531     }
 532 
 533     @Override
 534     public Hash commit(String message,
 535                        String authorName,
 536                        String authorEmail,
 537                        String committerName,
 538                        String committerEmail) throws IOException {
 539         return commit(message, authorName, authorEmail, null, committerName, committerEmail, null);
 540     }
 541 
 542     @Override
 543     public Hash commit(String message,
 544                        String authorName,
 545                        String authorEmail,
 546                        ZonedDateTime authorDate,
 547                        String committerName,
 548                        String committerEmail,
 549                        ZonedDateTime committerDate) throws IOException {
 550         if (!Objects.equals(authorName, committerName) ||
 551             !Objects.equals(authorEmail, committerEmail) ||
 552             !Objects.equals(authorDate, committerDate)) {
 553             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 554         }
 555 
 556         return commit(message, authorName, authorEmail, authorDate);
 557     }
 558 
 559     @Override
 560     public Hash amend(String message, String authorName, String authorEmail) throws IOException {
 561         var user = authorEmail == null ? authorName : authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 562         try (var p = capture(&quot;hg&quot;, &quot;commit&quot;, &quot;--amend&quot;, &quot;--message=&quot; + message, &quot;--user=&quot; + user)) {
 563             await(p);
 564         }
 565         return resolve(&quot;tip&quot;).orElseThrow(() -&gt; new IOException(&quot;Could not resolve &#39;tip&#39;&quot;));
 566     }
 567 
 568     @Override
 569     public Hash amend(String message, String authorName, String authorEmail, String committerName, String committerEmail) throws IOException {
 570         if (!Objects.equals(authorName, committerName) ||
 571             !Objects.equals(authorEmail, committerEmail)) {
 572             throw new IllegalArgumentException(&quot;hg does not support different author and committer data&quot;);
 573         }
 574 
 575         return amend(message, authorName, authorEmail);
 576     }
 577 
 578     @Override
 579     public Tag tag(Hash hash, String name, String message, String authorName, String authorEmail) throws IOException {
 580         var user = authorName + &quot; &lt;&quot; + authorEmail + &quot;&gt;&quot;;
 581         try (var p = capture(&quot;hg&quot;, &quot;tag&quot;,
 582                              &quot;--message&quot;, message,
 583                              &quot;--user&quot;, user,
 584                              &quot;--rev&quot;, hash.hex(),
 585                              name)) {
 586             await(p);
 587         }
 588 
 589         return new Tag(name);
 590     }
 591 
 592     @Override
 593     public Branch branch(Hash hash, String name) throws IOException {
 594         // Model a lightweight branch with a bookmark. Not ideal but the
 595         // closest to git branches.
 596         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--rev&quot;, hash.hex(), name)) {
 597             await(p);
 598         }
 599 
 600         return new Branch(name);
 601     }
 602 
 603     @Override
 604     public void prune(Branch branch, String remote) throws IOException {
 605         try (var p = capture(&quot;hg&quot;, &quot;bookmark&quot;, &quot;--delete&quot;, branch.name())) {
 606             await(p);
 607         }
 608         try (var p = capture(&quot;hg&quot;, &quot;push&quot;, &quot;--bookmark&quot;, branch.name(), remote)) {
 609             await(p);
 610         }
 611     }
 612 
 613     @Override
 614     public Hash mergeBase(Hash first, Hash second) throws IOException {
 615         var revset = &quot;ancestor(&quot; + first.hex() + &quot;, &quot; + second.hex() + &quot;)&quot;;
 616         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--rev=&quot; + revset, &quot;--template={node}\n&quot;)) {
 617             var res = await(p);
 618             if (res.stdout().size() != 1) {
 619                 throw new IOException(&quot;Unexpected output\n&quot; + res);
 620             }
 621             return new Hash(res.stdout().get(0));
 622         }
 623     }
 624 
 625     @Override
 626     public boolean isAncestor(Hash ancestor, Hash descendant) throws IOException {
 627         throw new RuntimeException(&quot;Not implemented yet&quot;);
 628     }
 629 
 630     @Override
 631     public void rebase(Hash hash, String committerName, String committerEmail) throws IOException {
 632         var current = currentBranch().orElseThrow(() -&gt;
 633                 new IOException(&quot;No current branch to rebase upon&quot;)
 634         );
 635         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.rebase=&quot;,
 636                              &quot;rebase&quot;, &quot;--dest&quot;, hash.hex(), &quot;--base&quot;, current.name())) {
 637             await(p);
 638         }
 639     }
 640 
 641     @Override
 642     public Optional&lt;Branch&gt; currentBranch() throws IOException {
 643         try (var p = capture(&quot;hg&quot;, &quot;branch&quot;)) {
 644             var res = await(p);
 645             if (res.stdout().size() != 1) {
 646                 return Optional.empty();
 647             }
 648             return Optional.of(new Branch(res.stdout().get(0)));
 649         }
 650     }
 651 
 652     @Override
 653     public Optional&lt;Bookmark&gt; currentBookmark() throws IOException {
 654         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, &quot;.&quot;, &quot;--template&quot;, &quot;{activebookmark}\n&quot;)) {
 655             var res = await(p);
 656             if (res.stdout().size() == 1) {
 657                 return Optional.of(new Bookmark(res.stdout().get(0)));
 658             }
 659             return Optional.empty();
 660         }
 661     }
 662 
 663     @Override
 664     public Branch defaultBranch() throws IOException {
 665         return new Branch(&quot;default&quot;);
 666     }
 667 
 668     @Override
 669     public Optional&lt;Tag&gt; defaultTag() throws IOException {
 670         return Optional.of(new Tag(&quot;tip&quot;));
 671     }
 672 
 673     @Override
 674     public Optional&lt;byte[]&gt; show(Path path, Hash hash) throws IOException {
 675         var output = Files.createTempFile(&quot;hg-cat-rev-&quot; + hash.abbreviate(), &quot;.bin&quot;);
 676         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output, &quot;--rev=&quot; + hash.hex(), path.toString())) {
 677             var res = p.await();
 678             if (res.status() == 0 &amp;&amp; Files.exists(output)) {
 679                 var bytes = Files.readAllBytes(output);
 680                 Files.delete(output);
 681                 return Optional.of(bytes);
 682             }
 683 
 684             if (Files.exists(output)) {
 685                 Files.delete(output);
 686             }
 687             return Optional.empty();
 688         }
 689     }
 690 
 691     private List&lt;FileEntry&gt; allFiles(Hash hash, List&lt;Path&gt; paths) throws IOException {
 692         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 693         copyResource(EXT_PY, ext);
 694 
 695         var include = new HashSet&lt;&gt;(paths);
 696 
 697         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-tree=&quot; + ext, &quot;ls-tree&quot;, hash.hex())) {
 698             var res = await(p);
 699             var entries = new ArrayList&lt;FileEntry&gt;();
 700             for (var line : res.stdout()) {
 701                 var parts = line.split(&quot;\t&quot;);
 702                 var metadata = parts[0].split(&quot; &quot;);
 703                 var path = Path.of(parts[1]);
 704                 if (include.isEmpty() || include.contains(path)) {
 705                     var entry = new FileEntry(hash,
 706                                               FileType.fromOctal(metadata[0]),
 707                                               new Hash(metadata[2]),
 708                                               path);
 709                     entries.add(entry);
 710                 }
 711             }
 712             return entries;
 713         }
 714     }
 715 
 716     @Override
 717     public List&lt;FileEntry&gt; files(Hash hash, List&lt;Path&gt; paths) throws IOException {
 718         if (paths.isEmpty()) {
 719             return allFiles(hash, paths);
 720         }
 721 
 722         var entries = new ArrayList&lt;FileEntry&gt;();
 723         var batchSize = 64;
 724         var start = 0;
 725         while (start &lt; paths.size()) {
 726             var end = start + batchSize;
 727             if (end &gt; paths.size()) {
 728                 end = paths.size();
 729             }
 730             entries.addAll(allFiles(hash, paths.subList(start, end)));
 731             start = end;
 732         }
 733         return entries;
 734     }
 735 
 736     @Override
 737     public List&lt;StatusEntry&gt; status(Hash from, Hash to) throws IOException {
 738         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 739         copyResource(EXT_PY, ext);
 740 
 741         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath().toString(),
 742                                                &quot;diff-git-raw&quot;, from.hex(), to.hex())) {
 743             var res = await(p);
 744             var entries = new ArrayList&lt;StatusEntry&gt;();
 745             for (var line : res.stdout()) {
 746                 entries.add(StatusEntry.fromRawLine(line));
 747             }
 748             return entries;
 749         }
 750     }
 751 
 752     @Override
 753     public void dump(FileEntry entry, Path to) throws IOException {
 754         var output = to.toAbsolutePath();
 755         try (var p = capture(&quot;hg&quot;, &quot;cat&quot;, &quot;--output=&quot; + output.toString(),
 756                                           &quot;--rev=&quot; + entry.commit(),
 757                                           entry.path().toString())) {
 758             await(p);
 759         }
 760     }
 761 
 762     @Override
 763     public void revert(Hash parent) throws IOException {
 764         try (var p = capture(&quot;hg&quot;, &quot;revert&quot;, &quot;--no-backup&quot;, &quot;--all&quot;, &quot;--rev&quot;, parent.hex())) {
 765             await(p);
 766         }
 767     }
 768 
 769     @Override
 770     public Diff diff(Hash from) throws IOException {
 771         return diff(from, List.of());
 772     }
 773 
 774     @Override
 775     public Diff diff(Hash from, List&lt;Path&gt; files) throws IOException {
 776         return diff(from, null, files);
 777     }
 778 
 779     @Override
 780     public Diff diff(Hash from, Hash to) throws IOException {
 781         return diff(from, to, List.of());
 782     }
 783 
 784     @Override
 785     public Diff diff(Hash from, Hash to, List&lt;Path&gt; files) throws IOException {
 786         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
 787         copyResource(EXT_PY, ext);
 788 
 789         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.diff-git-raw=&quot; + ext.toAbsolutePath(),
 790                                                 &quot;diff-git-raw&quot;, &quot;--patch&quot;, from.hex()));
 791         if (to != null) {
 792             cmd.add(to.hex());
 793         }
 794 
 795         if (files != null) {
 796             var filenames = files.stream().map(Path::toString).collect(Collectors.toList());
 797             cmd.add(&quot;--files=&quot; + String.join(&quot;,&quot;, filenames));
 798         }
 799 
 800         var p = start(cmd);
 801         try {
 802             var patches = UnifiedDiffParser.parseGitRaw(p.getInputStream());
 803             await(p);
 804             return new Diff(from, to, patches);
 805         } catch (Throwable t) {
 806             throw new IOException(t);
 807         }
 808     }
 809 
 810     @Override
 811     public Optional&lt;String&gt; username() throws IOException {
 812         var lines = config(&quot;ui.username&quot;);
 813         return lines.size() == 1 ? Optional.of(lines.get(0)) : Optional.empty();
 814     }
 815 
 816     @Override
 817     public Hash head() throws IOException {
 818         return resolve(&quot;.&quot;).orElseThrow(() -&gt; new IOException(&quot;. not available&quot;));
 819     }
 820 
 821     private List&lt;Hash&gt; heads() throws IOException {
 822         var heads = new ArrayList&lt;Hash&gt;();
 823         try (var p = capture(&quot;hg&quot;, &quot;heads&quot;, &quot;--template={node}\n&quot;)) {
 824             var res = p.await();
 825             if (res.status() == 0) {
 826                 for (var hash : res.stdout()) {
 827                     heads.add(new Hash(hash));
 828                 }
 829             }
 830         }
 831         return heads;
 832     }
 833 
 834     @Override
 835     public List&lt;String&gt; config(String key) throws IOException {
 836         // Do not use HgRepository.capture() here, want to run *with*
 837         // hg configuration.
 838         try (var p = Process.capture(&quot;hg&quot;, &quot;showconfig&quot;, key)
 839                             .workdir(dir)
 840                             .execute()) {
 841             var res = p.await();
 842             if (res.status() == 1) {
 843                 return List.of();
 844             }
 845             return res.stdout();
 846         }
 847     }
 848 
 849     public static Optional&lt;Repository&gt; get(Path p) throws IOException {
 850         if (!Files.exists(p)) {
 851             return Optional.empty();
 852         }
 853 
 854         var r = new HgRepository(p);
 855         return r.exists() ? Optional.of(new HgRepository(r.root())) : Optional.empty();
 856     }
 857 
 858     @Override
 859     public Repository copyTo(Path destination) throws IOException {
 860         var from = root().toAbsolutePath().toString();
 861         var to = destination.toAbsolutePath().toString();
 862         try (var p = capture(&quot;hg&quot;, &quot;clone&quot;, from, to)) {
 863             await(p);
 864         }
 865 
 866         return new HgRepository(destination.toAbsolutePath());
 867     }
 868 
 869     @Override
 870     public void merge(Hash h) throws IOException {
 871         merge(h.hex(), null);
 872     }
 873 
 874     @Override
 875     public void merge(Branch b) throws IOException {
 876         merge(b.name(), null);
 877     }
 878 
 879     @Override
 880     public void merge(Hash h, String strategy) throws IOException {
 881         merge(h.hex(), strategy);
 882     }
 883 
 884     private void merge(String ref, String strategy) throws IOException {
 885         var cmd = new ArrayList&lt;String&gt;();
 886         cmd.addAll(List.of(&quot;hg&quot;, &quot;merge&quot;, &quot;--rev=&quot; + ref));
 887         if (strategy != null) {
 888             cmd.add(&quot;--tool=&quot; + strategy);
 889         }
 890         try (var p = capture(cmd)) {
 891             await(p);
 892         }
 893     }
 894 
 895     @Override
 896     public void abortMerge() throws IOException {
 897         try (var p = capture(&quot;hg&quot;, &quot;merge&quot;, &quot;--abort&quot;)) {
 898             await(p);
 899         }
 900 
 901         try (var p = capture(&quot;hg&quot;, &quot;status&quot;, &quot;--unknown&quot;, &quot;--no-status&quot;)) {
 902             var res = await(p);
 903             for (var path : res.stdout()) {
 904                 if (path.toString().endsWith(&quot;.orig&quot;)) {
 905                     Files.delete(root().resolve(path));
 906                 }
 907             }
 908         }
 909     }
 910 
 911     @Override
 912     public void addRemote(String name, String path) throws IOException {
 913         setPaths(name, path, path);
 914     }
 915 
 916     @Override
 917     public void setPaths(String remote, String pullPath, String pushPath) throws IOException {
 918         var hgrc = Path.of(root().toString(), &quot;.hg&quot;, &quot;hgrc&quot;);
 919         if (!Files.exists(hgrc)) {
 920             Files.createFile(hgrc);
 921         }
 922 
 923         var lines = Files.readAllLines(hgrc);
 924         var newLines = new ArrayList&lt;String&gt;();
 925 
 926         var isInPathsSection = false;
 927         var hasPathsSection = false;
 928         for (var line : lines) {
 929             var isSectionHeader = line.startsWith(&quot;[&quot;) &amp;&amp; line.endsWith(&quot;]&quot;);
 930             if (isSectionHeader &amp;&amp; !isInPathsSection) {
 931                 isInPathsSection = line.equals(&quot;[paths]&quot;);
 932                 if (isInPathsSection) {
 933                     newLines.add(line);
 934                     newLines.add(remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath));
 935                     newLines.add(remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 936                     hasPathsSection = true;
 937                     continue;
 938                 }
 939             }
 940 
 941             if (isInPathsSection &amp;&amp; line.startsWith(remote)) {
 942                 if (line.startsWith(remote + &quot;-push&quot;)) {
 943                     // skip
 944                 } else if (line.startsWith(remote + &quot;:pushurl&quot;)) {
 945                     // skip
 946                 } else if (line.startsWith(remote + &quot; &quot;) || line.startsWith(remote + &quot;=&quot;)) {
 947                     // skip
 948                 } else {
 949                     newLines.add(line);
 950                 }
 951             } else {
 952                 newLines.add(line);
 953             }
 954         }
 955 
 956         Files.write(hgrc, newLines, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
 957         if (!hasPathsSection) {
 958             var section = List.of(&quot;[paths]&quot;,
 959                                   remote + &quot; = &quot; + (pullPath == null ? &quot;&quot; : pullPath),
 960                                   remote + &quot;-push = &quot; + (pushPath == null ? &quot;&quot; : pushPath));
 961             Files.write(hgrc, section, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
 962         }
 963     }
 964 
 965     @Override
 966     public String pullPath(String remote) throws IOException {
 967         var lines = config(&quot;paths.&quot; + remote);
 968         if (lines.size() != 1) {
 969             throw new IOException(&quot;Pull path not found for remote: &quot; + remote);
 970         }
 971         return lines.get(0);
 972     }
 973 
 974     @Override
 975     public String pushPath(String remote) throws IOException {
 976         var lines = config(&quot;paths.&quot; + remote + &quot;-push&quot;);
 977         if (lines.size() != 1) {
 978             lines = config(&quot;paths.&quot; + remote + &quot;@push&quot;);
 979         }
 980         if (lines.size() != 1) {
 981             return pullPath(remote);
 982         }
 983         return lines.get(0);
 984     }
 985 
 986     @Override
 987     public boolean isValidRevisionRange(String expression) throws IOException {
 988         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot; &quot;, &quot;--rev&quot;, expression)) {
 989             return p.await().status() == 0;
 990         }
 991     }
 992 
 993     private void setPermissions(Patch.Info target) throws IOException {
 994         if (target.path().isPresent() &amp;&amp; target.type().isPresent()) {
 995             var perms = target.type().get().permissions();
 996             if (perms.isPresent()) {
 997                 Files.setPosixFilePermissions(target.path().get(), perms.get());
 998             }
 999         }
1000     }
1001 
1002     @Override
1003     public void apply(Diff diff, boolean force) throws IOException {
1004         var patchFile = Files.createTempFile(&quot;import&quot;, &quot;.patch&quot;);
1005         diff.toFile(patchFile);
1006         apply(patchFile, force);
1007         Files.delete(patchFile);
1008     }
1009 
1010     @Override
1011     public void apply(Path patchFile, boolean force) throws IOException {
1012         var cmd = new ArrayList&lt;String&gt;();
1013         cmd.addAll(List.of(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;));
1014         if (force) {
1015             cmd.add(&quot;--force&quot;);
1016         }
1017         cmd.add(patchFile.toAbsolutePath().toString());
1018         try (var p = capture(cmd)) {
1019             await(p);
1020         }
1021     }
1022 
1023     @Override
1024     public void copy(Path from, Path to) throws IOException {
1025         try (var p = capture(&quot;hg&quot;, &quot;copy&quot;, from.toString(), to.toString())) {
1026             await(p);
1027         }
1028     }
1029 
1030     @Override
1031     public void move(Path from, Path to) throws IOException {
1032         try (var p = capture(&quot;hg&quot;, &quot;move&quot;, from.toString(), to.toString())) {
1033             await(p);
1034         }
1035     }
1036 
1037     @FunctionalInterface
1038     private static interface Operation {
1039         void execute(List&lt;Path&gt; args) throws IOException;
1040     }
1041 
1042     private void batch(Operation op, List&lt;Path&gt; args) throws IOException {
1043         var batchSize = 64;
1044         var start = 0;
1045         while (start &lt; args.size()) {
1046             var end = start + batchSize;
1047             if (end &gt; args.size()) {
1048                 end = args.size();
1049             }
1050             op.execute(args.subList(start, end));
1051             start = end;
1052         }
1053     }
1054 
1055     private void addAll(List&lt;Path&gt; paths) throws IOException {
1056         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;add&quot;));
1057         for (var path : paths) {
1058             cmd.add(path.toString());
1059         }
1060         try (var p = capture(cmd)) {
1061             await(p);
1062         }
1063     }
1064 
1065     private void removeAll(List&lt;Path&gt; paths) throws IOException {
1066         var cmd = new ArrayList&lt;&gt;(List.of(&quot;hg&quot;, &quot;rm&quot;));
1067         for (var path : paths) {
1068             cmd.add(path.toString());
1069         }
1070         try (var p = capture(cmd)) {
1071             await(p);
1072         }
1073     }
1074 
1075 
1076     @Override
1077     public void remove(List&lt;Path&gt; paths) throws IOException {
1078         batch(this::removeAll, paths);
1079     }
1080 
1081     @Override
1082     public void add(List&lt;Path&gt; paths) throws IOException {
1083         batch(this::addAll, paths);
1084     }
1085 
1086     @Override
1087     public void addremove() throws IOException {
1088         try (var p = capture(&quot;hg&quot;, &quot;addremove&quot;)) {
1089             await(p);
1090         }
1091     }
1092 
1093     @Override
1094     public Optional&lt;String&gt; upstreamFor(Branch b) throws IOException {
1095         // Mercurial doesn&#39;t have the concept of remotes like git,
1096         // a local branch must have the same name (if present) on the remote
1097         return Optional.of(b.name());
1098     }
1099 
<a name="1" id="anc1"></a><span class="line-modified">1100     public static Repository clone(URI from, Path to, boolean isBare) throws IOException {</span>
1101         var cmd = new ArrayList&lt;String&gt;();
1102         cmd.addAll(List.of(&quot;hg&quot;, &quot;clone&quot;));
1103         if (isBare) {
1104             cmd.add(&quot;--noupdate&quot;);
1105         }
1106         cmd.addAll(List.of(from.toString(), to.toString()));
1107 
1108         try (var p = capture(Path.of(&quot;&quot;).toAbsolutePath(), cmd)) {
1109             await(p);
1110         }
1111         return new HgRepository(to);
1112     }
1113 
1114     @Override
1115     public void pull() throws IOException {
1116         pull(null, null);
1117     }
1118 
1119     @Override
1120     public void pull(String remote) throws IOException {
1121         pull(remote, null);
1122     }
1123 
1124     @Override
1125     public void pull(String remote, String refspec) throws IOException {
1126         var cmd = new ArrayList&lt;String&gt;();
1127         cmd.addAll(List.of(&quot;hg&quot;, &quot;pull&quot;, &quot;--update&quot;));
1128         if (refspec != null) {
1129             cmd.add(&quot;--branch&quot;);
1130             cmd.add(refspec);
1131         }
1132         if (remote != null) {
1133             cmd.add(remote);
1134         }
1135         try (var p = capture(cmd)) {
1136             await(p);
1137         }
1138     }
1139 
1140     @Override
1141     public boolean contains(Branch b, Hash h) throws IOException {
1142         try (var p = capture(&quot;hg&quot;, &quot;log&quot;, &quot;--template&quot;, &quot;{branch}&quot;, &quot;-r&quot;, h.hex())) {
1143             var res = await(p);
1144             if (res.stdout().size() != 1) {
1145                 throw new IOException(&quot;Unexpected output: &quot; + String.join(&quot;\n&quot;, res.stdout()));
1146             }
1147             var line = res.stdout().get(0);
1148             return line.equals(b.name());
1149         }
1150     }
1151 
1152     @Override
1153     public List&lt;Reference&gt; remoteBranches(String remote) throws IOException {
1154         var refs = new ArrayList&lt;Reference&gt;();
1155 
1156         var ext = Files.createTempFile(&quot;ext&quot;, &quot;.py&quot;);
1157         copyResource(EXT_PY, ext);
1158 
1159         try (var p = capture(&quot;hg&quot;, &quot;--config&quot;, &quot;extensions.ls-remote=&quot; + ext, &quot;ls-remote&quot;, remote)) {
1160             var res = await(p);
1161             for (var line : res.stdout()) {
1162                 var parts = line.split(&quot;\t&quot;);
1163                 refs.add(new Reference(parts[1], new Hash(parts[0])));
1164             }
1165         }
1166         return refs;
1167     }
1168 
1169     @Override
1170     public List&lt;String&gt; remotes() throws IOException {
1171         var remotes = new ArrayList&lt;String&gt;();
1172         try (var p = capture(&quot;hg&quot;, &quot;paths&quot;)) {
1173             for (var line : await(p).stdout()) {
1174                 var parts = line.split(&quot; = &quot;);
1175                 var name = parts[0];
1176                 if (name.endsWith(&quot;-push&quot;) || name.endsWith(&quot;:push&quot;)) {
1177                     continue;
1178                 } else {
1179                     remotes.add(name);
1180                 }
1181             }
1182         }
1183         return remotes;
1184     }
1185 
1186     @Override
1187     public void addSubmodule(String pullPath, Path path) throws IOException {
1188         var uri = Files.exists(Path.of(pullPath)) ? Path.of(pullPath).toUri().toString() : pullPath;
<a name="2" id="anc2"></a><span class="line-modified">1189         HgRepository.clone(URI.create(uri), root().resolve(path).toAbsolutePath(), false);</span>
1190         var hgSub = root().resolve(&quot;.hgsub&quot;);
1191         Files.writeString(hgSub, path.toString() + &quot; = &quot; + pullPath + &quot;\n&quot;,
1192                           StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE);
1193         add(List.of(hgSub));
1194     }
1195 
1196     @Override
1197     public List&lt;Submodule&gt; submodules() throws IOException {
1198         var hgSub = root().resolve(&quot;.hgsub&quot;);
1199         var hgSubState = root().resolve(&quot;.hgsubstate&quot;);
1200         if (!(Files.exists(hgSub) &amp;&amp; Files.exists(hgSubState))) {
1201             return List.of();
1202         }
1203 
1204         var urls = new HashMap&lt;String, String&gt;();
1205         for (var line : Files.readAllLines(hgSub)) {
1206             var parts = line.split(&quot;=&quot;);
1207             var path = parts[0].trim();
1208             var url = parts[1].trim();
1209             urls.put(path, url);
1210         }
1211 
1212         var hashes = new HashMap&lt;String, String&gt;();
1213         for (var line : Files.readAllLines(hgSubState)) {
1214             var parts = line.split(&quot; &quot;);
1215             var hash = parts[0];
1216             var path = parts[1];
1217             hashes.put(path, hash);
1218         }
1219 
1220         var modules = new ArrayList&lt;Submodule&gt;();
1221         for (var path : urls.keySet()) {
1222             var url = urls.get(path);
1223             var hash = hashes.get(path);
1224             modules.add(new Submodule(new Hash(hash), Path.of(path), url));
1225         }
1226 
1227         return modules;
1228     }
1229 
1230     @Override
1231     public Optional&lt;Tag.Annotated&gt; annotate(Tag tag) throws IOException {
1232         var hgtags = root().resolve(&quot;.hgtags&quot;);
1233         if (!Files.exists(hgtags)) {
1234             return Optional.empty();
1235         }
1236         try (var p = capture(&quot;hg&quot;, &quot;annotate&quot;, hgtags.toString())) {
1237             var reversed = new ArrayList&lt;&gt;(await(p).stdout());
1238             Collections.reverse(reversed);
1239             for (var line : reversed) {
1240                 var parts = line.split(&quot; &quot;);
1241                 var tagName = parts[2];
1242                 if (tagName.equals(tag.name())) {
1243                     var target = new Hash(parts[1]);
1244                     var rev = parts[0].substring(0, parts[0].length() - 1).trim(); // skip last &#39;:&#39; and ev. whitespace
1245                     var hash = resolve(rev).orElseThrow(IOException::new);
1246                     var commit = lookup(hash).orElseThrow(IOException::new);
1247                     var message = String.join(&quot;\n&quot;, commit.message()) + &quot;\n&quot;;
1248                     return Optional.of(new Tag.Annotated(tagName, target, commit.author(), commit.date(), message));
1249                 }
1250             }
1251         }
1252         return Optional.empty();
1253     }
1254 
1255     @Override
1256     public void config(String section, String key, String value, boolean global) throws IOException {
1257         var hgrc = global ?
1258             Path.of(System.getProperty(&quot;user.home&quot;), &quot;.hgrc&quot;) :
1259             root().resolve(&quot;.hg&quot;).resolve(&quot;hgrc&quot;);
1260 
1261         var lines = List.of(
1262             &quot;[&quot; + section + &quot;]&quot;,
1263             key + &quot; = &quot; + value
1264         );
1265         if (!Files.exists(hgrc)) {
1266             Files.createFile(hgrc);
1267         }
1268         Files.write(hgrc, lines, StandardOpenOption.WRITE, StandardOpenOption.APPEND);
1269     }
1270 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>