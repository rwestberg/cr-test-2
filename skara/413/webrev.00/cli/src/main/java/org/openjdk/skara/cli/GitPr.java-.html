<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old cli/src/main/java/org/openjdk/skara/cli/GitPr.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.skara.cli;
  24 
  25 import org.openjdk.skara.args.*;
  26 import org.openjdk.skara.forge.*;
  27 import org.openjdk.skara.host.*;
  28 import org.openjdk.skara.issuetracker.IssueTracker;
  29 import org.openjdk.skara.issuetracker.Issue;
  30 import org.openjdk.skara.jcheck.JCheckConfiguration;
  31 import org.openjdk.skara.proxy.HttpProxy;
  32 import org.openjdk.skara.vcs.*;
  33 import org.openjdk.skara.vcs.openjdk.CommitMessageParsers;
  34 import org.openjdk.skara.version.Version;
  35 
  36 import java.io.IOException;
  37 import java.net.URI;
  38 import java.nio.charset.StandardCharsets;
  39 import java.nio.file.*;
  40 import java.util.*;
  41 import java.util.regex.Pattern;
  42 import java.util.concurrent.TimeUnit;
  43 import java.util.function.Supplier;
  44 import java.util.logging.Level;
  45 import java.util.stream.Collectors;
  46 
  47 public class GitPr {
  48     private static final StandardOpenOption APPEND = StandardOpenOption.APPEND;
  49     private static final Pattern ISSUE_ID_PATTERN = Pattern.compile(&quot;([A-Za-z][A-Za-z0-9]+)?-([0-9]+)&quot;);
  50     private static final Pattern ISSUE_MARKDOWN_PATTERN =
  51         Pattern.compile(&quot;^\\[([A-Z]+-[0-9]+)\\]\\(https:\\/\\/bugs.openjdk.java.net\\/browse\\/[A-Z]+-[0-9]+\\): .*$&quot;);
  52 
  53     private static void exit(String fmt, Object...args) {
  54         System.err.println(String.format(fmt, args));
  55         System.exit(1);
  56     }
  57 
  58     private static &lt;T&gt; Supplier&lt;T&gt; die(String fmt, Object... args) {
  59         return () -&gt; {
  60             exit(fmt, args);
  61             return null;
  62         };
  63     }
  64 
  65     private static String gitConfig(String key) {
  66         try {
  67             var pb = new ProcessBuilder(&quot;git&quot;, &quot;config&quot;, key);
  68             pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
  69             pb.redirectError(ProcessBuilder.Redirect.DISCARD);
  70             var p = pb.start();
  71 
  72             var output = new String(p.getInputStream().readAllBytes(), StandardCharsets.UTF_8);
  73             var res = p.waitFor();
  74             if (res != 0) {
  75                 return null;
  76             }
  77 
  78             return output == null ? null : output.replace(&quot;\n&quot;, &quot;&quot;);
  79         } catch (InterruptedException e) {
  80             return null;
  81         } catch (IOException e) {
  82             return null;
  83         }
  84     }
  85 
  86     private static String getOption(String name, Arguments arguments) {
  87         return getOption(name, null, arguments);
  88     }
  89 
  90     private static String getOption(String name, String subsection, Arguments arguments) {
  91         if (arguments.contains(name)) {
  92             return arguments.get(name).asString();
  93         }
  94 
  95         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
  96             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
  97             if (subsectionSpecific != null) {
  98                 return subsectionSpecific;
  99             }
 100         }
 101 
 102         return gitConfig(&quot;fork.&quot; + name);
 103     }
 104 
 105     private static boolean getSwitch(String name, Arguments arguments) {
 106         return getSwitch(name, null, arguments);
 107     }
 108 
 109     private static boolean getSwitch(String name, String subsection, Arguments arguments) {
 110         if (arguments.contains(name)) {
 111             return true;
 112         }
 113 
 114         if (subsection != null &amp;&amp; !subsection.isEmpty()) {
 115             var subsectionSpecific = gitConfig(&quot;pr.&quot; + subsection + &quot;.&quot; + name);
 116             if (subsectionSpecific != null) {
 117                 return subsectionSpecific.toLowerCase().equals(&quot;true&quot;);
 118             }
 119         }
 120 
 121         var sectionSpecific = gitConfig(&quot;fork.&quot; + name);
 122         return sectionSpecific != null &amp;&amp; sectionSpecific.toLowerCase().equals(&quot;true&quot;);
 123     }
 124 
 125     private static String rightPad(String s, int length) {
 126         return String.format(&quot;%-&quot; + length + &quot;s&quot;, s);
 127     }
 128 
 129     private static void appendPaddedHTMLComment(Path file, String line) throws IOException {
 130         var end = &quot; --&gt;&quot;;
 131         var pad = 79 - end.length();
 132         var newLine = &quot;\n&quot;;
 133         Files.writeString(file, rightPad(&quot;&lt;!-- &quot; + line, pad) + end + newLine, StandardOpenOption.APPEND);
 134     }
 135 
 136     private static String format(Issue issue) {
 137         var parts = issue.id().split(&quot;-&quot;);
 138         var id = parts.length == 2 ? parts[1] : issue.id();
 139         return id + &quot;: &quot; + issue.title();
 140     }
 141 
 142 
 143     private static String pullRequestIdArgument(Arguments arguments, ReadOnlyRepository repo) throws IOException {
 144         if (arguments.at(1).isPresent()) {
 145             return arguments.at(1).asString();
 146         }
 147 
 148         var currentBranch = repo.currentBranch();
 149         if (currentBranch.isPresent()) {
 150             var lines = repo.config(&quot;pr.&quot; + currentBranch.get().name() + &quot;.id&quot;);
 151             if (lines.size() == 1) {
 152                 return lines.get(0);
 153             }
 154         }
 155 
 156         exit(&quot;error: you must provide a pull request id&quot;);
 157         return null;
 158     }
 159 
 160     private static String statusForPullRequest(PullRequest pr) {
 161         var labels = pr.labels();
 162         if (pr.isDraft()) {
 163             return &quot;DRAFT&quot;;
 164         } else if (labels.contains(&quot;rfr&quot;)) {
 165             return &quot;RFR&quot;;
 166         } else if (labels.contains(&quot;ready&quot;)) {
 167             return &quot;READY&quot;;
 168         } else if (labels.contains(&quot;outdated&quot;)) {
 169             return &quot;OUTDATED&quot;;
 170         } else if (labels.contains(&quot;oca&quot;)) {
 171             return &quot;OCA&quot;;
 172         } else if (labels.contains(&quot;integrated&quot;)) {
 173             return &quot;INTEGRATED&quot;;
 174         } else {
 175             var checks = pr.checks(pr.headHash());
 176             var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
 177             if (jcheck.isPresent()) {
 178                 var checkStatus = jcheck.get().status();
 179                 if (checkStatus == CheckStatus.IN_PROGRESS) {
 180                     return &quot;CHECKING&quot;;
 181                 } else if (checkStatus == CheckStatus.SUCCESS) {
 182                     return &quot;RFR&quot;;
 183                 } else if (checkStatus == CheckStatus.FAILURE) {
 184                     return &quot;FAILURE&quot;;
 185                 }
 186             } else {
 187                 return &quot;CHECKING&quot;;
 188             }
 189         }
 190 
 191         return &quot;UNKNOWN&quot;;
 192     }
 193 
 194     private static String statusForCheck(Check check) {
 195         var checkStatus = check.status();
 196         if (checkStatus == CheckStatus.IN_PROGRESS) {
 197             return &quot;RUNNING&quot;;
 198         } else if (checkStatus == CheckStatus.SUCCESS) {
 199             return &quot;OK&quot;;
 200         } else if (checkStatus == CheckStatus.FAILURE) {
 201             return &quot;FAILED&quot;;
 202         } else if (checkStatus == CheckStatus.CANCELLED) {
 203             return &quot;CANCELLED&quot;;
 204         }
 205 
 206         return &quot;UNKNOWN&quot;;
 207     }
 208 
 209     private static List&lt;String&gt; issuesFromPullRequest(PullRequest pr) {
 210         var issueTitleIndex = -1;
 211         var lines = pr.body().split(&quot;\n&quot;);
 212         for (var i = 0; i &lt; lines.length; i++) {
 213             if (lines[i].startsWith(&quot;## Issue&quot;)) {
 214                 issueTitleIndex = i;
 215                 break;
 216             }
 217         }
 218 
 219         if (issueTitleIndex == -1) {
 220             return List.of();
 221         }
 222 
 223         var issues = new ArrayList&lt;String&gt;();
 224         for (var i = issueTitleIndex + 1; i &lt; lines.length; i++) {
 225             var m = ISSUE_MARKDOWN_PATTERN.matcher(lines[i]);
 226             if (m.matches()) {
 227                 issues.add(m.group(1));
 228             } else {
 229                 break;
 230             }
 231         }
 232 
 233         return issues;
 234     }
 235 
 236     private static String jbsProjectFromJcheckConf(Repository repo) throws IOException {
 237         var conf = JCheckConfiguration.from(repo, repo.resolve(&quot;master&quot;).orElseThrow(() -&gt;
 238             new IOException(&quot;Could not resolve &#39;master&#39; branch&quot;)
 239         ));
 240 
 241         return conf.general().jbs();
 242     }
 243 
 244     private static Optional&lt;Issue&gt; getIssue(Commit commit, String project) throws IOException {
 245         var message = CommitMessageParsers.v1.parse(commit.message());
 246         var issues = message.issues();
 247         if (issues.isEmpty()) {
 248             return getIssue(message.title(), project);
 249         } else if (issues.size() == 1) {
 250             var issue = issues.get(0);
 251             return getIssue(issue.id(), project);
 252         }
 253         return Optional.empty();
 254     }
 255 
 256     private static Optional&lt;Issue&gt; getIssue(Branch b, String project) throws IOException {
 257         return getIssue(b.name(), project);
 258     }
 259 
 260     private static Optional&lt;Issue&gt; getIssue(String s, String project) throws IOException {
 261         var m = ISSUE_ID_PATTERN.matcher(s);
 262         if (m.matches()) {
 263             var id = m.group(2);
 264             if (project == null) {
 265                 project = m.group(1);
 266             }
 267             var issueTracker = IssueTracker.from(&quot;jira&quot;, URI.create(&quot;https://bugs.openjdk.java.net&quot;));
 268             return issueTracker.project(project).issue(id);
 269         }
 270 
 271         return Optional.empty();
 272     }
 273 
 274     private static void await(Process p) throws IOException {
 275         try {
 276             var res = p.waitFor();
 277             if (res != 0) {
 278                 throw new IOException(&quot;Unexpected exit code &quot; + res);
 279             }
 280         } catch (InterruptedException e) {
 281             throw new IOException(e);
 282         }
 283     }
 284 
 285     private static boolean spawnEditor(ReadOnlyRepository repo, Path file) throws IOException {
 286         String editor = null;
 287         var lines = repo.config(&quot;core.editor&quot;);
 288         if (lines.size() == 1) {
 289             editor = lines.get(0);
 290         }
 291         if (editor == null) {
 292             editor = System.getenv(&quot;GIT_EDITOR&quot;);
 293         }
 294         if (editor == null) {
 295             editor = System.getenv(&quot;EDITOR&quot;);
 296         }
 297         if (editor == null) {
 298             editor = System.getenv(&quot;VISUAL&quot;);
 299         }
 300         if (editor == null) {
 301             editor = &quot;vi&quot;;
 302         }
 303 
 304         var pb = new ProcessBuilder(editor, file.toString());
 305         pb.inheritIO();
 306         var p = pb.start();
 307         try {
 308             return p.waitFor() == 0;
 309         } catch (InterruptedException e) {
 310             throw new IOException(e);
 311         }
 312     }
 313 
 314     private static String projectName(URI uri) {
 315         var name = uri.getPath().toString().substring(1);
 316         if (name.endsWith(&quot;.git&quot;)) {
 317             name = name.substring(0, name.length() - &quot;.git&quot;.length());
 318         }
 319         return name;
 320     }
 321 
 322     private static HostedRepository getHostedRepositoryFor(URI uri, ReadOnlyRepository repo, Forge host) throws IOException {
 323         HostedRepository targetRepo = null;
 324 
 325         try {
 326             var upstream = Remote.toWebURI(repo.pullPath(&quot;upstream&quot;));
 327             targetRepo = host.repository(projectName(upstream)).orElse(null);
 328         } catch (IOException e) {
 329             // do nothing
 330         }
 331 
 332         if (targetRepo == null) {
 333             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 334                     new IOException(&quot;Could not find repository at: &quot; + uri.toString())
 335             );
 336             var parentRepo = remoteRepo.parent();
 337             targetRepo = parentRepo.isPresent() ? parentRepo.get() : remoteRepo;
 338         }
 339 
 340         return targetRepo;
 341     }
 342 
 343     private static PullRequest getPullRequest(URI uri, ReadOnlyRepository repo, Forge host, String prId) throws IOException {
 344         var pr = getHostedRepositoryFor(uri, repo, host).pullRequest(prId);
 345         if (pr == null) {
 346             exit(&quot;error: could not fetch PR information&quot;);
 347         }
 348 
 349         return pr;
 350     }
 351 
 352     private static void show(String ref, Hash hash) throws IOException {
 353         show(ref, hash, null);
 354     }
 355     private static void show(String ref, Hash hash, Path dir) throws IOException {
 356         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 357                                                    &quot;--patch&quot;,
 358                                                    &quot;--find-renames=50%&quot;,
 359                                                    &quot;--find-copies=50%&quot;,
 360                                                    &quot;--find-copies-harder&quot;,
 361                                                    &quot;--abbrev&quot;,
 362                                                    ref + &quot;...&quot; + hash.hex());
 363         if (dir != null) {
 364             pb.directory(dir.toFile());
 365         }
 366         pb.inheritIO();
 367         await(pb.start());
 368     }
 369 
 370     private static void gimport() throws IOException {
 371         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;gimport&quot;);
 372         pb.inheritIO();
 373         await(pb.start());
 374     }
 375 
 376     private static void hgImport(Path patch) throws IOException {
 377         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;import&quot;, &quot;--no-commit&quot;, patch.toAbsolutePath().toString());
 378         pb.inheritIO();
 379         await(pb.start());
 380     }
 381 
 382     private static List&lt;String&gt; hgTags() throws IOException, InterruptedException {
 383         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;tags&quot;, &quot;--quiet&quot;);
 384         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 385         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 386         var p = pb.start();
 387         var bytes = p.getInputStream().readAllBytes();
 388         var exited = p.waitFor(1, TimeUnit.MINUTES);
 389         var exitValue = p.exitValue();
 390         if (!exited || exitValue != 0) {
 391             throw new IOException(&quot;&#39;hg tags&#39; exited with value: &quot; + exitValue);
 392         }
 393 
 394         return Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split(&quot;\n&quot;));
 395     }
 396 
 397     private static String hgResolve(String ref) throws IOException, InterruptedException {
 398         var pb = new ProcessBuilder(&quot;hg&quot;, &quot;log&quot;, &quot;-r&quot;, ref, &quot;--template&quot;, &quot;{node}&quot;);
 399         pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
 400         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 401         var p = pb.start();
 402         var bytes = p.getInputStream().readAllBytes();
 403         var exited = p.waitFor(1, TimeUnit.MINUTES);
 404         var exitValue = p.exitValue();
 405         if (!exited || exitValue != 0) {
 406             throw new IOException(&quot;&#39;hg log&#39; exited with value: &quot; + exitValue);
 407         }
 408 
 409         return new String(bytes, StandardCharsets.UTF_8);
 410     }
 411 
 412     private static Path diff(String ref, Hash hash) throws IOException {
 413         return diff(ref, hash, null);
 414     }
 415 
 416     private static Path diff(String ref, Hash hash, Path dir) throws IOException {
 417         var patch = Files.createTempFile(hash.hex(), &quot;.patch&quot;);
 418         var pb = new ProcessBuilder(&quot;git&quot;, &quot;diff&quot;, &quot;--binary&quot;,
 419                                                    &quot;--patch&quot;,
 420                                                    &quot;--find-renames=50%&quot;,
 421                                                    &quot;--find-copies=50%&quot;,
 422                                                    &quot;--find-copies-harder&quot;,
 423                                                    &quot;--abbrev&quot;,
 424                                                    ref + &quot;...&quot; + hash.hex());
 425         if (dir != null) {
 426             pb.directory(dir.toFile());
 427         }
 428         pb.redirectOutput(patch.toFile());
 429         pb.redirectError(ProcessBuilder.Redirect.INHERIT);
 430         await(pb.start());
 431         return patch;
 432     }
 433 
 434     private static void apply(Path patch) throws IOException {
 435         var pb = new ProcessBuilder(&quot;git&quot;, &quot;apply&quot;, &quot;--no-commit&quot;, patch.toString());
 436         pb.inheritIO();
 437         await(pb.start());
 438     }
 439 
 440     private static int longest(List&lt;String&gt; strings) {
 441         return strings.stream().mapToInt(String::length).max().orElse(0);
 442     }
 443 
 444     private static String removeTrailing(String s, String trail) {
 445         return s.endsWith(trail) ?
 446             s.substring(0, s.length() - trail.length()) :
 447             s;
 448     }
 449 
 450     public static void main(String[] args) throws IOException, InterruptedException {
 451         var flags = List.of(
 452             Option.shortcut(&quot;u&quot;)
 453                   .fullname(&quot;username&quot;)
 454                   .describe(&quot;NAME&quot;)
 455                   .helptext(&quot;Username on host&quot;)
 456                   .optional(),
 457             Option.shortcut(&quot;r&quot;)
 458                   .fullname(&quot;remote&quot;)
 459                   .describe(&quot;NAME&quot;)
 460                   .helptext(&quot;Name of remote, defaults to &#39;origin&#39;&quot;)
 461                   .optional(),
 462             Option.shortcut(&quot;b&quot;)
 463                   .fullname(&quot;branch&quot;)
 464                   .describe(&quot;NAME&quot;)
 465                   .helptext(&quot;Name of target branch, defaults to &#39;master&#39;&quot;)
 466                   .optional(),
 467             Option.shortcut(&quot;&quot;)
 468                   .fullname(&quot;authors&quot;)
 469                   .describe(&quot;LIST&quot;)
 470                   .helptext(&quot;Comma separated list of authors&quot;)
 471                   .optional(),
 472             Option.shortcut(&quot;&quot;)
 473                   .fullname(&quot;assignees&quot;)
 474                   .describe(&quot;LIST&quot;)
 475                   .helptext(&quot;Comma separated list of assignees&quot;)
 476                   .optional(),
 477             Option.shortcut(&quot;&quot;)
 478                   .fullname(&quot;labels&quot;)
 479                   .describe(&quot;LIST&quot;)
 480                   .helptext(&quot;Comma separated list of labels&quot;)
 481                   .optional(),
 482             Option.shortcut(&quot;&quot;)
 483                   .fullname(&quot;issues&quot;)
 484                   .describe(&quot;LIST&quot;)
 485                   .helptext(&quot;Comma separated list of issues&quot;)
 486                   .optional(),
 487             Option.shortcut(&quot;&quot;)
 488                   .fullname(&quot;columns&quot;)
 489                   .describe(&quot;id,title,author,assignees,labels&quot;)
 490                   .helptext(&quot;Comma separated list of columns to show&quot;)
 491                   .optional(),
 492             Switch.shortcut(&quot;&quot;)
 493                   .fullname(&quot;no-decoration&quot;)
 494                   .helptext(&quot;Hide any decorations when listing PRs&quot;)
 495                   .optional(),
 496             Switch.shortcut(&quot;&quot;)
 497                   .fullname(&quot;no-draft&quot;)
 498                   .helptext(&quot;Hide all pull requests in draft state&quot;)
 499                   .optional(),
 500             Switch.shortcut(&quot;&quot;)
 501                   .fullname(&quot;ignore-workspace&quot;)
 502                   .helptext(&quot;Ignore local changes in worktree and staging area when creating pull request&quot;)
 503                   .optional(),
 504             Switch.shortcut(&quot;&quot;)
 505                   .fullname(&quot;ignore-local-commits&quot;)
 506                   .helptext(&quot;Ignore local commits not pushed when creating pull request&quot;)
 507                   .optional(),
 508             Switch.shortcut(&quot;&quot;)
 509                   .fullname(&quot;publish&quot;)
 510                   .helptext(&quot;Publish the local branch before creating the pull request&quot;)
 511                   .optional(),
 512             Switch.shortcut(&quot;&quot;)
 513                   .fullname(&quot;jcheck&quot;)
 514                   .helptext(&quot;Run jcheck before creating the pull request&quot;)
 515                   .optional(),
 516             Switch.shortcut(&quot;&quot;)
 517                   .fullname(&quot;no-token&quot;)
 518                   .helptext(&quot;Do not use a personal access token (PAT). Only works for read-only operations.&quot;)
 519                   .optional(),
 520             Switch.shortcut(&quot;&quot;)
 521                   .fullname(&quot;no-checks&quot;)
 522                   .helptext(&quot;Do not show check status as part of the &#39;git pr status&#39; output&quot;)
 523                   .optional(),
 524             Switch.shortcut(&quot;&quot;)
 525                   .fullname(&quot;mercurial&quot;)
 526                   .helptext(&quot;Force use of Mercurial (hg)&quot;)
 527                   .optional(),
 528             Switch.shortcut(&quot;&quot;)
 529                   .fullname(&quot;verbose&quot;)
 530                   .helptext(&quot;Turn on verbose output&quot;)
 531                   .optional(),
 532             Switch.shortcut(&quot;&quot;)
 533                   .fullname(&quot;debug&quot;)
 534                   .helptext(&quot;Turn on debugging output&quot;)
 535                   .optional(),
 536             Switch.shortcut(&quot;&quot;)
 537                   .fullname(&quot;version&quot;)
 538                   .helptext(&quot;Print the version of this tool&quot;)
 539                   .optional());
 540 
 541         var actions = List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;, &quot;integrate&quot;,
 542                               &quot;approve&quot;, &quot;create&quot;, &quot;close&quot;, &quot;update&quot;, &quot;test&quot;, &quot;status&quot;);
 543         var inputs = List.of(
 544             Input.position(0)
 545                  .describe(String.join(&quot;|&quot;, actions))
 546                  .singular()
 547                  .optional(),
 548             Input.position(1)
 549                  .describe(&quot;ID&quot;)
 550                  .singular()
 551                  .optional()
 552         );
 553 
 554         var parser = new ArgumentParser(&quot;git-pr&quot;, flags, inputs);
 555         var arguments = parser.parse(args);
 556 
 557         if (arguments.contains(&quot;version&quot;)) {
 558             System.out.println(&quot;git-pr version: &quot; + Version.fromManifest().orElse(&quot;unknown&quot;));
 559             System.exit(0);
 560         }
 561 
 562         if (arguments.contains(&quot;verbose&quot;) || arguments.contains(&quot;debug&quot;)) {
 563             var level = arguments.contains(&quot;debug&quot;) ? Level.FINER : Level.FINE;
 564             Logging.setup(level);
 565         }
 566 
 567         HttpProxy.setup();
 568 
 569         var isMercurial = getSwitch(&quot;mercurial&quot;, arguments);
 570         var cwd = Path.of(&quot;&quot;).toAbsolutePath();
 571         var repo = Repository.get(cwd).orElseThrow(() -&gt; new IOException(&quot;no git repository found at &quot; + cwd.toString()));
 572         var remote = getOption(&quot;remote&quot;, arguments);
 573         if (remote == null) {
 574             remote = isMercurial ? &quot;default&quot; : &quot;origin&quot;;
 575         }
 576         var remotePullPath = repo.pullPath(remote);
 577         var username = getOption(&quot;username&quot;, arguments);
 578         var token = isMercurial ? System.getenv(&quot;HG_TOKEN&quot;) : System.getenv(&quot;GIT_TOKEN&quot;);
 579         var uri = Remote.toWebURI(remotePullPath);
 580         var shouldUseToken = !getSwitch(&quot;no-token&quot;, arguments);
 581         var credentials = !shouldUseToken ?
 582             null :
 583             GitCredentials.fill(uri.getHost(), uri.getPath(), username, token, uri.getScheme());
 584         var forgeURI = URI.create(uri.getScheme() + &quot;://&quot; + uri.getHost());
 585         var forge = credentials == null ?
 586             Forge.from(forgeURI) :
 587             Forge.from(forgeURI, new Credential(credentials.username(), credentials.password()));
 588         if (forge.isEmpty()) {
 589             if (!shouldUseToken) {
 590                 if (arguments.contains(&quot;verbose&quot;)) {
 591                     System.err.println(&quot;&quot;);
 592                 }
 593                 System.err.println(&quot;warning: using git-pr with --no-token may result in rate limiting from &quot; + forgeURI);
 594                 if (!arguments.contains(&quot;verbose&quot;)) {
 595                     System.err.println(&quot;         Re-run git-pr with --verbose to see if you are being rate limited&quot;);
 596                     System.err.println(&quot;&quot;);
 597                 }
 598             }
 599             exit(&quot;error: failed to connect to host: &quot; + forgeURI);
 600         }
 601         var host = forge.get();
 602 
 603         var action = arguments.at(0).isPresent() ? arguments.at(0).asString() : null;
 604         if (action == null) {
 605             var lines = repo.config(&quot;pr.default&quot;);
 606             if (lines.size() == 1) {
 607                 action = lines.get(0);
 608             }
 609         }
 610 
 611         if (action == null) {
 612             System.err.println(&quot;error: you must supply a valid action:&quot;);
 613             for (var a : actions) {
 614                 System.err.println(&quot;       - &quot; + a);
 615             }
 616             System.err.println(&quot;You can also configure a default action by running &#39;git configure --global pr.default &lt;action&gt;&#39;&quot;);
 617             System.exit(1);
 618         }
 619 
 620         if (!shouldUseToken &amp;&amp;
 621             !List.of(&quot;list&quot;, &quot;fetch&quot;, &quot;show&quot;, &quot;checkout&quot;, &quot;apply&quot;).contains(action)) {
 622             System.err.println(&quot;error: --no-token can only be used with read-only operations&quot;);
 623             System.exit(1);
 624         }
 625 
 626         if (action.equals(&quot;create&quot;)) {
 627             if (isMercurial) {
 628                 var currentBookmark = repo.currentBookmark();
 629                 if (!currentBookmark.isPresent()) {
 630                     System.err.println(&quot;error: no bookmark is active, you must be on an active bookmark&quot;);
 631                     System.err.println(&quot;&quot;);
 632                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 633                     System.err.println(&quot;&quot;);
 634                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 635                     System.err.println(&quot;&quot;);
 636                     System.exit(1);
 637                 }
 638 
 639                 var bookmark = currentBookmark.get();
 640                 if (bookmark.equals(new Bookmark(&quot;master&quot;))) {
 641                     System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; bookmark&quot;);
 642                     System.err.println(&quot;To create a bookmark and activate it, run:&quot;);
 643                     System.err.println(&quot;&quot;);
 644                     System.err.println(&quot;    hg bookmark NAME-FOR-YOUR-BOOKMARK&quot;);
 645                     System.err.println(&quot;&quot;);
 646                     System.exit(1);
 647                 }
 648 
 649                 var tags = hgTags();
 650                 var upstreams = tags.stream()
 651                                     .filter(t -&gt; t.endsWith(bookmark.name()))
 652                                     .collect(Collectors.toList());
 653                 if (upstreams.isEmpty()) {
 654                     System.err.println(&quot;error: there is no remote branch for the local bookmark &#39;&quot; + bookmark.name() + &quot;&#39;&quot;);
 655                     System.err.println(&quot;&quot;);
 656                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 657                     System.err.println(&quot;&quot;);
 658                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name());
 659                     System.err.println(&quot;&quot;);
 660                     System.exit(1);
 661                 }
 662 
 663                 var tagsAndHashes = new HashMap&lt;String, String&gt;();
 664                 for (var tag : tags) {
 665                     tagsAndHashes.put(tag, hgResolve(tag));
 666                 }
 667                 var bookmarkHash = hgResolve(bookmark.name());
 668                 if (!tagsAndHashes.containsValue(bookmarkHash)) {
 669                     System.err.println(&quot;error: there are local commits on bookmark &#39;&quot; + bookmark.name() + &quot;&#39; not present in a remote repository&quot;);
 670                     System.err.println(&quot;&quot;);
 671 
 672                     if (upstreams.size() == 1) {
 673                         System.err.println(&quot;To push the local commits to the remote repository, run:&quot;);
 674                         System.err.println(&quot;&quot;);
 675                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &quot; + upstreams.get(0));
 676                         System.err.println(&quot;&quot;);
 677                     } else {
 678                         System.err.println(&quot;The following paths contains the &quot; + bookmark.name() + &quot; bookmark:&quot;);
 679                         System.err.println(&quot;&quot;);
 680                         for (var upstream : upstreams) {
 681                             System.err.println(&quot;- &quot; + upstream.replace(&quot;/&quot; + bookmark.name(), &quot;&quot;));
 682                         }
 683                         System.err.println(&quot;&quot;);
 684                         System.err.println(&quot;To push the local commits to a remote repository, run:&quot;);
 685                         System.err.println(&quot;&quot;);
 686                         System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 687                         System.err.println(&quot;&quot;);
 688                     }
 689                     System.exit(1);
 690                 }
 691 
 692                 var targetBranch = arguments.get(&quot;branch&quot;).orString(&quot;master&quot;);
 693                 var targetHash = hgResolve(targetBranch);
 694                 var commits = repo.commits(targetHash + &quot;..&quot; + bookmarkHash + &quot;-&quot; + targetHash).asList();
 695                 if (commits.isEmpty()) {
 696                     System.err.println(&quot;error: no difference between bookmarks &quot; + targetBranch + &quot; and &quot; + bookmark.name());
 697                     System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 698                     System.exit(1);
 699                 }
 700 
 701                 var diff = repo.diff(repo.head());
 702                 if (!diff.patches().isEmpty()) {
 703                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 704                     System.err.println(&quot;&quot;);
 705                     for (var patch : diff.patches()) {
 706                         var path = patch.target().path().isPresent() ?
 707                             patch.target().path().get() : patch.source().path().get();
 708                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 709                     }
 710                     System.err.println(&quot;&quot;);
 711                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 712                     System.err.println(&quot;&quot;);
 713                     System.err.println(&quot;    hg commit --amend&quot;);
 714                     System.err.println(&quot;    hg git-cleanup&quot;);
 715                     System.err.println(&quot;    hg push --bookmark &quot; + bookmark.name() + &quot; &lt;PATH&gt;&quot;);
 716                     System.err.println(&quot;    hg gimport&quot;);
 717                     System.err.println(&quot;&quot;);
 718                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 719                     System.err.println(&quot;&quot;);
 720                     System.err.println(&quot;    hg shelve&quot;);
 721                     System.err.println(&quot;&quot;);
 722                     System.err.println(&quot;(You can later restore the changes by running: hg unshelve)&quot;);
 723                     System.exit(1);
 724                 }
 725 
 726                 var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 727                         new IOException(&quot;Could not find repository at &quot; + uri.toString())
 728                 );
 729                 if (token == null) {
 730                     GitCredentials.approve(credentials);
 731                 }
 732                 var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 733                         new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 734 
 735                 var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.txt&quot;);
 736                 if (commits.size() == 1) {
 737                     var commit = commits.get(0);
 738                     var message = CommitMessageParsers.v1.parse(commit.message());
 739                     Files.writeString(file, message.title() + &quot;\n&quot;);
 740                     if (!message.summaries().isEmpty()) {
 741                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 742                     }
 743                     if (!message.additional().isEmpty()) {
 744                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 745                     }
 746                 } else {
 747                     Files.write(file, List.of(&quot;&quot;));
 748                 }
 749                 Files.write(file, List.of(
 750                     &quot;# Please enter the pull request message for your changes. Lines starting&quot;,
 751                     &quot;# with &#39;#&#39; will be ignored, and an empty message aborts the pull request.&quot;,
 752                     &quot;# The first line will be considered the subject, use a blank line to separate&quot;,
 753                     &quot;# the subject from the body.&quot;,
 754                     &quot;#&quot;,
 755                     &quot;# Commits to be included from branch &#39;&quot; + bookmark.name() + &quot;&#39;&quot;
 756                     ),
 757                     StandardOpenOption.APPEND
 758                 );
 759                 for (var commit : commits) {
 760                     var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 761                     Files.writeString(file, &quot;# - &quot; + desc + &quot;\n&quot;, StandardOpenOption.APPEND);
 762                 }
 763                 Files.writeString(file, &quot;#\n&quot;, StandardOpenOption.APPEND);
 764                 Files.writeString(file, &quot;# Target repository: &quot; + remotePullPath + &quot;\n&quot;, StandardOpenOption.APPEND);
 765                 Files.writeString(file, &quot;# Target branch: &quot; + targetBranch + &quot;\n&quot;, StandardOpenOption.APPEND);
 766                 var success = spawnEditor(repo, file);
 767                 if (!success) {
 768                     System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 769                     System.exit(1);
 770                 }
 771                 var lines = Files.readAllLines(file)
 772                                  .stream()
 773                                  .filter(l -&gt; !l.startsWith(&quot;#&quot;))
 774                                  .collect(Collectors.toList());
 775                 var isEmpty = lines.stream().allMatch(String::isEmpty);
 776                 if (isEmpty) {
 777                     System.err.println(&quot;error: no message present, aborting&quot;);
 778                     System.exit(1);
 779                 }
 780 
 781                 var title = lines.get(0);
 782                 List&lt;String&gt; body = null;
 783                 if (lines.size() &gt; 1) {
 784                     body = lines.subList(1, lines.size())
 785                                 .stream()
 786                                 .dropWhile(String::isEmpty)
 787                                 .collect(Collectors.toList());
 788                 } else {
 789                     body = Collections.emptyList();
 790                 }
 791 
 792                 var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, bookmark.name(), title, body);
 793                 if (arguments.contains(&quot;assignees&quot;)) {
 794                     var usernames = Arrays.asList(arguments.get(&quot;assignees&quot;).asString().split(&quot;,&quot;));
 795                     var assignees = usernames.stream()
 796                                              .map(u -&gt; host.user(u))
 797                                              .collect(Collectors.toList());
 798                     pr.setAssignees(assignees);
 799                 }
 800                 System.out.println(pr.webUrl().toString());
 801                 Files.deleteIfExists(file);
 802 
 803                 System.exit(0);
 804             }
 805             var currentBranch = repo.currentBranch().orElseGet(() -&gt; {
 806                     System.err.println(&quot;error: the repository is in a detached HEAD state&quot;);
 807                     System.exit(1);
 808                     return null;
 809             });
 810             if (currentBranch.equals(repo.defaultBranch())) {
 811                 System.err.println(&quot;error: you should not create pull requests from the &#39;master&#39; branch&quot;);
 812                 System.err.println(&quot;&quot;);
 813                 System.err.println(&quot;To create a local branch for your changes and restore the &#39;master&#39; branch, run:&quot;);
 814                 System.err.println(&quot;&quot;);
 815                 System.err.println(&quot;    git checkout -b NAME-FOR-YOUR-LOCAL-BRANCH&quot;);
 816                 System.err.println(&quot;    git branch --force master origin/master&quot;);
 817                 System.err.println(&quot;&quot;);
 818                 System.exit(1);
 819             }
 820 
 821             var ignoreWorkspace = getSwitch(&quot;ignore-workspace&quot;, &quot;create&quot;, arguments);
 822             if (!ignoreWorkspace) {
 823                 var diff = repo.diff(repo.head());
 824                 if (!diff.patches().isEmpty()) {
 825                     System.err.println(&quot;error: there are uncommitted changes in your working tree:&quot;);
 826                     System.err.println(&quot;&quot;);
 827                     for (var patch : diff.patches()) {
 828                         var path = patch.target().path().isPresent() ?
 829                             patch.target().path().get() : patch.source().path().get();
 830                         System.err.println(&quot;    &quot; + patch.status().toString() + &quot; &quot; + path.toString());
 831                     }
 832                     System.err.println(&quot;&quot;);
 833                     System.err.println(&quot;If these changes are meant to be part of the pull request, run:&quot;);
 834                     System.err.println(&quot;&quot;);
 835                     System.err.println(&quot;    git commit -am &#39;Forgot to add some changes&#39;&quot;);
 836                     System.err.println(&quot;&quot;);
 837                     System.err.println(&quot;If these changes are *not* meant to be part of the pull request, run:&quot;);
 838                     System.err.println(&quot;&quot;);
 839                     System.err.println(&quot;    git stash&quot;);
 840                     System.err.println(&quot;&quot;);
 841                     System.err.println(&quot;(You can later restore the changes by running: git stash pop)&quot;);
 842                     System.exit(1);
 843                 }
 844             }
 845 
 846             var upstream = repo.upstreamFor(currentBranch);
 847             if (upstream.isEmpty()) {
 848                 var shouldPublish = getSwitch(&quot;publish&quot;, &quot;create&quot;, arguments);
 849                 if (shouldPublish) {
 850                     GitPublish.main(new String[] { &quot;--quiet&quot;, remote });
 851                     upstream = repo.upstreamFor(currentBranch);
 852                 } else {
 853                     System.err.println(&quot;error: there is no remote branch for the local branch &#39;&quot; + currentBranch.name() + &quot;&#39;&quot;);
 854                     System.err.println(&quot;&quot;);
 855                     System.err.println(&quot;A remote branch must be present at &quot; + remotePullPath + &quot; to create a pull request&quot;);
 856                     System.err.println(&quot;To create a remote branch and push the commits for your local branch, run:&quot;);
 857                     System.err.println(&quot;&quot;);
 858                     System.err.println(&quot;    git publish&quot;);
 859                     System.err.println(&quot;&quot;);
 860                     System.err.println(&quot;If you created the remote branch from another client, you must update this repository.&quot;);
 861                     System.err.println(&quot;To update remote information for this repository, run:&quot;);
 862                     System.err.println(&quot;&quot;);
 863                     System.err.println(&quot;    git fetch &quot; + remote);
 864                     System.err.println(&quot;    git branch --set-upstream &quot; + currentBranch + &quot; &quot; + remote + &quot;/&quot; + currentBranch);
 865                     System.err.println(&quot;&quot;);
 866                     System.exit(1);
 867                 }
 868             }
 869 
 870             var upstreamRefName = upstream.get().substring(remote.length() + 1);
 871             repo.fetch(uri, upstreamRefName);
 872 
 873             var shouldIgnoreLocalCommits = getSwitch(&quot;ignore-local-commits&quot;, &quot;create&quot;, arguments);
 874             if (!shouldIgnoreLocalCommits) {
 875                 var branchCommits = repo.commits(upstream.get() + &quot;..&quot; + currentBranch.name()).asList();
 876                 if (!branchCommits.isEmpty()) {
 877                     System.err.println(&quot;error: there are local commits on branch &#39;&quot; + currentBranch.name() + &quot;&#39; not present in the remote repository &quot; + remotePullPath);
 878                     System.err.println(&quot;&quot;);
 879                     System.err.println(&quot;All commits must be present in the remote repository to be part of the pull request&quot;);
 880                     System.err.println(&quot;The following commits are not present in the remote repository:&quot;);
 881                     System.err.println(&quot;&quot;);
 882                     for (var commit : branchCommits) {
 883                         System.err.println(&quot;- &quot; + commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0));
 884                     }
 885                     System.err.println(&quot;&quot;);
 886                     System.err.println(&quot;To push the above local commits to the remote repository, run:&quot;);
 887                     System.err.println(&quot;&quot;);
 888                     System.err.println(&quot;    git push &quot; + remote + &quot; &quot; + currentBranch.name());
 889                     System.err.println(&quot;&quot;);
 890                     System.exit(1);
 891                 }
 892             }
 893 
 894             var targetBranch = getOption(&quot;branch&quot;, &quot;create&quot;, arguments);
 895             if (targetBranch == null) {
 896                 targetBranch = &quot;master&quot;;
 897             }
 898             var commits = repo.commits(targetBranch + &quot;..&quot; + upstream.get()).asList();
 899             if (commits.isEmpty()) {
 900                 System.err.println(&quot;error: no difference between branches &quot; + targetBranch + &quot; and &quot; + currentBranch.name());
 901                 System.err.println(&quot;       Cannot create an empty pull request, have you committed?&quot;);
 902                 System.exit(1);
 903             }
 904 
 905             var shouldRunJCheck = getSwitch(&quot;jcheck&quot;, &quot;create&quot;, arguments);
 906             if (shouldRunJCheck) {
 907                 var jcheckArgs = new String[]{ &quot;--pull-request&quot;, &quot;--rev&quot;, targetBranch + &quot;..&quot; + upstream.get() };
 908                 var err = GitJCheck.run(jcheckArgs);
 909                 if (err != 0) {
 910                     System.exit(err);
 911                 }
 912             }
 913 
 914             var remoteRepo = host.repository(projectName(uri)).orElseThrow(() -&gt;
 915                     new IOException(&quot;Could not find repository at &quot; + uri.toString())
 916             );
 917             if (token == null) {
 918                 GitCredentials.approve(credentials);
 919             }
 920             var parentRepo = remoteRepo.parent().orElseThrow(() -&gt;
 921                     new IOException(&quot;error: remote repository &quot; + remotePullPath + &quot; is not a fork of any repository&quot;));
 922 
 923             var project = jbsProjectFromJcheckConf(repo);
 924             var issue = getIssue(currentBranch, project);
 925             var file = Files.createTempFile(&quot;PULL_REQUEST_&quot;, &quot;.md&quot;);
 926             if (issue.isPresent()) {
 927                 Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 928             } else if (commits.size() == 1) {
 929                 var commit = commits.get(0);
 930                 issue = getIssue(commit, project);
 931                 if (issue.isPresent()) {
 932                     Files.writeString(file, format(issue.get()) + &quot;\n\n&quot;);
 933                 } else {
 934                     var message = CommitMessageParsers.v1.parse(commit.message());
 935                     Files.writeString(file, message.title() + &quot;\n&quot;);
 936                     if (!message.summaries().isEmpty()) {
 937                         Files.write(file, message.summaries(), StandardOpenOption.APPEND);
 938                     }
 939                     if (!message.additional().isEmpty()) {
 940                         Files.write(file, message.additional(), StandardOpenOption.APPEND);
 941                     }
 942                 }
 943             } else {
 944                 Files.write(file, List.of(&quot;&quot;));
 945             }
 946 
 947             appendPaddedHTMLComment(file, &quot;Please enter the pull request message for your changes.&quot;);
 948             appendPaddedHTMLComment(file, &quot;The first line will be considered the subject, use a blank line to&quot;);
 949             appendPaddedHTMLComment(file, &quot;separate the subject from the body. These HTML comment lines will&quot;);
 950             appendPaddedHTMLComment(file, &quot;be removed automatically. An empty message aborts the pull request.&quot;);
 951             appendPaddedHTMLComment(file, &quot;&quot;);
 952             appendPaddedHTMLComment(file, &quot;Commits to be included from branch &#39;&quot; + currentBranch.name() + &quot;&#39;:&quot;);
 953             for (var commit : commits) {
 954                 var desc = commit.hash().abbreviate() + &quot;: &quot; + commit.message().get(0);
 955                 appendPaddedHTMLComment(file, &quot;- &quot; + desc);
 956                 if (!commit.isMerge()) {
 957                     var diff = commit.parentDiffs().get(0);
 958                     for (var patch : diff.patches()) {
 959                         var status = patch.status();
 960                         if (status.isModified()) {
 961                             appendPaddedHTMLComment(file, &quot;  M  &quot; + patch.target().path().get().toString());
 962                         } else if (status.isAdded()) {
 963                             appendPaddedHTMLComment(file, &quot;  A  &quot; + patch.target().path().get().toString());
 964                         } else if (status.isDeleted()) {
 965                             appendPaddedHTMLComment(file, &quot;  D  &quot; + patch.source().path().get().toString());
 966                         } else if (status.isRenamed()) {
 967                             appendPaddedHTMLComment(file, &quot;  R  &quot; + patch.target().path().get().toString());
 968                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 969                         } else if (status.isCopied()) {
 970                             appendPaddedHTMLComment(file, &quot;  C  &quot; + patch.target().path().get().toString());
 971                             appendPaddedHTMLComment(file, &quot;      (&quot; + patch.source().path().get().toString() + &quot;)&quot;);
 972                         }
 973                     }
 974                 }
 975             }
 976             appendPaddedHTMLComment(file, &quot;&quot;);
 977             if (issue.isPresent()) {
 978                 appendPaddedHTMLComment(file, &quot;Issue:      &quot; + issue.get().webUrl());
 979             }
 980             appendPaddedHTMLComment(file, &quot;Repository: &quot; + parentRepo.webUrl());
 981             appendPaddedHTMLComment(file, &quot;Branch:     &quot; + targetBranch);
 982 
 983             var success = spawnEditor(repo, file);
 984             if (!success) {
 985                 System.err.println(&quot;error: editor exited with non-zero status code, aborting&quot;);
 986                 System.exit(1);
 987             }
 988             var lines = Files.readAllLines(file)
 989                              .stream()
 990                              .filter(l -&gt; !(l.startsWith(&quot;&lt;!--&quot;) &amp;&amp; l.endsWith(&quot;--&gt;&quot;)))
 991                              .collect(Collectors.toList());
 992             var isEmpty = lines.stream().allMatch(String::isEmpty);
 993             if (isEmpty) {
 994                 System.err.println(&quot;error: no message present, aborting&quot;);
 995                 System.exit(1);
 996             }
 997 
 998             var title = lines.get(0);
 999             List&lt;String&gt; body = null;
1000             if (lines.size() &gt; 1) {
1001                 body = lines.subList(1, lines.size())
1002                             .stream()
1003                             .dropWhile(String::isEmpty)
1004                             .collect(Collectors.toList());
1005             } else {
1006                 body = Collections.emptyList();
1007             }
1008 
1009             var pr = remoteRepo.createPullRequest(parentRepo, targetBranch, currentBranch.name(), title, body);
1010             var assigneesOption = getOption(&quot;assignees&quot;, &quot;create&quot;, arguments);
1011             if (assigneesOption != null) {
1012                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1013                 var assignees = usernames.stream()
1014                                          .map(u -&gt; host.user(u))
1015                                          .collect(Collectors.toList());
1016                 pr.setAssignees(assignees);
1017             }
1018             System.out.println(pr.webUrl().toString());
1019             Files.deleteIfExists(file);
1020 
1021             repo.config(&quot;pr.&quot; + currentBranch.name(), &quot;id&quot;, pr.id().toString());
1022         } else if (action.equals(&quot;integrate&quot;)) {
1023             var id = pullRequestIdArgument(arguments, repo);
1024             var pr = getPullRequest(uri, repo, host, id);
1025             var integrateComment = pr.addComment(&quot;/integrate&quot;);
1026 
1027             var seenIntegrateComment = false;
1028             var expected = &quot;&lt;!-- Jmerge command reply message (&quot; + integrateComment.id() + &quot;) --&gt;&quot;;
1029             for (var i = 0; i &lt; 90; i++) {
1030                 var comments = pr.comments();
1031                 for (var comment : comments) {
1032                     if (!seenIntegrateComment) {
1033                         if (comment.id().equals(integrateComment.id())) {
1034                             seenIntegrateComment = true;
1035                         }
1036                         continue;
1037                     }
1038                     var lines = comment.body().split(&quot;\n&quot;);
1039                     if (lines.length &gt; 0 &amp;&amp; lines[0].equals(expected)) {
1040                         if (lines.length == 3 &amp;&amp; lines[2].startsWith(&quot;Pushed as commit&quot;)) {
1041                             var output = removeTrailing(lines[2], &quot;.&quot;);
1042                             System.out.println(output);
1043                             System.exit(0);
1044                         }
1045                     }
1046                 }
1047 
1048                 Thread.sleep(2000);
1049             }
1050 
1051             System.err.println(&quot;error: timed out waiting for response to /integrate command&quot;);
1052             System.exit(1);
1053         } else if (action.equals(&quot;test&quot;)) {
1054             var id = pullRequestIdArgument(arguments, repo);
1055             var pr = getPullRequest(uri, repo, host, id);
1056             var head = pr.headHash();
1057             var testComment = pr.addComment(&quot;/test&quot;);
1058 
1059             var seenTestComment = false;
1060             for (var i = 0; i &lt; 90; i++) {
1061                 var comments = pr.comments();
1062                 for (var comment : comments) {
1063                     if (!seenTestComment) {
1064                         if (comment.id().equals(testComment.id())) {
1065                             seenTestComment = true;
1066                         }
1067                         continue;
1068                     }
1069                     var lines = comment.body().split(&quot;\n&quot;);
1070                     var n = lines.length;
1071                     if (n &gt; 0) {
1072                         if (n == 4 &amp;&amp;
1073                             lines[0].equals(&quot;&lt;!-- TEST STARTED --&gt;&quot;) &amp;&amp;
1074                             lines[1].startsWith(&quot;&lt;!-- github.com-&quot;) &amp;&amp;
1075                             lines[2].equals(&quot;&lt;!-- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1076                             var output = removeTrailing(lines[3], &quot;.&quot;);
1077                             System.out.println(output);
1078                             System.exit(0);
1079                         } else if (n == 2 &amp;&amp;
1080                                    lines[0].equals(&quot;&lt;!-- TEST ERROR --&gt;&quot;)) {
1081                             var output = removeTrailing(lines[1], &quot;.&quot;);
1082                             System.out.println(output);
1083                             System.exit(1);
1084                         } else if (n == 4 &amp;&amp;
1085                                    lines[0].equals(&quot;&lt;!-- TEST PENDING --&gt;&quot;) &amp;&amp;
1086                                    lines[1].equals(&quot;&lt;!--- &quot; + head.hex() + &quot; --&gt;&quot;)) {
1087                             var output = removeTrailing(lines[3], &quot;.&quot;);
1088                             System.out.println(output);
1089                             System.exit(0);
1090                         }
1091                     }
1092                 }
1093 
1094                 Thread.sleep(2000);
1095             }
1096 
1097         } else if (action.equals(&quot;approve&quot;)) {
1098             var id = arguments.at(1).isPresent() ? arguments.at(1).asString() : null;
1099             if (id == null) {
1100                 exit(&quot;error: you must provide a pull request id&quot;);
1101             }
1102             var pr = getPullRequest(uri, repo, host, id);
1103             pr.addReview(Review.Verdict.APPROVED, &quot;Looks good!&quot;);
1104         } else if (action.equals(&quot;list&quot;)) {
1105             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1106             var prs = remoteRepo.pullRequests();
1107             var ids = new ArrayList&lt;String&gt;();
1108             var titles = new ArrayList&lt;String&gt;();
1109             var authors = new ArrayList&lt;String&gt;();
1110             var assignees = new ArrayList&lt;String&gt;();
1111             var labels = new ArrayList&lt;String&gt;();
1112             var issues = new ArrayList&lt;String&gt;();
1113             var branches = new ArrayList&lt;String&gt;();
1114             var statuses = new ArrayList&lt;String&gt;();
1115             var noDraft = getSwitch(&quot;no-draft&quot;, &quot;list&quot;, arguments);
1116 
1117             var authorsOption = getOption(&quot;authors&quot;, &quot;list&quot;, arguments);
1118             var filterAuthors = authorsOption == null ?
1119                 Set.of() :
1120                 new HashSet&lt;&gt;(Arrays.asList(authorsOption.split(&quot;,&quot;)));
1121 
1122             var assigneesOption = getOption(&quot;assignees&quot;, &quot;list&quot;, arguments);
1123             var filterAssignees = assigneesOption == null ?
1124                 Set.of() :
1125                 Arrays.asList(assigneesOption.split(&quot;,&quot;));
1126 
1127             var labelsOption = getOption(&quot;labels&quot;, &quot;list&quot;, arguments);
1128             var filterLabels = labelsOption == null ?
1129                 Set.of() :
1130                 Arrays.asList(labelsOption.split(&quot;,&quot;));
1131 
1132             var issuesOption = getOption(&quot;issues&quot;, &quot;list&quot;, arguments);
1133             var filterIssues = issuesOption == null ?
1134                 Set.of() :
1135                 Arrays.asList(issuesOption.split(&quot;,&quot;));
1136 
1137             var columnTitles = List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;assignees&quot;, &quot;labels&quot;, &quot;issues&quot;, &quot;branch&quot;, &quot;status&quot;);
1138             var columnValues = Map.of(columnTitles.get(0), ids,
1139                                       columnTitles.get(1), titles,
1140                                       columnTitles.get(2), authors,
1141                                       columnTitles.get(3), assignees,
1142                                       columnTitles.get(4), labels,
1143                                       columnTitles.get(5), issues,
1144                                       columnTitles.get(6), branches,
1145                                       columnTitles.get(7), statuses);
1146             var columnsOption = getOption(&quot;columns&quot;, &quot;list&quot;, arguments);
1147             var columns = columnsOption == null ?
1148                 List.of(&quot;id&quot;, &quot;title&quot;, &quot;authors&quot;, &quot;status&quot;) :
1149                 Arrays.asList(columnsOption.split(&quot;,&quot;));
1150 
1151             for (var column : columns) {
1152                 if (!columnTitles.contains(column)) {
1153                     System.err.println(&quot;error: unknown column: &quot; + column);
1154                     System.err.println(&quot;       available columns are: &quot; + String.join(&quot;,&quot;, columnTitles));
1155                     System.exit(1);
1156                 }
1157             }
1158 
1159             for (var pr : prs) {
1160                 if (pr.isDraft() &amp;&amp; noDraft) {
1161                     continue;
1162                 }
1163 
1164                 var prAuthor = pr.author().userName();
1165                 if (!filterAuthors.isEmpty() &amp;&amp; !filterAuthors.contains(prAuthor)) {
1166                     continue;
1167                 }
1168 
1169                 var prAssignees = pr.assignees().stream()
1170                                     .map(HostUser::userName)
1171                                     .collect(Collectors.toSet());
1172                 if (!filterAssignees.isEmpty() &amp;&amp; !filterAssignees.stream().anyMatch(prAssignees::contains)) {
1173                     continue;
1174                 }
1175 
1176                 var prLabels = new HashSet&lt;&gt;(pr.labels());
1177                 if (!filterLabels.isEmpty() &amp;&amp; !filterLabels.stream().anyMatch(prLabels::contains)) {
1178                     continue;
1179                 }
1180 
1181                 var prIssues = new HashSet&lt;&gt;(issuesFromPullRequest(pr));
1182                 if (!filterIssues.isEmpty() &amp;&amp; !filterIssues.stream().anyMatch(prIssues::contains)) {
1183                     continue;
1184                 }
1185 
1186 
1187                 ids.add(pr.id());
1188                 titles.add(pr.title());
1189                 authors.add(prAuthor);
1190                 assignees.add(String.join(&quot;,&quot;, prAssignees));
1191                 labels.add(String.join(&quot;,&quot;, prLabels));
1192                 issues.add(String.join(&quot;,&quot;, prIssues));
1193 
1194                 if (pr.author().userName().equals(credentials.username()) &amp;&amp;
1195                     pr.sourceRepository().webUrl().equals(uri)) {
1196                     branches.add(pr.sourceRef());
1197                 } else {
1198                     branches.add(&quot;&quot;);
1199                 }
1200 
1201                 if (columns.contains(&quot;status&quot;)) {
1202                     statuses.add(statusForPullRequest(pr).toLowerCase());
1203                 } else {
1204                     statuses.add(&quot;&quot;);
1205                 }
1206             }
1207 
1208 
1209             String fmt = &quot;&quot;;
1210             for (var column : columns.subList(0, columns.size() - 1)) {
1211                 var values = columnValues.get(column);
1212                 var n = Math.max(column.length(), longest(values));
1213                 fmt += &quot;%-&quot; + n + &quot;s    &quot;;
1214             }
1215             fmt += &quot;%s\n&quot;;
1216 
1217             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;list&quot;, arguments);
1218             if (!ids.isEmpty() &amp;&amp; !noDecoration) {
1219                 var upperCase = columns.stream()
1220                                        .map(String::toUpperCase)
1221                                        .collect(Collectors.toList());
1222                 System.out.format(fmt, (Object[]) upperCase.toArray(new String[0]));
1223             }
1224             for (var i = 0; i &lt; ids.size(); i++) {
1225                 final int n = i;
1226                 var row = columns.stream()
1227                                  .map(columnValues::get)
1228                                  .map(values -&gt; values.get(n))
1229                                  .collect(Collectors.toList());
1230                 System.out.format(fmt, (Object[]) row.toArray(new String[0]));
1231             }
1232         } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;) || action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1233             var prId = arguments.at(1);
1234             if (!prId.isPresent()) {
1235                 exit(&quot;error: missing pull request identifier&quot;);
1236             }
1237 
1238             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1239             var pr = remoteRepo.pullRequest(prId.asString());
1240             var repoUrl = remoteRepo.webUrl();
1241             var prHeadRef = pr.fetchRef();
1242             var isHgGit = isMercurial &amp;&amp; Repository.exists(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;));
1243             if (isHgGit) {
1244                 var hgGitRepo = Repository.get(repo.root().resolve(&quot;.hg&quot;).resolve(&quot;git&quot;)).get();
1245                 var hgGitFetchHead = hgGitRepo.fetch(repoUrl, prHeadRef);
1246 
1247                 if (action.equals(&quot;show&quot;) || action.equals(&quot;apply&quot;)) {
1248                     var target = hgGitRepo.fetch(repoUrl, pr.targetRef());
1249                     var hgGitMergeBase = hgGitRepo.mergeBase(target, hgGitFetchHead);
1250 
1251                     if (action.equals(&quot;show&quot;)) {
1252                         show(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1253                     } else {
1254                         var patch = diff(hgGitMergeBase.hex(), hgGitFetchHead, hgGitRepo.root());
1255                         hgImport(patch);
1256                         Files.delete(patch);
1257                     }
1258                 } else if (action.equals(&quot;fetch&quot;) || action.equals(&quot;checkout&quot;)) {
1259                     var hgGitRef = prHeadRef.endsWith(&quot;/head&quot;) ? prHeadRef.replace(&quot;/head&quot;, &quot;&quot;) : prHeadRef;
1260                     var hgGitBranches = hgGitRepo.branches();
1261                     if (hgGitBranches.contains(new Branch(hgGitRef))) {
1262                         hgGitRepo.delete(new Branch(hgGitRef));
1263                     }
1264                     hgGitRepo.branch(hgGitFetchHead, hgGitRef);
1265                     gimport();
1266                     var hgFetchHead = repo.resolve(hgGitRef).get();
1267 
1268                     if (action.equals(&quot;fetch&quot;) &amp;&amp; arguments.contains(&quot;branch&quot;)) {
1269                         repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1270                     } else if (action.equals(&quot;checkout&quot;)) {
1271                         repo.checkout(hgFetchHead);
1272                         if (arguments.contains(&quot;branch&quot;)) {
1273                             repo.branch(hgFetchHead, arguments.get(&quot;branch&quot;).asString());
1274                         }
1275                     }
1276                 } else {
1277                     exit(&quot;Unexpected action: &quot; + action);
1278                 }
1279 
1280                 return;
1281             }
1282 
1283             var fetchHead = repo.fetch(repoUrl, pr.fetchRef());
1284             if (action.equals(&quot;fetch&quot;)) {
1285                 var branchName = getOption(&quot;branch&quot;, &quot;fetch&quot;, arguments);
1286                 if (branchName != null) {
1287                     repo.branch(fetchHead, branchName);
1288                 } else {
1289                     System.out.println(fetchHead.hex());
1290                 }
1291             } else if (action.equals(&quot;checkout&quot;)) {
1292                 var branchName = getOption(&quot;branch&quot;, &quot;checkout&quot;, arguments);
1293                 if (branchName != null) {
1294                     var branch = repo.branch(fetchHead, branchName);
1295                     repo.checkout(branch, false);
1296                 } else {
1297                     repo.checkout(fetchHead, false);
1298                 }
1299             } else if (action.equals(&quot;show&quot;)) {
1300                 show(pr.targetRef(), fetchHead);
1301             } else if (action.equals(&quot;apply&quot;)) {
1302                 var patch = diff(pr.targetRef(), fetchHead);
1303                 apply(patch);
1304                 Files.deleteIfExists(patch);
1305             }
1306         } else if (action.equals(&quot;close&quot;)) {
1307             var prId = arguments.at(1);
1308             if (!prId.isPresent()) {
1309                 exit(&quot;error: missing pull request identifier&quot;);
1310             }
1311 
1312             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1313             var pr = remoteRepo.pullRequest(prId.asString());
1314             pr.setState(PullRequest.State.CLOSED);
1315         } else if (action.equals(&quot;update&quot;)) {
1316             var prId = arguments.at(1);
1317             if (!prId.isPresent()) {
1318                 exit(&quot;error: missing pull request identifier&quot;);
1319             }
1320 
1321             var remoteRepo = getHostedRepositoryFor(uri, repo, host);
1322             var pr = remoteRepo.pullRequest(prId.asString());
1323             var assigneesOption = getOption(&quot;assignees&quot;, &quot;update&quot;, arguments);
1324             if (assigneesOption != null) {
1325                 var usernames = Arrays.asList(assigneesOption.split(&quot;,&quot;));
1326                 var assignees = usernames.stream()
1327                     .map(u -&gt; host.user(u))
1328                     .collect(Collectors.toList());
1329                 pr.setAssignees(assignees);
1330             }
1331         } else if (action.equals(&quot;status&quot;)) {
1332             String id = pullRequestIdArgument(arguments, repo);
1333             var pr = getPullRequest(uri, repo, host, id);
1334             var noDecoration = getSwitch(&quot;no-decoration&quot;, &quot;status&quot;, arguments);
1335             var decoration = noDecoration ? &quot;&quot; : &quot;Status: &quot;;
1336             System.out.println(decoration + statusForPullRequest(pr));
1337 
1338             var noChecks = getSwitch(&quot;no-checks&quot;, &quot;status&quot;, arguments);
1339             if (!noChecks) {
1340                 var checks = pr.checks(pr.headHash());
1341                 var jcheck = Optional.ofNullable(checks.get(&quot;jcheck&quot;));
1342                 var submit = Optional.ofNullable(checks.get(&quot;submit&quot;));
1343                 var showChecks = jcheck.isPresent() || submit.isPresent();
1344                 if (showChecks) {
1345                     System.out.println(&quot;Checks:&quot;);
1346                     if (jcheck.isPresent()) {
1347                         System.out.println(&quot;- jcheck: &quot; + statusForCheck(jcheck.get()));
1348                     }
1349                     if (submit.isPresent()) {
1350                         System.out.println(&quot;- submit: &quot; + statusForCheck(submit.get()));
1351                     }
1352                 }
1353             }
1354         } else {
1355             exit(&quot;error: unexpected action: &quot; + action);
1356         }
1357     }
1358 }
    </pre>
  </body>
</html>