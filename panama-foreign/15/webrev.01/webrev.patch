diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -199,10 +199,10 @@
 
     static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_LAYOUT, "ofUnion",
                 MethodTypeDesc.of(CD_GROUP_LAYOUT, CD_LAYOUT.arrayType()));
 
     static final MethodHandleDesc MH_VOID_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_FUNCTION_DESC, "ofVoid",
-                MethodTypeDesc.of(CD_FUNCTION_DESC, ConstantDescs.CD_boolean, CD_LAYOUT.arrayType()));
+                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_LAYOUT.arrayType()));
 
     static final MethodHandleDesc MH_FUNCTION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_FUNCTION_DESC, "of",
-                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_LAYOUT, ConstantDescs.CD_boolean, CD_LAYOUT.arrayType()));
+                MethodTypeDesc.of(CD_FUNCTION_DESC, CD_LAYOUT, CD_LAYOUT.arrayType()));
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
@@ -40,15 +40,13 @@
  */
 public final class FunctionDescriptor implements Constable {
     
     private final MemoryLayout resLayout;
     private final MemoryLayout[] argLayouts;
-    private final boolean variadic;
 
-    private FunctionDescriptor(MemoryLayout resLayout, boolean variadic, MemoryLayout... argLayouts) {
+    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {
         this.resLayout = resLayout;
-        this.variadic = variadic;
         this.argLayouts = argLayouts;
     }
 
     /**
      * Returns the return foreign.layout associated with this function.
@@ -64,50 +62,60 @@
      */
     public List<MemoryLayout> argumentLayouts() {
         return Arrays.asList(argLayouts);
     }
 
-    /**
-     * Does this function accept a variable-arity argument list?
-     * @return true, if the function models a variadic function.
-     */
-    public boolean isVariadic() {
-        return variadic;
-    }
-
     /**
      * Create a function descriptor with given return and argument layouts.
-     * @param varargs is this a variadic function
      * @param resLayout the return
      * @param argLayouts the argument layouts.
      * @return the new function descriptor.
      */
-    public static FunctionDescriptor of(MemoryLayout resLayout, boolean varargs, MemoryLayout... argLayouts) {
-        return new FunctionDescriptor(resLayout, varargs, argLayouts);
+    public static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {
+        return new FunctionDescriptor(resLayout, argLayouts);
     }
 
     /**
      * Create a void function descriptor with given argument layouts.
-     * @param varargs is this a variadic function
      * @param argLayouts the argument layouts.
      * @return the new function descriptor.
      */
-    public static FunctionDescriptor ofVoid(boolean varargs, MemoryLayout... argLayouts) {
-        return new FunctionDescriptor(null, varargs, argLayouts);
+    public static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {
+        return new FunctionDescriptor(null, argLayouts);
+    }
+
+    /**
+     * Create a new function descriptor with the given argument layouts appended to the argument layout array
+     * of this function descriptor.
+     * @param addedLayouts the layouts to append
+     * @return the new function descriptor
+     */
+    public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {
+        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);
+        System.arraycopy(addedLayouts, 0, newLayouts, argLayouts.length, addedLayouts.length);
+        return new FunctionDescriptor(resLayout, newLayouts);
+    }
+
+    /**
+     * Create a new function descriptor with the given memory layout as the new return layout.
+     * @param newReturn the new return layout
+     * @return the new function descriptor
+     */
+    public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {
+        return new FunctionDescriptor(newReturn, argLayouts);
     }
 
     /**
      * Returns a string representation of this function descriptor.
      * @return a string representation of this function descriptor.
      */
     @Override
     public String toString() {
-        return String.format("(%s%s)%s",
+        return String.format("(%s)%s",
                 Stream.of(argLayouts)
                         .map(Object::toString)
                         .collect(Collectors.joining()),
-                variadic ? "*" : "",
                 returnLayout().map(Object::toString).orElse("v"));
     }
 
     /**
      * Compares the specified object with this function descriptor for equality. Returns {@code true} if and only if the specified
@@ -123,32 +131,30 @@
         }
         if (!(other instanceof FunctionDescriptor)) {
             return false;
         }
         FunctionDescriptor f = (FunctionDescriptor) other;
-        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts) &&
-            variadic == f.variadic;
+        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);
     }
 
     /**
      * Returns the hash code value for this function descriptor.
      * @return the hash code value for this function descriptor.
      */
     @Override
     public int hashCode() {
-        int hashCode = Arrays.hashCode(argLayouts) ^ Boolean.hashCode(variadic);
+        int hashCode = Arrays.hashCode(argLayouts);
         return resLayout == null ? hashCode : resLayout.hashCode() ^ hashCode;
     }
 
     @Override
     public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {
         List<ConstantDesc> constants = new ArrayList<>();
         constants.add(resLayout == null ? AbstractLayout.MH_VOID_FUNCTION : AbstractLayout.MH_FUNCTION);
         if (resLayout != null) {
             constants.add(resLayout.describeConstable().get());
         }
-        constants.add(variadic ? AbstractLayout.TRUE : AbstractLayout.FALSE);
         for (int i = 0 ; i < argLayouts.length ; i++) {
             constants.add(argLayouts[i].describeConstable().get());
         }
         return Optional.of(DynamicConstantDesc.ofNamed(
                     ConstantDescs.BSM_INVOKE, "function", AbstractLayout.CD_FUNCTION_DESC, constants.toArray(new ConstantDesc[0])));
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
@@ -41,43 +41,31 @@
     private final boolean forUpcall;
     private final List<List<Binding>> inputBindings = new ArrayList<>();
     private List<Binding> ouputBindings = List.of();
 
     private MethodType mt = MethodType.methodType(void.class);
-    private FunctionDescriptor desc = FunctionDescriptor.ofVoid(false);
+    private FunctionDescriptor desc = FunctionDescriptor.ofVoid();
 
     public CallingSequenceBuilder(boolean forUpcall) {
         this.forUpcall = forUpcall;
     }
 
     public final CallingSequenceBuilder addArgumentBindings(Class<?> carrier, MemoryLayout layout,
                                                             List<Binding> bindings) {
         verifyBindings(true, carrier, bindings);
         inputBindings.add(bindings);
         mt = mt.appendParameterTypes(carrier);
-        descAddArgument(layout);
+        desc = desc.appendArgumentLayouts(layout);
         return this;
     }
 
-    private void descAddArgument(MemoryLayout layout) {
-        boolean isVoid = desc.returnLayout().isEmpty();
-        var args = new ArrayList<>(desc.argumentLayouts());
-        args.add(layout);
-        var argsArray = args.toArray(MemoryLayout[]::new);
-        if (isVoid) {
-            desc = FunctionDescriptor.ofVoid(false, argsArray);
-        } else {
-            desc = FunctionDescriptor.of(desc.returnLayout().get(), false, argsArray);
-        }
-    }
-
     public CallingSequenceBuilder setReturnBindings(Class<?> carrier, MemoryLayout layout,
                                                     List<Binding> bindings) {
         verifyBindings(false, carrier, bindings);
         this.ouputBindings = bindings;
         mt = mt.changeReturnType(carrier);
-        desc = FunctionDescriptor.of(layout, false, desc.argumentLayouts().toArray(MemoryLayout[]::new));
+        desc = desc.changeReturnLayout(layout);
         return this;
     }
 
     public CallingSequence build() {
         return new CallingSequence(mt, desc, inputBindings, ouputBindings);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
@@ -57,23 +57,15 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -63,23 +63,15 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -45,11 +45,11 @@
     public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 4;
     public static final int MAX_VECTOR_RETURN_REGISTERS = 1;
     public static final int MAX_REGISTER_ARGUMENTS = 4;
     public static final int MAX_REGISTER_RETURNS = 1;
 
-    public static final String VARARGS_ANNOTATION_NAME = "isVarArg";
+    public static final String VARARGS_ANNOTATION_NAME = "abi/windows/varargs";
 
     private static Windowsx64ABI instance;
 
     public static Windowsx64ABI getInstance() {
         if (instance == null) {
@@ -58,23 +58,15 @@
         return instance;
     }
 
     @Override
     public MethodHandle downcallHandle(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return CallArranger.arrangeDowncall(MemoryAddressImpl.addressof(symbol), type, function);
     }
 
     @Override
     public MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function) {
-        if (function.isVariadic()) {
-            throw new IllegalArgumentException("Variadic function: " + function);
-        }
-
         return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));
     }
 
     @Override
     public String name() {
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -173,51 +173,53 @@
         final static MethodHandle qsort;
         final static MethodHandle qsortCompar;
         final static FunctionDescriptor qsortComparFunction;
         final static MethodHandle rand;
         final static MemoryAddress printfAddr;
+        final static FunctionDescriptor printfBase;
 
         static {
             try {
                 LibraryLookup lookup = LibraryLookup.ofDefault();
 
                 strcat = abi.downcallHandle(lookup.lookup("strcat"),
                         MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),
-                        FunctionDescriptor.of(C_POINTER, false, C_POINTER, C_POINTER));
+                        FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));
 
                 strcmp = abi.downcallHandle(lookup.lookup("strcmp"),
                         MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),
-                        FunctionDescriptor.of(C_INT, false, C_POINTER, C_POINTER));
+                        FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));
 
                 puts = abi.downcallHandle(lookup.lookup("puts"),
                         MethodType.methodType(int.class, MemoryAddress.class),
-                        FunctionDescriptor.of(C_INT, false, C_POINTER));
+                        FunctionDescriptor.of(C_INT, C_POINTER));
 
                 strlen = abi.downcallHandle(lookup.lookup("strlen"),
                         MethodType.methodType(int.class, MemoryAddress.class),
-                        FunctionDescriptor.of(C_INT, false, C_POINTER));
+                        FunctionDescriptor.of(C_INT, C_POINTER));
 
                 gmtime = abi.downcallHandle(lookup.lookup("gmtime"),
                         MethodType.methodType(MemoryAddress.class, MemoryAddress.class),
-                        FunctionDescriptor.of(C_POINTER, false, C_POINTER));
+                        FunctionDescriptor.of(C_POINTER, C_POINTER));
 
-                qsortComparFunction = FunctionDescriptor.of(C_INT, false,
-                        C_POINTER, C_POINTER);
+                qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);
 
                 qsort = abi.downcallHandle(lookup.lookup("qsort"),
                         MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),
-                        FunctionDescriptor.ofVoid(false, C_POINTER, C_ULONG, C_ULONG, C_POINTER));
+                        FunctionDescriptor.ofVoid(C_POINTER, C_ULONG, C_ULONG, C_POINTER));
 
                 //qsort upcall handle
                 qsortCompar = MethodHandles.lookup().findStatic(StdLibTest.StdLibHelper.class, "qsortCompare",
                         MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));
 
                 rand = abi.downcallHandle(lookup.lookup("rand"),
                         MethodType.methodType(int.class),
-                        FunctionDescriptor.of(C_INT, false));
+                        FunctionDescriptor.of(C_INT));
 
                 printfAddr = lookup.lookup("printf");
+
+                printfBase = FunctionDescriptor.of(C_INT, C_POINTER);
             } catch (Throwable ex) {
                 throw new IllegalStateException(ex);
             }
         }
 
@@ -345,18 +347,13 @@
             //method type
             MethodType mt = MethodType.methodType(int.class, MemoryAddress.class);
             for (PrintfArg arg : args) {
                 mt = mt.appendParameterTypes(arg.carrier);
             }
-            //function
-            List<MemoryLayout> argLayouts = new ArrayList<>();
-            argLayouts.add(C_POINTER); //format
-            for (PrintfArg arg : args) {
-                argLayouts.add(arg.layout);
-            }
-            MethodHandle mh = abi.downcallHandle(printfAddr, mt,
-                    FunctionDescriptor.of(C_INT, false, argLayouts.toArray(new MemoryLayout[0])));
+            FunctionDescriptor printfSpec = StdLibHelper.printfBase.appendArgumentLayouts(
+                    args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));
+            MethodHandle mh = abi.downcallHandle(printfAddr, mt, printfSpec);
             return mh.asSpreader(1, Object[].class, args.size());
         }
     }
 
     /*** data providers ***/
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -84,12 +84,12 @@
     }
 
     static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {
         MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);
         return ret == Ret.VOID ?
-                FunctionDescriptor.ofVoid(false, paramLayouts) :
-                FunctionDescriptor.of(paramLayouts[0], false, paramLayouts);
+                FunctionDescriptor.ofVoid(paramLayouts) :
+                FunctionDescriptor.of(paramLayouts[0], paramLayouts);
     }
 
     static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {
         Object[] args = new Object[params.size()];
         for (int i = 0 ; i < params.size() ; i++) {
diff a/test/jdk/java/foreign/TestLayoutConstants.java b/test/jdk/java/foreign/TestLayoutConstants.java
--- a/test/jdk/java/foreign/TestLayoutConstants.java
+++ b/test/jdk/java/foreign/TestLayoutConstants.java
@@ -47,14 +47,14 @@
             throw new AssertionError(ex);
         }
     }
 
     @Test(dataProvider = "functions")
-    public void testDescribeResolveFunction(MemoryLayout layout, boolean isVoid, boolean hasVarargs) {
+    public void testDescribeResolveFunction(MemoryLayout layout, boolean isVoid) {
         FunctionDescriptor expected = isVoid ?
-                FunctionDescriptor.ofVoid(hasVarargs, layout) :
-                FunctionDescriptor.of(layout, hasVarargs, layout);
+                FunctionDescriptor.ofVoid(layout) :
+                FunctionDescriptor.of(layout, layout);
         try {
             FunctionDescriptor actual = expected.describeConstable().get()
                     .resolveConstantDesc(MethodHandles.lookup());
             assertEquals(actual, expected);
         } catch (ReflectiveOperationException ex) {
@@ -110,24 +110,19 @@
     }
 
     @DataProvider(name = "functions")
     public Object[][] createFunctions() {
         Object[][] layouts = createLayouts();
-        Object[][] functions = new Object[layouts.length * 4][];
+        Object[][] functions = new Object[layouts.length * 2][];
         boolean[] values = new boolean[] { true, false };
         for (int i = 0 ; i < layouts.length ; i++) {
-            for (boolean hasVarargs : values) {
-                for (boolean isVoid : values) {
-                    int offset = 0;
-                    if (hasVarargs) {
-                        offset += 1;
-                    }
-                    if (isVoid) {
-                        offset += 2;
-                    }
-                    functions[i * 4 + offset] = new Object[] { layouts[i][0], isVoid, hasVarargs };
+            for (boolean isVoid : values) {
+                int offset = 0;
+                if (isVoid) {
+                    offset += 1;
                 }
+                functions[i * 2 + offset] = new Object[] { layouts[i][0], isVoid };
             }
         }
         return functions;
     }
 }
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -73,11 +73,11 @@
     static {
         try {
             DUMMY = MethodHandles.lookup().findStatic(TestUpcall.class, "dummy", MethodType.methodType(void.class));
             PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, "passAndSave", MethodType.methodType(Object.class, Object[].class, AtomicReference.class));
 
-            dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(false));
+            dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid());
             cleaner.register(dummyAddress, () -> abi.freeUpcallStub(dummyAddress));
         } catch (Throwable ex) {
             throw new IllegalStateException(ex);
         }
     }
@@ -114,12 +114,12 @@
     static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {
         List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());
         paramLayouts.add(C_POINTER); // the callback
         MemoryLayout[] layouts = paramLayouts.toArray(new MemoryLayout[0]);
         return ret == Ret.VOID ?
-                FunctionDescriptor.ofVoid(false, layouts) :
-                FunctionDescriptor.of(layouts[0], false, layouts);
+                FunctionDescriptor.ofVoid(layouts) :
+                FunctionDescriptor.of(layouts[0], layouts);
     }
 
     static Object[] makeArgs(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {
         Object[] args = new Object[params.size() + 1];
         for (int i = 0 ; i < params.size() ; i++) {
@@ -165,12 +165,12 @@
 
         mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));
 
         MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);
         FunctionDescriptor func = ret != Ret.VOID
-                ? FunctionDescriptor.of(firstlayout, false, paramLayouts)
-                : FunctionDescriptor.ofVoid(false, paramLayouts);
+                ? FunctionDescriptor.of(firstlayout, paramLayouts)
+                : FunctionDescriptor.ofVoid(paramLayouts);
         MemoryAddress stub = abi.upcallStub(mh, func);
         cleaner.register(stub, () -> abi.freeUpcallStub(stub));
         return stub;
     }
 
diff a/test/jdk/java/foreign/TestUpcallStubs.java b/test/jdk/java/foreign/TestUpcallStubs.java
--- a/test/jdk/java/foreign/TestUpcallStubs.java
+++ b/test/jdk/java/foreign/TestUpcallStubs.java
@@ -53,11 +53,11 @@
             throw new BootstrapMethodError(e);
         }
     }
 
     private static MemoryAddress getStub() {
-        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid(false));
+        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid());
     }
 
     @Test(expectedExceptions = IndexOutOfBoundsException.class)
     public void testNoAccess() {
         MemoryAddress stub = getStub();
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -96,11 +96,11 @@
             List<MemoryLayout> argLayouts = new ArrayList<>();
             argLayouts.add(C_POINTER); // call info
             argLayouts.add(C_INT); // size
             args.forEach(a -> argLayouts.add(asVarArg(a.layout)));
 
-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(false, argLayouts.toArray(MemoryLayout[]::new));
+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));
 
             List<Class<?>> carriers = new ArrayList<>();
             carriers.add(MemoryAddress.class); // call info
             carriers.add(int.class); // size
             args.forEach(a -> carriers.add(a.carrier));
diff a/test/jdk/java/foreign/callarranger/CallArrangerTestBase.java b/test/jdk/java/foreign/callarranger/CallArrangerTestBase.java
--- a/test/jdk/java/foreign/callarranger/CallArrangerTestBase.java
+++ b/test/jdk/java/foreign/callarranger/CallArrangerTestBase.java
@@ -45,16 +45,6 @@
     }
 
     public static void checkReturnBindings(CallingSequence callingSequence, Binding[] returnBindings) {
         assertEquals(callingSequence.returnBindings(), Arrays.asList(returnBindings));
     }
-
-    public static FunctionDescriptor descAddArgument(FunctionDescriptor desc, MemoryLayout... layouts) {
-        var args = new ArrayList<>(desc.argumentLayouts());
-        args.addAll(Arrays.asList(layouts));
-        var argsArray = args.toArray(MemoryLayout[]::new);
-        return desc.returnLayout().isEmpty()
-            ? FunctionDescriptor.ofVoid(false, argsArray)
-            : FunctionDescriptor.of(desc.returnLayout().get(), false, argsArray);
-    }
-
 }
diff a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
@@ -54,11 +54,11 @@
 public class TestAarch64CallArranger extends CallArrangerTestBase {
 
     @Test
     public void testEmpty() {
         MethodType mt = MethodType.methodType(void.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -73,11 +73,11 @@
     public void testInteger() {
         MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, int.class, int.class,
                 int.class, int.class, int.class, int.class,
                 int.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_INT, C_INT, C_INT,
                 C_INT, C_INT, C_INT, C_INT,
                 C_INT, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
@@ -104,11 +104,11 @@
 
     @Test
     public void testTwoIntTwoFloat() {
       MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, float.class, float.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_INT, C_FLOAT, C_FLOAT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
@@ -126,11 +126,11 @@
     }
 
     @Test(dataProvider = "structs")
     public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -177,11 +177,11 @@
     public void testMultipleStructs() {
         MemoryLayout struct1 = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);
         MemoryLayout struct2 = MemoryLayout.ofStruct(C_LONG, C_LONG, C_LONG);
 
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct1, struct2, C_INT);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct1, struct2, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -209,17 +209,17 @@
     @Test
     public void testReturnStruct1() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG, C_FLOAT);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertTrue(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));
-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER));
+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             {
                 convertAddress(),
                 move(r8, long.class)
@@ -232,11 +232,11 @@
     @Test
     public void testReturnStruct2() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -258,11 +258,11 @@
     @Test
     public void testStructHFA1() {
         MemoryLayout hfa = MemoryLayout.ofStruct(C_FLOAT, C_FLOAT);
 
         MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(hfa, false, C_FLOAT, C_INT, hfa);
+        FunctionDescriptor fd = FunctionDescriptor.of(hfa, C_FLOAT, C_INT, hfa);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -294,11 +294,11 @@
     @Test
     public void testStructHFA3() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_FLOAT, C_FLOAT, C_FLOAT);
 
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct, struct, struct);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
diff a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
@@ -56,17 +56,17 @@
 public class TestSysVCallArranger extends CallArrangerTestBase {
 
     @Test
     public void testEmpty() {
         MethodType mt = MethodType.methodType(void.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(rax, long.class) }
         });
 
@@ -77,18 +77,18 @@
 
     @Test
     public void testIntegerRegs() {
         MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, int.class, int.class, int.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_INT, C_INT, C_INT, C_INT, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(rdi, int.class) },
             { move(rsi, int.class) },
             { move(rdx, int.class) },
@@ -106,19 +106,19 @@
     @Test
     public void testDoubleRegs() {
         MethodType mt = MethodType.methodType(void.class,
                 double.class, double.class, double.class, double.class,
                 double.class, double.class, double.class, double.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,
                 C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(xmm0, double.class) },
             { move(xmm1, double.class) },
             { move(xmm2, double.class) },
@@ -139,20 +139,20 @@
     public void testMixed() {
         MethodType mt = MethodType.methodType(void.class,
                 long.class, long.class, long.class, long.class, long.class, long.class, long.class, long.class,
                 float.class, float.class, float.class, float.class,
                 float.class, float.class, float.class, float.class, float.class, float.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_LONG, C_LONG, C_LONG, C_LONG, C_LONG, C_LONG, C_LONG, C_LONG,
                 C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT,
                 C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(rdi, long.class) },
             { move(rsi, long.class) },
             { move(rdx, long.class) },
@@ -197,18 +197,18 @@
         MemoryLayout struct = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE);
 
         MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, MemorySegment.class, int.class, int.class,
                 double.class, double.class, int.class, int.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_INT, struct, C_INT, C_INT, C_DOUBLE, C_DOUBLE, C_INT, C_INT, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(rdi, int.class) },
             { move(rsi, int.class) },
             {
@@ -240,17 +240,17 @@
      * m(f_impl);
      */
     @Test
     public void testMemoryAddress() {
         MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, C_POINTER);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid( C_POINTER);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { convertAddress(), move(rdi, long.class) },
             { move(rax, long.class) },
         });
@@ -261,17 +261,17 @@
     }
 
     @Test(dataProvider = "structs")
     public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             expectedBindings,
             { move(rax, long.class) },
         });
@@ -319,17 +319,17 @@
     @Test
     public void testReturnRegisterStruct() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONG, C_ULONG);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
-        assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { move(rax, long.class) }
         });
 
@@ -349,17 +349,17 @@
     @Test
     public void testIMR() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONG, C_ULONG, C_ULONG);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertTrue(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class, long.class));
-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER, C_LONG));
+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { convertAddress(), move(rdi, long.class) },
             { move(rax, long.class) }
         });
diff a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
@@ -54,11 +54,11 @@
 public class TestWindowsCallArranger extends CallArrangerTestBase {
 
     @Test
     public void testEmpty() {
         MethodType mt = MethodType.methodType(void.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -69,11 +69,11 @@
     }
 
     @Test
     public void testIntegerRegs() {
         MethodType mt = MethodType.methodType(void.class, int.class, int.class, int.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, C_INT, C_INT, C_INT, C_INT);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -90,11 +90,11 @@
     }
 
     @Test
     public void testDoubleRegs() {
         MethodType mt = MethodType.methodType(void.class, double.class, double.class, double.class, double.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -112,11 +112,11 @@
 
     @Test
     public void testMixed() {
         MethodType mt = MethodType.methodType(void.class,
                 long.class, long.class, float.class, float.class, long.class, long.class, float.class, float.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_LONGLONG, C_LONGLONG, C_FLOAT, C_FLOAT, C_LONGLONG, C_LONGLONG, C_FLOAT, C_FLOAT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
@@ -141,11 +141,11 @@
     public void testAbiExample() {
         MemoryLayout structLayout = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE);
         MethodType mt = MethodType.methodType(void.class,
                 int.class, int.class, MemorySegment.class, int.class, int.class,
                 double.class, double.class, double.class, int.class, int.class, int.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_INT, structLayout, C_INT, C_INT,
                 C_DOUBLE, C_DOUBLE, C_DOUBLE, C_INT, C_INT, C_INT);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
@@ -177,11 +177,11 @@
 
     @Test
     public void testAbiExampleVarargs() {
         MethodType mt = MethodType.methodType(void.class,
                 int.class, double.class, int.class, double.class, double.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false,
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(
                 C_INT, C_DOUBLE, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE));
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
@@ -211,11 +211,11 @@
     @Test
     public void testStructRegister() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONGLONG);
 
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -240,11 +240,11 @@
     @Test
     public void testStructReference() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONGLONG, C_ULONGLONG);
 
         MethodType mt = MethodType.methodType(void.class, MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, struct);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -271,11 +271,11 @@
      * m(f_impl);
      */
     @Test
     public void testMemoryAddress() {
         MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);
-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(false, C_POINTER);
+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_POINTER);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -291,11 +291,11 @@
     @Test
     public void testReturnRegisterStruct() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONGLONG);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertFalse(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
@@ -313,17 +313,17 @@
     @Test
     public void testIMR() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONGLONG, C_ULONGLONG);
 
         MethodType mt = MethodType.methodType(MemorySegment.class);
-        FunctionDescriptor fd = FunctionDescriptor.of(struct, false);
+        FunctionDescriptor fd = FunctionDescriptor.of(struct);
         CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);
 
         assertTrue(bindings.isInMemoryReturn);
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));
-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER));
+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             { convertAddress(), move(rcx, long.class) }
         });
 
