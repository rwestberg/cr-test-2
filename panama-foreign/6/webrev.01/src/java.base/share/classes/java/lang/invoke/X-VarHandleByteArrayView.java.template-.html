<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/X-VarHandleByteArrayView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.lang.invoke;
 26 
 27 import jdk.internal.access.JavaNioAccess;
 28 import jdk.internal.access.SharedSecrets;
 29 import jdk.internal.misc.Unsafe;
 30 import jdk.internal.util.Preconditions;
 31 import jdk.internal.vm.annotation.ForceInline;
 32 
 33 import java.nio.ByteBuffer;
 34 import java.nio.ReadOnlyBufferException;
 35 import java.util.Objects;
 36 
 37 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
 38 
 39 #warn
 40 
 41 final class VarHandleByteArrayAs$Type$s extends VarHandleByteArrayBase {
 42 
 43     static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
 44 
 45     static final int ALIGN = $BoxType$.BYTES - 1;
 46 
 47 #if[floatingPoint]
 48     @ForceInline
 49     static $rawType$ convEndian(boolean big, $type$ v) {
 50         $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);
 51         return big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 52     }
 53 
 54     @ForceInline
 55     static $type$ convEndian(boolean big, $rawType$ rv) {
 56         rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);
 57         return $Type$.$rawType$BitsTo$Type$(rv);
 58     }
 59 #else[floatingPoint]
 60     @ForceInline
 61     static $type$ convEndian(boolean big, $type$ n) {
 62         return big == BE ? n : $BoxType$.reverseBytes(n);
 63     }
 64 #end[floatingPoint]
 65 
 66 
 67     private static abstract class ByteArrayViewVarHandle extends VarHandle {
 68         final boolean be;
 69 
 70         ByteArrayViewVarHandle(VarForm form, boolean be) {
 71             super(form);
 72             this.be = be;
 73         }
 74     }
 75 
 76     static final class ArrayHandle extends ByteArrayViewVarHandle {
 77 
 78         ArrayHandle(boolean be) {
 79             super(ArrayHandle.FORM, be);
 80         }
 81 
 82         @Override
 83         final MethodType accessModeTypeUncached(AccessMode accessMode) {
 84             return accessMode.at.accessModeType(byte[].class, $type$.class, int.class);
 85         }
 86 
 87         @ForceInline
 88         static int index(byte[] ba, int index) {
 89             return Preconditions.checkIndex(index, ba.length - ALIGN, null);
 90         }
 91 
 92         @ForceInline
 93         static long address(byte[] ba, int index) {
 94             long address = ((long) index) + Unsafe.ARRAY_BYTE_BASE_OFFSET;
 95             if ((address &amp; ALIGN) != 0)
 96                 throw newIllegalStateExceptionForMisalignedAccess(index);
 97             return address;
 98         }
 99 
100         @ForceInline
101         static $type$ get(ArrayHandle handle, Object oba, int index) {
102             byte[] ba = (byte[]) oba;
103 #if[floatingPoint]
104             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
105                     ba,
106                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
107                     handle.be);
108             return $Type$.$rawType$BitsTo$Type$(rawValue);
109 #else[floatingPoint]
110             return UNSAFE.get$Type$Unaligned(
111                     ba,
112                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
113                     handle.be);
114 #end[floatingPoint]
115         }
116 
117         @ForceInline
118         static void set(ArrayHandle handle, Object oba, int index, $type$ value) {
119             byte[] ba = (byte[]) oba;
120 #if[floatingPoint]
121             UNSAFE.put$RawType$Unaligned(
122                     ba,
123                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
124                     $Type$.$type$ToRaw$RawType$Bits(value),
125                     handle.be);
126 #else[floatingPoint]
127             UNSAFE.put$RawType$Unaligned(
128                     ba,
129                     ((long) index(ba, index)) + Unsafe.ARRAY_BYTE_BASE_OFFSET,
130                     value,
131                     handle.be);
132 #end[floatingPoint]
133         }
134 
135         @ForceInline
136         static $type$ getVolatile(ArrayHandle handle, Object oba, int index) {
137             byte[] ba = (byte[]) oba;
138             return convEndian(handle.be,
139                               UNSAFE.get$RawType$Volatile(
140                                       ba,
141                                       address(ba, index(ba, index))));
142         }
143 
144         @ForceInline
145         static void setVolatile(ArrayHandle handle, Object oba, int index, $type$ value) {
146             byte[] ba = (byte[]) oba;
147             UNSAFE.put$RawType$Volatile(
148                     ba,
149                     address(ba, index(ba, index)),
150                     convEndian(handle.be, value));
151         }
152 
153         @ForceInline
154         static $type$ getAcquire(ArrayHandle handle, Object oba, int index) {
155             byte[] ba = (byte[]) oba;
156             return convEndian(handle.be,
157                               UNSAFE.get$RawType$Acquire(
158                                       ba,
159                                       address(ba, index(ba, index))));
160         }
161 
162         @ForceInline
163         static void setRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
164             byte[] ba = (byte[]) oba;
165             UNSAFE.put$RawType$Release(
166                     ba,
167                     address(ba, index(ba, index)),
168                     convEndian(handle.be, value));
169         }
170 
171         @ForceInline
172         static $type$ getOpaque(ArrayHandle handle, Object oba, int index) {
173             byte[] ba = (byte[]) oba;
174             return convEndian(handle.be,
175                               UNSAFE.get$RawType$Opaque(
176                                       ba,
177                                       address(ba, index(ba, index))));
178         }
179 
180         @ForceInline
181         static void setOpaque(ArrayHandle handle, Object oba, int index, $type$ value) {
182             byte[] ba = (byte[]) oba;
183             UNSAFE.put$RawType$Opaque(
184                     ba,
185                     address(ba, index(ba, index)),
186                     convEndian(handle.be, value));
187         }
188 #if[CAS]
189 
190         @ForceInline
191         static boolean compareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
192             byte[] ba = (byte[]) oba;
193 #if[Object]
194             return UNSAFE.compareAndSetReference(
195                     ba,
196                     address(ba, index(ba, index)),
197                     convEndian(handle.be, expected), convEndian(handle.be, value));
198 #else[Object]
199             return UNSAFE.compareAndSet$RawType$(
200                     ba,
201                     address(ba, index(ba, index)),
202                     convEndian(handle.be, expected), convEndian(handle.be, value));
203 #end[Object]
204         }
205 
206         @ForceInline
207         static $type$ compareAndExchange(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
208             byte[] ba = (byte[]) oba;
209             return convEndian(handle.be,
210                               UNSAFE.compareAndExchange$RawType$(
211                                       ba,
212                                       address(ba, index(ba, index)),
213                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
214         }
215 
216         @ForceInline
217         static $type$ compareAndExchangeAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
218             byte[] ba = (byte[]) oba;
219             return convEndian(handle.be,
220                               UNSAFE.compareAndExchange$RawType$Acquire(
221                                       ba,
222                                       address(ba, index(ba, index)),
223                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
224         }
225 
226         @ForceInline
227         static $type$ compareAndExchangeRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
228             byte[] ba = (byte[]) oba;
229             return convEndian(handle.be,
230                               UNSAFE.compareAndExchange$RawType$Release(
231                                       ba,
232                                       address(ba, index(ba, index)),
233                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
234         }
235 
236         @ForceInline
237         static boolean weakCompareAndSetPlain(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
238             byte[] ba = (byte[]) oba;
239             return UNSAFE.weakCompareAndSet$RawType$Plain(
240                     ba,
241                     address(ba, index(ba, index)),
242                     convEndian(handle.be, expected), convEndian(handle.be, value));
243         }
244 
245         @ForceInline
246         static boolean weakCompareAndSet(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
247             byte[] ba = (byte[]) oba;
248             return UNSAFE.weakCompareAndSet$RawType$(
249                     ba,
250                     address(ba, index(ba, index)),
251                     convEndian(handle.be, expected), convEndian(handle.be, value));
252         }
253 
254         @ForceInline
255         static boolean weakCompareAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
256             byte[] ba = (byte[]) oba;
257             return UNSAFE.weakCompareAndSet$RawType$Acquire(
258                     ba,
259                     address(ba, index(ba, index)),
260                     convEndian(handle.be, expected), convEndian(handle.be, value));
261         }
262 
263         @ForceInline
264         static boolean weakCompareAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ expected, $type$ value) {
265             byte[] ba = (byte[]) oba;
266             return UNSAFE.weakCompareAndSet$RawType$Release(
267                     ba,
268                     address(ba, index(ba, index)),
269                     convEndian(handle.be, expected), convEndian(handle.be, value));
270         }
271 
272         @ForceInline
273         static $type$ getAndSet(ArrayHandle handle, Object oba, int index, $type$ value) {
274             byte[] ba = (byte[]) oba;
275 #if[Object]
276             return convEndian(handle.be,
277                               UNSAFE.getAndSetReference(
278                                       ba,
279                                       address(ba, index(ba, index)),
280                                       convEndian(handle.be, value)));
281 #else[Object]
282             return convEndian(handle.be,
283                               UNSAFE.getAndSet$RawType$(
284                                       ba,
285                                       address(ba, index(ba, index)),
286                                       convEndian(handle.be, value)));
287 #end[Object]
288         }
289 
290         @ForceInline
291         static $type$ getAndSetAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
292             byte[] ba = (byte[]) oba;
293             return convEndian(handle.be,
294                               UNSAFE.getAndSet$RawType$Acquire(
295                                       ba,
296                                       address(ba, index(ba, index)),
297                                       convEndian(handle.be, value)));
298         }
299 
300         @ForceInline
301         static $type$ getAndSetRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
302             byte[] ba = (byte[]) oba;
303             return convEndian(handle.be,
304                               UNSAFE.getAndSet$RawType$Release(
305                                       ba,
306                                       address(ba, index(ba, index)),
307                                       convEndian(handle.be, value)));
308         }
309 #end[CAS]
310 #if[AtomicAdd]
311 
312         @ForceInline
313         static $type$ getAndAdd(ArrayHandle handle, Object oba, int index, $type$ delta) {
314             byte[] ba = (byte[]) oba;
315             if (handle.be == BE) {
316                 return UNSAFE.getAndAdd$RawType$(
317                         ba,
318                         address(ba, index(ba, index)),
319                         delta);
320             } else {
321                 return getAndAddConvEndianWithCAS(ba, index, delta);
322             }
323         }
324 
325         @ForceInline
326         static $type$ getAndAddAcquire(ArrayHandle handle, Object oba, int index, $type$ delta) {
327             byte[] ba = (byte[]) oba;
328             if (handle.be == BE) {
329                 return UNSAFE.getAndAdd$RawType$Acquire(
330                         ba,
331                         address(ba, index(ba, index)),
332                         delta);
333             } else {
334                 return getAndAddConvEndianWithCAS(ba, index, delta);
335             }
336         }
337 
338         @ForceInline
339         static $type$ getAndAddRelease(ArrayHandle handle, Object oba, int index, $type$ delta) {
340             byte[] ba = (byte[]) oba;
341             if (handle.be == BE) {
342                 return UNSAFE.getAndAdd$RawType$Release(
343                         ba,
344                         address(ba, index(ba, index)),
345                         delta);
346             } else {
347                 return getAndAddConvEndianWithCAS(ba, index, delta);
348             }
349         }
350 
351         @ForceInline
352         static $type$ getAndAddConvEndianWithCAS(byte[] ba, int index, $type$ delta) {
353             $type$ nativeExpectedValue, expectedValue;
354             long offset = address(ba, index(ba, index));
355             do {
356                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
357                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
358             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
359                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
360             return expectedValue;
361         }
362 #end[AtomicAdd]
363 #if[Bitwise]
364 
365         @ForceInline
366         static $type$ getAndBitwiseOr(ArrayHandle handle, Object oba, int index, $type$ value) {
367             byte[] ba = (byte[]) oba;
368             if (handle.be == BE) {
369                 return UNSAFE.getAndBitwiseOr$RawType$(
370                         ba,
371                         address(ba, index(ba, index)),
372                         value);
373             } else {
374                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
375             }
376         }
377 
378         @ForceInline
379         static $type$ getAndBitwiseOrRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
380             byte[] ba = (byte[]) oba;
381             if (handle.be == BE) {
382                 return UNSAFE.getAndBitwiseOr$RawType$Release(
383                         ba,
384                         address(ba, index(ba, index)),
385                         value);
386             } else {
387                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
388             }
389         }
390 
391         @ForceInline
392         static $type$ getAndBitwiseOrAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
393             byte[] ba = (byte[]) oba;
394             if (handle.be == BE) {
395                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
396                         ba,
397                         address(ba, index(ba, index)),
398                         value);
399             } else {
400                 return getAndBitwiseOrConvEndianWithCAS(ba, index, value);
401             }
402         }
403 
404         @ForceInline
405         static $type$ getAndBitwiseOrConvEndianWithCAS(byte[] ba, int index, $type$ value) {
406             $type$ nativeExpectedValue, expectedValue;
407             long offset = address(ba, index(ba, index));
408             do {
409                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
410                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
411             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
412                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
413             return expectedValue;
414         }
415 
416         @ForceInline
417         static $type$ getAndBitwiseAnd(ArrayHandle handle, Object oba, int index, $type$ value) {
418             byte[] ba = (byte[]) oba;
419             if (handle.be == BE) {
420                 return UNSAFE.getAndBitwiseAnd$RawType$(
421                         ba,
422                         address(ba, index(ba, index)),
423                         value);
424             } else {
425                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
426             }
427         }
428 
429         @ForceInline
430         static $type$ getAndBitwiseAndRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
431             byte[] ba = (byte[]) oba;
432             if (handle.be == BE) {
433                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
434                         ba,
435                         address(ba, index(ba, index)),
436                         value);
437             } else {
438                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
439             }
440         }
441 
442         @ForceInline
443         static $type$ getAndBitwiseAndAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
444             byte[] ba = (byte[]) oba;
445             if (handle.be == BE) {
446                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
447                         ba,
448                         address(ba, index(ba, index)),
449                         value);
450             } else {
451                 return getAndBitwiseAndConvEndianWithCAS(ba, index, value);
452             }
453         }
454 
455         @ForceInline
456         static $type$ getAndBitwiseAndConvEndianWithCAS(byte[] ba, int index, $type$ value) {
457             $type$ nativeExpectedValue, expectedValue;
458             long offset = address(ba, index(ba, index));
459             do {
460                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
461                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
462             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
463                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
464             return expectedValue;
465         }
466 
467         @ForceInline
468         static $type$ getAndBitwiseXor(ArrayHandle handle, Object oba, int index, $type$ value) {
469             byte[] ba = (byte[]) oba;
470             if (handle.be == BE) {
471                 return UNSAFE.getAndBitwiseXor$RawType$(
472                         ba,
473                         address(ba, index(ba, index)),
474                         value);
475             } else {
476                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
477             }
478         }
479 
480         @ForceInline
481         static $type$ getAndBitwiseXorRelease(ArrayHandle handle, Object oba, int index, $type$ value) {
482             byte[] ba = (byte[]) oba;
483             if (handle.be == BE) {
484                 return UNSAFE.getAndBitwiseXor$RawType$Release(
485                         ba,
486                         address(ba, index(ba, index)),
487                         value);
488             } else {
489                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
490             }
491         }
492 
493         @ForceInline
494         static $type$ getAndBitwiseXorAcquire(ArrayHandle handle, Object oba, int index, $type$ value) {
495             byte[] ba = (byte[]) oba;
496             if (handle.be == BE) {
497                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
498                         ba,
499                         address(ba, index(ba, index)),
500                         value);
501             } else {
502                 return getAndBitwiseXorConvEndianWithCAS(ba, index, value);
503             }
504         }
505 
506         @ForceInline
507         static $type$ getAndBitwiseXorConvEndianWithCAS(byte[] ba, int index, $type$ value) {
508             $type$ nativeExpectedValue, expectedValue;
509             long offset = address(ba, index(ba, index));
510             do {
511                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(ba, offset);
512                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
513             } while (!UNSAFE.weakCompareAndSet$RawType$(ba, offset,
514                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
515             return expectedValue;
516         }
517 #end[Bitwise]
518 
519         static final VarForm FORM = new VarForm(ArrayHandle.class, byte[].class, $type$.class, int.class);
520     }
521 
522 
523     static final class ByteBufferHandle extends ByteArrayViewVarHandle {
524 
525         ByteBufferHandle(boolean be) {
526             super(ByteBufferHandle.FORM, be);
527         }
528 
529         @Override
530         final MethodType accessModeTypeUncached(AccessMode accessMode) {
531             return accessMode.at.accessModeType(ByteBuffer.class, $type$.class, int.class);
532         }
533 
534         @ForceInline
535         static int index(ByteBuffer bb, int index) {
536             nioAccess.checkSegment(bb);
537             return Preconditions.checkIndex(index, UNSAFE.getInt(bb, BUFFER_LIMIT) - ALIGN, null);
538         }
539 
540         @ForceInline
541         static int indexRO(ByteBuffer bb, int index) {
542             if (UNSAFE.getBoolean(bb, BYTE_BUFFER_IS_READ_ONLY))
543                 throw new ReadOnlyBufferException();
544             return index(bb, index);
545         }
546 
547         @ForceInline
548         static long address(ByteBuffer bb, int index) {
549             long address = ((long) index) + UNSAFE.getLong(bb, BUFFER_ADDRESS);
550             if ((address &amp; ALIGN) != 0)
551                 throw newIllegalStateExceptionForMisalignedAccess(index);
552             return address;
553         }
554 
555         @ForceInline
556         static $type$ get(ByteBufferHandle handle, Object obb, int index) {
557             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
558 #if[floatingPoint]
559             $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
560                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
561                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
562                     handle.be);
563             return $Type$.$rawType$BitsTo$Type$(rawValue);
564 #else[floatingPoint]
565             return UNSAFE.get$Type$Unaligned(
566                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
567                     ((long) index(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
568                     handle.be);
569 #end[floatingPoint]
570         }
571 
572         @ForceInline
573         static void set(ByteBufferHandle handle, Object obb, int index, $type$ value) {
574             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
575 #if[floatingPoint]
576             UNSAFE.put$RawType$Unaligned(
577                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
578                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
579                     $Type$.$type$ToRaw$RawType$Bits(value),
580                     handle.be);
581 #else[floatingPoint]
582             UNSAFE.put$Type$Unaligned(
583                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
584                     ((long) indexRO(bb, index)) + UNSAFE.getLong(bb, BUFFER_ADDRESS),
585                     value,
586                     handle.be);
587 #end[floatingPoint]
588         }
589 
590         @ForceInline
591         static $type$ getVolatile(ByteBufferHandle handle, Object obb, int index) {
592             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
593             return convEndian(handle.be,
594                               UNSAFE.get$RawType$Volatile(
595                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
596                                       address(bb, index(bb, index))));
597         }
598 
599         @ForceInline
600         static void setVolatile(ByteBufferHandle handle, Object obb, int index, $type$ value) {
601             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
602             UNSAFE.put$RawType$Volatile(
603                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
604                     address(bb, indexRO(bb, index)),
605                     convEndian(handle.be, value));
606         }
607 
608         @ForceInline
609         static $type$ getAcquire(ByteBufferHandle handle, Object obb, int index) {
610             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
611             return convEndian(handle.be,
612                               UNSAFE.get$RawType$Acquire(
613                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
614                                       address(bb, index(bb, index))));
615         }
616 
617         @ForceInline
618         static void setRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
619             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
620             UNSAFE.put$RawType$Release(
621                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
622                     address(bb, indexRO(bb, index)),
623                     convEndian(handle.be, value));
624         }
625 
626         @ForceInline
627         static $type$ getOpaque(ByteBufferHandle handle, Object obb, int index) {
628             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
629             return convEndian(handle.be,
630                               UNSAFE.get$RawType$Opaque(
631                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
632                                       address(bb, index(bb, index))));
633         }
634 
635         @ForceInline
636         static void setOpaque(ByteBufferHandle handle, Object obb, int index, $type$ value) {
637             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
638             UNSAFE.put$RawType$Opaque(
639                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
640                     address(bb, indexRO(bb, index)),
641                     convEndian(handle.be, value));
642         }
643 #if[CAS]
644 
645         @ForceInline
646         static boolean compareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
647             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
648 #if[Object]
649             return UNSAFE.compareAndSetReference(
650                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
651                     address(bb, indexRO(bb, index)),
652                     convEndian(handle.be, expected), convEndian(handle.be, value));
653 #else[Object]
654             return UNSAFE.compareAndSet$RawType$(
655                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
656                     address(bb, indexRO(bb, index)),
657                     convEndian(handle.be, expected), convEndian(handle.be, value));
658 #end[Object]
659         }
660 
661         @ForceInline
662         static $type$ compareAndExchange(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
663             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
664             return convEndian(handle.be,
665                               UNSAFE.compareAndExchange$RawType$(
666                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
667                                       address(bb, indexRO(bb, index)),
668                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
669         }
670 
671         @ForceInline
672         static $type$ compareAndExchangeAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
673             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
674             return convEndian(handle.be,
675                               UNSAFE.compareAndExchange$RawType$Acquire(
676                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
677                                       address(bb, indexRO(bb, index)),
678                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
679         }
680 
681         @ForceInline
682         static $type$ compareAndExchangeRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
683             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
684             return convEndian(handle.be,
685                               UNSAFE.compareAndExchange$RawType$Release(
686                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
687                                       address(bb, indexRO(bb, index)),
688                                       convEndian(handle.be, expected), convEndian(handle.be, value)));
689         }
690 
691         @ForceInline
692         static boolean weakCompareAndSetPlain(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
693             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
694             return UNSAFE.weakCompareAndSet$RawType$Plain(
695                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
696                     address(bb, indexRO(bb, index)),
697                     convEndian(handle.be, expected), convEndian(handle.be, value));
698         }
699 
700         @ForceInline
701         static boolean weakCompareAndSet(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
702             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
703             return UNSAFE.weakCompareAndSet$RawType$(
704                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
705                     address(bb, indexRO(bb, index)),
706                     convEndian(handle.be, expected), convEndian(handle.be, value));
707         }
708 
709         @ForceInline
710         static boolean weakCompareAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
711             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
712             return UNSAFE.weakCompareAndSet$RawType$Acquire(
713                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
714                     address(bb, indexRO(bb, index)),
715                     convEndian(handle.be, expected), convEndian(handle.be, value));
716         }
717 
718         @ForceInline
719         static boolean weakCompareAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ expected, $type$ value) {
720             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
721             return UNSAFE.weakCompareAndSet$RawType$Release(
722                     UNSAFE.getReference(bb, BYTE_BUFFER_HB),
723                     address(bb, indexRO(bb, index)),
724                     convEndian(handle.be, expected), convEndian(handle.be, value));
725         }
726 
727         @ForceInline
728         static $type$ getAndSet(ByteBufferHandle handle, Object obb, int index, $type$ value) {
729             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
730 #if[Object]
731             return convEndian(handle.be,
732                               UNSAFE.getAndSetReference(
733                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
734                                       address(bb, indexRO(bb, index)),
735                                       convEndian(handle.be, value)));
736 #else[Object]
737             return convEndian(handle.be,
738                               UNSAFE.getAndSet$RawType$(
739                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
740                                       address(bb, indexRO(bb, index)),
741                                       convEndian(handle.be, value)));
742 #end[Object]
743         }
744 
745         @ForceInline
746         static $type$ getAndSetAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
747             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
748             return convEndian(handle.be,
749                               UNSAFE.getAndSet$RawType$Acquire(
750                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
751                                       address(bb, indexRO(bb, index)),
752                                       convEndian(handle.be, value)));
753         }
754 
755         @ForceInline
756         static $type$ getAndSetRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
757             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
758             return convEndian(handle.be,
759                               UNSAFE.getAndSet$RawType$Release(
760                                       UNSAFE.getReference(bb, BYTE_BUFFER_HB),
761                                       address(bb, indexRO(bb, index)),
762                                       convEndian(handle.be, value)));
763         }
764 #end[CAS]
765 #if[AtomicAdd]
766 
767         @ForceInline
768         static $type$ getAndAdd(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
769             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
770             if (handle.be == BE) {
771                 return UNSAFE.getAndAdd$RawType$(
772                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
773                         address(bb, indexRO(bb, index)),
774                         delta);
775             } else {
776                 return getAndAddConvEndianWithCAS(bb, index, delta);
777             }
778         }
779 
780         @ForceInline
781         static $type$ getAndAddAcquire(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
782             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
783             if (handle.be == BE) {
784                 return UNSAFE.getAndAdd$RawType$Acquire(
785                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
786                         address(bb, indexRO(bb, index)),
787                         delta);
788             } else {
789                 return getAndAddConvEndianWithCAS(bb, index, delta);
790             }
791         }
792 
793         @ForceInline
794         static $type$ getAndAddRelease(ByteBufferHandle handle, Object obb, int index, $type$ delta) {
795             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
796             if (handle.be == BE) {
797                 return UNSAFE.getAndAdd$RawType$Release(
798                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
799                         address(bb, indexRO(bb, index)),
800                         delta);
801             } else {
802                 return getAndAddConvEndianWithCAS(bb, index, delta);
803             }
804         }
805 
806         @ForceInline
807         static $type$ getAndAddConvEndianWithCAS(ByteBuffer bb, int index, $type$ delta) {
808             $type$ nativeExpectedValue, expectedValue;
809             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
810             long offset = address(bb, indexRO(bb, index));
811             do {
812                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
813                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
814             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
815                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
816             return expectedValue;
817         }
818 #end[AtomicAdd]
819 #if[Bitwise]
820 
821         @ForceInline
822         static $type$ getAndBitwiseOr(ByteBufferHandle handle, Object obb, int index, $type$ value) {
823             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
824             if (handle.be == BE) {
825                 return UNSAFE.getAndBitwiseOr$RawType$(
826                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
827                         address(bb, indexRO(bb, index)),
828                         value);
829             } else {
830                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
831             }
832         }
833 
834         @ForceInline
835         static $type$ getAndBitwiseOrRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
836             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
837             if (handle.be == BE) {
838                 return UNSAFE.getAndBitwiseOr$RawType$Release(
839                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
840                         address(bb, indexRO(bb, index)),
841                         value);
842             } else {
843                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
844             }
845         }
846 
847         @ForceInline
848         static $type$ getAndBitwiseOrAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
849             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
850             if (handle.be == BE) {
851                 return UNSAFE.getAndBitwiseOr$RawType$Acquire(
852                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
853                         address(bb, indexRO(bb, index)),
854                         value);
855             } else {
856                 return getAndBitwiseOrConvEndianWithCAS(bb, index, value);
857             }
858         }
859 
860         @ForceInline
861         static $type$ getAndBitwiseOrConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
862             $type$ nativeExpectedValue, expectedValue;
863             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
864             long offset = address(bb, indexRO(bb, index));
865             do {
866                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
867                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
868             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
869                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
870             return expectedValue;
871         }
872 
873         @ForceInline
874         static $type$ getAndBitwiseAnd(ByteBufferHandle handle, Object obb, int index, $type$ value) {
875             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
876             if (handle.be == BE) {
877                 return UNSAFE.getAndBitwiseAnd$RawType$(
878                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
879                         address(bb, indexRO(bb, index)),
880                         value);
881             } else {
882                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
883             }
884         }
885 
886         @ForceInline
887         static $type$ getAndBitwiseAndRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
888             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
889             if (handle.be == BE) {
890                 return UNSAFE.getAndBitwiseAnd$RawType$Release(
891                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
892                         address(bb, indexRO(bb, index)),
893                         value);
894             } else {
895                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
896             }
897         }
898 
899         @ForceInline
900         static $type$ getAndBitwiseAndAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
901             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
902             if (handle.be == BE) {
903                 return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
904                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
905                         address(bb, indexRO(bb, index)),
906                         value);
907             } else {
908                 return getAndBitwiseAndConvEndianWithCAS(bb, index, value);
909             }
910         }
911 
912         @ForceInline
913         static $type$ getAndBitwiseAndConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
914             $type$ nativeExpectedValue, expectedValue;
915             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
916             long offset = address(bb, indexRO(bb, index));
917             do {
918                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
919                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
920             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
921                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
922             return expectedValue;
923         }
924 
925 
926         @ForceInline
927         static $type$ getAndBitwiseXor(ByteBufferHandle handle, Object obb, int index, $type$ value) {
928             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
929             if (handle.be == BE) {
930                 return UNSAFE.getAndBitwiseXor$RawType$(
931                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
932                         address(bb, indexRO(bb, index)),
933                         value);
934             } else {
935                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
936             }
937         }
938 
939         @ForceInline
940         static $type$ getAndBitwiseXorRelease(ByteBufferHandle handle, Object obb, int index, $type$ value) {
941             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
942             if (handle.be == BE) {
943                 return UNSAFE.getAndBitwiseXor$RawType$Release(
944                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
945                         address(bb, indexRO(bb, index)),
946                         value);
947             } else {
948                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
949             }
950         }
951 
952         @ForceInline
953         static $type$ getAndBitwiseXorAcquire(ByteBufferHandle handle, Object obb, int index, $type$ value) {
954             ByteBuffer bb = (ByteBuffer) Objects.requireNonNull(obb);
955             if (handle.be == BE) {
956                 return UNSAFE.getAndBitwiseXor$RawType$Acquire(
957                         UNSAFE.getReference(bb, BYTE_BUFFER_HB),
958                         address(bb, indexRO(bb, index)),
959                         value);
960             } else {
961                 return getAndBitwiseXorConvEndianWithCAS(bb, index, value);
962             }
963         }
964 
965         @ForceInline
966         static $type$ getAndBitwiseXorConvEndianWithCAS(ByteBuffer bb, int index, $type$ value) {
967             $type$ nativeExpectedValue, expectedValue;
968             Object base = UNSAFE.getReference(bb, BYTE_BUFFER_HB);
969             long offset = address(bb, indexRO(bb, index));
970             do {
971                 nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
972                 expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
973             } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
974                     nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
975             return expectedValue;
976         }
977 #end[Bitwise]
978 
979         static final VarForm FORM = new VarForm(ByteBufferHandle.class, ByteBuffer.class, $type$.class, int.class);
980     }
981 }
    </pre>
  </body>
</html>