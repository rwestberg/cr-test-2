<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/VarHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import java.lang.constant.ClassDesc;
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.ConstantDesc;
  31 import java.lang.constant.ConstantDescs;
  32 import java.lang.constant.DirectMethodHandleDesc;
  33 import java.lang.constant.DynamicConstantDesc;
  34 import java.util.HashMap;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.Objects;
  38 import java.util.Optional;
  39 import java.util.function.BiFunction;
  40 import java.util.function.Function;
  41 
  42 import jdk.internal.HotSpotIntrinsicCandidate;
  43 import jdk.internal.util.Preconditions;
  44 import jdk.internal.vm.annotation.ForceInline;
  45 import jdk.internal.vm.annotation.Stable;
  46 
  47 import static java.lang.invoke.MethodHandleStatics.UNSAFE;
  48 
  49 /**
  50  * A VarHandle is a dynamically strongly typed reference to a variable, or to a
  51  * parametrically-defined family of variables, including static fields,
  52  * non-static fields, array elements, or components of an off-heap data
  53  * structure.  Access to such variables is supported under various
  54  * &lt;em&gt;access modes&lt;/em&gt;, including plain read/write access, volatile
  55  * read/write access, and compare-and-set.
  56  *
  57  * &lt;p&gt;VarHandles are immutable and have no visible state.  VarHandles cannot be
  58  * subclassed by the user.
  59  *
  60  * &lt;p&gt;A VarHandle has:
  61  * &lt;ul&gt;
  62  * &lt;li&gt;a {@link #varType variable type} T, the type of every variable referenced
  63  * by this VarHandle; and
  64  * &lt;li&gt;a list of {@link #coordinateTypes coordinate types}
  65  * {@code CT1, CT2, ..., CTn}, the types of &lt;em&gt;coordinate expressions&lt;/em&gt; that
  66  * jointly locate a variable referenced by this VarHandle.
  67  * &lt;/ul&gt;
  68  * Variable and coordinate types may be primitive or reference, and are
  69  * represented by {@code Class} objects.  The list of coordinate types may be
  70  * empty.
  71  *
  72  * &lt;p&gt;Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
  73  * lookup} VarHandle instances document the supported variable type and the list
  74  * of coordinate types.
  75  *
  76  * &lt;p&gt;Each access mode is associated with one &lt;em&gt;access mode method&lt;/em&gt;, a
  77  * &lt;a href=&quot;MethodHandle.html#sigpoly&quot;&gt;signature polymorphic&lt;/a&gt; method named
  78  * for the access mode.  When an access mode method is invoked on a VarHandle
  79  * instance, the initial arguments to the invocation are coordinate expressions
  80  * that indicate in precisely which object the variable is to be accessed.
  81  * Trailing arguments to the invocation represent values of importance to the
  82  * access mode.  For example, the various compare-and-set or compare-and-exchange
  83  * access modes require two trailing arguments for the variable&#39;s expected value
  84  * and new value.
  85  *
  86  * &lt;p&gt;The arity and types of arguments to the invocation of an access mode
  87  * method are not checked statically.  Instead, each access mode method
  88  * specifies an {@link #accessModeType(AccessMode) access mode type},
  89  * represented as an instance of {@link MethodType}, that serves as a kind of
  90  * method signature against which the arguments are checked dynamically.  An
  91  * access mode type gives formal parameter types in terms of the coordinate
  92  * types of a VarHandle instance and the types for values of importance to the
  93  * access mode.  An access mode type also gives a return type, often in terms of
  94  * the variable type of a VarHandle instance.  When an access mode method is
  95  * invoked on a VarHandle instance, the symbolic type descriptor at the
  96  * call site, the run time types of arguments to the invocation, and the run
  97  * time type of the return value, must &lt;a href=&quot;#invoke&quot;&gt;match&lt;/a&gt; the types
  98  * given in the access mode type.  A runtime exception will be thrown if the
  99  * match fails.
 100  *
 101  * For example, the access mode method {@link #compareAndSet} specifies that if
 102  * its receiver is a VarHandle instance with coordinate types
 103  * {@code CT1, ..., CTn} and variable type {@code T}, then its access mode type
 104  * is {@code (CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean}.
 105  * Suppose that a VarHandle instance can access array elements, and that its
 106  * coordinate types are {@code String[]} and {@code int} while its variable type
 107  * is {@code String}.  The access mode type for {@code compareAndSet} on this
 108  * VarHandle instance would be
 109  * {@code (String[] c1, int c2, String expectedValue, String newValue)boolean}.
 110  * Such a VarHandle instance may be produced by the
 111  * {@link MethodHandles#arrayElementVarHandle(Class) array factory method} and
 112  * access array elements as follows:
 113  * &lt;pre&gt; {@code
 114  * String[] sa = ...
 115  * VarHandle avh = MethodHandles.arrayElementVarHandle(String[].class);
 116  * boolean r = avh.compareAndSet(sa, 10, &quot;expected&quot;, &quot;new&quot;);
 117  * }&lt;/pre&gt;
 118  *
 119  * &lt;p&gt;Access modes control atomicity and consistency properties.
 120  * &lt;em&gt;Plain&lt;/em&gt; read ({@code get}) and write ({@code set})
 121  * accesses are guaranteed to be bitwise atomic only for references
 122  * and for primitive values of at most 32 bits, and impose no observable
 123  * ordering constraints with respect to threads other than the
 124  * executing thread. &lt;em&gt;Opaque&lt;/em&gt; operations are bitwise atomic and
 125  * coherently ordered with respect to accesses to the same variable.
 126  * In addition to obeying Opaque properties, &lt;em&gt;Acquire&lt;/em&gt; mode
 127  * reads and their subsequent accesses are ordered after matching
 128  * &lt;em&gt;Release&lt;/em&gt; mode writes and their previous accesses.  In
 129  * addition to obeying Acquire and Release properties, all
 130  * &lt;em&gt;Volatile&lt;/em&gt; operations are totally ordered with respect to
 131  * each other.
 132  *
 133  * &lt;p&gt;Access modes are grouped into the following categories:
 134  * &lt;ul&gt;
 135  * &lt;li&gt;read access modes that get the value of a variable under specified
 136  * memory ordering effects.
 137  * The set of corresponding access mode methods belonging to this group
 138  * consists of the methods
 139  * {@link #get get},
 140  * {@link #getVolatile getVolatile},
 141  * {@link #getAcquire getAcquire},
 142  * {@link #getOpaque getOpaque}.
 143  * &lt;li&gt;write access modes that set the value of a variable under specified
 144  * memory ordering effects.
 145  * The set of corresponding access mode methods belonging to this group
 146  * consists of the methods
 147  * {@link #set set},
 148  * {@link #setVolatile setVolatile},
 149  * {@link #setRelease setRelease},
 150  * {@link #setOpaque setOpaque}.
 151  * &lt;li&gt;atomic update access modes that, for example, atomically compare and set
 152  * the value of a variable under specified memory ordering effects.
 153  * The set of corresponding access mode methods belonging to this group
 154  * consists of the methods
 155  * {@link #compareAndSet compareAndSet},
 156  * {@link #weakCompareAndSetPlain weakCompareAndSetPlain},
 157  * {@link #weakCompareAndSet weakCompareAndSet},
 158  * {@link #weakCompareAndSetAcquire weakCompareAndSetAcquire},
 159  * {@link #weakCompareAndSetRelease weakCompareAndSetRelease},
 160  * {@link #compareAndExchangeAcquire compareAndExchangeAcquire},
 161  * {@link #compareAndExchange compareAndExchange},
 162  * {@link #compareAndExchangeRelease compareAndExchangeRelease},
 163  * {@link #getAndSet getAndSet},
 164  * {@link #getAndSetAcquire getAndSetAcquire},
 165  * {@link #getAndSetRelease getAndSetRelease}.
 166  * &lt;li&gt;numeric atomic update access modes that, for example, atomically get and
 167  * set with addition the value of a variable under specified memory ordering
 168  * effects.
 169  * The set of corresponding access mode methods belonging to this group
 170  * consists of the methods
 171  * {@link #getAndAdd getAndAdd},
 172  * {@link #getAndAddAcquire getAndAddAcquire},
 173  * {@link #getAndAddRelease getAndAddRelease},
 174  * &lt;li&gt;bitwise atomic update access modes that, for example, atomically get and
 175  * bitwise OR the value of a variable under specified memory ordering
 176  * effects.
 177  * The set of corresponding access mode methods belonging to this group
 178  * consists of the methods
 179  * {@link #getAndBitwiseOr getAndBitwiseOr},
 180  * {@link #getAndBitwiseOrAcquire getAndBitwiseOrAcquire},
 181  * {@link #getAndBitwiseOrRelease getAndBitwiseOrRelease},
 182  * {@link #getAndBitwiseAnd getAndBitwiseAnd},
 183  * {@link #getAndBitwiseAndAcquire getAndBitwiseAndAcquire},
 184  * {@link #getAndBitwiseAndRelease getAndBitwiseAndRelease},
 185  * {@link #getAndBitwiseXor getAndBitwiseXor},
 186  * {@link #getAndBitwiseXorAcquire getAndBitwiseXorAcquire},
 187  * {@link #getAndBitwiseXorRelease getAndBitwiseXorRelease}.
 188  * &lt;/ul&gt;
 189  *
 190  * &lt;p&gt;Factory methods that produce or {@link java.lang.invoke.MethodHandles.Lookup
 191  * lookup} VarHandle instances document the set of access modes that are
 192  * supported, which may also include documenting restrictions based on the
 193  * variable type and whether a variable is read-only.  If an access mode is not
 194  * supported then the corresponding access mode method will on invocation throw
 195  * an {@code UnsupportedOperationException}.  Factory methods should document
 196  * any additional undeclared exceptions that may be thrown by access mode
 197  * methods.
 198  * The {@link #get get} access mode is supported for all
 199  * VarHandle instances and the corresponding method never throws
 200  * {@code UnsupportedOperationException}.
 201  * If a VarHandle references a read-only variable (for example a {@code final}
 202  * field) then write, atomic update, numeric atomic update, and bitwise atomic
 203  * update access modes are not supported and corresponding methods throw
 204  * {@code UnsupportedOperationException}.
 205  * Read/write access modes (if supported), with the exception of
 206  * {@code get} and {@code set}, provide atomic access for
 207  * reference types and all primitive types.
 208  * Unless stated otherwise in the documentation of a factory method, the access
 209  * modes {@code get} and {@code set} (if supported) provide atomic access for
 210  * reference types and all primitives types, with the exception of {@code long}
 211  * and {@code double} on 32-bit platforms.
 212  *
 213  * &lt;p&gt;Access modes will override any memory ordering effects specified at
 214  * the declaration site of a variable.  For example, a VarHandle accessing
 215  * a field using the {@code get} access mode will access the field as
 216  * specified &lt;em&gt;by its access mode&lt;/em&gt; even if that field is declared
 217  * {@code volatile}.  When mixed access is performed extreme care should be
 218  * taken since the Java Memory Model may permit surprising results.
 219  *
 220  * &lt;p&gt;In addition to supporting access to variables under various access modes,
 221  * a set of static methods, referred to as memory fence methods, is also
 222  * provided for fine-grained control of memory ordering.
 223  *
 224  * The Java Language Specification permits other threads to observe operations
 225  * as if they were executed in orders different than are apparent in program
 226  * source code, subject to constraints arising, for example, from the use of
 227  * locks, {@code volatile} fields or VarHandles.  The static methods,
 228  * {@link #fullFence fullFence}, {@link #acquireFence acquireFence},
 229  * {@link #releaseFence releaseFence}, {@link #loadLoadFence loadLoadFence} and
 230  * {@link #storeStoreFence storeStoreFence}, can also be used to impose
 231  * constraints.  Their specifications, as is the case for certain access modes,
 232  * are phrased in terms of the lack of &quot;reorderings&quot; -- observable ordering
 233  * effects that might otherwise occur if the fence was not present.  More
 234  * precise phrasing of the specification of access mode methods and memory fence
 235  * methods may accompany future updates of the Java Language Specification.
 236  *
 237  * &lt;h2&gt;Compiling invocation of access mode methods&lt;/h2&gt;
 238  * A Java method call expression naming an access mode method can invoke a
 239  * VarHandle from Java source code.  From the viewpoint of source code, these
 240  * methods can take any arguments and their polymorphic result (if expressed)
 241  * can be cast to any return type.  Formally this is accomplished by giving the
 242  * access mode methods variable arity {@code Object} arguments and
 243  * {@code Object} return types (if the return type is polymorphic), but they
 244  * have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt; which
 245  * connects this freedom of invocation directly to the JVM execution stack.
 246  * &lt;p&gt;
 247  * As is usual with virtual methods, source-level calls to access mode methods
 248  * compile to an {@code invokevirtual} instruction.  More unusually, the
 249  * compiler must record the actual argument types, and may not perform method
 250  * invocation conversions on the arguments.  Instead, it must generate
 251  * instructions to push them on the stack according to their own unconverted
 252  * types.  The VarHandle object itself will be pushed on the stack before the
 253  * arguments.  The compiler then generates an {@code invokevirtual} instruction
 254  * that invokes the access mode method with a symbolic type descriptor which
 255  * describes the argument and return types.
 256  * &lt;p&gt;
 257  * To issue a complete symbolic type descriptor, the compiler must also
 258  * determine the return type (if polymorphic).  This is based on a cast on the
 259  * method invocation expression, if there is one, or else {@code Object} if the
 260  * invocation is an expression, or else {@code void} if the invocation is a
 261  * statement.  The cast may be to a primitive type (but not {@code void}).
 262  * &lt;p&gt;
 263  * As a corner case, an uncasted {@code null} argument is given a symbolic type
 264  * descriptor of {@code java.lang.Void}.  The ambiguity with the type
 265  * {@code Void} is harmless, since there are no references of type {@code Void}
 266  * except the null reference.
 267  *
 268  *
 269  * &lt;h2&gt;&lt;a id=&quot;invoke&quot;&gt;Performing invocation of access mode methods&lt;/a&gt;&lt;/h2&gt;
 270  * The first time an {@code invokevirtual} instruction is executed it is linked
 271  * by symbolically resolving the names in the instruction and verifying that
 272  * the method call is statically legal.  This also holds for calls to access mode
 273  * methods.  In this case, the symbolic type descriptor emitted by the compiler
 274  * is checked for correct syntax, and names it contains are resolved.  Thus, an
 275  * {@code invokevirtual} instruction which invokes an access mode method will
 276  * always link, as long as the symbolic type descriptor is syntactically
 277  * well-formed and the types exist.
 278  * &lt;p&gt;
 279  * When the {@code invokevirtual} is executed after linking, the receiving
 280  * VarHandle&#39;s access mode type is first checked by the JVM to ensure that it
 281  * matches the symbolic type descriptor.  If the type
 282  * match fails, it means that the access mode method which the caller is
 283  * invoking is not present on the individual VarHandle being invoked.
 284  *
 285  * &lt;p&gt;
 286  * Invocation of an access mode method behaves as if an invocation of
 287  * {@link MethodHandle#invoke}, where the receiving method handle accepts the
 288  * VarHandle instance as the leading argument.  More specifically, the
 289  * following, where {@code {access-mode}} corresponds to the access mode method
 290  * name:
 291  * &lt;pre&gt; {@code
 292  * VarHandle vh = ..
 293  * R r = (R) vh.{access-mode}(p1, p2, ..., pN);
 294  * }&lt;/pre&gt;
 295  * behaves as if:
 296  * &lt;pre&gt; {@code
 297  * VarHandle vh = ..
 298  * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(&quot;{access-mode}&quot;);
 299  * MethodHandle mh = MethodHandles.varHandleExactInvoker(
 300  *                       am,
 301  *                       vh.accessModeType(am));
 302  *
 303  * R r = (R) mh.invoke(vh, p1, p2, ..., pN)
 304  * }&lt;/pre&gt;
 305  * (modulo access mode methods do not declare throwing of {@code Throwable}).
 306  * This is equivalent to:
 307  * &lt;pre&gt; {@code
 308  * MethodHandle mh = MethodHandles.lookup().findVirtual(
 309  *                       VarHandle.class,
 310  *                       &quot;{access-mode}&quot;,
 311  *                       MethodType.methodType(R, p1, p2, ..., pN));
 312  *
 313  * R r = (R) mh.invokeExact(vh, p1, p2, ..., pN)
 314  * }&lt;/pre&gt;
 315  * where the desired method type is the symbolic type descriptor and a
 316  * {@link MethodHandle#invokeExact} is performed, since before invocation of the
 317  * target, the handle will apply reference casts as necessary and box, unbox, or
 318  * widen primitive values, as if by {@link MethodHandle#asType asType} (see also
 319  * {@link MethodHandles#varHandleInvoker}).
 320  *
 321  * More concisely, such behaviour is equivalent to:
 322  * &lt;pre&gt; {@code
 323  * VarHandle vh = ..
 324  * VarHandle.AccessMode am = VarHandle.AccessMode.valueFromMethodName(&quot;{access-mode}&quot;);
 325  * MethodHandle mh = vh.toMethodHandle(am);
 326  *
 327  * R r = (R) mh.invoke(p1, p2, ..., pN)
 328  * }&lt;/pre&gt;
 329  * Where, in this case, the method handle is bound to the VarHandle instance.
 330  *
 331  *
 332  * &lt;h2&gt;Invocation checking&lt;/h2&gt;
 333  * In typical programs, VarHandle access mode type matching will usually
 334  * succeed.  But if a match fails, the JVM will throw a
 335  * {@link WrongMethodTypeException}.
 336  * &lt;p&gt;
 337  * Thus, an access mode type mismatch which might show up as a linkage error
 338  * in a statically typed program can show up as a dynamic
 339  * {@code WrongMethodTypeException} in a program which uses VarHandles.
 340  * &lt;p&gt;
 341  * Because access mode types contain &quot;live&quot; {@code Class} objects, method type
 342  * matching takes into account both type names and class loaders.
 343  * Thus, even if a VarHandle {@code VH} is created in one class loader
 344  * {@code L1} and used in another {@code L2}, VarHandle access mode method
 345  * calls are type-safe, because the caller&#39;s symbolic type descriptor, as
 346  * resolved in {@code L2}, is matched against the original callee method&#39;s
 347  * symbolic type descriptor, as resolved in {@code L1}.  The resolution in
 348  * {@code L1} happens when {@code VH} is created and its access mode types are
 349  * assigned, while the resolution in {@code L2} happens when the
 350  * {@code invokevirtual} instruction is linked.
 351  * &lt;p&gt;
 352  * Apart from type descriptor checks, a VarHandles&#39;s capability to
 353  * access it&#39;s variables is unrestricted.
 354  * If a VarHandle is formed on a non-public variable by a class that has access
 355  * to that variable, the resulting VarHandle can be used in any place by any
 356  * caller who receives a reference to it.
 357  * &lt;p&gt;
 358  * Unlike with the Core Reflection API, where access is checked every time a
 359  * reflective method is invoked, VarHandle access checking is performed
 360  * &lt;a href=&quot;MethodHandles.Lookup.html#access&quot;&gt;when the VarHandle is
 361  * created&lt;/a&gt;.
 362  * Thus, VarHandles to non-public variables, or to variables in non-public
 363  * classes, should generally be kept secret.  They should not be passed to
 364  * untrusted code unless their use from the untrusted code would be harmless.
 365  *
 366  *
 367  * &lt;h2&gt;VarHandle creation&lt;/h2&gt;
 368  * Java code can create a VarHandle that directly accesses any field that is
 369  * accessible to that code.  This is done via a reflective, capability-based
 370  * API called {@link java.lang.invoke.MethodHandles.Lookup
 371  * MethodHandles.Lookup}.
 372  * For example, a VarHandle for a non-static field can be obtained
 373  * from {@link java.lang.invoke.MethodHandles.Lookup#findVarHandle
 374  * Lookup.findVarHandle}.
 375  * There is also a conversion method from Core Reflection API objects,
 376  * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 377  * Lookup.unreflectVarHandle}.
 378  * &lt;p&gt;
 379  * Access to protected field members is restricted to receivers only of the
 380  * accessing class, or one of its subclasses, and the accessing class must in
 381  * turn be a subclass (or package sibling) of the protected member&#39;s defining
 382  * class.  If a VarHandle refers to a protected non-static field of a declaring
 383  * class outside the current package, the receiver argument will be narrowed to
 384  * the type of the accessing class.
 385  *
 386  * &lt;h2&gt;Interoperation between VarHandles and the Core Reflection API&lt;/h2&gt;
 387  * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup
 388  * Lookup} API, any field represented by a Core Reflection API object
 389  * can be converted to a behaviorally equivalent VarHandle.
 390  * For example, a reflective {@link java.lang.reflect.Field Field} can
 391  * be converted to a VarHandle using
 392  * {@link java.lang.invoke.MethodHandles.Lookup#unreflectVarHandle
 393  * Lookup.unreflectVarHandle}.
 394  * The resulting VarHandles generally provide more direct and efficient
 395  * access to the underlying fields.
 396  * &lt;p&gt;
 397  * As a special case, when the Core Reflection API is used to view the
 398  * signature polymorphic access mode methods in this class, they appear as
 399  * ordinary non-polymorphic methods.  Their reflective appearance, as viewed by
 400  * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
 401  * is unaffected by their special status in this API.
 402  * For example, {@link java.lang.reflect.Method#getModifiers
 403  * Method.getModifiers}
 404  * will report exactly those modifier bits required for any similarly
 405  * declared method, including in this case {@code native} and {@code varargs}
 406  * bits.
 407  * &lt;p&gt;
 408  * As with any reflected method, these methods (when reflected) may be invoked
 409  * directly via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke},
 410  * via JNI, or indirectly via
 411  * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
 412  * However, such reflective calls do not result in access mode method
 413  * invocations.  Such a call, if passed the required argument (a single one, of
 414  * type {@code Object[]}), will ignore the argument and will throw an
 415  * {@code UnsupportedOperationException}.
 416  * &lt;p&gt;
 417  * Since {@code invokevirtual} instructions can natively invoke VarHandle
 418  * access mode methods under any symbolic type descriptor, this reflective view
 419  * conflicts with the normal presentation of these methods via bytecodes.
 420  * Thus, these native methods, when reflectively viewed by
 421  * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
 422  * &lt;p&gt;
 423  * In order to obtain an invoker method for a particular access mode type,
 424  * use {@link java.lang.invoke.MethodHandles#varHandleExactInvoker} or
 425  * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.  The
 426  * {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
 427  * API is also able to return a method handle to call an access mode method for
 428  * any specified access mode type and is equivalent in behaviour to
 429  * {@link java.lang.invoke.MethodHandles#varHandleInvoker}.
 430  *
 431  * &lt;h2&gt;Interoperation between VarHandles and Java generics&lt;/h2&gt;
 432  * A VarHandle can be obtained for a variable, such as a field, which is
 433  * declared with Java generic types.  As with the Core Reflection API, the
 434  * VarHandle&#39;s variable type will be constructed from the erasure of the
 435  * source-level type.  When a VarHandle access mode method is invoked, the
 436  * types
 437  * of its arguments or the return value cast type may be generic types or type
 438  * instances.  If this occurs, the compiler will replace those types by their
 439  * erasures when it constructs the symbolic type descriptor for the
 440  * {@code invokevirtual} instruction.
 441  *
 442  * @see MethodHandle
 443  * @see MethodHandles
 444  * @see MethodType
 445  * @since 9
 446  */
 447 public abstract class VarHandle implements Constable {
 448     final VarForm vform;
 449 
 450     VarHandle(VarForm vform) {
 451         this.vform = vform;
 452     }
 453 
 454     RuntimeException unsupported() {
 455         return new UnsupportedOperationException();
 456     }
 457 
 458     boolean isDirect() {
 459         return true;
 460     }
 461 
 462     VarHandle asDirect() {
 463         return this;
 464     }
 465 
 466     // Plain accessors
 467 
 468     /**
 469      * Returns the value of a variable, with memory semantics of reading as
 470      * if the variable was declared non-{@code volatile}.  Commonly referred to
 471      * as plain read access.
 472      *
 473      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 474      *
 475      * &lt;p&gt;The symbolic type descriptor at the call site of {@code get}
 476      * must match the access mode type that is the result of calling
 477      * {@code accessModeType(VarHandle.AccessMode.GET)} on this VarHandle.
 478      *
 479      * &lt;p&gt;This access mode is supported by all VarHandle instances and never
 480      * throws {@code UnsupportedOperationException}.
 481      *
 482      * @param args the signature-polymorphic parameter list of the form
 483      * {@code (CT1 ct1, ..., CTn)}
 484      * , statically represented using varargs.
 485      * @return the signature-polymorphic result that is the value of the
 486      * variable
 487      * , statically represented using {@code Object}.
 488      * @throws WrongMethodTypeException if the access mode type does not
 489      * match the caller&#39;s symbolic type descriptor.
 490      * @throws ClassCastException if the access mode type matches the caller&#39;s
 491      * symbolic type descriptor, but a reference cast fails.
 492      */
 493     public final native
 494     @MethodHandle.PolymorphicSignature
 495     @HotSpotIntrinsicCandidate
 496     Object get(Object... args);
 497 
 498     /**
 499      * Sets the value of a variable to the {@code newValue}, with memory
 500      * semantics of setting as if the variable was declared non-{@code volatile}
 501      * and non-{@code final}.  Commonly referred to as plain write access.
 502      *
 503      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}
 504      *
 505      * &lt;p&gt;The symbolic type descriptor at the call site of {@code set}
 506      * must match the access mode type that is the result of calling
 507      * {@code accessModeType(VarHandle.AccessMode.SET)} on this VarHandle.
 508      *
 509      * @param args the signature-polymorphic parameter list of the form
 510      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 511      * , statically represented using varargs.
 512      * @throws UnsupportedOperationException if the access mode is unsupported
 513      * for this VarHandle.
 514      * @throws WrongMethodTypeException if the access mode type does not
 515      * match the caller&#39;s symbolic type descriptor.
 516      * @throws ClassCastException if the access mode type matches the caller&#39;s
 517      * symbolic type descriptor, but a reference cast fails.
 518      */
 519     public final native
 520     @MethodHandle.PolymorphicSignature
 521     @HotSpotIntrinsicCandidate
 522     void set(Object... args);
 523 
 524 
 525     // Volatile accessors
 526 
 527     /**
 528      * Returns the value of a variable, with memory semantics of reading as if
 529      * the variable was declared {@code volatile}.
 530      *
 531      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 532      *
 533      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getVolatile}
 534      * must match the access mode type that is the result of calling
 535      * {@code accessModeType(VarHandle.AccessMode.GET_VOLATILE)} on this
 536      * VarHandle.
 537      *
 538      * @param args the signature-polymorphic parameter list of the form
 539      * {@code (CT1 ct1, ..., CTn ctn)}
 540      * , statically represented using varargs.
 541      * @return the signature-polymorphic result that is the value of the
 542      * variable
 543      * , statically represented using {@code Object}.
 544      * @throws UnsupportedOperationException if the access mode is unsupported
 545      * for this VarHandle.
 546      * @throws WrongMethodTypeException if the access mode type does not
 547      * match the caller&#39;s symbolic type descriptor.
 548      * @throws ClassCastException if the access mode type matches the caller&#39;s
 549      * symbolic type descriptor, but a reference cast fails.
 550      */
 551     public final native
 552     @MethodHandle.PolymorphicSignature
 553     @HotSpotIntrinsicCandidate
 554     Object getVolatile(Object... args);
 555 
 556     /**
 557      * Sets the value of a variable to the {@code newValue}, with memory
 558      * semantics of setting as if the variable was declared {@code volatile}.
 559      *
 560      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 561      *
 562      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setVolatile}
 563      * must match the access mode type that is the result of calling
 564      * {@code accessModeType(VarHandle.AccessMode.SET_VOLATILE)} on this
 565      * VarHandle.
 566      *
 567      * @apiNote
 568      * Ignoring the many semantic differences from C and C++, this method has
 569      * memory ordering effects compatible with {@code memory_order_seq_cst}.
 570      *
 571      * @param args the signature-polymorphic parameter list of the form
 572      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 573      * , statically represented using varargs.
 574      * @throws UnsupportedOperationException if the access mode is unsupported
 575      * for this VarHandle.
 576      * @throws WrongMethodTypeException if the access mode type does not
 577      * match the caller&#39;s symbolic type descriptor.
 578      * @throws ClassCastException if the access mode type matches the caller&#39;s
 579      * symbolic type descriptor, but a reference cast fails.
 580      */
 581     public final native
 582     @MethodHandle.PolymorphicSignature
 583     @HotSpotIntrinsicCandidate
 584     void setVolatile(Object... args);
 585 
 586 
 587     /**
 588      * Returns the value of a variable, accessed in program order, but with no
 589      * assurance of memory ordering effects with respect to other threads.
 590      *
 591      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 592      *
 593      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getOpaque}
 594      * must match the access mode type that is the result of calling
 595      * {@code accessModeType(VarHandle.AccessMode.GET_OPAQUE)} on this
 596      * VarHandle.
 597      *
 598      * @param args the signature-polymorphic parameter list of the form
 599      * {@code (CT1 ct1, ..., CTn ctn)}
 600      * , statically represented using varargs.
 601      * @return the signature-polymorphic result that is the value of the
 602      * variable
 603      * , statically represented using {@code Object}.
 604      * @throws UnsupportedOperationException if the access mode is unsupported
 605      * for this VarHandle.
 606      * @throws WrongMethodTypeException if the access mode type does not
 607      * match the caller&#39;s symbolic type descriptor.
 608      * @throws ClassCastException if the access mode type matches the caller&#39;s
 609      * symbolic type descriptor, but a reference cast fails.
 610      */
 611     public final native
 612     @MethodHandle.PolymorphicSignature
 613     @HotSpotIntrinsicCandidate
 614     Object getOpaque(Object... args);
 615 
 616     /**
 617      * Sets the value of a variable to the {@code newValue}, in program order,
 618      * but with no assurance of memory ordering effects with respect to other
 619      * threads.
 620      *
 621      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 622      *
 623      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setOpaque}
 624      * must match the access mode type that is the result of calling
 625      * {@code accessModeType(VarHandle.AccessMode.SET_OPAQUE)} on this
 626      * VarHandle.
 627      *
 628      * @param args the signature-polymorphic parameter list of the form
 629      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 630      * , statically represented using varargs.
 631      * @throws UnsupportedOperationException if the access mode is unsupported
 632      * for this VarHandle.
 633      * @throws WrongMethodTypeException if the access mode type does not
 634      * match the caller&#39;s symbolic type descriptor.
 635      * @throws ClassCastException if the access mode type matches the caller&#39;s
 636      * symbolic type descriptor, but a reference cast fails.
 637      */
 638     public final native
 639     @MethodHandle.PolymorphicSignature
 640     @HotSpotIntrinsicCandidate
 641     void setOpaque(Object... args);
 642 
 643 
 644     // Lazy accessors
 645 
 646     /**
 647      * Returns the value of a variable, and ensures that subsequent loads and
 648      * stores are not reordered before this access.
 649      *
 650      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn)T}.
 651      *
 652      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAcquire}
 653      * must match the access mode type that is the result of calling
 654      * {@code accessModeType(VarHandle.AccessMode.GET_ACQUIRE)} on this
 655      * VarHandle.
 656      *
 657      * @apiNote
 658      * Ignoring the many semantic differences from C and C++, this method has
 659      * memory ordering effects compatible with {@code memory_order_acquire}
 660      * ordering.
 661      *
 662      * @param args the signature-polymorphic parameter list of the form
 663      * {@code (CT1 ct1, ..., CTn ctn)}
 664      * , statically represented using varargs.
 665      * @return the signature-polymorphic result that is the value of the
 666      * variable
 667      * , statically represented using {@code Object}.
 668      * @throws UnsupportedOperationException if the access mode is unsupported
 669      * for this VarHandle.
 670      * @throws WrongMethodTypeException if the access mode type does not
 671      * match the caller&#39;s symbolic type descriptor.
 672      * @throws ClassCastException if the access mode type matches the caller&#39;s
 673      * symbolic type descriptor, but a reference cast fails.
 674      */
 675     public final native
 676     @MethodHandle.PolymorphicSignature
 677     @HotSpotIntrinsicCandidate
 678     Object getAcquire(Object... args);
 679 
 680     /**
 681      * Sets the value of a variable to the {@code newValue}, and ensures that
 682      * prior loads and stores are not reordered after this access.
 683      *
 684      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)void}.
 685      *
 686      * &lt;p&gt;The symbolic type descriptor at the call site of {@code setRelease}
 687      * must match the access mode type that is the result of calling
 688      * {@code accessModeType(VarHandle.AccessMode.SET_RELEASE)} on this
 689      * VarHandle.
 690      *
 691      * @apiNote
 692      * Ignoring the many semantic differences from C and C++, this method has
 693      * memory ordering effects compatible with {@code memory_order_release}
 694      * ordering.
 695      *
 696      * @param args the signature-polymorphic parameter list of the form
 697      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
 698      * , statically represented using varargs.
 699      * @throws UnsupportedOperationException if the access mode is unsupported
 700      * for this VarHandle.
 701      * @throws WrongMethodTypeException if the access mode type does not
 702      * match the caller&#39;s symbolic type descriptor.
 703      * @throws ClassCastException if the access mode type matches the caller&#39;s
 704      * symbolic type descriptor, but a reference cast fails.
 705      */
 706     public final native
 707     @MethodHandle.PolymorphicSignature
 708     @HotSpotIntrinsicCandidate
 709     void setRelease(Object... args);
 710 
 711 
 712     // Compare and set accessors
 713 
 714     /**
 715      * Atomically sets the value of a variable to the {@code newValue} with the
 716      * memory semantics of {@link #setVolatile} if the variable&#39;s current value,
 717      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 718      * {@code expectedValue}, as accessed with the memory semantics of
 719      * {@link #getVolatile}.
 720      *
 721      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 722      *
 723      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 724      * compareAndSet} must match the access mode type that is the result of
 725      * calling {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_SET)} on
 726      * this VarHandle.
 727      *
 728      * @param args the signature-polymorphic parameter list of the form
 729      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 730      * , statically represented using varargs.
 731      * @return {@code true} if successful, otherwise {@code false} if the
 732      * witness value was not the same as the {@code expectedValue}.
 733      * @throws UnsupportedOperationException if the access mode is unsupported
 734      * for this VarHandle.
 735      * @throws WrongMethodTypeException if the access mode type does not
 736      * match the caller&#39;s symbolic type descriptor.
 737      * @throws ClassCastException if the access mode type matches the caller&#39;s
 738      * symbolic type descriptor, but a reference cast fails.
 739      * @see #setVolatile(Object...)
 740      * @see #getVolatile(Object...)
 741      */
 742     public final native
 743     @MethodHandle.PolymorphicSignature
 744     @HotSpotIntrinsicCandidate
 745     boolean compareAndSet(Object... args);
 746 
 747     /**
 748      * Atomically sets the value of a variable to the {@code newValue} with the
 749      * memory semantics of {@link #setVolatile} if the variable&#39;s current value,
 750      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 751      * {@code expectedValue}, as accessed with the memory semantics of
 752      * {@link #getVolatile}.
 753      *
 754      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 755      *
 756      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 757      * compareAndExchange}
 758      * must match the access mode type that is the result of calling
 759      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE)}
 760      * on this VarHandle.
 761      *
 762      * @param args the signature-polymorphic parameter list of the form
 763      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 764      * , statically represented using varargs.
 765      * @return the signature-polymorphic result that is the witness value, which
 766      * will be the same as the {@code expectedValue} if successful
 767      * , statically represented using {@code Object}.
 768      * @throws UnsupportedOperationException if the access mode is unsupported
 769      * for this VarHandle.
 770      * @throws WrongMethodTypeException if the access mode type is not
 771      * compatible with the caller&#39;s symbolic type descriptor.
 772      * @throws ClassCastException if the access mode type is compatible with the
 773      * caller&#39;s symbolic type descriptor, but a reference cast fails.
 774      * @see #setVolatile(Object...)
 775      * @see #getVolatile(Object...)
 776      */
 777     public final native
 778     @MethodHandle.PolymorphicSignature
 779     @HotSpotIntrinsicCandidate
 780     Object compareAndExchange(Object... args);
 781 
 782     /**
 783      * Atomically sets the value of a variable to the {@code newValue} with the
 784      * memory semantics of {@link #set} if the variable&#39;s current value,
 785      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 786      * {@code expectedValue}, as accessed with the memory semantics of
 787      * {@link #getAcquire}.
 788      *
 789      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 790      *
 791      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 792      * compareAndExchangeAcquire}
 793      * must match the access mode type that is the result of calling
 794      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_ACQUIRE)} on
 795      * this VarHandle.
 796      *
 797      * @param args the signature-polymorphic parameter list of the form
 798      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 799      * , statically represented using varargs.
 800      * @return the signature-polymorphic result that is the witness value, which
 801      * will be the same as the {@code expectedValue} if successful
 802      * , statically represented using {@code Object}.
 803      * @throws UnsupportedOperationException if the access mode is unsupported
 804      * for this VarHandle.
 805      * @throws WrongMethodTypeException if the access mode type does not
 806      * match the caller&#39;s symbolic type descriptor.
 807      * @throws ClassCastException if the access mode type matches the caller&#39;s
 808      * symbolic type descriptor, but a reference cast fails.
 809      * @see #set(Object...)
 810      * @see #getAcquire(Object...)
 811      */
 812     public final native
 813     @MethodHandle.PolymorphicSignature
 814     @HotSpotIntrinsicCandidate
 815     Object compareAndExchangeAcquire(Object... args);
 816 
 817     /**
 818      * Atomically sets the value of a variable to the {@code newValue} with the
 819      * memory semantics of {@link #setRelease} if the variable&#39;s current value,
 820      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 821      * {@code expectedValue}, as accessed with the memory semantics of
 822      * {@link #get}.
 823      *
 824      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T}.
 825      *
 826      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 827      * compareAndExchangeRelease}
 828      * must match the access mode type that is the result of calling
 829      * {@code accessModeType(VarHandle.AccessMode.COMPARE_AND_EXCHANGE_RELEASE)}
 830      * on this VarHandle.
 831      *
 832      * @param args the signature-polymorphic parameter list of the form
 833      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 834      * , statically represented using varargs.
 835      * @return the signature-polymorphic result that is the witness value, which
 836      * will be the same as the {@code expectedValue} if successful
 837      * , statically represented using {@code Object}.
 838      * @throws UnsupportedOperationException if the access mode is unsupported
 839      * for this VarHandle.
 840      * @throws WrongMethodTypeException if the access mode type does not
 841      * match the caller&#39;s symbolic type descriptor.
 842      * @throws ClassCastException if the access mode type matches the caller&#39;s
 843      * symbolic type descriptor, but a reference cast fails.
 844      * @see #setRelease(Object...)
 845      * @see #get(Object...)
 846      */
 847     public final native
 848     @MethodHandle.PolymorphicSignature
 849     @HotSpotIntrinsicCandidate
 850     Object compareAndExchangeRelease(Object... args);
 851 
 852     // Weak (spurious failures allowed)
 853 
 854     /**
 855      * Possibly atomically sets the value of a variable to the {@code newValue}
 856      * with the semantics of {@link #set} if the variable&#39;s current value,
 857      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 858      * {@code expectedValue}, as accessed with the memory semantics of
 859      * {@link #get}.
 860      *
 861      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 862      * contention) even if the witness value does match the expected value.
 863      *
 864      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 865      *
 866      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 867      * weakCompareAndSetPlain} must match the access mode type that is the result of
 868      * calling {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_PLAIN)}
 869      * on this VarHandle.
 870      *
 871      * @param args the signature-polymorphic parameter list of the form
 872      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 873      * , statically represented using varargs.
 874      * @return {@code true} if successful, otherwise {@code false} if the
 875      * witness value was not the same as the {@code expectedValue} or if this
 876      * operation spuriously failed.
 877      * @throws UnsupportedOperationException if the access mode is unsupported
 878      * for this VarHandle.
 879      * @throws WrongMethodTypeException if the access mode type does not
 880      * match the caller&#39;s symbolic type descriptor.
 881      * @throws ClassCastException if the access mode type matches the caller&#39;s
 882      * symbolic type descriptor, but a reference cast fails.
 883      * @see #set(Object...)
 884      * @see #get(Object...)
 885      */
 886     public final native
 887     @MethodHandle.PolymorphicSignature
 888     @HotSpotIntrinsicCandidate
 889     boolean weakCompareAndSetPlain(Object... args);
 890 
 891     /**
 892      * Possibly atomically sets the value of a variable to the {@code newValue}
 893      * with the memory semantics of {@link #setVolatile} if the variable&#39;s
 894      * current value, referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 895      * {@code expectedValue}, as accessed with the memory semantics of
 896      * {@link #getVolatile}.
 897      *
 898      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 899      * contention) even if the witness value does match the expected value.
 900      *
 901      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 902      *
 903      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 904      * weakCompareAndSet} must match the access mode type that is the
 905      * result of calling {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET)}
 906      * on this VarHandle.
 907      *
 908      * @param args the signature-polymorphic parameter list of the form
 909      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 910      * , statically represented using varargs.
 911      * @return {@code true} if successful, otherwise {@code false} if the
 912      * witness value was not the same as the {@code expectedValue} or if this
 913      * operation spuriously failed.
 914      * @throws UnsupportedOperationException if the access mode is unsupported
 915      * for this VarHandle.
 916      * @throws WrongMethodTypeException if the access mode type does not
 917      * match the caller&#39;s symbolic type descriptor.
 918      * @throws ClassCastException if the access mode type matches the caller&#39;s
 919      * symbolic type descriptor, but a reference cast fails.
 920      * @see #setVolatile(Object...)
 921      * @see #getVolatile(Object...)
 922      */
 923     public final native
 924     @MethodHandle.PolymorphicSignature
 925     @HotSpotIntrinsicCandidate
 926     boolean weakCompareAndSet(Object... args);
 927 
 928     /**
 929      * Possibly atomically sets the value of a variable to the {@code newValue}
 930      * with the semantics of {@link #set} if the variable&#39;s current value,
 931      * referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 932      * {@code expectedValue}, as accessed with the memory semantics of
 933      * {@link #getAcquire}.
 934      *
 935      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 936      * contention) even if the witness value does match the expected value.
 937      *
 938      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 939      *
 940      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 941      * weakCompareAndSetAcquire}
 942      * must match the access mode type that is the result of calling
 943      * {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_ACQUIRE)}
 944      * on this VarHandle.
 945      *
 946      * @param args the signature-polymorphic parameter list of the form
 947      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 948      * , statically represented using varargs.
 949      * @return {@code true} if successful, otherwise {@code false} if the
 950      * witness value was not the same as the {@code expectedValue} or if this
 951      * operation spuriously failed.
 952      * @throws UnsupportedOperationException if the access mode is unsupported
 953      * for this VarHandle.
 954      * @throws WrongMethodTypeException if the access mode type does not
 955      * match the caller&#39;s symbolic type descriptor.
 956      * @throws ClassCastException if the access mode type matches the caller&#39;s
 957      * symbolic type descriptor, but a reference cast fails.
 958      * @see #set(Object...)
 959      * @see #getAcquire(Object...)
 960      */
 961     public final native
 962     @MethodHandle.PolymorphicSignature
 963     @HotSpotIntrinsicCandidate
 964     boolean weakCompareAndSetAcquire(Object... args);
 965 
 966     /**
 967      * Possibly atomically sets the value of a variable to the {@code newValue}
 968      * with the semantics of {@link #setRelease} if the variable&#39;s current
 969      * value, referred to as the &lt;em&gt;witness value&lt;/em&gt;, {@code ==} the
 970      * {@code expectedValue}, as accessed with the memory semantics of
 971      * {@link #get}.
 972      *
 973      * &lt;p&gt;This operation may fail spuriously (typically, due to memory
 974      * contention) even if the witness value does match the expected value.
 975      *
 976      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean}.
 977      *
 978      * &lt;p&gt;The symbolic type descriptor at the call site of {@code
 979      * weakCompareAndSetRelease}
 980      * must match the access mode type that is the result of calling
 981      * {@code accessModeType(VarHandle.AccessMode.WEAK_COMPARE_AND_SET_RELEASE)}
 982      * on this VarHandle.
 983      *
 984      * @param args the signature-polymorphic parameter list of the form
 985      * {@code (CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)}
 986      * , statically represented using varargs.
 987      * @return {@code true} if successful, otherwise {@code false} if the
 988      * witness value was not the same as the {@code expectedValue} or if this
 989      * operation spuriously failed.
 990      * @throws UnsupportedOperationException if the access mode is unsupported
 991      * for this VarHandle.
 992      * @throws WrongMethodTypeException if the access mode type does not
 993      * match the caller&#39;s symbolic type descriptor.
 994      * @throws ClassCastException if the access mode type matches the caller&#39;s
 995      * symbolic type descriptor, but a reference cast fails.
 996      * @see #setRelease(Object...)
 997      * @see #get(Object...)
 998      */
 999     public final native
1000     @MethodHandle.PolymorphicSignature
1001     @HotSpotIntrinsicCandidate
1002     boolean weakCompareAndSetRelease(Object... args);
1003 
1004     /**
1005      * Atomically sets the value of a variable to the {@code newValue} with the
1006      * memory semantics of {@link #setVolatile} and returns the variable&#39;s
1007      * previous value, as accessed with the memory semantics of
1008      * {@link #getVolatile}.
1009      *
1010      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1011      *
1012      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSet}
1013      * must match the access mode type that is the result of calling
1014      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET)} on this
1015      * VarHandle.
1016      *
1017      * @param args the signature-polymorphic parameter list of the form
1018      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1019      * , statically represented using varargs.
1020      * @return the signature-polymorphic result that is the previous value of
1021      * the variable
1022      * , statically represented using {@code Object}.
1023      * @throws UnsupportedOperationException if the access mode is unsupported
1024      * for this VarHandle.
1025      * @throws WrongMethodTypeException if the access mode type does not
1026      * match the caller&#39;s symbolic type descriptor.
1027      * @throws ClassCastException if the access mode type matches the caller&#39;s
1028      * symbolic type descriptor, but a reference cast fails.
1029      * @see #setVolatile(Object...)
1030      * @see #getVolatile(Object...)
1031      */
1032     public final native
1033     @MethodHandle.PolymorphicSignature
1034     @HotSpotIntrinsicCandidate
1035     Object getAndSet(Object... args);
1036 
1037     /**
1038      * Atomically sets the value of a variable to the {@code newValue} with the
1039      * memory semantics of {@link #set} and returns the variable&#39;s
1040      * previous value, as accessed with the memory semantics of
1041      * {@link #getAcquire}.
1042      *
1043      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1044      *
1045      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSetAcquire}
1046      * must match the access mode type that is the result of calling
1047      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET_ACQUIRE)} on this
1048      * VarHandle.
1049      *
1050      * @param args the signature-polymorphic parameter list of the form
1051      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1052      * , statically represented using varargs.
1053      * @return the signature-polymorphic result that is the previous value of
1054      * the variable
1055      * , statically represented using {@code Object}.
1056      * @throws UnsupportedOperationException if the access mode is unsupported
1057      * for this VarHandle.
1058      * @throws WrongMethodTypeException if the access mode type does not
1059      * match the caller&#39;s symbolic type descriptor.
1060      * @throws ClassCastException if the access mode type matches the caller&#39;s
1061      * symbolic type descriptor, but a reference cast fails.
1062      * @see #setVolatile(Object...)
1063      * @see #getVolatile(Object...)
1064      */
1065     public final native
1066     @MethodHandle.PolymorphicSignature
1067     @HotSpotIntrinsicCandidate
1068     Object getAndSetAcquire(Object... args);
1069 
1070     /**
1071      * Atomically sets the value of a variable to the {@code newValue} with the
1072      * memory semantics of {@link #setRelease} and returns the variable&#39;s
1073      * previous value, as accessed with the memory semantics of
1074      * {@link #get}.
1075      *
1076      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T newValue)T}.
1077      *
1078      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndSetRelease}
1079      * must match the access mode type that is the result of calling
1080      * {@code accessModeType(VarHandle.AccessMode.GET_AND_SET_RELEASE)} on this
1081      * VarHandle.
1082      *
1083      * @param args the signature-polymorphic parameter list of the form
1084      * {@code (CT1 ct1, ..., CTn ctn, T newValue)}
1085      * , statically represented using varargs.
1086      * @return the signature-polymorphic result that is the previous value of
1087      * the variable
1088      * , statically represented using {@code Object}.
1089      * @throws UnsupportedOperationException if the access mode is unsupported
1090      * for this VarHandle.
1091      * @throws WrongMethodTypeException if the access mode type does not
1092      * match the caller&#39;s symbolic type descriptor.
1093      * @throws ClassCastException if the access mode type matches the caller&#39;s
1094      * symbolic type descriptor, but a reference cast fails.
1095      * @see #setVolatile(Object...)
1096      * @see #getVolatile(Object...)
1097      */
1098     public final native
1099     @MethodHandle.PolymorphicSignature
1100     @HotSpotIntrinsicCandidate
1101     Object getAndSetRelease(Object... args);
1102 
1103     // Primitive adders
1104     // Throw UnsupportedOperationException for refs
1105 
1106     /**
1107      * Atomically adds the {@code value} to the current value of a variable with
1108      * the memory semantics of {@link #setVolatile}, and returns the variable&#39;s
1109      * previous value, as accessed with the memory semantics of
1110      * {@link #getVolatile}.
1111      *
1112      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1113      *
1114      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAdd}
1115      * must match the access mode type that is the result of calling
1116      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD)} on this
1117      * VarHandle.
1118      *
1119      * @param args the signature-polymorphic parameter list of the form
1120      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1121      * , statically represented using varargs.
1122      * @return the signature-polymorphic result that is the previous value of
1123      * the variable
1124      * , statically represented using {@code Object}.
1125      * @throws UnsupportedOperationException if the access mode is unsupported
1126      * for this VarHandle.
1127      * @throws WrongMethodTypeException if the access mode type does not
1128      * match the caller&#39;s symbolic type descriptor.
1129      * @throws ClassCastException if the access mode type matches the caller&#39;s
1130      * symbolic type descriptor, but a reference cast fails.
1131      * @see #setVolatile(Object...)
1132      * @see #getVolatile(Object...)
1133      */
1134     public final native
1135     @MethodHandle.PolymorphicSignature
1136     @HotSpotIntrinsicCandidate
1137     Object getAndAdd(Object... args);
1138 
1139     /**
1140      * Atomically adds the {@code value} to the current value of a variable with
1141      * the memory semantics of {@link #set}, and returns the variable&#39;s
1142      * previous value, as accessed with the memory semantics of
1143      * {@link #getAcquire}.
1144      *
1145      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1146      *
1147      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAddAcquire}
1148      * must match the access mode type that is the result of calling
1149      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD_ACQUIRE)} on this
1150      * VarHandle.
1151      *
1152      * @param args the signature-polymorphic parameter list of the form
1153      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1154      * , statically represented using varargs.
1155      * @return the signature-polymorphic result that is the previous value of
1156      * the variable
1157      * , statically represented using {@code Object}.
1158      * @throws UnsupportedOperationException if the access mode is unsupported
1159      * for this VarHandle.
1160      * @throws WrongMethodTypeException if the access mode type does not
1161      * match the caller&#39;s symbolic type descriptor.
1162      * @throws ClassCastException if the access mode type matches the caller&#39;s
1163      * symbolic type descriptor, but a reference cast fails.
1164      * @see #setVolatile(Object...)
1165      * @see #getVolatile(Object...)
1166      */
1167     public final native
1168     @MethodHandle.PolymorphicSignature
1169     @HotSpotIntrinsicCandidate
1170     Object getAndAddAcquire(Object... args);
1171 
1172     /**
1173      * Atomically adds the {@code value} to the current value of a variable with
1174      * the memory semantics of {@link #setRelease}, and returns the variable&#39;s
1175      * previous value, as accessed with the memory semantics of
1176      * {@link #get}.
1177      *
1178      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T value)T}.
1179      *
1180      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndAddRelease}
1181      * must match the access mode type that is the result of calling
1182      * {@code accessModeType(VarHandle.AccessMode.GET_AND_ADD_RELEASE)} on this
1183      * VarHandle.
1184      *
1185      * @param args the signature-polymorphic parameter list of the form
1186      * {@code (CT1 ct1, ..., CTn ctn, T value)}
1187      * , statically represented using varargs.
1188      * @return the signature-polymorphic result that is the previous value of
1189      * the variable
1190      * , statically represented using {@code Object}.
1191      * @throws UnsupportedOperationException if the access mode is unsupported
1192      * for this VarHandle.
1193      * @throws WrongMethodTypeException if the access mode type does not
1194      * match the caller&#39;s symbolic type descriptor.
1195      * @throws ClassCastException if the access mode type matches the caller&#39;s
1196      * symbolic type descriptor, but a reference cast fails.
1197      * @see #setVolatile(Object...)
1198      * @see #getVolatile(Object...)
1199      */
1200     public final native
1201     @MethodHandle.PolymorphicSignature
1202     @HotSpotIntrinsicCandidate
1203     Object getAndAddRelease(Object... args);
1204 
1205 
1206     // Bitwise operations
1207     // Throw UnsupportedOperationException for refs
1208 
1209     /**
1210      * Atomically sets the value of a variable to the result of
1211      * bitwise OR between the variable&#39;s current value and the {@code mask}
1212      * with the memory semantics of {@link #setVolatile} and returns the
1213      * variable&#39;s previous value, as accessed with the memory semantics of
1214      * {@link #getVolatile}.
1215      *
1216      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1217      * logical OR is performed instead of a bitwise OR.
1218      *
1219      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1220      *
1221      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOr}
1222      * must match the access mode type that is the result of calling
1223      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR)} on this
1224      * VarHandle.
1225      *
1226      * @param args the signature-polymorphic parameter list of the form
1227      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1228      * , statically represented using varargs.
1229      * @return the signature-polymorphic result that is the previous value of
1230      * the variable
1231      * , statically represented using {@code Object}.
1232      * @throws UnsupportedOperationException if the access mode is unsupported
1233      * for this VarHandle.
1234      * @throws WrongMethodTypeException if the access mode type does not
1235      * match the caller&#39;s symbolic type descriptor.
1236      * @throws ClassCastException if the access mode type matches the caller&#39;s
1237      * symbolic type descriptor, but a reference cast fails.
1238      * @see #setVolatile(Object...)
1239      * @see #getVolatile(Object...)
1240      */
1241     public final native
1242     @MethodHandle.PolymorphicSignature
1243     @HotSpotIntrinsicCandidate
1244     Object getAndBitwiseOr(Object... args);
1245 
1246     /**
1247      * Atomically sets the value of a variable to the result of
1248      * bitwise OR between the variable&#39;s current value and the {@code mask}
1249      * with the memory semantics of {@link #set} and returns the
1250      * variable&#39;s previous value, as accessed with the memory semantics of
1251      * {@link #getAcquire}.
1252      *
1253      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1254      * logical OR is performed instead of a bitwise OR.
1255      *
1256      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1257      *
1258      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOrAcquire}
1259      * must match the access mode type that is the result of calling
1260      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_ACQUIRE)} on this
1261      * VarHandle.
1262      *
1263      * @param args the signature-polymorphic parameter list of the form
1264      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1265      * , statically represented using varargs.
1266      * @return the signature-polymorphic result that is the previous value of
1267      * the variable
1268      * , statically represented using {@code Object}.
1269      * @throws UnsupportedOperationException if the access mode is unsupported
1270      * for this VarHandle.
1271      * @throws WrongMethodTypeException if the access mode type does not
1272      * match the caller&#39;s symbolic type descriptor.
1273      * @throws ClassCastException if the access mode type matches the caller&#39;s
1274      * symbolic type descriptor, but a reference cast fails.
1275      * @see #set(Object...)
1276      * @see #getAcquire(Object...)
1277      */
1278     public final native
1279     @MethodHandle.PolymorphicSignature
1280     @HotSpotIntrinsicCandidate
1281     Object getAndBitwiseOrAcquire(Object... args);
1282 
1283     /**
1284      * Atomically sets the value of a variable to the result of
1285      * bitwise OR between the variable&#39;s current value and the {@code mask}
1286      * with the memory semantics of {@link #setRelease} and returns the
1287      * variable&#39;s previous value, as accessed with the memory semantics of
1288      * {@link #get}.
1289      *
1290      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1291      * logical OR is performed instead of a bitwise OR.
1292      *
1293      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1294      *
1295      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseOrRelease}
1296      * must match the access mode type that is the result of calling
1297      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_OR_RELEASE)} on this
1298      * VarHandle.
1299      *
1300      * @param args the signature-polymorphic parameter list of the form
1301      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1302      * , statically represented using varargs.
1303      * @return the signature-polymorphic result that is the previous value of
1304      * the variable
1305      * , statically represented using {@code Object}.
1306      * @throws UnsupportedOperationException if the access mode is unsupported
1307      * for this VarHandle.
1308      * @throws WrongMethodTypeException if the access mode type does not
1309      * match the caller&#39;s symbolic type descriptor.
1310      * @throws ClassCastException if the access mode type matches the caller&#39;s
1311      * symbolic type descriptor, but a reference cast fails.
1312      * @see #setRelease(Object...)
1313      * @see #get(Object...)
1314      */
1315     public final native
1316     @MethodHandle.PolymorphicSignature
1317     @HotSpotIntrinsicCandidate
1318     Object getAndBitwiseOrRelease(Object... args);
1319 
1320     /**
1321      * Atomically sets the value of a variable to the result of
1322      * bitwise AND between the variable&#39;s current value and the {@code mask}
1323      * with the memory semantics of {@link #setVolatile} and returns the
1324      * variable&#39;s previous value, as accessed with the memory semantics of
1325      * {@link #getVolatile}.
1326      *
1327      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1328      * logical AND is performed instead of a bitwise AND.
1329      *
1330      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1331      *
1332      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAnd}
1333      * must match the access mode type that is the result of calling
1334      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND)} on this
1335      * VarHandle.
1336      *
1337      * @param args the signature-polymorphic parameter list of the form
1338      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1339      * , statically represented using varargs.
1340      * @return the signature-polymorphic result that is the previous value of
1341      * the variable
1342      * , statically represented using {@code Object}.
1343      * @throws UnsupportedOperationException if the access mode is unsupported
1344      * for this VarHandle.
1345      * @throws WrongMethodTypeException if the access mode type does not
1346      * match the caller&#39;s symbolic type descriptor.
1347      * @throws ClassCastException if the access mode type matches the caller&#39;s
1348      * symbolic type descriptor, but a reference cast fails.
1349      * @see #setVolatile(Object...)
1350      * @see #getVolatile(Object...)
1351      */
1352     public final native
1353     @MethodHandle.PolymorphicSignature
1354     @HotSpotIntrinsicCandidate
1355     Object getAndBitwiseAnd(Object... args);
1356 
1357     /**
1358      * Atomically sets the value of a variable to the result of
1359      * bitwise AND between the variable&#39;s current value and the {@code mask}
1360      * with the memory semantics of {@link #set} and returns the
1361      * variable&#39;s previous value, as accessed with the memory semantics of
1362      * {@link #getAcquire}.
1363      *
1364      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1365      * logical AND is performed instead of a bitwise AND.
1366      *
1367      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1368      *
1369      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAndAcquire}
1370      * must match the access mode type that is the result of calling
1371      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_ACQUIRE)} on this
1372      * VarHandle.
1373      *
1374      * @param args the signature-polymorphic parameter list of the form
1375      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1376      * , statically represented using varargs.
1377      * @return the signature-polymorphic result that is the previous value of
1378      * the variable
1379      * , statically represented using {@code Object}.
1380      * @throws UnsupportedOperationException if the access mode is unsupported
1381      * for this VarHandle.
1382      * @throws WrongMethodTypeException if the access mode type does not
1383      * match the caller&#39;s symbolic type descriptor.
1384      * @throws ClassCastException if the access mode type matches the caller&#39;s
1385      * symbolic type descriptor, but a reference cast fails.
1386      * @see #set(Object...)
1387      * @see #getAcquire(Object...)
1388      */
1389     public final native
1390     @MethodHandle.PolymorphicSignature
1391     @HotSpotIntrinsicCandidate
1392     Object getAndBitwiseAndAcquire(Object... args);
1393 
1394     /**
1395      * Atomically sets the value of a variable to the result of
1396      * bitwise AND between the variable&#39;s current value and the {@code mask}
1397      * with the memory semantics of {@link #setRelease} and returns the
1398      * variable&#39;s previous value, as accessed with the memory semantics of
1399      * {@link #get}.
1400      *
1401      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1402      * logical AND is performed instead of a bitwise AND.
1403      *
1404      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1405      *
1406      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseAndRelease}
1407      * must match the access mode type that is the result of calling
1408      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_AND_RELEASE)} on this
1409      * VarHandle.
1410      *
1411      * @param args the signature-polymorphic parameter list of the form
1412      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1413      * , statically represented using varargs.
1414      * @return the signature-polymorphic result that is the previous value of
1415      * the variable
1416      * , statically represented using {@code Object}.
1417      * @throws UnsupportedOperationException if the access mode is unsupported
1418      * for this VarHandle.
1419      * @throws WrongMethodTypeException if the access mode type does not
1420      * match the caller&#39;s symbolic type descriptor.
1421      * @throws ClassCastException if the access mode type matches the caller&#39;s
1422      * symbolic type descriptor, but a reference cast fails.
1423      * @see #setRelease(Object...)
1424      * @see #get(Object...)
1425      */
1426     public final native
1427     @MethodHandle.PolymorphicSignature
1428     @HotSpotIntrinsicCandidate
1429     Object getAndBitwiseAndRelease(Object... args);
1430 
1431     /**
1432      * Atomically sets the value of a variable to the result of
1433      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1434      * with the memory semantics of {@link #setVolatile} and returns the
1435      * variable&#39;s previous value, as accessed with the memory semantics of
1436      * {@link #getVolatile}.
1437      *
1438      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1439      * logical XOR is performed instead of a bitwise XOR.
1440      *
1441      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1442      *
1443      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXor}
1444      * must match the access mode type that is the result of calling
1445      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR)} on this
1446      * VarHandle.
1447      *
1448      * @param args the signature-polymorphic parameter list of the form
1449      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1450      * , statically represented using varargs.
1451      * @return the signature-polymorphic result that is the previous value of
1452      * the variable
1453      * , statically represented using {@code Object}.
1454      * @throws UnsupportedOperationException if the access mode is unsupported
1455      * for this VarHandle.
1456      * @throws WrongMethodTypeException if the access mode type does not
1457      * match the caller&#39;s symbolic type descriptor.
1458      * @throws ClassCastException if the access mode type matches the caller&#39;s
1459      * symbolic type descriptor, but a reference cast fails.
1460      * @see #setVolatile(Object...)
1461      * @see #getVolatile(Object...)
1462      */
1463     public final native
1464     @MethodHandle.PolymorphicSignature
1465     @HotSpotIntrinsicCandidate
1466     Object getAndBitwiseXor(Object... args);
1467 
1468     /**
1469      * Atomically sets the value of a variable to the result of
1470      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1471      * with the memory semantics of {@link #set} and returns the
1472      * variable&#39;s previous value, as accessed with the memory semantics of
1473      * {@link #getAcquire}.
1474      *
1475      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1476      * logical XOR is performed instead of a bitwise XOR.
1477      *
1478      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1479      *
1480      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXorAcquire}
1481      * must match the access mode type that is the result of calling
1482      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_ACQUIRE)} on this
1483      * VarHandle.
1484      *
1485      * @param args the signature-polymorphic parameter list of the form
1486      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1487      * , statically represented using varargs.
1488      * @return the signature-polymorphic result that is the previous value of
1489      * the variable
1490      * , statically represented using {@code Object}.
1491      * @throws UnsupportedOperationException if the access mode is unsupported
1492      * for this VarHandle.
1493      * @throws WrongMethodTypeException if the access mode type does not
1494      * match the caller&#39;s symbolic type descriptor.
1495      * @throws ClassCastException if the access mode type matches the caller&#39;s
1496      * symbolic type descriptor, but a reference cast fails.
1497      * @see #set(Object...)
1498      * @see #getAcquire(Object...)
1499      */
1500     public final native
1501     @MethodHandle.PolymorphicSignature
1502     @HotSpotIntrinsicCandidate
1503     Object getAndBitwiseXorAcquire(Object... args);
1504 
1505     /**
1506      * Atomically sets the value of a variable to the result of
1507      * bitwise XOR between the variable&#39;s current value and the {@code mask}
1508      * with the memory semantics of {@link #setRelease} and returns the
1509      * variable&#39;s previous value, as accessed with the memory semantics of
1510      * {@link #get}.
1511      *
1512      * &lt;p&gt;If the variable type is the non-integral {@code boolean} type then a
1513      * logical XOR is performed instead of a bitwise XOR.
1514      *
1515      * &lt;p&gt;The method signature is of the form {@code (CT1 ct1, ..., CTn ctn, T mask)T}.
1516      *
1517      * &lt;p&gt;The symbolic type descriptor at the call site of {@code getAndBitwiseXorRelease}
1518      * must match the access mode type that is the result of calling
1519      * {@code accessModeType(VarHandle.AccessMode.GET_AND_BITWISE_XOR_RELEASE)} on this
1520      * VarHandle.
1521      *
1522      * @param args the signature-polymorphic parameter list of the form
1523      * {@code (CT1 ct1, ..., CTn ctn, T mask)}
1524      * , statically represented using varargs.
1525      * @return the signature-polymorphic result that is the previous value of
1526      * the variable
1527      * , statically represented using {@code Object}.
1528      * @throws UnsupportedOperationException if the access mode is unsupported
1529      * for this VarHandle.
1530      * @throws WrongMethodTypeException if the access mode type does not
1531      * match the caller&#39;s symbolic type descriptor.
1532      * @throws ClassCastException if the access mode type matches the caller&#39;s
1533      * symbolic type descriptor, but a reference cast fails.
1534      * @see #setRelease(Object...)
1535      * @see #get(Object...)
1536      */
1537     public final native
1538     @MethodHandle.PolymorphicSignature
1539     @HotSpotIntrinsicCandidate
1540     Object getAndBitwiseXorRelease(Object... args);
1541 
1542 
1543     enum AccessType {
1544         GET(Object.class),
1545         SET(void.class),
1546         COMPARE_AND_SET(boolean.class),
1547         COMPARE_AND_EXCHANGE(Object.class),
1548         GET_AND_UPDATE(Object.class);
1549 
1550         final Class&lt;?&gt; returnType;
1551         final boolean isMonomorphicInReturnType;
1552 
1553         AccessType(Class&lt;?&gt; returnType) {
1554             this.returnType = returnType;
1555             isMonomorphicInReturnType = returnType != Object.class;
1556         }
1557 
1558         MethodType accessModeType(Class&lt;?&gt; receiver, Class&lt;?&gt; value,
1559                                   Class&lt;?&gt;... intermediate) {
1560             Class&lt;?&gt;[] ps;
1561             int i;
1562             switch (this) {
1563                 case GET:
1564                     ps = allocateParameters(0, receiver, intermediate);
1565                     fillParameters(ps, receiver, intermediate);
1566                     return MethodType.methodType(value, ps);
1567                 case SET:
1568                     ps = allocateParameters(1, receiver, intermediate);
1569                     i = fillParameters(ps, receiver, intermediate);
1570                     ps[i] = value;
1571                     return MethodType.methodType(void.class, ps);
1572                 case COMPARE_AND_SET:
1573                     ps = allocateParameters(2, receiver, intermediate);
1574                     i = fillParameters(ps, receiver, intermediate);
1575                     ps[i++] = value;
1576                     ps[i] = value;
1577                     return MethodType.methodType(boolean.class, ps);
1578                 case COMPARE_AND_EXCHANGE:
1579                     ps = allocateParameters(2, receiver, intermediate);
1580                     i = fillParameters(ps, receiver, intermediate);
1581                     ps[i++] = value;
1582                     ps[i] = value;
1583                     return MethodType.methodType(value, ps);
1584                 case GET_AND_UPDATE:
1585                     ps = allocateParameters(1, receiver, intermediate);
1586                     i = fillParameters(ps, receiver, intermediate);
1587                     ps[i] = value;
1588                     return MethodType.methodType(value, ps);
1589                 default:
1590                     throw new InternalError(&quot;Unknown AccessType&quot;);
1591             }
1592         }
1593 
1594         private static Class&lt;?&gt;[] allocateParameters(int values,
1595                                                      Class&lt;?&gt; receiver, Class&lt;?&gt;... intermediate) {
1596             int size = ((receiver != null) ? 1 : 0) + intermediate.length + values;
1597             return new Class&lt;?&gt;[size];
1598         }
1599 
1600         private static int fillParameters(Class&lt;?&gt;[] ps,
1601                                           Class&lt;?&gt; receiver, Class&lt;?&gt;... intermediate) {
1602             int i = 0;
1603             if (receiver != null)
1604                 ps[i++] = receiver;
1605             for (int j = 0; j &lt; intermediate.length; j++)
1606                 ps[i++] = intermediate[j];
1607             return i;
1608         }
1609     }
1610 
1611     /**
1612      * The set of access modes that specify how a variable, referenced by a
1613      * VarHandle, is accessed.
1614      */
1615     public enum AccessMode {
1616         /**
1617          * The access mode whose access is specified by the corresponding
1618          * method
1619          * {@link VarHandle#get VarHandle.get}
1620          */
1621         GET(&quot;get&quot;, AccessType.GET),
1622         /**
1623          * The access mode whose access is specified by the corresponding
1624          * method
1625          * {@link VarHandle#set VarHandle.set}
1626          */
1627         SET(&quot;set&quot;, AccessType.SET),
1628         /**
1629          * The access mode whose access is specified by the corresponding
1630          * method
1631          * {@link VarHandle#getVolatile VarHandle.getVolatile}
1632          */
1633         GET_VOLATILE(&quot;getVolatile&quot;, AccessType.GET),
1634         /**
1635          * The access mode whose access is specified by the corresponding
1636          * method
1637          * {@link VarHandle#setVolatile VarHandle.setVolatile}
1638          */
1639         SET_VOLATILE(&quot;setVolatile&quot;, AccessType.SET),
1640         /**
1641          * The access mode whose access is specified by the corresponding
1642          * method
1643          * {@link VarHandle#getAcquire VarHandle.getAcquire}
1644          */
1645         GET_ACQUIRE(&quot;getAcquire&quot;, AccessType.GET),
1646         /**
1647          * The access mode whose access is specified by the corresponding
1648          * method
1649          * {@link VarHandle#setRelease VarHandle.setRelease}
1650          */
1651         SET_RELEASE(&quot;setRelease&quot;, AccessType.SET),
1652         /**
1653          * The access mode whose access is specified by the corresponding
1654          * method
1655          * {@link VarHandle#getOpaque VarHandle.getOpaque}
1656          */
1657         GET_OPAQUE(&quot;getOpaque&quot;, AccessType.GET),
1658         /**
1659          * The access mode whose access is specified by the corresponding
1660          * method
1661          * {@link VarHandle#setOpaque VarHandle.setOpaque}
1662          */
1663         SET_OPAQUE(&quot;setOpaque&quot;, AccessType.SET),
1664         /**
1665          * The access mode whose access is specified by the corresponding
1666          * method
1667          * {@link VarHandle#compareAndSet VarHandle.compareAndSet}
1668          */
1669         COMPARE_AND_SET(&quot;compareAndSet&quot;, AccessType.COMPARE_AND_SET),
1670         /**
1671          * The access mode whose access is specified by the corresponding
1672          * method
1673          * {@link VarHandle#compareAndExchange VarHandle.compareAndExchange}
1674          */
1675         COMPARE_AND_EXCHANGE(&quot;compareAndExchange&quot;, AccessType.COMPARE_AND_EXCHANGE),
1676         /**
1677          * The access mode whose access is specified by the corresponding
1678          * method
1679          * {@link VarHandle#compareAndExchangeAcquire VarHandle.compareAndExchangeAcquire}
1680          */
1681         COMPARE_AND_EXCHANGE_ACQUIRE(&quot;compareAndExchangeAcquire&quot;, AccessType.COMPARE_AND_EXCHANGE),
1682         /**
1683          * The access mode whose access is specified by the corresponding
1684          * method
1685          * {@link VarHandle#compareAndExchangeRelease VarHandle.compareAndExchangeRelease}
1686          */
1687         COMPARE_AND_EXCHANGE_RELEASE(&quot;compareAndExchangeRelease&quot;, AccessType.COMPARE_AND_EXCHANGE),
1688         /**
1689          * The access mode whose access is specified by the corresponding
1690          * method
1691          * {@link VarHandle#weakCompareAndSetPlain VarHandle.weakCompareAndSetPlain}
1692          */
1693         WEAK_COMPARE_AND_SET_PLAIN(&quot;weakCompareAndSetPlain&quot;, AccessType.COMPARE_AND_SET),
1694         /**
1695          * The access mode whose access is specified by the corresponding
1696          * method
1697          * {@link VarHandle#weakCompareAndSet VarHandle.weakCompareAndSet}
1698          */
1699         WEAK_COMPARE_AND_SET(&quot;weakCompareAndSet&quot;, AccessType.COMPARE_AND_SET),
1700         /**
1701          * The access mode whose access is specified by the corresponding
1702          * method
1703          * {@link VarHandle#weakCompareAndSetAcquire VarHandle.weakCompareAndSetAcquire}
1704          */
1705         WEAK_COMPARE_AND_SET_ACQUIRE(&quot;weakCompareAndSetAcquire&quot;, AccessType.COMPARE_AND_SET),
1706         /**
1707          * The access mode whose access is specified by the corresponding
1708          * method
1709          * {@link VarHandle#weakCompareAndSetRelease VarHandle.weakCompareAndSetRelease}
1710          */
1711         WEAK_COMPARE_AND_SET_RELEASE(&quot;weakCompareAndSetRelease&quot;, AccessType.COMPARE_AND_SET),
1712         /**
1713          * The access mode whose access is specified by the corresponding
1714          * method
1715          * {@link VarHandle#getAndSet VarHandle.getAndSet}
1716          */
1717         GET_AND_SET(&quot;getAndSet&quot;, AccessType.GET_AND_UPDATE),
1718         /**
1719          * The access mode whose access is specified by the corresponding
1720          * method
1721          * {@link VarHandle#getAndSetAcquire VarHandle.getAndSetAcquire}
1722          */
1723         GET_AND_SET_ACQUIRE(&quot;getAndSetAcquire&quot;, AccessType.GET_AND_UPDATE),
1724         /**
1725          * The access mode whose access is specified by the corresponding
1726          * method
1727          * {@link VarHandle#getAndSetRelease VarHandle.getAndSetRelease}
1728          */
1729         GET_AND_SET_RELEASE(&quot;getAndSetRelease&quot;, AccessType.GET_AND_UPDATE),
1730         /**
1731          * The access mode whose access is specified by the corresponding
1732          * method
1733          * {@link VarHandle#getAndAdd VarHandle.getAndAdd}
1734          */
1735         GET_AND_ADD(&quot;getAndAdd&quot;, AccessType.GET_AND_UPDATE),
1736         /**
1737          * The access mode whose access is specified by the corresponding
1738          * method
1739          * {@link VarHandle#getAndAddAcquire VarHandle.getAndAddAcquire}
1740          */
1741         GET_AND_ADD_ACQUIRE(&quot;getAndAddAcquire&quot;, AccessType.GET_AND_UPDATE),
1742         /**
1743          * The access mode whose access is specified by the corresponding
1744          * method
1745          * {@link VarHandle#getAndAddRelease VarHandle.getAndAddRelease}
1746          */
1747         GET_AND_ADD_RELEASE(&quot;getAndAddRelease&quot;, AccessType.GET_AND_UPDATE),
1748         /**
1749          * The access mode whose access is specified by the corresponding
1750          * method
1751          * {@link VarHandle#getAndBitwiseOr VarHandle.getAndBitwiseOr}
1752          */
1753         GET_AND_BITWISE_OR(&quot;getAndBitwiseOr&quot;, AccessType.GET_AND_UPDATE),
1754         /**
1755          * The access mode whose access is specified by the corresponding
1756          * method
1757          * {@link VarHandle#getAndBitwiseOrRelease VarHandle.getAndBitwiseOrRelease}
1758          */
1759         GET_AND_BITWISE_OR_RELEASE(&quot;getAndBitwiseOrRelease&quot;, AccessType.GET_AND_UPDATE),
1760         /**
1761          * The access mode whose access is specified by the corresponding
1762          * method
1763          * {@link VarHandle#getAndBitwiseOrAcquire VarHandle.getAndBitwiseOrAcquire}
1764          */
1765         GET_AND_BITWISE_OR_ACQUIRE(&quot;getAndBitwiseOrAcquire&quot;, AccessType.GET_AND_UPDATE),
1766         /**
1767          * The access mode whose access is specified by the corresponding
1768          * method
1769          * {@link VarHandle#getAndBitwiseAnd VarHandle.getAndBitwiseAnd}
1770          */
1771         GET_AND_BITWISE_AND(&quot;getAndBitwiseAnd&quot;, AccessType.GET_AND_UPDATE),
1772         /**
1773          * The access mode whose access is specified by the corresponding
1774          * method
1775          * {@link VarHandle#getAndBitwiseAndRelease VarHandle.getAndBitwiseAndRelease}
1776          */
1777         GET_AND_BITWISE_AND_RELEASE(&quot;getAndBitwiseAndRelease&quot;, AccessType.GET_AND_UPDATE),
1778         /**
1779          * The access mode whose access is specified by the corresponding
1780          * method
1781          * {@link VarHandle#getAndBitwiseAndAcquire VarHandle.getAndBitwiseAndAcquire}
1782          */
1783         GET_AND_BITWISE_AND_ACQUIRE(&quot;getAndBitwiseAndAcquire&quot;, AccessType.GET_AND_UPDATE),
1784         /**
1785          * The access mode whose access is specified by the corresponding
1786          * method
1787          * {@link VarHandle#getAndBitwiseXor VarHandle.getAndBitwiseXor}
1788          */
1789         GET_AND_BITWISE_XOR(&quot;getAndBitwiseXor&quot;, AccessType.GET_AND_UPDATE),
1790         /**
1791          * The access mode whose access is specified by the corresponding
1792          * method
1793          * {@link VarHandle#getAndBitwiseXorRelease VarHandle.getAndBitwiseXorRelease}
1794          */
1795         GET_AND_BITWISE_XOR_RELEASE(&quot;getAndBitwiseXorRelease&quot;, AccessType.GET_AND_UPDATE),
1796         /**
1797          * The access mode whose access is specified by the corresponding
1798          * method
1799          * {@link VarHandle#getAndBitwiseXorAcquire VarHandle.getAndBitwiseXorAcquire}
1800          */
1801         GET_AND_BITWISE_XOR_ACQUIRE(&quot;getAndBitwiseXorAcquire&quot;, AccessType.GET_AND_UPDATE),
1802         ;
1803 
1804         static final Map&lt;String, AccessMode&gt; methodNameToAccessMode;
1805         static {
1806             AccessMode[] values = AccessMode.values();
1807             // Initial capacity of # values divided by the load factor is sufficient
1808             // to avoid resizes for the smallest table size (64)
1809             int initialCapacity = (int)(values.length / 0.75f) + 1;
1810             methodNameToAccessMode = new HashMap&lt;&gt;(initialCapacity);
1811             for (AccessMode am : values) {
1812                 methodNameToAccessMode.put(am.methodName, am);
1813             }
1814         }
1815 
1816         final String methodName;
1817         final AccessType at;
1818 
1819         AccessMode(final String methodName, AccessType at) {
1820             this.methodName = methodName;
1821             this.at = at;
1822         }
1823 
1824         /**
1825          * Returns the {@code VarHandle} signature-polymorphic method name
1826          * associated with this {@code AccessMode} value.
1827          *
1828          * @return the signature-polymorphic method name
1829          * @see #valueFromMethodName
1830          */
1831         public String methodName() {
1832             return methodName;
1833         }
1834 
1835         /**
1836          * Returns the {@code AccessMode} value associated with the specified
1837          * {@code VarHandle} signature-polymorphic method name.
1838          *
1839          * @param methodName the signature-polymorphic method name
1840          * @return the {@code AccessMode} value
1841          * @throws IllegalArgumentException if there is no {@code AccessMode}
1842          *         value associated with method name (indicating the method
1843          *         name does not correspond to a {@code VarHandle}
1844          *         signature-polymorphic method name).
1845          * @see #methodName()
1846          */
1847         public static AccessMode valueFromMethodName(String methodName) {
1848             AccessMode am = methodNameToAccessMode.get(methodName);
1849             if (am != null) return am;
1850             throw new IllegalArgumentException(&quot;No AccessMode value for method name &quot; + methodName);
1851         }
1852 
1853         @ForceInline
1854         static MemberName getMemberName(int ordinal, VarForm vform) {
1855             return vform.memberName_table[ordinal];
1856         }
1857     }
1858 
1859     static final class AccessDescriptor {
1860         final MethodType symbolicMethodTypeErased;
1861         final MethodType symbolicMethodTypeInvoker;
1862         final Class&lt;?&gt; returnType;
1863         final int type;
1864         final int mode;
1865 
1866         public AccessDescriptor(MethodType symbolicMethodType, int type, int mode) {
1867             this.symbolicMethodTypeErased = symbolicMethodType.erase();
1868             this.symbolicMethodTypeInvoker = symbolicMethodType.insertParameterTypes(0, VarHandle.class);
1869             this.returnType = symbolicMethodType.returnType();
1870             this.type = type;
1871             this.mode = mode;
1872         }
1873     }
1874 
1875     /**
1876      * Returns a compact textual description of this {@linkplain VarHandle},
1877      * including the type of variable described, and a description of its coordinates.
1878      *
1879      * @return A compact textual description of this {@linkplain VarHandle}
1880      */
1881     @Override
1882     public final String toString() {
1883         return String.format(&quot;VarHandle[varType=%s, coord=%s]&quot;,
1884                              varType().getName(),
1885                              coordinateTypes());
1886     }
1887 
1888     /**
1889      * Returns the variable type of variables referenced by this VarHandle.
1890      *
1891      * @return the variable type of variables referenced by this VarHandle
1892      */
1893     public final Class&lt;?&gt; varType() {
1894         MethodType typeSet = accessModeType(AccessMode.SET);
1895         return typeSet.parameterType(typeSet.parameterCount() - 1);
1896     }
1897 
1898     /**
1899      * Returns the coordinate types for this VarHandle.
1900      *
1901      * @return the coordinate types for this VarHandle. The returned
1902      * list is unmodifiable
1903      */
1904     public final List&lt;Class&lt;?&gt;&gt; coordinateTypes() {
1905         MethodType typeGet = accessModeType(AccessMode.GET);
1906         return typeGet.parameterList();
1907     }
1908 
1909     /**
1910      * Obtains the access mode type for this VarHandle and a given access mode.
1911      *
1912      * &lt;p&gt;The access mode type&#39;s parameter types will consist of a prefix that
1913      * is the coordinate types of this VarHandle followed by further
1914      * types as defined by the access mode method.
1915      * The access mode type&#39;s return type is defined by the return type of the
1916      * access mode method.
1917      *
1918      * @param accessMode the access mode, corresponding to the
1919      * signature-polymorphic method of the same name
1920      * @return the access mode type for the given access mode
1921      */
1922     public final MethodType accessModeType(AccessMode accessMode) {
1923         TypesAndInvokers tis = getTypesAndInvokers();
1924         MethodType mt = tis.methodType_table[accessMode.at.ordinal()];
1925         if (mt == null) {
1926             mt = tis.methodType_table[accessMode.at.ordinal()] =
1927                     accessModeTypeUncached(accessMode);
1928         }
1929         return mt;
1930     }
1931     abstract MethodType accessModeTypeUncached(AccessMode accessMode);
1932 
1933     /**
1934      * Returns {@code true} if the given access mode is supported, otherwise
1935      * {@code false}.
1936      *
1937      * &lt;p&gt;The return of a {@code false} value for a given access mode indicates
1938      * that an {@code UnsupportedOperationException} is thrown on invocation
1939      * of the corresponding access mode method.
1940      *
1941      * @param accessMode the access mode, corresponding to the
1942      * signature-polymorphic method of the same name
1943      * @return {@code true} if the given access mode is supported, otherwise
1944      * {@code false}.
1945      */
1946     public final boolean isAccessModeSupported(AccessMode accessMode) {
1947         return AccessMode.getMemberName(accessMode.ordinal(), vform) != null;
1948     }
1949 
1950     /**
1951      * Obtains a method handle bound to this VarHandle and the given access
1952      * mode.
1953      *
1954      * @apiNote This method, for a VarHandle {@code vh} and access mode
1955      * {@code {access-mode}}, returns a method handle that is equivalent to
1956      * method handle {@code bmh} in the following code (though it may be more
1957      * efficient):
1958      * &lt;pre&gt;{@code
1959      * MethodHandle mh = MethodHandles.varHandleExactInvoker(
1960      *                       vh.accessModeType(VarHandle.AccessMode.{access-mode}));
1961      *
1962      * MethodHandle bmh = mh.bindTo(vh);
1963      * }&lt;/pre&gt;
1964      *
1965      * @param accessMode the access mode, corresponding to the
1966      * signature-polymorphic method of the same name
1967      * @return a method handle bound to this VarHandle and the given access mode
1968      */
1969     public MethodHandle toMethodHandle(AccessMode accessMode) {
1970         MemberName mn = AccessMode.getMemberName(accessMode.ordinal(), vform);
1971         if (mn != null) {
1972             MethodHandle mh = getMethodHandle(accessMode.ordinal());
1973             return mh.bindTo(this);
1974         }
1975         else {
1976             // Ensure an UnsupportedOperationException is thrown
1977             return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).
1978                     bindTo(this);
1979         }
1980     }
1981 
1982     /**
1983      * Return a nominal descriptor for this instance, if one can be
1984      * constructed, or an empty {@link Optional} if one cannot be.
1985      *
1986      * @return An {@link Optional} containing the resulting nominal descriptor,
1987      * or an empty {@link Optional} if one cannot be constructed.
1988      * @since 12
1989      */
1990     @Override
1991     public Optional&lt;VarHandleDesc&gt; describeConstable() {
1992         // partial function for field and array only
1993         return Optional.empty();
1994     }
1995 
1996     @Stable
1997     TypesAndInvokers typesAndInvokers;
1998 
1999     static class TypesAndInvokers {
2000         final @Stable
2001         MethodType[] methodType_table =
2002                 new MethodType[VarHandle.AccessType.values().length];
2003 
2004         final @Stable
2005         MethodHandle[] methodHandle_table =
2006                 new MethodHandle[AccessMode.values().length];
2007     }
2008 
2009     @ForceInline
2010     private final TypesAndInvokers getTypesAndInvokers() {
2011         TypesAndInvokers tis = typesAndInvokers;
2012         if (tis == null) {
2013             tis = typesAndInvokers = new TypesAndInvokers();
2014         }
2015         return tis;
2016     }
2017 
2018     @ForceInline
2019     MethodHandle getMethodHandle(int mode) {
2020         TypesAndInvokers tis = getTypesAndInvokers();
2021         MethodHandle mh = tis.methodHandle_table[mode];
2022         if (mh == null) {
2023             mh = tis.methodHandle_table[mode] = getMethodHandleUncached(mode);
2024         }
2025         return mh;
2026     }
2027     private final MethodHandle getMethodHandleUncached(int mode) {
2028         MethodType mt = accessModeType(AccessMode.values()[mode]).
2029                 insertParameterTypes(0, VarHandle.class);
2030         MemberName mn = vform.getMemberName(mode);
2031         DirectMethodHandle dmh = DirectMethodHandle.make(mn);
2032         // Such a method handle must not be publically exposed directly
2033         // otherwise it can be cracked, it must be transformed or rebound
2034         // before exposure
2035         MethodHandle mh = dmh.copyWith(mt, dmh.form);
2036         assert mh.type().erase() == mn.getMethodType().erase();
2037         return mh;
2038     }
2039 
2040 
2041     /*non-public*/
2042     final void updateVarForm(VarForm newVForm) {
2043         if (vform == newVForm) return;
2044         UNSAFE.putReference(this, VFORM_OFFSET, newVForm);
2045         UNSAFE.fullFence();
2046     }
2047 
2048     static final BiFunction&lt;String, List&lt;Integer&gt;, ArrayIndexOutOfBoundsException&gt;
2049             AIOOBE_SUPPLIER = Preconditions.outOfBoundsExceptionFormatter(
2050             new Function&lt;String, ArrayIndexOutOfBoundsException&gt;() {
2051                 @Override
2052                 public ArrayIndexOutOfBoundsException apply(String s) {
2053                     return new ArrayIndexOutOfBoundsException(s);
2054                 }
2055             });
2056 
2057     private static final long VFORM_OFFSET;
2058 
2059     static {
2060         VFORM_OFFSET = UNSAFE.objectFieldOffset(VarHandle.class, &quot;vform&quot;);
2061 
2062         // The VarHandleGuards must be initialized to ensure correct
2063         // compilation of the guard methods
2064         UNSAFE.ensureClassInitialized(VarHandleGuards.class);
2065     }
2066 
2067 
2068     // Fence methods
2069 
2070     /**
2071      * Ensures that loads and stores before the fence will not be reordered
2072      * with
2073      * loads and stores after the fence.
2074      *
2075      * @apiNote Ignoring the many semantic differences from C and C++, this
2076      * method has memory ordering effects compatible with
2077      * {@code atomic_thread_fence(memory_order_seq_cst)}
2078      */
2079     @ForceInline
2080     public static void fullFence() {
2081         UNSAFE.fullFence();
2082     }
2083 
2084     /**
2085      * Ensures that loads before the fence will not be reordered with loads and
2086      * stores after the fence.
2087      *
2088      * @apiNote Ignoring the many semantic differences from C and C++, this
2089      * method has memory ordering effects compatible with
2090      * {@code atomic_thread_fence(memory_order_acquire)}
2091      */
2092     @ForceInline
2093     public static void acquireFence() {
2094         UNSAFE.loadFence();
2095     }
2096 
2097     /**
2098      * Ensures that loads and stores before the fence will not be
2099      * reordered with stores after the fence.
2100      *
2101      * @apiNote Ignoring the many semantic differences from C and C++, this
2102      * method has memory ordering effects compatible with
2103      * {@code atomic_thread_fence(memory_order_release)}
2104      */
2105     @ForceInline
2106     public static void releaseFence() {
2107         UNSAFE.storeFence();
2108     }
2109 
2110     /**
2111      * Ensures that loads before the fence will not be reordered with
2112      * loads after the fence.
2113      */
2114     @ForceInline
2115     public static void loadLoadFence() {
2116         UNSAFE.loadLoadFence();
2117     }
2118 
2119     /**
2120      * Ensures that stores before the fence will not be reordered with
2121      * stores after the fence.
2122      */
2123     @ForceInline
2124     public static void storeStoreFence() {
2125         UNSAFE.storeStoreFence();
2126     }
2127 
2128     /**
2129      * A &lt;a href=&quot;{@docRoot}/java.base/java/lang/constant/package-summary.html#nominal&quot;&gt;nominal descriptor&lt;/a&gt; for a
2130      * {@link VarHandle} constant.
2131      *
2132      * @since 12
2133      */
2134     public static final class VarHandleDesc extends DynamicConstantDesc&lt;VarHandle&gt; {
2135 
2136         /**
2137          * Kinds of variable handle descs
2138          */
2139         private enum Kind {
2140             FIELD(ConstantDescs.BSM_VARHANDLE_FIELD),
2141             STATIC_FIELD(ConstantDescs.BSM_VARHANDLE_STATIC_FIELD),
2142             ARRAY(ConstantDescs.BSM_VARHANDLE_ARRAY);
2143 
2144             final DirectMethodHandleDesc bootstrapMethod;
2145 
2146             Kind(DirectMethodHandleDesc bootstrapMethod) {
2147                 this.bootstrapMethod = bootstrapMethod;
2148             }
2149 
2150             ConstantDesc[] toBSMArgs(ClassDesc declaringClass, ClassDesc varType) {
2151                 switch (this) {
2152                     case FIELD:
2153                     case STATIC_FIELD:
2154                         return new ConstantDesc[] {declaringClass, varType };
2155                     case ARRAY:
2156                         return new ConstantDesc[] {declaringClass };
2157                     default:
2158                         throw new InternalError(&quot;Cannot reach here&quot;);
2159                 }
2160             }
2161         }
2162 
2163         private final Kind kind;
2164         private final ClassDesc declaringClass;
2165         private final ClassDesc varType;
2166 
2167         /**
2168          * Construct a {@linkplain VarHandleDesc} given a kind, name, and declaring
2169          * class.
2170          *
2171          * @param kind the kind of the var handle
2172          * @param name the unqualified name of the field, for field var handles; otherwise ignored
2173          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2174          *                       for field var handles
2175          * @param varType a {@link ClassDesc} describing the type of the variable
2176          * @throws NullPointerException if any required argument is null
2177          * @jvms 4.2.2 Unqualified Names
2178          */
2179         private VarHandleDesc(Kind kind, String name, ClassDesc declaringClass, ClassDesc varType) {
2180             super(kind.bootstrapMethod, name,
2181                   ConstantDescs.CD_VarHandle,
2182                   kind.toBSMArgs(declaringClass, varType));
2183             this.kind = kind;
2184             this.declaringClass = declaringClass;
2185             this.varType = varType;
2186         }
2187 
2188         /**
2189          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2190          * for an instance field.
2191          *
2192          * @param name the unqualifed name of the field
2193          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2194          *                       for field var handles
2195          * @param fieldType a {@link ClassDesc} describing the type of the field
2196          * @return the {@linkplain VarHandleDesc}
2197          * @throws NullPointerException if any of the arguments are null
2198          * @jvms 4.2.2 Unqualified Names
2199          */
2200         public static VarHandleDesc ofField(ClassDesc declaringClass, String name, ClassDesc fieldType) {
2201             Objects.requireNonNull(declaringClass);
2202             Objects.requireNonNull(name);
2203             Objects.requireNonNull(fieldType);
2204             return new VarHandleDesc(Kind.FIELD, name, declaringClass, fieldType);
2205         }
2206 
2207         /**
2208          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2209          * for a static field.
2210          *
2211          * @param name the unqualified name of the field
2212          * @param declaringClass a {@link ClassDesc} describing the declaring class,
2213          *                       for field var handles
2214          * @param fieldType a {@link ClassDesc} describing the type of the field
2215          * @return the {@linkplain VarHandleDesc}
2216          * @throws NullPointerException if any of the arguments are null
2217          * @jvms 4.2.2 Unqualified Names
2218          */
2219         public static VarHandleDesc ofStaticField(ClassDesc declaringClass, String name, ClassDesc fieldType) {
2220             Objects.requireNonNull(declaringClass);
2221             Objects.requireNonNull(name);
2222             Objects.requireNonNull(fieldType);
2223             return new VarHandleDesc(Kind.STATIC_FIELD, name, declaringClass, fieldType);
2224         }
2225 
2226         /**
2227          * Returns a {@linkplain VarHandleDesc} corresponding to a {@link VarHandle}
2228          * for an array type.
2229          *
2230          * @param arrayClass a {@link ClassDesc} describing the type of the array
2231          * @return the {@linkplain VarHandleDesc}
2232          * @throws NullPointerException if any of the arguments are null
2233          */
2234         public static VarHandleDesc ofArray(ClassDesc arrayClass) {
2235             Objects.requireNonNull(arrayClass);
2236             if (!arrayClass.isArray())
2237                 throw new IllegalArgumentException(&quot;Array class argument not an array: &quot; + arrayClass);
2238             return new VarHandleDesc(Kind.ARRAY, ConstantDescs.DEFAULT_NAME, arrayClass, arrayClass.componentType());
2239         }
2240 
2241         /**
2242          * Returns a {@link ClassDesc} describing the type of the variable described
2243          * by this descriptor.
2244          *
2245          * @return the variable type
2246          */
2247         public ClassDesc varType() {
2248             return varType;
2249         }
2250 
2251         @Override
2252         public VarHandle resolveConstantDesc(MethodHandles.Lookup lookup)
2253                 throws ReflectiveOperationException {
2254             switch (kind) {
2255                 case FIELD:
2256                     return lookup.findVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup),
2257                                                 constantName(),
2258                                                 (Class&lt;?&gt;) varType.resolveConstantDesc(lookup));
2259                 case STATIC_FIELD:
2260                     return lookup.findStaticVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup),
2261                                                       constantName(),
2262                                                       (Class&lt;?&gt;) varType.resolveConstantDesc(lookup));
2263                 case ARRAY:
2264                     return MethodHandles.arrayElementVarHandle((Class&lt;?&gt;) declaringClass.resolveConstantDesc(lookup));
2265                 default:
2266                     throw new InternalError(&quot;Cannot reach here&quot;);
2267             }
2268         }
2269 
2270         /**
2271          * Returns a compact textual description of this constant description.
2272          * For a field {@linkplain VarHandle}, includes the owner, name, and type
2273          * of the field, and whether it is static; for an array {@linkplain VarHandle},
2274          * the name of the component type.
2275          *
2276          * @return A compact textual description of this descriptor
2277          */
2278         @Override
2279         public String toString() {
2280             switch (kind) {
2281                 case FIELD:
2282                 case STATIC_FIELD:
2283                     return String.format(&quot;VarHandleDesc[%s%s.%s:%s]&quot;,
2284                                          (kind == Kind.STATIC_FIELD) ? &quot;static &quot; : &quot;&quot;,
2285                                          declaringClass.displayName(), constantName(), varType.displayName());
2286                 case ARRAY:
2287                     return String.format(&quot;VarHandleDesc[%s[]]&quot;, declaringClass.displayName());
2288                 default:
2289                     throw new InternalError(&quot;Cannot reach here&quot;);
2290             }
2291         }
2292     }
2293 
2294 }
    </pre>
  </body>
</html>