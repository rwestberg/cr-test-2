<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X-VarHandleByteArrayView.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/X-VarHandleMemoryAddressView.java.template</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 76     static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
 77         long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
 78         if ((address &amp; VM_ALIGN) != 0) {
 79             throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
 80         }
 81         return address;
 82     }
 83 
 84     @ForceInline
 85     static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
 86         long base = bb.unsafeGetOffset();
 87         long address = base + offset;
 88         //note: the offset portion has already been aligned-checked, by construction
 89         if ((base &amp; alignmentMask) != 0) {
 90             throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
 91         }
 92         return address;
 93     }
 94     
 95     @ForceInline
<span class="line-modified"> 96     static $type$ get0(VarHandleMemoryAddressBase handle, Object obb, long base) {</span>

 97         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
 98 #if[floatingPoint]
 99         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
100                 bb.unsafeGetBase(),
101                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
102                 handle.be);
103         return $Type$.$rawType$BitsTo$Type$(rawValue);
104 #else[floatingPoint]
105 #if[byte]
106         return UNSAFE.get$Type$(
107                 bb.unsafeGetBase(),
108                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
109 #else[byte]
110         return UNSAFE.get$Type$Unaligned(
111                 bb.unsafeGetBase(),
112                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
113                 handle.be);
114 #end[byte]
115 #end[floatingPoint]
116     }
117 
118     @ForceInline
<span class="line-modified">119     static void set0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

120         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
121 #if[floatingPoint]
122         UNSAFE.put$RawType$Unaligned(
123                 bb.unsafeGetBase(),
124                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
125                 $Type$.$type$ToRaw$RawType$Bits(value),
126                 handle.be);
127 #else[floatingPoint]
128 #if[byte]
129         UNSAFE.put$Type$(
130                 bb.unsafeGetBase(),
131                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
132                 value);
133 #else[byte]
134         UNSAFE.put$Type$Unaligned(
135                 bb.unsafeGetBase(),
136                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
137                 value,
138                 handle.be);
139 #end[byte]
140 #end[floatingPoint]
141     }
142 
143     @ForceInline
<span class="line-modified">144     static $type$ getVolatile0(VarHandleMemoryAddressBase handle, Object obb, long base) {</span>

145         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
146         return convEndian(handle.be,
147                           UNSAFE.get$RawType$Volatile(
148                                   bb.unsafeGetBase(),
149                                   offset(bb, base, handle.alignmentMask)));
150     }
151 
152     @ForceInline
<span class="line-modified">153     static void setVolatile0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

154         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
155         UNSAFE.put$RawType$Volatile(
156                 bb.unsafeGetBase(),
157                 offset(bb, base, handle.alignmentMask),
158                 convEndian(handle.be, value));
159     }
160 
161     @ForceInline
<span class="line-modified">162     static $type$ getAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base) {</span>

163         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
164         return convEndian(handle.be,
165                           UNSAFE.get$RawType$Acquire(
166                                   bb.unsafeGetBase(),
167                                   offset(bb, base, handle.alignmentMask)));
168     }
169 
170     @ForceInline
<span class="line-modified">171     static void setRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

172         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
173         UNSAFE.put$RawType$Release(
174                 bb.unsafeGetBase(),
175                 offset(bb, base, handle.alignmentMask),
176                 convEndian(handle.be, value));
177     }
178 
179     @ForceInline
<span class="line-modified">180     static $type$ getOpaque0(VarHandleMemoryAddressBase handle, Object obb, long base) {</span>

181         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
182         return convEndian(handle.be,
183                           UNSAFE.get$RawType$Opaque(
184                                   bb.unsafeGetBase(),
185                                   offset(bb, base, handle.alignmentMask)));
186     }
187 
188     @ForceInline
<span class="line-modified">189     static void setOpaque0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

190         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
191         UNSAFE.put$RawType$Opaque(
192                 bb.unsafeGetBase(),
193                 offset(bb, base, handle.alignmentMask),
194                 convEndian(handle.be, value));
195     }
196 #if[CAS]
197 
198     @ForceInline
<span class="line-modified">199     static boolean compareAndSet0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

200         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
201         return UNSAFE.compareAndSet$RawType$(
202                 bb.unsafeGetBase(),
203                 offset(bb, base, handle.alignmentMask),
204                 convEndian(handle.be, expected), convEndian(handle.be, value));
205     }
206 
207     @ForceInline
<span class="line-modified">208     static $type$ compareAndExchange0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

209         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
210         return convEndian(handle.be,
211                           UNSAFE.compareAndExchange$RawType$(
212                                   bb.unsafeGetBase(),
213                                   offset(bb, base, handle.alignmentMask),
214                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
215     }
216 
217     @ForceInline
<span class="line-modified">218     static $type$ compareAndExchangeAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

219         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
220         return convEndian(handle.be,
221                           UNSAFE.compareAndExchange$RawType$Acquire(
222                                   bb.unsafeGetBase(),
223                                   offset(bb, base, handle.alignmentMask),
224                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
225     }
226 
227     @ForceInline
<span class="line-modified">228     static $type$ compareAndExchangeRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

229         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
230         return convEndian(handle.be,
231                           UNSAFE.compareAndExchange$RawType$Release(
232                                   bb.unsafeGetBase(),
233                                   offset(bb, base, handle.alignmentMask),
234                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
235     }
236 
237     @ForceInline
<span class="line-modified">238     static boolean weakCompareAndSetPlain0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

239         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
240         return UNSAFE.weakCompareAndSet$RawType$Plain(
241                 bb.unsafeGetBase(),
242                 offset(bb, base, handle.alignmentMask),
243                 convEndian(handle.be, expected), convEndian(handle.be, value));
244     }
245 
246     @ForceInline
<span class="line-modified">247     static boolean weakCompareAndSet0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

248         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
249         return UNSAFE.weakCompareAndSet$RawType$(
250                 bb.unsafeGetBase(),
251                 offset(bb, base, handle.alignmentMask),
252                 convEndian(handle.be, expected), convEndian(handle.be, value));
253     }
254 
255     @ForceInline
<span class="line-modified">256     static boolean weakCompareAndSetAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

257         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
258         return UNSAFE.weakCompareAndSet$RawType$Acquire(
259                 bb.unsafeGetBase(),
260                 offset(bb, base, handle.alignmentMask),
261                 convEndian(handle.be, expected), convEndian(handle.be, value));
262     }
263 
264     @ForceInline
<span class="line-modified">265     static boolean weakCompareAndSetRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ expected, $type$ value) {</span>

266         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
267         return UNSAFE.weakCompareAndSet$RawType$Release(
268                 bb.unsafeGetBase(),
269                 offset(bb, base, handle.alignmentMask),
270                 convEndian(handle.be, expected), convEndian(handle.be, value));
271     }
272 
273     @ForceInline
<span class="line-modified">274     static $type$ getAndSet0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

275         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
276         return convEndian(handle.be,
277                           UNSAFE.getAndSet$RawType$(
278                                   bb.unsafeGetBase(),
279                                   offset(bb, base, handle.alignmentMask),
280                                   convEndian(handle.be, value)));
281     }
282 
283     @ForceInline
<span class="line-modified">284     static $type$ getAndSetAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

285         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
286         return convEndian(handle.be,
287                           UNSAFE.getAndSet$RawType$Acquire(
288                                   bb.unsafeGetBase(),
289                                   offset(bb, base, handle.alignmentMask),
290                                   convEndian(handle.be, value)));
291     }
292 
293     @ForceInline
<span class="line-modified">294     static $type$ getAndSetRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

295         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
296         return convEndian(handle.be,
297                           UNSAFE.getAndSet$RawType$Release(
298                                   bb.unsafeGetBase(),
299                                   offset(bb, base, handle.alignmentMask),
300                                   convEndian(handle.be, value)));
301     }
302 #end[CAS]
303 #if[AtomicAdd]
304 
305     @ForceInline
<span class="line-modified">306     static $type$ getAndAdd0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ delta) {</span>

307         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
308         if (handle.be == BE) {
309             return UNSAFE.getAndAdd$RawType$(
310                     bb.unsafeGetBase(),
311                     offset(bb, base, handle.alignmentMask),
312                     delta);
313         } else {
314             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
315         }
316     }
317 
318     @ForceInline
<span class="line-modified">319     static $type$ getAndAddAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ delta) {</span>

320         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
321         if (handle.be == BE) {
322             return UNSAFE.getAndAdd$RawType$Acquire(
323                     bb.unsafeGetBase(),
324                     offset(bb, base, handle.alignmentMask),
325                     delta);
326         } else {
327             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
328         }
329     }
330 
331     @ForceInline
<span class="line-modified">332     static $type$ getAndAddRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ delta) {</span>

333         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
334         if (handle.be == BE) {
335             return UNSAFE.getAndAdd$RawType$Release(
336                     bb.unsafeGetBase(),
337                     offset(bb, base, handle.alignmentMask),
338                     delta);
339         } else {
340             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
341         }
342     }
343 
344     @ForceInline
345     static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
346         $type$ nativeExpectedValue, expectedValue;
347         Object base = bb.unsafeGetBase();
348         do {
349             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
350             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
351         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
352                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
353         return expectedValue;
354     }
355 #end[AtomicAdd]
356 #if[Bitwise]
357 
358     @ForceInline
<span class="line-modified">359     static $type$ getAndBitwiseOr0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

360         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
361         if (handle.be == BE) {
362             return UNSAFE.getAndBitwiseOr$RawType$(
363                     bb.unsafeGetBase(),
364                     offset(bb, base, handle.alignmentMask),
365                     value);
366         } else {
367             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
368         }
369     }
370 
371     @ForceInline
<span class="line-modified">372     static $type$ getAndBitwiseOrRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

373         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
374         if (handle.be == BE) {
375             return UNSAFE.getAndBitwiseOr$RawType$Release(
376                     bb.unsafeGetBase(),
377                     offset(bb, base, handle.alignmentMask),
378                     value);
379         } else {
380             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
381         }
382     }
383 
384     @ForceInline
<span class="line-modified">385     static $type$ getAndBitwiseOrAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

386         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
387         if (handle.be == BE) {
388             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
389                     bb.unsafeGetBase(),
390                     offset(bb, base, handle.alignmentMask),
391                     value);
392         } else {
393             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
394         }
395     }
396 
397     @ForceInline
398     static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
399         $type$ nativeExpectedValue, expectedValue;
400         Object base = bb.unsafeGetBase();
401         do {
402             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
403             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
404         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
405                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
406         return expectedValue;
407     }
408 
409     @ForceInline
<span class="line-modified">410     static $type$ getAndBitwiseAnd0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

411         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
412         if (handle.be == BE) {
413             return UNSAFE.getAndBitwiseAnd$RawType$(
414                     bb.unsafeGetBase(),
415                     offset(bb, base, handle.alignmentMask),
416                     value);
417         } else {
418             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
419         }
420     }
421 
422     @ForceInline
<span class="line-modified">423     static $type$ getAndBitwiseAndRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

424         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
425         if (handle.be == BE) {
426             return UNSAFE.getAndBitwiseAnd$RawType$Release(
427                     bb.unsafeGetBase(),
428                     offset(bb, base, handle.alignmentMask),
429                     value);
430         } else {
431             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
432         }
433     }
434 
435     @ForceInline
<span class="line-modified">436     static $type$ getAndBitwiseAndAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

437         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
438         if (handle.be == BE) {
439             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
440                     bb.unsafeGetBase(),
441                     offset(bb, base, handle.alignmentMask),
442                     value);
443         } else {
444             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
445         }
446     }
447 
448     @ForceInline
449     static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
450         $type$ nativeExpectedValue, expectedValue;
451         Object base = bb.unsafeGetBase();
452         do {
453             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
454             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
455         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
456                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
457         return expectedValue;
458     }
459 
460 
461     @ForceInline
<span class="line-modified">462     static $type$ getAndBitwiseXor0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

463         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
464         if (handle.be == BE) {
465             return UNSAFE.getAndBitwiseXor$RawType$(
466                     bb.unsafeGetBase(),
467                     offset(bb, base, handle.alignmentMask),
468                     value);
469         } else {
470             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
471         }
472     }
473 
474     @ForceInline
<span class="line-modified">475     static $type$ getAndBitwiseXorRelease0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

476         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
477         if (handle.be == BE) {
478             return UNSAFE.getAndBitwiseXor$RawType$Release(
479                     bb.unsafeGetBase(),
480                     offset(bb, base, handle.alignmentMask),
481                     value);
482         } else {
483             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
484         }
485     }
486 
487     @ForceInline
<span class="line-modified">488     static $type$ getAndBitwiseXorAcquire0(VarHandleMemoryAddressBase handle, Object obb, long base, $type$ value) {</span>

489         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
490         if (handle.be == BE) {
491             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
492                     bb.unsafeGetBase(),
493                     offset(bb, base, handle.alignmentMask),
494                     value);
495         } else {
496             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
497         }
498     }
499 
500     @ForceInline
501     static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
502         $type$ nativeExpectedValue, expectedValue;
503         Object base = bb.unsafeGetBase();
504         do {
505             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
506             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
507         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
508                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
</pre>
</td>
<td>
<hr />
<pre>
 76     static long offset(MemoryAddressProxy bb, long offset, long alignmentMask) {
 77         long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);
 78         if ((address &amp; VM_ALIGN) != 0) {
 79             throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
 80         }
 81         return address;
 82     }
 83 
 84     @ForceInline
 85     static long offsetNoVMAlignCheck(MemoryAddressProxy bb, long offset, long alignmentMask) {
 86         long base = bb.unsafeGetOffset();
 87         long address = base + offset;
 88         //note: the offset portion has already been aligned-checked, by construction
 89         if ((base &amp; alignmentMask) != 0) {
 90             throw VarHandleMemoryAddressBase.newIllegalStateExceptionForMisalignedAccess(address);
 91         }
 92         return address;
 93     }
 94     
 95     @ForceInline
<span class="line-modified"> 96     static $type$ get0(VarHandle ob, Object obb, long base) {</span>
<span class="line-added"> 97         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
 98         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
 99 #if[floatingPoint]
100         $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(
101                 bb.unsafeGetBase(),
102                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
103                 handle.be);
104         return $Type$.$rawType$BitsTo$Type$(rawValue);
105 #else[floatingPoint]
106 #if[byte]
107         return UNSAFE.get$Type$(
108                 bb.unsafeGetBase(),
109                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask));
110 #else[byte]
111         return UNSAFE.get$Type$Unaligned(
112                 bb.unsafeGetBase(),
113                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
114                 handle.be);
115 #end[byte]
116 #end[floatingPoint]
117     }
118 
119     @ForceInline
<span class="line-modified">120     static void set0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">121         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
122         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
123 #if[floatingPoint]
124         UNSAFE.put$RawType$Unaligned(
125                 bb.unsafeGetBase(),
126                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
127                 $Type$.$type$ToRaw$RawType$Bits(value),
128                 handle.be);
129 #else[floatingPoint]
130 #if[byte]
131         UNSAFE.put$Type$(
132                 bb.unsafeGetBase(),
133                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
134                 value);
135 #else[byte]
136         UNSAFE.put$Type$Unaligned(
137                 bb.unsafeGetBase(),
138                 offsetNoVMAlignCheck(bb, base, handle.alignmentMask),
139                 value,
140                 handle.be);
141 #end[byte]
142 #end[floatingPoint]
143     }
144 
145     @ForceInline
<span class="line-modified">146     static $type$ getVolatile0(VarHandle ob, Object obb, long base) {</span>
<span class="line-added">147         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
148         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
149         return convEndian(handle.be,
150                           UNSAFE.get$RawType$Volatile(
151                                   bb.unsafeGetBase(),
152                                   offset(bb, base, handle.alignmentMask)));
153     }
154 
155     @ForceInline
<span class="line-modified">156     static void setVolatile0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">157         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
158         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
159         UNSAFE.put$RawType$Volatile(
160                 bb.unsafeGetBase(),
161                 offset(bb, base, handle.alignmentMask),
162                 convEndian(handle.be, value));
163     }
164 
165     @ForceInline
<span class="line-modified">166     static $type$ getAcquire0(VarHandle ob, Object obb, long base) {</span>
<span class="line-added">167         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
168         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
169         return convEndian(handle.be,
170                           UNSAFE.get$RawType$Acquire(
171                                   bb.unsafeGetBase(),
172                                   offset(bb, base, handle.alignmentMask)));
173     }
174 
175     @ForceInline
<span class="line-modified">176     static void setRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">177         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
178         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
179         UNSAFE.put$RawType$Release(
180                 bb.unsafeGetBase(),
181                 offset(bb, base, handle.alignmentMask),
182                 convEndian(handle.be, value));
183     }
184 
185     @ForceInline
<span class="line-modified">186     static $type$ getOpaque0(VarHandle ob, Object obb, long base) {</span>
<span class="line-added">187         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
188         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, true);
189         return convEndian(handle.be,
190                           UNSAFE.get$RawType$Opaque(
191                                   bb.unsafeGetBase(),
192                                   offset(bb, base, handle.alignmentMask)));
193     }
194 
195     @ForceInline
<span class="line-modified">196     static void setOpaque0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">197         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
198         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
199         UNSAFE.put$RawType$Opaque(
200                 bb.unsafeGetBase(),
201                 offset(bb, base, handle.alignmentMask),
202                 convEndian(handle.be, value));
203     }
204 #if[CAS]
205 
206     @ForceInline
<span class="line-modified">207     static boolean compareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">208         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
209         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
210         return UNSAFE.compareAndSet$RawType$(
211                 bb.unsafeGetBase(),
212                 offset(bb, base, handle.alignmentMask),
213                 convEndian(handle.be, expected), convEndian(handle.be, value));
214     }
215 
216     @ForceInline
<span class="line-modified">217     static $type$ compareAndExchange0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">218         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
219         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
220         return convEndian(handle.be,
221                           UNSAFE.compareAndExchange$RawType$(
222                                   bb.unsafeGetBase(),
223                                   offset(bb, base, handle.alignmentMask),
224                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
225     }
226 
227     @ForceInline
<span class="line-modified">228     static $type$ compareAndExchangeAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">229         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
230         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
231         return convEndian(handle.be,
232                           UNSAFE.compareAndExchange$RawType$Acquire(
233                                   bb.unsafeGetBase(),
234                                   offset(bb, base, handle.alignmentMask),
235                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
236     }
237 
238     @ForceInline
<span class="line-modified">239     static $type$ compareAndExchangeRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">240         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
241         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
242         return convEndian(handle.be,
243                           UNSAFE.compareAndExchange$RawType$Release(
244                                   bb.unsafeGetBase(),
245                                   offset(bb, base, handle.alignmentMask),
246                                   convEndian(handle.be, expected), convEndian(handle.be, value)));
247     }
248 
249     @ForceInline
<span class="line-modified">250     static boolean weakCompareAndSetPlain0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">251         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
252         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
253         return UNSAFE.weakCompareAndSet$RawType$Plain(
254                 bb.unsafeGetBase(),
255                 offset(bb, base, handle.alignmentMask),
256                 convEndian(handle.be, expected), convEndian(handle.be, value));
257     }
258 
259     @ForceInline
<span class="line-modified">260     static boolean weakCompareAndSet0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">261         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
262         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
263         return UNSAFE.weakCompareAndSet$RawType$(
264                 bb.unsafeGetBase(),
265                 offset(bb, base, handle.alignmentMask),
266                 convEndian(handle.be, expected), convEndian(handle.be, value));
267     }
268 
269     @ForceInline
<span class="line-modified">270     static boolean weakCompareAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">271         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
272         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
273         return UNSAFE.weakCompareAndSet$RawType$Acquire(
274                 bb.unsafeGetBase(),
275                 offset(bb, base, handle.alignmentMask),
276                 convEndian(handle.be, expected), convEndian(handle.be, value));
277     }
278 
279     @ForceInline
<span class="line-modified">280     static boolean weakCompareAndSetRelease0(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {</span>
<span class="line-added">281         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
282         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
283         return UNSAFE.weakCompareAndSet$RawType$Release(
284                 bb.unsafeGetBase(),
285                 offset(bb, base, handle.alignmentMask),
286                 convEndian(handle.be, expected), convEndian(handle.be, value));
287     }
288 
289     @ForceInline
<span class="line-modified">290     static $type$ getAndSet0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">291         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
292         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
293         return convEndian(handle.be,
294                           UNSAFE.getAndSet$RawType$(
295                                   bb.unsafeGetBase(),
296                                   offset(bb, base, handle.alignmentMask),
297                                   convEndian(handle.be, value)));
298     }
299 
300     @ForceInline
<span class="line-modified">301     static $type$ getAndSetAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">302         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
303         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
304         return convEndian(handle.be,
305                           UNSAFE.getAndSet$RawType$Acquire(
306                                   bb.unsafeGetBase(),
307                                   offset(bb, base, handle.alignmentMask),
308                                   convEndian(handle.be, value)));
309     }
310 
311     @ForceInline
<span class="line-modified">312     static $type$ getAndSetRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">313         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
314         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
315         return convEndian(handle.be,
316                           UNSAFE.getAndSet$RawType$Release(
317                                   bb.unsafeGetBase(),
318                                   offset(bb, base, handle.alignmentMask),
319                                   convEndian(handle.be, value)));
320     }
321 #end[CAS]
322 #if[AtomicAdd]
323 
324     @ForceInline
<span class="line-modified">325     static $type$ getAndAdd0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
<span class="line-added">326         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
327         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
328         if (handle.be == BE) {
329             return UNSAFE.getAndAdd$RawType$(
330                     bb.unsafeGetBase(),
331                     offset(bb, base, handle.alignmentMask),
332                     delta);
333         } else {
334             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
335         }
336     }
337 
338     @ForceInline
<span class="line-modified">339     static $type$ getAndAddAcquire0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
<span class="line-added">340         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
341         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
342         if (handle.be == BE) {
343             return UNSAFE.getAndAdd$RawType$Acquire(
344                     bb.unsafeGetBase(),
345                     offset(bb, base, handle.alignmentMask),
346                     delta);
347         } else {
348             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
349         }
350     }
351 
352     @ForceInline
<span class="line-modified">353     static $type$ getAndAddRelease0(VarHandle ob, Object obb, long base, $type$ delta) {</span>
<span class="line-added">354         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
355         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
356         if (handle.be == BE) {
357             return UNSAFE.getAndAdd$RawType$Release(
358                     bb.unsafeGetBase(),
359                     offset(bb, base, handle.alignmentMask),
360                     delta);
361         } else {
362             return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);
363         }
364     }
365 
366     @ForceInline
367     static $type$ getAndAddConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ delta) {
368         $type$ nativeExpectedValue, expectedValue;
369         Object base = bb.unsafeGetBase();
370         do {
371             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
372             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
373         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
374                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));
375         return expectedValue;
376     }
377 #end[AtomicAdd]
378 #if[Bitwise]
379 
380     @ForceInline
<span class="line-modified">381     static $type$ getAndBitwiseOr0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">382         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
383         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
384         if (handle.be == BE) {
385             return UNSAFE.getAndBitwiseOr$RawType$(
386                     bb.unsafeGetBase(),
387                     offset(bb, base, handle.alignmentMask),
388                     value);
389         } else {
390             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
391         }
392     }
393 
394     @ForceInline
<span class="line-modified">395     static $type$ getAndBitwiseOrRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">396         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
397         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
398         if (handle.be == BE) {
399             return UNSAFE.getAndBitwiseOr$RawType$Release(
400                     bb.unsafeGetBase(),
401                     offset(bb, base, handle.alignmentMask),
402                     value);
403         } else {
404             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
405         }
406     }
407 
408     @ForceInline
<span class="line-modified">409     static $type$ getAndBitwiseOrAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">410         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
411         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
412         if (handle.be == BE) {
413             return UNSAFE.getAndBitwiseOr$RawType$Acquire(
414                     bb.unsafeGetBase(),
415                     offset(bb, base, handle.alignmentMask),
416                     value);
417         } else {
418             return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
419         }
420     }
421 
422     @ForceInline
423     static $type$ getAndBitwiseOrConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
424         $type$ nativeExpectedValue, expectedValue;
425         Object base = bb.unsafeGetBase();
426         do {
427             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
428             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
429         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
430                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));
431         return expectedValue;
432     }
433 
434     @ForceInline
<span class="line-modified">435     static $type$ getAndBitwiseAnd0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">436         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
437         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
438         if (handle.be == BE) {
439             return UNSAFE.getAndBitwiseAnd$RawType$(
440                     bb.unsafeGetBase(),
441                     offset(bb, base, handle.alignmentMask),
442                     value);
443         } else {
444             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
445         }
446     }
447 
448     @ForceInline
<span class="line-modified">449     static $type$ getAndBitwiseAndRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">450         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
451         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
452         if (handle.be == BE) {
453             return UNSAFE.getAndBitwiseAnd$RawType$Release(
454                     bb.unsafeGetBase(),
455                     offset(bb, base, handle.alignmentMask),
456                     value);
457         } else {
458             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
459         }
460     }
461 
462     @ForceInline
<span class="line-modified">463     static $type$ getAndBitwiseAndAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">464         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
465         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
466         if (handle.be == BE) {
467             return UNSAFE.getAndBitwiseAnd$RawType$Acquire(
468                     bb.unsafeGetBase(),
469                     offset(bb, base, handle.alignmentMask),
470                     value);
471         } else {
472             return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
473         }
474     }
475 
476     @ForceInline
477     static $type$ getAndBitwiseAndConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
478         $type$ nativeExpectedValue, expectedValue;
479         Object base = bb.unsafeGetBase();
480         do {
481             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
482             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
483         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
484                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue &amp; value)));
485         return expectedValue;
486     }
487 
488 
489     @ForceInline
<span class="line-modified">490     static $type$ getAndBitwiseXor0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">491         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
492         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
493         if (handle.be == BE) {
494             return UNSAFE.getAndBitwiseXor$RawType$(
495                     bb.unsafeGetBase(),
496                     offset(bb, base, handle.alignmentMask),
497                     value);
498         } else {
499             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
500         }
501     }
502 
503     @ForceInline
<span class="line-modified">504     static $type$ getAndBitwiseXorRelease0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">505         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
506         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
507         if (handle.be == BE) {
508             return UNSAFE.getAndBitwiseXor$RawType$Release(
509                     bb.unsafeGetBase(),
510                     offset(bb, base, handle.alignmentMask),
511                     value);
512         } else {
513             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
514         }
515     }
516 
517     @ForceInline
<span class="line-modified">518     static $type$ getAndBitwiseXorAcquire0(VarHandle ob, Object obb, long base, $type$ value) {</span>
<span class="line-added">519         VarHandleMemoryAddressBase handle = (VarHandleMemoryAddressBase)ob;</span>
520         MemoryAddressProxy bb = checkAddress(obb, base, handle.length, false);
521         if (handle.be == BE) {
522             return UNSAFE.getAndBitwiseXor$RawType$Acquire(
523                     bb.unsafeGetBase(),
524                     offset(bb, base, handle.alignmentMask),
525                     value);
526         } else {
527             return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);
528         }
529     }
530 
531     @ForceInline
532     static $type$ getAndBitwiseXorConvEndianWithCAS(MemoryAddressProxy bb, long offset, $type$ value) {
533         $type$ nativeExpectedValue, expectedValue;
534         Object base = bb.unsafeGetBase();
535         do {
536             nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);
537             expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);
538         } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,
539                 nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));
</pre>
</td>
</tr>
</table>
<center><a href="X-VarHandleByteArrayView.java.template.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/lang/invoke/VarHandles/VarHandleTestMethodTypeBoolean.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>