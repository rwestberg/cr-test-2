<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/ppc/sharedRuntime_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/vtableStubs.hpp&quot;
  31 #include &quot;frame_ppc.hpp&quot;
  32 #include &quot;gc/shared/gcLocker.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;interpreter/interp_masm.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;oops/compiledICHolder.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/vframeArray.hpp&quot;
  41 #include &quot;utilities/align.hpp&quot;
  42 #include &quot;vmreg_ppc.inline.hpp&quot;
  43 #ifdef COMPILER1
  44 #include &quot;c1/c1_Runtime1.hpp&quot;
  45 #endif
  46 #ifdef COMPILER2
  47 #include &quot;opto/ad.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #endif
  50 
  51 #include &lt;alloca.h&gt;
  52 
  53 #define __ masm-&gt;
  54 
  55 #ifdef PRODUCT
  56 #define BLOCK_COMMENT(str) // nothing
  57 #else
  58 #define BLOCK_COMMENT(str) __ block_comment(str)
  59 #endif
  60 
  61 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  62 
  63 
  64 class RegisterSaver {
  65  // Used for saving volatile registers.
  66  public:
  67 
  68   // Support different return pc locations.
  69   enum ReturnPCLocation {
  70     return_pc_is_lr,
  71     return_pc_is_pre_saved,
  72     return_pc_is_thread_saved_exception_pc
  73   };
  74 
  75   static OopMap* push_frame_reg_args_and_save_live_registers(MacroAssembler* masm,
  76                          int* out_frame_size_in_bytes,
  77                          bool generate_oop_map,
  78                          int return_pc_adjustment,
  79                          ReturnPCLocation return_pc_location,
  80                          bool save_vectors = false);
  81   static void    restore_live_registers_and_pop_frame(MacroAssembler* masm,
  82                          int frame_size_in_bytes,
  83                          bool restore_ctr,
  84                          bool save_vectors = false);
  85 
  86   static void push_frame_and_save_argument_registers(MacroAssembler* masm,
  87                          Register r_temp,
  88                          int frame_size,
  89                          int total_args,
  90                          const VMRegPair *regs, const VMRegPair *regs2 = NULL);
  91   static void restore_argument_registers_and_pop_frame(MacroAssembler*masm,
  92                          int frame_size,
  93                          int total_args,
  94                          const VMRegPair *regs, const VMRegPair *regs2 = NULL);
  95 
  96   // During deoptimization only the result registers need to be restored
  97   // all the other values have already been extracted.
  98   static void restore_result_registers(MacroAssembler* masm, int frame_size_in_bytes);
  99 
 100   // Constants and data structures:
 101 
 102   typedef enum {
 103     int_reg,
 104     float_reg,
 105     special_reg,
 106     vs_reg
 107   } RegisterType;
 108 
 109   typedef enum {
 110     reg_size          = 8,
 111     half_reg_size     = reg_size / 2,
 112     vs_reg_size       = 16
 113   } RegisterConstants;
 114 
 115   typedef struct {
 116     RegisterType        reg_type;
 117     int                 reg_num;
 118     VMReg               vmreg;
 119   } LiveRegType;
 120 };
 121 
 122 
 123 #define RegisterSaver_LiveIntReg(regname) \
 124   { RegisterSaver::int_reg,     regname-&gt;encoding(), regname-&gt;as_VMReg() }
 125 
 126 #define RegisterSaver_LiveFloatReg(regname) \
 127   { RegisterSaver::float_reg,   regname-&gt;encoding(), regname-&gt;as_VMReg() }
 128 
 129 #define RegisterSaver_LiveSpecialReg(regname) \
 130   { RegisterSaver::special_reg, regname-&gt;encoding(), regname-&gt;as_VMReg() }
 131 
 132 #define RegisterSaver_LiveVSReg(regname) \
 133   { RegisterSaver::vs_reg,      regname-&gt;encoding(), regname-&gt;as_VMReg() }
 134 
 135 static const RegisterSaver::LiveRegType RegisterSaver_LiveRegs[] = {
 136   // Live registers which get spilled to the stack. Register
 137   // positions in this array correspond directly to the stack layout.
 138 
 139   //
 140   // live special registers:
 141   //
 142   RegisterSaver_LiveSpecialReg(SR_CTR),
 143   //
 144   // live float registers:
 145   //
 146   RegisterSaver_LiveFloatReg( F0  ),
 147   RegisterSaver_LiveFloatReg( F1  ),
 148   RegisterSaver_LiveFloatReg( F2  ),
 149   RegisterSaver_LiveFloatReg( F3  ),
 150   RegisterSaver_LiveFloatReg( F4  ),
 151   RegisterSaver_LiveFloatReg( F5  ),
 152   RegisterSaver_LiveFloatReg( F6  ),
 153   RegisterSaver_LiveFloatReg( F7  ),
 154   RegisterSaver_LiveFloatReg( F8  ),
 155   RegisterSaver_LiveFloatReg( F9  ),
 156   RegisterSaver_LiveFloatReg( F10 ),
 157   RegisterSaver_LiveFloatReg( F11 ),
 158   RegisterSaver_LiveFloatReg( F12 ),
 159   RegisterSaver_LiveFloatReg( F13 ),
 160   RegisterSaver_LiveFloatReg( F14 ),
 161   RegisterSaver_LiveFloatReg( F15 ),
 162   RegisterSaver_LiveFloatReg( F16 ),
 163   RegisterSaver_LiveFloatReg( F17 ),
 164   RegisterSaver_LiveFloatReg( F18 ),
 165   RegisterSaver_LiveFloatReg( F19 ),
 166   RegisterSaver_LiveFloatReg( F20 ),
 167   RegisterSaver_LiveFloatReg( F21 ),
 168   RegisterSaver_LiveFloatReg( F22 ),
 169   RegisterSaver_LiveFloatReg( F23 ),
 170   RegisterSaver_LiveFloatReg( F24 ),
 171   RegisterSaver_LiveFloatReg( F25 ),
 172   RegisterSaver_LiveFloatReg( F26 ),
 173   RegisterSaver_LiveFloatReg( F27 ),
 174   RegisterSaver_LiveFloatReg( F28 ),
 175   RegisterSaver_LiveFloatReg( F29 ),
 176   RegisterSaver_LiveFloatReg( F30 ),
 177   RegisterSaver_LiveFloatReg( F31 ),
 178   //
 179   // live integer registers:
 180   //
 181   RegisterSaver_LiveIntReg(   R0  ),
 182   //RegisterSaver_LiveIntReg( R1  ), // stack pointer
 183   RegisterSaver_LiveIntReg(   R2  ),
 184   RegisterSaver_LiveIntReg(   R3  ),
 185   RegisterSaver_LiveIntReg(   R4  ),
 186   RegisterSaver_LiveIntReg(   R5  ),
 187   RegisterSaver_LiveIntReg(   R6  ),
 188   RegisterSaver_LiveIntReg(   R7  ),
 189   RegisterSaver_LiveIntReg(   R8  ),
 190   RegisterSaver_LiveIntReg(   R9  ),
 191   RegisterSaver_LiveIntReg(   R10 ),
 192   RegisterSaver_LiveIntReg(   R11 ),
 193   RegisterSaver_LiveIntReg(   R12 ),
 194   //RegisterSaver_LiveIntReg( R13 ), // system thread id
 195   RegisterSaver_LiveIntReg(   R14 ),
 196   RegisterSaver_LiveIntReg(   R15 ),
 197   RegisterSaver_LiveIntReg(   R16 ),
 198   RegisterSaver_LiveIntReg(   R17 ),
 199   RegisterSaver_LiveIntReg(   R18 ),
 200   RegisterSaver_LiveIntReg(   R19 ),
 201   RegisterSaver_LiveIntReg(   R20 ),
 202   RegisterSaver_LiveIntReg(   R21 ),
 203   RegisterSaver_LiveIntReg(   R22 ),
 204   RegisterSaver_LiveIntReg(   R23 ),
 205   RegisterSaver_LiveIntReg(   R24 ),
 206   RegisterSaver_LiveIntReg(   R25 ),
 207   RegisterSaver_LiveIntReg(   R26 ),
 208   RegisterSaver_LiveIntReg(   R27 ),
 209   RegisterSaver_LiveIntReg(   R28 ),
 210   RegisterSaver_LiveIntReg(   R29 ),
 211   RegisterSaver_LiveIntReg(   R30 ),
 212   RegisterSaver_LiveIntReg(   R31 )  // must be the last register (see save/restore functions below)
 213 };
 214 
 215 static const RegisterSaver::LiveRegType RegisterSaver_LiveVSRegs[] = {
 216   //
 217   // live vector scalar registers (optional, only these ones are used by C2):
 218   //
 219   RegisterSaver_LiveVSReg( VSR32 ),
 220   RegisterSaver_LiveVSReg( VSR33 ),
 221   RegisterSaver_LiveVSReg( VSR34 ),
 222   RegisterSaver_LiveVSReg( VSR35 ),
 223   RegisterSaver_LiveVSReg( VSR36 ),
 224   RegisterSaver_LiveVSReg( VSR37 ),
 225   RegisterSaver_LiveVSReg( VSR38 ),
 226   RegisterSaver_LiveVSReg( VSR39 ),
 227   RegisterSaver_LiveVSReg( VSR40 ),
 228   RegisterSaver_LiveVSReg( VSR41 ),
 229   RegisterSaver_LiveVSReg( VSR42 ),
 230   RegisterSaver_LiveVSReg( VSR43 ),
 231   RegisterSaver_LiveVSReg( VSR44 ),
 232   RegisterSaver_LiveVSReg( VSR45 ),
 233   RegisterSaver_LiveVSReg( VSR46 ),
 234   RegisterSaver_LiveVSReg( VSR47 ),
 235   RegisterSaver_LiveVSReg( VSR48 ),
 236   RegisterSaver_LiveVSReg( VSR49 ),
 237   RegisterSaver_LiveVSReg( VSR50 ),
 238   RegisterSaver_LiveVSReg( VSR51 )
 239 };
 240 
 241 
 242 OopMap* RegisterSaver::push_frame_reg_args_and_save_live_registers(MacroAssembler* masm,
 243                          int* out_frame_size_in_bytes,
 244                          bool generate_oop_map,
 245                          int return_pc_adjustment,
 246                          ReturnPCLocation return_pc_location,
 247                          bool save_vectors) {
 248   // Push an abi_reg_args-frame and store all registers which may be live.
 249   // If requested, create an OopMap: Record volatile registers as
 250   // callee-save values in an OopMap so their save locations will be
 251   // propagated to the RegisterMap of the caller frame during
 252   // StackFrameStream construction (needed for deoptimization; see
 253   // compiledVFrame::create_stack_value).
 254   // If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.
 255   // Updated return pc is returned in R31 (if not return_pc_is_pre_saved).
 256 
 257   // calcualte frame size
 258   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 259                                    sizeof(RegisterSaver::LiveRegType);
 260   const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) /
 261                                                    sizeof(RegisterSaver::LiveRegType))
 262                                                 : 0;
 263   const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;
 264   const int frame_size_in_bytes  = align_up(register_save_size, frame::alignment_in_bytes)
 265                                    + frame::abi_reg_args_size;
 266 
 267   *out_frame_size_in_bytes       = frame_size_in_bytes;
 268   const int frame_size_in_slots  = frame_size_in_bytes / sizeof(jint);
 269   const int register_save_offset = frame_size_in_bytes - register_save_size;
 270 
 271   // OopMap frame size is in c2 stack slots (sizeof(jint)) not bytes or words.
 272   OopMap* map = generate_oop_map ? new OopMap(frame_size_in_slots, 0) : NULL;
 273 
 274   BLOCK_COMMENT(&quot;push_frame_reg_args_and_save_live_registers {&quot;);
 275 
 276   // push a new frame
 277   __ push_frame(frame_size_in_bytes, noreg);
 278 
 279   // Save some registers in the last (non-vector) slots of the new frame so we
 280   // can use them as scratch regs or to determine the return pc.
 281   __ std(R31, frame_size_in_bytes -   reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 282   __ std(R30, frame_size_in_bytes - 2*reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 283 
 284   // save the flags
 285   // Do the save_LR_CR by hand and adjust the return pc if requested.
 286   __ mfcr(R30);
 287   __ std(R30, frame_size_in_bytes + _abi(cr), R1_SP);
 288   switch (return_pc_location) {
 289     case return_pc_is_lr: __ mflr(R31); break;
 290     case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, &quot;unsupported&quot;); break;
 291     case return_pc_is_thread_saved_exception_pc: __ ld(R31, thread_(saved_exception_pc)); break;
 292     default: ShouldNotReachHere();
 293   }
 294   if (return_pc_location != return_pc_is_pre_saved) {
 295     if (return_pc_adjustment != 0) {
 296       __ addi(R31, R31, return_pc_adjustment);
 297     }
 298     __ std(R31, frame_size_in_bytes + _abi(lr), R1_SP);
 299   }
 300 
 301   // save all registers (ints and floats)
 302   int offset = register_save_offset;
 303 
 304   for (int i = 0; i &lt; regstosave_num; i++) {
 305     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 306     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 307 
 308     switch (reg_type) {
 309       case RegisterSaver::int_reg: {
 310         if (reg_num &lt; 30) { // We spilled R30-31 right at the beginning.
 311           __ std(as_Register(reg_num), offset, R1_SP);
 312         }
 313         break;
 314       }
 315       case RegisterSaver::float_reg: {
 316         __ stfd(as_FloatRegister(reg_num), offset, R1_SP);
 317         break;
 318       }
 319       case RegisterSaver::special_reg: {
 320         if (reg_num == SR_CTR_SpecialRegisterEnumValue) {
 321           __ mfctr(R30);
 322           __ std(R30, offset, R1_SP);
 323         } else {
 324           Unimplemented();
 325         }
 326         break;
 327       }
 328       default:
 329         ShouldNotReachHere();
 330     }
 331 
 332     if (generate_oop_map) {
 333       map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset&gt;&gt;2),
 334                             RegisterSaver_LiveRegs[i].vmreg);
 335       map-&gt;set_callee_saved(VMRegImpl::stack2reg((offset + half_reg_size)&gt;&gt;2),
 336                             RegisterSaver_LiveRegs[i].vmreg-&gt;next());
 337     }
 338     offset += reg_size;
 339   }
 340 
 341   for (int i = 0; i &lt; vsregstosave_num; i++) {
 342     int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;
 343     int reg_type = RegisterSaver_LiveVSRegs[i].reg_type;
 344 
 345     __ li(R30, offset);
 346     __ stxvd2x(as_VectorSRegister(reg_num), R30, R1_SP);
 347 
 348     if (generate_oop_map) {
 349       map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset&gt;&gt;2),
 350                             RegisterSaver_LiveVSRegs[i].vmreg);
 351     }
 352     offset += vs_reg_size;
 353   }
 354 
 355   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 356 
 357   BLOCK_COMMENT(&quot;} push_frame_reg_args_and_save_live_registers&quot;);
 358 
 359   // And we&#39;re done.
 360   return map;
 361 }
 362 
 363 
 364 // Pop the current frame and restore all the registers that we
 365 // saved.
 366 void RegisterSaver::restore_live_registers_and_pop_frame(MacroAssembler* masm,
 367                                                          int frame_size_in_bytes,
 368                                                          bool restore_ctr,
 369                                                          bool save_vectors) {
 370   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 371                                    sizeof(RegisterSaver::LiveRegType);
 372   const int vsregstosave_num     = save_vectors ? (sizeof(RegisterSaver_LiveVSRegs) /
 373                                                    sizeof(RegisterSaver::LiveRegType))
 374                                                 : 0;
 375   const int register_save_size   = regstosave_num * reg_size + vsregstosave_num * vs_reg_size;
 376 
 377   const int register_save_offset = frame_size_in_bytes - register_save_size;
 378 
 379   BLOCK_COMMENT(&quot;restore_live_registers_and_pop_frame {&quot;);
 380 
 381   // restore all registers (ints and floats)
 382   int offset = register_save_offset;
 383 
 384   for (int i = 0; i &lt; regstosave_num; i++) {
 385     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 386     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 387 
 388     switch (reg_type) {
 389       case RegisterSaver::int_reg: {
 390         if (reg_num != 31) // R31 restored at the end, it&#39;s the tmp reg!
 391           __ ld(as_Register(reg_num), offset, R1_SP);
 392         break;
 393       }
 394       case RegisterSaver::float_reg: {
 395         __ lfd(as_FloatRegister(reg_num), offset, R1_SP);
 396         break;
 397       }
 398       case RegisterSaver::special_reg: {
 399         if (reg_num == SR_CTR_SpecialRegisterEnumValue) {
 400           if (restore_ctr) { // Nothing to do here if ctr already contains the next address.
 401             __ ld(R31, offset, R1_SP);
 402             __ mtctr(R31);
 403           }
 404         } else {
 405           Unimplemented();
 406         }
 407         break;
 408       }
 409       default:
 410         ShouldNotReachHere();
 411     }
 412     offset += reg_size;
 413   }
 414 
 415   for (int i = 0; i &lt; vsregstosave_num; i++) {
 416     int reg_num  = RegisterSaver_LiveVSRegs[i].reg_num;
 417     int reg_type = RegisterSaver_LiveVSRegs[i].reg_type;
 418 
 419     __ li(R31, offset);
 420     __ lxvd2x(as_VectorSRegister(reg_num), R31, R1_SP);
 421 
 422     offset += vs_reg_size;
 423   }
 424 
 425   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 426 
 427   // restore link and the flags
 428   __ ld(R31, frame_size_in_bytes + _abi(lr), R1_SP);
 429   __ mtlr(R31);
 430 
 431   __ ld(R31, frame_size_in_bytes + _abi(cr), R1_SP);
 432   __ mtcr(R31);
 433 
 434   // restore scratch register&#39;s value
 435   __ ld(R31, frame_size_in_bytes - reg_size - vsregstosave_num * vs_reg_size, R1_SP);
 436 
 437   // pop the frame
 438   __ addi(R1_SP, R1_SP, frame_size_in_bytes);
 439 
 440   BLOCK_COMMENT(&quot;} restore_live_registers_and_pop_frame&quot;);
 441 }
 442 
 443 void RegisterSaver::push_frame_and_save_argument_registers(MacroAssembler* masm, Register r_temp,
 444                                                            int frame_size,int total_args, const VMRegPair *regs,
 445                                                            const VMRegPair *regs2) {
 446   __ push_frame(frame_size, r_temp);
 447   int st_off = frame_size - wordSize;
 448   for (int i = 0; i &lt; total_args; i++) {
 449     VMReg r_1 = regs[i].first();
 450     VMReg r_2 = regs[i].second();
 451     if (!r_1-&gt;is_valid()) {
 452       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 453       continue;
 454     }
 455     if (r_1-&gt;is_Register()) {
 456       Register r = r_1-&gt;as_Register();
 457       __ std(r, st_off, R1_SP);
 458       st_off -= wordSize;
 459     } else if (r_1-&gt;is_FloatRegister()) {
 460       FloatRegister f = r_1-&gt;as_FloatRegister();
 461       __ stfd(f, st_off, R1_SP);
 462       st_off -= wordSize;
 463     }
 464   }
 465   if (regs2 != NULL) {
 466     for (int i = 0; i &lt; total_args; i++) {
 467       VMReg r_1 = regs2[i].first();
 468       VMReg r_2 = regs2[i].second();
 469       if (!r_1-&gt;is_valid()) {
 470         assert(!r_2-&gt;is_valid(), &quot;&quot;);
 471         continue;
 472       }
 473       if (r_1-&gt;is_Register()) {
 474         Register r = r_1-&gt;as_Register();
 475         __ std(r, st_off, R1_SP);
 476         st_off -= wordSize;
 477       } else if (r_1-&gt;is_FloatRegister()) {
 478         FloatRegister f = r_1-&gt;as_FloatRegister();
 479         __ stfd(f, st_off, R1_SP);
 480         st_off -= wordSize;
 481       }
 482     }
 483   }
 484 }
 485 
 486 void RegisterSaver::restore_argument_registers_and_pop_frame(MacroAssembler*masm, int frame_size,
 487                                                              int total_args, const VMRegPair *regs,
 488                                                              const VMRegPair *regs2) {
 489   int st_off = frame_size - wordSize;
 490   for (int i = 0; i &lt; total_args; i++) {
 491     VMReg r_1 = regs[i].first();
 492     VMReg r_2 = regs[i].second();
 493     if (r_1-&gt;is_Register()) {
 494       Register r = r_1-&gt;as_Register();
 495       __ ld(r, st_off, R1_SP);
 496       st_off -= wordSize;
 497     } else if (r_1-&gt;is_FloatRegister()) {
 498       FloatRegister f = r_1-&gt;as_FloatRegister();
 499       __ lfd(f, st_off, R1_SP);
 500       st_off -= wordSize;
 501     }
 502   }
 503   if (regs2 != NULL)
 504     for (int i = 0; i &lt; total_args; i++) {
 505       VMReg r_1 = regs2[i].first();
 506       VMReg r_2 = regs2[i].second();
 507       if (r_1-&gt;is_Register()) {
 508         Register r = r_1-&gt;as_Register();
 509         __ ld(r, st_off, R1_SP);
 510         st_off -= wordSize;
 511       } else if (r_1-&gt;is_FloatRegister()) {
 512         FloatRegister f = r_1-&gt;as_FloatRegister();
 513         __ lfd(f, st_off, R1_SP);
 514         st_off -= wordSize;
 515       }
 516     }
 517   __ pop_frame();
 518 }
 519 
 520 // Restore the registers that might be holding a result.
 521 void RegisterSaver::restore_result_registers(MacroAssembler* masm, int frame_size_in_bytes) {
 522   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 523                                    sizeof(RegisterSaver::LiveRegType);
 524   const int register_save_size   = regstosave_num * reg_size; // VS registers not relevant here.
 525   const int register_save_offset = frame_size_in_bytes - register_save_size;
 526 
 527   // restore all result registers (ints and floats)
 528   int offset = register_save_offset;
 529   for (int i = 0; i &lt; regstosave_num; i++) {
 530     int reg_num  = RegisterSaver_LiveRegs[i].reg_num;
 531     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 532     switch (reg_type) {
 533       case RegisterSaver::int_reg: {
 534         if (as_Register(reg_num)==R3_RET) // int result_reg
 535           __ ld(as_Register(reg_num), offset, R1_SP);
 536         break;
 537       }
 538       case RegisterSaver::float_reg: {
 539         if (as_FloatRegister(reg_num)==F1_RET) // float result_reg
 540           __ lfd(as_FloatRegister(reg_num), offset, R1_SP);
 541         break;
 542       }
 543       case RegisterSaver::special_reg: {
 544         // Special registers don&#39;t hold a result.
 545         break;
 546       }
 547       default:
 548         ShouldNotReachHere();
 549     }
 550     offset += reg_size;
 551   }
 552 
 553   assert(offset == frame_size_in_bytes, &quot;consistency check&quot;);
 554 }
 555 
 556 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 557 bool SharedRuntime::is_wide_vector(int size) {
 558   // Note, MaxVectorSize == 8/16 on PPC64.
 559   assert(size &lt;= (SuperwordUseVSX ? 16 : 8), &quot;%d bytes vectors are not supported&quot;, size);
 560   return size &gt; 8;
 561 }
 562 
 563 size_t SharedRuntime::trampoline_size() {
 564   return Assembler::load_const_size + 8;
 565 }
 566 
 567 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 568   Register Rtemp = R12;
 569   __ load_const(Rtemp, destination);
 570   __ mtctr(Rtemp);
 571   __ bctr();
 572 }
 573 
 574 static int reg2slot(VMReg r) {
 575   return r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 576 }
 577 
 578 static int reg2offset(VMReg r) {
 579   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 580 }
 581 
 582 // ---------------------------------------------------------------------------
 583 // Read the array of BasicTypes from a signature, and compute where the
 584 // arguments should go. Values in the VMRegPair regs array refer to 4-byte
 585 // quantities. Values less than VMRegImpl::stack0 are registers, those above
 586 // refer to 4-byte stack slots. All stack slots are based off of the stack pointer
 587 // as framesizes are fixed.
 588 // VMRegImpl::stack0 refers to the first slot 0(sp).
 589 // and VMRegImpl::stack0+1 refers to the memory word 4-bytes higher. Register
 590 // up to RegisterImpl::number_of_registers) are the 64-bit
 591 // integer registers.
 592 
 593 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 594 // either 32-bit or 64-bit depending on the build. The OUTPUTS are in 32-bit
 595 // units regardless of build. Of course for i486 there is no 64 bit build
 596 
 597 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 598 // By skipping the first C ABI register we can call non-static jni methods
 599 // with small numbers of arguments without having to shuffle the arguments
 600 // at all. Since we control the java ABI we ought to at least get some
 601 // advantage out of it.
 602 
 603 const VMReg java_iarg_reg[8] = {
 604   R3-&gt;as_VMReg(),
 605   R4-&gt;as_VMReg(),
 606   R5-&gt;as_VMReg(),
 607   R6-&gt;as_VMReg(),
 608   R7-&gt;as_VMReg(),
 609   R8-&gt;as_VMReg(),
 610   R9-&gt;as_VMReg(),
 611   R10-&gt;as_VMReg()
 612 };
 613 
 614 const VMReg java_farg_reg[13] = {
 615   F1-&gt;as_VMReg(),
 616   F2-&gt;as_VMReg(),
 617   F3-&gt;as_VMReg(),
 618   F4-&gt;as_VMReg(),
 619   F5-&gt;as_VMReg(),
 620   F6-&gt;as_VMReg(),
 621   F7-&gt;as_VMReg(),
 622   F8-&gt;as_VMReg(),
 623   F9-&gt;as_VMReg(),
 624   F10-&gt;as_VMReg(),
 625   F11-&gt;as_VMReg(),
 626   F12-&gt;as_VMReg(),
 627   F13-&gt;as_VMReg()
 628 };
 629 
 630 const int num_java_iarg_registers = sizeof(java_iarg_reg) / sizeof(java_iarg_reg[0]);
 631 const int num_java_farg_registers = sizeof(java_farg_reg) / sizeof(java_farg_reg[0]);
 632 
 633 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 634                                            VMRegPair *regs,
 635                                            int total_args_passed,
 636                                            int is_outgoing) {
 637   // C2c calling conventions for compiled-compiled calls.
 638   // Put 8 ints/longs into registers _AND_ 13 float/doubles into
 639   // registers _AND_ put the rest on the stack.
 640 
 641   const int inc_stk_for_intfloat   = 1; // 1 slots for ints and floats
 642   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles
 643 
 644   int i;
 645   VMReg reg;
 646   int stk = 0;
 647   int ireg = 0;
 648   int freg = 0;
 649 
 650   // We put the first 8 arguments into registers and the rest on the
 651   // stack, float arguments are already in their argument registers
 652   // due to c2c calling conventions (see calling_convention).
 653   for (int i = 0; i &lt; total_args_passed; ++i) {
 654     switch(sig_bt[i]) {
 655     case T_BOOLEAN:
 656     case T_CHAR:
 657     case T_BYTE:
 658     case T_SHORT:
 659     case T_INT:
 660       if (ireg &lt; num_java_iarg_registers) {
 661         // Put int/ptr in register
 662         reg = java_iarg_reg[ireg];
 663         ++ireg;
 664       } else {
 665         // Put int/ptr on stack.
 666         reg = VMRegImpl::stack2reg(stk);
 667         stk += inc_stk_for_intfloat;
 668       }
 669       regs[i].set1(reg);
 670       break;
 671     case T_LONG:
 672       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 673       if (ireg &lt; num_java_iarg_registers) {
 674         // Put long in register.
 675         reg = java_iarg_reg[ireg];
 676         ++ireg;
 677       } else {
 678         // Put long on stack. They must be aligned to 2 slots.
 679         if (stk &amp; 0x1) ++stk;
 680         reg = VMRegImpl::stack2reg(stk);
 681         stk += inc_stk_for_longdouble;
 682       }
 683       regs[i].set2(reg);
 684       break;
 685     case T_OBJECT:
 686     case T_ARRAY:
 687     case T_ADDRESS:
 688       if (ireg &lt; num_java_iarg_registers) {
 689         // Put ptr in register.
 690         reg = java_iarg_reg[ireg];
 691         ++ireg;
 692       } else {
 693         // Put ptr on stack. Objects must be aligned to 2 slots too,
 694         // because &quot;64-bit pointers record oop-ishness on 2 aligned
 695         // adjacent registers.&quot; (see OopFlow::build_oop_map).
 696         if (stk &amp; 0x1) ++stk;
 697         reg = VMRegImpl::stack2reg(stk);
 698         stk += inc_stk_for_longdouble;
 699       }
 700       regs[i].set2(reg);
 701       break;
 702     case T_FLOAT:
 703       if (freg &lt; num_java_farg_registers) {
 704         // Put float in register.
 705         reg = java_farg_reg[freg];
 706         ++freg;
 707       } else {
 708         // Put float on stack.
 709         reg = VMRegImpl::stack2reg(stk);
 710         stk += inc_stk_for_intfloat;
 711       }
 712       regs[i].set1(reg);
 713       break;
 714     case T_DOUBLE:
 715       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 716       if (freg &lt; num_java_farg_registers) {
 717         // Put double in register.
 718         reg = java_farg_reg[freg];
 719         ++freg;
 720       } else {
 721         // Put double on stack. They must be aligned to 2 slots.
 722         if (stk &amp; 0x1) ++stk;
 723         reg = VMRegImpl::stack2reg(stk);
 724         stk += inc_stk_for_longdouble;
 725       }
 726       regs[i].set2(reg);
 727       break;
 728     case T_VOID:
 729       // Do not count halves.
 730       regs[i].set_bad();
 731       break;
 732     default:
 733       ShouldNotReachHere();
 734     }
 735   }
 736   return align_up(stk, 2);
 737 }
 738 
 739 #if defined(COMPILER1) || defined(COMPILER2)
 740 // Calling convention for calling C code.
 741 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 742                                         VMRegPair *regs,
 743                                         VMRegPair *regs2,
 744                                         int total_args_passed) {
 745   // Calling conventions for C runtime calls and calls to JNI native methods.
 746   //
 747   // PPC64 convention: Hoist the first 8 int/ptr/long&#39;s in the first 8
 748   // int regs, leaving int regs undefined if the arg is flt/dbl. Hoist
 749   // the first 13 flt/dbl&#39;s in the first 13 fp regs but additionally
 750   // copy flt/dbl to the stack if they are beyond the 8th argument.
 751 
 752   const VMReg iarg_reg[8] = {
 753     R3-&gt;as_VMReg(),
 754     R4-&gt;as_VMReg(),
 755     R5-&gt;as_VMReg(),
 756     R6-&gt;as_VMReg(),
 757     R7-&gt;as_VMReg(),
 758     R8-&gt;as_VMReg(),
 759     R9-&gt;as_VMReg(),
 760     R10-&gt;as_VMReg()
 761   };
 762 
 763   const VMReg farg_reg[13] = {
 764     F1-&gt;as_VMReg(),
 765     F2-&gt;as_VMReg(),
 766     F3-&gt;as_VMReg(),
 767     F4-&gt;as_VMReg(),
 768     F5-&gt;as_VMReg(),
 769     F6-&gt;as_VMReg(),
 770     F7-&gt;as_VMReg(),
 771     F8-&gt;as_VMReg(),
 772     F9-&gt;as_VMReg(),
 773     F10-&gt;as_VMReg(),
 774     F11-&gt;as_VMReg(),
 775     F12-&gt;as_VMReg(),
 776     F13-&gt;as_VMReg()
 777   };
 778 
 779   // Check calling conventions consistency.
 780   assert(sizeof(iarg_reg) / sizeof(iarg_reg[0]) == Argument::n_int_register_parameters_c &amp;&amp;
 781          sizeof(farg_reg) / sizeof(farg_reg[0]) == Argument::n_float_register_parameters_c,
 782          &quot;consistency&quot;);
 783 
 784   // `Stk&#39; counts stack slots. Due to alignment, 32 bit values occupy
 785   // 2 such slots, like 64 bit values do.
 786   const int inc_stk_for_intfloat   = 2; // 2 slots for ints and floats
 787   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles
 788 
 789   int i;
 790   VMReg reg;
 791   // Leave room for C-compatible ABI_REG_ARGS.
 792   int stk = (frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size;
 793   int arg = 0;
 794   int freg = 0;
 795 
 796   // Avoid passing C arguments in the wrong stack slots.
 797 #if defined(ABI_ELFv2)
 798   assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 96,
 799          &quot;passing C arguments in wrong stack slots&quot;);
 800 #else
 801   assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 112,
 802          &quot;passing C arguments in wrong stack slots&quot;);
 803 #endif
 804   // We fill-out regs AND regs2 if an argument must be passed in a
 805   // register AND in a stack slot. If regs2 is NULL in such a
 806   // situation, we bail-out with a fatal error.
 807   for (int i = 0; i &lt; total_args_passed; ++i, ++arg) {
 808     // Initialize regs2 to BAD.
 809     if (regs2 != NULL) regs2[i].set_bad();
 810 
 811     switch(sig_bt[i]) {
 812 
 813     //
 814     // If arguments 0-7 are integers, they are passed in integer registers.
 815     // Argument i is placed in iarg_reg[i].
 816     //
 817     case T_BOOLEAN:
 818     case T_CHAR:
 819     case T_BYTE:
 820     case T_SHORT:
 821     case T_INT:
 822       // We must cast ints to longs and use full 64 bit stack slots
 823       // here.  Thus fall through, handle as long.
 824     case T_LONG:
 825     case T_OBJECT:
 826     case T_ARRAY:
 827     case T_ADDRESS:
 828     case T_METADATA:
 829       // Oops are already boxed if required (JNI).
 830       if (arg &lt; Argument::n_int_register_parameters_c) {
 831         reg = iarg_reg[arg];
 832       } else {
 833         reg = VMRegImpl::stack2reg(stk);
 834         stk += inc_stk_for_longdouble;
 835       }
 836       regs[i].set2(reg);
 837       break;
 838 
 839     //
 840     // Floats are treated differently from int regs:  The first 13 float arguments
 841     // are passed in registers (not the float args among the first 13 args).
 842     // Thus argument i is NOT passed in farg_reg[i] if it is float.  It is passed
 843     // in farg_reg[j] if argument i is the j-th float argument of this call.
 844     //
 845     case T_FLOAT:
 846 #if defined(LINUX)
 847       // Linux uses ELF ABI. Both original ELF and ELFv2 ABIs have float
 848       // in the least significant word of an argument slot.
 849 #if defined(VM_LITTLE_ENDIAN)
 850 #define FLOAT_WORD_OFFSET_IN_SLOT 0
 851 #else
 852 #define FLOAT_WORD_OFFSET_IN_SLOT 1
 853 #endif
 854 #elif defined(AIX)
 855       // Although AIX runs on big endian CPU, float is in the most
 856       // significant word of an argument slot.
 857 #define FLOAT_WORD_OFFSET_IN_SLOT 0
 858 #else
 859 #error &quot;unknown OS&quot;
 860 #endif
 861       if (freg &lt; Argument::n_float_register_parameters_c) {
 862         // Put float in register ...
 863         reg = farg_reg[freg];
 864         ++freg;
 865 
 866         // Argument i for i &gt; 8 is placed on the stack even if it&#39;s
 867         // placed in a register (if it&#39;s a float arg). Aix disassembly
 868         // shows that xlC places these float args on the stack AND in
 869         // a register. This is not documented, but we follow this
 870         // convention, too.
 871         if (arg &gt;= Argument::n_regs_not_on_stack_c) {
 872           // ... and on the stack.
 873           guarantee(regs2 != NULL, &quot;must pass float in register and stack slot&quot;);
 874           VMReg reg2 = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);
 875           regs2[i].set1(reg2);
 876           stk += inc_stk_for_intfloat;
 877         }
 878 
 879       } else {
 880         // Put float on stack.
 881         reg = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);
 882         stk += inc_stk_for_intfloat;
 883       }
 884       regs[i].set1(reg);
 885       break;
 886     case T_DOUBLE:
 887       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 888       if (freg &lt; Argument::n_float_register_parameters_c) {
 889         // Put double in register ...
 890         reg = farg_reg[freg];
 891         ++freg;
 892 
 893         // Argument i for i &gt; 8 is placed on the stack even if it&#39;s
 894         // placed in a register (if it&#39;s a double arg). Aix disassembly
 895         // shows that xlC places these float args on the stack AND in
 896         // a register. This is not documented, but we follow this
 897         // convention, too.
 898         if (arg &gt;= Argument::n_regs_not_on_stack_c) {
 899           // ... and on the stack.
 900           guarantee(regs2 != NULL, &quot;must pass float in register and stack slot&quot;);
 901           VMReg reg2 = VMRegImpl::stack2reg(stk);
 902           regs2[i].set2(reg2);
 903           stk += inc_stk_for_longdouble;
 904         }
 905       } else {
 906         // Put double on stack.
 907         reg = VMRegImpl::stack2reg(stk);
 908         stk += inc_stk_for_longdouble;
 909       }
 910       regs[i].set2(reg);
 911       break;
 912 
 913     case T_VOID:
 914       // Do not count halves.
 915       regs[i].set_bad();
 916       --arg;
 917       break;
 918     default:
 919       ShouldNotReachHere();
 920     }
 921   }
 922 
 923   return align_up(stk, 2);
 924 }
 925 #endif // COMPILER2
 926 
 927 static address gen_c2i_adapter(MacroAssembler *masm,
 928                             int total_args_passed,
 929                             int comp_args_on_stack,
 930                             const BasicType *sig_bt,
 931                             const VMRegPair *regs,
 932                             Label&amp; call_interpreter,
 933                             const Register&amp; ientry) {
 934 
 935   address c2i_entrypoint;
 936 
 937   const Register sender_SP = R21_sender_SP; // == R21_tmp1
 938   const Register code      = R22_tmp2;
 939   //const Register ientry  = R23_tmp3;
 940   const Register value_regs[] = { R24_tmp4, R25_tmp5, R26_tmp6 };
 941   const int num_value_regs = sizeof(value_regs) / sizeof(Register);
 942   int value_regs_index = 0;
 943 
 944   const Register return_pc = R27_tmp7;
 945   const Register tmp       = R28_tmp8;
 946 
 947   assert_different_registers(sender_SP, code, ientry, return_pc, tmp);
 948 
 949   // Adapter needs TOP_IJAVA_FRAME_ABI.
 950   const int adapter_size = frame::top_ijava_frame_abi_size +
 951                            align_up(total_args_passed * wordSize, frame::alignment_in_bytes);
 952 
 953   // regular (verified) c2i entry point
 954   c2i_entrypoint = __ pc();
 955 
 956   // Does compiled code exists? If yes, patch the caller&#39;s callsite.
 957   __ ld(code, method_(code));
 958   __ cmpdi(CCR0, code, 0);
 959   __ ld(ientry, method_(interpreter_entry)); // preloaded
 960   __ beq(CCR0, call_interpreter);
 961 
 962 
 963   // Patch caller&#39;s callsite, method_(code) was not NULL which means that
 964   // compiled code exists.
 965   __ mflr(return_pc);
 966   __ std(return_pc, _abi(lr), R1_SP);
 967   RegisterSaver::push_frame_and_save_argument_registers(masm, tmp, adapter_size, total_args_passed, regs);
 968 
 969   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite), R19_method, return_pc);
 970 
 971   RegisterSaver::restore_argument_registers_and_pop_frame(masm, adapter_size, total_args_passed, regs);
 972   __ ld(return_pc, _abi(lr), R1_SP);
 973   __ ld(ientry, method_(interpreter_entry)); // preloaded
 974   __ mtlr(return_pc);
 975 
 976 
 977   // Call the interpreter.
 978   __ BIND(call_interpreter);
 979   __ mtctr(ientry);
 980 
 981   // Get a copy of the current SP for loading caller&#39;s arguments.
 982   __ mr(sender_SP, R1_SP);
 983 
 984   // Add space for the adapter.
 985   __ resize_frame(-adapter_size, R12_scratch2);
 986 
 987   int st_off = adapter_size - wordSize;
 988 
 989   // Write the args into the outgoing interpreter space.
 990   for (int i = 0; i &lt; total_args_passed; i++) {
 991     VMReg r_1 = regs[i].first();
 992     VMReg r_2 = regs[i].second();
 993     if (!r_1-&gt;is_valid()) {
 994       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 995       continue;
 996     }
 997     if (r_1-&gt;is_stack()) {
 998       Register tmp_reg = value_regs[value_regs_index];
 999       value_regs_index = (value_regs_index + 1) % num_value_regs;
1000       // The calling convention produces OptoRegs that ignore the out
1001       // preserve area (JIT&#39;s ABI). We must account for it here.
1002       int ld_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
1003       if (!r_2-&gt;is_valid()) {
1004         __ lwz(tmp_reg, ld_off, sender_SP);
1005       } else {
1006         __ ld(tmp_reg, ld_off, sender_SP);
1007       }
1008       // Pretend stack targets were loaded into tmp_reg.
1009       r_1 = tmp_reg-&gt;as_VMReg();
1010     }
1011 
1012     if (r_1-&gt;is_Register()) {
1013       Register r = r_1-&gt;as_Register();
1014       if (!r_2-&gt;is_valid()) {
1015         __ stw(r, st_off, R1_SP);
1016         st_off-=wordSize;
1017       } else {
1018         // Longs are given 2 64-bit slots in the interpreter, but the
1019         // data is passed in only 1 slot.
1020         if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
1021           DEBUG_ONLY( __ li(tmp, 0); __ std(tmp, st_off, R1_SP); )
1022           st_off-=wordSize;
1023         }
1024         __ std(r, st_off, R1_SP);
1025         st_off-=wordSize;
1026       }
1027     } else {
1028       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
1029       FloatRegister f = r_1-&gt;as_FloatRegister();
1030       if (!r_2-&gt;is_valid()) {
1031         __ stfs(f, st_off, R1_SP);
1032         st_off-=wordSize;
1033       } else {
1034         // In 64bit, doubles are given 2 64-bit slots in the interpreter, but the
1035         // data is passed in only 1 slot.
1036         // One of these should get known junk...
1037         DEBUG_ONLY( __ li(tmp, 0); __ std(tmp, st_off, R1_SP); )
1038         st_off-=wordSize;
1039         __ stfd(f, st_off, R1_SP);
1040         st_off-=wordSize;
1041       }
1042     }
1043   }
1044 
1045   // Jump to the interpreter just as if interpreter was doing it.
1046 
1047   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
1048 
1049   // load TOS
1050   __ addi(R15_esp, R1_SP, st_off);
1051 
1052   // Frame_manager expects initial_caller_sp (= SP without resize by c2i) in R21_tmp1.
1053   assert(sender_SP == R21_sender_SP, &quot;passing initial caller&#39;s SP in wrong register&quot;);
1054   __ bctr();
1055 
1056   return c2i_entrypoint;
1057 }
1058 
1059 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
1060                                     int total_args_passed,
1061                                     int comp_args_on_stack,
1062                                     const BasicType *sig_bt,
1063                                     const VMRegPair *regs) {
1064 
1065   // Load method&#39;s entry-point from method.
1066   __ ld(R12_scratch2, in_bytes(Method::from_compiled_offset()), R19_method);
1067   __ mtctr(R12_scratch2);
1068 
1069   // We will only enter here from an interpreted frame and never from after
1070   // passing thru a c2i. Azul allowed this but we do not. If we lose the
1071   // race and use a c2i we will remain interpreted for the race loser(s).
1072   // This removes all sorts of headaches on the x86 side and also eliminates
1073   // the possibility of having c2i -&gt; i2c -&gt; c2i -&gt; ... endless transitions.
1074 
1075   // Note: r13 contains the senderSP on entry. We must preserve it since
1076   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
1077   // code goes non-entrant while we get args ready.
1078   // In addition we use r13 to locate all the interpreter args as
1079   // we must align the stack to 16 bytes on an i2c entry else we
1080   // lose alignment we expect in all compiled code and register
1081   // save code can segv when fxsave instructions find improperly
1082   // aligned stack pointer.
1083 
1084   const Register ld_ptr = R15_esp;
1085   const Register value_regs[] = { R22_tmp2, R23_tmp3, R24_tmp4, R25_tmp5, R26_tmp6 };
1086   const int num_value_regs = sizeof(value_regs) / sizeof(Register);
1087   int value_regs_index = 0;
1088 
1089   int ld_offset = total_args_passed*wordSize;
1090 
1091   // Cut-out for having no stack args. Since up to 2 int/oop args are passed
1092   // in registers, we will occasionally have no stack args.
1093   int comp_words_on_stack = 0;
1094   if (comp_args_on_stack) {
1095     // Sig words on the stack are greater-than VMRegImpl::stack0. Those in
1096     // registers are below. By subtracting stack0, we either get a negative
1097     // number (all values in registers) or the maximum stack slot accessed.
1098 
1099     // Convert 4-byte c2 stack slots to words.
1100     comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
1101     // Round up to miminum stack alignment, in wordSize.
1102     comp_words_on_stack = align_up(comp_words_on_stack, 2);
1103     __ resize_frame(-comp_words_on_stack * wordSize, R11_scratch1);
1104   }
1105 
1106   // Now generate the shuffle code.  Pick up all register args and move the
1107   // rest through register value=Z_R12.
1108   BLOCK_COMMENT(&quot;Shuffle arguments&quot;);
1109   for (int i = 0; i &lt; total_args_passed; i++) {
1110     if (sig_bt[i] == T_VOID) {
1111       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
1112       continue;
1113     }
1114 
1115     // Pick up 0, 1 or 2 words from ld_ptr.
1116     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
1117             &quot;scrambled load targets?&quot;);
1118     VMReg r_1 = regs[i].first();
1119     VMReg r_2 = regs[i].second();
1120     if (!r_1-&gt;is_valid()) {
1121       assert(!r_2-&gt;is_valid(), &quot;&quot;);
1122       continue;
1123     }
1124     if (r_1-&gt;is_FloatRegister()) {
1125       if (!r_2-&gt;is_valid()) {
1126         __ lfs(r_1-&gt;as_FloatRegister(), ld_offset, ld_ptr);
1127         ld_offset-=wordSize;
1128       } else {
1129         // Skip the unused interpreter slot.
1130         __ lfd(r_1-&gt;as_FloatRegister(), ld_offset-wordSize, ld_ptr);
1131         ld_offset-=2*wordSize;
1132       }
1133     } else {
1134       Register r;
1135       if (r_1-&gt;is_stack()) {
1136         // Must do a memory to memory move thru &quot;value&quot;.
1137         r = value_regs[value_regs_index];
1138         value_regs_index = (value_regs_index + 1) % num_value_regs;
1139       } else {
1140         r = r_1-&gt;as_Register();
1141       }
1142       if (!r_2-&gt;is_valid()) {
1143         // Not sure we need to do this but it shouldn&#39;t hurt.
1144         if (is_reference_type(sig_bt[i]) || sig_bt[i] == T_ADDRESS) {
1145           __ ld(r, ld_offset, ld_ptr);
1146           ld_offset-=wordSize;
1147         } else {
1148           __ lwz(r, ld_offset, ld_ptr);
1149           ld_offset-=wordSize;
1150         }
1151       } else {
1152         // In 64bit, longs are given 2 64-bit slots in the interpreter, but the
1153         // data is passed in only 1 slot.
1154         if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
1155           ld_offset-=wordSize;
1156         }
1157         __ ld(r, ld_offset, ld_ptr);
1158         ld_offset-=wordSize;
1159       }
1160 
1161       if (r_1-&gt;is_stack()) {
1162         // Now store value where the compiler expects it
1163         int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots())*VMRegImpl::stack_slot_size;
1164 
1165         if (sig_bt[i] == T_INT   || sig_bt[i] == T_FLOAT ||sig_bt[i] == T_BOOLEAN ||
1166             sig_bt[i] == T_SHORT || sig_bt[i] == T_CHAR  || sig_bt[i] == T_BYTE) {
1167           __ stw(r, st_off, R1_SP);
1168         } else {
1169           __ std(r, st_off, R1_SP);
1170         }
1171       }
1172     }
1173   }
1174 
1175   BLOCK_COMMENT(&quot;Store method&quot;);
1176   // Store method into thread-&gt;callee_target.
1177   // We might end up in handle_wrong_method if the callee is
1178   // deoptimized as we race thru here. If that happens we don&#39;t want
1179   // to take a safepoint because the caller frame will look
1180   // interpreted and arguments are now &quot;compiled&quot; so it is much better
1181   // to make this transition invisible to the stack walking
1182   // code. Unfortunately if we try and find the callee by normal means
1183   // a safepoint is possible. So we stash the desired callee in the
1184   // thread and the vm will find there should this case occur.
1185   __ std(R19_method, thread_(callee_target));
1186 
1187   // Jump to the compiled code just as if compiled code was doing it.
1188   __ bctr();
1189 }
1190 
1191 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
1192                                                             int total_args_passed,
1193                                                             int comp_args_on_stack,
1194                                                             const BasicType *sig_bt,
1195                                                             const VMRegPair *regs,
1196                                                             AdapterFingerPrint* fingerprint) {
1197   address i2c_entry;
1198   address c2i_unverified_entry;
1199   address c2i_entry;
1200 
1201 
1202   // entry: i2c
1203 
1204   __ align(CodeEntryAlignment);
1205   i2c_entry = __ pc();
1206   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
1207 
1208 
1209   // entry: c2i unverified
1210 
1211   __ align(CodeEntryAlignment);
1212   BLOCK_COMMENT(&quot;c2i unverified entry&quot;);
1213   c2i_unverified_entry = __ pc();
1214 
1215   // inline_cache contains a compiledICHolder
1216   const Register ic             = R19_method;
1217   const Register ic_klass       = R11_scratch1;
1218   const Register receiver_klass = R12_scratch2;
1219   const Register code           = R21_tmp1;
1220   const Register ientry         = R23_tmp3;
1221 
1222   assert_different_registers(ic, ic_klass, receiver_klass, R3_ARG1, code, ientry);
1223   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
1224 
1225   Label call_interpreter;
1226 
1227   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
1228          &quot;klass offset should reach into any page&quot;);
1229   // Check for NULL argument if we don&#39;t have implicit null checks.
1230   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
1231     if (TrapBasedNullChecks) {
1232       __ trap_null_check(R3_ARG1);
1233     } else {
1234       Label valid;
1235       __ cmpdi(CCR0, R3_ARG1, 0);
1236       __ bne_predict_taken(CCR0, valid);
1237       // We have a null argument, branch to ic_miss_stub.
1238       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1239                        relocInfo::runtime_call_type);
1240       __ BIND(valid);
1241     }
1242   }
1243   // Assume argument is not NULL, load klass from receiver.
1244   __ load_klass(receiver_klass, R3_ARG1);
1245 
1246   __ ld(ic_klass, CompiledICHolder::holder_klass_offset(), ic);
1247 
1248   if (TrapBasedICMissChecks) {
1249     __ trap_ic_miss_check(receiver_klass, ic_klass);
1250   } else {
1251     Label valid;
1252     __ cmpd(CCR0, receiver_klass, ic_klass);
1253     __ beq_predict_taken(CCR0, valid);
1254     // We have an unexpected klass, branch to ic_miss_stub.
1255     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
1256                      relocInfo::runtime_call_type);
1257     __ BIND(valid);
1258   }
1259 
1260   // Argument is valid and klass is as expected, continue.
1261 
1262   // Extract method from inline cache, verified entry point needs it.
1263   __ ld(R19_method, CompiledICHolder::holder_metadata_offset(), ic);
1264   assert(R19_method == ic, &quot;the inline cache register is dead here&quot;);
1265 
1266   __ ld(code, method_(code));
1267   __ cmpdi(CCR0, code, 0);
1268   __ ld(ientry, method_(interpreter_entry)); // preloaded
1269   __ beq_predict_taken(CCR0, call_interpreter);
1270 
1271   // Branch to ic_miss_stub.
1272   __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type);
1273 
1274   // entry: c2i
1275 
1276   c2i_entry = __ pc();
1277 
1278   // Class initialization barrier for static methods
1279   address c2i_no_clinit_check_entry = NULL;
1280   if (VM_Version::supports_fast_class_init_checks()) {
1281     Label L_skip_barrier;
1282 
1283     { // Bypass the barrier for non-static methods
1284       __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);
1285       __ andi_(R0, R0, JVM_ACC_STATIC);
1286       __ beq(CCR0, L_skip_barrier); // non-static
1287     }
1288 
1289     Register klass = R11_scratch1;
1290     __ load_method_holder(klass, R19_method);
1291     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
1292 
1293     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
1294     __ mtctr(klass);
1295     __ bctr();
1296 
1297     __ bind(L_skip_barrier);
1298     c2i_no_clinit_check_entry = __ pc();
1299   }
1300 
1301   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, call_interpreter, ientry);
1302 
1303   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);
1304 }
1305 
1306 // An oop arg. Must pass a handle not the oop itself.
1307 static void object_move(MacroAssembler* masm,
1308                         int frame_size_in_slots,
1309                         OopMap* oop_map, int oop_handle_offset,
1310                         bool is_receiver, int* receiver_offset,
1311                         VMRegPair src, VMRegPair dst,
1312                         Register r_caller_sp, Register r_temp_1, Register r_temp_2) {
1313   assert(!is_receiver || (is_receiver &amp;&amp; (*receiver_offset == -1)),
1314          &quot;receiver has already been moved&quot;);
1315 
1316   // We must pass a handle. First figure out the location we use as a handle.
1317 
1318   if (src.first()-&gt;is_stack()) {
1319     // stack to stack or reg
1320 
1321     const Register r_handle = dst.first()-&gt;is_stack() ? r_temp_1 : dst.first()-&gt;as_Register();
1322     Label skip;
1323     const int oop_slot_in_callers_frame = reg2slot(src.first());
1324 
1325     guarantee(!is_receiver, &quot;expecting receiver in register&quot;);
1326     oop_map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot_in_callers_frame + frame_size_in_slots));
1327 
1328     __ addi(r_handle, r_caller_sp, reg2offset(src.first()));
1329     __ ld(  r_temp_2, reg2offset(src.first()), r_caller_sp);
1330     __ cmpdi(CCR0, r_temp_2, 0);
1331     __ bne(CCR0, skip);
1332     // Use a NULL handle if oop is NULL.
1333     __ li(r_handle, 0);
1334     __ bind(skip);
1335 
1336     if (dst.first()-&gt;is_stack()) {
1337       // stack to stack
1338       __ std(r_handle, reg2offset(dst.first()), R1_SP);
1339     } else {
1340       // stack to reg
1341       // Nothing to do, r_handle is already the dst register.
1342     }
1343   } else {
1344     // reg to stack or reg
1345     const Register r_oop      = src.first()-&gt;as_Register();
1346     const Register r_handle   = dst.first()-&gt;is_stack() ? r_temp_1 : dst.first()-&gt;as_Register();
1347     const int oop_slot        = (r_oop-&gt;encoding()-R3_ARG1-&gt;encoding()) * VMRegImpl::slots_per_word
1348                                 + oop_handle_offset; // in slots
1349     const int oop_offset = oop_slot * VMRegImpl::stack_slot_size;
1350     Label skip;
1351 
1352     if (is_receiver) {
1353       *receiver_offset = oop_offset;
1354     }
1355     oop_map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1356 
1357     __ std( r_oop,    oop_offset, R1_SP);
1358     __ addi(r_handle, R1_SP, oop_offset);
1359 
1360     __ cmpdi(CCR0, r_oop, 0);
1361     __ bne(CCR0, skip);
1362     // Use a NULL handle if oop is NULL.
1363     __ li(r_handle, 0);
1364     __ bind(skip);
1365 
1366     if (dst.first()-&gt;is_stack()) {
1367       // reg to stack
1368       __ std(r_handle, reg2offset(dst.first()), R1_SP);
1369     } else {
1370       // reg to reg
1371       // Nothing to do, r_handle is already the dst register.
1372     }
1373   }
1374 }
1375 
1376 static void int_move(MacroAssembler*masm,
1377                      VMRegPair src, VMRegPair dst,
1378                      Register r_caller_sp, Register r_temp) {
1379   assert(src.first()-&gt;is_valid(), &quot;incoming must be int&quot;);
1380   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be long&quot;);
1381 
1382   if (src.first()-&gt;is_stack()) {
1383     if (dst.first()-&gt;is_stack()) {
1384       // stack to stack
1385       __ lwa(r_temp, reg2offset(src.first()), r_caller_sp);
1386       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1387     } else {
1388       // stack to reg
1389       __ lwa(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1390     }
1391   } else if (dst.first()-&gt;is_stack()) {
1392     // reg to stack
1393     __ extsw(r_temp, src.first()-&gt;as_Register());
1394     __ std(r_temp, reg2offset(dst.first()), R1_SP);
1395   } else {
1396     // reg to reg
1397     __ extsw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1398   }
1399 }
1400 
1401 static void long_move(MacroAssembler*masm,
1402                       VMRegPair src, VMRegPair dst,
1403                       Register r_caller_sp, Register r_temp) {
1404   assert(src.first()-&gt;is_valid() &amp;&amp; src.second() == src.first()-&gt;next(), &quot;incoming must be long&quot;);
1405   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be long&quot;);
1406 
1407   if (src.first()-&gt;is_stack()) {
1408     if (dst.first()-&gt;is_stack()) {
1409       // stack to stack
1410       __ ld( r_temp, reg2offset(src.first()), r_caller_sp);
1411       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1412     } else {
1413       // stack to reg
1414       __ ld(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1415     }
1416   } else if (dst.first()-&gt;is_stack()) {
1417     // reg to stack
1418     __ std(src.first()-&gt;as_Register(), reg2offset(dst.first()), R1_SP);
1419   } else {
1420     // reg to reg
1421     if (dst.first()-&gt;as_Register() != src.first()-&gt;as_Register())
1422       __ mr(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1423   }
1424 }
1425 
1426 static void float_move(MacroAssembler*masm,
1427                        VMRegPair src, VMRegPair dst,
1428                        Register r_caller_sp, Register r_temp) {
1429   assert(src.first()-&gt;is_valid() &amp;&amp; !src.second()-&gt;is_valid(), &quot;incoming must be float&quot;);
1430   assert(dst.first()-&gt;is_valid() &amp;&amp; !dst.second()-&gt;is_valid(), &quot;outgoing must be float&quot;);
1431 
1432   if (src.first()-&gt;is_stack()) {
1433     if (dst.first()-&gt;is_stack()) {
1434       // stack to stack
1435       __ lwz(r_temp, reg2offset(src.first()), r_caller_sp);
1436       __ stw(r_temp, reg2offset(dst.first()), R1_SP);
1437     } else {
1438       // stack to reg
1439       __ lfs(dst.first()-&gt;as_FloatRegister(), reg2offset(src.first()), r_caller_sp);
1440     }
1441   } else if (dst.first()-&gt;is_stack()) {
1442     // reg to stack
1443     __ stfs(src.first()-&gt;as_FloatRegister(), reg2offset(dst.first()), R1_SP);
1444   } else {
1445     // reg to reg
1446     if (dst.first()-&gt;as_FloatRegister() != src.first()-&gt;as_FloatRegister())
1447       __ fmr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1448   }
1449 }
1450 
1451 static void double_move(MacroAssembler*masm,
1452                         VMRegPair src, VMRegPair dst,
1453                         Register r_caller_sp, Register r_temp) {
1454   assert(src.first()-&gt;is_valid() &amp;&amp; src.second() == src.first()-&gt;next(), &quot;incoming must be double&quot;);
1455   assert(dst.first()-&gt;is_valid() &amp;&amp; dst.second() == dst.first()-&gt;next(), &quot;outgoing must be double&quot;);
1456 
1457   if (src.first()-&gt;is_stack()) {
1458     if (dst.first()-&gt;is_stack()) {
1459       // stack to stack
1460       __ ld( r_temp, reg2offset(src.first()), r_caller_sp);
1461       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1462     } else {
1463       // stack to reg
1464       __ lfd(dst.first()-&gt;as_FloatRegister(), reg2offset(src.first()), r_caller_sp);
1465     }
1466   } else if (dst.first()-&gt;is_stack()) {
1467     // reg to stack
1468     __ stfd(src.first()-&gt;as_FloatRegister(), reg2offset(dst.first()), R1_SP);
1469   } else {
1470     // reg to reg
1471     if (dst.first()-&gt;as_FloatRegister() != src.first()-&gt;as_FloatRegister())
1472       __ fmr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1473   }
1474 }
1475 
1476 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1477   switch (ret_type) {
1478     case T_BOOLEAN:
1479     case T_CHAR:
1480     case T_BYTE:
1481     case T_SHORT:
1482     case T_INT:
1483       __ stw (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1484       break;
1485     case T_ARRAY:
1486     case T_OBJECT:
1487     case T_LONG:
1488       __ std (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1489       break;
1490     case T_FLOAT:
1491       __ stfs(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1492       break;
1493     case T_DOUBLE:
1494       __ stfd(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1495       break;
1496     case T_VOID:
1497       break;
1498     default:
1499       ShouldNotReachHere();
1500       break;
1501   }
1502 }
1503 
1504 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1505   switch (ret_type) {
1506     case T_BOOLEAN:
1507     case T_CHAR:
1508     case T_BYTE:
1509     case T_SHORT:
1510     case T_INT:
1511       __ lwz(R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1512       break;
1513     case T_ARRAY:
1514     case T_OBJECT:
1515     case T_LONG:
1516       __ ld (R3_RET,  frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1517       break;
1518     case T_FLOAT:
1519       __ lfs(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1520       break;
1521     case T_DOUBLE:
1522       __ lfd(F1_RET, frame_slots*VMRegImpl::stack_slot_size, R1_SP);
1523       break;
1524     case T_VOID:
1525       break;
1526     default:
1527       ShouldNotReachHere();
1528       break;
1529   }
1530 }
1531 
1532 static void save_or_restore_arguments(MacroAssembler* masm,
1533                                       const int stack_slots,
1534                                       const int total_in_args,
1535                                       const int arg_save_area,
1536                                       OopMap* map,
1537                                       VMRegPair* in_regs,
1538                                       BasicType* in_sig_bt) {
1539   // If map is non-NULL then the code should store the values,
1540   // otherwise it should load them.
1541   int slot = arg_save_area;
1542   // Save down double word first.
1543   for (int i = 0; i &lt; total_in_args; i++) {
1544     if (in_regs[i].first()-&gt;is_FloatRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1545       int offset = slot * VMRegImpl::stack_slot_size;
1546       slot += VMRegImpl::slots_per_word;
1547       assert(slot &lt;= stack_slots, &quot;overflow (after DOUBLE stack slot)&quot;);
1548       if (map != NULL) {
1549         __ stfd(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1550       } else {
1551         __ lfd(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1552       }
1553     } else if (in_regs[i].first()-&gt;is_Register() &amp;&amp;
1554         (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_ARRAY)) {
1555       int offset = slot * VMRegImpl::stack_slot_size;
1556       if (map != NULL) {
1557         __ std(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1558         if (in_sig_bt[i] == T_ARRAY) {
1559           map-&gt;set_oop(VMRegImpl::stack2reg(slot));
1560         }
1561       } else {
1562         __ ld(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1563       }
1564       slot += VMRegImpl::slots_per_word;
1565       assert(slot &lt;= stack_slots, &quot;overflow (after LONG/ARRAY stack slot)&quot;);
1566     }
1567   }
1568   // Save or restore single word registers.
1569   for (int i = 0; i &lt; total_in_args; i++) {
1570     if (in_regs[i].first()-&gt;is_Register()) {
1571       int offset = slot * VMRegImpl::stack_slot_size;
1572       // Value lives in an input register. Save it on stack.
1573       switch (in_sig_bt[i]) {
1574         case T_BOOLEAN:
1575         case T_CHAR:
1576         case T_BYTE:
1577         case T_SHORT:
1578         case T_INT:
1579           if (map != NULL) {
1580             __ stw(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1581           } else {
1582             __ lwa(in_regs[i].first()-&gt;as_Register(), offset, R1_SP);
1583           }
1584           slot++;
1585           assert(slot &lt;= stack_slots, &quot;overflow (after INT or smaller stack slot)&quot;);
1586           break;
1587         case T_ARRAY:
1588         case T_LONG:
1589           // handled above
1590           break;
1591         case T_OBJECT:
1592         default: ShouldNotReachHere();
1593       }
1594     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1595       if (in_sig_bt[i] == T_FLOAT) {
1596         int offset = slot * VMRegImpl::stack_slot_size;
1597         slot++;
1598         assert(slot &lt;= stack_slots, &quot;overflow (after FLOAT stack slot)&quot;);
1599         if (map != NULL) {
1600           __ stfs(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1601         } else {
1602           __ lfs(in_regs[i].first()-&gt;as_FloatRegister(), offset, R1_SP);
1603         }
1604       }
1605     } else if (in_regs[i].first()-&gt;is_stack()) {
1606       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1607         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1608         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1609       }
1610     }
1611   }
1612 }
1613 
1614 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true. This
1615 // keeps a new JNI critical region from starting until a GC has been
1616 // forced. Save down any oops in registers and describe them in an
1617 // OopMap.
1618 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1619                                                const int stack_slots,
1620                                                const int total_in_args,
1621                                                const int arg_save_area,
1622                                                OopMapSet* oop_maps,
1623                                                VMRegPair* in_regs,
1624                                                BasicType* in_sig_bt,
1625                                                Register tmp_reg ) {
1626   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1627   Label cont;
1628   __ lbz(tmp_reg, (RegisterOrConstant)(intptr_t)GCLocker::needs_gc_address());
1629   __ cmplwi(CCR0, tmp_reg, 0);
1630   __ beq(CCR0, cont);
1631 
1632   // Save down any values that are live in registers and call into the
1633   // runtime to halt for a GC.
1634   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1635   save_or_restore_arguments(masm, stack_slots, total_in_args,
1636                             arg_save_area, map, in_regs, in_sig_bt);
1637 
1638   __ mr(R3_ARG1, R16_thread);
1639   __ set_last_Java_frame(R1_SP, noreg);
1640 
1641   __ block_comment(&quot;block_for_jni_critical&quot;);
1642   address entry_point = CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical);
1643 #if defined(ABI_ELFv2)
1644   __ call_c(entry_point, relocInfo::runtime_call_type);
1645 #else
1646   __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, entry_point), relocInfo::runtime_call_type);
1647 #endif
1648   address start           = __ pc() - __ offset(),
1649           calls_return_pc = __ last_calls_return_pc();
1650   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
1651 
1652   __ reset_last_Java_frame();
1653 
1654   // Reload all the register arguments.
1655   save_or_restore_arguments(masm, stack_slots, total_in_args,
1656                             arg_save_area, NULL, in_regs, in_sig_bt);
1657 
1658   __ BIND(cont);
1659 
1660 #ifdef ASSERT
1661   if (StressCriticalJNINatives) {
1662     // Stress register saving.
1663     OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1664     save_or_restore_arguments(masm, stack_slots, total_in_args,
1665                               arg_save_area, map, in_regs, in_sig_bt);
1666     // Destroy argument registers.
1667     for (int i = 0; i &lt; total_in_args; i++) {
1668       if (in_regs[i].first()-&gt;is_Register()) {
1669         const Register reg = in_regs[i].first()-&gt;as_Register();
1670         __ neg(reg, reg);
1671       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1672         __ fneg(in_regs[i].first()-&gt;as_FloatRegister(), in_regs[i].first()-&gt;as_FloatRegister());
1673       }
1674     }
1675 
1676     save_or_restore_arguments(masm, stack_slots, total_in_args,
1677                               arg_save_area, NULL, in_regs, in_sig_bt);
1678   }
1679 #endif
1680 }
1681 
1682 static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst, Register r_caller_sp, Register r_temp) {
1683   if (src.first()-&gt;is_stack()) {
1684     if (dst.first()-&gt;is_stack()) {
1685       // stack to stack
1686       __ ld(r_temp, reg2offset(src.first()), r_caller_sp);
1687       __ std(r_temp, reg2offset(dst.first()), R1_SP);
1688     } else {
1689       // stack to reg
1690       __ ld(dst.first()-&gt;as_Register(), reg2offset(src.first()), r_caller_sp);
1691     }
1692   } else if (dst.first()-&gt;is_stack()) {
1693     // reg to stack
1694     __ std(src.first()-&gt;as_Register(), reg2offset(dst.first()), R1_SP);
1695   } else {
1696     if (dst.first() != src.first()) {
1697       __ mr(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1698     }
1699   }
1700 }
1701 
1702 // Unpack an array argument into a pointer to the body and the length
1703 // if the array is non-null, otherwise pass 0 for both.
1704 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type,
1705                                   VMRegPair body_arg, VMRegPair length_arg, Register r_caller_sp,
1706                                   Register tmp_reg, Register tmp2_reg) {
1707   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1708          &quot;possible collision&quot;);
1709   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1710          &quot;possible collision&quot;);
1711 
1712   // Pass the length, ptr pair.
1713   Label set_out_args;
1714   VMRegPair tmp, tmp2;
1715   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1716   tmp2.set_ptr(tmp2_reg-&gt;as_VMReg());
1717   if (reg.first()-&gt;is_stack()) {
1718     // Load the arg up from the stack.
1719     move_ptr(masm, reg, tmp, r_caller_sp, /*unused*/ R0);
1720     reg = tmp;
1721   }
1722   __ li(tmp2_reg, 0); // Pass zeros if Array=null.
1723   if (tmp_reg != reg.first()-&gt;as_Register()) __ li(tmp_reg, 0);
1724   __ cmpdi(CCR0, reg.first()-&gt;as_Register(), 0);
1725   __ beq(CCR0, set_out_args);
1726   __ lwa(tmp2_reg, arrayOopDesc::length_offset_in_bytes(), reg.first()-&gt;as_Register());
1727   __ addi(tmp_reg, reg.first()-&gt;as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type));
1728   __ bind(set_out_args);
1729   move_ptr(masm, tmp, body_arg, r_caller_sp, /*unused*/ R0);
1730   move_ptr(masm, tmp2, length_arg, r_caller_sp, /*unused*/ R0); // Same as move32_64 on PPC64.
1731 }
1732 
1733 static void verify_oop_args(MacroAssembler* masm,
1734                             const methodHandle&amp; method,
1735                             const BasicType* sig_bt,
1736                             const VMRegPair* regs) {
1737   Register temp_reg = R19_method;  // not part of any compiled calling seq
1738   if (VerifyOops) {
1739     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1740       if (is_reference_type(sig_bt[i])) {
1741         VMReg r = regs[i].first();
1742         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1743         if (r-&gt;is_stack()) {
1744           __ ld(temp_reg, reg2offset(r), R1_SP);
1745           __ verify_oop(temp_reg, FILE_AND_LINE);
1746         } else {
1747           __ verify_oop(r-&gt;as_Register(), FILE_AND_LINE);
1748         }
1749       }
1750     }
1751   }
1752 }
1753 
1754 static void gen_special_dispatch(MacroAssembler* masm,
1755                                  const methodHandle&amp; method,
1756                                  const BasicType* sig_bt,
1757                                  const VMRegPair* regs) {
1758   verify_oop_args(masm, method, sig_bt, regs);
1759   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1760 
1761   // Now write the args into the outgoing interpreter space
1762   bool     has_receiver   = false;
1763   Register receiver_reg   = noreg;
1764   int      member_arg_pos = -1;
1765   Register member_reg     = noreg;
1766   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1767   if (ref_kind != 0) {
1768     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1769     member_reg = R19_method;  // known to be free at this point
1770     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1771   } else if (iid == vmIntrinsics::_invokeBasic) {
1772     has_receiver = true;
1773   } else {
1774     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1775   }
1776 
1777   if (member_reg != noreg) {
1778     // Load the member_arg into register, if necessary.
1779     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1780     VMReg r = regs[member_arg_pos].first();
1781     if (r-&gt;is_stack()) {
1782       __ ld(member_reg, reg2offset(r), R1_SP);
1783     } else {
1784       // no data motion is needed
1785       member_reg = r-&gt;as_Register();
1786     }
1787   }
1788 
1789   if (has_receiver) {
1790     // Make sure the receiver is loaded into a register.
1791     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1792     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1793     VMReg r = regs[0].first();
1794     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1795     if (r-&gt;is_stack()) {
1796       // Porting note:  This assumes that compiled calling conventions always
1797       // pass the receiver oop in a register.  If this is not true on some
1798       // platform, pick a temp and load the receiver from stack.
1799       fatal(&quot;receiver always in a register&quot;);
1800       receiver_reg = R11_scratch1;  // TODO (hs24): is R11_scratch1 really free at this point?
1801       __ ld(receiver_reg, reg2offset(r), R1_SP);
1802     } else {
1803       // no data motion is needed
1804       receiver_reg = r-&gt;as_Register();
1805     }
1806   }
1807 
1808   // Figure out which address we are really jumping to:
1809   MethodHandles::generate_method_handle_dispatch(masm, iid,
1810                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1811 }
1812 
1813 // ---------------------------------------------------------------------------
1814 // Generate a native wrapper for a given method. The method takes arguments
1815 // in the Java compiled code convention, marshals them to the native
1816 // convention (handlizes oops, etc), transitions to native, makes the call,
1817 // returns to java state (possibly blocking), unhandlizes any result and
1818 // returns.
1819 //
1820 // Critical native functions are a shorthand for the use of
1821 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1822 // functions.  The wrapper is expected to unpack the arguments before
1823 // passing them to the callee and perform checks before and after the
1824 // native call to ensure that they GCLocker
1825 // lock_critical/unlock_critical semantics are followed.  Some other
1826 // parts of JNI setup are skipped like the tear down of the JNI handle
1827 // block and the check for pending exceptions it&#39;s impossible for them
1828 // to be thrown.
1829 //
1830 // They are roughly structured like this:
1831 //   if (GCLocker::needs_gc())
1832 //     SharedRuntime::block_for_jni_critical();
1833 //   tranistion to thread_in_native
1834 //   unpack arrray arguments and call native entry point
1835 //   check for safepoint in progress
1836 //   check if any thread suspend flags are set
1837 //     call into JVM and possible unlock the JNI critical
1838 //     if a GC was suppressed while in the critical native.
1839 //   transition back to thread_in_Java
1840 //   return to caller
1841 //
1842 nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
1843                                                 const methodHandle&amp; method,
1844                                                 int compile_id,
1845                                                 BasicType *in_sig_bt,
1846                                                 VMRegPair *in_regs,
1847                                                 BasicType ret_type,
1848                                                 address critical_entry) {
1849   if (method-&gt;is_method_handle_intrinsic()) {
1850     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1851     intptr_t start = (intptr_t)__ pc();
1852     int vep_offset = ((intptr_t)__ pc()) - start;
1853     gen_special_dispatch(masm,
1854                          method,
1855                          in_sig_bt,
1856                          in_regs);
1857     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1858     __ flush();
1859     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1860     return nmethod::new_native_nmethod(method,
1861                                        compile_id,
1862                                        masm-&gt;code(),
1863                                        vep_offset,
1864                                        frame_complete,
1865                                        stack_slots / VMRegImpl::slots_per_word,
1866                                        in_ByteSize(-1),
1867                                        in_ByteSize(-1),
1868                                        (OopMapSet*)NULL);
1869   }
1870 
1871   bool is_critical_native = true;
1872   address native_func = critical_entry;
1873   if (native_func == NULL) {
1874     native_func = method-&gt;native_function();
1875     is_critical_native = false;
1876   }
1877   assert(native_func != NULL, &quot;must have function&quot;);
1878 
1879   // First, create signature for outgoing C call
1880   // --------------------------------------------------------------------------
1881 
1882   int total_in_args = method-&gt;size_of_parameters();
1883   // We have received a description of where all the java args are located
1884   // on entry to the wrapper. We need to convert these args to where
1885   // the jni function will expect them. To figure out where they go
1886   // we convert the java signature to a C signature by inserting
1887   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1888 
1889   // Calculate the total number of C arguments and create arrays for the
1890   // signature and the outgoing registers.
1891   // On ppc64, we have two arrays for the outgoing registers, because
1892   // some floating-point arguments must be passed in registers _and_
1893   // in stack locations.
1894   bool method_is_static = method-&gt;is_static();
1895   int  total_c_args     = total_in_args;
1896 
1897   if (!is_critical_native) {
1898     int n_hidden_args = method_is_static ? 2 : 1;
1899     total_c_args += n_hidden_args;
1900   } else {
1901     // No JNIEnv*, no this*, but unpacked arrays (base+length).
1902     for (int i = 0; i &lt; total_in_args; i++) {
1903       if (in_sig_bt[i] == T_ARRAY) {
1904         total_c_args++;
1905       }
1906     }
1907   }
1908 
1909   BasicType *out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1910   VMRegPair *out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1911   VMRegPair *out_regs2  = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1912   BasicType* in_elem_bt = NULL;
1913 
1914   // Create the signature for the C call:
1915   //   1) add the JNIEnv*
1916   //   2) add the class if the method is static
1917   //   3) copy the rest of the incoming signature (shifted by the number of
1918   //      hidden arguments).
1919 
1920   int argc = 0;
1921   if (!is_critical_native) {
1922     out_sig_bt[argc++] = T_ADDRESS;
1923     if (method-&gt;is_static()) {
1924       out_sig_bt[argc++] = T_OBJECT;
1925     }
1926 
1927     for (int i = 0; i &lt; total_in_args ; i++ ) {
1928       out_sig_bt[argc++] = in_sig_bt[i];
1929     }
1930   } else {
1931     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1932     SignatureStream ss(method-&gt;signature());
1933     int o = 0;
1934     for (int i = 0; i &lt; total_in_args ; i++, o++) {
1935       if (in_sig_bt[i] == T_ARRAY) {
1936         // Arrays are passed as int, elem* pair
1937         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
1938         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
1939         in_elem_bt[o] = ss.type();
1940       } else {
1941         in_elem_bt[o] = T_VOID;
1942       }
1943       if (in_sig_bt[i] != T_VOID) {
1944         assert(in_sig_bt[i] == ss.type() ||
1945                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
1946         ss.next();
1947       }
1948     }
1949 
1950     for (int i = 0; i &lt; total_in_args ; i++ ) {
1951       if (in_sig_bt[i] == T_ARRAY) {
1952         // Arrays are passed as int, elem* pair.
1953         out_sig_bt[argc++] = T_INT;
1954         out_sig_bt[argc++] = T_ADDRESS;
1955       } else {
1956         out_sig_bt[argc++] = in_sig_bt[i];
1957       }
1958     }
1959   }
1960 
1961 
1962   // Compute the wrapper&#39;s frame size.
1963   // --------------------------------------------------------------------------
1964 
1965   // Now figure out where the args must be stored and how much stack space
1966   // they require.
1967   //
1968   // Compute framesize for the wrapper. We need to handlize all oops in
1969   // incoming registers.
1970   //
1971   // Calculate the total number of stack slots we will need:
1972   //   1) abi requirements
1973   //   2) outgoing arguments
1974   //   3) space for inbound oop handle area
1975   //   4) space for handlizing a klass if static method
1976   //   5) space for a lock if synchronized method
1977   //   6) workspace for saving return values, int &lt;-&gt; float reg moves, etc.
1978   //   7) alignment
1979   //
1980   // Layout of the native wrapper frame:
1981   // (stack grows upwards, memory grows downwards)
1982   //
1983   // NW     [ABI_REG_ARGS]             &lt;-- 1) R1_SP
1984   //        [outgoing arguments]       &lt;-- 2) R1_SP + out_arg_slot_offset
1985   //        [oopHandle area]           &lt;-- 3) R1_SP + oop_handle_offset (save area for critical natives)
1986   //        klass                      &lt;-- 4) R1_SP + klass_offset
1987   //        lock                       &lt;-- 5) R1_SP + lock_offset
1988   //        [workspace]                &lt;-- 6) R1_SP + workspace_offset
1989   //        [alignment] (optional)     &lt;-- 7)
1990   // caller [JIT_TOP_ABI_48]           &lt;-- r_callers_sp
1991   //
1992   // - *_slot_offset Indicates offset from SP in number of stack slots.
1993   // - *_offset      Indicates offset from SP in bytes.
1994 
1995   int stack_slots = c_calling_convention(out_sig_bt, out_regs, out_regs2, total_c_args) + // 1+2)
1996                     SharedRuntime::out_preserve_stack_slots(); // See c_calling_convention.
1997 
1998   // Now the space for the inbound oop handle area.
1999   int total_save_slots = num_java_iarg_registers * VMRegImpl::slots_per_word;
2000   if (is_critical_native) {
2001     // Critical natives may have to call out so they need a save area
2002     // for register arguments.
2003     int double_slots = 0;
2004     int single_slots = 0;
2005     for (int i = 0; i &lt; total_in_args; i++) {
2006       if (in_regs[i].first()-&gt;is_Register()) {
2007         const Register reg = in_regs[i].first()-&gt;as_Register();
2008         switch (in_sig_bt[i]) {
2009           case T_BOOLEAN:
2010           case T_BYTE:
2011           case T_SHORT:
2012           case T_CHAR:
2013           case T_INT:
2014           // Fall through.
2015           case T_ARRAY:
2016           case T_LONG: double_slots++; break;
2017           default:  ShouldNotReachHere();
2018         }
2019       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
2020         switch (in_sig_bt[i]) {
2021           case T_FLOAT:  single_slots++; break;
2022           case T_DOUBLE: double_slots++; break;
2023           default:  ShouldNotReachHere();
2024         }
2025       }
2026     }
2027     total_save_slots = double_slots * 2 + align_up(single_slots, 2); // round to even
2028   }
2029 
2030   int oop_handle_slot_offset = stack_slots;
2031   stack_slots += total_save_slots;                                                // 3)
2032 
2033   int klass_slot_offset = 0;
2034   int klass_offset      = -1;
2035   if (method_is_static &amp;&amp; !is_critical_native) {                                  // 4)
2036     klass_slot_offset  = stack_slots;
2037     klass_offset       = klass_slot_offset * VMRegImpl::stack_slot_size;
2038     stack_slots       += VMRegImpl::slots_per_word;
2039   }
2040 
2041   int lock_slot_offset = 0;
2042   int lock_offset      = -1;
2043   if (method-&gt;is_synchronized()) {                                                // 5)
2044     lock_slot_offset   = stack_slots;
2045     lock_offset        = lock_slot_offset * VMRegImpl::stack_slot_size;
2046     stack_slots       += VMRegImpl::slots_per_word;
2047   }
2048 
2049   int workspace_slot_offset = stack_slots;                                        // 6)
2050   stack_slots         += 2;
2051 
2052   // Now compute actual number of stack words we need.
2053   // Rounding to make stack properly aligned.
2054   stack_slots = align_up(stack_slots,                                             // 7)
2055                          frame::alignment_in_bytes / VMRegImpl::stack_slot_size);
2056   int frame_size_in_bytes = stack_slots * VMRegImpl::stack_slot_size;
2057 
2058 
2059   // Now we can start generating code.
2060   // --------------------------------------------------------------------------
2061 
2062   intptr_t start_pc = (intptr_t)__ pc();
2063   intptr_t vep_start_pc;
2064   intptr_t frame_done_pc;
2065   intptr_t oopmap_pc;
2066 
2067   Label    ic_miss;
2068   Label    handle_pending_exception;
2069 
2070   Register r_callers_sp = R21;
2071   Register r_temp_1     = R22;
2072   Register r_temp_2     = R23;
2073   Register r_temp_3     = R24;
2074   Register r_temp_4     = R25;
2075   Register r_temp_5     = R26;
2076   Register r_temp_6     = R27;
2077   Register r_return_pc  = R28;
2078 
2079   Register r_carg1_jnienv        = noreg;
2080   Register r_carg2_classorobject = noreg;
2081   if (!is_critical_native) {
2082     r_carg1_jnienv        = out_regs[0].first()-&gt;as_Register();
2083     r_carg2_classorobject = out_regs[1].first()-&gt;as_Register();
2084   }
2085 
2086 
2087   // Generate the Unverified Entry Point (UEP).
2088   // --------------------------------------------------------------------------
2089   assert(start_pc == (intptr_t)__ pc(), &quot;uep must be at start&quot;);
2090 
2091   // Check ic: object class == cached class?
2092   if (!method_is_static) {
2093   Register ic = R19_inline_cache_reg;
2094   Register receiver_klass = r_temp_1;
2095 
2096   __ cmpdi(CCR0, R3_ARG1, 0);
2097   __ beq(CCR0, ic_miss);
2098   __ verify_oop(R3_ARG1, FILE_AND_LINE);
2099   __ load_klass(receiver_klass, R3_ARG1);
2100 
2101   __ cmpd(CCR0, receiver_klass, ic);
2102   __ bne(CCR0, ic_miss);
2103   }
2104 
2105 
2106   // Generate the Verified Entry Point (VEP).
2107   // --------------------------------------------------------------------------
2108   vep_start_pc = (intptr_t)__ pc();
2109 
2110   if (UseRTMLocking) {
2111     // Abort RTM transaction before calling JNI
2112     // because critical section can be large and
2113     // abort anyway. Also nmethod can be deoptimized.
2114     __ tabort_();
2115   }
2116 
2117   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
2118     Label L_skip_barrier;
2119     Register klass = r_temp_1;
2120     // Notify OOP recorder (don&#39;t need the relocation)
2121     AddressLiteral md = __ constant_metadata_address(method-&gt;method_holder());
2122     __ load_const_optimized(klass, md.value(), R0);
2123     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
2124 
2125     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
2126     __ mtctr(klass);
2127     __ bctr();
2128 
2129     __ bind(L_skip_barrier);
2130   }
2131 
2132   __ save_LR_CR(r_temp_1);
2133   __ generate_stack_overflow_check(frame_size_in_bytes); // Check before creating frame.
2134   __ mr(r_callers_sp, R1_SP);                            // Remember frame pointer.
2135   __ push_frame(frame_size_in_bytes, r_temp_1);          // Push the c2n adapter&#39;s frame.
2136   frame_done_pc = (intptr_t)__ pc();
2137 
2138   __ verify_thread();
2139 
2140   // Native nmethod wrappers never take possesion of the oop arguments.
2141   // So the caller will gc the arguments.
2142   // The only thing we need an oopMap for is if the call is static.
2143   //
2144   // An OopMap for lock (and class if static), and one for the VM call itself.
2145   OopMapSet *oop_maps = new OopMapSet();
2146   OopMap    *oop_map  = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
2147 
2148   if (is_critical_native) {
2149     check_needs_gc_for_critical_native(masm, stack_slots, total_in_args, oop_handle_slot_offset,
2150                                        oop_maps, in_regs, in_sig_bt, r_temp_1);
2151   }
2152 
2153   // Move arguments from register/stack to register/stack.
2154   // --------------------------------------------------------------------------
2155   //
2156   // We immediately shuffle the arguments so that for any vm call we have
2157   // to make from here on out (sync slow path, jvmti, etc.) we will have
2158   // captured the oops from our caller and have a valid oopMap for them.
2159   //
2160   // Natives require 1 or 2 extra arguments over the normal ones: the JNIEnv*
2161   // (derived from JavaThread* which is in R16_thread) and, if static,
2162   // the class mirror instead of a receiver. This pretty much guarantees that
2163   // register layout will not match. We ignore these extra arguments during
2164   // the shuffle. The shuffle is described by the two calling convention
2165   // vectors we have in our possession. We simply walk the java vector to
2166   // get the source locations and the c vector to get the destinations.
2167 
2168   // Record sp-based slot for receiver on stack for non-static methods.
2169   int receiver_offset = -1;
2170 
2171   // We move the arguments backward because the floating point registers
2172   // destination will always be to a register with a greater or equal
2173   // register number or the stack.
2174   //   in  is the index of the incoming Java arguments
2175   //   out is the index of the outgoing C arguments
2176 
2177 #ifdef ASSERT
2178   bool reg_destroyed[RegisterImpl::number_of_registers];
2179   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
2180   for (int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++) {
2181     reg_destroyed[r] = false;
2182   }
2183   for (int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++) {
2184     freg_destroyed[f] = false;
2185   }
2186 #endif // ASSERT
2187 
2188   for (int in = total_in_args - 1, out = total_c_args - 1; in &gt;= 0 ; in--, out--) {
2189 
2190 #ifdef ASSERT
2191     if (in_regs[in].first()-&gt;is_Register()) {
2192       assert(!reg_destroyed[in_regs[in].first()-&gt;as_Register()-&gt;encoding()], &quot;ack!&quot;);
2193     } else if (in_regs[in].first()-&gt;is_FloatRegister()) {
2194       assert(!freg_destroyed[in_regs[in].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;ack!&quot;);
2195     }
2196     if (out_regs[out].first()-&gt;is_Register()) {
2197       reg_destroyed[out_regs[out].first()-&gt;as_Register()-&gt;encoding()] = true;
2198     } else if (out_regs[out].first()-&gt;is_FloatRegister()) {
2199       freg_destroyed[out_regs[out].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
2200     }
2201     if (out_regs2[out].first()-&gt;is_Register()) {
2202       reg_destroyed[out_regs2[out].first()-&gt;as_Register()-&gt;encoding()] = true;
2203     } else if (out_regs2[out].first()-&gt;is_FloatRegister()) {
2204       freg_destroyed[out_regs2[out].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
2205     }
2206 #endif // ASSERT
2207 
2208     switch (in_sig_bt[in]) {
2209       case T_BOOLEAN:
2210       case T_CHAR:
2211       case T_BYTE:
2212       case T_SHORT:
2213       case T_INT:
2214         // Move int and do sign extension.
2215         int_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2216         break;
2217       case T_LONG:
2218         long_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2219         break;
2220       case T_ARRAY:
2221         if (is_critical_native) {
2222           int body_arg = out;
2223           out -= 1; // Point to length arg.
2224           unpack_array_argument(masm, in_regs[in], in_elem_bt[in], out_regs[body_arg], out_regs[out],
2225                                 r_callers_sp, r_temp_1, r_temp_2);
2226           break;
2227         }
2228       case T_OBJECT:
2229         assert(!is_critical_native, &quot;no oop arguments&quot;);
2230         object_move(masm, stack_slots,
2231                     oop_map, oop_handle_slot_offset,
2232                     ((in == 0) &amp;&amp; (!method_is_static)), &amp;receiver_offset,
2233                     in_regs[in], out_regs[out],
2234                     r_callers_sp, r_temp_1, r_temp_2);
2235         break;
2236       case T_VOID:
2237         break;
2238       case T_FLOAT:
2239         float_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2240         if (out_regs2[out].first()-&gt;is_valid()) {
2241           float_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);
2242         }
2243         break;
2244       case T_DOUBLE:
2245         double_move(masm, in_regs[in], out_regs[out], r_callers_sp, r_temp_1);
2246         if (out_regs2[out].first()-&gt;is_valid()) {
2247           double_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);
2248         }
2249         break;
2250       case T_ADDRESS:
2251         fatal(&quot;found type (T_ADDRESS) in java args&quot;);
2252         break;
2253       default:
2254         ShouldNotReachHere();
2255         break;
2256     }
2257   }
2258 
2259   // Pre-load a static method&#39;s oop into ARG2.
2260   // Used both by locking code and the normal JNI call code.
2261   if (method_is_static &amp;&amp; !is_critical_native) {
2262     __ set_oop_constant(JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
2263                         r_carg2_classorobject);
2264 
2265     // Now handlize the static class mirror in carg2. It&#39;s known not-null.
2266     __ std(r_carg2_classorobject, klass_offset, R1_SP);
2267     oop_map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
2268     __ addi(r_carg2_classorobject, R1_SP, klass_offset);
2269   }
2270 
2271   // Get JNIEnv* which is first argument to native.
2272   if (!is_critical_native) {
2273     __ addi(r_carg1_jnienv, R16_thread, in_bytes(JavaThread::jni_environment_offset()));
2274   }
2275 
2276   // NOTE:
2277   //
2278   // We have all of the arguments setup at this point.
2279   // We MUST NOT touch any outgoing regs from this point on.
2280   // So if we must call out we must push a new frame.
2281 
2282   // Get current pc for oopmap, and load it patchable relative to global toc.
2283   oopmap_pc = (intptr_t) __ pc();
2284   __ calculate_address_from_global_toc(r_return_pc, (address)oopmap_pc, true, true, true, true);
2285 
2286   // We use the same pc/oopMap repeatedly when we call out.
2287   oop_maps-&gt;add_gc_map(oopmap_pc - start_pc, oop_map);
2288 
2289   // r_return_pc now has the pc loaded that we will use when we finally call
2290   // to native.
2291 
2292   // Make sure that thread is non-volatile; it crosses a bunch of VM calls below.
2293   assert(R16_thread-&gt;is_nonvolatile(), &quot;thread must be in non-volatile register&quot;);
2294 
2295 # if 0
2296   // DTrace method entry
2297 # endif
2298 
2299   // Lock a synchronized method.
2300   // --------------------------------------------------------------------------
2301 
2302   if (method-&gt;is_synchronized()) {
2303     assert(!is_critical_native, &quot;unhandled&quot;);
2304     ConditionRegister r_flag = CCR1;
2305     Register          r_oop  = r_temp_4;
2306     const Register    r_box  = r_temp_5;
2307     Label             done, locked;
2308 
2309     // Load the oop for the object or class. r_carg2_classorobject contains
2310     // either the handlized oop from the incoming arguments or the handlized
2311     // class mirror (if the method is static).
2312     __ ld(r_oop, 0, r_carg2_classorobject);
2313 
2314     // Get the lock box slot&#39;s address.
2315     __ addi(r_box, R1_SP, lock_offset);
2316 
2317 #   ifdef ASSERT
2318     if (UseBiasedLocking) {
2319       // Making the box point to itself will make it clear it went unused
2320       // but also be obviously invalid.
2321       __ std(r_box, 0, r_box);
2322     }
2323 #   endif // ASSERT
2324 
2325     // Try fastpath for locking.
2326     // fast_lock kills r_temp_1, r_temp_2, r_temp_3.
2327     __ compiler_fast_lock_object(r_flag, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);
2328     __ beq(r_flag, locked);
2329 
2330     // None of the above fast optimizations worked so we have to get into the
2331     // slow case of monitor enter. Inline a special case of call_VM that
2332     // disallows any pending_exception.
2333 
2334     // Save argument registers and leave room for C-compatible ABI_REG_ARGS.
2335     int frame_size = frame::abi_reg_args_size + align_up(total_c_args * wordSize, frame::alignment_in_bytes);
2336     __ mr(R11_scratch1, R1_SP);
2337     RegisterSaver::push_frame_and_save_argument_registers(masm, R12_scratch2, frame_size, total_c_args, out_regs, out_regs2);
2338 
2339     // Do the call.
2340     __ set_last_Java_frame(R11_scratch1, r_return_pc);
2341     assert(r_return_pc-&gt;is_nonvolatile(), &quot;expecting return pc to be in non-volatile register&quot;);
2342     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), r_oop, r_box, R16_thread);
2343     __ reset_last_Java_frame();
2344 
2345     RegisterSaver::restore_argument_registers_and_pop_frame(masm, frame_size, total_c_args, out_regs, out_regs2);
2346 
2347     __ asm_assert_mem8_is_zero(thread_(pending_exception),
2348        &quot;no pending exception allowed on exit from SharedRuntime::complete_monitor_locking_C&quot;, 0);
2349 
2350     __ bind(locked);
2351   }
2352 
2353 
2354   // Publish thread state
2355   // --------------------------------------------------------------------------
2356 
2357   // Use that pc we placed in r_return_pc a while back as the current frame anchor.
2358   __ set_last_Java_frame(R1_SP, r_return_pc);
2359 
2360   // Transition from _thread_in_Java to _thread_in_native.
2361   __ li(R0, _thread_in_native);
2362   __ release();
2363   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2364   __ stw(R0, thread_(thread_state));
2365 
2366 
2367   // The JNI call
2368   // --------------------------------------------------------------------------
2369 #if defined(ABI_ELFv2)
2370   __ call_c(native_func, relocInfo::runtime_call_type);
2371 #else
2372   FunctionDescriptor* fd_native_method = (FunctionDescriptor*) native_func;
2373   __ call_c(fd_native_method, relocInfo::runtime_call_type);
2374 #endif
2375 
2376 
2377   // Now, we are back from the native code.
2378 
2379 
2380   // Unpack the native result.
2381   // --------------------------------------------------------------------------
2382 
2383   // For int-types, we do any needed sign-extension required.
2384   // Care must be taken that the return values (R3_RET and F1_RET)
2385   // will survive any VM calls for blocking or unlocking.
2386   // An OOP result (handle) is done specially in the slow-path code.
2387 
2388   switch (ret_type) {
2389     case T_VOID:    break;        // Nothing to do!
2390     case T_FLOAT:   break;        // Got it where we want it (unless slow-path).
2391     case T_DOUBLE:  break;        // Got it where we want it (unless slow-path).
2392     case T_LONG:    break;        // Got it where we want it (unless slow-path).
2393     case T_OBJECT:  break;        // Really a handle.
2394                                   // Cannot de-handlize until after reclaiming jvm_lock.
2395     case T_ARRAY:   break;
2396 
2397     case T_BOOLEAN: {             // 0 -&gt; false(0); !0 -&gt; true(1)
2398       Label skip_modify;
2399       __ cmpwi(CCR0, R3_RET, 0);
2400       __ beq(CCR0, skip_modify);
2401       __ li(R3_RET, 1);
2402       __ bind(skip_modify);
2403       break;
2404       }
2405     case T_BYTE: {                // sign extension
2406       __ extsb(R3_RET, R3_RET);
2407       break;
2408       }
2409     case T_CHAR: {                // unsigned result
2410       __ andi(R3_RET, R3_RET, 0xffff);
2411       break;
2412       }
2413     case T_SHORT: {               // sign extension
2414       __ extsh(R3_RET, R3_RET);
2415       break;
2416       }
2417     case T_INT:                   // nothing to do
2418       break;
2419     default:
2420       ShouldNotReachHere();
2421       break;
2422   }
2423 
2424 
2425   // Publish thread state
2426   // --------------------------------------------------------------------------
2427 
2428   // Switch thread to &quot;native transition&quot; state before reading the
2429   // synchronization state. This additional state is necessary because reading
2430   // and testing the synchronization state is not atomic w.r.t. GC, as this
2431   // scenario demonstrates:
2432   //   - Java thread A, in _thread_in_native state, loads _not_synchronized
2433   //     and is preempted.
2434   //   - VM thread changes sync state to synchronizing and suspends threads
2435   //     for GC.
2436   //   - Thread A is resumed to finish this native method, but doesn&#39;t block
2437   //     here since it didn&#39;t see any synchronization in progress, and escapes.
2438 
2439   // Transition from _thread_in_native to _thread_in_native_trans.
2440   __ li(R0, _thread_in_native_trans);
2441   __ release();
2442   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2443   __ stw(R0, thread_(thread_state));
2444 
2445 
2446   // Must we block?
2447   // --------------------------------------------------------------------------
2448 
2449   // Block, if necessary, before resuming in _thread_in_Java state.
2450   // In order for GC to work, don&#39;t clear the last_Java_sp until after blocking.
2451   Label after_transition;
2452   {
2453     Label no_block, sync;
2454 
2455     // Force this write out before the read below.
2456     __ fence();
2457 
2458     Register sync_state_addr = r_temp_4;
2459     Register sync_state      = r_temp_5;
2460     Register suspend_flags   = r_temp_6;
2461 
2462     // No synchronization in progress nor yet synchronized
2463     // (cmp-br-isync on one path, release (same as acquire on PPC64) on the other path).
2464     __ safepoint_poll(sync, sync_state);
2465 
2466     // Not suspended.
2467     // TODO: PPC port assert(4 == Thread::sz_suspend_flags(), &quot;unexpected field size&quot;);
2468     __ lwz(suspend_flags, thread_(suspend_flags));
2469     __ cmpwi(CCR1, suspend_flags, 0);
2470     __ beq(CCR1, no_block);
2471 
2472     // Block. Save any potential method result value before the operation and
2473     // use a leaf call to leave the last_Java_frame setup undisturbed. Doing this
2474     // lets us share the oopMap we used when we went native rather than create
2475     // a distinct one for this pc.
2476     __ bind(sync);
2477     __ isync();
2478 
2479     address entry_point = is_critical_native
2480       ? CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)
2481       : CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans);
2482     save_native_result(masm, ret_type, workspace_slot_offset);
2483     __ call_VM_leaf(entry_point, R16_thread);
2484     restore_native_result(masm, ret_type, workspace_slot_offset);
2485 
2486     if (is_critical_native) {
2487       __ b(after_transition); // No thread state transition here.
2488     }
2489     __ bind(no_block);
2490   }
2491 
2492   // Publish thread state.
2493   // --------------------------------------------------------------------------
2494 
2495   // Thread state is thread_in_native_trans. Any safepoint blocking has
2496   // already happened so we can now change state to _thread_in_Java.
2497 
2498   // Transition from _thread_in_native_trans to _thread_in_Java.
2499   __ li(R0, _thread_in_Java);
2500   __ lwsync(); // Acquire safepoint and suspend state, release thread state.
2501   // TODO: PPC port assert(4 == JavaThread::sz_thread_state(), &quot;unexpected field size&quot;);
2502   __ stw(R0, thread_(thread_state));
2503   __ bind(after_transition);
2504 
2505   // Reguard any pages if necessary.
2506   // --------------------------------------------------------------------------
2507 
2508   Label no_reguard;
2509   __ lwz(r_temp_1, thread_(stack_guard_state));
2510   __ cmpwi(CCR0, r_temp_1, JavaThread::stack_guard_yellow_reserved_disabled);
2511   __ bne(CCR0, no_reguard);
2512 
2513   save_native_result(masm, ret_type, workspace_slot_offset);
2514   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
2515   restore_native_result(masm, ret_type, workspace_slot_offset);
2516 
2517   __ bind(no_reguard);
2518 
2519 
2520   // Unlock
2521   // --------------------------------------------------------------------------
2522 
2523   if (method-&gt;is_synchronized()) {
2524 
2525     ConditionRegister r_flag   = CCR1;
2526     const Register r_oop       = r_temp_4;
2527     const Register r_box       = r_temp_5;
2528     const Register r_exception = r_temp_6;
2529     Label done;
2530 
2531     // Get oop and address of lock object box.
2532     if (method_is_static) {
2533       assert(klass_offset != -1, &quot;&quot;);
2534       __ ld(r_oop, klass_offset, R1_SP);
2535     } else {
2536       assert(receiver_offset != -1, &quot;&quot;);
2537       __ ld(r_oop, receiver_offset, R1_SP);
2538     }
2539     __ addi(r_box, R1_SP, lock_offset);
2540 
2541     // Try fastpath for unlocking.
2542     __ compiler_fast_unlock_object(r_flag, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);
2543     __ beq(r_flag, done);
2544 
2545     // Save and restore any potential method result value around the unlocking operation.
2546     save_native_result(masm, ret_type, workspace_slot_offset);
2547 
2548     // Must save pending exception around the slow-path VM call. Since it&#39;s a
2549     // leaf call, the pending exception (if any) can be kept in a register.
2550     __ ld(r_exception, thread_(pending_exception));
2551     assert(r_exception-&gt;is_nonvolatile(), &quot;exception register must be non-volatile&quot;);
2552     __ li(R0, 0);
2553     __ std(R0, thread_(pending_exception));
2554 
2555     // Slow case of monitor enter.
2556     // Inline a special case of call_VM that disallows any pending_exception.
2557     // Arguments are (oop obj, BasicLock* lock, JavaThread* thread).
2558     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), r_oop, r_box, R16_thread);
2559 
2560     __ asm_assert_mem8_is_zero(thread_(pending_exception),
2561        &quot;no pending exception allowed on exit from SharedRuntime::complete_monitor_unlocking_C&quot;, 0);
2562 
2563     restore_native_result(masm, ret_type, workspace_slot_offset);
2564 
2565     // Check_forward_pending_exception jump to forward_exception if any pending
2566     // exception is set. The forward_exception routine expects to see the
2567     // exception in pending_exception and not in a register. Kind of clumsy,
2568     // since all folks who branch to forward_exception must have tested
2569     // pending_exception first and hence have it in a register already.
2570     __ std(r_exception, thread_(pending_exception));
2571 
2572     __ bind(done);
2573   }
2574 
2575 # if 0
2576   // DTrace method exit
2577 # endif
2578 
2579   // Clear &quot;last Java frame&quot; SP and PC.
2580   // --------------------------------------------------------------------------
2581 
2582   __ reset_last_Java_frame();
2583 
2584   // Unbox oop result, e.g. JNIHandles::resolve value.
2585   // --------------------------------------------------------------------------
2586 
2587   if (is_reference_type(ret_type)) {
2588     __ resolve_jobject(R3_RET, r_temp_1, r_temp_2, /* needs_frame */ false);
2589   }
2590 
2591   if (CheckJNICalls) {
2592     // clear_pending_jni_exception_check
2593     __ load_const_optimized(R0, 0L);
2594     __ st_ptr(R0, JavaThread::pending_jni_exception_check_fn_offset(), R16_thread);
2595   }
2596 
2597   // Reset handle block.
2598   // --------------------------------------------------------------------------
2599   if (!is_critical_native) {
2600   __ ld(r_temp_1, thread_(active_handles));
2601   // TODO: PPC port assert(4 == JNIHandleBlock::top_size_in_bytes(), &quot;unexpected field size&quot;);
2602   __ li(r_temp_2, 0);
2603   __ stw(r_temp_2, JNIHandleBlock::top_offset_in_bytes(), r_temp_1);
2604 
2605 
2606   // Check for pending exceptions.
2607   // --------------------------------------------------------------------------
2608   __ ld(r_temp_2, thread_(pending_exception));
2609   __ cmpdi(CCR0, r_temp_2, 0);
2610   __ bne(CCR0, handle_pending_exception);
2611   }
2612 
2613   // Return
2614   // --------------------------------------------------------------------------
2615 
2616   __ pop_frame();
2617   __ restore_LR_CR(R11);
2618   __ blr();
2619 
2620 
2621   // Handler for pending exceptions (out-of-line).
2622   // --------------------------------------------------------------------------
2623   // Since this is a native call, we know the proper exception handler
2624   // is the empty function. We just pop this frame and then jump to
2625   // forward_exception_entry.
2626   if (!is_critical_native) {
2627   __ bind(handle_pending_exception);
2628 
2629   __ pop_frame();
2630   __ restore_LR_CR(R11);
2631   __ b64_patchable((address)StubRoutines::forward_exception_entry(),
2632                        relocInfo::runtime_call_type);
2633   }
2634 
2635   // Handler for a cache miss (out-of-line).
2636   // --------------------------------------------------------------------------
2637 
2638   if (!method_is_static) {
2639   __ bind(ic_miss);
2640 
2641   __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
2642                        relocInfo::runtime_call_type);
2643   }
2644 
2645   // Done.
2646   // --------------------------------------------------------------------------
2647 
2648   __ flush();
2649 
2650   nmethod *nm = nmethod::new_native_nmethod(method,
2651                                             compile_id,
2652                                             masm-&gt;code(),
2653                                             vep_start_pc-start_pc,
2654                                             frame_done_pc-start_pc,
2655                                             stack_slots / VMRegImpl::slots_per_word,
2656                                             (method_is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2657                                             in_ByteSize(lock_offset),
2658                                             oop_maps);
2659 
2660   if (is_critical_native) {
2661     nm-&gt;set_lazy_critical_native(true);
2662   }
2663 
2664   return nm;
2665 }
2666 
2667 // This function returns the adjust size (in number of words) to a c2i adapter
2668 // activation for use during deoptimization.
2669 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2670   return align_up((callee_locals - callee_parameters) * Interpreter::stackElementWords, frame::alignment_in_bytes);
2671 }
2672 
2673 uint SharedRuntime::out_preserve_stack_slots() {
2674 #if defined(COMPILER1) || defined(COMPILER2)
2675   return frame::jit_out_preserve_size / VMRegImpl::stack_slot_size;
2676 #else
2677   return 0;
2678 #endif
2679 }
2680 
2681 #if defined(COMPILER1) || defined(COMPILER2)
2682 // Frame generation for deopt and uncommon trap blobs.
2683 static void push_skeleton_frame(MacroAssembler* masm, bool deopt,
2684                                 /* Read */
2685                                 Register unroll_block_reg,
2686                                 /* Update */
2687                                 Register frame_sizes_reg,
2688                                 Register number_of_frames_reg,
2689                                 Register pcs_reg,
2690                                 /* Invalidate */
2691                                 Register frame_size_reg,
2692                                 Register pc_reg) {
2693 
2694   __ ld(pc_reg, 0, pcs_reg);
2695   __ ld(frame_size_reg, 0, frame_sizes_reg);
2696   __ std(pc_reg, _abi(lr), R1_SP);
2697   __ push_frame(frame_size_reg, R0/*tmp*/);
2698   __ std(R1_SP, _ijava_state_neg(sender_sp), R1_SP);
2699   __ addi(number_of_frames_reg, number_of_frames_reg, -1);
2700   __ addi(frame_sizes_reg, frame_sizes_reg, wordSize);
2701   __ addi(pcs_reg, pcs_reg, wordSize);
2702 }
2703 
2704 // Loop through the UnrollBlock info and create new frames.
2705 static void push_skeleton_frames(MacroAssembler* masm, bool deopt,
2706                                  /* read */
2707                                  Register unroll_block_reg,
2708                                  /* invalidate */
2709                                  Register frame_sizes_reg,
2710                                  Register number_of_frames_reg,
2711                                  Register pcs_reg,
2712                                  Register frame_size_reg,
2713                                  Register pc_reg) {
2714   Label loop;
2715 
2716  // _number_of_frames is of type int (deoptimization.hpp)
2717   __ lwa(number_of_frames_reg,
2718              Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes(),
2719              unroll_block_reg);
2720   __ ld(pcs_reg,
2721             Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes(),
2722             unroll_block_reg);
2723   __ ld(frame_sizes_reg,
2724             Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes(),
2725             unroll_block_reg);
2726 
2727   // stack: (caller_of_deoptee, ...).
2728 
2729   // At this point we either have an interpreter frame or a compiled
2730   // frame on top of stack. If it is a compiled frame we push a new c2i
2731   // adapter here
2732 
2733   // Memorize top-frame stack-pointer.
2734   __ mr(frame_size_reg/*old_sp*/, R1_SP);
2735 
2736   // Resize interpreter top frame OR C2I adapter.
2737 
2738   // At this moment, the top frame (which is the caller of the deoptee) is
2739   // an interpreter frame or a newly pushed C2I adapter or an entry frame.
2740   // The top frame has a TOP_IJAVA_FRAME_ABI and the frame contains the
2741   // outgoing arguments.
2742   //
2743   // In order to push the interpreter frame for the deoptee, we need to
2744   // resize the top frame such that we are able to place the deoptee&#39;s
2745   // locals in the frame.
2746   // Additionally, we have to turn the top frame&#39;s TOP_IJAVA_FRAME_ABI
2747   // into a valid PARENT_IJAVA_FRAME_ABI.
2748 
2749   __ lwa(R11_scratch1,
2750              Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes(),
2751              unroll_block_reg);
2752   __ neg(R11_scratch1, R11_scratch1);
2753 
2754   // R11_scratch1 contains size of locals for frame resizing.
2755   // R12_scratch2 contains top frame&#39;s lr.
2756 
2757   // Resize frame by complete frame size prevents TOC from being
2758   // overwritten by locals. A more stack space saving way would be
2759   // to copy the TOC to its location in the new abi.
2760   __ addi(R11_scratch1, R11_scratch1, - frame::parent_ijava_frame_abi_size);
2761 
2762   // now, resize the frame
2763   __ resize_frame(R11_scratch1, pc_reg/*tmp*/);
2764 
2765   // In the case where we have resized a c2i frame above, the optional
2766   // alignment below the locals has size 32 (why?).
2767   __ std(R12_scratch2, _abi(lr), R1_SP);
2768 
2769   // Initialize initial_caller_sp.
2770  __ std(frame_size_reg, _ijava_state_neg(sender_sp), R1_SP);
2771 
2772 #ifdef ASSERT
2773   // Make sure that there is at least one entry in the array.
2774   __ cmpdi(CCR0, number_of_frames_reg, 0);
2775   __ asm_assert_ne(&quot;array_size must be &gt; 0&quot;, 0x205);
2776 #endif
2777 
2778   // Now push the new interpreter frames.
2779   //
2780   __ bind(loop);
2781   // Allocate a new frame, fill in the pc.
2782   push_skeleton_frame(masm, deopt,
2783                       unroll_block_reg,
2784                       frame_sizes_reg,
2785                       number_of_frames_reg,
2786                       pcs_reg,
2787                       frame_size_reg,
2788                       pc_reg);
2789   __ cmpdi(CCR0, number_of_frames_reg, 0);
2790   __ bne(CCR0, loop);
2791 
2792   // Get the return address pointing into the frame manager.
2793   __ ld(R0, 0, pcs_reg);
2794   // Store it in the top interpreter frame.
2795   __ std(R0, _abi(lr), R1_SP);
2796   // Initialize frame_manager_lr of interpreter top frame.
2797 }
2798 #endif
2799 
2800 void SharedRuntime::generate_deopt_blob() {
2801   // Allocate space for the code
2802   ResourceMark rm;
2803   // Setup code generation tools
2804   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048, 1024);
2805   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
2806   Label exec_mode_initialized;
2807   int frame_size_in_words;
2808   OopMap* map = NULL;
2809   OopMapSet *oop_maps = new OopMapSet();
2810 
2811   // size of ABI112 plus spill slots for R3_RET and F1_RET.
2812   const int frame_size_in_bytes = frame::abi_reg_args_spill_size;
2813   const int frame_size_in_slots = frame_size_in_bytes / sizeof(jint);
2814   int first_frame_size_in_bytes = 0; // frame size of &quot;unpack frame&quot; for call to fetch_unroll_info.
2815 
2816   const Register exec_mode_reg = R21_tmp1;
2817 
2818   const address start = __ pc();
2819 
2820 #if defined(COMPILER1) || defined(COMPILER2)
2821   // --------------------------------------------------------------------------
2822   // Prolog for non exception case!
2823 
2824   // We have been called from the deopt handler of the deoptee.
2825   //
2826   // deoptee:
2827   //                      ...
2828   //                      call X
2829   //                      ...
2830   //  deopt_handler:      call_deopt_stub
2831   //  cur. return pc  --&gt; ...
2832   //
2833   // So currently SR_LR points behind the call in the deopt handler.
2834   // We adjust it such that it points to the start of the deopt handler.
2835   // The return_pc has been stored in the frame of the deoptee and
2836   // will replace the address of the deopt_handler in the call
2837   // to Deoptimization::fetch_unroll_info below.
2838   // We can&#39;t grab a free register here, because all registers may
2839   // contain live values, so let the RegisterSaver do the adjustment
2840   // of the return pc.
2841   const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;
2842 
2843   // Push the &quot;unpack frame&quot;
2844   // Save everything in sight.
2845   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2846                                                                    &amp;first_frame_size_in_bytes,
2847                                                                    /*generate_oop_map=*/ true,
2848                                                                    return_pc_adjustment_no_exception,
2849                                                                    RegisterSaver::return_pc_is_lr);
2850   assert(map != NULL, &quot;OopMap must have been created&quot;);
2851 
2852   __ li(exec_mode_reg, Deoptimization::Unpack_deopt);
2853   // Save exec mode for unpack_frames.
2854   __ b(exec_mode_initialized);
2855 
2856   // --------------------------------------------------------------------------
2857   // Prolog for exception case
2858 
2859   // An exception is pending.
2860   // We have been called with a return (interpreter) or a jump (exception blob).
2861   //
2862   // - R3_ARG1: exception oop
2863   // - R4_ARG2: exception pc
2864 
2865   int exception_offset = __ pc() - start;
2866 
2867   BLOCK_COMMENT(&quot;Prolog for exception case&quot;);
2868 
2869   // Store exception oop and pc in thread (location known to GC).
2870   // This is needed since the call to &quot;fetch_unroll_info()&quot; may safepoint.
2871   __ std(R3_ARG1, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2872   __ std(R4_ARG2, in_bytes(JavaThread::exception_pc_offset()),  R16_thread);
2873   __ std(R4_ARG2, _abi(lr), R1_SP);
2874 
2875   // Vanilla deoptimization with an exception pending in exception_oop.
2876   int exception_in_tls_offset = __ pc() - start;
2877 
2878   // Push the &quot;unpack frame&quot;.
2879   // Save everything in sight.
2880   RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2881                                                              &amp;first_frame_size_in_bytes,
2882                                                              /*generate_oop_map=*/ false,
2883                                                              /*return_pc_adjustment_exception=*/ 0,
2884                                                              RegisterSaver::return_pc_is_pre_saved);
2885 
2886   // Deopt during an exception. Save exec mode for unpack_frames.
2887   __ li(exec_mode_reg, Deoptimization::Unpack_exception);
2888 
2889   // fall through
2890 
2891   int reexecute_offset = 0;
2892 #ifdef COMPILER1
2893   __ b(exec_mode_initialized);
2894 
2895   // Reexecute entry, similar to c2 uncommon trap
2896   reexecute_offset = __ pc() - start;
2897 
2898   RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
2899                                                              &amp;first_frame_size_in_bytes,
2900                                                              /*generate_oop_map=*/ false,
2901                                                              /*return_pc_adjustment_reexecute=*/ 0,
2902                                                              RegisterSaver::return_pc_is_pre_saved);
2903   __ li(exec_mode_reg, Deoptimization::Unpack_reexecute);
2904 #endif
2905 
2906   // --------------------------------------------------------------------------
2907   __ BIND(exec_mode_initialized);
2908 
2909   {
2910   const Register unroll_block_reg = R22_tmp2;
2911 
2912   // We need to set `last_Java_frame&#39; because `fetch_unroll_info&#39; will
2913   // call `last_Java_frame()&#39;. The value of the pc in the frame is not
2914   // particularly important. It just needs to identify this blob.
2915   __ set_last_Java_frame(R1_SP, noreg);
2916 
2917   // With EscapeAnalysis turned on, this call may safepoint!
2918   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info), R16_thread, exec_mode_reg);
2919   address calls_return_pc = __ last_calls_return_pc();
2920   // Set an oopmap for the call site that describes all our saved registers.
2921   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
2922 
2923   __ reset_last_Java_frame();
2924   // Save the return value.
2925   __ mr(unroll_block_reg, R3_RET);
2926 
2927   // Restore only the result registers that have been saved
2928   // by save_volatile_registers(...).
2929   RegisterSaver::restore_result_registers(masm, first_frame_size_in_bytes);
2930 
2931   // reload the exec mode from the UnrollBlock (it might have changed)
2932   __ lwz(exec_mode_reg, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);
2933   // In excp_deopt_mode, restore and clear exception oop which we
2934   // stored in the thread during exception entry above. The exception
2935   // oop will be the return value of this stub.
2936   Label skip_restore_excp;
2937   __ cmpdi(CCR0, exec_mode_reg, Deoptimization::Unpack_exception);
2938   __ bne(CCR0, skip_restore_excp);
2939   __ ld(R3_RET, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2940   __ ld(R4_ARG2, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
2941   __ li(R0, 0);
2942   __ std(R0, in_bytes(JavaThread::exception_pc_offset()),  R16_thread);
2943   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
2944   __ BIND(skip_restore_excp);
2945 
2946   __ pop_frame();
2947 
2948   // stack: (deoptee, optional i2c, caller of deoptee, ...).
2949 
2950   // pop the deoptee&#39;s frame
2951   __ pop_frame();
2952 
2953   // stack: (caller_of_deoptee, ...).
2954 
2955   // Loop through the `UnrollBlock&#39; info and create interpreter frames.
2956   push_skeleton_frames(masm, true/*deopt*/,
2957                        unroll_block_reg,
2958                        R23_tmp3,
2959                        R24_tmp4,
2960                        R25_tmp5,
2961                        R26_tmp6,
2962                        R27_tmp7);
2963 
2964   // stack: (skeletal interpreter frame, ..., optional skeletal
2965   // interpreter frame, optional c2i, caller of deoptee, ...).
2966   }
2967 
2968   // push an `unpack_frame&#39; taking care of float / int return values.
2969   __ push_frame(frame_size_in_bytes, R0/*tmp*/);
2970 
2971   // stack: (unpack frame, skeletal interpreter frame, ..., optional
2972   // skeletal interpreter frame, optional c2i, caller of deoptee,
2973   // ...).
2974 
2975   // Spill live volatile registers since we&#39;ll do a call.
2976   __ std( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);
2977   __ stfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);
2978 
2979   // Let the unpacker layout information in the skeletal frames just
2980   // allocated.
2981   __ get_PC_trash_LR(R3_RET);
2982   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R3_RET);
2983   // This is a call to a LEAF method, so no oop map is required.
2984   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames),
2985                   R16_thread/*thread*/, exec_mode_reg/*exec_mode*/);
2986   __ reset_last_Java_frame();
2987 
2988   // Restore the volatiles saved above.
2989   __ ld( R3_RET, _abi_reg_args_spill(spill_ret),  R1_SP);
2990   __ lfd(F1_RET, _abi_reg_args_spill(spill_fret), R1_SP);
2991 
2992   // Pop the unpack frame.
2993   __ pop_frame();
2994   __ restore_LR_CR(R0);
2995 
2996   // stack: (top interpreter frame, ..., optional interpreter frame,
2997   // optional c2i, caller of deoptee, ...).
2998 
2999   // Initialize R14_state.
3000   __ restore_interpreter_state(R11_scratch1);
3001   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
3002 
3003   // Return to the interpreter entry point.
3004   __ blr();
3005   __ flush();
3006 #else // COMPILER2
3007   __ unimplemented(&quot;deopt blob needed only with compiler&quot;);
3008   int exception_offset = __ pc() - start;
3009 #endif // COMPILER2
3010 
3011   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset,
3012                                            reexecute_offset, first_frame_size_in_bytes / wordSize);
3013   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
3014 }
3015 
3016 #ifdef COMPILER2
3017 void SharedRuntime::generate_uncommon_trap_blob() {
3018   // Allocate space for the code.
3019   ResourceMark rm;
3020   // Setup code generation tools.
3021   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
3022   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
3023   address start = __ pc();
3024 
3025   if (UseRTMLocking) {
3026     // Abort RTM transaction before possible nmethod deoptimization.
3027     __ tabort_();
3028   }
3029 
3030   Register unroll_block_reg = R21_tmp1;
3031   Register klass_index_reg  = R22_tmp2;
3032   Register unc_trap_reg     = R23_tmp3;
3033 
3034   OopMapSet* oop_maps = new OopMapSet();
3035   int frame_size_in_bytes = frame::abi_reg_args_size;
3036   OopMap* map = new OopMap(frame_size_in_bytes / sizeof(jint), 0);
3037 
3038   // stack: (deoptee, optional i2c, caller_of_deoptee, ...).
3039 
3040   // Push a dummy `unpack_frame&#39; and call
3041   // `Deoptimization::uncommon_trap&#39; to pack the compiled frame into a
3042   // vframe array and return the `UnrollBlock&#39; information.
3043 
3044   // Save LR to compiled frame.
3045   __ save_LR_CR(R11_scratch1);
3046 
3047   // Push an &quot;uncommon_trap&quot; frame.
3048   __ push_frame_reg_args(0, R11_scratch1);
3049 
3050   // stack: (unpack frame, deoptee, optional i2c, caller_of_deoptee, ...).
3051 
3052   // Set the `unpack_frame&#39; as last_Java_frame.
3053   // `Deoptimization::uncommon_trap&#39; expects it and considers its
3054   // sender frame as the deoptee frame.
3055   // Remember the offset of the instruction whose address will be
3056   // moved to R11_scratch1.
3057   address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);
3058 
3059   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R11_scratch1);
3060 
3061   __ mr(klass_index_reg, R3);
3062   __ li(R5_ARG3, Deoptimization::Unpack_uncommon_trap);
3063   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap),
3064                   R16_thread, klass_index_reg, R5_ARG3);
3065 
3066   // Set an oopmap for the call site.
3067   oop_maps-&gt;add_gc_map(gc_map_pc - start, map);
3068 
3069   __ reset_last_Java_frame();
3070 
3071   // Pop the `unpack frame&#39;.
3072   __ pop_frame();
3073 
3074   // stack: (deoptee, optional i2c, caller_of_deoptee, ...).
3075 
3076   // Save the return value.
3077   __ mr(unroll_block_reg, R3_RET);
3078 
3079   // Pop the uncommon_trap frame.
3080   __ pop_frame();
3081 
3082   // stack: (caller_of_deoptee, ...).
3083 
3084 #ifdef ASSERT
3085   __ lwz(R22_tmp2, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes(), unroll_block_reg);
3086   __ cmpdi(CCR0, R22_tmp2, (unsigned)Deoptimization::Unpack_uncommon_trap);
3087   __ asm_assert_eq(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;, 0);
3088 #endif
3089 
3090   // Allocate new interpreter frame(s) and possibly a c2i adapter
3091   // frame.
3092   push_skeleton_frames(masm, false/*deopt*/,
3093                        unroll_block_reg,
3094                        R22_tmp2,
3095                        R23_tmp3,
3096                        R24_tmp4,
3097                        R25_tmp5,
3098                        R26_tmp6);
3099 
3100   // stack: (skeletal interpreter frame, ..., optional skeletal
3101   // interpreter frame, optional c2i, caller of deoptee, ...).
3102 
3103   // Push a dummy `unpack_frame&#39; taking care of float return values.
3104   // Call `Deoptimization::unpack_frames&#39; to layout information in the
3105   // interpreter frames just created.
3106 
3107   // Push a simple &quot;unpack frame&quot; here.
3108   __ push_frame_reg_args(0, R11_scratch1);
3109 
3110   // stack: (unpack frame, skeletal interpreter frame, ..., optional
3111   // skeletal interpreter frame, optional c2i, caller of deoptee,
3112   // ...).
3113 
3114   // Set the &quot;unpack_frame&quot; as last_Java_frame.
3115   __ get_PC_trash_LR(R11_scratch1);
3116   __ set_last_Java_frame(/*sp*/R1_SP, /*pc*/R11_scratch1);
3117 
3118   // Indicate it is the uncommon trap case.
3119   __ li(unc_trap_reg, Deoptimization::Unpack_uncommon_trap);
3120   // Let the unpacker layout information in the skeletal frames just
3121   // allocated.
3122   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames),
3123                   R16_thread, unc_trap_reg);
3124 
3125   __ reset_last_Java_frame();
3126   // Pop the `unpack frame&#39;.
3127   __ pop_frame();
3128   // Restore LR from top interpreter frame.
3129   __ restore_LR_CR(R11_scratch1);
3130 
3131   // stack: (top interpreter frame, ..., optional interpreter frame,
3132   // optional c2i, caller of deoptee, ...).
3133 
3134   __ restore_interpreter_state(R11_scratch1);
3135   __ load_const_optimized(R25_templateTableBase, (address)Interpreter::dispatch_table((TosState)0), R11_scratch1);
3136 
3137   // Return to the interpreter entry point.
3138   __ blr();
3139 
3140   masm-&gt;flush();
3141 
3142   _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, oop_maps, frame_size_in_bytes/wordSize);
3143 }
3144 #endif // COMPILER2
3145 
3146 // Generate a special Compile2Runtime blob that saves all registers, and setup oopmap.
3147 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3148   assert(StubRoutines::forward_exception_entry() != NULL,
3149          &quot;must be generated before&quot;);
3150 
3151   ResourceMark rm;
3152   OopMapSet *oop_maps = new OopMapSet();
3153   OopMap* map;
3154 
3155   // Allocate space for the code. Setup code generation tools.
3156   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3157   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3158 
3159   address start = __ pc();
3160   int frame_size_in_bytes = 0;
3161 
3162   RegisterSaver::ReturnPCLocation return_pc_location;
3163   bool cause_return = (poll_type == POLL_AT_RETURN);
3164   if (cause_return) {
3165     // Nothing to do here. The frame has already been popped in MachEpilogNode.
3166     // Register LR already contains the return pc.
3167     return_pc_location = RegisterSaver::return_pc_is_lr;
3168   } else {
3169     // Use thread()-&gt;saved_exception_pc() as return pc.
3170     return_pc_location = RegisterSaver::return_pc_is_thread_saved_exception_pc;
3171   }
3172 
3173   if (UseRTMLocking) {
3174     // Abort RTM transaction before calling runtime
3175     // because critical section can be large and so
3176     // will abort anyway. Also nmethod can be deoptimized.
3177     __ tabort_();
3178   }
3179 
3180   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3181 
3182   // Save registers, fpu state, and flags. Set R31 = return pc.
3183   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
3184                                                                    &amp;frame_size_in_bytes,
3185                                                                    /*generate_oop_map=*/ true,
3186                                                                    /*return_pc_adjustment=*/0,
3187                                                                    return_pc_location, save_vectors);
3188 
3189   // The following is basically a call_VM. However, we need the precise
3190   // address of the call in order to generate an oopmap. Hence, we do all the
3191   // work outselves.
3192   __ set_last_Java_frame(/*sp=*/R1_SP, /*pc=*/noreg);
3193 
3194   // The return address must always be correct so that the frame constructor
3195   // never sees an invalid pc.
3196 
3197   // Do the call
3198   __ call_VM_leaf(call_ptr, R16_thread);
3199   address calls_return_pc = __ last_calls_return_pc();
3200 
3201   // Set an oopmap for the call site. This oopmap will map all
3202   // oop-registers and debug-info registers as callee-saved. This
3203   // will allow deoptimization at this safepoint to find all possible
3204   // debug-info recordings, as well as let GC find all oops.
3205   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
3206 
3207   Label noException;
3208 
3209   // Clear the last Java frame.
3210   __ reset_last_Java_frame();
3211 
3212   BLOCK_COMMENT(&quot;  Check pending exception.&quot;);
3213   const Register pending_exception = R0;
3214   __ ld(pending_exception, thread_(pending_exception));
3215   __ cmpdi(CCR0, pending_exception, 0);
3216   __ beq(CCR0, noException);
3217 
3218   // Exception pending
3219   RegisterSaver::restore_live_registers_and_pop_frame(masm,
3220                                                       frame_size_in_bytes,
3221                                                       /*restore_ctr=*/true, save_vectors);
3222 
3223   BLOCK_COMMENT(&quot;  Jump to forward_exception_entry.&quot;);
3224   // Jump to forward_exception_entry, with the issuing PC in LR
3225   // so it looks like the original nmethod called forward_exception_entry.
3226   __ b64_patchable(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
3227 
3228   // No exception case.
3229   __ BIND(noException);
3230 
3231   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3232     Label no_adjust;
3233     // If our stashed return pc was modified by the runtime we avoid touching it
3234     __ ld(R0, frame_size_in_bytes + _abi(lr), R1_SP);
3235     __ cmpd(CCR0, R0, R31);
3236     __ bne(CCR0, no_adjust);
3237 
3238     // Adjust return pc forward to step over the safepoint poll instruction
3239     __ addi(R31, R31, 4);
3240     __ std(R31, frame_size_in_bytes + _abi(lr), R1_SP);
3241 
3242     __ bind(no_adjust);
3243   }
3244 
3245   // Normal exit, restore registers and exit.
3246   RegisterSaver::restore_live_registers_and_pop_frame(masm,
3247                                                       frame_size_in_bytes,
3248                                                       /*restore_ctr=*/true, save_vectors);
3249 
3250   __ blr();
3251 
3252   // Make sure all code is generated
3253   masm-&gt;flush();
3254 
3255   // Fill-out other meta info
3256   // CodeBlob frame size is in words.
3257   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_bytes / wordSize);
3258 }
3259 
3260 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss)
3261 //
3262 // Generate a stub that calls into the vm to find out the proper destination
3263 // of a java call. All the argument registers are live at this point
3264 // but since this is generic code we don&#39;t know what they are and the caller
3265 // must do any gc of the args.
3266 //
3267 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3268 
3269   // allocate space for the code
3270   ResourceMark rm;
3271 
3272   CodeBuffer buffer(name, 1000, 512);
3273   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3274 
3275   int frame_size_in_bytes;
3276 
3277   OopMapSet *oop_maps = new OopMapSet();
3278   OopMap* map = NULL;
3279 
3280   address start = __ pc();
3281 
3282   map = RegisterSaver::push_frame_reg_args_and_save_live_registers(masm,
3283                                                                    &amp;frame_size_in_bytes,
3284                                                                    /*generate_oop_map*/ true,
3285                                                                    /*return_pc_adjustment*/ 0,
3286                                                                    RegisterSaver::return_pc_is_lr);
3287 
3288   // Use noreg as last_Java_pc, the return pc will be reconstructed
3289   // from the physical frame.
3290   __ set_last_Java_frame(/*sp*/R1_SP, noreg);
3291 
3292   int frame_complete = __ offset();
3293 
3294   // Pass R19_method as 2nd (optional) argument, used by
3295   // counter_overflow_stub.
3296   __ call_VM_leaf(destination, R16_thread, R19_method);
3297   address calls_return_pc = __ last_calls_return_pc();
3298   // Set an oopmap for the call site.
3299   // We need this not only for callee-saved registers, but also for volatile
3300   // registers that the compiler might be keeping live across a safepoint.
3301   // Create the oopmap for the call&#39;s return pc.
3302   oop_maps-&gt;add_gc_map(calls_return_pc - start, map);
3303 
3304   // R3_RET contains the address we are going to jump to assuming no exception got installed.
3305 
3306   // clear last_Java_sp
3307   __ reset_last_Java_frame();
3308 
3309   // Check for pending exceptions.
3310   BLOCK_COMMENT(&quot;Check for pending exceptions.&quot;);
3311   Label pending;
3312   __ ld(R11_scratch1, thread_(pending_exception));
3313   __ cmpdi(CCR0, R11_scratch1, 0);
3314   __ bne(CCR0, pending);
3315 
3316   __ mtctr(R3_RET); // Ctr will not be touched by restore_live_registers_and_pop_frame.
3317 
3318   RegisterSaver::restore_live_registers_and_pop_frame(masm, frame_size_in_bytes, /*restore_ctr*/ false);
3319 
3320   // Get the returned method.
3321   __ get_vm_result_2(R19_method);
3322 
3323   __ bctr();
3324 
3325 
3326   // Pending exception after the safepoint.
3327   __ BIND(pending);
3328 
3329   RegisterSaver::restore_live_registers_and_pop_frame(masm, frame_size_in_bytes, /*restore_ctr*/ true);
3330 
3331   // exception pending =&gt; remove activation and forward to exception handler
3332 
3333   __ li(R11_scratch1, 0);
3334   __ ld(R3_ARG1, thread_(pending_exception));
3335   __ std(R11_scratch1, in_bytes(JavaThread::vm_result_offset()), R16_thread);
3336   __ b64_patchable(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
3337 
3338   // -------------
3339   // Make sure all code is generated.
3340   masm-&gt;flush();
3341 
3342   // return the blob
3343   // frame_size_words or bytes??
3344   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_bytes/wordSize,
3345                                        oop_maps, true);
3346 }
3347 
3348 
3349 //------------------------------Montgomery multiplication------------------------
3350 //
3351 
3352 // Subtract 0:b from carry:a. Return carry.
3353 static unsigned long
3354 sub(unsigned long a[], unsigned long b[], unsigned long carry, long len) {
3355   long i = 0;
3356   unsigned long tmp, tmp2;
3357   __asm__ __volatile__ (
3358     &quot;subfc  %[tmp], %[tmp], %[tmp]   \n&quot; // pre-set CA
3359     &quot;mtctr  %[len]                   \n&quot;
3360     &quot;0:                              \n&quot;
3361     &quot;ldx    %[tmp], %[i], %[a]       \n&quot;
3362     &quot;ldx    %[tmp2], %[i], %[b]      \n&quot;
3363     &quot;subfe  %[tmp], %[tmp2], %[tmp]  \n&quot; // subtract extended
3364     &quot;stdx   %[tmp], %[i], %[a]       \n&quot;
3365     &quot;addi   %[i], %[i], 8            \n&quot;
3366     &quot;bdnz   0b                       \n&quot;
3367     &quot;addme  %[tmp], %[carry]         \n&quot; // carry + CA - 1
3368     : [i]&quot;+b&quot;(i), [tmp]&quot;=&amp;r&quot;(tmp), [tmp2]&quot;=&amp;r&quot;(tmp2)
3369     : [a]&quot;r&quot;(a), [b]&quot;r&quot;(b), [carry]&quot;r&quot;(carry), [len]&quot;r&quot;(len)
3370     : &quot;ctr&quot;, &quot;xer&quot;, &quot;memory&quot;
3371   );
3372   return tmp;
3373 }
3374 
3375 // Multiply (unsigned) Long A by Long B, accumulating the double-
3376 // length result into the accumulator formed of T0, T1, and T2.
3377 inline void MACC(unsigned long A, unsigned long B, unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3378   unsigned long hi, lo;
3379   __asm__ __volatile__ (
3380     &quot;mulld  %[lo], %[A], %[B]    \n&quot;
3381     &quot;mulhdu %[hi], %[A], %[B]    \n&quot;
3382     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3383     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3384     &quot;addze  %[T2], %[T2]         \n&quot;
3385     : [hi]&quot;=&amp;r&quot;(hi), [lo]&quot;=&amp;r&quot;(lo), [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3386     : [A]&quot;r&quot;(A), [B]&quot;r&quot;(B)
3387     : &quot;xer&quot;
3388   );
3389 }
3390 
3391 // As above, but add twice the double-length result into the
3392 // accumulator.
3393 inline void MACC2(unsigned long A, unsigned long B, unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3394   unsigned long hi, lo;
3395   __asm__ __volatile__ (
3396     &quot;mulld  %[lo], %[A], %[B]    \n&quot;
3397     &quot;mulhdu %[hi], %[A], %[B]    \n&quot;
3398     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3399     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3400     &quot;addze  %[T2], %[T2]         \n&quot;
3401     &quot;addc   %[T0], %[T0], %[lo]  \n&quot;
3402     &quot;adde   %[T1], %[T1], %[hi]  \n&quot;
3403     &quot;addze  %[T2], %[T2]         \n&quot;
3404     : [hi]&quot;=&amp;r&quot;(hi), [lo]&quot;=&amp;r&quot;(lo), [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3405     : [A]&quot;r&quot;(A), [B]&quot;r&quot;(B)
3406     : &quot;xer&quot;
3407   );
3408 }
3409 
3410 // Fast Montgomery multiplication. The derivation of the algorithm is
3411 // in &quot;A Cryptographic Library for the Motorola DSP56000,
3412 // Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237&quot;.
3413 static void
3414 montgomery_multiply(unsigned long a[], unsigned long b[], unsigned long n[],
3415                     unsigned long m[], unsigned long inv, int len) {
3416   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3417   int i;
3418 
3419   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3420 
3421   for (i = 0; i &lt; len; i++) {
3422     int j;
3423     for (j = 0; j &lt; i; j++) {
3424       MACC(a[j], b[i-j], t0, t1, t2);
3425       MACC(m[j], n[i-j], t0, t1, t2);
3426     }
3427     MACC(a[i], b[0], t0, t1, t2);
3428     m[i] = t0 * inv;
3429     MACC(m[i], n[0], t0, t1, t2);
3430 
3431     assert(t0 == 0, &quot;broken Montgomery multiply&quot;);
3432 
3433     t0 = t1; t1 = t2; t2 = 0;
3434   }
3435 
3436   for (i = len; i &lt; 2*len; i++) {
3437     int j;
3438     for (j = i-len+1; j &lt; len; j++) {
3439       MACC(a[j], b[i-j], t0, t1, t2);
3440       MACC(m[j], n[i-j], t0, t1, t2);
3441     }
3442     m[i-len] = t0;
3443     t0 = t1; t1 = t2; t2 = 0;
3444   }
3445 
3446   while (t0) {
3447     t0 = sub(m, n, t0, len);
3448   }
3449 }
3450 
3451 // Fast Montgomery squaring. This uses asymptotically 25% fewer
3452 // multiplies so it should be up to 25% faster than Montgomery
3453 // multiplication. However, its loop control is more complex and it
3454 // may actually run slower on some machines.
3455 static void
3456 montgomery_square(unsigned long a[], unsigned long n[],
3457                   unsigned long m[], unsigned long inv, int len) {
3458   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3459   int i;
3460 
3461   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3462 
3463   for (i = 0; i &lt; len; i++) {
3464     int j;
3465     int end = (i+1)/2;
3466     for (j = 0; j &lt; end; j++) {
3467       MACC2(a[j], a[i-j], t0, t1, t2);
3468       MACC(m[j], n[i-j], t0, t1, t2);
3469     }
3470     if ((i &amp; 1) == 0) {
3471       MACC(a[j], a[j], t0, t1, t2);
3472     }
3473     for (; j &lt; i; j++) {
3474       MACC(m[j], n[i-j], t0, t1, t2);
3475     }
3476     m[i] = t0 * inv;
3477     MACC(m[i], n[0], t0, t1, t2);
3478 
3479     assert(t0 == 0, &quot;broken Montgomery square&quot;);
3480 
3481     t0 = t1; t1 = t2; t2 = 0;
3482   }
3483 
3484   for (i = len; i &lt; 2*len; i++) {
3485     int start = i-len+1;
3486     int end = start + (len - start)/2;
3487     int j;
3488     for (j = start; j &lt; end; j++) {
3489       MACC2(a[j], a[i-j], t0, t1, t2);
3490       MACC(m[j], n[i-j], t0, t1, t2);
3491     }
3492     if ((i &amp; 1) == 0) {
3493       MACC(a[j], a[j], t0, t1, t2);
3494     }
3495     for (; j &lt; len; j++) {
3496       MACC(m[j], n[i-j], t0, t1, t2);
3497     }
3498     m[i-len] = t0;
3499     t0 = t1; t1 = t2; t2 = 0;
3500   }
3501 
3502   while (t0) {
3503     t0 = sub(m, n, t0, len);
3504   }
3505 }
3506 
3507 // The threshold at which squaring is advantageous was determined
3508 // experimentally on an i7-3930K (Ivy Bridge) CPU @ 3.5GHz.
3509 // Doesn&#39;t seem to be relevant for Power8 so we use the same value.
3510 #define MONTGOMERY_SQUARING_THRESHOLD 64
3511 
3512 // Copy len longwords from s to d, word-swapping as we go. The
3513 // destination array is reversed.
3514 static void reverse_words(unsigned long *s, unsigned long *d, int len) {
3515   d += len;
3516   while(len-- &gt; 0) {
3517     d--;
3518     unsigned long s_val = *s;
3519     // Swap words in a longword on little endian machines.
3520 #ifdef VM_LITTLE_ENDIAN
3521      s_val = (s_val &lt;&lt; 32) | (s_val &gt;&gt; 32);
3522 #endif
3523     *d = s_val;
3524     s++;
3525   }
3526 }
3527 
3528 void SharedRuntime::montgomery_multiply(jint *a_ints, jint *b_ints, jint *n_ints,
3529                                         jint len, jlong inv,
3530                                         jint *m_ints) {
3531   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3532   assert(len % 2 == 0, &quot;array length in montgomery_multiply must be even&quot;);
3533   int longwords = len/2;
3534 
3535   // Make very sure we don&#39;t use so much space that the stack might
3536   // overflow. 512 jints corresponds to an 16384-bit integer and
3537   // will use here a total of 8k bytes of stack space.
3538   int total_allocation = longwords * sizeof (unsigned long) * 4;
3539   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3540   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3541 
3542   // Local scratch arrays
3543   unsigned long
3544     *a = scratch + 0 * longwords,
3545     *b = scratch + 1 * longwords,
3546     *n = scratch + 2 * longwords,
3547     *m = scratch + 3 * longwords;
3548 
3549   reverse_words((unsigned long *)a_ints, a, longwords);
3550   reverse_words((unsigned long *)b_ints, b, longwords);
3551   reverse_words((unsigned long *)n_ints, n, longwords);
3552 
3553   ::montgomery_multiply(a, b, n, m, (unsigned long)inv, longwords);
3554 
3555   reverse_words(m, (unsigned long *)m_ints, longwords);
3556 }
3557 
3558 void SharedRuntime::montgomery_square(jint *a_ints, jint *n_ints,
3559                                       jint len, jlong inv,
3560                                       jint *m_ints) {
3561   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3562   assert(len % 2 == 0, &quot;array length in montgomery_square must be even&quot;);
3563   int longwords = len/2;
3564 
3565   // Make very sure we don&#39;t use so much space that the stack might
3566   // overflow. 512 jints corresponds to an 16384-bit integer and
3567   // will use here a total of 6k bytes of stack space.
3568   int total_allocation = longwords * sizeof (unsigned long) * 3;
3569   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3570   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3571 
3572   // Local scratch arrays
3573   unsigned long
3574     *a = scratch + 0 * longwords,
3575     *n = scratch + 1 * longwords,
3576     *m = scratch + 2 * longwords;
3577 
3578   reverse_words((unsigned long *)a_ints, a, longwords);
3579   reverse_words((unsigned long *)n_ints, n, longwords);
3580 
3581   if (len &gt;= MONTGOMERY_SQUARING_THRESHOLD) {
3582     ::montgomery_square(a, n, m, (unsigned long)inv, longwords);
3583   } else {
3584     ::montgomery_multiply(a, a, n, m, (unsigned long)inv, longwords);
3585   }
3586 
3587   reverse_words(m, (unsigned long *)m_ints, longwords);
3588 }
    </pre>
  </body>
</html>