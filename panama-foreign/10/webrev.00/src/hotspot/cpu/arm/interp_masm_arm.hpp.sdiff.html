<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/interp_masm_arm.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/interp_masm_arm.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37 
 38  public:
 39 
 40   // allow JvmtiExport checks to be extended
 41   bool can_force_early_return()       { return JvmtiExport::can_force_early_return(); }
 42   bool can_post_interpreter_events()  { return JvmtiExport::can_post_interpreter_events(); }
 43   bool can_pop_frame()                { return JvmtiExport::can_pop_frame(); }
 44   bool can_post_breakpoint()          { return JvmtiExport::can_post_breakpoint(); }
 45   bool can_post_field_access()        { return JvmtiExport::can_post_field_access(); }
 46   bool can_post_field_modification()  { return JvmtiExport::can_post_field_modification(); }
 47   // flags controlled by JVMTI settings
 48   bool rewrite_frequent_pairs()       { return RewriteFrequentPairs; }
 49 
 50  protected:
 51 
 52   // Template interpreter specific version of call_VM_helper
 53   virtual void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions);
 54 
 55   // base routine for all dispatches
 56   typedef enum { DispatchDefault, DispatchNormal } DispatchTableMode;
<span class="line-modified"> 57   void dispatch_base(TosState state, DispatchTableMode table_mode, bool verifyoop = true);</span>
 58 
 59  public:
 60   InterpreterMacroAssembler(CodeBuffer* code);
 61 
 62   virtual void check_and_handle_popframe();
 63   virtual void check_and_handle_earlyret();
 64 
 65   // Interpreter-specific registers
 66 
 67   inline void check_stack_top() {}
 68   inline void check_stack_top_on_expansion() {}
 69   inline void check_extended_sp(Register tmp) {}
 70   inline void check_no_cached_stack_top(Register tmp) {}
 71 
 72 
 73   void save_bcp()                                          { str(Rbcp, Address(FP, frame::interpreter_frame_bcp_offset * wordSize)); }
 74   void restore_bcp()                                       { ldr(Rbcp, Address(FP, frame::interpreter_frame_bcp_offset * wordSize)); }
 75   void restore_locals()                                    { ldr(Rlocals, Address(FP, frame::interpreter_frame_locals_offset * wordSize)); }
 76   void restore_method()                                    { ldr(Rmethod, Address(FP, frame::interpreter_frame_method_offset * wordSize)); }
 77   void restore_dispatch();
</pre>
<hr />
<pre>
143       check_stack_top();
144       // NULL last_sp until next java call
145       str(zero_register(Rtemp), Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
146   }
147 
148   // Helpers for swap and dup
149   void load_ptr(int n, Register val);
150   void store_ptr(int n, Register val);
151 
152   // Generate a subtype check: branch to not_subtype if sub_klass is
153   // not a subtype of super_klass.
154   // Profiling code for the subtype check failure (profile_typecheck_failed)
155   // should be explicitly generated by the caller in the not_subtype case.
156   // Blows Rtemp, tmp1, tmp2.
157   void gen_subtype_check(Register Rsub_klass, Register Rsuper_klass,
158                          Label &amp;not_subtype, Register tmp1, Register tmp2);
159 
160   // Dispatching
161   void dispatch_prolog(TosState state, int step = 0);
162   void dispatch_epilog(TosState state, int step = 0);
<span class="line-modified">163   void dispatch_only(TosState state);                      // dispatch by R3_bytecode</span>
<span class="line-modified">164   void dispatch_only_normal(TosState state);               // dispatch normal table by R3_bytecode</span>
165   void dispatch_only_noverify(TosState state);
<span class="line-modified">166   void dispatch_next(TosState state, int step = 0);        // load R3_bytecode from [Rbcp + step] and dispatch by R3_bytecode</span>
167 
168   // jump to an invoked target
169   void prepare_to_jump_from_interpreted();
170   void jump_from_interpreted(Register method);
171 
172   void narrow(Register result);
173 
174   // Returning from interpreted functions
175   //
176   // Removes the current activation (incl. unlocking of monitors)
177   // and sets up the return address.  This code is also used for
178   // exception unwindwing. In that case, we do not want to throw
179   // IllegalMonitorStateExceptions, since that might get us into an
180   // infinite rethrow exception loop.
181   // Additionally this code is used for popFrame and earlyReturn.
182   // In popFrame case we want to skip throwing an exception,
183   // installing an exception, and notifying jvmdi.
184   // In earlyReturn case we only want to skip throwing an exception
185   // and installing an exception.
186   void remove_activation(TosState state, Register ret_addr,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 37 
 38  public:
 39 
 40   // allow JvmtiExport checks to be extended
 41   bool can_force_early_return()       { return JvmtiExport::can_force_early_return(); }
 42   bool can_post_interpreter_events()  { return JvmtiExport::can_post_interpreter_events(); }
 43   bool can_pop_frame()                { return JvmtiExport::can_pop_frame(); }
 44   bool can_post_breakpoint()          { return JvmtiExport::can_post_breakpoint(); }
 45   bool can_post_field_access()        { return JvmtiExport::can_post_field_access(); }
 46   bool can_post_field_modification()  { return JvmtiExport::can_post_field_modification(); }
 47   // flags controlled by JVMTI settings
 48   bool rewrite_frequent_pairs()       { return RewriteFrequentPairs; }
 49 
 50  protected:
 51 
 52   // Template interpreter specific version of call_VM_helper
 53   virtual void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions);
 54 
 55   // base routine for all dispatches
 56   typedef enum { DispatchDefault, DispatchNormal } DispatchTableMode;
<span class="line-modified"> 57   void dispatch_base(TosState state, DispatchTableMode table_mode, bool verifyoop = true, bool generate_poll = false);</span>
 58 
 59  public:
 60   InterpreterMacroAssembler(CodeBuffer* code);
 61 
 62   virtual void check_and_handle_popframe();
 63   virtual void check_and_handle_earlyret();
 64 
 65   // Interpreter-specific registers
 66 
 67   inline void check_stack_top() {}
 68   inline void check_stack_top_on_expansion() {}
 69   inline void check_extended_sp(Register tmp) {}
 70   inline void check_no_cached_stack_top(Register tmp) {}
 71 
 72 
 73   void save_bcp()                                          { str(Rbcp, Address(FP, frame::interpreter_frame_bcp_offset * wordSize)); }
 74   void restore_bcp()                                       { ldr(Rbcp, Address(FP, frame::interpreter_frame_bcp_offset * wordSize)); }
 75   void restore_locals()                                    { ldr(Rlocals, Address(FP, frame::interpreter_frame_locals_offset * wordSize)); }
 76   void restore_method()                                    { ldr(Rmethod, Address(FP, frame::interpreter_frame_method_offset * wordSize)); }
 77   void restore_dispatch();
</pre>
<hr />
<pre>
143       check_stack_top();
144       // NULL last_sp until next java call
145       str(zero_register(Rtemp), Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
146   }
147 
148   // Helpers for swap and dup
149   void load_ptr(int n, Register val);
150   void store_ptr(int n, Register val);
151 
152   // Generate a subtype check: branch to not_subtype if sub_klass is
153   // not a subtype of super_klass.
154   // Profiling code for the subtype check failure (profile_typecheck_failed)
155   // should be explicitly generated by the caller in the not_subtype case.
156   // Blows Rtemp, tmp1, tmp2.
157   void gen_subtype_check(Register Rsub_klass, Register Rsuper_klass,
158                          Label &amp;not_subtype, Register tmp1, Register tmp2);
159 
160   // Dispatching
161   void dispatch_prolog(TosState state, int step = 0);
162   void dispatch_epilog(TosState state, int step = 0);
<span class="line-modified">163   void dispatch_only(TosState state, bool generate_poll = false);  // dispatch by R3_bytecode</span>
<span class="line-modified">164   void dispatch_only_normal(TosState state);                       // dispatch normal table by R3_bytecode</span>
165   void dispatch_only_noverify(TosState state);
<span class="line-modified">166   void dispatch_next(TosState state, int step = 0, bool generate_poll = false); // load R3_bytecode from [Rbcp + step] and dispatch by R3_bytecode</span>
167 
168   // jump to an invoked target
169   void prepare_to_jump_from_interpreted();
170   void jump_from_interpreted(Register method);
171 
172   void narrow(Register result);
173 
174   // Returning from interpreted functions
175   //
176   // Removes the current activation (incl. unlocking of monitors)
177   // and sets up the return address.  This code is also used for
178   // exception unwindwing. In that case, we do not want to throw
179   // IllegalMonitorStateExceptions, since that might get us into an
180   // infinite rethrow exception loop.
181   // Additionally this code is used for popFrame and earlyReturn.
182   // In popFrame case we want to skip throwing an exception,
183   // installing an exception, and notifying jvmdi.
184   // In earlyReturn case we only want to skip throwing an exception
185   // and installing an exception.
186   void remove_activation(TosState state, Register ret_addr,
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>