<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/nativeInst.hpp&quot;
  31 #include &quot;code/vtableStubs.hpp&quot;
  32 #include &quot;gc/shared/gcLocker.hpp&quot;
  33 #include &quot;gc/shared/barrierSet.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;interpreter/interpreter.hpp&quot;
  36 #include &quot;logging/log.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/compiledICHolder.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;runtime/vm_version.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 #include &quot;vmreg_x86.inline.hpp&quot;
  46 #ifdef COMPILER1
  47 #include &quot;c1/c1_Runtime1.hpp&quot;
  48 #endif
  49 #ifdef COMPILER2
  50 #include &quot;opto/runtime.hpp&quot;
  51 #endif
  52 
  53 #define __ masm-&gt;
  54 
  55 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  56 
  57 class RegisterSaver {
  58   // Capture info about frame layout
  59 #define DEF_XMM_OFFS(regnum) xmm ## regnum ## _off = xmm_off + (regnum)*16/BytesPerInt, xmm ## regnum ## H_off
  60   enum layout {
  61                 fpu_state_off = 0,
  62                 fpu_state_end = fpu_state_off+FPUStateSizeInWords,
  63                 st0_off, st0H_off,
  64                 st1_off, st1H_off,
  65                 st2_off, st2H_off,
  66                 st3_off, st3H_off,
  67                 st4_off, st4H_off,
  68                 st5_off, st5H_off,
  69                 st6_off, st6H_off,
  70                 st7_off, st7H_off,
  71                 xmm_off,
  72                 DEF_XMM_OFFS(0),
  73                 DEF_XMM_OFFS(1),
  74                 DEF_XMM_OFFS(2),
  75                 DEF_XMM_OFFS(3),
  76                 DEF_XMM_OFFS(4),
  77                 DEF_XMM_OFFS(5),
  78                 DEF_XMM_OFFS(6),
  79                 DEF_XMM_OFFS(7),
  80                 flags_off = xmm7_off + 16/BytesPerInt + 1, // 16-byte stack alignment fill word
  81                 rdi_off,
  82                 rsi_off,
  83                 ignore_off,  // extra copy of rbp,
  84                 rsp_off,
  85                 rbx_off,
  86                 rdx_off,
  87                 rcx_off,
  88                 rax_off,
  89                 // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  90                 // will override any oopMap setting for it. We must therefore force the layout
  91                 // so that it agrees with the frame sender code.
  92                 rbp_off,
  93                 return_off,      // slot for return address
  94                 reg_save_size };
  95   enum { FPU_regs_live = flags_off - fpu_state_end };
  96 
  97   public:
  98 
  99   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words,
 100                                      int* total_frame_words, bool verify_fpu = true, bool save_vectors = false);
 101   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
 102 
 103   static int rax_offset() { return rax_off; }
 104   static int rbx_offset() { return rbx_off; }
 105 
 106   // Offsets into the register save area
 107   // Used by deoptimization when it is managing result register
 108   // values on its own
 109 
 110   static int raxOffset(void) { return rax_off; }
 111   static int rdxOffset(void) { return rdx_off; }
 112   static int rbxOffset(void) { return rbx_off; }
 113   static int xmm0Offset(void) { return xmm0_off; }
 114   // This really returns a slot in the fp save area, which one is not important
 115   static int fpResultOffset(void) { return st0_off; }
 116 
 117   // During deoptimization only the result register need to be restored
 118   // all the other values have already been extracted.
 119 
 120   static void restore_result_registers(MacroAssembler* masm);
 121 
 122 };
 123 
 124 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words,
 125                                            int* total_frame_words, bool verify_fpu, bool save_vectors) {
 126   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 127   int ymm_bytes = num_xmm_regs * 16;
 128   int zmm_bytes = num_xmm_regs * 32;
 129 #ifdef COMPILER2
 130   if (save_vectors) {
 131     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 132     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 133     // Save upper half of YMM registers
 134     int vect_bytes = ymm_bytes;
 135     if (UseAVX &gt; 2) {
 136       // Save upper half of ZMM registers as well
 137       vect_bytes += zmm_bytes;
 138     }
 139     additional_frame_words += vect_bytes / wordSize;
 140   }
 141 #else
 142   assert(!save_vectors, &quot;vectors are generated only by C2&quot;);
 143 #endif
 144   int frame_size_in_bytes = (reg_save_size + additional_frame_words) * wordSize;
 145   int frame_words = frame_size_in_bytes / wordSize;
 146   *total_frame_words = frame_words;
 147 
 148   assert(FPUStateSizeInWords == 27, &quot;update stack layout&quot;);
 149 
 150   // save registers, fpu state, and flags
 151   // We assume caller has already has return address slot on the stack
 152   // We push epb twice in this sequence because we want the real rbp,
 153   // to be under the return like a normal enter and we want to use pusha
 154   // We push by hand instead of using push.
 155   __ enter();
 156   __ pusha();
 157   __ pushf();
 158   __ subptr(rsp,FPU_regs_live*wordSize); // Push FPU registers space
 159   __ push_FPU_state();          // Save FPU state &amp; init
 160 
 161   if (verify_fpu) {
 162     // Some stubs may have non standard FPU control word settings so
 163     // only check and reset the value when it required to be the
 164     // standard value.  The safepoint blob in particular can be used
 165     // in methods which are using the 24 bit control word for
 166     // optimized float math.
 167 
 168 #ifdef ASSERT
 169     // Make sure the control word has the expected value
 170     Label ok;
 171     __ cmpw(Address(rsp, 0), StubRoutines::fpu_cntrl_wrd_std());
 172     __ jccb(Assembler::equal, ok);
 173     __ stop(&quot;corrupted control word detected&quot;);
 174     __ bind(ok);
 175 #endif
 176 
 177     // Reset the control word to guard against exceptions being unmasked
 178     // since fstp_d can cause FPU stack underflow exceptions.  Write it
 179     // into the on stack copy and then reload that to make sure that the
 180     // current and future values are correct.
 181     __ movw(Address(rsp, 0), StubRoutines::fpu_cntrl_wrd_std());
 182   }
 183 
 184   __ frstor(Address(rsp, 0));
 185   if (!verify_fpu) {
 186     // Set the control word so that exceptions are masked for the
 187     // following code.
 188     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 189   }
 190 
 191   int off = st0_off;
 192   int delta = st1_off - off;
 193 
 194   // Save the FPU registers in de-opt-able form
 195   for (int n = 0; n &lt; FloatRegisterImpl::number_of_registers; n++) {
 196     __ fstp_d(Address(rsp, off*wordSize));
 197     off += delta;
 198   }
 199 
 200   off = xmm0_off;
 201   delta = xmm1_off - off;
 202   if(UseSSE == 1) {
 203     // Save the XMM state
 204     for (int n = 0; n &lt; num_xmm_regs; n++) {
 205       __ movflt(Address(rsp, off*wordSize), as_XMMRegister(n));
 206       off += delta;
 207     }
 208   } else if(UseSSE &gt;= 2) {
 209     // Save whole 128bit (16 bytes) XMM registers
 210     for (int n = 0; n &lt; num_xmm_regs; n++) {
 211       __ movdqu(Address(rsp, off*wordSize), as_XMMRegister(n));
 212       off += delta;
 213     }
 214   }
 215 
 216   if (save_vectors) {
 217     __ subptr(rsp, ymm_bytes);
 218     // Save upper half of YMM registers
 219     for (int n = 0; n &lt; num_xmm_regs; n++) {
 220       __ vextractf128_high(Address(rsp, n*16), as_XMMRegister(n));
 221     }
 222     if (UseAVX &gt; 2) {
 223       __ subptr(rsp, zmm_bytes);
 224       // Save upper half of ZMM registers
 225       for (int n = 0; n &lt; num_xmm_regs; n++) {
 226         __ vextractf64x4_high(Address(rsp, n*32), as_XMMRegister(n));
 227       }
 228     }
 229   }
 230   __ vzeroupper();
 231 
 232   // Set an oopmap for the call site.  This oopmap will map all
 233   // oop-registers and debug-info registers as callee-saved.  This
 234   // will allow deoptimization at this safepoint to find all possible
 235   // debug-info recordings, as well as let GC find all oops.
 236 
 237   OopMapSet *oop_maps = new OopMapSet();
 238   OopMap* map =  new OopMap( frame_words, 0 );
 239 
 240 #define STACK_OFFSET(x) VMRegImpl::stack2reg((x) + additional_frame_words)
 241 #define NEXTREG(x) (x)-&gt;as_VMReg()-&gt;next()
 242 
 243   map-&gt;set_callee_saved(STACK_OFFSET(rax_off), rax-&gt;as_VMReg());
 244   map-&gt;set_callee_saved(STACK_OFFSET(rcx_off), rcx-&gt;as_VMReg());
 245   map-&gt;set_callee_saved(STACK_OFFSET(rdx_off), rdx-&gt;as_VMReg());
 246   map-&gt;set_callee_saved(STACK_OFFSET(rbx_off), rbx-&gt;as_VMReg());
 247   // rbp, location is known implicitly, no oopMap
 248   map-&gt;set_callee_saved(STACK_OFFSET(rsi_off), rsi-&gt;as_VMReg());
 249   map-&gt;set_callee_saved(STACK_OFFSET(rdi_off), rdi-&gt;as_VMReg());
 250   // %%% This is really a waste but we&#39;ll keep things as they were for now for the upper component
 251   off = st0_off;
 252   delta = st1_off - off;
 253   for (int n = 0; n &lt; FloatRegisterImpl::number_of_registers; n++) {
 254     FloatRegister freg_name = as_FloatRegister(n);
 255     map-&gt;set_callee_saved(STACK_OFFSET(off), freg_name-&gt;as_VMReg());
 256     map-&gt;set_callee_saved(STACK_OFFSET(off+1), NEXTREG(freg_name));
 257     off += delta;
 258   }
 259   off = xmm0_off;
 260   delta = xmm1_off - off;
 261   for (int n = 0; n &lt; num_xmm_regs; n++) {
 262     XMMRegister xmm_name = as_XMMRegister(n);
 263     map-&gt;set_callee_saved(STACK_OFFSET(off), xmm_name-&gt;as_VMReg());
 264     map-&gt;set_callee_saved(STACK_OFFSET(off+1), NEXTREG(xmm_name));
 265     off += delta;
 266   }
 267 #undef NEXTREG
 268 #undef STACK_OFFSET
 269 
 270   return map;
 271 }
 272 
 273 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 274   int num_xmm_regs = XMMRegisterImpl::number_of_registers;
 275   int ymm_bytes = num_xmm_regs * 16;
 276   int zmm_bytes = num_xmm_regs * 32;
 277   // Recover XMM &amp; FPU state
 278   int additional_frame_bytes = 0;
 279 #ifdef COMPILER2
 280   if (restore_vectors) {
 281     assert(UseAVX &gt; 0, &quot;Vectors larger than 16 byte long are supported only with AVX&quot;);
 282     assert(MaxVectorSize &lt;= 64, &quot;Only up to 64 byte long vectors are supported&quot;);
 283     // Save upper half of YMM registers
 284     additional_frame_bytes = ymm_bytes;
 285     if (UseAVX &gt; 2) {
 286       // Save upper half of ZMM registers as well
 287       additional_frame_bytes += zmm_bytes;
 288     }
 289   }
 290 #else
 291   assert(!restore_vectors, &quot;vectors are generated only by C2&quot;);
 292 #endif
 293 
 294   int off = xmm0_off;
 295   int delta = xmm1_off - off;
 296 
 297   __ vzeroupper();
 298 
 299   if (UseSSE == 1) {
 300     // Restore XMM registers
 301     assert(additional_frame_bytes == 0, &quot;&quot;);
 302     for (int n = 0; n &lt; num_xmm_regs; n++) {
 303       __ movflt(as_XMMRegister(n), Address(rsp, off*wordSize));
 304       off += delta;
 305     }
 306   } else if (UseSSE &gt;= 2) {
 307     // Restore whole 128bit (16 bytes) XMM registers. Do this before restoring YMM and
 308     // ZMM because the movdqu instruction zeros the upper part of the XMM register.
 309     for (int n = 0; n &lt; num_xmm_regs; n++) {
 310       __ movdqu(as_XMMRegister(n), Address(rsp, off*wordSize+additional_frame_bytes));
 311       off += delta;
 312     }
 313   }
 314 
 315   if (restore_vectors) {
 316     if (UseAVX &gt; 2) {
 317       // Restore upper half of ZMM registers.
 318       for (int n = 0; n &lt; num_xmm_regs; n++) {
 319         __ vinsertf64x4_high(as_XMMRegister(n), Address(rsp, n*32));
 320       }
 321       __ addptr(rsp, zmm_bytes);
 322     }
 323     // Restore upper half of YMM registers.
 324     for (int n = 0; n &lt; num_xmm_regs; n++) {
 325       __ vinsertf128_high(as_XMMRegister(n), Address(rsp, n*16));
 326     }
 327     __ addptr(rsp, ymm_bytes);
 328   }
 329 
 330   __ pop_FPU_state();
 331   __ addptr(rsp, FPU_regs_live*wordSize); // Pop FPU registers
 332 
 333   __ popf();
 334   __ popa();
 335   // Get the rbp, described implicitly by the frame sender code (no oopMap)
 336   __ pop(rbp);
 337 }
 338 
 339 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 340 
 341   // Just restore result register. Only used by deoptimization. By
 342   // now any callee save register that needs to be restore to a c2
 343   // caller of the deoptee has been extracted into the vframeArray
 344   // and will be stuffed into the c2i adapter we create for later
 345   // restoration so only result registers need to be restored here.
 346   //
 347 
 348   __ frstor(Address(rsp, 0));      // Restore fpu state
 349 
 350   // Recover XMM &amp; FPU state
 351   if( UseSSE == 1 ) {
 352     __ movflt(xmm0, Address(rsp, xmm0_off*wordSize));
 353   } else if( UseSSE &gt;= 2 ) {
 354     __ movdbl(xmm0, Address(rsp, xmm0_off*wordSize));
 355   }
 356   __ movptr(rax, Address(rsp, rax_off*wordSize));
 357   __ movptr(rdx, Address(rsp, rdx_off*wordSize));
 358   // Pop all of the register save are off the stack except the return address
 359   __ addptr(rsp, return_off * wordSize);
 360 }
 361 
 362 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 363 // 16 bytes XMM registers are saved by default using SSE2 movdqu instructions.
 364 // Note, MaxVectorSize == 0 with UseSSE &lt; 2 and vectors are not generated.
 365 bool SharedRuntime::is_wide_vector(int size) {
 366   return size &gt; 16;
 367 }
 368 
 369 size_t SharedRuntime::trampoline_size() {
 370   return 16;
 371 }
 372 
 373 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 374   __ jump(RuntimeAddress(destination));
 375 }
 376 
 377 // The java_calling_convention describes stack locations as ideal slots on
 378 // a frame with no abi restrictions. Since we must observe abi restrictions
 379 // (like the placement of the register window) the slots must be biased by
 380 // the following value.
 381 static int reg2offset_in(VMReg r) {
 382   // Account for saved rbp, and return address
 383   // This should really be in_preserve_stack_slots
 384   return (r-&gt;reg2stack() + 2) * VMRegImpl::stack_slot_size;
 385 }
 386 
 387 static int reg2offset_out(VMReg r) {
 388   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 389 }
 390 
 391 // ---------------------------------------------------------------------------
 392 // Read the array of BasicTypes from a signature, and compute where the
 393 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 394 // quantities.  Values less than SharedInfo::stack0 are registers, those above
 395 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 396 // as framesizes are fixed.
 397 // VMRegImpl::stack0 refers to the first slot 0(sp).
 398 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 399 // up to RegisterImpl::number_of_registers) are the 32-bit
 400 // integer registers.
 401 
 402 // Pass first two oop/int args in registers ECX and EDX.
 403 // Pass first two float/double args in registers XMM0 and XMM1.
 404 // Doubles have precedence, so if you pass a mix of floats and doubles
 405 // the doubles will grab the registers before the floats will.
 406 
 407 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 408 // either 32-bit or 64-bit depending on the build.  The OUTPUTS are in 32-bit
 409 // units regardless of build. Of course for i486 there is no 64 bit build
 410 
 411 
 412 // ---------------------------------------------------------------------------
 413 // The compiled Java calling convention.
 414 // Pass first two oop/int args in registers ECX and EDX.
 415 // Pass first two float/double args in registers XMM0 and XMM1.
 416 // Doubles have precedence, so if you pass a mix of floats and doubles
 417 // the doubles will grab the registers before the floats will.
 418 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 419                                            VMRegPair *regs,
 420                                            int total_args_passed,
 421                                            int is_outgoing) {
 422   uint    stack = 0;          // Starting stack position for args on stack
 423 
 424 
 425   // Pass first two oop/int args in registers ECX and EDX.
 426   uint reg_arg0 = 9999;
 427   uint reg_arg1 = 9999;
 428 
 429   // Pass first two float/double args in registers XMM0 and XMM1.
 430   // Doubles have precedence, so if you pass a mix of floats and doubles
 431   // the doubles will grab the registers before the floats will.
 432   // CNC - TURNED OFF FOR non-SSE.
 433   //       On Intel we have to round all doubles (and most floats) at
 434   //       call sites by storing to the stack in any case.
 435   // UseSSE=0 ==&gt; Don&#39;t Use ==&gt; 9999+0
 436   // UseSSE=1 ==&gt; Floats only ==&gt; 9999+1
 437   // UseSSE&gt;=2 ==&gt; Floats or doubles ==&gt; 9999+2
 438   enum { fltarg_dontuse = 9999+0, fltarg_float_only = 9999+1, fltarg_flt_dbl = 9999+2 };
 439   uint fargs = (UseSSE&gt;=2) ? 2 : UseSSE;
 440   uint freg_arg0 = 9999+fargs;
 441   uint freg_arg1 = 9999+fargs;
 442 
 443   // Pass doubles &amp; longs aligned on the stack.  First count stack slots for doubles
 444   int i;
 445   for( i = 0; i &lt; total_args_passed; i++) {
 446     if( sig_bt[i] == T_DOUBLE ) {
 447       // first 2 doubles go in registers
 448       if( freg_arg0 == fltarg_flt_dbl ) freg_arg0 = i;
 449       else if( freg_arg1 == fltarg_flt_dbl ) freg_arg1 = i;
 450       else // Else double is passed low on the stack to be aligned.
 451         stack += 2;
 452     } else if( sig_bt[i] == T_LONG ) {
 453       stack += 2;
 454     }
 455   }
 456   int dstack = 0;             // Separate counter for placing doubles
 457 
 458   // Now pick where all else goes.
 459   for( i = 0; i &lt; total_args_passed; i++) {
 460     // From the type and the argument number (count) compute the location
 461     switch( sig_bt[i] ) {
 462     case T_SHORT:
 463     case T_CHAR:
 464     case T_BYTE:
 465     case T_BOOLEAN:
 466     case T_INT:
 467     case T_ARRAY:
 468     case T_OBJECT:
 469     case T_ADDRESS:
 470       if( reg_arg0 == 9999 )  {
 471         reg_arg0 = i;
 472         regs[i].set1(rcx-&gt;as_VMReg());
 473       } else if( reg_arg1 == 9999 )  {
 474         reg_arg1 = i;
 475         regs[i].set1(rdx-&gt;as_VMReg());
 476       } else {
 477         regs[i].set1(VMRegImpl::stack2reg(stack++));
 478       }
 479       break;
 480     case T_FLOAT:
 481       if( freg_arg0 == fltarg_flt_dbl || freg_arg0 == fltarg_float_only ) {
 482         freg_arg0 = i;
 483         regs[i].set1(xmm0-&gt;as_VMReg());
 484       } else if( freg_arg1 == fltarg_flt_dbl || freg_arg1 == fltarg_float_only ) {
 485         freg_arg1 = i;
 486         regs[i].set1(xmm1-&gt;as_VMReg());
 487       } else {
 488         regs[i].set1(VMRegImpl::stack2reg(stack++));
 489       }
 490       break;
 491     case T_LONG:
 492       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
 493       regs[i].set2(VMRegImpl::stack2reg(dstack));
 494       dstack += 2;
 495       break;
 496     case T_DOUBLE:
 497       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
 498       if( freg_arg0 == (uint)i ) {
 499         regs[i].set2(xmm0-&gt;as_VMReg());
 500       } else if( freg_arg1 == (uint)i ) {
 501         regs[i].set2(xmm1-&gt;as_VMReg());
 502       } else {
 503         regs[i].set2(VMRegImpl::stack2reg(dstack));
 504         dstack += 2;
 505       }
 506       break;
 507     case T_VOID: regs[i].set_bad(); break;
 508       break;
 509     default:
 510       ShouldNotReachHere();
 511       break;
 512     }
 513   }
 514 
 515   // return value can be odd number of VMRegImpl stack slots make multiple of 2
 516   return align_up(stack, 2);
 517 }
 518 
 519 // Patch the callers callsite with entry to compiled code if it exists.
 520 static void patch_callers_callsite(MacroAssembler *masm) {
 521   Label L;
 522   __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 523   __ jcc(Assembler::equal, L);
 524   // Schedule the branch target address early.
 525   // Call into the VM to patch the caller, then jump to compiled callee
 526   // rax, isn&#39;t live so capture return address while we easily can
 527   __ movptr(rax, Address(rsp, 0));
 528   __ pusha();
 529   __ pushf();
 530 
 531   if (UseSSE == 1) {
 532     __ subptr(rsp, 2*wordSize);
 533     __ movflt(Address(rsp, 0), xmm0);
 534     __ movflt(Address(rsp, wordSize), xmm1);
 535   }
 536   if (UseSSE &gt;= 2) {
 537     __ subptr(rsp, 4*wordSize);
 538     __ movdbl(Address(rsp, 0), xmm0);
 539     __ movdbl(Address(rsp, 2*wordSize), xmm1);
 540   }
 541 #ifdef COMPILER2
 542   // C2 may leave the stack dirty if not in SSE2+ mode
 543   if (UseSSE &gt;= 2) {
 544     __ verify_FPU(0, &quot;c2i transition should have clean FPU stack&quot;);
 545   } else {
 546     __ empty_FPU_stack();
 547   }
 548 #endif /* COMPILER2 */
 549 
 550   // VM needs caller&#39;s callsite
 551   __ push(rax);
 552   // VM needs target method
 553   __ push(rbx);
 554   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 555   __ addptr(rsp, 2*wordSize);
 556 
 557   if (UseSSE == 1) {
 558     __ movflt(xmm0, Address(rsp, 0));
 559     __ movflt(xmm1, Address(rsp, wordSize));
 560     __ addptr(rsp, 2*wordSize);
 561   }
 562   if (UseSSE &gt;= 2) {
 563     __ movdbl(xmm0, Address(rsp, 0));
 564     __ movdbl(xmm1, Address(rsp, 2*wordSize));
 565     __ addptr(rsp, 4*wordSize);
 566   }
 567 
 568   __ popf();
 569   __ popa();
 570   __ bind(L);
 571 }
 572 
 573 
 574 static void move_c2i_double(MacroAssembler *masm, XMMRegister r, int st_off) {
 575   int next_off = st_off - Interpreter::stackElementSize;
 576   __ movdbl(Address(rsp, next_off), r);
 577 }
 578 
 579 static void gen_c2i_adapter(MacroAssembler *masm,
 580                             int total_args_passed,
 581                             int comp_args_on_stack,
 582                             const BasicType *sig_bt,
 583                             const VMRegPair *regs,
 584                             Label&amp; skip_fixup) {
 585   // Before we get into the guts of the C2I adapter, see if we should be here
 586   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 587   // interpreter, which means the caller made a static call to get here
 588   // (vcalls always get a compiled target if there is one).  Check for a
 589   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 590   patch_callers_callsite(masm);
 591 
 592   __ bind(skip_fixup);
 593 
 594 #ifdef COMPILER2
 595   // C2 may leave the stack dirty if not in SSE2+ mode
 596   if (UseSSE &gt;= 2) {
 597     __ verify_FPU(0, &quot;c2i transition should have clean FPU stack&quot;);
 598   } else {
 599     __ empty_FPU_stack();
 600   }
 601 #endif /* COMPILER2 */
 602 
 603   // Since all args are passed on the stack, total_args_passed * interpreter_
 604   // stack_element_size  is the
 605   // space we need.
 606   int extraspace = total_args_passed * Interpreter::stackElementSize;
 607 
 608   // Get return address
 609   __ pop(rax);
 610 
 611   // set senderSP value
 612   __ movptr(rsi, rsp);
 613 
 614   __ subptr(rsp, extraspace);
 615 
 616   // Now write the args into the outgoing interpreter space
 617   for (int i = 0; i &lt; total_args_passed; i++) {
 618     if (sig_bt[i] == T_VOID) {
 619       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 620       continue;
 621     }
 622 
 623     // st_off points to lowest address on stack.
 624     int st_off = ((total_args_passed - 1) - i) * Interpreter::stackElementSize;
 625     int next_off = st_off - Interpreter::stackElementSize;
 626 
 627     // Say 4 args:
 628     // i   st_off
 629     // 0   12 T_LONG
 630     // 1    8 T_VOID
 631     // 2    4 T_OBJECT
 632     // 3    0 T_BOOL
 633     VMReg r_1 = regs[i].first();
 634     VMReg r_2 = regs[i].second();
 635     if (!r_1-&gt;is_valid()) {
 636       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 637       continue;
 638     }
 639 
 640     if (r_1-&gt;is_stack()) {
 641       // memory to memory use fpu stack top
 642       int ld_off = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace;
 643 
 644       if (!r_2-&gt;is_valid()) {
 645         __ movl(rdi, Address(rsp, ld_off));
 646         __ movptr(Address(rsp, st_off), rdi);
 647       } else {
 648 
 649         // ld_off == LSW, ld_off+VMRegImpl::stack_slot_size == MSW
 650         // st_off == MSW, st_off-wordSize == LSW
 651 
 652         __ movptr(rdi, Address(rsp, ld_off));
 653         __ movptr(Address(rsp, next_off), rdi);
 654 #ifndef _LP64
 655         __ movptr(rdi, Address(rsp, ld_off + wordSize));
 656         __ movptr(Address(rsp, st_off), rdi);
 657 #else
 658 #ifdef ASSERT
 659         // Overwrite the unused slot with known junk
 660         __ mov64(rax, CONST64(0xdeadffffdeadaaaa));
 661         __ movptr(Address(rsp, st_off), rax);
 662 #endif /* ASSERT */
 663 #endif // _LP64
 664       }
 665     } else if (r_1-&gt;is_Register()) {
 666       Register r = r_1-&gt;as_Register();
 667       if (!r_2-&gt;is_valid()) {
 668         __ movl(Address(rsp, st_off), r);
 669       } else {
 670         // long/double in gpr
 671         NOT_LP64(ShouldNotReachHere());
 672         // Two VMRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
 673         // T_DOUBLE and T_LONG use two slots in the interpreter
 674         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
 675           // long/double in gpr
 676 #ifdef ASSERT
 677           // Overwrite the unused slot with known junk
 678           LP64_ONLY(__ mov64(rax, CONST64(0xdeadffffdeadaaab)));
 679           __ movptr(Address(rsp, st_off), rax);
 680 #endif /* ASSERT */
 681           __ movptr(Address(rsp, next_off), r);
 682         } else {
 683           __ movptr(Address(rsp, st_off), r);
 684         }
 685       }
 686     } else {
 687       assert(r_1-&gt;is_XMMRegister(), &quot;&quot;);
 688       if (!r_2-&gt;is_valid()) {
 689         __ movflt(Address(rsp, st_off), r_1-&gt;as_XMMRegister());
 690       } else {
 691         assert(sig_bt[i] == T_DOUBLE || sig_bt[i] == T_LONG, &quot;wrong type&quot;);
 692         move_c2i_double(masm, r_1-&gt;as_XMMRegister(), st_off);
 693       }
 694     }
 695   }
 696 
 697   // Schedule the branch target address early.
 698   __ movptr(rcx, Address(rbx, in_bytes(Method::interpreter_entry_offset())));
 699   // And repush original return address
 700   __ push(rax);
 701   __ jmp(rcx);
 702 }
 703 
 704 
 705 static void move_i2c_double(MacroAssembler *masm, XMMRegister r, Register saved_sp, int ld_off) {
 706   int next_val_off = ld_off - Interpreter::stackElementSize;
 707   __ movdbl(r, Address(saved_sp, next_val_off));
 708 }
 709 
 710 static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,
 711                         address code_start, address code_end,
 712                         Label&amp; L_ok) {
 713   Label L_fail;
 714   __ lea(temp_reg, ExternalAddress(code_start));
 715   __ cmpptr(pc_reg, temp_reg);
 716   __ jcc(Assembler::belowEqual, L_fail);
 717   __ lea(temp_reg, ExternalAddress(code_end));
 718   __ cmpptr(pc_reg, temp_reg);
 719   __ jcc(Assembler::below, L_ok);
 720   __ bind(L_fail);
 721 }
 722 
 723 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 724                                     int total_args_passed,
 725                                     int comp_args_on_stack,
 726                                     const BasicType *sig_bt,
 727                                     const VMRegPair *regs) {
 728   // Note: rsi contains the senderSP on entry. We must preserve it since
 729   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 730   // code goes non-entrant while we get args ready.
 731 
 732   // Adapters can be frameless because they do not require the caller
 733   // to perform additional cleanup work, such as correcting the stack pointer.
 734   // An i2c adapter is frameless because the *caller* frame, which is interpreted,
 735   // routinely repairs its own stack pointer (from interpreter_frame_last_sp),
 736   // even if a callee has modified the stack pointer.
 737   // A c2i adapter is frameless because the *callee* frame, which is interpreted,
 738   // routinely repairs its caller&#39;s stack pointer (from sender_sp, which is set
 739   // up via the senderSP register).
 740   // In other words, if *either* the caller or callee is interpreted, we can
 741   // get the stack pointer repaired after a call.
 742   // This is why c2i and i2c adapters cannot be indefinitely composed.
 743   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 744   // both caller and callee would be compiled methods, and neither would
 745   // clean up the stack pointer changes performed by the two adapters.
 746   // If this happens, control eventually transfers back to the compiled
 747   // caller, but with an uncorrected stack, causing delayed havoc.
 748 
 749   // Pick up the return address
 750   __ movptr(rax, Address(rsp, 0));
 751 
 752   if (VerifyAdapterCalls &amp;&amp;
 753       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 754     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 755     //  assert(Interpreter::contains($return_addr) ||
 756     //         StubRoutines::contains($return_addr),
 757     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 758     __ block_comment(&quot;verify_i2c { &quot;);
 759     Label L_ok;
 760     if (Interpreter::code() != NULL)
 761       range_check(masm, rax, rdi,
 762                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 763                   L_ok);
 764     if (StubRoutines::code1() != NULL)
 765       range_check(masm, rax, rdi,
 766                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 767                   L_ok);
 768     if (StubRoutines::code2() != NULL)
 769       range_check(masm, rax, rdi,
 770                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 771                   L_ok);
 772     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 773     __ block_comment(msg);
 774     __ stop(msg);
 775     __ bind(L_ok);
 776     __ block_comment(&quot;} verify_i2ce &quot;);
 777   }
 778 
 779   // Must preserve original SP for loading incoming arguments because
 780   // we need to align the outgoing SP for compiled code.
 781   __ movptr(rdi, rsp);
 782 
 783   // Cut-out for having no stack args.  Since up to 2 int/oop args are passed
 784   // in registers, we will occasionally have no stack args.
 785   int comp_words_on_stack = 0;
 786   if (comp_args_on_stack) {
 787     // Sig words on the stack are greater-than VMRegImpl::stack0.  Those in
 788     // registers are below.  By subtracting stack0, we either get a negative
 789     // number (all values in registers) or the maximum stack slot accessed.
 790     // int comp_args_on_stack = VMRegImpl::reg2stack(max_arg);
 791     // Convert 4-byte stack slots to words.
 792     comp_words_on_stack = align_up(comp_args_on_stack*4, wordSize)&gt;&gt;LogBytesPerWord;
 793     // Round up to miminum stack alignment, in wordSize
 794     comp_words_on_stack = align_up(comp_words_on_stack, 2);
 795     __ subptr(rsp, comp_words_on_stack * wordSize);
 796   }
 797 
 798   // Align the outgoing SP
 799   __ andptr(rsp, -(StackAlignmentInBytes));
 800 
 801   // push the return address on the stack (note that pushing, rather
 802   // than storing it, yields the correct frame alignment for the callee)
 803   __ push(rax);
 804 
 805   // Put saved SP in another register
 806   const Register saved_sp = rax;
 807   __ movptr(saved_sp, rdi);
 808 
 809 
 810   // Will jump to the compiled code just as if compiled code was doing it.
 811   // Pre-load the register-jump target early, to schedule it better.
 812   __ movptr(rdi, Address(rbx, in_bytes(Method::from_compiled_offset())));
 813 
 814   // Now generate the shuffle code.  Pick up all register args and move the
 815   // rest through the floating point stack top.
 816   for (int i = 0; i &lt; total_args_passed; i++) {
 817     if (sig_bt[i] == T_VOID) {
 818       // Longs and doubles are passed in native word order, but misaligned
 819       // in the 32-bit build.
 820       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 821       continue;
 822     }
 823 
 824     // Pick up 0, 1 or 2 words from SP+offset.
 825 
 826     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
 827             &quot;scrambled load targets?&quot;);
 828     // Load in argument order going down.
 829     int ld_off = (total_args_passed - i) * Interpreter::stackElementSize;
 830     // Point to interpreter value (vs. tag)
 831     int next_off = ld_off - Interpreter::stackElementSize;
 832     //
 833     //
 834     //
 835     VMReg r_1 = regs[i].first();
 836     VMReg r_2 = regs[i].second();
 837     if (!r_1-&gt;is_valid()) {
 838       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 839       continue;
 840     }
 841     if (r_1-&gt;is_stack()) {
 842       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 843       int st_off = regs[i].first()-&gt;reg2stack()*VMRegImpl::stack_slot_size + wordSize;
 844 
 845       // We can use rsi as a temp here because compiled code doesn&#39;t need rsi as an input
 846       // and if we end up going thru a c2i because of a miss a reasonable value of rsi
 847       // we be generated.
 848       if (!r_2-&gt;is_valid()) {
 849         // __ fld_s(Address(saved_sp, ld_off));
 850         // __ fstp_s(Address(rsp, st_off));
 851         __ movl(rsi, Address(saved_sp, ld_off));
 852         __ movptr(Address(rsp, st_off), rsi);
 853       } else {
 854         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 855         // are accessed as negative so LSW is at LOW address
 856 
 857         // ld_off is MSW so get LSW
 858         // st_off is LSW (i.e. reg.first())
 859         // __ fld_d(Address(saved_sp, next_off));
 860         // __ fstp_d(Address(rsp, st_off));
 861         //
 862         // We are using two VMRegs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 863         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 864         // So we must adjust where to pick up the data to match the interpreter.
 865         //
 866         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 867         // are accessed as negative so LSW is at LOW address
 868 
 869         // ld_off is MSW so get LSW
 870         const int offset = (NOT_LP64(true ||) sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 871                            next_off : ld_off;
 872         __ movptr(rsi, Address(saved_sp, offset));
 873         __ movptr(Address(rsp, st_off), rsi);
 874 #ifndef _LP64
 875         __ movptr(rsi, Address(saved_sp, ld_off));
 876         __ movptr(Address(rsp, st_off + wordSize), rsi);
 877 #endif // _LP64
 878       }
 879     } else if (r_1-&gt;is_Register()) {  // Register argument
 880       Register r = r_1-&gt;as_Register();
 881       assert(r != rax, &quot;must be different&quot;);
 882       if (r_2-&gt;is_valid()) {
 883         //
 884         // We are using two VMRegs. This can be either T_OBJECT, T_ADDRESS, T_LONG, or T_DOUBLE
 885         // the interpreter allocates two slots but only uses one for thr T_LONG or T_DOUBLE case
 886         // So we must adjust where to pick up the data to match the interpreter.
 887 
 888         const int offset = (NOT_LP64(true ||) sig_bt[i]==T_LONG||sig_bt[i]==T_DOUBLE)?
 889                            next_off : ld_off;
 890 
 891         // this can be a misaligned move
 892         __ movptr(r, Address(saved_sp, offset));
 893 #ifndef _LP64
 894         assert(r_2-&gt;as_Register() != rax, &quot;need another temporary register&quot;);
 895         // Remember r_1 is low address (and LSB on x86)
 896         // So r_2 gets loaded from high address regardless of the platform
 897         __ movptr(r_2-&gt;as_Register(), Address(saved_sp, ld_off));
 898 #endif // _LP64
 899       } else {
 900         __ movl(r, Address(saved_sp, ld_off));
 901       }
 902     } else {
 903       assert(r_1-&gt;is_XMMRegister(), &quot;&quot;);
 904       if (!r_2-&gt;is_valid()) {
 905         __ movflt(r_1-&gt;as_XMMRegister(), Address(saved_sp, ld_off));
 906       } else {
 907         move_i2c_double(masm, r_1-&gt;as_XMMRegister(), saved_sp, ld_off);
 908       }
 909     }
 910   }
 911 
 912   // 6243940 We might end up in handle_wrong_method if
 913   // the callee is deoptimized as we race thru here. If that
 914   // happens we don&#39;t want to take a safepoint because the
 915   // caller frame will look interpreted and arguments are now
 916   // &quot;compiled&quot; so it is much better to make this transition
 917   // invisible to the stack walking code. Unfortunately if
 918   // we try and find the callee by normal means a safepoint
 919   // is possible. So we stash the desired callee in the thread
 920   // and the vm will find there should this case occur.
 921 
 922   __ get_thread(rax);
 923   __ movptr(Address(rax, JavaThread::callee_target_offset()), rbx);
 924 
 925   // move Method* to rax, in case we end up in an c2i adapter.
 926   // the c2i adapters expect Method* in rax, (c2) because c2&#39;s
 927   // resolve stubs return the result (the method) in rax,.
 928   // I&#39;d love to fix this.
 929   __ mov(rax, rbx);
 930 
 931   __ jmp(rdi);
 932 }
 933 
 934 // ---------------------------------------------------------------
 935 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 936                                                             int total_args_passed,
 937                                                             int comp_args_on_stack,
 938                                                             const BasicType *sig_bt,
 939                                                             const VMRegPair *regs,
 940                                                             AdapterFingerPrint* fingerprint) {
 941   address i2c_entry = __ pc();
 942 
 943   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 944 
 945   // -------------------------------------------------------------------------
 946   // Generate a C2I adapter.  On entry we know rbx, holds the Method* during calls
 947   // to the interpreter.  The args start out packed in the compiled layout.  They
 948   // need to be unpacked into the interpreter layout.  This will almost always
 949   // require some stack space.  We grow the current (compiled) stack, then repack
 950   // the args.  We  finally end in a jump to the generic interpreter entry point.
 951   // On exit from the interpreter, the interpreter will restore our SP (lest the
 952   // compiled code, which relys solely on SP and not EBP, get sick).
 953 
 954   address c2i_unverified_entry = __ pc();
 955   Label skip_fixup;
 956 
 957   Register holder = rax;
 958   Register receiver = rcx;
 959   Register temp = rbx;
 960 
 961   {
 962 
 963     Label missed;
 964     __ movptr(temp, Address(receiver, oopDesc::klass_offset_in_bytes()));
 965     __ cmpptr(temp, Address(holder, CompiledICHolder::holder_klass_offset()));
 966     __ movptr(rbx, Address(holder, CompiledICHolder::holder_metadata_offset()));
 967     __ jcc(Assembler::notEqual, missed);
 968     // Method might have been compiled since the call site was patched to
 969     // interpreted if that is the case treat it as a miss so we can get
 970     // the call site corrected.
 971     __ cmpptr(Address(rbx, in_bytes(Method::code_offset())), (int32_t)NULL_WORD);
 972     __ jcc(Assembler::equal, skip_fixup);
 973 
 974     __ bind(missed);
 975     __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 976   }
 977 
 978   address c2i_entry = __ pc();
 979 
 980   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 981   bs-&gt;c2i_entry_barrier(masm);
 982 
 983   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 984 
 985   __ flush();
 986   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
 987 }
 988 
 989 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 990                                          VMRegPair *regs,
 991                                          VMRegPair *regs2,
 992                                          int total_args_passed) {
 993   assert(regs2 == NULL, &quot;not needed on x86&quot;);
 994 // We return the amount of VMRegImpl stack slots we need to reserve for all
 995 // the arguments NOT counting out_preserve_stack_slots.
 996 
 997   uint    stack = 0;        // All arguments on stack
 998 
 999   for( int i = 0; i &lt; total_args_passed; i++) {
1000     // From the type and the argument number (count) compute the location
1001     switch( sig_bt[i] ) {
1002     case T_BOOLEAN:
1003     case T_CHAR:
1004     case T_FLOAT:
1005     case T_BYTE:
1006     case T_SHORT:
1007     case T_INT:
1008     case T_OBJECT:
1009     case T_ARRAY:
1010     case T_ADDRESS:
1011     case T_METADATA:
1012       regs[i].set1(VMRegImpl::stack2reg(stack++));
1013       break;
1014     case T_LONG:
1015     case T_DOUBLE: // The stack numbering is reversed from Java
1016       // Since C arguments do not get reversed, the ordering for
1017       // doubles on the stack must be opposite the Java convention
1018       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
1019       regs[i].set2(VMRegImpl::stack2reg(stack));
1020       stack += 2;
1021       break;
1022     case T_VOID: regs[i].set_bad(); break;
1023     default:
1024       ShouldNotReachHere();
1025       break;
1026     }
1027   }
1028   return stack;
1029 }
1030 
1031 // A simple move of integer like type
1032 static void simple_move32(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1033   if (src.first()-&gt;is_stack()) {
1034     if (dst.first()-&gt;is_stack()) {
1035       // stack to stack
1036       // __ ld(FP, reg2offset(src.first()) + STACK_BIAS, L5);
1037       // __ st(L5, SP, reg2offset(dst.first()) + STACK_BIAS);
1038       __ movl2ptr(rax, Address(rbp, reg2offset_in(src.first())));
1039       __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1040     } else {
1041       // stack to reg
1042       __ movl2ptr(dst.first()-&gt;as_Register(),  Address(rbp, reg2offset_in(src.first())));
1043     }
1044   } else if (dst.first()-&gt;is_stack()) {
1045     // reg to stack
1046     // no need to sign extend on 64bit
1047     __ movptr(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_Register());
1048   } else {
1049     if (dst.first() != src.first()) {
1050       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1051     }
1052   }
1053 }
1054 
1055 // An oop arg. Must pass a handle not the oop itself
1056 static void object_move(MacroAssembler* masm,
1057                         OopMap* map,
1058                         int oop_handle_offset,
1059                         int framesize_in_slots,
1060                         VMRegPair src,
1061                         VMRegPair dst,
1062                         bool is_receiver,
1063                         int* receiver_offset) {
1064 
1065   // Because of the calling conventions we know that src can be a
1066   // register or a stack location. dst can only be a stack location.
1067 
1068   assert(dst.first()-&gt;is_stack(), &quot;must be stack&quot;);
1069   // must pass a handle. First figure out the location we use as a handle
1070 
1071   if (src.first()-&gt;is_stack()) {
1072     // Oop is already on the stack as an argument
1073     Register rHandle = rax;
1074     Label nil;
1075     __ xorptr(rHandle, rHandle);
1076     __ cmpptr(Address(rbp, reg2offset_in(src.first())), (int32_t)NULL_WORD);
1077     __ jcc(Assembler::equal, nil);
1078     __ lea(rHandle, Address(rbp, reg2offset_in(src.first())));
1079     __ bind(nil);
1080     __ movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);
1081 
1082     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1083     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
1084     if (is_receiver) {
1085       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
1086     }
1087   } else {
1088     // Oop is in an a register we must store it to the space we reserve
1089     // on the stack for oop_handles
1090     const Register rOop = src.first()-&gt;as_Register();
1091     const Register rHandle = rax;
1092     int oop_slot = (rOop == rcx ? 0 : 1) * VMRegImpl::slots_per_word + oop_handle_offset;
1093     int offset = oop_slot*VMRegImpl::stack_slot_size;
1094     Label skip;
1095     __ movptr(Address(rsp, offset), rOop);
1096     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1097     __ xorptr(rHandle, rHandle);
1098     __ cmpptr(rOop, (int32_t)NULL_WORD);
1099     __ jcc(Assembler::equal, skip);
1100     __ lea(rHandle, Address(rsp, offset));
1101     __ bind(skip);
1102     // Store the handle parameter
1103     __ movptr(Address(rsp, reg2offset_out(dst.first())), rHandle);
1104     if (is_receiver) {
1105       *receiver_offset = offset;
1106     }
1107   }
1108 }
1109 
1110 // A float arg may have to do float reg int reg conversion
1111 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1112   assert(!src.second()-&gt;is_valid() &amp;&amp; !dst.second()-&gt;is_valid(), &quot;bad float_move&quot;);
1113 
1114   // Because of the calling convention we know that src is either a stack location
1115   // or an xmm register. dst can only be a stack location.
1116 
1117   assert(dst.first()-&gt;is_stack() &amp;&amp; ( src.first()-&gt;is_stack() || src.first()-&gt;is_XMMRegister()), &quot;bad parameters&quot;);
1118 
1119   if (src.first()-&gt;is_stack()) {
1120     __ movl(rax, Address(rbp, reg2offset_in(src.first())));
1121     __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1122   } else {
1123     // reg to stack
1124     __ movflt(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1125   }
1126 }
1127 
1128 // A long move
1129 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1130 
1131   // The only legal possibility for a long_move VMRegPair is:
1132   // 1: two stack slots (possibly unaligned)
1133   // as neither the java  or C calling convention will use registers
1134   // for longs.
1135 
1136   if (src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack()) {
1137     assert(src.second()-&gt;is_stack() &amp;&amp; dst.second()-&gt;is_stack(), &quot;must be all stack&quot;);
1138     __ movptr(rax, Address(rbp, reg2offset_in(src.first())));
1139     NOT_LP64(__ movptr(rbx, Address(rbp, reg2offset_in(src.second()))));
1140     __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1141     NOT_LP64(__ movptr(Address(rsp, reg2offset_out(dst.second())), rbx));
1142   } else {
1143     ShouldNotReachHere();
1144   }
1145 }
1146 
1147 // A double move
1148 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1149 
1150   // The only legal possibilities for a double_move VMRegPair are:
1151   // The painful thing here is that like long_move a VMRegPair might be
1152 
1153   // Because of the calling convention we know that src is either
1154   //   1: a single physical register (xmm registers only)
1155   //   2: two stack slots (possibly unaligned)
1156   // dst can only be a pair of stack slots.
1157 
1158   assert(dst.first()-&gt;is_stack() &amp;&amp; (src.first()-&gt;is_XMMRegister() || src.first()-&gt;is_stack()), &quot;bad args&quot;);
1159 
1160   if (src.first()-&gt;is_stack()) {
1161     // source is all stack
1162     __ movptr(rax, Address(rbp, reg2offset_in(src.first())));
1163     NOT_LP64(__ movptr(rbx, Address(rbp, reg2offset_in(src.second()))));
1164     __ movptr(Address(rsp, reg2offset_out(dst.first())), rax);
1165     NOT_LP64(__ movptr(Address(rsp, reg2offset_out(dst.second())), rbx));
1166   } else {
1167     // reg to stack
1168     // No worries about stack alignment
1169     __ movdbl(Address(rsp, reg2offset_out(dst.first())), src.first()-&gt;as_XMMRegister());
1170   }
1171 }
1172 
1173 
1174 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1175   // We always ignore the frame_slots arg and just use the space just below frame pointer
1176   // which by this time is free to use
1177   switch (ret_type) {
1178   case T_FLOAT:
1179     __ fstp_s(Address(rbp, -wordSize));
1180     break;
1181   case T_DOUBLE:
1182     __ fstp_d(Address(rbp, -2*wordSize));
1183     break;
1184   case T_VOID:  break;
1185   case T_LONG:
1186     __ movptr(Address(rbp, -wordSize), rax);
1187     NOT_LP64(__ movptr(Address(rbp, -2*wordSize), rdx));
1188     break;
1189   default: {
1190     __ movptr(Address(rbp, -wordSize), rax);
1191     }
1192   }
1193 }
1194 
1195 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1196   // We always ignore the frame_slots arg and just use the space just below frame pointer
1197   // which by this time is free to use
1198   switch (ret_type) {
1199   case T_FLOAT:
1200     __ fld_s(Address(rbp, -wordSize));
1201     break;
1202   case T_DOUBLE:
1203     __ fld_d(Address(rbp, -2*wordSize));
1204     break;
1205   case T_LONG:
1206     __ movptr(rax, Address(rbp, -wordSize));
1207     NOT_LP64(__ movptr(rdx, Address(rbp, -2*wordSize)));
1208     break;
1209   case T_VOID:  break;
1210   default: {
1211     __ movptr(rax, Address(rbp, -wordSize));
1212     }
1213   }
1214 }
1215 
1216 
1217 static void save_or_restore_arguments(MacroAssembler* masm,
1218                                       const int stack_slots,
1219                                       const int total_in_args,
1220                                       const int arg_save_area,
1221                                       OopMap* map,
1222                                       VMRegPair* in_regs,
1223                                       BasicType* in_sig_bt) {
1224   // if map is non-NULL then the code should store the values,
1225   // otherwise it should load them.
1226   int handle_index = 0;
1227   // Save down double word first
1228   for ( int i = 0; i &lt; total_in_args; i++) {
1229     if (in_regs[i].first()-&gt;is_XMMRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1230       int slot = handle_index * VMRegImpl::slots_per_word + arg_save_area;
1231       int offset = slot * VMRegImpl::stack_slot_size;
1232       handle_index += 2;
1233       assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1234       if (map != NULL) {
1235         __ movdbl(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1236       } else {
1237         __ movdbl(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1238       }
1239     }
1240     if (in_regs[i].first()-&gt;is_Register() &amp;&amp; in_sig_bt[i] == T_LONG) {
1241       int slot = handle_index * VMRegImpl::slots_per_word + arg_save_area;
1242       int offset = slot * VMRegImpl::stack_slot_size;
1243       handle_index += 2;
1244       assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1245       if (map != NULL) {
1246         __ movl(Address(rsp, offset), in_regs[i].first()-&gt;as_Register());
1247         if (in_regs[i].second()-&gt;is_Register()) {
1248           __ movl(Address(rsp, offset + 4), in_regs[i].second()-&gt;as_Register());
1249         }
1250       } else {
1251         __ movl(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
1252         if (in_regs[i].second()-&gt;is_Register()) {
1253           __ movl(in_regs[i].second()-&gt;as_Register(), Address(rsp, offset + 4));
1254         }
1255       }
1256     }
1257   }
1258   // Save or restore single word registers
1259   for ( int i = 0; i &lt; total_in_args; i++) {
1260     if (in_regs[i].first()-&gt;is_Register()) {
1261       int slot = handle_index++ * VMRegImpl::slots_per_word + arg_save_area;
1262       int offset = slot * VMRegImpl::stack_slot_size;
1263       assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1264       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1265         map-&gt;set_oop(VMRegImpl::stack2reg(slot));;
1266       }
1267 
1268       // Value is in an input register pass we must flush it to the stack
1269       const Register reg = in_regs[i].first()-&gt;as_Register();
1270       switch (in_sig_bt[i]) {
1271         case T_ARRAY:
1272           if (map != NULL) {
1273             __ movptr(Address(rsp, offset), reg);
1274           } else {
1275             __ movptr(reg, Address(rsp, offset));
1276           }
1277           break;
1278         case T_BOOLEAN:
1279         case T_CHAR:
1280         case T_BYTE:
1281         case T_SHORT:
1282         case T_INT:
1283           if (map != NULL) {
1284             __ movl(Address(rsp, offset), reg);
1285           } else {
1286             __ movl(reg, Address(rsp, offset));
1287           }
1288           break;
1289         case T_OBJECT:
1290         default: ShouldNotReachHere();
1291       }
1292     } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1293       if (in_sig_bt[i] == T_FLOAT) {
1294         int slot = handle_index++ * VMRegImpl::slots_per_word + arg_save_area;
1295         int offset = slot * VMRegImpl::stack_slot_size;
1296         assert(handle_index &lt;= stack_slots, &quot;overflow&quot;);
1297         if (map != NULL) {
1298           __ movflt(Address(rsp, offset), in_regs[i].first()-&gt;as_XMMRegister());
1299         } else {
1300           __ movflt(in_regs[i].first()-&gt;as_XMMRegister(), Address(rsp, offset));
1301         }
1302       }
1303     } else if (in_regs[i].first()-&gt;is_stack()) {
1304       if (in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1305         int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1306         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1307       }
1308     }
1309   }
1310 }
1311 
1312 // Registers need to be saved for runtime call
1313 static Register caller_saved_registers[] = {
1314   rcx, rdx, rsi, rdi
1315 };
1316 
1317 // Save caller saved registers except r1 and r2
1318 static void save_registers_except(MacroAssembler* masm, Register r1, Register r2) {
1319   int reg_len = (int)(sizeof(caller_saved_registers) / sizeof(Register));
1320   for (int index = 0; index &lt; reg_len; index ++) {
1321     Register this_reg = caller_saved_registers[index];
1322     if (this_reg != r1 &amp;&amp; this_reg != r2) {
1323       __ push(this_reg);
1324     }
1325   }
1326 }
1327 
1328 // Restore caller saved registers except r1 and r2
1329 static void restore_registers_except(MacroAssembler* masm, Register r1, Register r2) {
1330   int reg_len = (int)(sizeof(caller_saved_registers) / sizeof(Register));
1331   for (int index = reg_len - 1; index &gt;= 0; index --) {
1332     Register this_reg = caller_saved_registers[index];
1333     if (this_reg != r1 &amp;&amp; this_reg != r2) {
1334       __ pop(this_reg);
1335     }
1336   }
1337 }
1338 
1339 // Pin object, return pinned object or null in rax
1340 static void gen_pin_object(MacroAssembler* masm,
1341                            Register thread, VMRegPair reg) {
1342   __ block_comment(&quot;gen_pin_object {&quot;);
1343 
1344   Label is_null;
1345   Register tmp_reg = rax;
1346   VMRegPair tmp(tmp_reg-&gt;as_VMReg());
1347   if (reg.first()-&gt;is_stack()) {
1348     // Load the arg up from the stack
1349     simple_move32(masm, reg, tmp);
1350     reg = tmp;
1351   } else {
1352     __ movl(tmp_reg, reg.first()-&gt;as_Register());
1353   }
1354   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1355   __ jccb(Assembler::equal, is_null);
1356 
1357   // Save registers that may be used by runtime call
1358   Register arg = reg.first()-&gt;is_Register() ? reg.first()-&gt;as_Register() : noreg;
1359   save_registers_except(masm, arg, thread);
1360 
1361   __ call_VM_leaf(
1362     CAST_FROM_FN_PTR(address, SharedRuntime::pin_object),
1363     thread, reg.first()-&gt;as_Register());
1364 
1365   // Restore saved registers
1366   restore_registers_except(masm, arg, thread);
1367 
1368   __ bind(is_null);
1369   __ block_comment(&quot;} gen_pin_object&quot;);
1370 }
1371 
1372 // Unpin object
1373 static void gen_unpin_object(MacroAssembler* masm,
1374                              Register thread, VMRegPair reg) {
1375   __ block_comment(&quot;gen_unpin_object {&quot;);
1376   Label is_null;
1377 
1378   // temp register
1379   __ push(rax);
1380   Register tmp_reg = rax;
1381   VMRegPair tmp(tmp_reg-&gt;as_VMReg());
1382 
1383   simple_move32(masm, reg, tmp);
1384 
1385   __ testptr(rax, rax);
1386   __ jccb(Assembler::equal, is_null);
1387 
1388   // Save registers that may be used by runtime call
1389   Register arg = reg.first()-&gt;is_Register() ? reg.first()-&gt;as_Register() : noreg;
1390   save_registers_except(masm, arg, thread);
1391 
1392   __ call_VM_leaf(
1393     CAST_FROM_FN_PTR(address, SharedRuntime::unpin_object),
1394     thread, rax);
1395 
1396   // Restore saved registers
1397   restore_registers_except(masm, arg, thread);
1398   __ bind(is_null);
1399   __ pop(rax);
1400   __ block_comment(&quot;} gen_unpin_object&quot;);
1401 }
1402 
1403 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1404 // keeps a new JNI critical region from starting until a GC has been
1405 // forced.  Save down any oops in registers and describe them in an
1406 // OopMap.
1407 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1408                                                Register thread,
1409                                                int stack_slots,
1410                                                int total_c_args,
1411                                                int total_in_args,
1412                                                int arg_save_area,
1413                                                OopMapSet* oop_maps,
1414                                                VMRegPair* in_regs,
1415                                                BasicType* in_sig_bt) {
1416   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1417   Label cont;
1418   __ cmp8(ExternalAddress((address)GCLocker::needs_gc_address()), false);
1419   __ jcc(Assembler::equal, cont);
1420 
1421   // Save down any incoming oops and call into the runtime to halt for a GC
1422 
1423   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1424 
1425   save_or_restore_arguments(masm, stack_slots, total_in_args,
1426                             arg_save_area, map, in_regs, in_sig_bt);
1427 
1428   address the_pc = __ pc();
1429   oop_maps-&gt;add_gc_map( __ offset(), map);
1430   __ set_last_Java_frame(thread, rsp, noreg, the_pc);
1431 
1432   __ block_comment(&quot;block_for_jni_critical&quot;);
1433   __ push(thread);
1434   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical)));
1435   __ increment(rsp, wordSize);
1436 
1437   __ get_thread(thread);
1438   __ reset_last_Java_frame(thread, false);
1439 
1440   save_or_restore_arguments(masm, stack_slots, total_in_args,
1441                             arg_save_area, NULL, in_regs, in_sig_bt);
1442 
1443   __ bind(cont);
1444 #ifdef ASSERT
1445   if (StressCriticalJNINatives) {
1446     // Stress register saving
1447     OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1448     save_or_restore_arguments(masm, stack_slots, total_in_args,
1449                               arg_save_area, map, in_regs, in_sig_bt);
1450     // Destroy argument registers
1451     for (int i = 0; i &lt; total_in_args - 1; i++) {
1452       if (in_regs[i].first()-&gt;is_Register()) {
1453         const Register reg = in_regs[i].first()-&gt;as_Register();
1454         __ xorptr(reg, reg);
1455       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1456         __ xorpd(in_regs[i].first()-&gt;as_XMMRegister(), in_regs[i].first()-&gt;as_XMMRegister());
1457       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1458         ShouldNotReachHere();
1459       } else if (in_regs[i].first()-&gt;is_stack()) {
1460         // Nothing to do
1461       } else {
1462         ShouldNotReachHere();
1463       }
1464       if (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_DOUBLE) {
1465         i++;
1466       }
1467     }
1468 
1469     save_or_restore_arguments(masm, stack_slots, total_in_args,
1470                               arg_save_area, NULL, in_regs, in_sig_bt);
1471   }
1472 #endif
1473 }
1474 
1475 // Unpack an array argument into a pointer to the body and the length
1476 // if the array is non-null, otherwise pass 0 for both.
1477 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) {
1478   Register tmp_reg = rax;
1479   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1480          &quot;possible collision&quot;);
1481   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1482          &quot;possible collision&quot;);
1483 
1484   // Pass the length, ptr pair
1485   Label is_null, done;
1486   VMRegPair tmp(tmp_reg-&gt;as_VMReg());
1487   if (reg.first()-&gt;is_stack()) {
1488     // Load the arg up from the stack
1489     simple_move32(masm, reg, tmp);
1490     reg = tmp;
1491   }
1492   __ testptr(reg.first()-&gt;as_Register(), reg.first()-&gt;as_Register());
1493   __ jccb(Assembler::equal, is_null);
1494   __ lea(tmp_reg, Address(reg.first()-&gt;as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1495   simple_move32(masm, tmp, body_arg);
1496   // load the length relative to the body.
1497   __ movl(tmp_reg, Address(tmp_reg, arrayOopDesc::length_offset_in_bytes() -
1498                            arrayOopDesc::base_offset_in_bytes(in_elem_type)));
1499   simple_move32(masm, tmp, length_arg);
1500   __ jmpb(done);
1501   __ bind(is_null);
1502   // Pass zeros
1503   __ xorptr(tmp_reg, tmp_reg);
1504   simple_move32(masm, tmp, body_arg);
1505   simple_move32(masm, tmp, length_arg);
1506   __ bind(done);
1507 }
1508 
1509 static void verify_oop_args(MacroAssembler* masm,
1510                             const methodHandle&amp; method,
1511                             const BasicType* sig_bt,
1512                             const VMRegPair* regs) {
1513   Register temp_reg = rbx;  // not part of any compiled calling seq
1514   if (VerifyOops) {
1515     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1516       if (is_reference_type(sig_bt[i])) {
1517         VMReg r = regs[i].first();
1518         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1519         if (r-&gt;is_stack()) {
1520           __ movptr(temp_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1521           __ verify_oop(temp_reg);
1522         } else {
1523           __ verify_oop(r-&gt;as_Register());
1524         }
1525       }
1526     }
1527   }
1528 }
1529 
1530 static void gen_special_dispatch(MacroAssembler* masm,
1531                                  const methodHandle&amp; method,
1532                                  const BasicType* sig_bt,
1533                                  const VMRegPair* regs) {
1534   verify_oop_args(masm, method, sig_bt, regs);
1535   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1536 
1537   // Now write the args into the outgoing interpreter space
1538   bool     has_receiver   = false;
1539   Register receiver_reg   = noreg;
1540   int      member_arg_pos = -1;
1541   Register member_reg     = noreg;
1542   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1543   if (ref_kind != 0) {
1544     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1545     member_reg = rbx;  // known to be free at this point
1546     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1547   } else if (iid == vmIntrinsics::_invokeBasic) {
1548     has_receiver = true;
1549   } else {
1550     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1551   }
1552 
1553   if (member_reg != noreg) {
1554     // Load the member_arg into register, if necessary.
1555     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1556     VMReg r = regs[member_arg_pos].first();
1557     if (r-&gt;is_stack()) {
1558       __ movptr(member_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1559     } else {
1560       // no data motion is needed
1561       member_reg = r-&gt;as_Register();
1562     }
1563   }
1564 
1565   if (has_receiver) {
1566     // Make sure the receiver is loaded into a register.
1567     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1568     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1569     VMReg r = regs[0].first();
1570     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1571     if (r-&gt;is_stack()) {
1572       // Porting note:  This assumes that compiled calling conventions always
1573       // pass the receiver oop in a register.  If this is not true on some
1574       // platform, pick a temp and load the receiver from stack.
1575       fatal(&quot;receiver always in a register&quot;);
1576       receiver_reg = rcx;  // known to be free at this point
1577       __ movptr(receiver_reg, Address(rsp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
1578     } else {
1579       // no data motion is needed
1580       receiver_reg = r-&gt;as_Register();
1581     }
1582   }
1583 
1584   // Figure out which address we are really jumping to:
1585   MethodHandles::generate_method_handle_dispatch(masm, iid,
1586                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1587 }
1588 
1589 // ---------------------------------------------------------------------------
1590 // Generate a native wrapper for a given method.  The method takes arguments
1591 // in the Java compiled code convention, marshals them to the native
1592 // convention (handlizes oops, etc), transitions to native, makes the call,
1593 // returns to java state (possibly blocking), unhandlizes any result and
1594 // returns.
1595 //
1596 // Critical native functions are a shorthand for the use of
1597 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1598 // functions.  The wrapper is expected to unpack the arguments before
1599 // passing them to the callee and perform checks before and after the
1600 // native call to ensure that they GCLocker
1601 // lock_critical/unlock_critical semantics are followed.  Some other
1602 // parts of JNI setup are skipped like the tear down of the JNI handle
1603 // block and the check for pending exceptions it&#39;s impossible for them
1604 // to be thrown.
1605 //
1606 // They are roughly structured like this:
1607 //    if (GCLocker::needs_gc())
1608 //      SharedRuntime::block_for_jni_critical();
1609 //    tranistion to thread_in_native
1610 //    unpack arrray arguments and call native entry point
1611 //    check for safepoint in progress
1612 //    check if any thread suspend flags are set
1613 //      call into JVM and possible unlock the JNI critical
1614 //      if a GC was suppressed while in the critical native.
1615 //    transition back to thread_in_Java
1616 //    return to caller
1617 //
1618 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1619                                                 const methodHandle&amp; method,
1620                                                 int compile_id,
1621                                                 BasicType* in_sig_bt,
1622                                                 VMRegPair* in_regs,
1623                                                 BasicType ret_type,
1624                                                 address critical_entry) {
1625   if (method-&gt;is_method_handle_intrinsic()) {
1626     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1627     intptr_t start = (intptr_t)__ pc();
1628     int vep_offset = ((intptr_t)__ pc()) - start;
1629     gen_special_dispatch(masm,
1630                          method,
1631                          in_sig_bt,
1632                          in_regs);
1633     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1634     __ flush();
1635     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1636     return nmethod::new_native_nmethod(method,
1637                                        compile_id,
1638                                        masm-&gt;code(),
1639                                        vep_offset,
1640                                        frame_complete,
1641                                        stack_slots / VMRegImpl::slots_per_word,
1642                                        in_ByteSize(-1),
1643                                        in_ByteSize(-1),
1644                                        (OopMapSet*)NULL);
1645   }
1646   bool is_critical_native = true;
1647   address native_func = critical_entry;
1648   if (native_func == NULL) {
1649     native_func = method-&gt;native_function();
1650     is_critical_native = false;
1651   }
1652   assert(native_func != NULL, &quot;must have function&quot;);
1653 
1654   // An OopMap for lock (and class if static)
1655   OopMapSet *oop_maps = new OopMapSet();
1656 
1657   // We have received a description of where all the java arg are located
1658   // on entry to the wrapper. We need to convert these args to where
1659   // the jni function will expect them. To figure out where they go
1660   // we convert the java signature to a C signature by inserting
1661   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1662 
1663   const int total_in_args = method-&gt;size_of_parameters();
1664   int total_c_args = total_in_args;
1665   if (!is_critical_native) {
1666     total_c_args += 1;
1667     if (method-&gt;is_static()) {
1668       total_c_args++;
1669     }
1670   } else {
1671     for (int i = 0; i &lt; total_in_args; i++) {
1672       if (in_sig_bt[i] == T_ARRAY) {
1673         total_c_args++;
1674       }
1675     }
1676   }
1677 
1678   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1679   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1680   BasicType* in_elem_bt = NULL;
1681 
1682   int argc = 0;
1683   if (!is_critical_native) {
1684     out_sig_bt[argc++] = T_ADDRESS;
1685     if (method-&gt;is_static()) {
1686       out_sig_bt[argc++] = T_OBJECT;
1687     }
1688 
1689     for (int i = 0; i &lt; total_in_args ; i++ ) {
1690       out_sig_bt[argc++] = in_sig_bt[i];
1691     }
1692   } else {
1693     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1694     SignatureStream ss(method-&gt;signature());
1695     for (int i = 0; i &lt; total_in_args ; i++ ) {
1696       if (in_sig_bt[i] == T_ARRAY) {
1697         // Arrays are passed as int, elem* pair
1698         out_sig_bt[argc++] = T_INT;
1699         out_sig_bt[argc++] = T_ADDRESS;
<a name="2" id="anc2"></a><span class="line-modified">1700         Symbol* atype = ss.as_symbol();</span>
<span class="line-modified">1701         const char* at = atype-&gt;as_C_string();</span>
<span class="line-modified">1702         if (strlen(at) == 2) {</span>
<span class="line-removed">1703           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="line-removed">1704           switch (at[1]) {</span>
<span class="line-removed">1705             case &#39;B&#39;: in_elem_bt[i]  = T_BYTE; break;</span>
<span class="line-removed">1706             case &#39;C&#39;: in_elem_bt[i]  = T_CHAR; break;</span>
<span class="line-removed">1707             case &#39;D&#39;: in_elem_bt[i]  = T_DOUBLE; break;</span>
<span class="line-removed">1708             case &#39;F&#39;: in_elem_bt[i]  = T_FLOAT; break;</span>
<span class="line-removed">1709             case &#39;I&#39;: in_elem_bt[i]  = T_INT; break;</span>
<span class="line-removed">1710             case &#39;J&#39;: in_elem_bt[i]  = T_LONG; break;</span>
<span class="line-removed">1711             case &#39;S&#39;: in_elem_bt[i]  = T_SHORT; break;</span>
<span class="line-removed">1712             case &#39;Z&#39;: in_elem_bt[i]  = T_BOOLEAN; break;</span>
<span class="line-removed">1713             default: ShouldNotReachHere();</span>
<span class="line-removed">1714           }</span>
<span class="line-removed">1715         }</span>
1716       } else {
1717         out_sig_bt[argc++] = in_sig_bt[i];
1718         in_elem_bt[i] = T_VOID;
1719       }
1720       if (in_sig_bt[i] != T_VOID) {
<a name="3" id="anc3"></a><span class="line-modified">1721         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>

1722         ss.next();
1723       }
1724     }
1725   }
1726 
1727   // Now figure out where the args must be stored and how much stack space
1728   // they require.
1729   int out_arg_slots;
1730   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1731 
1732   // Compute framesize for the wrapper.  We need to handlize all oops in
1733   // registers a max of 2 on x86.
1734 
1735   // Calculate the total number of stack slots we will need.
1736 
1737   // First count the abi requirement plus all of the outgoing args
1738   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1739 
1740   // Now the space for the inbound oop handle area
1741   int total_save_slots = 2 * VMRegImpl::slots_per_word; // 2 arguments passed in registers
1742   if (is_critical_native) {
1743     // Critical natives may have to call out so they need a save area
1744     // for register arguments.
1745     int double_slots = 0;
1746     int single_slots = 0;
1747     for ( int i = 0; i &lt; total_in_args; i++) {
1748       if (in_regs[i].first()-&gt;is_Register()) {
1749         const Register reg = in_regs[i].first()-&gt;as_Register();
1750         switch (in_sig_bt[i]) {
1751           case T_ARRAY:  // critical array (uses 2 slots on LP64)
1752           case T_BOOLEAN:
1753           case T_BYTE:
1754           case T_SHORT:
1755           case T_CHAR:
1756           case T_INT:  single_slots++; break;
1757           case T_LONG: double_slots++; break;
1758           default:  ShouldNotReachHere();
1759         }
1760       } else if (in_regs[i].first()-&gt;is_XMMRegister()) {
1761         switch (in_sig_bt[i]) {
1762           case T_FLOAT:  single_slots++; break;
1763           case T_DOUBLE: double_slots++; break;
1764           default:  ShouldNotReachHere();
1765         }
1766       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1767         ShouldNotReachHere();
1768       }
1769     }
1770     total_save_slots = double_slots * 2 + single_slots;
1771     // align the save area
1772     if (double_slots != 0) {
1773       stack_slots = align_up(stack_slots, 2);
1774     }
1775   }
1776 
1777   int oop_handle_offset = stack_slots;
1778   stack_slots += total_save_slots;
1779 
1780   // Now any space we need for handlizing a klass if static method
1781 
1782   int klass_slot_offset = 0;
1783   int klass_offset = -1;
1784   int lock_slot_offset = 0;
1785   bool is_static = false;
1786 
1787   if (method-&gt;is_static()) {
1788     klass_slot_offset = stack_slots;
1789     stack_slots += VMRegImpl::slots_per_word;
1790     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1791     is_static = true;
1792   }
1793 
1794   // Plus a lock if needed
1795 
1796   if (method-&gt;is_synchronized()) {
1797     lock_slot_offset = stack_slots;
1798     stack_slots += VMRegImpl::slots_per_word;
1799   }
1800 
1801   // Now a place (+2) to save return values or temp during shuffling
1802   // + 2 for return address (which we own) and saved rbp,
1803   stack_slots += 4;
1804 
1805   // Ok The space we have allocated will look like:
1806   //
1807   //
1808   // FP-&gt; |                     |
1809   //      |---------------------|
1810   //      | 2 slots for moves   |
1811   //      |---------------------|
1812   //      | lock box (if sync)  |
1813   //      |---------------------| &lt;- lock_slot_offset  (-lock_slot_rbp_offset)
1814   //      | klass (if static)   |
1815   //      |---------------------| &lt;- klass_slot_offset
1816   //      | oopHandle area      |
1817   //      |---------------------| &lt;- oop_handle_offset (a max of 2 registers)
1818   //      | outbound memory     |
1819   //      | based arguments     |
1820   //      |                     |
1821   //      |---------------------|
1822   //      |                     |
1823   // SP-&gt; | out_preserved_slots |
1824   //
1825   //
1826   // ****************************************************************************
1827   // WARNING - on Windows Java Natives use pascal calling convention and pop the
1828   // arguments off of the stack after the jni call. Before the call we can use
1829   // instructions that are SP relative. After the jni call we switch to FP
1830   // relative instructions instead of re-adjusting the stack on windows.
1831   // ****************************************************************************
1832 
1833 
1834   // Now compute actual number of stack words we need rounding to make
1835   // stack properly aligned.
1836   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1837 
1838   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1839 
1840   intptr_t start = (intptr_t)__ pc();
1841 
1842   // First thing make an ic check to see if we should even be here
1843 
1844   // We are free to use all registers as temps without saving them and
1845   // restoring them except rbp. rbp is the only callee save register
1846   // as far as the interpreter and the compiler(s) are concerned.
1847 
1848 
1849   const Register ic_reg = rax;
1850   const Register receiver = rcx;
1851   Label hit;
1852   Label exception_pending;
1853 
1854   __ verify_oop(receiver);
1855   __ cmpptr(ic_reg, Address(receiver, oopDesc::klass_offset_in_bytes()));
1856   __ jcc(Assembler::equal, hit);
1857 
1858   __ jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1859 
1860   // verified entry must be aligned for code patching.
1861   // and the first 5 bytes must be in the same cache line
1862   // if we align at 8 then we will be sure 5 bytes are in the same line
1863   __ align(8);
1864 
1865   __ bind(hit);
1866 
1867   int vep_offset = ((intptr_t)__ pc()) - start;
1868 
1869 #ifdef COMPILER1
1870   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
1871   if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
1872     inline_check_hashcode_from_object_header(masm, method, rcx /*obj_reg*/, rax /*result*/);
1873    }
1874 #endif // COMPILER1
1875 
1876   // The instruction at the verified entry point must be 5 bytes or longer
1877   // because it can be patched on the fly by make_non_entrant. The stack bang
1878   // instruction fits that requirement.
1879 
1880   // Generate stack overflow check
1881 
1882   if (UseStackBanging) {
1883     __ bang_stack_with_offset((int)JavaThread::stack_shadow_zone_size());
1884   } else {
1885     // need a 5 byte instruction to allow MT safe patching to non-entrant
1886     __ fat_nop();
1887   }
1888 
1889   // Generate a new frame for the wrapper.
1890   __ enter();
1891   // -2 because return address is already present and so is saved rbp
1892   __ subptr(rsp, stack_size - 2*wordSize);
1893 
1894 
1895   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1896   bs-&gt;nmethod_entry_barrier(masm);
1897 
1898   // Frame is now completed as far as size and linkage.
1899   int frame_complete = ((intptr_t)__ pc()) - start;
1900 
1901   if (UseRTMLocking) {
1902     // Abort RTM transaction before calling JNI
1903     // because critical section will be large and will be
1904     // aborted anyway. Also nmethod could be deoptimized.
1905     __ xabort(0);
1906   }
1907 
1908   // Calculate the difference between rsp and rbp,. We need to know it
1909   // after the native call because on windows Java Natives will pop
1910   // the arguments and it is painful to do rsp relative addressing
1911   // in a platform independent way. So after the call we switch to
1912   // rbp, relative addressing.
1913 
1914   int fp_adjustment = stack_size - 2*wordSize;
1915 
1916 #ifdef COMPILER2
1917   // C2 may leave the stack dirty if not in SSE2+ mode
1918   if (UseSSE &gt;= 2) {
1919     __ verify_FPU(0, &quot;c2i transition should have clean FPU stack&quot;);
1920   } else {
1921     __ empty_FPU_stack();
1922   }
1923 #endif /* COMPILER2 */
1924 
1925   // Compute the rbp, offset for any slots used after the jni call
1926 
1927   int lock_slot_rbp_offset = (lock_slot_offset*VMRegImpl::stack_slot_size) - fp_adjustment;
1928 
1929   // We use rdi as a thread pointer because it is callee save and
1930   // if we load it once it is usable thru the entire wrapper
1931   const Register thread = rdi;
1932 
1933    // We use rsi as the oop handle for the receiver/klass
1934    // It is callee save so it survives the call to native
1935 
1936    const Register oop_handle_reg = rsi;
1937 
1938    __ get_thread(thread);
1939 
1940   if (is_critical_native &amp;&amp; !Universe::heap()-&gt;supports_object_pinning()) {
1941     check_needs_gc_for_critical_native(masm, thread, stack_slots, total_c_args, total_in_args,
1942                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1943   }
1944 
1945   //
1946   // We immediately shuffle the arguments so that any vm call we have to
1947   // make from here on out (sync slow path, jvmti, etc.) we will have
1948   // captured the oops from our caller and have a valid oopMap for
1949   // them.
1950 
1951   // -----------------
1952   // The Grand Shuffle
1953   //
1954   // Natives require 1 or 2 extra arguments over the normal ones: the JNIEnv*
1955   // and, if static, the class mirror instead of a receiver.  This pretty much
1956   // guarantees that register layout will not match (and x86 doesn&#39;t use reg
1957   // parms though amd does).  Since the native abi doesn&#39;t use register args
1958   // and the java conventions does we don&#39;t have to worry about collisions.
1959   // All of our moved are reg-&gt;stack or stack-&gt;stack.
1960   // We ignore the extra arguments during the shuffle and handle them at the
1961   // last moment. The shuffle is described by the two calling convention
1962   // vectors we have in our possession. We simply walk the java vector to
1963   // get the source locations and the c vector to get the destinations.
1964 
1965   int c_arg = is_critical_native ? 0 : (method-&gt;is_static() ? 2 : 1 );
1966 
1967   // Record rsp-based slot for receiver on stack for non-static methods
1968   int receiver_offset = -1;
1969 
1970   // This is a trick. We double the stack slots so we can claim
1971   // the oops in the caller&#39;s frame. Since we are sure to have
1972   // more args than the caller doubling is enough to make
1973   // sure we can capture all the incoming oop args from the
1974   // caller.
1975   //
1976   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1977 
1978   // Inbound arguments that need to be pinned for critical natives
1979   GrowableArray&lt;int&gt; pinned_args(total_in_args);
1980   // Current stack slot for storing register based array argument
1981   int pinned_slot = oop_handle_offset;
1982 
1983   // Mark location of rbp,
1984   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, rbp-&gt;as_VMReg());
1985 
1986   // We know that we only have args in at most two integer registers (rcx, rdx). So rax, rbx
1987   // Are free to temporaries if we have to do  stack to steck moves.
1988   // All inbound args are referenced based on rbp, and all outbound args via rsp.
1989 
1990   for (int i = 0; i &lt; total_in_args ; i++, c_arg++ ) {
1991     switch (in_sig_bt[i]) {
1992       case T_ARRAY:
1993         if (is_critical_native) {
1994           VMRegPair in_arg = in_regs[i];
1995           if (Universe::heap()-&gt;supports_object_pinning()) {
1996             // gen_pin_object handles save and restore
1997             // of any clobbered registers
1998             gen_pin_object(masm, thread, in_arg);
1999             pinned_args.append(i);
2000 
2001             // rax has pinned array
2002             VMRegPair result_reg(rax-&gt;as_VMReg());
2003             if (!in_arg.first()-&gt;is_stack()) {
2004               assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2005               simple_move32(masm, result_reg, VMRegImpl::stack2reg(pinned_slot));
2006               pinned_slot += VMRegImpl::slots_per_word;
2007             } else {
2008               // Write back pinned value, it will be used to unpin this argument
2009               __ movptr(Address(rbp, reg2offset_in(in_arg.first())), result_reg.first()-&gt;as_Register());
2010             }
2011             // We have the array in register, use it
2012             in_arg = result_reg;
2013           }
2014 
2015           unpack_array_argument(masm, in_arg, in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
2016           c_arg++;
2017           break;
2018         }
2019       case T_OBJECT:
2020         assert(!is_critical_native, &quot;no oop arguments&quot;);
2021         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
2022                     ((i == 0) &amp;&amp; (!is_static)),
2023                     &amp;receiver_offset);
2024         break;
2025       case T_VOID:
2026         break;
2027 
2028       case T_FLOAT:
2029         float_move(masm, in_regs[i], out_regs[c_arg]);
2030           break;
2031 
2032       case T_DOUBLE:
2033         assert( i + 1 &lt; total_in_args &amp;&amp;
2034                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
2035                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
2036         double_move(masm, in_regs[i], out_regs[c_arg]);
2037         break;
2038 
2039       case T_LONG :
2040         long_move(masm, in_regs[i], out_regs[c_arg]);
2041         break;
2042 
2043       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
2044 
2045       default:
2046         simple_move32(masm, in_regs[i], out_regs[c_arg]);
2047     }
2048   }
2049 
2050   // Pre-load a static method&#39;s oop into rsi.  Used both by locking code and
2051   // the normal JNI call code.
2052   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
2053 
2054     //  load opp into a register
2055     __ movoop(oop_handle_reg, JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()));
2056 
2057     // Now handlize the static class mirror it&#39;s known not-null.
2058     __ movptr(Address(rsp, klass_offset), oop_handle_reg);
2059     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
2060 
2061     // Now get the handle
2062     __ lea(oop_handle_reg, Address(rsp, klass_offset));
2063     // store the klass handle as second argument
2064     __ movptr(Address(rsp, wordSize), oop_handle_reg);
2065   }
2066 
2067   // Change state to native (we save the return address in the thread, since it might not
2068   // be pushed on the stack when we do a a stack traversal). It is enough that the pc()
2069   // points into the right code segment. It does not have to be the correct return pc.
2070   // We use the same pc/oopMap repeatedly when we call out
2071 
2072   intptr_t the_pc = (intptr_t) __ pc();
2073   oop_maps-&gt;add_gc_map(the_pc - start, map);
2074 
2075   __ set_last_Java_frame(thread, rsp, noreg, (address)the_pc);
2076 
2077 
2078   // We have all of the arguments setup at this point. We must not touch any register
2079   // argument registers at this point (what if we save/restore them there are no oop?
2080 
2081   {
2082     SkipIfEqual skip_if(masm, &amp;DTraceMethodProbes, 0);
2083     __ mov_metadata(rax, method());
2084     __ call_VM_leaf(
2085          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2086          thread, rax);
2087   }
2088 
2089   // RedefineClasses() tracing support for obsolete method entry
2090   if (log_is_enabled(Trace, redefine, class, obsolete)) {
2091     __ mov_metadata(rax, method());
2092     __ call_VM_leaf(
2093          CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
2094          thread, rax);
2095   }
2096 
2097   // These are register definitions we need for locking/unlocking
2098   const Register swap_reg = rax;  // Must use rax, for cmpxchg instruction
2099   const Register obj_reg  = rcx;  // Will contain the oop
2100   const Register lock_reg = rdx;  // Address of compiler lock object (BasicLock)
2101 
2102   Label slow_path_lock;
2103   Label lock_done;
2104 
2105   // Lock a synchronized method
2106   if (method-&gt;is_synchronized()) {
2107     assert(!is_critical_native, &quot;unhandled&quot;);
2108 
2109 
2110     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2111 
2112     // Get the handle (the 2nd argument)
2113     __ movptr(oop_handle_reg, Address(rsp, wordSize));
2114 
2115     // Get address of the box
2116 
2117     __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));
2118 
2119     // Load the oop from the handle
2120     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2121 
2122     if (UseBiasedLocking) {
2123       // Note that oop_handle_reg is trashed during this call
2124       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, false, lock_done, &amp;slow_path_lock);
2125     }
2126 
2127     // Load immediate 1 into swap_reg %rax,
2128     __ movptr(swap_reg, 1);
2129 
2130     // Load (object-&gt;mark() | 1) into swap_reg %rax,
2131     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2132 
2133     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2134     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2135 
2136     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2137     // *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)
2138     __ lock();
2139     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2140     __ jcc(Assembler::equal, lock_done);
2141 
2142     // Test if the oopMark is an obvious stack pointer, i.e.,
2143     //  1) (mark &amp; 3) == 0, and
2144     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
2145     // These 3 tests can be done by evaluating the following
2146     // expression: ((mark - rsp) &amp; (3 - os::vm_page_size())),
2147     // assuming both stack pointer and pagesize have their
2148     // least significant 2 bits clear.
2149     // NOTE: the oopMark is in swap_reg %rax, as the result of cmpxchg
2150 
2151     __ subptr(swap_reg, rsp);
2152     __ andptr(swap_reg, 3 - os::vm_page_size());
2153 
2154     // Save the test result, for recursive case, the result is zero
2155     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2156     __ jcc(Assembler::notEqual, slow_path_lock);
2157     // Slow path will re-enter here
2158     __ bind(lock_done);
2159 
2160     if (UseBiasedLocking) {
2161       // Re-fetch oop_handle_reg as we trashed it above
2162       __ movptr(oop_handle_reg, Address(rsp, wordSize));
2163     }
2164   }
2165 
2166 
2167   // Finally just about ready to make the JNI call
2168 
2169 
2170   // get JNIEnv* which is first argument to native
2171   if (!is_critical_native) {
2172     __ lea(rdx, Address(thread, in_bytes(JavaThread::jni_environment_offset())));
2173     __ movptr(Address(rsp, 0), rdx);
2174   }
2175 
2176   // Now set thread in native
2177   __ movl(Address(thread, JavaThread::thread_state_offset()), _thread_in_native);
2178 
2179   __ call(RuntimeAddress(native_func));
2180 
2181   // Verify or restore cpu control state after JNI call
2182   __ restore_cpu_control_state_after_jni();
2183 
2184   // WARNING - on Windows Java Natives use pascal calling convention and pop the
2185   // arguments off of the stack. We could just re-adjust the stack pointer here
2186   // and continue to do SP relative addressing but we instead switch to FP
2187   // relative addressing.
2188 
2189   // Unpack native results.
2190   switch (ret_type) {
2191   case T_BOOLEAN: __ c2bool(rax);            break;
2192   case T_CHAR   : __ andptr(rax, 0xFFFF);    break;
2193   case T_BYTE   : __ sign_extend_byte (rax); break;
2194   case T_SHORT  : __ sign_extend_short(rax); break;
2195   case T_INT    : /* nothing to do */        break;
2196   case T_DOUBLE :
2197   case T_FLOAT  :
2198     // Result is in st0 we&#39;ll save as needed
2199     break;
2200   case T_ARRAY:                 // Really a handle
2201   case T_OBJECT:                // Really a handle
2202       break; // can&#39;t de-handlize until after safepoint check
2203   case T_VOID: break;
2204   case T_LONG: break;
2205   default       : ShouldNotReachHere();
2206   }
2207 
2208   // unpin pinned arguments
2209   pinned_slot = oop_handle_offset;
2210   if (pinned_args.length() &gt; 0) {
2211     // save return value that may be overwritten otherwise.
2212     save_native_result(masm, ret_type, stack_slots);
2213     for (int index = 0; index &lt; pinned_args.length(); index ++) {
2214       int i = pinned_args.at(index);
2215       assert(pinned_slot &lt;= stack_slots, &quot;overflow&quot;);
2216       if (!in_regs[i].first()-&gt;is_stack()) {
2217         int offset = pinned_slot * VMRegImpl::stack_slot_size;
2218         __ movl(in_regs[i].first()-&gt;as_Register(), Address(rsp, offset));
2219         pinned_slot += VMRegImpl::slots_per_word;
2220       }
2221       // gen_pin_object handles save and restore
2222       // of any other clobbered registers
2223       gen_unpin_object(masm, thread, in_regs[i]);
2224     }
2225     restore_native_result(masm, ret_type, stack_slots);
2226   }
2227 
2228   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2229   // This additional state is necessary because reading and testing the synchronization
2230   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2231   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2232   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2233   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2234   //     didn&#39;t see any synchronization is progress, and escapes.
2235   __ movl(Address(thread, JavaThread::thread_state_offset()), _thread_in_native_trans);
2236 
2237   // Force this write out before the read below
2238   __ membar(Assembler::Membar_mask_bits(
2239             Assembler::LoadLoad | Assembler::LoadStore |
2240             Assembler::StoreLoad | Assembler::StoreStore));
2241 
2242   if (AlwaysRestoreFPU) {
2243     // Make sure the control word is correct.
2244     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
2245   }
2246 
2247   Label after_transition;
2248 
2249   // check for safepoint operation in progress and/or pending suspend requests
2250   { Label Continue, slow_path;
2251 
2252     __ safepoint_poll(slow_path, thread, noreg);
2253 
2254     __ cmpl(Address(thread, JavaThread::suspend_flags_offset()), 0);
2255     __ jcc(Assembler::equal, Continue);
2256     __ bind(slow_path);
2257 
2258     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2259     // and never return here preventing us from clearing _last_native_pc down below.
2260     // Also can&#39;t use call_VM_leaf either as it will check to see if rsi &amp; rdi are
2261     // preserved and correspond to the bcp/locals pointers. So we do a runtime call
2262     // by hand.
2263     //
2264     __ vzeroupper();
2265 
2266     save_native_result(masm, ret_type, stack_slots);
2267     __ push(thread);
2268     if (!is_critical_native) {
2269       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address,
2270                                               JavaThread::check_special_condition_for_native_trans)));
2271     } else {
2272       __ call(RuntimeAddress(CAST_FROM_FN_PTR(address,
2273                                               JavaThread::check_special_condition_for_native_trans_and_transition)));
2274     }
2275     __ increment(rsp, wordSize);
2276     // Restore any method result value
2277     restore_native_result(masm, ret_type, stack_slots);
2278 
2279     if (is_critical_native) {
2280       // The call above performed the transition to thread_in_Java so
2281       // skip the transition logic below.
2282       __ jmpb(after_transition);
2283     }
2284 
2285     __ bind(Continue);
2286   }
2287 
2288   // change thread state
2289   __ movl(Address(thread, JavaThread::thread_state_offset()), _thread_in_Java);
2290   __ bind(after_transition);
2291 
2292   Label reguard;
2293   Label reguard_done;
2294   __ cmpl(Address(thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
2295   __ jcc(Assembler::equal, reguard);
2296 
2297   // slow path reguard  re-enters here
2298   __ bind(reguard_done);
2299 
2300   // Handle possible exception (will unlock if necessary)
2301 
2302   // native result if any is live
2303 
2304   // Unlock
2305   Label slow_path_unlock;
2306   Label unlock_done;
2307   if (method-&gt;is_synchronized()) {
2308 
2309     Label done;
2310 
2311     // Get locked oop from the handle we passed to jni
2312     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2313 
2314     if (UseBiasedLocking) {
2315       __ biased_locking_exit(obj_reg, rbx, done);
2316     }
2317 
2318     // Simple recursive lock?
2319 
2320     __ cmpptr(Address(rbp, lock_slot_rbp_offset), (int32_t)NULL_WORD);
2321     __ jcc(Assembler::equal, done);
2322 
2323     // Must save rax, if if it is live now because cmpxchg must use it
2324     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2325       save_native_result(masm, ret_type, stack_slots);
2326     }
2327 
2328     //  get old displaced header
2329     __ movptr(rbx, Address(rbp, lock_slot_rbp_offset));
2330 
2331     // get address of the stack lock
2332     __ lea(rax, Address(rbp, lock_slot_rbp_offset));
2333 
2334     // Atomic swap old header if oop still contains the stack lock
2335     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2336     // *obj_reg = rbx, iff *obj_reg == rax, else rax, = *(obj_reg)
2337     __ lock();
2338     __ cmpxchgptr(rbx, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2339     __ jcc(Assembler::notEqual, slow_path_unlock);
2340 
2341     // slow path re-enters here
2342     __ bind(unlock_done);
2343     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2344       restore_native_result(masm, ret_type, stack_slots);
2345     }
2346 
2347     __ bind(done);
2348 
2349   }
2350 
2351   {
2352     SkipIfEqual skip_if(masm, &amp;DTraceMethodProbes, 0);
2353     // Tell dtrace about this method exit
2354     save_native_result(masm, ret_type, stack_slots);
2355     __ mov_metadata(rax, method());
2356     __ call_VM_leaf(
2357          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2358          thread, rax);
2359     restore_native_result(masm, ret_type, stack_slots);
2360   }
2361 
2362   // We can finally stop using that last_Java_frame we setup ages ago
2363 
2364   __ reset_last_Java_frame(thread, false);
2365 
2366   // Unbox oop result, e.g. JNIHandles::resolve value.
2367   if (is_reference_type(ret_type)) {
2368     __ resolve_jobject(rax /* value */,
2369                        thread /* thread */,
2370                        rcx /* tmp */);
2371   }
2372 
2373   if (CheckJNICalls) {
2374     // clear_pending_jni_exception_check
2375     __ movptr(Address(thread, JavaThread::pending_jni_exception_check_fn_offset()), NULL_WORD);
2376   }
2377 
2378   if (!is_critical_native) {
2379     // reset handle block
2380     __ movptr(rcx, Address(thread, JavaThread::active_handles_offset()));
2381     __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);
2382 
2383     // Any exception pending?
2384     __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2385     __ jcc(Assembler::notEqual, exception_pending);
2386   }
2387 
2388   // no exception, we&#39;re almost done
2389 
2390   // check that only result value is on FPU stack
2391   __ verify_FPU(ret_type == T_FLOAT || ret_type == T_DOUBLE ? 1 : 0, &quot;native_wrapper normal exit&quot;);
2392 
2393   // Fixup floating pointer results so that result looks like a return from a compiled method
2394   if (ret_type == T_FLOAT) {
2395     if (UseSSE &gt;= 1) {
2396       // Pop st0 and store as float and reload into xmm register
2397       __ fstp_s(Address(rbp, -4));
2398       __ movflt(xmm0, Address(rbp, -4));
2399     }
2400   } else if (ret_type == T_DOUBLE) {
2401     if (UseSSE &gt;= 2) {
2402       // Pop st0 and store as double and reload into xmm register
2403       __ fstp_d(Address(rbp, -8));
2404       __ movdbl(xmm0, Address(rbp, -8));
2405     }
2406   }
2407 
2408   // Return
2409 
2410   __ leave();
2411   __ ret(0);
2412 
2413   // Unexpected paths are out of line and go here
2414 
2415   // Slow path locking &amp; unlocking
2416   if (method-&gt;is_synchronized()) {
2417 
2418     // BEGIN Slow path lock
2419 
2420     __ bind(slow_path_lock);
2421 
2422     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2423     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2424     __ push(thread);
2425     __ push(lock_reg);
2426     __ push(obj_reg);
2427     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C)));
2428     __ addptr(rsp, 3*wordSize);
2429 
2430 #ifdef ASSERT
2431     { Label L;
2432     __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int)NULL_WORD);
2433     __ jcc(Assembler::equal, L);
2434     __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2435     __ bind(L);
2436     }
2437 #endif
2438     __ jmp(lock_done);
2439 
2440     // END Slow path lock
2441 
2442     // BEGIN Slow path unlock
2443     __ bind(slow_path_unlock);
2444     __ vzeroupper();
2445     // Slow path unlock
2446 
2447     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2448       save_native_result(masm, ret_type, stack_slots);
2449     }
2450     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2451 
2452     __ pushptr(Address(thread, in_bytes(Thread::pending_exception_offset())));
2453     __ movptr(Address(thread, in_bytes(Thread::pending_exception_offset())), NULL_WORD);
2454 
2455 
2456     // should be a peal
2457     // +wordSize because of the push above
2458     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2459     __ push(thread);
2460     __ lea(rax, Address(rbp, lock_slot_rbp_offset));
2461     __ push(rax);
2462 
2463     __ push(obj_reg);
2464     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C)));
2465     __ addptr(rsp, 3*wordSize);
2466 #ifdef ASSERT
2467     {
2468       Label L;
2469       __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);
2470       __ jcc(Assembler::equal, L);
2471       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2472       __ bind(L);
2473     }
2474 #endif /* ASSERT */
2475 
2476     __ popptr(Address(thread, in_bytes(Thread::pending_exception_offset())));
2477 
2478     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2479       restore_native_result(masm, ret_type, stack_slots);
2480     }
2481     __ jmp(unlock_done);
2482     // END Slow path unlock
2483 
2484   }
2485 
2486   // SLOW PATH Reguard the stack if needed
2487 
2488   __ bind(reguard);
2489   __ vzeroupper();
2490   save_native_result(masm, ret_type, stack_slots);
2491   {
2492     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
2493   }
2494   restore_native_result(masm, ret_type, stack_slots);
2495   __ jmp(reguard_done);
2496 
2497 
2498   // BEGIN EXCEPTION PROCESSING
2499 
2500   if (!is_critical_native) {
2501     // Forward  the exception
2502     __ bind(exception_pending);
2503 
2504     // remove possible return value from FPU register stack
2505     __ empty_FPU_stack();
2506 
2507     // pop our frame
2508     __ leave();
2509     // and forward the exception
2510     __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2511   }
2512 
2513   __ flush();
2514 
2515   nmethod *nm = nmethod::new_native_nmethod(method,
2516                                             compile_id,
2517                                             masm-&gt;code(),
2518                                             vep_offset,
2519                                             frame_complete,
2520                                             stack_slots / VMRegImpl::slots_per_word,
2521                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2522                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2523                                             oop_maps);
2524 
2525   if (is_critical_native) {
2526     nm-&gt;set_lazy_critical_native(true);
2527   }
2528 
2529   return nm;
2530 
2531 }
2532 
2533 // this function returns the adjust size (in number of words) to a c2i adapter
2534 // activation for use during deoptimization
2535 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals ) {
2536   return (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2537 }
2538 
2539 
2540 uint SharedRuntime::out_preserve_stack_slots() {
2541   return 0;
2542 }
2543 
2544 //------------------------------generate_deopt_blob----------------------------
2545 void SharedRuntime::generate_deopt_blob() {
2546   // allocate space for the code
2547   ResourceMark rm;
2548   // setup code generation tools
2549   // note: the buffer code size must account for StackShadowPages=50
2550   CodeBuffer   buffer(&quot;deopt_blob&quot;, 1536, 1024);
2551   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2552   int frame_size_in_words;
2553   OopMap* map = NULL;
2554   // Account for the extra args we place on the stack
2555   // by the time we call fetch_unroll_info
2556   const int additional_words = 2; // deopt kind, thread
2557 
2558   OopMapSet *oop_maps = new OopMapSet();
2559 
2560   // -------------
2561   // This code enters when returning to a de-optimized nmethod.  A return
2562   // address has been pushed on the the stack, and return values are in
2563   // registers.
2564   // If we are doing a normal deopt then we were called from the patched
2565   // nmethod from the point we returned to the nmethod. So the return
2566   // address on the stack is wrong by NativeCall::instruction_size
2567   // We will adjust the value to it looks like we have the original return
2568   // address on the stack (like when we eagerly deoptimized).
2569   // In the case of an exception pending with deoptimized then we enter
2570   // with a return address on the stack that points after the call we patched
2571   // into the exception handler. We have the following register state:
2572   //    rax,: exception
2573   //    rbx,: exception handler
2574   //    rdx: throwing pc
2575   // So in this case we simply jam rdx into the useless return address and
2576   // the stack looks just like we want.
2577   //
2578   // At this point we need to de-opt.  We save the argument return
2579   // registers.  We call the first C routine, fetch_unroll_info().  This
2580   // routine captures the return values and returns a structure which
2581   // describes the current frame size and the sizes of all replacement frames.
2582   // The current frame is compiled code and may contain many inlined
2583   // functions, each with their own JVM state.  We pop the current frame, then
2584   // push all the new frames.  Then we call the C routine unpack_frames() to
2585   // populate these frames.  Finally unpack_frames() returns us the new target
2586   // address.  Notice that callee-save registers are BLOWN here; they have
2587   // already been captured in the vframeArray at the time the return PC was
2588   // patched.
2589   address start = __ pc();
2590   Label cont;
2591 
2592   // Prolog for non exception case!
2593 
2594   // Save everything in sight.
2595 
2596   map = RegisterSaver::save_live_registers(masm, additional_words, &amp;frame_size_in_words, false);
2597   // Normal deoptimization
2598   __ push(Deoptimization::Unpack_deopt);
2599   __ jmp(cont);
2600 
2601   int reexecute_offset = __ pc() - start;
2602 
2603   // Reexecute case
2604   // return address is the pc describes what bci to do re-execute at
2605 
2606   // No need to update map as each call to save_live_registers will produce identical oopmap
2607   (void) RegisterSaver::save_live_registers(masm, additional_words, &amp;frame_size_in_words, false);
2608 
2609   __ push(Deoptimization::Unpack_reexecute);
2610   __ jmp(cont);
2611 
2612   int exception_offset = __ pc() - start;
2613 
2614   // Prolog for exception case
2615 
2616   // all registers are dead at this entry point, except for rax, and
2617   // rdx which contain the exception oop and exception pc
2618   // respectively.  Set them in TLS and fall thru to the
2619   // unpack_with_exception_in_tls entry point.
2620 
2621   __ get_thread(rdi);
2622   __ movptr(Address(rdi, JavaThread::exception_pc_offset()), rdx);
2623   __ movptr(Address(rdi, JavaThread::exception_oop_offset()), rax);
2624 
2625   int exception_in_tls_offset = __ pc() - start;
2626 
2627   // new implementation because exception oop is now passed in JavaThread
2628 
2629   // Prolog for exception case
2630   // All registers must be preserved because they might be used by LinearScan
2631   // Exceptiop oop and throwing PC are passed in JavaThread
2632   // tos: stack at point of call to method that threw the exception (i.e. only
2633   // args are on the stack, no return address)
2634 
2635   // make room on stack for the return address
2636   // It will be patched later with the throwing pc. The correct value is not
2637   // available now because loading it from memory would destroy registers.
2638   __ push(0);
2639 
2640   // Save everything in sight.
2641 
2642   // No need to update map as each call to save_live_registers will produce identical oopmap
2643   (void) RegisterSaver::save_live_registers(masm, additional_words, &amp;frame_size_in_words, false);
2644 
2645   // Now it is safe to overwrite any register
2646 
2647   // store the correct deoptimization type
2648   __ push(Deoptimization::Unpack_exception);
2649 
2650   // load throwing pc from JavaThread and patch it as the return address
2651   // of the current frame. Then clear the field in JavaThread
2652   __ get_thread(rdi);
2653   __ movptr(rdx, Address(rdi, JavaThread::exception_pc_offset()));
2654   __ movptr(Address(rbp, wordSize), rdx);
2655   __ movptr(Address(rdi, JavaThread::exception_pc_offset()), NULL_WORD);
2656 
2657 #ifdef ASSERT
2658   // verify that there is really an exception oop in JavaThread
2659   __ movptr(rax, Address(rdi, JavaThread::exception_oop_offset()));
2660   __ verify_oop(rax);
2661 
2662   // verify that there is no pending exception
2663   Label no_pending_exception;
2664   __ movptr(rax, Address(rdi, Thread::pending_exception_offset()));
2665   __ testptr(rax, rax);
2666   __ jcc(Assembler::zero, no_pending_exception);
2667   __ stop(&quot;must not have pending exception here&quot;);
2668   __ bind(no_pending_exception);
2669 #endif
2670 
2671   __ bind(cont);
2672 
2673   // Compiled code leaves the floating point stack dirty, empty it.
2674   __ empty_FPU_stack();
2675 
2676 
2677   // Call C code.  Need thread and this frame, but NOT official VM entry
2678   // crud.  We cannot block on this call, no GC can happen.
2679   __ get_thread(rcx);
2680   __ push(rcx);
2681   // fetch_unroll_info needs to call last_java_frame()
2682   __ set_last_Java_frame(rcx, noreg, noreg, NULL);
2683 
2684   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
2685 
2686   // Need to have an oopmap that tells fetch_unroll_info where to
2687   // find any register it might need.
2688 
2689   oop_maps-&gt;add_gc_map( __ pc()-start, map);
2690 
2691   // Discard args to fetch_unroll_info
2692   __ pop(rcx);
2693   __ pop(rcx);
2694 
2695   __ get_thread(rcx);
2696   __ reset_last_Java_frame(rcx, false);
2697 
2698   // Load UnrollBlock into EDI
2699   __ mov(rdi, rax);
2700 
2701   // Move the unpack kind to a safe place in the UnrollBlock because
2702   // we are very short of registers
2703 
2704   Address unpack_kind(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes());
2705   // retrieve the deopt kind from the UnrollBlock.
2706   __ movl(rax, unpack_kind);
2707 
2708    Label noException;
2709   __ cmpl(rax, Deoptimization::Unpack_exception);   // Was exception pending?
2710   __ jcc(Assembler::notEqual, noException);
2711   __ movptr(rax, Address(rcx, JavaThread::exception_oop_offset()));
2712   __ movptr(rdx, Address(rcx, JavaThread::exception_pc_offset()));
2713   __ movptr(Address(rcx, JavaThread::exception_oop_offset()), NULL_WORD);
2714   __ movptr(Address(rcx, JavaThread::exception_pc_offset()), NULL_WORD);
2715 
2716   __ verify_oop(rax);
2717 
2718   // Overwrite the result registers with the exception results.
2719   __ movptr(Address(rsp, RegisterSaver::raxOffset()*wordSize), rax);
2720   __ movptr(Address(rsp, RegisterSaver::rdxOffset()*wordSize), rdx);
2721 
2722   __ bind(noException);
2723 
2724   // Stack is back to only having register save data on the stack.
2725   // Now restore the result registers. Everything else is either dead or captured
2726   // in the vframeArray.
2727 
2728   RegisterSaver::restore_result_registers(masm);
2729 
2730   // Non standard control word may be leaked out through a safepoint blob, and we can
2731   // deopt at a poll point with the non standard control word. However, we should make
2732   // sure the control word is correct after restore_result_registers.
2733   __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
2734 
2735   // All of the register save area has been popped of the stack. Only the
2736   // return address remains.
2737 
2738   // Pop all the frames we must move/replace.
2739   //
2740   // Frame picture (youngest to oldest)
2741   // 1: self-frame (no frame link)
2742   // 2: deopting frame  (no frame link)
2743   // 3: caller of deopting frame (could be compiled/interpreted).
2744   //
2745   // Note: by leaving the return address of self-frame on the stack
2746   // and using the size of frame 2 to adjust the stack
2747   // when we are done the return to frame 3 will still be on the stack.
2748 
2749   // Pop deoptimized frame
2750   __ addptr(rsp, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2751 
2752   // sp should be pointing at the return address to the caller (3)
2753 
2754   // Pick up the initial fp we should save
2755   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
2756   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
2757 
2758 #ifdef ASSERT
2759   // Compilers generate code that bang the stack by as much as the
2760   // interpreter would need. So this stack banging should never
2761   // trigger a fault. Verify that it does not on non product builds.
2762   if (UseStackBanging) {
2763     __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2764     __ bang_stack_size(rbx, rcx);
2765   }
2766 #endif
2767 
2768   // Load array of frame pcs into ECX
2769   __ movptr(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2770 
2771   __ pop(rsi); // trash the old pc
2772 
2773   // Load array of frame sizes into ESI
2774   __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2775 
2776   Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset_in_bytes());
2777 
2778   __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2779   __ movl(counter, rbx);
2780 
2781   // Now adjust the caller&#39;s stack to make up for the extra locals
2782   // but record the original sp so that we can save it in the skeletal interpreter
2783   // frame and the stack walking of interpreter_sender will get the unextended sp
2784   // value and not the &quot;real&quot; sp value.
2785 
2786   Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset_in_bytes());
2787   __ movptr(sp_temp, rsp);
2788   __ movl2ptr(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
2789   __ subptr(rsp, rbx);
2790 
2791   // Push interpreter frames in a loop
2792   Label loop;
2793   __ bind(loop);
2794   __ movptr(rbx, Address(rsi, 0));      // Load frame size
2795   __ subptr(rbx, 2*wordSize);           // we&#39;ll push pc and rbp, by hand
2796   __ pushptr(Address(rcx, 0));          // save return address
2797   __ enter();                           // save old &amp; set new rbp,
2798   __ subptr(rsp, rbx);                  // Prolog!
2799   __ movptr(rbx, sp_temp);              // sender&#39;s sp
2800   // This value is corrected by layout_activation_impl
2801   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);
2802   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), rbx); // Make it walkable
2803   __ movptr(sp_temp, rsp);              // pass to next frame
2804   __ addptr(rsi, wordSize);             // Bump array pointer (sizes)
2805   __ addptr(rcx, wordSize);             // Bump array pointer (pcs)
2806   __ decrementl(counter);             // decrement counter
2807   __ jcc(Assembler::notZero, loop);
2808   __ pushptr(Address(rcx, 0));          // save final return address
2809 
2810   // Re-push self-frame
2811   __ enter();                           // save old &amp; set new rbp,
2812 
2813   //  Return address and rbp, are in place
2814   // We&#39;ll push additional args later. Just allocate a full sized
2815   // register save area
2816   __ subptr(rsp, (frame_size_in_words-additional_words - 2) * wordSize);
2817 
2818   // Restore frame locals after moving the frame
2819   __ movptr(Address(rsp, RegisterSaver::raxOffset()*wordSize), rax);
2820   __ movptr(Address(rsp, RegisterSaver::rdxOffset()*wordSize), rdx);
2821   __ fstp_d(Address(rsp, RegisterSaver::fpResultOffset()*wordSize));   // Pop float stack and store in local
2822   if( UseSSE&gt;=2 ) __ movdbl(Address(rsp, RegisterSaver::xmm0Offset()*wordSize), xmm0);
2823   if( UseSSE==1 ) __ movflt(Address(rsp, RegisterSaver::xmm0Offset()*wordSize), xmm0);
2824 
2825   // Set up the args to unpack_frame
2826 
2827   __ pushl(unpack_kind);                     // get the unpack_kind value
2828   __ get_thread(rcx);
2829   __ push(rcx);
2830 
2831   // set last_Java_sp, last_Java_fp
2832   __ set_last_Java_frame(rcx, noreg, rbp, NULL);
2833 
2834   // Call C code.  Need thread but NOT official VM entry
2835   // crud.  We cannot block on this call, no GC can happen.  Call should
2836   // restore return values to their stack-slots with the new SP.
2837   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2838   // Set an oopmap for the call site
2839   oop_maps-&gt;add_gc_map( __ pc()-start, new OopMap( frame_size_in_words, 0 ));
2840 
2841   // rax, contains the return result type
2842   __ push(rax);
2843 
2844   __ get_thread(rcx);
2845   __ reset_last_Java_frame(rcx, false);
2846 
2847   // Collect return values
2848   __ movptr(rax,Address(rsp, (RegisterSaver::raxOffset() + additional_words + 1)*wordSize));
2849   __ movptr(rdx,Address(rsp, (RegisterSaver::rdxOffset() + additional_words + 1)*wordSize));
2850 
2851   // Clear floating point stack before returning to interpreter
2852   __ empty_FPU_stack();
2853 
2854   // Check if we should push the float or double return value.
2855   Label results_done, yes_double_value;
2856   __ cmpl(Address(rsp, 0), T_DOUBLE);
2857   __ jcc (Assembler::zero, yes_double_value);
2858   __ cmpl(Address(rsp, 0), T_FLOAT);
2859   __ jcc (Assembler::notZero, results_done);
2860 
2861   // return float value as expected by interpreter
2862   if( UseSSE&gt;=1 ) __ movflt(xmm0, Address(rsp, (RegisterSaver::xmm0Offset() + additional_words + 1)*wordSize));
2863   else            __ fld_d(Address(rsp, (RegisterSaver::fpResultOffset() + additional_words + 1)*wordSize));
2864   __ jmp(results_done);
2865 
2866   // return double value as expected by interpreter
2867   __ bind(yes_double_value);
2868   if( UseSSE&gt;=2 ) __ movdbl(xmm0, Address(rsp, (RegisterSaver::xmm0Offset() + additional_words + 1)*wordSize));
2869   else            __ fld_d(Address(rsp, (RegisterSaver::fpResultOffset() + additional_words + 1)*wordSize));
2870 
2871   __ bind(results_done);
2872 
2873   // Pop self-frame.
2874   __ leave();                              // Epilog!
2875 
2876   // Jump to interpreter
2877   __ ret(0);
2878 
2879   // -------------
2880   // make sure all code is generated
2881   masm-&gt;flush();
2882 
2883   _deopt_blob = DeoptimizationBlob::create( &amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2884   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2885 }
2886 
2887 
2888 #ifdef COMPILER2
2889 //------------------------------generate_uncommon_trap_blob--------------------
2890 void SharedRuntime::generate_uncommon_trap_blob() {
2891   // allocate space for the code
2892   ResourceMark rm;
2893   // setup code generation tools
2894   CodeBuffer   buffer(&quot;uncommon_trap_blob&quot;, 512, 512);
2895   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2896 
2897   enum frame_layout {
2898     arg0_off,      // thread                     sp + 0 // Arg location for
2899     arg1_off,      // unloaded_class_index       sp + 1 // calling C
2900     arg2_off,      // exec_mode                  sp + 2
2901     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
2902     // will override any oopMap setting for it. We must therefore force the layout
2903     // so that it agrees with the frame sender code.
2904     rbp_off,       // callee saved register      sp + 3
2905     return_off,    // slot for return address    sp + 4
2906     framesize
2907   };
2908 
2909   address start = __ pc();
2910 
2911   if (UseRTMLocking) {
2912     // Abort RTM transaction before possible nmethod deoptimization.
2913     __ xabort(0);
2914   }
2915 
2916   // Push self-frame.
2917   __ subptr(rsp, return_off*wordSize);     // Epilog!
2918 
2919   // rbp, is an implicitly saved callee saved register (i.e. the calling
2920   // convention will save restore it in prolog/epilog) Other than that
2921   // there are no callee save registers no that adapter frames are gone.
2922   __ movptr(Address(rsp, rbp_off*wordSize), rbp);
2923 
2924   // Clear the floating point exception stack
2925   __ empty_FPU_stack();
2926 
2927   // set last_Java_sp
2928   __ get_thread(rdx);
2929   __ set_last_Java_frame(rdx, noreg, noreg, NULL);
2930 
2931   // Call C code.  Need thread but NOT official VM entry
2932   // crud.  We cannot block on this call, no GC can happen.  Call should
2933   // capture callee-saved registers as well as return values.
2934   __ movptr(Address(rsp, arg0_off*wordSize), rdx);
2935   // argument already in ECX
2936   __ movl(Address(rsp, arg1_off*wordSize),rcx);
2937   __ movl(Address(rsp, arg2_off*wordSize), Deoptimization::Unpack_uncommon_trap);
2938   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap)));
2939 
2940   // Set an oopmap for the call site
2941   OopMapSet *oop_maps = new OopMapSet();
2942   OopMap* map =  new OopMap( framesize, 0 );
2943   // No oopMap for rbp, it is known implicitly
2944 
2945   oop_maps-&gt;add_gc_map( __ pc()-start, map);
2946 
2947   __ get_thread(rcx);
2948 
2949   __ reset_last_Java_frame(rcx, false);
2950 
2951   // Load UnrollBlock into EDI
2952   __ movptr(rdi, rax);
2953 
2954 #ifdef ASSERT
2955   { Label L;
2956     __ cmpptr(Address(rdi, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()),
2957             (int32_t)Deoptimization::Unpack_uncommon_trap);
2958     __ jcc(Assembler::equal, L);
2959     __ stop(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;);
2960     __ bind(L);
2961   }
2962 #endif
2963 
2964   // Pop all the frames we must move/replace.
2965   //
2966   // Frame picture (youngest to oldest)
2967   // 1: self-frame (no frame link)
2968   // 2: deopting frame  (no frame link)
2969   // 3: caller of deopting frame (could be compiled/interpreted).
2970 
2971   // Pop self-frame.  We have no frame, and must rely only on EAX and ESP.
2972   __ addptr(rsp,(framesize-1)*wordSize);     // Epilog!
2973 
2974   // Pop deoptimized frame
2975   __ movl2ptr(rcx, Address(rdi,Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2976   __ addptr(rsp, rcx);
2977 
2978   // sp should be pointing at the return address to the caller (3)
2979 
2980   // Pick up the initial fp we should save
2981   // restore rbp before stack bang because if stack overflow is thrown it needs to be pushed (and preserved)
2982   __ movptr(rbp, Address(rdi, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
2983 
2984 #ifdef ASSERT
2985   // Compilers generate code that bang the stack by as much as the
2986   // interpreter would need. So this stack banging should never
2987   // trigger a fault. Verify that it does not on non product builds.
2988   if (UseStackBanging) {
2989     __ movl(rbx, Address(rdi ,Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2990     __ bang_stack_size(rbx, rcx);
2991   }
2992 #endif
2993 
2994   // Load array of frame pcs into ECX
2995   __ movl(rcx,Address(rdi,Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2996 
2997   __ pop(rsi); // trash the pc
2998 
2999   // Load array of frame sizes into ESI
3000   __ movptr(rsi,Address(rdi,Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
3001 
3002   Address counter(rdi, Deoptimization::UnrollBlock::counter_temp_offset_in_bytes());
3003 
3004   __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
3005   __ movl(counter, rbx);
3006 
3007   // Now adjust the caller&#39;s stack to make up for the extra locals
3008   // but record the original sp so that we can save it in the skeletal interpreter
3009   // frame and the stack walking of interpreter_sender will get the unextended sp
3010   // value and not the &quot;real&quot; sp value.
3011 
3012   Address sp_temp(rdi, Deoptimization::UnrollBlock::sender_sp_temp_offset_in_bytes());
3013   __ movptr(sp_temp, rsp);
3014   __ movl(rbx, Address(rdi, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
3015   __ subptr(rsp, rbx);
3016 
3017   // Push interpreter frames in a loop
3018   Label loop;
3019   __ bind(loop);
3020   __ movptr(rbx, Address(rsi, 0));      // Load frame size
3021   __ subptr(rbx, 2*wordSize);           // we&#39;ll push pc and rbp, by hand
3022   __ pushptr(Address(rcx, 0));          // save return address
3023   __ enter();                           // save old &amp; set new rbp,
3024   __ subptr(rsp, rbx);                  // Prolog!
3025   __ movptr(rbx, sp_temp);              // sender&#39;s sp
3026   // This value is corrected by layout_activation_impl
3027   __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD );
3028   __ movptr(Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize), rbx); // Make it walkable
3029   __ movptr(sp_temp, rsp);              // pass to next frame
3030   __ addptr(rsi, wordSize);             // Bump array pointer (sizes)
3031   __ addptr(rcx, wordSize);             // Bump array pointer (pcs)
3032   __ decrementl(counter);             // decrement counter
3033   __ jcc(Assembler::notZero, loop);
3034   __ pushptr(Address(rcx, 0));            // save final return address
3035 
3036   // Re-push self-frame
3037   __ enter();                           // save old &amp; set new rbp,
3038   __ subptr(rsp, (framesize-2) * wordSize);   // Prolog!
3039 
3040 
3041   // set last_Java_sp, last_Java_fp
3042   __ get_thread(rdi);
3043   __ set_last_Java_frame(rdi, noreg, rbp, NULL);
3044 
3045   // Call C code.  Need thread but NOT official VM entry
3046   // crud.  We cannot block on this call, no GC can happen.  Call should
3047   // restore return values to their stack-slots with the new SP.
3048   __ movptr(Address(rsp,arg0_off*wordSize),rdi);
3049   __ movl(Address(rsp,arg1_off*wordSize), Deoptimization::Unpack_uncommon_trap);
3050   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
3051   // Set an oopmap for the call site
3052   oop_maps-&gt;add_gc_map( __ pc()-start, new OopMap( framesize, 0 ) );
3053 
3054   __ get_thread(rdi);
3055   __ reset_last_Java_frame(rdi, true);
3056 
3057   // Pop self-frame.
3058   __ leave();     // Epilog!
3059 
3060   // Jump to interpreter
3061   __ ret(0);
3062 
3063   // -------------
3064   // make sure all code is generated
3065   masm-&gt;flush();
3066 
3067    _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, oop_maps, framesize);
3068 }
3069 #endif // COMPILER2
3070 
3071 //------------------------------generate_handler_blob------
3072 //
3073 // Generate a special Compile2Runtime blob that saves all registers,
3074 // setup oopmap, and calls safepoint code to stop the compiled code for
3075 // a safepoint.
3076 //
3077 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3078 
3079   // Account for thread arg in our frame
3080   const int additional_words = 1;
3081   int frame_size_in_words;
3082 
3083   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3084 
3085   ResourceMark rm;
3086   OopMapSet *oop_maps = new OopMapSet();
3087   OopMap* map;
3088 
3089   // allocate space for the code
3090   // setup code generation tools
3091   CodeBuffer   buffer(&quot;handler_blob&quot;, 1024, 512);
3092   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3093 
3094   const Register java_thread = rdi; // callee-saved for VC++
3095   address start   = __ pc();
3096   address call_pc = NULL;
3097   bool cause_return = (poll_type == POLL_AT_RETURN);
3098   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3099 
3100   if (UseRTMLocking) {
3101     // Abort RTM transaction before calling runtime
3102     // because critical section will be large and will be
3103     // aborted anyway. Also nmethod could be deoptimized.
3104     __ xabort(0);
3105   }
3106 
3107   // If cause_return is true we are at a poll_return and there is
3108   // the return address on the stack to the caller on the nmethod
3109   // that is safepoint. We can leave this return on the stack and
3110   // effectively complete the return and safepoint in the caller.
3111   // Otherwise we push space for a return address that the safepoint
3112   // handler will install later to make the stack walking sensible.
3113   if (!cause_return)
3114     __ push(rbx);  // Make room for return address (or push it again)
3115 
3116   map = RegisterSaver::save_live_registers(masm, additional_words, &amp;frame_size_in_words, false, save_vectors);
3117 
3118   // The following is basically a call_VM. However, we need the precise
3119   // address of the call in order to generate an oopmap. Hence, we do all the
3120   // work ourselves.
3121 
3122   // Push thread argument and setup last_Java_sp
3123   __ get_thread(java_thread);
3124   __ push(java_thread);
3125   __ set_last_Java_frame(java_thread, noreg, noreg, NULL);
3126 
3127   // if this was not a poll_return then we need to correct the return address now.
3128   if (!cause_return) {
3129     // Get the return pc saved by the signal handler and stash it in its appropriate place on the stack.
3130     // Additionally, rbx is a callee saved register and we can look at it later to determine
3131     // if someone changed the return address for us!
3132     __ movptr(rbx, Address(java_thread, JavaThread::saved_exception_pc_offset()));
3133     __ movptr(Address(rbp, wordSize), rbx);
3134   }
3135 
3136   // do the call
3137   __ call(RuntimeAddress(call_ptr));
3138 
3139   // Set an oopmap for the call site.  This oopmap will map all
3140   // oop-registers and debug-info registers as callee-saved.  This
3141   // will allow deoptimization at this safepoint to find all possible
3142   // debug-info recordings, as well as let GC find all oops.
3143 
3144   oop_maps-&gt;add_gc_map( __ pc() - start, map);
3145 
3146   // Discard arg
3147   __ pop(rcx);
3148 
3149   Label noException;
3150 
3151   // Clear last_Java_sp again
3152   __ get_thread(java_thread);
3153   __ reset_last_Java_frame(java_thread, false);
3154 
3155   __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3156   __ jcc(Assembler::equal, noException);
3157 
3158   // Exception pending
3159   RegisterSaver::restore_live_registers(masm, save_vectors);
3160 
3161   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3162 
3163   __ bind(noException);
3164 
3165   Label no_adjust, bail, not_special;
3166   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3167     // If our stashed return pc was modified by the runtime we avoid touching it
3168     __ cmpptr(rbx, Address(rbp, wordSize));
3169     __ jccb(Assembler::notEqual, no_adjust);
3170 
3171     // Skip over the poll instruction.
3172     // See NativeInstruction::is_safepoint_poll()
3173     // Possible encodings:
3174     //      85 00       test   %eax,(%rax)
3175     //      85 01       test   %eax,(%rcx)
3176     //      85 02       test   %eax,(%rdx)
3177     //      85 03       test   %eax,(%rbx)
3178     //      85 06       test   %eax,(%rsi)
3179     //      85 07       test   %eax,(%rdi)
3180     //
3181     //      85 04 24    test   %eax,(%rsp)
3182     //      85 45 00    test   %eax,0x0(%rbp)
3183 
3184 #ifdef ASSERT
3185     __ movptr(rax, rbx); // remember where 0x85 should be, for verification below
3186 #endif
3187     // rsp/rbp base encoding takes 3 bytes with the following register values:
3188     // rsp 0x04
3189     // rbp 0x05
3190     __ movzbl(rcx, Address(rbx, 1));
3191     __ andptr(rcx, 0x07); // looking for 0x04 .. 0x05
3192     __ subptr(rcx, 4);    // looking for 0x00 .. 0x01
3193     __ cmpptr(rcx, 1);
3194     __ jcc(Assembler::above, not_special);
3195     __ addptr(rbx, 1);
3196     __ bind(not_special);
3197 #ifdef ASSERT
3198     // Verify the correct encoding of the poll we&#39;re about to skip.
3199     __ cmpb(Address(rax, 0), NativeTstRegMem::instruction_code_memXregl);
3200     __ jcc(Assembler::notEqual, bail);
3201     // Mask out the modrm bits
3202     __ testb(Address(rax, 1), NativeTstRegMem::modrm_mask);
3203     // rax encodes to 0, so if the bits are nonzero it&#39;s incorrect
3204     __ jcc(Assembler::notZero, bail);
3205 #endif
3206     // Adjust return pc forward to step over the safepoint poll instruction
3207     __ addptr(rbx, 2);
3208     __ movptr(Address(rbp, wordSize), rbx);
3209   }
3210 
3211   __ bind(no_adjust);
3212   // Normal exit, register restoring and exit
3213   RegisterSaver::restore_live_registers(masm, save_vectors);
3214 
3215   __ ret(0);
3216 
3217 #ifdef ASSERT
3218   __ bind(bail);
3219   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
3220 #endif
3221 
3222   // make sure all code is generated
3223   masm-&gt;flush();
3224 
3225   // Fill-out other meta info
3226   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
3227 }
3228 
3229 //
3230 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3231 //
3232 // Generate a stub that calls into vm to find out the proper destination
3233 // of a java call. All the argument registers are live at this point
3234 // but since this is generic code we don&#39;t know what they are and the caller
3235 // must do any gc of the args.
3236 //
3237 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3238   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3239 
3240   // allocate space for the code
3241   ResourceMark rm;
3242 
3243   CodeBuffer buffer(name, 1000, 512);
3244   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3245 
3246   int frame_size_words;
3247   enum frame_layout {
3248                 thread_off,
3249                 extra_words };
3250 
3251   OopMapSet *oop_maps = new OopMapSet();
3252   OopMap* map = NULL;
3253 
3254   int start = __ offset();
3255 
3256   map = RegisterSaver::save_live_registers(masm, extra_words, &amp;frame_size_words);
3257 
3258   int frame_complete = __ offset();
3259 
3260   const Register thread = rdi;
3261   __ get_thread(rdi);
3262 
3263   __ push(thread);
3264   __ set_last_Java_frame(thread, noreg, rbp, NULL);
3265 
3266   __ call(RuntimeAddress(destination));
3267 
3268 
3269   // Set an oopmap for the call site.
3270   // We need this not only for callee-saved registers, but also for volatile
3271   // registers that the compiler might be keeping live across a safepoint.
3272 
3273   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3274 
3275   // rax, contains the address we are going to jump to assuming no exception got installed
3276 
3277   __ addptr(rsp, wordSize);
3278 
3279   // clear last_Java_sp
3280   __ reset_last_Java_frame(thread, true);
3281   // check for pending exceptions
3282   Label pending;
3283   __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
3284   __ jcc(Assembler::notEqual, pending);
3285 
3286   // get the returned Method*
3287   __ get_vm_result_2(rbx, thread);
3288   __ movptr(Address(rsp, RegisterSaver::rbx_offset() * wordSize), rbx);
3289 
3290   __ movptr(Address(rsp, RegisterSaver::rax_offset() * wordSize), rax);
3291 
3292   RegisterSaver::restore_live_registers(masm);
3293 
3294   // We are back the the original state on entry and ready to go.
3295 
3296   __ jmp(rax);
3297 
3298   // Pending exception after the safepoint
3299 
3300   __ bind(pending);
3301 
3302   RegisterSaver::restore_live_registers(masm);
3303 
3304   // exception pending =&gt; remove activation and forward to exception handler
3305 
3306   __ get_thread(thread);
3307   __ movptr(Address(thread, JavaThread::vm_result_offset()), NULL_WORD);
3308   __ movptr(rax, Address(thread, Thread::pending_exception_offset()));
3309   __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3310 
3311   // -------------
3312   // make sure all code is generated
3313   masm-&gt;flush();
3314 
3315   // return the  blob
3316   // frame_size_words or bytes??
3317   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_words, oop_maps, true);
3318 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>