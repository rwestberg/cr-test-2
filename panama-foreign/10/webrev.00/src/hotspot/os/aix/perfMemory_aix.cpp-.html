<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/aix/perfMemory_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/oop.inline.hpp&quot;
  32 #include &quot;os_aix.inline.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;runtime/os.hpp&quot;
  35 #include &quot;runtime/perfMemory.hpp&quot;
  36 #include &quot;services/memTracker.hpp&quot;
  37 #include &quot;utilities/exceptions.hpp&quot;
  38 
  39 // put OS-includes here
  40 # include &lt;sys/types.h&gt;
  41 # include &lt;sys/mman.h&gt;
  42 # include &lt;errno.h&gt;
  43 # include &lt;stdio.h&gt;
  44 # include &lt;unistd.h&gt;
  45 # include &lt;sys/stat.h&gt;
  46 # include &lt;signal.h&gt;
  47 # include &lt;pwd.h&gt;
  48 
  49 static char* backing_store_file_name = NULL;  // name of the backing store
  50                                               // file, if successfully created.
  51 
  52 // Standard Memory Implementation Details
  53 
  54 // create the PerfData memory region in standard memory.
  55 //
  56 static char* create_standard_memory(size_t size) {
  57 
  58   // allocate an aligned chuck of memory
  59   char* mapAddress = os::reserve_memory(size);
  60 
  61   if (mapAddress == NULL) {
  62     return NULL;
  63   }
  64 
  65   // commit memory
  66   if (!os::commit_memory(mapAddress, size, !ExecMem)) {
  67     if (PrintMiscellaneous &amp;&amp; Verbose) {
  68       warning(&quot;Could not commit PerfData memory\n&quot;);
  69     }
  70     os::release_memory(mapAddress, size);
  71     return NULL;
  72   }
  73 
  74   return mapAddress;
  75 }
  76 
  77 // delete the PerfData memory region
  78 //
  79 static void delete_standard_memory(char* addr, size_t size) {
  80 
  81   // there are no persistent external resources to cleanup for standard
  82   // memory. since DestroyJavaVM does not support unloading of the JVM,
  83   // cleanup of the memory resource is not performed. The memory will be
  84   // reclaimed by the OS upon termination of the process.
  85   //
  86   return;
  87 }
  88 
  89 // save the specified memory region to the given file
  90 //
  91 // Note: this function might be called from signal handler (by os::abort()),
  92 // don&#39;t allocate heap memory.
  93 //
  94 static void save_memory_to_file(char* addr, size_t size) {
  95 
  96   const char* destfile = PerfMemory::get_perfdata_file_path();
  97   assert(destfile[0] != &#39;\0&#39;, &quot;invalid PerfData file path&quot;);
  98 
  99   int result;
 100 
 101   RESTARTABLE(::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IREAD|S_IWRITE),
 102               result);;
 103   if (result == OS_ERR) {
 104     if (PrintMiscellaneous &amp;&amp; Verbose) {
 105       warning(&quot;Could not create Perfdata save file: %s: %s\n&quot;,
 106               destfile, os::strerror(errno));
 107     }
 108   } else {
 109     int fd = result;
 110 
 111     for (size_t remaining = size; remaining &gt; 0;) {
 112 
 113       RESTARTABLE(::write(fd, addr, remaining), result);
 114       if (result == OS_ERR) {
 115         if (PrintMiscellaneous &amp;&amp; Verbose) {
 116           warning(&quot;Could not write Perfdata save file: %s: %s\n&quot;,
 117                   destfile, os::strerror(errno));
 118         }
 119         break;
 120       }
 121 
 122       remaining -= (size_t)result;
 123       addr += result;
 124     }
 125 
 126     result = ::close(fd);
 127     if (PrintMiscellaneous &amp;&amp; Verbose) {
 128       if (result == OS_ERR) {
 129         warning(&quot;Could not close %s: %s\n&quot;, destfile, os::strerror(errno));
 130       }
 131     }
 132   }
 133   FREE_C_HEAP_ARRAY(char, destfile);
 134 }
 135 
 136 
 137 // Shared Memory Implementation Details
 138 
 139 // Note: the solaris and linux shared memory implementation uses the mmap
 140 // interface with a backing store file to implement named shared memory.
 141 // Using the file system as the name space for shared memory allows a
 142 // common name space to be supported across a variety of platforms. It
 143 // also provides a name space that Java applications can deal with through
 144 // simple file apis.
 145 //
 146 // The solaris and linux implementations store the backing store file in
 147 // a user specific temporary directory located in the /tmp file system,
 148 // which is always a local file system and is sometimes a RAM based file
 149 // system.
 150 
 151 // return the user specific temporary directory name.
 152 //
 153 // the caller is expected to free the allocated memory.
 154 //
 155 static char* get_user_tmp_dir(const char* user) {
 156 
 157   const char* tmpdir = os::get_temp_directory();
 158   const char* perfdir = PERFDATA_NAME;
 159   size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;
 160   char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 161 
 162   // construct the path name to user specific tmp directory
 163   snprintf(dirname, nbytes, &quot;%s/%s_%s&quot;, tmpdir, perfdir, user);
 164 
 165   return dirname;
 166 }
 167 
 168 // convert the given file name into a process id. if the file
 169 // does not meet the file naming constraints, return 0.
 170 //
 171 static pid_t filename_to_pid(const char* filename) {
 172 
 173   // a filename that doesn&#39;t begin with a digit is not a
 174   // candidate for conversion.
 175   //
 176   if (!isdigit(*filename)) {
 177     return 0;
 178   }
 179 
 180   // check if file name can be converted to an integer without
 181   // any leftover characters.
 182   //
 183   char* remainder = NULL;
 184   errno = 0;
 185   pid_t pid = (pid_t)strtol(filename, &amp;remainder, 10);
 186 
 187   if (errno != 0) {
 188     return 0;
 189   }
 190 
 191   // check for left over characters. If any, then the filename is
 192   // not a candidate for conversion.
 193   //
 194   if (remainder != NULL &amp;&amp; *remainder != &#39;\0&#39;) {
 195     return 0;
 196   }
 197 
 198   // successful conversion, return the pid
 199   return pid;
 200 }
 201 
 202 // Check if the given statbuf is considered a secure directory for
 203 // the backing store files. Returns true if the directory is considered
 204 // a secure location. Returns false if the statbuf is a symbolic link or
 205 // if an error occurred.
 206 //
 207 static bool is_statbuf_secure(struct stat *statp) {
 208   if (S_ISLNK(statp-&gt;st_mode) || !S_ISDIR(statp-&gt;st_mode)) {
 209     // The path represents a link or some non-directory file type,
 210     // which is not what we expected. Declare it insecure.
 211     //
 212     return false;
 213   }
 214   // We have an existing directory, check if the permissions are safe.
 215   //
 216   if ((statp-&gt;st_mode &amp; (S_IWGRP|S_IWOTH)) != 0) {
 217     // The directory is open for writing and could be subjected
 218     // to a symlink or a hard link attack. Declare it insecure.
 219     //
 220     return false;
 221   }
 222   // If user is not root then see if the uid of the directory matches the effective uid of the process.
 223   uid_t euid = geteuid();
 224   if ((euid != 0) &amp;&amp; (statp-&gt;st_uid != euid)) {
 225     // The directory was not created by this user, declare it insecure.
 226     //
 227     return false;
 228   }
 229   return true;
 230 }
 231 
 232 
 233 // Check if the given path is considered a secure directory for
 234 // the backing store files. Returns true if the directory exists
 235 // and is considered a secure location. Returns false if the path
 236 // is a symbolic link or if an error occurred.
 237 //
 238 static bool is_directory_secure(const char* path) {
 239   struct stat statbuf;
 240   int result = 0;
 241 
 242   RESTARTABLE(::lstat(path, &amp;statbuf), result);
 243   if (result == OS_ERR) {
 244     return false;
 245   }
 246 
 247   // The path exists, see if it is secure.
 248   return is_statbuf_secure(&amp;statbuf);
 249 }
 250 
 251 // (Taken over from Solaris to support the O_NOFOLLOW case on AIX.)
 252 // Check if the given directory file descriptor is considered a secure
 253 // directory for the backing store files. Returns true if the directory
 254 // exists and is considered a secure location. Returns false if the path
 255 // is a symbolic link or if an error occurred.
 256 static bool is_dirfd_secure(int dir_fd) {
 257   struct stat statbuf;
 258   int result = 0;
 259 
 260   RESTARTABLE(::fstat(dir_fd, &amp;statbuf), result);
 261   if (result == OS_ERR) {
 262     return false;
 263   }
 264 
 265   // The path exists, now check its mode.
 266   return is_statbuf_secure(&amp;statbuf);
 267 }
 268 
 269 
 270 // Check to make sure fd1 and fd2 are referencing the same file system object.
 271 static bool is_same_fsobject(int fd1, int fd2) {
 272   struct stat statbuf1;
 273   struct stat statbuf2;
 274   int result = 0;
 275 
 276   RESTARTABLE(::fstat(fd1, &amp;statbuf1), result);
 277   if (result == OS_ERR) {
 278     return false;
 279   }
 280   RESTARTABLE(::fstat(fd2, &amp;statbuf2), result);
 281   if (result == OS_ERR) {
 282     return false;
 283   }
 284 
 285   if ((statbuf1.st_ino == statbuf2.st_ino) &amp;&amp;
 286       (statbuf1.st_dev == statbuf2.st_dev)) {
 287     return true;
 288   } else {
 289     return false;
 290   }
 291 }
 292 
 293 // Helper functions for open without O_NOFOLLOW which is not present on AIX 5.3/6.1.
 294 // We use the jdk6 implementation here.
 295 #ifndef O_NOFOLLOW
 296 // The O_NOFOLLOW oflag doesn&#39;t exist before solaris 5.10, this is to simulate that behaviour
 297 // was done in jdk 5/6 hotspot by Oracle this way
 298 static int open_o_nofollow_impl(const char* path, int oflag, mode_t mode, bool use_mode) {
 299   struct stat orig_st;
 300   struct stat new_st;
 301   bool create;
 302   int error;
 303   int fd;
 304   int result;
 305 
 306   create = false;
 307 
 308   RESTARTABLE(::lstat(path, &amp;orig_st), result);
 309 
 310   if (result == OS_ERR) {
 311     if (errno == ENOENT &amp;&amp; (oflag &amp; O_CREAT) != 0) {
 312       // File doesn&#39;t exist, but_we want to create it, add O_EXCL flag
 313       // to make sure no-one creates it (or a symlink) before us
 314       // This works as we expect with symlinks, from posix man page:
 315       // &#39;If O_EXCL  and  O_CREAT  are set, and path names a symbolic
 316       // link, open() shall fail and set errno to [EEXIST]&#39;.
 317       oflag |= O_EXCL;
 318       create = true;
 319     } else {
 320       // File doesn&#39;t exist, and we are not creating it.
 321       return OS_ERR;
 322     }
 323   } else {
 324     // lstat success, check if existing file is a link.
 325     if ((orig_st.st_mode &amp; S_IFMT) == S_IFLNK)  {
 326       // File is a symlink.
 327       errno = ELOOP;
 328       return OS_ERR;
 329     }
 330   }
 331 
 332   if (use_mode == true) {
 333     RESTARTABLE(::open(path, oflag, mode), fd);
 334   } else {
 335     RESTARTABLE(::open(path, oflag), fd);
 336   }
 337 
 338   if (fd == OS_ERR) {
 339     return fd;
 340   }
 341 
 342   // Can&#39;t do inode checks on before/after if we created the file.
 343   if (create == false) {
 344     RESTARTABLE(::fstat(fd, &amp;new_st), result);
 345     if (result == OS_ERR) {
 346       // Keep errno from fstat, in case close also fails.
 347       error = errno;
 348       ::close(fd);
 349       errno = error;
 350       return OS_ERR;
 351     }
 352 
 353     if (orig_st.st_dev != new_st.st_dev || orig_st.st_ino != new_st.st_ino) {
 354       // File was tampered with during race window.
 355       ::close(fd);
 356       errno = EEXIST;
 357       if (PrintMiscellaneous &amp;&amp; Verbose) {
 358         warning(&quot;possible file tampering attempt detected when opening %s&quot;, path);
 359       }
 360       return OS_ERR;
 361     }
 362   }
 363 
 364   return fd;
 365 }
 366 
 367 static int open_o_nofollow(const char* path, int oflag, mode_t mode) {
 368   return open_o_nofollow_impl(path, oflag, mode, true);
 369 }
 370 
 371 static int open_o_nofollow(const char* path, int oflag) {
 372   return open_o_nofollow_impl(path, oflag, 0, false);
 373 }
 374 #endif
 375 
 376 // Open the directory of the given path and validate it.
 377 // Return a DIR * of the open directory.
 378 static DIR *open_directory_secure(const char* dirname) {
 379   // Open the directory using open() so that it can be verified
 380   // to be secure by calling is_dirfd_secure(), opendir() and then check
 381   // to see if they are the same file system object.  This method does not
 382   // introduce a window of opportunity for the directory to be attacked that
 383   // calling opendir() and is_directory_secure() does.
 384   int result;
 385   DIR *dirp = NULL;
 386 
 387   // No O_NOFOLLOW defined at buildtime, and it is not documented for open;
 388   // so provide a workaround in this case.
 389 #ifdef O_NOFOLLOW
 390   RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);
 391 #else
 392   // workaround (jdk6 coding)
 393   result = open_o_nofollow(dirname, O_RDONLY);
 394 #endif
 395 
 396   if (result == OS_ERR) {
 397     // Directory doesn&#39;t exist or is a symlink, so there is nothing to cleanup.
 398     if (PrintMiscellaneous &amp;&amp; Verbose) {
 399       if (errno == ELOOP) {
 400         warning(&quot;directory %s is a symlink and is not secure\n&quot;, dirname);
 401       } else {
 402         warning(&quot;could not open directory %s: %s\n&quot;, dirname, os::strerror(errno));
 403       }
 404     }
 405     return dirp;
 406   }
 407   int fd = result;
 408 
 409   // Determine if the open directory is secure.
 410   if (!is_dirfd_secure(fd)) {
 411     // The directory is not a secure directory.
 412     os::close(fd);
 413     return dirp;
 414   }
 415 
 416   // Open the directory.
 417   dirp = ::opendir(dirname);
 418   if (dirp == NULL) {
 419     // The directory doesn&#39;t exist, close fd and return.
 420     os::close(fd);
 421     return dirp;
 422   }
 423 
 424   // Check to make sure fd and dirp are referencing the same file system object.
 425   if (!is_same_fsobject(fd, dirp-&gt;dd_fd)) {
 426     // The directory is not secure.
 427     os::close(fd);
 428     os::closedir(dirp);
 429     dirp = NULL;
 430     return dirp;
 431   }
 432 
 433   // Close initial open now that we know directory is secure
 434   os::close(fd);
 435 
 436   return dirp;
 437 }
 438 
 439 // NOTE: The code below uses fchdir(), open() and unlink() because
 440 // fdopendir(), openat() and unlinkat() are not supported on all
 441 // versions.  Once the support for fdopendir(), openat() and unlinkat()
 442 // is available on all supported versions the code can be changed
 443 // to use these functions.
 444 
 445 // Open the directory of the given path, validate it and set the
 446 // current working directory to it.
 447 // Return a DIR * of the open directory and the saved cwd fd.
 448 //
 449 static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {
 450 
 451   // Open the directory.
 452   DIR* dirp = open_directory_secure(dirname);
 453   if (dirp == NULL) {
 454     // Directory doesn&#39;t exist or is insecure, so there is nothing to cleanup.
 455     return dirp;
 456   }
 457   int fd = dirp-&gt;dd_fd;
 458 
 459   // Open a fd to the cwd and save it off.
 460   int result;
 461   RESTARTABLE(::open(&quot;.&quot;, O_RDONLY), result);
 462   if (result == OS_ERR) {
 463     *saved_cwd_fd = -1;
 464   } else {
 465     *saved_cwd_fd = result;
 466   }
 467 
 468   // Set the current directory to dirname by using the fd of the directory and
 469   // handle errors, otherwise shared memory files will be created in cwd.
 470   result = fchdir(fd);
 471   if (result == OS_ERR) {
 472     if (PrintMiscellaneous &amp;&amp; Verbose) {
 473       warning(&quot;could not change to directory %s&quot;, dirname);
 474     }
 475     if (*saved_cwd_fd != -1) {
 476       ::close(*saved_cwd_fd);
 477       *saved_cwd_fd = -1;
 478     }
 479     // Close the directory.
 480     os::closedir(dirp);
 481     return NULL;
 482   } else {
 483     return dirp;
 484   }
 485 }
 486 
 487 // Close the directory and restore the current working directory.
 488 //
 489 static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {
 490 
 491   int result;
 492   // If we have a saved cwd change back to it and close the fd.
 493   if (saved_cwd_fd != -1) {
 494     result = fchdir(saved_cwd_fd);
 495     ::close(saved_cwd_fd);
 496   }
 497 
 498   // Close the directory.
 499   os::closedir(dirp);
 500 }
 501 
 502 // Check if the given file descriptor is considered a secure.
 503 static bool is_file_secure(int fd, const char *filename) {
 504 
 505   int result;
 506   struct stat statbuf;
 507 
 508   // Determine if the file is secure.
 509   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
 510   if (result == OS_ERR) {
 511     if (PrintMiscellaneous &amp;&amp; Verbose) {
 512       warning(&quot;fstat failed on %s: %s\n&quot;, filename, os::strerror(errno));
 513     }
 514     return false;
 515   }
 516   if (statbuf.st_nlink &gt; 1) {
 517     // A file with multiple links is not expected.
 518     if (PrintMiscellaneous &amp;&amp; Verbose) {
 519       warning(&quot;file %s has multiple links\n&quot;, filename);
 520     }
 521     return false;
 522   }
 523   return true;
 524 }
 525 
 526 // Return the user name for the given user id.
 527 //
 528 // The caller is expected to free the allocated memory.
 529 static char* get_user_name(uid_t uid) {
 530 
 531   struct passwd pwent;
 532 
 533   // Determine the max pwbuf size from sysconf, and hardcode
 534   // a default if this not available through sysconf.
 535   long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);
 536   if (bufsize == -1)
 537     bufsize = 1024;
 538 
 539   char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);
 540 
 541   struct passwd* p;
 542   int result = getpwuid_r(uid, &amp;pwent, pwbuf, (size_t)bufsize, &amp;p);
 543 
 544   if (result != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
 545     if (PrintMiscellaneous &amp;&amp; Verbose) {
 546       if (result != 0) {
 547         warning(&quot;Could not retrieve passwd entry: %s\n&quot;,
 548                 os::strerror(result));
 549       }
 550       else if (p == NULL) {
 551         // this check is added to protect against an observed problem
 552         // with getpwuid_r() on RedHat 9 where getpwuid_r returns 0,
 553         // indicating success, but has p == NULL. This was observed when
 554         // inserting a file descriptor exhaustion fault prior to the call
 555         // getpwuid_r() call. In this case, error is set to the appropriate
 556         // error condition, but this is undocumented behavior. This check
 557         // is safe under any condition, but the use of errno in the output
 558         // message may result in an erroneous message.
 559         // Bug Id 89052 was opened with RedHat.
 560         //
 561         warning(&quot;Could not retrieve passwd entry: %s\n&quot;,
 562                 os::strerror(errno));
 563       }
 564       else {
 565         warning(&quot;Could not determine user name: %s\n&quot;,
 566                 p-&gt;pw_name == NULL ? &quot;pw_name = NULL&quot; :
 567                                      &quot;pw_name zero length&quot;);
 568       }
 569     }
 570     FREE_C_HEAP_ARRAY(char, pwbuf);
 571     return NULL;
 572   }
 573 
 574   char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p-&gt;pw_name) + 1, mtInternal);
 575   strcpy(user_name, p-&gt;pw_name);
 576 
 577   FREE_C_HEAP_ARRAY(char, pwbuf);
 578   return user_name;
 579 }
 580 
 581 // return the name of the user that owns the process identified by vmid.
 582 //
 583 // This method uses a slow directory search algorithm to find the backing
 584 // store file for the specified vmid and returns the user name, as determined
 585 // by the user name suffix of the hsperfdata_&lt;username&gt; directory name.
 586 //
 587 // the caller is expected to free the allocated memory.
 588 //
 589 static char* get_user_name_slow(int vmid, TRAPS) {
 590 
 591   // short circuit the directory search if the process doesn&#39;t even exist.
 592   if (kill(vmid, 0) == OS_ERR) {
 593     if (errno == ESRCH) {
 594       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 595                   &quot;Process not found&quot;);
 596     }
 597     else /* EPERM */ {
 598       THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));
 599     }
 600   }
 601 
 602   // directory search
 603   char* oldest_user = NULL;
 604   time_t oldest_ctime = 0;
 605 
 606   const char* tmpdirname = os::get_temp_directory();
 607 
 608   DIR* tmpdirp = os::opendir(tmpdirname);
 609 
 610   if (tmpdirp == NULL) {
 611     return NULL;
 612   }
 613 
 614   // for each entry in the directory that matches the pattern hsperfdata_*,
 615   // open the directory and check if the file for the given vmid exists.
 616   // The file with the expected name and the latest creation date is used
 617   // to determine the user name for the process id.
 618   //
 619   struct dirent* dentry;
 620   errno = 0;
 621   while ((dentry = os::readdir(tmpdirp)) != NULL) {
 622 
 623     // check if the directory entry is a hsperfdata file
 624     if (strncmp(dentry-&gt;d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {
 625       continue;
 626     }
 627 
 628     char* usrdir_name = NEW_C_HEAP_ARRAY(char,
 629                               strlen(tmpdirname) + strlen(dentry-&gt;d_name) + 2, mtInternal);
 630     strcpy(usrdir_name, tmpdirname);
 631     strcat(usrdir_name, &quot;/&quot;);
 632     strcat(usrdir_name, dentry-&gt;d_name);
 633 
 634     // Open the user directory.
 635     DIR* subdirp = open_directory_secure(usrdir_name);
 636 
 637     if (subdirp == NULL) {
 638       FREE_C_HEAP_ARRAY(char, usrdir_name);
 639       continue;
 640     }
 641 
 642     // Since we don&#39;t create the backing store files in directories
 643     // pointed to by symbolic links, we also don&#39;t follow them when
 644     // looking for the files. We check for a symbolic link after the
 645     // call to opendir in order to eliminate a small window where the
 646     // symlink can be exploited.
 647     //
 648     if (!is_directory_secure(usrdir_name)) {
 649       FREE_C_HEAP_ARRAY(char, usrdir_name);
 650       os::closedir(subdirp);
 651       continue;
 652     }
 653 
 654     struct dirent* udentry;
 655     errno = 0;
 656     while ((udentry = os::readdir(subdirp)) != NULL) {
 657 
 658       if (filename_to_pid(udentry-&gt;d_name) == vmid) {
 659         struct stat statbuf;
 660         int result;
 661 
 662         char* filename = NEW_C_HEAP_ARRAY(char,
 663                             strlen(usrdir_name) + strlen(udentry-&gt;d_name) + 2, mtInternal);
 664 
 665         strcpy(filename, usrdir_name);
 666         strcat(filename, &quot;/&quot;);
 667         strcat(filename, udentry-&gt;d_name);
 668 
 669         // don&#39;t follow symbolic links for the file
 670         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 671         if (result == OS_ERR) {
 672            FREE_C_HEAP_ARRAY(char, filename);
 673            continue;
 674         }
 675 
 676         // skip over files that are not regular files.
 677         if (!S_ISREG(statbuf.st_mode)) {
 678           FREE_C_HEAP_ARRAY(char, filename);
 679           continue;
 680         }
 681 
 682         // compare and save filename with latest creation time
 683         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 684 
 685           if (statbuf.st_ctime &gt; oldest_ctime) {
 686             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 687 
 688             FREE_C_HEAP_ARRAY(char, oldest_user);
 689             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 690 
 691             strcpy(oldest_user, user);
 692             oldest_ctime = statbuf.st_ctime;
 693           }
 694         }
 695 
 696         FREE_C_HEAP_ARRAY(char, filename);
 697       }
 698     }
 699     os::closedir(subdirp);
 700     FREE_C_HEAP_ARRAY(char, usrdir_name);
 701   }
 702   os::closedir(tmpdirp);
 703 
 704   return(oldest_user);
 705 }
 706 
 707 // return the name of the user that owns the JVM indicated by the given vmid.
 708 //
 709 static char* get_user_name(int vmid, TRAPS) {
 710   return get_user_name_slow(vmid, THREAD);
 711 }
 712 
 713 // return the file name of the backing store file for the named
 714 // shared memory region for the given user name and vmid.
 715 //
 716 // the caller is expected to free the allocated memory.
 717 //
 718 static char* get_sharedmem_filename(const char* dirname, int vmid) {
 719 
 720   // add 2 for the file separator and a null terminator.
 721   size_t nbytes = strlen(dirname) + UINT_CHARS + 2;
 722 
 723   char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 724   snprintf(name, nbytes, &quot;%s/%d&quot;, dirname, vmid);
 725 
 726   return name;
 727 }
 728 
 729 
 730 // remove file
 731 //
 732 // this method removes the file specified by the given path
 733 //
 734 static void remove_file(const char* path) {
 735 
 736   int result;
 737 
 738   // if the file is a directory, the following unlink will fail. since
 739   // we don&#39;t expect to find directories in the user temp directory, we
 740   // won&#39;t try to handle this situation. even if accidentially or
 741   // maliciously planted, the directory&#39;s presence won&#39;t hurt anything.
 742   //
 743   RESTARTABLE(::unlink(path), result);
 744   if (PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; result == OS_ERR) {
 745     if (errno != ENOENT) {
 746       warning(&quot;Could not unlink shared memory backing&quot;
 747               &quot; store file %s : %s\n&quot;, path, os::strerror(errno));
 748     }
 749   }
 750 }
 751 
 752 // Cleanup stale shared memory resources
 753 //
 754 // This method attempts to remove all stale shared memory files in
 755 // the named user temporary directory. It scans the named directory
 756 // for files matching the pattern ^$[0-9]*$. For each file found, the
 757 // process id is extracted from the file name and a test is run to
 758 // determine if the process is alive. If the process is not alive,
 759 // any stale file resources are removed.
 760 static void cleanup_sharedmem_resources(const char* dirname) {
 761 
 762   int saved_cwd_fd;
 763   // Open the directory.
 764   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 765   if (dirp == NULL) {
 766      // Directory doesn&#39;t exist or is insecure, so there is nothing to cleanup.
 767     return;
 768   }
 769 
 770   // For each entry in the directory that matches the expected file
 771   // name pattern, determine if the file resources are stale and if
 772   // so, remove the file resources. Note, instrumented HotSpot processes
 773   // for this user may start and/or terminate during this search and
 774   // remove or create new files in this directory. The behavior of this
 775   // loop under these conditions is dependent upon the implementation of
 776   // opendir/readdir.
 777   struct dirent* entry;
 778   errno = 0;
 779   while ((entry = os::readdir(dirp)) != NULL) {
 780 
 781     pid_t pid = filename_to_pid(entry-&gt;d_name);
 782 
 783     if (pid == 0) {
 784 
 785       if (strcmp(entry-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry-&gt;d_name, &quot;..&quot;) != 0) {
 786 
 787         // Attempt to remove all unexpected files, except &quot;.&quot; and &quot;..&quot;.
 788         unlink(entry-&gt;d_name);
 789       }
 790 
 791       errno = 0;
 792       continue;
 793     }
 794 
 795     // We now have a file name that converts to a valid integer
 796     // that could represent a process id . if this process id
 797     // matches the current process id or the process is not running,
 798     // then remove the stale file resources.
 799     //
 800     // Process liveness is detected by sending signal number 0 to
 801     // the process id (see kill(2)). if kill determines that the
 802     // process does not exist, then the file resources are removed.
 803     // if kill determines that that we don&#39;t have permission to
 804     // signal the process, then the file resources are assumed to
 805     // be stale and are removed because the resources for such a
 806     // process should be in a different user specific directory.
 807     if ((pid == os::current_process_id()) ||
 808         (kill(pid, 0) == OS_ERR &amp;&amp; (errno == ESRCH || errno == EPERM))) {
 809 
 810         unlink(entry-&gt;d_name);
 811     }
 812     errno = 0;
 813   }
 814 
 815   // Close the directory and reset the current working directory.
 816   close_directory_secure_cwd(dirp, saved_cwd_fd);
 817 }
 818 
 819 // Make the user specific temporary directory. Returns true if
 820 // the directory exists and is secure upon return. Returns false
 821 // if the directory exists but is either a symlink, is otherwise
 822 // insecure, or if an error occurred.
 823 static bool make_user_tmp_dir(const char* dirname) {
 824 
 825   // Create the directory with 0755 permissions. note that the directory
 826   // will be owned by euid::egid, which may not be the same as uid::gid.
 827   if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {
 828     if (errno == EEXIST) {
 829       // The directory already exists and was probably created by another
 830       // JVM instance. However, this could also be the result of a
 831       // deliberate symlink. Verify that the existing directory is safe.
 832       if (!is_directory_secure(dirname)) {
 833         // Directory is not secure.
 834         if (PrintMiscellaneous &amp;&amp; Verbose) {
 835           warning(&quot;%s directory is insecure\n&quot;, dirname);
 836         }
 837         return false;
 838       }
 839     }
 840     else {
 841       // we encountered some other failure while attempting
 842       // to create the directory
 843       //
 844       if (PrintMiscellaneous &amp;&amp; Verbose) {
 845         warning(&quot;could not create directory %s: %s\n&quot;,
 846                 dirname, os::strerror(errno));
 847       }
 848       return false;
 849     }
 850   }
 851   return true;
 852 }
 853 
 854 // create the shared memory file resources
 855 //
 856 // This method creates the shared memory file with the given size
 857 // This method also creates the user specific temporary directory, if
 858 // it does not yet exist.
 859 //
 860 static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {
 861 
 862   // make the user temporary directory
 863   if (!make_user_tmp_dir(dirname)) {
 864     // could not make/find the directory or the found directory
 865     // was not secure
 866     return -1;
 867   }
 868 
 869   int saved_cwd_fd;
 870   // Open the directory and set the current working directory to it.
 871   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 872   if (dirp == NULL) {
 873     // Directory doesn&#39;t exist or is insecure, so cannot create shared
 874     // memory file.
 875     return -1;
 876   }
 877 
 878   // Open the filename in the current directory.
 879   // Cannot use O_TRUNC here; truncation of an existing file has to happen
 880   // after the is_file_secure() check below.
 881   int result;
 882 
 883   // No O_NOFOLLOW defined at buildtime, and it is not documented for open;
 884   // so provide a workaround in this case.
 885 #ifdef O_NOFOLLOW
 886   RESTARTABLE(::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IREAD|S_IWRITE), result);
 887 #else
 888   // workaround function (jdk6 code)
 889   result = open_o_nofollow(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
 890 #endif
 891 
 892   if (result == OS_ERR) {
 893     if (PrintMiscellaneous &amp;&amp; Verbose) {
 894       if (errno == ELOOP) {
 895         warning(&quot;file %s is a symlink and is not secure\n&quot;, filename);
 896       } else {
 897         warning(&quot;could not create file %s: %s\n&quot;, filename, os::strerror(errno));
 898       }
 899     }
 900     // Close the directory and reset the current working directory.
 901     close_directory_secure_cwd(dirp, saved_cwd_fd);
 902 
 903     return -1;
 904   }
 905   // Close the directory and reset the current working directory.
 906   close_directory_secure_cwd(dirp, saved_cwd_fd);
 907 
 908   // save the file descriptor
 909   int fd = result;
 910 
 911   // Check to see if the file is secure.
 912   if (!is_file_secure(fd, filename)) {
 913     ::close(fd);
 914     return -1;
 915   }
 916 
 917   // Truncate the file to get rid of any existing data.
 918   RESTARTABLE(::ftruncate(fd, (off_t)0), result);
 919   if (result == OS_ERR) {
 920     if (PrintMiscellaneous &amp;&amp; Verbose) {
 921       warning(&quot;could not truncate shared memory file: %s\n&quot;, os::strerror(errno));
 922     }
 923     ::close(fd);
 924     return -1;
 925   }
 926   // set the file size
 927   RESTARTABLE(::ftruncate(fd, (off_t)size), result);
 928   if (result == OS_ERR) {
 929     if (PrintMiscellaneous &amp;&amp; Verbose) {
 930       warning(&quot;could not set shared memory file size: %s\n&quot;, os::strerror(errno));
 931     }
 932     ::close(fd);
 933     return -1;
 934   }
 935 
 936   return fd;
 937 }
 938 
 939 // open the shared memory file for the given user and vmid. returns
 940 // the file descriptor for the open file or -1 if the file could not
 941 // be opened.
 942 //
 943 static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {
 944 
 945   // open the file
 946   int result;
 947   // provide a workaround in case no O_NOFOLLOW is defined at buildtime
 948 #ifdef O_NOFOLLOW
 949   RESTARTABLE(::open(filename, oflags), result);
 950 #else
 951   result = open_o_nofollow(filename, oflags);
 952 #endif
 953   if (result == OS_ERR) {
 954     if (errno == ENOENT) {
 955       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 956                  &quot;Process not found&quot;, OS_ERR);
 957     }
 958     else if (errno == EACCES) {
 959       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 960                  &quot;Permission denied&quot;, OS_ERR);
 961     }
 962     else {
 963       THROW_MSG_(vmSymbols::java_io_IOException(),
 964                  os::strerror(errno), OS_ERR);
 965     }
 966   }
 967   int fd = result;
 968 
 969   // Check to see if the file is secure.
 970   if (!is_file_secure(fd, filename)) {
 971     ::close(fd);
 972     return -1;
 973   }
 974 
 975   return fd;
 976 }
 977 
 978 // create a named shared memory region. returns the address of the
 979 // memory region on success or NULL on failure. A return value of
 980 // NULL will ultimately disable the shared memory feature.
 981 //
 982 // On AIX, the name space for shared memory objects
 983 // is the file system name space.
 984 //
 985 // A monitoring application attaching to a JVM does not need to know
 986 // the file system name of the shared memory object. However, it may
 987 // be convenient for applications to discover the existence of newly
 988 // created and terminating JVMs by watching the file system name space
 989 // for files being created or removed.
 990 //
 991 static char* mmap_create_shared(size_t size) {
 992 
 993   int result;
 994   int fd;
 995   char* mapAddress;
 996 
 997   int vmid = os::current_process_id();
 998 
 999   char* user_name = get_user_name(geteuid());
1000 
1001   if (user_name == NULL)
1002     return NULL;
1003 
1004   char* dirname = get_user_tmp_dir(user_name);
1005   char* filename = get_sharedmem_filename(dirname, vmid);
1006 
1007   // get the short filename.
1008   char* short_filename = strrchr(filename, &#39;/&#39;);
1009   if (short_filename == NULL) {
1010     short_filename = filename;
1011   } else {
1012     short_filename++;
1013   }
1014 
1015   // cleanup any stale shared memory files
1016   cleanup_sharedmem_resources(dirname);
1017 
1018   assert(((size &gt; 0) &amp;&amp; (size % os::vm_page_size() == 0)),
1019          &quot;unexpected PerfMemory region size&quot;);
1020 
1021   fd = create_sharedmem_resources(dirname, short_filename, size);
1022 
1023   FREE_C_HEAP_ARRAY(char, user_name);
1024   FREE_C_HEAP_ARRAY(char, dirname);
1025 
1026   if (fd == -1) {
1027     FREE_C_HEAP_ARRAY(char, filename);
1028     return NULL;
1029   }
1030 
1031   mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
1032 
1033   result = ::close(fd);
1034   assert(result != OS_ERR, &quot;could not close file&quot;);
1035 
1036   if (mapAddress == MAP_FAILED) {
1037     if (PrintMiscellaneous &amp;&amp; Verbose) {
1038       warning(&quot;mmap failed -  %s\n&quot;, os::strerror(errno));
1039     }
1040     remove_file(filename);
1041     FREE_C_HEAP_ARRAY(char, filename);
1042     return NULL;
1043   }
1044 
1045   // save the file name for use in delete_shared_memory()
1046   backing_store_file_name = filename;
1047 
1048   // clear the shared memory region
1049   (void)::memset((void*) mapAddress, 0, size);
1050 
1051   // It does not go through os api, the operation has to record from here.
1052   MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);
1053 
1054   return mapAddress;
1055 }
1056 
1057 // release a named shared memory region
1058 //
1059 static void unmap_shared(char* addr, size_t bytes) {
1060   // Do not rely on os::reserve_memory/os::release_memory to use mmap.
1061   // Use os::reserve_memory/os::release_memory for PerfDisableSharedMem=1, mmap/munmap for PerfDisableSharedMem=0
1062   if (::munmap(addr, bytes) == -1) {
1063     warning(&quot;perfmemory: munmap failed (%d)\n&quot;, errno);
1064   }
1065 }
1066 
1067 // create the PerfData memory region in shared memory.
1068 //
1069 static char* create_shared_memory(size_t size) {
1070 
1071   // create the shared memory region.
1072   return mmap_create_shared(size);
1073 }
1074 
1075 // delete the shared PerfData memory region
1076 //
1077 static void delete_shared_memory(char* addr, size_t size) {
1078 
1079   // cleanup the persistent shared memory resources. since DestroyJavaVM does
1080   // not support unloading of the JVM, unmapping of the memory resource is
1081   // not performed. The memory will be reclaimed by the OS upon termination of
1082   // the process. The backing store file is deleted from the file system.
1083 
1084   assert(!PerfDisableSharedMem, &quot;shouldn&#39;t be here&quot;);
1085 
1086   if (backing_store_file_name != NULL) {
1087     remove_file(backing_store_file_name);
1088     // Don&#39;t.. Free heap memory could deadlock os::abort() if it is called
1089     // from signal handler. OS will reclaim the heap memory.
1090     // FREE_C_HEAP_ARRAY(char, backing_store_file_name);
1091     backing_store_file_name = NULL;
1092   }
1093 }
1094 
1095 // return the size of the file for the given file descriptor
1096 // or 0 if it is not a valid size for a shared memory file
1097 //
1098 static size_t sharedmem_filesize(int fd, TRAPS) {
1099 
1100   struct stat statbuf;
1101   int result;
1102 
1103   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1104   if (result == OS_ERR) {
1105     if (PrintMiscellaneous &amp;&amp; Verbose) {
1106       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1107     }
1108     THROW_MSG_0(vmSymbols::java_io_IOException(),
1109                 &quot;Could not determine PerfMemory size&quot;);
1110   }
1111 
1112   if ((statbuf.st_size == 0) ||
1113      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
1114     THROW_MSG_0(vmSymbols::java_io_IOException(),
1115                 &quot;Invalid PerfMemory size&quot;);
1116   }
1117 
1118   return (size_t)statbuf.st_size;
1119 }
1120 
1121 // attach to a named shared memory region.
1122 //
1123 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1124 
1125   char* mapAddress;
1126   int result;
1127   int fd;
1128   size_t size = 0;
1129   const char* luser = NULL;
1130 
1131   int mmap_prot;
1132   int file_flags;
1133 
1134   ResourceMark rm;
1135 
1136   // map the high level access mode to the appropriate permission
1137   // constructs for the file and the shared memory mapping.
1138   if (mode == PerfMemory::PERF_MODE_RO) {
1139     mmap_prot = PROT_READ;
1140   // No O_NOFOLLOW defined at buildtime, and it is not documented for open.
1141 #ifdef O_NOFOLLOW
1142     file_flags = O_RDONLY | O_NOFOLLOW;
1143 #else
1144     file_flags = O_RDONLY;
1145 #endif
1146   }
1147   else if (mode == PerfMemory::PERF_MODE_RW) {
1148 #ifdef LATER
1149     mmap_prot = PROT_READ | PROT_WRITE;
1150     file_flags = O_RDWR | O_NOFOLLOW;
1151 #else
1152     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1153               &quot;Unsupported access mode&quot;);
1154 #endif
1155   }
1156   else {
1157     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1158               &quot;Illegal access mode&quot;);
1159   }
1160 
1161   if (user == NULL || strlen(user) == 0) {
1162     luser = get_user_name(vmid, CHECK);
1163   }
1164   else {
1165     luser = user;
1166   }
1167 
1168   if (luser == NULL) {
1169     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1170               &quot;Could not map vmid to user Name&quot;);
1171   }
1172 
1173   char* dirname = get_user_tmp_dir(luser);
1174 
1175   // since we don&#39;t follow symbolic links when creating the backing
1176   // store file, we don&#39;t follow them when attaching either.
1177   //
1178   if (!is_directory_secure(dirname)) {
1179     FREE_C_HEAP_ARRAY(char, dirname);
1180     if (luser != user) {
1181       FREE_C_HEAP_ARRAY(char, luser);
1182     }
1183     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1184               &quot;Process not found&quot;);
1185   }
1186 
1187   char* filename = get_sharedmem_filename(dirname, vmid);
1188 
1189   // copy heap memory to resource memory. the open_sharedmem_file
1190   // method below need to use the filename, but could throw an
1191   // exception. using a resource array prevents the leak that
1192   // would otherwise occur.
1193   char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);
1194   strcpy(rfilename, filename);
1195 
1196   // free the c heap resources that are no longer needed
1197   if (luser != user) FREE_C_HEAP_ARRAY(char, luser);
1198   FREE_C_HEAP_ARRAY(char, dirname);
1199   FREE_C_HEAP_ARRAY(char, filename);
1200 
1201   // open the shared memory file for the give vmid
1202   fd = open_sharedmem_file(rfilename, file_flags, THREAD);
1203 
1204   if (fd == OS_ERR) {
1205     return;
1206   }
1207 
1208   if (HAS_PENDING_EXCEPTION) {
1209     ::close(fd);
1210     return;
1211   }
1212 
1213   if (*sizep == 0) {
1214     size = sharedmem_filesize(fd, CHECK);
1215   } else {
1216     size = *sizep;
1217   }
1218 
1219   assert(size &gt; 0, &quot;unexpected size &lt;= 0&quot;);
1220 
1221   mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);
1222 
1223   result = ::close(fd);
1224   assert(result != OS_ERR, &quot;could not close file&quot;);
1225 
1226   if (mapAddress == MAP_FAILED) {
1227     if (PrintMiscellaneous &amp;&amp; Verbose) {
1228       warning(&quot;mmap failed: %s\n&quot;, os::strerror(errno));
1229     }
1230     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
1231               &quot;Could not map PerfMemory&quot;);
1232   }
1233 
1234   // it does not go through os api, the operation has to record from here.
1235   MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);
1236 
1237   *addr = mapAddress;
1238   *sizep = size;
1239 
1240   log_debug(perf, memops)(&quot;mapped &quot; SIZE_FORMAT &quot; bytes for vmid %d at &quot;
1241                           INTPTR_FORMAT, size, vmid, p2i((void*)mapAddress));
1242 }
1243 
1244 // create the PerfData memory region
1245 //
1246 // This method creates the memory region used to store performance
1247 // data for the JVM. The memory may be created in standard or
1248 // shared memory.
1249 //
1250 void PerfMemory::create_memory_region(size_t size) {
1251 
1252   if (PerfDisableSharedMem) {
1253     // do not share the memory for the performance data.
1254     _start = create_standard_memory(size);
1255   }
1256   else {
1257     _start = create_shared_memory(size);
1258     if (_start == NULL) {
1259 
1260       // creation of the shared memory region failed, attempt
1261       // to create a contiguous, non-shared memory region instead.
1262       //
1263       if (PrintMiscellaneous &amp;&amp; Verbose) {
1264         warning(&quot;Reverting to non-shared PerfMemory region.\n&quot;);
1265       }
1266       PerfDisableSharedMem = true;
1267       _start = create_standard_memory(size);
1268     }
1269   }
1270 
1271   if (_start != NULL) _capacity = size;
1272 
1273 }
1274 
1275 // delete the PerfData memory region
1276 //
1277 // This method deletes the memory region used to store performance
1278 // data for the JVM. The memory region indicated by the &lt;address, size&gt;
1279 // tuple will be inaccessible after a call to this method.
1280 //
1281 void PerfMemory::delete_memory_region() {
1282 
1283   assert((start() != NULL &amp;&amp; capacity() &gt; 0), &quot;verify proper state&quot;);
1284 
1285   // If user specifies PerfDataSaveFile, it will save the performance data
1286   // to the specified file name no matter whether PerfDataSaveToFile is specified
1287   // or not. In other word, -XX:PerfDataSaveFile=.. overrides flag
1288   // -XX:+PerfDataSaveToFile.
1289   if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {
1290     save_memory_to_file(start(), capacity());
1291   }
1292 
1293   if (PerfDisableSharedMem) {
1294     delete_standard_memory(start(), capacity());
1295   }
1296   else {
1297     delete_shared_memory(start(), capacity());
1298   }
1299 }
1300 
1301 // attach to the PerfData memory region for another JVM
1302 //
1303 // This method returns an &lt;address, size&gt; tuple that points to
1304 // a memory buffer that is kept reasonably synchronized with
1305 // the PerfData memory region for the indicated JVM. This
1306 // buffer may be kept in synchronization via shared memory
1307 // or some other mechanism that keeps the buffer updated.
1308 //
1309 // If the JVM chooses not to support the attachability feature,
1310 // this method should throw an UnsupportedOperation exception.
1311 //
1312 // This implementation utilizes named shared memory to map
1313 // the indicated process&#39;s PerfData memory region into this JVMs
1314 // address space.
1315 //
1316 void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {
1317 
1318   if (vmid == 0 || vmid == os::current_process_id()) {
1319      *addrp = start();
1320      *sizep = capacity();
1321      return;
1322   }
1323 
1324   mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);
1325 }
1326 
1327 // detach from the PerfData memory region of another JVM
1328 //
1329 // This method detaches the PerfData memory region of another
1330 // JVM, specified as an &lt;address, size&gt; tuple of a buffer
1331 // in this process&#39;s address space. This method may perform
1332 // arbitrary actions to accomplish the detachment. The memory
1333 // region specified by &lt;address, size&gt; will be inaccessible after
1334 // a call to this method.
1335 //
1336 // If the JVM chooses not to support the attachability feature,
1337 // this method should throw an UnsupportedOperation exception.
1338 //
1339 // This implementation utilizes named shared memory to detach
1340 // the indicated process&#39;s PerfData memory region from this
1341 // process&#39;s address space.
1342 //
1343 void PerfMemory::detach(char* addr, size_t bytes, TRAPS) {
1344 
1345   assert(addr != 0, &quot;address sanity check&quot;);
1346   assert(bytes &gt; 0, &quot;capacity sanity check&quot;);
1347 
1348   if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {
1349     // prevent accidental detachment of this process&#39;s PerfMemory region
1350     return;
1351   }
1352 
1353   unmap_shared(addr, bytes);
1354 }
    </pre>
  </body>
</html>