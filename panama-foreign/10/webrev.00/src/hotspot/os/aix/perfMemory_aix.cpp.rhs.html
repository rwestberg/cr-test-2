<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os/aix/perfMemory_aix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2012, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;oops/oop.inline.hpp&quot;
  32 #include &quot;os_aix.inline.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;runtime/os.hpp&quot;
  35 #include &quot;runtime/perfMemory.hpp&quot;
  36 #include &quot;services/memTracker.hpp&quot;
  37 #include &quot;utilities/exceptions.hpp&quot;
  38 
  39 // put OS-includes here
  40 # include &lt;sys/types.h&gt;
  41 # include &lt;sys/mman.h&gt;
  42 # include &lt;errno.h&gt;
  43 # include &lt;stdio.h&gt;
  44 # include &lt;unistd.h&gt;
  45 # include &lt;sys/stat.h&gt;
  46 # include &lt;signal.h&gt;
  47 # include &lt;pwd.h&gt;
  48 
  49 static char* backing_store_file_name = NULL;  // name of the backing store
  50                                               // file, if successfully created.
  51 
  52 // Standard Memory Implementation Details
  53 
  54 // create the PerfData memory region in standard memory.
  55 //
  56 static char* create_standard_memory(size_t size) {
  57 
  58   // allocate an aligned chuck of memory
  59   char* mapAddress = os::reserve_memory(size);
  60 
  61   if (mapAddress == NULL) {
  62     return NULL;
  63   }
  64 
  65   // commit memory
  66   if (!os::commit_memory(mapAddress, size, !ExecMem)) {
  67     if (PrintMiscellaneous &amp;&amp; Verbose) {
  68       warning(&quot;Could not commit PerfData memory\n&quot;);
  69     }
  70     os::release_memory(mapAddress, size);
  71     return NULL;
  72   }
  73 
  74   return mapAddress;
  75 }
  76 
  77 // delete the PerfData memory region
  78 //
  79 static void delete_standard_memory(char* addr, size_t size) {
  80 
  81   // there are no persistent external resources to cleanup for standard
  82   // memory. since DestroyJavaVM does not support unloading of the JVM,
  83   // cleanup of the memory resource is not performed. The memory will be
  84   // reclaimed by the OS upon termination of the process.
  85   //
  86   return;
  87 }
  88 
  89 // save the specified memory region to the given file
  90 //
  91 // Note: this function might be called from signal handler (by os::abort()),
  92 // don&#39;t allocate heap memory.
  93 //
  94 static void save_memory_to_file(char* addr, size_t size) {
  95 
  96   const char* destfile = PerfMemory::get_perfdata_file_path();
  97   assert(destfile[0] != &#39;\0&#39;, &quot;invalid PerfData file path&quot;);
  98 
  99   int result;
 100 
<a name="2" id="anc2"></a><span class="line-modified"> 101   RESTARTABLE(os::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IREAD|S_IWRITE),</span>
<span class="line-modified"> 102               result);</span>
 103   if (result == OS_ERR) {
 104     if (PrintMiscellaneous &amp;&amp; Verbose) {
 105       warning(&quot;Could not create Perfdata save file: %s: %s\n&quot;,
 106               destfile, os::strerror(errno));
 107     }
 108   } else {
 109     int fd = result;
 110 
 111     for (size_t remaining = size; remaining &gt; 0;) {
 112 
 113       RESTARTABLE(::write(fd, addr, remaining), result);
 114       if (result == OS_ERR) {
 115         if (PrintMiscellaneous &amp;&amp; Verbose) {
 116           warning(&quot;Could not write Perfdata save file: %s: %s\n&quot;,
 117                   destfile, os::strerror(errno));
 118         }
 119         break;
 120       }
 121 
 122       remaining -= (size_t)result;
 123       addr += result;
 124     }
 125 
 126     result = ::close(fd);
 127     if (PrintMiscellaneous &amp;&amp; Verbose) {
 128       if (result == OS_ERR) {
 129         warning(&quot;Could not close %s: %s\n&quot;, destfile, os::strerror(errno));
 130       }
 131     }
 132   }
 133   FREE_C_HEAP_ARRAY(char, destfile);
 134 }
 135 
 136 
 137 // Shared Memory Implementation Details
 138 
 139 // Note: the solaris and linux shared memory implementation uses the mmap
 140 // interface with a backing store file to implement named shared memory.
 141 // Using the file system as the name space for shared memory allows a
 142 // common name space to be supported across a variety of platforms. It
 143 // also provides a name space that Java applications can deal with through
 144 // simple file apis.
 145 //
 146 // The solaris and linux implementations store the backing store file in
 147 // a user specific temporary directory located in the /tmp file system,
 148 // which is always a local file system and is sometimes a RAM based file
 149 // system.
 150 
 151 // return the user specific temporary directory name.
 152 //
 153 // the caller is expected to free the allocated memory.
 154 //
 155 static char* get_user_tmp_dir(const char* user) {
 156 
 157   const char* tmpdir = os::get_temp_directory();
 158   const char* perfdir = PERFDATA_NAME;
 159   size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;
 160   char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 161 
 162   // construct the path name to user specific tmp directory
 163   snprintf(dirname, nbytes, &quot;%s/%s_%s&quot;, tmpdir, perfdir, user);
 164 
 165   return dirname;
 166 }
 167 
 168 // convert the given file name into a process id. if the file
 169 // does not meet the file naming constraints, return 0.
 170 //
 171 static pid_t filename_to_pid(const char* filename) {
 172 
 173   // a filename that doesn&#39;t begin with a digit is not a
 174   // candidate for conversion.
 175   //
 176   if (!isdigit(*filename)) {
 177     return 0;
 178   }
 179 
 180   // check if file name can be converted to an integer without
 181   // any leftover characters.
 182   //
 183   char* remainder = NULL;
 184   errno = 0;
 185   pid_t pid = (pid_t)strtol(filename, &amp;remainder, 10);
 186 
 187   if (errno != 0) {
 188     return 0;
 189   }
 190 
 191   // check for left over characters. If any, then the filename is
 192   // not a candidate for conversion.
 193   //
 194   if (remainder != NULL &amp;&amp; *remainder != &#39;\0&#39;) {
 195     return 0;
 196   }
 197 
 198   // successful conversion, return the pid
 199   return pid;
 200 }
 201 
 202 // Check if the given statbuf is considered a secure directory for
 203 // the backing store files. Returns true if the directory is considered
 204 // a secure location. Returns false if the statbuf is a symbolic link or
 205 // if an error occurred.
 206 //
 207 static bool is_statbuf_secure(struct stat *statp) {
 208   if (S_ISLNK(statp-&gt;st_mode) || !S_ISDIR(statp-&gt;st_mode)) {
 209     // The path represents a link or some non-directory file type,
 210     // which is not what we expected. Declare it insecure.
 211     //
 212     return false;
 213   }
 214   // We have an existing directory, check if the permissions are safe.
 215   //
 216   if ((statp-&gt;st_mode &amp; (S_IWGRP|S_IWOTH)) != 0) {
 217     // The directory is open for writing and could be subjected
 218     // to a symlink or a hard link attack. Declare it insecure.
 219     //
 220     return false;
 221   }
 222   // If user is not root then see if the uid of the directory matches the effective uid of the process.
 223   uid_t euid = geteuid();
 224   if ((euid != 0) &amp;&amp; (statp-&gt;st_uid != euid)) {
 225     // The directory was not created by this user, declare it insecure.
 226     //
 227     return false;
 228   }
 229   return true;
 230 }
 231 
 232 
 233 // Check if the given path is considered a secure directory for
 234 // the backing store files. Returns true if the directory exists
 235 // and is considered a secure location. Returns false if the path
 236 // is a symbolic link or if an error occurred.
 237 //
 238 static bool is_directory_secure(const char* path) {
 239   struct stat statbuf;
 240   int result = 0;
 241 
 242   RESTARTABLE(::lstat(path, &amp;statbuf), result);
 243   if (result == OS_ERR) {
 244     return false;
 245   }
 246 
 247   // The path exists, see if it is secure.
 248   return is_statbuf_secure(&amp;statbuf);
 249 }
 250 
<a name="3" id="anc3"></a>
 251 // Check if the given directory file descriptor is considered a secure
 252 // directory for the backing store files. Returns true if the directory
 253 // exists and is considered a secure location. Returns false if the path
 254 // is a symbolic link or if an error occurred.
 255 static bool is_dirfd_secure(int dir_fd) {
 256   struct stat statbuf;
 257   int result = 0;
 258 
 259   RESTARTABLE(::fstat(dir_fd, &amp;statbuf), result);
 260   if (result == OS_ERR) {
 261     return false;
 262   }
 263 
 264   // The path exists, now check its mode.
 265   return is_statbuf_secure(&amp;statbuf);
 266 }
 267 
 268 
 269 // Check to make sure fd1 and fd2 are referencing the same file system object.
 270 static bool is_same_fsobject(int fd1, int fd2) {
 271   struct stat statbuf1;
 272   struct stat statbuf2;
 273   int result = 0;
 274 
 275   RESTARTABLE(::fstat(fd1, &amp;statbuf1), result);
 276   if (result == OS_ERR) {
 277     return false;
 278   }
 279   RESTARTABLE(::fstat(fd2, &amp;statbuf2), result);
 280   if (result == OS_ERR) {
 281     return false;
 282   }
 283 
 284   if ((statbuf1.st_ino == statbuf2.st_ino) &amp;&amp;
 285       (statbuf1.st_dev == statbuf2.st_dev)) {
 286     return true;
 287   } else {
 288     return false;
 289   }
 290 }
 291 
<a name="4" id="anc4"></a>


















































































 292 // Open the directory of the given path and validate it.
 293 // Return a DIR * of the open directory.
 294 static DIR *open_directory_secure(const char* dirname) {
 295   // Open the directory using open() so that it can be verified
 296   // to be secure by calling is_dirfd_secure(), opendir() and then check
 297   // to see if they are the same file system object.  This method does not
 298   // introduce a window of opportunity for the directory to be attacked that
 299   // calling opendir() and is_directory_secure() does.
 300   int result;
 301   DIR *dirp = NULL;
<a name="5" id="anc5"></a>



 302   RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);
<a name="6" id="anc6"></a>



 303 
 304   if (result == OS_ERR) {
 305     // Directory doesn&#39;t exist or is a symlink, so there is nothing to cleanup.
 306     if (PrintMiscellaneous &amp;&amp; Verbose) {
 307       if (errno == ELOOP) {
 308         warning(&quot;directory %s is a symlink and is not secure\n&quot;, dirname);
 309       } else {
 310         warning(&quot;could not open directory %s: %s\n&quot;, dirname, os::strerror(errno));
 311       }
 312     }
 313     return dirp;
 314   }
 315   int fd = result;
 316 
 317   // Determine if the open directory is secure.
 318   if (!is_dirfd_secure(fd)) {
 319     // The directory is not a secure directory.
 320     os::close(fd);
 321     return dirp;
 322   }
 323 
 324   // Open the directory.
 325   dirp = ::opendir(dirname);
 326   if (dirp == NULL) {
 327     // The directory doesn&#39;t exist, close fd and return.
 328     os::close(fd);
 329     return dirp;
 330   }
 331 
 332   // Check to make sure fd and dirp are referencing the same file system object.
 333   if (!is_same_fsobject(fd, dirp-&gt;dd_fd)) {
 334     // The directory is not secure.
 335     os::close(fd);
 336     os::closedir(dirp);
 337     dirp = NULL;
 338     return dirp;
 339   }
 340 
 341   // Close initial open now that we know directory is secure
 342   os::close(fd);
 343 
 344   return dirp;
 345 }
 346 
 347 // NOTE: The code below uses fchdir(), open() and unlink() because
 348 // fdopendir(), openat() and unlinkat() are not supported on all
 349 // versions.  Once the support for fdopendir(), openat() and unlinkat()
 350 // is available on all supported versions the code can be changed
 351 // to use these functions.
 352 
 353 // Open the directory of the given path, validate it and set the
 354 // current working directory to it.
 355 // Return a DIR * of the open directory and the saved cwd fd.
 356 //
 357 static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {
 358 
 359   // Open the directory.
 360   DIR* dirp = open_directory_secure(dirname);
 361   if (dirp == NULL) {
 362     // Directory doesn&#39;t exist or is insecure, so there is nothing to cleanup.
 363     return dirp;
 364   }
 365   int fd = dirp-&gt;dd_fd;
 366 
 367   // Open a fd to the cwd and save it off.
 368   int result;
 369   RESTARTABLE(::open(&quot;.&quot;, O_RDONLY), result);
 370   if (result == OS_ERR) {
 371     *saved_cwd_fd = -1;
 372   } else {
 373     *saved_cwd_fd = result;
 374   }
 375 
 376   // Set the current directory to dirname by using the fd of the directory and
 377   // handle errors, otherwise shared memory files will be created in cwd.
 378   result = fchdir(fd);
 379   if (result == OS_ERR) {
 380     if (PrintMiscellaneous &amp;&amp; Verbose) {
 381       warning(&quot;could not change to directory %s&quot;, dirname);
 382     }
 383     if (*saved_cwd_fd != -1) {
 384       ::close(*saved_cwd_fd);
 385       *saved_cwd_fd = -1;
 386     }
 387     // Close the directory.
 388     os::closedir(dirp);
 389     return NULL;
 390   } else {
 391     return dirp;
 392   }
 393 }
 394 
 395 // Close the directory and restore the current working directory.
 396 //
 397 static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {
 398 
 399   int result;
 400   // If we have a saved cwd change back to it and close the fd.
 401   if (saved_cwd_fd != -1) {
 402     result = fchdir(saved_cwd_fd);
 403     ::close(saved_cwd_fd);
 404   }
 405 
 406   // Close the directory.
 407   os::closedir(dirp);
 408 }
 409 
 410 // Check if the given file descriptor is considered a secure.
 411 static bool is_file_secure(int fd, const char *filename) {
 412 
 413   int result;
 414   struct stat statbuf;
 415 
 416   // Determine if the file is secure.
 417   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
 418   if (result == OS_ERR) {
 419     if (PrintMiscellaneous &amp;&amp; Verbose) {
 420       warning(&quot;fstat failed on %s: %s\n&quot;, filename, os::strerror(errno));
 421     }
 422     return false;
 423   }
 424   if (statbuf.st_nlink &gt; 1) {
 425     // A file with multiple links is not expected.
 426     if (PrintMiscellaneous &amp;&amp; Verbose) {
 427       warning(&quot;file %s has multiple links\n&quot;, filename);
 428     }
 429     return false;
 430   }
 431   return true;
 432 }
 433 
 434 // Return the user name for the given user id.
 435 //
 436 // The caller is expected to free the allocated memory.
 437 static char* get_user_name(uid_t uid) {
 438 
 439   struct passwd pwent;
 440 
 441   // Determine the max pwbuf size from sysconf, and hardcode
 442   // a default if this not available through sysconf.
 443   long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);
 444   if (bufsize == -1)
 445     bufsize = 1024;
 446 
 447   char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);
 448 
 449   struct passwd* p;
 450   int result = getpwuid_r(uid, &amp;pwent, pwbuf, (size_t)bufsize, &amp;p);
 451 
 452   if (result != 0 || p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
 453     if (PrintMiscellaneous &amp;&amp; Verbose) {
 454       if (result != 0) {
 455         warning(&quot;Could not retrieve passwd entry: %s\n&quot;,
 456                 os::strerror(result));
 457       }
 458       else if (p == NULL) {
 459         // this check is added to protect against an observed problem
 460         // with getpwuid_r() on RedHat 9 where getpwuid_r returns 0,
 461         // indicating success, but has p == NULL. This was observed when
 462         // inserting a file descriptor exhaustion fault prior to the call
 463         // getpwuid_r() call. In this case, error is set to the appropriate
 464         // error condition, but this is undocumented behavior. This check
 465         // is safe under any condition, but the use of errno in the output
 466         // message may result in an erroneous message.
 467         // Bug Id 89052 was opened with RedHat.
 468         //
 469         warning(&quot;Could not retrieve passwd entry: %s\n&quot;,
 470                 os::strerror(errno));
 471       }
 472       else {
 473         warning(&quot;Could not determine user name: %s\n&quot;,
 474                 p-&gt;pw_name == NULL ? &quot;pw_name = NULL&quot; :
 475                                      &quot;pw_name zero length&quot;);
 476       }
 477     }
 478     FREE_C_HEAP_ARRAY(char, pwbuf);
 479     return NULL;
 480   }
 481 
 482   char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p-&gt;pw_name) + 1, mtInternal);
 483   strcpy(user_name, p-&gt;pw_name);
 484 
 485   FREE_C_HEAP_ARRAY(char, pwbuf);
 486   return user_name;
 487 }
 488 
 489 // return the name of the user that owns the process identified by vmid.
 490 //
 491 // This method uses a slow directory search algorithm to find the backing
 492 // store file for the specified vmid and returns the user name, as determined
 493 // by the user name suffix of the hsperfdata_&lt;username&gt; directory name.
 494 //
 495 // the caller is expected to free the allocated memory.
 496 //
 497 static char* get_user_name_slow(int vmid, TRAPS) {
 498 
 499   // short circuit the directory search if the process doesn&#39;t even exist.
 500   if (kill(vmid, 0) == OS_ERR) {
 501     if (errno == ESRCH) {
 502       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 503                   &quot;Process not found&quot;);
 504     }
 505     else /* EPERM */ {
 506       THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));
 507     }
 508   }
 509 
 510   // directory search
 511   char* oldest_user = NULL;
 512   time_t oldest_ctime = 0;
 513 
 514   const char* tmpdirname = os::get_temp_directory();
 515 
 516   DIR* tmpdirp = os::opendir(tmpdirname);
 517 
 518   if (tmpdirp == NULL) {
 519     return NULL;
 520   }
 521 
 522   // for each entry in the directory that matches the pattern hsperfdata_*,
 523   // open the directory and check if the file for the given vmid exists.
 524   // The file with the expected name and the latest creation date is used
 525   // to determine the user name for the process id.
 526   //
 527   struct dirent* dentry;
 528   errno = 0;
 529   while ((dentry = os::readdir(tmpdirp)) != NULL) {
 530 
 531     // check if the directory entry is a hsperfdata file
 532     if (strncmp(dentry-&gt;d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {
 533       continue;
 534     }
 535 
 536     char* usrdir_name = NEW_C_HEAP_ARRAY(char,
 537                               strlen(tmpdirname) + strlen(dentry-&gt;d_name) + 2, mtInternal);
 538     strcpy(usrdir_name, tmpdirname);
 539     strcat(usrdir_name, &quot;/&quot;);
 540     strcat(usrdir_name, dentry-&gt;d_name);
 541 
 542     // Open the user directory.
 543     DIR* subdirp = open_directory_secure(usrdir_name);
 544 
 545     if (subdirp == NULL) {
 546       FREE_C_HEAP_ARRAY(char, usrdir_name);
 547       continue;
 548     }
 549 
 550     // Since we don&#39;t create the backing store files in directories
 551     // pointed to by symbolic links, we also don&#39;t follow them when
 552     // looking for the files. We check for a symbolic link after the
 553     // call to opendir in order to eliminate a small window where the
 554     // symlink can be exploited.
 555     //
 556     if (!is_directory_secure(usrdir_name)) {
 557       FREE_C_HEAP_ARRAY(char, usrdir_name);
 558       os::closedir(subdirp);
 559       continue;
 560     }
 561 
 562     struct dirent* udentry;
 563     errno = 0;
 564     while ((udentry = os::readdir(subdirp)) != NULL) {
 565 
 566       if (filename_to_pid(udentry-&gt;d_name) == vmid) {
 567         struct stat statbuf;
 568         int result;
 569 
 570         char* filename = NEW_C_HEAP_ARRAY(char,
 571                             strlen(usrdir_name) + strlen(udentry-&gt;d_name) + 2, mtInternal);
 572 
 573         strcpy(filename, usrdir_name);
 574         strcat(filename, &quot;/&quot;);
 575         strcat(filename, udentry-&gt;d_name);
 576 
 577         // don&#39;t follow symbolic links for the file
 578         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 579         if (result == OS_ERR) {
 580            FREE_C_HEAP_ARRAY(char, filename);
 581            continue;
 582         }
 583 
 584         // skip over files that are not regular files.
 585         if (!S_ISREG(statbuf.st_mode)) {
 586           FREE_C_HEAP_ARRAY(char, filename);
 587           continue;
 588         }
 589 
 590         // compare and save filename with latest creation time
 591         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 592 
 593           if (statbuf.st_ctime &gt; oldest_ctime) {
 594             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 595 
 596             FREE_C_HEAP_ARRAY(char, oldest_user);
 597             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 598 
 599             strcpy(oldest_user, user);
 600             oldest_ctime = statbuf.st_ctime;
 601           }
 602         }
 603 
 604         FREE_C_HEAP_ARRAY(char, filename);
 605       }
 606     }
 607     os::closedir(subdirp);
 608     FREE_C_HEAP_ARRAY(char, usrdir_name);
 609   }
 610   os::closedir(tmpdirp);
 611 
 612   return(oldest_user);
 613 }
 614 
 615 // return the name of the user that owns the JVM indicated by the given vmid.
 616 //
 617 static char* get_user_name(int vmid, TRAPS) {
 618   return get_user_name_slow(vmid, THREAD);
 619 }
 620 
 621 // return the file name of the backing store file for the named
 622 // shared memory region for the given user name and vmid.
 623 //
 624 // the caller is expected to free the allocated memory.
 625 //
 626 static char* get_sharedmem_filename(const char* dirname, int vmid) {
 627 
 628   // add 2 for the file separator and a null terminator.
 629   size_t nbytes = strlen(dirname) + UINT_CHARS + 2;
 630 
 631   char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 632   snprintf(name, nbytes, &quot;%s/%d&quot;, dirname, vmid);
 633 
 634   return name;
 635 }
 636 
 637 
 638 // remove file
 639 //
 640 // this method removes the file specified by the given path
 641 //
 642 static void remove_file(const char* path) {
 643 
 644   int result;
 645 
 646   // if the file is a directory, the following unlink will fail. since
 647   // we don&#39;t expect to find directories in the user temp directory, we
 648   // won&#39;t try to handle this situation. even if accidentially or
 649   // maliciously planted, the directory&#39;s presence won&#39;t hurt anything.
 650   //
 651   RESTARTABLE(::unlink(path), result);
 652   if (PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; result == OS_ERR) {
 653     if (errno != ENOENT) {
 654       warning(&quot;Could not unlink shared memory backing&quot;
 655               &quot; store file %s : %s\n&quot;, path, os::strerror(errno));
 656     }
 657   }
 658 }
 659 
 660 // Cleanup stale shared memory resources
 661 //
 662 // This method attempts to remove all stale shared memory files in
 663 // the named user temporary directory. It scans the named directory
 664 // for files matching the pattern ^$[0-9]*$. For each file found, the
 665 // process id is extracted from the file name and a test is run to
 666 // determine if the process is alive. If the process is not alive,
 667 // any stale file resources are removed.
 668 static void cleanup_sharedmem_resources(const char* dirname) {
 669 
 670   int saved_cwd_fd;
 671   // Open the directory.
 672   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 673   if (dirp == NULL) {
 674      // Directory doesn&#39;t exist or is insecure, so there is nothing to cleanup.
 675     return;
 676   }
 677 
 678   // For each entry in the directory that matches the expected file
 679   // name pattern, determine if the file resources are stale and if
 680   // so, remove the file resources. Note, instrumented HotSpot processes
 681   // for this user may start and/or terminate during this search and
 682   // remove or create new files in this directory. The behavior of this
 683   // loop under these conditions is dependent upon the implementation of
 684   // opendir/readdir.
 685   struct dirent* entry;
 686   errno = 0;
 687   while ((entry = os::readdir(dirp)) != NULL) {
 688 
 689     pid_t pid = filename_to_pid(entry-&gt;d_name);
 690 
 691     if (pid == 0) {
 692 
 693       if (strcmp(entry-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry-&gt;d_name, &quot;..&quot;) != 0) {
 694 
 695         // Attempt to remove all unexpected files, except &quot;.&quot; and &quot;..&quot;.
 696         unlink(entry-&gt;d_name);
 697       }
 698 
 699       errno = 0;
 700       continue;
 701     }
 702 
 703     // We now have a file name that converts to a valid integer
 704     // that could represent a process id . if this process id
 705     // matches the current process id or the process is not running,
 706     // then remove the stale file resources.
 707     //
 708     // Process liveness is detected by sending signal number 0 to
 709     // the process id (see kill(2)). if kill determines that the
 710     // process does not exist, then the file resources are removed.
 711     // if kill determines that that we don&#39;t have permission to
 712     // signal the process, then the file resources are assumed to
 713     // be stale and are removed because the resources for such a
 714     // process should be in a different user specific directory.
 715     if ((pid == os::current_process_id()) ||
 716         (kill(pid, 0) == OS_ERR &amp;&amp; (errno == ESRCH || errno == EPERM))) {
 717 
 718         unlink(entry-&gt;d_name);
 719     }
 720     errno = 0;
 721   }
 722 
 723   // Close the directory and reset the current working directory.
 724   close_directory_secure_cwd(dirp, saved_cwd_fd);
 725 }
 726 
 727 // Make the user specific temporary directory. Returns true if
 728 // the directory exists and is secure upon return. Returns false
 729 // if the directory exists but is either a symlink, is otherwise
 730 // insecure, or if an error occurred.
 731 static bool make_user_tmp_dir(const char* dirname) {
 732 
 733   // Create the directory with 0755 permissions. note that the directory
 734   // will be owned by euid::egid, which may not be the same as uid::gid.
 735   if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {
 736     if (errno == EEXIST) {
 737       // The directory already exists and was probably created by another
 738       // JVM instance. However, this could also be the result of a
 739       // deliberate symlink. Verify that the existing directory is safe.
 740       if (!is_directory_secure(dirname)) {
 741         // Directory is not secure.
 742         if (PrintMiscellaneous &amp;&amp; Verbose) {
 743           warning(&quot;%s directory is insecure\n&quot;, dirname);
 744         }
 745         return false;
 746       }
 747     }
 748     else {
 749       // we encountered some other failure while attempting
 750       // to create the directory
 751       //
 752       if (PrintMiscellaneous &amp;&amp; Verbose) {
 753         warning(&quot;could not create directory %s: %s\n&quot;,
 754                 dirname, os::strerror(errno));
 755       }
 756       return false;
 757     }
 758   }
 759   return true;
 760 }
 761 
 762 // create the shared memory file resources
 763 //
 764 // This method creates the shared memory file with the given size
 765 // This method also creates the user specific temporary directory, if
 766 // it does not yet exist.
 767 //
 768 static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {
 769 
 770   // make the user temporary directory
 771   if (!make_user_tmp_dir(dirname)) {
 772     // could not make/find the directory or the found directory
 773     // was not secure
 774     return -1;
 775   }
 776 
 777   int saved_cwd_fd;
 778   // Open the directory and set the current working directory to it.
 779   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 780   if (dirp == NULL) {
 781     // Directory doesn&#39;t exist or is insecure, so cannot create shared
 782     // memory file.
 783     return -1;
 784   }
 785 
 786   // Open the filename in the current directory.
 787   // Cannot use O_TRUNC here; truncation of an existing file has to happen
 788   // after the is_file_secure() check below.
 789   int result;
<a name="7" id="anc7"></a><span class="line-modified"> 790   RESTARTABLE(os::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IREAD|S_IWRITE), result);</span>








 791 
 792   if (result == OS_ERR) {
 793     if (PrintMiscellaneous &amp;&amp; Verbose) {
 794       if (errno == ELOOP) {
 795         warning(&quot;file %s is a symlink and is not secure\n&quot;, filename);
 796       } else {
 797         warning(&quot;could not create file %s: %s\n&quot;, filename, os::strerror(errno));
 798       }
 799     }
 800     // Close the directory and reset the current working directory.
 801     close_directory_secure_cwd(dirp, saved_cwd_fd);
 802 
 803     return -1;
 804   }
 805   // Close the directory and reset the current working directory.
 806   close_directory_secure_cwd(dirp, saved_cwd_fd);
 807 
 808   // save the file descriptor
 809   int fd = result;
 810 
 811   // Check to see if the file is secure.
 812   if (!is_file_secure(fd, filename)) {
 813     ::close(fd);
 814     return -1;
 815   }
 816 
 817   // Truncate the file to get rid of any existing data.
 818   RESTARTABLE(::ftruncate(fd, (off_t)0), result);
 819   if (result == OS_ERR) {
 820     if (PrintMiscellaneous &amp;&amp; Verbose) {
 821       warning(&quot;could not truncate shared memory file: %s\n&quot;, os::strerror(errno));
 822     }
 823     ::close(fd);
 824     return -1;
 825   }
 826   // set the file size
 827   RESTARTABLE(::ftruncate(fd, (off_t)size), result);
 828   if (result == OS_ERR) {
 829     if (PrintMiscellaneous &amp;&amp; Verbose) {
 830       warning(&quot;could not set shared memory file size: %s\n&quot;, os::strerror(errno));
 831     }
 832     ::close(fd);
 833     return -1;
 834   }
 835 
 836   return fd;
 837 }
 838 
 839 // open the shared memory file for the given user and vmid. returns
 840 // the file descriptor for the open file or -1 if the file could not
 841 // be opened.
 842 //
 843 static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {
 844 
 845   // open the file
 846   int result;
<a name="8" id="anc8"></a><span class="line-modified"> 847   RESTARTABLE(os::open(filename, oflags, 0), result);</span>
<span class="line-modified"> 848 </span>




 849   if (result == OS_ERR) {
 850     if (errno == ENOENT) {
 851       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 852                  &quot;Process not found&quot;, OS_ERR);
 853     }
 854     else if (errno == EACCES) {
 855       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 856                  &quot;Permission denied&quot;, OS_ERR);
 857     }
 858     else {
 859       THROW_MSG_(vmSymbols::java_io_IOException(),
 860                  os::strerror(errno), OS_ERR);
 861     }
 862   }
 863   int fd = result;
 864 
 865   // Check to see if the file is secure.
 866   if (!is_file_secure(fd, filename)) {
 867     ::close(fd);
 868     return -1;
 869   }
 870 
 871   return fd;
 872 }
 873 
 874 // create a named shared memory region. returns the address of the
 875 // memory region on success or NULL on failure. A return value of
 876 // NULL will ultimately disable the shared memory feature.
 877 //
 878 // On AIX, the name space for shared memory objects
 879 // is the file system name space.
 880 //
 881 // A monitoring application attaching to a JVM does not need to know
 882 // the file system name of the shared memory object. However, it may
 883 // be convenient for applications to discover the existence of newly
 884 // created and terminating JVMs by watching the file system name space
 885 // for files being created or removed.
 886 //
 887 static char* mmap_create_shared(size_t size) {
 888 
 889   int result;
 890   int fd;
 891   char* mapAddress;
 892 
 893   int vmid = os::current_process_id();
 894 
 895   char* user_name = get_user_name(geteuid());
 896 
 897   if (user_name == NULL)
 898     return NULL;
 899 
 900   char* dirname = get_user_tmp_dir(user_name);
 901   char* filename = get_sharedmem_filename(dirname, vmid);
 902 
 903   // get the short filename.
 904   char* short_filename = strrchr(filename, &#39;/&#39;);
 905   if (short_filename == NULL) {
 906     short_filename = filename;
 907   } else {
 908     short_filename++;
 909   }
 910 
 911   // cleanup any stale shared memory files
 912   cleanup_sharedmem_resources(dirname);
 913 
 914   assert(((size &gt; 0) &amp;&amp; (size % os::vm_page_size() == 0)),
 915          &quot;unexpected PerfMemory region size&quot;);
 916 
 917   fd = create_sharedmem_resources(dirname, short_filename, size);
 918 
 919   FREE_C_HEAP_ARRAY(char, user_name);
 920   FREE_C_HEAP_ARRAY(char, dirname);
 921 
 922   if (fd == -1) {
 923     FREE_C_HEAP_ARRAY(char, filename);
 924     return NULL;
 925   }
 926 
 927   mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
 928 
 929   result = ::close(fd);
 930   assert(result != OS_ERR, &quot;could not close file&quot;);
 931 
 932   if (mapAddress == MAP_FAILED) {
 933     if (PrintMiscellaneous &amp;&amp; Verbose) {
 934       warning(&quot;mmap failed -  %s\n&quot;, os::strerror(errno));
 935     }
 936     remove_file(filename);
 937     FREE_C_HEAP_ARRAY(char, filename);
 938     return NULL;
 939   }
 940 
 941   // save the file name for use in delete_shared_memory()
 942   backing_store_file_name = filename;
 943 
 944   // clear the shared memory region
 945   (void)::memset((void*) mapAddress, 0, size);
 946 
 947   // It does not go through os api, the operation has to record from here.
 948   MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);
 949 
 950   return mapAddress;
 951 }
 952 
 953 // release a named shared memory region
 954 //
 955 static void unmap_shared(char* addr, size_t bytes) {
 956   // Do not rely on os::reserve_memory/os::release_memory to use mmap.
 957   // Use os::reserve_memory/os::release_memory for PerfDisableSharedMem=1, mmap/munmap for PerfDisableSharedMem=0
 958   if (::munmap(addr, bytes) == -1) {
 959     warning(&quot;perfmemory: munmap failed (%d)\n&quot;, errno);
 960   }
 961 }
 962 
 963 // create the PerfData memory region in shared memory.
 964 //
 965 static char* create_shared_memory(size_t size) {
 966 
 967   // create the shared memory region.
 968   return mmap_create_shared(size);
 969 }
 970 
 971 // delete the shared PerfData memory region
 972 //
 973 static void delete_shared_memory(char* addr, size_t size) {
 974 
 975   // cleanup the persistent shared memory resources. since DestroyJavaVM does
 976   // not support unloading of the JVM, unmapping of the memory resource is
 977   // not performed. The memory will be reclaimed by the OS upon termination of
 978   // the process. The backing store file is deleted from the file system.
 979 
 980   assert(!PerfDisableSharedMem, &quot;shouldn&#39;t be here&quot;);
 981 
 982   if (backing_store_file_name != NULL) {
 983     remove_file(backing_store_file_name);
 984     // Don&#39;t.. Free heap memory could deadlock os::abort() if it is called
 985     // from signal handler. OS will reclaim the heap memory.
 986     // FREE_C_HEAP_ARRAY(char, backing_store_file_name);
 987     backing_store_file_name = NULL;
 988   }
 989 }
 990 
 991 // return the size of the file for the given file descriptor
 992 // or 0 if it is not a valid size for a shared memory file
 993 //
 994 static size_t sharedmem_filesize(int fd, TRAPS) {
 995 
 996   struct stat statbuf;
 997   int result;
 998 
 999   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1000   if (result == OS_ERR) {
1001     if (PrintMiscellaneous &amp;&amp; Verbose) {
1002       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1003     }
1004     THROW_MSG_0(vmSymbols::java_io_IOException(),
1005                 &quot;Could not determine PerfMemory size&quot;);
1006   }
1007 
1008   if ((statbuf.st_size == 0) ||
1009      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
1010     THROW_MSG_0(vmSymbols::java_io_IOException(),
1011                 &quot;Invalid PerfMemory size&quot;);
1012   }
1013 
1014   return (size_t)statbuf.st_size;
1015 }
1016 
1017 // attach to a named shared memory region.
1018 //
1019 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1020 
1021   char* mapAddress;
1022   int result;
1023   int fd;
1024   size_t size = 0;
1025   const char* luser = NULL;
1026 
1027   int mmap_prot;
1028   int file_flags;
1029 
1030   ResourceMark rm;
1031 
1032   // map the high level access mode to the appropriate permission
1033   // constructs for the file and the shared memory mapping.
1034   if (mode == PerfMemory::PERF_MODE_RO) {
1035     mmap_prot = PROT_READ;
<a name="9" id="anc9"></a>

1036     file_flags = O_RDONLY | O_NOFOLLOW;
<a name="10" id="anc10"></a>


1037   }
1038   else if (mode == PerfMemory::PERF_MODE_RW) {
1039 #ifdef LATER
1040     mmap_prot = PROT_READ | PROT_WRITE;
1041     file_flags = O_RDWR | O_NOFOLLOW;
1042 #else
1043     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1044               &quot;Unsupported access mode&quot;);
1045 #endif
1046   }
1047   else {
1048     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1049               &quot;Illegal access mode&quot;);
1050   }
1051 
1052   if (user == NULL || strlen(user) == 0) {
1053     luser = get_user_name(vmid, CHECK);
1054   }
1055   else {
1056     luser = user;
1057   }
1058 
1059   if (luser == NULL) {
1060     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1061               &quot;Could not map vmid to user Name&quot;);
1062   }
1063 
1064   char* dirname = get_user_tmp_dir(luser);
1065 
1066   // since we don&#39;t follow symbolic links when creating the backing
1067   // store file, we don&#39;t follow them when attaching either.
1068   //
1069   if (!is_directory_secure(dirname)) {
1070     FREE_C_HEAP_ARRAY(char, dirname);
1071     if (luser != user) {
1072       FREE_C_HEAP_ARRAY(char, luser);
1073     }
1074     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1075               &quot;Process not found&quot;);
1076   }
1077 
1078   char* filename = get_sharedmem_filename(dirname, vmid);
1079 
1080   // copy heap memory to resource memory. the open_sharedmem_file
1081   // method below need to use the filename, but could throw an
1082   // exception. using a resource array prevents the leak that
1083   // would otherwise occur.
1084   char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);
1085   strcpy(rfilename, filename);
1086 
1087   // free the c heap resources that are no longer needed
1088   if (luser != user) FREE_C_HEAP_ARRAY(char, luser);
1089   FREE_C_HEAP_ARRAY(char, dirname);
1090   FREE_C_HEAP_ARRAY(char, filename);
1091 
1092   // open the shared memory file for the give vmid
1093   fd = open_sharedmem_file(rfilename, file_flags, THREAD);
1094 
1095   if (fd == OS_ERR) {
1096     return;
1097   }
1098 
1099   if (HAS_PENDING_EXCEPTION) {
1100     ::close(fd);
1101     return;
1102   }
1103 
1104   if (*sizep == 0) {
1105     size = sharedmem_filesize(fd, CHECK);
1106   } else {
1107     size = *sizep;
1108   }
1109 
1110   assert(size &gt; 0, &quot;unexpected size &lt;= 0&quot;);
1111 
1112   mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);
1113 
1114   result = ::close(fd);
1115   assert(result != OS_ERR, &quot;could not close file&quot;);
1116 
1117   if (mapAddress == MAP_FAILED) {
1118     if (PrintMiscellaneous &amp;&amp; Verbose) {
1119       warning(&quot;mmap failed: %s\n&quot;, os::strerror(errno));
1120     }
1121     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
1122               &quot;Could not map PerfMemory&quot;);
1123   }
1124 
1125   // it does not go through os api, the operation has to record from here.
1126   MemTracker::record_virtual_memory_reserve((address)mapAddress, size, CURRENT_PC, mtInternal);
1127 
1128   *addr = mapAddress;
1129   *sizep = size;
1130 
1131   log_debug(perf, memops)(&quot;mapped &quot; SIZE_FORMAT &quot; bytes for vmid %d at &quot;
1132                           INTPTR_FORMAT, size, vmid, p2i((void*)mapAddress));
1133 }
1134 
1135 // create the PerfData memory region
1136 //
1137 // This method creates the memory region used to store performance
1138 // data for the JVM. The memory may be created in standard or
1139 // shared memory.
1140 //
1141 void PerfMemory::create_memory_region(size_t size) {
1142 
1143   if (PerfDisableSharedMem) {
1144     // do not share the memory for the performance data.
1145     _start = create_standard_memory(size);
1146   }
1147   else {
1148     _start = create_shared_memory(size);
1149     if (_start == NULL) {
1150 
1151       // creation of the shared memory region failed, attempt
1152       // to create a contiguous, non-shared memory region instead.
1153       //
1154       if (PrintMiscellaneous &amp;&amp; Verbose) {
1155         warning(&quot;Reverting to non-shared PerfMemory region.\n&quot;);
1156       }
1157       PerfDisableSharedMem = true;
1158       _start = create_standard_memory(size);
1159     }
1160   }
1161 
1162   if (_start != NULL) _capacity = size;
1163 
1164 }
1165 
1166 // delete the PerfData memory region
1167 //
1168 // This method deletes the memory region used to store performance
1169 // data for the JVM. The memory region indicated by the &lt;address, size&gt;
1170 // tuple will be inaccessible after a call to this method.
1171 //
1172 void PerfMemory::delete_memory_region() {
1173 
1174   assert((start() != NULL &amp;&amp; capacity() &gt; 0), &quot;verify proper state&quot;);
1175 
1176   // If user specifies PerfDataSaveFile, it will save the performance data
1177   // to the specified file name no matter whether PerfDataSaveToFile is specified
1178   // or not. In other word, -XX:PerfDataSaveFile=.. overrides flag
1179   // -XX:+PerfDataSaveToFile.
1180   if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {
1181     save_memory_to_file(start(), capacity());
1182   }
1183 
1184   if (PerfDisableSharedMem) {
1185     delete_standard_memory(start(), capacity());
1186   }
1187   else {
1188     delete_shared_memory(start(), capacity());
1189   }
1190 }
1191 
1192 // attach to the PerfData memory region for another JVM
1193 //
1194 // This method returns an &lt;address, size&gt; tuple that points to
1195 // a memory buffer that is kept reasonably synchronized with
1196 // the PerfData memory region for the indicated JVM. This
1197 // buffer may be kept in synchronization via shared memory
1198 // or some other mechanism that keeps the buffer updated.
1199 //
1200 // If the JVM chooses not to support the attachability feature,
1201 // this method should throw an UnsupportedOperation exception.
1202 //
1203 // This implementation utilizes named shared memory to map
1204 // the indicated process&#39;s PerfData memory region into this JVMs
1205 // address space.
1206 //
1207 void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {
1208 
1209   if (vmid == 0 || vmid == os::current_process_id()) {
1210      *addrp = start();
1211      *sizep = capacity();
1212      return;
1213   }
1214 
1215   mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);
1216 }
1217 
1218 // detach from the PerfData memory region of another JVM
1219 //
1220 // This method detaches the PerfData memory region of another
1221 // JVM, specified as an &lt;address, size&gt; tuple of a buffer
1222 // in this process&#39;s address space. This method may perform
1223 // arbitrary actions to accomplish the detachment. The memory
1224 // region specified by &lt;address, size&gt; will be inaccessible after
1225 // a call to this method.
1226 //
1227 // If the JVM chooses not to support the attachability feature,
1228 // this method should throw an UnsupportedOperation exception.
1229 //
1230 // This implementation utilizes named shared memory to detach
1231 // the indicated process&#39;s PerfData memory region from this
1232 // process&#39;s address space.
1233 //
1234 void PerfMemory::detach(char* addr, size_t bytes, TRAPS) {
1235 
1236   assert(addr != 0, &quot;address sanity check&quot;);
1237   assert(bytes &gt; 0, &quot;capacity sanity check&quot;);
1238 
1239   if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {
1240     // prevent accidental detachment of this process&#39;s PerfMemory region
1241     return;
1242   }
1243 
1244   unmap_shared(addr, bytes);
1245 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>