<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;compiler/compilationPolicy.hpp&quot;
  28 #include &quot;compiler/compilerOracle.hpp&quot;
  29 #include &quot;interpreter/bytecode.hpp&quot;
  30 #include &quot;interpreter/bytecodeStream.hpp&quot;
  31 #include &quot;interpreter/linkResolver.hpp&quot;
  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/methodData.inline.hpp&quot;
  35 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  36 #include &quot;runtime/arguments.hpp&quot;
  37 #include &quot;runtime/atomic.hpp&quot;
  38 #include &quot;runtime/deoptimization.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/orderAccess.hpp&quot;
  41 #include &quot;runtime/safepointVerifiers.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 
  45 // ==================================================================
  46 // DataLayout
  47 //
  48 // Overlay for generic profiling data.
  49 
  50 // Some types of data layouts need a length field.
  51 bool DataLayout::needs_array_len(u1 tag) {
  52   return (tag == multi_branch_data_tag) || (tag == arg_info_data_tag) || (tag == parameters_type_data_tag);
  53 }
  54 
  55 // Perform generic initialization of the data.  More specific
  56 // initialization occurs in overrides of ProfileData::post_initialize.
  57 void DataLayout::initialize(u1 tag, u2 bci, int cell_count) {
  58   _header._bits = (intptr_t)0;
  59   _header._struct._tag = tag;
  60   _header._struct._bci = bci;
  61   for (int i = 0; i &lt; cell_count; i++) {
  62     set_cell_at(i, (intptr_t)0);
  63   }
  64   if (needs_array_len(tag)) {
  65     set_cell_at(ArrayData::array_len_off_set, cell_count - 1); // -1 for header.
  66   }
  67   if (tag == call_type_data_tag) {
  68     CallTypeData::initialize(this, cell_count);
  69   } else if (tag == virtual_call_type_data_tag) {
  70     VirtualCallTypeData::initialize(this, cell_count);
  71   }
  72 }
  73 
  74 void DataLayout::clean_weak_klass_links(bool always_clean) {
  75   ResourceMark m;
  76   data_in()-&gt;clean_weak_klass_links(always_clean);
  77 }
  78 
  79 
  80 // ==================================================================
  81 // ProfileData
  82 //
  83 // A ProfileData object is created to refer to a section of profiling
  84 // data in a structured way.
  85 
  86 // Constructor for invalid ProfileData.
  87 ProfileData::ProfileData() {
  88   _data = NULL;
  89 }
  90 
  91 char* ProfileData::print_data_on_helper(const MethodData* md) const {
  92   DataLayout* dp  = md-&gt;extra_data_base();
  93   DataLayout* end = md-&gt;args_data_limit();
  94   stringStream ss;
  95   for (;; dp = MethodData::next_extra(dp)) {
  96     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
  97     switch(dp-&gt;tag()) {
  98     case DataLayout::speculative_trap_data_tag:
  99       if (dp-&gt;bci() == bci()) {
 100         SpeculativeTrapData* data = new SpeculativeTrapData(dp);
 101         int trap = data-&gt;trap_state();
 102         char buf[100];
 103         ss.print(&quot;trap/&quot;);
 104         data-&gt;method()-&gt;print_short_name(&amp;ss);
 105         ss.print(&quot;(%s) &quot;, Deoptimization::format_trap_state(buf, sizeof(buf), trap));
 106       }
 107       break;
 108     case DataLayout::bit_data_tag:
 109       break;
 110     case DataLayout::no_tag:
 111     case DataLayout::arg_info_data_tag:
 112       return ss.as_string();
 113       break;
 114     default:
 115       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
 116     }
 117   }
 118   return NULL;
 119 }
 120 
 121 void ProfileData::print_data_on(outputStream* st, const MethodData* md) const {
 122   print_data_on(st, print_data_on_helper(md));
 123 }
 124 
 125 void ProfileData::print_shared(outputStream* st, const char* name, const char* extra) const {
 126   st-&gt;print(&quot;bci: %d&quot;, bci());
 127   st-&gt;fill_to(tab_width_one);
 128   st-&gt;print(&quot;%s&quot;, name);
 129   tab(st);
 130   int trap = trap_state();
 131   if (trap != 0) {
 132     char buf[100];
 133     st-&gt;print(&quot;trap(%s) &quot;, Deoptimization::format_trap_state(buf, sizeof(buf), trap));
 134   }
 135   if (extra != NULL) {
 136     st-&gt;print(&quot;%s&quot;, extra);
 137   }
 138   int flags = data()-&gt;flags();
 139   if (flags != 0) {
 140     st-&gt;print(&quot;flags(%d) &quot;, flags);
 141   }
 142 }
 143 
 144 void ProfileData::tab(outputStream* st, bool first) const {
 145   st-&gt;fill_to(first ? tab_width_one : tab_width_two);
 146 }
 147 
 148 // ==================================================================
 149 // BitData
 150 //
 151 // A BitData corresponds to a one-bit flag.  This is used to indicate
 152 // whether a checkcast bytecode has seen a null value.
 153 
 154 
 155 void BitData::print_data_on(outputStream* st, const char* extra) const {
 156   print_shared(st, &quot;BitData&quot;, extra);
 157   st-&gt;cr();
 158 }
 159 
 160 // ==================================================================
 161 // CounterData
 162 //
 163 // A CounterData corresponds to a simple counter.
 164 
 165 void CounterData::print_data_on(outputStream* st, const char* extra) const {
 166   print_shared(st, &quot;CounterData&quot;, extra);
 167   st-&gt;print_cr(&quot;count(%u)&quot;, count());
 168 }
 169 
 170 // ==================================================================
 171 // JumpData
 172 //
 173 // A JumpData is used to access profiling information for a direct
 174 // branch.  It is a counter, used for counting the number of branches,
 175 // plus a data displacement, used for realigning the data pointer to
 176 // the corresponding target bci.
 177 
 178 void JumpData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 179   assert(stream-&gt;bci() == bci(), &quot;wrong pos&quot;);
 180   int target;
 181   Bytecodes::Code c = stream-&gt;code();
 182   if (c == Bytecodes::_goto_w || c == Bytecodes::_jsr_w) {
 183     target = stream-&gt;dest_w();
 184   } else {
 185     target = stream-&gt;dest();
 186   }
 187   int my_di = mdo-&gt;dp_to_di(dp());
 188   int target_di = mdo-&gt;bci_to_di(target);
 189   int offset = target_di - my_di;
 190   set_displacement(offset);
 191 }
 192 
 193 void JumpData::print_data_on(outputStream* st, const char* extra) const {
 194   print_shared(st, &quot;JumpData&quot;, extra);
 195   st-&gt;print_cr(&quot;taken(%u) displacement(%d)&quot;, taken(), displacement());
 196 }
 197 
 198 int TypeStackSlotEntries::compute_cell_count(Symbol* signature, bool include_receiver, int max) {
 199   // Parameter profiling include the receiver
 200   int args_count = include_receiver ? 1 : 0;
 201   ResourceMark rm;
<a name="1" id="anc1"></a><span class="line-modified"> 202   SignatureStream ss(signature);</span>
<span class="line-modified"> 203   args_count += ss.reference_parameter_count();</span>
 204   args_count = MIN2(args_count, max);
 205   return args_count * per_arg_cell_count;
 206 }
 207 
 208 int TypeEntriesAtCall::compute_cell_count(BytecodeStream* stream) {
 209   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 210   assert(TypeStackSlotEntries::per_arg_count() &gt; ReturnTypeEntry::static_cell_count(), &quot;code to test for arguments/results broken&quot;);
 211   const methodHandle m = stream-&gt;method();
 212   int bci = stream-&gt;bci();
 213   Bytecode_invoke inv(m, bci);
 214   int args_cell = 0;
 215   if (MethodData::profile_arguments_for_invoke(m, bci)) {
 216     args_cell = TypeStackSlotEntries::compute_cell_count(inv.signature(), false, TypeProfileArgsLimit);
 217   }
 218   int ret_cell = 0;
 219   if (MethodData::profile_return_for_invoke(m, bci) &amp;&amp; is_reference_type(inv.result_type())) {
 220     ret_cell = ReturnTypeEntry::static_cell_count();
 221   }
 222   int header_cell = 0;
 223   if (args_cell + ret_cell &gt; 0) {
 224     header_cell = header_cell_count();
 225   }
 226 
 227   return header_cell + args_cell + ret_cell;
 228 }
 229 
<a name="2" id="anc2"></a><span class="line-modified"> 230 class ArgumentOffsetComputer : public SignatureInfo {</span>
 231 private:
 232   int _max;
<a name="3" id="anc3"></a>
 233   GrowableArray&lt;int&gt; _offsets;
 234 
<a name="4" id="anc4"></a><span class="line-modified"> 235   void set(int size, BasicType type) { _size += size; }</span>
<span class="line-modified"> 236   void do_object(int begin, int end) {</span>
<span class="line-modified"> 237     if (_offsets.length() &lt; _max) {</span>
<span class="line-modified"> 238       _offsets.push(_size);</span>
 239     }
<a name="5" id="anc5"></a><span class="line-modified"> 240     SignatureInfo::do_object(begin, end);</span>
<span class="line-removed"> 241   }</span>
<span class="line-removed"> 242   void do_array (int begin, int end) {</span>
<span class="line-removed"> 243     if (_offsets.length() &lt; _max) {</span>
<span class="line-removed"> 244       _offsets.push(_size);</span>
<span class="line-removed"> 245     }</span>
<span class="line-removed"> 246     SignatureInfo::do_array(begin, end);</span>
 247   }
 248 
<a name="6" id="anc6"></a><span class="line-modified"> 249 public:</span>
 250   ArgumentOffsetComputer(Symbol* signature, int max)
<a name="7" id="anc7"></a><span class="line-modified"> 251     : SignatureInfo(signature), _max(max), _offsets(Thread::current(), max) {</span>



 252   }
 253 
<a name="8" id="anc8"></a><span class="line-removed"> 254   int total() { lazy_iterate_parameters(); return _size; }</span>
<span class="line-removed"> 255 </span>
 256   int off_at(int i) const { return _offsets.at(i); }
 257 };
 258 
 259 void TypeStackSlotEntries::post_initialize(Symbol* signature, bool has_receiver, bool include_receiver) {
 260   ResourceMark rm;
 261   int start = 0;
 262   // Parameter profiling include the receiver
 263   if (include_receiver &amp;&amp; has_receiver) {
 264     set_stack_slot(0, 0);
 265     set_type(0, type_none());
 266     start += 1;
 267   }
 268   ArgumentOffsetComputer aos(signature, _number_of_entries-start);
<a name="9" id="anc9"></a><span class="line-removed"> 269   aos.total();</span>
 270   for (int i = start; i &lt; _number_of_entries; i++) {
 271     set_stack_slot(i, aos.off_at(i-start) + (has_receiver ? 1 : 0));
 272     set_type(i, type_none());
 273   }
 274 }
 275 
 276 void CallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 277   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 278   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 279 
<a name="10" id="anc10"></a><span class="line-removed"> 280   SignatureStream ss(inv.signature());</span>
 281   if (has_arguments()) {
 282 #ifdef ASSERT
 283     ResourceMark rm;
<a name="11" id="anc11"></a><span class="line-modified"> 284     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>

 285     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 286     check_number_of_arguments(count);
 287 #endif
 288     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 289   }
 290 
 291   if (has_return()) {
 292     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);
 293     _ret.post_initialize();
 294   }
 295 }
 296 
 297 void VirtualCallTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 298   assert(Bytecodes::is_invoke(stream-&gt;code()), &quot;should be invoke&quot;);
 299   Bytecode_invoke inv(stream-&gt;method(), stream-&gt;bci());
 300 
 301   if (has_arguments()) {
 302 #ifdef ASSERT
 303     ResourceMark rm;
<a name="12" id="anc12"></a><span class="line-modified"> 304     SignatureStream ss(inv.signature());</span>
<span class="line-modified"> 305     int count = MIN2(ss.reference_parameter_count(), (int)TypeProfileArgsLimit);</span>
 306     assert(count &gt; 0, &quot;room for args type but none found?&quot;);
 307     check_number_of_arguments(count);
 308 #endif
 309     _args.post_initialize(inv.signature(), inv.has_receiver(), false);
 310   }
 311 
 312   if (has_return()) {
 313     assert(is_reference_type(inv.result_type()), &quot;room for a ret type but doesn&#39;t return obj?&quot;);
 314     _ret.post_initialize();
 315   }
 316 }
 317 
 318 void TypeStackSlotEntries::clean_weak_klass_links(bool always_clean) {
 319   for (int i = 0; i &lt; _number_of_entries; i++) {
 320     intptr_t p = type(i);
 321     Klass* k = (Klass*)klass_part(p);
 322     if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 323       set_type(i, with_status((Klass*)NULL, p));
 324     }
 325   }
 326 }
 327 
 328 void ReturnTypeEntry::clean_weak_klass_links(bool always_clean) {
 329   intptr_t p = type();
 330   Klass* k = (Klass*)klass_part(p);
 331   if (k != NULL &amp;&amp; (always_clean || !k-&gt;is_loader_alive())) {
 332     set_type(with_status((Klass*)NULL, p));
 333   }
 334 }
 335 
 336 bool TypeEntriesAtCall::return_profiling_enabled() {
 337   return MethodData::profile_return();
 338 }
 339 
 340 bool TypeEntriesAtCall::arguments_profiling_enabled() {
 341   return MethodData::profile_arguments();
 342 }
 343 
 344 void TypeEntries::print_klass(outputStream* st, intptr_t k) {
 345   if (is_type_none(k)) {
 346     st-&gt;print(&quot;none&quot;);
 347   } else if (is_type_unknown(k)) {
 348     st-&gt;print(&quot;unknown&quot;);
 349   } else {
 350     valid_klass(k)-&gt;print_value_on(st);
 351   }
 352   if (was_null_seen(k)) {
 353     st-&gt;print(&quot; (null seen)&quot;);
 354   }
 355 }
 356 
 357 void TypeStackSlotEntries::print_data_on(outputStream* st) const {
 358   for (int i = 0; i &lt; _number_of_entries; i++) {
 359     _pd-&gt;tab(st);
 360     st-&gt;print(&quot;%d: stack(%u) &quot;, i, stack_slot(i));
 361     print_klass(st, type(i));
 362     st-&gt;cr();
 363   }
 364 }
 365 
 366 void ReturnTypeEntry::print_data_on(outputStream* st) const {
 367   _pd-&gt;tab(st);
 368   print_klass(st, type());
 369   st-&gt;cr();
 370 }
 371 
 372 void CallTypeData::print_data_on(outputStream* st, const char* extra) const {
 373   CounterData::print_data_on(st, extra);
 374   if (has_arguments()) {
 375     tab(st, true);
 376     st-&gt;print(&quot;argument types&quot;);
 377     _args.print_data_on(st);
 378   }
 379   if (has_return()) {
 380     tab(st, true);
 381     st-&gt;print(&quot;return type&quot;);
 382     _ret.print_data_on(st);
 383   }
 384 }
 385 
 386 void VirtualCallTypeData::print_data_on(outputStream* st, const char* extra) const {
 387   VirtualCallData::print_data_on(st, extra);
 388   if (has_arguments()) {
 389     tab(st, true);
 390     st-&gt;print(&quot;argument types&quot;);
 391     _args.print_data_on(st);
 392   }
 393   if (has_return()) {
 394     tab(st, true);
 395     st-&gt;print(&quot;return type&quot;);
 396     _ret.print_data_on(st);
 397   }
 398 }
 399 
 400 // ==================================================================
 401 // ReceiverTypeData
 402 //
 403 // A ReceiverTypeData is used to access profiling information about a
 404 // dynamic type check.  It consists of a counter which counts the total times
 405 // that the check is reached, and a series of (Klass*, count) pairs
 406 // which are used to store a type profile for the receiver of the check.
 407 
 408 void ReceiverTypeData::clean_weak_klass_links(bool always_clean) {
 409     for (uint row = 0; row &lt; row_limit(); row++) {
 410     Klass* p = receiver(row);
 411     if (p != NULL &amp;&amp; (always_clean || !p-&gt;is_loader_alive())) {
 412       clear_row(row);
 413     }
 414   }
 415 }
 416 
 417 #if INCLUDE_JVMCI
 418 void VirtualCallData::clean_weak_klass_links(bool always_clean) {
 419   ReceiverTypeData::clean_weak_klass_links(always_clean);
 420   for (uint row = 0; row &lt; method_row_limit(); row++) {
 421     Method* p = method(row);
 422     if (p != NULL &amp;&amp; (always_clean || !p-&gt;method_holder()-&gt;is_loader_alive())) {
 423       clear_method_row(row);
 424     }
 425   }
 426 }
 427 
 428 void VirtualCallData::clean_weak_method_links() {
 429   ReceiverTypeData::clean_weak_method_links();
 430   for (uint row = 0; row &lt; method_row_limit(); row++) {
 431     Method* p = method(row);
 432     if (p != NULL &amp;&amp; p-&gt;is_old()) {
 433       clear_method_row(row);
 434     }
 435   }
 436 }
 437 #endif // INCLUDE_JVMCI
 438 
 439 void ReceiverTypeData::print_receiver_data_on(outputStream* st) const {
 440   uint row;
 441   int entries = 0;
 442   for (row = 0; row &lt; row_limit(); row++) {
 443     if (receiver(row) != NULL)  entries++;
 444   }
 445 #if INCLUDE_JVMCI
 446   st-&gt;print_cr(&quot;count(%u) nonprofiled_count(%u) entries(%u)&quot;, count(), nonprofiled_count(), entries);
 447 #else
 448   st-&gt;print_cr(&quot;count(%u) entries(%u)&quot;, count(), entries);
 449 #endif
 450   int total = count();
 451   for (row = 0; row &lt; row_limit(); row++) {
 452     if (receiver(row) != NULL) {
 453       total += receiver_count(row);
 454     }
 455   }
 456   for (row = 0; row &lt; row_limit(); row++) {
 457     if (receiver(row) != NULL) {
 458       tab(st);
 459       receiver(row)-&gt;print_value_on(st);
 460       st-&gt;print_cr(&quot;(%u %4.2f)&quot;, receiver_count(row), (float) receiver_count(row) / (float) total);
 461     }
 462   }
 463 }
 464 void ReceiverTypeData::print_data_on(outputStream* st, const char* extra) const {
 465   print_shared(st, &quot;ReceiverTypeData&quot;, extra);
 466   print_receiver_data_on(st);
 467 }
 468 
 469 #if INCLUDE_JVMCI
 470 void VirtualCallData::print_method_data_on(outputStream* st) const {
 471   uint row;
 472   int entries = 0;
 473   for (row = 0; row &lt; method_row_limit(); row++) {
 474     if (method(row) != NULL) entries++;
 475   }
 476   tab(st);
 477   st-&gt;print_cr(&quot;method_entries(%u)&quot;, entries);
 478   int total = count();
 479   for (row = 0; row &lt; method_row_limit(); row++) {
 480     if (method(row) != NULL) {
 481       total += method_count(row);
 482     }
 483   }
 484   for (row = 0; row &lt; method_row_limit(); row++) {
 485     if (method(row) != NULL) {
 486       tab(st);
 487       method(row)-&gt;print_value_on(st);
 488       st-&gt;print_cr(&quot;(%u %4.2f)&quot;, method_count(row), (float) method_count(row) / (float) total);
 489     }
 490   }
 491 }
 492 #endif // INCLUDE_JVMCI
 493 
 494 void VirtualCallData::print_data_on(outputStream* st, const char* extra) const {
 495   print_shared(st, &quot;VirtualCallData&quot;, extra);
 496   print_receiver_data_on(st);
 497   print_method_data_on(st);
 498 }
 499 
 500 // ==================================================================
 501 // RetData
 502 //
 503 // A RetData is used to access profiling information for a ret bytecode.
 504 // It is composed of a count of the number of times that the ret has
 505 // been executed, followed by a series of triples of the form
 506 // (bci, count, di) which count the number of times that some bci was the
 507 // target of the ret and cache a corresponding displacement.
 508 
 509 void RetData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 510   for (uint row = 0; row &lt; row_limit(); row++) {
 511     set_bci_displacement(row, -1);
 512     set_bci(row, no_bci);
 513   }
 514   // release so other threads see a consistent state.  bci is used as
 515   // a valid flag for bci_displacement.
 516   OrderAccess::release();
 517 }
 518 
 519 // This routine needs to atomically update the RetData structure, so the
 520 // caller needs to hold the RetData_lock before it gets here.  Since taking
 521 // the lock can block (and allow GC) and since RetData is a ProfileData is a
 522 // wrapper around a derived oop, taking the lock in _this_ method will
 523 // basically cause the &#39;this&#39; pointer&#39;s _data field to contain junk after the
 524 // lock.  We require the caller to take the lock before making the ProfileData
 525 // structure.  Currently the only caller is InterpreterRuntime::update_mdp_for_ret
 526 address RetData::fixup_ret(int return_bci, MethodData* h_mdo) {
 527   // First find the mdp which corresponds to the return bci.
 528   address mdp = h_mdo-&gt;bci_to_dp(return_bci);
 529 
 530   // Now check to see if any of the cache slots are open.
 531   for (uint row = 0; row &lt; row_limit(); row++) {
 532     if (bci(row) == no_bci) {
 533       set_bci_displacement(row, mdp - dp());
 534       set_bci_count(row, DataLayout::counter_increment);
 535       // Barrier to ensure displacement is written before the bci; allows
 536       // the interpreter to read displacement without fear of race condition.
 537       release_set_bci(row, return_bci);
 538       break;
 539     }
 540   }
 541   return mdp;
 542 }
 543 
 544 void RetData::print_data_on(outputStream* st, const char* extra) const {
 545   print_shared(st, &quot;RetData&quot;, extra);
 546   uint row;
 547   int entries = 0;
 548   for (row = 0; row &lt; row_limit(); row++) {
 549     if (bci(row) != no_bci)  entries++;
 550   }
 551   st-&gt;print_cr(&quot;count(%u) entries(%u)&quot;, count(), entries);
 552   for (row = 0; row &lt; row_limit(); row++) {
 553     if (bci(row) != no_bci) {
 554       tab(st);
 555       st-&gt;print_cr(&quot;bci(%d: count(%u) displacement(%d))&quot;,
 556                    bci(row), bci_count(row), bci_displacement(row));
 557     }
 558   }
 559 }
 560 
 561 // ==================================================================
 562 // BranchData
 563 //
 564 // A BranchData is used to access profiling data for a two-way branch.
 565 // It consists of taken and not_taken counts as well as a data displacement
 566 // for the taken case.
 567 
 568 void BranchData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 569   assert(stream-&gt;bci() == bci(), &quot;wrong pos&quot;);
 570   int target = stream-&gt;dest();
 571   int my_di = mdo-&gt;dp_to_di(dp());
 572   int target_di = mdo-&gt;bci_to_di(target);
 573   int offset = target_di - my_di;
 574   set_displacement(offset);
 575 }
 576 
 577 void BranchData::print_data_on(outputStream* st, const char* extra) const {
 578   print_shared(st, &quot;BranchData&quot;, extra);
 579   st-&gt;print_cr(&quot;taken(%u) displacement(%d)&quot;,
 580                taken(), displacement());
 581   tab(st);
 582   st-&gt;print_cr(&quot;not taken(%u)&quot;, not_taken());
 583 }
 584 
 585 // ==================================================================
 586 // MultiBranchData
 587 //
 588 // A MultiBranchData is used to access profiling information for
 589 // a multi-way branch (*switch bytecodes).  It consists of a series
 590 // of (count, displacement) pairs, which count the number of times each
 591 // case was taken and specify the data displacment for each branch target.
 592 
 593 int MultiBranchData::compute_cell_count(BytecodeStream* stream) {
 594   int cell_count = 0;
 595   if (stream-&gt;code() == Bytecodes::_tableswitch) {
 596     Bytecode_tableswitch sw(stream-&gt;method()(), stream-&gt;bcp());
 597     cell_count = 1 + per_case_cell_count * (1 + sw.length()); // 1 for default
 598   } else {
 599     Bytecode_lookupswitch sw(stream-&gt;method()(), stream-&gt;bcp());
 600     cell_count = 1 + per_case_cell_count * (sw.number_of_pairs() + 1); // 1 for default
 601   }
 602   return cell_count;
 603 }
 604 
 605 void MultiBranchData::post_initialize(BytecodeStream* stream,
 606                                       MethodData* mdo) {
 607   assert(stream-&gt;bci() == bci(), &quot;wrong pos&quot;);
 608   int target;
 609   int my_di;
 610   int target_di;
 611   int offset;
 612   if (stream-&gt;code() == Bytecodes::_tableswitch) {
 613     Bytecode_tableswitch sw(stream-&gt;method()(), stream-&gt;bcp());
 614     int len = sw.length();
 615     assert(array_len() == per_case_cell_count * (len + 1), &quot;wrong len&quot;);
 616     for (int count = 0; count &lt; len; count++) {
 617       target = sw.dest_offset_at(count) + bci();
 618       my_di = mdo-&gt;dp_to_di(dp());
 619       target_di = mdo-&gt;bci_to_di(target);
 620       offset = target_di - my_di;
 621       set_displacement_at(count, offset);
 622     }
 623     target = sw.default_offset() + bci();
 624     my_di = mdo-&gt;dp_to_di(dp());
 625     target_di = mdo-&gt;bci_to_di(target);
 626     offset = target_di - my_di;
 627     set_default_displacement(offset);
 628 
 629   } else {
 630     Bytecode_lookupswitch sw(stream-&gt;method()(), stream-&gt;bcp());
 631     int npairs = sw.number_of_pairs();
 632     assert(array_len() == per_case_cell_count * (npairs + 1), &quot;wrong len&quot;);
 633     for (int count = 0; count &lt; npairs; count++) {
 634       LookupswitchPair pair = sw.pair_at(count);
 635       target = pair.offset() + bci();
 636       my_di = mdo-&gt;dp_to_di(dp());
 637       target_di = mdo-&gt;bci_to_di(target);
 638       offset = target_di - my_di;
 639       set_displacement_at(count, offset);
 640     }
 641     target = sw.default_offset() + bci();
 642     my_di = mdo-&gt;dp_to_di(dp());
 643     target_di = mdo-&gt;bci_to_di(target);
 644     offset = target_di - my_di;
 645     set_default_displacement(offset);
 646   }
 647 }
 648 
 649 void MultiBranchData::print_data_on(outputStream* st, const char* extra) const {
 650   print_shared(st, &quot;MultiBranchData&quot;, extra);
 651   st-&gt;print_cr(&quot;default_count(%u) displacement(%d)&quot;,
 652                default_count(), default_displacement());
 653   int cases = number_of_cases();
 654   for (int i = 0; i &lt; cases; i++) {
 655     tab(st);
 656     st-&gt;print_cr(&quot;count(%u) displacement(%d)&quot;,
 657                  count_at(i), displacement_at(i));
 658   }
 659 }
 660 
 661 void ArgInfoData::print_data_on(outputStream* st, const char* extra) const {
 662   print_shared(st, &quot;ArgInfoData&quot;, extra);
 663   int nargs = number_of_args();
 664   for (int i = 0; i &lt; nargs; i++) {
 665     st-&gt;print(&quot;  0x%x&quot;, arg_modified(i));
 666   }
 667   st-&gt;cr();
 668 }
 669 
 670 int ParametersTypeData::compute_cell_count(Method* m) {
 671   if (!MethodData::profile_parameters_for_method(methodHandle(Thread::current(), m))) {
 672     return 0;
 673   }
 674   int max = TypeProfileParmsLimit == -1 ? INT_MAX : TypeProfileParmsLimit;
 675   int obj_args = TypeStackSlotEntries::compute_cell_count(m-&gt;signature(), !m-&gt;is_static(), max);
 676   if (obj_args &gt; 0) {
 677     return obj_args + 1; // 1 cell for array len
 678   }
 679   return 0;
 680 }
 681 
 682 void ParametersTypeData::post_initialize(BytecodeStream* stream, MethodData* mdo) {
 683   _parameters.post_initialize(mdo-&gt;method()-&gt;signature(), !mdo-&gt;method()-&gt;is_static(), true);
 684 }
 685 
 686 bool ParametersTypeData::profiling_enabled() {
 687   return MethodData::profile_parameters();
 688 }
 689 
 690 void ParametersTypeData::print_data_on(outputStream* st, const char* extra) const {
 691   st-&gt;print(&quot;parameter types&quot;); // FIXME extra ignored?
 692   _parameters.print_data_on(st);
 693 }
 694 
 695 void SpeculativeTrapData::print_data_on(outputStream* st, const char* extra) const {
 696   print_shared(st, &quot;SpeculativeTrapData&quot;, extra);
 697   tab(st);
 698   method()-&gt;print_short_name(st);
 699   st-&gt;cr();
 700 }
 701 
 702 // ==================================================================
 703 // MethodData*
 704 //
 705 // A MethodData* holds information which has been collected about
 706 // a method.
 707 
 708 MethodData* MethodData::allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS) {
 709   int size = MethodData::compute_allocation_size_in_words(method);
 710 
 711   return new (loader_data, size, MetaspaceObj::MethodDataType, THREAD)
 712     MethodData(method, size, THREAD);
 713 }
 714 
 715 int MethodData::bytecode_cell_count(Bytecodes::Code code) {
 716   if (is_client_compilation_mode_vm()) {
 717     return no_profile_data;
 718   }
 719   switch (code) {
 720   case Bytecodes::_checkcast:
 721   case Bytecodes::_instanceof:
 722   case Bytecodes::_aastore:
 723     if (TypeProfileCasts) {
 724       return ReceiverTypeData::static_cell_count();
 725     } else {
 726       return BitData::static_cell_count();
 727     }
 728   case Bytecodes::_invokespecial:
 729   case Bytecodes::_invokestatic:
 730     if (MethodData::profile_arguments() || MethodData::profile_return()) {
 731       return variable_cell_count;
 732     } else {
 733       return CounterData::static_cell_count();
 734     }
 735   case Bytecodes::_goto:
 736   case Bytecodes::_goto_w:
 737   case Bytecodes::_jsr:
 738   case Bytecodes::_jsr_w:
 739     return JumpData::static_cell_count();
 740   case Bytecodes::_invokevirtual:
 741   case Bytecodes::_invokeinterface:
 742     if (MethodData::profile_arguments() || MethodData::profile_return()) {
 743       return variable_cell_count;
 744     } else {
 745       return VirtualCallData::static_cell_count();
 746     }
 747   case Bytecodes::_invokedynamic:
 748     if (MethodData::profile_arguments() || MethodData::profile_return()) {
 749       return variable_cell_count;
 750     } else {
 751       return CounterData::static_cell_count();
 752     }
 753   case Bytecodes::_ret:
 754     return RetData::static_cell_count();
 755   case Bytecodes::_ifeq:
 756   case Bytecodes::_ifne:
 757   case Bytecodes::_iflt:
 758   case Bytecodes::_ifge:
 759   case Bytecodes::_ifgt:
 760   case Bytecodes::_ifle:
 761   case Bytecodes::_if_icmpeq:
 762   case Bytecodes::_if_icmpne:
 763   case Bytecodes::_if_icmplt:
 764   case Bytecodes::_if_icmpge:
 765   case Bytecodes::_if_icmpgt:
 766   case Bytecodes::_if_icmple:
 767   case Bytecodes::_if_acmpeq:
 768   case Bytecodes::_if_acmpne:
 769   case Bytecodes::_ifnull:
 770   case Bytecodes::_ifnonnull:
 771     return BranchData::static_cell_count();
 772   case Bytecodes::_lookupswitch:
 773   case Bytecodes::_tableswitch:
 774     return variable_cell_count;
 775   default:
 776     return no_profile_data;
 777   }
 778 }
 779 
 780 // Compute the size of the profiling information corresponding to
 781 // the current bytecode.
 782 int MethodData::compute_data_size(BytecodeStream* stream) {
 783   int cell_count = bytecode_cell_count(stream-&gt;code());
 784   if (cell_count == no_profile_data) {
 785     return 0;
 786   }
 787   if (cell_count == variable_cell_count) {
 788     switch (stream-&gt;code()) {
 789     case Bytecodes::_lookupswitch:
 790     case Bytecodes::_tableswitch:
 791       cell_count = MultiBranchData::compute_cell_count(stream);
 792       break;
 793     case Bytecodes::_invokespecial:
 794     case Bytecodes::_invokestatic:
 795     case Bytecodes::_invokedynamic:
 796       assert(MethodData::profile_arguments() || MethodData::profile_return(), &quot;should be collecting args profile&quot;);
 797       if (profile_arguments_for_invoke(stream-&gt;method(), stream-&gt;bci()) ||
 798           profile_return_for_invoke(stream-&gt;method(), stream-&gt;bci())) {
 799         cell_count = CallTypeData::compute_cell_count(stream);
 800       } else {
 801         cell_count = CounterData::static_cell_count();
 802       }
 803       break;
 804     case Bytecodes::_invokevirtual:
 805     case Bytecodes::_invokeinterface: {
 806       assert(MethodData::profile_arguments() || MethodData::profile_return(), &quot;should be collecting args profile&quot;);
 807       if (profile_arguments_for_invoke(stream-&gt;method(), stream-&gt;bci()) ||
 808           profile_return_for_invoke(stream-&gt;method(), stream-&gt;bci())) {
 809         cell_count = VirtualCallTypeData::compute_cell_count(stream);
 810       } else {
 811         cell_count = VirtualCallData::static_cell_count();
 812       }
 813       break;
 814     }
 815     default:
 816       fatal(&quot;unexpected bytecode for var length profile data&quot;);
 817     }
 818   }
 819   // Note:  cell_count might be zero, meaning that there is just
 820   //        a DataLayout header, with no extra cells.
 821   assert(cell_count &gt;= 0, &quot;sanity&quot;);
 822   return DataLayout::compute_size_in_bytes(cell_count);
 823 }
 824 
 825 bool MethodData::is_speculative_trap_bytecode(Bytecodes::Code code) {
 826   // Bytecodes for which we may use speculation
 827   switch (code) {
 828   case Bytecodes::_checkcast:
 829   case Bytecodes::_instanceof:
 830   case Bytecodes::_aastore:
 831   case Bytecodes::_invokevirtual:
 832   case Bytecodes::_invokeinterface:
 833   case Bytecodes::_if_acmpeq:
 834   case Bytecodes::_if_acmpne:
 835   case Bytecodes::_ifnull:
 836   case Bytecodes::_ifnonnull:
 837   case Bytecodes::_invokestatic:
 838 #ifdef COMPILER2
 839     if (is_server_compilation_mode_vm()) {
 840       return UseTypeSpeculation;
 841     }
 842 #endif
 843   default:
 844     return false;
 845   }
 846   return false;
 847 }
 848 
 849 #if INCLUDE_JVMCI
 850 
 851 void* FailedSpeculation::operator new(size_t size, size_t fs_size) throw() {
 852   return CHeapObj&lt;mtCompiler&gt;::operator new(fs_size, std::nothrow);
 853 }
 854 
 855 FailedSpeculation::FailedSpeculation(address speculation, int speculation_len) : _data_len(speculation_len), _next(NULL) {
 856   memcpy(data(), speculation, speculation_len);
 857 }
 858 
 859 // A heuristic check to detect nmethods that outlive a failed speculations list.
 860 static void guarantee_failed_speculations_alive(nmethod* nm, FailedSpeculation** failed_speculations_address) {
 861   jlong head = (jlong)(address) *failed_speculations_address;
 862   if ((head &amp; 0x1) == 0x1) {
 863     stringStream st;
 864     if (nm != NULL) {
 865       st.print(&quot;%d&quot;, nm-&gt;compile_id());
 866       Method* method = nm-&gt;method();
 867       st.print_raw(&quot;{&quot;);
 868       if (method != NULL) {
 869         method-&gt;print_name(&amp;st);
 870       } else {
 871         const char* jvmci_name = nm-&gt;jvmci_name();
 872         if (jvmci_name != NULL) {
 873           st.print_raw(jvmci_name);
 874         }
 875       }
 876       st.print_raw(&quot;}&quot;);
 877     } else {
 878       st.print(&quot;&lt;unknown&gt;&quot;);
 879     }
 880     fatal(&quot;Adding to failed speculations list that appears to have been freed. Source: %s&quot;, st.as_string());
 881   }
 882 }
 883 
 884 bool FailedSpeculation::add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len) {
 885   assert(failed_speculations_address != NULL, &quot;must be&quot;);
 886   size_t fs_size = sizeof(FailedSpeculation) + speculation_len;
 887   FailedSpeculation* fs = new (fs_size) FailedSpeculation(speculation, speculation_len);
 888   if (fs == NULL) {
 889     // no memory -&gt; ignore failed speculation
 890     return false;
 891   }
 892 
 893   guarantee(is_aligned(fs, sizeof(FailedSpeculation*)), &quot;FailedSpeculation objects must be pointer aligned&quot;);
 894   guarantee_failed_speculations_alive(nm, failed_speculations_address);
 895 
 896   FailedSpeculation** cursor = failed_speculations_address;
 897   do {
 898     if (*cursor == NULL) {
 899       FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) NULL, fs);
 900       if (old_fs == NULL) {
 901         // Successfully appended fs to end of the list
 902         return true;
 903       }
 904       cursor = old_fs-&gt;next_adr();
 905     } else {
 906       cursor = (*cursor)-&gt;next_adr();
 907     }
 908   } while (true);
 909 }
 910 
 911 void FailedSpeculation::free_failed_speculations(FailedSpeculation** failed_speculations_address) {
 912   assert(failed_speculations_address != NULL, &quot;must be&quot;);
 913   FailedSpeculation* fs = *failed_speculations_address;
 914   while (fs != NULL) {
 915     FailedSpeculation* next = fs-&gt;next();
 916     delete fs;
 917     fs = next;
 918   }
 919 
 920   // Write an unaligned value to failed_speculations_address to denote
 921   // that it is no longer a valid pointer. This is allows for the check
 922   // in add_failed_speculation against adding to a freed failed
 923   // speculations list.
 924   long* head = (long*) failed_speculations_address;
 925   (*head) = (*head) | 0x1;
 926 }
 927 #endif // INCLUDE_JVMCI
 928 
 929 int MethodData::compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps) {
 930 #if INCLUDE_JVMCI
 931   if (ProfileTraps) {
 932     // Assume that up to 30% of the possibly trapping BCIs with no MDP will need to allocate one.
 933     int extra_data_count = MIN2(empty_bc_count, MAX2(4, (empty_bc_count * 30) / 100));
 934 
 935     // Make sure we have a minimum number of extra data slots to
 936     // allocate SpeculativeTrapData entries. We would want to have one
 937     // entry per compilation that inlines this method and for which
 938     // some type speculation assumption fails. So the room we need for
 939     // the SpeculativeTrapData entries doesn&#39;t directly depend on the
 940     // size of the method. Because it&#39;s hard to estimate, we reserve
 941     // space for an arbitrary number of entries.
 942     int spec_data_count = (needs_speculative_traps ? SpecTrapLimitExtraEntries : 0) *
 943       (SpeculativeTrapData::static_cell_count() + DataLayout::header_size_in_cells());
 944 
 945     return MAX2(extra_data_count, spec_data_count);
 946   } else {
 947     return 0;
 948   }
 949 #else // INCLUDE_JVMCI
 950   if (ProfileTraps) {
 951     // Assume that up to 3% of BCIs with no MDP will need to allocate one.
 952     int extra_data_count = (uint)(empty_bc_count * 3) / 128 + 1;
 953     // If the method is large, let the extra BCIs grow numerous (to ~1%).
 954     int one_percent_of_data
 955       = (uint)data_size / (DataLayout::header_size_in_bytes()*128);
 956     if (extra_data_count &lt; one_percent_of_data)
 957       extra_data_count = one_percent_of_data;
 958     if (extra_data_count &gt; empty_bc_count)
 959       extra_data_count = empty_bc_count;  // no need for more
 960 
 961     // Make sure we have a minimum number of extra data slots to
 962     // allocate SpeculativeTrapData entries. We would want to have one
 963     // entry per compilation that inlines this method and for which
 964     // some type speculation assumption fails. So the room we need for
 965     // the SpeculativeTrapData entries doesn&#39;t directly depend on the
 966     // size of the method. Because it&#39;s hard to estimate, we reserve
 967     // space for an arbitrary number of entries.
 968     int spec_data_count = (needs_speculative_traps ? SpecTrapLimitExtraEntries : 0) *
 969       (SpeculativeTrapData::static_cell_count() + DataLayout::header_size_in_cells());
 970 
 971     return MAX2(extra_data_count, spec_data_count);
 972   } else {
 973     return 0;
 974   }
 975 #endif // INCLUDE_JVMCI
 976 }
 977 
 978 // Compute the size of the MethodData* necessary to store
 979 // profiling information about a given method.  Size is in bytes.
 980 int MethodData::compute_allocation_size_in_bytes(const methodHandle&amp; method) {
 981   int data_size = 0;
 982   BytecodeStream stream(method);
 983   Bytecodes::Code c;
 984   int empty_bc_count = 0;  // number of bytecodes lacking data
 985   bool needs_speculative_traps = false;
 986   while ((c = stream.next()) &gt;= 0) {
 987     int size_in_bytes = compute_data_size(&amp;stream);
 988     data_size += size_in_bytes;
 989     if (size_in_bytes == 0 JVMCI_ONLY(&amp;&amp; Bytecodes::can_trap(c)))  empty_bc_count += 1;
 990     needs_speculative_traps = needs_speculative_traps || is_speculative_trap_bytecode(c);
 991   }
 992   int object_size = in_bytes(data_offset()) + data_size;
 993 
 994   // Add some extra DataLayout cells (at least one) to track stray traps.
 995   int extra_data_count = compute_extra_data_count(data_size, empty_bc_count, needs_speculative_traps);
 996   object_size += extra_data_count * DataLayout::compute_size_in_bytes(0);
 997 
 998   // Add a cell to record information about modified arguments.
 999   int arg_size = method-&gt;size_of_parameters();
1000   object_size += DataLayout::compute_size_in_bytes(arg_size+1);
1001 
1002   // Reserve room for an area of the MDO dedicated to profiling of
1003   // parameters
1004   int args_cell = ParametersTypeData::compute_cell_count(method());
1005   if (args_cell &gt; 0) {
1006     object_size += DataLayout::compute_size_in_bytes(args_cell);
1007   }
1008   return object_size;
1009 }
1010 
1011 // Compute the size of the MethodData* necessary to store
1012 // profiling information about a given method.  Size is in words
1013 int MethodData::compute_allocation_size_in_words(const methodHandle&amp; method) {
1014   int byte_size = compute_allocation_size_in_bytes(method);
1015   int word_size = align_up(byte_size, BytesPerWord) / BytesPerWord;
1016   return align_metadata_size(word_size);
1017 }
1018 
1019 // Initialize an individual data segment.  Returns the size of
1020 // the segment in bytes.
1021 int MethodData::initialize_data(BytecodeStream* stream,
1022                                        int data_index) {
1023   if (is_client_compilation_mode_vm()) {
1024     return 0;
1025   }
1026   int cell_count = -1;
1027   int tag = DataLayout::no_tag;
1028   DataLayout* data_layout = data_layout_at(data_index);
1029   Bytecodes::Code c = stream-&gt;code();
1030   switch (c) {
1031   case Bytecodes::_checkcast:
1032   case Bytecodes::_instanceof:
1033   case Bytecodes::_aastore:
1034     if (TypeProfileCasts) {
1035       cell_count = ReceiverTypeData::static_cell_count();
1036       tag = DataLayout::receiver_type_data_tag;
1037     } else {
1038       cell_count = BitData::static_cell_count();
1039       tag = DataLayout::bit_data_tag;
1040     }
1041     break;
1042   case Bytecodes::_invokespecial:
1043   case Bytecodes::_invokestatic: {
1044     int counter_data_cell_count = CounterData::static_cell_count();
1045     if (profile_arguments_for_invoke(stream-&gt;method(), stream-&gt;bci()) ||
1046         profile_return_for_invoke(stream-&gt;method(), stream-&gt;bci())) {
1047       cell_count = CallTypeData::compute_cell_count(stream);
1048     } else {
1049       cell_count = counter_data_cell_count;
1050     }
1051     if (cell_count &gt; counter_data_cell_count) {
1052       tag = DataLayout::call_type_data_tag;
1053     } else {
1054       tag = DataLayout::counter_data_tag;
1055     }
1056     break;
1057   }
1058   case Bytecodes::_goto:
1059   case Bytecodes::_goto_w:
1060   case Bytecodes::_jsr:
1061   case Bytecodes::_jsr_w:
1062     cell_count = JumpData::static_cell_count();
1063     tag = DataLayout::jump_data_tag;
1064     break;
1065   case Bytecodes::_invokevirtual:
1066   case Bytecodes::_invokeinterface: {
1067     int virtual_call_data_cell_count = VirtualCallData::static_cell_count();
1068     if (profile_arguments_for_invoke(stream-&gt;method(), stream-&gt;bci()) ||
1069         profile_return_for_invoke(stream-&gt;method(), stream-&gt;bci())) {
1070       cell_count = VirtualCallTypeData::compute_cell_count(stream);
1071     } else {
1072       cell_count = virtual_call_data_cell_count;
1073     }
1074     if (cell_count &gt; virtual_call_data_cell_count) {
1075       tag = DataLayout::virtual_call_type_data_tag;
1076     } else {
1077       tag = DataLayout::virtual_call_data_tag;
1078     }
1079     break;
1080   }
1081   case Bytecodes::_invokedynamic: {
1082     // %%% should make a type profile for any invokedynamic that takes a ref argument
1083     int counter_data_cell_count = CounterData::static_cell_count();
1084     if (profile_arguments_for_invoke(stream-&gt;method(), stream-&gt;bci()) ||
1085         profile_return_for_invoke(stream-&gt;method(), stream-&gt;bci())) {
1086       cell_count = CallTypeData::compute_cell_count(stream);
1087     } else {
1088       cell_count = counter_data_cell_count;
1089     }
1090     if (cell_count &gt; counter_data_cell_count) {
1091       tag = DataLayout::call_type_data_tag;
1092     } else {
1093       tag = DataLayout::counter_data_tag;
1094     }
1095     break;
1096   }
1097   case Bytecodes::_ret:
1098     cell_count = RetData::static_cell_count();
1099     tag = DataLayout::ret_data_tag;
1100     break;
1101   case Bytecodes::_ifeq:
1102   case Bytecodes::_ifne:
1103   case Bytecodes::_iflt:
1104   case Bytecodes::_ifge:
1105   case Bytecodes::_ifgt:
1106   case Bytecodes::_ifle:
1107   case Bytecodes::_if_icmpeq:
1108   case Bytecodes::_if_icmpne:
1109   case Bytecodes::_if_icmplt:
1110   case Bytecodes::_if_icmpge:
1111   case Bytecodes::_if_icmpgt:
1112   case Bytecodes::_if_icmple:
1113   case Bytecodes::_if_acmpeq:
1114   case Bytecodes::_if_acmpne:
1115   case Bytecodes::_ifnull:
1116   case Bytecodes::_ifnonnull:
1117     cell_count = BranchData::static_cell_count();
1118     tag = DataLayout::branch_data_tag;
1119     break;
1120   case Bytecodes::_lookupswitch:
1121   case Bytecodes::_tableswitch:
1122     cell_count = MultiBranchData::compute_cell_count(stream);
1123     tag = DataLayout::multi_branch_data_tag;
1124     break;
1125   default:
1126     break;
1127   }
1128   assert(tag == DataLayout::multi_branch_data_tag ||
1129          ((MethodData::profile_arguments() || MethodData::profile_return()) &amp;&amp;
1130           (tag == DataLayout::call_type_data_tag ||
1131            tag == DataLayout::counter_data_tag ||
1132            tag == DataLayout::virtual_call_type_data_tag ||
1133            tag == DataLayout::virtual_call_data_tag)) ||
1134          cell_count == bytecode_cell_count(c), &quot;cell counts must agree&quot;);
1135   if (cell_count &gt;= 0) {
1136     assert(tag != DataLayout::no_tag, &quot;bad tag&quot;);
1137     assert(bytecode_has_profile(c), &quot;agree w/ BHP&quot;);
1138     data_layout-&gt;initialize(tag, stream-&gt;bci(), cell_count);
1139     return DataLayout::compute_size_in_bytes(cell_count);
1140   } else {
1141     assert(!bytecode_has_profile(c), &quot;agree w/ !BHP&quot;);
1142     return 0;
1143   }
1144 }
1145 
1146 // Get the data at an arbitrary (sort of) data index.
1147 ProfileData* MethodData::data_at(int data_index) const {
1148   if (out_of_bounds(data_index)) {
1149     return NULL;
1150   }
1151   DataLayout* data_layout = data_layout_at(data_index);
1152   return data_layout-&gt;data_in();
1153 }
1154 
1155 ProfileData* DataLayout::data_in() {
1156   switch (tag()) {
1157   case DataLayout::no_tag:
1158   default:
1159     ShouldNotReachHere();
1160     return NULL;
1161   case DataLayout::bit_data_tag:
1162     return new BitData(this);
1163   case DataLayout::counter_data_tag:
1164     return new CounterData(this);
1165   case DataLayout::jump_data_tag:
1166     return new JumpData(this);
1167   case DataLayout::receiver_type_data_tag:
1168     return new ReceiverTypeData(this);
1169   case DataLayout::virtual_call_data_tag:
1170     return new VirtualCallData(this);
1171   case DataLayout::ret_data_tag:
1172     return new RetData(this);
1173   case DataLayout::branch_data_tag:
1174     return new BranchData(this);
1175   case DataLayout::multi_branch_data_tag:
1176     return new MultiBranchData(this);
1177   case DataLayout::arg_info_data_tag:
1178     return new ArgInfoData(this);
1179   case DataLayout::call_type_data_tag:
1180     return new CallTypeData(this);
1181   case DataLayout::virtual_call_type_data_tag:
1182     return new VirtualCallTypeData(this);
1183   case DataLayout::parameters_type_data_tag:
1184     return new ParametersTypeData(this);
1185   case DataLayout::speculative_trap_data_tag:
1186     return new SpeculativeTrapData(this);
1187   }
1188 }
1189 
1190 // Iteration over data.
1191 ProfileData* MethodData::next_data(ProfileData* current) const {
1192   int current_index = dp_to_di(current-&gt;dp());
1193   int next_index = current_index + current-&gt;size_in_bytes();
1194   ProfileData* next = data_at(next_index);
1195   return next;
1196 }
1197 
1198 // Give each of the data entries a chance to perform specific
1199 // data initialization.
1200 void MethodData::post_initialize(BytecodeStream* stream) {
1201   ResourceMark rm;
1202   ProfileData* data;
1203   for (data = first_data(); is_valid(data); data = next_data(data)) {
1204     stream-&gt;set_start(data-&gt;bci());
1205     stream-&gt;next();
1206     data-&gt;post_initialize(stream, this);
1207   }
1208   if (_parameters_type_data_di != no_parameters) {
1209     parameters_type_data()-&gt;post_initialize(NULL, this);
1210   }
1211 }
1212 
1213 // Initialize the MethodData* corresponding to a given method.
1214 MethodData::MethodData(const methodHandle&amp; method, int size, TRAPS)
1215   : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;),
1216     _parameters_type_data_di(parameters_uninitialized) {
1217   // Set the method back-pointer.
1218   _method = method();
1219   initialize();
1220 }
1221 
1222 void MethodData::initialize() {
1223   Thread* thread = Thread::current();
1224   NoSafepointVerifier no_safepoint;  // init function atomic wrt GC
1225   ResourceMark rm(thread);
1226 
1227   init();
1228   set_creation_mileage(mileage_of(method()));
1229 
1230   // Go through the bytecodes and allocate and initialize the
1231   // corresponding data cells.
1232   int data_size = 0;
1233   int empty_bc_count = 0;  // number of bytecodes lacking data
1234   _data[0] = 0;  // apparently not set below.
1235   BytecodeStream stream(methodHandle(thread, method()));
1236   Bytecodes::Code c;
1237   bool needs_speculative_traps = false;
1238   while ((c = stream.next()) &gt;= 0) {
1239     int size_in_bytes = initialize_data(&amp;stream, data_size);
1240     data_size += size_in_bytes;
1241     if (size_in_bytes == 0 JVMCI_ONLY(&amp;&amp; Bytecodes::can_trap(c)))  empty_bc_count += 1;
1242     needs_speculative_traps = needs_speculative_traps || is_speculative_trap_bytecode(c);
1243   }
1244   _data_size = data_size;
1245   int object_size = in_bytes(data_offset()) + data_size;
1246 
1247   // Add some extra DataLayout cells (at least one) to track stray traps.
1248   int extra_data_count = compute_extra_data_count(data_size, empty_bc_count, needs_speculative_traps);
1249   int extra_size = extra_data_count * DataLayout::compute_size_in_bytes(0);
1250 
1251   // Let&#39;s zero the space for the extra data
1252   Copy::zero_to_bytes(((address)_data) + data_size, extra_size);
1253 
1254   // Add a cell to record information about modified arguments.
1255   // Set up _args_modified array after traps cells so that
1256   // the code for traps cells works.
1257   DataLayout *dp = data_layout_at(data_size + extra_size);
1258 
1259   int arg_size = method()-&gt;size_of_parameters();
1260   dp-&gt;initialize(DataLayout::arg_info_data_tag, 0, arg_size+1);
1261 
1262   int arg_data_size = DataLayout::compute_size_in_bytes(arg_size+1);
1263   object_size += extra_size + arg_data_size;
1264 
1265   int parms_cell = ParametersTypeData::compute_cell_count(method());
1266   // If we are profiling parameters, we reserver an area near the end
1267   // of the MDO after the slots for bytecodes (because there&#39;s no bci
1268   // for method entry so they don&#39;t fit with the framework for the
1269   // profiling of bytecodes). We store the offset within the MDO of
1270   // this area (or -1 if no parameter is profiled)
1271   if (parms_cell &gt; 0) {
1272     object_size += DataLayout::compute_size_in_bytes(parms_cell);
1273     _parameters_type_data_di = data_size + extra_size + arg_data_size;
1274     DataLayout *dp = data_layout_at(data_size + extra_size + arg_data_size);
1275     dp-&gt;initialize(DataLayout::parameters_type_data_tag, 0, parms_cell);
1276   } else {
1277     _parameters_type_data_di = no_parameters;
1278   }
1279 
1280   // Set an initial hint. Don&#39;t use set_hint_di() because
1281   // first_di() may be out of bounds if data_size is 0.
1282   // In that situation, _hint_di is never used, but at
1283   // least well-defined.
1284   _hint_di = first_di();
1285 
1286   post_initialize(&amp;stream);
1287 
1288   assert(object_size == compute_allocation_size_in_bytes(methodHandle(thread, _method)), &quot;MethodData: computed size != initialized size&quot;);
1289   set_size(object_size);
1290 }
1291 
1292 void MethodData::init() {
1293   _invocation_counter.init();
1294   _backedge_counter.init();
1295   _invocation_counter_start = 0;
1296   _backedge_counter_start = 0;
1297 
1298   // Set per-method invoke- and backedge mask.
1299   double scale = 1.0;
1300   methodHandle mh(Thread::current(), _method);
1301   CompilerOracle::has_option_value(mh, &quot;CompileThresholdScaling&quot;, scale);
1302   _invoke_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0InvokeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1303   _backedge_mask = right_n_bits(CompilerConfig::scaled_freq_log(Tier0BackedgeNotifyFreqLog, scale)) &lt;&lt; InvocationCounter::count_shift;
1304 
1305   _tenure_traps = 0;
1306   _num_loops = 0;
1307   _num_blocks = 0;
1308   _would_profile = unknown;
1309 
1310 #if INCLUDE_JVMCI
1311   _jvmci_ir_size = 0;
1312   _failed_speculations = NULL;
1313 #endif
1314 
1315 #if INCLUDE_RTM_OPT
1316   _rtm_state = NoRTM; // No RTM lock eliding by default
1317   if (UseRTMLocking &amp;&amp;
1318       !CompilerOracle::has_option_string(mh, &quot;NoRTMLockEliding&quot;)) {
1319     if (CompilerOracle::has_option_string(mh, &quot;UseRTMLockEliding&quot;) || !UseRTMDeopt) {
1320       // Generate RTM lock eliding code without abort ratio calculation code.
1321       _rtm_state = UseRTM;
1322     } else if (UseRTMDeopt) {
1323       // Generate RTM lock eliding code and include abort ratio calculation
1324       // code if UseRTMDeopt is on.
1325       _rtm_state = ProfileRTM;
1326     }
1327   }
1328 #endif
1329 
1330   // Initialize flags and trap history.
1331   _nof_decompiles = 0;
1332   _nof_overflow_recompiles = 0;
1333   _nof_overflow_traps = 0;
1334   clear_escape_info();
1335   assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, &quot;align&quot;);
1336   Copy::zero_to_words((HeapWord*) &amp;_trap_hist,
1337                       sizeof(_trap_hist) / sizeof(HeapWord));
1338 }
1339 
1340 // Get a measure of how much mileage the method has on it.
1341 int MethodData::mileage_of(Method* method) {
1342   int mileage = 0;
1343   if (TieredCompilation) {
1344     mileage = MAX2(method-&gt;invocation_count(), method-&gt;backedge_count());
1345   } else {
1346     int iic = method-&gt;interpreter_invocation_count();
1347     if (mileage &lt; iic)  mileage = iic;
1348     MethodCounters* mcs = method-&gt;method_counters();
1349     if (mcs != NULL) {
1350       InvocationCounter* ic = mcs-&gt;invocation_counter();
1351       InvocationCounter* bc = mcs-&gt;backedge_counter();
1352       int icval = ic-&gt;count();
1353       if (ic-&gt;carry()) icval += CompileThreshold;
1354       if (mileage &lt; icval)  mileage = icval;
1355       int bcval = bc-&gt;count();
1356       if (bc-&gt;carry()) bcval += CompileThreshold;
1357       if (mileage &lt; bcval)  mileage = bcval;
1358     }
1359   }
1360   return mileage;
1361 }
1362 
1363 bool MethodData::is_mature() const {
1364   return CompilationPolicy::policy()-&gt;is_mature(_method);
1365 }
1366 
1367 // Translate a bci to its corresponding data index (di).
1368 address MethodData::bci_to_dp(int bci) {
1369   ResourceMark rm;
1370   ProfileData* data = data_before(bci);
1371   ProfileData* prev = NULL;
1372   for ( ; is_valid(data); data = next_data(data)) {
1373     if (data-&gt;bci() &gt;= bci) {
1374       if (data-&gt;bci() == bci)  set_hint_di(dp_to_di(data-&gt;dp()));
1375       else if (prev != NULL)   set_hint_di(dp_to_di(prev-&gt;dp()));
1376       return data-&gt;dp();
1377     }
1378     prev = data;
1379   }
1380   return (address)limit_data_position();
1381 }
1382 
1383 // Translate a bci to its corresponding data, or NULL.
1384 ProfileData* MethodData::bci_to_data(int bci) {
1385   ProfileData* data = data_before(bci);
1386   for ( ; is_valid(data); data = next_data(data)) {
1387     if (data-&gt;bci() == bci) {
1388       set_hint_di(dp_to_di(data-&gt;dp()));
1389       return data;
1390     } else if (data-&gt;bci() &gt; bci) {
1391       break;
1392     }
1393   }
1394   return bci_to_extra_data(bci, NULL, false);
1395 }
1396 
1397 DataLayout* MethodData::next_extra(DataLayout* dp) {
1398   int nb_cells = 0;
1399   switch(dp-&gt;tag()) {
1400   case DataLayout::bit_data_tag:
1401   case DataLayout::no_tag:
1402     nb_cells = BitData::static_cell_count();
1403     break;
1404   case DataLayout::speculative_trap_data_tag:
1405     nb_cells = SpeculativeTrapData::static_cell_count();
1406     break;
1407   default:
1408     fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1409   }
1410   return (DataLayout*)((address)dp + DataLayout::compute_size_in_bytes(nb_cells));
1411 }
1412 
1413 ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent) {
1414   DataLayout* end = args_data_limit();
1415 
1416   for (;; dp = next_extra(dp)) {
1417     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
1418     // No need for &quot;Atomic::load_acquire&quot; ops,
1419     // since the data structure is monotonic.
1420     switch(dp-&gt;tag()) {
1421     case DataLayout::no_tag:
1422       return NULL;
1423     case DataLayout::arg_info_data_tag:
1424       dp = end;
1425       return NULL; // ArgInfoData is at the end of extra data section.
1426     case DataLayout::bit_data_tag:
1427       if (m == NULL &amp;&amp; dp-&gt;bci() == bci) {
1428         return new BitData(dp);
1429       }
1430       break;
1431     case DataLayout::speculative_trap_data_tag:
1432       if (m != NULL) {
1433         SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1434         // data-&gt;method() may be null in case of a concurrent
1435         // allocation. Maybe it&#39;s for the same method. Try to use that
1436         // entry in that case.
1437         if (dp-&gt;bci() == bci) {
1438           if (data-&gt;method() == NULL) {
1439             assert(concurrent, &quot;impossible because no concurrent allocation&quot;);
1440             return NULL;
1441           } else if (data-&gt;method() == m) {
1442             return data;
1443           }
1444         }
1445       }
1446       break;
1447     default:
1448       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1449     }
1450   }
1451   return NULL;
1452 }
1453 
1454 
1455 // Translate a bci to its corresponding extra data, or NULL.
1456 ProfileData* MethodData::bci_to_extra_data(int bci, Method* m, bool create_if_missing) {
1457   // This code assumes an entry for a SpeculativeTrapData is 2 cells
1458   assert(2*DataLayout::compute_size_in_bytes(BitData::static_cell_count()) ==
1459          DataLayout::compute_size_in_bytes(SpeculativeTrapData::static_cell_count()),
1460          &quot;code needs to be adjusted&quot;);
1461 
1462   // Do not create one of these if method has been redefined.
1463   if (m != NULL &amp;&amp; m-&gt;is_old()) {
1464     return NULL;
1465   }
1466 
1467   DataLayout* dp  = extra_data_base();
1468   DataLayout* end = args_data_limit();
1469 
1470   // Allocation in the extra data space has to be atomic because not
1471   // all entries have the same size and non atomic concurrent
1472   // allocation would result in a corrupted extra data space.
1473   ProfileData* result = bci_to_extra_data_helper(bci, m, dp, true);
1474   if (result != NULL) {
1475     return result;
1476   }
1477 
1478   if (create_if_missing &amp;&amp; dp &lt; end) {
1479     MutexLocker ml(&amp;_extra_data_lock);
1480     // Check again now that we have the lock. Another thread may
1481     // have added extra data entries.
1482     ProfileData* result = bci_to_extra_data_helper(bci, m, dp, false);
1483     if (result != NULL || dp &gt;= end) {
1484       return result;
1485     }
1486 
1487     assert(dp-&gt;tag() == DataLayout::no_tag || (dp-&gt;tag() == DataLayout::speculative_trap_data_tag &amp;&amp; m != NULL), &quot;should be free&quot;);
1488     assert(next_extra(dp)-&gt;tag() == DataLayout::no_tag || next_extra(dp)-&gt;tag() == DataLayout::arg_info_data_tag, &quot;should be free or arg info&quot;);
1489     u1 tag = m == NULL ? DataLayout::bit_data_tag : DataLayout::speculative_trap_data_tag;
1490     // SpeculativeTrapData is 2 slots. Make sure we have room.
1491     if (m != NULL &amp;&amp; next_extra(dp)-&gt;tag() != DataLayout::no_tag) {
1492       return NULL;
1493     }
1494     DataLayout temp;
1495     temp.initialize(tag, bci, 0);
1496 
1497     dp-&gt;set_header(temp.header());
1498     assert(dp-&gt;tag() == tag, &quot;sane&quot;);
1499     assert(dp-&gt;bci() == bci, &quot;no concurrent allocation&quot;);
1500     if (tag == DataLayout::bit_data_tag) {
1501       return new BitData(dp);
1502     } else {
1503       SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1504       data-&gt;set_method(m);
1505       return data;
1506     }
1507   }
1508   return NULL;
1509 }
1510 
1511 ArgInfoData *MethodData::arg_info() {
1512   DataLayout* dp    = extra_data_base();
1513   DataLayout* end   = args_data_limit();
1514   for (; dp &lt; end; dp = next_extra(dp)) {
1515     if (dp-&gt;tag() == DataLayout::arg_info_data_tag)
1516       return new ArgInfoData(dp);
1517   }
1518   return NULL;
1519 }
1520 
1521 // Printing
1522 
1523 void MethodData::print_on(outputStream* st) const {
1524   assert(is_methodData(), &quot;should be method data&quot;);
1525   st-&gt;print(&quot;method data for &quot;);
1526   method()-&gt;print_value_on(st);
1527   st-&gt;cr();
1528   print_data_on(st);
1529 }
1530 
1531 void MethodData::print_value_on(outputStream* st) const {
1532   assert(is_methodData(), &quot;should be method data&quot;);
1533   st-&gt;print(&quot;method data for &quot;);
1534   method()-&gt;print_value_on(st);
1535 }
1536 
1537 void MethodData::print_data_on(outputStream* st) const {
1538   ResourceMark rm;
1539   ProfileData* data = first_data();
1540   if (_parameters_type_data_di != no_parameters) {
1541     parameters_type_data()-&gt;print_data_on(st);
1542   }
1543   for ( ; is_valid(data); data = next_data(data)) {
1544     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1545     st-&gt;fill_to(6);
1546     data-&gt;print_data_on(st, this);
1547   }
1548   st-&gt;print_cr(&quot;--- Extra data:&quot;);
1549   DataLayout* dp    = extra_data_base();
1550   DataLayout* end   = args_data_limit();
1551   for (;; dp = next_extra(dp)) {
1552     assert(dp &lt; end, &quot;moved past end of extra data&quot;);
1553     // No need for &quot;Atomic::load_acquire&quot; ops,
1554     // since the data structure is monotonic.
1555     switch(dp-&gt;tag()) {
1556     case DataLayout::no_tag:
1557       continue;
1558     case DataLayout::bit_data_tag:
1559       data = new BitData(dp);
1560       break;
1561     case DataLayout::speculative_trap_data_tag:
1562       data = new SpeculativeTrapData(dp);
1563       break;
1564     case DataLayout::arg_info_data_tag:
1565       data = new ArgInfoData(dp);
1566       dp = end; // ArgInfoData is at the end of extra data section.
1567       break;
1568     default:
1569       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1570     }
1571     st-&gt;print(&quot;%d&quot;, dp_to_di(data-&gt;dp()));
1572     st-&gt;fill_to(6);
1573     data-&gt;print_data_on(st);
1574     if (dp &gt;= end) return;
1575   }
1576 }
1577 
1578 // Verification
1579 
1580 void MethodData::verify_on(outputStream* st) {
1581   guarantee(is_methodData(), &quot;object must be method data&quot;);
1582   // guarantee(m-&gt;is_perm(), &quot;should be in permspace&quot;);
1583   this-&gt;verify_data_on(st);
1584 }
1585 
1586 void MethodData::verify_data_on(outputStream* st) {
1587   NEEDS_CLEANUP;
1588   // not yet implemented.
1589 }
1590 
1591 bool MethodData::profile_jsr292(const methodHandle&amp; m, int bci) {
1592   if (m-&gt;is_compiled_lambda_form()) {
1593     return true;
1594   }
1595 
1596   Bytecode_invoke inv(m , bci);
1597   return inv.is_invokedynamic() || inv.is_invokehandle();
1598 }
1599 
1600 bool MethodData::profile_unsafe(const methodHandle&amp; m, int bci) {
1601   Bytecode_invoke inv(m , bci);
1602   if (inv.is_invokevirtual()) {
1603     if (inv.klass() == vmSymbols::jdk_internal_misc_Unsafe() ||
1604         inv.klass() == vmSymbols::sun_misc_Unsafe()) {
1605       ResourceMark rm;
1606       char* name = inv.name()-&gt;as_C_string();
1607       if (!strncmp(name, &quot;get&quot;, 3) || !strncmp(name, &quot;put&quot;, 3)) {
1608         return true;
1609       }
1610     }
1611   }
1612   return false;
1613 }
1614 
1615 int MethodData::profile_arguments_flag() {
1616   return TypeProfileLevel % 10;
1617 }
1618 
1619 bool MethodData::profile_arguments() {
1620   return profile_arguments_flag() &gt; no_type_profile &amp;&amp; profile_arguments_flag() &lt;= type_profile_all;
1621 }
1622 
1623 bool MethodData::profile_arguments_jsr292_only() {
1624   return profile_arguments_flag() == type_profile_jsr292;
1625 }
1626 
1627 bool MethodData::profile_all_arguments() {
1628   return profile_arguments_flag() == type_profile_all;
1629 }
1630 
1631 bool MethodData::profile_arguments_for_invoke(const methodHandle&amp; m, int bci) {
1632   if (!profile_arguments()) {
1633     return false;
1634   }
1635 
1636   if (profile_all_arguments()) {
1637     return true;
1638   }
1639 
1640   if (profile_unsafe(m, bci)) {
1641     return true;
1642   }
1643 
1644   assert(profile_arguments_jsr292_only(), &quot;inconsistent&quot;);
1645   return profile_jsr292(m, bci);
1646 }
1647 
1648 int MethodData::profile_return_flag() {
1649   return (TypeProfileLevel % 100) / 10;
1650 }
1651 
1652 bool MethodData::profile_return() {
1653   return profile_return_flag() &gt; no_type_profile &amp;&amp; profile_return_flag() &lt;= type_profile_all;
1654 }
1655 
1656 bool MethodData::profile_return_jsr292_only() {
1657   return profile_return_flag() == type_profile_jsr292;
1658 }
1659 
1660 bool MethodData::profile_all_return() {
1661   return profile_return_flag() == type_profile_all;
1662 }
1663 
1664 bool MethodData::profile_return_for_invoke(const methodHandle&amp; m, int bci) {
1665   if (!profile_return()) {
1666     return false;
1667   }
1668 
1669   if (profile_all_return()) {
1670     return true;
1671   }
1672 
1673   assert(profile_return_jsr292_only(), &quot;inconsistent&quot;);
1674   return profile_jsr292(m, bci);
1675 }
1676 
1677 int MethodData::profile_parameters_flag() {
1678   return TypeProfileLevel / 100;
1679 }
1680 
1681 bool MethodData::profile_parameters() {
1682   return profile_parameters_flag() &gt; no_type_profile &amp;&amp; profile_parameters_flag() &lt;= type_profile_all;
1683 }
1684 
1685 bool MethodData::profile_parameters_jsr292_only() {
1686   return profile_parameters_flag() == type_profile_jsr292;
1687 }
1688 
1689 bool MethodData::profile_all_parameters() {
1690   return profile_parameters_flag() == type_profile_all;
1691 }
1692 
1693 bool MethodData::profile_parameters_for_method(const methodHandle&amp; m) {
1694   if (!profile_parameters()) {
1695     return false;
1696   }
1697 
1698   if (profile_all_parameters()) {
1699     return true;
1700   }
1701 
1702   assert(profile_parameters_jsr292_only(), &quot;inconsistent&quot;);
1703   return m-&gt;is_compiled_lambda_form();
1704 }
1705 
1706 void MethodData::metaspace_pointers_do(MetaspaceClosure* it) {
1707   log_trace(cds)(&quot;Iter(MethodData): %p&quot;, this);
1708   it-&gt;push(&amp;_method);
1709 }
1710 
1711 void MethodData::clean_extra_data_helper(DataLayout* dp, int shift, bool reset) {
1712   if (shift == 0) {
1713     return;
1714   }
1715   if (!reset) {
1716     // Move all cells of trap entry at dp left by &quot;shift&quot; cells
1717     intptr_t* start = (intptr_t*)dp;
1718     intptr_t* end = (intptr_t*)next_extra(dp);
1719     for (intptr_t* ptr = start; ptr &lt; end; ptr++) {
1720       *(ptr-shift) = *ptr;
1721     }
1722   } else {
1723     // Reset &quot;shift&quot; cells stopping at dp
1724     intptr_t* start = ((intptr_t*)dp) - shift;
1725     intptr_t* end = (intptr_t*)dp;
1726     for (intptr_t* ptr = start; ptr &lt; end; ptr++) {
1727       *ptr = 0;
1728     }
1729   }
1730 }
1731 
1732 // Check for entries that reference an unloaded method
1733 class CleanExtraDataKlassClosure : public CleanExtraDataClosure {
1734   bool _always_clean;
1735 public:
1736   CleanExtraDataKlassClosure(bool always_clean) : _always_clean(always_clean) {}
1737   bool is_live(Method* m) {
1738     return !(_always_clean) &amp;&amp; m-&gt;method_holder()-&gt;is_loader_alive();
1739   }
1740 };
1741 
1742 // Check for entries that reference a redefined method
1743 class CleanExtraDataMethodClosure : public CleanExtraDataClosure {
1744 public:
1745   CleanExtraDataMethodClosure() {}
1746   bool is_live(Method* m) { return !m-&gt;is_old(); }
1747 };
1748 
1749 
1750 // Remove SpeculativeTrapData entries that reference an unloaded or
1751 // redefined method
1752 void MethodData::clean_extra_data(CleanExtraDataClosure* cl) {
1753   DataLayout* dp  = extra_data_base();
1754   DataLayout* end = args_data_limit();
1755 
1756   int shift = 0;
1757   for (; dp &lt; end; dp = next_extra(dp)) {
1758     switch(dp-&gt;tag()) {
1759     case DataLayout::speculative_trap_data_tag: {
1760       SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1761       Method* m = data-&gt;method();
1762       assert(m != NULL, &quot;should have a method&quot;);
1763       if (!cl-&gt;is_live(m)) {
1764         // &quot;shift&quot; accumulates the number of cells for dead
1765         // SpeculativeTrapData entries that have been seen so
1766         // far. Following entries must be shifted left by that many
1767         // cells to remove the dead SpeculativeTrapData entries.
1768         shift += (int)((intptr_t*)next_extra(dp) - (intptr_t*)dp);
1769       } else {
1770         // Shift this entry left if it follows dead
1771         // SpeculativeTrapData entries
1772         clean_extra_data_helper(dp, shift);
1773       }
1774       break;
1775     }
1776     case DataLayout::bit_data_tag:
1777       // Shift this entry left if it follows dead SpeculativeTrapData
1778       // entries
1779       clean_extra_data_helper(dp, shift);
1780       continue;
1781     case DataLayout::no_tag:
1782     case DataLayout::arg_info_data_tag:
1783       // We are at end of the live trap entries. The previous &quot;shift&quot;
1784       // cells contain entries that are either dead or were shifted
1785       // left. They need to be reset to no_tag
1786       clean_extra_data_helper(dp, shift, true);
1787       return;
1788     default:
1789       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1790     }
1791   }
1792 }
1793 
1794 // Verify there&#39;s no unloaded or redefined method referenced by a
1795 // SpeculativeTrapData entry
1796 void MethodData::verify_extra_data_clean(CleanExtraDataClosure* cl) {
1797 #ifdef ASSERT
1798   DataLayout* dp  = extra_data_base();
1799   DataLayout* end = args_data_limit();
1800 
1801   for (; dp &lt; end; dp = next_extra(dp)) {
1802     switch(dp-&gt;tag()) {
1803     case DataLayout::speculative_trap_data_tag: {
1804       SpeculativeTrapData* data = new SpeculativeTrapData(dp);
1805       Method* m = data-&gt;method();
1806       assert(m != NULL &amp;&amp; cl-&gt;is_live(m), &quot;Method should exist&quot;);
1807       break;
1808     }
1809     case DataLayout::bit_data_tag:
1810       continue;
1811     case DataLayout::no_tag:
1812     case DataLayout::arg_info_data_tag:
1813       return;
1814     default:
1815       fatal(&quot;unexpected tag %d&quot;, dp-&gt;tag());
1816     }
1817   }
1818 #endif
1819 }
1820 
1821 void MethodData::clean_method_data(bool always_clean) {
1822   ResourceMark rm;
1823   for (ProfileData* data = first_data();
1824        is_valid(data);
1825        data = next_data(data)) {
1826     data-&gt;clean_weak_klass_links(always_clean);
1827   }
1828   ParametersTypeData* parameters = parameters_type_data();
1829   if (parameters != NULL) {
1830     parameters-&gt;clean_weak_klass_links(always_clean);
1831   }
1832 
1833   CleanExtraDataKlassClosure cl(always_clean);
1834   clean_extra_data(&amp;cl);
1835   verify_extra_data_clean(&amp;cl);
1836 }
1837 
1838 // This is called during redefinition to clean all &quot;old&quot; redefined
1839 // methods out of MethodData for all methods.
1840 void MethodData::clean_weak_method_links() {
1841   ResourceMark rm;
1842   for (ProfileData* data = first_data();
1843        is_valid(data);
1844        data = next_data(data)) {
1845     data-&gt;clean_weak_method_links();
1846   }
1847 
1848   CleanExtraDataMethodClosure cl;
1849   clean_extra_data(&amp;cl);
1850   verify_extra_data_clean(&amp;cl);
1851 }
1852 
1853 #ifdef ASSERT
1854 void MethodData::verify_clean_weak_method_links() {
1855   ResourceMark rm;
1856   for (ProfileData* data = first_data();
1857        is_valid(data);
1858        data = next_data(data)) {
1859     data-&gt;verify_clean_weak_method_links();
1860   }
1861 
1862   CleanExtraDataMethodClosure cl;
1863   verify_extra_data_clean(&amp;cl);
1864 }
1865 #endif // ASSERT
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>