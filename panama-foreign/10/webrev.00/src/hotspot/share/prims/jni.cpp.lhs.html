<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markWord.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/symbol.hpp&quot;
  59 #include &quot;oops/typeArrayKlass.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/jniCheck.hpp&quot;
  62 #include &quot;prims/jniExport.hpp&quot;
  63 #include &quot;prims/jniFastGetField.hpp&quot;
  64 #include &quot;prims/jvm_misc.hpp&quot;
  65 #include &quot;prims/jvmtiExport.hpp&quot;
  66 #include &quot;prims/jvmtiThreadState.hpp&quot;
  67 #include &quot;runtime/atomic.hpp&quot;
  68 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  69 #include &quot;runtime/handles.inline.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/reflection.hpp&quot;
  76 #include &quot;runtime/safepointVerifiers.hpp&quot;
  77 #include &quot;runtime/sharedRuntime.hpp&quot;
  78 #include &quot;runtime/signature.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;services/memTracker.hpp&quot;
  82 #include &quot;services/runtimeService.hpp&quot;
  83 #include &quot;utilities/defaultStream.hpp&quot;
  84 #include &quot;utilities/dtrace.hpp&quot;
  85 #include &quot;utilities/events.hpp&quot;
  86 #include &quot;utilities/histogram.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #include &quot;utilities/vmError.hpp&quot;
  89 #if INCLUDE_JVMCI
  90 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  91 #endif
  92 
  93 static jint CurrentVersion = JNI_VERSION_10;
  94 
  95 #ifdef _WIN32
  96 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
  97 #endif
  98 
  99 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 100 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 101 // Methods that have multiple return paths use this to avoid having to
 102 // instrument each return path.  Methods that use CHECK or THROW must use this
 103 // since those macros can cause an immedate uninstrumented return.
 104 //
 105 // In order to get the return value, a reference to the variable containing
 106 // the return value must be passed to the contructor of the object, and
 107 // the return value must be set before return (since the mark object has
 108 // a reference to it).
 109 //
 110 // Example:
 111 // DT_RETURN_MARK_DECL(SomeFunc, int);
 112 // JNI_ENTRY(int, SomeFunc, ...)
 113 //   int return_value = 0;
 114 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 115 //   foo(CHECK_0)
 116 //   return_value = 5;
 117 //   return return_value;
 118 // JNI_END
 119 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 120   DTRACE_ONLY(                                                             \
 121     class DTraceReturnProbeMark_##name {                                   \
 122      public:                                                               \
 123       const type&amp; _ret_ref;                                                \
 124       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 125       ~DTraceReturnProbeMark_##name() {                                    \
 126         probe;                                                             \
 127       }                                                                    \
 128     }                                                                      \
 129   )
 130 // Void functions are simpler since there&#39;s no return value
 131 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 132   DTRACE_ONLY(                                                             \
 133     class DTraceReturnProbeMark_##name {                                   \
 134      public:                                                               \
 135       ~DTraceReturnProbeMark_##name() {                                    \
 136         probe;                                                             \
 137       }                                                                    \
 138     }                                                                      \
 139   )
 140 
 141 // Place these macros in the function to mark the return.  Non-void
 142 // functions need the type and address of the return value.
 143 #define DT_RETURN_MARK(name, type, ref) \
 144   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 145 #define DT_VOID_RETURN_MARK(name) \
 146   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 147 
 148 
 149 // Use these to select distinct code for floating-point vs. non-floating point
 150 // situations.  Used from within common macros where we need slightly
 151 // different behavior for Float/Double
 152 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 153 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 154 #define FP_SELECT_Char(intcode, fpcode)    intcode
 155 #define FP_SELECT_Short(intcode, fpcode)   intcode
 156 #define FP_SELECT_Object(intcode, fpcode)  intcode
 157 #define FP_SELECT_Int(intcode, fpcode)     intcode
 158 #define FP_SELECT_Long(intcode, fpcode)    intcode
 159 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 160 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 161 #define FP_SELECT(TypeName, intcode, fpcode) \
 162   FP_SELECT_##TypeName(intcode, fpcode)
 163 
 164 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 165 // (dtrace doesn&#39;t do FP yet)
 166 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 167   FP_SELECT(TypeName, \
 168     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 169 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 172 
 173 
 174 // out-of-line helpers for class jfieldIDWorkaround:
 175 
 176 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 177   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 178     uintptr_t as_uint = (uintptr_t) id;
 179     intptr_t offset = raw_instance_offset(id);
 180     if (is_checked_jfieldID(id)) {
 181       if (!klass_hash_ok(k, id)) {
 182         return false;
 183       }
 184     }
 185     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 186   } else {
 187     JNIid* result = (JNIid*) id;
 188 #ifdef ASSERT
 189     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 190 #else
 191     return result != NULL;
 192 #endif
 193   }
 194 }
 195 
 196 
 197 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 198   if (offset &lt;= small_offset_mask) {
 199     Klass* field_klass = k;
 200     Klass* super_klass = field_klass-&gt;super();
 201     // With compressed oops the most super class with nonstatic fields would
 202     // be the owner of fields embedded in the header.
 203     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 204            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 205       field_klass = super_klass;   // super contains the field also
 206       super_klass = field_klass-&gt;super();
 207     }
 208     debug_only(NoSafepointVerifier nosafepoint;)
 209     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 210     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 211   } else {
 212 #if 0
 213     #ifndef PRODUCT
 214     {
 215       ResourceMark rm;
 216       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 217     }
 218     #endif
 219 #endif
 220     return 0;
 221   }
 222 }
 223 
 224 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 225   uintptr_t as_uint = (uintptr_t) id;
 226   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 227   do {
 228     debug_only(NoSafepointVerifier nosafepoint;)
 229     // Could use a non-blocking query for identity_hash here...
 230     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 231       return true;
 232     k = k-&gt;super();
 233   } while (k != NULL);
 234   return false;
 235 }
 236 
 237 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 238   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 239   uintptr_t as_uint = (uintptr_t) id;
 240   intptr_t offset = raw_instance_offset(id);
 241   if (VerifyJNIFields) {
 242     if (is_checked_jfieldID(id)) {
 243       guarantee(klass_hash_ok(k, id),
 244     &quot;Bug in native code: jfieldID class must match object&quot;);
 245     } else {
 246 #if 0
 247       #ifndef PRODUCT
 248       if (Verbose) {
 249   ResourceMark rm;
 250   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 251       }
 252       #endif
 253 #endif
 254     }
 255   }
 256   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 257       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 258 }
 259 
 260 // Wrapper to trace JNI functions
 261 
 262 #ifdef ASSERT
 263   Histogram* JNIHistogram;
 264   static volatile int JNIHistogram_lock = 0;
 265 
 266   class JNIHistogramElement : public HistogramElement {
 267     public:
 268      JNIHistogramElement(const char* name);
 269   };
 270 
 271   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 272     _name = elementName;
 273     uintx count = 0;
 274 
 275     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 276       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 277         count +=1;
 278         if ( (WarnOnStalledSpinLock &gt; 0)
 279           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 280           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 281         }
 282       }
 283      }
 284 
 285 
 286     if(JNIHistogram == NULL)
 287       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 288 
 289     JNIHistogram-&gt;add_element(this);
 290     Atomic::dec(&amp;JNIHistogram_lock);
 291   }
 292 
 293   #define JNICountWrapper(arg)                                     \
 294      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 295       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 296      if (e != NULL) e-&gt;increment_count()
 297   #define JNIWrapper(arg) JNICountWrapper(arg);
 298 #else
 299   #define JNIWrapper(arg)
 300 #endif
 301 
 302 
 303 // Implementation of JNI entries
 304 
 305 DT_RETURN_MARK_DECL(DefineClass, jclass
 306                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 307 
 308 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 309                                   const jbyte *buf, jsize bufLen))
 310   JNIWrapper(&quot;DefineClass&quot;);
 311 
 312   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 313     env, (char*) name, loaderRef, (char*) buf, bufLen);
 314 
 315   jclass cls = NULL;
 316   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 317 
 318   TempNewSymbol class_name = NULL;
 319   // Since exceptions can be thrown, class initialization can take place
 320   // if name is NULL no check for class name in .class stream has to be made.
 321   if (name != NULL) {
 322     const int str_len = (int)strlen(name);
 323     if (str_len &gt; Symbol::max_length()) {
 324       // It&#39;s impossible to create this class;  the name cannot fit
 325       // into the constant pool.
 326       Exceptions::fthrow(THREAD_AND_LOCATION,
 327                          vmSymbols::java_lang_NoClassDefFoundError(),
 328                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 329                          Symbol::max_length(),
 330                          name);
 331       return 0;
 332     }
 333     class_name = SymbolTable::new_symbol(name);
 334   }
 335   ResourceMark rm(THREAD);
 336   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 337   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 338 
 339   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 340     // check whether the current caller thread holds the lock or not.
 341     // If not, increment the corresponding counter
 342     if (ObjectSynchronizer::
 343         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 344         ObjectSynchronizer::owner_self) {
 345       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 346     }
 347   }
 348   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 349                                                    class_loader,
 350                                                    Handle(),
 351                                                    &amp;st,
 352                                                    CHECK_NULL);
 353 
 354   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 355     trace_class_resolution(k);
 356   }
 357 
 358   cls = (jclass)JNIHandles::make_local(
 359     env, k-&gt;java_mirror());
 360   return cls;
 361 JNI_END
 362 
 363 
 364 
 365 DT_RETURN_MARK_DECL(FindClass, jclass
 366                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 367 
 368 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 369   JNIWrapper(&quot;FindClass&quot;);
 370 
 371   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 372 
 373   jclass result = NULL;
 374   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 375 
 376   // Sanity check the name:  it cannot be null or larger than the maximum size
 377   // name we can fit in the constant pool.
 378   if (name == NULL) {
 379     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 380   }
 381   if ((int)strlen(name) &gt; Symbol::max_length()) {
 382     Exceptions::fthrow(THREAD_AND_LOCATION,
 383                        vmSymbols::java_lang_NoClassDefFoundError(),
 384                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 385                        Symbol::max_length(),
 386                        name);
 387     return 0;
 388   }
 389 
 390   //%note jni_3
 391   Handle protection_domain;
 392   // Find calling class
 393   Klass* k = thread-&gt;security_get_caller_class(0);
 394   // default to the system loader when no context
 395   Handle loader(THREAD, SystemDictionary::java_system_loader());
 396   if (k != NULL) {
 397     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 398     // in the correct class context.
 399     if (k-&gt;class_loader() == NULL &amp;&amp;
 400         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {
 401       JavaValue result(T_OBJECT);
 402       JavaCalls::call_static(&amp;result, k,
 403                              vmSymbols::getFromClass_name(),
 404                              vmSymbols::void_class_signature(),
 405                              CHECK_NULL);
 406       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns
 407       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 408       // it will return NULL to indicate no context.
 409       oop mirror = (oop) result.get_jobject();
 410       if (mirror != NULL) {
 411         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 412         loader = Handle(THREAD, fromClass-&gt;class_loader());
 413         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 414       }
 415     } else {
 416       loader = Handle(THREAD, k-&gt;class_loader());
 417     }
 418   }
 419 
 420   TempNewSymbol sym = SymbolTable::new_symbol(name);
 421   result = find_class_from_class_loader(env, sym, true, loader,
 422                                         protection_domain, true, thread);
 423 
 424   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 425     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 426   }
 427 
 428   return result;
 429 JNI_END
 430 
 431 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 432                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 433 
 434 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 435   JNIWrapper(&quot;FromReflectedMethod&quot;);
 436 
 437   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 438 
 439   jmethodID ret = NULL;
 440   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 441 
 442   // method is a handle to a java.lang.reflect.Method object
 443   oop reflected  = JNIHandles::resolve_non_null(method);
 444   oop mirror     = NULL;
 445   int slot       = 0;
 446 
 447   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 448     mirror = java_lang_reflect_Constructor::clazz(reflected);
 449     slot   = java_lang_reflect_Constructor::slot(reflected);
 450   } else {
 451     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 452     mirror = java_lang_reflect_Method::clazz(reflected);
 453     slot   = java_lang_reflect_Method::slot(reflected);
 454   }
 455   Klass* k1 = java_lang_Class::as_Klass(mirror);
 456 
 457   // Make sure class is initialized before handing id&#39;s out to methods
 458   k1-&gt;initialize(CHECK_NULL);
 459   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 460   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 461   return ret;
 462 JNI_END
 463 
 464 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 465                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 466 
 467 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 468   JNIWrapper(&quot;FromReflectedField&quot;);
 469 
 470   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 471 
 472   jfieldID ret = NULL;
 473   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 474 
 475   // field is a handle to a java.lang.reflect.Field object
 476   oop reflected   = JNIHandles::resolve_non_null(field);
 477   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 478   Klass* k1       = java_lang_Class::as_Klass(mirror);
 479   int slot        = java_lang_reflect_Field::slot(reflected);
 480   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 481 
 482   // Make sure class is initialized before handing id&#39;s out to fields
 483   k1-&gt;initialize(CHECK_NULL);
 484 
 485   // First check if this is a static field
 486   if (modifiers &amp; JVM_ACC_STATIC) {
 487     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 488     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 489     assert(id != NULL, &quot;corrupt Field object&quot;);
 490     debug_only(id-&gt;set_is_static_field_id();)
 491     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 492     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 493     return ret;
 494   }
 495 
 496   // The slot is the index of the field description in the field-array
 497   // The jfieldID is the offset of the field within the object
 498   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 499   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 500   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 501   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);
 502   return ret;
 503 JNI_END
 504 
 505 
 506 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 507                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 508 
 509 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 510   JNIWrapper(&quot;ToReflectedMethod&quot;);
 511 
 512   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 513 
 514   jobject ret = NULL;
 515   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 516 
 517   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 518   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 519   oop reflection_method;
 520   if (m-&gt;is_initializer()) {
 521     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 522   } else {
 523     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 524   }
 525   ret = JNIHandles::make_local(env, reflection_method);
 526   return ret;
 527 JNI_END
 528 
 529 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 530                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 531 
 532 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 533   JNIWrapper(&quot;GetSuperclass&quot;);
 534 
 535   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 536 
 537   jclass obj = NULL;
 538   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 539 
 540   oop mirror = JNIHandles::resolve_non_null(sub);
 541   // primitive classes return NULL
 542   if (java_lang_Class::is_primitive(mirror)) return NULL;
 543 
 544   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 545   // arrays return Object
 546   // interfaces return NULL
 547   // proper classes return Klass::super()
 548   Klass* k = java_lang_Class::as_Klass(mirror);
 549   if (k-&gt;is_interface()) return NULL;
 550 
 551   // return mirror for superclass
 552   Klass* super = k-&gt;java_super();
 553   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 554   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 555                                  ? SystemDictionary::Object_klass()
 556                                  : k-&gt;super() ) );
 557   assert(super == super2,
 558          &quot;java_super computation depends on interface, array, other super&quot;);
 559   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 560   return obj;
 561 JNI_END
 562 
 563 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 564   JNIWrapper(&quot;IsSubclassOf&quot;);
 565 
 566   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 567 
 568   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 569   oop super_mirror = JNIHandles::resolve_non_null(super);
 570   if (java_lang_Class::is_primitive(sub_mirror) ||
 571       java_lang_Class::is_primitive(super_mirror)) {
 572     jboolean ret = (sub_mirror == super_mirror);
 573 
 574     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 575     return ret;
 576   }
 577   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 578   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 579   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 580   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 581                    JNI_TRUE : JNI_FALSE;
 582 
 583   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 584   return ret;
 585 JNI_END
 586 
 587 
 588 DT_RETURN_MARK_DECL(Throw, jint
 589                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 590 
 591 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 592   JNIWrapper(&quot;Throw&quot;);
 593 
 594   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 595 
 596   jint ret = JNI_OK;
 597   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 598 
 599   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 600   ShouldNotReachHere();
 601   return 0;  // Mute compiler.
 602 JNI_END
 603 
 604 
 605 DT_RETURN_MARK_DECL(ThrowNew, jint
 606                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 607 
 608 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 609   JNIWrapper(&quot;ThrowNew&quot;);
 610 
 611   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 612 
 613   jint ret = JNI_OK;
 614   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 615 
 616   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 617   Symbol*  name = k-&gt;name();
 618   Handle class_loader (THREAD,  k-&gt;class_loader());
 619   Handle protection_domain (THREAD, k-&gt;protection_domain());
 620   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 621   ShouldNotReachHere();
 622   return 0;  // Mute compiler.
 623 JNI_END
 624 
 625 
 626 // JNI functions only transform a pending async exception to a synchronous
 627 // exception in ExceptionOccurred and ExceptionCheck calls, since
 628 // delivering an async exception in other places won&#39;t change the native
 629 // code&#39;s control flow and would be harmful when native code further calls
 630 // JNI functions with a pending exception. Async exception is also checked
 631 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 632 // false but deliver the async exception at the very end during
 633 // state transition.
 634 
 635 static void jni_check_async_exceptions(JavaThread *thread) {
 636   assert(thread == Thread::current(), &quot;must be itself&quot;);
 637   thread-&gt;check_and_handle_async_exceptions();
 638 }
 639 
 640 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 641   JNIWrapper(&quot;ExceptionOccurred&quot;);
 642 
 643   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 644 
 645   jni_check_async_exceptions(thread);
 646   oop exception = thread-&gt;pending_exception();
 647   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 648 
 649   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 650   return ret;
 651 JNI_END
 652 
 653 
 654 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 655   JNIWrapper(&quot;ExceptionDescribe&quot;);
 656 
 657   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 658 
 659   if (thread-&gt;has_pending_exception()) {
 660     Handle ex(thread, thread-&gt;pending_exception());
 661     thread-&gt;clear_pending_exception();
 662     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 663       // Don&#39;t print anything if we are being killed.
 664     } else {
 665       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 666       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 667         ResourceMark rm(THREAD);
 668         jio_fprintf(defaultStream::error_stream(),
 669         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 670       }
 671       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 672         JavaValue result(T_VOID);
 673         JavaCalls::call_virtual(&amp;result,
 674                                 ex,
 675                                 SystemDictionary::Throwable_klass(),
 676                                 vmSymbols::printStackTrace_name(),
 677                                 vmSymbols::void_method_signature(),
 678                                 THREAD);
 679         // If an exception is thrown in the call it gets thrown away. Not much
 680         // we can do with it. The native code that calls this, does not check
 681         // for the exception - hence, it might still be in the thread when DestroyVM gets
 682         // called, potentially causing a few asserts to trigger - since no pending exception
 683         // is expected.
 684         CLEAR_PENDING_EXCEPTION;
 685       } else {
 686         ResourceMark rm(THREAD);
 687         jio_fprintf(defaultStream::error_stream(),
 688         &quot;. Uncaught exception of type %s.&quot;,
 689         ex-&gt;klass()-&gt;external_name());
 690       }
 691     }
 692   }
 693 
 694   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 695 JNI_END
 696 
 697 
 698 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 699   JNIWrapper(&quot;ExceptionClear&quot;);
 700 
 701   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 702 
 703   // The jni code might be using this API to clear java thrown exception.
 704   // So just mark jvmti thread exception state as exception caught.
 705   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 706   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 707     state-&gt;set_exception_caught();
 708   }
 709   thread-&gt;clear_pending_exception();
 710 
 711   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 712 JNI_END
 713 
 714 
 715 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 716   JNIWrapper(&quot;FatalError&quot;);
 717 
 718   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 719 
 720   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 721   thread-&gt;print_stack();
 722   os::abort(); // Dump core and abort
 723 JNI_END
 724 
 725 
 726 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 727   JNIWrapper(&quot;PushLocalFrame&quot;);
 728 
 729   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 730 
 731   //%note jni_11
 732   if (capacity &lt; 0 ||
 733       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 734     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 735     return JNI_ERR;
 736   }
 737   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 738   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 739   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 740   new_handles-&gt;set_pop_frame_link(old_handles);
 741   thread-&gt;set_active_handles(new_handles);
 742   jint ret = JNI_OK;
 743   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 744   return ret;
 745 JNI_END
 746 
 747 
 748 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 749   JNIWrapper(&quot;PopLocalFrame&quot;);
 750 
 751   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 752 
 753   //%note jni_11
 754   Handle result_handle(thread, JNIHandles::resolve(result));
 755   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 756   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 757   if (new_handles != NULL) {
 758     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 759     // This way code will still work if PopLocalFrame is called without a corresponding
 760     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 761     // the release_block call will release the blocks.
 762     thread-&gt;set_active_handles(new_handles);
 763     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 764     JNIHandleBlock::release_block(old_handles, thread); // may block
 765     result = JNIHandles::make_local(thread, result_handle());
 766   }
 767   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 768   return result;
 769 JNI_END
 770 
 771 
 772 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 773   JNIWrapper(&quot;NewGlobalRef&quot;);
 774 
 775   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 776 
 777   Handle ref_handle(thread, JNIHandles::resolve(ref));
 778   jobject ret = JNIHandles::make_global(ref_handle);
 779 
 780   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 781   return ret;
 782 JNI_END
 783 
 784 // Must be JNI_ENTRY (with HandleMark)
 785 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 786   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 787 
 788   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 789 
 790   JNIHandles::destroy_global(ref);
 791 
 792   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 793 JNI_END
 794 
 795 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 796   JNIWrapper(&quot;DeleteLocalRef&quot;);
 797 
 798   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 799 
 800   JNIHandles::destroy_local(obj);
 801 
 802   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 803 JNI_END
 804 
 805 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 806   JNIWrapper(&quot;IsSameObject&quot;);
 807 
 808   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 809 
 810   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 811 
 812   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 813   return ret;
 814 JNI_END
 815 
 816 
 817 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 818   JNIWrapper(&quot;NewLocalRef&quot;);
 819 
 820   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 821 
 822   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 823 
 824   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 825   return ret;
 826 JNI_END
 827 
 828 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 829   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 830 
 831   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 832 
 833   jint ret;
 834   if (capacity &gt;= 0 &amp;&amp;
 835       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 836     ret = JNI_OK;
 837   } else {
 838     ret = JNI_ERR;
 839   }
 840 
 841   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 842   return ret;
 843 JNI_END
 844 
 845 // Return the Handle Type
 846 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 847   JNIWrapper(&quot;GetObjectRefType&quot;);
 848 
 849   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 850 
 851   jobjectRefType ret = JNIInvalidRefType;
 852   if (obj != NULL) {
 853     ret = JNIHandles::handle_type(thread, obj);
 854   }
 855 
 856   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 857   return ret;
 858 JNI_END
 859 
 860 
 861 class JNI_ArgumentPusher : public SignatureIterator {
 862  protected:
 863   JavaCallArguments*  _arguments;
 864 
<a name="2" id="anc2"></a><span class="line-modified"> 865   virtual void get_bool   () = 0;</span>
<span class="line-modified"> 866   virtual void get_char   () = 0;</span>
<span class="line-modified"> 867   virtual void get_short  () = 0;</span>
<span class="line-modified"> 868   virtual void get_byte   () = 0;</span>
<span class="line-modified"> 869   virtual void get_int    () = 0;</span>
<span class="line-modified"> 870   virtual void get_long   () = 0;</span>
<span class="line-modified"> 871   virtual void get_float  () = 0;</span>
<span class="line-modified"> 872   virtual void get_double () = 0;</span>
<span class="line-modified"> 873   virtual void get_object () = 0;</span>
<span class="line-modified"> 874 </span>
<span class="line-modified"> 875   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified"> 876     this-&gt;_return_type = T_ILLEGAL;</span>






 877     _arguments = NULL;
 878   }
 879 
 880  public:
<a name="3" id="anc3"></a><span class="line-modified"> 881   virtual void iterate( uint64_t fingerprint ) = 0;</span>
<span class="line-removed"> 882 </span>
<span class="line-removed"> 883   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }</span>
<span class="line-removed"> 884 </span>
<span class="line-removed"> 885   inline void do_bool()                     { if (!is_return_type()) get_bool();   }</span>
<span class="line-removed"> 886   inline void do_char()                     { if (!is_return_type()) get_char();   }</span>
<span class="line-removed"> 887   inline void do_short()                    { if (!is_return_type()) get_short();  }</span>
<span class="line-removed"> 888   inline void do_byte()                     { if (!is_return_type()) get_byte();   }</span>
<span class="line-removed"> 889   inline void do_int()                      { if (!is_return_type()) get_int();    }</span>
<span class="line-removed"> 890   inline void do_long()                     { if (!is_return_type()) get_long();   }</span>
<span class="line-removed"> 891   inline void do_float()                    { if (!is_return_type()) get_float();  }</span>
<span class="line-removed"> 892   inline void do_double()                   { if (!is_return_type()) get_double(); }</span>
<span class="line-removed"> 893   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }</span>
<span class="line-removed"> 894   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array</span>
<span class="line-removed"> 895   inline void do_void()                     { }</span>
<span class="line-removed"> 896 </span>
<span class="line-removed"> 897   JavaCallArguments* arguments()     { return _arguments; }</span>
<span class="line-removed"> 898   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }</span>
 899 };
 900 
 901 
 902 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 903  protected:
 904   va_list _ap;
 905 
<a name="4" id="anc4"></a><span class="line-modified"> 906   inline void get_bool()   {</span>
<span class="line-modified"> 907     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed"> 908     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed"> 909     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed"> 910     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed"> 911     jboolean b = va_arg(_ap, jint);</span>
<span class="line-removed"> 912     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
 913   }
<a name="5" id="anc5"></a><span class="line-removed"> 914   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg</span>
<span class="line-removed"> 915   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg</span>
<span class="line-removed"> 916   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg</span>
<span class="line-removed"> 917   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }</span>
<span class="line-removed"> 918 </span>
<span class="line-removed"> 919   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }</span>
<span class="line-removed"> 922   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg</span>
<span class="line-removed"> 923   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }</span>
<span class="line-removed"> 924   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }</span>
 925 
<a name="6" id="anc6"></a><span class="line-modified"> 926   inline void set_ap(va_list rap) {</span>
<span class="line-modified"> 927     va_copy(_ap, rap);</span>



















 928   }
 929 
 930  public:
<a name="7" id="anc7"></a><span class="line-removed"> 931   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)</span>
<span class="line-removed"> 932        : JNI_ArgumentPusher(signature) {</span>
<span class="line-removed"> 933     set_ap(rap);</span>
<span class="line-removed"> 934   }</span>
 935   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<a name="8" id="anc8"></a><span class="line-modified"> 936       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
 937     set_ap(rap);
 938   }
 939 
<a name="9" id="anc9"></a><span class="line-modified"> 940   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified"> 941   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified"> 942     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed"> 943       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed"> 944     } else {</span>
<span class="line-removed"> 945       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed"> 946                                   result_feature_mask);</span>
<span class="line-removed"> 947 </span>
<span class="line-removed"> 948       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed"> 949       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed"> 950       while ( 1 ) {</span>
<span class="line-removed"> 951         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed"> 952           case bool_parm:</span>
<span class="line-removed"> 953             get_bool();</span>
<span class="line-removed"> 954             break;</span>
<span class="line-removed"> 955           case char_parm:</span>
<span class="line-removed"> 956             get_char();</span>
<span class="line-removed"> 957             break;</span>
<span class="line-removed"> 958           case short_parm:</span>
<span class="line-removed"> 959             get_short();</span>
<span class="line-removed"> 960             break;</span>
<span class="line-removed"> 961           case byte_parm:</span>
<span class="line-removed"> 962             get_byte();</span>
<span class="line-removed"> 963             break;</span>
<span class="line-removed"> 964           case int_parm:</span>
<span class="line-removed"> 965             get_int();</span>
<span class="line-removed"> 966             break;</span>
<span class="line-removed"> 967           case obj_parm:</span>
<span class="line-removed"> 968             get_object();</span>
<span class="line-removed"> 969             break;</span>
<span class="line-removed"> 970           case long_parm:</span>
<span class="line-removed"> 971             get_long();</span>
<span class="line-removed"> 972             break;</span>
<span class="line-removed"> 973           case float_parm:</span>
<span class="line-removed"> 974             get_float();</span>
<span class="line-removed"> 975             break;</span>
<span class="line-removed"> 976           case double_parm:</span>
<span class="line-removed"> 977             get_double();</span>
<span class="line-removed"> 978             break;</span>
<span class="line-removed"> 979           case done_parm:</span>
<span class="line-removed"> 980             return;</span>
<span class="line-removed"> 981             break;</span>
<span class="line-removed"> 982           default:</span>
<span class="line-removed"> 983             ShouldNotReachHere();</span>
<span class="line-removed"> 984             break;</span>
<span class="line-removed"> 985         }</span>
<span class="line-removed"> 986         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed"> 987       }</span>
<span class="line-removed"> 988     }</span>
 989   }
 990 };
 991 
 992 
 993 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 994  protected:
 995   const jvalue *_ap;
 996 
<a name="10" id="anc10"></a><span class="line-removed"> 997   inline void get_bool()   {</span>
<span class="line-removed"> 998     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed"> 999     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed">1000     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed">1001     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed">1002     jboolean b = (_ap++)-&gt;z;</span>
<span class="line-removed">1003     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
<span class="line-removed">1004   }</span>
<span class="line-removed">1005   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }</span>
<span class="line-removed">1006   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }</span>
<span class="line-removed">1007   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }</span>
<span class="line-removed">1008   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }</span>
<span class="line-removed">1009 </span>
<span class="line-removed">1010   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }</span>
<span class="line-removed">1011   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }</span>
<span class="line-removed">1012   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}</span>
<span class="line-removed">1013   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }</span>
<span class="line-removed">1014 </span>
1015   inline void set_ap(const jvalue *rap) { _ap = rap; }
1016 
<a name="11" id="anc11"></a><span class="line-modified">1017  public:</span>
<span class="line-modified">1018   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)</span>
<span class="line-modified">1019        : JNI_ArgumentPusher(signature) {</span>
<span class="line-modified">1020     set_ap(rap);</span>











1021   }
<a name="12" id="anc12"></a>

1022   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<a name="13" id="anc13"></a><span class="line-modified">1023       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
1024     set_ap(rap);
1025   }
1026 
<a name="14" id="anc14"></a><span class="line-modified">1027   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified">1028   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified">1029     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed">1030       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed">1031     } else {</span>
<span class="line-removed">1032       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed">1033                                   result_feature_mask);</span>
<span class="line-removed">1034       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed">1035       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed">1036       while ( 1 ) {</span>
<span class="line-removed">1037         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed">1038           case bool_parm:</span>
<span class="line-removed">1039             get_bool();</span>
<span class="line-removed">1040             break;</span>
<span class="line-removed">1041           case char_parm:</span>
<span class="line-removed">1042             get_char();</span>
<span class="line-removed">1043             break;</span>
<span class="line-removed">1044           case short_parm:</span>
<span class="line-removed">1045             get_short();</span>
<span class="line-removed">1046             break;</span>
<span class="line-removed">1047           case byte_parm:</span>
<span class="line-removed">1048             get_byte();</span>
<span class="line-removed">1049             break;</span>
<span class="line-removed">1050           case int_parm:</span>
<span class="line-removed">1051             get_int();</span>
<span class="line-removed">1052             break;</span>
<span class="line-removed">1053           case obj_parm:</span>
<span class="line-removed">1054             get_object();</span>
<span class="line-removed">1055             break;</span>
<span class="line-removed">1056           case long_parm:</span>
<span class="line-removed">1057             get_long();</span>
<span class="line-removed">1058             break;</span>
<span class="line-removed">1059           case float_parm:</span>
<span class="line-removed">1060             get_float();</span>
<span class="line-removed">1061             break;</span>
<span class="line-removed">1062           case double_parm:</span>
<span class="line-removed">1063             get_double();</span>
<span class="line-removed">1064             break;</span>
<span class="line-removed">1065           case done_parm:</span>
<span class="line-removed">1066             return;</span>
<span class="line-removed">1067             break;</span>
<span class="line-removed">1068           default:</span>
<span class="line-removed">1069             ShouldNotReachHere();</span>
<span class="line-removed">1070             break;</span>
<span class="line-removed">1071         }</span>
<span class="line-removed">1072         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed">1073       }</span>
<span class="line-removed">1074     }</span>
1075   }
1076 };
1077 
1078 
1079 enum JNICallType {
1080   JNI_STATIC,
1081   JNI_VIRTUAL,
1082   JNI_NONVIRTUAL
1083 };
1084 
1085 
1086 
1087 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1088   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1089 
1090   // Create object to hold arguments for the JavaCall, and associate it with
1091   // the jni parser
1092   ResourceMark rm(THREAD);
1093   int number_of_parameters = method-&gt;size_of_parameters();
1094   JavaCallArguments java_args(number_of_parameters);
<a name="15" id="anc15"></a><span class="line-removed">1095   args-&gt;set_java_argument_object(&amp;java_args);</span>
1096 
1097   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1098 
1099   // Fill out JavaCallArguments object
<a name="16" id="anc16"></a><span class="line-modified">1100   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1101   // Initialize result type
<a name="17" id="anc17"></a><span class="line-modified">1102   result-&gt;set_type(args-&gt;get_ret_type());</span>
1103 
1104   // Invoke the method. Result is returned as oop.
1105   JavaCalls::call(result, method, &amp;java_args, CHECK);
1106 
1107   // Convert result
1108   if (is_reference_type(result-&gt;get_type())) {
1109     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1110   }
1111 }
1112 
1113 
1114 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1115   oop recv = JNIHandles::resolve(receiver);
1116   if (recv == NULL) {
1117     THROW(vmSymbols::java_lang_NullPointerException());
1118   }
1119   Handle h_recv(THREAD, recv);
1120 
1121   int number_of_parameters;
1122   Method* selected_method;
1123   {
1124     Method* m = Method::resolve_jmethod_id(method_id);
1125     number_of_parameters = m-&gt;size_of_parameters();
1126     Klass* holder = m-&gt;method_holder();
1127     if (call_type != JNI_VIRTUAL) {
1128         selected_method = m;
1129     } else if (!m-&gt;has_itable_index()) {
1130       // non-interface call -- for that little speed boost, don&#39;t handlize
1131       debug_only(NoSafepointVerifier nosafepoint;)
1132       // jni_GetMethodID makes sure class is linked and initialized
1133       // so m should have a valid vtable index.
1134       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1135       int vtbl_index = m-&gt;vtable_index();
1136       if (vtbl_index != Method::nonvirtual_vtable_index) {
1137         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1138       } else {
1139         // final method
1140         selected_method = m;
1141       }
1142     } else {
1143       // interface call
1144       int itbl_index = m-&gt;itable_index();
1145       Klass* k = h_recv-&gt;klass();
1146       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1147     }
1148   }
1149 
1150   methodHandle method(THREAD, selected_method);
1151 
1152   // Create object to hold arguments for the JavaCall, and associate it with
1153   // the jni parser
1154   ResourceMark rm(THREAD);
1155   JavaCallArguments java_args(number_of_parameters);
<a name="18" id="anc18"></a><span class="line-removed">1156   args-&gt;set_java_argument_object(&amp;java_args);</span>
1157 
1158   // handle arguments
1159   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<a name="19" id="anc19"></a><span class="line-modified">1160   args-&gt;push_receiver(h_recv); // Push jobject handle</span>
1161 
1162   // Fill out JavaCallArguments object
<a name="20" id="anc20"></a><span class="line-modified">1163   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1164   // Initialize result type
<a name="21" id="anc21"></a><span class="line-modified">1165   result-&gt;set_type(args-&gt;get_ret_type());</span>
1166 
1167   // Invoke the method. Result is returned as oop.
1168   JavaCalls::call(result, method, &amp;java_args, CHECK);
1169 
1170   // Convert result
1171   if (is_reference_type(result-&gt;get_type())) {
1172     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1173   }
1174 }
1175 
1176 
1177 static instanceOop alloc_object(jclass clazz, TRAPS) {
1178   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1179   if (k == NULL) {
1180     ResourceMark rm(THREAD);
1181     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1182   }
1183   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1184   k-&gt;initialize(CHECK_NULL);
1185   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
1186   return ih;
1187 }
1188 
1189 DT_RETURN_MARK_DECL(AllocObject, jobject
1190                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1191 
1192 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1193   JNIWrapper(&quot;AllocObject&quot;);
1194 
1195   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1196 
1197   jobject ret = NULL;
1198   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1199 
1200   instanceOop i = alloc_object(clazz, CHECK_NULL);
1201   ret = JNIHandles::make_local(env, i);
1202   return ret;
1203 JNI_END
1204 
1205 DT_RETURN_MARK_DECL(NewObjectA, jobject
1206                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1207 
1208 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1209   JNIWrapper(&quot;NewObjectA&quot;);
1210 
1211   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1212 
1213   jobject obj = NULL;
1214   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1215 
1216   instanceOop i = alloc_object(clazz, CHECK_NULL);
1217   obj = JNIHandles::make_local(env, i);
1218   JavaValue jvalue(T_VOID);
1219   JNI_ArgumentPusherArray ap(methodID, args);
1220   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1221   return obj;
1222 JNI_END
1223 
1224 
1225 DT_RETURN_MARK_DECL(NewObjectV, jobject
1226                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1227 
1228 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1229   JNIWrapper(&quot;NewObjectV&quot;);
1230 
1231   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1232 
1233   jobject obj = NULL;
1234   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1235 
1236   instanceOop i = alloc_object(clazz, CHECK_NULL);
1237   obj = JNIHandles::make_local(env, i);
1238   JavaValue jvalue(T_VOID);
1239   JNI_ArgumentPusherVaArg ap(methodID, args);
1240   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1241   return obj;
1242 JNI_END
1243 
1244 
1245 DT_RETURN_MARK_DECL(NewObject, jobject
1246                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1247 
1248 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1249   JNIWrapper(&quot;NewObject&quot;);
1250 
1251   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1252 
1253   jobject obj = NULL;
1254   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1255 
1256   instanceOop i = alloc_object(clazz, CHECK_NULL);
1257   obj = JNIHandles::make_local(env, i);
1258   va_list args;
1259   va_start(args, methodID);
1260   JavaValue jvalue(T_VOID);
1261   JNI_ArgumentPusherVaArg ap(methodID, args);
1262   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1263   va_end(args);
1264   return obj;
1265 JNI_END
1266 
1267 
1268 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1269   JNIWrapper(&quot;GetObjectClass&quot;);
1270 
1271   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1272 
1273   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1274   jclass ret =
1275     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1276 
1277   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1278   return ret;
1279 JNI_END
1280 
1281 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1282   JNIWrapper(&quot;IsInstanceOf&quot;);
1283 
1284   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1285 
1286   jboolean ret = JNI_TRUE;
1287   if (obj != NULL) {
1288     ret = JNI_FALSE;
1289     Klass* k = java_lang_Class::as_Klass(
1290       JNIHandles::resolve_non_null(clazz));
1291     if (k != NULL) {
1292       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1293     }
1294   }
1295 
1296   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1297   return ret;
1298 JNI_END
1299 
1300 
1301 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1302                                const char *sig, bool is_static, TRAPS) {
1303   // %%%% This code should probably just call into a method in the LinkResolver
1304   //
1305   // The class should have been loaded (we have an instance of the class
1306   // passed in) so the method and signature should already be in the symbol
1307   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1308   const char *name_to_probe = (name_str == NULL)
1309                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1310                         : name_str;
1311   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1312   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1313 
1314   if (name == NULL || signature == NULL) {
1315     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1316   }
1317 
1318   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1319 
1320   // Throw a NoSuchMethodError exception if we have an instance of a
1321   // primitive java.lang.Class
1322   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1323     ResourceMark rm;
1324     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1325   }
1326 
1327   // Make sure class is linked and initialized before handing id&#39;s out to
1328   // Method*s.
1329   klass-&gt;initialize(CHECK_NULL);
1330 
1331   Method* m;
1332   if (name == vmSymbols::object_initializer_name() ||
1333       name == vmSymbols::class_initializer_name()) {
1334     // Never search superclasses for constructors
1335     if (klass-&gt;is_instance_klass()) {
1336       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1337     } else {
1338       m = NULL;
1339     }
1340   } else {
1341     m = klass-&gt;lookup_method(name, signature);
1342     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1343       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1344     }
1345   }
1346   if (m == NULL || (m-&gt;is_static() != is_static)) {
1347     ResourceMark rm;
1348     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1349   }
1350   return m-&gt;jmethod_id();
1351 }
1352 
1353 
1354 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1355           const char *name, const char *sig))
1356   JNIWrapper(&quot;GetMethodID&quot;);
1357   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1358   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1359   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1360   return ret;
1361 JNI_END
1362 
1363 
1364 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1365           const char *name, const char *sig))
1366   JNIWrapper(&quot;GetStaticMethodID&quot;);
1367   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1368   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1369   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1370   return ret;
1371 JNI_END
1372 
1373 
1374 
1375 //
1376 // Calling Methods
1377 //
1378 
1379 
1380 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1381                           , EntryProbe, ReturnProbe)    \
1382 \
1383   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1384                           , ReturnProbe);                          \
1385 \
1386 JNI_ENTRY(ResultType, \
1387           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1388   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1389 \
1390   EntryProbe; \
1391   ResultType ret = 0;\
1392   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1393                      (const ResultType&amp;)ret);\
1394 \
1395   va_list args; \
1396   va_start(args, methodID); \
1397   JavaValue jvalue(Tag); \
1398   JNI_ArgumentPusherVaArg ap(methodID, args); \
1399   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1400   va_end(args); \
1401   ret = jvalue.get_##ResultType(); \
1402   return ret;\
1403 JNI_END
1404 
1405 // the runtime type of subword integral basic types is integer
1406 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1407                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1408                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1409 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1410                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1411                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1412 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1413                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1414                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1415 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1416                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1417                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1418 
1419 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1420                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1421                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1422 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1423                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1424                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1425 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1426                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1427                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1428 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1429 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1430                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1431                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1432 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1433                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1434                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1435 
1436 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1437                           , EntryProbe, ReturnProbe)    \
1438 \
1439   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1440                           , ReturnProbe);                          \
1441 \
1442 JNI_ENTRY(ResultType, \
1443           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1444   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1445 \
1446   EntryProbe;\
1447   ResultType ret = 0;\
1448   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1449                      (const ResultType&amp;)ret);\
1450 \
1451   JavaValue jvalue(Tag); \
1452   JNI_ArgumentPusherVaArg ap(methodID, args); \
1453   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1454   ret = jvalue.get_##ResultType(); \
1455   return ret;\
1456 JNI_END
1457 
1458 // the runtime type of subword integral basic types is integer
1459 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1460                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1461                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1462 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1463                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1464                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1465 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1466                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1467                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1468 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1469                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1470                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1471 
1472 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1473                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1474                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1475 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1476                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1477                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1478 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1479                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1480                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1481 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1482 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1483                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1484                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1485 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1486                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1487                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1488 
1489 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1490                           , EntryProbe, ReturnProbe)    \
1491 \
1492   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1493                           , ReturnProbe);                          \
1494 \
1495 JNI_ENTRY(ResultType, \
1496           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1497   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1498   EntryProbe; \
1499   ResultType ret = 0;\
1500   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1501                      (const ResultType&amp;)ret);\
1502 \
1503   JavaValue jvalue(Tag); \
1504   JNI_ArgumentPusherArray ap(methodID, args); \
1505   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1506   ret = jvalue.get_##ResultType(); \
1507   return ret;\
1508 JNI_END
1509 
1510 // the runtime type of subword integral basic types is integer
1511 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1512                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1513                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1514 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1515                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1516                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1517 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1518                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1519                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1520 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1521                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1522                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1523 
1524 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1525                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1526                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1527 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1528                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1529                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1530 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1531                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1532                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1533 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1534 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1535                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1536                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1537 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1538                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1539                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1540 
1541 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1542 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1543 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1544 
1545 
1546 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1547   JNIWrapper(&quot;CallVoidMethod&quot;);
1548   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1549   DT_VOID_RETURN_MARK(CallVoidMethod);
1550 
1551   va_list args;
1552   va_start(args, methodID);
1553   JavaValue jvalue(T_VOID);
1554   JNI_ArgumentPusherVaArg ap(methodID, args);
1555   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1556   va_end(args);
1557 JNI_END
1558 
1559 
1560 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1561   JNIWrapper(&quot;CallVoidMethodV&quot;);
1562   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1563   DT_VOID_RETURN_MARK(CallVoidMethodV);
1564 
1565   JavaValue jvalue(T_VOID);
1566   JNI_ArgumentPusherVaArg ap(methodID, args);
1567   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1568 JNI_END
1569 
1570 
1571 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1572   JNIWrapper(&quot;CallVoidMethodA&quot;);
1573   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1574   DT_VOID_RETURN_MARK(CallVoidMethodA);
1575 
1576   JavaValue jvalue(T_VOID);
1577   JNI_ArgumentPusherArray ap(methodID, args);
1578   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1579 JNI_END
1580 
1581 
1582 
1583 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1584                                     , EntryProbe, ReturnProbe)      \
1585 \
1586   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1587                           , ReturnProbe);\
1588 \
1589 JNI_ENTRY(ResultType, \
1590           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1591   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1592 \
1593   EntryProbe;\
1594   ResultType ret;\
1595   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1596                      (const ResultType&amp;)ret);\
1597 \
1598   va_list args; \
1599   va_start(args, methodID); \
1600   JavaValue jvalue(Tag); \
1601   JNI_ArgumentPusherVaArg ap(methodID, args); \
1602   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1603   va_end(args); \
1604   ret = jvalue.get_##ResultType(); \
1605   return ret;\
1606 JNI_END
1607 
1608 // the runtime type of subword integral basic types is integer
1609 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1610                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1611                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1612 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1613                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1614                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1615 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1616                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1617                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1618 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1619                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1620                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1621 
1622 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1623                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1624                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1625 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1626                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1627                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1628 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1629                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1630 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1631                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1632 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1633                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1634                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1635 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1636                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1637                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1638 
1639 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1640                                     , EntryProbe, ReturnProbe)      \
1641 \
1642   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1643                           , ReturnProbe);\
1644 \
1645 JNI_ENTRY(ResultType, \
1646           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1647   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1648 \
1649   EntryProbe;\
1650   ResultType ret;\
1651   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1652                      (const ResultType&amp;)ret);\
1653 \
1654   JavaValue jvalue(Tag); \
1655   JNI_ArgumentPusherVaArg ap(methodID, args); \
1656   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1657   ret = jvalue.get_##ResultType(); \
1658   return ret;\
1659 JNI_END
1660 
1661 // the runtime type of subword integral basic types is integer
1662 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1663                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1664                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1665 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1666                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1667                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1668 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1669                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1670                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1671 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1672                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1673                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1674 
1675 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1676                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1677                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1678 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1679                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1680                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1681 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1682                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1683 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1684                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1685 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1686                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1687                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1688 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1689                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1690                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1691 
1692 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1693                                     , EntryProbe, ReturnProbe)      \
1694 \
1695   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1696                           , ReturnProbe);\
1697 \
1698 JNI_ENTRY(ResultType, \
1699           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1700   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1701 \
1702   EntryProbe;\
1703   ResultType ret;\
1704   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1705                      (const ResultType&amp;)ret);\
1706 \
1707   JavaValue jvalue(Tag); \
1708   JNI_ArgumentPusherArray ap(methodID, args); \
1709   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1710   ret = jvalue.get_##ResultType(); \
1711   return ret;\
1712 JNI_END
1713 
1714 // the runtime type of subword integral basic types is integer
1715 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1716                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1717                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1718 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1719                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1720                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1721 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1722                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1723                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1724 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1725                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1726                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1727 
1728 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1729                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1730                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1731 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1732                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1733                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1734 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1735                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1736 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1737                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1738 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1739                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1740                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1741 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1742                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1743                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1744 
1745 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1746                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1747 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1748                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1749 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1750                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1751 
1752 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1753   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1754 
1755   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1756   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1757 
1758   va_list args;
1759   va_start(args, methodID);
1760   JavaValue jvalue(T_VOID);
1761   JNI_ArgumentPusherVaArg ap(methodID, args);
1762   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1763   va_end(args);
1764 JNI_END
1765 
1766 
1767 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1768   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1769 
1770   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1771                env, obj, cls, (uintptr_t) methodID);
1772   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1773 
1774   JavaValue jvalue(T_VOID);
1775   JNI_ArgumentPusherVaArg ap(methodID, args);
1776   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1777 JNI_END
1778 
1779 
1780 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1781   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1782   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1783                 env, obj, cls, (uintptr_t) methodID);
1784   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1785   JavaValue jvalue(T_VOID);
1786   JNI_ArgumentPusherArray ap(methodID, args);
1787   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1788 JNI_END
1789 
1790 
1791 
1792 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1793                                 , EntryProbe, ResultProbe) \
1794 \
1795   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1796                           , ResultProbe);                               \
1797 \
1798 JNI_ENTRY(ResultType, \
1799           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1800   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1801 \
1802   EntryProbe; \
1803   ResultType ret = 0;\
1804   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1805                      (const ResultType&amp;)ret);\
1806 \
1807   va_list args; \
1808   va_start(args, methodID); \
1809   JavaValue jvalue(Tag); \
1810   JNI_ArgumentPusherVaArg ap(methodID, args); \
1811   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1812   va_end(args); \
1813   ret = jvalue.get_##ResultType(); \
1814   return ret;\
1815 JNI_END
1816 
1817 // the runtime type of subword integral basic types is integer
1818 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1819                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1820                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1821 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1822                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1823                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1824 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1825                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1826                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1827 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1828                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1829                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1830 
1831 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1832                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1833                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1834 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1835                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1836                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1837 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1838                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1839                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1840 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1841 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1842                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1843                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1844 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1845                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1846                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1847 
1848 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1849                                 , EntryProbe, ResultProbe) \
1850 \
1851   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1852                           , ResultProbe);                               \
1853 \
1854 JNI_ENTRY(ResultType, \
1855           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1856   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1857 \
1858   EntryProbe; \
1859   ResultType ret = 0;\
1860   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1861                      (const ResultType&amp;)ret);\
1862 \
1863   JavaValue jvalue(Tag); \
1864   JNI_ArgumentPusherVaArg ap(methodID, args); \
1865   /* Make sure class is initialized before trying to invoke its method */ \
1866   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1867   k-&gt;initialize(CHECK_0); \
1868   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1869   va_end(args); \
1870   ret = jvalue.get_##ResultType(); \
1871   return ret;\
1872 JNI_END
1873 
1874 // the runtime type of subword integral basic types is integer
1875 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1876                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1877                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1878 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1879                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1880                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1881 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1882                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1883                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1884 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1885                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1886                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1887 
1888 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1889                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1890                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1891 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1892                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1893                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1894 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1895                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1896                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1897 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1898 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1899                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1900                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1901 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1902                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1903                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1904 
1905 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1906                                 , EntryProbe, ResultProbe) \
1907 \
1908   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1909                           , ResultProbe);                               \
1910 \
1911 JNI_ENTRY(ResultType, \
1912           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1913   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1914 \
1915   EntryProbe; \
1916   ResultType ret = 0;\
1917   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1918                      (const ResultType&amp;)ret);\
1919 \
1920   JavaValue jvalue(Tag); \
1921   JNI_ArgumentPusherArray ap(methodID, args); \
1922   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1923   ret = jvalue.get_##ResultType(); \
1924   return ret;\
1925 JNI_END
1926 
1927 // the runtime type of subword integral basic types is integer
1928 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1929                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1930                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1931 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1932                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1933                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1934 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1935                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1936                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1937 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1938                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1939                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1940 
1941 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1942                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1943                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1944 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1945                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1946                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1947 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1948                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1949                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1950 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1951 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1952                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1953                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1954 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1955                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1956                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1957 
1958 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1959                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1960 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1961                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1962 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1963                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1964 
1965 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1966   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1967   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1968   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1969 
1970   va_list args;
1971   va_start(args, methodID);
1972   JavaValue jvalue(T_VOID);
1973   JNI_ArgumentPusherVaArg ap(methodID, args);
1974   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1975   va_end(args);
1976 JNI_END
1977 
1978 
1979 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1980   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1981   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1982   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1983 
1984   JavaValue jvalue(T_VOID);
1985   JNI_ArgumentPusherVaArg ap(methodID, args);
1986   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1987 JNI_END
1988 
1989 
1990 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1991   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1992   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1993   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1994 
1995   JavaValue jvalue(T_VOID);
1996   JNI_ArgumentPusherArray ap(methodID, args);
1997   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1998 JNI_END
1999 
2000 
2001 //
2002 // Accessing Fields
2003 //
2004 
2005 
2006 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
2007                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
2008 
2009 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
2010           const char *name, const char *sig))
2011   JNIWrapper(&quot;GetFieldID&quot;);
2012   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2013   jfieldID ret = 0;
2014   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
2015 
2016   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2017 
2018   // The class should have been loaded (we have an instance of the class
2019   // passed in) so the field and signature should already be in the symbol
2020   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2021   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2022   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2023   if (fieldname == NULL || signame == NULL) {
2024     ResourceMark rm;
2025     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
2026   }
2027 
2028   // Make sure class is initialized before handing id&#39;s out to fields
2029   k-&gt;initialize(CHECK_NULL);
2030 
2031   fieldDescriptor fd;
2032   if (!k-&gt;is_instance_klass() ||
2033       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
2034     ResourceMark rm;
2035     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
2036   }
2037 
2038   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
2039   // It may also have hash bits for k, if VerifyJNIFields is turned on.
2040   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());
2041   return ret;
2042 JNI_END
2043 
2044 
2045 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
2046   JNIWrapper(&quot;GetObjectField&quot;);
2047   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
2048   oop o = JNIHandles::resolve_non_null(obj);
2049   Klass* k = o-&gt;klass();
2050   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2051   // Keep JVMTI addition small and only check enabled flag here.
2052   // jni_GetField_probe() assumes that is okay to create handles.
2053   if (JvmtiExport::should_post_field_access()) {
2054     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
2055   }
2056   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
2057   jobject ret = JNIHandles::make_local(env, loaded_obj);
2058   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
2059   return ret;
2060 JNI_END
2061 
2062 
2063 
2064 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2065   , EntryProbe, ReturnProbe) \
2066 \
2067   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2068   , ReturnProbe); \
2069 \
2070 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2071   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2072 \
2073   EntryProbe; \
2074   Return ret = 0;\
2075   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2076 \
2077   oop o = JNIHandles::resolve_non_null(obj); \
2078   Klass* k = o-&gt;klass(); \
2079   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2080   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2081   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2082   /* and creates a ResetNoHandleMark.                                   */ \
2083   if (JvmtiExport::should_post_field_access()) { \
2084     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2085   } \
2086   ret = o-&gt;Fieldname##_field(offset); \
2087   return ret; \
2088 JNI_END
2089 
2090 DEFINE_GETFIELD(jboolean, bool,   Boolean
2091                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2092                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2093 DEFINE_GETFIELD(jbyte,    byte,   Byte
2094                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2095                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2096 DEFINE_GETFIELD(jchar,    char,   Char
2097                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2098                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2099 DEFINE_GETFIELD(jshort,   short,  Short
2100                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2101                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2102 DEFINE_GETFIELD(jint,     int,    Int
2103                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2104                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2105 DEFINE_GETFIELD(jlong,    long,   Long
2106                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2107                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2108 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2109 DEFINE_GETFIELD(jfloat,   float,  Float
2110                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2111                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2112 DEFINE_GETFIELD(jdouble,  double, Double
2113                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2114                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2115 
2116 address jni_GetBooleanField_addr() {
2117   return (address)jni_GetBooleanField;
2118 }
2119 address jni_GetByteField_addr() {
2120   return (address)jni_GetByteField;
2121 }
2122 address jni_GetCharField_addr() {
2123   return (address)jni_GetCharField;
2124 }
2125 address jni_GetShortField_addr() {
2126   return (address)jni_GetShortField;
2127 }
2128 address jni_GetIntField_addr() {
2129   return (address)jni_GetIntField;
2130 }
2131 address jni_GetLongField_addr() {
2132   return (address)jni_GetLongField;
2133 }
2134 address jni_GetFloatField_addr() {
2135   return (address)jni_GetFloatField;
2136 }
2137 address jni_GetDoubleField_addr() {
2138   return (address)jni_GetDoubleField;
2139 }
2140 
2141 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2142   JNIWrapper(&quot;SetObjectField&quot;);
2143   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2144   oop o = JNIHandles::resolve_non_null(obj);
2145   Klass* k = o-&gt;klass();
2146   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2147   // Keep JVMTI addition small and only check enabled flag here.
2148   // jni_SetField_probe_nh() assumes that is not okay to create handles
2149   // and creates a ResetNoHandleMark.
2150   if (JvmtiExport::should_post_field_modification()) {
2151     jvalue field_value;
2152     field_value.l = value;
2153     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2154   }
2155   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2156   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2157 JNI_END
2158 
2159 
2160 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2161                         , EntryProbe, ReturnProbe) \
2162 \
2163 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2164   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2165 \
2166   EntryProbe; \
2167 \
2168   oop o = JNIHandles::resolve_non_null(obj); \
2169   Klass* k = o-&gt;klass(); \
2170   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2171   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2172   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2173   /* and creates a ResetNoHandleMark.                                   */ \
2174   if (JvmtiExport::should_post_field_modification()) { \
2175     jvalue field_value; \
2176     field_value.unionType = value; \
2177     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2178   } \
2179   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2180   o-&gt;Fieldname##_field_put(offset, value); \
2181   ReturnProbe; \
2182 JNI_END
2183 
2184 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2185                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2186                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2187 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2188                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2189                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2190 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2191                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2192                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2193 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2194                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2195                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2196 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2197                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2198                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2199 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2200                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2201                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2202 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2203 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2204                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2205                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2206 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2207                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2208                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2209 
2210 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2211                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2212 
2213 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2214   JNIWrapper(&quot;ToReflectedField&quot;);
2215   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2216   jobject ret = NULL;
2217   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2218 
2219   fieldDescriptor fd;
2220   bool found = false;
2221   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2222 
2223   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2224 
2225   if (isStatic) {
2226     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2227     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2228     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2229     found = id-&gt;find_local_field(&amp;fd);
2230   } else {
2231     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2232     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2233     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2234   }
2235   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2236   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2237   ret = JNIHandles::make_local(env, reflected);
2238   return ret;
2239 JNI_END
2240 
2241 
2242 //
2243 // Accessing Static Fields
2244 //
2245 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2246                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2247 
2248 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2249           const char *name, const char *sig))
2250   JNIWrapper(&quot;GetStaticFieldID&quot;);
2251   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2252   jfieldID ret = NULL;
2253   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2254 
2255   // The class should have been loaded (we have an instance of the class
2256   // passed in) so the field and signature should already be in the symbol
2257   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2258   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2259   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2260   if (fieldname == NULL || signame == NULL) {
2261     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2262   }
2263   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2264   // Make sure class is initialized before handing id&#39;s out to static fields
2265   k-&gt;initialize(CHECK_NULL);
2266 
2267   fieldDescriptor fd;
2268   if (!k-&gt;is_instance_klass() ||
2269       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2270     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2271   }
2272 
2273   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2274   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2275   debug_only(id-&gt;set_is_static_field_id();)
2276 
2277   debug_only(id-&gt;verify(fd.field_holder()));
2278 
2279   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2280   return ret;
2281 JNI_END
2282 
2283 
2284 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2285   JNIWrapper(&quot;GetStaticObjectField&quot;);
2286   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2287 #if INCLUDE_JNI_CHECK
2288   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2289 #endif // INCLUDE_JNI_CHECK
2290   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2291   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2292   // Keep JVMTI addition small and only check enabled flag here.
2293   // jni_GetField_probe() assumes that is okay to create handles.
2294   if (JvmtiExport::should_post_field_access()) {
2295     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2296   }
2297   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2298   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2299   return ret;
2300 JNI_END
2301 
2302 
2303 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2304                               , EntryProbe, ReturnProbe) \
2305 \
2306   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2307                           , ReturnProbe);                                          \
2308 \
2309 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2310   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2311   EntryProbe; \
2312   Return ret = 0;\
2313   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2314                      (const Return&amp;)ret);\
2315   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2316   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2317   /* Keep JVMTI addition small and only check enabled flag here. */ \
2318   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2319   if (JvmtiExport::should_post_field_access()) { \
2320     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2321   } \
2322   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2323   return ret;\
2324 JNI_END
2325 
2326 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2327                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2328 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2329                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2330 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2331                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2332 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2333                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2334 DEFINE_GETSTATICFIELD(jint,     int,    Int
2335                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2336 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2337                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2338 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2339 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2340                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2341 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2342                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2343 
2344 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2345   JNIWrapper(&quot;SetStaticObjectField&quot;);
2346  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2347   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2348   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2349   // Keep JVMTI addition small and only check enabled flag here.
2350   // jni_SetField_probe() assumes that is okay to create handles.
2351   if (JvmtiExport::should_post_field_modification()) {
2352     jvalue field_value;
2353     field_value.l = value;
2354     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2355   }
2356   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2357   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2358 JNI_END
2359 
2360 
2361 
2362 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2363                               , EntryProbe, ReturnProbe) \
2364 \
2365 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2366   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2367   EntryProbe; \
2368 \
2369   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2370   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2371   /* Keep JVMTI addition small and only check enabled flag here. */ \
2372   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2373   if (JvmtiExport::should_post_field_modification()) { \
2374     jvalue field_value; \
2375     field_value.unionType = value; \
2376     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2377   } \
2378   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2379   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2380   ReturnProbe;\
2381 JNI_END
2382 
2383 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2384                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2385                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2386 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2387                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2388                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2389 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2390                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2391                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2392 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2393                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2394                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2395 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2396                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2397                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2398 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2399                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2400                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2401 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2402 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2403                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2404                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2405 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2406                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2407                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2408 
2409 //
2410 // String Operations
2411 //
2412 
2413 // Unicode Interface
2414 
2415 DT_RETURN_MARK_DECL(NewString, jstring
2416                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2417 
2418 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2419   JNIWrapper(&quot;NewString&quot;);
2420  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2421   jstring ret = NULL;
2422   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2423   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2424   ret = (jstring) JNIHandles::make_local(env, string);
2425   return ret;
2426 JNI_END
2427 
2428 
2429 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2430   JNIWrapper(&quot;GetStringLength&quot;);
2431   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2432   jsize ret = 0;
2433   oop s = JNIHandles::resolve_non_null(string);
2434   ret = java_lang_String::length(s);
2435  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2436   return ret;
2437 JNI_END
2438 
2439 
2440 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2441   JNIEnv *env, jstring string, jboolean *isCopy))
2442   JNIWrapper(&quot;GetStringChars&quot;);
2443  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2444   jchar* buf = NULL;
2445   oop s = JNIHandles::resolve_non_null(string);
2446   typeArrayOop s_value = java_lang_String::value(s);
2447   if (s_value != NULL) {
2448     int s_len = java_lang_String::length(s, s_value);
2449     bool is_latin1 = java_lang_String::is_latin1(s);
2450     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2451     /* JNI Specification states return NULL on OOM */
2452     if (buf != NULL) {
2453       if (s_len &gt; 0) {
2454         if (!is_latin1) {
2455           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2456                                              buf, s_len);
2457         } else {
2458           for (int i = 0; i &lt; s_len; i++) {
2459             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2460           }
2461         }
2462       }
2463       buf[s_len] = 0;
2464       //%note jni_5
2465       if (isCopy != NULL) {
2466         *isCopy = JNI_TRUE;
2467       }
2468     }
2469   }
2470   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2471   return buf;
2472 JNI_END
2473 
2474 
2475 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2476   JNIWrapper(&quot;ReleaseStringChars&quot;);
2477   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2478   //%note jni_6
2479   if (chars != NULL) {
2480     // Since String objects are supposed to be immutable, don&#39;t copy any
2481     // new data back.  A bad user will have to go after the char array.
2482     FreeHeap((void*) chars);
2483   }
2484   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2485 JNI_END
2486 
2487 
2488 // UTF Interface
2489 
2490 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2491                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2492 
2493 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2494   JNIWrapper(&quot;NewStringUTF&quot;);
2495   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2496   jstring ret;
2497   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2498 
2499   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2500   ret = (jstring) JNIHandles::make_local(env, result);
2501   return ret;
2502 JNI_END
2503 
2504 
2505 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2506   JNIWrapper(&quot;GetStringUTFLength&quot;);
2507  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2508   oop java_string = JNIHandles::resolve_non_null(string);
2509   jsize ret = java_lang_String::utf8_length(java_string);
2510   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2511   return ret;
2512 JNI_END
2513 
2514 
2515 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2516   JNIWrapper(&quot;GetStringUTFChars&quot;);
2517  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2518   char* result = NULL;
2519   oop java_string = JNIHandles::resolve_non_null(string);
2520   typeArrayOop s_value = java_lang_String::value(java_string);
2521   if (s_value != NULL) {
2522     size_t length = java_lang_String::utf8_length(java_string, s_value);
2523     /* JNI Specification states return NULL on OOM */
2524     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2525     if (result != NULL) {
2526       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2527       if (isCopy != NULL) {
2528         *isCopy = JNI_TRUE;
2529       }
2530     }
2531   }
2532  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2533   return result;
2534 JNI_END
2535 
2536 
2537 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2538   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2539  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2540   if (chars != NULL) {
2541     FreeHeap((char*) chars);
2542   }
2543 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2544 JNI_END
2545 
2546 
2547 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2548   JNIWrapper(&quot;GetArrayLength&quot;);
2549  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2550   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2551   assert(a-&gt;is_array(), &quot;must be array&quot;);
2552   jsize ret = a-&gt;length();
2553  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2554   return ret;
2555 JNI_END
2556 
2557 
2558 //
2559 // Object Array Operations
2560 //
2561 
2562 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2563                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2564 
2565 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2566   JNIWrapper(&quot;NewObjectArray&quot;);
2567  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2568   jobjectArray ret = NULL;
2569   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2570   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2571   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2572   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2573   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2574   oop initial_value = JNIHandles::resolve(initialElement);
2575   if (initial_value != NULL) {  // array already initialized with NULL
2576     for (int index = 0; index &lt; length; index++) {
2577       result-&gt;obj_at_put(index, initial_value);
2578     }
2579   }
2580   ret = (jobjectArray) JNIHandles::make_local(env, result);
2581   return ret;
2582 JNI_END
2583 
2584 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2585                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2586 
2587 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2588   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2589  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2590   jobject ret = NULL;
2591   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2592   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2593   if (a-&gt;is_within_bounds(index)) {
2594     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));
2595     return ret;
2596   } else {
2597     ResourceMark rm(THREAD);
2598     stringStream ss;
2599     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2600     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2601   }
2602 JNI_END
2603 
2604 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2605                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2606 
2607 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2608   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2609  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2610   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2611 
2612   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2613   oop v = JNIHandles::resolve(value);
2614   if (a-&gt;is_within_bounds(index)) {
2615     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2616       a-&gt;obj_at_put(index, v);
2617     } else {
2618       ResourceMark rm(THREAD);
2619       stringStream ss;
2620       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2621       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2622                v-&gt;klass()-&gt;external_name(),
2623                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2624                index);
2625       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2626         ss.print(&quot;[]&quot;);
2627       }
2628       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2629     }
2630   } else {
2631     ResourceMark rm(THREAD);
2632     stringStream ss;
2633     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2634     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2635   }
2636 JNI_END
2637 
2638 
2639 
2640 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2641                               ,EntryProbe,ReturnProbe)  \
2642 \
2643   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2644                       , ReturnProbe); \
2645 \
2646 JNI_ENTRY(Return, \
2647           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2648   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2649   EntryProbe; \
2650   Return ret = NULL;\
2651   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2652 \
2653   oop obj= oopFactory::Allocator(len, CHECK_0); \
2654   ret = (Return) JNIHandles::make_local(env, obj); \
2655   return ret;\
2656 JNI_END
2657 
2658 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2659                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2660                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2661 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2662                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2663                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2664 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2665                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2666                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2667 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2668                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2669                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2670 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2671                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2672                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2673 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2674                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2675                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2676 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2677                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2678                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2679 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2680                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2681                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2682 
2683 // Return an address which will fault if the caller writes to it.
2684 
2685 static char* get_bad_address() {
2686   static char* bad_address = NULL;
2687   if (bad_address == NULL) {
2688     size_t size = os::vm_allocation_granularity();
2689     bad_address = os::reserve_memory(size);
2690     if (bad_address != NULL) {
2691       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2692                          /*is_committed*/false);
2693       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2694     }
2695   }
2696   return bad_address;
2697 }
2698 
2699 
2700 
2701 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2702                                       , EntryProbe, ReturnProbe) \
2703 \
2704 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2705           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2706   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2707   EntryProbe; \
2708   /* allocate an chunk of memory in c land */ \
2709   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2710   ElementType* result; \
2711   int len = a-&gt;length(); \
2712   if (len == 0) { \
2713     if (isCopy != NULL) { \
2714       *isCopy = JNI_FALSE; \
2715     } \
2716     /* Empty array: legal but useless, can&#39;t return NULL. \
2717      * Return a pointer to something useless. \
2718      * Avoid asserts in typeArrayOop. */ \
2719     result = (ElementType*)get_bad_address(); \
2720   } else { \
2721     /* JNI Specification states return NULL on OOM */                    \
2722     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2723     if (result != NULL) {                                                \
2724       /* copy the array to the c chunk */                                \
2725       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2726                                          result, len);                   \
2727       if (isCopy) {                                                      \
2728         *isCopy = JNI_TRUE;                                              \
2729       }                                                                  \
2730     }                                                                    \
2731   } \
2732   ReturnProbe; \
2733   return result; \
2734 JNI_END
2735 
2736 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2737                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2738                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2739 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2740                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2741                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2742 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2743                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2744                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2745 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2746                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2747                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2748 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2749                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2750                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2751 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2752                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2753                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2754 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2755 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2756                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2757                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2758 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2759                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2760                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2761 
2762 
2763 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2764                                           , EntryProbe, ReturnProbe);\
2765 \
2766 JNI_ENTRY_NO_PRESERVE(void, \
2767           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2768                                              ElementType *buf, jint mode)) \
2769   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2770   EntryProbe; \
2771   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2772   int len = a-&gt;length(); \
2773   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2774     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2775       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2776     } \
2777     if ((mode == 0) || (mode == JNI_ABORT)) { \
2778       FreeHeap(buf); \
2779     } \
2780   } \
2781   ReturnProbe; \
2782 JNI_END
2783 
2784 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2785                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2786                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2787 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2788                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2789                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2790 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2791                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2792                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2793 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2794                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2795                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2796 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2797                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2798                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2799 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2800                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2801                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2802 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2803                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2804                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2805 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2806                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2807                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2808 
2809 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2810   ResourceMark rm(THREAD);
2811   if (copy_len &lt; 0) {
2812     stringStream ss;
2813     ss.print(&quot;Length %d is negative&quot;, copy_len);
2814     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2815   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2816     stringStream ss;
2817     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2818              start, (int64_t)start+(int64_t)copy_len, array_len);
2819     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2820   }
2821 }
2822 
2823 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2824                                     , EntryProbe, ReturnProbe); \
2825   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2826                            , ReturnProbe); \
2827 \
2828 JNI_ENTRY(void, \
2829 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2830              jsize len, ElementType *buf)) \
2831   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2832   EntryProbe; \
2833   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2834   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2835   check_bounds(start, len, src-&gt;length(), CHECK); \
2836   if (len &gt; 0) {    \
2837     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2838   } \
2839 JNI_END
2840 
2841 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2842                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2843                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2844 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2845                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2846                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2847 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2848                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2849                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2850 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2851                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2852                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2853 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2854                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2855                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2856 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2857                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2858                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2859 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2860                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2861                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2862 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2863                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2864                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2865 
2866 
2867 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2868                                     , EntryProbe, ReturnProbe); \
2869   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2870                            ,ReturnProbe);           \
2871 \
2872 JNI_ENTRY(void, \
2873 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2874              jsize len, const ElementType *buf)) \
2875   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2876   EntryProbe; \
2877   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2878   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2879   check_bounds(start, len, dst-&gt;length(), CHECK); \
2880   if (len &gt; 0) { \
2881     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2882   } \
2883 JNI_END
2884 
2885 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2886                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2887                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2888 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2889                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2890                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2891 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2892                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2893                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2894 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2895                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2896                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2897 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2898                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2899                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2900 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2901                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2902                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2903 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2904                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2905                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2906 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2907                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2908                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2909 
2910 
2911 DT_RETURN_MARK_DECL(RegisterNatives, jint
2912                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2913 
2914 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2915                                     const JNINativeMethod *methods,
2916                                     jint nMethods))
2917   JNIWrapper(&quot;RegisterNatives&quot;);
2918   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2919   jint ret = 0;
2920   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2921 
2922   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2923 
<a name="22" id="anc22"></a>













2924   for (int index = 0; index &lt; nMethods; index++) {
2925     const char* meth_name = methods[index].name;
2926     const char* meth_sig = methods[index].signature;
2927     int meth_name_len = (int)strlen(meth_name);
2928 
2929     // The class should have been loaded (we have an instance of the class
2930     // passed in) so the method and signature should already be in the symbol
2931     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2932     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2933     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2934 
2935     if (name == NULL || signature == NULL) {
<a name="23" id="anc23"></a><span class="line-modified">2936       ResourceMark rm;</span>
2937       stringStream st;
2938       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2939       // Must return negative value on failure
2940       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2941     }
2942 
<a name="24" id="anc24"></a>





2943     bool res = Method::register_native(k, name, signature,
2944                                        (address) methods[index].fnPtr, THREAD);
2945     if (!res) {
2946       ret = -1;
2947       break;
2948     }
2949   }
2950   return ret;
2951 JNI_END
2952 
2953 
2954 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2955   JNIWrapper(&quot;UnregisterNatives&quot;);
2956  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2957   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2958   //%note jni_2
2959   if (k-&gt;is_instance_klass()) {
2960     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2961       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2962       if (m-&gt;is_native()) {
2963         m-&gt;clear_native_function();
2964         m-&gt;set_signature_handler(NULL);
2965       }
2966     }
2967   }
2968  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2969   return 0;
2970 JNI_END
2971 
2972 //
2973 // Monitor functions
2974 //
2975 
2976 DT_RETURN_MARK_DECL(MonitorEnter, jint
2977                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
2978 
2979 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
2980  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
2981   jint ret = JNI_ERR;
2982   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
2983 
2984   // If the object is null, we can&#39;t do anything with it
2985   if (jobj == NULL) {
2986     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
2987   }
2988 
2989   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
2990   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
2991   ret = JNI_OK;
2992   return ret;
2993 JNI_END
2994 
2995 DT_RETURN_MARK_DECL(MonitorExit, jint
2996                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
2997 
2998 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
2999  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3000   jint ret = JNI_ERR;
3001   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3002 
3003   // Don&#39;t do anything with a null object
3004   if (jobj == NULL) {
3005     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3006   }
3007 
3008   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3009   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3010 
3011   ret = JNI_OK;
3012   return ret;
3013 JNI_END
3014 
3015 //
3016 // Extensions
3017 //
3018 
3019 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3020                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3021 
3022 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3023   JNIWrapper(&quot;GetStringRegion&quot;);
3024  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3025   DT_VOID_RETURN_MARK(GetStringRegion);
3026   oop s = JNIHandles::resolve_non_null(string);
3027   typeArrayOop s_value = java_lang_String::value(s);
3028   int s_len = java_lang_String::length(s, s_value);
3029   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3030     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3031   } else {
3032     if (len &gt; 0) {
3033       bool is_latin1 = java_lang_String::is_latin1(s);
3034       if (!is_latin1) {
3035         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3036                                            buf, len);
3037       } else {
3038         for (int i = 0; i &lt; len; i++) {
3039           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3040         }
3041       }
3042     }
3043   }
3044 JNI_END
3045 
3046 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3047                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3048 
3049 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3050   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3051  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3052   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3053   oop s = JNIHandles::resolve_non_null(string);
3054   typeArrayOop s_value = java_lang_String::value(s);
3055   int s_len = java_lang_String::length(s, s_value);
3056   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3057     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3058   } else {
3059     //%note jni_7
3060     if (len &gt; 0) {
3061       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3062       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3063       // as_utf8_string null-terminates the result string
3064     } else {
3065       // JDK null-terminates the buffer even in len is zero
3066       if (buf != NULL) {
3067         buf[0] = 0;
3068       }
3069     }
3070   }
3071 JNI_END
3072 
3073 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3074   if (Universe::heap()-&gt;supports_object_pinning()) {
3075     const oop o = JNIHandles::resolve_non_null(obj);
3076     return Universe::heap()-&gt;pin_object(thread, o);
3077   } else {
3078     GCLocker::lock_critical(thread);
3079     return JNIHandles::resolve_non_null(obj);
3080   }
3081 }
3082 
3083 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3084   if (Universe::heap()-&gt;supports_object_pinning()) {
3085     const oop o = JNIHandles::resolve_non_null(obj);
3086     return Universe::heap()-&gt;unpin_object(thread, o);
3087   } else {
3088     GCLocker::unlock_critical(thread);
3089   }
3090 }
3091 
3092 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3093   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3094  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3095   if (isCopy != NULL) {
3096     *isCopy = JNI_FALSE;
3097   }
3098   oop a = lock_gc_or_pin_object(thread, array);
3099   assert(a-&gt;is_array(), &quot;just checking&quot;);
3100   BasicType type;
3101   if (a-&gt;is_objArray()) {
3102     type = T_OBJECT;
3103   } else {
3104     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3105   }
3106   void* ret = arrayOop(a)-&gt;base(type);
3107  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3108   return ret;
3109 JNI_END
3110 
3111 
3112 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3113   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3114   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3115   unlock_gc_or_unpin_object(thread, array);
3116 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3117 JNI_END
3118 
3119 
3120 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3121   JNIWrapper(&quot;GetStringCritical&quot;);
3122   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3123   oop s = lock_gc_or_pin_object(thread, string);
3124   typeArrayOop s_value = java_lang_String::value(s);
3125   bool is_latin1 = java_lang_String::is_latin1(s);
3126   if (isCopy != NULL) {
3127     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3128   }
3129   jchar* ret;
3130   if (!is_latin1) {
3131     ret = (jchar*) s_value-&gt;base(T_CHAR);
3132   } else {
3133     // Inflate latin1 encoded string to UTF16
3134     int s_len = java_lang_String::length(s, s_value);
3135     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3136     /* JNI Specification states return NULL on OOM */
3137     if (ret != NULL) {
3138       for (int i = 0; i &lt; s_len; i++) {
3139         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3140       }
3141       ret[s_len] = 0;
3142     }
3143   }
3144  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3145   return ret;
3146 JNI_END
3147 
3148 
3149 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3150   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3151   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3152   // The str and chars arguments are ignored for UTF16 strings
3153   oop s = JNIHandles::resolve_non_null(str);
3154   bool is_latin1 = java_lang_String::is_latin1(s);
3155   if (is_latin1) {
3156     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3157     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3158     FREE_C_HEAP_ARRAY(jchar, chars);
3159   }
3160   unlock_gc_or_unpin_object(thread, str);
3161 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3162 JNI_END
3163 
3164 
3165 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3166   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3167  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3168   Handle ref_handle(thread, JNIHandles::resolve(ref));
3169   jweak ret = JNIHandles::make_weak_global(ref_handle);
3170  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3171   return ret;
3172 JNI_END
3173 
3174 // Must be JNI_ENTRY (with HandleMark)
3175 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3176   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3177   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3178   JNIHandles::destroy_weak_global(ref);
3179   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3180 JNI_END
3181 
3182 
3183 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3184   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3185  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3186   jni_check_async_exceptions(thread);
3187   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3188  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3189   return ret;
3190 JNI_END
3191 
3192 
3193 // Initialization state for three routines below relating to
3194 // java.nio.DirectBuffers
3195 static          int directBufferSupportInitializeStarted = 0;
3196 static volatile int directBufferSupportInitializeEnded   = 0;
3197 static volatile int directBufferSupportInitializeFailed  = 0;
3198 static jclass    bufferClass                 = NULL;
3199 static jclass    directBufferClass           = NULL;
3200 static jclass    directByteBufferClass       = NULL;
3201 static jmethodID directByteBufferConstructor = NULL;
3202 static jfieldID  directBufferAddressField    = NULL;
3203 static jfieldID  bufferCapacityField         = NULL;
3204 
3205 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3206   Handle loader;            // null (bootstrap) loader
3207   Handle protection_domain; // null protection domain
3208 
3209   TempNewSymbol sym = SymbolTable::new_symbol(name);
3210   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3211 
3212   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3213     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3214   }
3215   return result;
3216 }
3217 
3218 // These lookups are done with the NULL (bootstrap) ClassLoader to
3219 // circumvent any security checks that would be done by jni_FindClass.
3220 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3221 {
3222   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3223   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3224   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3225   return true;
3226 }
3227 JNI_END
3228 
3229 
3230 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3231   if (directBufferSupportInitializeFailed) {
3232     return false;
3233   }
3234 
3235   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3236     if (!lookupDirectBufferClasses(env)) {
3237       directBufferSupportInitializeFailed = 1;
3238       return false;
3239     }
3240 
3241     // Make global references for these
3242     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3243     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3244     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3245 
3246     // Get needed field and method IDs
3247     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3248     if (env-&gt;ExceptionCheck()) {
3249       env-&gt;ExceptionClear();
3250       directBufferSupportInitializeFailed = 1;
3251       return false;
3252     }
3253     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3254     if (env-&gt;ExceptionCheck()) {
3255       env-&gt;ExceptionClear();
3256       directBufferSupportInitializeFailed = 1;
3257       return false;
3258     }
3259     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3260     if (env-&gt;ExceptionCheck()) {
3261       env-&gt;ExceptionClear();
3262       directBufferSupportInitializeFailed = 1;
3263       return false;
3264     }
3265 
3266     if ((directByteBufferConstructor == NULL) ||
3267         (directBufferAddressField    == NULL) ||
3268         (bufferCapacityField         == NULL)) {
3269       directBufferSupportInitializeFailed = 1;
3270       return false;
3271     }
3272 
3273     directBufferSupportInitializeEnded = 1;
3274   } else {
3275     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3276       os::naked_yield();
3277     }
3278   }
3279 
3280   return !directBufferSupportInitializeFailed;
3281 }
3282 
3283 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3284 {
3285   // thread_from_jni_environment() will block if VM is gone.
3286   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3287 
3288   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3289  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3290 
3291   if (!directBufferSupportInitializeEnded) {
3292     if (!initializeDirectBufferSupport(env, thread)) {
3293       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3294       return NULL;
3295     }
3296   }
3297 
3298   // Being paranoid about accidental sign extension on address
3299   jlong addr = (jlong) ((uintptr_t) address);
3300   // NOTE that package-private DirectByteBuffer constructor currently
3301   // takes int capacity
3302   jint  cap  = (jint)  capacity;
3303   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3304   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3305   return ret;
3306 }
3307 
3308 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3309                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3310 
3311 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3312 {
3313   // thread_from_jni_environment() will block if VM is gone.
3314   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3315 
3316   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3317   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3318   void* ret = NULL;
3319   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3320 
3321   if (!directBufferSupportInitializeEnded) {
3322     if (!initializeDirectBufferSupport(env, thread)) {
3323       return 0;
3324     }
3325   }
3326 
3327   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3328     return 0;
3329   }
3330 
3331   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3332   return ret;
3333 }
3334 
3335 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3336                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3337 
3338 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3339 {
3340   // thread_from_jni_environment() will block if VM is gone.
3341   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3342 
3343   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3344   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3345   jlong ret = -1;
3346   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3347 
3348   if (!directBufferSupportInitializeEnded) {
3349     if (!initializeDirectBufferSupport(env, thread)) {
3350       ret = 0;
3351       return ret;
3352     }
3353   }
3354 
3355   if (buf == NULL) {
3356     return -1;
3357   }
3358 
3359   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3360     return -1;
3361   }
3362 
3363   // NOTE that capacity is currently an int in the implementation
3364   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3365   return ret;
3366 }
3367 
3368 
3369 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3370   JNIWrapper(&quot;GetVersion&quot;);
3371   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3372   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3373   return CurrentVersion;
3374 JNI_END
3375 
3376 extern struct JavaVM_ main_vm;
3377 
3378 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3379   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3380   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3381   *vm  = (JavaVM *)(&amp;main_vm);
3382   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3383   return JNI_OK;
3384 JNI_END
3385 
3386 
3387 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3388   JNIWrapper(&quot;GetModule&quot;);
3389   return Modules::get_module(clazz, THREAD);
3390 JNI_END
3391 
3392 
3393 // Structure containing all jni functions
3394 struct JNINativeInterface_ jni_NativeInterface = {
3395     NULL,
3396     NULL,
3397     NULL,
3398 
3399     NULL,
3400 
3401     jni_GetVersion,
3402 
3403     jni_DefineClass,
3404     jni_FindClass,
3405 
3406     jni_FromReflectedMethod,
3407     jni_FromReflectedField,
3408 
3409     jni_ToReflectedMethod,
3410 
3411     jni_GetSuperclass,
3412     jni_IsAssignableFrom,
3413 
3414     jni_ToReflectedField,
3415 
3416     jni_Throw,
3417     jni_ThrowNew,
3418     jni_ExceptionOccurred,
3419     jni_ExceptionDescribe,
3420     jni_ExceptionClear,
3421     jni_FatalError,
3422 
3423     jni_PushLocalFrame,
3424     jni_PopLocalFrame,
3425 
3426     jni_NewGlobalRef,
3427     jni_DeleteGlobalRef,
3428     jni_DeleteLocalRef,
3429     jni_IsSameObject,
3430 
3431     jni_NewLocalRef,
3432     jni_EnsureLocalCapacity,
3433 
3434     jni_AllocObject,
3435     jni_NewObject,
3436     jni_NewObjectV,
3437     jni_NewObjectA,
3438 
3439     jni_GetObjectClass,
3440     jni_IsInstanceOf,
3441 
3442     jni_GetMethodID,
3443 
3444     jni_CallObjectMethod,
3445     jni_CallObjectMethodV,
3446     jni_CallObjectMethodA,
3447     jni_CallBooleanMethod,
3448     jni_CallBooleanMethodV,
3449     jni_CallBooleanMethodA,
3450     jni_CallByteMethod,
3451     jni_CallByteMethodV,
3452     jni_CallByteMethodA,
3453     jni_CallCharMethod,
3454     jni_CallCharMethodV,
3455     jni_CallCharMethodA,
3456     jni_CallShortMethod,
3457     jni_CallShortMethodV,
3458     jni_CallShortMethodA,
3459     jni_CallIntMethod,
3460     jni_CallIntMethodV,
3461     jni_CallIntMethodA,
3462     jni_CallLongMethod,
3463     jni_CallLongMethodV,
3464     jni_CallLongMethodA,
3465     jni_CallFloatMethod,
3466     jni_CallFloatMethodV,
3467     jni_CallFloatMethodA,
3468     jni_CallDoubleMethod,
3469     jni_CallDoubleMethodV,
3470     jni_CallDoubleMethodA,
3471     jni_CallVoidMethod,
3472     jni_CallVoidMethodV,
3473     jni_CallVoidMethodA,
3474 
3475     jni_CallNonvirtualObjectMethod,
3476     jni_CallNonvirtualObjectMethodV,
3477     jni_CallNonvirtualObjectMethodA,
3478     jni_CallNonvirtualBooleanMethod,
3479     jni_CallNonvirtualBooleanMethodV,
3480     jni_CallNonvirtualBooleanMethodA,
3481     jni_CallNonvirtualByteMethod,
3482     jni_CallNonvirtualByteMethodV,
3483     jni_CallNonvirtualByteMethodA,
3484     jni_CallNonvirtualCharMethod,
3485     jni_CallNonvirtualCharMethodV,
3486     jni_CallNonvirtualCharMethodA,
3487     jni_CallNonvirtualShortMethod,
3488     jni_CallNonvirtualShortMethodV,
3489     jni_CallNonvirtualShortMethodA,
3490     jni_CallNonvirtualIntMethod,
3491     jni_CallNonvirtualIntMethodV,
3492     jni_CallNonvirtualIntMethodA,
3493     jni_CallNonvirtualLongMethod,
3494     jni_CallNonvirtualLongMethodV,
3495     jni_CallNonvirtualLongMethodA,
3496     jni_CallNonvirtualFloatMethod,
3497     jni_CallNonvirtualFloatMethodV,
3498     jni_CallNonvirtualFloatMethodA,
3499     jni_CallNonvirtualDoubleMethod,
3500     jni_CallNonvirtualDoubleMethodV,
3501     jni_CallNonvirtualDoubleMethodA,
3502     jni_CallNonvirtualVoidMethod,
3503     jni_CallNonvirtualVoidMethodV,
3504     jni_CallNonvirtualVoidMethodA,
3505 
3506     jni_GetFieldID,
3507 
3508     jni_GetObjectField,
3509     jni_GetBooleanField,
3510     jni_GetByteField,
3511     jni_GetCharField,
3512     jni_GetShortField,
3513     jni_GetIntField,
3514     jni_GetLongField,
3515     jni_GetFloatField,
3516     jni_GetDoubleField,
3517 
3518     jni_SetObjectField,
3519     jni_SetBooleanField,
3520     jni_SetByteField,
3521     jni_SetCharField,
3522     jni_SetShortField,
3523     jni_SetIntField,
3524     jni_SetLongField,
3525     jni_SetFloatField,
3526     jni_SetDoubleField,
3527 
3528     jni_GetStaticMethodID,
3529 
3530     jni_CallStaticObjectMethod,
3531     jni_CallStaticObjectMethodV,
3532     jni_CallStaticObjectMethodA,
3533     jni_CallStaticBooleanMethod,
3534     jni_CallStaticBooleanMethodV,
3535     jni_CallStaticBooleanMethodA,
3536     jni_CallStaticByteMethod,
3537     jni_CallStaticByteMethodV,
3538     jni_CallStaticByteMethodA,
3539     jni_CallStaticCharMethod,
3540     jni_CallStaticCharMethodV,
3541     jni_CallStaticCharMethodA,
3542     jni_CallStaticShortMethod,
3543     jni_CallStaticShortMethodV,
3544     jni_CallStaticShortMethodA,
3545     jni_CallStaticIntMethod,
3546     jni_CallStaticIntMethodV,
3547     jni_CallStaticIntMethodA,
3548     jni_CallStaticLongMethod,
3549     jni_CallStaticLongMethodV,
3550     jni_CallStaticLongMethodA,
3551     jni_CallStaticFloatMethod,
3552     jni_CallStaticFloatMethodV,
3553     jni_CallStaticFloatMethodA,
3554     jni_CallStaticDoubleMethod,
3555     jni_CallStaticDoubleMethodV,
3556     jni_CallStaticDoubleMethodA,
3557     jni_CallStaticVoidMethod,
3558     jni_CallStaticVoidMethodV,
3559     jni_CallStaticVoidMethodA,
3560 
3561     jni_GetStaticFieldID,
3562 
3563     jni_GetStaticObjectField,
3564     jni_GetStaticBooleanField,
3565     jni_GetStaticByteField,
3566     jni_GetStaticCharField,
3567     jni_GetStaticShortField,
3568     jni_GetStaticIntField,
3569     jni_GetStaticLongField,
3570     jni_GetStaticFloatField,
3571     jni_GetStaticDoubleField,
3572 
3573     jni_SetStaticObjectField,
3574     jni_SetStaticBooleanField,
3575     jni_SetStaticByteField,
3576     jni_SetStaticCharField,
3577     jni_SetStaticShortField,
3578     jni_SetStaticIntField,
3579     jni_SetStaticLongField,
3580     jni_SetStaticFloatField,
3581     jni_SetStaticDoubleField,
3582 
3583     jni_NewString,
3584     jni_GetStringLength,
3585     jni_GetStringChars,
3586     jni_ReleaseStringChars,
3587 
3588     jni_NewStringUTF,
3589     jni_GetStringUTFLength,
3590     jni_GetStringUTFChars,
3591     jni_ReleaseStringUTFChars,
3592 
3593     jni_GetArrayLength,
3594 
3595     jni_NewObjectArray,
3596     jni_GetObjectArrayElement,
3597     jni_SetObjectArrayElement,
3598 
3599     jni_NewBooleanArray,
3600     jni_NewByteArray,
3601     jni_NewCharArray,
3602     jni_NewShortArray,
3603     jni_NewIntArray,
3604     jni_NewLongArray,
3605     jni_NewFloatArray,
3606     jni_NewDoubleArray,
3607 
3608     jni_GetBooleanArrayElements,
3609     jni_GetByteArrayElements,
3610     jni_GetCharArrayElements,
3611     jni_GetShortArrayElements,
3612     jni_GetIntArrayElements,
3613     jni_GetLongArrayElements,
3614     jni_GetFloatArrayElements,
3615     jni_GetDoubleArrayElements,
3616 
3617     jni_ReleaseBooleanArrayElements,
3618     jni_ReleaseByteArrayElements,
3619     jni_ReleaseCharArrayElements,
3620     jni_ReleaseShortArrayElements,
3621     jni_ReleaseIntArrayElements,
3622     jni_ReleaseLongArrayElements,
3623     jni_ReleaseFloatArrayElements,
3624     jni_ReleaseDoubleArrayElements,
3625 
3626     jni_GetBooleanArrayRegion,
3627     jni_GetByteArrayRegion,
3628     jni_GetCharArrayRegion,
3629     jni_GetShortArrayRegion,
3630     jni_GetIntArrayRegion,
3631     jni_GetLongArrayRegion,
3632     jni_GetFloatArrayRegion,
3633     jni_GetDoubleArrayRegion,
3634 
3635     jni_SetBooleanArrayRegion,
3636     jni_SetByteArrayRegion,
3637     jni_SetCharArrayRegion,
3638     jni_SetShortArrayRegion,
3639     jni_SetIntArrayRegion,
3640     jni_SetLongArrayRegion,
3641     jni_SetFloatArrayRegion,
3642     jni_SetDoubleArrayRegion,
3643 
3644     jni_RegisterNatives,
3645     jni_UnregisterNatives,
3646 
3647     jni_MonitorEnter,
3648     jni_MonitorExit,
3649 
3650     jni_GetJavaVM,
3651 
3652     jni_GetStringRegion,
3653     jni_GetStringUTFRegion,
3654 
3655     jni_GetPrimitiveArrayCritical,
3656     jni_ReleasePrimitiveArrayCritical,
3657 
3658     jni_GetStringCritical,
3659     jni_ReleaseStringCritical,
3660 
3661     jni_NewWeakGlobalRef,
3662     jni_DeleteWeakGlobalRef,
3663 
3664     jni_ExceptionCheck,
3665 
3666     jni_NewDirectByteBuffer,
3667     jni_GetDirectBufferAddress,
3668     jni_GetDirectBufferCapacity,
3669 
3670     // New 1_6 features
3671 
3672     jni_GetObjectRefType,
3673 
3674     // Module features
3675 
3676     jni_GetModule
3677 };
3678 
3679 
3680 // For jvmti use to modify jni function table.
3681 // Java threads in native contiues to run until it is transitioned
3682 // to VM at safepoint. Before the transition or before it is blocked
3683 // for safepoint it may access jni function table. VM could crash if
3684 // any java thread access the jni function table in the middle of memcpy.
3685 // To avoid this each function pointers are copied automically.
3686 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3687   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3688   intptr_t *a = (intptr_t *) jni_functions();
3689   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3690   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3691     Atomic::store(a++, *b++);
3692   }
3693 }
3694 
3695 void quicken_jni_functions() {
3696   // Replace Get&lt;Primitive&gt;Field with fast versions
3697   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
3698     address func;
3699     func = JNI_FastGetField::generate_fast_get_boolean_field();
3700     if (func != (address)-1) {
3701       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
3702     }
3703     func = JNI_FastGetField::generate_fast_get_byte_field();
3704     if (func != (address)-1) {
3705       jni_NativeInterface.GetByteField = (GetByteField_t)func;
3706     }
3707     func = JNI_FastGetField::generate_fast_get_char_field();
3708     if (func != (address)-1) {
3709       jni_NativeInterface.GetCharField = (GetCharField_t)func;
3710     }
3711     func = JNI_FastGetField::generate_fast_get_short_field();
3712     if (func != (address)-1) {
3713       jni_NativeInterface.GetShortField = (GetShortField_t)func;
3714     }
3715     func = JNI_FastGetField::generate_fast_get_int_field();
3716     if (func != (address)-1) {
3717       jni_NativeInterface.GetIntField = (GetIntField_t)func;
3718     }
3719     func = JNI_FastGetField::generate_fast_get_long_field();
3720     if (func != (address)-1) {
3721       jni_NativeInterface.GetLongField = (GetLongField_t)func;
3722     }
3723     func = JNI_FastGetField::generate_fast_get_float_field();
3724     if (func != (address)-1) {
3725       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
3726     }
3727     func = JNI_FastGetField::generate_fast_get_double_field();
3728     if (func != (address)-1) {
3729       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
3730     }
3731   }
3732 }
3733 
3734 // Returns the function structure
3735 struct JNINativeInterface_* jni_functions() {
3736 #if INCLUDE_JNI_CHECK
3737   if (CheckJNICalls) return jni_functions_check();
3738 #endif // INCLUDE_JNI_CHECK
3739   return &amp;jni_NativeInterface;
3740 }
3741 
3742 // Returns the function structure
3743 struct JNINativeInterface_* jni_functions_nocheck() {
3744   return &amp;jni_NativeInterface;
3745 }
3746 
3747 static void post_thread_start_event(const JavaThread* jt) {
3748   assert(jt != NULL, &quot;invariant&quot;);
3749   EventThreadStart event;
3750   if (event.should_commit()) {
3751     event.set_thread(JFR_THREAD_ID(jt));
3752     event.commit();
3753   }
3754 }
3755 
3756 // Invocation API
3757 
3758 
3759 // Forward declaration
3760 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3761 
3762 // Global invocation API vars
3763 volatile int vm_created = 0;
3764 // Indicate whether it is safe to recreate VM
3765 volatile int safe_to_recreate_vm = 1;
3766 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3767 
3768 
3769 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3770 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3771 
3772 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3773                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3774 
3775 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3776   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3777   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3778   jint ret = JNI_ERR;
3779   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3780 
3781   if (Threads::is_supported_jni_version(args-&gt;version)) {
3782     ret = JNI_OK;
3783   }
3784   // 1.1 style no longer supported in hotspot.
3785   // According the JNI spec, we should update args-&gt;version on return.
3786   // We also use the structure to communicate with launcher about default
3787   // stack size.
3788   if (args-&gt;version == JNI_VERSION_1_1) {
3789     args-&gt;version = JNI_VERSION_1_2;
3790     // javaStackSize is int in arguments structure
3791     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
3792     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
3793   }
3794   return ret;
3795 }
3796 
3797 DT_RETURN_MARK_DECL(CreateJavaVM, jint
3798                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
3799 
3800 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
3801   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
3802 
3803   jint result = JNI_ERR;
3804   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
3805 
3806   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
3807   // platforms use the GCC builtin __sync_lock_test_and_set for this,
3808   // but __sync_lock_test_and_set is not guaranteed to do what we want
3809   // on all architectures.  So we check it works before relying on it.
3810 #if defined(ZERO) &amp;&amp; defined(ASSERT)
3811   {
3812     jint a = 0xcafebabe;
3813     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
3814     void *c = &amp;a;
3815     void *d = Atomic::xchg(&amp;c, &amp;b);
3816     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3817     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3818   }
3819 #endif // ZERO &amp;&amp; ASSERT
3820 
3821   // At the moment it&#39;s only possible to have one Java VM,
3822   // since some of the runtime state is in global variables.
3823 
3824   // We cannot use our mutex locks here, since they only work on
3825   // Threads. We do an atomic compare and exchange to ensure only
3826   // one thread can call this method at a time
3827 
3828   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3829   // the add/dec implementations are dependent on whether we are running
3830   // on a multiprocessor Atomic::xchg does not have this problem.
3831   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
3832     return JNI_EEXIST;   // already created, or create attempt in progress
3833   }
3834   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
3835     return JNI_ERR;  // someone tried and failed and retry not allowed.
3836   }
3837 
3838   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3839 
3840   /**
3841    * Certain errors during initialization are recoverable and do not
3842    * prevent this method from being called again at a later time
3843    * (perhaps with different arguments).  However, at a certain
3844    * point during initialization if an error occurs we cannot allow
3845    * this function to be called again (or it will crash).  In those
3846    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3847    * sets safe_to_recreate_vm to 1, such that any new call to
3848    * JNI_CreateJavaVM will immediately fail using the above logic.
3849    */
3850   bool can_try_again = true;
3851 
3852   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3853   if (result == JNI_OK) {
3854     JavaThread *thread = JavaThread::current();
3855     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
3856     /* thread is thread_in_vm here */
3857     *vm = (JavaVM *)(&amp;main_vm);
3858     *(JNIEnv**)penv = thread-&gt;jni_environment();
3859 
3860 #if INCLUDE_JVMCI
3861     if (EnableJVMCI) {
3862       if (UseJVMCICompiler) {
3863         // JVMCI is initialized on a CompilerThread
3864         if (BootstrapJVMCI) {
3865           JavaThread* THREAD = thread;
3866           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
3867           compiler-&gt;bootstrap(THREAD);
3868           if (HAS_PENDING_EXCEPTION) {
3869             HandleMark hm;
3870             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3871           }
3872         }
3873       }
3874     }
3875 #endif
3876 
3877     // Notify JVMTI
3878     if (JvmtiExport::should_post_thread_life()) {
3879        JvmtiExport::post_thread_start(thread);
3880     }
3881 
3882     post_thread_start_event(thread);
3883 
3884 #ifndef PRODUCT
3885     if (ReplayCompiles) ciReplay::replay(thread);
3886 
3887     // Some platforms (like Win*) need a wrapper around these test
3888     // functions in order to properly handle error conditions.
3889     VMError::test_error_handler();
3890 #endif
3891 
3892     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
3893     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3894   } else {
3895     // If create_vm exits because of a pending exception, exit with that
3896     // exception.  In the future when we figure out how to reclaim memory,
3897     // we may be able to exit with JNI_ERR and allow the calling application
3898     // to continue.
3899     if (Universe::is_fully_initialized()) {
3900       // otherwise no pending exception possible - VM will already have aborted
3901       JavaThread* THREAD = JavaThread::current();
3902       if (HAS_PENDING_EXCEPTION) {
3903         HandleMark hm;
3904         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
3905       }
3906     }
3907 
3908     if (can_try_again) {
3909       // reset safe_to_recreate_vm to 1 so that retrial would be possible
3910       safe_to_recreate_vm = 1;
3911     }
3912 
3913     // Creation failed. We must reset vm_created
3914     *vm = 0;
3915     *(JNIEnv**)penv = 0;
3916     // reset vm_created last to avoid race condition. Use OrderAccess to
3917     // control both compiler and architectural-based reordering.
3918     Atomic::release_store(&amp;vm_created, 0);
3919   }
3920 
3921   // Flush stdout and stderr before exit.
3922   fflush(stdout);
3923   fflush(stderr);
3924 
3925   return result;
3926 
3927 }
3928 
3929 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
3930   jint result = JNI_ERR;
3931   // On Windows, let CreateJavaVM run with SEH protection
3932 #ifdef _WIN32
3933   __try {
3934 #endif
3935     result = JNI_CreateJavaVM_inner(vm, penv, args);
3936 #ifdef _WIN32
3937   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3938     // Nothing to do.
3939   }
3940 #endif
3941   return result;
3942 }
3943 
3944 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
3945   // See bug 4367188, the wrapper can sometimes cause VM crashes
3946   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
3947 
3948   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
3949 
3950   if (vm_created == 1) {
3951     if (numVMs != NULL) *numVMs = 1;
3952     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
3953   } else {
3954     if (numVMs != NULL) *numVMs = 0;
3955   }
3956   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
3957   return JNI_OK;
3958 }
3959 
3960 extern &quot;C&quot; {
3961 
3962 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
3963                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
3964 
3965 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
3966   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
3967   jint res = JNI_ERR;
3968   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
3969 
3970   if (vm_created == 0) {
3971     res = JNI_ERR;
3972     return res;
3973   }
3974 
3975   JNIWrapper(&quot;DestroyJavaVM&quot;);
3976   JNIEnv *env;
3977   JavaVMAttachArgs destroyargs;
3978   destroyargs.version = CurrentVersion;
3979   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
3980   destroyargs.group = NULL;
3981   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
3982   if (res != JNI_OK) {
3983     return res;
3984   }
3985 
3986   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
3987   JavaThread* thread = JavaThread::current();
3988   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
3989   if (Threads::destroy_vm()) {
3990     // Should not change thread state, VM is gone
3991     vm_created = 0;
3992     res = JNI_OK;
3993     return res;
3994   } else {
3995     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
3996     res = JNI_ERR;
3997     return res;
3998   }
3999 }
4000 
4001 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4002   jint result = JNI_ERR;
4003   // On Windows, we need SEH protection
4004 #ifdef _WIN32
4005   __try {
4006 #endif
4007     result = jni_DestroyJavaVM_inner(vm);
4008 #ifdef _WIN32
4009   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4010     // Nothing to do.
4011   }
4012 #endif
4013   return result;
4014 }
4015 
4016 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4017   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4018 
4019   // Check below commented out from JDK1.2fcs as well
4020   /*
4021   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4022     return JNI_EVERSION;
4023   }
4024   */
4025 
4026   Thread* t = Thread::current_or_null();
4027   if (t != NULL) {
4028     // If the thread has been attached this operation is a no-op
4029     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4030     return JNI_OK;
4031   }
4032 
4033   // Create a thread and mark it as attaching so it will be skipped by the
4034   // ThreadsListEnumerator - see CR 6404306
4035   JavaThread* thread = new JavaThread(true);
4036 
4037   // Set correct safepoint info. The thread is going to call into Java when
4038   // initializing the Java level thread object. Hence, the correct state must
4039   // be set in order for the Safepoint code to deal with it correctly.
4040   thread-&gt;set_thread_state(_thread_in_vm);
4041   thread-&gt;record_stack_base_and_size();
4042   thread-&gt;register_thread_stack_with_NMT();
4043   thread-&gt;initialize_thread_current();
4044 
4045   if (!os::create_attached_thread(thread)) {
4046     thread-&gt;smr_delete();
4047     return JNI_ERR;
4048   }
4049   // Enable stack overflow checks
4050   thread-&gt;create_stack_guard_pages();
4051 
4052   thread-&gt;initialize_tlab();
4053 
4054   thread-&gt;cache_global_variables();
4055 
4056   // This thread will not do a safepoint check, since it has
4057   // not been added to the Thread list yet.
4058   { MutexLocker ml(Threads_lock);
4059     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4060     // avoid this thread trying to do a GC before it is added to the thread-list
4061     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4062     Threads::add(thread, daemon);
4063   }
4064   // Create thread group and name info from attach arguments
4065   oop group = NULL;
4066   char* thread_name = NULL;
4067   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4068     group = JNIHandles::resolve(args-&gt;group);
4069     thread_name = args-&gt;name; // may be NULL
4070   }
4071   if (group == NULL) group = Universe::main_thread_group();
4072 
4073   // Create Java level thread object and attach it to this thread
4074   bool attach_failed = false;
4075   {
4076     EXCEPTION_MARK;
4077     HandleMark hm(THREAD);
4078     Handle thread_group(THREAD, group);
4079     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4080     if (HAS_PENDING_EXCEPTION) {
4081       CLEAR_PENDING_EXCEPTION;
4082       // cleanup outside the handle mark.
4083       attach_failed = true;
4084     }
4085   }
4086 
4087   if (attach_failed) {
4088     // Added missing cleanup
4089     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4090     return JNI_ERR;
4091   }
4092 
4093   // mark the thread as no longer attaching
4094   // this uses a fence to push the change through so we don&#39;t have
4095   // to regrab the threads_lock
4096   thread-&gt;set_done_attaching_via_jni();
4097 
4098   // Set java thread status.
4099   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4100               java_lang_Thread::RUNNABLE);
4101 
4102   // Notify the debugger
4103   if (JvmtiExport::should_post_thread_life()) {
4104     JvmtiExport::post_thread_start(thread);
4105   }
4106 
4107   post_thread_start_event(thread);
4108 
4109   *(JNIEnv**)penv = thread-&gt;jni_environment();
4110 
4111   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4112   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4113   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4114   // needed.
4115 
4116   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4117 
4118   // Perform any platform dependent FPU setup
4119   os::setup_fpu();
4120 
4121   return JNI_OK;
4122 }
4123 
4124 
4125 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4126   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4127   if (vm_created == 0) {
4128   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4129     return JNI_ERR;
4130   }
4131 
4132   JNIWrapper(&quot;AttachCurrentThread&quot;);
4133   jint ret = attach_current_thread(vm, penv, _args, false);
4134   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4135   return ret;
4136 }
4137 
4138 
4139 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4140   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4141 
4142   JNIWrapper(&quot;DetachCurrentThread&quot;);
4143 
4144   // If the thread has already been detached the operation is a no-op
4145   if (Thread::current_or_null() == NULL) {
4146     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4147     return JNI_OK;
4148   }
4149 
4150   VM_Exit::block_if_vm_exited();
4151 
4152   JavaThread* thread = JavaThread::current();
4153   if (thread-&gt;has_last_Java_frame()) {
4154     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4155     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4156     return JNI_ERR;
4157   }
4158 
4159   // Safepoint support. Have to do call-back to safepoint code, if in the
4160   // middle of a safepoint operation
4161   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4162 
4163   // XXX: Note that JavaThread::exit() call below removes the guards on the
4164   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4165   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4166   // of the guards is visible in jni_AttachCurrentThread above,
4167   // the removal of the guards is buried below in JavaThread::exit()
4168   // here. The abstraction should be more symmetrically either exposed
4169   // or hidden (e.g. it could probably be hidden in the same
4170   // (platform-dependent) methods where we do alternate stack
4171   // maintenance work?)
4172   thread-&gt;exit(false, JavaThread::jni_detach);
4173   thread-&gt;smr_delete();
4174 
4175   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4176   return JNI_OK;
4177 }
4178 
4179 DT_RETURN_MARK_DECL(GetEnv, jint
4180                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4181 
4182 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4183   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4184   jint ret = JNI_ERR;
4185   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4186 
4187   if (vm_created == 0) {
4188     *penv = NULL;
4189     ret = JNI_EDETACHED;
4190     return ret;
4191   }
4192 
4193   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4194     return ret;
4195   }
4196 
4197 #ifndef JVMPI_VERSION_1
4198 // need these in order to be polite about older agents
4199 #define JVMPI_VERSION_1   ((jint)0x10000001)
4200 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4201 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4202 #endif // !JVMPI_VERSION_1
4203 
4204   Thread* thread = Thread::current_or_null();
4205   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4206     if (Threads::is_supported_jni_version_including_1_1(version)) {
4207       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4208       ret = JNI_OK;
4209       return ret;
4210 
4211     } else if (version == JVMPI_VERSION_1 ||
4212                version == JVMPI_VERSION_1_1 ||
4213                version == JVMPI_VERSION_1_2) {
4214       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4215       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4216       ret = JNI_EVERSION;
4217       return ret;
4218     } else if (JvmtiExport::is_jvmdi_version(version)) {
4219       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4220       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4221       ret = JNI_EVERSION;
4222       return ret;
4223     } else {
4224       *penv = NULL;
4225       ret = JNI_EVERSION;
4226       return ret;
4227     }
4228   } else {
4229     *penv = NULL;
4230     ret = JNI_EDETACHED;
4231     return ret;
4232   }
4233 }
4234 
4235 
4236 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4237   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4238   if (vm_created == 0) {
4239   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4240     return JNI_ERR;
4241   }
4242 
4243   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4244   jint ret = attach_current_thread(vm, penv, _args, true);
4245   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4246   return ret;
4247 }
4248 
4249 
4250 } // End extern &quot;C&quot;
4251 
4252 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4253     NULL,
4254     NULL,
4255     NULL,
4256 
4257     jni_DestroyJavaVM,
4258     jni_AttachCurrentThread,
4259     jni_DetachCurrentThread,
4260     jni_GetEnv,
4261     jni_AttachCurrentThreadAsDaemon
4262 };
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>