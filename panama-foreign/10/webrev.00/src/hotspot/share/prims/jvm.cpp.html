<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/jvmtiThreadState.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;prims/stackwalk.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/init.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/deoptimization.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/java.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  73 #include &quot;runtime/jniHandles.inline.hpp&quot;
  74 #include &quot;runtime/os.inline.hpp&quot;
  75 #include &quot;runtime/perfData.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/thread.inline.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vframe.inline.hpp&quot;
  80 #include &quot;runtime/vmOperations.hpp&quot;
  81 #include &quot;runtime/vm_version.hpp&quot;
  82 #include &quot;services/attachListener.hpp&quot;
  83 #include &quot;services/management.hpp&quot;
  84 #include &quot;services/threadService.hpp&quot;
  85 #include &quot;utilities/copy.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
  91 #include &quot;utilities/utf8.hpp&quot;
  92 #if INCLUDE_CDS
  93 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  94 #endif
  95 
  96 #include &lt;errno.h&gt;
  97 
  98 /*
  99   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 100   such ctors and calls MUST NOT come between an oop declaration/init and its
 101   usage because if objects are move this may cause various memory stomps, bus
 102   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 103   failures&quot;:
 104 
 105       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 106           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 107 
 108           // Object address to be held directly in mirror &amp; not visible to GC
 109           oop mirror = JNIHandles::resolve_non_null(ofClass);
 110 
 111           // If this ctor can hit a safepoint, moving objects around, then
 112           ComplexConstructor foo;
 113 
 114           // Boom! mirror may point to JUNK instead of the intended object
 115           (some dereference of mirror)
 116 
 117           // Here&#39;s another call that may block for GC, making mirror stale
 118           MutexLocker ml(some_lock);
 119 
 120           // And here&#39;s an initializer that can result in a stale oop
 121           // all in one step.
 122           oop o = call_that_can_throw_exception(TRAPS);
 123 
 124 
 125   The solution is to keep the oop declaration BELOW the ctor or function
 126   call that might cause a GC, do another resolve to reassign the oop, or
 127   consider use of a Handle instead of an oop so there is immunity from object
 128   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 129   and thus can only support use of handles passed in.
 130 */
 131 
 132 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 133   ResourceMark rm;
 134   int line_number = -1;
 135   const char * source_file = NULL;
 136   const char * trace = &quot;explicit&quot;;
 137   InstanceKlass* caller = NULL;
 138   JavaThread* jthread = JavaThread::current();
 139   if (jthread-&gt;has_last_Java_frame()) {
 140     vframeStream vfst(jthread);
 141 
 142     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 143     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 144     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 145     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 146     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 147 
 148     Method* last_caller = NULL;
 149 
 150     while (!vfst.at_end()) {
 151       Method* m = vfst.method();
 152       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 153           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 154           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 155         break;
 156       }
 157       last_caller = m;
 158       vfst.next();
 159     }
 160     // if this is called from Class.forName0 and that is called from Class.forName,
 161     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 162     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 163     bool found_it = false;
 164     if (!vfst.at_end() &amp;&amp;
 165         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 166         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 167       vfst.next();
 168       if (!vfst.at_end() &amp;&amp;
 169           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 170           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 171         vfst.next();
 172         found_it = true;
 173       }
 174     } else if (last_caller != NULL &amp;&amp;
 175                last_caller-&gt;method_holder()-&gt;name() ==
 176                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 177                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 178       found_it = true;
 179     } else if (!vfst.at_end()) {
 180       if (vfst.method()-&gt;is_native()) {
 181         // JNI call
 182         found_it = true;
 183       }
 184     }
 185     if (found_it &amp;&amp; !vfst.at_end()) {
 186       // found the caller
 187       caller = vfst.method()-&gt;method_holder();
 188       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 189       if (line_number == -1) {
 190         // show method name if it&#39;s a native method
 191         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 192       }
 193       Symbol* s = caller-&gt;source_file_name();
 194       if (s != NULL) {
 195         source_file = s-&gt;as_C_string();
 196       }
 197     }
 198   }
 199   if (caller != NULL) {
 200     if (to_class != caller) {
 201       const char * from = caller-&gt;external_name();
 202       const char * to = to_class-&gt;external_name();
 203       // print in a single call to reduce interleaving between threads
 204       if (source_file != NULL) {
 205         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 206       } else {
 207         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 208       }
 209     }
 210   }
 211 }
 212 
 213 void trace_class_resolution(Klass* to_class) {
 214   EXCEPTION_MARK;
 215   trace_class_resolution_impl(to_class, THREAD);
 216   if (HAS_PENDING_EXCEPTION) {
 217     CLEAR_PENDING_EXCEPTION;
 218   }
 219 }
 220 
 221 // Wrapper to trace JVM functions
 222 
 223 #ifdef ASSERT
 224   Histogram* JVMHistogram;
 225   volatile int JVMHistogram_lock = 0;
 226 
 227   class JVMHistogramElement : public HistogramElement {
 228     public:
 229      JVMHistogramElement(const char* name);
 230   };
 231 
 232   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 233     _name = elementName;
 234     uintx count = 0;
 235 
 236     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 237       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 238         count +=1;
 239         if ( (WarnOnStalledSpinLock &gt; 0)
 240           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 241           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 242         }
 243       }
 244      }
 245 
 246     if(JVMHistogram == NULL)
 247       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 248 
 249     JVMHistogram-&gt;add_element(this);
 250     Atomic::dec(&amp;JVMHistogram_lock);
 251   }
 252 
 253   #define JVMCountWrapper(arg) \
 254       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 255       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 256 
 257   #define JVMWrapper(arg) JVMCountWrapper(arg);
 258 #else
 259   #define JVMWrapper(arg)
 260 #endif
 261 
 262 
 263 // Interface version /////////////////////////////////////////////////////////////////////
 264 
 265 
 266 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 267   return JVM_INTERFACE_VERSION;
 268 JVM_END
 269 
 270 
 271 // java.lang.System //////////////////////////////////////////////////////////////////////
 272 
 273 
 274 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 275   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 276   return os::javaTimeMillis();
 277 JVM_END
 278 
 279 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 280   JVMWrapper(&quot;JVM_NanoTime&quot;);
 281   return os::javaTimeNanos();
 282 JVM_END
 283 
 284 // The function below is actually exposed by jdk.internal.misc.VM and not
 285 // java.lang.System, but we choose to keep it here so that it stays next
 286 // to JVM_CurrentTimeMillis and JVM_NanoTime
 287 
 288 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 289 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 290 
 291 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 292   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 293   jlong seconds;
 294   jlong nanos;
 295 
 296   os::javaTimeSystemUTC(seconds, nanos);
 297 
 298   // We&#39;re going to verify that the result can fit in a long.
 299   // For that we need the difference in seconds between &#39;seconds&#39;
 300   // and &#39;offset_secs&#39; to be such that:
 301   //     |seconds - offset_secs| &lt; (2^63/10^9)
 302   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 303   // which makes |seconds - offset_secs| &lt; 2^33
 304   // and we will prefer +/- 2^32 as the maximum acceptable diff
 305   // as 2^32 has a more natural feel than 2^33...
 306   //
 307   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 308   // sentinel value (-1) which the caller should take as an
 309   // exception value indicating that the offset given to us is
 310   // too far from range of the current time - leading to too big
 311   // a nano adjustment. The caller is expected to recover by
 312   // computing a more accurate offset and calling this method
 313   // again. (For the record 2^32 secs is ~136 years, so that
 314   // should rarely happen)
 315   //
 316   jlong diff = seconds - offset_secs;
 317   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 318      return -1; // sentinel value: the offset is too far off the target
 319   }
 320 
 321   // return the adjustment. If you compute a time by adding
 322   // this number of nanoseconds along with the number of seconds
 323   // in the offset you should get the current UTC time.
 324   return (diff * (jlong)1000000000) + nanos;
 325 JVM_END
 326 
 327 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 328                                jobject dst, jint dst_pos, jint length))
 329   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 330   // Check if we have null pointers
 331   if (src == NULL || dst == NULL) {
 332     THROW(vmSymbols::java_lang_NullPointerException());
 333   }
 334   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 335   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 336   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 337   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 338   // Do copy
 339   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 340 JVM_END
 341 
 342 
 343 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 344   JavaValue r(T_OBJECT);
 345   // public synchronized Object put(Object key, Object value);
 346   HandleMark hm(THREAD);
 347   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 348   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 349   JavaCalls::call_virtual(&amp;r,
 350                           props,
 351                           SystemDictionary::Properties_klass(),
 352                           vmSymbols::put_name(),
 353                           vmSymbols::object_object_object_signature(),
 354                           key_str,
 355                           value_str,
 356                           THREAD);
 357 }
 358 
 359 
 360 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 361 
 362 /*
 363  * Return all of the system properties in a Java String array with alternating
 364  * names and values from the jvm SystemProperty.
 365  * Which includes some internal and all commandline -D defined properties.
 366  */
 367 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 368   JVMWrapper(&quot;JVM_GetProperties&quot;);
 369   ResourceMark rm(THREAD);
 370   HandleMark hm(THREAD);
 371   int ndx = 0;
 372   int fixedCount = 2;
 373 
 374   SystemProperty* p = Arguments::system_properties();
 375   int count = Arguments::PropertyList_count(p);
 376 
 377   // Allocate result String array
 378   InstanceKlass* ik = SystemDictionary::String_klass();
 379   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 380   objArrayHandle result_h(THREAD, r);
 381 
 382   while (p != NULL) {
 383     const char * key = p-&gt;key();
 384     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 385         const char * value = p-&gt;value();
 386         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 387         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 388         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 389         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 390         ndx++;
 391     }
 392     p = p-&gt;next();
 393   }
 394 
 395   // Convert the -XX:MaxDirectMemorySize= command line flag
 396   // to the sun.nio.MaxDirectMemorySize property.
 397   // Do this after setting user properties to prevent people
 398   // from setting the value with a -D option, as requested.
 399   // Leave empty if not supplied
 400   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 401     char as_chars[256];
 402     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 403     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 404     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 405     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 406     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 407     ndx++;
 408   }
 409 
 410   // JVM monitoring and management support
 411   // Add the sun.management.compiler property for the compiler&#39;s name
 412   {
 413 #undef CSIZE
 414 #if defined(_LP64) || defined(_WIN64)
 415   #define CSIZE &quot;64-Bit &quot;
 416 #else
 417   #define CSIZE
 418 #endif // 64bit
 419 
 420 #ifdef TIERED
 421     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 422 #else
 423 #if defined(COMPILER1)
 424     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 425 #elif defined(COMPILER2)
 426     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 427 #elif INCLUDE_JVMCI
 428     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 429 #else
 430     const char* compiler_name = &quot;&quot;;
 431 #endif // compilers
 432 #endif // TIERED
 433 
 434     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 435         (Arguments::mode() != Arguments::_int)) {
 436       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 437       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 438       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 439       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 440       ndx++;
 441     }
 442   }
 443 
 444   return (jobjectArray) JNIHandles::make_local(env, result_h());
 445 JVM_END
 446 
 447 
 448 /*
 449  * Return the temporary directory that the VM uses for the attach
 450  * and perf data files.
 451  *
 452  * It is important that this directory is well-known and the
 453  * same for all VM instances. It cannot be affected by configuration
 454  * variables such as java.io.tmpdir.
 455  */
 456 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 457   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 458   HandleMark hm(THREAD);
 459   const char* temp_dir = os::get_temp_directory();
 460   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 461   return (jstring) JNIHandles::make_local(env, h());
 462 JVM_END
 463 
 464 
 465 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 466 
 467 extern volatile jint vm_created;
 468 
 469 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 470   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 471   EventShutdown event;
 472   if (event.should_commit()) {
 473     event.set_reason(&quot;Shutdown requested from Java&quot;);
 474     event.commit();
 475   }
 476 JVM_END
 477 
 478 
 479 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 480   before_exit(thread);
 481   vm_exit(code);
 482 JVM_END
 483 
 484 
 485 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 486   JVMWrapper(&quot;JVM_GC&quot;);
 487   if (!DisableExplicitGC) {
 488     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 489   }
 490 JVM_END
 491 
 492 
 493 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 494   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 495   return Universe::heap()-&gt;millis_since_last_gc();
 496 JVM_END
 497 
 498 
 499 static inline jlong convert_size_t_to_jlong(size_t val) {
 500   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 501   NOT_LP64 (return (jlong)val;)
 502   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 503 }
 504 
 505 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 506   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 507   size_t n = Universe::heap()-&gt;capacity();
 508   return convert_size_t_to_jlong(n);
 509 JVM_END
 510 
 511 
 512 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 513   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 514   size_t n = Universe::heap()-&gt;unused();
 515   return convert_size_t_to_jlong(n);
 516 JVM_END
 517 
 518 
 519 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 520   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 521   size_t n = Universe::heap()-&gt;max_capacity();
 522   return convert_size_t_to_jlong(n);
 523 JVM_END
 524 
 525 
 526 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 527   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 528   return os::active_processor_count();
 529 JVM_END
 530 
 531 
 532 
 533 // java.lang.Throwable //////////////////////////////////////////////////////
 534 
 535 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 536   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 537   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 538   java_lang_Throwable::fill_in_stack_trace(exception);
 539 JVM_END
 540 
 541 // java.lang.NullPointerException ///////////////////////////////////////////
 542 
 543 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 544   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 545 
 546   oop exc = JNIHandles::resolve_non_null(throwable);
 547 
 548   Method* method;
 549   int bci;
 550   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 551     return NULL;
 552   }
 553   if (method-&gt;is_native()) {
 554     return NULL;
 555   }
 556 
 557   stringStream ss;
 558   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 559   if (ok) {
 560     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);
 561     return (jstring) JNIHandles::make_local(env, result);
 562   } else {
 563     return NULL;
 564   }
 565 JVM_END
 566 
 567 // java.lang.StackTraceElement //////////////////////////////////////////////
 568 
 569 
 570 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 571   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 572   Handle exception(THREAD, JNIHandles::resolve(throwable));
 573   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 574   objArrayHandle stack_trace(THREAD, st);
 575   // Fill in the allocated stack trace
 576   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 577 JVM_END
 578 
 579 
 580 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 581   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 582   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 583   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 584   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 585 JVM_END
 586 
 587 
 588 // java.lang.StackWalker //////////////////////////////////////////////////////
 589 
 590 
 591 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 592                                      jint skip_frames, jint frame_count, jint start_index,
 593                                      jobjectArray frames))
 594   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 595   JavaThread* jt = (JavaThread*) THREAD;
 596   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 597     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 598   }
 599 
 600   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 601 
 602   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 603   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 604   // be null.
 605   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 606   objArrayHandle frames_array_h(THREAD, fa);
 607 
 608   int limit = start_index + frame_count;
 609   if (frames_array_h-&gt;length() &lt; limit) {
 610     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 611   }
 612 
 613   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 614                                start_index, frames_array_h, CHECK_NULL);
 615   return JNIHandles::make_local(env, result);
 616 JVM_END
 617 
 618 
 619 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 620                                   jint frame_count, jint start_index,
 621                                   jobjectArray frames))
 622   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 623   JavaThread* jt = (JavaThread*) THREAD;
 624 
 625   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 626   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 627   // be null.
 628   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 629   objArrayHandle frames_array_h(THREAD, fa);
 630 
 631   int limit = start_index+frame_count;
 632   if (frames_array_h-&gt;length() &lt; limit) {
 633     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 634   }
 635 
 636   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 637   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 638                                    start_index, frames_array_h, THREAD);
 639 JVM_END
 640 
 641 // java.lang.Object ///////////////////////////////////////////////
 642 
 643 
 644 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 645   JVMWrapper(&quot;JVM_IHashCode&quot;);
 646   // as implemented in the classic virtual machine; return 0 if object is NULL
 647   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 648 JVM_END
 649 
 650 
 651 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 652   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 653   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 654   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 655   if (JvmtiExport::should_post_monitor_wait()) {
 656     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 657 
 658     // The current thread already owns the monitor and it has not yet
 659     // been added to the wait queue so the current thread cannot be
 660     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 661     // event handler cannot accidentally consume an unpark() meant for
 662     // the ParkEvent associated with this ObjectMonitor.
 663   }
 664   ObjectSynchronizer::wait(obj, ms, CHECK);
 665 JVM_END
 666 
 667 
 668 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 669   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 670   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 671   ObjectSynchronizer::notify(obj, CHECK);
 672 JVM_END
 673 
 674 
 675 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 676   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 677   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 678   ObjectSynchronizer::notifyall(obj, CHECK);
 679 JVM_END
 680 
 681 
 682 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 683   JVMWrapper(&quot;JVM_Clone&quot;);
 684   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 685   Klass* klass = obj-&gt;klass();
 686   JvmtiVMObjectAllocEventCollector oam;
 687 
 688 #ifdef ASSERT
 689   // Just checking that the cloneable flag is set correct
 690   if (obj-&gt;is_array()) {
 691     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 692   } else {
 693     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 694     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 695     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 696   }
 697 #endif
 698 
 699   // Check if class of obj supports the Cloneable interface.
 700   // All arrays are considered to be cloneable (See JLS 20.1.5).
 701   // All j.l.r.Reference classes are considered non-cloneable.
 702   if (!klass-&gt;is_cloneable() ||
 703       (klass-&gt;is_instance_klass() &amp;&amp;
 704        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 705     ResourceMark rm(THREAD);
 706     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 707   }
 708 
 709   // Make shallow object copy
 710   const int size = obj-&gt;size();
 711   oop new_obj_oop = NULL;
 712   if (obj-&gt;is_array()) {
 713     const int length = ((arrayOop)obj())-&gt;length();
 714     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 715                                                    /* do_zero */ true, CHECK_NULL);
 716   } else {
 717     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 718   }
 719 
 720   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 721 
 722   Handle new_obj(THREAD, new_obj_oop);
 723   // Caution: this involves a java upcall, so the clone should be
 724   // &quot;gc-robust&quot; by this stage.
 725   if (klass-&gt;has_finalizer()) {
 726     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 727     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 728     new_obj = Handle(THREAD, new_obj_oop);
 729   }
 730 
 731   return JNIHandles::make_local(env, new_obj());
 732 JVM_END
 733 
 734 // java.io.File ///////////////////////////////////////////////////////////////
 735 
 736 JVM_LEAF(char*, JVM_NativePath(char* path))
 737   JVMWrapper(&quot;JVM_NativePath&quot;);
 738   return os::native_path(path);
 739 JVM_END
 740 
 741 
 742 // Misc. class handling ///////////////////////////////////////////////////////////
 743 
 744 
 745 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 746   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 747 
 748   // Getting the class of the caller frame.
 749   //
 750   // The call stack at this point looks something like this:
 751   //
 752   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 753   // [1] [ @CallerSensitive API.method                                   ]
 754   // [.] [ (skipped intermediate frames)                                 ]
 755   // [n] [ caller                                                        ]
 756   vframeStream vfst(thread);
 757   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 758   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 759     Method* m = vfst.method();
 760     assert(m != NULL, &quot;sanity&quot;);
 761     switch (n) {
 762     case 0:
 763       // This must only be called from Reflection.getCallerClass
 764       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 765         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 766       }
 767       // fall-through
 768     case 1:
 769       // Frame 0 and 1 must be caller sensitive.
 770       if (!m-&gt;caller_sensitive()) {
 771         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 772       }
 773       break;
 774     default:
 775       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 776         // We have reached the desired frame; return the holder class.
 777         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 778       }
 779       break;
 780     }
 781   }
 782   return NULL;
 783 JVM_END
 784 
 785 
 786 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 787   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 788   oop mirror = NULL;
 789   BasicType t = name2type(utf);
 790   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 791     mirror = Universe::java_mirror(t);
 792   }
 793   if (mirror == NULL) {
 794     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 795   } else {
 796     return (jclass) JNIHandles::make_local(env, mirror);
 797   }
 798 JVM_END
 799 
 800 
 801 // Returns a class loaded by the bootstrap class loader; or null
 802 // if not found.  ClassNotFoundException is not thrown.
 803 // FindClassFromBootLoader is exported to the launcher for windows.
 804 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 805                                               const char* name))
 806   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 807 
 808   // Java libraries should ensure that name is never null...
 809   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 810     // It&#39;s impossible to create this class;  the name cannot fit
 811     // into the constant pool.
 812     return NULL;
 813   }
 814 
 815   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 816   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 817   if (k == NULL) {
 818     return NULL;
 819   }
 820 
 821   if (log_is_enabled(Debug, class, resolve)) {
 822     trace_class_resolution(k);
 823   }
 824   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 825 JVM_END
 826 
 827 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 828 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 829                                           jboolean init, jobject loader,
 830                                           jclass caller))
 831   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 832   // Java libraries should ensure that name is never null...
 833   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 834     // It&#39;s impossible to create this class;  the name cannot fit
 835     // into the constant pool.
 836     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
 837   }
 838 
 839   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 840 
 841   oop loader_oop = JNIHandles::resolve(loader);
 842   oop from_class = JNIHandles::resolve(caller);
 843   oop protection_domain = NULL;
 844   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 845   // NPE. Put it in another way, the bootstrap class loader has all permission and
 846   // thus no checkPackageAccess equivalence in the VM class loader.
 847   // The caller is also passed as NULL by the java code if there is no security
 848   // manager to avoid the performance cost of getting the calling class.
 849   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 850     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 851   }
 852 
 853   Handle h_loader(THREAD, loader_oop);
 854   Handle h_prot(THREAD, protection_domain);
 855   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 856                                                h_prot, false, THREAD);
 857 
 858   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 859     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 860   }
 861   return result;
 862 JVM_END
 863 
 864 // Currently only called from the old verifier.
 865 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 866                                          jboolean init, jclass from))
 867   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 868   if (name == NULL) {
 869     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 870   }
 871   if ((int)strlen(name) &gt; Symbol::max_length()) {
 872     // It&#39;s impossible to create this class;  the name cannot fit
 873     // into the constant pool.
 874     Exceptions::fthrow(THREAD_AND_LOCATION,
 875                        vmSymbols::java_lang_NoClassDefFoundError(),
 876                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 877                        Symbol::max_length(),
 878                        name);
 879     return 0;
 880   }
 881   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 882   oop from_class_oop = JNIHandles::resolve(from);
 883   Klass* from_class = (from_class_oop == NULL)
 884                            ? (Klass*)NULL
 885                            : java_lang_Class::as_Klass(from_class_oop);
 886   oop class_loader = NULL;
 887   oop protection_domain = NULL;
 888   if (from_class != NULL) {
 889     class_loader = from_class-&gt;class_loader();
 890     protection_domain = from_class-&gt;protection_domain();
 891   }
 892   Handle h_loader(THREAD, class_loader);
 893   Handle h_prot  (THREAD, protection_domain);
 894   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 895                                                h_prot, true, thread);
 896 
 897   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 898     // this function is generally only used for class loading during verification.
 899     ResourceMark rm;
 900     oop from_mirror = JNIHandles::resolve_non_null(from);
 901     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 902     const char * from_name = from_class-&gt;external_name();
 903 
 904     oop mirror = JNIHandles::resolve_non_null(result);
 905     Klass* to_class = java_lang_Class::as_Klass(mirror);
 906     const char * to = to_class-&gt;external_name();
 907     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 908   }
 909 
 910   return result;
 911 JVM_END
 912 
 913 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 914   if (loader.is_null()) {
 915     return;
 916   }
 917 
 918   // check whether the current caller thread holds the lock or not.
 919   // If not, increment the corresponding counter
 920   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 921       ObjectSynchronizer::owner_self) {
 922     counter-&gt;inc();
 923   }
 924 }
 925 
 926 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 927 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 928                                       jobject loader, const jbyte *buf,
 929                                       jsize len, jobject pd, const char *source,
 930                                       TRAPS) {
 931   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 932 
 933   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 934   JavaThread* jt = (JavaThread*) THREAD;
 935 
 936   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 937                              ClassLoader::perf_define_appclass_selftime(),
 938                              ClassLoader::perf_define_appclasses(),
 939                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 940                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 941                              PerfClassTraceTime::DEFINE_CLASS);
 942 
 943   if (UsePerfData) {
 944     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 945   }
 946 
 947   // Since exceptions can be thrown, class initialization can take place
 948   // if name is NULL no check for class name in .class stream has to be made.
 949   TempNewSymbol class_name = NULL;
 950   if (name != NULL) {
 951     const int str_len = (int)strlen(name);
 952     if (str_len &gt; Symbol::max_length()) {
 953       // It&#39;s impossible to create this class;  the name cannot fit
 954       // into the constant pool.
 955       Exceptions::fthrow(THREAD_AND_LOCATION,
 956                          vmSymbols::java_lang_NoClassDefFoundError(),
 957                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 958                          Symbol::max_length(),
 959                          name);
 960       return 0;
 961     }
 962     class_name = SymbolTable::new_symbol(name, str_len);
 963   }
 964 
 965   ResourceMark rm(THREAD);
 966   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 967   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 968   if (UsePerfData) {
 969     is_lock_held_by_thread(class_loader,
 970                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 971                            THREAD);
 972   }
 973   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 974   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 975                                                    class_loader,
 976                                                    protection_domain,
 977                                                    &amp;st,
 978                                                    CHECK_NULL);
 979 
 980   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 981     trace_class_resolution(k);
 982   }
 983 
 984   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 985 }
 986 
 987 
 988 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
 989   JVMWrapper(&quot;JVM_DefineClass&quot;);
 990 
 991   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 992 JVM_END
 993 
 994 
 995 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
 996   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
 997 
 998   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
 999 JVM_END
1000 
1001 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1002   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1003   ResourceMark rm(THREAD);
1004 
1005   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1006   char* str = java_lang_String::as_utf8_string(h_name());
1007 
1008   // Sanity check, don&#39;t expect null
1009   if (str == NULL) return NULL;
1010 
1011   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1012   char* p = (char*)str;
1013   while (*p != &#39;\0&#39;) {
1014       if (*p == &#39;.&#39;) {
1015           *p = &#39;/&#39;;
1016       }
1017       p++;
1018   }
1019 
1020   const int str_len = (int)(p - str);
1021   if (str_len &gt; Symbol::max_length()) {
1022     // It&#39;s impossible to create this class;  the name cannot fit
1023     // into the constant pool.
1024     return NULL;
1025   }
1026   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1027 
1028   // Security Note:
1029   //   The Java level wrapper will perform the necessary security check allowing
1030   //   us to pass the NULL as the initiating class loader.
1031   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1032   if (UsePerfData) {
1033     is_lock_held_by_thread(h_loader,
1034                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1035                            THREAD);
1036   }
1037 
1038   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1039                                                               h_loader,
1040                                                               Handle(),
1041                                                               CHECK_NULL);
1042 #if INCLUDE_CDS
1043   if (k == NULL) {
1044     // If the class is not already loaded, try to see if it&#39;s in the shared
1045     // archive for the current classloader (h_loader).
1046     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1047   }
1048 #endif
1049   return (k == NULL) ? NULL :
1050             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1051 JVM_END
1052 
1053 // Module support //////////////////////////////////////////////////////////////////////////////
1054 
1055 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1056                                  jstring location, const char* const* packages, jsize num_packages))
1057   JVMWrapper(&quot;JVM_DefineModule&quot;);
1058   Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);
1059 JVM_END
1060 
1061 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1062   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1063   Modules::set_bootloader_unnamed_module(module, CHECK);
1064 JVM_END
1065 
1066 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))
1067   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1068   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1069 JVM_END
1070 
1071 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))
1072   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1073   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1074 JVM_END
1075 
1076 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))
1077   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1078   Modules::add_module_exports(from_module, package, NULL, CHECK);
1079 JVM_END
1080 
1081 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1082   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1083   Modules::add_reads_module(from_module, source_module, CHECK);
1084 JVM_END
1085 
1086 // Reflection support //////////////////////////////////////////////////////////////////////////////
1087 
1088 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1089   assert (cls != NULL, &quot;illegal class&quot;);
1090   JVMWrapper(&quot;JVM_InitClassName&quot;);
1091   JvmtiVMObjectAllocEventCollector oam;
1092   ResourceMark rm(THREAD);
1093   HandleMark hm(THREAD);
1094   Handle java_class(THREAD, JNIHandles::resolve(cls));
1095   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1096   return (jstring) JNIHandles::make_local(env, result);
1097 JVM_END
1098 
1099 
1100 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1101   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1102   JvmtiVMObjectAllocEventCollector oam;
1103   oop mirror = JNIHandles::resolve_non_null(cls);
1104 
1105   // Special handling for primitive objects
1106   if (java_lang_Class::is_primitive(mirror)) {
1107     // Primitive objects does not have any interfaces
1108     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1109     return (jobjectArray) JNIHandles::make_local(env, r);
1110   }
1111 
1112   Klass* klass = java_lang_Class::as_Klass(mirror);
1113   // Figure size of result array
1114   int size;
1115   if (klass-&gt;is_instance_klass()) {
1116     size = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;length();
1117   } else {
1118     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1119     size = 2;
1120   }
1121 
1122   // Allocate result array
1123   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1124   objArrayHandle result (THREAD, r);
1125   // Fill in result
1126   if (klass-&gt;is_instance_klass()) {
1127     // Regular instance klass, fill in all local interfaces
1128     for (int index = 0; index &lt; size; index++) {
1129       Klass* k = InstanceKlass::cast(klass)-&gt;local_interfaces()-&gt;at(index);
1130       result-&gt;obj_at_put(index, k-&gt;java_mirror());
1131     }
1132   } else {
1133     // All arrays implement java.lang.Cloneable and java.io.Serializable
1134     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1135     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1136   }
1137   return (jobjectArray) JNIHandles::make_local(env, result());
1138 JVM_END
1139 
1140 
1141 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1142   JVMWrapper(&quot;JVM_IsInterface&quot;);
1143   oop mirror = JNIHandles::resolve_non_null(cls);
1144   if (java_lang_Class::is_primitive(mirror)) {
1145     return JNI_FALSE;
1146   }
1147   Klass* k = java_lang_Class::as_Klass(mirror);
1148   jboolean result = k-&gt;is_interface();
1149   assert(!result || k-&gt;is_instance_klass(),
1150          &quot;all interfaces are instance types&quot;);
1151   // The compiler intrinsic for isInterface tests the
1152   // Klass::_access_flags bits in the same way.
1153   return result;
1154 JVM_END
1155 
1156 
1157 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1158   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1159   JvmtiVMObjectAllocEventCollector oam;
1160   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1161     // There are no signers for primitive types
1162     return NULL;
1163   }
1164 
1165   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1166 
1167   // If there are no signers set in the class, or if the class
1168   // is an array, return NULL.
1169   if (signers == NULL) return NULL;
1170 
1171   // copy of the signers array
1172   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1173   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1174   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1175     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1176   }
1177 
1178   // return the copy
1179   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1180 JVM_END
1181 
1182 
1183 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1184   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1185   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1186     // This call is ignored for primitive types and arrays.
1187     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1188     // be called with an array.  Only the bootstrap loader creates arrays.
1189     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1190     if (k-&gt;is_instance_klass()) {
1191       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1192     }
1193   }
1194 JVM_END
1195 
1196 
1197 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1198   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1199   if (JNIHandles::resolve(cls) == NULL) {
1200     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1201   }
1202 
1203   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1204     // Primitive types does not have a protection domain.
1205     return NULL;
1206   }
1207 
1208   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1209   return (jobject) JNIHandles::make_local(env, pd);
1210 JVM_END
1211 
1212 
1213 // Returns the inherited_access_control_context field of the running thread.
1214 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1215   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1216   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1217   return JNIHandles::make_local(env, result);
1218 JVM_END
1219 
1220 class RegisterArrayForGC {
1221  private:
1222   JavaThread *_thread;
1223  public:
1224   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1225     _thread = thread;
1226     _thread-&gt;register_array_for_gc(array);
1227   }
1228 
1229   ~RegisterArrayForGC() {
1230     _thread-&gt;register_array_for_gc(NULL);
1231   }
1232 };
1233 
1234 
1235 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1236   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1237   if (!UsePrivilegedStack) return NULL;
1238 
1239   ResourceMark rm(THREAD);
1240   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1241   JvmtiVMObjectAllocEventCollector oam;
1242 
1243   // count the protection domains on the execution stack. We collapse
1244   // duplicate consecutive protection domains into a single one, as
1245   // well as stopping when we hit a privileged frame.
1246 
1247   oop previous_protection_domain = NULL;
1248   Handle privileged_context(thread, NULL);
1249   bool is_privileged = false;
1250   oop protection_domain = NULL;
1251 
1252   // Iterate through Java frames
1253   vframeStream vfst(thread);
1254   for(; !vfst.at_end(); vfst.next()) {
1255     // get method of frame
1256     Method* method = vfst.method();
1257 
1258     // stop at the first privileged frame
1259     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1260       method-&gt;name() == vmSymbols::executePrivileged_name())
1261     {
1262       // this frame is privileged
1263       is_privileged = true;
1264 
1265       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1266 
1267       StackValueCollection* locals = priv-&gt;locals();
1268       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1269       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1270       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1271       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1272       privileged_context    = ctx_sv-&gt;get_obj();
1273       Handle caller         = clr_sv-&gt;get_obj();
1274 
1275       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1276       protection_domain  = caller_klass-&gt;protection_domain();
1277     } else {
1278       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1279     }
1280 
1281     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1282       local_array-&gt;push(protection_domain);
1283       previous_protection_domain = protection_domain;
1284     }
1285 
1286     if (is_privileged) break;
1287   }
1288 
1289 
1290   // either all the domains on the stack were system domains, or
1291   // we had a privileged system domain
1292   if (local_array-&gt;is_empty()) {
1293     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1294 
1295     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1296     return JNIHandles::make_local(env, result);
1297   }
1298 
1299   // the resource area must be registered in case of a gc
1300   RegisterArrayForGC ragc(thread, local_array);
1301   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1302                                                  local_array-&gt;length(), CHECK_NULL);
1303   objArrayHandle h_context(thread, context);
1304   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1305     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1306   }
1307 
1308   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1309 
1310   return JNIHandles::make_local(env, result);
1311 JVM_END
1312 
1313 
1314 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1315   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1316   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1317   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1318 JVM_END
1319 
1320 
1321 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1322   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1323   oop mirror = JNIHandles::resolve_non_null(cls);
1324   return (jboolean) java_lang_Class::is_primitive(mirror);
1325 JVM_END
1326 
1327 
1328 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1329   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1330   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1331     // Primitive type
1332     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1333   }
1334 
1335   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1336   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1337   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1338   return k-&gt;modifier_flags();
1339 JVM_END
1340 
1341 
1342 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1343 
1344 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1345   JvmtiVMObjectAllocEventCollector oam;
1346   // ofClass is a reference to a java_lang_Class object. The mirror object
1347   // of an InstanceKlass
1348 
1349   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1350       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1351     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1352     return (jobjectArray)JNIHandles::make_local(env, result);
1353   }
1354 
1355   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1356   InnerClassesIterator iter(k);
1357 
1358   if (iter.length() == 0) {
1359     // Neither an inner nor outer class
1360     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1361     return (jobjectArray)JNIHandles::make_local(env, result);
1362   }
1363 
1364   // find inner class info
1365   constantPoolHandle cp(thread, k-&gt;constants());
1366   int length = iter.length();
1367 
1368   // Allocate temp. result array
1369   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1370   objArrayHandle result (THREAD, r);
1371   int members = 0;
1372 
1373   for (; !iter.done(); iter.next()) {
1374     int ioff = iter.inner_class_info_index();
1375     int ooff = iter.outer_class_info_index();
1376 
1377     if (ioff != 0 &amp;&amp; ooff != 0) {
1378       // Check to see if the name matches the class we&#39;re looking for
1379       // before attempting to find the class.
1380       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1381         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1382         if (outer_klass == k) {
1383            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1384            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1385 
1386            // Throws an exception if outer klass has not declared k as
1387            // an inner klass
1388            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1389 
1390            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1391            members++;
1392         }
1393       }
1394     }
1395   }
1396 
1397   if (members != length) {
1398     // Return array of right length
1399     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1400     for(int i = 0; i &lt; members; i++) {
1401       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1402     }
1403     return (jobjectArray)JNIHandles::make_local(env, res);
1404   }
1405 
1406   return (jobjectArray)JNIHandles::make_local(env, result());
1407 JVM_END
1408 
1409 
1410 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1411 {
1412   // ofClass is a reference to a java_lang_Class object.
1413   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1414       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1415     return NULL;
1416   }
1417 
1418   bool inner_is_member = false;
1419   Klass* outer_klass
1420     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1421                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1422   if (outer_klass == NULL)  return NULL;  // already a top-level class
1423   if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
1424   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1425 }
1426 JVM_END
1427 
1428 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1429 {
1430   oop mirror = JNIHandles::resolve_non_null(cls);
1431   if (java_lang_Class::is_primitive(mirror) ||
1432       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1433     return NULL;
1434   }
1435   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1436   int ooff = 0, noff = 0;
1437   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1438     if (noff != 0) {
1439       constantPoolHandle i_cp(thread, k-&gt;constants());
1440       Symbol* name = i_cp-&gt;symbol_at(noff);
1441       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1442       return (jstring) JNIHandles::make_local(env, str());
1443     }
1444   }
1445   return NULL;
1446 }
1447 JVM_END
1448 
1449 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1450   assert (cls != NULL, &quot;illegal class&quot;);
1451   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1452   JvmtiVMObjectAllocEventCollector oam;
1453   ResourceMark rm(THREAD);
1454   // Return null for arrays and primatives
1455   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1456     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1457     if (k-&gt;is_instance_klass()) {
1458       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1459       if (sym == NULL) return NULL;
1460       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1461       return (jstring) JNIHandles::make_local(env, str());
1462     }
1463   }
1464   return NULL;
1465 JVM_END
1466 
1467 
1468 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1469   assert (cls != NULL, &quot;illegal class&quot;);
1470   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1471 
1472   // Return null for arrays and primitives
1473   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1474     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1475     if (k-&gt;is_instance_klass()) {
1476       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1477       return (jbyteArray) JNIHandles::make_local(env, a);
1478     }
1479   }
1480   return NULL;
1481 JVM_END
1482 
1483 
1484 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1485   // some of this code was adapted from from jni_FromReflectedField
1486 
1487   oop reflected = JNIHandles::resolve_non_null(field);
1488   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1489   Klass* k    = java_lang_Class::as_Klass(mirror);
1490   int slot      = java_lang_reflect_Field::slot(reflected);
1491   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1492 
1493   InstanceKlass* ik = InstanceKlass::cast(k);
1494   intptr_t offset = ik-&gt;field_offset(slot);
1495 
1496   if (modifiers &amp; JVM_ACC_STATIC) {
1497     // for static fields we only look in the current class
1498     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1499       assert(false, &quot;cannot find static field&quot;);
1500       return false;
1501     }
1502   } else {
1503     // for instance fields we start with the current class and work
1504     // our way up through the superclass chain
1505     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1506       assert(false, &quot;cannot find instance field&quot;);
1507       return false;
1508     }
1509   }
1510   return true;
1511 }
1512 
1513 static Method* jvm_get_method_common(jobject method) {
1514   // some of this code was adapted from from jni_FromReflectedMethod
1515 
1516   oop reflected = JNIHandles::resolve_non_null(method);
1517   oop mirror    = NULL;
1518   int slot      = 0;
1519 
1520   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1521     mirror = java_lang_reflect_Constructor::clazz(reflected);
1522     slot   = java_lang_reflect_Constructor::slot(reflected);
1523   } else {
1524     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1525            &quot;wrong type&quot;);
1526     mirror = java_lang_reflect_Method::clazz(reflected);
1527     slot   = java_lang_reflect_Method::slot(reflected);
1528   }
1529   Klass* k = java_lang_Class::as_Klass(mirror);
1530 
1531   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1532   assert(m != NULL, &quot;cannot find method&quot;);
1533   return m;  // caller has to deal with NULL in product mode
1534 }
1535 
1536 /* Type use annotations support (JDK 1.8) */
1537 
1538 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1539   assert (cls != NULL, &quot;illegal class&quot;);
1540   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1541   ResourceMark rm(THREAD);
1542   // Return null for arrays and primitives
1543   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1544     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1545     if (k-&gt;is_instance_klass()) {
1546       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1547       if (type_annotations != NULL) {
1548         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1549         return (jbyteArray) JNIHandles::make_local(env, a);
1550       }
1551     }
1552   }
1553   return NULL;
1554 JVM_END
1555 
1556 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1557   assert (method != NULL, &quot;illegal method&quot;);
1558   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1559 
1560   // method is a handle to a java.lang.reflect.Method object
1561   Method* m = jvm_get_method_common(method);
1562   if (m == NULL) {
1563     return NULL;
1564   }
1565 
1566   AnnotationArray* type_annotations = m-&gt;type_annotations();
1567   if (type_annotations != NULL) {
1568     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1569     return (jbyteArray) JNIHandles::make_local(env, a);
1570   }
1571 
1572   return NULL;
1573 JVM_END
1574 
1575 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1576   assert (field != NULL, &quot;illegal field&quot;);
1577   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1578 
1579   fieldDescriptor fd;
1580   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1581   if (!gotFd) {
1582     return NULL;
1583   }
1584 
1585   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1586 JVM_END
1587 
1588 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1589   if (!cp-&gt;is_within_bounds(index)) {
1590     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1591   }
1592 }
1593 
1594 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1595 {
1596   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1597   // method is a handle to a java.lang.reflect.Method object
1598   Method* method_ptr = jvm_get_method_common(method);
1599   methodHandle mh (THREAD, method_ptr);
1600   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1601   const int num_params = mh-&gt;method_parameters_length();
1602 
1603   if (num_params &lt; 0) {
1604     // A -1 return value from method_parameters_length means there is no
1605     // parameter data.  Return null to indicate this to the reflection
1606     // API.
1607     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1608     return (jobjectArray)NULL;
1609   } else {
1610     // Otherwise, we return something up to reflection, even if it is
1611     // a zero-length array.  Why?  Because in some cases this can
1612     // trigger a MalformedParametersException.
1613 
1614     // make sure all the symbols are properly formatted
1615     for (int i = 0; i &lt; num_params; i++) {
1616       MethodParametersElement* params = mh-&gt;method_parameters_start();
1617       int index = params[i].name_cp_index;
1618       constantPoolHandle cp(THREAD, mh-&gt;constants());
1619       bounds_check(cp, index, CHECK_NULL);
1620 
1621       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1622         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1623                     &quot;Wrong type at constant pool index&quot;);
1624       }
1625 
1626     }
1627 
1628     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1629     objArrayHandle result (THREAD, result_oop);
1630 
1631     for (int i = 0; i &lt; num_params; i++) {
1632       MethodParametersElement* params = mh-&gt;method_parameters_start();
1633       // For a 0 index, give a NULL symbol
1634       Symbol* sym = 0 != params[i].name_cp_index ?
1635         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1636       int flags = params[i].flags;
1637       oop param = Reflection::new_parameter(reflected_method, i, sym,
1638                                             flags, CHECK_NULL);
1639       result-&gt;obj_at_put(i, param);
1640     }
1641     return (jobjectArray)JNIHandles::make_local(env, result());
1642   }
1643 }
1644 JVM_END
1645 
1646 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1647 
1648 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1649 {
1650   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1651   JvmtiVMObjectAllocEventCollector oam;
1652 
1653   // Exclude primitive types and array types
1654   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1655       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1656     // Return empty array
1657     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1658     return (jobjectArray) JNIHandles::make_local(env, res);
1659   }
1660 
1661   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1662   constantPoolHandle cp(THREAD, k-&gt;constants());
1663 
1664   // Ensure class is linked
1665   k-&gt;link_class(CHECK_NULL);
1666 
1667   // Allocate result
1668   int num_fields;
1669 
1670   if (publicOnly) {
1671     num_fields = 0;
1672     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1673       if (fs.access_flags().is_public()) ++num_fields;
1674     }
1675   } else {
1676     num_fields = k-&gt;java_fields_count();
1677   }
1678 
1679   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1680   objArrayHandle result (THREAD, r);
1681 
1682   int out_idx = 0;
1683   fieldDescriptor fd;
1684   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1685     if (!publicOnly || fs.access_flags().is_public()) {
1686       fd.reinitialize(k, fs.index());
1687       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1688       result-&gt;obj_at_put(out_idx, field);
1689       ++out_idx;
1690     }
1691   }
1692   assert(out_idx == num_fields, &quot;just checking&quot;);
1693   return (jobjectArray) JNIHandles::make_local(env, result());
1694 }
1695 JVM_END
1696 
1697 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1698 {
1699   JVMWrapper(&quot;JVM_IsRecord&quot;);
1700   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1701   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1702     InstanceKlass* ik = InstanceKlass::cast(k);
1703     return ik-&gt;is_record();
1704   } else {
1705     return false;
1706   }
1707 }
1708 JVM_END
1709 
1710 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1711 {
1712   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1713   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1714   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1715   InstanceKlass* ik = InstanceKlass::cast(c);
1716 
1717   if (ik-&gt;is_record()) {
1718     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1719     assert(components != NULL, &quot;components should not be NULL&quot;);
1720     {
1721       JvmtiVMObjectAllocEventCollector oam;
1722       constantPoolHandle cp(THREAD, ik-&gt;constants());
1723       int length = components-&gt;length();
1724       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1725       objArrayOop record_components =
1726         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1727       objArrayHandle components_h (THREAD, record_components);
1728 
1729       for (int x = 0; x &lt; length; x++) {
1730         RecordComponent* component = components-&gt;at(x);
1731         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1732         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1733         components_h-&gt;obj_at_put(x, component_oop);
1734       }
1735       return (jobjectArray)JNIHandles::make_local(components_h());
1736     }
1737   }
1738 
1739   // Return empty array if ofClass is not a record.
1740   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1741   return (jobjectArray)JNIHandles::make_local(env, result);
1742 }
1743 JVM_END
1744 
1745 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1746   if (want_constructor) {
1747     return (method-&gt;is_initializer() &amp;&amp; !method-&gt;is_static());
1748   } else {
1749     return  (!method-&gt;is_initializer() &amp;&amp; !method-&gt;is_overpass());
1750   }
1751 }
1752 
1753 static jobjectArray get_class_declared_methods_helper(
1754                                   JNIEnv *env,
1755                                   jclass ofClass, jboolean publicOnly,
1756                                   bool want_constructor,
1757                                   Klass* klass, TRAPS) {
1758 
1759   JvmtiVMObjectAllocEventCollector oam;
1760 
1761   // Exclude primitive types and array types
1762   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1763       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1764     // Return empty array
1765     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1766     return (jobjectArray) JNIHandles::make_local(env, res);
1767   }
1768 
1769   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1770 
1771   // Ensure class is linked
1772   k-&gt;link_class(CHECK_NULL);
1773 
1774   Array&lt;Method*&gt;* methods = k-&gt;methods();
1775   int methods_length = methods-&gt;length();
1776 
1777   // Save original method_idnum in case of redefinition, which can change
1778   // the idnum of obsolete methods.  The new method will have the same idnum
1779   // but if we refresh the methods array, the counts will be wrong.
1780   ResourceMark rm(THREAD);
1781   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1782   int num_methods = 0;
1783 
1784   for (int i = 0; i &lt; methods_length; i++) {
1785     methodHandle method(THREAD, methods-&gt;at(i));
1786     if (select_method(method, want_constructor)) {
1787       if (!publicOnly || method-&gt;is_public()) {
1788         idnums-&gt;push(method-&gt;method_idnum());
1789         ++num_methods;
1790       }
1791     }
1792   }
1793 
1794   // Allocate result
1795   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1796   objArrayHandle result (THREAD, r);
1797 
1798   // Now just put the methods that we selected above, but go by their idnum
1799   // in case of redefinition.  The methods can be redefined at any safepoint,
1800   // so above when allocating the oop array and below when creating reflect
1801   // objects.
1802   for (int i = 0; i &lt; num_methods; i++) {
1803     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1804     if (method.is_null()) {
1805       // Method may have been deleted and seems this API can handle null
1806       // Otherwise should probably put a method that throws NSME
1807       result-&gt;obj_at_put(i, NULL);
1808     } else {
1809       oop m;
1810       if (want_constructor) {
1811         m = Reflection::new_constructor(method, CHECK_NULL);
1812       } else {
1813         m = Reflection::new_method(method, false, CHECK_NULL);
1814       }
1815       result-&gt;obj_at_put(i, m);
1816     }
1817   }
1818 
1819   return (jobjectArray) JNIHandles::make_local(env, result());
1820 }
1821 
1822 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1823 {
1824   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1825   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1826                                            /*want_constructor*/ false,
1827                                            SystemDictionary::reflect_Method_klass(), THREAD);
1828 }
1829 JVM_END
1830 
1831 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1832 {
1833   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
1834   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1835                                            /*want_constructor*/ true,
1836                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
1837 }
1838 JVM_END
1839 
1840 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
1841 {
1842   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
1843   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1844     // Primitive type
1845     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1846   }
1847 
1848   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1849   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
1850 }
1851 JVM_END
1852 
1853 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
1854 {
1855   JVMWrapper(&quot;JVM_AreNestMates&quot;);
1856   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1857   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1858   InstanceKlass* ck = InstanceKlass::cast(c);
1859   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
1860   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
1861   InstanceKlass* mk = InstanceKlass::cast(m);
1862   return ck-&gt;has_nestmate_access_to(mk, THREAD);
1863 }
1864 JVM_END
1865 
1866 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
1867 {
1868   // current is not a primitive or array class
1869   JVMWrapper(&quot;JVM_GetNestHost&quot;);
1870   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1871   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1872   InstanceKlass* ck = InstanceKlass::cast(c);
1873   // Don&#39;t post exceptions if validation fails
1874   InstanceKlass* host = ck-&gt;nest_host(NULL, THREAD);
1875   return (jclass) (host == NULL ? NULL :
1876                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
1877 }
1878 JVM_END
1879 
1880 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
1881 {
1882   // current is not a primitive or array class
1883   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
1884   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
1885   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1886   InstanceKlass* ck = InstanceKlass::cast(c);
1887   // Get the nest host for this nest - throw ICCE if validation fails
1888   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
1889   InstanceKlass* host = ck-&gt;nest_host(icce, CHECK_NULL);
1890 
1891   {
1892     JvmtiVMObjectAllocEventCollector oam;
1893     Array&lt;u2&gt;* members = host-&gt;nest_members();
1894     int length = members == NULL ? 0 : members-&gt;length();
1895     // nest host is first in the array so make it one bigger
1896     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
1897                                              length + 1, CHECK_NULL);
1898     objArrayHandle result (THREAD, r);
1899     result-&gt;obj_at_put(0, host-&gt;java_mirror());
1900     if (length != 0) {
1901       int i;
1902       for (i = 0; i &lt; length; i++) {
1903          int cp_index = members-&gt;at(i);
1904          Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, CHECK_NULL);
1905          if (k-&gt;is_instance_klass()) {
1906            InstanceKlass* nest_host_k =
1907              InstanceKlass::cast(k)-&gt;nest_host(icce, CHECK_NULL);
1908            if (nest_host_k == host) {
1909              result-&gt;obj_at_put(i+1, k-&gt;java_mirror());
1910            }
1911            else {
1912              // k&#39;s nest host is legal but it isn&#39;t our host so
1913              // throw ICCE
1914              ResourceMark rm(THREAD);
1915              Exceptions::fthrow(THREAD_AND_LOCATION,
1916                                 icce,
1917                                 &quot;Nest member %s in %s declares a different nest host of %s&quot;,
1918                                 k-&gt;external_name(),
1919                                 host-&gt;external_name(),
1920                                 nest_host_k-&gt;external_name()
1921                            );
1922              return NULL;
1923            }
1924          }
1925          else {
1926            // we have a bad nest member entry - throw ICCE
1927            ResourceMark rm(THREAD);
1928            Exceptions::fthrow(THREAD_AND_LOCATION,
1929                               icce,
1930                               &quot;Class %s can not be a nest member of %s&quot;,
1931                               k-&gt;external_name(),
1932                               host-&gt;external_name()
1933                               );
1934            return NULL;
1935          }
1936       }
1937     }
1938     else {
1939       assert(host == ck, &quot;must be singleton nest&quot;);
1940     }
1941     return (jobjectArray)JNIHandles::make_local(THREAD, result());
1942   }
1943 }
1944 JVM_END
1945 
1946 // Constant pool access //////////////////////////////////////////////////////////
1947 
1948 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
1949 {
1950   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
1951   JvmtiVMObjectAllocEventCollector oam;
1952 
1953   // Return null for primitives and arrays
1954   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1955     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1956     if (k-&gt;is_instance_klass()) {
1957       InstanceKlass* k_h = InstanceKlass::cast(k);
1958       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
1959       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
1960       return JNIHandles::make_local(jcp());
1961     }
1962   }
1963   return NULL;
1964 }
1965 JVM_END
1966 
1967 
1968 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
1969 {
1970   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
1971   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1972   return cp-&gt;length();
1973 }
1974 JVM_END
1975 
1976 
1977 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
1978 {
1979   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
1980   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1981   bounds_check(cp, index, CHECK_NULL);
1982   constantTag tag = cp-&gt;tag_at(index);
1983   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1984     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
1985   }
1986   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
1987   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
1988 }
1989 JVM_END
1990 
1991 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
1992 {
1993   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
1994   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
1995   bounds_check(cp, index, CHECK_NULL);
1996   constantTag tag = cp-&gt;tag_at(index);
1997   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
1998     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
1999   }
2000   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2001   if (k == NULL) return NULL;
2002   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2003 }
2004 JVM_END
2005 
2006 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2007   constantTag tag = cp-&gt;tag_at(index);
2008   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2009     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2010   }
2011   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2012   Klass* k_o;
2013   if (force_resolution) {
2014     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2015   } else {
2016     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2017     if (k_o == NULL) return NULL;
2018   }
2019   InstanceKlass* k = InstanceKlass::cast(k_o);
2020   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2021   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2022   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2023   if (m.is_null()) {
2024     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2025   }
2026   oop method;
2027   if (!m-&gt;is_initializer() || m-&gt;is_static()) {
2028     method = Reflection::new_method(m, true, CHECK_NULL);
2029   } else {
2030     method = Reflection::new_constructor(m, CHECK_NULL);
2031   }
2032   return JNIHandles::make_local(method);
2033 }
2034 
2035 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2036 {
2037   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2038   JvmtiVMObjectAllocEventCollector oam;
2039   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2040   bounds_check(cp, index, CHECK_NULL);
2041   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2042   return res;
2043 }
2044 JVM_END
2045 
2046 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2047 {
2048   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2049   JvmtiVMObjectAllocEventCollector oam;
2050   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2051   bounds_check(cp, index, CHECK_NULL);
2052   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2053   return res;
2054 }
2055 JVM_END
2056 
2057 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2058   constantTag tag = cp-&gt;tag_at(index);
2059   if (!tag.is_field()) {
2060     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2061   }
2062   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2063   Klass* k_o;
2064   if (force_resolution) {
2065     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2066   } else {
2067     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2068     if (k_o == NULL) return NULL;
2069   }
2070   InstanceKlass* k = InstanceKlass::cast(k_o);
2071   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2072   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2073   fieldDescriptor fd;
2074   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2075   if (target_klass == NULL) {
2076     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2077   }
2078   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2079   return JNIHandles::make_local(field);
2080 }
2081 
2082 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2083 {
2084   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2085   JvmtiVMObjectAllocEventCollector oam;
2086   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2087   bounds_check(cp, index, CHECK_NULL);
2088   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2089   return res;
2090 }
2091 JVM_END
2092 
2093 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2094 {
2095   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2096   JvmtiVMObjectAllocEventCollector oam;
2097   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2098   bounds_check(cp, index, CHECK_NULL);
2099   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2100   return res;
2101 }
2102 JVM_END
2103 
2104 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2105 {
2106   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2107   JvmtiVMObjectAllocEventCollector oam;
2108   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2109   bounds_check(cp, index, CHECK_NULL);
2110   constantTag tag = cp-&gt;tag_at(index);
2111   if (!tag.is_field_or_method()) {
2112     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2113   }
2114   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2115   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2116   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2117   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2118   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2119   objArrayHandle dest(THREAD, dest_o);
2120   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2121   dest-&gt;obj_at_put(0, str());
2122   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2123   dest-&gt;obj_at_put(1, str());
2124   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2125   dest-&gt;obj_at_put(2, str());
2126   return (jobjectArray) JNIHandles::make_local(dest());
2127 }
2128 JVM_END
2129 
2130 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2131 {
2132   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2133   JvmtiVMObjectAllocEventCollector oam;
2134   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2135   bounds_check(cp, index, CHECK_0);
2136   constantTag tag = cp-&gt;tag_at(index);
2137   if (!tag.is_field_or_method()) {
2138     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2139   }
2140   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2141 }
2142 JVM_END
2143 
2144 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2145 {
2146   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2147   JvmtiVMObjectAllocEventCollector oam;
2148   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2149   bounds_check(cp, index, CHECK_0);
2150   constantTag tag = cp-&gt;tag_at(index);
2151   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2152     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2153   }
2154   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2155 }
2156 JVM_END
2157 
2158 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2159 {
2160   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2161   JvmtiVMObjectAllocEventCollector oam;
2162   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2163   bounds_check(cp, index, CHECK_NULL);
2164   constantTag tag = cp-&gt;tag_at(index);
2165   if (!tag.is_name_and_type()) {
2166     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2167   }
2168   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2169   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2170   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2171   objArrayHandle dest(THREAD, dest_o);
2172   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2173   dest-&gt;obj_at_put(0, str());
2174   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2175   dest-&gt;obj_at_put(1, str());
2176   return (jobjectArray) JNIHandles::make_local(dest());
2177 }
2178 JVM_END
2179 
2180 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2181 {
2182   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2183   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2184   bounds_check(cp, index, CHECK_0);
2185   constantTag tag = cp-&gt;tag_at(index);
2186   if (!tag.is_int()) {
2187     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2188   }
2189   return cp-&gt;int_at(index);
2190 }
2191 JVM_END
2192 
2193 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2194 {
2195   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2196   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2197   bounds_check(cp, index, CHECK_(0L));
2198   constantTag tag = cp-&gt;tag_at(index);
2199   if (!tag.is_long()) {
2200     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2201   }
2202   return cp-&gt;long_at(index);
2203 }
2204 JVM_END
2205 
2206 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2207 {
2208   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2209   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2210   bounds_check(cp, index, CHECK_(0.0f));
2211   constantTag tag = cp-&gt;tag_at(index);
2212   if (!tag.is_float()) {
2213     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2214   }
2215   return cp-&gt;float_at(index);
2216 }
2217 JVM_END
2218 
2219 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2220 {
2221   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2222   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2223   bounds_check(cp, index, CHECK_(0.0));
2224   constantTag tag = cp-&gt;tag_at(index);
2225   if (!tag.is_double()) {
2226     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2227   }
2228   return cp-&gt;double_at(index);
2229 }
2230 JVM_END
2231 
2232 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2233 {
2234   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2235   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2236   bounds_check(cp, index, CHECK_NULL);
2237   constantTag tag = cp-&gt;tag_at(index);
2238   if (!tag.is_string()) {
2239     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2240   }
2241   oop str = cp-&gt;string_at(index, CHECK_NULL);
2242   return (jstring) JNIHandles::make_local(str);
2243 }
2244 JVM_END
2245 
2246 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2247 {
2248   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2249   JvmtiVMObjectAllocEventCollector oam;
2250   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2251   bounds_check(cp, index, CHECK_NULL);
2252   constantTag tag = cp-&gt;tag_at(index);
2253   if (!tag.is_symbol()) {
2254     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2255   }
2256   Symbol* sym = cp-&gt;symbol_at(index);
2257   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2258   return (jstring) JNIHandles::make_local(str());
2259 }
2260 JVM_END
2261 
2262 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2263 {
2264   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2265   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2266   bounds_check(cp, index, CHECK_0);
2267   constantTag tag = cp-&gt;tag_at(index);
2268   jbyte result = tag.value();
2269   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2270   // they are changed to the corresponding tags from the JVM spec, so that java code in
2271   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2272   if (tag.is_klass_or_reference()) {
2273       result = JVM_CONSTANT_Class;
2274   } else if (tag.is_string_index()) {
2275       result = JVM_CONSTANT_String;
2276   } else if (tag.is_method_type_in_error()) {
2277       result = JVM_CONSTANT_MethodType;
2278   } else if (tag.is_method_handle_in_error()) {
2279       result = JVM_CONSTANT_MethodHandle;
2280   } else if (tag.is_dynamic_constant_in_error()) {
2281       result = JVM_CONSTANT_Dynamic;
2282   }
2283   return result;
2284 }
2285 JVM_END
2286 
2287 // Assertion support. //////////////////////////////////////////////////////////
2288 
2289 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2290   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2291   assert(cls != NULL, &quot;bad class&quot;);
2292 
2293   oop r = JNIHandles::resolve(cls);
2294   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2295   if (java_lang_Class::is_primitive(r)) return false;
2296 
2297   Klass* k = java_lang_Class::as_Klass(r);
2298   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2299   if (!k-&gt;is_instance_klass()) return false;
2300 
2301   ResourceMark rm(THREAD);
2302   const char* name = k-&gt;name()-&gt;as_C_string();
2303   bool system_class = k-&gt;class_loader() == NULL;
2304   return JavaAssertions::enabled(name, system_class);
2305 
2306 JVM_END
2307 
2308 
2309 // Return a new AssertionStatusDirectives object with the fields filled in with
2310 // command-line assertion arguments (i.e., -ea, -da).
2311 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2312   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2313   JvmtiVMObjectAllocEventCollector oam;
2314   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2315   return JNIHandles::make_local(env, asd);
2316 JVM_END
2317 
2318 // Verification ////////////////////////////////////////////////////////////////////////////////
2319 
2320 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2321 
2322 // RedefineClasses support: bug 6214132 caused verification to fail.
2323 // All functions from this section should call the jvmtiThreadSate function:
2324 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2325 // The function returns a Klass* of the _scratch_class if the verifier
2326 // was invoked in the middle of the class redefinition.
2327 // Otherwise it returns its argument value which is the _the_class Klass*.
2328 // Please, refer to the description in the jvmtiThreadSate.hpp.
2329 
2330 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2331   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2332   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2333   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2334   return k-&gt;name()-&gt;as_utf8();
2335 JVM_END
2336 
2337 
2338 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2339   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2340   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2341   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2342   // types will have length zero if this is not an InstanceKlass
2343   // (length is determined by call to JVM_GetClassCPEntriesCount)
2344   if (k-&gt;is_instance_klass()) {
2345     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2346     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2347       constantTag tag = cp-&gt;tag_at(index);
2348       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2349     }
2350   }
2351 JVM_END
2352 
2353 
2354 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2355   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2356   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2357   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2358   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2359 JVM_END
2360 
2361 
2362 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2363   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2364   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2365   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2366   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2367 JVM_END
2368 
2369 
2370 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2371   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2372   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2373   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2374   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2375 JVM_END
2376 
2377 
2378 // The following methods, used for the verifier, are never called with
2379 // array klasses, so a direct cast to InstanceKlass is safe.
2380 // Typically, these methods are called in a loop with bounds determined
2381 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2382 // zero for arrays.
2383 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2384   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2385   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2386   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2387   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2388   int length = method-&gt;checked_exceptions_length();
2389   if (length &gt; 0) {
2390     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2391     for (int i = 0; i &lt; length; i++) {
2392       exceptions[i] = table[i].class_cp_index;
2393     }
2394   }
2395 JVM_END
2396 
2397 
2398 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2399   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2400   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2401   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2402   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2403   return method-&gt;checked_exceptions_length();
2404 JVM_END
2405 
2406 
2407 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2408   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2409   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2410   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2411   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2412   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2413 JVM_END
2414 
2415 
2416 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2417   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2418   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2419   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2420   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2421   return method-&gt;code_size();
2422 JVM_END
2423 
2424 
2425 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2426   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2427   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2428   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2429   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2430   ExceptionTable extable(method);
2431   entry-&gt;start_pc   = extable.start_pc(entry_index);
2432   entry-&gt;end_pc     = extable.end_pc(entry_index);
2433   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2434   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2435 JVM_END
2436 
2437 
2438 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2439   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2440   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2441   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2442   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2443   return method-&gt;exception_table_length();
2444 JVM_END
2445 
2446 
2447 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2448   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2449   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2450   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2451   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2452   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2453 JVM_END
2454 
2455 
2456 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2457   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2458   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2459   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2460   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2461 JVM_END
2462 
2463 
2464 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2465   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2466   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2467   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2468   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2469   return method-&gt;max_locals();
2470 JVM_END
2471 
2472 
2473 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2474   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2475   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2476   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2477   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2478   return method-&gt;size_of_parameters();
2479 JVM_END
2480 
2481 
2482 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2483   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2484   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2485   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2486   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2487   return method-&gt;verifier_max_stack();
2488 JVM_END
2489 
2490 
2491 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2492   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2493   ResourceMark rm(THREAD);
2494   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2495   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2496   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2497   return method-&gt;name() == vmSymbols::object_initializer_name();
2498 JVM_END
2499 
2500 
2501 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2502   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2503   ResourceMark rm(THREAD);
2504   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2505   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2506   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2507   return method-&gt;is_overpass();
2508 JVM_END
2509 
2510 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2511   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2512   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2513   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2514   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2515   return method-&gt;name()-&gt;as_utf8();
2516 JVM_END
2517 
2518 
2519 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2520   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2521   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2522   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2523   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2524   return method-&gt;signature()-&gt;as_utf8();
2525 JVM_END
2526 
2527 /**
2528  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2529  * read entries in the constant pool.  Since the old verifier always
2530  * works on a copy of the code, it will not see any rewriting that
2531  * may possibly occur in the middle of verification.  So it is important
2532  * that nothing it calls tries to use the cpCache instead of the raw
2533  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2534  */
2535 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2536   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2537   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2538   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2539   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2540   switch (cp-&gt;tag_at(cp_index).value()) {
2541     case JVM_CONSTANT_Fieldref:
2542       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2543     default:
2544       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2545   }
2546   ShouldNotReachHere();
2547   return NULL;
2548 JVM_END
2549 
2550 
2551 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2552   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2553   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2554   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2555   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2556   switch (cp-&gt;tag_at(cp_index).value()) {
2557     case JVM_CONSTANT_InterfaceMethodref:
2558     case JVM_CONSTANT_Methodref:
2559       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2560     default:
2561       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2562   }
2563   ShouldNotReachHere();
2564   return NULL;
2565 JVM_END
2566 
2567 
2568 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2569   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2570   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2571   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2572   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2573   switch (cp-&gt;tag_at(cp_index).value()) {
2574     case JVM_CONSTANT_InterfaceMethodref:
2575     case JVM_CONSTANT_Methodref:
2576       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2577     default:
2578       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2579   }
2580   ShouldNotReachHere();
2581   return NULL;
2582 JVM_END
2583 
2584 
2585 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2586   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2587   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2588   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2589   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2590   switch (cp-&gt;tag_at(cp_index).value()) {
2591     case JVM_CONSTANT_Fieldref:
2592       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2593     default:
2594       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2595   }
2596   ShouldNotReachHere();
2597   return NULL;
2598 JVM_END
2599 
2600 
2601 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2602   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2603   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2604   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2605   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2606   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2607   return classname-&gt;as_utf8();
2608 JVM_END
2609 
2610 
2611 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2612   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2613   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2614   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2615   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2616   switch (cp-&gt;tag_at(cp_index).value()) {
2617     case JVM_CONSTANT_Fieldref: {
2618       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2619       Symbol* classname = cp-&gt;klass_name_at(class_index);
2620       return classname-&gt;as_utf8();
2621     }
2622     default:
2623       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2624   }
2625   ShouldNotReachHere();
2626   return NULL;
2627 JVM_END
2628 
2629 
2630 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2631   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2632   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2633   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2634   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2635   switch (cp-&gt;tag_at(cp_index).value()) {
2636     case JVM_CONSTANT_Methodref:
2637     case JVM_CONSTANT_InterfaceMethodref: {
2638       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2639       Symbol* classname = cp-&gt;klass_name_at(class_index);
2640       return classname-&gt;as_utf8();
2641     }
2642     default:
2643       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2644   }
2645   ShouldNotReachHere();
2646   return NULL;
2647 JVM_END
2648 
2649 
2650 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2651   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2652   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2653   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2654   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2655   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2656   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2657   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2658   switch (cp-&gt;tag_at(cp_index).value()) {
2659     case JVM_CONSTANT_Fieldref: {
2660       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2661       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2662       InstanceKlass* ik = InstanceKlass::cast(k_called);
2663       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2664         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2665           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2666         }
2667       }
2668       return -1;
2669     }
2670     default:
2671       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2672   }
2673   ShouldNotReachHere();
2674   return 0;
2675 JVM_END
2676 
2677 
2678 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2679   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2680   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2681   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2682   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2683   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2684   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2685   switch (cp-&gt;tag_at(cp_index).value()) {
2686     case JVM_CONSTANT_Methodref:
2687     case JVM_CONSTANT_InterfaceMethodref: {
2688       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2689       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2690       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2691       int methods_count = methods-&gt;length();
2692       for (int i = 0; i &lt; methods_count; i++) {
2693         Method* method = methods-&gt;at(i);
2694         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2695             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2696         }
2697       }
2698       return -1;
2699     }
2700     default:
2701       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2702   }
2703   ShouldNotReachHere();
2704   return 0;
2705 JVM_END
2706 
2707 
2708 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2709 
2710 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2711   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2712 JVM_END
2713 
2714 
2715 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2716   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2717   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2718   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2719   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2720   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2721   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2722 JVM_END
2723 
2724 // Printing support //////////////////////////////////////////////////
2725 extern &quot;C&quot; {
2726 
2727 ATTRIBUTE_PRINTF(3, 0)
2728 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2729   // Reject count values that are negative signed values converted to
2730   // unsigned; see bug 4399518, 4417214
2731   if ((intptr_t)count &lt;= 0) return -1;
2732 
2733   int result = os::vsnprintf(str, count, fmt, args);
2734   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2735     result = -1;
2736   }
2737 
2738   return result;
2739 }
2740 
2741 ATTRIBUTE_PRINTF(3, 4)
2742 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2743   va_list args;
2744   int len;
2745   va_start(args, fmt);
2746   len = jio_vsnprintf(str, count, fmt, args);
2747   va_end(args);
2748   return len;
2749 }
2750 
2751 ATTRIBUTE_PRINTF(2, 3)
2752 int jio_fprintf(FILE* f, const char *fmt, ...) {
2753   int len;
2754   va_list args;
2755   va_start(args, fmt);
2756   len = jio_vfprintf(f, fmt, args);
2757   va_end(args);
2758   return len;
2759 }
2760 
2761 ATTRIBUTE_PRINTF(2, 0)
2762 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
2763   if (Arguments::vfprintf_hook() != NULL) {
2764      return Arguments::vfprintf_hook()(f, fmt, args);
2765   } else {
2766     return vfprintf(f, fmt, args);
2767   }
2768 }
2769 
2770 ATTRIBUTE_PRINTF(1, 2)
2771 JNIEXPORT int jio_printf(const char *fmt, ...) {
2772   int len;
2773   va_list args;
2774   va_start(args, fmt);
2775   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
2776   va_end(args);
2777   return len;
2778 }
2779 
2780 // HotSpot specific jio method
2781 void jio_print(const char* s, size_t len) {
2782   // Try to make this function as atomic as possible.
2783   if (Arguments::vfprintf_hook() != NULL) {
2784     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
2785   } else {
2786     // Make an unused local variable to avoid warning from gcc compiler.
2787     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
2788   }
2789 }
2790 
2791 } // Extern C
2792 
2793 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
2794 
2795 // In most of the JVM thread support functions we need to access the
2796 // thread through a ThreadsListHandle to prevent it from exiting and
2797 // being reclaimed while we try to operate on it. The exceptions to this
2798 // rule are when operating on the current thread, or if the monitor of
2799 // the target java.lang.Thread is locked at the Java level - in both
2800 // cases the target cannot exit.
2801 
2802 static void thread_entry(JavaThread* thread, TRAPS) {
2803   HandleMark hm(THREAD);
2804   Handle obj(THREAD, thread-&gt;threadObj());
2805   JavaValue result(T_VOID);
2806   JavaCalls::call_virtual(&amp;result,
2807                           obj,
2808                           SystemDictionary::Thread_klass(),
2809                           vmSymbols::run_method_name(),
2810                           vmSymbols::void_method_signature(),
2811                           THREAD);
2812 }
2813 
2814 
2815 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
2816   JVMWrapper(&quot;JVM_StartThread&quot;);
2817   JavaThread *native_thread = NULL;
2818 
2819   // We cannot hold the Threads_lock when we throw an exception,
2820   // due to rank ordering issues. Example:  we might need to grab the
2821   // Heap_lock while we construct the exception.
2822   bool throw_illegal_thread_state = false;
2823 
2824   // We must release the Threads_lock before we can post a jvmti event
2825   // in Thread::start.
2826   {
2827     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
2828     // we operate.
2829     MutexLocker mu(Threads_lock);
2830 
2831     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
2832     // re-starting an already started thread, so we should usually find
2833     // that the JavaThread is null. However for a JNI attached thread
2834     // there is a small window between the Thread object being created
2835     // (with its JavaThread set) and the update to its threadStatus, so we
2836     // have to check for this
2837     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
2838       throw_illegal_thread_state = true;
2839     } else {
2840       // We could also check the stillborn flag to see if this thread was already stopped, but
2841       // for historical reasons we let the thread detect that itself when it starts running
2842 
2843       jlong size =
2844              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
2845       // Allocate the C++ Thread structure and create the native thread.  The
2846       // stack size retrieved from java is 64-bit signed, but the constructor takes
2847       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
2848       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
2849       //  - Avoid passing negative values which would result in really large stacks.
2850       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
2851       size_t sz = size &gt; 0 ? (size_t) size : 0;
2852       native_thread = new JavaThread(&amp;thread_entry, sz);
2853 
2854       // At this point it may be possible that no osthread was created for the
2855       // JavaThread due to lack of memory. Check for this situation and throw
2856       // an exception if necessary. Eventually we may want to change this so
2857       // that we only grab the lock if the thread was created successfully -
2858       // then we can also do this check and throw the exception in the
2859       // JavaThread constructor.
2860       if (native_thread-&gt;osthread() != NULL) {
2861         // Note: the current thread is not being used within &quot;prepare&quot;.
2862         native_thread-&gt;prepare(jthread);
2863       }
2864     }
2865   }
2866 
2867   if (throw_illegal_thread_state) {
2868     THROW(vmSymbols::java_lang_IllegalThreadStateException());
2869   }
2870 
2871   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
2872 
2873   if (native_thread-&gt;osthread() == NULL) {
2874     // No one should hold a reference to the &#39;native_thread&#39;.
2875     native_thread-&gt;smr_delete();
2876     if (JvmtiExport::should_post_resource_exhausted()) {
2877       JvmtiExport::post_resource_exhausted(
2878         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
2879         os::native_thread_creation_failed_msg());
2880     }
2881     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
2882               os::native_thread_creation_failed_msg());
2883   }
2884 
2885   Thread::start(native_thread);
2886 
2887 JVM_END
2888 
2889 
2890 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
2891 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
2892 // but is thought to be reliable and simple. In the case, where the receiver is the
2893 // same thread as the sender, no VM_Operation is needed.
2894 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
2895   JVMWrapper(&quot;JVM_StopThread&quot;);
2896 
2897   // A nested ThreadsListHandle will grab the Threads_lock so create
2898   // tlh before we resolve throwable.
2899   ThreadsListHandle tlh(thread);
2900   oop java_throwable = JNIHandles::resolve(throwable);
2901   if (java_throwable == NULL) {
2902     THROW(vmSymbols::java_lang_NullPointerException());
2903   }
2904   oop java_thread = NULL;
2905   JavaThread* receiver = NULL;
2906   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
2907   Events::log_exception(thread,
2908                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
2909                         p2i(receiver), p2i(java_thread), p2i(throwable));
2910 
2911   if (is_alive) {
2912     // jthread refers to a live JavaThread.
2913     if (thread == receiver) {
2914       // Exception is getting thrown at self so no VM_Operation needed.
2915       THROW_OOP(java_throwable);
2916     } else {
2917       // Use a VM_Operation to throw the exception.
2918       Thread::send_async_exception(java_thread, java_throwable);
2919     }
2920   } else {
2921     // Either:
2922     // - target thread has not been started before being stopped, or
2923     // - target thread already terminated
2924     // We could read the threadStatus to determine which case it is
2925     // but that is overkill as it doesn&#39;t matter. We must set the
2926     // stillborn flag for the first case, and if the thread has already
2927     // exited setting this flag has no effect.
2928     java_lang_Thread::set_stillborn(java_thread);
2929   }
2930 JVM_END
2931 
2932 
2933 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
2934   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
2935 
2936   oop thread_oop = JNIHandles::resolve_non_null(jthread);
2937   return java_lang_Thread::is_alive(thread_oop);
2938 JVM_END
2939 
2940 
2941 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
2942   JVMWrapper(&quot;JVM_SuspendThread&quot;);
2943 
2944   ThreadsListHandle tlh(thread);
2945   JavaThread* receiver = NULL;
2946   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2947   if (is_alive) {
2948     // jthread refers to a live JavaThread.
2949     {
2950       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
2951       if (receiver-&gt;is_external_suspend()) {
2952         // Don&#39;t allow nested external suspend requests. We can&#39;t return
2953         // an error from this interface so just ignore the problem.
2954         return;
2955       }
2956       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
2957         return;
2958       }
2959       receiver-&gt;set_external_suspend();
2960     }
2961 
2962     // java_suspend() will catch threads in the process of exiting
2963     // and will ignore them.
2964     receiver-&gt;java_suspend();
2965 
2966     // It would be nice to have the following assertion in all the
2967     // time, but it is possible for a racing resume request to have
2968     // resumed this thread right after we suspended it. Temporarily
2969     // enable this assertion if you are chasing a different kind of
2970     // bug.
2971     //
2972     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
2973     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
2974   }
2975 JVM_END
2976 
2977 
2978 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
2979   JVMWrapper(&quot;JVM_ResumeThread&quot;);
2980 
2981   ThreadsListHandle tlh(thread);
2982   JavaThread* receiver = NULL;
2983   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
2984   if (is_alive) {
2985     // jthread refers to a live JavaThread.
2986 
2987     // This is the original comment for this Threads_lock grab:
2988     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
2989     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
2990     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
2991     //   looks at it.
2992     //
2993     // The above comment dates back to when we had both internal and
2994     // external suspend APIs that shared a common underlying mechanism.
2995     // External suspend is now entirely cooperative and doesn&#39;t share
2996     // anything with internal suspend. That said, there are some
2997     // assumptions in the VM that an external resume grabs the
2998     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
2999     // resolve the assumptions that exist elsewhere.
3000     //
3001     MutexLocker ml(Threads_lock);
3002     receiver-&gt;java_resume();
3003   }
3004 JVM_END
3005 
3006 
3007 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3008   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3009 
3010   ThreadsListHandle tlh(thread);
3011   oop java_thread = NULL;
3012   JavaThread* receiver = NULL;
3013   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3014   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3015 
3016   if (is_alive) {
3017     // jthread refers to a live JavaThread.
3018     Thread::set_priority(receiver, (ThreadPriority)prio);
3019   }
3020   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3021   // priority set in the java.lang.Thread object above will be pushed
3022   // down when it does start.
3023 JVM_END
3024 
3025 
3026 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3027   JVMWrapper(&quot;JVM_Yield&quot;);
3028   if (os::dont_yield()) return;
3029   HOTSPOT_THREAD_YIELD();
3030   os::naked_yield();
3031 JVM_END
3032 
3033 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3034   assert(event != NULL, &quot;invariant&quot;);
3035   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3036   event-&gt;set_time(millis);
3037   event-&gt;commit();
3038 }
3039 
3040 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3041   JVMWrapper(&quot;JVM_Sleep&quot;);
3042 
3043   if (millis &lt; 0) {
3044     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3045   }
3046 
3047   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3048     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3049   }
3050 
3051   // Save current thread state and restore it at the end of this block.
3052   // And set new thread state to SLEEPING.
3053   JavaThreadSleepState jtss(thread);
3054 
3055   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3056   EventThreadSleep event;
3057 
3058   if (millis == 0) {
3059     os::naked_yield();
3060   } else {
3061     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3062     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3063     if (!thread-&gt;sleep(millis)) { // interrupted
3064       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3065       // us while we were sleeping. We do not overwrite those.
3066       if (!HAS_PENDING_EXCEPTION) {
3067         if (event.should_commit()) {
3068           post_thread_sleep_event(&amp;event, millis);
3069         }
3070         HOTSPOT_THREAD_SLEEP_END(1);
3071 
3072         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3073         // to properly restore the thread state.  That&#39;s likely wrong.
3074         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3075       }
3076     }
3077     thread-&gt;osthread()-&gt;set_state(old_state);
3078   }
3079   if (event.should_commit()) {
3080     post_thread_sleep_event(&amp;event, millis);
3081   }
3082   HOTSPOT_THREAD_SLEEP_END(0);
3083 JVM_END
3084 
3085 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3086   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3087   oop jthread = thread-&gt;threadObj();
3088   assert (thread != NULL, &quot;no current thread!&quot;);
3089   return JNIHandles::make_local(env, jthread);
3090 JVM_END
3091 
3092 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3093   JVMWrapper(&quot;JVM_Interrupt&quot;);
3094 
3095   ThreadsListHandle tlh(thread);
3096   JavaThread* receiver = NULL;
3097   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3098   if (is_alive) {
3099     // jthread refers to a live JavaThread.
3100     receiver-&gt;interrupt();
3101   }
3102 JVM_END
3103 
3104 
3105 // Return true iff the current thread has locked the object passed in
3106 
3107 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3108   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3109   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3110   if (obj == NULL) {
3111     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3112   }
3113   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3114   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3115 JVM_END
3116 
3117 
3118 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3119   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3120   VM_PrintThreads op;
3121   VMThread::execute(&amp;op);
3122   if (JvmtiExport::should_post_data_dump()) {
3123     JvmtiExport::post_data_dump();
3124   }
3125 JVM_END
3126 
3127 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3128   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3129 
3130   // We don&#39;t use a ThreadsListHandle here because the current thread
3131   // must be alive.
3132   oop java_thread = JNIHandles::resolve_non_null(jthread);
3133   JavaThread* thr = java_lang_Thread::thread(java_thread);
3134   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3135     // Thread naming is only supported for the current thread and
3136     // we don&#39;t set the name of an attached thread to avoid stepping
3137     // on other programs.
3138     ResourceMark rm(thread);
3139     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3140     os::set_native_thread_name(thread_name);
3141   }
3142 JVM_END
3143 
3144 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3145 
3146 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3147   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3148   ResourceMark rm(THREAD);
3149   JvmtiVMObjectAllocEventCollector oam;
3150   vframeStream vfst(thread);
3151 
3152   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3153     // This must only be called from SecurityManager.getClassContext
3154     Method* m = vfst.method();
3155     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3156           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3157           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3158       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3159     }
3160   }
3161 
3162   // Collect method holders
3163   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3164   for (; !vfst.at_end(); vfst.security_next()) {
3165     Method* m = vfst.method();
3166     // Native frames are not returned
3167     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3168       Klass* holder = m-&gt;method_holder();
3169       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3170       klass_array-&gt;append(holder);
3171     }
3172   }
3173 
3174   // Create result array of type [Ljava/lang/Class;
3175   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3176   // Fill in mirrors corresponding to method holders
3177   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3178     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3179   }
3180 
3181   return (jobjectArray) JNIHandles::make_local(env, result);
3182 JVM_END
3183 
3184 
3185 // java.lang.Package ////////////////////////////////////////////////////////////////
3186 
3187 
3188 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3189   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3190   ResourceMark rm(THREAD);
3191   JvmtiVMObjectAllocEventCollector oam;
3192   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3193   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3194   return (jstring) JNIHandles::make_local(result);
3195 JVM_END
3196 
3197 
3198 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3199   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3200   JvmtiVMObjectAllocEventCollector oam;
3201   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3202   return (jobjectArray) JNIHandles::make_local(result);
3203 JVM_END
3204 
3205 
3206 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3207 
3208 
3209 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3210   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3211 
3212   MonitorLocker ml(Heap_lock);
3213   oop ref = Universe::reference_pending_list();
3214   if (ref != NULL) {
3215     Universe::set_reference_pending_list(NULL);
3216   }
3217   return JNIHandles::make_local(env, ref);
3218 JVM_END
3219 
3220 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3221   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3222   MonitorLocker ml(Heap_lock);
3223   return Universe::has_reference_pending_list();
3224 JVM_END
3225 
3226 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3227   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3228   MonitorLocker ml(Heap_lock);
3229   while (!Universe::has_reference_pending_list()) {
3230     ml.wait();
3231   }
3232 JVM_END
3233 
3234 
3235 // ObjectInputStream ///////////////////////////////////////////////////////////////
3236 
3237 // Return the first user-defined class loader up the execution stack, or null
3238 // if only code from the bootstrap or platform class loader is on the stack.
3239 
3240 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3241   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3242     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3243     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3244     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3245       return JNIHandles::make_local(env, loader);
3246     }
3247   }
3248   return NULL;
3249 JVM_END
3250 
3251 
3252 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3253 
3254 
3255 // resolve array handle and check arguments
3256 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3257   if (arr == NULL) {
3258     THROW_0(vmSymbols::java_lang_NullPointerException());
3259   }
3260   oop a = JNIHandles::resolve_non_null(arr);
3261   if (!a-&gt;is_array()) {
3262     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3263   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3264     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3265   }
3266   return arrayOop(a);
3267 }
3268 
3269 
3270 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3271   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3272   arrayOop a = check_array(env, arr, false, CHECK_0);
3273   return a-&gt;length();
3274 JVM_END
3275 
3276 
3277 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3278   JVMWrapper(&quot;JVM_Array_Get&quot;);
3279   JvmtiVMObjectAllocEventCollector oam;
3280   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3281   jvalue value;
3282   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3283   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3284   return JNIHandles::make_local(env, box);
3285 JVM_END
3286 
3287 
3288 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3289   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3290   jvalue value;
3291   value.i = 0; // to initialize value before getting used in CHECK
3292   arrayOop a = check_array(env, arr, true, CHECK_(value));
3293   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3294   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3295   BasicType wide_type = (BasicType) wCode;
3296   if (type != wide_type) {
3297     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3298   }
3299   return value;
3300 JVM_END
3301 
3302 
3303 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3304   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3305   arrayOop a = check_array(env, arr, false, CHECK);
3306   oop box = JNIHandles::resolve(val);
3307   jvalue value;
3308   value.i = 0; // to initialize value before getting used in CHECK
3309   BasicType value_type;
3310   if (a-&gt;is_objArray()) {
3311     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3312     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3313   } else {
3314     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3315   }
3316   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3317 JVM_END
3318 
3319 
3320 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3321   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3322   arrayOop a = check_array(env, arr, true, CHECK);
3323   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3324   BasicType value_type = (BasicType) vCode;
3325   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3326 JVM_END
3327 
3328 
3329 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3330   JVMWrapper(&quot;JVM_NewArray&quot;);
3331   JvmtiVMObjectAllocEventCollector oam;
3332   oop element_mirror = JNIHandles::resolve(eltClass);
3333   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3334   return JNIHandles::make_local(env, result);
3335 JVM_END
3336 
3337 
3338 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3339   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3340   JvmtiVMObjectAllocEventCollector oam;
3341   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3342   oop element_mirror = JNIHandles::resolve(eltClass);
3343   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3344   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3345   return JNIHandles::make_local(env, result);
3346 JVM_END
3347 
3348 
3349 // Library support ///////////////////////////////////////////////////////////////////////////
3350 
3351 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3352   //%note jvm_ct
3353   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3354   char ebuf[1024];
3355   void *load_result;
3356   {
3357     ThreadToNativeFromVM ttnfvm(thread);
3358     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3359   }
3360   if (load_result == NULL) {
3361     char msg[1024];
3362     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3363     // Since &#39;ebuf&#39; may contain a string encoded using
3364     // platform encoding scheme, we need to pass
3365     // Exceptions::unsafe_to_utf8 to the new_exception method
3366     // as the last argument. See bug 6367357.
3367     Handle h_exception =
3368       Exceptions::new_exception(thread,
3369                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3370                                 msg, Exceptions::unsafe_to_utf8);
3371 
3372     THROW_HANDLE_0(h_exception);
3373   }
3374   return load_result;
3375 JVM_END
3376 
3377 
3378 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3379   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3380   os::dll_unload(handle);
3381 JVM_END
3382 
3383 
3384 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3385   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3386   return os::dll_lookup(handle, name);
3387 JVM_END
3388 
3389 
3390 // JNI version ///////////////////////////////////////////////////////////////////////////////
3391 
3392 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3393   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3394   return Threads::is_supported_jni_version_including_1_1(version);
3395 JVM_END
3396 
3397 
3398 // String support ///////////////////////////////////////////////////////////////////////////
3399 
3400 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3401   JVMWrapper(&quot;JVM_InternString&quot;);
3402   JvmtiVMObjectAllocEventCollector oam;
3403   if (str == NULL) return NULL;
3404   oop string = JNIHandles::resolve_non_null(str);
3405   oop result = StringTable::intern(string, CHECK_NULL);
3406   return (jstring) JNIHandles::make_local(env, result);
3407 JVM_END
3408 
3409 
3410 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3411 
3412 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3413 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3414 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3415 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3416 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3417 
3418 
3419 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3420   VM_Exit::block_if_vm_exited();
3421   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3422   return new os::PlatformMutex();
3423 }
3424 
3425 
3426 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3427   VM_Exit::block_if_vm_exited();
3428   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3429   delete ((os::PlatformMutex*) mon);
3430 }
3431 
3432 
3433 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3434   VM_Exit::block_if_vm_exited();
3435   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3436   ((os::PlatformMutex*) mon)-&gt;lock();
3437   return 0;
3438 }
3439 
3440 
3441 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3442   VM_Exit::block_if_vm_exited();
3443   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3444   ((os::PlatformMutex*) mon)-&gt;unlock();
3445 }
3446 
3447 
3448 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3449 
3450 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3451                                     Handle loader, Handle protection_domain,
3452                                     jboolean throwError, TRAPS) {
3453   // Security Note:
3454   //   The Java level wrapper will perform the necessary security check allowing
3455   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3456   //   the checkPackageAccess relative to the initiating class loader via the
3457   //   protection_domain. The protection_domain is passed as NULL by the java code
3458   //   if there is no security manager in 3-arg Class.forName().
3459   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3460 
3461   // Check if we should initialize the class
3462   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3463     klass-&gt;initialize(CHECK_NULL);
3464   }
3465   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3466 }
3467 
3468 
3469 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3470 
3471 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3472   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3473   Handle method_handle;
3474   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3475     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3476     Handle receiver(THREAD, JNIHandles::resolve(obj));
3477     objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3478     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3479     jobject res = JNIHandles::make_local(env, result);
3480     if (JvmtiExport::should_post_vm_object_alloc()) {
3481       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3482       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3483       if (java_lang_Class::is_primitive(ret_type)) {
3484         // Only for primitive type vm allocates memory for java object.
3485         // See box() method.
3486         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3487       }
3488     }
3489     return res;
3490   } else {
3491     THROW_0(vmSymbols::java_lang_StackOverflowError());
3492   }
3493 JVM_END
3494 
3495 
3496 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3497   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3498   oop constructor_mirror = JNIHandles::resolve(c);
3499   objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));
3500   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3501   jobject res = JNIHandles::make_local(env, result);
3502   if (JvmtiExport::should_post_vm_object_alloc()) {
3503     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3504   }
3505   return res;
3506 JVM_END
3507 
3508 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3509 
3510 JVM_LEAF(jboolean, JVM_SupportsCX8())
3511   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3512   return VM_Version::supports_cx8();
3513 JVM_END
3514 
3515 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3516   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3517   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3518   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3519   HeapShared::initialize_from_archived_subgraph(k);
3520 JVM_END
3521 
3522 // Returns an array of all live Thread objects (VM internal JavaThreads,
3523 // jvmti agent threads, and JNI attaching threads  are skipped)
3524 // See CR 6404306 regarding JNI attaching threads
3525 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3526   ResourceMark rm(THREAD);
3527   ThreadsListEnumerator tle(THREAD, false, false);
3528   JvmtiVMObjectAllocEventCollector oam;
3529 
3530   int num_threads = tle.num_threads();
3531   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3532   objArrayHandle threads_ah(THREAD, r);
3533 
3534   for (int i = 0; i &lt; num_threads; i++) {
3535     Handle h = tle.get_threadObj(i);
3536     threads_ah-&gt;obj_at_put(i, h());
3537   }
3538 
3539   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3540 JVM_END
3541 
3542 
3543 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3544 // Return StackTraceElement[][], each element is the stack trace of a thread in
3545 // the corresponding entry in the given threads array
3546 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3547   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3548   JvmtiVMObjectAllocEventCollector oam;
3549 
3550   // Check if threads is null
3551   if (threads == NULL) {
3552     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3553   }
3554 
3555   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3556   objArrayHandle ah(THREAD, a);
3557   int num_threads = ah-&gt;length();
3558   // check if threads is non-empty array
3559   if (num_threads == 0) {
3560     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3561   }
3562 
3563   // check if threads is not an array of objects of Thread class
3564   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3565   if (k != SystemDictionary::Thread_klass()) {
3566     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3567   }
3568 
3569   ResourceMark rm(THREAD);
3570 
3571   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3572   for (int i = 0; i &lt; num_threads; i++) {
3573     oop thread_obj = ah-&gt;obj_at(i);
3574     instanceHandle h(THREAD, (instanceOop) thread_obj);
3575     thread_handle_array-&gt;append(h);
3576   }
3577 
3578   // The JavaThread references in thread_handle_array are validated
3579   // in VM_ThreadDump::doit().
3580   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3581   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3582 
3583 JVM_END
3584 
3585 // JVM monitoring and management support
3586 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3587   return Management::get_jmm_interface(version);
3588 JVM_END
3589 
3590 // com.sun.tools.attach.VirtualMachine agent properties support
3591 //
3592 // Initialize the agent properties with the properties maintained in the VM
3593 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3594   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3595   ResourceMark rm;
3596 
3597   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3598 
3599   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3600   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3601   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3602   return properties;
3603 JVM_END
3604 
3605 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3606 {
3607   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3608   JvmtiVMObjectAllocEventCollector oam;
3609 
3610   if (ofClass == NULL) {
3611     return NULL;
3612   }
3613   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3614   // Special handling for primitive objects
3615   if (java_lang_Class::is_primitive(mirror())) {
3616     return NULL;
3617   }
3618   Klass* k = java_lang_Class::as_Klass(mirror());
3619   if (!k-&gt;is_instance_klass()) {
3620     return NULL;
3621   }
3622   InstanceKlass* ik = InstanceKlass::cast(k);
3623   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3624   if (encl_method_class_idx == 0) {
3625     return NULL;
3626   }
3627   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3628   objArrayHandle dest(THREAD, dest_o);
3629   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3630   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3631   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3632   if (encl_method_method_idx != 0) {
3633     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3634                         extract_low_short_from_int(
3635                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3636     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3637     dest-&gt;obj_at_put(1, str());
3638     sym = ik-&gt;constants()-&gt;symbol_at(
3639               extract_high_short_from_int(
3640                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3641     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3642     dest-&gt;obj_at_put(2, str());
3643   }
3644   return (jobjectArray) JNIHandles::make_local(dest());
3645 }
3646 JVM_END
3647 
3648 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3649 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3650   ResourceMark rm(THREAD);
3651 
3652   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3653     return NULL;
3654   }
3655 
3656   char** vm_flags = Arguments::jvm_flags_array();
3657   char** vm_args = Arguments::jvm_args_array();
3658   int num_flags = Arguments::num_jvm_flags();
3659   int num_args = Arguments::num_jvm_args();
3660 
3661   InstanceKlass* ik = SystemDictionary::String_klass();
3662   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3663   objArrayHandle result_h(THREAD, r);
3664 
3665   int index = 0;
3666   for (int j = 0; j &lt; num_flags; j++, index++) {
3667     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3668     result_h-&gt;obj_at_put(index, h());
3669   }
3670   for (int i = 0; i &lt; num_args; i++, index++) {
3671     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3672     result_h-&gt;obj_at_put(index, h());
3673   }
3674   return (jobjectArray) JNIHandles::make_local(env, result_h());
3675 JVM_END
3676 
3677 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3678   return os::get_signal_number(name);
3679 JVM_END
    </pre>
  </body>
</html>