<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/phaseX.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
 845 // Return the Handle Type
 846 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 847   JNIWrapper(&quot;GetObjectRefType&quot;);
 848 
 849   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 850 
 851   jobjectRefType ret = JNIInvalidRefType;
 852   if (obj != NULL) {
 853     ret = JNIHandles::handle_type(thread, obj);
 854   }
 855 
 856   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 857   return ret;
 858 JNI_END
 859 
 860 
 861 class JNI_ArgumentPusher : public SignatureIterator {
 862  protected:
 863   JavaCallArguments*  _arguments;
 864 
<span class="line-modified"> 865   virtual void get_bool   () = 0;</span>
<span class="line-modified"> 866   virtual void get_char   () = 0;</span>
<span class="line-modified"> 867   virtual void get_short  () = 0;</span>
<span class="line-modified"> 868   virtual void get_byte   () = 0;</span>
<span class="line-modified"> 869   virtual void get_int    () = 0;</span>
<span class="line-modified"> 870   virtual void get_long   () = 0;</span>
<span class="line-modified"> 871   virtual void get_float  () = 0;</span>
<span class="line-modified"> 872   virtual void get_double () = 0;</span>
<span class="line-modified"> 873   virtual void get_object () = 0;</span>
<span class="line-modified"> 874 </span>
<span class="line-modified"> 875   JNI_ArgumentPusher(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified"> 876     this-&gt;_return_type = T_ILLEGAL;</span>






 877     _arguments = NULL;
 878   }
 879 
 880  public:
<span class="line-modified"> 881   virtual void iterate( uint64_t fingerprint ) = 0;</span>
<span class="line-removed"> 882 </span>
<span class="line-removed"> 883   void set_java_argument_object(JavaCallArguments *arguments) { _arguments = arguments; }</span>
<span class="line-removed"> 884 </span>
<span class="line-removed"> 885   inline void do_bool()                     { if (!is_return_type()) get_bool();   }</span>
<span class="line-removed"> 886   inline void do_char()                     { if (!is_return_type()) get_char();   }</span>
<span class="line-removed"> 887   inline void do_short()                    { if (!is_return_type()) get_short();  }</span>
<span class="line-removed"> 888   inline void do_byte()                     { if (!is_return_type()) get_byte();   }</span>
<span class="line-removed"> 889   inline void do_int()                      { if (!is_return_type()) get_int();    }</span>
<span class="line-removed"> 890   inline void do_long()                     { if (!is_return_type()) get_long();   }</span>
<span class="line-removed"> 891   inline void do_float()                    { if (!is_return_type()) get_float();  }</span>
<span class="line-removed"> 892   inline void do_double()                   { if (!is_return_type()) get_double(); }</span>
<span class="line-removed"> 893   inline void do_object(int begin, int end) { if (!is_return_type()) get_object(); }</span>
<span class="line-removed"> 894   inline void do_array(int begin, int end)  { if (!is_return_type()) get_object(); } // do_array uses get_object -- there is no get_array</span>
<span class="line-removed"> 895   inline void do_void()                     { }</span>
<span class="line-removed"> 896 </span>
<span class="line-removed"> 897   JavaCallArguments* arguments()     { return _arguments; }</span>
<span class="line-removed"> 898   void push_receiver(Handle h)       { _arguments-&gt;push_oop(h); }</span>
 899 };
 900 
 901 
 902 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 903  protected:
 904   va_list _ap;
 905 
<span class="line-modified"> 906   inline void get_bool()   {</span>
<span class="line-modified"> 907     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed"> 908     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed"> 909     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed"> 910     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed"> 911     jboolean b = va_arg(_ap, jint);</span>
<span class="line-removed"> 912     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
 913   }
<span class="line-removed"> 914   inline void get_char()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // char is coerced to int when using va_arg</span>
<span class="line-removed"> 915   inline void get_short()  { _arguments-&gt;push_int(va_arg(_ap, jint)); } // short is coerced to int when using va_arg</span>
<span class="line-removed"> 916   inline void get_byte()   { _arguments-&gt;push_int(va_arg(_ap, jint)); } // byte is coerced to int when using va_arg</span>
<span class="line-removed"> 917   inline void get_int()    { _arguments-&gt;push_int(va_arg(_ap, jint)); }</span>
<span class="line-removed"> 918 </span>
<span class="line-removed"> 919   // each of these paths is exercized by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921   inline void get_long()   { _arguments-&gt;push_long(va_arg(_ap, jlong)); }</span>
<span class="line-removed"> 922   inline void get_float()  { _arguments-&gt;push_float((jfloat)va_arg(_ap, jdouble)); } // float is coerced to double w/ va_arg</span>
<span class="line-removed"> 923   inline void get_double() { _arguments-&gt;push_double(va_arg(_ap, jdouble)); }</span>
<span class="line-removed"> 924   inline void get_object() { _arguments-&gt;push_jobject(va_arg(_ap, jobject)); }</span>
 925 
<span class="line-modified"> 926   inline void set_ap(va_list rap) {</span>
<span class="line-modified"> 927     va_copy(_ap, rap);</span>



















 928   }
 929 
 930  public:
<span class="line-removed"> 931   JNI_ArgumentPusherVaArg(Symbol* signature, va_list rap)</span>
<span class="line-removed"> 932        : JNI_ArgumentPusher(signature) {</span>
<span class="line-removed"> 933     set_ap(rap);</span>
<span class="line-removed"> 934   }</span>
 935   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<span class="line-modified"> 936       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
 937     set_ap(rap);
 938   }
 939 
<span class="line-modified"> 940   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified"> 941   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified"> 942     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed"> 943       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed"> 944     } else {</span>
<span class="line-removed"> 945       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed"> 946                                   result_feature_mask);</span>
<span class="line-removed"> 947 </span>
<span class="line-removed"> 948       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed"> 949       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed"> 950       while ( 1 ) {</span>
<span class="line-removed"> 951         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed"> 952           case bool_parm:</span>
<span class="line-removed"> 953             get_bool();</span>
<span class="line-removed"> 954             break;</span>
<span class="line-removed"> 955           case char_parm:</span>
<span class="line-removed"> 956             get_char();</span>
<span class="line-removed"> 957             break;</span>
<span class="line-removed"> 958           case short_parm:</span>
<span class="line-removed"> 959             get_short();</span>
<span class="line-removed"> 960             break;</span>
<span class="line-removed"> 961           case byte_parm:</span>
<span class="line-removed"> 962             get_byte();</span>
<span class="line-removed"> 963             break;</span>
<span class="line-removed"> 964           case int_parm:</span>
<span class="line-removed"> 965             get_int();</span>
<span class="line-removed"> 966             break;</span>
<span class="line-removed"> 967           case obj_parm:</span>
<span class="line-removed"> 968             get_object();</span>
<span class="line-removed"> 969             break;</span>
<span class="line-removed"> 970           case long_parm:</span>
<span class="line-removed"> 971             get_long();</span>
<span class="line-removed"> 972             break;</span>
<span class="line-removed"> 973           case float_parm:</span>
<span class="line-removed"> 974             get_float();</span>
<span class="line-removed"> 975             break;</span>
<span class="line-removed"> 976           case double_parm:</span>
<span class="line-removed"> 977             get_double();</span>
<span class="line-removed"> 978             break;</span>
<span class="line-removed"> 979           case done_parm:</span>
<span class="line-removed"> 980             return;</span>
<span class="line-removed"> 981             break;</span>
<span class="line-removed"> 982           default:</span>
<span class="line-removed"> 983             ShouldNotReachHere();</span>
<span class="line-removed"> 984             break;</span>
<span class="line-removed"> 985         }</span>
<span class="line-removed"> 986         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed"> 987       }</span>
<span class="line-removed"> 988     }</span>
 989   }
 990 };
 991 
 992 
 993 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 994  protected:
 995   const jvalue *_ap;
 996 
<span class="line-removed"> 997   inline void get_bool()   {</span>
<span class="line-removed"> 998     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-removed"> 999     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-removed">1000     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-removed">1001     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-removed">1002     jboolean b = (_ap++)-&gt;z;</span>
<span class="line-removed">1003     _arguments-&gt;push_int((jint)(b == 0 ? JNI_FALSE : JNI_TRUE));</span>
<span class="line-removed">1004   }</span>
<span class="line-removed">1005   inline void get_char()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;c); }</span>
<span class="line-removed">1006   inline void get_short()  { _arguments-&gt;push_int((jint)(_ap++)-&gt;s); }</span>
<span class="line-removed">1007   inline void get_byte()   { _arguments-&gt;push_int((jint)(_ap++)-&gt;b); }</span>
<span class="line-removed">1008   inline void get_int()    { _arguments-&gt;push_int((jint)(_ap++)-&gt;i); }</span>
<span class="line-removed">1009 </span>
<span class="line-removed">1010   inline void get_long()   { _arguments-&gt;push_long((_ap++)-&gt;j);  }</span>
<span class="line-removed">1011   inline void get_float()  { _arguments-&gt;push_float((_ap++)-&gt;f); }</span>
<span class="line-removed">1012   inline void get_double() { _arguments-&gt;push_double((_ap++)-&gt;d);}</span>
<span class="line-removed">1013   inline void get_object() { _arguments-&gt;push_jobject((_ap++)-&gt;l); }</span>
<span class="line-removed">1014 </span>
1015   inline void set_ap(const jvalue *rap) { _ap = rap; }
1016 
<span class="line-modified">1017  public:</span>
<span class="line-modified">1018   JNI_ArgumentPusherArray(Symbol* signature, const jvalue *rap)</span>
<span class="line-modified">1019        : JNI_ArgumentPusher(signature) {</span>
<span class="line-modified">1020     set_ap(rap);</span>











1021   }


1022   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<span class="line-modified">1023       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)-&gt;signature()) {</span>
1024     set_ap(rap);
1025   }
1026 
<span class="line-modified">1027   // Optimized path if we have the bitvector form of signature</span>
<span class="line-modified">1028   void iterate( uint64_t fingerprint ) {</span>
<span class="line-modified">1029     if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-removed">1030       SignatureIterator::iterate(); // Must be too many arguments</span>
<span class="line-removed">1031     } else {</span>
<span class="line-removed">1032       _return_type = (BasicType)((fingerprint &gt;&gt; static_feature_size) &amp;</span>
<span class="line-removed">1033                                   result_feature_mask);</span>
<span class="line-removed">1034       assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-removed">1035       fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-removed">1036       while ( 1 ) {</span>
<span class="line-removed">1037         switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed">1038           case bool_parm:</span>
<span class="line-removed">1039             get_bool();</span>
<span class="line-removed">1040             break;</span>
<span class="line-removed">1041           case char_parm:</span>
<span class="line-removed">1042             get_char();</span>
<span class="line-removed">1043             break;</span>
<span class="line-removed">1044           case short_parm:</span>
<span class="line-removed">1045             get_short();</span>
<span class="line-removed">1046             break;</span>
<span class="line-removed">1047           case byte_parm:</span>
<span class="line-removed">1048             get_byte();</span>
<span class="line-removed">1049             break;</span>
<span class="line-removed">1050           case int_parm:</span>
<span class="line-removed">1051             get_int();</span>
<span class="line-removed">1052             break;</span>
<span class="line-removed">1053           case obj_parm:</span>
<span class="line-removed">1054             get_object();</span>
<span class="line-removed">1055             break;</span>
<span class="line-removed">1056           case long_parm:</span>
<span class="line-removed">1057             get_long();</span>
<span class="line-removed">1058             break;</span>
<span class="line-removed">1059           case float_parm:</span>
<span class="line-removed">1060             get_float();</span>
<span class="line-removed">1061             break;</span>
<span class="line-removed">1062           case double_parm:</span>
<span class="line-removed">1063             get_double();</span>
<span class="line-removed">1064             break;</span>
<span class="line-removed">1065           case done_parm:</span>
<span class="line-removed">1066             return;</span>
<span class="line-removed">1067             break;</span>
<span class="line-removed">1068           default:</span>
<span class="line-removed">1069             ShouldNotReachHere();</span>
<span class="line-removed">1070             break;</span>
<span class="line-removed">1071         }</span>
<span class="line-removed">1072         fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="line-removed">1073       }</span>
<span class="line-removed">1074     }</span>
1075   }
1076 };
1077 
1078 
1079 enum JNICallType {
1080   JNI_STATIC,
1081   JNI_VIRTUAL,
1082   JNI_NONVIRTUAL
1083 };
1084 
1085 
1086 
1087 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1088   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
1089 
1090   // Create object to hold arguments for the JavaCall, and associate it with
1091   // the jni parser
1092   ResourceMark rm(THREAD);
1093   int number_of_parameters = method-&gt;size_of_parameters();
1094   JavaCallArguments java_args(number_of_parameters);
<span class="line-removed">1095   args-&gt;set_java_argument_object(&amp;java_args);</span>
1096 
1097   assert(method-&gt;is_static(), &quot;method should be static&quot;);
1098 
1099   // Fill out JavaCallArguments object
<span class="line-modified">1100   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1101   // Initialize result type
<span class="line-modified">1102   result-&gt;set_type(args-&gt;get_ret_type());</span>
1103 
1104   // Invoke the method. Result is returned as oop.
1105   JavaCalls::call(result, method, &amp;java_args, CHECK);
1106 
1107   // Convert result
1108   if (is_reference_type(result-&gt;get_type())) {
1109     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1110   }
1111 }
1112 
1113 
1114 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1115   oop recv = JNIHandles::resolve(receiver);
1116   if (recv == NULL) {
1117     THROW(vmSymbols::java_lang_NullPointerException());
1118   }
1119   Handle h_recv(THREAD, recv);
1120 
1121   int number_of_parameters;
1122   Method* selected_method;
</pre>
<hr />
<pre>
1136       if (vtbl_index != Method::nonvirtual_vtable_index) {
1137         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1138       } else {
1139         // final method
1140         selected_method = m;
1141       }
1142     } else {
1143       // interface call
1144       int itbl_index = m-&gt;itable_index();
1145       Klass* k = h_recv-&gt;klass();
1146       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1147     }
1148   }
1149 
1150   methodHandle method(THREAD, selected_method);
1151 
1152   // Create object to hold arguments for the JavaCall, and associate it with
1153   // the jni parser
1154   ResourceMark rm(THREAD);
1155   JavaCallArguments java_args(number_of_parameters);
<span class="line-removed">1156   args-&gt;set_java_argument_object(&amp;java_args);</span>
1157 
1158   // handle arguments
1159   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<span class="line-modified">1160   args-&gt;push_receiver(h_recv); // Push jobject handle</span>
1161 
1162   // Fill out JavaCallArguments object
<span class="line-modified">1163   args-&gt;iterate( Fingerprinter(method).fingerprint() );</span>
1164   // Initialize result type
<span class="line-modified">1165   result-&gt;set_type(args-&gt;get_ret_type());</span>
1166 
1167   // Invoke the method. Result is returned as oop.
1168   JavaCalls::call(result, method, &amp;java_args, CHECK);
1169 
1170   // Convert result
1171   if (is_reference_type(result-&gt;get_type())) {
1172     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1173   }
1174 }
1175 
1176 
1177 static instanceOop alloc_object(jclass clazz, TRAPS) {
1178   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1179   if (k == NULL) {
1180     ResourceMark rm(THREAD);
1181     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1182   }
1183   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1184   k-&gt;initialize(CHECK_NULL);
1185   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
</pre>
<hr />
<pre>
2904                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2905                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2906 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2907                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2908                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2909 
2910 
2911 DT_RETURN_MARK_DECL(RegisterNatives, jint
2912                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2913 
2914 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2915                                     const JNINativeMethod *methods,
2916                                     jint nMethods))
2917   JNIWrapper(&quot;RegisterNatives&quot;);
2918   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2919   jint ret = 0;
2920   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2921 
2922   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2923 














2924   for (int index = 0; index &lt; nMethods; index++) {
2925     const char* meth_name = methods[index].name;
2926     const char* meth_sig = methods[index].signature;
2927     int meth_name_len = (int)strlen(meth_name);
2928 
2929     // The class should have been loaded (we have an instance of the class
2930     // passed in) so the method and signature should already be in the symbol
2931     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2932     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2933     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2934 
2935     if (name == NULL || signature == NULL) {
<span class="line-modified">2936       ResourceMark rm;</span>
2937       stringStream st;
2938       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2939       // Must return negative value on failure
2940       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2941     }
2942 






2943     bool res = Method::register_native(k, name, signature,
2944                                        (address) methods[index].fnPtr, THREAD);
2945     if (!res) {
2946       ret = -1;
2947       break;
2948     }
2949   }
2950   return ret;
2951 JNI_END
2952 
2953 
2954 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2955   JNIWrapper(&quot;UnregisterNatives&quot;);
2956  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2957   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2958   //%note jni_2
2959   if (k-&gt;is_instance_klass()) {
2960     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2961       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2962       if (m-&gt;is_native()) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
</pre>
<hr />
<pre>
 845 // Return the Handle Type
 846 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 847   JNIWrapper(&quot;GetObjectRefType&quot;);
 848 
 849   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 850 
 851   jobjectRefType ret = JNIInvalidRefType;
 852   if (obj != NULL) {
 853     ret = JNIHandles::handle_type(thread, obj);
 854   }
 855 
 856   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 857   return ret;
 858 JNI_END
 859 
 860 
 861 class JNI_ArgumentPusher : public SignatureIterator {
 862  protected:
 863   JavaCallArguments*  _arguments;
 864 
<span class="line-modified"> 865   void push_int(jint x)         { _arguments-&gt;push_int(x); }</span>
<span class="line-modified"> 866   void push_long(jlong x)       { _arguments-&gt;push_long(x); }</span>
<span class="line-modified"> 867   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }</span>
<span class="line-modified"> 868   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }</span>
<span class="line-modified"> 869   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }</span>
<span class="line-modified"> 870 </span>
<span class="line-modified"> 871   void push_boolean(jboolean b) {</span>
<span class="line-modified"> 872     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and</span>
<span class="line-modified"> 873     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in</span>
<span class="line-modified"> 874     // TemplateInterpreterGenerator::generate_result_handler_for and</span>
<span class="line-modified"> 875     // SharedRuntime::generate_native_wrapper.</span>
<span class="line-modified"> 876     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);</span>
<span class="line-added"> 877   }</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879   JNI_ArgumentPusher(Method* method)</span>
<span class="line-added"> 880     : SignatureIterator(method-&gt;signature(),</span>
<span class="line-added"> 881                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())</span>
<span class="line-added"> 882   {</span>
 883     _arguments = NULL;
 884   }
 885 
 886  public:
<span class="line-modified"> 887   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;</span>

















 888 };
 889 
 890 
 891 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 892  protected:
 893   va_list _ap;
 894 
<span class="line-modified"> 895   void set_ap(va_list rap) {</span>
<span class="line-modified"> 896     va_copy(_ap, rap);</span>





 897   }











 898 
<span class="line-modified"> 899   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 900   void do_type(BasicType type) {</span>
<span class="line-added"> 901     switch (type) {</span>
<span class="line-added"> 902     // these are coerced to int when using va_arg</span>
<span class="line-added"> 903     case T_BYTE:</span>
<span class="line-added"> 904     case T_CHAR:</span>
<span class="line-added"> 905     case T_SHORT:</span>
<span class="line-added"> 906     case T_INT:         push_int(va_arg(_ap, jint)); break;</span>
<span class="line-added"> 907     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;</span>
<span class="line-added"> 908 </span>
<span class="line-added"> 909     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911     case T_LONG:        push_long(va_arg(_ap, jlong)); break;</span>
<span class="line-added"> 912     // float is coerced to double w/ va_arg</span>
<span class="line-added"> 913     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;</span>
<span class="line-added"> 914     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     case T_ARRAY:</span>
<span class="line-added"> 917     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>
<span class="line-added"> 918     default:            ShouldNotReachHere();</span>
<span class="line-added"> 919     }</span>
 920   }
 921 
 922  public:




 923   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
<span class="line-modified"> 924       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
 925     set_ap(rap);
 926   }
 927 
<span class="line-modified"> 928   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="line-modified"> 929     _arguments = arguments;</span>
<span class="line-modified"> 930     do_parameters_on(this);</span>














































 931   }
 932 };
 933 
 934 
 935 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 936  protected:
 937   const jvalue *_ap;
 938 


















 939   inline void set_ap(const jvalue *rap) { _ap = rap; }
 940 
<span class="line-modified"> 941   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 942   void do_type(BasicType type) {</span>
<span class="line-modified"> 943     switch (type) {</span>
<span class="line-modified"> 944     case T_CHAR:        push_int((_ap++)-&gt;c); break;</span>
<span class="line-added"> 945     case T_SHORT:       push_int((_ap++)-&gt;s); break;</span>
<span class="line-added"> 946     case T_BYTE:        push_int((_ap++)-&gt;b); break;</span>
<span class="line-added"> 947     case T_INT:         push_int((_ap++)-&gt;i); break;</span>
<span class="line-added"> 948     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;</span>
<span class="line-added"> 949     case T_LONG:        push_long((_ap++)-&gt;j); break;</span>
<span class="line-added"> 950     case T_FLOAT:       push_float((_ap++)-&gt;f); break;</span>
<span class="line-added"> 951     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;</span>
<span class="line-added"> 952     case T_ARRAY:</span>
<span class="line-added"> 953     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>
<span class="line-added"> 954     default:            ShouldNotReachHere();</span>
<span class="line-added"> 955     }</span>
 956   }
<span class="line-added"> 957 </span>
<span class="line-added"> 958  public:</span>
 959   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
<span class="line-modified"> 960       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {</span>
 961     set_ap(rap);
 962   }
 963 
<span class="line-modified"> 964   virtual void push_arguments_on(JavaCallArguments* arguments) {</span>
<span class="line-modified"> 965     _arguments = arguments;</span>
<span class="line-modified"> 966     do_parameters_on(this);</span>













































 967   }
 968 };
 969 
 970 
 971 enum JNICallType {
 972   JNI_STATIC,
 973   JNI_VIRTUAL,
 974   JNI_NONVIRTUAL
 975 };
 976 
 977 
 978 
 979 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 980   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 981 
 982   // Create object to hold arguments for the JavaCall, and associate it with
 983   // the jni parser
 984   ResourceMark rm(THREAD);
 985   int number_of_parameters = method-&gt;size_of_parameters();
 986   JavaCallArguments java_args(number_of_parameters);

 987 
 988   assert(method-&gt;is_static(), &quot;method should be static&quot;);
 989 
 990   // Fill out JavaCallArguments object
<span class="line-modified"> 991   args-&gt;push_arguments_on(&amp;java_args);</span>
 992   // Initialize result type
<span class="line-modified"> 993   result-&gt;set_type(args-&gt;return_type());</span>
 994 
 995   // Invoke the method. Result is returned as oop.
 996   JavaCalls::call(result, method, &amp;java_args, CHECK);
 997 
 998   // Convert result
 999   if (is_reference_type(result-&gt;get_type())) {
1000     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1001   }
1002 }
1003 
1004 
1005 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1006   oop recv = JNIHandles::resolve(receiver);
1007   if (recv == NULL) {
1008     THROW(vmSymbols::java_lang_NullPointerException());
1009   }
1010   Handle h_recv(THREAD, recv);
1011 
1012   int number_of_parameters;
1013   Method* selected_method;
</pre>
<hr />
<pre>
1027       if (vtbl_index != Method::nonvirtual_vtable_index) {
1028         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1029       } else {
1030         // final method
1031         selected_method = m;
1032       }
1033     } else {
1034       // interface call
1035       int itbl_index = m-&gt;itable_index();
1036       Klass* k = h_recv-&gt;klass();
1037       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1038     }
1039   }
1040 
1041   methodHandle method(THREAD, selected_method);
1042 
1043   // Create object to hold arguments for the JavaCall, and associate it with
1044   // the jni parser
1045   ResourceMark rm(THREAD);
1046   JavaCallArguments java_args(number_of_parameters);

1047 
1048   // handle arguments
1049   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
<span class="line-modified">1050   java_args.push_oop(h_recv); // Push jobject handle</span>
1051 
1052   // Fill out JavaCallArguments object
<span class="line-modified">1053   args-&gt;push_arguments_on(&amp;java_args);</span>
1054   // Initialize result type
<span class="line-modified">1055   result-&gt;set_type(args-&gt;return_type());</span>
1056 
1057   // Invoke the method. Result is returned as oop.
1058   JavaCalls::call(result, method, &amp;java_args, CHECK);
1059 
1060   // Convert result
1061   if (is_reference_type(result-&gt;get_type())) {
1062     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1063   }
1064 }
1065 
1066 
1067 static instanceOop alloc_object(jclass clazz, TRAPS) {
1068   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1069   if (k == NULL) {
1070     ResourceMark rm(THREAD);
1071     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1072   }
1073   k-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1074   k-&gt;initialize(CHECK_NULL);
1075   instanceOop ih = InstanceKlass::cast(k)-&gt;allocate_instance(THREAD);
</pre>
<hr />
<pre>
2794                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2795                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2796 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2797                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2798                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2799 
2800 
2801 DT_RETURN_MARK_DECL(RegisterNatives, jint
2802                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2803 
2804 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2805                                     const JNINativeMethod *methods,
2806                                     jint nMethods))
2807   JNIWrapper(&quot;RegisterNatives&quot;);
2808   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2809   jint ret = 0;
2810   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2811 
2812   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2813 
<span class="line-added">2814   // There are no restrictions on native code registering native methods, which</span>
<span class="line-added">2815   // allows agents to redefine the bindings to native methods. But we issue a</span>
<span class="line-added">2816   // warning if any code running outside of the boot/platform loader is rebinding</span>
<span class="line-added">2817   // any native methods in classes loaded by the boot/platform loader.</span>
<span class="line-added">2818   Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="line-added">2819   bool do_warning = false;</span>
<span class="line-added">2820   oop cl = k-&gt;class_loader();</span>
<span class="line-added">2821   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {</span>
<span class="line-added">2822     // If no caller class, or caller class has a different loader, then</span>
<span class="line-added">2823     // issue a warning below.</span>
<span class="line-added">2824     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="line-added">2825   }</span>
<span class="line-added">2826 </span>
<span class="line-added">2827 </span>
2828   for (int index = 0; index &lt; nMethods; index++) {
2829     const char* meth_name = methods[index].name;
2830     const char* meth_sig = methods[index].signature;
2831     int meth_name_len = (int)strlen(meth_name);
2832 
2833     // The class should have been loaded (we have an instance of the class
2834     // passed in) so the method and signature should already be in the symbol
2835     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2836     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2837     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2838 
2839     if (name == NULL || signature == NULL) {
<span class="line-modified">2840       ResourceMark rm(THREAD);</span>
2841       stringStream st;
2842       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2843       // Must return negative value on failure
2844       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2845     }
2846 
<span class="line-added">2847     if (do_warning) {</span>
<span class="line-added">2848       ResourceMark rm(THREAD);</span>
<span class="line-added">2849       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;</span>
<span class="line-added">2850               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);</span>
<span class="line-added">2851     }</span>
<span class="line-added">2852 </span>
2853     bool res = Method::register_native(k, name, signature,
2854                                        (address) methods[index].fnPtr, THREAD);
2855     if (!res) {
2856       ret = -1;
2857       break;
2858     }
2859   }
2860   return ret;
2861 JNI_END
2862 
2863 
2864 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2865   JNIWrapper(&quot;UnregisterNatives&quot;);
2866  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2867   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2868   //%note jni_2
2869   if (k-&gt;is_instance_klass()) {
2870     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2871       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2872       if (m-&gt;is_native()) {
</pre>
</td>
</tr>
</table>
<center><a href="../opto/phaseX.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>