<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;prims/methodHandles.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/timerTrace.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/safepointVerifiers.hpp&quot;
  53 #include &quot;runtime/signature.hpp&quot;
  54 #include &quot;runtime/stubRoutines.hpp&quot;
  55 #include &quot;utilities/exceptions.hpp&quot;
  56 
  57 
  58 /*
  59  * JSR 292 reference implementation: method handles
  60  * The JDK 7 reference implementation represented method handle
  61  * combinations as chains.  Each link in the chain had a &quot;vmentry&quot;
  62  * field which pointed at a bit of assembly code which performed
  63  * one transformation before dispatching to the next link in the chain.
  64  *
  65  * The current reference implementation pushes almost all code generation
  66  * responsibility to (trusted) Java code.  A method handle contains a
  67  * pointer to its &quot;LambdaForm&quot;, which embodies all details of the method
  68  * handle&#39;s behavior.  The LambdaForm is a normal Java object, managed
  69  * by a runtime coded in Java.
  70  */
  71 
  72 bool MethodHandles::_enabled = false; // set true after successful native linkage
  73 MethodHandlesAdapterBlob* MethodHandles::_adapter_code = NULL;
  74 
  75 /**
  76  * Generates method handle adapters. Returns &#39;false&#39; if memory allocation
  77  * failed and true otherwise.
  78  */
  79 void MethodHandles::generate_adapters() {
  80   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
  81   assert(_adapter_code == NULL, &quot;generate only once&quot;);
  82 
  83   ResourceMark rm;
  84   TraceTime timer(&quot;MethodHandles adapters generation&quot;, TRACETIME_LOG(Info, startuptime));
  85   _adapter_code = MethodHandlesAdapterBlob::create(adapter_code_size);
  86   CodeBuffer code(_adapter_code);
  87   MethodHandlesAdapterGenerator g(&amp;code);
  88   g.generate();
  89   code.log_section_sizes(&quot;MethodHandlesAdapterBlob&quot;);
  90 }
  91 
  92 //------------------------------------------------------------------------------
  93 // MethodHandlesAdapterGenerator::generate
  94 //
  95 void MethodHandlesAdapterGenerator::generate() {
  96   // Generate generic method handle adapters.
  97   // Generate interpreter entries
  98   for (Interpreter::MethodKind mk = Interpreter::method_handle_invoke_FIRST;
  99        mk &lt;= Interpreter::method_handle_invoke_LAST;
 100        mk = Interpreter::MethodKind(1 + (int)mk)) {
 101     vmIntrinsics::ID iid = Interpreter::method_handle_intrinsic(mk);
 102     StubCodeMark mark(this, &quot;MethodHandle::interpreter_entry&quot;, vmIntrinsics::name_at(iid));
 103     address entry = MethodHandles::generate_method_handle_interpreter_entry(_masm, iid);
 104     if (entry != NULL) {
 105       Interpreter::set_entry_for_kind(mk, entry);
 106     }
 107     // If the entry is not set, it will throw AbstractMethodError.
 108   }
 109 }
 110 
 111 void MethodHandles::set_enabled(bool z) {
 112   if (_enabled != z) {
 113     guarantee(z, &quot;can only enable once&quot;);
 114     _enabled = z;
 115   }
 116 }
 117 
 118 // MemberName support
 119 
 120 // import java_lang_invoke_MemberName.*
 121 enum {
 122   IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,
 123   IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,
 124   IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,
 125   IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,
 126   CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,
 127   REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,
 128   REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,
 129   SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,
 130   SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,
 131   ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE
 132 };
 133 
 134 int MethodHandles::ref_kind_to_flags(int ref_kind) {
 135   assert(ref_kind_is_valid(ref_kind), &quot;%d&quot;, ref_kind);
 136   int flags = (ref_kind &lt;&lt; REFERENCE_KIND_SHIFT);
 137   if (ref_kind_is_field(ref_kind)) {
 138     flags |= IS_FIELD;
 139   } else if (ref_kind_is_method(ref_kind)) {
 140     flags |= IS_METHOD;
 141   } else if (ref_kind == JVM_REF_newInvokeSpecial) {
 142     flags |= IS_CONSTRUCTOR;
 143   }
 144   return flags;
 145 }
 146 
 147 Handle MethodHandles::resolve_MemberName_type(Handle mname, Klass* caller, TRAPS) {
 148   Handle empty;
 149   Handle type(THREAD, java_lang_invoke_MemberName::type(mname()));
 150   if (!java_lang_String::is_instance_inlined(type())) {
 151     return type; // already resolved
 152   }
 153   Symbol* signature = java_lang_String::as_symbol_or_null(type());
 154   if (signature == NULL) {
 155     return empty;  // no such signature exists in the VM
 156   }
 157   Handle resolved;
 158   int flags = java_lang_invoke_MemberName::flags(mname());
 159   switch (flags &amp; ALL_KINDS) {
 160     case IS_METHOD:
 161     case IS_CONSTRUCTOR:
 162       resolved = SystemDictionary::find_method_handle_type(signature, caller, CHECK_(empty));
 163       break;
 164     case IS_FIELD:
 165       resolved = SystemDictionary::find_field_handle_type(signature, caller, CHECK_(empty));
 166       break;
 167     default:
 168       THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 169   }
 170   if (resolved.is_null()) {
 171     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MemberName type&quot;, empty);
 172   }
 173   return resolved;
 174 }
 175 
 176 oop MethodHandles::init_MemberName(Handle mname, Handle target, TRAPS) {
 177   // This method is used from java.lang.invoke.MemberName constructors.
 178   // It fills in the new MemberName from a java.lang.reflect.Member.
 179   Thread* thread = Thread::current();
 180   oop target_oop = target();
 181   Klass* target_klass = target_oop-&gt;klass();
 182   if (target_klass == SystemDictionary::reflect_Field_klass()) {
 183     oop clazz = java_lang_reflect_Field::clazz(target_oop); // fd.field_holder()
 184     int slot  = java_lang_reflect_Field::slot(target_oop);  // fd.index()
 185     Klass* k = java_lang_Class::as_Klass(clazz);
 186     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 187       fieldDescriptor fd(InstanceKlass::cast(k), slot);
 188       oop mname2 = init_field_MemberName(mname, fd);
 189       if (mname2 != NULL) {
 190         // Since we have the reified name and type handy, add them to the result.
 191         if (java_lang_invoke_MemberName::name(mname2) == NULL)
 192           java_lang_invoke_MemberName::set_name(mname2, java_lang_reflect_Field::name(target_oop));
 193         if (java_lang_invoke_MemberName::type(mname2) == NULL)
 194           java_lang_invoke_MemberName::set_type(mname2, java_lang_reflect_Field::type(target_oop));
 195       }
 196       return mname2;
 197     }
 198   } else if (target_klass == SystemDictionary::reflect_Method_klass()) {
 199     oop clazz  = java_lang_reflect_Method::clazz(target_oop);
 200     int slot   = java_lang_reflect_Method::slot(target_oop);
 201     Klass* k = java_lang_Class::as_Klass(clazz);
 202     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 203       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 204       if (m == NULL || is_signature_polymorphic(m-&gt;intrinsic_id()))
 205         return NULL;            // do not resolve unless there is a concrete signature
 206       CallInfo info(m, k, CHECK_NULL);
 207       return init_method_MemberName(mname, info);
 208     }
 209   } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {
 210     oop clazz  = java_lang_reflect_Constructor::clazz(target_oop);
 211     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 212     Klass* k = java_lang_Class::as_Klass(clazz);
 213     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 214       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 215       if (m == NULL)  return NULL;
 216       CallInfo info(m, k, CHECK_NULL);
 217       return init_method_MemberName(mname, info);
 218     }
 219   }
 220   return NULL;
 221 }
 222 
 223 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 224   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 225   methodHandle m(Thread::current(), info.resolved_method());
 226   assert(m.not_null(), &quot;null method handle&quot;);
 227   InstanceKlass* m_klass = m-&gt;method_holder();
 228   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 229   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 230   int vmindex = Method::invalid_vtable_index;
 231 
 232   switch (info.call_kind()) {
 233   case CallInfo::itable_call:
 234     vmindex = info.itable_index();
 235     // More importantly, the itable index only works with the method holder.
 236     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 237     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
 238     if (TraceInvokeDynamic) {
 239       ttyLocker ttyl;
 240       ResourceMark rm;
 241       tty-&gt;print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,
 242             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 243             vmindex);
 244        m-&gt;access_flags().print_on(tty);
 245        if (!m-&gt;is_abstract()) {
 246          if (!m-&gt;is_private()) {
 247            tty-&gt;print(&quot;default&quot;);
 248          }
 249          else {
 250            tty-&gt;print(&quot;private-intf&quot;);
 251          }
 252        }
 253        tty-&gt;cr();
 254     }
 255     break;
 256 
 257   case CallInfo::vtable_call:
 258     vmindex = info.vtable_index();
 259     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 260     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 261     if (m_klass-&gt;is_interface()) {
 262       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 263       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 264       // (LinkResolver should help us figure this out.)
 265       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 266       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 267       if (m_klass_non_interface-&gt;is_interface()) {
 268         m_klass_non_interface = SystemDictionary::Object_klass();
 269 #ifdef ASSERT
 270         { ResourceMark rm;
 271           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 272           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 273                  &quot;at %d, %s != %s&quot;, vmindex,
 274                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 275         }
 276 #endif //ASSERT
 277       }
 278       if (!m-&gt;is_public()) {
 279         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 280         return NULL;  // elicit an error later in product build
 281       }
 282       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 283       m_klass = m_klass_non_interface;
 284     }
 285     if (TraceInvokeDynamic) {
 286       ttyLocker ttyl;
 287       ResourceMark rm;
 288       tty-&gt;print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,
 289             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),
 290             m_klass-&gt;internal_name(), vmindex);
 291        m-&gt;access_flags().print_on(tty);
 292        if (m-&gt;is_default_method()) {
 293          tty-&gt;print(&quot;default&quot;);
 294        }
 295        tty-&gt;cr();
 296     }
 297     break;
 298 
 299   case CallInfo::direct_call:
 300     vmindex = Method::nonvirtual_vtable_index;
 301     if (m-&gt;is_static()) {
 302       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 303     } else if (m-&gt;is_initializer()) {
 304       flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 305     } else {
 306       // &quot;special&quot; reflects that this is a direct call, not that it
 307       // necessarily originates from an invokespecial. We can also do
 308       // direct calls for private and/or final non-static methods.
 309       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 310     }
 311     break;
 312 
 313   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 314   }
 315 
 316   // @CallerSensitive annotation detected
 317   if (m-&gt;caller_sensitive()) {
 318     flags |= CALLER_SENSITIVE;
 319   }
 320 
 321   Handle resolved_method = info.resolved_method_name();
 322   assert(java_lang_invoke_ResolvedMethodName::vmtarget(resolved_method()) == m() || m-&gt;is_old(),
 323          &quot;Should not change after link resolution&quot;);
 324 
 325   oop mname_oop = mname();
 326   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 327   java_lang_invoke_MemberName::set_method (mname_oop, resolved_method());
 328   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);   // vtable/itable index
 329   java_lang_invoke_MemberName::set_clazz  (mname_oop, m_klass-&gt;java_mirror());
 330   // Note:  name and type can be lazily computed by resolve_MemberName,
 331   // if Java code needs them as resolved String and MethodType objects.
 332   // If relevant, the vtable or itable value is stored as vmindex.
 333   // This is done eagerly, since it is readily available without
 334   // constructing any new objects.
 335   return mname();
 336 }
 337 
 338 oop MethodHandles::init_field_MemberName(Handle mname, fieldDescriptor&amp; fd, bool is_setter) {
 339   int flags = (jushort)( fd.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS );
 340   flags |= IS_FIELD | ((fd.is_static() ? JVM_REF_getStatic : JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 341   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) &lt;&lt; REFERENCE_KIND_SHIFT);
 342   int vmindex        = fd.offset();  // determines the field uniquely when combined with static bit
 343 
 344   oop mname_oop = mname();
 345   java_lang_invoke_MemberName::set_flags  (mname_oop, flags);
 346   java_lang_invoke_MemberName::set_method (mname_oop, NULL);
 347   java_lang_invoke_MemberName::set_vmindex(mname_oop, vmindex);
 348   java_lang_invoke_MemberName::set_clazz  (mname_oop, fd.field_holder()-&gt;java_mirror());
 349 
 350   oop type = field_signature_type_or_null(fd.signature());
 351   oop name = field_name_or_null(fd.name());
 352   if (name != NULL)
 353     java_lang_invoke_MemberName::set_name(mname_oop,   name);
 354   if (type != NULL)
 355     java_lang_invoke_MemberName::set_type(mname_oop,   type);
 356   // Note:  name and type can be lazily computed by resolve_MemberName,
 357   // if Java code needs them as resolved String and Class objects.
 358   // Note that the incoming type oop might be pre-resolved (non-null).
 359   // The base clazz and field offset (vmindex) must be eagerly stored,
 360   // because they unambiguously identify the field.
 361   // Although the fieldDescriptor::_index would also identify the field,
 362   // we do not use it, because it is harder to decode.
 363   // TO DO: maybe intern mname_oop
 364   return mname();
 365 }
 366 
 367 // JVM 2.9 Special Methods:
 368 // A method is signature polymorphic if and only if all of the following conditions hold :
 369 // * It is declared in the java.lang.invoke.MethodHandle/VarHandle classes.
 370 // * It has a single formal parameter of type Object[].
 371 // * It has a return type of Object for a polymorphic return type, otherwise a fixed return type.
 372 // * It has the ACC_VARARGS and ACC_NATIVE flags set.
 373 bool MethodHandles::is_method_handle_invoke_name(Klass* klass, Symbol* name) {
 374   if (klass == NULL)
 375     return false;
 376   // The following test will fail spuriously during bootstrap of MethodHandle itself:
 377   //    if (klass != SystemDictionary::MethodHandle_klass())
 378   // Test the name instead:
 379   if (klass-&gt;name() != vmSymbols::java_lang_invoke_MethodHandle() &amp;&amp;
 380       klass-&gt;name() != vmSymbols::java_lang_invoke_VarHandle()) {
 381     return false;
 382   }
 383 
 384   // Look up signature polymorphic method with polymorphic return type
 385   Symbol* poly_sig = vmSymbols::object_array_object_signature();
 386   InstanceKlass* iklass = InstanceKlass::cast(klass);
 387   Method* m = iklass-&gt;find_method(name, poly_sig);
 388   if (m != NULL) {
 389     int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS;
 390     int flags = m-&gt;access_flags().as_int();
 391     if ((flags &amp; required) == required) {
 392       return true;
 393     }
 394   }
 395 
 396   // Look up signature polymorphic method with non-polymorphic (non Object) return type
 397   int me;
 398   int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 399   if (ms == -1) return false;
 400   for (; ms &lt; me; ms++) {
 401     Method* m = iklass-&gt;methods()-&gt;at(ms);
 402     int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS;
 403     int flags = m-&gt;access_flags().as_int();
 404     if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 405       return true;
 406     }
 407   }
 408   return false;
 409 }
 410 
 411 
 412 Symbol* MethodHandles::signature_polymorphic_intrinsic_name(vmIntrinsics::ID iid) {
 413   assert(is_signature_polymorphic_intrinsic(iid), &quot;%d %s&quot;, iid, vmIntrinsics::name_at(iid));
 414   switch (iid) {
 415   case vmIntrinsics::_invokeBasic:      return vmSymbols::invokeBasic_name();
 416   case vmIntrinsics::_linkToVirtual:    return vmSymbols::linkToVirtual_name();
 417   case vmIntrinsics::_linkToStatic:     return vmSymbols::linkToStatic_name();
 418   case vmIntrinsics::_linkToSpecial:    return vmSymbols::linkToSpecial_name();
 419   case vmIntrinsics::_linkToInterface:  return vmSymbols::linkToInterface_name();
 420   default:
 421     fatal(&quot;unexpected intrinsic id: %d %s&quot;, iid, vmIntrinsics::name_at(iid));
 422     return 0;
 423   }
 424 }
 425 
 426 Bytecodes::Code MethodHandles::signature_polymorphic_intrinsic_bytecode(vmIntrinsics::ID id) {
 427   switch(id) {
 428     case vmIntrinsics::_linkToVirtual:   return Bytecodes::_invokevirtual;
 429     case vmIntrinsics::_linkToInterface: return Bytecodes::_invokeinterface;
 430     case vmIntrinsics::_linkToStatic:    return Bytecodes::_invokestatic;
 431     case vmIntrinsics::_linkToSpecial:   return Bytecodes::_invokespecial;
 432     case vmIntrinsics::_invokeBasic:     return Bytecodes::_invokehandle;
 433     default:
 434       fatal(&quot;unexpected id: (%d) %s&quot;, (uint)id, vmIntrinsics::name_at(id));
 435       return Bytecodes::_illegal;
 436   }
 437 }
 438 
 439 int MethodHandles::signature_polymorphic_intrinsic_ref_kind(vmIntrinsics::ID iid) {
 440   switch (iid) {
 441   case vmIntrinsics::_invokeBasic:      return 0;
 442   case vmIntrinsics::_linkToVirtual:    return JVM_REF_invokeVirtual;
 443   case vmIntrinsics::_linkToStatic:     return JVM_REF_invokeStatic;
 444   case vmIntrinsics::_linkToSpecial:    return JVM_REF_invokeSpecial;
 445   case vmIntrinsics::_linkToInterface:  return JVM_REF_invokeInterface;
 446   default:
 447     fatal(&quot;unexpected intrinsic id: %d %s&quot;, iid, vmIntrinsics::name_at(iid));
 448     return 0;
 449   }
 450 }
 451 
 452 vmIntrinsics::ID MethodHandles::signature_polymorphic_name_id(Symbol* name) {
 453   vmSymbols::SID name_id = vmSymbols::find_sid(name);
 454   switch (name_id) {
 455   // The ID _invokeGeneric stands for all non-static signature-polymorphic methods, except built-ins.
 456   case vmSymbols::VM_SYMBOL_ENUM_NAME(invoke_name):           return vmIntrinsics::_invokeGeneric;
 457   // The only built-in non-static signature-polymorphic method is MethodHandle.invokeBasic:
 458   case vmSymbols::VM_SYMBOL_ENUM_NAME(invokeBasic_name):      return vmIntrinsics::_invokeBasic;
 459 
 460   // There is one static signature-polymorphic method for each JVM invocation mode.
 461   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;
 462   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;
 463   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;
 464   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;
 465   default:                                                    break;
 466   }
 467 
 468   // Cover the case of invokeExact and any future variants of invokeFoo.
 469   Klass* mh_klass = SystemDictionary::well_known_klass(
 470                               SystemDictionary::WK_KLASS_ENUM_NAME(MethodHandle_klass) );
 471   if (mh_klass != NULL &amp;&amp; is_method_handle_invoke_name(mh_klass, name)) {
 472     return vmIntrinsics::_invokeGeneric;
 473   }
 474 
 475   // Cover the case of methods on VarHandle.
 476   Klass* vh_klass = SystemDictionary::well_known_klass(
 477                               SystemDictionary::WK_KLASS_ENUM_NAME(VarHandle_klass) );
 478   if (vh_klass != NULL &amp;&amp; is_method_handle_invoke_name(vh_klass, name)) {
 479     return vmIntrinsics::_invokeGeneric;
 480   }
 481 
 482   // Note: The pseudo-intrinsic _compiledLambdaForm is never linked against.
 483   // Instead it is used to mark lambda forms bound to invokehandle or invokedynamic.
 484   return vmIntrinsics::_none;
 485 }
 486 
 487 vmIntrinsics::ID MethodHandles::signature_polymorphic_name_id(Klass* klass, Symbol* name) {
 488   if (klass != NULL &amp;&amp;
 489       (klass-&gt;name() == vmSymbols::java_lang_invoke_MethodHandle() ||
 490        klass-&gt;name() == vmSymbols::java_lang_invoke_VarHandle())) {
 491     vmIntrinsics::ID iid = signature_polymorphic_name_id(name);
 492     if (iid != vmIntrinsics::_none)
 493       return iid;
 494     if (is_method_handle_invoke_name(klass, name))
 495       return vmIntrinsics::_invokeGeneric;
 496   }
 497   return vmIntrinsics::_none;
 498 }
 499 
 500 // Returns true if method is signature polymorphic and public
 501 bool MethodHandles::is_signature_polymorphic_public_name(Klass* klass, Symbol* name) {
 502   if (is_signature_polymorphic_name(klass, name)) {
 503     InstanceKlass* iklass = InstanceKlass::cast(klass);
 504     int me;
 505     int ms = iklass-&gt;find_method_by_name(name, &amp;me);
 506     assert(ms != -1, &quot;&quot;);
 507     for (; ms &lt; me; ms++) {
 508       Method* m = iklass-&gt;methods()-&gt;at(ms);
 509       int required = JVM_ACC_NATIVE | JVM_ACC_VARARGS | JVM_ACC_PUBLIC;
 510       int flags = m-&gt;access_flags().as_int();
 511       if ((flags &amp; required) == required &amp;&amp; ArgumentCount(m-&gt;signature()).size() == 1) {
 512         return true;
 513       }
 514     }
 515   }
 516   return false;
 517 }
 518 
 519 // convert the external string or reflective type to an internal signature
 520 Symbol* MethodHandles::lookup_signature(oop type_str, bool intern_if_not_found, TRAPS) {
 521   if (java_lang_invoke_MethodType::is_instance(type_str)) {
 522     return java_lang_invoke_MethodType::as_signature(type_str, intern_if_not_found);
 523   } else if (java_lang_Class::is_instance(type_str)) {
 524     return java_lang_Class::as_signature(type_str, false);
 525   } else if (java_lang_String::is_instance_inlined(type_str)) {
 526     if (intern_if_not_found) {
 527       return java_lang_String::as_symbol(type_str);
 528     } else {
 529       return java_lang_String::as_symbol_or_null(type_str);
 530     }
 531   } else {
 532     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized type&quot;, NULL);
 533   }
 534 }
 535 
 536 static const char OBJ_SIG[] = &quot;Ljava/lang/Object;&quot;;
 537 enum { OBJ_SIG_LEN = 18 };
 538 
 539 bool MethodHandles::is_basic_type_signature(Symbol* sig) {
 540   assert(vmSymbols::object_signature()-&gt;utf8_length() == (int)OBJ_SIG_LEN, &quot;&quot;);
 541   assert(vmSymbols::object_signature()-&gt;equals(OBJ_SIG), &quot;&quot;);
<a name="1" id="anc1"></a><span class="line-modified"> 542   const int len = sig-&gt;utf8_length();</span>
<span class="line-modified"> 543   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified"> 544     switch (sig-&gt;char_at(i)) {</span>
<span class="line-removed"> 545     case JVM_SIGNATURE_CLASS:</span>
 546       // only java/lang/Object is valid here
<a name="2" id="anc2"></a><span class="line-modified"> 547       if (sig-&gt;index_of_at(i, OBJ_SIG, OBJ_SIG_LEN) != i)</span>
 548         return false;
<a name="3" id="anc3"></a><span class="line-modified"> 549       i += OBJ_SIG_LEN-1;  //-1 because of i++ in loop</span>
<span class="line-modified"> 550       continue;</span>
<span class="line-modified"> 551     case JVM_SIGNATURE_FUNC:</span>
<span class="line-modified"> 552     case JVM_SIGNATURE_ENDFUNC:</span>
<span class="line-modified"> 553     case JVM_SIGNATURE_VOID:</span>
<span class="line-modified"> 554     case JVM_SIGNATURE_INT:</span>
<span class="line-modified"> 555     case JVM_SIGNATURE_LONG:</span>
<span class="line-removed"> 556     case JVM_SIGNATURE_FLOAT:</span>
<span class="line-removed"> 557     case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-removed"> 558       continue;</span>
 559     default:
<a name="4" id="anc4"></a><span class="line-modified"> 560       // subword types (T_BYTE etc.), arrays</span>
 561       return false;
 562     }
 563   }
 564   return true;
 565 }
 566 
 567 Symbol* MethodHandles::lookup_basic_type_signature(Symbol* sig, bool keep_last_arg, TRAPS) {
 568   Symbol* bsig = NULL;
 569   if (sig == NULL) {
 570     return sig;
 571   } else if (is_basic_type_signature(sig)) {
 572     sig-&gt;increment_refcount();
 573     return sig;  // that was easy
<a name="5" id="anc5"></a><span class="line-modified"> 574   } else if (sig-&gt;char_at(0) != JVM_SIGNATURE_FUNC) {</span>
<span class="line-modified"> 575     BasicType bt = char2type(sig-&gt;char_at(0));</span>
 576     if (is_subword_type(bt)) {
 577       bsig = vmSymbols::int_signature();
 578     } else {
 579       assert(is_reference_type(bt), &quot;is_basic_type_signature was false&quot;);
 580       bsig = vmSymbols::object_signature();
 581     }
 582   } else {
 583     ResourceMark rm;
 584     stringStream buffer(128);
 585     buffer.put(JVM_SIGNATURE_FUNC);
 586     int arg_pos = 0, keep_arg_pos = -1;
 587     if (keep_last_arg)
 588       keep_arg_pos = ArgumentCount(sig).size() - 1;
 589     for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {
 590       BasicType bt = ss.type();
 591       size_t this_arg_pos = buffer.size();
 592       if (ss.at_return_type()) {
 593         buffer.put(JVM_SIGNATURE_ENDFUNC);
 594       }
 595       if (arg_pos == keep_arg_pos) {
 596         buffer.write((char*) ss.raw_bytes(),
 597                      (int)   ss.raw_length());
 598       } else if (is_reference_type(bt)) {
 599         buffer.write(OBJ_SIG, OBJ_SIG_LEN);
 600       } else {
 601         if (is_subword_type(bt))
 602           bt = T_INT;
 603         buffer.put(type2char(bt));
 604       }
 605       arg_pos++;
 606     }
 607     const char* sigstr =       buffer.base();
 608     int         siglen = (int) buffer.size();
 609     bsig = SymbolTable::new_symbol(sigstr, siglen);
 610   }
 611   assert(is_basic_type_signature(bsig) ||
 612          // detune assert in case the injected argument is not a basic type:
 613          keep_last_arg, &quot;&quot;);
 614   return bsig;
 615 }
 616 
 617 void MethodHandles::print_as_basic_type_signature_on(outputStream* st,
<a name="6" id="anc6"></a><span class="line-modified"> 618                                                      Symbol* sig,</span>
<span class="line-removed"> 619                                                      bool keep_arrays,</span>
<span class="line-removed"> 620                                                      bool keep_basic_names) {</span>
 621   st = st ? st : tty;
<a name="7" id="anc7"></a><span class="line-removed"> 622   int len  = sig-&gt;utf8_length();</span>
<span class="line-removed"> 623   int array = 0;</span>
 624   bool prev_type = false;
<a name="8" id="anc8"></a><span class="line-modified"> 625   for (int i = 0; i &lt; len; i++) {</span>
<span class="line-modified"> 626     char ch = sig-&gt;char_at(i);</span>
<span class="line-modified"> 627     switch (ch) {</span>
<span class="line-modified"> 628     case JVM_SIGNATURE_FUNC:</span>
<span class="line-modified"> 629     case JVM_SIGNATURE_ENDFUNC:</span>
<span class="line-modified"> 630       prev_type = false;</span>
<span class="line-modified"> 631       st-&gt;put(ch);</span>
<span class="line-modified"> 632       continue;</span>
<span class="line-modified"> 633     case JVM_SIGNATURE_ARRAY:</span>
<span class="line-modified"> 634       if (!keep_basic_names &amp;&amp; keep_arrays)</span>
<span class="line-modified"> 635         st-&gt;put(ch);</span>
<span class="line-modified"> 636       array++;</span>
<span class="line-modified"> 637       continue;</span>
<span class="line-modified"> 638     case JVM_SIGNATURE_CLASS:</span>
<span class="line-modified"> 639       {</span>
<span class="line-modified"> 640         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-removed"> 641         int start = i+1, slash = start;</span>
<span class="line-removed"> 642         while (++i &lt; len &amp;&amp; (ch = sig-&gt;char_at(i)) != JVM_SIGNATURE_ENDCLASS) {</span>
<span class="line-removed"> 643           if (ch == JVM_SIGNATURE_SLASH || ch == JVM_SIGNATURE_DOT || ch == &#39;$&#39;)  slash = i+1;</span>
<span class="line-removed"> 644         }</span>
<span class="line-removed"> 645         if (slash &lt; i)  start = slash;</span>
<span class="line-removed"> 646         if (!keep_basic_names) {</span>
<span class="line-removed"> 647           st-&gt;put(JVM_SIGNATURE_CLASS);</span>
<span class="line-removed"> 648         } else {</span>
<span class="line-removed"> 649           for (int j = start; j &lt; i; j++)</span>
<span class="line-removed"> 650             st-&gt;put(sig-&gt;char_at(j));</span>
<span class="line-removed"> 651           prev_type = true;</span>
<span class="line-removed"> 652         }</span>
<span class="line-removed"> 653         break;</span>
<span class="line-removed"> 654       }</span>
<span class="line-removed"> 655     default:</span>
<span class="line-removed"> 656       {</span>
<span class="line-removed"> 657         if (array &amp;&amp; char2type(ch) != T_ILLEGAL &amp;&amp; !keep_arrays) {</span>
<span class="line-removed"> 658           ch = JVM_SIGNATURE_ARRAY;</span>
<span class="line-removed"> 659           array = 0;</span>
<span class="line-removed"> 660         }</span>
<span class="line-removed"> 661         if (prev_type)  st-&gt;put(&#39;,&#39;);</span>
<span class="line-removed"> 662         const char* n = NULL;</span>
<span class="line-removed"> 663         if (keep_basic_names)</span>
<span class="line-removed"> 664           n = type2name(char2type(ch));</span>
<span class="line-removed"> 665         if (n == NULL) {</span>
<span class="line-removed"> 666           // unknown letter, or we don&#39;t want to know its name</span>
<span class="line-removed"> 667           st-&gt;put(ch);</span>
<span class="line-removed"> 668         } else {</span>
<span class="line-removed"> 669           st-&gt;print(&quot;%s&quot;, n);</span>
<span class="line-removed"> 670           prev_type = true;</span>
<span class="line-removed"> 671         }</span>
<span class="line-removed"> 672         break;</span>
<span class="line-removed"> 673       }</span>
<span class="line-removed"> 674     }</span>
<span class="line-removed"> 675     // Switch break goes here to take care of array suffix:</span>
<span class="line-removed"> 676     if (prev_type) {</span>
<span class="line-removed"> 677       while (array &gt; 0) {</span>
<span class="line-removed"> 678         st-&gt;print(&quot;[]&quot;);</span>
<span class="line-removed"> 679         --array;</span>
<span class="line-removed"> 680       }</span>
 681     }
<a name="9" id="anc9"></a><span class="line-removed"> 682     array = 0;</span>
 683   }
 684 }
 685 
 686 
 687 
 688 static oop object_java_mirror() {
 689   return SystemDictionary::Object_klass()-&gt;java_mirror();
 690 }
 691 
 692 oop MethodHandles::field_name_or_null(Symbol* s) {
 693   if (s == NULL)  return NULL;
 694   return StringTable::lookup(s);
 695 }
 696 
 697 oop MethodHandles::field_signature_type_or_null(Symbol* s) {
 698   if (s == NULL)  return NULL;
<a name="10" id="anc10"></a><span class="line-modified"> 699   BasicType bt = FieldType::basic_type(s);</span>
 700   if (is_java_primitive(bt)) {
 701     assert(s-&gt;utf8_length() == 1, &quot;&quot;);
 702     return java_lang_Class::primitive_mirror(bt);
 703   }
 704   // Here are some more short cuts for common types.
 705   // They are optional, since reference types can be resolved lazily.
 706   if (bt == T_OBJECT) {
 707     if (s == vmSymbols::object_signature()) {
 708       return object_java_mirror();
 709     } else if (s == vmSymbols::class_signature()) {
 710       return SystemDictionary::Class_klass()-&gt;java_mirror();
 711     } else if (s == vmSymbols::string_signature()) {
 712       return SystemDictionary::String_klass()-&gt;java_mirror();
 713     }
 714   }
 715   return NULL;
 716 }
 717 
 718 
 719 // An unresolved member name is a mere symbolic reference.
 720 // Resolving it plants a vmtarget/vmindex in it,
 721 // which refers directly to JVM internals.
 722 Handle MethodHandles::resolve_MemberName(Handle mname, Klass* caller,
 723                                          bool speculative_resolve, TRAPS) {
 724   Handle empty;
 725   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 726 
 727   if (java_lang_invoke_MemberName::vmtarget(mname()) != NULL) {
 728     // Already resolved.
 729     DEBUG_ONLY(int vmindex = java_lang_invoke_MemberName::vmindex(mname()));
 730     assert(vmindex &gt;= Method::nonvirtual_vtable_index, &quot;&quot;);
 731     return mname;
 732   }
 733 
 734   Handle defc_oop(THREAD, java_lang_invoke_MemberName::clazz(mname()));
 735   Handle name_str(THREAD, java_lang_invoke_MemberName::name( mname()));
 736   Handle type_str(THREAD, java_lang_invoke_MemberName::type( mname()));
 737   int    flags    =       java_lang_invoke_MemberName::flags(mname());
 738   int    ref_kind =       (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
 739   if (!ref_kind_is_valid(ref_kind)) {
 740     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;, empty);
 741   }
 742 
 743   DEBUG_ONLY(int old_vmindex);
 744   assert((old_vmindex = java_lang_invoke_MemberName::vmindex(mname())) == 0, &quot;clean input&quot;);
 745 
 746   if (defc_oop.is_null() || name_str.is_null() || type_str.is_null()) {
 747     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to resolve&quot;, empty);
 748   }
 749 
 750   InstanceKlass* defc = NULL;
 751   {
 752     Klass* defc_klass = java_lang_Class::as_Klass(defc_oop());
 753     if (defc_klass == NULL)  return empty;  // a primitive; no resolution possible
 754     if (!defc_klass-&gt;is_instance_klass()) {
 755       if (!defc_klass-&gt;is_array_klass())  return empty;
 756       defc_klass = SystemDictionary::Object_klass();
 757     }
 758     defc = InstanceKlass::cast(defc_klass);
 759   }
 760   if (defc == NULL) {
 761     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;primitive class&quot;, empty);
 762   }
 763   defc-&gt;link_class(CHECK_(empty));  // possible safepoint
 764 
 765   // convert the external string name to an internal symbol
 766   TempNewSymbol name = java_lang_String::as_symbol_or_null(name_str());
 767   if (name == NULL)  return empty;  // no such name
 768   if (name == vmSymbols::class_initializer_name())
 769     return empty; // illegal name
 770 
 771   vmIntrinsics::ID mh_invoke_id = vmIntrinsics::_none;
 772   if ((flags &amp; ALL_KINDS) == IS_METHOD &amp;&amp;
 773       (defc == SystemDictionary::MethodHandle_klass() || defc == SystemDictionary::VarHandle_klass()) &amp;&amp;
 774       (ref_kind == JVM_REF_invokeVirtual ||
 775        ref_kind == JVM_REF_invokeSpecial ||
 776        // static invocation mode is required for _linkToVirtual, etc.:
 777        ref_kind == JVM_REF_invokeStatic)) {
 778     vmIntrinsics::ID iid = signature_polymorphic_name_id(name);
 779     if (iid != vmIntrinsics::_none &amp;&amp;
 780         ((ref_kind == JVM_REF_invokeStatic) == is_signature_polymorphic_static(iid))) {
 781       // Virtual methods invoke and invokeExact, plus internal invokers like _invokeBasic.
 782       // For a static reference it could an internal linkage routine like _linkToVirtual, etc.
 783       mh_invoke_id = iid;
 784     }
 785   }
 786 
 787   // convert the external string or reflective type to an internal signature
 788   TempNewSymbol type = lookup_signature(type_str(), (mh_invoke_id != vmIntrinsics::_none), CHECK_(empty));
 789   if (type == NULL)  return empty;  // no such signature exists in the VM
 790 
 791   LinkInfo::AccessCheck access_check = caller != NULL ?
 792                                               LinkInfo::needs_access_check :
 793                                               LinkInfo::skip_access_check;
 794 
 795   // Time to do the lookup.
 796   switch (flags &amp; ALL_KINDS) {
 797   case IS_METHOD:
 798     {
 799       CallInfo result;
 800       LinkInfo link_info(defc, name, type, caller, access_check);
 801       {
 802         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 803         if (ref_kind == JVM_REF_invokeStatic) {
 804           LinkResolver::resolve_static_call(result,
 805                         link_info, false, THREAD);
 806         } else if (ref_kind == JVM_REF_invokeInterface) {
 807           LinkResolver::resolve_interface_call(result, Handle(), defc,
 808                         link_info, false, THREAD);
 809         } else if (mh_invoke_id != vmIntrinsics::_none) {
 810           assert(!is_signature_polymorphic_static(mh_invoke_id), &quot;&quot;);
 811           LinkResolver::resolve_handle_call(result, link_info, THREAD);
 812         } else if (ref_kind == JVM_REF_invokeSpecial) {
 813           LinkResolver::resolve_special_call(result, Handle(),
 814                         link_info, THREAD);
 815         } else if (ref_kind == JVM_REF_invokeVirtual) {
 816           LinkResolver::resolve_virtual_call(result, Handle(), defc,
 817                         link_info, false, THREAD);
 818         } else {
 819           assert(false, &quot;ref_kind=%d&quot;, ref_kind);
 820         }
 821         if (HAS_PENDING_EXCEPTION) {
 822           if (speculative_resolve) {
 823             CLEAR_PENDING_EXCEPTION;
 824           }
 825           return empty;
 826         }
 827       }
 828       if (result.resolved_appendix().not_null()) {
 829         // The resolved MemberName must not be accompanied by an appendix argument,
 830         // since there is no way to bind this value into the MemberName.
 831         // Caller is responsible to prevent this from happening.
 832         THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;appendix&quot;, empty);
 833       }
 834       result.set_resolved_method_name(CHECK_(empty));
 835       oop mname2 = init_method_MemberName(mname, result);
 836       return Handle(THREAD, mname2);
 837     }
 838   case IS_CONSTRUCTOR:
 839     {
 840       CallInfo result;
 841       LinkInfo link_info(defc, name, type, caller, access_check);
 842       {
 843         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 844         if (name == vmSymbols::object_initializer_name()) {
 845           LinkResolver::resolve_special_call(result, Handle(), link_info, THREAD);
 846         } else {
 847           break;                // will throw after end of switch
 848         }
 849         if (HAS_PENDING_EXCEPTION) {
 850           if (speculative_resolve) {
 851             CLEAR_PENDING_EXCEPTION;
 852           }
 853           return empty;
 854         }
 855       }
 856       assert(result.is_statically_bound(), &quot;&quot;);
 857       result.set_resolved_method_name(CHECK_(empty));
 858       oop mname2 = init_method_MemberName(mname, result);
 859       return Handle(THREAD, mname2);
 860     }
 861   case IS_FIELD:
 862     {
 863       fieldDescriptor result; // find_field initializes fd if found
 864       {
 865         assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);
 866         LinkInfo link_info(defc, name, type, caller, LinkInfo::skip_access_check);
 867         LinkResolver::resolve_field(result, link_info, Bytecodes::_nop, false, THREAD);
 868         if (HAS_PENDING_EXCEPTION) {
 869           if (speculative_resolve) {
 870             CLEAR_PENDING_EXCEPTION;
 871           }
 872           return empty;
 873         }
 874       }
 875       oop mname2 = init_field_MemberName(mname, result, ref_kind_is_setter(ref_kind));
 876       return Handle(THREAD, mname2);
 877     }
 878   default:
 879     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;, empty);
 880   }
 881 
 882   return empty;
 883 }
 884 
 885 // Conversely, a member name which is only initialized from JVM internals
 886 // may have null defc, name, and type fields.
 887 // Resolving it plants a vmtarget/vmindex in it,
 888 // which refers directly to JVM internals.
 889 void MethodHandles::expand_MemberName(Handle mname, int suppress, TRAPS) {
 890   assert(java_lang_invoke_MemberName::is_instance(mname()), &quot;&quot;);
 891 
 892   bool have_defc = (java_lang_invoke_MemberName::clazz(mname()) != NULL);
 893   bool have_name = (java_lang_invoke_MemberName::name(mname()) != NULL);
 894   bool have_type = (java_lang_invoke_MemberName::type(mname()) != NULL);
 895   int flags      = java_lang_invoke_MemberName::flags(mname());
 896 
 897   if (suppress != 0) {
 898     if (suppress &amp; _suppress_defc)  have_defc = true;
 899     if (suppress &amp; _suppress_name)  have_name = true;
 900     if (suppress &amp; _suppress_type)  have_type = true;
 901   }
 902 
 903   if (have_defc &amp;&amp; have_name &amp;&amp; have_type)  return;  // nothing needed
 904 
 905   switch (flags &amp; ALL_KINDS) {
 906   case IS_METHOD:
 907   case IS_CONSTRUCTOR:
 908     {
 909       Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
 910       if (vmtarget == NULL) {
 911         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand&quot;);
 912       }
 913       methodHandle m(THREAD, vmtarget);
 914       DEBUG_ONLY(vmtarget = NULL);  // safety
 915       if (!have_defc) {
 916         InstanceKlass* defc = m-&gt;method_holder();
 917         java_lang_invoke_MemberName::set_clazz(mname(), defc-&gt;java_mirror());
 918       }
 919       if (!have_name) {
 920         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 921         oop name = StringTable::intern(m-&gt;name(), CHECK);
 922         java_lang_invoke_MemberName::set_name(mname(), name);
 923       }
 924       if (!have_type) {
 925         Handle type = java_lang_String::create_from_symbol(m-&gt;signature(), CHECK);
 926         java_lang_invoke_MemberName::set_type(mname(), type());
 927       }
 928       return;
 929     }
 930   case IS_FIELD:
 931     {
 932       oop clazz = java_lang_invoke_MemberName::clazz(mname());
 933       if (clazz == NULL) {
 934         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;nothing to expand (as field)&quot;);
 935       }
 936       InstanceKlass* defc = InstanceKlass::cast(java_lang_Class::as_Klass(clazz));
 937       DEBUG_ONLY(clazz = NULL);  // safety
 938       int vmindex  = java_lang_invoke_MemberName::vmindex(mname());
 939       bool is_static = ((flags &amp; JVM_ACC_STATIC) != 0);
 940       fieldDescriptor fd; // find_field initializes fd if found
 941       if (!defc-&gt;find_field_from_offset(vmindex, is_static, &amp;fd))
 942         break;                  // cannot expand
 943       if (!have_name) {
 944         //not java_lang_String::create_from_symbol; let&#39;s intern member names
 945         oop name = StringTable::intern(fd.name(), CHECK);
 946         java_lang_invoke_MemberName::set_name(mname(), name);
 947       }
 948       if (!have_type) {
 949         // If it is a primitive field type, don&#39;t mess with short strings like &quot;I&quot;.
 950         Handle type (THREAD, field_signature_type_or_null(fd.signature()));
 951         if (type.is_null()) {
 952           type = java_lang_String::create_from_symbol(fd.signature(), CHECK);
 953         }
 954         java_lang_invoke_MemberName::set_type(mname(), type());
 955       }
 956       return;
 957     }
 958   }
 959   THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;unrecognized MemberName format&quot;);
 960 }
 961 
 962 int MethodHandles::find_MemberNames(Klass* k,
 963                                     Symbol* name, Symbol* sig,
 964                                     int mflags, Klass* caller,
 965                                     int skip, objArrayHandle results, TRAPS) {
 966   // %%% take caller into account!
 967 
 968   Thread* thread = Thread::current();
 969 
 970   if (k == NULL || !k-&gt;is_instance_klass())  return -1;
 971 
 972   int rfill = 0, rlimit = results-&gt;length(), rskip = skip;
 973   // overflow measurement:
 974   int overflow = 0, overflow_limit = MAX2(1000, rlimit);
 975 
 976   int match_flags = mflags;
 977   bool search_superc = ((match_flags &amp; SEARCH_SUPERCLASSES) != 0);
 978   bool search_intfc  = ((match_flags &amp; SEARCH_INTERFACES)   != 0);
 979   bool local_only = !(search_superc | search_intfc);
 980 
 981   if (name != NULL) {
 982     if (name-&gt;utf8_length() == 0)  return 0; // a match is not possible
 983   }
 984   if (sig != NULL) {
<a name="11" id="anc11"></a><span class="line-modified"> 985     if (sig-&gt;utf8_length() == 0)  return 0; // a match is not possible</span>
<span class="line-removed"> 986     if (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC)</span>
 987       match_flags &amp;= ~(IS_FIELD | IS_TYPE);
 988     else
 989       match_flags &amp;= ~(IS_CONSTRUCTOR | IS_METHOD);
 990   }
 991 
 992   if ((match_flags &amp; IS_TYPE) != 0) {
 993     // NYI, and Core Reflection works quite well for this query
 994   }
 995 
 996   if ((match_flags &amp; IS_FIELD) != 0) {
 997     InstanceKlass* ik = InstanceKlass::cast(k);
 998     for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
 999       if (name != NULL &amp;&amp; st.name() != name)
1000           continue;
1001       if (sig != NULL &amp;&amp; st.signature() != sig)
1002         continue;
1003       // passed the filters
1004       if (rskip &gt; 0) {
1005         --rskip;
1006       } else if (rfill &lt; rlimit) {
1007         Handle result(thread, results-&gt;obj_at(rfill++));
1008         if (!java_lang_invoke_MemberName::is_instance(result()))
1009           return -99;  // caller bug!
1010         oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());
1011         if (saved != result())
1012           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1013       } else if (++overflow &gt;= overflow_limit) {
1014         match_flags = 0; break; // got tired of looking at overflow
1015       }
1016     }
1017   }
1018 
1019   if ((match_flags &amp; (IS_METHOD | IS_CONSTRUCTOR)) != 0) {
1020     // watch out for these guys:
1021     Symbol* init_name   = vmSymbols::object_initializer_name();
1022     Symbol* clinit_name = vmSymbols::class_initializer_name();
1023     if (name == clinit_name)  clinit_name = NULL; // hack for exposing &lt;clinit&gt;
1024     bool negate_name_test = false;
1025     // fix name so that it captures the intention of IS_CONSTRUCTOR
1026     if (!(match_flags &amp; IS_METHOD)) {
1027       // constructors only
1028       if (name == NULL) {
1029         name = init_name;
1030       } else if (name != init_name) {
1031         return 0;               // no constructors of this method name
1032       }
1033     } else if (!(match_flags &amp; IS_CONSTRUCTOR)) {
1034       // methods only
1035       if (name == NULL) {
1036         name = init_name;
1037         negate_name_test = true; // if we see the name, we *omit* the entry
1038       } else if (name == init_name) {
1039         return 0;               // no methods of this constructor name
1040       }
1041     } else {
1042       // caller will accept either sort; no need to adjust name
1043     }
1044     InstanceKlass* ik = InstanceKlass::cast(k);
1045     for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {
1046       Method* m = st.method();
1047       Symbol* m_name = m-&gt;name();
1048       if (m_name == clinit_name)
1049         continue;
1050       if (name != NULL &amp;&amp; ((m_name != name) ^ negate_name_test))
1051           continue;
1052       if (sig != NULL &amp;&amp; m-&gt;signature() != sig)
1053         continue;
1054       // passed the filters
1055       if (rskip &gt; 0) {
1056         --rskip;
1057       } else if (rfill &lt; rlimit) {
1058         Handle result(thread, results-&gt;obj_at(rfill++));
1059         if (!java_lang_invoke_MemberName::is_instance(result()))
1060           return -99;  // caller bug!
1061         CallInfo info(m, NULL, CHECK_0);
1062         oop saved = MethodHandles::init_method_MemberName(result, info);
1063         if (saved != result())
1064           results-&gt;obj_at_put(rfill-1, saved);  // show saved instance to user
1065       } else if (++overflow &gt;= overflow_limit) {
1066         match_flags = 0; break; // got tired of looking at overflow
1067       }
1068     }
1069   }
1070 
1071   // return number of elements we at leasted wanted to initialize
1072   return rfill + overflow;
1073 }
1074 
1075 void MethodHandles::add_dependent_nmethod(oop call_site, nmethod* nm) {
1076   assert_locked_or_safepoint(CodeCache_lock);
1077 
1078   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1079   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1080   // Try to purge stale entries on updates.
1081   // Since GC doesn&#39;t clean dependency contexts rooted at CallSiteContext objects,
1082   // in order to avoid memory leak, stale entries are purged whenever a dependency list
1083   // is changed (both on addition and removal). Though memory reclamation is delayed,
1084   // it avoids indefinite memory usage growth.
1085   deps.add_dependent_nmethod(nm);
1086 }
1087 
1088 void MethodHandles::remove_dependent_nmethod(oop call_site, nmethod* nm) {
1089   assert_locked_or_safepoint(CodeCache_lock);
1090 
1091   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1092   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1093   deps.remove_dependent_nmethod(nm);
1094 }
1095 
1096 void MethodHandles::clean_dependency_context(oop call_site) {
1097   oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);
1098   DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1099   deps.clean_unloading_dependents();
1100 }
1101 
1102 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1103   assert_lock_strong(Compile_lock);
1104 
1105   int marked = 0;
1106   CallSiteDepChange changes(call_site, target);
1107   {
1108     NoSafepointVerifier nsv;
1109     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1110 
1111     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1112     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1113     marked = deps.mark_dependent_nmethods(changes);
1114   }
1115   if (marked &gt; 0) {
1116     // At least one nmethod has been marked for deoptimization.
1117     Deoptimization::deoptimize_all_marked();
1118   }
1119 }
1120 
1121 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
1122   if (TraceMethodHandles) {
1123     const char* name = vmIntrinsics::name_at(iid);
1124     if (*name == &#39;_&#39;)  name += 1;
1125     const size_t len = strlen(name) + 50;
1126     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1127     const char* suffix = &quot;&quot;;
1128     if (is_signature_polymorphic(iid)) {
1129       if (is_signature_polymorphic_static(iid))
1130         suffix = &quot;/static&quot;;
1131       else
1132         suffix = &quot;/private&quot;;
1133     }
1134     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1135     trace_method_handle(_masm, qname);
1136     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1137     // during runtime.
1138   }
1139 }
1140 
1141 //
1142 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1143 // They are the private interface between this JVM and the HotSpot-specific
1144 // Java code that implements JSR 292 method handles.
1145 //
1146 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1147 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1148 //
1149 
1150 #ifndef PRODUCT
1151 #define EACH_NAMED_CON(template, requirement) \
1152     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
1153     template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \
1154     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1155     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1156     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1157     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1158     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1159     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1160     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
1161     /*end*/
1162 
1163 #define IGNORE_REQ(req_expr) /* req_expr */
1164 #define ONE_PLUS(scope,value) 1+
1165 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1166 #define VALUE_COMMA(scope,value) scope::value,
1167 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1168 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1169 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1170 
1171 static bool advertise_con_value(int which) {
1172   if (which &lt; 0)  return false;
1173   bool ok = true;
1174   int count = 0;
1175 #define INC_COUNT(scope,value) \
1176   ++count;
1177 #define CHECK_REQ(req_expr) \
1178   if (which &lt; count)  return ok; \
1179   ok = (req_expr);
1180   EACH_NAMED_CON(INC_COUNT, CHECK_REQ);
1181 #undef INC_COUNT
1182 #undef CHECK_REQ
1183   assert(count == con_value_count, &quot;&quot;);
1184   if (which &lt; count)  return ok;
1185   return false;
1186 }
1187 
1188 #undef ONE_PLUS
1189 #undef VALUE_COMMA
1190 #undef STRING_NULL
1191 #undef EACH_NAMED_CON
1192 #endif // PRODUCT
1193 
1194 JVM_ENTRY(jint, MHN_getNamedCon(JNIEnv *env, jobject igcls, jint which, jobjectArray box_jh)) {
1195 #ifndef PRODUCT
1196   if (advertise_con_value(which)) {
1197     assert(which &gt;= 0 &amp;&amp; which &lt; con_value_count, &quot;&quot;);
1198     int con = con_values[which];
1199     objArrayHandle box(THREAD, (objArrayOop) JNIHandles::resolve(box_jh));
1200     if (box.not_null() &amp;&amp; box-&gt;klass() == Universe::objectArrayKlassObj() &amp;&amp; box-&gt;length() &gt; 0) {
1201       const char* str = &amp;con_names[0];
1202       for (int i = 0; i &lt; which; i++)
1203         str += strlen(str) + 1;   // skip name and null
1204       oop name = java_lang_String::create_oop_from_str(str, CHECK_0);  // possible safepoint
1205       box-&gt;obj_at_put(0, name);
1206     }
1207     return con;
1208   }
1209 #endif
1210   return 0;
1211 }
1212 JVM_END
1213 
1214 // void init(MemberName self, AccessibleObject ref)
1215 JVM_ENTRY(void, MHN_init_Mem(JNIEnv *env, jobject igcls, jobject mname_jh, jobject target_jh)) {
1216   if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1217   if (target_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;target is null&quot;); }
1218   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1219   Handle target(THREAD, JNIHandles::resolve_non_null(target_jh));
1220   MethodHandles::init_MemberName(mname, target, CHECK);
1221 }
1222 JVM_END
1223 
1224 // void expand(MemberName self)
1225 JVM_ENTRY(void, MHN_expand_Mem(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1226   if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1227   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1228   MethodHandles::expand_MemberName(mname, 0, CHECK);
1229 }
1230 JVM_END
1231 
1232 // void resolve(MemberName self, Class&lt;?&gt; caller)
1233 JVM_ENTRY(jobject, MHN_resolve_Mem(JNIEnv *env, jobject igcls, jobject mname_jh, jclass caller_jh,
1234     jboolean speculative_resolve)) {
1235   if (mname_jh == NULL) { THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;mname is null&quot;); }
1236   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1237 
1238   // The trusted Java code that calls this method should already have performed
1239   // access checks on behalf of the given caller.  But, we can verify this.
1240   if (VerifyMethodHandles &amp;&amp; caller_jh != NULL &amp;&amp;
1241       java_lang_invoke_MemberName::clazz(mname()) != NULL) {
1242     Klass* reference_klass = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
1243     if (reference_klass != NULL &amp;&amp; reference_klass-&gt;is_objArray_klass()) {
1244       reference_klass = ObjArrayKlass::cast(reference_klass)-&gt;bottom_klass();
1245     }
1246 
1247     // Reflection::verify_class_access can only handle instance classes.
1248     if (reference_klass != NULL &amp;&amp; reference_klass-&gt;is_instance_klass()) {
1249       // Emulate LinkResolver::check_klass_accessability.
1250       Klass* caller = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1251       if (caller != SystemDictionary::Object_klass()
1252           &amp;&amp; Reflection::verify_class_access(caller,
1253                                              InstanceKlass::cast(reference_klass),
1254                                              true) != Reflection::ACCESS_OK) {
1255         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), reference_klass-&gt;external_name());
1256       }
1257     }
1258   }
1259 
1260   Klass* caller = caller_jh == NULL ? NULL :
1261                      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(caller_jh));
1262   Handle resolved = MethodHandles::resolve_MemberName(mname, caller, speculative_resolve == JNI_TRUE,
1263                                                       CHECK_NULL);
1264 
1265   if (resolved.is_null()) {
1266     int flags = java_lang_invoke_MemberName::flags(mname());
1267     int ref_kind = (flags &gt;&gt; REFERENCE_KIND_SHIFT) &amp; REFERENCE_KIND_MASK;
1268     if (!MethodHandles::ref_kind_is_valid(ref_kind)) {
1269       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;obsolete MemberName format&quot;);
1270     }
1271     if (speculative_resolve) {
1272       assert(!HAS_PENDING_EXCEPTION, &quot;No exceptions expected when resolving speculatively&quot;);
1273       return NULL;
1274     }
1275     if ((flags &amp; ALL_KINDS) == IS_FIELD) {
1276       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchFieldError(), &quot;field resolution failed&quot;);
1277     } else if ((flags &amp; ALL_KINDS) == IS_METHOD ||
1278                (flags &amp; ALL_KINDS) == IS_CONSTRUCTOR) {
1279       THROW_MSG_NULL(vmSymbols::java_lang_NoSuchMethodError(), &quot;method resolution failed&quot;);
1280     } else {
1281       THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;resolution failed&quot;);
1282     }
1283   }
1284 
1285   return JNIHandles::make_local(THREAD, resolved());
1286 }
1287 JVM_END
1288 
1289 static jlong find_member_field_offset(oop mname, bool must_be_static, TRAPS) {
1290   if (mname == NULL ||
1291       java_lang_invoke_MemberName::clazz(mname) == NULL) {
1292     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;mname not resolved&quot;);
1293   } else {
1294     int flags = java_lang_invoke_MemberName::flags(mname);
1295     if ((flags &amp; IS_FIELD) != 0 &amp;&amp;
1296         (must_be_static
1297          ? (flags &amp; JVM_ACC_STATIC) != 0
1298          : (flags &amp; JVM_ACC_STATIC) == 0)) {
1299       int vmindex = java_lang_invoke_MemberName::vmindex(mname);
1300       return (jlong) vmindex;
1301     }
1302   }
1303   const char* msg = (must_be_static ? &quot;static field required&quot; : &quot;non-static field required&quot;);
1304   THROW_MSG_0(vmSymbols::java_lang_InternalError(), msg);
1305   return 0;
1306 }
1307 
1308 JVM_ENTRY(jlong, MHN_objectFieldOffset(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1309   return find_member_field_offset(JNIHandles::resolve(mname_jh), false, THREAD);
1310 }
1311 JVM_END
1312 
1313 JVM_ENTRY(jlong, MHN_staticFieldOffset(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1314   return find_member_field_offset(JNIHandles::resolve(mname_jh), true, THREAD);
1315 }
1316 JVM_END
1317 
1318 JVM_ENTRY(jobject, MHN_staticFieldBase(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1319   // use the other function to perform sanity checks:
1320   jlong ignore = find_member_field_offset(JNIHandles::resolve(mname_jh), true, CHECK_NULL);
1321   oop clazz = java_lang_invoke_MemberName::clazz(JNIHandles::resolve_non_null(mname_jh));
1322   return JNIHandles::make_local(THREAD, clazz);
1323 }
1324 JVM_END
1325 
1326 JVM_ENTRY(jobject, MHN_getMemberVMInfo(JNIEnv *env, jobject igcls, jobject mname_jh)) {
1327   if (mname_jh == NULL)  return NULL;
1328   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
1329   intptr_t vmindex  = java_lang_invoke_MemberName::vmindex(mname());
1330   objArrayHandle result = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 2, CHECK_NULL);
1331   jvalue vmindex_value; vmindex_value.j = (long)vmindex;
1332   oop x = java_lang_boxing_object::create(T_LONG, &amp;vmindex_value, CHECK_NULL);
1333   result-&gt;obj_at_put(0, x);
1334 
1335   int flags = java_lang_invoke_MemberName::flags(mname());
1336   if ((flags &amp; IS_FIELD) != 0) {
1337     x = java_lang_invoke_MemberName::clazz(mname());
1338   } else {
1339     Method* vmtarget = java_lang_invoke_MemberName::vmtarget(mname());
1340     assert(vmtarget != NULL &amp;&amp; vmtarget-&gt;is_method(), &quot;vmtarget is only method&quot;);
1341     x = mname();
1342   }
1343   result-&gt;obj_at_put(1, x);
1344   return JNIHandles::make_local(env, result());
1345 }
1346 JVM_END
1347 
1348 
1349 
1350 //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1351 //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1352 JVM_ENTRY(jint, MHN_getMembers(JNIEnv *env, jobject igcls,
1353                                jclass clazz_jh, jstring name_jh, jstring sig_jh,
1354                                int mflags, jclass caller_jh, jint skip, jobjectArray results_jh)) {
1355   if (clazz_jh == NULL || results_jh == NULL)  return -1;
1356   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz_jh));
1357 
1358   objArrayHandle results(THREAD, (objArrayOop) JNIHandles::resolve(results_jh));
1359   if (results.is_null() || !results-&gt;is_objArray())  return -1;
1360 
1361   TempNewSymbol name = NULL;
1362   TempNewSymbol sig = NULL;
1363   if (name_jh != NULL) {
1364     name = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(name_jh));
1365     if (name == NULL)  return 0; // a match is not possible
1366   }
1367   if (sig_jh != NULL) {
1368     sig = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(sig_jh));
1369     if (sig == NULL)  return 0; // a match is not possible
1370   }
1371 
1372   Klass* caller = NULL;
1373   if (caller_jh != NULL) {
1374     oop caller_oop = JNIHandles::resolve_non_null(caller_jh);
1375     if (!java_lang_Class::is_instance(caller_oop))  return -1;
1376     caller = java_lang_Class::as_Klass(caller_oop);
1377   }
1378 
1379   if (name != NULL &amp;&amp; sig != NULL &amp;&amp; results.not_null()) {
1380     // try a direct resolve
1381     // %%% TO DO
1382   }
1383 
1384   int res = MethodHandles::find_MemberNames(k, name, sig, mflags,
1385                                             caller, skip, results, CHECK_0);
1386   // TO DO: expand at least some of the MemberNames, to avoid massive callbacks
1387   return res;
1388 }
1389 JVM_END
1390 
1391 JVM_ENTRY(void, MHN_setCallSiteTargetNormal(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1392   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1393   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1394   {
1395     // Walk all nmethods depending on this call site.
1396     MutexLocker mu(thread, Compile_lock);
1397     MethodHandles::flush_dependent_nmethods(call_site, target);
1398     java_lang_invoke_CallSite::set_target(call_site(), target());
1399   }
1400 }
1401 JVM_END
1402 
1403 JVM_ENTRY(void, MHN_setCallSiteTargetVolatile(JNIEnv* env, jobject igcls, jobject call_site_jh, jobject target_jh)) {
1404   Handle call_site(THREAD, JNIHandles::resolve_non_null(call_site_jh));
1405   Handle target   (THREAD, JNIHandles::resolve_non_null(target_jh));
1406   {
1407     // Walk all nmethods depending on this call site.
1408     MutexLocker mu(thread, Compile_lock);
1409     MethodHandles::flush_dependent_nmethods(call_site, target);
1410     java_lang_invoke_CallSite::set_target_volatile(call_site(), target());
1411   }
1412 }
1413 JVM_END
1414 
1415 JVM_ENTRY(void, MHN_copyOutBootstrapArguments(JNIEnv* env, jobject igcls,
1416                                               jobject caller_jh, jintArray index_info_jh,
1417                                               jint start, jint end,
1418                                               jobjectArray buf_jh, jint pos,
1419                                               jboolean resolve, jobject ifna_jh)) {
1420   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller_jh));
1421   if (caller_k == NULL || !caller_k-&gt;is_instance_klass()) {
1422       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad caller&quot;);
1423   }
1424   InstanceKlass* caller = InstanceKlass::cast(caller_k);
1425   typeArrayOop index_info_oop = (typeArrayOop) JNIHandles::resolve(index_info_jh);
1426   if (index_info_oop == NULL ||
1427       index_info_oop-&gt;klass() != Universe::intArrayKlassObj() ||
1428       typeArrayOop(index_info_oop)-&gt;length() &lt; 2) {
1429       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad index info (0)&quot;);
1430   }
1431   typeArrayHandle index_info(THREAD, index_info_oop);
1432   int bss_index_in_pool = index_info-&gt;int_at(1);
1433   // While we are here, take a quick look at the index info:
1434   if (bss_index_in_pool &lt;= 0 ||
1435       bss_index_in_pool &gt;= caller-&gt;constants()-&gt;length() ||
1436       index_info-&gt;int_at(0)
1437       != caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool)) {
1438       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;bad index info (1)&quot;);
1439   }
1440   objArrayHandle buf(THREAD, (objArrayOop) JNIHandles::resolve(buf_jh));
1441   if (start &lt; 0) {
1442     for (int pseudo_index = -4; pseudo_index &lt; 0; pseudo_index++) {
1443       if (start == pseudo_index) {
1444         if (start &gt;= end || 0 &gt; pos || pos &gt;= buf-&gt;length())  break;
1445         oop pseudo_arg = NULL;
1446         switch (pseudo_index) {
1447         case -4:  // bootstrap method
1448           {
1449             int bsm_index = caller-&gt;constants()-&gt;bootstrap_method_ref_index_at(bss_index_in_pool);
1450             pseudo_arg = caller-&gt;constants()-&gt;resolve_possibly_cached_constant_at(bsm_index, CHECK);
1451             break;
1452           }
1453         case -3:  // name
1454           {
1455             Symbol* name = caller-&gt;constants()-&gt;name_ref_at(bss_index_in_pool);
1456             Handle str = java_lang_String::create_from_symbol(name, CHECK);
1457             pseudo_arg = str();
1458             break;
1459           }
1460         case -2:  // type
1461           {
1462             Symbol* type = caller-&gt;constants()-&gt;signature_ref_at(bss_index_in_pool);
1463             Handle th;
1464             if (type-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {
1465               th = SystemDictionary::find_method_handle_type(type, caller, CHECK);
1466             } else {
1467               th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);
1468             }
1469             pseudo_arg = th();
1470             break;
1471           }
1472         case -1:  // argument count
1473           {
1474             int argc = caller-&gt;constants()-&gt;bootstrap_argument_count_at(bss_index_in_pool);
1475             jvalue argc_value; argc_value.i = (jint)argc;
1476             pseudo_arg = java_lang_boxing_object::create(T_INT, &amp;argc_value, CHECK);
1477             break;
1478           }
1479         }
1480 
1481         // Store the pseudo-argument, and advance the pointers.
1482         buf-&gt;obj_at_put(pos++, pseudo_arg);
1483         ++start;
1484       }
1485     }
1486     // When we are done with this there may be regular arguments to process too.
1487   }
1488   Handle ifna(THREAD, JNIHandles::resolve(ifna_jh));
1489   caller-&gt;constants()-&gt;
1490     copy_bootstrap_arguments_at(bss_index_in_pool,
1491                                 start, end, buf, pos,
1492                                 (resolve == JNI_TRUE), ifna, CHECK);
1493 }
1494 JVM_END
1495 
1496 // It is called by a Cleaner object which ensures that dropped CallSites properly
1497 // deallocate their dependency information.
1498 JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {
1499   Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));
1500   {
1501     // Walk all nmethods depending on this call site.
1502     MutexLocker mu1(thread, Compile_lock);
1503 
1504     int marked = 0;
1505     {
1506       NoSafepointVerifier nsv;
1507       MutexLocker mu2(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);
1508       DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());
1509       marked = deps.remove_all_dependents();
1510     }
1511     if (marked &gt; 0) {
1512       // At least one nmethod has been marked for deoptimization
1513       Deoptimization::deoptimize_all_marked();
1514     }
1515   }
1516 }
1517 JVM_END
1518 
1519 /**
1520  * Throws a java/lang/UnsupportedOperationException unconditionally.
1521  * This is required by the specification of MethodHandle.invoke if
1522  * invoked directly.
1523  */
1524 JVM_ENTRY(jobject, MH_invoke_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1525   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invoke cannot be invoked reflectively&quot;);
1526   return NULL;
1527 }
1528 JVM_END
1529 
1530 /**
1531  * Throws a java/lang/UnsupportedOperationException unconditionally.
1532  * This is required by the specification of MethodHandle.invokeExact if
1533  * invoked directly.
1534  */
1535 JVM_ENTRY(jobject, MH_invokeExact_UOE(JNIEnv* env, jobject mh, jobjectArray args)) {
1536   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;MethodHandle.invokeExact cannot be invoked reflectively&quot;);
1537   return NULL;
1538 }
1539 JVM_END
1540 
1541 /// JVM_RegisterMethodHandleMethods
1542 
1543 #undef CS  // Solaris builds complain
1544 
1545 #define LANG &quot;Ljava/lang/&quot;
1546 #define JLINV &quot;Ljava/lang/invoke/&quot;
1547 
1548 #define OBJ   LANG &quot;Object;&quot;
1549 #define CLS   LANG &quot;Class;&quot;
1550 #define STRG  LANG &quot;String;&quot;
1551 #define CS    JLINV &quot;CallSite;&quot;
1552 #define MT    JLINV &quot;MethodType;&quot;
1553 #define MH    JLINV &quot;MethodHandle;&quot;
1554 #define MEM   JLINV &quot;MemberName;&quot;
1555 #define CTX   JLINV &quot;MethodHandleNatives$CallSiteContext;&quot;
1556 
1557 #define CC (char*)  /*cast a literal from (const char*)*/
1558 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1559 
1560 // These are the native methods on java.lang.invoke.MethodHandleNatives.
1561 static JNINativeMethod MHN_methods[] = {
1562   {CC &quot;init&quot;,                      CC &quot;(&quot; MEM &quot;&quot; OBJ &quot;)V&quot;,                   FN_PTR(MHN_init_Mem)},
1563   {CC &quot;expand&quot;,                    CC &quot;(&quot; MEM &quot;)V&quot;,                          FN_PTR(MHN_expand_Mem)},
1564   {CC &quot;resolve&quot;,                   CC &quot;(&quot; MEM &quot;&quot; CLS &quot;Z)&quot; MEM,               FN_PTR(MHN_resolve_Mem)},
1565   //  static native int getNamedCon(int which, Object[] name)
1566   {CC &quot;getNamedCon&quot;,               CC &quot;(I[&quot; OBJ &quot;)I&quot;,                        FN_PTR(MHN_getNamedCon)},
1567   //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1568   //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1569   {CC &quot;getMembers&quot;,                CC &quot;(&quot; CLS &quot;&quot; STRG &quot;&quot; STRG &quot;I&quot; CLS &quot;I[&quot; MEM &quot;)I&quot;, FN_PTR(MHN_getMembers)},
1570   {CC &quot;objectFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_objectFieldOffset)},
1571   {CC &quot;setCallSiteTargetNormal&quot;,   CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetNormal)},
1572   {CC &quot;setCallSiteTargetVolatile&quot;, CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetVolatile)},
1573   {CC &quot;copyOutBootstrapArguments&quot;, CC &quot;(&quot; CLS &quot;[III[&quot; OBJ &quot;IZ&quot; OBJ &quot;)V&quot;,     FN_PTR(MHN_copyOutBootstrapArguments)},
1574   {CC &quot;clearCallSiteContext&quot;,      CC &quot;(&quot; CTX &quot;)V&quot;,                          FN_PTR(MHN_clearCallSiteContext)},
1575   {CC &quot;staticFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_staticFieldOffset)},
1576   {CC &quot;staticFieldBase&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_staticFieldBase)},
1577   {CC &quot;getMemberVMInfo&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_getMemberVMInfo)}
1578 };
1579 
1580 static JNINativeMethod MH_methods[] = {
1581   // UnsupportedOperationException throwers
1582   {CC &quot;invoke&quot;,                    CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invoke_UOE)},
1583   {CC &quot;invokeExact&quot;,               CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invokeExact_UOE)}
1584 };
1585 
1586 /**
1587  * This one function is exported, used by NativeLookup.
1588  */
1589 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1590   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1591   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1592 
1593   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1594   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1595 
1596   {
1597     ThreadToNativeFromVM ttnfv(thread);
1598 
1599     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1600     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1601               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1602 
1603     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1604     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1605               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1606   }
1607 
1608   if (TraceInvokeDynamic) {
1609     tty-&gt;print_cr(&quot;MethodHandle support loaded (using LambdaForms)&quot;);
1610   }
1611 
1612   MethodHandles::set_enabled(true);
1613 }
1614 JVM_END
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>