<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="escape.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -77,10 +77,22 @@</span>
      }
    }
    return nreplacements;
  }
  
<span class="udiff-line-added">+ void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {</span>
<span class="udiff-line-added">+   assert(old != NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   for (DUIterator_Fast imax, i = old-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-added">+     Node* use = old-&gt;fast_out(i);</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(use);</span>
<span class="udiff-line-added">+     imax -= replace_input(use, old, target);</span>
<span class="udiff-line-added">+     // back up iterator</span>
<span class="udiff-line-added">+     --i;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   assert(old-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {
    // Copy debug information and adjust JVMState information
    uint old_dbg_start = oldcall-&gt;tf()-&gt;domain()-&gt;cnt();
    uint new_dbg_start = newcall-&gt;tf()-&gt;domain()-&gt;cnt();
    int jvms_adj  = new_dbg_start - old_dbg_start;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1275,53 +1287,72 @@</span>
              Node* length,  // array length for an array allocation
              const TypeFunc* slow_call_type, // Type of slow call
              address slow_call_address  // Address of slow call
      )
  {
<span class="udiff-line-removed">- </span>
    Node* ctrl = alloc-&gt;in(TypeFunc::Control);
    Node* mem  = alloc-&gt;in(TypeFunc::Memory);
    Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
    Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
    Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
    Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
<span class="udiff-line-removed">- </span>
    assert(ctrl != NULL, &quot;must have control&quot;);
<span class="udiff-line-added">+ </span>
    // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
    // they will not be used if &quot;always_slow&quot; is set
    enum { slow_result_path = 1, fast_result_path = 2 };
    Node *result_region = NULL;
    Node *result_phi_rawmem = NULL;
    Node *result_phi_rawoop = NULL;
    Node *result_phi_i_o = NULL;
  
    // The initial slow comparison is a size check, the comparison
    // we want to do is a BoolTest::gt
<span class="udiff-line-modified-removed">-   bool always_slow = false;</span>
<span class="udiff-line-modified-added">+   bool expand_fast_path = true;</span>
    int tv = _igvn.find_int_con(initial_slow_test, -1);
    if (tv &gt;= 0) {
<span class="udiff-line-modified-removed">-     always_slow = (tv == 1);</span>
<span class="udiff-line-modified-added">+     // InitialTest has constant result</span>
<span class="udiff-line-added">+     //   0 - can fit in TLAB</span>
<span class="udiff-line-added">+     //   1 - always too big or negative</span>
<span class="udiff-line-added">+     assert(tv &lt;= 1, &quot;0 or 1 if a constant&quot;);</span>
<span class="udiff-line-added">+     expand_fast_path = (tv == 0);</span>
      initial_slow_test = NULL;
    } else {
      initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
    }
  
    if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
        (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
      // Force slow-path allocation
<span class="udiff-line-modified-removed">-     always_slow = true;</span>
<span class="udiff-line-modified-added">+     expand_fast_path = false;</span>
      initial_slow_test = NULL;
    }
  
<span class="udiff-line-added">+   bool allocation_has_use = (alloc-&gt;result_cast() != NULL);</span>
<span class="udiff-line-added">+   if (!allocation_has_use) {</span>
<span class="udiff-line-added">+     InitializeNode* init = alloc-&gt;initialization();</span>
<span class="udiff-line-added">+     if (init != NULL) {</span>
<span class="udiff-line-added">+       yank_initalize_node(init);</span>
<span class="udiff-line-added">+       assert(init-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="udiff-line-added">+       _igvn.remove_dead_node(init);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (expand_fast_path &amp;&amp; (initial_slow_test == NULL)) {</span>
<span class="udiff-line-added">+       // Remove allocation node and return.</span>
<span class="udiff-line-added">+       // Size is a non-negative constant -&gt; no initial check needed -&gt; directly to fast path.</span>
<span class="udiff-line-added">+       // Also, no usages -&gt; empty fast path -&gt; no fall out to slow path -&gt; nothing left.</span>
<span class="udiff-line-added">+       yank_alloc_node(alloc);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
    enum { too_big_or_final_path = 1, need_gc_path = 2 };
    Node *slow_region = NULL;
    Node *toobig_false = ctrl;
  
<span class="udiff-line-removed">-   assert (initial_slow_test == NULL || !always_slow, &quot;arguments must be consistent&quot;);</span>
    // generate the initial test if necessary
    if (initial_slow_test != NULL ) {
<span class="udiff-line-added">+     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);</span>
      slow_region = new RegionNode(3);
  
      // Now make the initial failure test.  Usually a too-big test but
      // might be a TRUE for finalizers or a fancy class check for
      // newInstance0.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1331,157 +1362,84 @@</span>
      Node *toobig_true = new IfTrueNode( toobig_iff );
      transform_later(toobig_true);
      slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
      toobig_false = new IfFalseNode( toobig_iff );
      transform_later(toobig_false);
<span class="udiff-line-modified-removed">-   } else {         // No initial test, just fall into next case</span>
<span class="udiff-line-modified-added">+   } else {</span>
<span class="udiff-line-added">+     // No initial test, just fall into next case</span>
<span class="udiff-line-added">+     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);</span>
      toobig_false = ctrl;
      debug_only(slow_region = NodeSentinel);
    }
  
<span class="udiff-line-added">+   // If we are here there are several possibilities</span>
<span class="udiff-line-added">+   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.</span>
<span class="udiff-line-added">+   // no_initial_check means a constant allocation.</span>
<span class="udiff-line-added">+   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)</span>
<span class="udiff-line-added">+   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)</span>
<span class="udiff-line-added">+   // if !allocation_has_use the fast path is empty</span>
<span class="udiff-line-added">+   // if !allocation_has_use &amp;&amp; no_initial_check</span>
<span class="udiff-line-added">+   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.</span>
<span class="udiff-line-added">+   //   removed by yank_alloc_node above.</span>
<span class="udiff-line-added">+ </span>
    Node *slow_mem = mem;  // save the current memory state for slow path
    // generate the fast allocation code unless we know that the initial test will always go slow
<span class="udiff-line-modified-removed">-   if (!always_slow) {</span>
<span class="udiff-line-modified-added">+   if (expand_fast_path) {</span>
      // Fast path modifies only raw memory.
      if (mem-&gt;is_MergeMem()) {
        mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
      }
  
      // allocate the Region and Phi nodes for the result
      result_region = new RegionNode(3);
      result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
<span class="udiff-line-removed">-     result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);</span>
      result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
  
      // Grab regular I/O before optional prefetch may change it.
      // Slow-path does no I/O so just set it to the original I/O.
      result_phi_i_o-&gt;init_req(slow_result_path, i_o);
  
<span class="udiff-line-removed">-     Node* needgc_ctrl = NULL;</span>
      // Name successful fast-path variables
      Node* fast_oop_ctrl;
      Node* fast_oop_rawmem;
<span class="udiff-line-added">+     if (allocation_has_use) {</span>
<span class="udiff-line-added">+       Node* needgc_ctrl = NULL;</span>
<span class="udiff-line-added">+       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);</span>
  
<span class="udiff-line-modified-removed">-     intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-modified-removed">-     Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,</span>
<span class="udiff-line-modified-removed">-                                       fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="udiff-line-modified-removed">-                                       prefetch_lines);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (initial_slow_test) {</span>
<span class="udiff-line-modified-removed">-       slow_region-&gt;init_req(need_gc_path, needgc_ctrl);</span>
<span class="udiff-line-modified-removed">-       // This completes all paths into the slow merge point</span>
<span class="udiff-line-removed">-       transform_later(slow_region);</span>
<span class="udiff-line-removed">-     } else {                      // No initial slow path needed!</span>
<span class="udiff-line-removed">-       // Just fall from the need-GC path straight into the VM call.</span>
<span class="udiff-line-removed">-       slow_region = needgc_ctrl;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     InitializeNode* init = alloc-&gt;initialization();</span>
<span class="udiff-line-removed">-     fast_oop_rawmem = initialize_object(alloc,</span>
<span class="udiff-line-removed">-                                         fast_oop_ctrl, fast_oop_rawmem, fast_oop,</span>
<span class="udiff-line-removed">-                                         klass_node, length, size_in_bytes);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // If initialization is performed by an array copy, any required</span>
<span class="udiff-line-removed">-     // MemBarStoreStore was already added. If the object does not</span>
<span class="udiff-line-removed">-     // escape no need for a MemBarStoreStore. If the object does not</span>
<span class="udiff-line-removed">-     // escape in its initializer and memory barrier (MemBarStoreStore or</span>
<span class="udiff-line-removed">-     // stronger) is already added at exit of initializer, also no need</span>
<span class="udiff-line-removed">-     // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore</span>
<span class="udiff-line-removed">-     // so that stores that initialize this object can&#39;t be reordered</span>
<span class="udiff-line-removed">-     // with a subsequent store that makes this object accessible by</span>
<span class="udiff-line-removed">-     // other threads.</span>
<span class="udiff-line-removed">-     // Other threads include java threads and JVM internal threads</span>
<span class="udiff-line-removed">-     // (for example concurrent GC threads). Current concurrent GC</span>
<span class="udiff-line-removed">-     // implementation: G1 will not scan newly created object,</span>
<span class="udiff-line-removed">-     // so it&#39;s safe to skip storestore barrier when allocation does</span>
<span class="udiff-line-removed">-     // not escape.</span>
<span class="udiff-line-removed">-     if (!alloc-&gt;does_not_escape_thread() &amp;&amp;</span>
<span class="udiff-line-removed">-         !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;</span>
<span class="udiff-line-removed">-         (init == NULL || !init-&gt;is_complete_with_arraycopy())) {</span>
<span class="udiff-line-removed">-       if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {</span>
<span class="udiff-line-removed">-         // No InitializeNode or no stores captured by zeroing</span>
<span class="udiff-line-removed">-         // elimination. Simply add the MemBarStoreStore after object</span>
<span class="udiff-line-removed">-         // initialization.</span>
<span class="udiff-line-removed">-         MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="udiff-line-removed">-         transform_later(mb);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);</span>
<span class="udiff-line-removed">-         mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="udiff-line-removed">-         fast_oop_ctrl = new ProjNode(mb,TypeFunc::Control);</span>
<span class="udiff-line-removed">-         transform_later(fast_oop_ctrl);</span>
<span class="udiff-line-removed">-         fast_oop_rawmem = new ProjNode(mb,TypeFunc::Memory);</span>
<span class="udiff-line-removed">-         transform_later(fast_oop_rawmem);</span>
<span class="udiff-line-modified-added">+       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;</span>
<span class="udiff-line-modified-added">+       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="udiff-line-modified-added">+       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,</span>
<span class="udiff-line-modified-added">+                                         fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="udiff-line-modified-added">+                                         prefetch_lines);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (initial_slow_test != NULL) {</span>
<span class="udiff-line-modified-added">+         // This completes all paths into the slow merge point</span>
<span class="udiff-line-modified-added">+         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);</span>
<span class="udiff-line-modified-added">+         transform_later(slow_region);</span>
        } else {
<span class="udiff-line-modified-removed">-         // Add the MemBarStoreStore after the InitializeNode so that</span>
<span class="udiff-line-modified-removed">-         // all stores performing the initialization that were moved</span>
<span class="udiff-line-modified-removed">-         // before the InitializeNode happen before the storestore</span>
<span class="udiff-line-removed">-         // barrier.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="udiff-line-removed">-         Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="udiff-line-removed">-         transform_later(mb);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         Node* ctrl = new ProjNode(init,TypeFunc::Control);</span>
<span class="udiff-line-removed">-         transform_later(ctrl);</span>
<span class="udiff-line-removed">-         Node* mem = new ProjNode(init,TypeFunc::Memory);</span>
<span class="udiff-line-removed">-         transform_later(mem);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // The MemBarStoreStore depends on control and memory coming</span>
<span class="udiff-line-removed">-         // from the InitializeNode</span>
<span class="udiff-line-removed">-         mb-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="udiff-line-removed">-         mb-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         ctrl = new ProjNode(mb,TypeFunc::Control);</span>
<span class="udiff-line-removed">-         transform_later(ctrl);</span>
<span class="udiff-line-removed">-         mem = new ProjNode(mb,TypeFunc::Memory);</span>
<span class="udiff-line-removed">-         transform_later(mem);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // All nodes that depended on the InitializeNode for control</span>
<span class="udiff-line-removed">-         // and memory must now depend on the MemBarNode that itself</span>
<span class="udiff-line-removed">-         // depends on the InitializeNode</span>
<span class="udiff-line-removed">-         if (init_ctrl != NULL) {</span>
<span class="udiff-line-removed">-           _igvn.replace_node(init_ctrl, ctrl);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (init_mem != NULL) {</span>
<span class="udiff-line-removed">-           _igvn.replace_node(init_mem, mem);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         // No initial slow path needed!</span>
<span class="udiff-line-modified-added">+         // Just fall from the need-GC path straight into the VM call.</span>
<span class="udiff-line-modified-added">+         slow_region = needgc_ctrl;</span>
        }
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     if (C-&gt;env()-&gt;dtrace_extended_probes()) {</span>
<span class="udiff-line-modified-removed">-       // Slow-path call</span>
<span class="udiff-line-modified-removed">-       int size = TypeFunc::Parms + 2;</span>
<span class="udiff-line-modified-removed">-       CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),</span>
<span class="udiff-line-modified-removed">-                                             CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),</span>
<span class="udiff-line-modified-removed">-                                             &quot;dtrace_object_alloc&quot;,</span>
<span class="udiff-line-modified-removed">-                                             TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       // Get base of thread-local storage area</span>
<span class="udiff-line-modified-removed">-       Node* thread = new ThreadLocalNode();</span>
<span class="udiff-line-modified-removed">-       transform_later(thread);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       call-&gt;init_req(TypeFunc::Parms+0, thread);</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::Parms+1, fast_oop);</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::Memory , fast_oop_rawmem);</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="udiff-line-removed">-       call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));</span>
<span class="udiff-line-removed">-       transform_later(call);</span>
<span class="udiff-line-removed">-       fast_oop_ctrl = new ProjNode(call,TypeFunc::Control);</span>
<span class="udiff-line-removed">-       transform_later(fast_oop_ctrl);</span>
<span class="udiff-line-removed">-       fast_oop_rawmem = new ProjNode(call,TypeFunc::Memory);</span>
<span class="udiff-line-removed">-       transform_later(fast_oop_rawmem);</span>
<span class="udiff-line-modified-added">+       InitializeNode* init = alloc-&gt;initialization();</span>
<span class="udiff-line-modified-added">+       fast_oop_rawmem = initialize_object(alloc,</span>
<span class="udiff-line-modified-added">+                                           fast_oop_ctrl, fast_oop_rawmem, fast_oop,</span>
<span class="udiff-line-modified-added">+                                           klass_node, length, size_in_bytes);</span>
<span class="udiff-line-modified-added">+       expand_initialize_membar(alloc, init, fast_oop_ctrl, fast_oop_rawmem);</span>
<span class="udiff-line-modified-added">+       expand_dtrace_alloc_probe(alloc, fast_oop, fast_oop_ctrl, fast_oop_rawmem);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+       assert (initial_slow_test != NULL, &quot;sanity&quot;);</span>
<span class="udiff-line-modified-added">+       fast_oop_ctrl   = toobig_false;</span>
<span class="udiff-line-modified-added">+       fast_oop_rawmem = mem;</span>
<span class="udiff-line-modified-added">+       transform_later(slow_region);</span>
      }
  
      // Plug in the successful fast-path into the result merge point
      result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
<span class="udiff-line-removed">-     result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);</span>
      result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
      result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
    } else {
      slow_region = ctrl;
      result_phi_i_o = i_o; // Rename it to use in the following code.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1490,25 +1448,25 @@</span>
    // Generate slow-path call
    CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
                                 OptoRuntime::stub_name(slow_call_address),
                                 alloc-&gt;jvms()-&gt;bci(),
                                 TypePtr::BOTTOM);
<span class="udiff-line-modified-removed">-   call-&gt;init_req( TypeFunc::Control, slow_region );</span>
<span class="udiff-line-modified-removed">-   call-&gt;init_req( TypeFunc::I_O    , top() )     ;   // does no i/o</span>
<span class="udiff-line-modified-removed">-   call-&gt;init_req( TypeFunc::Memory , slow_mem ); // may gc ptrs</span>
<span class="udiff-line-modified-removed">-   call-&gt;init_req( TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr) );</span>
<span class="udiff-line-modified-removed">-   call-&gt;init_req( TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr) );</span>
<span class="udiff-line-modified-added">+   call-&gt;init_req(TypeFunc::Control,   slow_region);</span>
<span class="udiff-line-modified-added">+   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o</span>
<span class="udiff-line-modified-added">+   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs</span>
<span class="udiff-line-modified-added">+   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="udiff-line-modified-added">+   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));</span>
  
    call-&gt;init_req(TypeFunc::Parms+0, klass_node);
    if (length != NULL) {
      call-&gt;init_req(TypeFunc::Parms+1, length);
    }
  
    // Copy debug information and adjust JVMState information, then replace
    // allocate node with the call
    copy_call_debug_info((CallNode *) alloc,  call);
<span class="udiff-line-modified-removed">-   if (!always_slow) {</span>
<span class="udiff-line-modified-added">+   if (expand_fast_path) {</span>
      call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
    } else {
      // Hook i_o projection to avoid its elimination during allocation
      // replacement (when only a slow call is generated).
      call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1530,86 +1488,59 @@</span>
  
    // An allocate node has separate memory projections for the uses on
    // the control and i_o paths. Replace the control memory projection with
    // result_phi_rawmem (unless we are only generating a slow call when
    // both memory projections are combined)
<span class="udiff-line-modified-removed">-   if (!always_slow &amp;&amp; _memproj_fallthrough != NULL) {</span>
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast imax, i = _memproj_fallthrough-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node *use = _memproj_fallthrough-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       _igvn.rehash_node_delayed(use);</span>
<span class="udiff-line-removed">-       imax -= replace_input(use, _memproj_fallthrough, result_phi_rawmem);</span>
<span class="udiff-line-removed">-       // back up iterator</span>
<span class="udiff-line-removed">-       --i;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {</span>
<span class="udiff-line-modified-added">+     migrate_outs(_memproj_fallthrough, result_phi_rawmem);</span>
    }
    // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
    // _memproj_catchall so we end up with a call that has only 1 memory projection.
    if (_memproj_catchall != NULL ) {
      if (_memproj_fallthrough == NULL) {
        _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
        transform_later(_memproj_fallthrough);
      }
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast imax, i = _memproj_catchall-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node *use = _memproj_catchall-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       _igvn.rehash_node_delayed(use);</span>
<span class="udiff-line-removed">-       imax -= replace_input(use, _memproj_catchall, _memproj_fallthrough);</span>
<span class="udiff-line-removed">-       // back up iterator</span>
<span class="udiff-line-removed">-       --i;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(_memproj_catchall-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="udiff-line-modified-added">+     migrate_outs(_memproj_catchall, _memproj_fallthrough);</span>
      _igvn.remove_dead_node(_memproj_catchall);
    }
  
    // An allocate node has separate i_o projections for the uses on the control
    // and i_o paths. Always replace the control i_o projection with result i_o
    // otherwise incoming i_o become dead when only a slow call is generated
    // (it is different from memory projections where both projections are
    // combined in such case).
    if (_ioproj_fallthrough != NULL) {
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast imax, i = _ioproj_fallthrough-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node *use = _ioproj_fallthrough-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       _igvn.rehash_node_delayed(use);</span>
<span class="udiff-line-removed">-       imax -= replace_input(use, _ioproj_fallthrough, result_phi_i_o);</span>
<span class="udiff-line-removed">-       // back up iterator</span>
<span class="udiff-line-removed">-       --i;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     migrate_outs(_ioproj_fallthrough, result_phi_i_o);</span>
    }
    // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
    // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
    if (_ioproj_catchall != NULL ) {
      if (_ioproj_fallthrough == NULL) {
        _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
        transform_later(_ioproj_fallthrough);
      }
<span class="udiff-line-modified-removed">-     for (DUIterator_Fast imax, i = _ioproj_catchall-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="udiff-line-removed">-       Node *use = _ioproj_catchall-&gt;fast_out(i);</span>
<span class="udiff-line-removed">-       _igvn.rehash_node_delayed(use);</span>
<span class="udiff-line-removed">-       imax -= replace_input(use, _ioproj_catchall, _ioproj_fallthrough);</span>
<span class="udiff-line-removed">-       // back up iterator</span>
<span class="udiff-line-removed">-       --i;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     assert(_ioproj_catchall-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
<span class="udiff-line-modified-added">+     migrate_outs(_ioproj_catchall, _ioproj_fallthrough);</span>
      _igvn.remove_dead_node(_ioproj_catchall);
    }
  
    // if we generated only a slow call, we are done
<span class="udiff-line-modified-removed">-   if (always_slow) {</span>
<span class="udiff-line-modified-added">+   if (!expand_fast_path) {</span>
      // Now we can unhook i_o.
      if (result_phi_i_o-&gt;outcnt() &gt; 1) {
        call-&gt;set_req(TypeFunc::I_O, top());
      } else {
<span class="udiff-line-modified-removed">-       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;&quot;);</span>
<span class="udiff-line-modified-added">+       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);</span>
        // Case of new array with negative size known during compilation.
        // AllocateArrayNode::Ideal() optimization disconnect unreachable
        // following code since call to runtime will throw exception.
        // As result there will be no users of i_o after the call.
        // Leave i_o attached to this call to avoid problems in preceding graph.
      }
      return;
    }
  
<span class="udiff-line-removed">- </span>
    if (_fallthroughcatchproj != NULL) {
      ctrl = _fallthroughcatchproj-&gt;clone();
      transform_later(ctrl);
      _igvn.replace_node(_fallthroughcatchproj, result_region);
    } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1624,20 +1555,181 @@</span>
      transform_later(slow_result);
      _igvn.replace_node(_resproj, result_phi_rawoop);
    }
  
    // Plug slow-path into result merge point
<span class="udiff-line-modified-removed">-   result_region    -&gt;init_req( slow_result_path, ctrl );</span>
<span class="udiff-line-removed">-   result_phi_rawoop-&gt;init_req( slow_result_path, slow_result);</span>
<span class="udiff-line-removed">-   result_phi_rawmem-&gt;init_req( slow_result_path, _memproj_fallthrough );</span>
<span class="udiff-line-modified-added">+   result_region-&gt;init_req( slow_result_path, ctrl);</span>
    transform_later(result_region);
<span class="udiff-line-modified-removed">-   transform_later(result_phi_rawoop);</span>
<span class="udiff-line-modified-added">+   if (allocation_has_use) {</span>
<span class="udiff-line-added">+     result_phi_rawoop-&gt;init_req(slow_result_path, slow_result);</span>
<span class="udiff-line-added">+     transform_later(result_phi_rawoop);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   result_phi_rawmem-&gt;init_req(slow_result_path, _memproj_fallthrough);</span>
    transform_later(result_phi_rawmem);
    transform_later(result_phi_i_o);
    // This completes all paths into the result merge point
  }
  
<span class="udiff-line-added">+ // Remove alloc node that has no uses.</span>
<span class="udiff-line-added">+ void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {</span>
<span class="udiff-line-added">+   Node* ctrl = alloc-&gt;in(TypeFunc::Control);</span>
<span class="udiff-line-added">+   Node* mem  = alloc-&gt;in(TypeFunc::Memory);</span>
<span class="udiff-line-added">+   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   extract_call_projections(alloc);</span>
<span class="udiff-line-added">+   if (_fallthroughcatchproj != NULL) {</span>
<span class="udiff-line-added">+     migrate_outs(_fallthroughcatchproj, ctrl);</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(_fallthroughcatchproj);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_catchallcatchproj != NULL) {</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(_catchallcatchproj);</span>
<span class="udiff-line-added">+     _catchallcatchproj-&gt;set_req(0, top());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_fallthroughproj != NULL) {</span>
<span class="udiff-line-added">+     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(catchnode);</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(_fallthroughproj);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_memproj_fallthrough != NULL) {</span>
<span class="udiff-line-added">+     migrate_outs(_memproj_fallthrough, mem);</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(_memproj_fallthrough);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_ioproj_fallthrough != NULL) {</span>
<span class="udiff-line-added">+     migrate_outs(_ioproj_fallthrough, i_o);</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(_ioproj_fallthrough);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_memproj_catchall != NULL) {</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(_memproj_catchall);</span>
<span class="udiff-line-added">+     _memproj_catchall-&gt;set_req(0, top());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (_ioproj_catchall != NULL) {</span>
<span class="udiff-line-added">+     _igvn.rehash_node_delayed(_ioproj_catchall);</span>
<span class="udiff-line-added">+     _ioproj_catchall-&gt;set_req(0, top());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _igvn.remove_dead_node(alloc);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,</span>
<span class="udiff-line-added">+                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {</span>
<span class="udiff-line-added">+   // If initialization is performed by an array copy, any required</span>
<span class="udiff-line-added">+   // MemBarStoreStore was already added. If the object does not</span>
<span class="udiff-line-added">+   // escape no need for a MemBarStoreStore. If the object does not</span>
<span class="udiff-line-added">+   // escape in its initializer and memory barrier (MemBarStoreStore or</span>
<span class="udiff-line-added">+   // stronger) is already added at exit of initializer, also no need</span>
<span class="udiff-line-added">+   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore</span>
<span class="udiff-line-added">+   // so that stores that initialize this object can&#39;t be reordered</span>
<span class="udiff-line-added">+   // with a subsequent store that makes this object accessible by</span>
<span class="udiff-line-added">+   // other threads.</span>
<span class="udiff-line-added">+   // Other threads include java threads and JVM internal threads</span>
<span class="udiff-line-added">+   // (for example concurrent GC threads). Current concurrent GC</span>
<span class="udiff-line-added">+   // implementation: G1 will not scan newly created object,</span>
<span class="udiff-line-added">+   // so it&#39;s safe to skip storestore barrier when allocation does</span>
<span class="udiff-line-added">+   // not escape.</span>
<span class="udiff-line-added">+   if (!alloc-&gt;does_not_escape_thread() &amp;&amp;</span>
<span class="udiff-line-added">+     !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;</span>
<span class="udiff-line-added">+     (init == NULL || !init-&gt;is_complete_with_arraycopy())) {</span>
<span class="udiff-line-added">+     if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {</span>
<span class="udiff-line-added">+       // No InitializeNode or no stores captured by zeroing</span>
<span class="udiff-line-added">+       // elimination. Simply add the MemBarStoreStore after object</span>
<span class="udiff-line-added">+       // initialization.</span>
<span class="udiff-line-added">+       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="udiff-line-added">+       transform_later(mb);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);</span>
<span class="udiff-line-added">+       mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="udiff-line-added">+       fast_oop_ctrl = new ProjNode(mb, TypeFunc::Control);</span>
<span class="udiff-line-added">+       transform_later(fast_oop_ctrl);</span>
<span class="udiff-line-added">+       fast_oop_rawmem = new ProjNode(mb, TypeFunc::Memory);</span>
<span class="udiff-line-added">+       transform_later(fast_oop_rawmem);</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       // Add the MemBarStoreStore after the InitializeNode so that</span>
<span class="udiff-line-added">+       // all stores performing the initialization that were moved</span>
<span class="udiff-line-added">+       // before the InitializeNode happen before the storestore</span>
<span class="udiff-line-added">+       // barrier.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="udiff-line-added">+       Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="udiff-line-added">+       transform_later(mb);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       Node* ctrl = new ProjNode(init, TypeFunc::Control);</span>
<span class="udiff-line-added">+       transform_later(ctrl);</span>
<span class="udiff-line-added">+       Node* mem = new ProjNode(init, TypeFunc::Memory);</span>
<span class="udiff-line-added">+       transform_later(mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // The MemBarStoreStore depends on control and memory coming</span>
<span class="udiff-line-added">+       // from the InitializeNode</span>
<span class="udiff-line-added">+       mb-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="udiff-line-added">+       mb-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       ctrl = new ProjNode(mb, TypeFunc::Control);</span>
<span class="udiff-line-added">+       transform_later(ctrl);</span>
<span class="udiff-line-added">+       mem = new ProjNode(mb, TypeFunc::Memory);</span>
<span class="udiff-line-added">+       transform_later(mem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // All nodes that depended on the InitializeNode for control</span>
<span class="udiff-line-added">+       // and memory must now depend on the MemBarNode that itself</span>
<span class="udiff-line-added">+       // depends on the InitializeNode</span>
<span class="udiff-line-added">+       if (init_ctrl != NULL) {</span>
<span class="udiff-line-added">+         _igvn.replace_node(init_ctrl, ctrl);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       if (init_mem != NULL) {</span>
<span class="udiff-line-added">+         _igvn.replace_node(init_mem, mem);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void PhaseMacroExpand::expand_dtrace_alloc_probe(AllocateNode* alloc, Node* oop,</span>
<span class="udiff-line-added">+                                                 Node*&amp; ctrl, Node*&amp; rawmem) {</span>
<span class="udiff-line-added">+   if (C-&gt;env()-&gt;dtrace_extended_probes()) {</span>
<span class="udiff-line-added">+     // Slow-path call</span>
<span class="udiff-line-added">+     int size = TypeFunc::Parms + 2;</span>
<span class="udiff-line-added">+     CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),</span>
<span class="udiff-line-added">+                                           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),</span>
<span class="udiff-line-added">+                                           &quot;dtrace_object_alloc&quot;,</span>
<span class="udiff-line-added">+                                           TypeRawPtr::BOTTOM);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Get base of thread-local storage area</span>
<span class="udiff-line-added">+     Node* thread = new ThreadLocalNode();</span>
<span class="udiff-line-added">+     transform_later(thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::Parms + 0, thread);</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::Parms + 1, oop);</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::Memory , ctrl);</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="udiff-line-added">+     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));</span>
<span class="udiff-line-added">+     transform_later(call);</span>
<span class="udiff-line-added">+     ctrl = new ProjNode(call, TypeFunc::Control);</span>
<span class="udiff-line-added">+     transform_later(ctrl);</span>
<span class="udiff-line-added">+     rawmem = new ProjNode(call, TypeFunc::Memory);</span>
<span class="udiff-line-added">+     transform_later(rawmem);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Remove InitializeNode without use</span>
<span class="udiff-line-added">+ void PhaseMacroExpand::yank_initalize_node(InitializeNode* initnode) {</span>
<span class="udiff-line-added">+   assert(initnode-&gt;proj_out_or_null(TypeFunc::Parms) == NULL, &quot;No uses allowed&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Node* ctrl_out  = initnode-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="udiff-line-added">+   Node* mem_out   = initnode-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Move all uses of each to</span>
<span class="udiff-line-added">+   if (ctrl_out != NULL ) {</span>
<span class="udiff-line-added">+     migrate_outs(ctrl_out, initnode-&gt;in(TypeFunc::Control));</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(ctrl_out);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Move all uses of each to</span>
<span class="udiff-line-added">+   if (mem_out != NULL ) {</span>
<span class="udiff-line-added">+     migrate_outs(mem_out, initnode-&gt;in(TypeFunc::Memory));</span>
<span class="udiff-line-added">+     _igvn.remove_dead_node(mem_out);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
  // Helper for PhaseMacroExpand::expand_allocate_common.
  // Initializes the newly-allocated storage.
  Node*
  PhaseMacroExpand::initialize_object(AllocateNode* alloc,
</pre>
<center><a href="escape.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>