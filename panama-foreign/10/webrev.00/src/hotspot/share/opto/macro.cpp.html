<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/macro.hpp&quot;
  41 #include &quot;opto/memnode.hpp&quot;
  42 #include &quot;opto/narrowptrnode.hpp&quot;
  43 #include &quot;opto/node.hpp&quot;
  44 #include &quot;opto/opaquenode.hpp&quot;
  45 #include &quot;opto/phaseX.hpp&quot;
  46 #include &quot;opto/rootnode.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #include &quot;opto/subnode.hpp&quot;
  49 #include &quot;opto/type.hpp&quot;
  50 #include &quot;runtime/sharedRuntime.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 #if INCLUDE_G1GC
  53 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  54 #endif // INCLUDE_G1GC
  55 #if INCLUDE_SHENANDOAHGC
  56 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  57 #endif
  58 
  59 
  60 //
  61 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  62 // Returns the number of replacements made.
  63 //
  64 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  65   int nreplacements = 0;
  66   uint req = use-&gt;req();
  67   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  68     Node *uin = use-&gt;in(j);
  69     if (uin == oldref) {
  70       if (j &lt; req)
  71         use-&gt;set_req(j, newref);
  72       else
  73         use-&gt;set_prec(j, newref);
  74       nreplacements++;
  75     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  76       break;
  77     }
  78   }
  79   return nreplacements;
  80 }
  81 
  82 void PhaseMacroExpand::migrate_outs(Node *old, Node *target) {
  83   assert(old != NULL, &quot;sanity&quot;);
  84   for (DUIterator_Fast imax, i = old-&gt;fast_outs(imax); i &lt; imax; i++) {
  85     Node* use = old-&gt;fast_out(i);
  86     _igvn.rehash_node_delayed(use);
  87     imax -= replace_input(use, old, target);
  88     // back up iterator
  89     --i;
  90   }
  91   assert(old-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
  92 }
  93 
  94 void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {
  95   // Copy debug information and adjust JVMState information
  96   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain()-&gt;cnt();
  97   uint new_dbg_start = newcall-&gt;tf()-&gt;domain()-&gt;cnt();
  98   int jvms_adj  = new_dbg_start - old_dbg_start;
  99   assert (new_dbg_start == newcall-&gt;req(), &quot;argument count mismatch&quot;);
 100 
 101   // SafePointScalarObject node could be referenced several times in debug info.
 102   // Use Dict to record cloned nodes.
 103   Dict* sosn_map = new Dict(cmpkey,hashkey);
 104   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {
 105     Node* old_in = oldcall-&gt;in(i);
 106     // Clone old SafePointScalarObjectNodes, adjusting their field contents.
 107     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {
 108       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();
 109       uint old_unique = C-&gt;unique();
 110       Node* new_in = old_sosn-&gt;clone(sosn_map);
 111       if (old_unique != C-&gt;unique()) { // New node?
 112         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge
 113         new_in = transform_later(new_in); // Register new node.
 114       }
 115       old_in = new_in;
 116     }
 117     newcall-&gt;add_req(old_in);
 118   }
 119 
 120   // JVMS may be shared so clone it before we modify it
 121   newcall-&gt;set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);
 122   for (JVMState *jvms = newcall-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
 123     jvms-&gt;set_map(newcall);
 124     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);
 125     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);
 126     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);
 127     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);
 128     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);
 129   }
 130 }
 131 
 132 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
 133   Node* cmp;
 134   if (mask != 0) {
 135     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
 136     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
 137   } else {
 138     cmp = word;
 139   }
 140   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
 141   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
 142   transform_later(iff);
 143 
 144   // Fast path taken.
 145   Node *fast_taken = transform_later(new IfFalseNode(iff));
 146 
 147   // Fast path not-taken, i.e. slow path
 148   Node *slow_taken = transform_later(new IfTrueNode(iff));
 149 
 150   if (return_fast_path) {
 151     region-&gt;init_req(edge, slow_taken); // Capture slow-control
 152     return fast_taken;
 153   } else {
 154     region-&gt;init_req(edge, fast_taken); // Capture fast-control
 155     return slow_taken;
 156   }
 157 }
 158 
 159 //--------------------copy_predefined_input_for_runtime_call--------------------
 160 void PhaseMacroExpand::copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call) {
 161   // Set fixed predefined input arguments
 162   call-&gt;init_req( TypeFunc::Control, ctrl );
 163   call-&gt;init_req( TypeFunc::I_O    , oldcall-&gt;in( TypeFunc::I_O) );
 164   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 165   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 166   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 167 }
 168 
 169 //------------------------------make_slow_call---------------------------------
 170 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 171                                            address slow_call, const char* leaf_name, Node* slow_path,
 172                                            Node* parm0, Node* parm1, Node* parm2) {
 173 
 174   // Slow-path call
 175  CallNode *call = leaf_name
 176    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 177    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 178 
 179   // Slow path call has no side-effects, uses few values
 180   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 181   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 182   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 183   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
 184   copy_call_debug_info(oldcall, call);
 185   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 186   _igvn.replace_node(oldcall, call);
 187   transform_later(call);
 188 
 189   return call;
 190 }
 191 
 192 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 193   _fallthroughproj = NULL;
 194   _fallthroughcatchproj = NULL;
 195   _ioproj_fallthrough = NULL;
 196   _ioproj_catchall = NULL;
 197   _catchallcatchproj = NULL;
 198   _memproj_fallthrough = NULL;
 199   _memproj_catchall = NULL;
 200   _resproj = NULL;
 201   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 202     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 203     switch (pn-&gt;_con) {
 204       case TypeFunc::Control:
 205       {
 206         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 207         _fallthroughproj = pn;
 208         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 209         const Node *cn = pn-&gt;fast_out(j);
 210         if (cn-&gt;is_Catch()) {
 211           ProjNode *cpn = NULL;
 212           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 213             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 214             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 215             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 216               _fallthroughcatchproj = cpn;
 217             else {
 218               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 219               _catchallcatchproj = cpn;
 220             }
 221           }
 222         }
 223         break;
 224       }
 225       case TypeFunc::I_O:
 226         if (pn-&gt;_is_io_use)
 227           _ioproj_catchall = pn;
 228         else
 229           _ioproj_fallthrough = pn;
 230         break;
 231       case TypeFunc::Memory:
 232         if (pn-&gt;_is_io_use)
 233           _memproj_catchall = pn;
 234         else
 235           _memproj_fallthrough = pn;
 236         break;
 237       case TypeFunc::Parms:
 238         _resproj = pn;
 239         break;
 240       default:
 241         assert(false, &quot;unexpected projection from allocation node.&quot;);
 242     }
 243   }
 244 
 245 }
 246 
 247 void PhaseMacroExpand::eliminate_gc_barrier(Node* p2x) {
 248   BarrierSetC2 *bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 249   bs-&gt;eliminate_gc_barrier(this, p2x);
 250 }
 251 
 252 // Search for a memory operation for the specified memory slice.
 253 static Node *scan_mem_chain(Node *mem, int alias_idx, int offset, Node *start_mem, Node *alloc, PhaseGVN *phase) {
 254   Node *orig_mem = mem;
 255   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 256   const TypeOopPtr *tinst = phase-&gt;C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
 257   while (true) {
 258     if (mem == alloc_mem || mem == start_mem ) {
 259       return mem;  // hit one of our sentinels
 260     } else if (mem-&gt;is_MergeMem()) {
 261       mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 262     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 263       Node *in = mem-&gt;in(0);
 264       // we can safely skip over safepoints, calls, locks and membars because we
 265       // already know that the object is safe to eliminate.
 266       if (in-&gt;is_Initialize() &amp;&amp; in-&gt;as_Initialize()-&gt;allocation() == alloc) {
 267         return in;
 268       } else if (in-&gt;is_Call()) {
 269         CallNode *call = in-&gt;as_Call();
 270         if (call-&gt;may_modify(tinst, phase)) {
 271           assert(call-&gt;is_ArrayCopy(), &quot;ArrayCopy is the only call node that doesn&#39;t make allocation escape&quot;);
 272           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 273             return in;
 274           }
 275         }
 276         mem = in-&gt;in(TypeFunc::Memory);
 277       } else if (in-&gt;is_MemBar()) {
 278         ArrayCopyNode* ac = NULL;
 279         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 280           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 281           return ac;
 282         }
 283         mem = in-&gt;in(TypeFunc::Memory);
 284       } else {
 285         assert(false, &quot;unexpected projection&quot;);
 286       }
 287     } else if (mem-&gt;is_Store()) {
 288       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 289       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 290       if (adr_idx == alias_idx) {
 291         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
 292         int adr_offset = atype-&gt;offset();
 293         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 294         // Array elements references have the same alias_idx
 295         // but different offset and different instance_id.
 296         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 297           return mem;
 298       } else {
 299         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 300       }
 301       mem = mem-&gt;in(MemNode::Memory);
 302     } else if (mem-&gt;is_ClearArray()) {
 303       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 304         // Can not bypass initialization of the instance
 305         // we are looking.
 306         debug_only(intptr_t offset;)
 307         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 308         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 309         // We are looking for stored value, return Initialize node
 310         // or memory edge from Allocate node.
 311         if (init != NULL)
 312           return init;
 313         else
 314           return alloc-&gt;in(TypeFunc::Memory); // It will produce zero value (see callers).
 315       }
 316       // Otherwise skip it (the call updated &#39;mem&#39; value).
 317     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 318       mem = mem-&gt;in(0);
 319       Node* adr = NULL;
 320       if (mem-&gt;is_LoadStore()) {
 321         adr = mem-&gt;in(MemNode::Address);
 322       } else {
 323         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 324                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 325         adr = mem-&gt;in(3); // Destination array
 326       }
 327       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 328       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 329       if (adr_idx == alias_idx) {
 330         DEBUG_ONLY(mem-&gt;dump();)
 331         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 332         return NULL;
 333       }
 334       mem = mem-&gt;in(MemNode::Memory);
 335    } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {
 336       Node* adr = mem-&gt;in(3); // Destination array
 337       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 338       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 339       if (adr_idx == alias_idx) {
 340         DEBUG_ONLY(mem-&gt;dump();)
 341         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 342         return NULL;
 343       }
 344       mem = mem-&gt;in(MemNode::Memory);
 345     } else {
 346       return mem;
 347     }
 348     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 349   }
 350 }
 351 
 352 // Generate loads from source of the arraycopy for fields of
 353 // destination needed at a deoptimization point
 354 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 355   BasicType bt = ft;
 356   const Type *type = ftype;
 357   if (ft == T_NARROWOOP) {
 358     bt = T_OBJECT;
 359     type = ftype-&gt;make_oopptr();
 360   }
 361   Node* res = NULL;
 362   if (ac-&gt;is_clonebasic()) {
 363     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 364     Node* base = ac-&gt;in(ArrayCopyNode::Src)-&gt;in(AddPNode::Base);
 365     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 366     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 367     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 368   } else {
 369     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 370       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 371       uint shift = exact_log2(type2aelembytes(bt));
 372       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 373       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 374       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 375       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 376 
 377       Node* adr = NULL;
 378       const TypePtr* adr_type = NULL;
 379       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 380         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
 381         Node* base = ac-&gt;in(ArrayCopyNode::Src);
 382         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));
 383         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(off);
 384         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 385           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 386           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 387         }
 388       } else {
 389         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 390 #ifdef _LP64
 391         diff = _igvn.transform(new ConvI2LNode(diff));
 392 #endif
 393         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 394 
 395         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
 396         Node* base = ac-&gt;in(ArrayCopyNode::Src);
 397         adr = _igvn.transform(new AddPNode(base, base, off));
 398         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(Type::OffsetBot);
 399         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 400           // Non constant offset in the array: we can&#39;t statically
 401           // determine the value
 402           return NULL;
 403         }
 404       }
 405       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 406     }
 407   }
 408   if (res != NULL) {
 409     res = _igvn.transform(res);
 410     if (ftype-&gt;isa_narrowoop()) {
 411       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
 412       res = _igvn.transform(new EncodePNode(res, ftype));
 413     }
 414     return res;
 415   }
 416   return NULL;
 417 }
 418 
 419 //
 420 // Given a Memory Phi, compute a value Phi containing the values from stores
 421 // on the input paths.
 422 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 423 // Returns the computed Phi, or NULL if it cannot compute it.
 424 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 425   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 426   int alias_idx = C-&gt;get_alias_index(adr_t);
 427   int offset = adr_t-&gt;offset();
 428   int instance_id = adr_t-&gt;instance_id();
 429 
 430   // Check if an appropriate value phi already exists.
 431   Node* region = mem-&gt;in(0);
 432   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 433     Node* phi = region-&gt;fast_out(k);
 434     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 435         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 436       return phi;
 437     }
 438   }
 439   // Check if an appropriate new value phi already exists.
 440   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 441   if (new_phi != NULL)
 442     return new_phi;
 443 
 444   if (level &lt;= 0) {
 445     return NULL; // Give up: phi tree too deep
 446   }
 447   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 448   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 449 
 450   uint length = mem-&gt;req();
 451   GrowableArray &lt;Node *&gt; values(length, length, NULL, false);
 452 
 453   // create a new Phi for the value
 454   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 455   transform_later(phi);
 456   value_phis-&gt;push(phi, mem-&gt;_idx);
 457 
 458   for (uint j = 1; j &lt; length; j++) {
 459     Node *in = mem-&gt;in(j);
 460     if (in == NULL || in-&gt;is_top()) {
 461       values.at_put(j, in);
 462     } else  {
 463       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 464       if (val == start_mem || val == alloc_mem) {
 465         // hit a sentinel, return appropriate 0 value
 466         values.at_put(j, _igvn.zerocon(ft));
 467         continue;
 468       }
 469       if (val-&gt;is_Initialize()) {
 470         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 471       }
 472       if (val == NULL) {
 473         return NULL;  // can&#39;t find a value on this path
 474       }
 475       if (val == mem) {
 476         values.at_put(j, mem);
 477       } else if (val-&gt;is_Store()) {
 478         Node* n = val-&gt;in(MemNode::ValueIn);
 479         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 480         n = bs-&gt;step_over_gc_barrier(n);
 481         values.at_put(j, n);
 482       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
 483         values.at_put(j, _igvn.zerocon(ft));
 484       } else if (val-&gt;is_Phi()) {
 485         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 486         if (val == NULL) {
 487           return NULL;
 488         }
 489         values.at_put(j, val);
 490       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 491         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 492                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 493                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 494         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 495         return NULL;
 496       } else if (val-&gt;is_ArrayCopy()) {
 497         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 498         if (res == NULL) {
 499           return NULL;
 500         }
 501         values.at_put(j, res);
 502       } else {
 503 #ifdef ASSERT
 504         val-&gt;dump();
 505         assert(false, &quot;unknown node on this path&quot;);
 506 #endif
 507         return NULL;  // unknown node on this path
 508       }
 509     }
 510   }
 511   // Set Phi&#39;s inputs
 512   for (uint j = 1; j &lt; length; j++) {
 513     if (values.at(j) == mem) {
 514       phi-&gt;init_req(j, phi);
 515     } else {
 516       phi-&gt;init_req(j, values.at(j));
 517     }
 518   }
 519   return phi;
 520 }
 521 
 522 // Search the last value stored into the object&#39;s field.
 523 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 524   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 525   int instance_id = adr_t-&gt;instance_id();
 526   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 527 
 528   int alias_idx = C-&gt;get_alias_index(adr_t);
 529   int offset = adr_t-&gt;offset();
 530   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 531   Node *alloc_ctrl = alloc-&gt;in(TypeFunc::Control);
 532   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 533   Arena *a = Thread::current()-&gt;resource_area();
 534   VectorSet visited(a);
 535 
 536   bool done = sfpt_mem == alloc_mem;
 537   Node *mem = sfpt_mem;
 538   while (!done) {
 539     if (visited.test_set(mem-&gt;_idx)) {
 540       return NULL;  // found a loop, give up
 541     }
 542     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 543     if (mem == start_mem || mem == alloc_mem) {
 544       done = true;  // hit a sentinel, return appropriate 0 value
 545     } else if (mem-&gt;is_Initialize()) {
 546       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 547       if (mem == NULL) {
 548         done = true; // Something go wrong.
 549       } else if (mem-&gt;is_Store()) {
 550         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 551         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 552         done = true;
 553       }
 554     } else if (mem-&gt;is_Store()) {
 555       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 556       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 557       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
 558              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;offset() == offset &amp;&amp;
 559              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 560       done = true;
 561     } else if (mem-&gt;is_Phi()) {
 562       // try to find a phi&#39;s unique input
 563       Node *unique_input = NULL;
 564       Node *top = C-&gt;top();
 565       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 566         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 567         if (n == NULL || n == top || n == mem) {
 568           continue;
 569         } else if (unique_input == NULL) {
 570           unique_input = n;
 571         } else if (unique_input != n) {
 572           unique_input = top;
 573           break;
 574         }
 575       }
 576       if (unique_input != NULL &amp;&amp; unique_input != top) {
 577         mem = unique_input;
 578       } else {
 579         done = true;
 580       }
 581     } else if (mem-&gt;is_ArrayCopy()) {
 582       done = true;
 583     } else {
 584       assert(false, &quot;unexpected node&quot;);
 585     }
 586   }
 587   if (mem != NULL) {
 588     if (mem == start_mem || mem == alloc_mem) {
 589       // hit a sentinel, return appropriate 0 value
 590       return _igvn.zerocon(ft);
 591     } else if (mem-&gt;is_Store()) {
 592       Node* n = mem-&gt;in(MemNode::ValueIn);
 593       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 594       n = bs-&gt;step_over_gc_barrier(n);
 595       return n;
 596     } else if (mem-&gt;is_Phi()) {
 597       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 598       Node_Stack value_phis(a, 8);
 599       Node * phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 600       if (phi != NULL) {
 601         return phi;
 602       } else {
 603         // Kill all new Phis
 604         while(value_phis.is_nonempty()) {
 605           Node* n = value_phis.node();
 606           _igvn.replace_node(n, C-&gt;top());
 607           value_phis.pop();
 608         }
 609       }
 610     } else if (mem-&gt;is_ArrayCopy()) {
 611       Node* ctl = mem-&gt;in(0);
 612       Node* m = mem-&gt;in(TypeFunc::Memory);
 613       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 614         // pin the loads in the uncommon trap path
 615         ctl = sfpt_ctl;
 616         m = sfpt_mem;
 617       }
 618       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 619     }
 620   }
 621   // Something go wrong.
 622   return NULL;
 623 }
 624 
 625 // Check the possibility of scalar replacement.
 626 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 627   //  Scan the uses of the allocation to check for anything that would
 628   //  prevent us from eliminating it.
 629   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 630   DEBUG_ONLY( Node* disq_node = NULL; )
 631   bool  can_eliminate = true;
 632 
 633   Node* res = alloc-&gt;result_cast();
 634   const TypeOopPtr* res_type = NULL;
 635   if (res == NULL) {
 636     // All users were eliminated.
 637   } else if (!res-&gt;is_CheckCastPP()) {
 638     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 639     can_eliminate = false;
 640   } else {
 641     res_type = _igvn.type(res)-&gt;isa_oopptr();
 642     if (res_type == NULL) {
 643       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 644       can_eliminate = false;
 645     } else if (res_type-&gt;isa_aryptr()) {
 646       int length = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 647       if (length &lt; 0) {
 648         NOT_PRODUCT(fail_eliminate = &quot;Array&#39;s size is not constant&quot;;)
 649         can_eliminate = false;
 650       }
 651     }
 652   }
 653 
 654   if (can_eliminate &amp;&amp; res != NULL) {
 655     for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax);
 656                                j &lt; jmax &amp;&amp; can_eliminate; j++) {
 657       Node* use = res-&gt;fast_out(j);
 658 
 659       if (use-&gt;is_AddP()) {
 660         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 661         int offset = addp_type-&gt;offset();
 662 
 663         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 664           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 665           can_eliminate = false;
 666           break;
 667         }
 668         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 669                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 670           Node* n = use-&gt;fast_out(k);
 671           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X &amp;&amp;
 672               SHENANDOAHGC_ONLY((!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n)) &amp;&amp;)
 673               !(n-&gt;is_ArrayCopy() &amp;&amp;
 674                 n-&gt;as_ArrayCopy()-&gt;is_clonebasic() &amp;&amp;
 675                 n-&gt;in(ArrayCopyNode::Dest) == use)) {
 676             DEBUG_ONLY(disq_node = n;)
 677             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 678               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 679             } else {
 680               NOT_PRODUCT(fail_eliminate = &quot;Not store field referrence&quot;;)
 681             }
 682             can_eliminate = false;
 683           }
 684         }
 685       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 686                  (use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 687                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 688                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 689                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 690         // ok to eliminate
 691       } else if (use-&gt;is_SafePoint()) {
 692         SafePointNode* sfpt = use-&gt;as_SafePoint();
 693         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 694           // Object is passed as argument.
 695           DEBUG_ONLY(disq_node = use;)
 696           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 697           can_eliminate = false;
 698         }
 699         Node* sfptMem = sfpt-&gt;memory();
 700         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 701           DEBUG_ONLY(disq_node = use;)
 702           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 703           can_eliminate = false;
 704         } else {
 705           safepoints.append_if_missing(sfpt);
 706         }
 707       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 708         if (use-&gt;is_Phi()) {
 709           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 710             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 711           } else {
 712             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 713           }
 714           DEBUG_ONLY(disq_node = use;)
 715         } else {
 716           if (use-&gt;Opcode() == Op_Return) {
 717             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 718           }else {
 719             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 720           }
 721           DEBUG_ONLY(disq_node = use;)
 722         }
 723         can_eliminate = false;
 724       }
 725     }
 726   }
 727 
 728 #ifndef PRODUCT
 729   if (PrintEliminateAllocations) {
 730     if (can_eliminate) {
 731       tty-&gt;print(&quot;Scalar &quot;);
 732       if (res == NULL)
 733         alloc-&gt;dump();
 734       else
 735         res-&gt;dump();
 736     } else if (alloc-&gt;_is_scalar_replaceable) {
 737       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 738       if (res == NULL)
 739         alloc-&gt;dump();
 740       else
 741         res-&gt;dump();
 742 #ifdef ASSERT
 743       if (disq_node != NULL) {
 744           tty-&gt;print(&quot;  &gt;&gt;&gt;&gt; &quot;);
 745           disq_node-&gt;dump();
 746       }
 747 #endif /*ASSERT*/
 748     }
 749   }
 750 #endif
 751   return can_eliminate;
 752 }
 753 
 754 // Do scalar replacement.
 755 bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 756   GrowableArray &lt;SafePointNode *&gt; safepoints_done;
 757 
 758   ciKlass* klass = NULL;
 759   ciInstanceKlass* iklass = NULL;
 760   int nfields = 0;
 761   int array_base = 0;
 762   int element_size = 0;
 763   BasicType basic_elem_type = T_ILLEGAL;
 764   ciType* elem_type = NULL;
 765 
 766   Node* res = alloc-&gt;result_cast();
 767   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 768   const TypeOopPtr* res_type = NULL;
 769   if (res != NULL) { // Could be NULL when there are no users
 770     res_type = _igvn.type(res)-&gt;isa_oopptr();
 771   }
 772 
 773   if (res != NULL) {
 774     klass = res_type-&gt;klass();
 775     if (res_type-&gt;isa_instptr()) {
 776       // find the fields of the class which will be needed for safepoint debug information
 777       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 778       iklass = klass-&gt;as_instance_klass();
 779       nfields = iklass-&gt;nof_nonstatic_fields();
 780     } else {
 781       // find the array&#39;s elements which will be needed for safepoint debug information
 782       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 783       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 784       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 785       basic_elem_type = elem_type-&gt;basic_type();
 786       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 787       element_size = type2aelembytes(basic_elem_type);
 788     }
 789   }
 790   //
 791   // Process the safepoint uses
 792   //
 793   while (safepoints.length() &gt; 0) {
 794     SafePointNode* sfpt = safepoints.pop();
 795     Node* mem = sfpt-&gt;memory();
 796     Node* ctl = sfpt-&gt;control();
 797     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 798     // Fields of scalar objs are referenced only at the end
 799     // of regular debuginfo at the last (youngest) JVMS.
 800     // Record relative start index.
 801     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 802     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 803 #ifdef ASSERT
 804                                                  alloc,
 805 #endif
 806                                                  first_ind, nfields);
 807     sobj-&gt;init_req(0, C-&gt;root());
 808     transform_later(sobj);
 809 
 810     // Scan object&#39;s fields adding an input to the safepoint for each field.
 811     for (int j = 0; j &lt; nfields; j++) {
 812       intptr_t offset;
 813       ciField* field = NULL;
 814       if (iklass != NULL) {
 815         field = iklass-&gt;nonstatic_field_at(j);
 816         offset = field-&gt;offset();
 817         elem_type = field-&gt;type();
 818         basic_elem_type = field-&gt;layout_type();
 819       } else {
 820         offset = array_base + j * (intptr_t)element_size;
 821       }
 822 
 823       const Type *field_type;
 824       // The next code is taken from Parse::do_get_xxx().
 825       if (is_reference_type(basic_elem_type)) {
 826         if (!elem_type-&gt;is_loaded()) {
 827           field_type = TypeInstPtr::BOTTOM;
 828         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 829           // This can happen if the constant oop is non-perm.
 830           ciObject* con = field-&gt;constant_value().as_object();
 831           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 832           // and may yield a vacuous result if the field is of interface type.
 833           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 834           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 835         } else {
 836           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 837         }
 838         if (UseCompressedOops) {
 839           field_type = field_type-&gt;make_narrowoop();
 840           basic_elem_type = T_NARROWOOP;
 841         }
 842       } else {
 843         field_type = Type::get_const_basic_type(basic_elem_type);
 844       }
 845 
 846       const TypeOopPtr *field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();
 847 
 848       Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);
 849       if (field_val == NULL) {
 850         // We weren&#39;t able to find a value for this field,
 851         // give up on eliminating this allocation.
 852 
 853         // Remove any extra entries we added to the safepoint.
 854         uint last = sfpt-&gt;req() - 1;
 855         for (int k = 0;  k &lt; j; k++) {
 856           sfpt-&gt;del_req(last--);
 857         }
 858         _igvn._worklist.push(sfpt);
 859         // rollback processed safepoints
 860         while (safepoints_done.length() &gt; 0) {
 861           SafePointNode* sfpt_done = safepoints_done.pop();
 862           // remove any extra entries we added to the safepoint
 863           last = sfpt_done-&gt;req() - 1;
 864           for (int k = 0;  k &lt; nfields; k++) {
 865             sfpt_done-&gt;del_req(last--);
 866           }
 867           JVMState *jvms = sfpt_done-&gt;jvms();
 868           jvms-&gt;set_endoff(sfpt_done-&gt;req());
 869           // Now make a pass over the debug information replacing any references
 870           // to SafePointScalarObjectNode with the allocated object.
 871           int start = jvms-&gt;debug_start();
 872           int end   = jvms-&gt;debug_end();
 873           for (int i = start; i &lt; end; i++) {
 874             if (sfpt_done-&gt;in(i)-&gt;is_SafePointScalarObject()) {
 875               SafePointScalarObjectNode* scobj = sfpt_done-&gt;in(i)-&gt;as_SafePointScalarObject();
 876               if (scobj-&gt;first_index(jvms) == sfpt_done-&gt;req() &amp;&amp;
 877                   scobj-&gt;n_fields() == (uint)nfields) {
 878                 assert(scobj-&gt;alloc() == alloc, &quot;sanity&quot;);
 879                 sfpt_done-&gt;set_req(i, res);
 880               }
 881             }
 882           }
 883           _igvn._worklist.push(sfpt_done);
 884         }
 885 #ifndef PRODUCT
 886         if (PrintEliminateAllocations) {
 887           if (field != NULL) {
 888             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 889                        sfpt-&gt;_idx);
 890             field-&gt;print();
 891             int field_idx = C-&gt;get_alias_index(field_addr_type);
 892             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 893           } else { // Array&#39;s element
 894             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 895                        sfpt-&gt;_idx, j);
 896           }
 897           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 898           if (res == NULL)
 899             alloc-&gt;dump();
 900           else
 901             res-&gt;dump();
 902         }
 903 #endif
 904         return false;
 905       }
 906       if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {
 907         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 908         // to be able scalar replace the allocation.
 909         if (field_val-&gt;is_EncodeP()) {
 910           field_val = field_val-&gt;in(1);
 911         } else {
 912           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 913         }
 914       }
 915       sfpt-&gt;add_req(field_val);
 916     }
 917     JVMState *jvms = sfpt-&gt;jvms();
 918     jvms-&gt;set_endoff(sfpt-&gt;req());
 919     // Now make a pass over the debug information replacing any references
 920     // to the allocated object with &quot;sobj&quot;
 921     int start = jvms-&gt;debug_start();
 922     int end   = jvms-&gt;debug_end();
 923     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 924     _igvn._worklist.push(sfpt);
 925     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 926   }
 927   return true;
 928 }
 929 
 930 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 931   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 932   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 933   if (ctl_proj != NULL) {
 934     igvn.replace_node(ctl_proj, n-&gt;in(0));
 935   }
 936   if (mem_proj != NULL) {
 937     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 938   }
 939 }
 940 
 941 // Process users of eliminated allocation.
 942 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {
 943   Node* res = alloc-&gt;result_cast();
 944   if (res != NULL) {
 945     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 946       Node *use = res-&gt;last_out(j);
 947       uint oc1 = res-&gt;outcnt();
 948 
 949       if (use-&gt;is_AddP()) {
 950         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 951           Node *n = use-&gt;last_out(k);
 952           uint oc2 = use-&gt;outcnt();
 953           if (n-&gt;is_Store()) {
 954 #ifdef ASSERT
 955             // Verify that there is no dependent MemBarVolatile nodes,
 956             // they should be removed during IGVN, see MemBarNode::Ideal().
 957             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax);
 958                                        p &lt; pmax; p++) {
 959               Node* mb = n-&gt;fast_out(p);
 960               assert(mb-&gt;is_Initialize() || !mb-&gt;is_MemBar() ||
 961                      mb-&gt;req() &lt;= MemBarNode::Precedent ||
 962                      mb-&gt;in(MemBarNode::Precedent) != n,
 963                      &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);
 964             }
 965 #endif
 966             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
 967           } else if (n-&gt;is_ArrayCopy()) {
 968             // Disconnect ArrayCopy node
 969             ArrayCopyNode* ac = n-&gt;as_ArrayCopy();
 970             assert(ac-&gt;is_clonebasic(), &quot;unexpected array copy kind&quot;);
 971             Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
 972             disconnect_projections(ac, _igvn);
 973             assert(alloc-&gt;in(0)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
 974             Node* membar_before = alloc-&gt;in(0)-&gt;in(0);
 975             disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
 976             if (membar_after-&gt;is_MemBar()) {
 977               disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
 978             }
 979           } else {
 980             eliminate_gc_barrier(n);
 981           }
 982           k -= (oc2 - use-&gt;outcnt());
 983         }
 984         _igvn.remove_dead_node(use);
 985       } else if (use-&gt;is_ArrayCopy()) {
 986         // Disconnect ArrayCopy node
 987         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
 988         assert(ac-&gt;is_arraycopy_validated() ||
 989                ac-&gt;is_copyof_validated() ||
 990                ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
 991         CallProjections callprojs;
 992         ac-&gt;extract_projections(&amp;callprojs, true);
 993 
 994         _igvn.replace_node(callprojs.fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));
 995         _igvn.replace_node(callprojs.fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));
 996         _igvn.replace_node(callprojs.fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));
 997 
 998         // Set control to top. IGVN will remove the remaining projections
 999         ac-&gt;set_req(0, top());
1000         ac-&gt;replace_edge(res, top());
1001 
1002         // Disconnect src right away: it can help find new
1003         // opportunities for allocation elimination
1004         Node* src = ac-&gt;in(ArrayCopyNode::Src);
1005         ac-&gt;replace_edge(src, top());
1006         // src can be top at this point if src and dest of the
1007         // arraycopy were the same
1008         if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
1009           _igvn.remove_dead_node(src);
1010         }
1011 
1012         _igvn._worklist.push(ac);
1013       } else {
1014         eliminate_gc_barrier(use);
1015       }
1016       j -= (oc1 - res-&gt;outcnt());
1017     }
1018     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1019     _igvn.remove_dead_node(res);
1020   }
1021 
1022   //
1023   // Process other users of allocation&#39;s projections
1024   //
1025   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1026     // First disconnect stores captured by Initialize node.
1027     // If Initialize node is eliminated first in the following code,
1028     // it will kill such stores and DUIterator_Last will assert.
1029     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1030       Node *use = _resproj-&gt;fast_out(j);
1031       if (use-&gt;is_AddP()) {
1032         // raw memory addresses used only by the initialization
1033         _igvn.replace_node(use, C-&gt;top());
1034         --j; --jmax;
1035       }
1036     }
1037     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1038       Node *use = _resproj-&gt;last_out(j);
1039       uint oc1 = _resproj-&gt;outcnt();
1040       if (use-&gt;is_Initialize()) {
1041         // Eliminate Initialize node.
1042         InitializeNode *init = use-&gt;as_Initialize();
1043         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1044         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1045         if (ctrl_proj != NULL) {
1046           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1047 #ifdef ASSERT
1048           Node* tmp = init-&gt;in(TypeFunc::Control);
1049           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1050 #endif
1051         }
1052         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1053         if (mem_proj != NULL) {
1054           Node *mem = init-&gt;in(TypeFunc::Memory);
1055 #ifdef ASSERT
1056           if (mem-&gt;is_MergeMem()) {
1057             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1058           } else {
1059             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1060           }
1061 #endif
1062           _igvn.replace_node(mem_proj, mem);
1063         }
1064       } else  {
1065         assert(false, &quot;only Initialize or AddP expected&quot;);
1066       }
1067       j -= (oc1 - _resproj-&gt;outcnt());
1068     }
1069   }
1070   if (_fallthroughcatchproj != NULL) {
1071     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1072   }
1073   if (_memproj_fallthrough != NULL) {
1074     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1075   }
1076   if (_memproj_catchall != NULL) {
1077     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1078   }
1079   if (_ioproj_fallthrough != NULL) {
1080     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1081   }
1082   if (_ioproj_catchall != NULL) {
1083     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1084   }
1085   if (_catchallcatchproj != NULL) {
1086     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1087   }
1088 }
1089 
1090 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1091   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1092   // if reallocation fails during deoptimization we&#39;ll pop all
1093   // interpreter frames for this compiled frame and that won&#39;t play
1094   // nice with JVMTI popframe.
1095   if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc-&gt;_is_non_escaping) {
1096     return false;
1097   }
1098   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1099   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
1100   Node* res = alloc-&gt;result_cast();
1101   // Eliminate boxing allocations which are not used
1102   // regardless scalar replacable status.
1103   bool boxing_alloc = C-&gt;eliminate_boxing() &amp;&amp;
1104                       tklass-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1105                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1106   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; (!boxing_alloc || (res != NULL))) {
1107     return false;
1108   }
1109 
1110   extract_call_projections(alloc);
1111 
1112   GrowableArray &lt;SafePointNode *&gt; safepoints;
1113   if (!can_eliminate_allocation(alloc, safepoints)) {
1114     return false;
1115   }
1116 
1117   if (!alloc-&gt;_is_scalar_replaceable) {
1118     assert(res == NULL, &quot;sanity&quot;);
1119     // We can only eliminate allocation if all debug info references
1120     // are already replaced with SafePointScalarObject because
1121     // we can&#39;t search for a fields value without instance_id.
1122     if (safepoints.length() &gt; 0) {
1123       return false;
1124     }
1125   }
1126 
1127   if (!scalar_replacement(alloc, safepoints)) {
1128     return false;
1129   }
1130 
1131   CompileLog* log = C-&gt;log();
1132   if (log != NULL) {
1133     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1134               log-&gt;identify(tklass-&gt;klass()));
1135     JVMState* p = alloc-&gt;jvms();
1136     while (p != NULL) {
1137       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1138       p = p-&gt;caller();
1139     }
1140     log-&gt;tail(&quot;eliminate_allocation&quot;);
1141   }
1142 
1143   process_users_of_allocation(alloc);
1144 
1145 #ifndef PRODUCT
1146   if (PrintEliminateAllocations) {
1147     if (alloc-&gt;is_AllocateArray())
1148       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1149     else
1150       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1151   }
1152 #endif
1153 
1154   return true;
1155 }
1156 
1157 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1158   // EA should remove all uses of non-escaping boxing node.
1159   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1160     return false;
1161   }
1162 
1163   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1164 
1165   extract_call_projections(boxing);
1166 
1167   const TypeTuple* r = boxing-&gt;tf()-&gt;range();
1168   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1169   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1170   assert(t != NULL, &quot;sanity&quot;);
1171 
1172   CompileLog* log = C-&gt;log();
1173   if (log != NULL) {
1174     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1175               log-&gt;identify(t-&gt;klass()));
1176     JVMState* p = boxing-&gt;jvms();
1177     while (p != NULL) {
1178       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1179       p = p-&gt;caller();
1180     }
1181     log-&gt;tail(&quot;eliminate_boxing&quot;);
1182   }
1183 
1184   process_users_of_allocation(boxing);
1185 
1186 #ifndef PRODUCT
1187   if (PrintEliminateAllocations) {
1188     tty-&gt;print(&quot;++++ Eliminated: %d &quot;, boxing-&gt;_idx);
1189     boxing-&gt;method()-&gt;print_short_name(tty);
1190     tty-&gt;cr();
1191   }
1192 #endif
1193 
1194   return true;
1195 }
1196 
1197 //---------------------------set_eden_pointers-------------------------
1198 void PhaseMacroExpand::set_eden_pointers(Node* &amp;eden_top_adr, Node* &amp;eden_end_adr) {
1199   if (UseTLAB) {                // Private allocation: load from TLS
1200     Node* thread = transform_later(new ThreadLocalNode());
1201     int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());
1202     int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());
1203     eden_top_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_top_offset);
1204     eden_end_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_end_offset);
1205   } else {                      // Shared allocation: load from globals
1206     CollectedHeap* ch = Universe::heap();
1207     address top_adr = (address)ch-&gt;top_addr();
1208     address end_adr = (address)ch-&gt;end_addr();
1209     eden_top_adr = makecon(TypeRawPtr::make(top_adr));
1210     eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);
1211   }
1212 }
1213 
1214 
1215 Node* PhaseMacroExpand::make_load(Node* ctl, Node* mem, Node* base, int offset, const Type* value_type, BasicType bt) {
1216   Node* adr = basic_plus_adr(base, offset);
1217   const TypePtr* adr_type = adr-&gt;bottom_type()-&gt;is_ptr();
1218   Node* value = LoadNode::make(_igvn, ctl, mem, adr, adr_type, value_type, bt, MemNode::unordered);
1219   transform_later(value);
1220   return value;
1221 }
1222 
1223 
1224 Node* PhaseMacroExpand::make_store(Node* ctl, Node* mem, Node* base, int offset, Node* value, BasicType bt) {
1225   Node* adr = basic_plus_adr(base, offset);
1226   mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);
1227   transform_later(mem);
1228   return mem;
1229 }
1230 
1231 //=============================================================================
1232 //
1233 //                              A L L O C A T I O N
1234 //
1235 // Allocation attempts to be fast in the case of frequent small objects.
1236 // It breaks down like this:
1237 //
1238 // 1) Size in doublewords is computed.  This is a constant for objects and
1239 // variable for most arrays.  Doubleword units are used to avoid size
1240 // overflow of huge doubleword arrays.  We need doublewords in the end for
1241 // rounding.
1242 //
1243 // 2) Size is checked for being &#39;too large&#39;.  Too-large allocations will go
1244 // the slow path into the VM.  The slow path can throw any required
1245 // exceptions, and does all the special checks for very large arrays.  The
1246 // size test can constant-fold away for objects.  For objects with
1247 // finalizers it constant-folds the otherway: you always go slow with
1248 // finalizers.
1249 //
1250 // 3) If NOT using TLABs, this is the contended loop-back point.
1251 // Load-Locked the heap top.  If using TLABs normal-load the heap top.
1252 //
1253 // 4) Check that heap top + size*8 &lt; max.  If we fail go the slow ` route.
1254 // NOTE: &quot;top+size*8&quot; cannot wrap the 4Gig line!  Here&#39;s why: for largish
1255 // &quot;size*8&quot; we always enter the VM, where &quot;largish&quot; is a constant picked small
1256 // enough that there&#39;s always space between the eden max and 4Gig (old space is
1257 // there so it&#39;s quite large) and large enough that the cost of entering the VM
1258 // is dwarfed by the cost to initialize the space.
1259 //
1260 // 5) If NOT using TLABs, Store-Conditional the adjusted heap top back
1261 // down.  If contended, repeat at step 3.  If using TLABs normal-store
1262 // adjusted heap top back down; there is no contention.
1263 //
1264 // 6) If !ZeroTLAB then Bulk-clear the object/array.  Fill in klass &amp; mark
1265 // fields.
1266 //
1267 // 7) Merge with the slow-path; cast the raw memory pointer to the correct
1268 // oop flavor.
1269 //
1270 //=============================================================================
1271 // FastAllocateSizeLimit value is in DOUBLEWORDS.
1272 // Allocations bigger than this always go the slow route.
1273 // This value must be small enough that allocation attempts that need to
1274 // trigger exceptions go the slow route.  Also, it must be small enough so
1275 // that heap_top + size_in_bytes does not wrap around the 4Gig limit.
1276 //=============================================================================j//
1277 // %%% Here is an old comment from parseHelper.cpp; is it outdated?
1278 // The allocator will coalesce int-&gt;oop copies away.  See comment in
1279 // coalesce.cpp about how this works.  It depends critically on the exact
1280 // code shape produced here, so if you are changing this code shape
1281 // make sure the GC info for the heap-top is correct in and around the
1282 // slow-path call.
1283 //
1284 
1285 void PhaseMacroExpand::expand_allocate_common(
1286             AllocateNode* alloc, // allocation node to be expanded
1287             Node* length,  // array length for an array allocation
1288             const TypeFunc* slow_call_type, // Type of slow call
1289             address slow_call_address  // Address of slow call
1290     )
1291 {
1292   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1293   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1294   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1295   Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
1296   Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
1297   Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
1298   assert(ctrl != NULL, &quot;must have control&quot;);
1299 
1300   // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
1301   // they will not be used if &quot;always_slow&quot; is set
1302   enum { slow_result_path = 1, fast_result_path = 2 };
1303   Node *result_region = NULL;
1304   Node *result_phi_rawmem = NULL;
1305   Node *result_phi_rawoop = NULL;
1306   Node *result_phi_i_o = NULL;
1307 
1308   // The initial slow comparison is a size check, the comparison
1309   // we want to do is a BoolTest::gt
1310   bool expand_fast_path = true;
1311   int tv = _igvn.find_int_con(initial_slow_test, -1);
1312   if (tv &gt;= 0) {
1313     // InitialTest has constant result
1314     //   0 - can fit in TLAB
1315     //   1 - always too big or negative
1316     assert(tv &lt;= 1, &quot;0 or 1 if a constant&quot;);
1317     expand_fast_path = (tv == 0);
1318     initial_slow_test = NULL;
1319   } else {
1320     initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
1321   }
1322 
1323   if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
1324       (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
1325     // Force slow-path allocation
1326     expand_fast_path = false;
1327     initial_slow_test = NULL;
1328   }
1329 
1330   bool allocation_has_use = (alloc-&gt;result_cast() != NULL);
1331   if (!allocation_has_use) {
1332     InitializeNode* init = alloc-&gt;initialization();
1333     if (init != NULL) {
1334       yank_initalize_node(init);
1335       assert(init-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);
1336       _igvn.remove_dead_node(init);
1337     }
1338     if (expand_fast_path &amp;&amp; (initial_slow_test == NULL)) {
1339       // Remove allocation node and return.
1340       // Size is a non-negative constant -&gt; no initial check needed -&gt; directly to fast path.
1341       // Also, no usages -&gt; empty fast path -&gt; no fall out to slow path -&gt; nothing left.
1342       yank_alloc_node(alloc);
1343       return;
1344     }
1345   }
1346 
1347   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1348   Node *slow_region = NULL;
1349   Node *toobig_false = ctrl;
1350 
1351   // generate the initial test if necessary
1352   if (initial_slow_test != NULL ) {
1353     assert (expand_fast_path, &quot;Only need test if there is a fast path&quot;);
1354     slow_region = new RegionNode(3);
1355 
1356     // Now make the initial failure test.  Usually a too-big test but
1357     // might be a TRUE for finalizers or a fancy class check for
1358     // newInstance0.
1359     IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);
1360     transform_later(toobig_iff);
1361     // Plug the failing-too-big test into the slow-path region
1362     Node *toobig_true = new IfTrueNode( toobig_iff );
1363     transform_later(toobig_true);
1364     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
1365     toobig_false = new IfFalseNode( toobig_iff );
1366     transform_later(toobig_false);
1367   } else {
1368     // No initial test, just fall into next case
1369     assert(allocation_has_use || !expand_fast_path, &quot;Should already have been handled&quot;);
1370     toobig_false = ctrl;
1371     debug_only(slow_region = NodeSentinel);
1372   }
1373 
1374   // If we are here there are several possibilities
1375   // - expand_fast_path is false - then only a slow path is expanded. That&#39;s it.
1376   // no_initial_check means a constant allocation.
1377   // - If check always evaluates to false -&gt; expand_fast_path is false (see above)
1378   // - If check always evaluates to true -&gt; directly into fast path (but may bailout to slowpath)
1379   // if !allocation_has_use the fast path is empty
1380   // if !allocation_has_use &amp;&amp; no_initial_check
1381   // - Then there are no fastpath that can fall out to slowpath -&gt; no allocation code at all.
1382   //   removed by yank_alloc_node above.
1383 
1384   Node *slow_mem = mem;  // save the current memory state for slow path
1385   // generate the fast allocation code unless we know that the initial test will always go slow
1386   if (expand_fast_path) {
1387     // Fast path modifies only raw memory.
1388     if (mem-&gt;is_MergeMem()) {
1389       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1390     }
1391 
1392     // allocate the Region and Phi nodes for the result
1393     result_region = new RegionNode(3);
1394     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
1395     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1396 
1397     // Grab regular I/O before optional prefetch may change it.
1398     // Slow-path does no I/O so just set it to the original I/O.
1399     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1400 
1401     // Name successful fast-path variables
1402     Node* fast_oop_ctrl;
1403     Node* fast_oop_rawmem;
1404     if (allocation_has_use) {
1405       Node* needgc_ctrl = NULL;
1406       result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);
1407 
1408       intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;
1409       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1410       Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,
1411                                         fast_oop_ctrl, fast_oop_rawmem,
1412                                         prefetch_lines);
1413 
1414       if (initial_slow_test != NULL) {
1415         // This completes all paths into the slow merge point
1416         slow_region-&gt;init_req(need_gc_path, needgc_ctrl);
1417         transform_later(slow_region);
1418       } else {
1419         // No initial slow path needed!
1420         // Just fall from the need-GC path straight into the VM call.
1421         slow_region = needgc_ctrl;
1422       }
1423 
1424       InitializeNode* init = alloc-&gt;initialization();
1425       fast_oop_rawmem = initialize_object(alloc,
1426                                           fast_oop_ctrl, fast_oop_rawmem, fast_oop,
1427                                           klass_node, length, size_in_bytes);
1428       expand_initialize_membar(alloc, init, fast_oop_ctrl, fast_oop_rawmem);
1429       expand_dtrace_alloc_probe(alloc, fast_oop, fast_oop_ctrl, fast_oop_rawmem);
1430 
1431       result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);
1432     } else {
1433       assert (initial_slow_test != NULL, &quot;sanity&quot;);
1434       fast_oop_ctrl   = toobig_false;
1435       fast_oop_rawmem = mem;
1436       transform_later(slow_region);
1437     }
1438 
1439     // Plug in the successful fast-path into the result merge point
1440     result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
1441     result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
1442     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1443   } else {
1444     slow_region = ctrl;
1445     result_phi_i_o = i_o; // Rename it to use in the following code.
1446   }
1447 
1448   // Generate slow-path call
1449   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1450                                OptoRuntime::stub_name(slow_call_address),
1451                                alloc-&gt;jvms()-&gt;bci(),
1452                                TypePtr::BOTTOM);
1453   call-&gt;init_req(TypeFunc::Control,   slow_region);
1454   call-&gt;init_req(TypeFunc::I_O,       top());    // does no i/o
1455   call-&gt;init_req(TypeFunc::Memory,    slow_mem); // may gc ptrs
1456   call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1457   call-&gt;init_req(TypeFunc::FramePtr,  alloc-&gt;in(TypeFunc::FramePtr));
1458 
1459   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1460   if (length != NULL) {
1461     call-&gt;init_req(TypeFunc::Parms+1, length);
1462   }
1463 
1464   // Copy debug information and adjust JVMState information, then replace
1465   // allocate node with the call
1466   copy_call_debug_info((CallNode *) alloc,  call);
1467   if (expand_fast_path) {
1468     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1469   } else {
1470     // Hook i_o projection to avoid its elimination during allocation
1471     // replacement (when only a slow call is generated).
1472     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1473   }
1474   _igvn.replace_node(alloc, call);
1475   transform_later(call);
1476 
1477   // Identify the output projections from the allocate node and
1478   // adjust any references to them.
1479   // The control and io projections look like:
1480   //
1481   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1482   //  Allocate                   Catch
1483   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1484   //
1485   //  We are interested in the CatchProj nodes.
1486   //
1487   extract_call_projections(call);
1488 
1489   // An allocate node has separate memory projections for the uses on
1490   // the control and i_o paths. Replace the control memory projection with
1491   // result_phi_rawmem (unless we are only generating a slow call when
1492   // both memory projections are combined)
1493   if (expand_fast_path &amp;&amp; _memproj_fallthrough != NULL) {
1494     migrate_outs(_memproj_fallthrough, result_phi_rawmem);
1495   }
1496   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1497   // _memproj_catchall so we end up with a call that has only 1 memory projection.
1498   if (_memproj_catchall != NULL ) {
1499     if (_memproj_fallthrough == NULL) {
1500       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1501       transform_later(_memproj_fallthrough);
1502     }
1503     migrate_outs(_memproj_catchall, _memproj_fallthrough);
1504     _igvn.remove_dead_node(_memproj_catchall);
1505   }
1506 
1507   // An allocate node has separate i_o projections for the uses on the control
1508   // and i_o paths. Always replace the control i_o projection with result i_o
1509   // otherwise incoming i_o become dead when only a slow call is generated
1510   // (it is different from memory projections where both projections are
1511   // combined in such case).
1512   if (_ioproj_fallthrough != NULL) {
1513     migrate_outs(_ioproj_fallthrough, result_phi_i_o);
1514   }
1515   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1516   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
1517   if (_ioproj_catchall != NULL ) {
1518     if (_ioproj_fallthrough == NULL) {
1519       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1520       transform_later(_ioproj_fallthrough);
1521     }
1522     migrate_outs(_ioproj_catchall, _ioproj_fallthrough);
1523     _igvn.remove_dead_node(_ioproj_catchall);
1524   }
1525 
1526   // if we generated only a slow call, we are done
1527   if (!expand_fast_path) {
1528     // Now we can unhook i_o.
1529     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1530       call-&gt;set_req(TypeFunc::I_O, top());
1531     } else {
1532       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;sanity&quot;);
1533       // Case of new array with negative size known during compilation.
1534       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1535       // following code since call to runtime will throw exception.
1536       // As result there will be no users of i_o after the call.
1537       // Leave i_o attached to this call to avoid problems in preceding graph.
1538     }
1539     return;
1540   }
1541 
1542   if (_fallthroughcatchproj != NULL) {
1543     ctrl = _fallthroughcatchproj-&gt;clone();
1544     transform_later(ctrl);
1545     _igvn.replace_node(_fallthroughcatchproj, result_region);
1546   } else {
1547     ctrl = top();
1548   }
1549   Node *slow_result;
1550   if (_resproj == NULL) {
1551     // no uses of the allocation result
1552     slow_result = top();
1553   } else {
1554     slow_result = _resproj-&gt;clone();
1555     transform_later(slow_result);
1556     _igvn.replace_node(_resproj, result_phi_rawoop);
1557   }
1558 
1559   // Plug slow-path into result merge point
1560   result_region-&gt;init_req( slow_result_path, ctrl);
1561   transform_later(result_region);
1562   if (allocation_has_use) {
1563     result_phi_rawoop-&gt;init_req(slow_result_path, slow_result);
1564     transform_later(result_phi_rawoop);
1565   }
1566   result_phi_rawmem-&gt;init_req(slow_result_path, _memproj_fallthrough);
1567   transform_later(result_phi_rawmem);
1568   transform_later(result_phi_i_o);
1569   // This completes all paths into the result merge point
1570 }
1571 
1572 // Remove alloc node that has no uses.
1573 void PhaseMacroExpand::yank_alloc_node(AllocateNode* alloc) {
1574   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1575   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1576   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1577 
1578   extract_call_projections(alloc);
1579   if (_fallthroughcatchproj != NULL) {
1580     migrate_outs(_fallthroughcatchproj, ctrl);
1581     _igvn.remove_dead_node(_fallthroughcatchproj);
1582   }
1583   if (_catchallcatchproj != NULL) {
1584     _igvn.rehash_node_delayed(_catchallcatchproj);
1585     _catchallcatchproj-&gt;set_req(0, top());
1586   }
1587   if (_fallthroughproj != NULL) {
1588     Node* catchnode = _fallthroughproj-&gt;unique_ctrl_out();
1589     _igvn.remove_dead_node(catchnode);
1590     _igvn.remove_dead_node(_fallthroughproj);
1591   }
1592   if (_memproj_fallthrough != NULL) {
1593     migrate_outs(_memproj_fallthrough, mem);
1594     _igvn.remove_dead_node(_memproj_fallthrough);
1595   }
1596   if (_ioproj_fallthrough != NULL) {
1597     migrate_outs(_ioproj_fallthrough, i_o);
1598     _igvn.remove_dead_node(_ioproj_fallthrough);
1599   }
1600   if (_memproj_catchall != NULL) {
1601     _igvn.rehash_node_delayed(_memproj_catchall);
1602     _memproj_catchall-&gt;set_req(0, top());
1603   }
1604   if (_ioproj_catchall != NULL) {
1605     _igvn.rehash_node_delayed(_ioproj_catchall);
1606     _ioproj_catchall-&gt;set_req(0, top());
1607   }
1608   _igvn.remove_dead_node(alloc);
1609 }
1610 
1611 void PhaseMacroExpand::expand_initialize_membar(AllocateNode* alloc, InitializeNode* init,
1612                                                 Node*&amp; fast_oop_ctrl, Node*&amp; fast_oop_rawmem) {
1613   // If initialization is performed by an array copy, any required
1614   // MemBarStoreStore was already added. If the object does not
1615   // escape no need for a MemBarStoreStore. If the object does not
1616   // escape in its initializer and memory barrier (MemBarStoreStore or
1617   // stronger) is already added at exit of initializer, also no need
1618   // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore
1619   // so that stores that initialize this object can&#39;t be reordered
1620   // with a subsequent store that makes this object accessible by
1621   // other threads.
1622   // Other threads include java threads and JVM internal threads
1623   // (for example concurrent GC threads). Current concurrent GC
1624   // implementation: G1 will not scan newly created object,
1625   // so it&#39;s safe to skip storestore barrier when allocation does
1626   // not escape.
1627   if (!alloc-&gt;does_not_escape_thread() &amp;&amp;
1628     !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;
1629     (init == NULL || !init-&gt;is_complete_with_arraycopy())) {
1630     if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {
1631       // No InitializeNode or no stores captured by zeroing
1632       // elimination. Simply add the MemBarStoreStore after object
1633       // initialization.
1634       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1635       transform_later(mb);
1636 
1637       mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);
1638       mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);
1639       fast_oop_ctrl = new ProjNode(mb, TypeFunc::Control);
1640       transform_later(fast_oop_ctrl);
1641       fast_oop_rawmem = new ProjNode(mb, TypeFunc::Memory);
1642       transform_later(fast_oop_rawmem);
1643     } else {
1644       // Add the MemBarStoreStore after the InitializeNode so that
1645       // all stores performing the initialization that were moved
1646       // before the InitializeNode happen before the storestore
1647       // barrier.
1648 
1649       Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);
1650       Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);
1651 
1652       MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);
1653       transform_later(mb);
1654 
1655       Node* ctrl = new ProjNode(init, TypeFunc::Control);
1656       transform_later(ctrl);
1657       Node* mem = new ProjNode(init, TypeFunc::Memory);
1658       transform_later(mem);
1659 
1660       // The MemBarStoreStore depends on control and memory coming
1661       // from the InitializeNode
1662       mb-&gt;init_req(TypeFunc::Memory, mem);
1663       mb-&gt;init_req(TypeFunc::Control, ctrl);
1664 
1665       ctrl = new ProjNode(mb, TypeFunc::Control);
1666       transform_later(ctrl);
1667       mem = new ProjNode(mb, TypeFunc::Memory);
1668       transform_later(mem);
1669 
1670       // All nodes that depended on the InitializeNode for control
1671       // and memory must now depend on the MemBarNode that itself
1672       // depends on the InitializeNode
1673       if (init_ctrl != NULL) {
1674         _igvn.replace_node(init_ctrl, ctrl);
1675       }
1676       if (init_mem != NULL) {
1677         _igvn.replace_node(init_mem, mem);
1678       }
1679     }
1680   }
1681 }
1682 
1683 void PhaseMacroExpand::expand_dtrace_alloc_probe(AllocateNode* alloc, Node* oop,
1684                                                 Node*&amp; ctrl, Node*&amp; rawmem) {
1685   if (C-&gt;env()-&gt;dtrace_extended_probes()) {
1686     // Slow-path call
1687     int size = TypeFunc::Parms + 2;
1688     CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),
1689                                           CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),
1690                                           &quot;dtrace_object_alloc&quot;,
1691                                           TypeRawPtr::BOTTOM);
1692 
1693     // Get base of thread-local storage area
1694     Node* thread = new ThreadLocalNode();
1695     transform_later(thread);
1696 
1697     call-&gt;init_req(TypeFunc::Parms + 0, thread);
1698     call-&gt;init_req(TypeFunc::Parms + 1, oop);
1699     call-&gt;init_req(TypeFunc::Control, ctrl);
1700     call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o
1701     call-&gt;init_req(TypeFunc::Memory , ctrl);
1702     call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));
1703     call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));
1704     transform_later(call);
1705     ctrl = new ProjNode(call, TypeFunc::Control);
1706     transform_later(ctrl);
1707     rawmem = new ProjNode(call, TypeFunc::Memory);
1708     transform_later(rawmem);
1709   }
1710 }
1711 
1712 // Remove InitializeNode without use
1713 void PhaseMacroExpand::yank_initalize_node(InitializeNode* initnode) {
1714   assert(initnode-&gt;proj_out_or_null(TypeFunc::Parms) == NULL, &quot;No uses allowed&quot;);
1715 
1716   Node* ctrl_out  = initnode-&gt;proj_out_or_null(TypeFunc::Control);
1717   Node* mem_out   = initnode-&gt;proj_out_or_null(TypeFunc::Memory);
1718 
1719   // Move all uses of each to
1720   if (ctrl_out != NULL ) {
1721     migrate_outs(ctrl_out, initnode-&gt;in(TypeFunc::Control));
1722     _igvn.remove_dead_node(ctrl_out);
1723   }
1724 
1725   // Move all uses of each to
1726   if (mem_out != NULL ) {
1727     migrate_outs(mem_out, initnode-&gt;in(TypeFunc::Memory));
1728     _igvn.remove_dead_node(mem_out);
1729   }
1730 }
1731 
1732 // Helper for PhaseMacroExpand::expand_allocate_common.
1733 // Initializes the newly-allocated storage.
1734 Node*
1735 PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1736                                     Node* control, Node* rawmem, Node* object,
1737                                     Node* klass_node, Node* length,
1738                                     Node* size_in_bytes) {
1739   InitializeNode* init = alloc-&gt;initialization();
1740   // Store the klass &amp; mark bits
1741   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, object, control, rawmem);
1742   if (!mark_node-&gt;is_Con()) {
1743     transform_later(mark_node);
1744   }
1745   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1746 
1747   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1748   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1749 
1750   // Array length
1751   if (length != NULL) {         // Arrays need length field
1752     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1753     // conservatively small header size:
1754     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1755     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1756     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1757       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1758   }
1759 
1760   // Clear the object body, if necessary.
1761   if (init == NULL) {
1762     // The init has somehow disappeared; be cautious and clear everything.
1763     //
1764     // This can happen if a node is allocated but an uncommon trap occurs
1765     // immediately.  In this case, the Initialize gets associated with the
1766     // trap, and may be placed in a different (outer) loop, if the Allocate
1767     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1768     // there can be two Allocates to one Initialize.  The answer in all these
1769     // edge cases is safety first.  It is always safe to clear immediately
1770     // within an Allocate, and then (maybe or maybe not) clear some more later.
1771     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1772       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
1773                                             header_size, size_in_bytes,
1774                                             &amp;_igvn);
1775     }
1776   } else {
1777     if (!init-&gt;is_complete()) {
1778       // Try to win by zeroing only what the init does not store.
1779       // We can also try to do some peephole optimizations,
1780       // such as combining some adjacent subword stores.
1781       rawmem = init-&gt;complete_stores(control, rawmem, object,
1782                                      header_size, size_in_bytes, &amp;_igvn);
1783     }
1784     // We have no more use for this link, since the AllocateNode goes away:
1785     init-&gt;set_req(InitializeNode::RawAddress, top());
1786     // (If we keep the link, it just confuses the register allocator,
1787     // who thinks he sees a real use of the address by the membar.)
1788   }
1789 
1790   return rawmem;
1791 }
1792 
1793 // Generate prefetch instructions for next allocations.
1794 Node* PhaseMacroExpand::prefetch_allocation(Node* i_o, Node*&amp; needgc_false,
1795                                         Node*&amp; contended_phi_rawmem,
1796                                         Node* old_eden_top, Node* new_eden_top,
1797                                         intx lines) {
1798    enum { fall_in_path = 1, pf_path = 2 };
1799    if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 2 ) {
1800       // Generate prefetch allocation with watermark check.
1801       // As an allocation hits the watermark, we will prefetch starting
1802       // at a &quot;distance&quot; away from watermark.
1803 
1804       Node *pf_region = new RegionNode(3);
1805       Node *pf_phi_rawmem = new PhiNode( pf_region, Type::MEMORY,
1806                                                 TypeRawPtr::BOTTOM );
1807       // I/O is used for Prefetch
1808       Node *pf_phi_abio = new PhiNode( pf_region, Type::ABIO );
1809 
1810       Node *thread = new ThreadLocalNode();
1811       transform_later(thread);
1812 
1813       Node *eden_pf_adr = new AddPNode( top()/*not oop*/, thread,
1814                    _igvn.MakeConX(in_bytes(JavaThread::tlab_pf_top_offset())) );
1815       transform_later(eden_pf_adr);
1816 
1817       Node *old_pf_wm = new LoadPNode(needgc_false,
1818                                    contended_phi_rawmem, eden_pf_adr,
1819                                    TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,
1820                                    MemNode::unordered);
1821       transform_later(old_pf_wm);
1822 
1823       // check against new_eden_top
1824       Node *need_pf_cmp = new CmpPNode( new_eden_top, old_pf_wm );
1825       transform_later(need_pf_cmp);
1826       Node *need_pf_bol = new BoolNode( need_pf_cmp, BoolTest::ge );
1827       transform_later(need_pf_bol);
1828       IfNode *need_pf_iff = new IfNode( needgc_false, need_pf_bol,
1829                                        PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN );
1830       transform_later(need_pf_iff);
1831 
1832       // true node, add prefetchdistance
1833       Node *need_pf_true = new IfTrueNode( need_pf_iff );
1834       transform_later(need_pf_true);
1835 
1836       Node *need_pf_false = new IfFalseNode( need_pf_iff );
1837       transform_later(need_pf_false);
1838 
1839       Node *new_pf_wmt = new AddPNode( top(), old_pf_wm,
1840                                     _igvn.MakeConX(AllocatePrefetchDistance) );
1841       transform_later(new_pf_wmt );
1842       new_pf_wmt-&gt;set_req(0, need_pf_true);
1843 
1844       Node *store_new_wmt = new StorePNode(need_pf_true,
1845                                        contended_phi_rawmem, eden_pf_adr,
1846                                        TypeRawPtr::BOTTOM, new_pf_wmt,
1847                                        MemNode::unordered);
1848       transform_later(store_new_wmt);
1849 
1850       // adding prefetches
1851       pf_phi_abio-&gt;init_req( fall_in_path, i_o );
1852 
1853       Node *prefetch_adr;
1854       Node *prefetch;
1855       uint step_size = AllocatePrefetchStepSize;
1856       uint distance = 0;
1857 
1858       for ( intx i = 0; i &lt; lines; i++ ) {
1859         prefetch_adr = new AddPNode( old_pf_wm, new_pf_wmt,
1860                                             _igvn.MakeConX(distance) );
1861         transform_later(prefetch_adr);
1862         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1863         transform_later(prefetch);
1864         distance += step_size;
1865         i_o = prefetch;
1866       }
1867       pf_phi_abio-&gt;set_req( pf_path, i_o );
1868 
1869       pf_region-&gt;init_req( fall_in_path, need_pf_false );
1870       pf_region-&gt;init_req( pf_path, need_pf_true );
1871 
1872       pf_phi_rawmem-&gt;init_req( fall_in_path, contended_phi_rawmem );
1873       pf_phi_rawmem-&gt;init_req( pf_path, store_new_wmt );
1874 
1875       transform_later(pf_region);
1876       transform_later(pf_phi_rawmem);
1877       transform_later(pf_phi_abio);
1878 
1879       needgc_false = pf_region;
1880       contended_phi_rawmem = pf_phi_rawmem;
1881       i_o = pf_phi_abio;
1882    } else if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 3 ) {
1883       // Insert a prefetch instruction for each allocation.
1884       // This code is used to generate 1 prefetch instruction per cache line.
1885 
1886       // Generate several prefetch instructions.
1887       uint step_size = AllocatePrefetchStepSize;
1888       uint distance = AllocatePrefetchDistance;
1889 
1890       // Next cache address.
1891       Node *cache_adr = new AddPNode(old_eden_top, old_eden_top,
1892                                      _igvn.MakeConX(step_size + distance));
1893       transform_later(cache_adr);
1894       cache_adr = new CastP2XNode(needgc_false, cache_adr);
1895       transform_later(cache_adr);
1896       // Address is aligned to execute prefetch to the beginning of cache line size
1897       // (it is important when BIS instruction is used on SPARC as prefetch).
1898       Node* mask = _igvn.MakeConX(~(intptr_t)(step_size-1));
1899       cache_adr = new AndXNode(cache_adr, mask);
1900       transform_later(cache_adr);
1901       cache_adr = new CastX2PNode(cache_adr);
1902       transform_later(cache_adr);
1903 
1904       // Prefetch
1905       Node *prefetch = new PrefetchAllocationNode( contended_phi_rawmem, cache_adr );
1906       prefetch-&gt;set_req(0, needgc_false);
1907       transform_later(prefetch);
1908       contended_phi_rawmem = prefetch;
1909       Node *prefetch_adr;
1910       distance = step_size;
1911       for ( intx i = 1; i &lt; lines; i++ ) {
1912         prefetch_adr = new AddPNode( cache_adr, cache_adr,
1913                                             _igvn.MakeConX(distance) );
1914         transform_later(prefetch_adr);
1915         prefetch = new PrefetchAllocationNode( contended_phi_rawmem, prefetch_adr );
1916         transform_later(prefetch);
1917         distance += step_size;
1918         contended_phi_rawmem = prefetch;
1919       }
1920    } else if( AllocatePrefetchStyle &gt; 0 ) {
1921       // Insert a prefetch for each allocation only on the fast-path
1922       Node *prefetch_adr;
1923       Node *prefetch;
1924       // Generate several prefetch instructions.
1925       uint step_size = AllocatePrefetchStepSize;
1926       uint distance = AllocatePrefetchDistance;
1927       for ( intx i = 0; i &lt; lines; i++ ) {
1928         prefetch_adr = new AddPNode( old_eden_top, new_eden_top,
1929                                             _igvn.MakeConX(distance) );
1930         transform_later(prefetch_adr);
1931         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1932         // Do not let it float too high, since if eden_top == eden_end,
1933         // both might be null.
1934         if( i == 0 ) { // Set control for first prefetch, next follows it
1935           prefetch-&gt;init_req(0, needgc_false);
1936         }
1937         transform_later(prefetch);
1938         distance += step_size;
1939         i_o = prefetch;
1940       }
1941    }
1942    return i_o;
1943 }
1944 
1945 
1946 void PhaseMacroExpand::expand_allocate(AllocateNode *alloc) {
1947   expand_allocate_common(alloc, NULL,
1948                          OptoRuntime::new_instance_Type(),
1949                          OptoRuntime::new_instance_Java());
1950 }
1951 
1952 void PhaseMacroExpand::expand_allocate_array(AllocateArrayNode *alloc) {
1953   Node* length = alloc-&gt;in(AllocateNode::ALength);
1954   InitializeNode* init = alloc-&gt;initialization();
1955   Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
1956   ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1957   address slow_call_address;  // Address of slow call
1958   if (init != NULL &amp;&amp; init-&gt;is_complete_with_arraycopy() &amp;&amp;
1959       k-&gt;is_type_array_klass()) {
1960     // Don&#39;t zero type array during slow allocation in VM since
1961     // it will be initialized later by arraycopy in compiled code.
1962     slow_call_address = OptoRuntime::new_array_nozero_Java();
1963   } else {
1964     slow_call_address = OptoRuntime::new_array_Java();
1965   }
1966   expand_allocate_common(alloc, length,
1967                          OptoRuntime::new_array_Type(),
1968                          slow_call_address);
1969 }
1970 
1971 //-------------------mark_eliminated_box----------------------------------
1972 //
1973 // During EA obj may point to several objects but after few ideal graph
1974 // transformations (CCP) it may point to only one non escaping object
1975 // (but still using phi), corresponding locks and unlocks will be marked
1976 // for elimination. Later obj could be replaced with a new node (new phi)
1977 // and which does not have escape information. And later after some graph
1978 // reshape other locks and unlocks (which were not marked for elimination
1979 // before) are connected to this new obj (phi) but they still will not be
1980 // marked for elimination since new obj has no escape information.
1981 // Mark all associated (same box and obj) lock and unlock nodes for
1982 // elimination if some of them marked already.
1983 void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {
1984   if (oldbox-&gt;as_BoxLock()-&gt;is_eliminated())
1985     return; // This BoxLock node was processed already.
1986 
1987   // New implementation (EliminateNestedLocks) has separate BoxLock
1988   // node for each locked region so mark all associated locks/unlocks as
1989   // eliminated even if different objects are referenced in one locked region
1990   // (for example, OSR compilation of nested loop inside locked scope).
1991   if (EliminateNestedLocks ||
1992       oldbox-&gt;as_BoxLock()-&gt;is_simple_lock_region(NULL, obj)) {
1993     // Box is used only in one lock region. Mark this box as eliminated.
1994     _igvn.hash_delete(oldbox);
1995     oldbox-&gt;as_BoxLock()-&gt;set_eliminated(); // This changes box&#39;s hash value
1996      _igvn.hash_insert(oldbox);
1997 
1998     for (uint i = 0; i &lt; oldbox-&gt;outcnt(); i++) {
1999       Node* u = oldbox-&gt;raw_out(i);
2000       if (u-&gt;is_AbstractLock() &amp;&amp; !u-&gt;as_AbstractLock()-&gt;is_non_esc_obj()) {
2001         AbstractLockNode* alock = u-&gt;as_AbstractLock();
2002         // Check lock&#39;s box since box could be referenced by Lock&#39;s debug info.
2003         if (alock-&gt;box_node() == oldbox) {
2004           // Mark eliminated all related locks and unlocks.
2005 #ifdef ASSERT
2006           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc4&quot;);
2007 #endif
2008           alock-&gt;set_non_esc_obj();
2009         }
2010       }
2011     }
2012     return;
2013   }
2014 
2015   // Create new &quot;eliminated&quot; BoxLock node and use it in monitor debug info
2016   // instead of oldbox for the same object.
2017   BoxLockNode* newbox = oldbox-&gt;clone()-&gt;as_BoxLock();
2018 
2019   // Note: BoxLock node is marked eliminated only here and it is used
2020   // to indicate that all associated lock and unlock nodes are marked
2021   // for elimination.
2022   newbox-&gt;set_eliminated();
2023   transform_later(newbox);
2024 
2025   // Replace old box node with new box for all users of the same object.
2026   for (uint i = 0; i &lt; oldbox-&gt;outcnt();) {
2027     bool next_edge = true;
2028 
2029     Node* u = oldbox-&gt;raw_out(i);
2030     if (u-&gt;is_AbstractLock()) {
2031       AbstractLockNode* alock = u-&gt;as_AbstractLock();
2032       if (alock-&gt;box_node() == oldbox &amp;&amp; alock-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2033         // Replace Box and mark eliminated all related locks and unlocks.
2034 #ifdef ASSERT
2035         alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc5&quot;);
2036 #endif
2037         alock-&gt;set_non_esc_obj();
2038         _igvn.rehash_node_delayed(alock);
2039         alock-&gt;set_box_node(newbox);
2040         next_edge = false;
2041       }
2042     }
2043     if (u-&gt;is_FastLock() &amp;&amp; u-&gt;as_FastLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2044       FastLockNode* flock = u-&gt;as_FastLock();
2045       assert(flock-&gt;box_node() == oldbox, &quot;sanity&quot;);
2046       _igvn.rehash_node_delayed(flock);
2047       flock-&gt;set_box_node(newbox);
2048       next_edge = false;
2049     }
2050 
2051     // Replace old box in monitor debug info.
2052     if (u-&gt;is_SafePoint() &amp;&amp; u-&gt;as_SafePoint()-&gt;jvms()) {
2053       SafePointNode* sfn = u-&gt;as_SafePoint();
2054       JVMState* youngest_jvms = sfn-&gt;jvms();
2055       int max_depth = youngest_jvms-&gt;depth();
2056       for (int depth = 1; depth &lt;= max_depth; depth++) {
2057         JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2058         int num_mon  = jvms-&gt;nof_monitors();
2059         // Loop over monitors
2060         for (int idx = 0; idx &lt; num_mon; idx++) {
2061           Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2062           Node* box_node = sfn-&gt;monitor_box(jvms, idx);
2063           if (box_node == oldbox &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2064             int j = jvms-&gt;monitor_box_offset(idx);
2065             _igvn.replace_input_of(u, j, newbox);
2066             next_edge = false;
2067           }
2068         }
2069       }
2070     }
2071     if (next_edge) i++;
2072   }
2073 }
2074 
2075 //-----------------------mark_eliminated_locking_nodes-----------------------
2076 void PhaseMacroExpand::mark_eliminated_locking_nodes(AbstractLockNode *alock) {
2077   if (EliminateNestedLocks) {
2078     if (alock-&gt;is_nested()) {
2079        assert(alock-&gt;box_node()-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2080        return;
2081     } else if (!alock-&gt;is_non_esc_obj()) { // Not eliminated or coarsened
2082       // Only Lock node has JVMState needed here.
2083       // Not that preceding claim is documented anywhere else.
2084       if (alock-&gt;jvms() != NULL) {
2085         if (alock-&gt;as_Lock()-&gt;is_nested_lock_region()) {
2086           // Mark eliminated related nested locks and unlocks.
2087           Node* obj = alock-&gt;obj_node();
2088           BoxLockNode* box_node = alock-&gt;box_node()-&gt;as_BoxLock();
2089           assert(!box_node-&gt;is_eliminated(), &quot;should not be marked yet&quot;);
2090           // Note: BoxLock node is marked eliminated only here
2091           // and it is used to indicate that all associated lock
2092           // and unlock nodes are marked for elimination.
2093           box_node-&gt;set_eliminated(); // Box&#39;s hash is always NO_HASH here
2094           for (uint i = 0; i &lt; box_node-&gt;outcnt(); i++) {
2095             Node* u = box_node-&gt;raw_out(i);
2096             if (u-&gt;is_AbstractLock()) {
2097               alock = u-&gt;as_AbstractLock();
2098               if (alock-&gt;box_node() == box_node) {
2099                 // Verify that this Box is referenced only by related locks.
2100                 assert(alock-&gt;obj_node()-&gt;eqv_uncast(obj), &quot;&quot;);
2101                 // Mark all related locks and unlocks.
2102 #ifdef ASSERT
2103                 alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_nested&quot;);
2104 #endif
2105                 alock-&gt;set_nested();
2106               }
2107             }
2108           }
2109         } else {
2110 #ifdef ASSERT
2111           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_NOT_nested_lock_region&quot;);
2112           if (C-&gt;log() != NULL)
2113             alock-&gt;as_Lock()-&gt;is_nested_lock_region(C); // rerun for debugging output
2114 #endif
2115         }
2116       }
2117       return;
2118     }
2119     // Process locks for non escaping object
2120     assert(alock-&gt;is_non_esc_obj(), &quot;&quot;);
2121   } // EliminateNestedLocks
2122 
2123   if (alock-&gt;is_non_esc_obj()) { // Lock is used for non escaping object
2124     // Look for all locks of this object and mark them and
2125     // corresponding BoxLock nodes as eliminated.
2126     Node* obj = alock-&gt;obj_node();
2127     for (uint j = 0; j &lt; obj-&gt;outcnt(); j++) {
2128       Node* o = obj-&gt;raw_out(j);
2129       if (o-&gt;is_AbstractLock() &amp;&amp;
2130           o-&gt;as_AbstractLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2131         alock = o-&gt;as_AbstractLock();
2132         Node* box = alock-&gt;box_node();
2133         // Replace old box node with new eliminated box for all users
2134         // of the same object and mark related locks as eliminated.
2135         mark_eliminated_box(box, obj);
2136       }
2137     }
2138   }
2139 }
2140 
2141 // we have determined that this lock/unlock can be eliminated, we simply
2142 // eliminate the node without expanding it.
2143 //
2144 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2145 //        eliminated.  This should be investigated as a future enhancement.
2146 //
2147 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2148 
2149   if (!alock-&gt;is_eliminated()) {
2150     return false;
2151   }
2152 #ifdef ASSERT
2153   if (!alock-&gt;is_coarsened()) {
2154     // Check that new &quot;eliminated&quot; BoxLock node is created.
2155     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2156     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2157   }
2158 #endif
2159 
2160   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2161 
2162 #ifndef PRODUCT
2163   if (PrintEliminateLocks) {
2164     if (alock-&gt;is_Lock()) {
2165       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2166     } else {
2167       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2168     }
2169   }
2170 #endif
2171 
2172   Node* mem  = alock-&gt;in(TypeFunc::Memory);
2173   Node* ctrl = alock-&gt;in(TypeFunc::Control);
2174   guarantee(ctrl != NULL, &quot;missing control projection, cannot replace_node() with NULL&quot;);
2175 
2176   extract_call_projections(alock);
2177   // There are 2 projections from the lock.  The lock node will
2178   // be deleted when its last use is subsumed below.
2179   assert(alock-&gt;outcnt() == 2 &amp;&amp;
2180          _fallthroughproj != NULL &amp;&amp;
2181          _memproj_fallthrough != NULL,
2182          &quot;Unexpected projections from Lock/Unlock&quot;);
2183 
2184   Node* fallthroughproj = _fallthroughproj;
2185   Node* memproj_fallthrough = _memproj_fallthrough;
2186 
2187   // The memory projection from a lock/unlock is RawMem
2188   // The input to a Lock is merged memory, so extract its RawMem input
2189   // (unless the MergeMem has been optimized away.)
2190   if (alock-&gt;is_Lock()) {
2191     // Seach for MemBarAcquireLock node and delete it also.
2192     MemBarNode* membar = fallthroughproj-&gt;unique_ctrl_out()-&gt;as_MemBar();
2193     assert(membar != NULL &amp;&amp; membar-&gt;Opcode() == Op_MemBarAcquireLock, &quot;&quot;);
2194     Node* ctrlproj = membar-&gt;proj_out(TypeFunc::Control);
2195     Node* memproj = membar-&gt;proj_out(TypeFunc::Memory);
2196     _igvn.replace_node(ctrlproj, fallthroughproj);
2197     _igvn.replace_node(memproj, memproj_fallthrough);
2198 
2199     // Delete FastLock node also if this Lock node is unique user
2200     // (a loop peeling may clone a Lock node).
2201     Node* flock = alock-&gt;as_Lock()-&gt;fastlock_node();
2202     if (flock-&gt;outcnt() == 1) {
2203       assert(flock-&gt;unique_out() == alock, &quot;sanity&quot;);
2204       _igvn.replace_node(flock, top());
2205     }
2206   }
2207 
2208   // Seach for MemBarReleaseLock node and delete it also.
2209   if (alock-&gt;is_Unlock() &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_MemBar()) {
2210     MemBarNode* membar = ctrl-&gt;in(0)-&gt;as_MemBar();
2211     assert(membar-&gt;Opcode() == Op_MemBarReleaseLock &amp;&amp;
2212            mem-&gt;is_Proj() &amp;&amp; membar == mem-&gt;in(0), &quot;&quot;);
2213     _igvn.replace_node(fallthroughproj, ctrl);
2214     _igvn.replace_node(memproj_fallthrough, mem);
2215     fallthroughproj = ctrl;
2216     memproj_fallthrough = mem;
2217     ctrl = membar-&gt;in(TypeFunc::Control);
2218     mem  = membar-&gt;in(TypeFunc::Memory);
2219   }
2220 
2221   _igvn.replace_node(fallthroughproj, ctrl);
2222   _igvn.replace_node(memproj_fallthrough, mem);
2223   return true;
2224 }
2225 
2226 
2227 //------------------------------expand_lock_node----------------------
2228 void PhaseMacroExpand::expand_lock_node(LockNode *lock) {
2229 
2230   Node* ctrl = lock-&gt;in(TypeFunc::Control);
2231   Node* mem = lock-&gt;in(TypeFunc::Memory);
2232   Node* obj = lock-&gt;obj_node();
2233   Node* box = lock-&gt;box_node();
2234   Node* flock = lock-&gt;fastlock_node();
2235 
2236   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2237 
2238   // Make the merge point
2239   Node *region;
2240   Node *mem_phi;
2241   Node *slow_path;
2242 
2243   if (UseOptoBiasInlining) {
2244     /*
2245      *  See the full description in MacroAssembler::biased_locking_enter().
2246      *
2247      *  if( (mark_word &amp; biased_lock_mask) == biased_lock_pattern ) {
2248      *    // The object is biased.
2249      *    proto_node = klass-&gt;prototype_header;
2250      *    o_node = thread | proto_node;
2251      *    x_node = o_node ^ mark_word;
2252      *    if( (x_node &amp; ~age_mask) == 0 ) { // Biased to the current thread ?
2253      *      // Done.
2254      *    } else {
2255      *      if( (x_node &amp; biased_lock_mask) != 0 ) {
2256      *        // The klass&#39;s prototype header is no longer biased.
2257      *        cas(&amp;mark_word, mark_word, proto_node)
2258      *        goto cas_lock;
2259      *      } else {
2260      *        // The klass&#39;s prototype header is still biased.
2261      *        if( (x_node &amp; epoch_mask) != 0 ) { // Expired epoch?
2262      *          old = mark_word;
2263      *          new = o_node;
2264      *        } else {
2265      *          // Different thread or anonymous biased.
2266      *          old = mark_word &amp; (epoch_mask | age_mask | biased_lock_mask);
2267      *          new = thread | old;
2268      *        }
2269      *        // Try to rebias.
2270      *        if( cas(&amp;mark_word, old, new) == 0 ) {
2271      *          // Done.
2272      *        } else {
2273      *          goto slow_path; // Failed.
2274      *        }
2275      *      }
2276      *    }
2277      *  } else {
2278      *    // The object is not biased.
2279      *    cas_lock:
2280      *    if( FastLock(obj) == 0 ) {
2281      *      // Done.
2282      *    } else {
2283      *      slow_path:
2284      *      OptoRuntime::complete_monitor_locking_Java(obj);
2285      *    }
2286      *  }
2287      */
2288 
2289     region  = new RegionNode(5);
2290     // create a Phi for the memory state
2291     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2292 
2293     Node* fast_lock_region  = new RegionNode(3);
2294     Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);
2295 
2296     // First, check mark word for the biased lock pattern.
2297     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2298 
2299     // Get fast path - mark word has the biased lock pattern.
2300     ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,
2301                          markWord::biased_lock_mask_in_place,
2302                          markWord::biased_lock_pattern, true);
2303     // fast_lock_region-&gt;in(1) is set to slow path.
2304     fast_lock_mem_phi-&gt;init_req(1, mem);
2305 
2306     // Now check that the lock is biased to the current thread and has
2307     // the same epoch and bias as Klass::_prototype_header.
2308 
2309     // Special-case a fresh allocation to avoid building nodes:
2310     Node* klass_node = AllocateNode::Ideal_klass(obj, &amp;_igvn);
2311     if (klass_node == NULL) {
2312       Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
2313       klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)-&gt;is_ptr()));
2314 #ifdef _LP64
2315       if (UseCompressedClassPointers &amp;&amp; klass_node-&gt;is_DecodeNKlass()) {
2316         assert(klass_node-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;sanity&quot;);
2317         klass_node-&gt;in(1)-&gt;init_req(0, ctrl);
2318       } else
2319 #endif
2320       klass_node-&gt;init_req(0, ctrl);
2321     }
2322     Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X-&gt;basic_type());
2323 
2324     Node* thread = transform_later(new ThreadLocalNode());
2325     Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2326     Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));
2327     Node* x_node = transform_later(new XorXNode(o_node, mark_node));
2328 
2329     // Get slow path - mark word does NOT match the value.
2330     STATIC_ASSERT(markWord::age_mask_in_place &lt;= INT_MAX);
2331     Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,
2332                                       (~(int)markWord::age_mask_in_place), 0);
2333     // region-&gt;in(3) is set to fast path - the object is biased to the current thread.
2334     mem_phi-&gt;init_req(3, mem);
2335 
2336 
2337     // Mark word does NOT match the value (thread | Klass::_prototype_header).
2338 
2339 
2340     // First, check biased pattern.
2341     // Get fast path - _prototype_header has the same biased lock pattern.
2342     ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,
2343                           markWord::biased_lock_mask_in_place, 0, true);
2344 
2345     not_biased_ctrl = fast_lock_region-&gt;in(2); // Slow path
2346     // fast_lock_region-&gt;in(2) - the prototype header is no longer biased
2347     // and we have to revoke the bias on this object.
2348     // We are going to try to reset the mark of this object to the prototype
2349     // value and fall through to the CAS-based locking scheme.
2350     Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
2351     Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,
2352                                           proto_node, mark_node);
2353     transform_later(cas);
2354     Node* proj = transform_later(new SCMemProjNode(cas));
2355     fast_lock_mem_phi-&gt;init_req(2, proj);
2356 
2357 
2358     // Second, check epoch bits.
2359     Node* rebiased_region  = new RegionNode(3);
2360     Node* old_phi = new PhiNode( rebiased_region, TypeX_X);
2361     Node* new_phi = new PhiNode( rebiased_region, TypeX_X);
2362 
2363     // Get slow path - mark word does NOT match epoch bits.
2364     Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,
2365                                       markWord::epoch_mask_in_place, 0);
2366     // The epoch of the current bias is not valid, attempt to rebias the object
2367     // toward the current thread.
2368     rebiased_region-&gt;init_req(2, epoch_ctrl);
2369     old_phi-&gt;init_req(2, mark_node);
2370     new_phi-&gt;init_req(2, o_node);
2371 
2372     // rebiased_region-&gt;in(1) is set to fast path.
2373     // The epoch of the current bias is still valid but we know
2374     // nothing about the owner; it might be set or it might be clear.
2375     Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |
2376                              markWord::age_mask_in_place |
2377                              markWord::epoch_mask_in_place);
2378     Node* old = transform_later(new AndXNode(mark_node, cmask));
2379     cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2380     Node* new_mark = transform_later(new OrXNode(cast_thread, old));
2381     old_phi-&gt;init_req(1, old);
2382     new_phi-&gt;init_req(1, new_mark);
2383 
2384     transform_later(rebiased_region);
2385     transform_later(old_phi);
2386     transform_later(new_phi);
2387 
2388     // Try to acquire the bias of the object using an atomic operation.
2389     // If this fails we will go in to the runtime to revoke the object&#39;s bias.
2390     cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);
2391     transform_later(cas);
2392     proj = transform_later(new SCMemProjNode(cas));
2393 
2394     // Get slow path - Failed to CAS.
2395     not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);
2396     mem_phi-&gt;init_req(4, proj);
2397     // region-&gt;in(4) is set to fast path - the object is rebiased to the current thread.
2398 
2399     // Failed to CAS.
2400     slow_path  = new RegionNode(3);
2401     Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);
2402 
2403     slow_path-&gt;init_req(1, not_biased_ctrl); // Capture slow-control
2404     slow_mem-&gt;init_req(1, proj);
2405 
2406     // Call CAS-based locking scheme (FastLock node).
2407 
2408     transform_later(fast_lock_region);
2409     transform_later(fast_lock_mem_phi);
2410 
2411     // Get slow path - FastLock failed to lock the object.
2412     ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);
2413     mem_phi-&gt;init_req(2, fast_lock_mem_phi);
2414     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2415 
2416     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2417     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2418 
2419     transform_later(slow_path);
2420     transform_later(slow_mem);
2421     // Reset lock&#39;s memory edge.
2422     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2423 
2424   } else {
2425     region  = new RegionNode(3);
2426     // create a Phi for the memory state
2427     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2428 
2429     // Optimize test; set region slot 2
2430     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2431     mem_phi-&gt;init_req(2, mem);
2432   }
2433 
2434   // Make slow path call
2435   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2436                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2437                                   obj, box, NULL);
2438 
2439   extract_call_projections(call);
2440 
2441   // Slow path can only throw asynchronous exceptions, which are always
2442   // de-opted.  So the compiler thinks the slow-call can never throw an
2443   // exception.  If it DOES throw an exception we would need the debug
2444   // info removed first (since if it throws there is no monitor).
2445   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2446            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2447 
2448   // Capture slow path
2449   // disconnect fall-through projection from call and create a new one
2450   // hook up users of fall-through projection to region
2451   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2452   transform_later(slow_ctrl);
2453   _igvn.hash_delete(_fallthroughproj);
2454   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2455   region-&gt;init_req(1, slow_ctrl);
2456   // region inputs are now complete
2457   transform_later(region);
2458   _igvn.replace_node(_fallthroughproj, region);
2459 
2460   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory));
2461   mem_phi-&gt;init_req(1, memproj );
2462   transform_later(mem_phi);
2463   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2464 }
2465 
2466 //------------------------------expand_unlock_node----------------------
2467 void PhaseMacroExpand::expand_unlock_node(UnlockNode *unlock) {
2468 
2469   Node* ctrl = unlock-&gt;in(TypeFunc::Control);
2470   Node* mem = unlock-&gt;in(TypeFunc::Memory);
2471   Node* obj = unlock-&gt;obj_node();
2472   Node* box = unlock-&gt;box_node();
2473 
2474   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2475 
2476   // No need for a null check on unlock
2477 
2478   // Make the merge point
2479   Node *region;
2480   Node *mem_phi;
2481 
2482   if (UseOptoBiasInlining) {
2483     // Check for biased locking unlock case, which is a no-op.
2484     // See the full description in MacroAssembler::biased_locking_exit().
2485     region  = new RegionNode(4);
2486     // create a Phi for the memory state
2487     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2488     mem_phi-&gt;init_req(3, mem);
2489 
2490     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2491     ctrl = opt_bits_test(ctrl, region, 3, mark_node,
2492                          markWord::biased_lock_mask_in_place,
2493                          markWord::biased_lock_pattern);
2494   } else {
2495     region  = new RegionNode(3);
2496     // create a Phi for the memory state
2497     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2498   }
2499 
2500   FastUnlockNode *funlock = new FastUnlockNode( ctrl, obj, box );
2501   funlock = transform_later( funlock )-&gt;as_FastUnlock();
2502   // Optimize test; set region slot 2
2503   Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);
2504   Node *thread = transform_later(new ThreadLocalNode());
2505 
2506   CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),
2507                                   CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),
2508                                   &quot;complete_monitor_unlocking_C&quot;, slow_path, obj, box, thread);
2509 
2510   extract_call_projections(call);
2511 
2512   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2513            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2514 
2515   // No exceptions for unlocking
2516   // Capture slow path
2517   // disconnect fall-through projection from call and create a new one
2518   // hook up users of fall-through projection to region
2519   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2520   transform_later(slow_ctrl);
2521   _igvn.hash_delete(_fallthroughproj);
2522   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2523   region-&gt;init_req(1, slow_ctrl);
2524   // region inputs are now complete
2525   transform_later(region);
2526   _igvn.replace_node(_fallthroughproj, region);
2527 
2528   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2529   mem_phi-&gt;init_req(1, memproj );
2530   mem_phi-&gt;init_req(2, mem);
2531   transform_later(mem_phi);
2532   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2533 }
2534 
2535 //---------------------------eliminate_macro_nodes----------------------
2536 // Eliminate scalar replaced allocations and associated locks.
2537 void PhaseMacroExpand::eliminate_macro_nodes() {
2538   if (C-&gt;macro_count() == 0)
2539     return;
2540 
2541   // First, attempt to eliminate locks
2542   int cnt = C-&gt;macro_count();
2543   for (int i=0; i &lt; cnt; i++) {
2544     Node *n = C-&gt;macro_node(i);
2545     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2546       // Before elimination mark all associated (same box and obj)
2547       // lock and unlock nodes.
2548       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2549     }
2550   }
2551   bool progress = true;
2552   while (progress) {
2553     progress = false;
2554     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2555       Node * n = C-&gt;macro_node(i-1);
2556       bool success = false;
2557       debug_only(int old_macro_count = C-&gt;macro_count(););
2558       if (n-&gt;is_AbstractLock()) {
2559         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2560       }
2561       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2562       progress = progress || success;
2563     }
2564   }
2565   // Next, attempt to eliminate allocations
2566   _has_locks = false;
2567   progress = true;
2568   while (progress) {
2569     progress = false;
2570     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2571       Node * n = C-&gt;macro_node(i-1);
2572       bool success = false;
2573       debug_only(int old_macro_count = C-&gt;macro_count(););
2574       switch (n-&gt;class_id()) {
2575       case Node::Class_Allocate:
2576       case Node::Class_AllocateArray:
2577         success = eliminate_allocate_node(n-&gt;as_Allocate());
2578         break;
2579       case Node::Class_CallStaticJava:
2580         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2581         break;
2582       case Node::Class_Lock:
2583       case Node::Class_Unlock:
2584         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2585         _has_locks = true;
2586         break;
2587       case Node::Class_ArrayCopy:
2588         break;
2589       case Node::Class_OuterStripMinedLoop:
2590         break;
2591       default:
2592         assert(n-&gt;Opcode() == Op_LoopLimit ||
2593                n-&gt;Opcode() == Op_Opaque1   ||
2594                n-&gt;Opcode() == Op_Opaque2   ||
2595                n-&gt;Opcode() == Op_Opaque3   ||
2596                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2597                &quot;unknown node type in macro list&quot;);
2598       }
2599       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2600       progress = progress || success;
2601     }
2602   }
2603 }
2604 
2605 //------------------------------expand_macro_nodes----------------------
2606 //  Returns true if a failure occurred.
2607 bool PhaseMacroExpand::expand_macro_nodes() {
2608   // Last attempt to eliminate macro nodes.
2609   eliminate_macro_nodes();
2610 
2611   // Make sure expansion will not cause node limit to be exceeded.
2612   // Worst case is a macro node gets expanded into about 200 nodes.
2613   // Allow 50% more for optimization.
2614   if (C-&gt;check_node_count(C-&gt;macro_count() * 300, &quot;out of nodes before macro expansion&quot; ) )
2615     return true;
2616 
2617   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2618   bool progress = true;
2619   while (progress) {
2620     progress = false;
2621     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2622       Node* n = C-&gt;macro_node(i-1);
2623       bool success = false;
2624       debug_only(int old_macro_count = C-&gt;macro_count(););
2625       if (n-&gt;Opcode() == Op_LoopLimit) {
2626         // Remove it from macro list and put on IGVN worklist to optimize.
2627         C-&gt;remove_macro_node(n);
2628         _igvn._worklist.push(n);
2629         success = true;
2630       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
2631         // Remove it from macro list and put on IGVN worklist to optimize.
2632         C-&gt;remove_macro_node(n);
2633         _igvn._worklist.push(n);
2634         success = true;
2635       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
2636         _igvn.replace_node(n, n-&gt;in(1));
2637         success = true;
2638 #if INCLUDE_RTM_OPT
2639       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
2640         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
2641         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
2642         Node* cmp = n-&gt;unique_out();
2643 #ifdef ASSERT
2644         // Validate graph.
2645         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
2646         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
2647         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
2648                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
2649         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
2650         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
2651                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
2652 #endif
2653         Node* repl = n-&gt;in(1);
2654         if (!_has_locks) {
2655           // Remove RTM state check if there are no locks in the code.
2656           // Replace input to compare the same value.
2657           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
2658         }
2659         _igvn.replace_node(n, repl);
2660         success = true;
2661 #endif
2662       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
2663         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
2664         C-&gt;remove_macro_node(n);
2665         success = true;
2666       }
2667       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
2668       progress = progress || success;
2669     }
2670   }
2671 
2672   // expand arraycopy &quot;macro&quot; nodes first
2673   // For ReduceBulkZeroing, we must first process all arraycopy nodes
2674   // before the allocate nodes are expanded.
2675   for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2676     Node* n = C-&gt;macro_node(i-1);
2677     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2678     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2679       // node is unreachable, so don&#39;t try to expand it
2680       C-&gt;remove_macro_node(n);
2681       continue;
2682     }
2683     debug_only(int old_macro_count = C-&gt;macro_count(););
2684     switch (n-&gt;class_id()) {
2685     case Node::Class_Lock:
2686       expand_lock_node(n-&gt;as_Lock());
2687       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2688       break;
2689     case Node::Class_Unlock:
2690       expand_unlock_node(n-&gt;as_Unlock());
2691       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2692       break;
2693     case Node::Class_ArrayCopy:
2694       expand_arraycopy_node(n-&gt;as_ArrayCopy());
2695       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2696       break;
2697     }
2698     if (C-&gt;failing())  return true;
2699   }
2700 
2701   // All nodes except Allocate nodes are expanded now. There could be
2702   // new optimization opportunities (such as folding newly created
2703   // load from a just allocated object). Run IGVN.
2704   _igvn.set_delay_transform(false);
2705   _igvn.optimize();
2706   if (C-&gt;failing())  return true;
2707 
2708   _igvn.set_delay_transform(true);
2709 
2710   // expand &quot;macro&quot; nodes
2711   // nodes are removed from the macro list as they are processed
2712   while (C-&gt;macro_count() &gt; 0) {
2713     int macro_count = C-&gt;macro_count();
2714     Node * n = C-&gt;macro_node(macro_count-1);
2715     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2716     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2717       // node is unreachable, so don&#39;t try to expand it
2718       C-&gt;remove_macro_node(n);
2719       continue;
2720     }
2721     switch (n-&gt;class_id()) {
2722     case Node::Class_Allocate:
2723       expand_allocate(n-&gt;as_Allocate());
2724       break;
2725     case Node::Class_AllocateArray:
2726       expand_allocate_array(n-&gt;as_AllocateArray());
2727       break;
2728     default:
2729       assert(false, &quot;unknown node type in macro list&quot;);
2730     }
2731     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
2732     if (C-&gt;failing())  return true;
2733   }
2734 
2735   _igvn.set_delay_transform(false);
2736   _igvn.optimize();
2737   if (C-&gt;failing())  return true;
2738   return false;
2739 }
    </pre>
  </body>
</html>