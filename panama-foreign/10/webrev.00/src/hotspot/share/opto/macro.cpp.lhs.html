<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/macro.hpp&quot;
  41 #include &quot;opto/memnode.hpp&quot;
  42 #include &quot;opto/narrowptrnode.hpp&quot;
  43 #include &quot;opto/node.hpp&quot;
  44 #include &quot;opto/opaquenode.hpp&quot;
  45 #include &quot;opto/phaseX.hpp&quot;
  46 #include &quot;opto/rootnode.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #include &quot;opto/subnode.hpp&quot;
  49 #include &quot;opto/type.hpp&quot;
  50 #include &quot;runtime/sharedRuntime.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
  52 #if INCLUDE_G1GC
  53 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  54 #endif // INCLUDE_G1GC
  55 #if INCLUDE_SHENANDOAHGC
  56 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  57 #endif
  58 
  59 
  60 //
  61 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  62 // Returns the number of replacements made.
  63 //
  64 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  65   int nreplacements = 0;
  66   uint req = use-&gt;req();
  67   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  68     Node *uin = use-&gt;in(j);
  69     if (uin == oldref) {
  70       if (j &lt; req)
  71         use-&gt;set_req(j, newref);
  72       else
  73         use-&gt;set_prec(j, newref);
  74       nreplacements++;
  75     } else if (j &gt;= req &amp;&amp; uin == NULL) {
  76       break;
  77     }
  78   }
  79   return nreplacements;
  80 }
  81 
<a name="1" id="anc1"></a>











  82 void PhaseMacroExpand::copy_call_debug_info(CallNode *oldcall, CallNode * newcall) {
  83   // Copy debug information and adjust JVMState information
  84   uint old_dbg_start = oldcall-&gt;tf()-&gt;domain()-&gt;cnt();
  85   uint new_dbg_start = newcall-&gt;tf()-&gt;domain()-&gt;cnt();
  86   int jvms_adj  = new_dbg_start - old_dbg_start;
  87   assert (new_dbg_start == newcall-&gt;req(), &quot;argument count mismatch&quot;);
  88 
  89   // SafePointScalarObject node could be referenced several times in debug info.
  90   // Use Dict to record cloned nodes.
  91   Dict* sosn_map = new Dict(cmpkey,hashkey);
  92   for (uint i = old_dbg_start; i &lt; oldcall-&gt;req(); i++) {
  93     Node* old_in = oldcall-&gt;in(i);
  94     // Clone old SafePointScalarObjectNodes, adjusting their field contents.
  95     if (old_in != NULL &amp;&amp; old_in-&gt;is_SafePointScalarObject()) {
  96       SafePointScalarObjectNode* old_sosn = old_in-&gt;as_SafePointScalarObject();
  97       uint old_unique = C-&gt;unique();
  98       Node* new_in = old_sosn-&gt;clone(sosn_map);
  99       if (old_unique != C-&gt;unique()) { // New node?
 100         new_in-&gt;set_req(0, C-&gt;root()); // reset control edge
 101         new_in = transform_later(new_in); // Register new node.
 102       }
 103       old_in = new_in;
 104     }
 105     newcall-&gt;add_req(old_in);
 106   }
 107 
 108   // JVMS may be shared so clone it before we modify it
 109   newcall-&gt;set_jvms(oldcall-&gt;jvms() != NULL ? oldcall-&gt;jvms()-&gt;clone_deep(C) : NULL);
 110   for (JVMState *jvms = newcall-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
 111     jvms-&gt;set_map(newcall);
 112     jvms-&gt;set_locoff(jvms-&gt;locoff()+jvms_adj);
 113     jvms-&gt;set_stkoff(jvms-&gt;stkoff()+jvms_adj);
 114     jvms-&gt;set_monoff(jvms-&gt;monoff()+jvms_adj);
 115     jvms-&gt;set_scloff(jvms-&gt;scloff()+jvms_adj);
 116     jvms-&gt;set_endoff(jvms-&gt;endoff()+jvms_adj);
 117   }
 118 }
 119 
 120 Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {
 121   Node* cmp;
 122   if (mask != 0) {
 123     Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));
 124     cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));
 125   } else {
 126     cmp = word;
 127   }
 128   Node* bol = transform_later(new BoolNode(cmp, BoolTest::ne));
 129   IfNode* iff = new IfNode( ctrl, bol, PROB_MIN, COUNT_UNKNOWN );
 130   transform_later(iff);
 131 
 132   // Fast path taken.
 133   Node *fast_taken = transform_later(new IfFalseNode(iff));
 134 
 135   // Fast path not-taken, i.e. slow path
 136   Node *slow_taken = transform_later(new IfTrueNode(iff));
 137 
 138   if (return_fast_path) {
 139     region-&gt;init_req(edge, slow_taken); // Capture slow-control
 140     return fast_taken;
 141   } else {
 142     region-&gt;init_req(edge, fast_taken); // Capture fast-control
 143     return slow_taken;
 144   }
 145 }
 146 
 147 //--------------------copy_predefined_input_for_runtime_call--------------------
 148 void PhaseMacroExpand::copy_predefined_input_for_runtime_call(Node * ctrl, CallNode* oldcall, CallNode* call) {
 149   // Set fixed predefined input arguments
 150   call-&gt;init_req( TypeFunc::Control, ctrl );
 151   call-&gt;init_req( TypeFunc::I_O    , oldcall-&gt;in( TypeFunc::I_O) );
 152   call-&gt;init_req( TypeFunc::Memory , oldcall-&gt;in( TypeFunc::Memory ) ); // ?????
 153   call-&gt;init_req( TypeFunc::ReturnAdr, oldcall-&gt;in( TypeFunc::ReturnAdr ) );
 154   call-&gt;init_req( TypeFunc::FramePtr, oldcall-&gt;in( TypeFunc::FramePtr ) );
 155 }
 156 
 157 //------------------------------make_slow_call---------------------------------
 158 CallNode* PhaseMacroExpand::make_slow_call(CallNode *oldcall, const TypeFunc* slow_call_type,
 159                                            address slow_call, const char* leaf_name, Node* slow_path,
 160                                            Node* parm0, Node* parm1, Node* parm2) {
 161 
 162   // Slow-path call
 163  CallNode *call = leaf_name
 164    ? (CallNode*)new CallLeafNode      ( slow_call_type, slow_call, leaf_name, TypeRawPtr::BOTTOM )
 165    : (CallNode*)new CallStaticJavaNode( slow_call_type, slow_call, OptoRuntime::stub_name(slow_call), oldcall-&gt;jvms()-&gt;bci(), TypeRawPtr::BOTTOM );
 166 
 167   // Slow path call has no side-effects, uses few values
 168   copy_predefined_input_for_runtime_call(slow_path, oldcall, call );
 169   if (parm0 != NULL)  call-&gt;init_req(TypeFunc::Parms+0, parm0);
 170   if (parm1 != NULL)  call-&gt;init_req(TypeFunc::Parms+1, parm1);
 171   if (parm2 != NULL)  call-&gt;init_req(TypeFunc::Parms+2, parm2);
 172   copy_call_debug_info(oldcall, call);
 173   call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
 174   _igvn.replace_node(oldcall, call);
 175   transform_later(call);
 176 
 177   return call;
 178 }
 179 
 180 void PhaseMacroExpand::extract_call_projections(CallNode *call) {
 181   _fallthroughproj = NULL;
 182   _fallthroughcatchproj = NULL;
 183   _ioproj_fallthrough = NULL;
 184   _ioproj_catchall = NULL;
 185   _catchallcatchproj = NULL;
 186   _memproj_fallthrough = NULL;
 187   _memproj_catchall = NULL;
 188   _resproj = NULL;
 189   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
 190     ProjNode *pn = call-&gt;fast_out(i)-&gt;as_Proj();
 191     switch (pn-&gt;_con) {
 192       case TypeFunc::Control:
 193       {
 194         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 195         _fallthroughproj = pn;
 196         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 197         const Node *cn = pn-&gt;fast_out(j);
 198         if (cn-&gt;is_Catch()) {
 199           ProjNode *cpn = NULL;
 200           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 201             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 202             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 203             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 204               _fallthroughcatchproj = cpn;
 205             else {
 206               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 207               _catchallcatchproj = cpn;
 208             }
 209           }
 210         }
 211         break;
 212       }
 213       case TypeFunc::I_O:
 214         if (pn-&gt;_is_io_use)
 215           _ioproj_catchall = pn;
 216         else
 217           _ioproj_fallthrough = pn;
 218         break;
 219       case TypeFunc::Memory:
 220         if (pn-&gt;_is_io_use)
 221           _memproj_catchall = pn;
 222         else
 223           _memproj_fallthrough = pn;
 224         break;
 225       case TypeFunc::Parms:
 226         _resproj = pn;
 227         break;
 228       default:
 229         assert(false, &quot;unexpected projection from allocation node.&quot;);
 230     }
 231   }
 232 
 233 }
 234 
 235 void PhaseMacroExpand::eliminate_gc_barrier(Node* p2x) {
 236   BarrierSetC2 *bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 237   bs-&gt;eliminate_gc_barrier(this, p2x);
 238 }
 239 
 240 // Search for a memory operation for the specified memory slice.
 241 static Node *scan_mem_chain(Node *mem, int alias_idx, int offset, Node *start_mem, Node *alloc, PhaseGVN *phase) {
 242   Node *orig_mem = mem;
 243   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 244   const TypeOopPtr *tinst = phase-&gt;C-&gt;get_adr_type(alias_idx)-&gt;isa_oopptr();
 245   while (true) {
 246     if (mem == alloc_mem || mem == start_mem ) {
 247       return mem;  // hit one of our sentinels
 248     } else if (mem-&gt;is_MergeMem()) {
 249       mem = mem-&gt;as_MergeMem()-&gt;memory_at(alias_idx);
 250     } else if (mem-&gt;is_Proj() &amp;&amp; mem-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
 251       Node *in = mem-&gt;in(0);
 252       // we can safely skip over safepoints, calls, locks and membars because we
 253       // already know that the object is safe to eliminate.
 254       if (in-&gt;is_Initialize() &amp;&amp; in-&gt;as_Initialize()-&gt;allocation() == alloc) {
 255         return in;
 256       } else if (in-&gt;is_Call()) {
 257         CallNode *call = in-&gt;as_Call();
 258         if (call-&gt;may_modify(tinst, phase)) {
 259           assert(call-&gt;is_ArrayCopy(), &quot;ArrayCopy is the only call node that doesn&#39;t make allocation escape&quot;);
 260           if (call-&gt;as_ArrayCopy()-&gt;modifies(offset, offset, phase, false)) {
 261             return in;
 262           }
 263         }
 264         mem = in-&gt;in(TypeFunc::Memory);
 265       } else if (in-&gt;is_MemBar()) {
 266         ArrayCopyNode* ac = NULL;
 267         if (ArrayCopyNode::may_modify(tinst, in-&gt;as_MemBar(), phase, ac)) {
 268           assert(ac != NULL &amp;&amp; ac-&gt;is_clonebasic(), &quot;Only basic clone is a non escaping clone&quot;);
 269           return ac;
 270         }
 271         mem = in-&gt;in(TypeFunc::Memory);
 272       } else {
 273         assert(false, &quot;unexpected projection&quot;);
 274       }
 275     } else if (mem-&gt;is_Store()) {
 276       const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 277       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 278       if (adr_idx == alias_idx) {
 279         assert(atype-&gt;isa_oopptr(), &quot;address type must be oopptr&quot;);
 280         int adr_offset = atype-&gt;offset();
 281         uint adr_iid = atype-&gt;is_oopptr()-&gt;instance_id();
 282         // Array elements references have the same alias_idx
 283         // but different offset and different instance_id.
 284         if (adr_offset == offset &amp;&amp; adr_iid == alloc-&gt;_idx)
 285           return mem;
 286       } else {
 287         assert(adr_idx == Compile::AliasIdxRaw, &quot;address must match or be raw&quot;);
 288       }
 289       mem = mem-&gt;in(MemNode::Memory);
 290     } else if (mem-&gt;is_ClearArray()) {
 291       if (!ClearArrayNode::step_through(&amp;mem, alloc-&gt;_idx, phase)) {
 292         // Can not bypass initialization of the instance
 293         // we are looking.
 294         debug_only(intptr_t offset;)
 295         assert(alloc == AllocateNode::Ideal_allocation(mem-&gt;in(3), phase, offset), &quot;sanity&quot;);
 296         InitializeNode* init = alloc-&gt;as_Allocate()-&gt;initialization();
 297         // We are looking for stored value, return Initialize node
 298         // or memory edge from Allocate node.
 299         if (init != NULL)
 300           return init;
 301         else
 302           return alloc-&gt;in(TypeFunc::Memory); // It will produce zero value (see callers).
 303       }
 304       // Otherwise skip it (the call updated &#39;mem&#39; value).
 305     } else if (mem-&gt;Opcode() == Op_SCMemProj) {
 306       mem = mem-&gt;in(0);
 307       Node* adr = NULL;
 308       if (mem-&gt;is_LoadStore()) {
 309         adr = mem-&gt;in(MemNode::Address);
 310       } else {
 311         assert(mem-&gt;Opcode() == Op_EncodeISOArray ||
 312                mem-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 313         adr = mem-&gt;in(3); // Destination array
 314       }
 315       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 316       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 317       if (adr_idx == alias_idx) {
 318         DEBUG_ONLY(mem-&gt;dump();)
 319         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 320         return NULL;
 321       }
 322       mem = mem-&gt;in(MemNode::Memory);
 323    } else if (mem-&gt;Opcode() == Op_StrInflatedCopy) {
 324       Node* adr = mem-&gt;in(3); // Destination array
 325       const TypePtr* atype = adr-&gt;bottom_type()-&gt;is_ptr();
 326       int adr_idx = phase-&gt;C-&gt;get_alias_index(atype);
 327       if (adr_idx == alias_idx) {
 328         DEBUG_ONLY(mem-&gt;dump();)
 329         assert(false, &quot;Object is not scalar replaceable if a StrInflatedCopy node accesses its field&quot;);
 330         return NULL;
 331       }
 332       mem = mem-&gt;in(MemNode::Memory);
 333     } else {
 334       return mem;
 335     }
 336     assert(mem != orig_mem, &quot;dead memory loop&quot;);
 337   }
 338 }
 339 
 340 // Generate loads from source of the arraycopy for fields of
 341 // destination needed at a deoptimization point
 342 Node* PhaseMacroExpand::make_arraycopy_load(ArrayCopyNode* ac, intptr_t offset, Node* ctl, Node* mem, BasicType ft, const Type *ftype, AllocateNode *alloc) {
 343   BasicType bt = ft;
 344   const Type *type = ftype;
 345   if (ft == T_NARROWOOP) {
 346     bt = T_OBJECT;
 347     type = ftype-&gt;make_oopptr();
 348   }
 349   Node* res = NULL;
 350   if (ac-&gt;is_clonebasic()) {
 351     assert(ac-&gt;in(ArrayCopyNode::Src) != ac-&gt;in(ArrayCopyNode::Dest), &quot;clone source equals destination&quot;);
 352     Node* base = ac-&gt;in(ArrayCopyNode::Src)-&gt;in(AddPNode::Base);
 353     Node* adr = _igvn.transform(new AddPNode(base, base, MakeConX(offset)));
 354     const TypePtr* adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(offset);
 355     res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 356   } else {
 357     if (ac-&gt;modifies(offset, offset, &amp;_igvn, true)) {
 358       assert(ac-&gt;in(ArrayCopyNode::Dest) == alloc-&gt;result_cast(), &quot;arraycopy destination should be allocation&#39;s result&quot;);
 359       uint shift = exact_log2(type2aelembytes(bt));
 360       Node* src_pos = ac-&gt;in(ArrayCopyNode::SrcPos);
 361       Node* dest_pos = ac-&gt;in(ArrayCopyNode::DestPos);
 362       const TypeInt* src_pos_t = _igvn.type(src_pos)-&gt;is_int();
 363       const TypeInt* dest_pos_t = _igvn.type(dest_pos)-&gt;is_int();
 364 
 365       Node* adr = NULL;
 366       const TypePtr* adr_type = NULL;
 367       if (src_pos_t-&gt;is_con() &amp;&amp; dest_pos_t-&gt;is_con()) {
 368         intptr_t off = ((src_pos_t-&gt;get_con() - dest_pos_t-&gt;get_con()) &lt;&lt; shift) + offset;
 369         Node* base = ac-&gt;in(ArrayCopyNode::Src);
 370         adr = _igvn.transform(new AddPNode(base, base, MakeConX(off)));
 371         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(off);
 372         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 373           // Don&#39;t emit a new load from src if src == dst but try to get the value from memory instead
 374           return value_from_mem(ac-&gt;in(TypeFunc::Memory), ctl, ft, ftype, adr_type-&gt;isa_oopptr(), alloc);
 375         }
 376       } else {
 377         Node* diff = _igvn.transform(new SubINode(ac-&gt;in(ArrayCopyNode::SrcPos), ac-&gt;in(ArrayCopyNode::DestPos)));
 378 #ifdef _LP64
 379         diff = _igvn.transform(new ConvI2LNode(diff));
 380 #endif
 381         diff = _igvn.transform(new LShiftXNode(diff, intcon(shift)));
 382 
 383         Node* off = _igvn.transform(new AddXNode(MakeConX(offset), diff));
 384         Node* base = ac-&gt;in(ArrayCopyNode::Src);
 385         adr = _igvn.transform(new AddPNode(base, base, off));
 386         adr_type = _igvn.type(base)-&gt;is_ptr()-&gt;add_offset(Type::OffsetBot);
 387         if (ac-&gt;in(ArrayCopyNode::Src) == ac-&gt;in(ArrayCopyNode::Dest)) {
 388           // Non constant offset in the array: we can&#39;t statically
 389           // determine the value
 390           return NULL;
 391         }
 392       }
 393       res = LoadNode::make(_igvn, ctl, mem, adr, adr_type, type, bt, MemNode::unordered, LoadNode::UnknownControl);
 394     }
 395   }
 396   if (res != NULL) {
 397     res = _igvn.transform(res);
 398     if (ftype-&gt;isa_narrowoop()) {
 399       // PhaseMacroExpand::scalar_replacement adds DecodeN nodes
 400       res = _igvn.transform(new EncodePNode(res, ftype));
 401     }
 402     return res;
 403   }
 404   return NULL;
 405 }
 406 
 407 //
 408 // Given a Memory Phi, compute a value Phi containing the values from stores
 409 // on the input paths.
 410 // Note: this function is recursive, its depth is limited by the &quot;level&quot; argument
 411 // Returns the computed Phi, or NULL if it cannot compute it.
 412 Node *PhaseMacroExpand::value_from_mem_phi(Node *mem, BasicType ft, const Type *phi_type, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level) {
 413   assert(mem-&gt;is_Phi(), &quot;sanity&quot;);
 414   int alias_idx = C-&gt;get_alias_index(adr_t);
 415   int offset = adr_t-&gt;offset();
 416   int instance_id = adr_t-&gt;instance_id();
 417 
 418   // Check if an appropriate value phi already exists.
 419   Node* region = mem-&gt;in(0);
 420   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 421     Node* phi = region-&gt;fast_out(k);
 422     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 423         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 424       return phi;
 425     }
 426   }
 427   // Check if an appropriate new value phi already exists.
 428   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 429   if (new_phi != NULL)
 430     return new_phi;
 431 
 432   if (level &lt;= 0) {
 433     return NULL; // Give up: phi tree too deep
 434   }
 435   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 436   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 437 
 438   uint length = mem-&gt;req();
 439   GrowableArray &lt;Node *&gt; values(length, length, NULL, false);
 440 
 441   // create a new Phi for the value
 442   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 443   transform_later(phi);
 444   value_phis-&gt;push(phi, mem-&gt;_idx);
 445 
 446   for (uint j = 1; j &lt; length; j++) {
 447     Node *in = mem-&gt;in(j);
 448     if (in == NULL || in-&gt;is_top()) {
 449       values.at_put(j, in);
 450     } else  {
 451       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 452       if (val == start_mem || val == alloc_mem) {
 453         // hit a sentinel, return appropriate 0 value
 454         values.at_put(j, _igvn.zerocon(ft));
 455         continue;
 456       }
 457       if (val-&gt;is_Initialize()) {
 458         val = val-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 459       }
 460       if (val == NULL) {
 461         return NULL;  // can&#39;t find a value on this path
 462       }
 463       if (val == mem) {
 464         values.at_put(j, mem);
 465       } else if (val-&gt;is_Store()) {
 466         Node* n = val-&gt;in(MemNode::ValueIn);
 467         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 468         n = bs-&gt;step_over_gc_barrier(n);
 469         values.at_put(j, n);
 470       } else if(val-&gt;is_Proj() &amp;&amp; val-&gt;in(0) == alloc) {
 471         values.at_put(j, _igvn.zerocon(ft));
 472       } else if (val-&gt;is_Phi()) {
 473         val = value_from_mem_phi(val, ft, phi_type, adr_t, alloc, value_phis, level-1);
 474         if (val == NULL) {
 475           return NULL;
 476         }
 477         values.at_put(j, val);
 478       } else if (val-&gt;Opcode() == Op_SCMemProj) {
 479         assert(val-&gt;in(0)-&gt;is_LoadStore() ||
 480                val-&gt;in(0)-&gt;Opcode() == Op_EncodeISOArray ||
 481                val-&gt;in(0)-&gt;Opcode() == Op_StrCompressedCopy, &quot;sanity&quot;);
 482         assert(false, &quot;Object is not scalar replaceable if a LoadStore node accesses its field&quot;);
 483         return NULL;
 484       } else if (val-&gt;is_ArrayCopy()) {
 485         Node* res = make_arraycopy_load(val-&gt;as_ArrayCopy(), offset, val-&gt;in(0), val-&gt;in(TypeFunc::Memory), ft, phi_type, alloc);
 486         if (res == NULL) {
 487           return NULL;
 488         }
 489         values.at_put(j, res);
 490       } else {
 491 #ifdef ASSERT
 492         val-&gt;dump();
 493         assert(false, &quot;unknown node on this path&quot;);
 494 #endif
 495         return NULL;  // unknown node on this path
 496       }
 497     }
 498   }
 499   // Set Phi&#39;s inputs
 500   for (uint j = 1; j &lt; length; j++) {
 501     if (values.at(j) == mem) {
 502       phi-&gt;init_req(j, phi);
 503     } else {
 504       phi-&gt;init_req(j, values.at(j));
 505     }
 506   }
 507   return phi;
 508 }
 509 
 510 // Search the last value stored into the object&#39;s field.
 511 Node *PhaseMacroExpand::value_from_mem(Node *sfpt_mem, Node *sfpt_ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc) {
 512   assert(adr_t-&gt;is_known_instance_field(), &quot;instance required&quot;);
 513   int instance_id = adr_t-&gt;instance_id();
 514   assert((uint)instance_id == alloc-&gt;_idx, &quot;wrong allocation&quot;);
 515 
 516   int alias_idx = C-&gt;get_alias_index(adr_t);
 517   int offset = adr_t-&gt;offset();
 518   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 519   Node *alloc_ctrl = alloc-&gt;in(TypeFunc::Control);
 520   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 521   Arena *a = Thread::current()-&gt;resource_area();
 522   VectorSet visited(a);
 523 
 524   bool done = sfpt_mem == alloc_mem;
 525   Node *mem = sfpt_mem;
 526   while (!done) {
 527     if (visited.test_set(mem-&gt;_idx)) {
 528       return NULL;  // found a loop, give up
 529     }
 530     mem = scan_mem_chain(mem, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 531     if (mem == start_mem || mem == alloc_mem) {
 532       done = true;  // hit a sentinel, return appropriate 0 value
 533     } else if (mem-&gt;is_Initialize()) {
 534       mem = mem-&gt;as_Initialize()-&gt;find_captured_store(offset, type2aelembytes(ft), &amp;_igvn);
 535       if (mem == NULL) {
 536         done = true; // Something go wrong.
 537       } else if (mem-&gt;is_Store()) {
 538         const TypePtr* atype = mem-&gt;as_Store()-&gt;adr_type();
 539         assert(C-&gt;get_alias_index(atype) == Compile::AliasIdxRaw, &quot;store is correct memory slice&quot;);
 540         done = true;
 541       }
 542     } else if (mem-&gt;is_Store()) {
 543       const TypeOopPtr* atype = mem-&gt;as_Store()-&gt;adr_type()-&gt;isa_oopptr();
 544       assert(atype != NULL, &quot;address type must be oopptr&quot;);
 545       assert(C-&gt;get_alias_index(atype) == alias_idx &amp;&amp;
 546              atype-&gt;is_known_instance_field() &amp;&amp; atype-&gt;offset() == offset &amp;&amp;
 547              atype-&gt;instance_id() == instance_id, &quot;store is correct memory slice&quot;);
 548       done = true;
 549     } else if (mem-&gt;is_Phi()) {
 550       // try to find a phi&#39;s unique input
 551       Node *unique_input = NULL;
 552       Node *top = C-&gt;top();
 553       for (uint i = 1; i &lt; mem-&gt;req(); i++) {
 554         Node *n = scan_mem_chain(mem-&gt;in(i), alias_idx, offset, start_mem, alloc, &amp;_igvn);
 555         if (n == NULL || n == top || n == mem) {
 556           continue;
 557         } else if (unique_input == NULL) {
 558           unique_input = n;
 559         } else if (unique_input != n) {
 560           unique_input = top;
 561           break;
 562         }
 563       }
 564       if (unique_input != NULL &amp;&amp; unique_input != top) {
 565         mem = unique_input;
 566       } else {
 567         done = true;
 568       }
 569     } else if (mem-&gt;is_ArrayCopy()) {
 570       done = true;
 571     } else {
 572       assert(false, &quot;unexpected node&quot;);
 573     }
 574   }
 575   if (mem != NULL) {
 576     if (mem == start_mem || mem == alloc_mem) {
 577       // hit a sentinel, return appropriate 0 value
 578       return _igvn.zerocon(ft);
 579     } else if (mem-&gt;is_Store()) {
 580       Node* n = mem-&gt;in(MemNode::ValueIn);
 581       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 582       n = bs-&gt;step_over_gc_barrier(n);
 583       return n;
 584     } else if (mem-&gt;is_Phi()) {
 585       // attempt to produce a Phi reflecting the values on the input paths of the Phi
 586       Node_Stack value_phis(a, 8);
 587       Node * phi = value_from_mem_phi(mem, ft, ftype, adr_t, alloc, &amp;value_phis, ValueSearchLimit);
 588       if (phi != NULL) {
 589         return phi;
 590       } else {
 591         // Kill all new Phis
 592         while(value_phis.is_nonempty()) {
 593           Node* n = value_phis.node();
 594           _igvn.replace_node(n, C-&gt;top());
 595           value_phis.pop();
 596         }
 597       }
 598     } else if (mem-&gt;is_ArrayCopy()) {
 599       Node* ctl = mem-&gt;in(0);
 600       Node* m = mem-&gt;in(TypeFunc::Memory);
 601       if (sfpt_ctl-&gt;is_Proj() &amp;&amp; sfpt_ctl-&gt;as_Proj()-&gt;is_uncommon_trap_proj(Deoptimization::Reason_none)) {
 602         // pin the loads in the uncommon trap path
 603         ctl = sfpt_ctl;
 604         m = sfpt_mem;
 605       }
 606       return make_arraycopy_load(mem-&gt;as_ArrayCopy(), offset, ctl, m, ft, ftype, alloc);
 607     }
 608   }
 609   // Something go wrong.
 610   return NULL;
 611 }
 612 
 613 // Check the possibility of scalar replacement.
 614 bool PhaseMacroExpand::can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 615   //  Scan the uses of the allocation to check for anything that would
 616   //  prevent us from eliminating it.
 617   NOT_PRODUCT( const char* fail_eliminate = NULL; )
 618   DEBUG_ONLY( Node* disq_node = NULL; )
 619   bool  can_eliminate = true;
 620 
 621   Node* res = alloc-&gt;result_cast();
 622   const TypeOopPtr* res_type = NULL;
 623   if (res == NULL) {
 624     // All users were eliminated.
 625   } else if (!res-&gt;is_CheckCastPP()) {
 626     NOT_PRODUCT(fail_eliminate = &quot;Allocation does not have unique CheckCastPP&quot;;)
 627     can_eliminate = false;
 628   } else {
 629     res_type = _igvn.type(res)-&gt;isa_oopptr();
 630     if (res_type == NULL) {
 631       NOT_PRODUCT(fail_eliminate = &quot;Neither instance or array allocation&quot;;)
 632       can_eliminate = false;
 633     } else if (res_type-&gt;isa_aryptr()) {
 634       int length = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 635       if (length &lt; 0) {
 636         NOT_PRODUCT(fail_eliminate = &quot;Array&#39;s size is not constant&quot;;)
 637         can_eliminate = false;
 638       }
 639     }
 640   }
 641 
 642   if (can_eliminate &amp;&amp; res != NULL) {
 643     for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax);
 644                                j &lt; jmax &amp;&amp; can_eliminate; j++) {
 645       Node* use = res-&gt;fast_out(j);
 646 
 647       if (use-&gt;is_AddP()) {
 648         const TypePtr* addp_type = _igvn.type(use)-&gt;is_ptr();
 649         int offset = addp_type-&gt;offset();
 650 
 651         if (offset == Type::OffsetTop || offset == Type::OffsetBot) {
 652           NOT_PRODUCT(fail_eliminate = &quot;Undefined field referrence&quot;;)
 653           can_eliminate = false;
 654           break;
 655         }
 656         for (DUIterator_Fast kmax, k = use-&gt;fast_outs(kmax);
 657                                    k &lt; kmax &amp;&amp; can_eliminate; k++) {
 658           Node* n = use-&gt;fast_out(k);
 659           if (!n-&gt;is_Store() &amp;&amp; n-&gt;Opcode() != Op_CastP2X &amp;&amp;
 660               SHENANDOAHGC_ONLY((!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n)) &amp;&amp;)
 661               !(n-&gt;is_ArrayCopy() &amp;&amp;
 662                 n-&gt;as_ArrayCopy()-&gt;is_clonebasic() &amp;&amp;
 663                 n-&gt;in(ArrayCopyNode::Dest) == use)) {
 664             DEBUG_ONLY(disq_node = n;)
 665             if (n-&gt;is_Load() || n-&gt;is_LoadStore()) {
 666               NOT_PRODUCT(fail_eliminate = &quot;Field load&quot;;)
 667             } else {
 668               NOT_PRODUCT(fail_eliminate = &quot;Not store field referrence&quot;;)
 669             }
 670             can_eliminate = false;
 671           }
 672         }
 673       } else if (use-&gt;is_ArrayCopy() &amp;&amp;
 674                  (use-&gt;as_ArrayCopy()-&gt;is_arraycopy_validated() ||
 675                   use-&gt;as_ArrayCopy()-&gt;is_copyof_validated() ||
 676                   use-&gt;as_ArrayCopy()-&gt;is_copyofrange_validated()) &amp;&amp;
 677                  use-&gt;in(ArrayCopyNode::Dest) == res) {
 678         // ok to eliminate
 679       } else if (use-&gt;is_SafePoint()) {
 680         SafePointNode* sfpt = use-&gt;as_SafePoint();
 681         if (sfpt-&gt;is_Call() &amp;&amp; sfpt-&gt;as_Call()-&gt;has_non_debug_use(res)) {
 682           // Object is passed as argument.
 683           DEBUG_ONLY(disq_node = use;)
 684           NOT_PRODUCT(fail_eliminate = &quot;Object is passed as argument&quot;;)
 685           can_eliminate = false;
 686         }
 687         Node* sfptMem = sfpt-&gt;memory();
 688         if (sfptMem == NULL || sfptMem-&gt;is_top()) {
 689           DEBUG_ONLY(disq_node = use;)
 690           NOT_PRODUCT(fail_eliminate = &quot;NULL or TOP memory&quot;;)
 691           can_eliminate = false;
 692         } else {
 693           safepoints.append_if_missing(sfpt);
 694         }
 695       } else if (use-&gt;Opcode() != Op_CastP2X) { // CastP2X is used by card mark
 696         if (use-&gt;is_Phi()) {
 697           if (use-&gt;outcnt() == 1 &amp;&amp; use-&gt;unique_out()-&gt;Opcode() == Op_Return) {
 698             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 699           } else {
 700             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by Phi&quot;;)
 701           }
 702           DEBUG_ONLY(disq_node = use;)
 703         } else {
 704           if (use-&gt;Opcode() == Op_Return) {
 705             NOT_PRODUCT(fail_eliminate = &quot;Object is return value&quot;;)
 706           }else {
 707             NOT_PRODUCT(fail_eliminate = &quot;Object is referenced by node&quot;;)
 708           }
 709           DEBUG_ONLY(disq_node = use;)
 710         }
 711         can_eliminate = false;
 712       }
 713     }
 714   }
 715 
 716 #ifndef PRODUCT
 717   if (PrintEliminateAllocations) {
 718     if (can_eliminate) {
 719       tty-&gt;print(&quot;Scalar &quot;);
 720       if (res == NULL)
 721         alloc-&gt;dump();
 722       else
 723         res-&gt;dump();
 724     } else if (alloc-&gt;_is_scalar_replaceable) {
 725       tty-&gt;print(&quot;NotScalar (%s)&quot;, fail_eliminate);
 726       if (res == NULL)
 727         alloc-&gt;dump();
 728       else
 729         res-&gt;dump();
 730 #ifdef ASSERT
 731       if (disq_node != NULL) {
 732           tty-&gt;print(&quot;  &gt;&gt;&gt;&gt; &quot;);
 733           disq_node-&gt;dump();
 734       }
 735 #endif /*ASSERT*/
 736     }
 737   }
 738 #endif
 739   return can_eliminate;
 740 }
 741 
 742 // Do scalar replacement.
 743 bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints) {
 744   GrowableArray &lt;SafePointNode *&gt; safepoints_done;
 745 
 746   ciKlass* klass = NULL;
 747   ciInstanceKlass* iklass = NULL;
 748   int nfields = 0;
 749   int array_base = 0;
 750   int element_size = 0;
 751   BasicType basic_elem_type = T_ILLEGAL;
 752   ciType* elem_type = NULL;
 753 
 754   Node* res = alloc-&gt;result_cast();
 755   assert(res == NULL || res-&gt;is_CheckCastPP(), &quot;unexpected AllocateNode result&quot;);
 756   const TypeOopPtr* res_type = NULL;
 757   if (res != NULL) { // Could be NULL when there are no users
 758     res_type = _igvn.type(res)-&gt;isa_oopptr();
 759   }
 760 
 761   if (res != NULL) {
 762     klass = res_type-&gt;klass();
 763     if (res_type-&gt;isa_instptr()) {
 764       // find the fields of the class which will be needed for safepoint debug information
 765       assert(klass-&gt;is_instance_klass(), &quot;must be an instance klass.&quot;);
 766       iklass = klass-&gt;as_instance_klass();
 767       nfields = iklass-&gt;nof_nonstatic_fields();
 768     } else {
 769       // find the array&#39;s elements which will be needed for safepoint debug information
 770       nfields = alloc-&gt;in(AllocateNode::ALength)-&gt;find_int_con(-1);
 771       assert(klass-&gt;is_array_klass() &amp;&amp; nfields &gt;= 0, &quot;must be an array klass.&quot;);
 772       elem_type = klass-&gt;as_array_klass()-&gt;element_type();
 773       basic_elem_type = elem_type-&gt;basic_type();
 774       array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
 775       element_size = type2aelembytes(basic_elem_type);
 776     }
 777   }
 778   //
 779   // Process the safepoint uses
 780   //
 781   while (safepoints.length() &gt; 0) {
 782     SafePointNode* sfpt = safepoints.pop();
 783     Node* mem = sfpt-&gt;memory();
 784     Node* ctl = sfpt-&gt;control();
 785     assert(sfpt-&gt;jvms() != NULL, &quot;missed JVMS&quot;);
 786     // Fields of scalar objs are referenced only at the end
 787     // of regular debuginfo at the last (youngest) JVMS.
 788     // Record relative start index.
 789     uint first_ind = (sfpt-&gt;req() - sfpt-&gt;jvms()-&gt;scloff());
 790     SafePointScalarObjectNode* sobj = new SafePointScalarObjectNode(res_type,
 791 #ifdef ASSERT
 792                                                  alloc,
 793 #endif
 794                                                  first_ind, nfields);
 795     sobj-&gt;init_req(0, C-&gt;root());
 796     transform_later(sobj);
 797 
 798     // Scan object&#39;s fields adding an input to the safepoint for each field.
 799     for (int j = 0; j &lt; nfields; j++) {
 800       intptr_t offset;
 801       ciField* field = NULL;
 802       if (iklass != NULL) {
 803         field = iklass-&gt;nonstatic_field_at(j);
 804         offset = field-&gt;offset();
 805         elem_type = field-&gt;type();
 806         basic_elem_type = field-&gt;layout_type();
 807       } else {
 808         offset = array_base + j * (intptr_t)element_size;
 809       }
 810 
 811       const Type *field_type;
 812       // The next code is taken from Parse::do_get_xxx().
 813       if (is_reference_type(basic_elem_type)) {
 814         if (!elem_type-&gt;is_loaded()) {
 815           field_type = TypeInstPtr::BOTTOM;
 816         } else if (field != NULL &amp;&amp; field-&gt;is_static_constant()) {
 817           // This can happen if the constant oop is non-perm.
 818           ciObject* con = field-&gt;constant_value().as_object();
 819           // Do not &quot;join&quot; in the previous type; it doesn&#39;t add value,
 820           // and may yield a vacuous result if the field is of interface type.
 821           field_type = TypeOopPtr::make_from_constant(con)-&gt;isa_oopptr();
 822           assert(field_type != NULL, &quot;field singleton type must be consistent&quot;);
 823         } else {
 824           field_type = TypeOopPtr::make_from_klass(elem_type-&gt;as_klass());
 825         }
 826         if (UseCompressedOops) {
 827           field_type = field_type-&gt;make_narrowoop();
 828           basic_elem_type = T_NARROWOOP;
 829         }
 830       } else {
 831         field_type = Type::get_const_basic_type(basic_elem_type);
 832       }
 833 
 834       const TypeOopPtr *field_addr_type = res_type-&gt;add_offset(offset)-&gt;isa_oopptr();
 835 
 836       Node *field_val = value_from_mem(mem, ctl, basic_elem_type, field_type, field_addr_type, alloc);
 837       if (field_val == NULL) {
 838         // We weren&#39;t able to find a value for this field,
 839         // give up on eliminating this allocation.
 840 
 841         // Remove any extra entries we added to the safepoint.
 842         uint last = sfpt-&gt;req() - 1;
 843         for (int k = 0;  k &lt; j; k++) {
 844           sfpt-&gt;del_req(last--);
 845         }
 846         _igvn._worklist.push(sfpt);
 847         // rollback processed safepoints
 848         while (safepoints_done.length() &gt; 0) {
 849           SafePointNode* sfpt_done = safepoints_done.pop();
 850           // remove any extra entries we added to the safepoint
 851           last = sfpt_done-&gt;req() - 1;
 852           for (int k = 0;  k &lt; nfields; k++) {
 853             sfpt_done-&gt;del_req(last--);
 854           }
 855           JVMState *jvms = sfpt_done-&gt;jvms();
 856           jvms-&gt;set_endoff(sfpt_done-&gt;req());
 857           // Now make a pass over the debug information replacing any references
 858           // to SafePointScalarObjectNode with the allocated object.
 859           int start = jvms-&gt;debug_start();
 860           int end   = jvms-&gt;debug_end();
 861           for (int i = start; i &lt; end; i++) {
 862             if (sfpt_done-&gt;in(i)-&gt;is_SafePointScalarObject()) {
 863               SafePointScalarObjectNode* scobj = sfpt_done-&gt;in(i)-&gt;as_SafePointScalarObject();
 864               if (scobj-&gt;first_index(jvms) == sfpt_done-&gt;req() &amp;&amp;
 865                   scobj-&gt;n_fields() == (uint)nfields) {
 866                 assert(scobj-&gt;alloc() == alloc, &quot;sanity&quot;);
 867                 sfpt_done-&gt;set_req(i, res);
 868               }
 869             }
 870           }
 871           _igvn._worklist.push(sfpt_done);
 872         }
 873 #ifndef PRODUCT
 874         if (PrintEliminateAllocations) {
 875           if (field != NULL) {
 876             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of Field: &quot;,
 877                        sfpt-&gt;_idx);
 878             field-&gt;print();
 879             int field_idx = C-&gt;get_alias_index(field_addr_type);
 880             tty-&gt;print(&quot; (alias_idx=%d)&quot;, field_idx);
 881           } else { // Array&#39;s element
 882             tty-&gt;print(&quot;=== At SafePoint node %d can&#39;t find value of array element [%d]&quot;,
 883                        sfpt-&gt;_idx, j);
 884           }
 885           tty-&gt;print(&quot;, which prevents elimination of: &quot;);
 886           if (res == NULL)
 887             alloc-&gt;dump();
 888           else
 889             res-&gt;dump();
 890         }
 891 #endif
 892         return false;
 893       }
 894       if (UseCompressedOops &amp;&amp; field_type-&gt;isa_narrowoop()) {
 895         // Enable &quot;DecodeN(EncodeP(Allocate)) --&gt; Allocate&quot; transformation
 896         // to be able scalar replace the allocation.
 897         if (field_val-&gt;is_EncodeP()) {
 898           field_val = field_val-&gt;in(1);
 899         } else {
 900           field_val = transform_later(new DecodeNNode(field_val, field_val-&gt;get_ptr_type()));
 901         }
 902       }
 903       sfpt-&gt;add_req(field_val);
 904     }
 905     JVMState *jvms = sfpt-&gt;jvms();
 906     jvms-&gt;set_endoff(sfpt-&gt;req());
 907     // Now make a pass over the debug information replacing any references
 908     // to the allocated object with &quot;sobj&quot;
 909     int start = jvms-&gt;debug_start();
 910     int end   = jvms-&gt;debug_end();
 911     sfpt-&gt;replace_edges_in_range(res, sobj, start, end);
 912     _igvn._worklist.push(sfpt);
 913     safepoints_done.append_if_missing(sfpt); // keep it for rollback
 914   }
 915   return true;
 916 }
 917 
 918 static void disconnect_projections(MultiNode* n, PhaseIterGVN&amp; igvn) {
 919   Node* ctl_proj = n-&gt;proj_out_or_null(TypeFunc::Control);
 920   Node* mem_proj = n-&gt;proj_out_or_null(TypeFunc::Memory);
 921   if (ctl_proj != NULL) {
 922     igvn.replace_node(ctl_proj, n-&gt;in(0));
 923   }
 924   if (mem_proj != NULL) {
 925     igvn.replace_node(mem_proj, n-&gt;in(TypeFunc::Memory));
 926   }
 927 }
 928 
 929 // Process users of eliminated allocation.
 930 void PhaseMacroExpand::process_users_of_allocation(CallNode *alloc) {
 931   Node* res = alloc-&gt;result_cast();
 932   if (res != NULL) {
 933     for (DUIterator_Last jmin, j = res-&gt;last_outs(jmin); j &gt;= jmin; ) {
 934       Node *use = res-&gt;last_out(j);
 935       uint oc1 = res-&gt;outcnt();
 936 
 937       if (use-&gt;is_AddP()) {
 938         for (DUIterator_Last kmin, k = use-&gt;last_outs(kmin); k &gt;= kmin; ) {
 939           Node *n = use-&gt;last_out(k);
 940           uint oc2 = use-&gt;outcnt();
 941           if (n-&gt;is_Store()) {
 942 #ifdef ASSERT
 943             // Verify that there is no dependent MemBarVolatile nodes,
 944             // they should be removed during IGVN, see MemBarNode::Ideal().
 945             for (DUIterator_Fast pmax, p = n-&gt;fast_outs(pmax);
 946                                        p &lt; pmax; p++) {
 947               Node* mb = n-&gt;fast_out(p);
 948               assert(mb-&gt;is_Initialize() || !mb-&gt;is_MemBar() ||
 949                      mb-&gt;req() &lt;= MemBarNode::Precedent ||
 950                      mb-&gt;in(MemBarNode::Precedent) != n,
 951                      &quot;MemBarVolatile should be eliminated for non-escaping object&quot;);
 952             }
 953 #endif
 954             _igvn.replace_node(n, n-&gt;in(MemNode::Memory));
 955           } else if (n-&gt;is_ArrayCopy()) {
 956             // Disconnect ArrayCopy node
 957             ArrayCopyNode* ac = n-&gt;as_ArrayCopy();
 958             assert(ac-&gt;is_clonebasic(), &quot;unexpected array copy kind&quot;);
 959             Node* membar_after = ac-&gt;proj_out(TypeFunc::Control)-&gt;unique_ctrl_out();
 960             disconnect_projections(ac, _igvn);
 961             assert(alloc-&gt;in(0)-&gt;is_Proj() &amp;&amp; alloc-&gt;in(0)-&gt;in(0)-&gt;Opcode() == Op_MemBarCPUOrder, &quot;mem barrier expected before allocation&quot;);
 962             Node* membar_before = alloc-&gt;in(0)-&gt;in(0);
 963             disconnect_projections(membar_before-&gt;as_MemBar(), _igvn);
 964             if (membar_after-&gt;is_MemBar()) {
 965               disconnect_projections(membar_after-&gt;as_MemBar(), _igvn);
 966             }
 967           } else {
 968             eliminate_gc_barrier(n);
 969           }
 970           k -= (oc2 - use-&gt;outcnt());
 971         }
 972         _igvn.remove_dead_node(use);
 973       } else if (use-&gt;is_ArrayCopy()) {
 974         // Disconnect ArrayCopy node
 975         ArrayCopyNode* ac = use-&gt;as_ArrayCopy();
 976         assert(ac-&gt;is_arraycopy_validated() ||
 977                ac-&gt;is_copyof_validated() ||
 978                ac-&gt;is_copyofrange_validated(), &quot;unsupported&quot;);
 979         CallProjections callprojs;
 980         ac-&gt;extract_projections(&amp;callprojs, true);
 981 
 982         _igvn.replace_node(callprojs.fallthrough_ioproj, ac-&gt;in(TypeFunc::I_O));
 983         _igvn.replace_node(callprojs.fallthrough_memproj, ac-&gt;in(TypeFunc::Memory));
 984         _igvn.replace_node(callprojs.fallthrough_catchproj, ac-&gt;in(TypeFunc::Control));
 985 
 986         // Set control to top. IGVN will remove the remaining projections
 987         ac-&gt;set_req(0, top());
 988         ac-&gt;replace_edge(res, top());
 989 
 990         // Disconnect src right away: it can help find new
 991         // opportunities for allocation elimination
 992         Node* src = ac-&gt;in(ArrayCopyNode::Src);
 993         ac-&gt;replace_edge(src, top());
 994         // src can be top at this point if src and dest of the
 995         // arraycopy were the same
 996         if (src-&gt;outcnt() == 0 &amp;&amp; !src-&gt;is_top()) {
 997           _igvn.remove_dead_node(src);
 998         }
 999 
1000         _igvn._worklist.push(ac);
1001       } else {
1002         eliminate_gc_barrier(use);
1003       }
1004       j -= (oc1 - res-&gt;outcnt());
1005     }
1006     assert(res-&gt;outcnt() == 0, &quot;all uses of allocated objects must be deleted&quot;);
1007     _igvn.remove_dead_node(res);
1008   }
1009 
1010   //
1011   // Process other users of allocation&#39;s projections
1012   //
1013   if (_resproj != NULL &amp;&amp; _resproj-&gt;outcnt() != 0) {
1014     // First disconnect stores captured by Initialize node.
1015     // If Initialize node is eliminated first in the following code,
1016     // it will kill such stores and DUIterator_Last will assert.
1017     for (DUIterator_Fast jmax, j = _resproj-&gt;fast_outs(jmax);  j &lt; jmax; j++) {
1018       Node *use = _resproj-&gt;fast_out(j);
1019       if (use-&gt;is_AddP()) {
1020         // raw memory addresses used only by the initialization
1021         _igvn.replace_node(use, C-&gt;top());
1022         --j; --jmax;
1023       }
1024     }
1025     for (DUIterator_Last jmin, j = _resproj-&gt;last_outs(jmin); j &gt;= jmin; ) {
1026       Node *use = _resproj-&gt;last_out(j);
1027       uint oc1 = _resproj-&gt;outcnt();
1028       if (use-&gt;is_Initialize()) {
1029         // Eliminate Initialize node.
1030         InitializeNode *init = use-&gt;as_Initialize();
1031         assert(init-&gt;outcnt() &lt;= 2, &quot;only a control and memory projection expected&quot;);
1032         Node *ctrl_proj = init-&gt;proj_out_or_null(TypeFunc::Control);
1033         if (ctrl_proj != NULL) {
1034           _igvn.replace_node(ctrl_proj, init-&gt;in(TypeFunc::Control));
1035 #ifdef ASSERT
1036           Node* tmp = init-&gt;in(TypeFunc::Control);
1037           assert(tmp == _fallthroughcatchproj, &quot;allocation control projection&quot;);
1038 #endif
1039         }
1040         Node *mem_proj = init-&gt;proj_out_or_null(TypeFunc::Memory);
1041         if (mem_proj != NULL) {
1042           Node *mem = init-&gt;in(TypeFunc::Memory);
1043 #ifdef ASSERT
1044           if (mem-&gt;is_MergeMem()) {
1045             assert(mem-&gt;in(TypeFunc::Memory) == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1046           } else {
1047             assert(mem == _memproj_fallthrough, &quot;allocation memory projection&quot;);
1048           }
1049 #endif
1050           _igvn.replace_node(mem_proj, mem);
1051         }
1052       } else  {
1053         assert(false, &quot;only Initialize or AddP expected&quot;);
1054       }
1055       j -= (oc1 - _resproj-&gt;outcnt());
1056     }
1057   }
1058   if (_fallthroughcatchproj != NULL) {
1059     _igvn.replace_node(_fallthroughcatchproj, alloc-&gt;in(TypeFunc::Control));
1060   }
1061   if (_memproj_fallthrough != NULL) {
1062     _igvn.replace_node(_memproj_fallthrough, alloc-&gt;in(TypeFunc::Memory));
1063   }
1064   if (_memproj_catchall != NULL) {
1065     _igvn.replace_node(_memproj_catchall, C-&gt;top());
1066   }
1067   if (_ioproj_fallthrough != NULL) {
1068     _igvn.replace_node(_ioproj_fallthrough, alloc-&gt;in(TypeFunc::I_O));
1069   }
1070   if (_ioproj_catchall != NULL) {
1071     _igvn.replace_node(_ioproj_catchall, C-&gt;top());
1072   }
1073   if (_catchallcatchproj != NULL) {
1074     _igvn.replace_node(_catchallcatchproj, C-&gt;top());
1075   }
1076 }
1077 
1078 bool PhaseMacroExpand::eliminate_allocate_node(AllocateNode *alloc) {
1079   // Don&#39;t do scalar replacement if the frame can be popped by JVMTI:
1080   // if reallocation fails during deoptimization we&#39;ll pop all
1081   // interpreter frames for this compiled frame and that won&#39;t play
1082   // nice with JVMTI popframe.
1083   if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc-&gt;_is_non_escaping) {
1084     return false;
1085   }
1086   Node* klass = alloc-&gt;in(AllocateNode::KlassNode);
1087   const TypeKlassPtr* tklass = _igvn.type(klass)-&gt;is_klassptr();
1088   Node* res = alloc-&gt;result_cast();
1089   // Eliminate boxing allocations which are not used
1090   // regardless scalar replacable status.
1091   bool boxing_alloc = C-&gt;eliminate_boxing() &amp;&amp;
1092                       tklass-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1093                       tklass-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1094   if (!alloc-&gt;_is_scalar_replaceable &amp;&amp; (!boxing_alloc || (res != NULL))) {
1095     return false;
1096   }
1097 
1098   extract_call_projections(alloc);
1099 
1100   GrowableArray &lt;SafePointNode *&gt; safepoints;
1101   if (!can_eliminate_allocation(alloc, safepoints)) {
1102     return false;
1103   }
1104 
1105   if (!alloc-&gt;_is_scalar_replaceable) {
1106     assert(res == NULL, &quot;sanity&quot;);
1107     // We can only eliminate allocation if all debug info references
1108     // are already replaced with SafePointScalarObject because
1109     // we can&#39;t search for a fields value without instance_id.
1110     if (safepoints.length() &gt; 0) {
1111       return false;
1112     }
1113   }
1114 
1115   if (!scalar_replacement(alloc, safepoints)) {
1116     return false;
1117   }
1118 
1119   CompileLog* log = C-&gt;log();
1120   if (log != NULL) {
1121     log-&gt;head(&quot;eliminate_allocation type=&#39;%d&#39;&quot;,
1122               log-&gt;identify(tklass-&gt;klass()));
1123     JVMState* p = alloc-&gt;jvms();
1124     while (p != NULL) {
1125       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1126       p = p-&gt;caller();
1127     }
1128     log-&gt;tail(&quot;eliminate_allocation&quot;);
1129   }
1130 
1131   process_users_of_allocation(alloc);
1132 
1133 #ifndef PRODUCT
1134   if (PrintEliminateAllocations) {
1135     if (alloc-&gt;is_AllocateArray())
1136       tty-&gt;print_cr(&quot;++++ Eliminated: %d AllocateArray&quot;, alloc-&gt;_idx);
1137     else
1138       tty-&gt;print_cr(&quot;++++ Eliminated: %d Allocate&quot;, alloc-&gt;_idx);
1139   }
1140 #endif
1141 
1142   return true;
1143 }
1144 
1145 bool PhaseMacroExpand::eliminate_boxing_node(CallStaticJavaNode *boxing) {
1146   // EA should remove all uses of non-escaping boxing node.
1147   if (!C-&gt;eliminate_boxing() || boxing-&gt;proj_out_or_null(TypeFunc::Parms) != NULL) {
1148     return false;
1149   }
1150 
1151   assert(boxing-&gt;result_cast() == NULL, &quot;unexpected boxing node result&quot;);
1152 
1153   extract_call_projections(boxing);
1154 
1155   const TypeTuple* r = boxing-&gt;tf()-&gt;range();
1156   assert(r-&gt;cnt() &gt; TypeFunc::Parms, &quot;sanity&quot;);
1157   const TypeInstPtr* t = r-&gt;field_at(TypeFunc::Parms)-&gt;isa_instptr();
1158   assert(t != NULL, &quot;sanity&quot;);
1159 
1160   CompileLog* log = C-&gt;log();
1161   if (log != NULL) {
1162     log-&gt;head(&quot;eliminate_boxing type=&#39;%d&#39;&quot;,
1163               log-&gt;identify(t-&gt;klass()));
1164     JVMState* p = boxing-&gt;jvms();
1165     while (p != NULL) {
1166       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
1167       p = p-&gt;caller();
1168     }
1169     log-&gt;tail(&quot;eliminate_boxing&quot;);
1170   }
1171 
1172   process_users_of_allocation(boxing);
1173 
1174 #ifndef PRODUCT
1175   if (PrintEliminateAllocations) {
1176     tty-&gt;print(&quot;++++ Eliminated: %d &quot;, boxing-&gt;_idx);
1177     boxing-&gt;method()-&gt;print_short_name(tty);
1178     tty-&gt;cr();
1179   }
1180 #endif
1181 
1182   return true;
1183 }
1184 
1185 //---------------------------set_eden_pointers-------------------------
1186 void PhaseMacroExpand::set_eden_pointers(Node* &amp;eden_top_adr, Node* &amp;eden_end_adr) {
1187   if (UseTLAB) {                // Private allocation: load from TLS
1188     Node* thread = transform_later(new ThreadLocalNode());
1189     int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());
1190     int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());
1191     eden_top_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_top_offset);
1192     eden_end_adr = basic_plus_adr(top()/*not oop*/, thread, tlab_end_offset);
1193   } else {                      // Shared allocation: load from globals
1194     CollectedHeap* ch = Universe::heap();
1195     address top_adr = (address)ch-&gt;top_addr();
1196     address end_adr = (address)ch-&gt;end_addr();
1197     eden_top_adr = makecon(TypeRawPtr::make(top_adr));
1198     eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);
1199   }
1200 }
1201 
1202 
1203 Node* PhaseMacroExpand::make_load(Node* ctl, Node* mem, Node* base, int offset, const Type* value_type, BasicType bt) {
1204   Node* adr = basic_plus_adr(base, offset);
1205   const TypePtr* adr_type = adr-&gt;bottom_type()-&gt;is_ptr();
1206   Node* value = LoadNode::make(_igvn, ctl, mem, adr, adr_type, value_type, bt, MemNode::unordered);
1207   transform_later(value);
1208   return value;
1209 }
1210 
1211 
1212 Node* PhaseMacroExpand::make_store(Node* ctl, Node* mem, Node* base, int offset, Node* value, BasicType bt) {
1213   Node* adr = basic_plus_adr(base, offset);
1214   mem = StoreNode::make(_igvn, ctl, mem, adr, NULL, value, bt, MemNode::unordered);
1215   transform_later(mem);
1216   return mem;
1217 }
1218 
1219 //=============================================================================
1220 //
1221 //                              A L L O C A T I O N
1222 //
1223 // Allocation attempts to be fast in the case of frequent small objects.
1224 // It breaks down like this:
1225 //
1226 // 1) Size in doublewords is computed.  This is a constant for objects and
1227 // variable for most arrays.  Doubleword units are used to avoid size
1228 // overflow of huge doubleword arrays.  We need doublewords in the end for
1229 // rounding.
1230 //
1231 // 2) Size is checked for being &#39;too large&#39;.  Too-large allocations will go
1232 // the slow path into the VM.  The slow path can throw any required
1233 // exceptions, and does all the special checks for very large arrays.  The
1234 // size test can constant-fold away for objects.  For objects with
1235 // finalizers it constant-folds the otherway: you always go slow with
1236 // finalizers.
1237 //
1238 // 3) If NOT using TLABs, this is the contended loop-back point.
1239 // Load-Locked the heap top.  If using TLABs normal-load the heap top.
1240 //
1241 // 4) Check that heap top + size*8 &lt; max.  If we fail go the slow ` route.
1242 // NOTE: &quot;top+size*8&quot; cannot wrap the 4Gig line!  Here&#39;s why: for largish
1243 // &quot;size*8&quot; we always enter the VM, where &quot;largish&quot; is a constant picked small
1244 // enough that there&#39;s always space between the eden max and 4Gig (old space is
1245 // there so it&#39;s quite large) and large enough that the cost of entering the VM
1246 // is dwarfed by the cost to initialize the space.
1247 //
1248 // 5) If NOT using TLABs, Store-Conditional the adjusted heap top back
1249 // down.  If contended, repeat at step 3.  If using TLABs normal-store
1250 // adjusted heap top back down; there is no contention.
1251 //
1252 // 6) If !ZeroTLAB then Bulk-clear the object/array.  Fill in klass &amp; mark
1253 // fields.
1254 //
1255 // 7) Merge with the slow-path; cast the raw memory pointer to the correct
1256 // oop flavor.
1257 //
1258 //=============================================================================
1259 // FastAllocateSizeLimit value is in DOUBLEWORDS.
1260 // Allocations bigger than this always go the slow route.
1261 // This value must be small enough that allocation attempts that need to
1262 // trigger exceptions go the slow route.  Also, it must be small enough so
1263 // that heap_top + size_in_bytes does not wrap around the 4Gig limit.
1264 //=============================================================================j//
1265 // %%% Here is an old comment from parseHelper.cpp; is it outdated?
1266 // The allocator will coalesce int-&gt;oop copies away.  See comment in
1267 // coalesce.cpp about how this works.  It depends critically on the exact
1268 // code shape produced here, so if you are changing this code shape
1269 // make sure the GC info for the heap-top is correct in and around the
1270 // slow-path call.
1271 //
1272 
1273 void PhaseMacroExpand::expand_allocate_common(
1274             AllocateNode* alloc, // allocation node to be expanded
1275             Node* length,  // array length for an array allocation
1276             const TypeFunc* slow_call_type, // Type of slow call
1277             address slow_call_address  // Address of slow call
1278     )
1279 {
<a name="2" id="anc2"></a><span class="line-removed">1280 </span>
1281   Node* ctrl = alloc-&gt;in(TypeFunc::Control);
1282   Node* mem  = alloc-&gt;in(TypeFunc::Memory);
1283   Node* i_o  = alloc-&gt;in(TypeFunc::I_O);
1284   Node* size_in_bytes     = alloc-&gt;in(AllocateNode::AllocSize);
1285   Node* klass_node        = alloc-&gt;in(AllocateNode::KlassNode);
1286   Node* initial_slow_test = alloc-&gt;in(AllocateNode::InitialTest);
<a name="3" id="anc3"></a><span class="line-removed">1287 </span>
1288   assert(ctrl != NULL, &quot;must have control&quot;);
<a name="4" id="anc4"></a>
1289   // We need a Region and corresponding Phi&#39;s to merge the slow-path and fast-path results.
1290   // they will not be used if &quot;always_slow&quot; is set
1291   enum { slow_result_path = 1, fast_result_path = 2 };
1292   Node *result_region = NULL;
1293   Node *result_phi_rawmem = NULL;
1294   Node *result_phi_rawoop = NULL;
1295   Node *result_phi_i_o = NULL;
1296 
1297   // The initial slow comparison is a size check, the comparison
1298   // we want to do is a BoolTest::gt
<a name="5" id="anc5"></a><span class="line-modified">1299   bool always_slow = false;</span>
1300   int tv = _igvn.find_int_con(initial_slow_test, -1);
1301   if (tv &gt;= 0) {
<a name="6" id="anc6"></a><span class="line-modified">1302     always_slow = (tv == 1);</span>




1303     initial_slow_test = NULL;
1304   } else {
1305     initial_slow_test = BoolNode::make_predicate(initial_slow_test, &amp;_igvn);
1306   }
1307 
1308   if (C-&gt;env()-&gt;dtrace_alloc_probes() ||
1309       (!UseTLAB &amp;&amp; !Universe::heap()-&gt;supports_inline_contig_alloc())) {
1310     // Force slow-path allocation
<a name="7" id="anc7"></a><span class="line-modified">1311     always_slow = true;</span>
1312     initial_slow_test = NULL;
1313   }
1314 
<a name="8" id="anc8"></a>















1315 
1316   enum { too_big_or_final_path = 1, need_gc_path = 2 };
1317   Node *slow_region = NULL;
1318   Node *toobig_false = ctrl;
1319 
<a name="9" id="anc9"></a><span class="line-removed">1320   assert (initial_slow_test == NULL || !always_slow, &quot;arguments must be consistent&quot;);</span>
1321   // generate the initial test if necessary
1322   if (initial_slow_test != NULL ) {
<a name="10" id="anc10"></a>
1323     slow_region = new RegionNode(3);
1324 
1325     // Now make the initial failure test.  Usually a too-big test but
1326     // might be a TRUE for finalizers or a fancy class check for
1327     // newInstance0.
1328     IfNode *toobig_iff = new IfNode(ctrl, initial_slow_test, PROB_MIN, COUNT_UNKNOWN);
1329     transform_later(toobig_iff);
1330     // Plug the failing-too-big test into the slow-path region
1331     Node *toobig_true = new IfTrueNode( toobig_iff );
1332     transform_later(toobig_true);
1333     slow_region    -&gt;init_req( too_big_or_final_path, toobig_true );
1334     toobig_false = new IfFalseNode( toobig_iff );
1335     transform_later(toobig_false);
<a name="11" id="anc11"></a><span class="line-modified">1336   } else {         // No initial test, just fall into next case</span>


1337     toobig_false = ctrl;
1338     debug_only(slow_region = NodeSentinel);
1339   }
1340 
<a name="12" id="anc12"></a>









1341   Node *slow_mem = mem;  // save the current memory state for slow path
1342   // generate the fast allocation code unless we know that the initial test will always go slow
<a name="13" id="anc13"></a><span class="line-modified">1343   if (!always_slow) {</span>
1344     // Fast path modifies only raw memory.
1345     if (mem-&gt;is_MergeMem()) {
1346       mem = mem-&gt;as_MergeMem()-&gt;memory_at(Compile::AliasIdxRaw);
1347     }
1348 
1349     // allocate the Region and Phi nodes for the result
1350     result_region = new RegionNode(3);
1351     result_phi_rawmem = new PhiNode(result_region, Type::MEMORY, TypeRawPtr::BOTTOM);
<a name="14" id="anc14"></a><span class="line-removed">1352     result_phi_rawoop = new PhiNode(result_region, TypeRawPtr::BOTTOM);</span>
1353     result_phi_i_o    = new PhiNode(result_region, Type::ABIO); // I/O is used for Prefetch
1354 
1355     // Grab regular I/O before optional prefetch may change it.
1356     // Slow-path does no I/O so just set it to the original I/O.
1357     result_phi_i_o-&gt;init_req(slow_result_path, i_o);
1358 
<a name="15" id="anc15"></a><span class="line-removed">1359     Node* needgc_ctrl = NULL;</span>
1360     // Name successful fast-path variables
1361     Node* fast_oop_ctrl;
1362     Node* fast_oop_rawmem;
<a name="16" id="anc16"></a>


1363 
<a name="17" id="anc17"></a><span class="line-modified">1364     intx prefetch_lines = length != NULL ? AllocatePrefetchLines : AllocateInstancePrefetchLines;</span>
<span class="line-modified">1365 </span>
<span class="line-modified">1366     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified">1367     Node* fast_oop = bs-&gt;obj_allocate(this, ctrl, mem, toobig_false, size_in_bytes, i_o, needgc_ctrl,</span>
<span class="line-modified">1368                                       fast_oop_ctrl, fast_oop_rawmem,</span>
<span class="line-modified">1369                                       prefetch_lines);</span>
<span class="line-modified">1370 </span>
<span class="line-modified">1371     if (initial_slow_test) {</span>
<span class="line-modified">1372       slow_region-&gt;init_req(need_gc_path, needgc_ctrl);</span>
<span class="line-modified">1373       // This completes all paths into the slow merge point</span>
<span class="line-removed">1374       transform_later(slow_region);</span>
<span class="line-removed">1375     } else {                      // No initial slow path needed!</span>
<span class="line-removed">1376       // Just fall from the need-GC path straight into the VM call.</span>
<span class="line-removed">1377       slow_region = needgc_ctrl;</span>
<span class="line-removed">1378     }</span>
<span class="line-removed">1379 </span>
<span class="line-removed">1380     InitializeNode* init = alloc-&gt;initialization();</span>
<span class="line-removed">1381     fast_oop_rawmem = initialize_object(alloc,</span>
<span class="line-removed">1382                                         fast_oop_ctrl, fast_oop_rawmem, fast_oop,</span>
<span class="line-removed">1383                                         klass_node, length, size_in_bytes);</span>
<span class="line-removed">1384 </span>
<span class="line-removed">1385     // If initialization is performed by an array copy, any required</span>
<span class="line-removed">1386     // MemBarStoreStore was already added. If the object does not</span>
<span class="line-removed">1387     // escape no need for a MemBarStoreStore. If the object does not</span>
<span class="line-removed">1388     // escape in its initializer and memory barrier (MemBarStoreStore or</span>
<span class="line-removed">1389     // stronger) is already added at exit of initializer, also no need</span>
<span class="line-removed">1390     // for a MemBarStoreStore. Otherwise we need a MemBarStoreStore</span>
<span class="line-removed">1391     // so that stores that initialize this object can&#39;t be reordered</span>
<span class="line-removed">1392     // with a subsequent store that makes this object accessible by</span>
<span class="line-removed">1393     // other threads.</span>
<span class="line-removed">1394     // Other threads include java threads and JVM internal threads</span>
<span class="line-removed">1395     // (for example concurrent GC threads). Current concurrent GC</span>
<span class="line-removed">1396     // implementation: G1 will not scan newly created object,</span>
<span class="line-removed">1397     // so it&#39;s safe to skip storestore barrier when allocation does</span>
<span class="line-removed">1398     // not escape.</span>
<span class="line-removed">1399     if (!alloc-&gt;does_not_escape_thread() &amp;&amp;</span>
<span class="line-removed">1400         !alloc-&gt;is_allocation_MemBar_redundant() &amp;&amp;</span>
<span class="line-removed">1401         (init == NULL || !init-&gt;is_complete_with_arraycopy())) {</span>
<span class="line-removed">1402       if (init == NULL || init-&gt;req() &lt; InitializeNode::RawStores) {</span>
<span class="line-removed">1403         // No InitializeNode or no stores captured by zeroing</span>
<span class="line-removed">1404         // elimination. Simply add the MemBarStoreStore after object</span>
<span class="line-removed">1405         // initialization.</span>
<span class="line-removed">1406         MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="line-removed">1407         transform_later(mb);</span>
<span class="line-removed">1408 </span>
<span class="line-removed">1409         mb-&gt;init_req(TypeFunc::Memory, fast_oop_rawmem);</span>
<span class="line-removed">1410         mb-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="line-removed">1411         fast_oop_ctrl = new ProjNode(mb,TypeFunc::Control);</span>
<span class="line-removed">1412         transform_later(fast_oop_ctrl);</span>
<span class="line-removed">1413         fast_oop_rawmem = new ProjNode(mb,TypeFunc::Memory);</span>
<span class="line-removed">1414         transform_later(fast_oop_rawmem);</span>
1415       } else {
<a name="18" id="anc18"></a><span class="line-modified">1416         // Add the MemBarStoreStore after the InitializeNode so that</span>
<span class="line-modified">1417         // all stores performing the initialization that were moved</span>
<span class="line-modified">1418         // before the InitializeNode happen before the storestore</span>
<span class="line-removed">1419         // barrier.</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421         Node* init_ctrl = init-&gt;proj_out_or_null(TypeFunc::Control);</span>
<span class="line-removed">1422         Node* init_mem = init-&gt;proj_out_or_null(TypeFunc::Memory);</span>
<span class="line-removed">1423 </span>
<span class="line-removed">1424         MemBarNode* mb = MemBarNode::make(C, Op_MemBarStoreStore, Compile::AliasIdxBot);</span>
<span class="line-removed">1425         transform_later(mb);</span>
<span class="line-removed">1426 </span>
<span class="line-removed">1427         Node* ctrl = new ProjNode(init,TypeFunc::Control);</span>
<span class="line-removed">1428         transform_later(ctrl);</span>
<span class="line-removed">1429         Node* mem = new ProjNode(init,TypeFunc::Memory);</span>
<span class="line-removed">1430         transform_later(mem);</span>
<span class="line-removed">1431 </span>
<span class="line-removed">1432         // The MemBarStoreStore depends on control and memory coming</span>
<span class="line-removed">1433         // from the InitializeNode</span>
<span class="line-removed">1434         mb-&gt;init_req(TypeFunc::Memory, mem);</span>
<span class="line-removed">1435         mb-&gt;init_req(TypeFunc::Control, ctrl);</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437         ctrl = new ProjNode(mb,TypeFunc::Control);</span>
<span class="line-removed">1438         transform_later(ctrl);</span>
<span class="line-removed">1439         mem = new ProjNode(mb,TypeFunc::Memory);</span>
<span class="line-removed">1440         transform_later(mem);</span>
<span class="line-removed">1441 </span>
<span class="line-removed">1442         // All nodes that depended on the InitializeNode for control</span>
<span class="line-removed">1443         // and memory must now depend on the MemBarNode that itself</span>
<span class="line-removed">1444         // depends on the InitializeNode</span>
<span class="line-removed">1445         if (init_ctrl != NULL) {</span>
<span class="line-removed">1446           _igvn.replace_node(init_ctrl, ctrl);</span>
<span class="line-removed">1447         }</span>
<span class="line-removed">1448         if (init_mem != NULL) {</span>
<span class="line-removed">1449           _igvn.replace_node(init_mem, mem);</span>
<span class="line-removed">1450         }</span>
1451       }
<a name="19" id="anc19"></a><span class="line-removed">1452     }</span>
1453 
<a name="20" id="anc20"></a><span class="line-modified">1454     if (C-&gt;env()-&gt;dtrace_extended_probes()) {</span>
<span class="line-modified">1455       // Slow-path call</span>
<span class="line-modified">1456       int size = TypeFunc::Parms + 2;</span>
<span class="line-modified">1457       CallLeafNode *call = new CallLeafNode(OptoRuntime::dtrace_object_alloc_Type(),</span>
<span class="line-modified">1458                                             CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc_base),</span>
<span class="line-modified">1459                                             &quot;dtrace_object_alloc&quot;,</span>
<span class="line-modified">1460                                             TypeRawPtr::BOTTOM);</span>
<span class="line-modified">1461 </span>
<span class="line-modified">1462       // Get base of thread-local storage area</span>
<span class="line-modified">1463       Node* thread = new ThreadLocalNode();</span>
<span class="line-modified">1464       transform_later(thread);</span>
<span class="line-modified">1465 </span>
<span class="line-modified">1466       call-&gt;init_req(TypeFunc::Parms+0, thread);</span>
<span class="line-removed">1467       call-&gt;init_req(TypeFunc::Parms+1, fast_oop);</span>
<span class="line-removed">1468       call-&gt;init_req(TypeFunc::Control, fast_oop_ctrl);</span>
<span class="line-removed">1469       call-&gt;init_req(TypeFunc::I_O    , top()); // does no i/o</span>
<span class="line-removed">1470       call-&gt;init_req(TypeFunc::Memory , fast_oop_rawmem);</span>
<span class="line-removed">1471       call-&gt;init_req(TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr));</span>
<span class="line-removed">1472       call-&gt;init_req(TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr));</span>
<span class="line-removed">1473       transform_later(call);</span>
<span class="line-removed">1474       fast_oop_ctrl = new ProjNode(call,TypeFunc::Control);</span>
<span class="line-removed">1475       transform_later(fast_oop_ctrl);</span>
<span class="line-removed">1476       fast_oop_rawmem = new ProjNode(call,TypeFunc::Memory);</span>
<span class="line-removed">1477       transform_later(fast_oop_rawmem);</span>
1478     }
1479 
1480     // Plug in the successful fast-path into the result merge point
1481     result_region    -&gt;init_req(fast_result_path, fast_oop_ctrl);
<a name="21" id="anc21"></a><span class="line-removed">1482     result_phi_rawoop-&gt;init_req(fast_result_path, fast_oop);</span>
1483     result_phi_i_o   -&gt;init_req(fast_result_path, i_o);
1484     result_phi_rawmem-&gt;init_req(fast_result_path, fast_oop_rawmem);
1485   } else {
1486     slow_region = ctrl;
1487     result_phi_i_o = i_o; // Rename it to use in the following code.
1488   }
1489 
1490   // Generate slow-path call
1491   CallNode *call = new CallStaticJavaNode(slow_call_type, slow_call_address,
1492                                OptoRuntime::stub_name(slow_call_address),
1493                                alloc-&gt;jvms()-&gt;bci(),
1494                                TypePtr::BOTTOM);
<a name="22" id="anc22"></a><span class="line-modified">1495   call-&gt;init_req( TypeFunc::Control, slow_region );</span>
<span class="line-modified">1496   call-&gt;init_req( TypeFunc::I_O    , top() )     ;   // does no i/o</span>
<span class="line-modified">1497   call-&gt;init_req( TypeFunc::Memory , slow_mem ); // may gc ptrs</span>
<span class="line-modified">1498   call-&gt;init_req( TypeFunc::ReturnAdr, alloc-&gt;in(TypeFunc::ReturnAdr) );</span>
<span class="line-modified">1499   call-&gt;init_req( TypeFunc::FramePtr, alloc-&gt;in(TypeFunc::FramePtr) );</span>
1500 
1501   call-&gt;init_req(TypeFunc::Parms+0, klass_node);
1502   if (length != NULL) {
1503     call-&gt;init_req(TypeFunc::Parms+1, length);
1504   }
1505 
1506   // Copy debug information and adjust JVMState information, then replace
1507   // allocate node with the call
1508   copy_call_debug_info((CallNode *) alloc,  call);
<a name="23" id="anc23"></a><span class="line-modified">1509   if (!always_slow) {</span>
1510     call-&gt;set_cnt(PROB_UNLIKELY_MAG(4));  // Same effect as RC_UNCOMMON.
1511   } else {
1512     // Hook i_o projection to avoid its elimination during allocation
1513     // replacement (when only a slow call is generated).
1514     call-&gt;set_req(TypeFunc::I_O, result_phi_i_o);
1515   }
1516   _igvn.replace_node(alloc, call);
1517   transform_later(call);
1518 
1519   // Identify the output projections from the allocate node and
1520   // adjust any references to them.
1521   // The control and io projections look like:
1522   //
1523   //        v---Proj(ctrl) &lt;-----+   v---CatchProj(ctrl)
1524   //  Allocate                   Catch
1525   //        ^---Proj(io) &lt;-------+   ^---CatchProj(io)
1526   //
1527   //  We are interested in the CatchProj nodes.
1528   //
1529   extract_call_projections(call);
1530 
1531   // An allocate node has separate memory projections for the uses on
1532   // the control and i_o paths. Replace the control memory projection with
1533   // result_phi_rawmem (unless we are only generating a slow call when
1534   // both memory projections are combined)
<a name="24" id="anc24"></a><span class="line-modified">1535   if (!always_slow &amp;&amp; _memproj_fallthrough != NULL) {</span>
<span class="line-modified">1536     for (DUIterator_Fast imax, i = _memproj_fallthrough-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1537       Node *use = _memproj_fallthrough-&gt;fast_out(i);</span>
<span class="line-removed">1538       _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">1539       imax -= replace_input(use, _memproj_fallthrough, result_phi_rawmem);</span>
<span class="line-removed">1540       // back up iterator</span>
<span class="line-removed">1541       --i;</span>
<span class="line-removed">1542     }</span>
1543   }
1544   // Now change uses of _memproj_catchall to use _memproj_fallthrough and delete
1545   // _memproj_catchall so we end up with a call that has only 1 memory projection.
1546   if (_memproj_catchall != NULL ) {
1547     if (_memproj_fallthrough == NULL) {
1548       _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);
1549       transform_later(_memproj_fallthrough);
1550     }
<a name="25" id="anc25"></a><span class="line-modified">1551     for (DUIterator_Fast imax, i = _memproj_catchall-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1552       Node *use = _memproj_catchall-&gt;fast_out(i);</span>
<span class="line-removed">1553       _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">1554       imax -= replace_input(use, _memproj_catchall, _memproj_fallthrough);</span>
<span class="line-removed">1555       // back up iterator</span>
<span class="line-removed">1556       --i;</span>
<span class="line-removed">1557     }</span>
<span class="line-removed">1558     assert(_memproj_catchall-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
1559     _igvn.remove_dead_node(_memproj_catchall);
1560   }
1561 
1562   // An allocate node has separate i_o projections for the uses on the control
1563   // and i_o paths. Always replace the control i_o projection with result i_o
1564   // otherwise incoming i_o become dead when only a slow call is generated
1565   // (it is different from memory projections where both projections are
1566   // combined in such case).
1567   if (_ioproj_fallthrough != NULL) {
<a name="26" id="anc26"></a><span class="line-modified">1568     for (DUIterator_Fast imax, i = _ioproj_fallthrough-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1569       Node *use = _ioproj_fallthrough-&gt;fast_out(i);</span>
<span class="line-removed">1570       _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">1571       imax -= replace_input(use, _ioproj_fallthrough, result_phi_i_o);</span>
<span class="line-removed">1572       // back up iterator</span>
<span class="line-removed">1573       --i;</span>
<span class="line-removed">1574     }</span>
1575   }
1576   // Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete
1577   // _ioproj_catchall so we end up with a call that has only 1 i_o projection.
1578   if (_ioproj_catchall != NULL ) {
1579     if (_ioproj_fallthrough == NULL) {
1580       _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);
1581       transform_later(_ioproj_fallthrough);
1582     }
<a name="27" id="anc27"></a><span class="line-modified">1583     for (DUIterator_Fast imax, i = _ioproj_catchall-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">1584       Node *use = _ioproj_catchall-&gt;fast_out(i);</span>
<span class="line-removed">1585       _igvn.rehash_node_delayed(use);</span>
<span class="line-removed">1586       imax -= replace_input(use, _ioproj_catchall, _ioproj_fallthrough);</span>
<span class="line-removed">1587       // back up iterator</span>
<span class="line-removed">1588       --i;</span>
<span class="line-removed">1589     }</span>
<span class="line-removed">1590     assert(_ioproj_catchall-&gt;outcnt() == 0, &quot;all uses must be deleted&quot;);</span>
1591     _igvn.remove_dead_node(_ioproj_catchall);
1592   }
1593 
1594   // if we generated only a slow call, we are done
<a name="28" id="anc28"></a><span class="line-modified">1595   if (always_slow) {</span>
1596     // Now we can unhook i_o.
1597     if (result_phi_i_o-&gt;outcnt() &gt; 1) {
1598       call-&gt;set_req(TypeFunc::I_O, top());
1599     } else {
<a name="29" id="anc29"></a><span class="line-modified">1600       assert(result_phi_i_o-&gt;unique_ctrl_out() == call, &quot;&quot;);</span>
1601       // Case of new array with negative size known during compilation.
1602       // AllocateArrayNode::Ideal() optimization disconnect unreachable
1603       // following code since call to runtime will throw exception.
1604       // As result there will be no users of i_o after the call.
1605       // Leave i_o attached to this call to avoid problems in preceding graph.
1606     }
1607     return;
1608   }
1609 
<a name="30" id="anc30"></a><span class="line-removed">1610 </span>
1611   if (_fallthroughcatchproj != NULL) {
1612     ctrl = _fallthroughcatchproj-&gt;clone();
1613     transform_later(ctrl);
1614     _igvn.replace_node(_fallthroughcatchproj, result_region);
1615   } else {
1616     ctrl = top();
1617   }
1618   Node *slow_result;
1619   if (_resproj == NULL) {
1620     // no uses of the allocation result
1621     slow_result = top();
1622   } else {
1623     slow_result = _resproj-&gt;clone();
1624     transform_later(slow_result);
1625     _igvn.replace_node(_resproj, result_phi_rawoop);
1626   }
1627 
1628   // Plug slow-path into result merge point
<a name="31" id="anc31"></a><span class="line-modified">1629   result_region    -&gt;init_req( slow_result_path, ctrl );</span>
<span class="line-removed">1630   result_phi_rawoop-&gt;init_req( slow_result_path, slow_result);</span>
<span class="line-removed">1631   result_phi_rawmem-&gt;init_req( slow_result_path, _memproj_fallthrough );</span>
1632   transform_later(result_region);
<a name="32" id="anc32"></a><span class="line-modified">1633   transform_later(result_phi_rawoop);</span>




1634   transform_later(result_phi_rawmem);
1635   transform_later(result_phi_i_o);
1636   // This completes all paths into the result merge point
1637 }
1638 
<a name="33" id="anc33"></a>






























































































































































1639 
1640 // Helper for PhaseMacroExpand::expand_allocate_common.
1641 // Initializes the newly-allocated storage.
1642 Node*
1643 PhaseMacroExpand::initialize_object(AllocateNode* alloc,
1644                                     Node* control, Node* rawmem, Node* object,
1645                                     Node* klass_node, Node* length,
1646                                     Node* size_in_bytes) {
1647   InitializeNode* init = alloc-&gt;initialization();
1648   // Store the klass &amp; mark bits
1649   Node* mark_node = alloc-&gt;make_ideal_mark(&amp;_igvn, object, control, rawmem);
1650   if (!mark_node-&gt;is_Con()) {
1651     transform_later(mark_node);
1652   }
1653   rawmem = make_store(control, rawmem, object, oopDesc::mark_offset_in_bytes(), mark_node, TypeX_X-&gt;basic_type());
1654 
1655   rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);
1656   int header_size = alloc-&gt;minimum_header_size();  // conservatively small
1657 
1658   // Array length
1659   if (length != NULL) {         // Arrays need length field
1660     rawmem = make_store(control, rawmem, object, arrayOopDesc::length_offset_in_bytes(), length, T_INT);
1661     // conservatively small header size:
1662     header_size = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1663     ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1664     if (k-&gt;is_array_klass())    // we know the exact header size in most cases:
1665       header_size = Klass::layout_helper_header_size(k-&gt;layout_helper());
1666   }
1667 
1668   // Clear the object body, if necessary.
1669   if (init == NULL) {
1670     // The init has somehow disappeared; be cautious and clear everything.
1671     //
1672     // This can happen if a node is allocated but an uncommon trap occurs
1673     // immediately.  In this case, the Initialize gets associated with the
1674     // trap, and may be placed in a different (outer) loop, if the Allocate
1675     // is in a loop.  If (this is rare) the inner loop gets unrolled, then
1676     // there can be two Allocates to one Initialize.  The answer in all these
1677     // edge cases is safety first.  It is always safe to clear immediately
1678     // within an Allocate, and then (maybe or maybe not) clear some more later.
1679     if (!(UseTLAB &amp;&amp; ZeroTLAB)) {
1680       rawmem = ClearArrayNode::clear_memory(control, rawmem, object,
1681                                             header_size, size_in_bytes,
1682                                             &amp;_igvn);
1683     }
1684   } else {
1685     if (!init-&gt;is_complete()) {
1686       // Try to win by zeroing only what the init does not store.
1687       // We can also try to do some peephole optimizations,
1688       // such as combining some adjacent subword stores.
1689       rawmem = init-&gt;complete_stores(control, rawmem, object,
1690                                      header_size, size_in_bytes, &amp;_igvn);
1691     }
1692     // We have no more use for this link, since the AllocateNode goes away:
1693     init-&gt;set_req(InitializeNode::RawAddress, top());
1694     // (If we keep the link, it just confuses the register allocator,
1695     // who thinks he sees a real use of the address by the membar.)
1696   }
1697 
1698   return rawmem;
1699 }
1700 
1701 // Generate prefetch instructions for next allocations.
1702 Node* PhaseMacroExpand::prefetch_allocation(Node* i_o, Node*&amp; needgc_false,
1703                                         Node*&amp; contended_phi_rawmem,
1704                                         Node* old_eden_top, Node* new_eden_top,
1705                                         intx lines) {
1706    enum { fall_in_path = 1, pf_path = 2 };
1707    if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 2 ) {
1708       // Generate prefetch allocation with watermark check.
1709       // As an allocation hits the watermark, we will prefetch starting
1710       // at a &quot;distance&quot; away from watermark.
1711 
1712       Node *pf_region = new RegionNode(3);
1713       Node *pf_phi_rawmem = new PhiNode( pf_region, Type::MEMORY,
1714                                                 TypeRawPtr::BOTTOM );
1715       // I/O is used for Prefetch
1716       Node *pf_phi_abio = new PhiNode( pf_region, Type::ABIO );
1717 
1718       Node *thread = new ThreadLocalNode();
1719       transform_later(thread);
1720 
1721       Node *eden_pf_adr = new AddPNode( top()/*not oop*/, thread,
1722                    _igvn.MakeConX(in_bytes(JavaThread::tlab_pf_top_offset())) );
1723       transform_later(eden_pf_adr);
1724 
1725       Node *old_pf_wm = new LoadPNode(needgc_false,
1726                                    contended_phi_rawmem, eden_pf_adr,
1727                                    TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,
1728                                    MemNode::unordered);
1729       transform_later(old_pf_wm);
1730 
1731       // check against new_eden_top
1732       Node *need_pf_cmp = new CmpPNode( new_eden_top, old_pf_wm );
1733       transform_later(need_pf_cmp);
1734       Node *need_pf_bol = new BoolNode( need_pf_cmp, BoolTest::ge );
1735       transform_later(need_pf_bol);
1736       IfNode *need_pf_iff = new IfNode( needgc_false, need_pf_bol,
1737                                        PROB_UNLIKELY_MAG(4), COUNT_UNKNOWN );
1738       transform_later(need_pf_iff);
1739 
1740       // true node, add prefetchdistance
1741       Node *need_pf_true = new IfTrueNode( need_pf_iff );
1742       transform_later(need_pf_true);
1743 
1744       Node *need_pf_false = new IfFalseNode( need_pf_iff );
1745       transform_later(need_pf_false);
1746 
1747       Node *new_pf_wmt = new AddPNode( top(), old_pf_wm,
1748                                     _igvn.MakeConX(AllocatePrefetchDistance) );
1749       transform_later(new_pf_wmt );
1750       new_pf_wmt-&gt;set_req(0, need_pf_true);
1751 
1752       Node *store_new_wmt = new StorePNode(need_pf_true,
1753                                        contended_phi_rawmem, eden_pf_adr,
1754                                        TypeRawPtr::BOTTOM, new_pf_wmt,
1755                                        MemNode::unordered);
1756       transform_later(store_new_wmt);
1757 
1758       // adding prefetches
1759       pf_phi_abio-&gt;init_req( fall_in_path, i_o );
1760 
1761       Node *prefetch_adr;
1762       Node *prefetch;
1763       uint step_size = AllocatePrefetchStepSize;
1764       uint distance = 0;
1765 
1766       for ( intx i = 0; i &lt; lines; i++ ) {
1767         prefetch_adr = new AddPNode( old_pf_wm, new_pf_wmt,
1768                                             _igvn.MakeConX(distance) );
1769         transform_later(prefetch_adr);
1770         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1771         transform_later(prefetch);
1772         distance += step_size;
1773         i_o = prefetch;
1774       }
1775       pf_phi_abio-&gt;set_req( pf_path, i_o );
1776 
1777       pf_region-&gt;init_req( fall_in_path, need_pf_false );
1778       pf_region-&gt;init_req( pf_path, need_pf_true );
1779 
1780       pf_phi_rawmem-&gt;init_req( fall_in_path, contended_phi_rawmem );
1781       pf_phi_rawmem-&gt;init_req( pf_path, store_new_wmt );
1782 
1783       transform_later(pf_region);
1784       transform_later(pf_phi_rawmem);
1785       transform_later(pf_phi_abio);
1786 
1787       needgc_false = pf_region;
1788       contended_phi_rawmem = pf_phi_rawmem;
1789       i_o = pf_phi_abio;
1790    } else if( UseTLAB &amp;&amp; AllocatePrefetchStyle == 3 ) {
1791       // Insert a prefetch instruction for each allocation.
1792       // This code is used to generate 1 prefetch instruction per cache line.
1793 
1794       // Generate several prefetch instructions.
1795       uint step_size = AllocatePrefetchStepSize;
1796       uint distance = AllocatePrefetchDistance;
1797 
1798       // Next cache address.
1799       Node *cache_adr = new AddPNode(old_eden_top, old_eden_top,
1800                                      _igvn.MakeConX(step_size + distance));
1801       transform_later(cache_adr);
1802       cache_adr = new CastP2XNode(needgc_false, cache_adr);
1803       transform_later(cache_adr);
1804       // Address is aligned to execute prefetch to the beginning of cache line size
1805       // (it is important when BIS instruction is used on SPARC as prefetch).
1806       Node* mask = _igvn.MakeConX(~(intptr_t)(step_size-1));
1807       cache_adr = new AndXNode(cache_adr, mask);
1808       transform_later(cache_adr);
1809       cache_adr = new CastX2PNode(cache_adr);
1810       transform_later(cache_adr);
1811 
1812       // Prefetch
1813       Node *prefetch = new PrefetchAllocationNode( contended_phi_rawmem, cache_adr );
1814       prefetch-&gt;set_req(0, needgc_false);
1815       transform_later(prefetch);
1816       contended_phi_rawmem = prefetch;
1817       Node *prefetch_adr;
1818       distance = step_size;
1819       for ( intx i = 1; i &lt; lines; i++ ) {
1820         prefetch_adr = new AddPNode( cache_adr, cache_adr,
1821                                             _igvn.MakeConX(distance) );
1822         transform_later(prefetch_adr);
1823         prefetch = new PrefetchAllocationNode( contended_phi_rawmem, prefetch_adr );
1824         transform_later(prefetch);
1825         distance += step_size;
1826         contended_phi_rawmem = prefetch;
1827       }
1828    } else if( AllocatePrefetchStyle &gt; 0 ) {
1829       // Insert a prefetch for each allocation only on the fast-path
1830       Node *prefetch_adr;
1831       Node *prefetch;
1832       // Generate several prefetch instructions.
1833       uint step_size = AllocatePrefetchStepSize;
1834       uint distance = AllocatePrefetchDistance;
1835       for ( intx i = 0; i &lt; lines; i++ ) {
1836         prefetch_adr = new AddPNode( old_eden_top, new_eden_top,
1837                                             _igvn.MakeConX(distance) );
1838         transform_later(prefetch_adr);
1839         prefetch = new PrefetchAllocationNode( i_o, prefetch_adr );
1840         // Do not let it float too high, since if eden_top == eden_end,
1841         // both might be null.
1842         if( i == 0 ) { // Set control for first prefetch, next follows it
1843           prefetch-&gt;init_req(0, needgc_false);
1844         }
1845         transform_later(prefetch);
1846         distance += step_size;
1847         i_o = prefetch;
1848       }
1849    }
1850    return i_o;
1851 }
1852 
1853 
1854 void PhaseMacroExpand::expand_allocate(AllocateNode *alloc) {
1855   expand_allocate_common(alloc, NULL,
1856                          OptoRuntime::new_instance_Type(),
1857                          OptoRuntime::new_instance_Java());
1858 }
1859 
1860 void PhaseMacroExpand::expand_allocate_array(AllocateArrayNode *alloc) {
1861   Node* length = alloc-&gt;in(AllocateNode::ALength);
1862   InitializeNode* init = alloc-&gt;initialization();
1863   Node* klass_node = alloc-&gt;in(AllocateNode::KlassNode);
1864   ciKlass* k = _igvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
1865   address slow_call_address;  // Address of slow call
1866   if (init != NULL &amp;&amp; init-&gt;is_complete_with_arraycopy() &amp;&amp;
1867       k-&gt;is_type_array_klass()) {
1868     // Don&#39;t zero type array during slow allocation in VM since
1869     // it will be initialized later by arraycopy in compiled code.
1870     slow_call_address = OptoRuntime::new_array_nozero_Java();
1871   } else {
1872     slow_call_address = OptoRuntime::new_array_Java();
1873   }
1874   expand_allocate_common(alloc, length,
1875                          OptoRuntime::new_array_Type(),
1876                          slow_call_address);
1877 }
1878 
1879 //-------------------mark_eliminated_box----------------------------------
1880 //
1881 // During EA obj may point to several objects but after few ideal graph
1882 // transformations (CCP) it may point to only one non escaping object
1883 // (but still using phi), corresponding locks and unlocks will be marked
1884 // for elimination. Later obj could be replaced with a new node (new phi)
1885 // and which does not have escape information. And later after some graph
1886 // reshape other locks and unlocks (which were not marked for elimination
1887 // before) are connected to this new obj (phi) but they still will not be
1888 // marked for elimination since new obj has no escape information.
1889 // Mark all associated (same box and obj) lock and unlock nodes for
1890 // elimination if some of them marked already.
1891 void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {
1892   if (oldbox-&gt;as_BoxLock()-&gt;is_eliminated())
1893     return; // This BoxLock node was processed already.
1894 
1895   // New implementation (EliminateNestedLocks) has separate BoxLock
1896   // node for each locked region so mark all associated locks/unlocks as
1897   // eliminated even if different objects are referenced in one locked region
1898   // (for example, OSR compilation of nested loop inside locked scope).
1899   if (EliminateNestedLocks ||
1900       oldbox-&gt;as_BoxLock()-&gt;is_simple_lock_region(NULL, obj)) {
1901     // Box is used only in one lock region. Mark this box as eliminated.
1902     _igvn.hash_delete(oldbox);
1903     oldbox-&gt;as_BoxLock()-&gt;set_eliminated(); // This changes box&#39;s hash value
1904      _igvn.hash_insert(oldbox);
1905 
1906     for (uint i = 0; i &lt; oldbox-&gt;outcnt(); i++) {
1907       Node* u = oldbox-&gt;raw_out(i);
1908       if (u-&gt;is_AbstractLock() &amp;&amp; !u-&gt;as_AbstractLock()-&gt;is_non_esc_obj()) {
1909         AbstractLockNode* alock = u-&gt;as_AbstractLock();
1910         // Check lock&#39;s box since box could be referenced by Lock&#39;s debug info.
1911         if (alock-&gt;box_node() == oldbox) {
1912           // Mark eliminated all related locks and unlocks.
1913 #ifdef ASSERT
1914           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc4&quot;);
1915 #endif
1916           alock-&gt;set_non_esc_obj();
1917         }
1918       }
1919     }
1920     return;
1921   }
1922 
1923   // Create new &quot;eliminated&quot; BoxLock node and use it in monitor debug info
1924   // instead of oldbox for the same object.
1925   BoxLockNode* newbox = oldbox-&gt;clone()-&gt;as_BoxLock();
1926 
1927   // Note: BoxLock node is marked eliminated only here and it is used
1928   // to indicate that all associated lock and unlock nodes are marked
1929   // for elimination.
1930   newbox-&gt;set_eliminated();
1931   transform_later(newbox);
1932 
1933   // Replace old box node with new box for all users of the same object.
1934   for (uint i = 0; i &lt; oldbox-&gt;outcnt();) {
1935     bool next_edge = true;
1936 
1937     Node* u = oldbox-&gt;raw_out(i);
1938     if (u-&gt;is_AbstractLock()) {
1939       AbstractLockNode* alock = u-&gt;as_AbstractLock();
1940       if (alock-&gt;box_node() == oldbox &amp;&amp; alock-&gt;obj_node()-&gt;eqv_uncast(obj)) {
1941         // Replace Box and mark eliminated all related locks and unlocks.
1942 #ifdef ASSERT
1943         alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_non_esc5&quot;);
1944 #endif
1945         alock-&gt;set_non_esc_obj();
1946         _igvn.rehash_node_delayed(alock);
1947         alock-&gt;set_box_node(newbox);
1948         next_edge = false;
1949       }
1950     }
1951     if (u-&gt;is_FastLock() &amp;&amp; u-&gt;as_FastLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
1952       FastLockNode* flock = u-&gt;as_FastLock();
1953       assert(flock-&gt;box_node() == oldbox, &quot;sanity&quot;);
1954       _igvn.rehash_node_delayed(flock);
1955       flock-&gt;set_box_node(newbox);
1956       next_edge = false;
1957     }
1958 
1959     // Replace old box in monitor debug info.
1960     if (u-&gt;is_SafePoint() &amp;&amp; u-&gt;as_SafePoint()-&gt;jvms()) {
1961       SafePointNode* sfn = u-&gt;as_SafePoint();
1962       JVMState* youngest_jvms = sfn-&gt;jvms();
1963       int max_depth = youngest_jvms-&gt;depth();
1964       for (int depth = 1; depth &lt;= max_depth; depth++) {
1965         JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1966         int num_mon  = jvms-&gt;nof_monitors();
1967         // Loop over monitors
1968         for (int idx = 0; idx &lt; num_mon; idx++) {
1969           Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1970           Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1971           if (box_node == oldbox &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
1972             int j = jvms-&gt;monitor_box_offset(idx);
1973             _igvn.replace_input_of(u, j, newbox);
1974             next_edge = false;
1975           }
1976         }
1977       }
1978     }
1979     if (next_edge) i++;
1980   }
1981 }
1982 
1983 //-----------------------mark_eliminated_locking_nodes-----------------------
1984 void PhaseMacroExpand::mark_eliminated_locking_nodes(AbstractLockNode *alock) {
1985   if (EliminateNestedLocks) {
1986     if (alock-&gt;is_nested()) {
1987        assert(alock-&gt;box_node()-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
1988        return;
1989     } else if (!alock-&gt;is_non_esc_obj()) { // Not eliminated or coarsened
1990       // Only Lock node has JVMState needed here.
1991       // Not that preceding claim is documented anywhere else.
1992       if (alock-&gt;jvms() != NULL) {
1993         if (alock-&gt;as_Lock()-&gt;is_nested_lock_region()) {
1994           // Mark eliminated related nested locks and unlocks.
1995           Node* obj = alock-&gt;obj_node();
1996           BoxLockNode* box_node = alock-&gt;box_node()-&gt;as_BoxLock();
1997           assert(!box_node-&gt;is_eliminated(), &quot;should not be marked yet&quot;);
1998           // Note: BoxLock node is marked eliminated only here
1999           // and it is used to indicate that all associated lock
2000           // and unlock nodes are marked for elimination.
2001           box_node-&gt;set_eliminated(); // Box&#39;s hash is always NO_HASH here
2002           for (uint i = 0; i &lt; box_node-&gt;outcnt(); i++) {
2003             Node* u = box_node-&gt;raw_out(i);
2004             if (u-&gt;is_AbstractLock()) {
2005               alock = u-&gt;as_AbstractLock();
2006               if (alock-&gt;box_node() == box_node) {
2007                 // Verify that this Box is referenced only by related locks.
2008                 assert(alock-&gt;obj_node()-&gt;eqv_uncast(obj), &quot;&quot;);
2009                 // Mark all related locks and unlocks.
2010 #ifdef ASSERT
2011                 alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_set_nested&quot;);
2012 #endif
2013                 alock-&gt;set_nested();
2014               }
2015             }
2016           }
2017         } else {
2018 #ifdef ASSERT
2019           alock-&gt;log_lock_optimization(C, &quot;eliminate_lock_NOT_nested_lock_region&quot;);
2020           if (C-&gt;log() != NULL)
2021             alock-&gt;as_Lock()-&gt;is_nested_lock_region(C); // rerun for debugging output
2022 #endif
2023         }
2024       }
2025       return;
2026     }
2027     // Process locks for non escaping object
2028     assert(alock-&gt;is_non_esc_obj(), &quot;&quot;);
2029   } // EliminateNestedLocks
2030 
2031   if (alock-&gt;is_non_esc_obj()) { // Lock is used for non escaping object
2032     // Look for all locks of this object and mark them and
2033     // corresponding BoxLock nodes as eliminated.
2034     Node* obj = alock-&gt;obj_node();
2035     for (uint j = 0; j &lt; obj-&gt;outcnt(); j++) {
2036       Node* o = obj-&gt;raw_out(j);
2037       if (o-&gt;is_AbstractLock() &amp;&amp;
2038           o-&gt;as_AbstractLock()-&gt;obj_node()-&gt;eqv_uncast(obj)) {
2039         alock = o-&gt;as_AbstractLock();
2040         Node* box = alock-&gt;box_node();
2041         // Replace old box node with new eliminated box for all users
2042         // of the same object and mark related locks as eliminated.
2043         mark_eliminated_box(box, obj);
2044       }
2045     }
2046   }
2047 }
2048 
2049 // we have determined that this lock/unlock can be eliminated, we simply
2050 // eliminate the node without expanding it.
2051 //
2052 // Note:  The membar&#39;s associated with the lock/unlock are currently not
2053 //        eliminated.  This should be investigated as a future enhancement.
2054 //
2055 bool PhaseMacroExpand::eliminate_locking_node(AbstractLockNode *alock) {
2056 
2057   if (!alock-&gt;is_eliminated()) {
2058     return false;
2059   }
2060 #ifdef ASSERT
2061   if (!alock-&gt;is_coarsened()) {
2062     // Check that new &quot;eliminated&quot; BoxLock node is created.
2063     BoxLockNode* oldbox = alock-&gt;box_node()-&gt;as_BoxLock();
2064     assert(oldbox-&gt;is_eliminated(), &quot;should be done already&quot;);
2065   }
2066 #endif
2067 
2068   alock-&gt;log_lock_optimization(C, &quot;eliminate_lock&quot;);
2069 
2070 #ifndef PRODUCT
2071   if (PrintEliminateLocks) {
2072     if (alock-&gt;is_Lock()) {
2073       tty-&gt;print_cr(&quot;++++ Eliminated: %d Lock&quot;, alock-&gt;_idx);
2074     } else {
2075       tty-&gt;print_cr(&quot;++++ Eliminated: %d Unlock&quot;, alock-&gt;_idx);
2076     }
2077   }
2078 #endif
2079 
2080   Node* mem  = alock-&gt;in(TypeFunc::Memory);
2081   Node* ctrl = alock-&gt;in(TypeFunc::Control);
2082   guarantee(ctrl != NULL, &quot;missing control projection, cannot replace_node() with NULL&quot;);
2083 
2084   extract_call_projections(alock);
2085   // There are 2 projections from the lock.  The lock node will
2086   // be deleted when its last use is subsumed below.
2087   assert(alock-&gt;outcnt() == 2 &amp;&amp;
2088          _fallthroughproj != NULL &amp;&amp;
2089          _memproj_fallthrough != NULL,
2090          &quot;Unexpected projections from Lock/Unlock&quot;);
2091 
2092   Node* fallthroughproj = _fallthroughproj;
2093   Node* memproj_fallthrough = _memproj_fallthrough;
2094 
2095   // The memory projection from a lock/unlock is RawMem
2096   // The input to a Lock is merged memory, so extract its RawMem input
2097   // (unless the MergeMem has been optimized away.)
2098   if (alock-&gt;is_Lock()) {
2099     // Seach for MemBarAcquireLock node and delete it also.
2100     MemBarNode* membar = fallthroughproj-&gt;unique_ctrl_out()-&gt;as_MemBar();
2101     assert(membar != NULL &amp;&amp; membar-&gt;Opcode() == Op_MemBarAcquireLock, &quot;&quot;);
2102     Node* ctrlproj = membar-&gt;proj_out(TypeFunc::Control);
2103     Node* memproj = membar-&gt;proj_out(TypeFunc::Memory);
2104     _igvn.replace_node(ctrlproj, fallthroughproj);
2105     _igvn.replace_node(memproj, memproj_fallthrough);
2106 
2107     // Delete FastLock node also if this Lock node is unique user
2108     // (a loop peeling may clone a Lock node).
2109     Node* flock = alock-&gt;as_Lock()-&gt;fastlock_node();
2110     if (flock-&gt;outcnt() == 1) {
2111       assert(flock-&gt;unique_out() == alock, &quot;sanity&quot;);
2112       _igvn.replace_node(flock, top());
2113     }
2114   }
2115 
2116   // Seach for MemBarReleaseLock node and delete it also.
2117   if (alock-&gt;is_Unlock() &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_MemBar()) {
2118     MemBarNode* membar = ctrl-&gt;in(0)-&gt;as_MemBar();
2119     assert(membar-&gt;Opcode() == Op_MemBarReleaseLock &amp;&amp;
2120            mem-&gt;is_Proj() &amp;&amp; membar == mem-&gt;in(0), &quot;&quot;);
2121     _igvn.replace_node(fallthroughproj, ctrl);
2122     _igvn.replace_node(memproj_fallthrough, mem);
2123     fallthroughproj = ctrl;
2124     memproj_fallthrough = mem;
2125     ctrl = membar-&gt;in(TypeFunc::Control);
2126     mem  = membar-&gt;in(TypeFunc::Memory);
2127   }
2128 
2129   _igvn.replace_node(fallthroughproj, ctrl);
2130   _igvn.replace_node(memproj_fallthrough, mem);
2131   return true;
2132 }
2133 
2134 
2135 //------------------------------expand_lock_node----------------------
2136 void PhaseMacroExpand::expand_lock_node(LockNode *lock) {
2137 
2138   Node* ctrl = lock-&gt;in(TypeFunc::Control);
2139   Node* mem = lock-&gt;in(TypeFunc::Memory);
2140   Node* obj = lock-&gt;obj_node();
2141   Node* box = lock-&gt;box_node();
2142   Node* flock = lock-&gt;fastlock_node();
2143 
2144   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2145 
2146   // Make the merge point
2147   Node *region;
2148   Node *mem_phi;
2149   Node *slow_path;
2150 
2151   if (UseOptoBiasInlining) {
2152     /*
2153      *  See the full description in MacroAssembler::biased_locking_enter().
2154      *
2155      *  if( (mark_word &amp; biased_lock_mask) == biased_lock_pattern ) {
2156      *    // The object is biased.
2157      *    proto_node = klass-&gt;prototype_header;
2158      *    o_node = thread | proto_node;
2159      *    x_node = o_node ^ mark_word;
2160      *    if( (x_node &amp; ~age_mask) == 0 ) { // Biased to the current thread ?
2161      *      // Done.
2162      *    } else {
2163      *      if( (x_node &amp; biased_lock_mask) != 0 ) {
2164      *        // The klass&#39;s prototype header is no longer biased.
2165      *        cas(&amp;mark_word, mark_word, proto_node)
2166      *        goto cas_lock;
2167      *      } else {
2168      *        // The klass&#39;s prototype header is still biased.
2169      *        if( (x_node &amp; epoch_mask) != 0 ) { // Expired epoch?
2170      *          old = mark_word;
2171      *          new = o_node;
2172      *        } else {
2173      *          // Different thread or anonymous biased.
2174      *          old = mark_word &amp; (epoch_mask | age_mask | biased_lock_mask);
2175      *          new = thread | old;
2176      *        }
2177      *        // Try to rebias.
2178      *        if( cas(&amp;mark_word, old, new) == 0 ) {
2179      *          // Done.
2180      *        } else {
2181      *          goto slow_path; // Failed.
2182      *        }
2183      *      }
2184      *    }
2185      *  } else {
2186      *    // The object is not biased.
2187      *    cas_lock:
2188      *    if( FastLock(obj) == 0 ) {
2189      *      // Done.
2190      *    } else {
2191      *      slow_path:
2192      *      OptoRuntime::complete_monitor_locking_Java(obj);
2193      *    }
2194      *  }
2195      */
2196 
2197     region  = new RegionNode(5);
2198     // create a Phi for the memory state
2199     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2200 
2201     Node* fast_lock_region  = new RegionNode(3);
2202     Node* fast_lock_mem_phi = new PhiNode( fast_lock_region, Type::MEMORY, TypeRawPtr::BOTTOM);
2203 
2204     // First, check mark word for the biased lock pattern.
2205     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2206 
2207     // Get fast path - mark word has the biased lock pattern.
2208     ctrl = opt_bits_test(ctrl, fast_lock_region, 1, mark_node,
2209                          markWord::biased_lock_mask_in_place,
2210                          markWord::biased_lock_pattern, true);
2211     // fast_lock_region-&gt;in(1) is set to slow path.
2212     fast_lock_mem_phi-&gt;init_req(1, mem);
2213 
2214     // Now check that the lock is biased to the current thread and has
2215     // the same epoch and bias as Klass::_prototype_header.
2216 
2217     // Special-case a fresh allocation to avoid building nodes:
2218     Node* klass_node = AllocateNode::Ideal_klass(obj, &amp;_igvn);
2219     if (klass_node == NULL) {
2220       Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
2221       klass_node = transform_later(LoadKlassNode::make(_igvn, NULL, mem, k_adr, _igvn.type(k_adr)-&gt;is_ptr()));
2222 #ifdef _LP64
2223       if (UseCompressedClassPointers &amp;&amp; klass_node-&gt;is_DecodeNKlass()) {
2224         assert(klass_node-&gt;in(1)-&gt;Opcode() == Op_LoadNKlass, &quot;sanity&quot;);
2225         klass_node-&gt;in(1)-&gt;init_req(0, ctrl);
2226       } else
2227 #endif
2228       klass_node-&gt;init_req(0, ctrl);
2229     }
2230     Node *proto_node = make_load(ctrl, mem, klass_node, in_bytes(Klass::prototype_header_offset()), TypeX_X, TypeX_X-&gt;basic_type());
2231 
2232     Node* thread = transform_later(new ThreadLocalNode());
2233     Node* cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2234     Node* o_node = transform_later(new OrXNode(cast_thread, proto_node));
2235     Node* x_node = transform_later(new XorXNode(o_node, mark_node));
2236 
2237     // Get slow path - mark word does NOT match the value.
2238     STATIC_ASSERT(markWord::age_mask_in_place &lt;= INT_MAX);
2239     Node* not_biased_ctrl =  opt_bits_test(ctrl, region, 3, x_node,
2240                                       (~(int)markWord::age_mask_in_place), 0);
2241     // region-&gt;in(3) is set to fast path - the object is biased to the current thread.
2242     mem_phi-&gt;init_req(3, mem);
2243 
2244 
2245     // Mark word does NOT match the value (thread | Klass::_prototype_header).
2246 
2247 
2248     // First, check biased pattern.
2249     // Get fast path - _prototype_header has the same biased lock pattern.
2250     ctrl =  opt_bits_test(not_biased_ctrl, fast_lock_region, 2, x_node,
2251                           markWord::biased_lock_mask_in_place, 0, true);
2252 
2253     not_biased_ctrl = fast_lock_region-&gt;in(2); // Slow path
2254     // fast_lock_region-&gt;in(2) - the prototype header is no longer biased
2255     // and we have to revoke the bias on this object.
2256     // We are going to try to reset the mark of this object to the prototype
2257     // value and fall through to the CAS-based locking scheme.
2258     Node* adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
2259     Node* cas = new StoreXConditionalNode(not_biased_ctrl, mem, adr,
2260                                           proto_node, mark_node);
2261     transform_later(cas);
2262     Node* proj = transform_later(new SCMemProjNode(cas));
2263     fast_lock_mem_phi-&gt;init_req(2, proj);
2264 
2265 
2266     // Second, check epoch bits.
2267     Node* rebiased_region  = new RegionNode(3);
2268     Node* old_phi = new PhiNode( rebiased_region, TypeX_X);
2269     Node* new_phi = new PhiNode( rebiased_region, TypeX_X);
2270 
2271     // Get slow path - mark word does NOT match epoch bits.
2272     Node* epoch_ctrl =  opt_bits_test(ctrl, rebiased_region, 1, x_node,
2273                                       markWord::epoch_mask_in_place, 0);
2274     // The epoch of the current bias is not valid, attempt to rebias the object
2275     // toward the current thread.
2276     rebiased_region-&gt;init_req(2, epoch_ctrl);
2277     old_phi-&gt;init_req(2, mark_node);
2278     new_phi-&gt;init_req(2, o_node);
2279 
2280     // rebiased_region-&gt;in(1) is set to fast path.
2281     // The epoch of the current bias is still valid but we know
2282     // nothing about the owner; it might be set or it might be clear.
2283     Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |
2284                              markWord::age_mask_in_place |
2285                              markWord::epoch_mask_in_place);
2286     Node* old = transform_later(new AndXNode(mark_node, cmask));
2287     cast_thread = transform_later(new CastP2XNode(ctrl, thread));
2288     Node* new_mark = transform_later(new OrXNode(cast_thread, old));
2289     old_phi-&gt;init_req(1, old);
2290     new_phi-&gt;init_req(1, new_mark);
2291 
2292     transform_later(rebiased_region);
2293     transform_later(old_phi);
2294     transform_later(new_phi);
2295 
2296     // Try to acquire the bias of the object using an atomic operation.
2297     // If this fails we will go in to the runtime to revoke the object&#39;s bias.
2298     cas = new StoreXConditionalNode(rebiased_region, mem, adr, new_phi, old_phi);
2299     transform_later(cas);
2300     proj = transform_later(new SCMemProjNode(cas));
2301 
2302     // Get slow path - Failed to CAS.
2303     not_biased_ctrl = opt_bits_test(rebiased_region, region, 4, cas, 0, 0);
2304     mem_phi-&gt;init_req(4, proj);
2305     // region-&gt;in(4) is set to fast path - the object is rebiased to the current thread.
2306 
2307     // Failed to CAS.
2308     slow_path  = new RegionNode(3);
2309     Node *slow_mem = new PhiNode( slow_path, Type::MEMORY, TypeRawPtr::BOTTOM);
2310 
2311     slow_path-&gt;init_req(1, not_biased_ctrl); // Capture slow-control
2312     slow_mem-&gt;init_req(1, proj);
2313 
2314     // Call CAS-based locking scheme (FastLock node).
2315 
2316     transform_later(fast_lock_region);
2317     transform_later(fast_lock_mem_phi);
2318 
2319     // Get slow path - FastLock failed to lock the object.
2320     ctrl = opt_bits_test(fast_lock_region, region, 2, flock, 0, 0);
2321     mem_phi-&gt;init_req(2, fast_lock_mem_phi);
2322     // region-&gt;in(2) is set to fast path - the object is locked to the current thread.
2323 
2324     slow_path-&gt;init_req(2, ctrl); // Capture slow-control
2325     slow_mem-&gt;init_req(2, fast_lock_mem_phi);
2326 
2327     transform_later(slow_path);
2328     transform_later(slow_mem);
2329     // Reset lock&#39;s memory edge.
2330     lock-&gt;set_req(TypeFunc::Memory, slow_mem);
2331 
2332   } else {
2333     region  = new RegionNode(3);
2334     // create a Phi for the memory state
2335     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2336 
2337     // Optimize test; set region slot 2
2338     slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);
2339     mem_phi-&gt;init_req(2, mem);
2340   }
2341 
2342   // Make slow path call
2343   CallNode *call = make_slow_call((CallNode *) lock, OptoRuntime::complete_monitor_enter_Type(),
2344                                   OptoRuntime::complete_monitor_locking_Java(), NULL, slow_path,
2345                                   obj, box, NULL);
2346 
2347   extract_call_projections(call);
2348 
2349   // Slow path can only throw asynchronous exceptions, which are always
2350   // de-opted.  So the compiler thinks the slow-call can never throw an
2351   // exception.  If it DOES throw an exception we would need the debug
2352   // info removed first (since if it throws there is no monitor).
2353   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2354            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2355 
2356   // Capture slow path
2357   // disconnect fall-through projection from call and create a new one
2358   // hook up users of fall-through projection to region
2359   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2360   transform_later(slow_ctrl);
2361   _igvn.hash_delete(_fallthroughproj);
2362   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2363   region-&gt;init_req(1, slow_ctrl);
2364   // region inputs are now complete
2365   transform_later(region);
2366   _igvn.replace_node(_fallthroughproj, region);
2367 
2368   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory));
2369   mem_phi-&gt;init_req(1, memproj );
2370   transform_later(mem_phi);
2371   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2372 }
2373 
2374 //------------------------------expand_unlock_node----------------------
2375 void PhaseMacroExpand::expand_unlock_node(UnlockNode *unlock) {
2376 
2377   Node* ctrl = unlock-&gt;in(TypeFunc::Control);
2378   Node* mem = unlock-&gt;in(TypeFunc::Memory);
2379   Node* obj = unlock-&gt;obj_node();
2380   Node* box = unlock-&gt;box_node();
2381 
2382   assert(!box-&gt;as_BoxLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2383 
2384   // No need for a null check on unlock
2385 
2386   // Make the merge point
2387   Node *region;
2388   Node *mem_phi;
2389 
2390   if (UseOptoBiasInlining) {
2391     // Check for biased locking unlock case, which is a no-op.
2392     // See the full description in MacroAssembler::biased_locking_exit().
2393     region  = new RegionNode(4);
2394     // create a Phi for the memory state
2395     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2396     mem_phi-&gt;init_req(3, mem);
2397 
2398     Node* mark_node = make_load(ctrl, mem, obj, oopDesc::mark_offset_in_bytes(), TypeX_X, TypeX_X-&gt;basic_type());
2399     ctrl = opt_bits_test(ctrl, region, 3, mark_node,
2400                          markWord::biased_lock_mask_in_place,
2401                          markWord::biased_lock_pattern);
2402   } else {
2403     region  = new RegionNode(3);
2404     // create a Phi for the memory state
2405     mem_phi = new PhiNode( region, Type::MEMORY, TypeRawPtr::BOTTOM);
2406   }
2407 
2408   FastUnlockNode *funlock = new FastUnlockNode( ctrl, obj, box );
2409   funlock = transform_later( funlock )-&gt;as_FastUnlock();
2410   // Optimize test; set region slot 2
2411   Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);
2412   Node *thread = transform_later(new ThreadLocalNode());
2413 
2414   CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),
2415                                   CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),
2416                                   &quot;complete_monitor_unlocking_C&quot;, slow_path, obj, box, thread);
2417 
2418   extract_call_projections(call);
2419 
2420   assert ( _ioproj_fallthrough == NULL &amp;&amp; _ioproj_catchall == NULL &amp;&amp;
2421            _memproj_catchall == NULL &amp;&amp; _catchallcatchproj == NULL, &quot;Unexpected projection from Lock&quot;);
2422 
2423   // No exceptions for unlocking
2424   // Capture slow path
2425   // disconnect fall-through projection from call and create a new one
2426   // hook up users of fall-through projection to region
2427   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2428   transform_later(slow_ctrl);
2429   _igvn.hash_delete(_fallthroughproj);
2430   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2431   region-&gt;init_req(1, slow_ctrl);
2432   // region inputs are now complete
2433   transform_later(region);
2434   _igvn.replace_node(_fallthroughproj, region);
2435 
2436   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2437   mem_phi-&gt;init_req(1, memproj );
2438   mem_phi-&gt;init_req(2, mem);
2439   transform_later(mem_phi);
2440   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2441 }
2442 
2443 //---------------------------eliminate_macro_nodes----------------------
2444 // Eliminate scalar replaced allocations and associated locks.
2445 void PhaseMacroExpand::eliminate_macro_nodes() {
2446   if (C-&gt;macro_count() == 0)
2447     return;
2448 
2449   // First, attempt to eliminate locks
2450   int cnt = C-&gt;macro_count();
2451   for (int i=0; i &lt; cnt; i++) {
2452     Node *n = C-&gt;macro_node(i);
2453     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2454       // Before elimination mark all associated (same box and obj)
2455       // lock and unlock nodes.
2456       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2457     }
2458   }
2459   bool progress = true;
2460   while (progress) {
2461     progress = false;
2462     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2463       Node * n = C-&gt;macro_node(i-1);
2464       bool success = false;
2465       debug_only(int old_macro_count = C-&gt;macro_count(););
2466       if (n-&gt;is_AbstractLock()) {
2467         success = eliminate_locking_node(n-&gt;as_AbstractLock());
2468       }
2469       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2470       progress = progress || success;
2471     }
2472   }
2473   // Next, attempt to eliminate allocations
2474   _has_locks = false;
2475   progress = true;
2476   while (progress) {
2477     progress = false;
2478     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2479       Node * n = C-&gt;macro_node(i-1);
2480       bool success = false;
2481       debug_only(int old_macro_count = C-&gt;macro_count(););
2482       switch (n-&gt;class_id()) {
2483       case Node::Class_Allocate:
2484       case Node::Class_AllocateArray:
2485         success = eliminate_allocate_node(n-&gt;as_Allocate());
2486         break;
2487       case Node::Class_CallStaticJava:
2488         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2489         break;
2490       case Node::Class_Lock:
2491       case Node::Class_Unlock:
2492         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2493         _has_locks = true;
2494         break;
2495       case Node::Class_ArrayCopy:
2496         break;
2497       case Node::Class_OuterStripMinedLoop:
2498         break;
2499       default:
2500         assert(n-&gt;Opcode() == Op_LoopLimit ||
2501                n-&gt;Opcode() == Op_Opaque1   ||
2502                n-&gt;Opcode() == Op_Opaque2   ||
2503                n-&gt;Opcode() == Op_Opaque3   ||
2504                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2505                &quot;unknown node type in macro list&quot;);
2506       }
2507       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2508       progress = progress || success;
2509     }
2510   }
2511 }
2512 
2513 //------------------------------expand_macro_nodes----------------------
2514 //  Returns true if a failure occurred.
2515 bool PhaseMacroExpand::expand_macro_nodes() {
2516   // Last attempt to eliminate macro nodes.
2517   eliminate_macro_nodes();
2518 
2519   // Make sure expansion will not cause node limit to be exceeded.
2520   // Worst case is a macro node gets expanded into about 200 nodes.
2521   // Allow 50% more for optimization.
2522   if (C-&gt;check_node_count(C-&gt;macro_count() * 300, &quot;out of nodes before macro expansion&quot; ) )
2523     return true;
2524 
2525   // Eliminate Opaque and LoopLimit nodes. Do it after all loop optimizations.
2526   bool progress = true;
2527   while (progress) {
2528     progress = false;
2529     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2530       Node* n = C-&gt;macro_node(i-1);
2531       bool success = false;
2532       debug_only(int old_macro_count = C-&gt;macro_count(););
2533       if (n-&gt;Opcode() == Op_LoopLimit) {
2534         // Remove it from macro list and put on IGVN worklist to optimize.
2535         C-&gt;remove_macro_node(n);
2536         _igvn._worklist.push(n);
2537         success = true;
2538       } else if (n-&gt;Opcode() == Op_CallStaticJava) {
2539         // Remove it from macro list and put on IGVN worklist to optimize.
2540         C-&gt;remove_macro_node(n);
2541         _igvn._worklist.push(n);
2542         success = true;
2543       } else if (n-&gt;Opcode() == Op_Opaque1 || n-&gt;Opcode() == Op_Opaque2) {
2544         _igvn.replace_node(n, n-&gt;in(1));
2545         success = true;
2546 #if INCLUDE_RTM_OPT
2547       } else if ((n-&gt;Opcode() == Op_Opaque3) &amp;&amp; ((Opaque3Node*)n)-&gt;rtm_opt()) {
2548         assert(C-&gt;profile_rtm(), &quot;should be used only in rtm deoptimization code&quot;);
2549         assert((n-&gt;outcnt() == 1) &amp;&amp; n-&gt;unique_out()-&gt;is_Cmp(), &quot;&quot;);
2550         Node* cmp = n-&gt;unique_out();
2551 #ifdef ASSERT
2552         // Validate graph.
2553         assert((cmp-&gt;outcnt() == 1) &amp;&amp; cmp-&gt;unique_out()-&gt;is_Bool(), &quot;&quot;);
2554         BoolNode* bol = cmp-&gt;unique_out()-&gt;as_Bool();
2555         assert((bol-&gt;outcnt() == 1) &amp;&amp; bol-&gt;unique_out()-&gt;is_If() &amp;&amp;
2556                (bol-&gt;_test._test == BoolTest::ne), &quot;&quot;);
2557         IfNode* ifn = bol-&gt;unique_out()-&gt;as_If();
2558         assert((ifn-&gt;outcnt() == 2) &amp;&amp;
2559                ifn-&gt;proj_out(1)-&gt;is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != NULL, &quot;&quot;);
2560 #endif
2561         Node* repl = n-&gt;in(1);
2562         if (!_has_locks) {
2563           // Remove RTM state check if there are no locks in the code.
2564           // Replace input to compare the same value.
2565           repl = (cmp-&gt;in(1) == n) ? cmp-&gt;in(2) : cmp-&gt;in(1);
2566         }
2567         _igvn.replace_node(n, repl);
2568         success = true;
2569 #endif
2570       } else if (n-&gt;Opcode() == Op_OuterStripMinedLoop) {
2571         n-&gt;as_OuterStripMinedLoop()-&gt;adjust_strip_mined_loop(&amp;_igvn);
2572         C-&gt;remove_macro_node(n);
2573         success = true;
2574       }
2575       assert(!success || (C-&gt;macro_count() == (old_macro_count - 1)), &quot;elimination must have deleted one node from macro list&quot;);
2576       progress = progress || success;
2577     }
2578   }
2579 
2580   // expand arraycopy &quot;macro&quot; nodes first
2581   // For ReduceBulkZeroing, we must first process all arraycopy nodes
2582   // before the allocate nodes are expanded.
2583   for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
2584     Node* n = C-&gt;macro_node(i-1);
2585     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2586     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2587       // node is unreachable, so don&#39;t try to expand it
2588       C-&gt;remove_macro_node(n);
2589       continue;
2590     }
2591     debug_only(int old_macro_count = C-&gt;macro_count(););
2592     switch (n-&gt;class_id()) {
2593     case Node::Class_Lock:
2594       expand_lock_node(n-&gt;as_Lock());
2595       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2596       break;
2597     case Node::Class_Unlock:
2598       expand_unlock_node(n-&gt;as_Unlock());
2599       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2600       break;
2601     case Node::Class_ArrayCopy:
2602       expand_arraycopy_node(n-&gt;as_ArrayCopy());
2603       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2604       break;
2605     }
2606     if (C-&gt;failing())  return true;
2607   }
2608 
2609   // All nodes except Allocate nodes are expanded now. There could be
2610   // new optimization opportunities (such as folding newly created
2611   // load from a just allocated object). Run IGVN.
2612   _igvn.set_delay_transform(false);
2613   _igvn.optimize();
2614   if (C-&gt;failing())  return true;
2615 
2616   _igvn.set_delay_transform(true);
2617 
2618   // expand &quot;macro&quot; nodes
2619   // nodes are removed from the macro list as they are processed
2620   while (C-&gt;macro_count() &gt; 0) {
2621     int macro_count = C-&gt;macro_count();
2622     Node * n = C-&gt;macro_node(macro_count-1);
2623     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2624     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2625       // node is unreachable, so don&#39;t try to expand it
2626       C-&gt;remove_macro_node(n);
2627       continue;
2628     }
2629     switch (n-&gt;class_id()) {
2630     case Node::Class_Allocate:
2631       expand_allocate(n-&gt;as_Allocate());
2632       break;
2633     case Node::Class_AllocateArray:
2634       expand_allocate_array(n-&gt;as_AllocateArray());
2635       break;
2636     default:
2637       assert(false, &quot;unknown node type in macro list&quot;);
2638     }
2639     assert(C-&gt;macro_count() &lt; macro_count, &quot;must have deleted a node from macro list&quot;);
2640     if (C-&gt;failing())  return true;
2641   }
2642 
2643   _igvn.set_delay_transform(false);
2644   _igvn.optimize();
2645   if (C-&gt;failing())  return true;
2646   return false;
2647 }
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>