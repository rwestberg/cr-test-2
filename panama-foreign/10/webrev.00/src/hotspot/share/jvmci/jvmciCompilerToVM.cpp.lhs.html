<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciCompilerToVM.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/scopeDesc.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/disassembler.hpp&quot;
  32 #include &quot;interpreter/linkResolver.hpp&quot;
  33 #include &quot;interpreter/bytecodeStream.hpp&quot;
  34 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  35 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  36 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  37 #include &quot;logging/log.hpp&quot;
  38 #include &quot;logging/logTag.hpp&quot;
  39 #include &quot;memory/oopFactory.hpp&quot;
  40 #include &quot;memory/universe.hpp&quot;
  41 #include &quot;oops/constantPool.inline.hpp&quot;
  42 #include &quot;oops/method.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/nativeLookup.hpp&quot;
  45 #include &quot;runtime/atomic.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/frame.inline.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/jniHandles.inline.hpp&quot;
  51 #include &quot;runtime/timerTrace.hpp&quot;
  52 #include &quot;runtime/vframe_hp.hpp&quot;
  53 
  54 JVMCIKlassHandle::JVMCIKlassHandle(Thread* thread, Klass* klass) {
  55   _thread = thread;
  56   _klass = klass;
  57   if (klass != NULL) {
  58     _holder = Handle(_thread, klass-&gt;klass_holder());
  59   }
  60 }
  61 
  62 JVMCIKlassHandle&amp; JVMCIKlassHandle::operator=(Klass* klass) {
  63   _klass = klass;
  64   if (klass != NULL) {
  65     _holder = Handle(_thread, klass-&gt;klass_holder());
  66   }
  67   return *this;
  68 }
  69 
  70 static void requireInHotSpot(const char* caller, JVMCI_TRAPS) {
  71   if (!JVMCIENV-&gt;is_hotspot()) {
  72     JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot call %s from JVMCI shared library&quot;, caller));
  73   }
  74 }
  75 
  76 void JNIHandleMark::push_jni_handle_block(JavaThread* thread) {
  77   if (thread != NULL) {
  78     // Allocate a new block for JNI handles.
  79     // Inlined code from jni_PushLocalFrame()
  80     JNIHandleBlock* java_handles = thread-&gt;active_handles();
  81     JNIHandleBlock* compile_handles = JNIHandleBlock::allocate_block(thread);
  82     assert(compile_handles != NULL &amp;&amp; java_handles != NULL, &quot;should not be NULL&quot;);
  83     compile_handles-&gt;set_pop_frame_link(java_handles);
  84     thread-&gt;set_active_handles(compile_handles);
  85   }
  86 }
  87 
  88 void JNIHandleMark::pop_jni_handle_block(JavaThread* thread) {
  89   if (thread != NULL) {
  90     // Release our JNI handle block
  91     JNIHandleBlock* compile_handles = thread-&gt;active_handles();
  92     JNIHandleBlock* java_handles = compile_handles-&gt;pop_frame_link();
  93     thread-&gt;set_active_handles(java_handles);
  94     compile_handles-&gt;set_pop_frame_link(NULL);
  95     JNIHandleBlock::release_block(compile_handles, thread); // may block
  96   }
  97 }
  98 
  99 class JVMCITraceMark : public StackObj {
 100   const char* _msg;
 101  public:
 102   JVMCITraceMark(const char* msg) {
 103     _msg = msg;
 104     if (JVMCITraceLevel &gt;= 1) {
 105       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Enter %s&quot;, p2i(JavaThread::current()), _msg);
 106     }
 107   }
 108   ~JVMCITraceMark() {
 109     if (JVMCITraceLevel &gt;= 1) {
 110       tty-&gt;print_cr(PTR_FORMAT &quot; JVMCITrace-1: Exit %s&quot;, p2i(JavaThread::current()), _msg);
 111     }
 112   }
 113 };
 114 
 115 
 116 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
 117   assert(_index &lt; _args-&gt;length(), &quot;out of bounds&quot;);
 118   oop arg=((objArrayOop) (_args))-&gt;obj_at(_index++);
 119   assert(expectedType == T_OBJECT || java_lang_boxing_object::is_instance(arg, expectedType), &quot;arg type mismatch&quot;);
 120   return Handle(Thread::current(), arg);
 121 }
 122 
 123 // Bring the JVMCI compiler thread into the VM state.
 124 #define JVMCI_VM_ENTRY_MARK                   \
 125   ThreadInVMfromNative __tiv(thread);         \
 126   ResetNoHandleMark rnhm;                     \
 127   HandleMarkCleaner __hm(thread);             \
 128   Thread* THREAD = thread;                    \
 129   debug_only(VMNativeEntryWrapper __vew;)
 130 
 131 // Native method block that transitions current thread to &#39;_thread_in_vm&#39;.
 132 #define C2V_BLOCK(result_type, name, signature)      \
 133   TRACE_CALL(result_type, jvmci_ ## name signature)  \
 134   JVMCI_VM_ENTRY_MARK;                               \
 135   ResourceMark rm;                                   \
 136   JNI_JVMCIENV(thread, env);
 137 
 138 static Thread* get_current_thread() {
 139   return Thread::current_or_null_safe();
 140 }
 141 
 142 // Entry to native method implementation that transitions
 143 // current thread to &#39;_thread_in_vm&#39;.
 144 #define C2V_VMENTRY(result_type, name, signature)        \
 145   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 146   Thread* base_thread = get_current_thread();            \
 147   if (base_thread == NULL) {                             \
 148     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 149         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 150     return;                                              \
 151   }                                                      \
 152   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 153   JavaThread* thread = (JavaThread*) base_thread;        \
 154   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 155   C2V_BLOCK(result_type, name, signature)
 156 
 157 #define C2V_VMENTRY_(result_type, name, signature, result) \
 158   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 159   Thread* base_thread = get_current_thread();            \
 160   if (base_thread == NULL) {                             \
 161     env-&gt;ThrowNew(JNIJVMCI::InternalError::clazz(),      \
 162         err_msg(&quot;Cannot call into HotSpot from JVMCI shared library without attaching current thread&quot;)); \
 163     return result;                                       \
 164   }                                                      \
 165   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
 166   JavaThread* thread = (JavaThread*) base_thread;        \
 167   JVMCITraceMark jtm(&quot;CompilerToVM::&quot; #name);            \
 168   C2V_BLOCK(result_type, name, signature)
 169 
 170 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 171 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 172 
 173 // Entry to native method implementation that does not transition
 174 // current thread to &#39;_thread_in_vm&#39;.
 175 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
 176   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
 177   Thread* base_thread = get_current_thread();
 178 
 179 #define C2V_END }
 180 
 181 #define JNI_THROW(caller, name, msg) do {                                         \
 182     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 183     if (__throw_res != JNI_OK) {                                                  \
 184       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 185     }                                                                             \
 186     return;                                                                       \
 187   } while (0);
 188 
 189 #define JNI_THROW_(caller, name, msg, result) do {                                \
 190     jint __throw_res = env-&gt;ThrowNew(JNIJVMCI::name::clazz(), msg);               \
 191     if (__throw_res != JNI_OK) {                                                  \
 192       tty-&gt;print_cr(&quot;Throwing &quot; #name &quot; in &quot; caller &quot; returned %d&quot;, __throw_res); \
 193     }                                                                             \
 194     return result;                                                                \
 195   } while (0)
 196 
 197 jobjectArray readConfiguration0(JNIEnv *env, JVMCI_TRAPS);
 198 
 199 C2V_VMENTRY_NULL(jobjectArray, readConfiguration, (JNIEnv* env))
 200   jobjectArray config = readConfiguration0(env, JVMCI_CHECK_NULL);
 201   return config;
 202 }
 203 
 204 C2V_VMENTRY_NULL(jobject, getFlagValue, (JNIEnv* env, jobject c2vm, jobject name_handle))
 205 #define RETURN_BOXED_LONG(value) jvalue p; p.j = (jlong) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_LONG, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 206 #define RETURN_BOXED_DOUBLE(value) jvalue p; p.d = (jdouble) (value); JVMCIObject box = JVMCIENV-&gt;create_box(T_DOUBLE, &amp;p, JVMCI_CHECK_NULL); return box.as_jobject();
 207   JVMCIObject name = JVMCIENV-&gt;wrap(name_handle);
 208   if (name.is_null()) {
 209     JVMCI_THROW_NULL(NullPointerException);
 210   }
 211   const char* cstring = JVMCIENV-&gt;as_utf8_string(name);
 212   const JVMFlag* flag = JVMFlag::find_declared_flag(cstring);
 213   if (flag == NULL) {
 214     return c2vm;
 215   }
 216   if (flag-&gt;is_bool()) {
 217     jvalue prim;
 218     prim.z = flag-&gt;get_bool();
 219     JVMCIObject box = JVMCIENV-&gt;create_box(T_BOOLEAN, &amp;prim, JVMCI_CHECK_NULL);
 220     return JVMCIENV-&gt;get_jobject(box);
 221   } else if (flag-&gt;is_ccstr()) {
 222     JVMCIObject value = JVMCIENV-&gt;create_string(flag-&gt;get_ccstr(), JVMCI_CHECK_NULL);
 223     return JVMCIENV-&gt;get_jobject(value);
 224   } else if (flag-&gt;is_intx()) {
 225     RETURN_BOXED_LONG(flag-&gt;get_intx());
 226   } else if (flag-&gt;is_int()) {
 227     RETURN_BOXED_LONG(flag-&gt;get_int());
 228   } else if (flag-&gt;is_uint()) {
 229     RETURN_BOXED_LONG(flag-&gt;get_uint());
 230   } else if (flag-&gt;is_uint64_t()) {
 231     RETURN_BOXED_LONG(flag-&gt;get_uint64_t());
 232   } else if (flag-&gt;is_size_t()) {
 233     RETURN_BOXED_LONG(flag-&gt;get_size_t());
 234   } else if (flag-&gt;is_uintx()) {
 235     RETURN_BOXED_LONG(flag-&gt;get_uintx());
 236   } else if (flag-&gt;is_double()) {
 237     RETURN_BOXED_DOUBLE(flag-&gt;get_double());
 238   } else {
 239     JVMCI_ERROR_NULL(&quot;VM flag %s has unsupported type %s&quot;, flag-&gt;_name, flag-&gt;_type);
 240   }
 241 #undef RETURN_BOXED_LONG
 242 #undef RETURN_BOXED_DOUBLE
 243 C2V_END
 244 
 245 C2V_VMENTRY_NULL(jobject, getObjectAtAddress, (JNIEnv* env, jobject c2vm, jlong oop_address))
 246   requireInHotSpot(&quot;getObjectAtAddress&quot;, JVMCI_CHECK_NULL);
 247   if (oop_address == 0) {
 248     JVMCI_THROW_MSG_NULL(InternalError, &quot;Handle must be non-zero&quot;);
 249   }
 250   oop obj = *((oopDesc**) oop_address);
 251   if (obj != NULL) {
 252     oopDesc::verify(obj);
 253   }
 254   return JNIHandles::make_local(obj);
 255 C2V_END
 256 
 257 C2V_VMENTRY_NULL(jbyteArray, getBytecode, (JNIEnv* env, jobject, jobject jvmci_method))
 258   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 259 
 260   int code_size = method-&gt;code_size();
 261   jbyte* reconstituted_code = NEW_RESOURCE_ARRAY(jbyte, code_size);
 262 
 263   guarantee(method-&gt;method_holder()-&gt;is_rewritten(), &quot;Method&#39;s holder should be rewritten&quot;);
 264   // iterate over all bytecodes and replace non-Java bytecodes
 265 
 266   for (BytecodeStream s(method); s.next() != Bytecodes::_illegal; ) {
 267     Bytecodes::Code code = s.code();
 268     Bytecodes::Code raw_code = s.raw_code();
 269     int bci = s.bci();
 270     int len = s.instruction_size();
 271 
 272     // Restore original byte code.
 273     reconstituted_code[bci] =  (jbyte) (s.is_wide()? Bytecodes::_wide : code);
 274     if (len &gt; 1) {
 275       memcpy(reconstituted_code + (bci + 1), s.bcp()+1, len-1);
 276     }
 277 
 278     if (len &gt; 1) {
 279       // Restore the big-endian constant pool indexes.
 280       // Cf. Rewriter::scan_method
 281       switch (code) {
 282         case Bytecodes::_getstatic:
 283         case Bytecodes::_putstatic:
 284         case Bytecodes::_getfield:
 285         case Bytecodes::_putfield:
 286         case Bytecodes::_invokevirtual:
 287         case Bytecodes::_invokespecial:
 288         case Bytecodes::_invokestatic:
 289         case Bytecodes::_invokeinterface:
 290         case Bytecodes::_invokehandle: {
 291           int cp_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 292           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 293           break;
 294         }
 295 
 296         case Bytecodes::_invokedynamic: {
 297           int cp_index = Bytes::get_native_u4((address) reconstituted_code + (bci + 1));
 298           Bytes::put_Java_u4((address) reconstituted_code + (bci + 1), (u4) cp_index);
 299           break;
 300         }
 301 
 302         default:
 303           break;
 304       }
 305 
 306       // Not all ldc byte code are rewritten.
 307       switch (raw_code) {
 308         case Bytecodes::_fast_aldc: {
 309           int cpc_index = reconstituted_code[bci + 1] &amp; 0xff;
 310           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 311           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 312           reconstituted_code[bci + 1] = (jbyte) cp_index;
 313           break;
 314         }
 315 
 316         case Bytecodes::_fast_aldc_w: {
 317           int cpc_index = Bytes::get_native_u2((address) reconstituted_code + (bci + 1));
 318           int cp_index = method-&gt;constants()-&gt;object_to_cp_index(cpc_index);
 319           assert(cp_index &lt; method-&gt;constants()-&gt;length(), &quot;sanity check&quot;);
 320           Bytes::put_Java_u2((address) reconstituted_code + (bci + 1), (u2) cp_index);
 321           break;
 322         }
 323 
 324         default:
 325           break;
 326       }
 327     }
 328   }
 329 
 330   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
 331   JVMCIENV-&gt;copy_bytes_from(reconstituted_code, result, 0, code_size);
 332   return JVMCIENV-&gt;get_jbyteArray(result);
 333 C2V_END
 334 
 335 C2V_VMENTRY_0(jint, getExceptionTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
 336   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 337   return method-&gt;exception_table_length();
 338 C2V_END
 339 
 340 C2V_VMENTRY_0(jlong, getExceptionTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
 341   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 342   if (method-&gt;exception_table_length() == 0) {
 343     return 0L;
 344   }
 345   return (jlong) (address) method-&gt;exception_table_start();
 346 C2V_END
 347 
 348 C2V_VMENTRY_NULL(jobject, asResolvedJavaMethod, (JNIEnv* env, jobject, jobject executable_handle))
 349   requireInHotSpot(&quot;asResolvedJavaMethod&quot;, JVMCI_CHECK_NULL);
 350   oop executable = JNIHandles::resolve(executable_handle);
 351   oop mirror = NULL;
 352   int slot = 0;
 353 
 354   if (executable-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 355     mirror = java_lang_reflect_Constructor::clazz(executable);
 356     slot = java_lang_reflect_Constructor::slot(executable);
 357   } else {
 358     assert(executable-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 359     mirror = java_lang_reflect_Method::clazz(executable);
 360     slot = java_lang_reflect_Method::slot(executable);
 361   }
 362   Klass* holder = java_lang_Class::as_Klass(mirror);
 363   methodHandle method (THREAD, InstanceKlass::cast(holder)-&gt;method_with_idnum(slot));
 364   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 365   return JVMCIENV-&gt;get_jobject(result);
 366 }
 367 
 368 C2V_VMENTRY_NULL(jobject, getResolvedJavaMethod, (JNIEnv* env, jobject, jobject base, jlong offset))
 369   Method* method;
 370   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 371   if (base_object.is_null()) {
 372     method = *((Method**)(offset));
 373   } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 374     Handle obj = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 375     if (obj-&gt;is_a(SystemDictionary::ResolvedMethodName_klass())) {
 376       method = (Method*) (intptr_t) obj-&gt;long_field(offset);
 377     } else {
 378       JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, obj-&gt;klass()-&gt;external_name()));
 379     }
 380   } else if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 381     method = JVMCIENV-&gt;asMethod(base_object);
 382   }
 383   if (method == NULL) {
 384     JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
 385   }
 386   assert (method-&gt;is_method(), &quot;invalid read&quot;);
 387   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, method), JVMCI_CHECK_NULL);
 388   return JVMCIENV-&gt;get_jobject(result);
 389 }
 390 
 391 C2V_VMENTRY_NULL(jobject, getConstantPool, (JNIEnv* env, jobject, jobject object_handle))
 392   ConstantPool* cp = NULL;
 393   JVMCIObject object = JVMCIENV-&gt;wrap(object_handle);
 394   if (object.is_null()) {
 395     JVMCI_THROW_NULL(NullPointerException);
 396   }
 397   if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(object)) {
 398     cp = JVMCIENV-&gt;asMethod(object)-&gt;constMethod()-&gt;constants();
 399   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(object)) {
 400     cp = InstanceKlass::cast(JVMCIENV-&gt;asKlass(object))-&gt;constants();
 401   } else {
 402     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 403                 err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(object)));
 404   }
 405   assert(cp != NULL, &quot;npe&quot;);
 406 
 407   JVMCIObject result = JVMCIENV-&gt;get_jvmci_constant_pool(constantPoolHandle(THREAD, cp), JVMCI_CHECK_NULL);
 408   return JVMCIENV-&gt;get_jobject(result);
 409 }
 410 
 411 C2V_VMENTRY_NULL(jobject, getResolvedJavaType0, (JNIEnv* env, jobject, jobject base, jlong offset, jboolean compressed))
 412   JVMCIKlassHandle klass(THREAD);
 413   JVMCIObject base_object = JVMCIENV-&gt;wrap(base);
 414   jlong base_address = 0;
 415   if (base_object.is_non_null() &amp;&amp; offset == oopDesc::klass_offset_in_bytes()) {
 416     // klass = JVMCIENV-&gt;unhandle(base_object)-&gt;klass();
 417     if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 418       Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 419       klass = base_oop-&gt;klass();
 420     } else {
 421       assert(false, &quot;What types are we actually expecting here?&quot;);
 422     }
 423   } else if (!compressed) {
 424     if (base_object.is_non_null()) {
 425       if (JVMCIENV-&gt;isa_HotSpotResolvedJavaMethodImpl(base_object)) {
 426         base_address = (intptr_t) JVMCIENV-&gt;asMethod(base_object);
 427       } else if (JVMCIENV-&gt;isa_HotSpotConstantPool(base_object)) {
 428         base_address = (intptr_t) JVMCIENV-&gt;asConstantPool(base_object);
 429       } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
 430         base_address = (intptr_t) JVMCIENV-&gt;asKlass(base_object);
 431       } else if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base_object)) {
 432         Handle base_oop = JVMCIENV-&gt;asConstant(base_object, JVMCI_CHECK_NULL);
 433         if (base_oop-&gt;is_a(SystemDictionary::Class_klass())) {
 434           base_address = cast_from_oop&lt;jlong&gt;(base_oop());
 435         }
 436       }
 437       if (base_address == 0) {
 438         JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 439                     err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;, JVMCIENV-&gt;klass_name(base_object), offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 440       }
 441     }
 442     klass = *((Klass**) (intptr_t) (base_address + offset));
 443   } else {
 444     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
 445                 err_msg(&quot;Unexpected arguments: %s &quot; JLONG_FORMAT &quot; %s&quot;,
 446                         base_object.is_non_null() ? JVMCIENV-&gt;klass_name(base_object) : &quot;null&quot;,
 447                         offset, compressed ? &quot;true&quot; : &quot;false&quot;));
 448   }
 449   assert (klass == NULL || klass-&gt;is_klass(), &quot;invalid read&quot;);
 450   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 451   return JVMCIENV-&gt;get_jobject(result);
 452 }
 453 
 454 C2V_VMENTRY_NULL(jobject, findUniqueConcreteMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 455   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 456   Klass* holder = JVMCIENV-&gt;asKlass(jvmci_type);
 457   if (holder-&gt;is_interface()) {
 458     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, holder-&gt;external_name()));
 459   }
 460   if (method-&gt;can_be_statically_bound()) {
 461     JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Effectively static method %s.%s should be handled in Java code&quot;, method-&gt;method_holder()-&gt;external_name(), method-&gt;external_name()));
 462   }
 463 
 464   methodHandle ucm;
 465   {
 466     MutexLocker locker(Compile_lock);
 467     ucm = methodHandle(THREAD, Dependencies::find_unique_concrete_method(holder, method()));
 468   }
 469   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(ucm, JVMCI_CHECK_NULL);
 470   return JVMCIENV-&gt;get_jobject(result);
 471 C2V_END
 472 
 473 C2V_VMENTRY_NULL(jobject, getImplementor, (JNIEnv* env, jobject, jobject jvmci_type))
 474   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 475   if (!klass-&gt;is_interface()) {
 476     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 477         err_msg(&quot;Expected interface type, got %s&quot;, klass-&gt;external_name()));
 478   }
 479   InstanceKlass* iklass = InstanceKlass::cast(klass);
 480   JVMCIKlassHandle handle(THREAD);
 481   {
 482     // Need Compile_lock around implementor()
 483     MutexLocker locker(Compile_lock);
 484     handle = iklass-&gt;implementor();
 485   }
 486   JVMCIObject implementor = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 487   return JVMCIENV-&gt;get_jobject(implementor);
 488 C2V_END
 489 
 490 C2V_VMENTRY_0(jboolean, methodIsIgnoredBySecurityStackWalk,(JNIEnv* env, jobject, jobject jvmci_method))
 491   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 492   return method-&gt;is_ignored_by_security_stack_walk();
 493 C2V_END
 494 
 495 C2V_VMENTRY_0(jboolean, isCompilable,(JNIEnv* env, jobject, jobject jvmci_method))
 496   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
 497   ConstantPool* cp = method-&gt;constMethod()-&gt;constants();
 498   assert(cp != NULL, &quot;npe&quot;);
 499   // don&#39;t inline method when constant pool contains a CONSTANT_Dynamic
 500   return !method-&gt;is_not_compilable(CompLevel_full_optimization) &amp;&amp; !cp-&gt;has_dynamic_constant();
 501 C2V_END
 502 
 503 C2V_VMENTRY_0(jboolean, hasNeverInlineDirective,(JNIEnv* env, jobject, jobject jvmci_method))
 504   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 505   return !Inline || CompilerOracle::should_not_inline(method) || method-&gt;dont_inline();
 506 C2V_END
 507 
 508 C2V_VMENTRY_0(jboolean, shouldInlineMethod,(JNIEnv* env, jobject, jobject jvmci_method))
 509   methodHandle method (THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 510   return CompilerOracle::should_inline(method) || method-&gt;force_inline();
 511 C2V_END
 512 
 513 C2V_VMENTRY_NULL(jobject, lookupType, (JNIEnv* env, jobject, jstring jname, jclass accessing_class, jboolean resolve))
 514   JVMCIObject name = JVMCIENV-&gt;wrap(jname);
 515   const char* str = JVMCIENV-&gt;as_utf8_string(name);
 516   TempNewSymbol class_name = SymbolTable::new_symbol(str);
 517 
 518   if (class_name-&gt;utf8_length() &lt;= 1) {
 519     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Primitive type %s should be handled in Java code&quot;, class_name-&gt;as_C_string()));
 520   }
 521 
 522   JVMCIKlassHandle resolved_klass(THREAD);
 523   Klass* accessing_klass = NULL;
 524   Handle class_loader;
 525   Handle protection_domain;
 526   if (accessing_class != NULL) {
 527     accessing_klass = JVMCIENV-&gt;asKlass(accessing_class);
 528     class_loader = Handle(THREAD, accessing_klass-&gt;class_loader());
 529     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
 530   } else {
 531     // Use the System class loader
 532     class_loader = Handle(THREAD, SystemDictionary::java_system_loader());
 533     JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 534   }
 535 
 536   if (resolve) {
 537     resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_0);
 538     if (resolved_klass == NULL) {
 539       JVMCI_THROW_MSG_NULL(ClassNotFoundException, str);
 540     }
 541   } else {
<a name="2" id="anc2"></a><span class="line-modified"> 542     if (class_name-&gt;char_at(0) == JVM_SIGNATURE_CLASS &amp;&amp;</span>
<span class="line-removed"> 543         class_name-&gt;char_at(class_name-&gt;utf8_length()-1) == JVM_SIGNATURE_ENDCLASS) {</span>
 544       // This is a name from a signature.  Strip off the trimmings.
 545       // Call recursive to keep scope of strippedsym.
<a name="3" id="anc3"></a><span class="line-modified"> 546       TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1,</span>
<span class="line-removed"> 547                                                           class_name-&gt;utf8_length()-2);</span>
 548       resolved_klass = SystemDictionary::find(strippedsym, class_loader, protection_domain, CHECK_0);
<a name="4" id="anc4"></a><span class="line-modified"> 549     } else if (FieldType::is_array(class_name)) {</span>
<span class="line-modified"> 550       FieldArrayInfo fd;</span>
<span class="line-modified"> 551       // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified"> 552       // of this call</span>
<span class="line-modified"> 553       BasicType t = FieldType::get_array_info(class_name, fd, CHECK_0);</span>
<span class="line-removed"> 554       if (t == T_OBJECT) {</span>
<span class="line-removed"> 555         TempNewSymbol strippedsym = SymbolTable::new_symbol(class_name-&gt;as_utf8()+1+fd.dimension(),</span>
<span class="line-removed"> 556                                                             class_name-&gt;utf8_length()-2-fd.dimension());</span>
 557         resolved_klass = SystemDictionary::find(strippedsym,
<a name="5" id="anc5"></a><span class="line-modified"> 558                                                              class_loader,</span>
<span class="line-modified"> 559                                                              protection_domain,</span>
<span class="line-modified"> 560                                                              CHECK_0);</span>
 561         if (!resolved_klass.is_null()) {
<a name="6" id="anc6"></a><span class="line-modified"> 562           resolved_klass = resolved_klass-&gt;array_klass(fd.dimension(), CHECK_0);</span>
 563         }
 564       } else {
<a name="7" id="anc7"></a><span class="line-modified"> 565         resolved_klass = TypeArrayKlass::cast(Universe::typeArrayKlassObj(t))-&gt;array_klass(fd.dimension(), CHECK_0);</span>
 566       }
 567     } else {
 568       resolved_klass = SystemDictionary::find(class_name, class_loader, protection_domain, CHECK_0);
 569     }
 570   }
 571   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 572   return JVMCIENV-&gt;get_jobject(result);
 573 C2V_END
 574 
 575 C2V_VMENTRY_NULL(jobject, getArrayType, (JNIEnv* env, jobject, jobject jvmci_type))
 576   if (jvmci_type == NULL) {
 577     JVMCI_THROW_0(NullPointerException);
 578   }
 579 
 580   JVMCIObject jvmci_type_object = JVMCIENV-&gt;wrap(jvmci_type);
 581   JVMCIKlassHandle array_klass(THREAD);
 582   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(jvmci_type_object)) {
 583     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(jvmci_type_object), JVMCI_CHECK_0);
 584     if (type == T_VOID) {
 585       return NULL;
 586     }
 587     array_klass = Universe::typeArrayKlassObj(type);
 588     if (array_klass == NULL) {
 589       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;No array klass for primitive type %s&quot;, type2name(type)));
 590     }
 591   } else {
 592     Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 593     if (klass == NULL) {
 594       JVMCI_THROW_0(NullPointerException);
 595     }
 596     array_klass = klass-&gt;array_klass(CHECK_NULL);
 597   }
 598   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(array_klass, JVMCI_CHECK_NULL);
 599   return JVMCIENV-&gt;get_jobject(result);
 600 C2V_END
 601 
 602 C2V_VMENTRY_NULL(jobject, lookupClass, (JNIEnv* env, jobject, jclass mirror))
 603   requireInHotSpot(&quot;lookupClass&quot;, JVMCI_CHECK_NULL);
 604   if (mirror == NULL) {
 605     return NULL;
 606   }
 607   JVMCIKlassHandle klass(THREAD);
 608   klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
 609   if (klass == NULL) {
 610     JVMCI_THROW_MSG_NULL(IllegalArgumentException, &quot;Primitive classes are unsupported&quot;);
 611   }
 612   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 613   return JVMCIENV-&gt;get_jobject(result);
 614 }
 615 
 616 C2V_VMENTRY_NULL(jobject, resolvePossiblyCachedConstantInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 617   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 618   oop result = cp-&gt;resolve_possibly_cached_constant_at(index, CHECK_NULL);
 619   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(result));
 620 C2V_END
 621 
 622 C2V_VMENTRY_0(jint, lookupNameAndTypeRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 623   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 624   return cp-&gt;name_and_type_ref_index_at(index);
 625 C2V_END
 626 
 627 C2V_VMENTRY_NULL(jobject, lookupNameInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 628   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 629   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;name_ref_at(which), JVMCI_CHECK_NULL);
 630   return JVMCIENV-&gt;get_jobject(sym);
 631 C2V_END
 632 
 633 C2V_VMENTRY_NULL(jobject, lookupSignatureInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint which))
 634   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 635   JVMCIObject sym = JVMCIENV-&gt;create_string(cp-&gt;signature_ref_at(which), JVMCI_CHECK_NULL);
 636   return JVMCIENV-&gt;get_jobject(sym);
 637 C2V_END
 638 
 639 C2V_VMENTRY_0(jint, lookupKlassRefIndexInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 640   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 641   return cp-&gt;klass_ref_index_at(index);
 642 C2V_END
 643 
 644 C2V_VMENTRY_NULL(jobject, resolveTypeInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 645   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 646   Klass* klass = cp-&gt;klass_at(index, CHECK_NULL);
 647   JVMCIKlassHandle resolved_klass(THREAD, klass);
 648   if (resolved_klass-&gt;is_instance_klass()) {
 649     InstanceKlass::cast(resolved_klass())-&gt;link_class(CHECK_NULL);
 650     if (!InstanceKlass::cast(resolved_klass())-&gt;is_linked()) {
 651       // link_class() should not return here if there is an issue.
 652       JVMCI_THROW_MSG_NULL(InternalError, err_msg(&quot;Class %s must be linked&quot;, resolved_klass()-&gt;external_name()));
 653     }
 654   }
 655   JVMCIObject klassObject = JVMCIENV-&gt;get_jvmci_type(resolved_klass, JVMCI_CHECK_NULL);
 656   return JVMCIENV-&gt;get_jobject(klassObject);
 657 C2V_END
 658 
 659 C2V_VMENTRY_NULL(jobject, lookupKlassInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 660   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 661   Klass* loading_klass = cp-&gt;pool_holder();
 662   bool is_accessible = false;
 663   JVMCIKlassHandle klass(THREAD, JVMCIRuntime::get_klass_by_index(cp, index, is_accessible, loading_klass));
 664   Symbol* symbol = NULL;
 665   if (klass.is_null()) {
 666     constantTag tag = cp-&gt;tag_at(index);
 667     if (tag.is_klass()) {
 668       // The klass has been inserted into the constant pool
 669       // very recently.
 670       klass = cp-&gt;resolved_klass_at(index);
 671     } else if (tag.is_symbol()) {
 672       symbol = cp-&gt;symbol_at(index);
 673     } else {
 674       assert(cp-&gt;tag_at(index).is_unresolved_klass(), &quot;wrong tag&quot;);
 675       symbol = cp-&gt;klass_name_at(index);
 676     }
 677   }
 678   JVMCIObject result;
 679   if (!klass.is_null()) {
 680     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
 681   } else {
 682     result = JVMCIENV-&gt;create_string(symbol, JVMCI_CHECK_NULL);
 683   }
 684   return JVMCIENV-&gt;get_jobject(result);
 685 C2V_END
 686 
 687 C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 688   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 689   oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);
 690   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(appendix_oop));
 691 C2V_END
 692 
 693 C2V_VMENTRY_NULL(jobject, lookupMethodInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jbyte opcode))
 694   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 695   InstanceKlass* pool_holder = cp-&gt;pool_holder();
 696   Bytecodes::Code bc = (Bytecodes::Code) (((int) opcode) &amp; 0xFF);
 697   methodHandle method(THREAD, JVMCIRuntime::get_method_by_index(cp, index, bc, pool_holder));
 698   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(method, JVMCI_CHECK_NULL);
 699   return JVMCIENV-&gt;get_jobject(result);
 700 C2V_END
 701 
 702 C2V_VMENTRY_0(jint, constantPoolRemapInstructionOperandFromCache, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
 703   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 704   return cp-&gt;remap_instruction_operand_from_cache(index);
 705 C2V_END
 706 
 707 C2V_VMENTRY_NULL(jobject, resolveFieldInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index, jobject jvmci_method, jbyte opcode, jintArray info_handle))
 708   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
 709   Bytecodes::Code code = (Bytecodes::Code)(((int) opcode) &amp; 0xFF);
 710   fieldDescriptor fd;
 711   methodHandle mh(THREAD, (jvmci_method != NULL) ? JVMCIENV-&gt;asMethod(jvmci_method) : NULL);
 712   LinkInfo link_info(cp, index, mh, CHECK_0);
 713   LinkResolver::resolve_field(fd, link_info, Bytecodes::java_code(code), false, CHECK_0);
 714   JVMCIPrimitiveArray info = JVMCIENV-&gt;wrap(info_handle);
 715   if (info.is_null() || JVMCIENV-&gt;get_length(info) != 3) {
 716     JVMCI_ERROR_NULL(&quot;info must not be null and have a length of 3&quot;);
 717   }
 718   JVMCIENV-&gt;put_int_at(info, 0, fd.access_flags().as_int());
 719   JVMCIENV-&gt;put_int_at(info, 1, fd.offset());
 720   JVMCIENV-&gt;put_int_at(info, 2, fd.index());
 721   JVMCIKlassHandle handle(THREAD, fd.field_holder());
 722   JVMCIObject field_holder = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
 723   return JVMCIENV-&gt;get_jobject(field_holder);
 724 C2V_END
 725 
 726 C2V_VMENTRY_0(jint, getVtableIndexForInterfaceMethod, (JNIEnv* env, jobject, jobject jvmci_type, jobject jvmci_method))
 727   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 728   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 729   if (klass-&gt;is_interface()) {
 730     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Interface %s should be handled in Java code&quot;, klass-&gt;external_name()));
 731   }
 732   if (!method-&gt;method_holder()-&gt;is_interface()) {
 733     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Method %s is not held by an interface, this case should be handled in Java code&quot;, method-&gt;name_and_sig_as_C_string()));
 734   }
 735   if (!klass-&gt;is_instance_klass()) {
 736     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
 737   }
 738   if (!InstanceKlass::cast(klass)-&gt;is_linked()) {
 739     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be linked&quot;, klass-&gt;external_name()));
 740   }
 741   return LinkResolver::vtable_index_of_interface_method(klass, method);
 742 C2V_END
 743 
 744 C2V_VMENTRY_NULL(jobject, resolveMethod, (JNIEnv* env, jobject, jobject receiver_jvmci_type, jobject jvmci_method, jobject caller_jvmci_type))
 745   Klass* recv_klass = JVMCIENV-&gt;asKlass(receiver_jvmci_type);
 746   Klass* caller_klass = JVMCIENV-&gt;asKlass(caller_jvmci_type);
 747   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 748 
 749   Klass* resolved     = method-&gt;method_holder();
 750   Symbol* h_name      = method-&gt;name();
 751   Symbol* h_signature = method-&gt;signature();
 752 
 753   if (MethodHandles::is_signature_polymorphic_method(method())) {
 754       // Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.
 755       return NULL;
 756   }
 757 
 758   if (method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 759       resolved == SystemDictionary::Object_klass() &amp;&amp;
 760       recv_klass-&gt;is_array_klass()) {
 761     // Resolution of the clone method on arrays always returns Object.clone even though that method
 762     // has protected access.  There&#39;s some trickery in the access checking to make this all work out
 763     // so it&#39;s necessary to pass in the array class as the resolved class to properly trigger this.
 764     // Otherwise it&#39;s impossible to resolve the array clone methods through JVMCI.  See
 765     // LinkResolver::check_method_accessability for the matching logic.
 766     resolved = recv_klass;
 767   }
 768 
 769   LinkInfo link_info(resolved, h_name, h_signature, caller_klass);
 770   Method* m = NULL;
 771   // Only do exact lookup if receiver klass has been linked.  Otherwise,
 772   // the vtable has not been setup, and the LinkResolver will fail.
 773   if (recv_klass-&gt;is_array_klass() ||
 774       (InstanceKlass::cast(recv_klass)-&gt;is_linked() &amp;&amp; !recv_klass-&gt;is_interface())) {
 775     if (resolved-&gt;is_interface()) {
 776       m = LinkResolver::resolve_interface_call_or_null(recv_klass, link_info);
 777     } else {
 778       m = LinkResolver::resolve_virtual_call_or_null(recv_klass, link_info);
 779     }
 780   }
 781 
 782   if (m == NULL) {
 783     // Return NULL if there was a problem with lookup (uninitialized class, etc.)
 784     return NULL;
 785   }
 786 
 787   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(methodHandle(THREAD, m), JVMCI_CHECK_NULL);
 788   return JVMCIENV-&gt;get_jobject(result);
 789 C2V_END
 790 
 791 C2V_VMENTRY_0(jboolean, hasFinalizableSubclass,(JNIEnv* env, jobject, jobject jvmci_type))
 792   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 793   assert(klass != NULL, &quot;method must not be called for primitive types&quot;);
 794   return Dependencies::find_finalizable_subclass(klass) != NULL;
 795 C2V_END
 796 
 797 C2V_VMENTRY_NULL(jobject, getClassInitializer, (JNIEnv* env, jobject, jobject jvmci_type))
 798   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
 799   if (!klass-&gt;is_instance_klass()) {
 800     return NULL;
 801   }
 802   InstanceKlass* iklass = InstanceKlass::cast(klass);
 803   methodHandle clinit(THREAD, iklass-&gt;class_initializer());
 804   JVMCIObject result = JVMCIENV-&gt;get_jvmci_method(clinit, JVMCI_CHECK_NULL);
 805   return JVMCIENV-&gt;get_jobject(result);
 806 C2V_END
 807 
 808 C2V_VMENTRY_0(jlong, getMaxCallTargetOffset, (JNIEnv* env, jobject, jlong addr))
 809   address target_addr = (address) addr;
 810   if (target_addr != 0x0) {
 811     int64_t off_low = (int64_t)target_addr - ((int64_t)CodeCache::low_bound() + sizeof(int));
 812     int64_t off_high = (int64_t)target_addr - ((int64_t)CodeCache::high_bound() + sizeof(int));
 813     return MAX2(ABS(off_low), ABS(off_high));
 814   }
 815   return -1;
 816 C2V_END
 817 
 818 C2V_VMENTRY(void, setNotInlinableOrCompilable,(JNIEnv* env, jobject,  jobject jvmci_method))
 819   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
 820   method-&gt;set_not_c1_compilable();
 821   method-&gt;set_not_c2_compilable();
 822   method-&gt;set_dont_inline(true);
 823 C2V_END
 824 
 825 C2V_VMENTRY_0(jint, installCode, (JNIEnv *env, jobject, jobject target, jobject compiled_code,
 826             jobject installed_code, jlong failed_speculations_address, jbyteArray speculations_obj))
 827   HandleMark hm;
 828   JNIHandleMark jni_hm(thread);
 829 
 830   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 831   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 832   CodeBlob* cb = NULL;
 833   JVMCIObject installed_code_handle = JVMCIENV-&gt;wrap(installed_code);
 834   JVMCIPrimitiveArray speculations_handle = JVMCIENV-&gt;wrap(speculations_obj);
 835 
 836   int speculations_len = JVMCIENV-&gt;get_length(speculations_handle);
 837   char* speculations = NEW_RESOURCE_ARRAY(char, speculations_len);
 838   JVMCIENV-&gt;copy_bytes_to(speculations_handle, (jbyte*) speculations, 0, speculations_len);
 839 
 840   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK_JNI_ERR);
 841 
 842   TraceTime install_time(&quot;installCode&quot;, JVMCICompiler::codeInstallTimer());
 843   bool is_immutable_PIC = JVMCIENV-&gt;get_HotSpotCompiledCode_isImmutablePIC(compiled_code_handle) &gt; 0;
 844 
 845   CodeInstaller installer(JVMCIENV, is_immutable_PIC);
 846   JVMCI::CodeInstallResult result = installer.install(compiler,
 847       target_handle,
 848       compiled_code_handle,
 849       cb,
 850       installed_code_handle,
 851       (FailedSpeculation**)(address) failed_speculations_address,
 852       speculations,
 853       speculations_len,
 854       JVMCI_CHECK_0);
 855 
 856   if (PrintCodeCacheOnCompilation) {
 857     stringStream s;
 858     // Dump code cache into a buffer before locking the tty,
 859     {
 860       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 861       CodeCache::print_summary(&amp;s, false);
 862     }
 863     ttyLocker ttyl;
 864     tty-&gt;print_raw_cr(s.as_string());
 865   }
 866 
 867   if (result != JVMCI::ok) {
 868     assert(cb == NULL, &quot;should be&quot;);
 869   } else {
 870     if (installed_code_handle.is_non_null()) {
 871       if (cb-&gt;is_nmethod()) {
 872         assert(JVMCIENV-&gt;isa_HotSpotNmethod(installed_code_handle), &quot;wrong type&quot;);
 873         // Clear the link to an old nmethod first
 874         JVMCIObject nmethod_mirror = installed_code_handle;
 875         JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK_0);
 876       } else {
 877         assert(JVMCIENV-&gt;isa_InstalledCode(installed_code_handle), &quot;wrong type&quot;);
 878       }
 879       // Initialize the link to the new code blob
 880       JVMCIENV-&gt;initialize_installed_code(installed_code_handle, cb, JVMCI_CHECK_0);
 881     }
 882   }
 883   return result;
 884 C2V_END
 885 
 886 C2V_VMENTRY_0(jint, getMetadata, (JNIEnv *env, jobject, jobject target, jobject compiled_code, jobject metadata))
 887 #if INCLUDE_AOT
 888   HandleMark hm;
 889   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 890 
 891   JVMCIObject target_handle = JVMCIENV-&gt;wrap(target);
 892   JVMCIObject compiled_code_handle = JVMCIENV-&gt;wrap(compiled_code);
 893   JVMCIObject metadata_handle = JVMCIENV-&gt;wrap(metadata);
 894 
 895   CodeMetadata code_metadata;
 896 
 897   CodeInstaller installer(JVMCIENV, true /* immutable PIC compilation */);
 898   JVMCI::CodeInstallResult result = installer.gather_metadata(target_handle, compiled_code_handle, code_metadata, JVMCI_CHECK_0);
 899   if (result != JVMCI::ok) {
 900     return result;
 901   }
 902 
 903   if (code_metadata.get_nr_pc_desc() &gt; 0) {
 904     int size = sizeof(PcDesc) * code_metadata.get_nr_pc_desc();
 905     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 906     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_pc_desc(), array, 0, size);
 907     HotSpotJVMCI::HotSpotMetaData::set_pcDescBytes(JVMCIENV, metadata_handle, array);
 908   }
 909 
 910   if (code_metadata.get_scopes_size() &gt; 0) {
 911     int size = code_metadata.get_scopes_size();
 912     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 913     JVMCIENV-&gt;copy_bytes_from((jbyte*) code_metadata.get_scopes_desc(), array, 0, size);
 914     HotSpotJVMCI::HotSpotMetaData::set_scopesDescBytes(JVMCIENV, metadata_handle, array);
 915   }
 916 
 917   RelocBuffer* reloc_buffer = code_metadata.get_reloc_buffer();
 918   int size = (int) reloc_buffer-&gt;size();
 919   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 920   JVMCIENV-&gt;copy_bytes_from((jbyte*) reloc_buffer-&gt;begin(), array, 0, size);
 921   HotSpotJVMCI::HotSpotMetaData::set_relocBytes(JVMCIENV, metadata_handle, array);
 922 
 923   const OopMapSet* oopMapSet = installer.oopMapSet();
 924   {
 925     ResourceMark mark;
 926     ImmutableOopMapBuilder builder(oopMapSet);
 927     int size = builder.heap_size();
 928     JVMCIPrimitiveArray array = JVMCIENV-&gt;new_byteArray(size, JVMCI_CHECK_(JVMCI::cache_full));
 929     builder.generate_into((address) HotSpotJVMCI::resolve(array)-&gt;byte_at_addr(0));
 930     HotSpotJVMCI::HotSpotMetaData::set_oopMaps(JVMCIENV, metadata_handle, array);
 931   }
 932 
 933   AOTOopRecorder* recorder = code_metadata.get_oop_recorder();
 934 
 935   int nr_meta_refs = recorder-&gt;nr_meta_refs();
 936   JVMCIObjectArray metadataArray = JVMCIENV-&gt;new_Object_array(nr_meta_refs, JVMCI_CHECK_(JVMCI::cache_full));
 937   for (int i = 0; i &lt; nr_meta_refs; ++i) {
 938     jobject element = recorder-&gt;meta_element(i);
 939     if (element == NULL) {
 940       return JVMCI::cache_full;
 941     }
 942     JVMCIENV-&gt;put_object_at(metadataArray, i, JVMCIENV-&gt;wrap(element));
 943   }
 944   HotSpotJVMCI::HotSpotMetaData::set_metadata(JVMCIENV, metadata_handle, metadataArray);
 945 
 946   ExceptionHandlerTable* handler = code_metadata.get_exception_table();
 947   int table_size = handler-&gt;size_in_bytes();
 948   JVMCIPrimitiveArray exceptionArray = JVMCIENV-&gt;new_byteArray(table_size, JVMCI_CHECK_(JVMCI::cache_full));
 949   if (table_size &gt; 0) {
 950     handler-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(exceptionArray)-&gt;byte_at_addr(0));
 951   }
 952   HotSpotJVMCI::HotSpotMetaData::set_exceptionBytes(JVMCIENV, metadata_handle, exceptionArray);
 953 
 954   ImplicitExceptionTable* implicit = code_metadata.get_implicit_exception_table();
 955   int implicit_table_size = implicit-&gt;size_in_bytes();
 956   JVMCIPrimitiveArray implicitExceptionArray = JVMCIENV-&gt;new_byteArray(implicit_table_size, JVMCI_CHECK_(JVMCI::cache_full));
 957   if (implicit_table_size &gt; 0) {
 958     implicit-&gt;copy_bytes_to((address) HotSpotJVMCI::resolve(implicitExceptionArray)-&gt;byte_at_addr(0), implicit_table_size);
 959   }
 960   HotSpotJVMCI::HotSpotMetaData::set_implicitExceptionBytes(JVMCIENV, metadata_handle, implicitExceptionArray);
 961 
 962   return result;
 963 #else
 964   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
 965 #endif
 966 C2V_END
 967 
 968 C2V_VMENTRY(void, resetCompilationStatistics, (JNIEnv* env, jobject))
 969   JVMCICompiler* compiler = JVMCICompiler::instance(true, CHECK);
 970   CompilerStatistics* stats = compiler-&gt;stats();
 971   stats-&gt;_standard.reset();
 972   stats-&gt;_osr.reset();
 973 C2V_END
 974 
 975 C2V_VMENTRY_NULL(jobject, disassembleCodeBlob, (JNIEnv* env, jobject, jobject installedCode))
 976   HandleMark hm;
 977 
 978   if (installedCode == NULL) {
 979     JVMCI_THROW_MSG_NULL(NullPointerException, &quot;installedCode is null&quot;);
 980   }
 981 
 982   JVMCIObject installedCodeObject = JVMCIENV-&gt;wrap(installedCode);
 983   nmethodLocker locker;
 984   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(installedCodeObject, locker);
 985   if (cb == NULL) {
 986     return NULL;
 987   }
 988 
 989   // We don&#39;t want the stringStream buffer to resize during disassembly as it
 990   // uses scoped resource memory. If a nested function called during disassembly uses
 991   // a ResourceMark and the buffer expands within the scope of the mark,
 992   // the buffer becomes garbage when that scope is exited. Experience shows that
 993   // the disassembled code is typically about 10x the code size so a fixed buffer
 994   // sized to 20x code size plus a fixed amount for header info should be sufficient.
 995   int bufferSize = cb-&gt;code_size() * 20 + 1024;
 996   char* buffer = NEW_RESOURCE_ARRAY(char, bufferSize);
 997   stringStream st(buffer, bufferSize);
 998   if (cb-&gt;is_nmethod()) {
 999     nmethod* nm = (nmethod*) cb;
1000     if (!nm-&gt;is_alive()) {
1001       return NULL;
1002     }
1003   }
1004   Disassembler::decode(cb, &amp;st);
1005   if (st.size() &lt;= 0) {
1006     return NULL;
1007   }
1008 
1009   JVMCIObject result = JVMCIENV-&gt;create_string(st.as_string(), JVMCI_CHECK_NULL);
1010   return JVMCIENV-&gt;get_jobject(result);
1011 C2V_END
1012 
1013 C2V_VMENTRY_NULL(jobject, getStackTraceElement, (JNIEnv* env, jobject, jobject jvmci_method, int bci))
1014   HandleMark hm;
1015 
1016   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1017   JVMCIObject element = JVMCIENV-&gt;new_StackTraceElement(method, bci, JVMCI_CHECK_NULL);
1018   return JVMCIENV-&gt;get_jobject(element);
1019 C2V_END
1020 
1021 C2V_VMENTRY_NULL(jobject, executeHotSpotNmethod, (JNIEnv* env, jobject, jobject args, jobject hs_nmethod))
1022   // The incoming arguments array would have to contain JavaConstants instead of regular objects
1023   // and the return value would have to be wrapped as a JavaConstant.
1024   requireInHotSpot(&quot;executeHotSpotNmethod&quot;, JVMCI_CHECK_NULL);
1025 
1026   HandleMark hm;
1027 
1028   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1029   nmethodLocker locker;
1030   nmethod* nm = JVMCIENV-&gt;get_nmethod(nmethod_mirror, locker);
1031   if (nm == NULL) {
1032     JVMCI_THROW_NULL(InvalidInstalledCodeException);
1033   }
1034   methodHandle mh(THREAD, nm-&gt;method());
1035   Symbol* signature = mh-&gt;signature();
1036   JavaCallArguments jca(mh-&gt;size_of_parameters());
1037 
1038   JavaArgumentUnboxer jap(signature, &amp;jca, (arrayOop) JNIHandles::resolve(args), mh-&gt;is_static());
<a name="8" id="anc8"></a><span class="line-modified">1039   JavaValue result(jap.get_ret_type());</span>
1040   jca.set_alternative_target(nm);
1041   JavaCalls::call(&amp;result, mh, &amp;jca, CHECK_NULL);
1042 
<a name="9" id="anc9"></a><span class="line-modified">1043   if (jap.get_ret_type() == T_VOID) {</span>
1044     return NULL;
<a name="10" id="anc10"></a><span class="line-modified">1045   } else if (is_reference_type(jap.get_ret_type())) {</span>
1046     return JNIHandles::make_local((oop) result.get_jobject());
1047   } else {
1048     jvalue *value = (jvalue *) result.get_value_addr();
1049     // Narrow the value down if required (Important on big endian machines)
<a name="11" id="anc11"></a><span class="line-modified">1050     switch (jap.get_ret_type()) {</span>
1051       case T_BOOLEAN:
1052        value-&gt;z = (jboolean) value-&gt;i;
1053        break;
1054       case T_BYTE:
1055        value-&gt;b = (jbyte) value-&gt;i;
1056        break;
1057       case T_CHAR:
1058        value-&gt;c = (jchar) value-&gt;i;
1059        break;
1060       case T_SHORT:
1061        value-&gt;s = (jshort) value-&gt;i;
1062        break;
1063       default:
1064         break;
1065     }
<a name="12" id="anc12"></a><span class="line-modified">1066     JVMCIObject o = JVMCIENV-&gt;create_box(jap.get_ret_type(), value, JVMCI_CHECK_NULL);</span>
1067     return JVMCIENV-&gt;get_jobject(o);
1068   }
1069 C2V_END
1070 
1071 C2V_VMENTRY_NULL(jlongArray, getLineNumberTable, (JNIEnv* env, jobject, jobject jvmci_method))
1072   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1073   if (!method-&gt;has_linenumber_table()) {
1074     return NULL;
1075   }
1076   u2 num_entries = 0;
1077   CompressedLineNumberReadStream streamForSize(method-&gt;compressed_linenumber_table());
1078   while (streamForSize.read_pair()) {
1079     num_entries++;
1080   }
1081 
1082   CompressedLineNumberReadStream stream(method-&gt;compressed_linenumber_table());
1083   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(2 * num_entries, JVMCI_CHECK_NULL);
1084 
1085   int i = 0;
1086   jlong value;
1087   while (stream.read_pair()) {
1088     value = ((long) stream.bci());
1089     JVMCIENV-&gt;put_long_at(result, i, value);
1090     value = ((long) stream.line());
1091     JVMCIENV-&gt;put_long_at(result, i + 1, value);
1092     i += 2;
1093   }
1094 
1095   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
1096 C2V_END
1097 
1098 C2V_VMENTRY_0(jlong, getLocalVariableTableStart, (JNIEnv* env, jobject, jobject jvmci_method))
1099   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1100   if (!method-&gt;has_localvariable_table()) {
1101     return 0;
1102   }
1103   return (jlong) (address) method-&gt;localvariable_table_start();
1104 C2V_END
1105 
1106 C2V_VMENTRY_0(jint, getLocalVariableTableLength, (JNIEnv* env, jobject, jobject jvmci_method))
1107   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1108   return method-&gt;localvariable_table_length();
1109 C2V_END
1110 
1111 C2V_VMENTRY(void, reprofile, (JNIEnv* env, jobject, jobject jvmci_method))
1112   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1113   MethodCounters* mcs = method-&gt;method_counters();
1114   if (mcs != NULL) {
1115     mcs-&gt;clear_counters();
1116   }
1117   NOT_PRODUCT(method-&gt;set_compiled_invocation_count(0));
1118 
1119   CompiledMethod* code = method-&gt;code();
1120   if (code != NULL) {
1121     code-&gt;make_not_entrant();
1122   }
1123 
1124   MethodData* method_data = method-&gt;method_data();
1125   if (method_data == NULL) {
1126     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
1127     method_data = MethodData::allocate(loader_data, method, CHECK);
1128     method-&gt;set_method_data(method_data);
1129   } else {
1130     method_data-&gt;initialize();
1131   }
1132 C2V_END
1133 
1134 
1135 C2V_VMENTRY(void, invalidateHotSpotNmethod, (JNIEnv* env, jobject, jobject hs_nmethod))
1136   JVMCIObject nmethod_mirror = JVMCIENV-&gt;wrap(hs_nmethod);
1137   JVMCIENV-&gt;invalidate_nmethod_mirror(nmethod_mirror, JVMCI_CHECK);
1138 C2V_END
1139 
1140 C2V_VMENTRY_NULL(jobject, readUncompressedOop, (JNIEnv* env, jobject, jlong addr))
1141   oop ret = RawAccess&lt;&gt;::oop_load((oop*)(address)addr);
1142   return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_object_constant(ret));
1143  C2V_END
1144 
1145 C2V_VMENTRY_NULL(jlongArray, collectCounters, (JNIEnv* env, jobject))
1146   // Returns a zero length array if counters aren&#39;t enabled
1147   JVMCIPrimitiveArray array = JVMCIENV-&gt;new_longArray(JVMCICounterSize, JVMCI_CHECK_NULL);
1148   if (JVMCICounterSize &gt; 0) {
1149     jlong* temp_array = NEW_RESOURCE_ARRAY(jlong, JVMCICounterSize);
1150     JavaThread::collect_counters(temp_array, JVMCICounterSize);
1151     JVMCIENV-&gt;copy_longs_from(temp_array, array, 0, JVMCICounterSize);
1152   }
1153   return (jlongArray) JVMCIENV-&gt;get_jobject(array);
1154 C2V_END
1155 
1156 C2V_VMENTRY_0(jint, getCountersSize, (JNIEnv* env, jobject))
1157   return (jint) JVMCICounterSize;
1158 C2V_END
1159 
1160 C2V_VMENTRY(void, setCountersSize, (JNIEnv* env, jobject, jint new_size))
1161   JavaThread::resize_all_jvmci_counters(new_size);
1162 C2V_END
1163 
1164 C2V_VMENTRY_0(jint, allocateCompileId, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci))
1165   HandleMark hm;
1166   if (jvmci_method == NULL) {
1167     JVMCI_THROW_0(NullPointerException);
1168   }
1169   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
1170   if (entry_bci &gt;= method-&gt;code_size() || entry_bci &lt; -1) {
1171     JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Unexpected bci %d&quot;, entry_bci));
1172   }
1173   return CompileBroker::assign_compile_id_unlocked(THREAD, method, entry_bci);
1174 C2V_END
1175 
1176 
1177 C2V_VMENTRY_0(jboolean, isMature, (JNIEnv* env, jobject, jlong metaspace_method_data))
1178   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1179   return mdo != NULL &amp;&amp; mdo-&gt;is_mature();
1180 C2V_END
1181 
1182 C2V_VMENTRY_0(jboolean, hasCompiledCodeForOSR, (JNIEnv* env, jobject, jobject jvmci_method, int entry_bci, int comp_level))
1183   Method* method = JVMCIENV-&gt;asMethod(jvmci_method);
1184   return method-&gt;lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;
1185 C2V_END
1186 
1187 C2V_VMENTRY_NULL(jobject, getSymbol, (JNIEnv* env, jobject, jlong symbol))
1188   JVMCIObject sym = JVMCIENV-&gt;create_string((Symbol*)(address)symbol, JVMCI_CHECK_NULL);
1189   return JVMCIENV-&gt;get_jobject(sym);
1190 C2V_END
1191 
1192 bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {
1193   objArrayOop methods_oop = (objArrayOop) JNIHandles::resolve(methods);
1194 
1195   for (int i = 0; i &lt; methods_oop-&gt;length(); i++) {
1196     oop resolved = methods_oop-&gt;obj_at(i);
1197     if ((resolved-&gt;klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) &amp;&amp; HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {
1198       return true;
1199     }
1200   }
1201   return false;
1202 }
1203 
1204 void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {
1205   CallInfo callinfo;
1206   Handle receiver = args-&gt;receiver();
1207   Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver-&gt;klass();
1208   LinkInfo link_info(spec_klass, name, signature);
1209   LinkResolver::resolve_interface_call(
1210           callinfo, receiver, recvrKlass, link_info, true, CHECK);
1211   methodHandle method(THREAD, callinfo.selected_method());
1212   assert(method.not_null(), &quot;should have thrown exception&quot;);
1213 
1214   // Invoke the method
1215   JavaCalls::call(result, method, args, CHECK);
1216 }
1217 
1218 C2V_VMENTRY_NULL(jobject, iterateFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jobject visitor_handle))
1219 
1220   if (!thread-&gt;has_last_Java_frame()) {
1221     return NULL;
1222   }
1223   Handle visitor(THREAD, JNIHandles::resolve_non_null(visitor_handle));
1224 
1225   requireInHotSpot(&quot;iterateFrames&quot;, JVMCI_CHECK_NULL);
1226 
1227   HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1228   Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1229 
1230   StackFrameStream fst(thread);
1231   jobjectArray methods = initial_methods;
1232 
1233   int frame_number = 0;
1234   vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1235 
1236   while (true) {
1237     // look for the given method
1238     bool realloc_called = false;
1239     while (true) {
1240       StackValueCollection* locals = NULL;
1241       if (vf-&gt;is_compiled_frame()) {
1242         // compiled method frame
1243         compiledVFrame* cvf = compiledVFrame::cast(vf);
1244         if (methods == NULL || matches(methods, cvf-&gt;method(), JVMCIENV)) {
1245           if (initialSkip &gt; 0) {
1246             initialSkip--;
1247           } else {
1248             ScopeDesc* scope = cvf-&gt;scope();
1249             // native wrappers do not have a scope
1250             if (scope != NULL &amp;&amp; scope-&gt;objects() != NULL) {
1251               GrowableArray&lt;ScopeValue*&gt;* objects;
1252               if (!realloc_called) {
1253                 objects = scope-&gt;objects();
1254               } else {
1255                 // some object might already have been re-allocated, only reallocate the non-allocated ones
1256                 objects = new GrowableArray&lt;ScopeValue*&gt;(scope-&gt;objects()-&gt;length());
1257                 for (int i = 0; i &lt; scope-&gt;objects()-&gt;length(); i++) {
1258                   ObjectValue* sv = (ObjectValue*) scope-&gt;objects()-&gt;at(i);
1259                   if (sv-&gt;value().is_null()) {
1260                     objects-&gt;append(sv);
1261                   }
1262                 }
1263               }
1264               bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);
1265               Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);
1266               realloc_called = true;
1267 
1268               GrowableArray&lt;ScopeValue*&gt;* local_values = scope-&gt;locals();
1269               assert(local_values != NULL, &quot;NULL locals&quot;);
1270               typeArrayOop array_oop = oopFactory::new_boolArray(local_values-&gt;length(), CHECK_NULL);
1271               typeArrayHandle array(THREAD, array_oop);
1272               for (int i = 0; i &lt; local_values-&gt;length(); i++) {
1273                 ScopeValue* value = local_values-&gt;at(i);
1274                 if (value-&gt;is_object()) {
1275                   array-&gt;bool_at_put(i, true);
1276                 }
1277               }
1278               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());
1279             } else {
1280               HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1281             }
1282 
1283             locals = cvf-&gt;locals();
1284             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf-&gt;bci());
1285             methodHandle mh(THREAD, cvf-&gt;method());
1286             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1287             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1288           }
1289         }
1290       } else if (vf-&gt;is_interpreted_frame()) {
1291         // interpreted method frame
1292         interpretedVFrame* ivf = interpretedVFrame::cast(vf);
1293         if (methods == NULL || matches(methods, ivf-&gt;method(), JVMCIENV)) {
1294           if (initialSkip &gt; 0) {
1295             initialSkip--;
1296           } else {
1297             locals = ivf-&gt;locals();
1298             HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf-&gt;bci());
1299             methodHandle mh(THREAD, ivf-&gt;method());
1300             JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1301             HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));
1302             HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);
1303           }
1304         }
1305       }
1306 
1307       // locals != NULL means that we found a matching frame and result is already partially initialized
1308       if (locals != NULL) {
1309         methods = match_methods;
1310         HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));
1311         HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()-&gt;sp());
1312         HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);
1313 
1314         // initialize the locals array
1315         objArrayOop array_oop = oopFactory::new_objectArray(locals-&gt;size(), CHECK_NULL);
1316         objArrayHandle array(THREAD, array_oop);
1317         for (int i = 0; i &lt; locals-&gt;size(); i++) {
1318           StackValue* var = locals-&gt;at(i);
1319           if (var-&gt;type() == T_OBJECT) {
1320             array-&gt;obj_at_put(i, locals-&gt;at(i)-&gt;get_obj()());
1321           }
1322         }
1323         HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());
1324         HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);
1325 
1326         JavaValue result(T_OBJECT);
1327         JavaCallArguments args(visitor);
1328         args.push_oop(frame_reference);
1329         call_interface(&amp;result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &amp;args, CHECK_NULL);
1330         if (result.get_jobject() != NULL) {
1331           return JNIHandles::make_local(thread, (oop) result.get_jobject());
1332         }
1333         assert(initialSkip == 0, &quot;There should be no match before initialSkip == 0&quot;);
1334         if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {
1335           // the frame has been deoptimized, we need to re-synchronize the frame and vframe
1336           intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());
1337           fst = StackFrameStream(thread);
1338           while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1339             fst.next();
1340           }
1341           if (fst.current()-&gt;sp() != stack_pointer) {
1342             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;stack frame not found after deopt&quot;)
1343           }
1344           vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1345           if (!vf-&gt;is_compiled_frame()) {
1346             THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;compiled stack frame expected&quot;)
1347           }
1348           for (int i = 0; i &lt; frame_number; i++) {
1349             if (vf-&gt;is_top()) {
1350               THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), &quot;vframe not found after deopt&quot;)
1351             }
1352             vf = vf-&gt;sender();
1353             assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1354           }
1355         }
1356         frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;allocate_instance_handle(CHECK_NULL);
1357         HotSpotJVMCI::HotSpotStackFrameReference::klass()-&gt;initialize(CHECK_NULL);
1358       }
1359 
1360       if (vf-&gt;is_top()) {
1361         break;
1362       }
1363       frame_number++;
1364       vf = vf-&gt;sender();
1365     } // end of vframe loop
1366 
1367     if (fst.is_done()) {
1368       break;
1369     }
1370     fst.next();
1371     vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);
1372     frame_number = 0;
1373   } // end of frame loop
1374 
1375   // the end was reached without finding a matching method
1376   return NULL;
1377 C2V_END
1378 
1379 C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1380   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1381   CallInfo callInfo;
1382   LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);
1383   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;invokedynamic_cp_cache_entry_at(index);
1384   cp_cache_entry-&gt;set_dynamic_call(cp, callInfo);
1385 C2V_END
1386 
1387 C2V_VMENTRY(void, resolveInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1388   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1389   Klass* holder = cp-&gt;klass_ref_at(index, CHECK);
1390   Symbol* name = cp-&gt;name_ref_at(index);
1391   if (MethodHandles::is_signature_polymorphic_name(holder, name)) {
1392     CallInfo callInfo;
1393     LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokehandle, CHECK);
1394     ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1395     cp_cache_entry-&gt;set_method_handle(cp, callInfo);
1396   }
1397 C2V_END
1398 
1399 C2V_VMENTRY_0(jint, isResolvedInvokeHandleInPool, (JNIEnv* env, jobject, jobject jvmci_constant_pool, jint index))
1400   constantPoolHandle cp(THREAD, JVMCIENV-&gt;asConstantPool(jvmci_constant_pool));
1401   ConstantPoolCacheEntry* cp_cache_entry = cp-&gt;cache()-&gt;entry_at(cp-&gt;decode_cpcache_index(index));
1402   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokehandle)) {
1403     // MethodHandle.invoke* --&gt; LambdaForm?
1404     ResourceMark rm;
1405 
1406     LinkInfo link_info(cp, index, CATCH);
1407 
1408     Klass* resolved_klass = link_info.resolved_klass();
1409 
1410     Symbol* name_sym = cp-&gt;name_ref_at(index);
1411 
1412     vmassert(MethodHandles::is_method_handle_invoke_name(resolved_klass, name_sym), &quot;!&quot;);
1413     vmassert(MethodHandles::is_signature_polymorphic_name(resolved_klass, name_sym), &quot;!&quot;);
1414 
1415     methodHandle adapter_method(THREAD, cp_cache_entry-&gt;f1_as_method());
1416 
1417     methodHandle resolved_method(adapter_method);
1418 
1419     // Can we treat it as a regular invokevirtual?
1420     if (resolved_method-&gt;method_holder() == resolved_klass &amp;&amp; resolved_method-&gt;name() == name_sym) {
1421       vmassert(!resolved_method-&gt;is_static(),&quot;!&quot;);
1422       vmassert(MethodHandles::is_signature_polymorphic_method(resolved_method()),&quot;!&quot;);
1423       vmassert(!MethodHandles::is_signature_polymorphic_static(resolved_method-&gt;intrinsic_id()), &quot;!&quot;);
1424       vmassert(cp_cache_entry-&gt;appendix_if_resolved(cp) == NULL, &quot;!&quot;);
1425 
1426       methodHandle m(THREAD, LinkResolver::linktime_resolve_virtual_method_or_null(link_info));
1427       vmassert(m == resolved_method, &quot;!!&quot;);
1428       return -1;
1429     }
1430 
1431     return Bytecodes::_invokevirtual;
1432   }
1433   if (cp_cache_entry-&gt;is_resolved(Bytecodes::_invokedynamic)) {
1434     return Bytecodes::_invokedynamic;
1435   }
1436   return -1;
1437 C2V_END
1438 
1439 
1440 C2V_VMENTRY_NULL(jobject, getSignaturePolymorphicHolders, (JNIEnv* env, jobject))
1441   JVMCIObjectArray holders = JVMCIENV-&gt;new_String_array(2, JVMCI_CHECK_NULL);
1442   JVMCIObject mh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/MethodHandle;&quot;, JVMCI_CHECK_NULL);
1443   JVMCIObject vh = JVMCIENV-&gt;create_string(&quot;Ljava/lang/invoke/VarHandle;&quot;, JVMCI_CHECK_NULL);
1444   JVMCIENV-&gt;put_object_at(holders, 0, mh);
1445   JVMCIENV-&gt;put_object_at(holders, 1, vh);
1446   return JVMCIENV-&gt;get_jobject(holders);
1447 C2V_END
1448 
1449 C2V_VMENTRY_0(jboolean, shouldDebugNonSafepoints, (JNIEnv* env, jobject))
1450   //see compute_recording_non_safepoints in debugInfroRec.cpp
1451   if (JvmtiExport::should_post_compiled_method_load() &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
1452     return true;
1453   }
1454   return DebugNonSafepoints;
1455 C2V_END
1456 
1457 // public native void materializeVirtualObjects(HotSpotStackFrameReference stackFrame, boolean invalidate);
1458 C2V_VMENTRY(void, materializeVirtualObjects, (JNIEnv* env, jobject, jobject _hs_frame, bool invalidate))
1459   JVMCIObject hs_frame = JVMCIENV-&gt;wrap(_hs_frame);
1460   if (hs_frame.is_null()) {
1461     JVMCI_THROW_MSG(NullPointerException, &quot;stack frame is null&quot;);
1462   }
1463 
1464   requireInHotSpot(&quot;materializeVirtualObjects&quot;, JVMCI_CHECK);
1465 
1466   JVMCIENV-&gt;HotSpotStackFrameReference_initialize(JVMCI_CHECK);
1467 
1468   // look for the given stack frame
1469   StackFrameStream fst(thread);
1470   intptr_t* stack_pointer = (intptr_t*) JVMCIENV-&gt;get_HotSpotStackFrameReference_stackPointer(hs_frame);
1471   while (fst.current()-&gt;sp() != stack_pointer &amp;&amp; !fst.is_done()) {
1472     fst.next();
1473   }
1474   if (fst.current()-&gt;sp() != stack_pointer) {
1475     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found&quot;);
1476   }
1477 
1478   if (invalidate) {
1479     if (!fst.current()-&gt;is_compiled_frame()) {
1480       JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1481     }
1482     assert(fst.current()-&gt;cb()-&gt;is_nmethod(), &quot;nmethod expected&quot;);
1483     ((nmethod*) fst.current()-&gt;cb())-&gt;make_not_entrant();
1484   }
1485   Deoptimization::deoptimize(thread, *fst.current(), fst.register_map(), Deoptimization::Reason_none);
1486   // look for the frame again as it has been updated by deopt (pc, deopt state...)
1487   StackFrameStream fstAfterDeopt(thread);
1488   while (fstAfterDeopt.current()-&gt;sp() != stack_pointer &amp;&amp; !fstAfterDeopt.is_done()) {
1489     fstAfterDeopt.next();
1490   }
1491   if (fstAfterDeopt.current()-&gt;sp() != stack_pointer) {
1492     JVMCI_THROW_MSG(IllegalStateException, &quot;stack frame not found after deopt&quot;);
1493   }
1494 
1495   vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);
1496   if (!vf-&gt;is_compiled_frame()) {
1497     JVMCI_THROW_MSG(IllegalStateException, &quot;compiled stack frame expected&quot;);
1498   }
1499 
1500   GrowableArray&lt;compiledVFrame*&gt;* virtualFrames = new GrowableArray&lt;compiledVFrame*&gt;(10);
1501   while (true) {
1502     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
1503     virtualFrames-&gt;push(compiledVFrame::cast(vf));
1504     if (vf-&gt;is_top()) {
1505       break;
1506     }
1507     vf = vf-&gt;sender();
1508   }
1509 
1510   int last_frame_number = JVMCIENV-&gt;get_HotSpotStackFrameReference_frameNumber(hs_frame);
1511   if (last_frame_number &gt;= virtualFrames-&gt;length()) {
1512     JVMCI_THROW_MSG(IllegalStateException, &quot;invalid frame number&quot;);
1513   }
1514 
1515   // Reallocate the non-escaping objects and restore their fields.
1516   assert (virtualFrames-&gt;at(last_frame_number)-&gt;scope() != NULL,&quot;invalid scope&quot;);
1517   GrowableArray&lt;ScopeValue*&gt;* objects = virtualFrames-&gt;at(last_frame_number)-&gt;scope()-&gt;objects();
1518 
1519   if (objects == NULL) {
1520     // no objects to materialize
1521     return;
1522   }
1523 
1524   bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);
1525   Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);
1526 
1527   for (int frame_index = 0; frame_index &lt; virtualFrames-&gt;length(); frame_index++) {
1528     compiledVFrame* cvf = virtualFrames-&gt;at(frame_index);
1529 
1530     GrowableArray&lt;ScopeValue*&gt;* scopeLocals = cvf-&gt;scope()-&gt;locals();
1531     StackValueCollection* locals = cvf-&gt;locals();
1532     if (locals != NULL) {
1533       for (int i2 = 0; i2 &lt; locals-&gt;size(); i2++) {
1534         StackValue* var = locals-&gt;at(i2);
1535         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeLocals-&gt;at(i2)-&gt;is_object()) {
1536           jvalue val;
1537           val.l = cast_from_oop&lt;jobject&gt;(locals-&gt;at(i2)-&gt;get_obj()());
1538           cvf-&gt;update_local(T_OBJECT, i2, val);
1539         }
1540       }
1541     }
1542 
1543     GrowableArray&lt;ScopeValue*&gt;* scopeExpressions = cvf-&gt;scope()-&gt;expressions();
1544     StackValueCollection* expressions = cvf-&gt;expressions();
1545     if (expressions != NULL) {
1546       for (int i2 = 0; i2 &lt; expressions-&gt;size(); i2++) {
1547         StackValue* var = expressions-&gt;at(i2);
1548         if (var-&gt;type() == T_OBJECT &amp;&amp; scopeExpressions-&gt;at(i2)-&gt;is_object()) {
1549           jvalue val;
1550           val.l = cast_from_oop&lt;jobject&gt;(expressions-&gt;at(i2)-&gt;get_obj()());
1551           cvf-&gt;update_stack(T_OBJECT, i2, val);
1552         }
1553       }
1554     }
1555 
1556     GrowableArray&lt;MonitorValue*&gt;* scopeMonitors = cvf-&gt;scope()-&gt;monitors();
1557     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1558     if (monitors != NULL) {
1559       for (int i2 = 0; i2 &lt; monitors-&gt;length(); i2++) {
1560         cvf-&gt;update_monitor(i2, monitors-&gt;at(i2));
1561       }
1562     }
1563   }
1564 
1565   // all locals are materialized by now
1566   JVMCIENV-&gt;set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);
1567   // update the locals array
1568   JVMCIObjectArray array = JVMCIENV-&gt;get_HotSpotStackFrameReference_locals(hs_frame);
1569   StackValueCollection* locals = virtualFrames-&gt;at(last_frame_number)-&gt;locals();
1570   for (int i = 0; i &lt; locals-&gt;size(); i++) {
1571     StackValue* var = locals-&gt;at(i);
1572     if (var-&gt;type() == T_OBJECT) {
1573       JVMCIENV-&gt;put_object_at(array, i, HotSpotJVMCI::wrap(locals-&gt;at(i)-&gt;get_obj()()));
1574     }
1575   }
1576   HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, hs_frame, JNI_TRUE);
1577 C2V_END
1578 
1579 // Creates a scope where the current thread is attached and detached
1580 // from HotSpot if it wasn&#39;t already attached when entering the scope.
1581 extern &quot;C&quot; void jio_printf(const char *fmt, ...);
1582 class AttachDetach : public StackObj {
1583  public:
1584   bool _attached;
1585   AttachDetach(JNIEnv* env, Thread* current_thread) {
1586     if (current_thread == NULL) {
1587       extern struct JavaVM_ main_vm;
1588       JNIEnv* hotspotEnv;
1589       jint res = main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
1590       _attached = res == JNI_OK;
1591       static volatile int report_attach_error = 0;
1592       if (res != JNI_OK &amp;&amp; report_attach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_attach_error, 0, 1) == 0) {
1593         // Only report an attach error once
1594         jio_printf(&quot;Warning: attaching current thread to VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1595       }
1596     } else {
1597       _attached = false;
1598     }
1599   }
1600   ~AttachDetach() {
1601     if (_attached &amp;&amp; get_current_thread() != NULL) {
1602       extern struct JavaVM_ main_vm;
1603       jint res = main_vm.DetachCurrentThread();
1604       static volatile int report_detach_error = 0;
1605       if (res != JNI_OK &amp;&amp; report_detach_error == 0 &amp;&amp; Atomic::cmpxchg(&amp;report_detach_error, 0, 1) == 0) {
1606         // Only report an attach error once
1607         jio_printf(&quot;Warning: detaching current thread from VM failed with %d (future attach errors are suppressed)\n&quot;, res);
1608       }
1609     }
1610   }
1611 };
1612 
1613 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
1614   AttachDetach ad(env, base_thread);
1615   bool use_tty = true;
1616   if (base_thread == NULL) {
1617     if (!ad._attached) {
1618       // Can only use tty if the current thread is attached
1619       return 0;
1620     }
1621     base_thread = get_current_thread();
1622   }
1623   JVMCITraceMark jtm(&quot;writeDebugOutput&quot;);
1624   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
1625   JavaThread* thread = (JavaThread*) base_thread;
1626   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
1627   if (bytes == NULL) {
1628     if (can_throw) {
1629       JVMCI_THROW_0(NullPointerException);
1630     }
1631     return -1;
1632   }
1633   JVMCIPrimitiveArray array = JVMCIENV-&gt;wrap(bytes);
1634 
1635   // Check if offset and length are non negative.
1636   if (offset &lt; 0 || length &lt; 0) {
1637     if (can_throw) {
1638       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1639     }
1640     return -2;
1641   }
1642   // Check if the range is valid.
1643   int array_length = JVMCIENV-&gt;get_length(array);
1644   if ((((unsigned int) length + (unsigned int) offset) &gt; (unsigned int) array_length)) {
1645     if (can_throw) {
1646       JVMCI_THROW_0(ArrayIndexOutOfBoundsException);
1647     }
1648     return -2;
1649   }
1650   jbyte buffer[O_BUFLEN];
1651   while (length &gt; 0) {
1652     int copy_len = MIN2(length, (jint)O_BUFLEN);
1653     JVMCIENV-&gt;copy_bytes_to(array, buffer, offset, copy_len);
1654     tty-&gt;write((char*) buffer, copy_len);
1655     length -= O_BUFLEN;
1656     offset += O_BUFLEN;
1657   }
1658   if (flush) {
1659     tty-&gt;flush();
1660   }
1661   return 0;
1662 C2V_END
1663 
1664 C2V_VMENTRY(void, flushDebugOutput, (JNIEnv* env, jobject))
1665   tty-&gt;flush();
1666 C2V_END
1667 
1668 C2V_VMENTRY_0(jint, methodDataProfileDataSize, (JNIEnv* env, jobject, jlong metaspace_method_data, jint position))
1669   MethodData* mdo = JVMCIENV-&gt;asMethodData(metaspace_method_data);
1670   ProfileData* profile_data = mdo-&gt;data_at(position);
1671   if (mdo-&gt;is_valid(profile_data)) {
1672     return profile_data-&gt;size_in_bytes();
1673   }
1674   DataLayout* data    = mdo-&gt;extra_data_base();
1675   DataLayout* end   = mdo-&gt;extra_data_limit();
1676   for (;; data = mdo-&gt;next_extra(data)) {
1677     assert(data &lt; end, &quot;moved past end of extra data&quot;);
1678     profile_data = data-&gt;data_in();
1679     if (mdo-&gt;dp_to_di(profile_data-&gt;dp()) == position) {
1680       return profile_data-&gt;size_in_bytes();
1681     }
1682   }
1683   JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(&quot;Invalid profile data position %d&quot;, position));
1684 C2V_END
1685 
1686 C2V_VMENTRY_0(jlong, getFingerprint, (JNIEnv* env, jobject, jlong metaspace_klass))
1687 #if INCLUDE_AOT
1688   Klass *k = (Klass*) (address) metaspace_klass;
1689   if (k-&gt;is_instance_klass()) {
1690     return InstanceKlass::cast(k)-&gt;get_stored_fingerprint();
1691   } else {
1692     return 0;
1693   }
1694 #else
1695   JVMCI_THROW_MSG_0(InternalError, &quot;unimplemented&quot;);
1696 #endif
1697 C2V_END
1698 
1699 C2V_VMENTRY_NULL(jobject, getHostClass, (JNIEnv* env, jobject, jobject jvmci_type))
1700   InstanceKlass* k = InstanceKlass::cast(JVMCIENV-&gt;asKlass(jvmci_type));
1701   InstanceKlass* host = k-&gt;unsafe_anonymous_host();
1702   JVMCIKlassHandle handle(THREAD, host);
1703   JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(handle, JVMCI_CHECK_NULL);
1704   return JVMCIENV-&gt;get_jobject(result);
1705 C2V_END
1706 
1707 C2V_VMENTRY_NULL(jobject, getInterfaces, (JNIEnv* env, jobject, jobject jvmci_type))
1708   if (jvmci_type == NULL) {
1709     JVMCI_THROW_0(NullPointerException);
1710   }
1711 
1712   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1713   if (klass == NULL) {
1714     JVMCI_THROW_0(NullPointerException);
1715   }
1716   if (!klass-&gt;is_instance_klass()) {
1717     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Class %s must be instance klass&quot;, klass-&gt;external_name()));
1718   }
1719   InstanceKlass* iklass = InstanceKlass::cast(klass);
1720 
1721   // Regular instance klass, fill in all local interfaces
1722   int size = iklass-&gt;local_interfaces()-&gt;length();
1723   JVMCIObjectArray interfaces = JVMCIENV-&gt;new_HotSpotResolvedObjectTypeImpl_array(size, JVMCI_CHECK_NULL);
1724   for (int index = 0; index &lt; size; index++) {
1725     JVMCIKlassHandle klass(THREAD);
1726     Klass* k = iklass-&gt;local_interfaces()-&gt;at(index);
1727     klass = k;
1728     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CHECK_NULL);
1729     JVMCIENV-&gt;put_object_at(interfaces, index, type);
1730   }
1731   return JVMCIENV-&gt;get_jobject(interfaces);
1732 C2V_END
1733 
1734 C2V_VMENTRY_NULL(jobject, getComponentType, (JNIEnv* env, jobject, jobject jvmci_type))
1735   if (jvmci_type == NULL) {
1736     JVMCI_THROW_0(NullPointerException);
1737   }
1738 
1739   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1740   oop mirror = klass-&gt;java_mirror();
1741   if (java_lang_Class::is_primitive(mirror) ||
1742       !java_lang_Class::as_Klass(mirror)-&gt;is_array_klass()) {
1743     return NULL;
1744   }
1745 
1746   oop component_mirror = java_lang_Class::component_mirror(mirror);
1747   if (component_mirror == NULL) {
1748     return NULL;
1749   }
1750   Klass* component_klass = java_lang_Class::as_Klass(component_mirror);
1751   if (component_klass != NULL) {
1752     JVMCIKlassHandle klass_handle(THREAD);
1753     klass_handle = component_klass;
1754     JVMCIObject result = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
1755     return JVMCIENV-&gt;get_jobject(result);
1756   }
1757   BasicType type = java_lang_Class::primitive_type(component_mirror);
1758   JVMCIObject result = JVMCIENV-&gt;get_jvmci_primitive_type(type);
1759   return JVMCIENV-&gt;get_jobject(result);
1760 C2V_END
1761 
1762 C2V_VMENTRY(void, ensureInitialized, (JNIEnv* env, jobject, jobject jvmci_type))
1763   if (jvmci_type == NULL) {
1764     JVMCI_THROW(NullPointerException);
1765   }
1766 
1767   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
1768   if (klass != NULL &amp;&amp; klass-&gt;should_be_initialized()) {
1769     InstanceKlass* k = InstanceKlass::cast(klass);
1770     k-&gt;initialize(CHECK);
1771   }
1772 C2V_END
1773 
1774 C2V_VMENTRY_0(jint, interpreterFrameSize, (JNIEnv* env, jobject, jobject bytecode_frame_handle))
1775   if (bytecode_frame_handle == NULL) {
1776     JVMCI_THROW_0(NullPointerException);
1777   }
1778 
1779   JVMCIObject top_bytecode_frame = JVMCIENV-&gt;wrap(bytecode_frame_handle);
1780   JVMCIObject bytecode_frame = top_bytecode_frame;
1781   int size = 0;
1782   int callee_parameters = 0;
1783   int callee_locals = 0;
1784   Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1785   int extra_args = method-&gt;max_stack() - JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1786 
1787   while (bytecode_frame.is_non_null()) {
1788     int locks = JVMCIENV-&gt;get_BytecodeFrame_numLocks(bytecode_frame);
1789     int temps = JVMCIENV-&gt;get_BytecodeFrame_numStack(bytecode_frame);
1790     bool is_top_frame = (JVMCIENV-&gt;equals(bytecode_frame, top_bytecode_frame));
1791     Method* method = JVMCIENV-&gt;asMethod(JVMCIENV-&gt;get_BytecodePosition_method(bytecode_frame));
1792 
1793     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
1794                                                                  temps + callee_parameters,
1795                                                                  extra_args,
1796                                                                  locks,
1797                                                                  callee_parameters,
1798                                                                  callee_locals,
1799                                                                  is_top_frame);
1800     size += frame_size;
1801 
1802     callee_parameters = method-&gt;size_of_parameters();
1803     callee_locals = method-&gt;max_locals();
1804     extra_args = 0;
1805     bytecode_frame = JVMCIENV-&gt;get_BytecodePosition_caller(bytecode_frame);
1806   }
1807   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
1808 C2V_END
1809 
1810 C2V_VMENTRY(void, compileToBytecode, (JNIEnv* env, jobject, jobject lambda_form_handle))
1811   Handle lambda_form = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(lambda_form_handle), JVMCI_CHECK);
1812   if (lambda_form-&gt;is_a(SystemDictionary::LambdaForm_klass())) {
1813     TempNewSymbol compileToBytecode = SymbolTable::new_symbol(&quot;compileToBytecode&quot;);
1814     JavaValue result(T_VOID);
1815     JavaCalls::call_special(&amp;result, lambda_form, SystemDictionary::LambdaForm_klass(), compileToBytecode, vmSymbols::void_method_signature(), CHECK);
1816   } else {
1817     JVMCI_THROW_MSG(IllegalArgumentException,
1818                     err_msg(&quot;Unexpected type: %s&quot;, lambda_form-&gt;klass()-&gt;external_name()))
1819   }
1820 C2V_END
1821 
1822 C2V_VMENTRY_0(jint, getIdentityHashCode, (JNIEnv* env, jobject, jobject object))
1823   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1824   return obj-&gt;identity_hash();
1825 C2V_END
1826 
1827 C2V_VMENTRY_0(jboolean, isInternedString, (JNIEnv* env, jobject, jobject object))
1828   Handle str = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
1829   if (!java_lang_String::is_instance(str())) {
1830     return false;
1831   }
1832   int len;
1833   jchar* name = java_lang_String::as_unicode_string(str(), len, CHECK_0);
1834   return (StringTable::lookup(name, len) != NULL);
1835 C2V_END
1836 
1837 
1838 C2V_VMENTRY_NULL(jobject, unboxPrimitive, (JNIEnv* env, jobject, jobject object))
1839   if (object == NULL) {
1840     JVMCI_THROW_0(NullPointerException);
1841   }
1842   Handle box = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
1843   BasicType type = java_lang_boxing_object::basic_type(box());
1844   jvalue result;
1845   if (java_lang_boxing_object::get_value(box(), &amp;result) == T_ILLEGAL) {
1846     return NULL;
1847   }
1848   JVMCIObject boxResult = JVMCIENV-&gt;create_box(type, &amp;result, JVMCI_CHECK_NULL);
1849   return JVMCIENV-&gt;get_jobject(boxResult);
1850 C2V_END
1851 
1852 C2V_VMENTRY_NULL(jobject, boxPrimitive, (JNIEnv* env, jobject, jobject object))
1853   if (object == NULL) {
1854     JVMCI_THROW_0(NullPointerException);
1855   }
1856   JVMCIObject box = JVMCIENV-&gt;wrap(object);
1857   BasicType type = JVMCIENV-&gt;get_box_type(box);
1858   if (type == T_ILLEGAL) {
1859     return NULL;
1860   }
1861   jvalue value = JVMCIENV-&gt;get_boxed_value(type, box);
1862   JavaValue box_result(T_OBJECT);
1863   JavaCallArguments jargs;
1864   Klass* box_klass = NULL;
1865   Symbol* box_signature = NULL;
1866 #define BOX_CASE(bt, v, argtype, name)           \
1867   case bt: \
1868     jargs.push_##argtype(value.v); \
1869     box_klass = SystemDictionary::name##_klass(); \
1870     box_signature = vmSymbols::name##_valueOf_signature(); \
1871     break
1872 
1873   switch (type) {
1874     BOX_CASE(T_BOOLEAN, z, int, Boolean);
1875     BOX_CASE(T_BYTE, b, int, Byte);
1876     BOX_CASE(T_CHAR, c, int, Character);
1877     BOX_CASE(T_SHORT, s, int, Short);
1878     BOX_CASE(T_INT, i, int, Integer);
1879     BOX_CASE(T_LONG, j, long, Long);
1880     BOX_CASE(T_FLOAT, f, float, Float);
1881     BOX_CASE(T_DOUBLE, d, double, Double);
1882     default:
1883       ShouldNotReachHere();
1884   }
1885 #undef BOX_CASE
1886 
1887   JavaCalls::call_static(&amp;box_result,
1888                          box_klass,
1889                          vmSymbols::valueOf_name(),
1890                          box_signature, &amp;jargs, CHECK_NULL);
1891   oop hotspot_box = (oop) box_result.get_jobject();
1892   JVMCIObject result = JVMCIENV-&gt;get_object_constant(hotspot_box, false);
1893   return JVMCIENV-&gt;get_jobject(result);
1894 C2V_END
1895 
1896 C2V_VMENTRY_NULL(jobjectArray, getDeclaredConstructors, (JNIEnv* env, jobject, jobject holder))
1897   if (holder == NULL) {
1898     JVMCI_THROW_0(NullPointerException);
1899   }
1900   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1901   if (!klass-&gt;is_instance_klass()) {
1902     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1903     return JVMCIENV-&gt;get_jobjectArray(methods);
1904   }
1905 
1906   InstanceKlass* iklass = InstanceKlass::cast(klass);
1907   // Ensure class is linked
1908   iklass-&gt;link_class(CHECK_NULL);
1909 
1910   GrowableArray&lt;Method*&gt; constructors_array;
1911   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1912     Method* m = iklass-&gt;methods()-&gt;at(i);
1913     if (m-&gt;is_initializer() &amp;&amp; !m-&gt;is_static()) {
1914       constructors_array.append(m);
1915     }
1916   }
1917   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(constructors_array.length(), JVMCI_CHECK_NULL);
1918   for (int i = 0; i &lt; constructors_array.length(); i++) {
1919     methodHandle ctor(THREAD, constructors_array.at(i));
1920     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(ctor, JVMCI_CHECK_NULL);
1921     JVMCIENV-&gt;put_object_at(methods, i, method);
1922   }
1923   return JVMCIENV-&gt;get_jobjectArray(methods);
1924 C2V_END
1925 
1926 C2V_VMENTRY_NULL(jobjectArray, getDeclaredMethods, (JNIEnv* env, jobject, jobject holder))
1927   if (holder == NULL) {
1928     JVMCI_THROW_0(NullPointerException);
1929   }
1930   Klass* klass = JVMCIENV-&gt;asKlass(holder);
1931   if (!klass-&gt;is_instance_klass()) {
1932     JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);
1933     return JVMCIENV-&gt;get_jobjectArray(methods);
1934   }
1935 
1936   InstanceKlass* iklass = InstanceKlass::cast(klass);
1937   // Ensure class is linked
1938   iklass-&gt;link_class(CHECK_NULL);
1939 
1940   GrowableArray&lt;Method*&gt; methods_array;
1941   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
1942     Method* m = iklass-&gt;methods()-&gt;at(i);
1943     if (!m-&gt;is_initializer() &amp;&amp; !m-&gt;is_overpass()) {
1944       methods_array.append(m);
1945     }
1946   }
1947   JVMCIObjectArray methods = JVMCIENV-&gt;new_ResolvedJavaMethod_array(methods_array.length(), JVMCI_CHECK_NULL);
1948   for (int i = 0; i &lt; methods_array.length(); i++) {
1949     methodHandle mh(THREAD, methods_array.at(i));
1950     JVMCIObject method = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CHECK_NULL);
1951     JVMCIENV-&gt;put_object_at(methods, i, method);
1952   }
1953   return JVMCIENV-&gt;get_jobjectArray(methods);
1954 C2V_END
1955 
1956 C2V_VMENTRY_NULL(jobject, readFieldValue, (JNIEnv* env, jobject, jobject object, jobject field, jboolean is_volatile))
1957   if (object == NULL || field == NULL) {
1958     JVMCI_THROW_0(NullPointerException);
1959   }
1960   JVMCIObject field_object = JVMCIENV-&gt;wrap(field);
1961   JVMCIObject java_type = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_type(field_object);
1962   int modifiers = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_modifiers(field_object);
1963   Klass* holder = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_holder(field_object));
1964   if (!holder-&gt;is_instance_klass()) {
1965     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Holder %s must be instance klass&quot;, holder-&gt;external_name()));
1966   }
1967   InstanceKlass* ik = InstanceKlass::cast(holder);
1968   BasicType constant_type;
1969   if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(java_type)) {
1970     constant_type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(java_type), JVMCI_CHECK_NULL);
1971   } else {
1972     constant_type = T_OBJECT;
1973   }
1974   int displacement = JVMCIENV-&gt;get_HotSpotResolvedJavaFieldImpl_offset(field_object);
1975   fieldDescriptor fd;
1976   if (!ik-&gt;find_local_field_from_offset(displacement, (modifiers &amp; JVM_ACC_STATIC) != 0, &amp;fd)) {
1977     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Can&#39;t find field with displacement %d&quot;, displacement));
1978   }
1979   JVMCIObject base = JVMCIENV-&gt;wrap(object);
1980   Handle obj;
1981   if (JVMCIENV-&gt;isa_HotSpotObjectConstantImpl(base)) {
1982     obj = JVMCIENV-&gt;asConstant(base, JVMCI_CHECK_NULL);
1983   } else if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base)) {
1984     Klass* klass = JVMCIENV-&gt;asKlass(base);
1985     obj = Handle(THREAD, klass-&gt;java_mirror());
1986   } else {
1987     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
1988                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base)));
1989   }
1990   jlong value = 0;
1991   JVMCIObject kind;
1992   switch (constant_type) {
1993     case T_OBJECT: {
1994       oop object = is_volatile ? obj-&gt;obj_field_acquire(displacement) : obj-&gt;obj_field(displacement);
1995       JVMCIObject result = JVMCIENV-&gt;get_object_constant(object);
1996       if (result.is_null()) {
1997         return JVMCIENV-&gt;get_jobject(JVMCIENV-&gt;get_JavaConstant_NULL_POINTER());
1998       }
1999       return JVMCIENV-&gt;get_jobject(result);
2000     }
2001     case T_FLOAT: {
2002       float f = is_volatile ? obj-&gt;float_field_acquire(displacement) : obj-&gt;float_field(displacement);
2003       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forFloat(f, JVMCI_CHECK_NULL);
2004       return JVMCIENV-&gt;get_jobject(result);
2005     }
2006     case T_DOUBLE: {
2007       double f = is_volatile ? obj-&gt;double_field_acquire(displacement) : obj-&gt;double_field(displacement);
2008       JVMCIObject result = JVMCIENV-&gt;call_JavaConstant_forDouble(f, JVMCI_CHECK_NULL);
2009       return JVMCIENV-&gt;get_jobject(result);
2010     }
2011     case T_BOOLEAN: value = is_volatile ? obj-&gt;bool_field_acquire(displacement) : obj-&gt;bool_field(displacement); break;
2012     case T_BYTE: value = is_volatile ? obj-&gt;byte_field_acquire(displacement) : obj-&gt;byte_field(displacement); break;
2013     case T_SHORT: value = is_volatile ? obj-&gt;short_field_acquire(displacement) : obj-&gt;short_field(displacement); break;
2014     case T_CHAR: value = is_volatile ? obj-&gt;char_field_acquire(displacement) : obj-&gt;char_field(displacement); break;
2015     case T_INT: value = is_volatile ? obj-&gt;int_field_acquire(displacement) : obj-&gt;int_field(displacement); break;
2016     case T_LONG: value = is_volatile ? obj-&gt;long_field_acquire(displacement) : obj-&gt;long_field(displacement); break;
2017     default:
2018       ShouldNotReachHere();
2019   }
2020   JVMCIObject result = JVMCIENV-&gt;call_PrimitiveConstant_forTypeChar(type2char(constant_type), value, JVMCI_CHECK_NULL);
2021   return JVMCIENV-&gt;get_jobject(result);
2022 C2V_END
2023 
2024 C2V_VMENTRY_0(jboolean, isInstance, (JNIEnv* env, jobject, jobject holder, jobject object))
2025   if (object == NULL || holder == NULL) {
2026     JVMCI_THROW_0(NullPointerException);
2027   }
2028   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_0);
2029   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2030   return obj-&gt;is_a(klass);
2031 C2V_END
2032 
2033 C2V_VMENTRY_0(jboolean, isAssignableFrom, (JNIEnv* env, jobject, jobject holder, jobject otherHolder))
2034   if (holder == NULL || otherHolder == NULL) {
2035     JVMCI_THROW_0(NullPointerException);
2036   }
2037   Klass* klass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder));
2038   Klass* otherKlass = JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(otherHolder));
2039   return otherKlass-&gt;is_subtype_of(klass);
2040 C2V_END
2041 
2042 C2V_VMENTRY_0(jboolean, isTrustedForIntrinsics, (JNIEnv* env, jobject, jobject holder))
2043   if (holder == NULL) {
2044     JVMCI_THROW_0(NullPointerException);
2045   }
2046   InstanceKlass* ik = InstanceKlass::cast(JVMCIENV-&gt;asKlass(JVMCIENV-&gt;wrap(holder)));
2047   if (ik-&gt;class_loader_data()-&gt;is_boot_class_loader_data() || ik-&gt;class_loader_data()-&gt;is_platform_class_loader_data()) {
2048     return true;
2049   }
2050   return false;
2051 C2V_END
2052 
2053 C2V_VMENTRY_NULL(jobject, asJavaType, (JNIEnv* env, jobject, jobject object))
2054   if (object == NULL) {
2055     JVMCI_THROW_0(NullPointerException);
2056   }
2057   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2058   if (java_lang_Class::is_instance(obj())) {
2059     if (java_lang_Class::is_primitive(obj())) {
2060       JVMCIObject type = JVMCIENV-&gt;get_jvmci_primitive_type(java_lang_Class::primitive_type(obj()));
2061       return JVMCIENV-&gt;get_jobject(type);
2062     }
2063     Klass* klass = java_lang_Class::as_Klass(obj());
2064     JVMCIKlassHandle klass_handle(THREAD);
2065     klass_handle = klass;
2066     JVMCIObject type = JVMCIENV-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_NULL);
2067     return JVMCIENV-&gt;get_jobject(type);
2068   }
2069   return NULL;
2070 C2V_END
2071 
2072 
2073 C2V_VMENTRY_NULL(jobject, asString, (JNIEnv* env, jobject, jobject object))
2074   if (object == NULL) {
2075     JVMCI_THROW_0(NullPointerException);
2076   }
2077   Handle obj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(object), JVMCI_CHECK_NULL);
2078   const char* str = java_lang_String::as_utf8_string(obj());
2079   JVMCIObject result = JVMCIENV-&gt;create_string(str, JVMCI_CHECK_NULL);
2080   return JVMCIENV-&gt;get_jobject(result);
2081 C2V_END
2082 
2083 
2084 C2V_VMENTRY_0(jboolean, equals, (JNIEnv* env, jobject, jobject x, jlong xHandle, jobject y, jlong yHandle))
2085   if (x == NULL || y == NULL) {
2086     JVMCI_THROW_0(NullPointerException);
2087   }
2088   return JVMCIENV-&gt;resolve_handle(xHandle) == JVMCIENV-&gt;resolve_handle(yHandle);
2089 C2V_END
2090 
2091 C2V_VMENTRY_NULL(jobject, getJavaMirror, (JNIEnv* env, jobject, jobject object))
2092   if (object == NULL) {
2093     JVMCI_THROW_0(NullPointerException);
2094   }
2095   JVMCIObject base_object = JVMCIENV-&gt;wrap(object);
2096   Handle mirror;
2097   if (JVMCIENV-&gt;isa_HotSpotResolvedObjectTypeImpl(base_object)) {
2098     mirror = Handle(THREAD, JVMCIENV-&gt;asKlass(base_object)-&gt;java_mirror());
2099   } else if (JVMCIENV-&gt;isa_HotSpotResolvedPrimitiveType(base_object)) {
2100     mirror = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_mirror(base_object), JVMCI_CHECK_NULL);
2101   } else {
2102     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2103                          err_msg(&quot;Unexpected type: %s&quot;, JVMCIENV-&gt;klass_name(base_object)));
2104  }
2105   JVMCIObject result = JVMCIENV-&gt;get_object_constant(mirror());
2106   return JVMCIENV-&gt;get_jobject(result);
2107 C2V_END
2108 
2109 
2110 C2V_VMENTRY_0(jint, getArrayLength, (JNIEnv* env, jobject, jobject x))
2111   if (x == NULL) {
2112     JVMCI_THROW_0(NullPointerException);
2113   }
2114   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2115   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2116     return arrayOop(xobj())-&gt;length();
2117   }
2118   return -1;
2119  C2V_END
2120 
2121 
2122 C2V_VMENTRY_NULL(jobject, readArrayElement, (JNIEnv* env, jobject, jobject x, int index))
2123   if (x == NULL) {
2124     JVMCI_THROW_0(NullPointerException);
2125   }
2126   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_NULL);
2127   if (xobj-&gt;klass()-&gt;is_array_klass()) {
2128     arrayOop array = arrayOop(xobj());
2129     BasicType element_type = ArrayKlass::cast(array-&gt;klass())-&gt;element_type();
2130     if (index &lt; 0 || index &gt;= array-&gt;length()) {
2131       return NULL;
2132     }
2133     JVMCIObject result;
2134 
2135     if (element_type == T_OBJECT) {
2136       result = JVMCIENV-&gt;get_object_constant(objArrayOop(xobj())-&gt;obj_at(index));
2137       if (result.is_null()) {
2138         result = JVMCIENV-&gt;get_JavaConstant_NULL_POINTER();
2139       }
2140     } else {
2141       jvalue value;
2142       switch (element_type) {
2143         case T_DOUBLE:        value.d = typeArrayOop(xobj())-&gt;double_at(index);        break;
2144         case T_FLOAT:         value.f = typeArrayOop(xobj())-&gt;float_at(index);         break;
2145         case T_LONG:          value.j = typeArrayOop(xobj())-&gt;long_at(index);          break;
2146         case T_INT:           value.i = typeArrayOop(xobj())-&gt;int_at(index);            break;
2147         case T_SHORT:         value.s = typeArrayOop(xobj())-&gt;short_at(index);          break;
2148         case T_CHAR:          value.c = typeArrayOop(xobj())-&gt;char_at(index);           break;
2149         case T_BYTE:          value.b = typeArrayOop(xobj())-&gt;byte_at(index);           break;
2150         case T_BOOLEAN:       value.z = typeArrayOop(xobj())-&gt;byte_at(index) &amp; 1;       break;
2151         default:              ShouldNotReachHere();
2152       }
2153       result = JVMCIENV-&gt;create_box(element_type, &amp;value, JVMCI_CHECK_NULL);
2154     }
2155     assert(!result.is_null(), &quot;must have a value&quot;);
2156     return JVMCIENV-&gt;get_jobject(result);
2157   }
2158   return NULL;;
2159 C2V_END
2160 
2161 
2162 C2V_VMENTRY_0(jint, arrayBaseOffset, (JNIEnv* env, jobject, jobject kind))
2163   if (kind == NULL) {
2164     JVMCI_THROW_0(NullPointerException);
2165   }
2166   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2167   return arrayOopDesc::header_size(type) * HeapWordSize;
2168 C2V_END
2169 
2170 C2V_VMENTRY_0(jint, arrayIndexScale, (JNIEnv* env, jobject, jobject kind))
2171   if (kind == NULL) {
2172     JVMCI_THROW_0(NullPointerException);
2173   }
2174   BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;wrap(kind), JVMCI_CHECK_0);
2175   return type2aelembytes(type);
2176 C2V_END
2177 
2178 C2V_VMENTRY_0(jbyte, getByte, (JNIEnv* env, jobject, jobject x, long displacement))
2179   if (x == NULL) {
2180     JVMCI_THROW_0(NullPointerException);
2181   }
2182   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2183   return xobj-&gt;byte_field(displacement);
2184 }
2185 
2186 C2V_VMENTRY_0(jshort, getShort, (JNIEnv* env, jobject, jobject x, long displacement))
2187   if (x == NULL) {
2188     JVMCI_THROW_0(NullPointerException);
2189   }
2190   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2191   return xobj-&gt;short_field(displacement);
2192 }
2193 
2194 C2V_VMENTRY_0(jint, getInt, (JNIEnv* env, jobject, jobject x, long displacement))
2195   if (x == NULL) {
2196     JVMCI_THROW_0(NullPointerException);
2197   }
2198   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2199   return xobj-&gt;int_field(displacement);
2200 }
2201 
2202 C2V_VMENTRY_0(jlong, getLong, (JNIEnv* env, jobject, jobject x, long displacement))
2203   if (x == NULL) {
2204     JVMCI_THROW_0(NullPointerException);
2205   }
2206   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2207   return xobj-&gt;long_field(displacement);
2208 }
2209 
2210 C2V_VMENTRY_NULL(jobject, getObject, (JNIEnv* env, jobject, jobject x, long displacement))
2211   if (x == NULL) {
2212     JVMCI_THROW_0(NullPointerException);
2213   }
2214   Handle xobj = JVMCIENV-&gt;asConstant(JVMCIENV-&gt;wrap(x), JVMCI_CHECK_0);
2215   oop res = xobj-&gt;obj_field(displacement);
2216   JVMCIObject result = JVMCIENV-&gt;get_object_constant(res);
2217   return JVMCIENV-&gt;get_jobject(result);
2218 }
2219 
2220 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
2221   jobject handle = (jobject)(address)h;
2222   if (handle != NULL) {
2223     JVMCI::destroy_global(handle);
2224   }
2225 }
2226 
2227 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
2228   if (!UseJVMCINativeLibrary) {
2229     JVMCI_THROW_MSG(UnsupportedOperationException, &quot;JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)&quot;);
2230   }
2231 }
2232 
2233 static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {
2234   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2235   if (javaVM == NULL) {
2236     JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg(&quot;Require JVMCI shared library to be initialized in %s&quot;, caller));
2237   }
2238   return javaVM;
2239 }
2240 
2241 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
2242   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2243   requireInHotSpot(&quot;registerNativeMethods&quot;, JVMCI_CHECK_NULL);
2244   void* shared_library = JVMCIEnv::get_shared_library_handle();
2245   if (shared_library == NULL) {
2246     // Ensure the JVMCI shared library runtime is initialized.
2247     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
2248     JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2249     HandleMark hm;
2250     JVMCIRuntime* runtime = JVMCI::compiler_runtime();
2251     JVMCIObject receiver = runtime-&gt;get_HotSpotJVMCIRuntime(peerEnv);
2252     if (peerEnv-&gt;has_pending_exception()) {
2253       peerEnv-&gt;describe_pending_exception(true);
2254     }
2255     shared_library = JVMCIEnv::get_shared_library_handle();
2256     if (shared_library == NULL) {
2257       JVMCI_THROW_MSG_0(InternalError, &quot;Error initializing JVMCI runtime&quot;);
2258     }
2259   }
2260 
2261   if (mirror == NULL) {
2262     JVMCI_THROW_0(NullPointerException);
2263   }
2264   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2265   if (klass == NULL || !klass-&gt;is_instance_klass()) {
2266     JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;clazz is for primitive type&quot;);
2267   }
2268 
2269   InstanceKlass* iklass = InstanceKlass::cast(klass);
2270   for (int i = 0; i &lt; iklass-&gt;methods()-&gt;length(); i++) {
2271     methodHandle method(THREAD, iklass-&gt;methods()-&gt;at(i));
2272     if (method-&gt;is_native()) {
2273 
2274       // Compute argument size
2275       int args_size = 1                             // JNIEnv
2276                     + (method-&gt;is_static() ? 1 : 0) // class for static methods
2277                     + method-&gt;size_of_parameters(); // actual parameters
2278 
2279       // 1) Try JNI short style
2280       stringStream st;
2281       char* pure_name = NativeLookup::pure_jni_name(method);
2282       os::print_jni_name_prefix_on(&amp;st, args_size);
2283       st.print_raw(pure_name);
2284       os::print_jni_name_suffix_on(&amp;st, args_size);
2285       char* jni_name = st.as_string();
2286 
2287       address entry = (address) os::dll_lookup(shared_library, jni_name);
2288       if (entry == NULL) {
2289         // 2) Try JNI long style
2290         st.reset();
2291         char* long_name = NativeLookup::long_jni_name(method);
2292         os::print_jni_name_prefix_on(&amp;st, args_size);
2293         st.print_raw(pure_name);
2294         st.print_raw(long_name);
2295         os::print_jni_name_suffix_on(&amp;st, args_size);
2296         char* jni_long_name = st.as_string();
2297         entry = (address) os::dll_lookup(shared_library, jni_long_name);
2298         if (entry == NULL) {
2299           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [neither %s nor %s exist in %s]&quot;,
2300               method-&gt;name_and_sig_as_C_string(),
2301               jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));
2302         }
2303       }
2304 
2305       if (method-&gt;has_native_function() &amp;&amp; entry != method-&gt;native_function()) {
2306         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(&quot;%s [cannot re-link from &quot; PTR_FORMAT &quot; to &quot; PTR_FORMAT &quot;]&quot;,
2307             method-&gt;name_and_sig_as_C_string(), p2i(method-&gt;native_function()), p2i(entry)));
2308       }
2309       method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting);
2310       log_debug(jni, resolve)(&quot;[Dynamic-linking native method %s.%s ... JNI]&quot;,
2311                               method-&gt;method_holder()-&gt;external_name(),
2312                               method-&gt;name()-&gt;as_C_string());
2313     }
2314   }
2315 
2316   JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
2317   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_longArray(4, JVMCI_CHECK_NULL);
2318   JVMCIENV-&gt;put_long_at(result, 0, (jlong) (address) javaVM);
2319   JVMCIENV-&gt;put_long_at(result, 1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);
2320   JVMCIENV-&gt;put_long_at(result, 2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);
2321   JVMCIENV-&gt;put_long_at(result, 3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);
2322   return (jlongArray) JVMCIENV-&gt;get_jobject(result);
2323 }
2324 
2325 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
2326   if (base_thread == NULL) {
2327     // Called from unattached JVMCI shared library thread
2328     return false;
2329   }
2330   JVMCITraceMark jtm(&quot;isCurrentThreadAttached&quot;);
2331   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2332   JavaThread* thread = (JavaThread*) base_thread;
2333   if (thread-&gt;jni_environment() == env) {
2334     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
2335     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2336     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;isCurrentThreadAttached&quot;, JVMCI_CHECK_0);
2337     JNIEnv* peerEnv;
2338     return javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK;
2339   }
2340   return true;
2341 C2V_END
2342 
2343 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
2344   if (base_thread == NULL) {
2345     // Called from unattached JVMCI shared library thread
2346     return 0L;
2347   }
2348   JVMCITraceMark jtm(&quot;getCurrentJavaThread&quot;);
2349   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);
2350   return (jlong) p2i(base_thread);
2351 C2V_END
2352 
2353 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
2354   if (base_thread == NULL) {
2355     // Called from unattached JVMCI shared library thread
2356     extern struct JavaVM_ main_vm;
2357     JNIEnv* hotspotEnv;
2358     jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&amp;hotspotEnv, NULL) :
2359                            main_vm.AttachCurrentThread((void**)&amp;hotspotEnv, NULL);
2360     if (res != JNI_OK) {
2361       JNI_THROW_(&quot;attachCurrentThread&quot;, InternalError, err_msg(&quot;Trying to attach thread returned %d&quot;, res), false);
2362     }
2363     return true;
2364   }
2365   JVMCITraceMark jtm(&quot;attachCurrentThread&quot;);
2366   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2367   JavaThread* thread = (JavaThread*) base_thread;
2368   if (thread-&gt;jni_environment() == env) {
2369     // Called from HotSpot
2370     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
2371     requireJVMCINativeLibrary(JVMCI_CHECK_0);
2372     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;attachCurrentThread&quot;, JVMCI_CHECK_0);
2373     JavaVMAttachArgs attach_args;
2374     attach_args.version = JNI_VERSION_1_2;
2375     attach_args.name = thread-&gt;name();
2376     attach_args.group = NULL;
2377     JNIEnv* peerEnv;
2378     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) == JNI_OK) {
2379       return false;
2380     }
2381     jint res = as_daemon ? javaVM-&gt;AttachCurrentThreadAsDaemon((void**)&amp;peerEnv, &amp;attach_args) :
2382                            javaVM-&gt;AttachCurrentThread((void**)&amp;peerEnv, &amp;attach_args);
2383     if (res == JNI_OK) {
2384       guarantee(peerEnv != NULL, &quot;must be&quot;);
2385       return true;
2386     }
2387     JVMCI_THROW_MSG_0(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, attach_args.name));
2388   }
2389   // Called from JVMCI shared library
2390   return false;
2391 C2V_END
2392 
2393 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
2394   if (base_thread == NULL) {
2395     // Called from unattached JVMCI shared library thread
2396     JNI_THROW(&quot;detachCurrentThread&quot;, IllegalStateException, err_msg(&quot;Cannot detach non-attached thread&quot;));
2397   }
2398   JVMCITraceMark jtm(&quot;detachCurrentThread&quot;);
2399   assert(base_thread-&gt;is_Java_thread(), &quot;just checking&quot;);\
2400   JavaThread* thread = (JavaThread*) base_thread;
2401   if (thread-&gt;jni_environment() == env) {
2402     // Called from HotSpot
2403     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
2404     requireJVMCINativeLibrary(JVMCI_CHECK);
2405     requireInHotSpot(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2406     JavaVM* javaVM = requireNativeLibraryJavaVM(&quot;detachCurrentThread&quot;, JVMCI_CHECK);
2407     JNIEnv* peerEnv;
2408     if (javaVM-&gt;GetEnv((void**)&amp;peerEnv, JNI_VERSION_1_2) != JNI_OK) {
2409       JVMCI_THROW_MSG(IllegalStateException, err_msg(&quot;Cannot detach non-attached thread: %s&quot;, thread-&gt;name()));
2410     }
2411     jint res = javaVM-&gt;DetachCurrentThread();
2412     if (res != JNI_OK) {
2413       JVMCI_THROW_MSG(InternalError, err_msg(&quot;Error %d while attaching %s&quot;, res, thread-&gt;name()));
2414     }
2415   } else {
2416     // Called from attached JVMCI shared library thread
2417     extern struct JavaVM_ main_vm;
2418     jint res = main_vm.DetachCurrentThread();
2419     if (res != JNI_OK) {
2420       JNI_THROW(&quot;detachCurrentThread&quot;, InternalError, err_msg(&quot;Cannot detach non-attached thread&quot;));
2421     }
2422   }
2423 C2V_END
2424 
2425 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
2426   requireJVMCINativeLibrary(JVMCI_CHECK_0);
2427   if (obj_handle == NULL) {
2428     return 0L;
2429   }
2430   JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV-&gt;is_hotspot(), __FILE__, __LINE__);
2431   JVMCIEnv* peerEnv = &amp;__peer_jvmci_env__;
2432   JVMCIEnv* thisEnv = JVMCIENV;
2433 
2434   JVMCIObject obj = thisEnv-&gt;wrap(obj_handle);
2435   JVMCIObject result;
2436   if (thisEnv-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
2437     methodHandle method(THREAD, thisEnv-&gt;asMethod(obj));
2438     result = peerEnv-&gt;get_jvmci_method(method, JVMCI_CHECK_0);
2439   } else if (thisEnv-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
2440     Klass* klass = thisEnv-&gt;asKlass(obj);
2441     JVMCIKlassHandle klass_handle(THREAD);
2442     klass_handle = klass;
2443     result = peerEnv-&gt;get_jvmci_type(klass_handle, JVMCI_CHECK_0);
2444   } else if (thisEnv-&gt;isa_HotSpotResolvedPrimitiveType(obj)) {
2445     BasicType type = JVMCIENV-&gt;kindToBasicType(JVMCIENV-&gt;get_HotSpotResolvedPrimitiveType_kind(obj), JVMCI_CHECK_0);
2446     result = peerEnv-&gt;get_jvmci_primitive_type(type);
2447   } else if (thisEnv-&gt;isa_IndirectHotSpotObjectConstantImpl(obj) ||
2448              thisEnv-&gt;isa_DirectHotSpotObjectConstantImpl(obj)) {
2449     Handle constant = thisEnv-&gt;asConstant(obj, JVMCI_CHECK_0);
2450     result = peerEnv-&gt;get_object_constant(constant());
2451   } else if (thisEnv-&gt;isa_HotSpotNmethod(obj)) {
2452     nmethodLocker locker;
2453     nmethod* nm = JVMCIENV-&gt;get_nmethod(obj, locker);
2454     if (nm != NULL) {
2455       JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2456       if (data != NULL) {
2457         if (peerEnv-&gt;is_hotspot()) {
2458           // Only the mirror in the HotSpot heap is accessible
2459           // through JVMCINMethodData
2460           oop nmethod_mirror = data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ true);
2461           if (nmethod_mirror != NULL) {
2462             result = HotSpotJVMCI::wrap(nmethod_mirror);
2463           }
2464         }
2465       }
2466     }
2467     if (result.is_null()) {
2468       JVMCIObject methodObject = thisEnv-&gt;get_HotSpotNmethod_method(obj);
2469       methodHandle mh(THREAD, thisEnv-&gt;asMethod(methodObject));
2470       jboolean isDefault = thisEnv-&gt;get_HotSpotNmethod_isDefault(obj);
2471       jlong compileIdSnapshot = thisEnv-&gt;get_HotSpotNmethod_compileIdSnapshot(obj);
2472       JVMCIObject name_string = thisEnv-&gt;get_InstalledCode_name(obj);
2473       const char* cstring = name_string.is_null() ? NULL : thisEnv-&gt;as_utf8_string(name_string);
2474       // Create a new HotSpotNmethod instance in the peer runtime
2475       result = peerEnv-&gt;new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);
2476       if (nm == NULL) {
2477         // nmethod must have been unloaded
2478       } else {
2479         // Link the new HotSpotNmethod to the nmethod
2480         peerEnv-&gt;initialize_installed_code(result, nm, JVMCI_CHECK_0);
2481         // Only HotSpotNmethod instances in the HotSpot heap are tracked directly by the runtime.
2482         if (peerEnv-&gt;is_hotspot()) {
2483           JVMCINMethodData* data = nm-&gt;jvmci_nmethod_data();
2484           if (data == NULL) {
2485             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot set HotSpotNmethod mirror for default nmethod&quot;);
2486           }
2487           if (data-&gt;get_nmethod_mirror(nm, /* phantom_ref */ false) != NULL) {
2488             JVMCI_THROW_MSG_0(IllegalArgumentException, &quot;Cannot overwrite existing HotSpotNmethod mirror for nmethod&quot;);
2489           }
2490           oop nmethod_mirror = HotSpotJVMCI::resolve(result);
2491           data-&gt;set_nmethod_mirror(nm, nmethod_mirror);
2492         }
2493       }
2494     }
2495   } else {
2496     JVMCI_THROW_MSG_0(IllegalArgumentException,
2497                 err_msg(&quot;Cannot translate object of type: %s&quot;, thisEnv-&gt;klass_name(obj)));
2498   }
2499   return (jlong) peerEnv-&gt;make_global(result).as_jobject();
2500 }
2501 
2502 C2V_VMENTRY_NULL(jobject, unhand, (JNIEnv* env, jobject, jlong obj_handle))
2503   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
2504   if (obj_handle == 0L) {
2505     return NULL;
2506   }
2507   jobject global_handle = (jobject) obj_handle;
2508   JVMCIObject global_handle_obj = JVMCIENV-&gt;wrap((jobject) obj_handle);
2509   jobject result = JVMCIENV-&gt;make_local(global_handle_obj).as_jobject();
2510 
2511   JVMCIENV-&gt;destroy_global(global_handle_obj);
2512   return result;
2513 }
2514 
2515 C2V_VMENTRY(void, updateHotSpotNmethod, (JNIEnv* env, jobject, jobject code_handle))
2516   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2517   // Execute this operation for the side effect of updating the InstalledCode state
2518   nmethodLocker locker;
2519   JVMCIENV-&gt;get_nmethod(code, locker);
2520 }
2521 
2522 C2V_VMENTRY_NULL(jbyteArray, getCode, (JNIEnv* env, jobject, jobject code_handle))
2523   JVMCIObject code = JVMCIENV-&gt;wrap(code_handle);
2524   nmethodLocker locker;
2525   CodeBlob* cb = JVMCIENV-&gt;get_code_blob(code, locker);
2526   if (cb == NULL) {
2527     return NULL;
2528   }
2529   int code_size = cb-&gt;code_size();
2530   JVMCIPrimitiveArray result = JVMCIENV-&gt;new_byteArray(code_size, JVMCI_CHECK_NULL);
2531   JVMCIENV-&gt;copy_bytes_from((jbyte*) cb-&gt;code_begin(), result, 0, code_size);
2532   return JVMCIENV-&gt;get_jbyteArray(result);
2533 }
2534 
2535 C2V_VMENTRY_NULL(jobject, asReflectionExecutable, (JNIEnv* env, jobject, jobject jvmci_method))
2536   requireInHotSpot(&quot;asReflectionExecutable&quot;, JVMCI_CHECK_NULL);
2537   methodHandle m(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2538   oop executable;
2539   if (m-&gt;is_initializer()) {
2540     if (m-&gt;is_static_initializer()) {
2541       JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2542           &quot;Cannot create java.lang.reflect.Method for class initializer&quot;);
2543     }
2544     executable = Reflection::new_constructor(m, CHECK_NULL);
2545   } else {
2546     executable = Reflection::new_method(m, false, CHECK_NULL);
2547   }
2548   return JNIHandles::make_local(THREAD, executable);
2549 }
2550 
2551 C2V_VMENTRY_NULL(jobject, asReflectionField, (JNIEnv* env, jobject, jobject jvmci_type, jint index))
2552   requireInHotSpot(&quot;asReflectionField&quot;, JVMCI_CHECK_NULL);
2553   Klass* klass = JVMCIENV-&gt;asKlass(jvmci_type);
2554   if (!klass-&gt;is_instance_klass()) {
2555     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2556         err_msg(&quot;Expected non-primitive type, got %s&quot;, klass-&gt;external_name()));
2557   }
2558   InstanceKlass* iklass = InstanceKlass::cast(klass);
2559   Array&lt;u2&gt;* fields = iklass-&gt;fields();
2560   if (index &lt; 0 ||index &gt; fields-&gt;length()) {
2561     JVMCI_THROW_MSG_NULL(IllegalArgumentException,
2562         err_msg(&quot;Field index %d out of bounds for %s&quot;, index, klass-&gt;external_name()));
2563   }
2564   fieldDescriptor fd(iklass, index);
2565   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2566   return JNIHandles::make_local(env, reflected);
2567 }
2568 
2569 C2V_VMENTRY_NULL(jobjectArray, getFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address, jobjectArray current))
2570   FailedSpeculation* head = *((FailedSpeculation**)(address) failed_speculations_address);
2571   int result_length = 0;
2572   for (FailedSpeculation* fs = head; fs != NULL; fs = fs-&gt;next()) {
2573     result_length++;
2574   }
2575   int current_length = 0;
2576   JVMCIObjectArray current_array = NULL;
2577   if (current != NULL) {
2578     current_array = JVMCIENV-&gt;wrap(current);
2579     current_length = JVMCIENV-&gt;get_length(current_array);
2580     if (current_length == result_length) {
2581       // No new failures
2582       return current;
2583     }
2584   }
2585   JVMCIObjectArray result = JVMCIENV-&gt;new_byte_array_array(result_length, JVMCI_CHECK_NULL);
2586   int result_index = 0;
2587   for (FailedSpeculation* fs = head; result_index &lt; result_length; fs = fs-&gt;next()) {
2588     assert(fs != NULL, &quot;npe&quot;);
2589     JVMCIPrimitiveArray entry;
2590     if (result_index &lt; current_length) {
2591       entry = (JVMCIPrimitiveArray) JVMCIENV-&gt;get_object_at(current_array, result_index);
2592     } else {
2593       entry = JVMCIENV-&gt;new_byteArray(fs-&gt;data_len(), JVMCI_CHECK_NULL);
2594       JVMCIENV-&gt;copy_bytes_from((jbyte*) fs-&gt;data(), entry, 0, fs-&gt;data_len());
2595     }
2596     JVMCIENV-&gt;put_object_at(result, result_index++, entry);
2597   }
2598   return JVMCIENV-&gt;get_jobjectArray(result);
2599 }
2600 
2601 C2V_VMENTRY_0(jlong, getFailedSpeculationsAddress, (JNIEnv* env, jobject, jobject jvmci_method))
2602   methodHandle method(THREAD, JVMCIENV-&gt;asMethod(jvmci_method));
2603   MethodData* method_data = method-&gt;method_data();
2604   if (method_data == NULL) {
2605     ClassLoaderData* loader_data = method-&gt;method_holder()-&gt;class_loader_data();
2606     method_data = MethodData::allocate(loader_data, method, CHECK_0);
2607     method-&gt;set_method_data(method_data);
2608   }
2609   return (jlong) method_data-&gt;get_failed_speculations_address();
2610 }
2611 
2612 C2V_VMENTRY(void, releaseFailedSpeculations, (JNIEnv* env, jobject, jlong failed_speculations_address))
2613   FailedSpeculation::free_failed_speculations((FailedSpeculation**)(address) failed_speculations_address);
2614 }
2615 
2616 C2V_VMENTRY_0(jboolean, addFailedSpeculation, (JNIEnv* env, jobject, jlong failed_speculations_address, jbyteArray speculation_obj))
2617   JVMCIPrimitiveArray speculation_handle = JVMCIENV-&gt;wrap(speculation_obj);
2618   int speculation_len = JVMCIENV-&gt;get_length(speculation_handle);
2619   char* speculation = NEW_RESOURCE_ARRAY(char, speculation_len);
2620   JVMCIENV-&gt;copy_bytes_to(speculation_handle, (jbyte*) speculation, 0, speculation_len);
2621   return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);
2622 }
2623 
2624 C2V_VMENTRY(void, callSystemExit, (JNIEnv* env, jobject, jint status))
2625   JavaValue result(T_VOID);
2626   JavaCallArguments jargs(1);
2627   jargs.push_int(status);
2628   JavaCalls::call_static(&amp;result,
2629                        SystemDictionary::System_klass(),
2630                        vmSymbols::exit_method_name(),
2631                        vmSymbols::int_void_signature(),
2632                        &amp;jargs,
2633                        CHECK);
2634 }
2635 
2636 #define CC (char*)  /*cast a literal from (const char*)*/
2637 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;(c2v_ ## f))
2638 
2639 #define STRING                  &quot;Ljava/lang/String;&quot;
2640 #define OBJECT                  &quot;Ljava/lang/Object;&quot;
2641 #define CLASS                   &quot;Ljava/lang/Class;&quot;
2642 #define OBJECTCONSTANT          &quot;Ljdk/vm/ci/hotspot/HotSpotObjectConstantImpl;&quot;
2643 #define HANDLECONSTANT          &quot;Ljdk/vm/ci/hotspot/IndirectHotSpotObjectConstantImpl;&quot;
2644 #define EXECUTABLE              &quot;Ljava/lang/reflect/Executable;&quot;
2645 #define STACK_TRACE_ELEMENT     &quot;Ljava/lang/StackTraceElement;&quot;
2646 #define INSTALLED_CODE          &quot;Ljdk/vm/ci/code/InstalledCode;&quot;
2647 #define TARGET_DESCRIPTION      &quot;Ljdk/vm/ci/code/TargetDescription;&quot;
2648 #define BYTECODE_FRAME          &quot;Ljdk/vm/ci/code/BytecodeFrame;&quot;
2649 #define JAVACONSTANT            &quot;Ljdk/vm/ci/meta/JavaConstant;&quot;
2650 #define INSPECTED_FRAME_VISITOR &quot;Ljdk/vm/ci/code/stack/InspectedFrameVisitor;&quot;
2651 #define RESOLVED_METHOD         &quot;Ljdk/vm/ci/meta/ResolvedJavaMethod;&quot;
2652 #define HS_RESOLVED_METHOD      &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethodImpl;&quot;
2653 #define HS_RESOLVED_KLASS       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl;&quot;
2654 #define HS_RESOLVED_TYPE        &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaType;&quot;
2655 #define HS_RESOLVED_FIELD       &quot;Ljdk/vm/ci/hotspot/HotSpotResolvedJavaField;&quot;
2656 #define HS_INSTALLED_CODE       &quot;Ljdk/vm/ci/hotspot/HotSpotInstalledCode;&quot;
2657 #define HS_NMETHOD              &quot;Ljdk/vm/ci/hotspot/HotSpotNmethod;&quot;
2658 #define HS_CONSTANT_POOL        &quot;Ljdk/vm/ci/hotspot/HotSpotConstantPool;&quot;
2659 #define HS_COMPILED_CODE        &quot;Ljdk/vm/ci/hotspot/HotSpotCompiledCode;&quot;
2660 #define HS_CONFIG               &quot;Ljdk/vm/ci/hotspot/HotSpotVMConfig;&quot;
2661 #define HS_METADATA             &quot;Ljdk/vm/ci/hotspot/HotSpotMetaData;&quot;
2662 #define HS_STACK_FRAME_REF      &quot;Ljdk/vm/ci/hotspot/HotSpotStackFrameReference;&quot;
2663 #define HS_SPECULATION_LOG      &quot;Ljdk/vm/ci/hotspot/HotSpotSpeculationLog;&quot;
2664 #define METASPACE_OBJECT        &quot;Ljdk/vm/ci/hotspot/MetaspaceObject;&quot;
2665 #define REFLECTION_EXECUTABLE   &quot;Ljava/lang/reflect/Executable;&quot;
2666 #define REFLECTION_FIELD        &quot;Ljava/lang/reflect/Field;&quot;
2667 #define METASPACE_METHOD_DATA   &quot;J&quot;
2668 
2669 JNINativeMethod CompilerToVM::methods[] = {
2670   {CC &quot;getBytecode&quot;,                                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[B&quot;,                                                      FN_PTR(getBytecode)},
2671   {CC &quot;getExceptionTableStart&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getExceptionTableStart)},
2672   {CC &quot;getExceptionTableLength&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getExceptionTableLength)},
2673   {CC &quot;findUniqueConcreteMethod&quot;,                     CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)&quot; HS_RESOLVED_METHOD,                   FN_PTR(findUniqueConcreteMethod)},
2674   {CC &quot;getImplementor&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getImplementor)},
2675   {CC &quot;getStackTraceElement&quot;,                         CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)&quot; STACK_TRACE_ELEMENT,                                   FN_PTR(getStackTraceElement)},
2676   {CC &quot;methodIsIgnoredBySecurityStackWalk&quot;,           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(methodIsIgnoredBySecurityStackWalk)},
2677   {CC &quot;setNotInlinableOrCompilable&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(setNotInlinableOrCompilable)},
2678   {CC &quot;isCompilable&quot;,                                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(isCompilable)},
2679   {CC &quot;hasNeverInlineDirective&quot;,                      CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(hasNeverInlineDirective)},
2680   {CC &quot;shouldInlineMethod&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)Z&quot;,                                                       FN_PTR(shouldInlineMethod)},
2681   {CC &quot;lookupType&quot;,                                   CC &quot;(&quot; STRING HS_RESOLVED_KLASS &quot;Z)&quot; HS_RESOLVED_TYPE,                                FN_PTR(lookupType)},
2682   {CC &quot;getArrayType&quot;,                                 CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getArrayType)},
2683   {CC &quot;lookupClass&quot;,                                  CC &quot;(&quot; CLASS &quot;)&quot; HS_RESOLVED_TYPE,                                                    FN_PTR(lookupClass)},
2684   {CC &quot;lookupNameInPool&quot;,                             CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupNameInPool)},
2685   {CC &quot;lookupNameAndTypeRefIndexInPool&quot;,              CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupNameAndTypeRefIndexInPool)},
2686   {CC &quot;lookupSignatureInPool&quot;,                        CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; STRING,                                                  FN_PTR(lookupSignatureInPool)},
2687   {CC &quot;lookupKlassRefIndexInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(lookupKlassRefIndexInPool)},
2688   {CC &quot;lookupKlassInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)Ljava/lang/Object;&quot;,                                       FN_PTR(lookupKlassInPool)},
2689   {CC &quot;lookupAppendixInPool&quot;,                         CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(lookupAppendixInPool)},
2690   {CC &quot;lookupMethodInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;IB)&quot; HS_RESOLVED_METHOD,                                     FN_PTR(lookupMethodInPool)},
2691   {CC &quot;constantPoolRemapInstructionOperandFromCache&quot;, CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(constantPoolRemapInstructionOperandFromCache)},
2692   {CC &quot;resolvePossiblyCachedConstantInPool&quot;,          CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; OBJECTCONSTANT,                                          FN_PTR(resolvePossiblyCachedConstantInPool)},
2693   {CC &quot;resolveTypeInPool&quot;,                            CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(resolveTypeInPool)},
2694   {CC &quot;resolveFieldInPool&quot;,                           CC &quot;(&quot; HS_CONSTANT_POOL &quot;I&quot; HS_RESOLVED_METHOD &quot;B[I)&quot; HS_RESOLVED_KLASS,              FN_PTR(resolveFieldInPool)},
2695   {CC &quot;resolveInvokeDynamicInPool&quot;,                   CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeDynamicInPool)},
2696   {CC &quot;resolveInvokeHandleInPool&quot;,                    CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)V&quot;,                                                        FN_PTR(resolveInvokeHandleInPool)},
2697   {CC &quot;isResolvedInvokeHandleInPool&quot;,                 CC &quot;(&quot; HS_CONSTANT_POOL &quot;I)I&quot;,                                                        FN_PTR(isResolvedInvokeHandleInPool)},
2698   {CC &quot;resolveMethod&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD, FN_PTR(resolveMethod)},
2699   {CC &quot;getSignaturePolymorphicHolders&quot;,               CC &quot;()[&quot; STRING,                                                                      FN_PTR(getSignaturePolymorphicHolders)},
2700   {CC &quot;getVtableIndexForInterfaceMethod&quot;,             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_METHOD &quot;)I&quot;,                                     FN_PTR(getVtableIndexForInterfaceMethod)},
2701   {CC &quot;getClassInitializer&quot;,                          CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_METHOD,                                      FN_PTR(getClassInitializer)},
2702   {CC &quot;hasFinalizableSubclass&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(hasFinalizableSubclass)},
2703   {CC &quot;getMaxCallTargetOffset&quot;,                       CC &quot;(J)J&quot;,                                                                            FN_PTR(getMaxCallTargetOffset)},
2704   {CC &quot;asResolvedJavaMethod&quot;,                         CC &quot;(&quot; EXECUTABLE &quot;)&quot; HS_RESOLVED_METHOD,                                             FN_PTR(asResolvedJavaMethod)},
2705   {CC &quot;getResolvedJavaMethod&quot;,                        CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; HS_RESOLVED_METHOD,                                        FN_PTR(getResolvedJavaMethod)},
2706   {CC &quot;getConstantPool&quot;,                              CC &quot;(&quot; METASPACE_OBJECT &quot;)&quot; HS_CONSTANT_POOL,                                         FN_PTR(getConstantPool)},
2707   {CC &quot;getResolvedJavaType0&quot;,                         CC &quot;(Ljava/lang/Object;JZ)&quot; HS_RESOLVED_KLASS,                                        FN_PTR(getResolvedJavaType0)},
2708   {CC &quot;readConfiguration&quot;,                            CC &quot;()[&quot; OBJECT,                                                                      FN_PTR(readConfiguration)},
2709   {CC &quot;installCode&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE INSTALLED_CODE &quot;J[B)I&quot;,                    FN_PTR(installCode)},
2710   {CC &quot;getMetadata&quot;,                                  CC &quot;(&quot; TARGET_DESCRIPTION HS_COMPILED_CODE HS_METADATA &quot;)I&quot;,                          FN_PTR(getMetadata)},
2711   {CC &quot;resetCompilationStatistics&quot;,                   CC &quot;()V&quot;,                                                                             FN_PTR(resetCompilationStatistics)},
2712   {CC &quot;disassembleCodeBlob&quot;,                          CC &quot;(&quot; INSTALLED_CODE &quot;)&quot; STRING,                                                     FN_PTR(disassembleCodeBlob)},
2713   {CC &quot;executeHotSpotNmethod&quot;,                        CC &quot;([&quot; OBJECT HS_NMETHOD &quot;)&quot; OBJECT,                                                 FN_PTR(executeHotSpotNmethod)},
2714   {CC &quot;getLineNumberTable&quot;,                           CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)[J&quot;,                                                      FN_PTR(getLineNumberTable)},
2715   {CC &quot;getLocalVariableTableStart&quot;,                   CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getLocalVariableTableStart)},
2716   {CC &quot;getLocalVariableTableLength&quot;,                  CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)I&quot;,                                                       FN_PTR(getLocalVariableTableLength)},
2717   {CC &quot;reprofile&quot;,                                    CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)V&quot;,                                                       FN_PTR(reprofile)},
2718   {CC &quot;invalidateHotSpotNmethod&quot;,                     CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(invalidateHotSpotNmethod)},
2719   {CC &quot;readUncompressedOop&quot;,                          CC &quot;(J)&quot; OBJECTCONSTANT,                                                              FN_PTR(readUncompressedOop)},
2720   {CC &quot;collectCounters&quot;,                              CC &quot;()[J&quot;,                                                                            FN_PTR(collectCounters)},
2721   {CC &quot;getCountersSize&quot;,                              CC &quot;()I&quot;,                                                                             FN_PTR(getCountersSize)},
2722   {CC &quot;setCountersSize&quot;,                              CC &quot;(I)V&quot;,                                                                            FN_PTR(setCountersSize)},
2723   {CC &quot;allocateCompileId&quot;,                            CC &quot;(&quot; HS_RESOLVED_METHOD &quot;I)I&quot;,                                                      FN_PTR(allocateCompileId)},
2724   {CC &quot;isMature&quot;,                                     CC &quot;(&quot; METASPACE_METHOD_DATA &quot;)Z&quot;,                                                    FN_PTR(isMature)},
2725   {CC &quot;hasCompiledCodeForOSR&quot;,                        CC &quot;(&quot; HS_RESOLVED_METHOD &quot;II)Z&quot;,                                                     FN_PTR(hasCompiledCodeForOSR)},
2726   {CC &quot;getSymbol&quot;,                                    CC &quot;(J)&quot; STRING,                                                                      FN_PTR(getSymbol)},
2727   {CC &quot;iterateFrames&quot;,                                CC &quot;([&quot; RESOLVED_METHOD &quot;[&quot; RESOLVED_METHOD &quot;I&quot; INSPECTED_FRAME_VISITOR &quot;)&quot; OBJECT,   FN_PTR(iterateFrames)},
2728   {CC &quot;materializeVirtualObjects&quot;,                    CC &quot;(&quot; HS_STACK_FRAME_REF &quot;Z)V&quot;,                                                      FN_PTR(materializeVirtualObjects)},
2729   {CC &quot;shouldDebugNonSafepoints&quot;,                     CC &quot;()Z&quot;,                                                                             FN_PTR(shouldDebugNonSafepoints)},
2730   {CC &quot;writeDebugOutput&quot;,                             CC &quot;([BIIZZ)I&quot;,                                                                       FN_PTR(writeDebugOutput)},
2731   {CC &quot;flushDebugOutput&quot;,                             CC &quot;()V&quot;,                                                                             FN_PTR(flushDebugOutput)},
2732   {CC &quot;methodDataProfileDataSize&quot;,                    CC &quot;(JI)I&quot;,                                                                           FN_PTR(methodDataProfileDataSize)},
2733   {CC &quot;getFingerprint&quot;,                               CC &quot;(J)J&quot;,                                                                            FN_PTR(getFingerprint)},
2734   {CC &quot;getHostClass&quot;,                                 CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_KLASS,                                       FN_PTR(getHostClass)},
2735   {CC &quot;interpreterFrameSize&quot;,                         CC &quot;(&quot; BYTECODE_FRAME &quot;)I&quot;,                                                           FN_PTR(interpreterFrameSize)},
2736   {CC &quot;compileToBytecode&quot;,                            CC &quot;(&quot; OBJECTCONSTANT &quot;)V&quot;,                                                           FN_PTR(compileToBytecode)},
2737   {CC &quot;getFlagValue&quot;,                                 CC &quot;(&quot; STRING &quot;)&quot; OBJECT,                                                             FN_PTR(getFlagValue)},
2738   {CC &quot;getObjectAtAddress&quot;,                           CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(getObjectAtAddress)},
2739   {CC &quot;getInterfaces&quot;,                                CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; HS_RESOLVED_KLASS,                                      FN_PTR(getInterfaces)},
2740   {CC &quot;getComponentType&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)&quot; HS_RESOLVED_TYPE,                                        FN_PTR(getComponentType)},
2741   {CC &quot;ensureInitialized&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)V&quot;,                                                        FN_PTR(ensureInitialized)},
2742   {CC &quot;getIdentityHashCode&quot;,                          CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getIdentityHashCode)},
2743   {CC &quot;isInternedString&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;)Z&quot;,                                                           FN_PTR(isInternedString)},
2744   {CC &quot;unboxPrimitive&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; OBJECT,                                                     FN_PTR(unboxPrimitive)},
2745   {CC &quot;boxPrimitive&quot;,                                 CC &quot;(&quot; OBJECT &quot;)&quot; OBJECTCONSTANT,                                                     FN_PTR(boxPrimitive)},
2746   {CC &quot;getDeclaredConstructors&quot;,                      CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredConstructors)},
2747   {CC &quot;getDeclaredMethods&quot;,                           CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)[&quot; RESOLVED_METHOD,                                        FN_PTR(getDeclaredMethods)},
2748   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                         FN_PTR(readFieldValue)},
2749   {CC &quot;readFieldValue&quot;,                               CC &quot;(&quot; OBJECTCONSTANT HS_RESOLVED_FIELD &quot;Z)&quot; JAVACONSTANT,                            FN_PTR(readFieldValue)},
2750   {CC &quot;isInstance&quot;,                                   CC &quot;(&quot; HS_RESOLVED_KLASS OBJECTCONSTANT &quot;)Z&quot;,                                         FN_PTR(isInstance)},
2751   {CC &quot;isAssignableFrom&quot;,                             CC &quot;(&quot; HS_RESOLVED_KLASS HS_RESOLVED_KLASS &quot;)Z&quot;,                                      FN_PTR(isAssignableFrom)},
2752   {CC &quot;isTrustedForIntrinsics&quot;,                       CC &quot;(&quot; HS_RESOLVED_KLASS &quot;)Z&quot;,                                                        FN_PTR(isTrustedForIntrinsics)},
2753   {CC &quot;asJavaType&quot;,                                   CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; HS_RESOLVED_TYPE,                                           FN_PTR(asJavaType)},
2754   {CC &quot;asString&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;)&quot; STRING,                                                     FN_PTR(asString)},
2755   {CC &quot;equals&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J&quot; OBJECTCONSTANT &quot;J)Z&quot;,                                       FN_PTR(equals)},
2756   {CC &quot;getJavaMirror&quot;,                                CC &quot;(&quot; HS_RESOLVED_TYPE &quot;)&quot; OBJECTCONSTANT,                                           FN_PTR(getJavaMirror)},
2757   {CC &quot;getArrayLength&quot;,                               CC &quot;(&quot; OBJECTCONSTANT &quot;)I&quot;,                                                           FN_PTR(getArrayLength)},
2758   {CC &quot;readArrayElement&quot;,                             CC &quot;(&quot; OBJECTCONSTANT &quot;I)Ljava/lang/Object;&quot;,                                         FN_PTR(readArrayElement)},
2759   {CC &quot;arrayBaseOffset&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayBaseOffset)},
2760   {CC &quot;arrayIndexScale&quot;,                              CC &quot;(Ljdk/vm/ci/meta/JavaKind;)I&quot;,                                                    FN_PTR(arrayIndexScale)},
2761   {CC &quot;getByte&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)B&quot;,                                                          FN_PTR(getByte)},
2762   {CC &quot;getShort&quot;,                                     CC &quot;(&quot; OBJECTCONSTANT &quot;J)S&quot;,                                                          FN_PTR(getShort)},
2763   {CC &quot;getInt&quot;,                                       CC &quot;(&quot; OBJECTCONSTANT &quot;J)I&quot;,                                                          FN_PTR(getInt)},
2764   {CC &quot;getLong&quot;,                                      CC &quot;(&quot; OBJECTCONSTANT &quot;J)J&quot;,                                                          FN_PTR(getLong)},
2765   {CC &quot;getObject&quot;,                                    CC &quot;(&quot; OBJECTCONSTANT &quot;J)&quot; OBJECTCONSTANT,                                            FN_PTR(getObject)},
2766   {CC &quot;deleteGlobalHandle&quot;,                           CC &quot;(J)V&quot;,                                                                            FN_PTR(deleteGlobalHandle)},
2767   {CC &quot;registerNativeMethods&quot;,                        CC &quot;(&quot; CLASS &quot;)[J&quot;,                                                                   FN_PTR(registerNativeMethods)},
2768   {CC &quot;isCurrentThreadAttached&quot;,                      CC &quot;()Z&quot;,                                                                             FN_PTR(isCurrentThreadAttached)},
2769   {CC &quot;getCurrentJavaThread&quot;,                         CC &quot;()J&quot;,                                                                             FN_PTR(getCurrentJavaThread)},
2770   {CC &quot;attachCurrentThread&quot;,                          CC &quot;(Z)Z&quot;,                                                                            FN_PTR(attachCurrentThread)},
2771   {CC &quot;detachCurrentThread&quot;,                          CC &quot;()V&quot;,                                                                             FN_PTR(detachCurrentThread)},
2772   {CC &quot;translate&quot;,                                    CC &quot;(&quot; OBJECT &quot;)J&quot;,                                                                   FN_PTR(translate)},
2773   {CC &quot;unhand&quot;,                                       CC &quot;(J)&quot; OBJECT,                                                                      FN_PTR(unhand)},
2774   {CC &quot;updateHotSpotNmethod&quot;,                         CC &quot;(&quot; HS_NMETHOD &quot;)V&quot;,                                                               FN_PTR(updateHotSpotNmethod)},
2775   {CC &quot;getCode&quot;,                                      CC &quot;(&quot; HS_INSTALLED_CODE &quot;)[B&quot;,                                                       FN_PTR(getCode)},
2776   {CC &quot;asReflectionExecutable&quot;,                       CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)&quot; REFLECTION_EXECUTABLE,                                  FN_PTR(asReflectionExecutable)},
2777   {CC &quot;asReflectionField&quot;,                            CC &quot;(&quot; HS_RESOLVED_KLASS &quot;I)&quot; REFLECTION_FIELD,                                       FN_PTR(asReflectionField)},
2778   {CC &quot;getFailedSpeculations&quot;,                        CC &quot;(J[[B)[[B&quot;,                                                                       FN_PTR(getFailedSpeculations)},
2779   {CC &quot;getFailedSpeculationsAddress&quot;,                 CC &quot;(&quot; HS_RESOLVED_METHOD &quot;)J&quot;,                                                       FN_PTR(getFailedSpeculationsAddress)},
2780   {CC &quot;releaseFailedSpeculations&quot;,                    CC &quot;(J)V&quot;,                                                                            FN_PTR(releaseFailedSpeculations)},
2781   {CC &quot;addFailedSpeculation&quot;,                         CC &quot;(J[B)Z&quot;,                                                                          FN_PTR(addFailedSpeculation)},
2782   {CC &quot;callSystemExit&quot;,                               CC &quot;(I)V&quot;,                                                                            FN_PTR(callSystemExit)},
2783 };
2784 
2785 int CompilerToVM::methods_count() {
2786   return sizeof(methods) / sizeof(JNINativeMethod);
2787 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>