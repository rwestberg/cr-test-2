<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.inline.hpp&quot;
  34 #include &quot;classfile/moduleEntry.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/verificationType.hpp&quot;
  39 #include &quot;classfile/verifier.hpp&quot;
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;logging/logStream.hpp&quot;
  43 #include &quot;memory/allocation.hpp&quot;
  44 #include &quot;memory/metadataFactory.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/resourceArea.hpp&quot;
  47 #include &quot;memory/universe.hpp&quot;
  48 #include &quot;oops/annotations.hpp&quot;
  49 #include &quot;oops/constantPool.inline.hpp&quot;
  50 #include &quot;oops/fieldStreams.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  53 #include &quot;oops/klass.inline.hpp&quot;
  54 #include &quot;oops/klassVtable.hpp&quot;
  55 #include &quot;oops/metadata.hpp&quot;
  56 #include &quot;oops/method.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/recordComponent.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.hpp&quot;
  66 #include &quot;runtime/perfData.hpp&quot;
  67 #include &quot;runtime/reflection.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/signature.hpp&quot;
  70 #include &quot;runtime/timer.hpp&quot;
  71 #include &quot;services/classLoadingService.hpp&quot;
  72 #include &quot;services/threadService.hpp&quot;
  73 #include &quot;utilities/align.hpp&quot;
  74 #include &quot;utilities/bitMap.inline.hpp&quot;
  75 #include &quot;utilities/copy.hpp&quot;
  76 #include &quot;utilities/exceptions.hpp&quot;
  77 #include &quot;utilities/globalDefinitions.hpp&quot;
  78 #include &quot;utilities/growableArray.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 #include &quot;utilities/ostream.hpp&quot;
  81 #include &quot;utilities/resourceHash.hpp&quot;
  82 #include &quot;utilities/utf8.hpp&quot;
  83 
  84 #if INCLUDE_CDS
  85 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  86 #endif
  87 #if INCLUDE_JFR
  88 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  89 #endif
  90 
  91 // We generally try to create the oops directly when parsing, rather than
  92 // allocating temporary data structures and copying the bytes twice. A
  93 // temporary area is only needed when parsing utf8 entries in the constant
  94 // pool and when parsing line number tables.
  95 
  96 // We add assert in debug mode when class format is not checked.
  97 
  98 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
  99 #define JAVA_MIN_SUPPORTED_VERSION        45
 100 #define JAVA_PREVIEW_MINOR_VERSION        65535
 101 
 102 // Used for two backward compatibility reasons:
 103 // - to check for new additions to the class file format in JDK1.5
 104 // - to check for bug fixes in the format checker in JDK1.5
 105 #define JAVA_1_5_VERSION                  49
 106 
 107 // Used for backward compatibility reasons:
 108 // - to check for javac bug fixes that happened after 1.5
 109 // - also used as the max version when running in jdk6
 110 #define JAVA_6_VERSION                    50
 111 
 112 // Used for backward compatibility reasons:
 113 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 114 #define JAVA_7_VERSION                    51
 115 
 116 // Extension method support.
 117 #define JAVA_8_VERSION                    52
 118 
 119 #define JAVA_9_VERSION                    53
 120 
 121 #define JAVA_10_VERSION                   54
 122 
 123 #define JAVA_11_VERSION                   55
 124 
 125 #define JAVA_12_VERSION                   56
 126 
 127 #define JAVA_13_VERSION                   57
 128 
 129 #define JAVA_14_VERSION                   58
 130 
 131 #define JAVA_15_VERSION                   59
 132 
 133 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 134   assert((bad_constant == JVM_CONSTANT_Module ||
 135           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 136          &quot;Unexpected bad constant pool entry&quot;);
 137   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 138 }
 139 
 140 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 141                                                   ConstantPool* cp,
 142                                                   const int length,
 143                                                   TRAPS) {
 144   assert(stream != NULL, &quot;invariant&quot;);
 145   assert(cp != NULL, &quot;invariant&quot;);
 146 
 147   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 148   // this function (_current can be allocated in a register, with scalar
 149   // replacement of aggregates). The _current pointer is copied back to
 150   // stream() when this function returns. DON&#39;T call another method within
 151   // this method that uses stream().
 152   const ClassFileStream cfs1 = *stream;
 153   const ClassFileStream* const cfs = &amp;cfs1;
 154 
 155   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 156   debug_only(const u1* const old_current = stream-&gt;current();)
 157 
 158   // Used for batching symbol allocations.
 159   const char* names[SymbolTable::symbol_alloc_batch_size];
 160   int lengths[SymbolTable::symbol_alloc_batch_size];
 161   int indices[SymbolTable::symbol_alloc_batch_size];
 162   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 163   int names_count = 0;
 164 
 165   // parsing  Index 0 is unused
 166   for (int index = 1; index &lt; length; index++) {
 167     // Each of the following case guarantees one more byte in the stream
 168     // for the following tag or the access_flags following constant pool,
 169     // so we don&#39;t need bounds-check for reading tag.
 170     const u1 tag = cfs-&gt;get_u1_fast();
 171     switch (tag) {
 172       case JVM_CONSTANT_Class : {
 173         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 174         const u2 name_index = cfs-&gt;get_u2_fast();
 175         cp-&gt;klass_index_at_put(index, name_index);
 176         break;
 177       }
 178       case JVM_CONSTANT_Fieldref: {
 179         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 180         const u2 class_index = cfs-&gt;get_u2_fast();
 181         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Methodref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_InterfaceMethodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_String : {
 200         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 201         const u2 string_index = cfs-&gt;get_u2_fast();
 202         cp-&gt;string_index_at_put(index, string_index);
 203         break;
 204       }
 205       case JVM_CONSTANT_MethodHandle :
 206       case JVM_CONSTANT_MethodType: {
 207         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 208           classfile_parse_error(
 209             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 210             tag, CHECK);
 211         }
 212         if (tag == JVM_CONSTANT_MethodHandle) {
 213           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 214           const u1 ref_kind = cfs-&gt;get_u1_fast();
 215           const u2 method_index = cfs-&gt;get_u2_fast();
 216           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 217         }
 218         else if (tag == JVM_CONSTANT_MethodType) {
 219           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 220           const u2 signature_index = cfs-&gt;get_u2_fast();
 221           cp-&gt;method_type_index_at_put(index, signature_index);
 222         }
 223         else {
 224           ShouldNotReachHere();
 225         }
 226         break;
 227       }
 228       case JVM_CONSTANT_Dynamic : {
 229         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 230           classfile_parse_error(
 231               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 232               tag, CHECK);
 233         }
 234         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 235         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 236         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 237         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 238           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 239         }
 240         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 241         break;
 242       }
 243       case JVM_CONSTANT_InvokeDynamic : {
 244         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 245           classfile_parse_error(
 246               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 247               tag, CHECK);
 248         }
 249         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 250         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 251         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 252         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 253           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 254         }
 255         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 256         break;
 257       }
 258       case JVM_CONSTANT_Integer: {
 259         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 260         const u4 bytes = cfs-&gt;get_u4_fast();
 261         cp-&gt;int_at_put(index, (jint)bytes);
 262         break;
 263       }
 264       case JVM_CONSTANT_Float: {
 265         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 266         const u4 bytes = cfs-&gt;get_u4_fast();
 267         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 268         break;
 269       }
 270       case JVM_CONSTANT_Long: {
 271         // A mangled type might cause you to overrun allocated memory
 272         guarantee_property(index + 1 &lt; length,
 273                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 274                            index,
 275                            CHECK);
 276         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 277         const u8 bytes = cfs-&gt;get_u8_fast();
 278         cp-&gt;long_at_put(index, bytes);
 279         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 280         break;
 281       }
 282       case JVM_CONSTANT_Double: {
 283         // A mangled type might cause you to overrun allocated memory
 284         guarantee_property(index+1 &lt; length,
 285                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 286                            index,
 287                            CHECK);
 288         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 289         const u8 bytes = cfs-&gt;get_u8_fast();
 290         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 291         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 292         break;
 293       }
 294       case JVM_CONSTANT_NameAndType: {
 295         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 296         const u2 name_index = cfs-&gt;get_u2_fast();
 297         const u2 signature_index = cfs-&gt;get_u2_fast();
 298         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 299         break;
 300       }
 301       case JVM_CONSTANT_Utf8 : {
 302         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 303         u2  utf8_length = cfs-&gt;get_u2_fast();
 304         const u1* utf8_buffer = cfs-&gt;current();
 305         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 306         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 307         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 308         cfs-&gt;skip_u1_fast(utf8_length);
 309 
 310         // Before storing the symbol, make sure it&#39;s legal
 311         if (_need_verify) {
 312           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 313         }
 314 
 315         if (has_cp_patch_at(index)) {
 316           Handle patch = clear_cp_patch_at(index);
 317           guarantee_property(java_lang_String::is_instance(patch()),
 318                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 319                              index,
 320                              CHECK);
 321           const char* const str = java_lang_String::as_utf8_string(patch());
 322           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 323           utf8_buffer = (const u1*) str;
 324           utf8_length = (u2) strlen(str);
 325         }
 326 
 327         unsigned int hash;
 328         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 329                                                         utf8_length,
 330                                                         hash);
 331         if (result == NULL) {
 332           names[names_count] = (const char*)utf8_buffer;
 333           lengths[names_count] = utf8_length;
 334           indices[names_count] = index;
 335           hashValues[names_count++] = hash;
 336           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 337             SymbolTable::new_symbols(_loader_data,
 338                                      constantPoolHandle(THREAD, cp),
 339                                      names_count,
 340                                      names,
 341                                      lengths,
 342                                      indices,
 343                                      hashValues);
 344             names_count = 0;
 345           }
 346         } else {
 347           cp-&gt;symbol_at_put(index, result);
 348         }
 349         break;
 350       }
 351       case JVM_CONSTANT_Module:
 352       case JVM_CONSTANT_Package: {
 353         // Record that an error occurred in these two cases but keep parsing so
 354         // that ACC_Module can be checked for in the access_flags.  Need to
 355         // throw NoClassDefFoundError in that case.
 356         if (_major_version &gt;= JAVA_9_VERSION) {
 357           cfs-&gt;guarantee_more(3, CHECK);
 358           cfs-&gt;get_u2_fast();
 359           set_class_bad_constant_seen(tag);
 360           break;
 361         }
 362       }
 363       default: {
 364         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 365                               tag,
 366                               CHECK);
 367         break;
 368       }
 369     } // end of switch(tag)
 370   } // end of for
 371 
 372   // Allocate the remaining symbols
 373   if (names_count &gt; 0) {
 374     SymbolTable::new_symbols(_loader_data,
 375                              constantPoolHandle(THREAD, cp),
 376                              names_count,
 377                              names,
 378                              lengths,
 379                              indices,
 380                              hashValues);
 381   }
 382 
 383   // Copy _current pointer of local copy back to stream.
 384   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 385   stream-&gt;set_current(cfs1.current());
 386 
 387 }
 388 
 389 static inline bool valid_cp_range(int index, int length) {
 390   return (index &gt; 0 &amp;&amp; index &lt; length);
 391 }
 392 
 393 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 394   assert(cp != NULL, &quot;invariant&quot;);
 395   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 396     return cp-&gt;symbol_at(index);
 397   }
 398   return NULL;
 399 }
 400 
 401 #ifdef ASSERT
 402 PRAGMA_DIAG_PUSH
 403 PRAGMA_FORMAT_NONLITERAL_IGNORED
 404 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 405   ResourceMark rm(THREAD);
 406   fatal(msg, _class_name-&gt;as_C_string());
 407 }
 408 
 409 void ClassFileParser::report_assert_property_failure(const char* msg,
 410                                                      int index,
 411                                                      TRAPS) const {
 412   ResourceMark rm(THREAD);
 413   fatal(msg, index, _class_name-&gt;as_C_string());
 414 }
 415 PRAGMA_DIAG_POP
 416 #endif
 417 
 418 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 419                                          ConstantPool* const cp,
 420                                          const int length,
 421                                          TRAPS) {
 422   assert(cp != NULL, &quot;invariant&quot;);
 423   assert(stream != NULL, &quot;invariant&quot;);
 424 
 425   // parsing constant pool entries
 426   parse_constant_pool_entries(stream, cp, length, CHECK);
 427   if (class_bad_constant_seen() != 0) {
 428     // a bad CP entry has been detected previously so stop parsing and just return.
 429     return;
 430   }
 431 
 432   int index = 1;  // declared outside of loops for portability
 433   int num_klasses = 0;
 434 
 435   // first verification pass - validate cross references
 436   // and fixup class and string constants
 437   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 438     const jbyte tag = cp-&gt;tag_at(index).value();
 439     switch (tag) {
 440       case JVM_CONSTANT_Class: {
 441         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 442         break;
 443       }
 444       case JVM_CONSTANT_Fieldref:
 445         // fall through
 446       case JVM_CONSTANT_Methodref:
 447         // fall through
 448       case JVM_CONSTANT_InterfaceMethodref: {
 449         if (!_need_verify) break;
 450         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 451         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 452         check_property(valid_klass_reference_at(klass_ref_index),
 453                        &quot;Invalid constant pool index %u in class file %s&quot;,
 454                        klass_ref_index, CHECK);
 455         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 456           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 457           &quot;Invalid constant pool index %u in class file %s&quot;,
 458           name_and_type_ref_index, CHECK);
 459         break;
 460       }
 461       case JVM_CONSTANT_String: {
 462         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 463         break;
 464       }
 465       case JVM_CONSTANT_Integer:
 466         break;
 467       case JVM_CONSTANT_Float:
 468         break;
 469       case JVM_CONSTANT_Long:
 470       case JVM_CONSTANT_Double: {
 471         index++;
 472         check_property(
 473           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 474           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 475           index, CHECK);
 476         break;
 477       }
 478       case JVM_CONSTANT_NameAndType: {
 479         if (!_need_verify) break;
 480         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 481         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 482         check_property(valid_symbol_at(name_ref_index),
 483           &quot;Invalid constant pool index %u in class file %s&quot;,
 484           name_ref_index, CHECK);
 485         check_property(valid_symbol_at(signature_ref_index),
 486           &quot;Invalid constant pool index %u in class file %s&quot;,
 487           signature_ref_index, CHECK);
 488         break;
 489       }
 490       case JVM_CONSTANT_Utf8:
 491         break;
 492       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 493       case JVM_CONSTANT_UnresolvedClassInError: {
 494         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 495         break;
 496       }
 497       case JVM_CONSTANT_ClassIndex: {
 498         const int class_index = cp-&gt;klass_index_at(index);
 499         check_property(valid_symbol_at(class_index),
 500           &quot;Invalid constant pool index %u in class file %s&quot;,
 501           class_index, CHECK);
 502         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 503         break;
 504       }
 505       case JVM_CONSTANT_StringIndex: {
 506         const int string_index = cp-&gt;string_index_at(index);
 507         check_property(valid_symbol_at(string_index),
 508           &quot;Invalid constant pool index %u in class file %s&quot;,
 509           string_index, CHECK);
 510         Symbol* const sym = cp-&gt;symbol_at(string_index);
 511         cp-&gt;unresolved_string_at_put(index, sym);
 512         break;
 513       }
 514       case JVM_CONSTANT_MethodHandle: {
 515         const int ref_index = cp-&gt;method_handle_index_at(index);
 516         check_property(valid_cp_range(ref_index, length),
 517           &quot;Invalid constant pool index %u in class file %s&quot;,
 518           ref_index, CHECK);
 519         const constantTag tag = cp-&gt;tag_at(ref_index);
 520         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 521 
 522         switch (ref_kind) {
 523           case JVM_REF_getField:
 524           case JVM_REF_getStatic:
 525           case JVM_REF_putField:
 526           case JVM_REF_putStatic: {
 527             check_property(
 528               tag.is_field(),
 529               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 530               ref_index, CHECK);
 531             break;
 532           }
 533           case JVM_REF_invokeVirtual:
 534           case JVM_REF_newInvokeSpecial: {
 535             check_property(
 536               tag.is_method(),
 537               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 538               ref_index, CHECK);
 539             break;
 540           }
 541           case JVM_REF_invokeStatic:
 542           case JVM_REF_invokeSpecial: {
 543             check_property(
 544               tag.is_method() ||
 545               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 546               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 547               ref_index, CHECK);
 548             break;
 549           }
 550           case JVM_REF_invokeInterface: {
 551             check_property(
 552               tag.is_interface_method(),
 553               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 554               ref_index, CHECK);
 555             break;
 556           }
 557           default: {
 558             classfile_parse_error(
 559               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 560               index, CHECK);
 561           }
 562         } // switch(refkind)
 563         // Keep the ref_index unchanged.  It will be indirected at link-time.
 564         break;
 565       } // case MethodHandle
 566       case JVM_CONSTANT_MethodType: {
 567         const int ref_index = cp-&gt;method_type_index_at(index);
 568         check_property(valid_symbol_at(ref_index),
 569           &quot;Invalid constant pool index %u in class file %s&quot;,
 570           ref_index, CHECK);
 571         break;
 572       }
 573       case JVM_CONSTANT_Dynamic: {
 574         const int name_and_type_ref_index =
 575           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 576 
 577         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 578           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 579           &quot;Invalid constant pool index %u in class file %s&quot;,
 580           name_and_type_ref_index, CHECK);
 581         // bootstrap specifier index must be checked later,
 582         // when BootstrapMethods attr is available
 583 
 584         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 585         cp-&gt;set_has_dynamic_constant();
 586         break;
 587       }
 588       case JVM_CONSTANT_InvokeDynamic: {
 589         const int name_and_type_ref_index =
 590           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 591 
 592         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 593           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 594           &quot;Invalid constant pool index %u in class file %s&quot;,
 595           name_and_type_ref_index, CHECK);
 596         // bootstrap specifier index must be checked later,
 597         // when BootstrapMethods attr is available
 598         break;
 599       }
 600       default: {
 601         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 602         ShouldNotReachHere();
 603         break;
 604       }
 605     } // switch(tag)
 606   } // end of for
 607 
 608   _first_patched_klass_resolved_index = num_klasses;
 609   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 610 
 611   if (_cp_patches != NULL) {
 612     // need to treat this_class specially...
 613 
 614     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 615     // for now. These will be replaced with actual names of the patched classes in patch_class().
 616     Symbol* s = vmSymbols::star_name();
 617     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 618       cp-&gt;symbol_at_put(n, s);
 619     }
 620 
 621     int this_class_index;
 622     {
 623       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 624       const u1* const mark = stream-&gt;current();
 625       stream-&gt;skip_u2_fast(1); // skip flags
 626       this_class_index = stream-&gt;get_u2_fast();
 627       stream-&gt;set_current(mark);  // revert to mark
 628     }
 629 
 630     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 631       if (has_cp_patch_at(index)) {
 632         guarantee_property(index != this_class_index,
 633           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 634           index, CHECK);
 635         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 636       }
 637     }
 638   }
 639 
 640   if (!_need_verify) {
 641     return;
 642   }
 643 
 644   // second verification pass - checks the strings are of the right format.
 645   // but not yet to the other entries
 646   for (index = 1; index &lt; length; index++) {
 647     const jbyte tag = cp-&gt;tag_at(index).value();
 648     switch (tag) {
 649       case JVM_CONSTANT_UnresolvedClass: {
 650         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 651         // check the name, even if _cp_patches will overwrite it
 652         verify_legal_class_name(class_name, CHECK);
 653         break;
 654       }
 655       case JVM_CONSTANT_NameAndType: {
 656         if (_need_verify) {
 657           const int sig_index = cp-&gt;signature_ref_index_at(index);
 658           const int name_index = cp-&gt;name_ref_index_at(index);
 659           const Symbol* const name = cp-&gt;symbol_at(name_index);
 660           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 661           guarantee_property(sig-&gt;utf8_length() != 0,
 662             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 663             sig_index, CHECK);
 664           guarantee_property(name-&gt;utf8_length() != 0,
 665             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 666             name_index, CHECK);
 667 
 668           if (sig-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {
 669             // Format check method name and signature
 670             verify_legal_method_name(name, CHECK);
 671             verify_legal_method_signature(name, sig, CHECK);
 672           } else {
 673             // Format check field name and signature
 674             verify_legal_field_name(name, CHECK);
 675             verify_legal_field_signature(name, sig, CHECK);
 676           }
 677         }
 678         break;
 679       }
 680       case JVM_CONSTANT_Dynamic: {
 681         const int name_and_type_ref_index =
 682           cp-&gt;name_and_type_ref_index_at(index);
 683         // already verified to be utf8
 684         const int name_ref_index =
 685           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 686         // already verified to be utf8
 687         const int signature_ref_index =
 688           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 689         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 690         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 691         if (_need_verify) {
 692           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 693           // Need only to be sure signature is non-zero length and the right type.
 694           if (signature-&gt;utf8_length() == 0 ||
 695               signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {
 696             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 697           }
 698         }
 699         break;
 700       }
 701       case JVM_CONSTANT_InvokeDynamic:
 702       case JVM_CONSTANT_Fieldref:
 703       case JVM_CONSTANT_Methodref:
 704       case JVM_CONSTANT_InterfaceMethodref: {
 705         const int name_and_type_ref_index =
 706           cp-&gt;name_and_type_ref_index_at(index);
 707         // already verified to be utf8
 708         const int name_ref_index =
 709           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 710         // already verified to be utf8
 711         const int signature_ref_index =
 712           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 713         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 714         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 715         if (tag == JVM_CONSTANT_Fieldref) {
 716           if (_need_verify) {
 717             // Field name and signature are verified above, when iterating NameAndType_info.
 718             // Need only to be sure signature is non-zero length and the right type.
 719             if (signature-&gt;utf8_length() == 0 ||
 720                 signature-&gt;char_at(0) == JVM_SIGNATURE_FUNC) {
 721               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 722             }
 723           }
 724         } else {
 725           if (_need_verify) {
 726             // Method name and signature are verified above, when iterating NameAndType_info.
 727             // Need only to be sure signature is non-zero length and the right type.
 728             if (signature-&gt;utf8_length() == 0 ||
 729                 signature-&gt;char_at(0) != JVM_SIGNATURE_FUNC) {
 730               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 731             }
 732           }
 733           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 734           const unsigned int name_len = name-&gt;utf8_length();
 735           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 736               name_len != 0 &amp;&amp;
 737               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 738               name != vmSymbols::object_initializer_name()) {
 739             classfile_parse_error(
 740               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 741               name_ref_index, CHECK);
 742           }
 743         }
 744         break;
 745       }
 746       case JVM_CONSTANT_MethodHandle: {
 747         const int ref_index = cp-&gt;method_handle_index_at(index);
 748         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 749         switch (ref_kind) {
 750           case JVM_REF_invokeVirtual:
 751           case JVM_REF_invokeStatic:
 752           case JVM_REF_invokeSpecial:
 753           case JVM_REF_newInvokeSpecial: {
 754             const int name_and_type_ref_index =
 755               cp-&gt;name_and_type_ref_index_at(ref_index);
 756             const int name_ref_index =
 757               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 758             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 759             if (ref_kind == JVM_REF_newInvokeSpecial) {
 760               if (name != vmSymbols::object_initializer_name()) {
 761                 classfile_parse_error(
 762                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 763                     name_ref_index, CHECK);
 764               }
 765             } else {
 766               if (name == vmSymbols::object_initializer_name()) {
 767                 classfile_parse_error(
 768                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 769                   name_ref_index, CHECK);
 770               }
 771             }
 772             break;
 773           }
 774           // Other ref_kinds are already fully checked in previous pass.
 775         } // switch(ref_kind)
 776         break;
 777       }
 778       case JVM_CONSTANT_MethodType: {
 779         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 780         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 781         verify_legal_method_signature(no_name, signature, CHECK);
 782         break;
 783       }
 784       case JVM_CONSTANT_Utf8: {
 785         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 786       }
 787     }  // switch(tag)
 788   }  // end of for
 789 }
 790 
 791 Handle ClassFileParser::clear_cp_patch_at(int index) {
 792   Handle patch = cp_patch_at(index);
 793   _cp_patches-&gt;at_put(index, Handle());
 794   assert(!has_cp_patch_at(index), &quot;&quot;);
 795   return patch;
 796 }
 797 
 798 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 799   int name_index = _orig_cp_size + _num_patched_klasses;
 800   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 801 
 802   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 803   _num_patched_klasses ++;
 804 }
 805 
 806 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 807                                           int index,
 808                                           Handle patch,
 809                                           TRAPS) {
 810   assert(cp != NULL, &quot;invariant&quot;);
 811 
 812   BasicType patch_type = T_VOID;
 813 
 814   switch (cp-&gt;tag_at(index).value()) {
 815 
 816     case JVM_CONSTANT_UnresolvedClass: {
 817       // Patching a class means pre-resolving it.
 818       // The name in the constant pool is ignored.
 819       if (java_lang_Class::is_instance(patch())) {
 820         guarantee_property(!java_lang_Class::is_primitive(patch()),
 821                            &quot;Illegal class patch at %d in class file %s&quot;,
 822                            index, CHECK);
 823         Klass* k = java_lang_Class::as_Klass(patch());
 824         patch_class(cp, index, k, k-&gt;name());
 825       } else {
 826         guarantee_property(java_lang_String::is_instance(patch()),
 827                            &quot;Illegal class patch at %d in class file %s&quot;,
 828                            index, CHECK);
 829         Symbol* const name = java_lang_String::as_symbol(patch());
 830         patch_class(cp, index, NULL, name);
 831       }
 832       break;
 833     }
 834 
 835     case JVM_CONSTANT_String: {
 836       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 837       // references to be created first.
 838       return;
 839     }
 840     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 841     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 842     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 843     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 844     patch_prim:
 845     {
 846       jvalue value;
 847       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 848       guarantee_property(value_type == patch_type,
 849                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 850                          index, CHECK);
 851       switch (value_type) {
 852         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 853         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 854         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 855         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 856         default:       assert(false, &quot;&quot;);
 857       }
 858     } // end patch_prim label
 859     break;
 860 
 861     default: {
 862       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 863       guarantee_property(!has_cp_patch_at(index),
 864                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 865                          index, CHECK);
 866       return;
 867     }
 868   } // end of switch(tag)
 869 
 870   // On fall-through, mark the patch as used.
 871   clear_cp_patch_at(index);
 872 }
 873 class NameSigHash: public ResourceObj {
 874  public:
 875   const Symbol*       _name;       // name
 876   const Symbol*       _sig;        // signature
 877   NameSigHash*  _next;             // Next entry in hash table
 878 };
 879 
 880 static const int HASH_ROW_SIZE = 256;
 881 
 882 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 883   unsigned int raw_hash = 0;
 884   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 885   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 886 
 887   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 888 }
 889 
 890 
 891 static void initialize_hashtable(NameSigHash** table) {
 892   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 893 }
 894 // Return false if the name/sig combination is found in table.
 895 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 896 // The old format checker uses heap sort to find duplicates.
 897 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 898 // of table since we don&#39;t expect Symbol*&#39;s to move.
 899 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 900   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 901 
 902   // First lookup for duplicates
 903   int index = hash(name, sig);
 904   NameSigHash* entry = table[index];
 905   while (entry != NULL) {
 906     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 907       return false;
 908     }
 909     entry = entry-&gt;_next;
 910   }
 911 
 912   // No duplicate is found, allocate a new entry and fill it.
 913   entry = new NameSigHash();
 914   entry-&gt;_name = name;
 915   entry-&gt;_sig = sig;
 916 
 917   // Insert into hash table
 918   entry-&gt;_next = table[index];
 919   table[index] = entry;
 920 
 921   return true;
 922 }
 923 
 924 // Side-effects: populates the _local_interfaces field
 925 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,
 926                                        const int itfs_len,
 927                                        ConstantPool* const cp,
 928                                        bool* const has_nonstatic_concrete_methods,
 929                                        TRAPS) {
 930   assert(stream != NULL, &quot;invariant&quot;);
 931   assert(cp != NULL, &quot;invariant&quot;);
 932   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 933 
 934   if (itfs_len == 0) {
 935     _local_interfaces = Universe::the_empty_instance_klass_array();
 936   } else {
 937     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 938     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 939 
 940     int index;
 941     for (index = 0; index &lt; itfs_len; index++) {
 942       const u2 interface_index = stream-&gt;get_u2(CHECK);
 943       Klass* interf;
 944       check_property(
 945         valid_klass_reference_at(interface_index),
 946         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 947         interface_index, CHECK);
 948       if (cp-&gt;tag_at(interface_index).is_klass()) {
 949         interf = cp-&gt;resolved_klass_at(interface_index);
 950       } else {
 951         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 952 
 953         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 954         // But need to make sure it&#39;s not an array type.
 955         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 956                            &quot;Bad interface name in class file %s&quot;, CHECK);
 957 
 958         // Call resolve_super so classcircularity is checked
 959         interf = SystemDictionary::resolve_super_or_fail(
 960                                                   _class_name,
 961                                                   unresolved_klass,
 962                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 963                                                   _protection_domain,
 964                                                   false,
 965                                                   CHECK);
 966       }
 967 
 968       if (!interf-&gt;is_interface()) {
 969         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 970                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 971                           _class_name-&gt;as_klass_external_name(),
 972                           interf-&gt;external_name(),
 973                           interf-&gt;class_in_module_of_loader()));
 974       }
 975 
 976       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {
 977         *has_nonstatic_concrete_methods = true;
 978       }
 979       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));
 980     }
 981 
 982     if (!_need_verify || itfs_len &lt;= 1) {
 983       return;
 984     }
 985 
 986     // Check if there&#39;s any duplicates in interfaces
 987     ResourceMark rm(THREAD);
 988     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 989                                                                  NameSigHash*,
 990                                                                  HASH_ROW_SIZE);
 991     initialize_hashtable(interface_names);
 992     bool dup = false;
 993     const Symbol* name = NULL;
 994     {
 995       debug_only(NoSafepointVerifier nsv;)
 996       for (index = 0; index &lt; itfs_len; index++) {
 997         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
 998         name = k-&gt;name();
 999         // If no duplicates, add (name, NULL) in hashtable interface_names.
1000         if (!put_after_lookup(name, NULL, interface_names)) {
1001           dup = true;
1002           break;
1003         }
1004       }
1005     }
1006     if (dup) {
1007       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1008                              name-&gt;as_C_string(), CHECK);
1009     }
1010   }
1011 }
1012 
1013 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1014                                            int constantvalue_index,
1015                                            int signature_index,
1016                                            TRAPS) const {
1017   // Make sure the constant pool entry is of a type appropriate to this field
1018   guarantee_property(
1019     (constantvalue_index &gt; 0 &amp;&amp;
1020       constantvalue_index &lt; cp-&gt;length()),
1021     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1022     constantvalue_index, CHECK);
1023 
1024   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1025   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1026     case T_LONG: {
1027       guarantee_property(value_type.is_long(),
1028                          &quot;Inconsistent constant value type in class file %s&quot;,
1029                          CHECK);
1030       break;
1031     }
1032     case T_FLOAT: {
1033       guarantee_property(value_type.is_float(),
1034                          &quot;Inconsistent constant value type in class file %s&quot;,
1035                          CHECK);
1036       break;
1037     }
1038     case T_DOUBLE: {
1039       guarantee_property(value_type.is_double(),
1040                          &quot;Inconsistent constant value type in class file %s&quot;,
1041                          CHECK);
1042       break;
1043     }
1044     case T_BYTE:
1045     case T_CHAR:
1046     case T_SHORT:
1047     case T_BOOLEAN:
1048     case T_INT: {
1049       guarantee_property(value_type.is_int(),
1050                          &quot;Inconsistent constant value type in class file %s&quot;,
1051                          CHECK);
1052       break;
1053     }
1054     case T_OBJECT: {
1055       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1056                          &amp;&amp; value_type.is_string()),
1057                          &quot;Bad string initial value in class file %s&quot;,
1058                          CHECK);
1059       break;
1060     }
1061     default: {
1062       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1063                              constantvalue_index,
1064                              CHECK);
1065     }
1066   }
1067 }
1068 
1069 class AnnotationCollector : public ResourceObj{
1070 public:
1071   enum Location { _in_field, _in_method, _in_class };
1072   enum ID {
1073     _unknown = 0,
1074     _method_CallerSensitive,
1075     _method_ForceInline,
1076     _method_DontInline,
1077     _method_InjectedProfile,
1078     _method_LambdaForm_Compiled,
1079     _method_Hidden,
1080     _method_HotSpotIntrinsicCandidate,
1081     _jdk_internal_vm_annotation_Contended,
1082     _field_Stable,
1083     _jdk_internal_vm_annotation_ReservedStackAccess,
1084     _annotation_LIMIT
1085   };
1086   const Location _location;
1087   int _annotations_present;
1088   u2 _contended_group;
1089 
1090   AnnotationCollector(Location location)
1091     : _location(location), _annotations_present(0)
1092   {
1093     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1094   }
1095   // If this annotation name has an ID, report it (or _none).
1096   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);
1097   // Set the annotation name:
1098   void set_annotation(ID id) {
1099     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1100     _annotations_present |= nth_bit((int)id);
1101   }
1102 
1103   void remove_annotation(ID id) {
1104     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1105     _annotations_present &amp;= ~nth_bit((int)id);
1106   }
1107 
1108   // Report if the annotation is present.
1109   bool has_any_annotations() const { return _annotations_present != 0; }
1110   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1111 
1112   void set_contended_group(u2 group) { _contended_group = group; }
1113   u2 contended_group() const { return _contended_group; }
1114 
1115   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1116 
1117   void set_stable(bool stable) { set_annotation(_field_Stable); }
1118   bool is_stable() const { return has_annotation(_field_Stable); }
1119 };
1120 
1121 // This class also doubles as a holder for metadata cleanup.
1122 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1123 private:
1124   ClassLoaderData* _loader_data;
1125   AnnotationArray* _field_annotations;
1126   AnnotationArray* _field_type_annotations;
1127 public:
1128   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1129     AnnotationCollector(_in_field),
1130     _loader_data(loader_data),
1131     _field_annotations(NULL),
1132     _field_type_annotations(NULL) {}
1133   ~FieldAnnotationCollector();
1134   void apply_to(FieldInfo* f);
1135   AnnotationArray* field_annotations()      { return _field_annotations; }
1136   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1137 
1138   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1139   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1140 };
1141 
1142 class MethodAnnotationCollector : public AnnotationCollector{
1143 public:
1144   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1145   void apply_to(const methodHandle&amp; m);
1146 };
1147 
1148 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1149 public:
1150   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1151   void apply_to(InstanceKlass* ik);
1152 };
1153 
1154 
1155 static int skip_annotation_value(const u1*, int, int); // fwd decl
1156 
1157 // Safely increment index by val if does not pass limit
1158 #define SAFE_ADD(index, limit, val) \
1159 if (index &gt;= limit - val) return limit; \
1160 index += val;
1161 
1162 // Skip an annotation.  Return &gt;=limit if there is any problem.
1163 static int skip_annotation(const u1* buffer, int limit, int index) {
1164   assert(buffer != NULL, &quot;invariant&quot;);
1165   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1166   // value := switch (tag:u1) { ... }
1167   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1168   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1169   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1170     SAFE_ADD(index, limit, 2); // skip member
1171     index = skip_annotation_value(buffer, limit, index);
1172   }
1173   return index;
1174 }
1175 
1176 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1177 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1178   assert(buffer != NULL, &quot;invariant&quot;);
1179 
1180   // value := switch (tag:u1) {
1181   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1182   //   case e: e_class:u2 e_name:u2;
1183   //   case s: s_con:u2;
1184   //   case [: do(nval:u2) {value};
1185   //   case @: annotation;
1186   //   case s: s_con:u2;
1187   // }
1188   SAFE_ADD(index, limit, 1); // read tag
1189   const u1 tag = buffer[index - 1];
1190   switch (tag) {
1191     case &#39;B&#39;:
1192     case &#39;C&#39;:
1193     case &#39;I&#39;:
1194     case &#39;S&#39;:
1195     case &#39;Z&#39;:
1196     case &#39;D&#39;:
1197     case &#39;F&#39;:
1198     case &#39;J&#39;:
1199     case &#39;c&#39;:
1200     case &#39;s&#39;:
1201       SAFE_ADD(index, limit, 2);  // skip con or s_con
1202       break;
1203     case &#39;e&#39;:
1204       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1205       break;
1206     case &#39;[&#39;:
1207     {
1208       SAFE_ADD(index, limit, 2); // read nval
1209       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1210       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1211         index = skip_annotation_value(buffer, limit, index);
1212       }
1213     }
1214     break;
1215     case &#39;@&#39;:
1216       index = skip_annotation(buffer, limit, index);
1217       break;
1218     default:
1219       return limit;  //  bad tag byte
1220   }
1221   return index;
1222 }
1223 
1224 // Sift through annotations, looking for those significant to the VM:
1225 static void parse_annotations(const ConstantPool* const cp,
1226                               const u1* buffer, int limit,
1227                               AnnotationCollector* coll,
1228                               ClassLoaderData* loader_data,
1229                               TRAPS) {
1230 
1231   assert(cp != NULL, &quot;invariant&quot;);
1232   assert(buffer != NULL, &quot;invariant&quot;);
1233   assert(coll != NULL, &quot;invariant&quot;);
1234   assert(loader_data != NULL, &quot;invariant&quot;);
1235 
1236   // annotations := do(nann:u2) {annotation}
1237   int index = 2; // read nann
1238   if (index &gt;= limit)  return;
1239   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1240   enum {  // initial annotation layout
1241     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1242     count_off = 2,      // u2   such as 1 (one value)
1243     member_off = 4,     // utf8 such as &#39;value&#39;
1244     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1245     e_tag_val = &#39;e&#39;,
1246     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1247     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1248     e_size = 11,     // end of &#39;e&#39; annotation
1249     c_tag_val = &#39;c&#39;,    // payload is type
1250     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1251     c_size = 9,       // end of &#39;c&#39; annotation
1252     s_tag_val = &#39;s&#39;,    // payload is String
1253     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1254     s_size = 9,
1255     min_size = 6        // smallest possible size (zero members)
1256   };
1257   // Cannot add min_size to index in case of overflow MAX_INT
1258   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1259     int index0 = index;
1260     index = skip_annotation(buffer, limit, index);
1261     const u1* const abase = buffer + index0;
1262     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1263     const int count = Bytes::get_Java_u2((address)abase + count_off);
1264     const Symbol* const aname = check_symbol_at(cp, atype);
1265     if (aname == NULL)  break;  // invalid annotation name
1266     const Symbol* member = NULL;
1267     if (count &gt;= 1) {
1268       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1269       member = check_symbol_at(cp, member_index);
1270       if (member == NULL)  break;  // invalid member name
1271     }
1272 
1273     // Here is where parsing particular annotations will take place.
1274     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname);
1275     if (AnnotationCollector::_unknown == id)  continue;
1276     coll-&gt;set_annotation(id);
1277 
1278     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1279       // @Contended can optionally specify the contention group.
1280       //
1281       // Contended group defines the equivalence class over the fields:
1282       // the fields within the same contended group are not treated distinct.
1283       // The only exception is default group, which does not incur the
1284       // equivalence. Naturally, contention group for classes is meaningless.
1285       //
1286       // While the contention group is specified as String, annotation
1287       // values are already interned, and we might as well use the constant
1288       // pool index as the group tag.
1289       //
1290       u2 group_index = 0; // default contended group
1291       if (count == 1
1292         &amp;&amp; s_size == (index - index0)  // match size
1293         &amp;&amp; s_tag_val == *(abase + tag_off)
1294         &amp;&amp; member == vmSymbols::value_name()) {
1295         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1296         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1297           group_index = 0; // default contended group
1298         }
1299       }
1300       coll-&gt;set_contended_group(group_index);
1301     }
1302   }
1303 }
1304 
1305 
1306 // Parse attributes for a field.
1307 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1308                                              u2 attributes_count,
1309                                              bool is_static, u2 signature_index,
1310                                              u2* const constantvalue_index_addr,
1311                                              bool* const is_synthetic_addr,
1312                                              u2* const generic_signature_index_addr,
1313                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1314                                              TRAPS) {
1315   assert(cfs != NULL, &quot;invariant&quot;);
1316   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1317   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1318   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1319   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1320   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1321 
1322   u2 constantvalue_index = 0;
1323   u2 generic_signature_index = 0;
1324   bool is_synthetic = false;
1325   const u1* runtime_visible_annotations = NULL;
1326   int runtime_visible_annotations_length = 0;
1327   const u1* runtime_invisible_annotations = NULL;
1328   int runtime_invisible_annotations_length = 0;
1329   const u1* runtime_visible_type_annotations = NULL;
1330   int runtime_visible_type_annotations_length = 0;
1331   const u1* runtime_invisible_type_annotations = NULL;
1332   int runtime_invisible_type_annotations_length = 0;
1333   bool runtime_invisible_annotations_exists = false;
1334   bool runtime_invisible_type_annotations_exists = false;
1335   const ConstantPool* const cp = _cp;
1336 
1337   while (attributes_count--) {
1338     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1339     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1340     const u4 attribute_length = cfs-&gt;get_u4_fast();
1341     check_property(valid_symbol_at(attribute_name_index),
1342                    &quot;Invalid field attribute index %u in class file %s&quot;,
1343                    attribute_name_index,
1344                    CHECK);
1345 
1346     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1347     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1348       // ignore if non-static
1349       if (constantvalue_index != 0) {
1350         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1351       }
1352       check_property(
1353         attribute_length == 2,
1354         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1355         attribute_length, CHECK);
1356 
1357       constantvalue_index = cfs-&gt;get_u2(CHECK);
1358       if (_need_verify) {
1359         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1360       }
1361     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1362       if (attribute_length != 0) {
1363         classfile_parse_error(
1364           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1365           attribute_length, CHECK);
1366       }
1367       is_synthetic = true;
1368     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1369       if (attribute_length != 0) {
1370         classfile_parse_error(
1371           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1372           attribute_length, CHECK);
1373       }
1374     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1375       if (attribute_name == vmSymbols::tag_signature()) {
1376         if (generic_signature_index != 0) {
1377           classfile_parse_error(
1378             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1379         }
1380         if (attribute_length != 2) {
1381           classfile_parse_error(
1382             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1383             attribute_length, CHECK);
1384         }
1385         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1386       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1387         if (runtime_visible_annotations != NULL) {
1388           classfile_parse_error(
1389             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1390         }
1391         runtime_visible_annotations_length = attribute_length;
1392         runtime_visible_annotations = cfs-&gt;current();
1393         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1394         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1395         parse_annotations(cp,
1396                           runtime_visible_annotations,
1397                           runtime_visible_annotations_length,
1398                           parsed_annotations,
1399                           _loader_data,
1400                           CHECK);
1401         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1402       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1403         if (runtime_invisible_annotations_exists) {
1404           classfile_parse_error(
1405             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1406         }
1407         runtime_invisible_annotations_exists = true;
1408         if (PreserveAllAnnotations) {
1409           runtime_invisible_annotations_length = attribute_length;
1410           runtime_invisible_annotations = cfs-&gt;current();
1411           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1412         }
1413         cfs-&gt;skip_u1(attribute_length, CHECK);
1414       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1415         if (runtime_visible_type_annotations != NULL) {
1416           classfile_parse_error(
1417             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1418         }
1419         runtime_visible_type_annotations_length = attribute_length;
1420         runtime_visible_type_annotations = cfs-&gt;current();
1421         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1422         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1423       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1424         if (runtime_invisible_type_annotations_exists) {
1425           classfile_parse_error(
1426             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1427         } else {
1428           runtime_invisible_type_annotations_exists = true;
1429         }
1430         if (PreserveAllAnnotations) {
1431           runtime_invisible_type_annotations_length = attribute_length;
1432           runtime_invisible_type_annotations = cfs-&gt;current();
1433           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1434         }
1435         cfs-&gt;skip_u1(attribute_length, CHECK);
1436       } else {
1437         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1438       }
1439     } else {
1440       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1441     }
1442   }
1443 
1444   *constantvalue_index_addr = constantvalue_index;
1445   *is_synthetic_addr = is_synthetic;
1446   *generic_signature_index_addr = generic_signature_index;
1447   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1448                                             runtime_visible_annotations_length,
1449                                             runtime_invisible_annotations,
1450                                             runtime_invisible_annotations_length,
1451                                             CHECK);
1452   parsed_annotations-&gt;set_field_annotations(a);
1453   a = assemble_annotations(runtime_visible_type_annotations,
1454                            runtime_visible_type_annotations_length,
1455                            runtime_invisible_type_annotations,
1456                            runtime_invisible_type_annotations_length,
1457                            CHECK);
1458   parsed_annotations-&gt;set_field_type_annotations(a);
1459   return;
1460 }
1461 
1462 
1463 // Field allocation types. Used for computing field offsets.
1464 
1465 enum FieldAllocationType {
1466   STATIC_OOP,           // Oops
1467   STATIC_BYTE,          // Boolean, Byte, char
1468   STATIC_SHORT,         // shorts
1469   STATIC_WORD,          // ints
1470   STATIC_DOUBLE,        // aligned long or double
1471   NONSTATIC_OOP,
1472   NONSTATIC_BYTE,
1473   NONSTATIC_SHORT,
1474   NONSTATIC_WORD,
1475   NONSTATIC_DOUBLE,
1476   MAX_FIELD_ALLOCATION_TYPE,
1477   BAD_ALLOCATION_TYPE = -1
1478 };
1479 
1480 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1481   BAD_ALLOCATION_TYPE, // 0
1482   BAD_ALLOCATION_TYPE, // 1
1483   BAD_ALLOCATION_TYPE, // 2
1484   BAD_ALLOCATION_TYPE, // 3
1485   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1486   NONSTATIC_SHORT,     // T_CHAR        =  5,
1487   NONSTATIC_WORD,      // T_FLOAT       =  6,
1488   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1489   NONSTATIC_BYTE,      // T_BYTE        =  8,
1490   NONSTATIC_SHORT,     // T_SHORT       =  9,
1491   NONSTATIC_WORD,      // T_INT         = 10,
1492   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1493   NONSTATIC_OOP,       // T_OBJECT      = 12,
1494   NONSTATIC_OOP,       // T_ARRAY       = 13,
1495   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1496   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1497   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1498   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1499   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1500   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1501   BAD_ALLOCATION_TYPE, // 0
1502   BAD_ALLOCATION_TYPE, // 1
1503   BAD_ALLOCATION_TYPE, // 2
1504   BAD_ALLOCATION_TYPE, // 3
1505   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1506   STATIC_SHORT,        // T_CHAR        =  5,
1507   STATIC_WORD,         // T_FLOAT       =  6,
1508   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1509   STATIC_BYTE,         // T_BYTE        =  8,
1510   STATIC_SHORT,        // T_SHORT       =  9,
1511   STATIC_WORD,         // T_INT         = 10,
1512   STATIC_DOUBLE,       // T_LONG        = 11,
1513   STATIC_OOP,          // T_OBJECT      = 12,
1514   STATIC_OOP,          // T_ARRAY       = 13,
1515   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1516   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1517   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1518   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1519   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1520   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1521 };
1522 
1523 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {
1524   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1525   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1526   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
1527   return result;
1528 }
1529 
1530 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1531  public:
1532   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1533 
1534   FieldAllocationCount() {
1535     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1536       count[i] = 0;
1537     }
1538   }
1539 
1540   FieldAllocationType update(bool is_static, BasicType type) {
1541     FieldAllocationType atype = basic_type_to_atype(is_static, type);
1542     if (atype != BAD_ALLOCATION_TYPE) {
1543       // Make sure there is no overflow with injected fields.
1544       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1545       count[atype]++;
1546     }
1547     return atype;
1548   }
1549 };
1550 
1551 // Side-effects: populates the _fields, _fields_annotations,
1552 // _fields_type_annotations fields
1553 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1554                                    bool is_interface,
1555                                    FieldAllocationCount* const fac,
1556                                    ConstantPool* cp,
1557                                    const int cp_size,
1558                                    u2* const java_fields_count_ptr,
1559                                    TRAPS) {
1560 
1561   assert(cfs != NULL, &quot;invariant&quot;);
1562   assert(fac != NULL, &quot;invariant&quot;);
1563   assert(cp != NULL, &quot;invariant&quot;);
1564   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1565 
1566   assert(NULL == _fields, &quot;invariant&quot;);
1567   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1568   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1569 
1570   cfs-&gt;guarantee_more(2, CHECK);  // length
1571   const u2 length = cfs-&gt;get_u2_fast();
1572   *java_fields_count_ptr = length;
1573 
1574   int num_injected = 0;
1575   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1576                                                                   &amp;num_injected);
1577   const int total_fields = length + num_injected;
1578 
1579   // The field array starts with tuples of shorts
1580   // [access, name index, sig index, initial value index, byte offset].
1581   // A generic signature slot only exists for field with generic
1582   // signature attribute. And the access flag is set with
1583   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1584   // signature slots are at the end of the field array and after all
1585   // other fields data.
1586   //
1587   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1588   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1589   //       ...
1590   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1591   //       [generic signature index]
1592   //       [generic signature index]
1593   //       ...
1594   //
1595   // Allocate a temporary resource array for field data. For each field,
1596   // a slot is reserved in the temporary array for the generic signature
1597   // index. After parsing all fields, the data are copied to a permanent
1598   // array and any unused slots will be discarded.
1599   ResourceMark rm(THREAD);
1600   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1601                                               u2,
1602                                               total_fields * (FieldInfo::field_slots + 1));
1603 
1604   // The generic signature slots start after all other fields&#39; data.
1605   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1606   int num_generic_signature = 0;
1607   for (int n = 0; n &lt; length; n++) {
1608     // access_flags, name_index, descriptor_index, attributes_count
1609     cfs-&gt;guarantee_more(8, CHECK);
1610 
1611     AccessFlags access_flags;
1612     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
1613     verify_legal_field_modifiers(flags, is_interface, CHECK);
1614     access_flags.set_flags(flags);
1615 
1616     const u2 name_index = cfs-&gt;get_u2_fast();
1617     check_property(valid_symbol_at(name_index),
1618       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1619       name_index, CHECK);
1620     const Symbol* const name = cp-&gt;symbol_at(name_index);
1621     verify_legal_field_name(name, CHECK);
1622 
1623     const u2 signature_index = cfs-&gt;get_u2_fast();
1624     check_property(valid_symbol_at(signature_index),
1625       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1626       signature_index, CHECK);
1627     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1628     verify_legal_field_signature(name, sig, CHECK);
1629 
1630     u2 constantvalue_index = 0;
1631     bool is_synthetic = false;
1632     u2 generic_signature_index = 0;
1633     const bool is_static = access_flags.is_static();
1634     FieldAnnotationCollector parsed_annotations(_loader_data);
1635 
1636     const u2 attributes_count = cfs-&gt;get_u2_fast();
1637     if (attributes_count &gt; 0) {
1638       parse_field_attributes(cfs,
1639                              attributes_count,
1640                              is_static,
1641                              signature_index,
1642                              &amp;constantvalue_index,
1643                              &amp;is_synthetic,
1644                              &amp;generic_signature_index,
1645                              &amp;parsed_annotations,
1646                              CHECK);
1647 
1648       if (parsed_annotations.field_annotations() != NULL) {
1649         if (_fields_annotations == NULL) {
1650           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1651                                              _loader_data, length, NULL,
1652                                              CHECK);
1653         }
1654         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1655         parsed_annotations.set_field_annotations(NULL);
1656       }
1657       if (parsed_annotations.field_type_annotations() != NULL) {
1658         if (_fields_type_annotations == NULL) {
1659           _fields_type_annotations =
1660             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1661                                                          length,
1662                                                          NULL,
1663                                                          CHECK);
1664         }
1665         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1666         parsed_annotations.set_field_type_annotations(NULL);
1667       }
1668 
1669       if (is_synthetic) {
1670         access_flags.set_is_synthetic();
1671       }
1672       if (generic_signature_index != 0) {
1673         access_flags.set_field_has_generic_signature();
1674         fa[generic_signature_slot] = generic_signature_index;
1675         generic_signature_slot ++;
1676         num_generic_signature ++;
1677       }
1678     }
1679 
1680     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1681     field-&gt;initialize(access_flags.as_short(),
1682                       name_index,
1683                       signature_index,
1684                       constantvalue_index);
1685     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1686 
1687     // Remember how many oops we encountered and compute allocation type
1688     const FieldAllocationType atype = fac-&gt;update(is_static, type);
1689     field-&gt;set_allocation_type(atype);
1690 
1691     // After field is initialized with type, we can augment it with aux info
1692     if (parsed_annotations.has_any_annotations())
1693       parsed_annotations.apply_to(field);
1694   }
1695 
1696   int index = length;
1697   if (num_injected != 0) {
1698     for (int n = 0; n &lt; num_injected; n++) {
1699       // Check for duplicates
1700       if (injected[n].may_be_java) {
1701         const Symbol* const name      = injected[n].name();
1702         const Symbol* const signature = injected[n].signature();
1703         bool duplicate = false;
1704         for (int i = 0; i &lt; length; i++) {
1705           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1706           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1707               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1708             // Symbol is desclared in Java so skip this one
1709             duplicate = true;
1710             break;
1711           }
1712         }
1713         if (duplicate) {
1714           // These will be removed from the field array at the end
1715           continue;
1716         }
1717       }
1718 
1719       // Injected field
1720       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1721       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1722                         injected[n].name_index,
1723                         injected[n].signature_index,
1724                         0);
1725 
1726       const BasicType type = FieldType::basic_type(injected[n].signature());
1727 
1728       // Remember how many oops we encountered and compute allocation type
1729       const FieldAllocationType atype = fac-&gt;update(false, type);
1730       field-&gt;set_allocation_type(atype);
1731       index++;
1732     }
1733   }
1734 
1735   assert(NULL == _fields, &quot;invariant&quot;);
1736 
1737   _fields =
1738     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1739                                    index * FieldInfo::field_slots + num_generic_signature,
1740                                    CHECK);
1741   // Sometimes injected fields already exist in the Java source so
1742   // the fields array could be too long.  In that case the
1743   // fields array is trimed. Also unused slots that were reserved
1744   // for generic signature indexes are discarded.
1745   {
1746     int i = 0;
1747     for (; i &lt; index * FieldInfo::field_slots; i++) {
1748       _fields-&gt;at_put(i, fa[i]);
1749     }
1750     for (int j = total_fields * FieldInfo::field_slots;
1751          j &lt; generic_signature_slot; j++) {
1752       _fields-&gt;at_put(i++, fa[j]);
1753     }
1754     assert(_fields-&gt;length() == i, &quot;&quot;);
1755   }
1756 
1757   if (_need_verify &amp;&amp; length &gt; 1) {
1758     // Check duplicated fields
1759     ResourceMark rm(THREAD);
1760     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1761       THREAD, NameSigHash*, HASH_ROW_SIZE);
1762     initialize_hashtable(names_and_sigs);
1763     bool dup = false;
1764     const Symbol* name = NULL;
1765     const Symbol* sig = NULL;
1766     {
1767       debug_only(NoSafepointVerifier nsv;)
1768       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1769         name = fs.name();
1770         sig = fs.signature();
1771         // If no duplicates, add name/signature in hashtable names_and_sigs.
1772         if (!put_after_lookup(name, sig, names_and_sigs)) {
1773           dup = true;
1774           break;
1775         }
1776       }
1777     }
1778     if (dup) {
1779       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1780                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1781     }
1782   }
1783 }
1784 
1785 
1786 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1787                                                                          u4 code_length,
1788                                                                          u4 exception_table_length,
1789                                                                          TRAPS) {
1790   assert(cfs != NULL, &quot;invariant&quot;);
1791 
1792   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1793   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1794 
1795   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1796                                                                // end_pc,
1797                                                                // handler_pc,
1798                                                                // catch_type_index
1799 
1800   // Will check legal target after parsing code array in verifier.
1801   if (_need_verify) {
1802     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1803       const u2 start_pc = cfs-&gt;get_u2_fast();
1804       const u2 end_pc = cfs-&gt;get_u2_fast();
1805       const u2 handler_pc = cfs-&gt;get_u2_fast();
1806       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1807       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1808                          &quot;Illegal exception table range in class file %s&quot;,
1809                          CHECK_NULL);
1810       guarantee_property(handler_pc &lt; code_length,
1811                          &quot;Illegal exception table handler in class file %s&quot;,
1812                          CHECK_NULL);
1813       if (catch_type_index != 0) {
1814         guarantee_property(valid_klass_reference_at(catch_type_index),
1815                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1816       }
1817     }
1818   } else {
1819     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1820   }
1821   return exception_table_start;
1822 }
1823 
1824 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1825                                              u4 code_length,
1826                                              CompressedLineNumberWriteStream**const write_stream,
1827                                              TRAPS) {
1828 
1829   const ClassFileStream* const cfs = _stream;
1830   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1831 
1832   // Each entry is a u2 start_pc, and a u2 line_number
1833   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1834 
1835   // Verify line number attribute and table length
1836   check_property(
1837     code_attribute_length == sizeof(u2) + length_in_bytes,
1838     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1839 
1840   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1841 
1842   if ((*write_stream) == NULL) {
1843     if (length_in_bytes &gt; fixed_buffer_size) {
1844       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1845     } else {
1846       (*write_stream) = new CompressedLineNumberWriteStream(
1847         _linenumbertable_buffer, fixed_buffer_size);
1848     }
1849   }
1850 
1851   while (num_entries-- &gt; 0) {
1852     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1853     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1854     guarantee_property(bci &lt; code_length,
1855         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1856     (*write_stream)-&gt;write_pair(bci, line);
1857   }
1858 }
1859 
1860 
1861 class LVT_Hash : public AllStatic {
1862  public:
1863 
1864   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1865   /*
1866    * 3-tuple start_bci/length/slot has to be unique key,
1867    * so the following comparison seems to be redundant:
1868    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1869    */
1870     return (e0.start_bci     == e1.start_bci &amp;&amp;
1871             e0.length        == e1.length &amp;&amp;
1872             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1873             e0.slot          == e1.slot);
1874   }
1875 
1876   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1877     unsigned int raw_hash = e0.start_bci;
1878 
1879     raw_hash = e0.length        + raw_hash * 37;
1880     raw_hash = e0.name_cp_index + raw_hash * 37;
1881     raw_hash = e0.slot          + raw_hash * 37;
1882 
1883     return raw_hash;
1884   }
1885 };
1886 
1887 
1888 // Class file LocalVariableTable elements.
1889 class Classfile_LVT_Element {
1890  public:
1891   u2 start_bci;
1892   u2 length;
1893   u2 name_cp_index;
1894   u2 descriptor_cp_index;
1895   u2 slot;
1896 };
1897 
1898 static void copy_lvt_element(const Classfile_LVT_Element* const src,
1899                              LocalVariableTableElement* const lvt) {
1900   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
1901   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
1902   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
1903   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
1904   lvt-&gt;signature_cp_index  = 0;
1905   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
1906 }
1907 
1908 // Function is used to parse both attributes:
1909 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
1910 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
1911                                                                              u4 code_length,
1912                                                                              u2 max_locals,
1913                                                                              u4 code_attribute_length,
1914                                                                              u2* const localvariable_table_length,
1915                                                                              bool isLVTT,
1916                                                                              TRAPS) {
1917   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
1918   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
1919   const unsigned int size =
1920     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
1921 
1922   const ConstantPool* const cp = _cp;
1923 
1924   // Verify local variable table attribute has right length
1925   if (_need_verify) {
1926     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
1927                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
1928   }
1929 
1930   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
1931   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
1932   if (!_need_verify) {
1933     cfs-&gt;skip_u2_fast(size);
1934   } else {
1935     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
1936     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
1937       const u2 start_pc = cfs-&gt;get_u2_fast();
1938       const u2 length = cfs-&gt;get_u2_fast();
1939       const u2 name_index = cfs-&gt;get_u2_fast();
1940       const u2 descriptor_index = cfs-&gt;get_u2_fast();
1941       const u2 index = cfs-&gt;get_u2_fast();
1942       // Assign to a u4 to avoid overflow
1943       const u4 end_pc = (u4)start_pc + (u4)length;
1944 
1945       if (start_pc &gt;= code_length) {
1946         classfile_parse_error(
1947           &quot;Invalid start_pc %u in %s in class file %s&quot;,
1948           start_pc, tbl_name, CHECK_NULL);
1949       }
1950       if (end_pc &gt; code_length) {
1951         classfile_parse_error(
1952           &quot;Invalid length %u in %s in class file %s&quot;,
1953           length, tbl_name, CHECK_NULL);
1954       }
1955       const int cp_size = cp-&gt;length();
1956       guarantee_property(valid_symbol_at(name_index),
1957         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
1958         name_index, tbl_name, CHECK_NULL);
1959       guarantee_property(valid_symbol_at(descriptor_index),
1960         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
1961         descriptor_index, tbl_name, CHECK_NULL);
1962 
1963       const Symbol* const name = cp-&gt;symbol_at(name_index);
1964       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
1965       verify_legal_field_name(name, CHECK_NULL);
1966       u2 extra_slot = 0;
1967       if (!isLVTT) {
1968         verify_legal_field_signature(name, sig, CHECK_NULL);
1969 
1970         // 4894874: check special cases for double and long local variables
1971         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
1972             sig == vmSymbols::type_signature(T_LONG)) {
1973           extra_slot = 1;
1974         }
1975       }
1976       guarantee_property((index + extra_slot) &lt; max_locals,
1977                           &quot;Invalid index %u in %s in class file %s&quot;,
1978                           index, tbl_name, CHECK_NULL);
1979     }
1980   }
1981   return localvariable_table_start;
1982 }
1983 
1984 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
1985                                       u4 code_attribute_length,
1986                                       bool need_verify,
1987                                       TRAPS) {
1988   assert(cfs != NULL, &quot;invariant&quot;);
1989 
1990   if (0 == code_attribute_length) {
1991     return NULL;
1992   }
1993 
1994   const u1* const stackmap_table_start = cfs-&gt;current();
1995   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
1996 
1997   // check code_attribute_length first
1998   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
1999 
2000   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2001     return NULL;
2002   }
2003   return stackmap_table_start;
2004 }
2005 
2006 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2007                                                                             u2* const checked_exceptions_length,
2008                                                                             u4 method_attribute_length,
2009                                                                             TRAPS) {
2010   assert(cfs != NULL, &quot;invariant&quot;);
2011   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2012 
2013   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2014   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2015   const unsigned int size =
2016     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2017   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2018   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2019   if (!_need_verify) {
2020     cfs-&gt;skip_u2_fast(size);
2021   } else {
2022     // Verify each value in the checked exception table
2023     u2 checked_exception;
2024     const u2 len = *checked_exceptions_length;
2025     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2026     for (int i = 0; i &lt; len; i++) {
2027       checked_exception = cfs-&gt;get_u2_fast();
2028       check_property(
2029         valid_klass_reference_at(checked_exception),
2030         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2031         checked_exception, CHECK_NULL);
2032     }
2033   }
2034   // check exceptions attribute length
2035   if (_need_verify) {
2036     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2037                                                    sizeof(u2) * size),
2038                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2039   }
2040   return checked_exceptions_start;
2041 }
2042 
2043 void ClassFileParser::throwIllegalSignature(const char* type,
2044                                             const Symbol* name,
2045                                             const Symbol* sig,
2046                                             TRAPS) const {
2047   assert(name != NULL, &quot;invariant&quot;);
2048   assert(sig != NULL, &quot;invariant&quot;);
2049 
2050   ResourceMark rm(THREAD);
2051   Exceptions::fthrow(THREAD_AND_LOCATION,
2052       vmSymbols::java_lang_ClassFormatError(),
2053       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,
2054       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());
2055 }
2056 
2057 AnnotationCollector::ID
2058 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2059                                       const Symbol* name) {
2060   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2061   // Privileged code can use all annotations.  Other code silently drops some.
2062   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2063                           loader_data-&gt;is_platform_class_loader_data() ||
2064                           loader_data-&gt;is_unsafe_anonymous();
2065   switch (sid) {
2066     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2067       if (_location != _in_method)  break;  // only allow for methods
2068       if (!privileged)              break;  // only allow in privileged code
2069       return _method_CallerSensitive;
2070     }
2071     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2072       if (_location != _in_method)  break;  // only allow for methods
2073       if (!privileged)              break;  // only allow in privileged code
2074       return _method_ForceInline;
2075     }
2076     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2077       if (_location != _in_method)  break;  // only allow for methods
2078       if (!privileged)              break;  // only allow in privileged code
2079       return _method_DontInline;
2080     }
2081     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2082       if (_location != _in_method)  break;  // only allow for methods
2083       if (!privileged)              break;  // only allow in privileged code
2084       return _method_InjectedProfile;
2085     }
2086     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2087       if (_location != _in_method)  break;  // only allow for methods
2088       if (!privileged)              break;  // only allow in privileged code
2089       return _method_LambdaForm_Compiled;
2090     }
2091     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2092       if (_location != _in_method)  break;  // only allow for methods
2093       if (!privileged)              break;  // only allow in privileged code
2094       return _method_Hidden;
2095     }
2096     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2097       if (_location != _in_method)  break;  // only allow for methods
2098       if (!privileged)              break;  // only allow in privileged code
2099       return _method_HotSpotIntrinsicCandidate;
2100     }
2101     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2102       if (_location != _in_field)   break;  // only allow for fields
2103       if (!privileged)              break;  // only allow in privileged code
2104       return _field_Stable;
2105     }
2106     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2107       if (_location != _in_field &amp;&amp; _location != _in_class) {
2108         break;  // only allow for fields and classes
2109       }
2110       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2111         break;  // honor privileges
2112       }
2113       return _jdk_internal_vm_annotation_Contended;
2114     }
2115     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2116       if (_location != _in_method)  break;  // only allow for methods
2117       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2118       return _jdk_internal_vm_annotation_ReservedStackAccess;
2119     }
2120     default: {
2121       break;
2122     }
2123   }
2124   return AnnotationCollector::_unknown;
2125 }
2126 
2127 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2128   if (is_contended())
2129     f-&gt;set_contended_group(contended_group());
2130   if (is_stable())
2131     f-&gt;set_stable(true);
2132 }
2133 
2134 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2135   // If there&#39;s an error deallocate metadata for field annotations
2136   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2137   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2138 }
2139 
2140 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2141   if (has_annotation(_method_CallerSensitive))
2142     m-&gt;set_caller_sensitive(true);
2143   if (has_annotation(_method_ForceInline))
2144     m-&gt;set_force_inline(true);
2145   if (has_annotation(_method_DontInline))
2146     m-&gt;set_dont_inline(true);
2147   if (has_annotation(_method_InjectedProfile))
2148     m-&gt;set_has_injected_profile(true);
2149   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2150     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2151   if (has_annotation(_method_Hidden))
2152     m-&gt;set_hidden(true);
2153   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2154     m-&gt;set_intrinsic_candidate(true);
2155   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2156     m-&gt;set_has_reserved_stack_access(true);
2157 }
2158 
2159 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2160   assert(ik != NULL, &quot;invariant&quot;);
2161   ik-&gt;set_is_contended(is_contended());
2162 }
2163 
2164 #define MAX_ARGS_SIZE 255
2165 #define MAX_CODE_SIZE 65535
2166 #define INITIAL_MAX_LVT_NUMBER 256
2167 
2168 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2169  *
2170  * Rules for LVT&#39;s and LVTT&#39;s are:
2171  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2172  *   - If there are n LVT&#39;s, it is the same as if there was just
2173  *     one LVT containing all the entries from the n LVT&#39;s.
2174  *   - There may be no more than one LVT entry per local variable.
2175  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2176  *        start_pc, length, name, slot
2177  *   - There may be no more than one LVTT entry per each LVT entry.
2178  *     Each LVTT entry has to match some LVT entry.
2179  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2180  */
2181 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2182                                                int lvt_cnt,
2183                                                u2* const localvariable_table_length,
2184                                                const unsafe_u2** const localvariable_table_start,
2185                                                int lvtt_cnt,
2186                                                u2* const localvariable_type_table_length,
2187                                                const unsafe_u2** const localvariable_type_table_start,
2188                                                TRAPS) {
2189 
2190   ResourceMark rm(THREAD);
2191 
2192   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2193                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2194 
2195   LVT_HashTable* const table = new LVT_HashTable();
2196 
2197   // To fill LocalVariableTable in
2198   const Classfile_LVT_Element* cf_lvt;
2199   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2200 
2201   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2202     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2203     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2204       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2205       // If no duplicates, add LVT elem in hashtable.
2206       if (table-&gt;put(*lvt, lvt) == false
2207           &amp;&amp; _need_verify
2208           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2209         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2210                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2211                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2212                                CHECK);
2213       }
2214     }
2215   }
2216 
2217   // To merge LocalVariableTable and LocalVariableTypeTable
2218   const Classfile_LVT_Element* cf_lvtt;
2219   LocalVariableTableElement lvtt_elem;
2220 
2221   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2222     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2223     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2224       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2225       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2226       if (entry == NULL) {
2227         if (_need_verify) {
2228           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2229                                 &quot;does not match any LVT entry&quot;,
2230                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2231                                  CHECK);
2232         }
2233       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2234         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2235                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2236                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2237                                CHECK);
2238       } else {
2239         // to add generic signatures into LocalVariableTable
2240         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2241       }
2242     }
2243   }
2244 }
2245 
2246 
2247 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2248                                        const u1* runtime_visible_annotations,
2249                                        int runtime_visible_annotations_length,
2250                                        const u1* runtime_invisible_annotations,
2251                                        int runtime_invisible_annotations_length,
2252                                        const u1* runtime_visible_parameter_annotations,
2253                                        int runtime_visible_parameter_annotations_length,
2254                                        const u1* runtime_invisible_parameter_annotations,
2255                                        int runtime_invisible_parameter_annotations_length,
2256                                        const u1* runtime_visible_type_annotations,
2257                                        int runtime_visible_type_annotations_length,
2258                                        const u1* runtime_invisible_type_annotations,
2259                                        int runtime_invisible_type_annotations_length,
2260                                        const u1* annotation_default,
2261                                        int annotation_default_length,
2262                                        TRAPS) {
2263 
2264   AnnotationArray* a;
2265 
2266   if (runtime_visible_annotations_length +
2267       runtime_invisible_annotations_length &gt; 0) {
2268      a = assemble_annotations(runtime_visible_annotations,
2269                               runtime_visible_annotations_length,
2270                               runtime_invisible_annotations,
2271                               runtime_invisible_annotations_length,
2272                               CHECK);
2273      cm-&gt;set_method_annotations(a);
2274   }
2275 
2276   if (runtime_visible_parameter_annotations_length +
2277       runtime_invisible_parameter_annotations_length &gt; 0) {
2278     a = assemble_annotations(runtime_visible_parameter_annotations,
2279                              runtime_visible_parameter_annotations_length,
2280                              runtime_invisible_parameter_annotations,
2281                              runtime_invisible_parameter_annotations_length,
2282                              CHECK);
2283     cm-&gt;set_parameter_annotations(a);
2284   }
2285 
2286   if (annotation_default_length &gt; 0) {
2287     a = assemble_annotations(annotation_default,
2288                              annotation_default_length,
2289                              NULL,
2290                              0,
2291                              CHECK);
2292     cm-&gt;set_default_annotations(a);
2293   }
2294 
2295   if (runtime_visible_type_annotations_length +
2296       runtime_invisible_type_annotations_length &gt; 0) {
2297     a = assemble_annotations(runtime_visible_type_annotations,
2298                              runtime_visible_type_annotations_length,
2299                              runtime_invisible_type_annotations,
2300                              runtime_invisible_type_annotations_length,
2301                              CHECK);
2302     cm-&gt;set_type_annotations(a);
2303   }
2304 }
2305 
2306 
2307 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2308 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2309 // Method* to save footprint, so we only know the size of the resulting Method* when the
2310 // entire method attribute is parsed.
2311 //
2312 // The promoted_flags parameter is used to pass relevant access_flags
2313 // from the method back up to the containing klass. These flag values
2314 // are added to klass&#39;s access_flags.
2315 
2316 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2317                                       bool is_interface,
2318                                       const ConstantPool* cp,
2319                                       AccessFlags* const promoted_flags,
2320                                       TRAPS) {
2321   assert(cfs != NULL, &quot;invariant&quot;);
2322   assert(cp != NULL, &quot;invariant&quot;);
2323   assert(promoted_flags != NULL, &quot;invariant&quot;);
2324 
2325   ResourceMark rm(THREAD);
2326   // Parse fixed parts:
2327   // access_flags, name_index, descriptor_index, attributes_count
2328   cfs-&gt;guarantee_more(8, CHECK_NULL);
2329 
2330   int flags = cfs-&gt;get_u2_fast();
2331   const u2 name_index = cfs-&gt;get_u2_fast();
2332   const int cp_size = cp-&gt;length();
2333   check_property(
2334     valid_symbol_at(name_index),
2335     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2336     name_index, CHECK_NULL);
2337   const Symbol* const name = cp-&gt;symbol_at(name_index);
2338   verify_legal_method_name(name, CHECK_NULL);
2339 
2340   const u2 signature_index = cfs-&gt;get_u2_fast();
2341   guarantee_property(
2342     valid_symbol_at(signature_index),
2343     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2344     signature_index, CHECK_NULL);
2345   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2346 
2347   if (name == vmSymbols::class_initializer_name()) {
2348     // We ignore the other access flags for a valid class initializer.
2349     // (JVM Spec 2nd ed., chapter 4.6)
2350     if (_major_version &lt; 51) { // backward compatibility
2351       flags = JVM_ACC_STATIC;
2352     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2353       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2354     } else {
2355       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2356     }
2357   } else {
2358     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);
2359   }
2360 
2361   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {
2362     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2363   }
2364 
2365   int args_size = -1;  // only used when _need_verify is true
2366   if (_need_verify) {
2367     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2368                  verify_legal_method_signature(name, signature, CHECK_NULL);
2369     if (args_size &gt; MAX_ARGS_SIZE) {
2370       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2371     }
2372   }
2373 
2374   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2375 
2376   // Default values for code and exceptions attribute elements
2377   u2 max_stack = 0;
2378   u2 max_locals = 0;
2379   u4 code_length = 0;
2380   const u1* code_start = 0;
2381   u2 exception_table_length = 0;
2382   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2383   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2384   u2 checked_exceptions_length = 0;
2385   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2386   CompressedLineNumberWriteStream* linenumber_table = NULL;
2387   int linenumber_table_length = 0;
2388   int total_lvt_length = 0;
2389   u2 lvt_cnt = 0;
2390   u2 lvtt_cnt = 0;
2391   bool lvt_allocated = false;
2392   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2393   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2394   u2* localvariable_table_length = NULL;
2395   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2396   u2* localvariable_type_table_length = NULL;
2397   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2398   int method_parameters_length = -1;
2399   const u1* method_parameters_data = NULL;
2400   bool method_parameters_seen = false;
2401   bool parsed_code_attribute = false;
2402   bool parsed_checked_exceptions_attribute = false;
2403   bool parsed_stackmap_attribute = false;
2404   // stackmap attribute - JDK1.5
2405   const u1* stackmap_data = NULL;
2406   int stackmap_data_length = 0;
2407   u2 generic_signature_index = 0;
2408   MethodAnnotationCollector parsed_annotations;
2409   const u1* runtime_visible_annotations = NULL;
2410   int runtime_visible_annotations_length = 0;
2411   const u1* runtime_invisible_annotations = NULL;
2412   int runtime_invisible_annotations_length = 0;
2413   const u1* runtime_visible_parameter_annotations = NULL;
2414   int runtime_visible_parameter_annotations_length = 0;
2415   const u1* runtime_invisible_parameter_annotations = NULL;
2416   int runtime_invisible_parameter_annotations_length = 0;
2417   const u1* runtime_visible_type_annotations = NULL;
2418   int runtime_visible_type_annotations_length = 0;
2419   const u1* runtime_invisible_type_annotations = NULL;
2420   int runtime_invisible_type_annotations_length = 0;
2421   bool runtime_invisible_annotations_exists = false;
2422   bool runtime_invisible_type_annotations_exists = false;
2423   bool runtime_invisible_parameter_annotations_exists = false;
2424   const u1* annotation_default = NULL;
2425   int annotation_default_length = 0;
2426 
2427   // Parse code and exceptions attribute
2428   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2429   while (method_attributes_count--) {
2430     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2431     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2432     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2433     check_property(
2434       valid_symbol_at(method_attribute_name_index),
2435       &quot;Invalid method attribute name index %u in class file %s&quot;,
2436       method_attribute_name_index, CHECK_NULL);
2437 
2438     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2439     if (method_attribute_name == vmSymbols::tag_code()) {
2440       // Parse Code attribute
2441       if (_need_verify) {
2442         guarantee_property(
2443             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2444                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2445                          CHECK_NULL);
2446       }
2447       if (parsed_code_attribute) {
2448         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2449                               CHECK_NULL);
2450       }
2451       parsed_code_attribute = true;
2452 
2453       // Stack size, locals size, and code size
2454       cfs-&gt;guarantee_more(8, CHECK_NULL);
2455       max_stack = cfs-&gt;get_u2_fast();
2456       max_locals = cfs-&gt;get_u2_fast();
2457       code_length = cfs-&gt;get_u4_fast();
2458       if (_need_verify) {
2459         guarantee_property(args_size &lt;= max_locals,
2460                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2461                            CHECK_NULL);
2462         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2463                            &quot;Invalid method Code length %u in class file %s&quot;,
2464                            code_length, CHECK_NULL);
2465       }
2466       // Code pointer
2467       code_start = cfs-&gt;current();
2468       assert(code_start != NULL, &quot;null code start&quot;);
2469       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2470       cfs-&gt;skip_u1_fast(code_length);
2471 
2472       // Exception handler table
2473       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2474       exception_table_length = cfs-&gt;get_u2_fast();
2475       if (exception_table_length &gt; 0) {
2476         exception_table_start = parse_exception_table(cfs,
2477                                                       code_length,
2478                                                       exception_table_length,
2479                                                       CHECK_NULL);
2480       }
2481 
2482       // Parse additional attributes in code attribute
2483       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2484       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2485 
2486       unsigned int calculated_attribute_length = 0;
2487 
2488       calculated_attribute_length =
2489           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2490       calculated_attribute_length +=
2491         code_length +
2492         sizeof(exception_table_length) +
2493         sizeof(code_attributes_count) +
2494         exception_table_length *
2495             ( sizeof(u2) +   // start_pc
2496               sizeof(u2) +   // end_pc
2497               sizeof(u2) +   // handler_pc
2498               sizeof(u2) );  // catch_type_index
2499 
2500       while (code_attributes_count--) {
2501         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2502         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2503         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2504         calculated_attribute_length += code_attribute_length +
2505                                        sizeof(code_attribute_name_index) +
2506                                        sizeof(code_attribute_length);
2507         check_property(valid_symbol_at(code_attribute_name_index),
2508                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2509                        code_attribute_name_index,
2510                        CHECK_NULL);
2511         if (LoadLineNumberTables &amp;&amp;
2512             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2513           // Parse and compress line number table
2514           parse_linenumber_table(code_attribute_length,
2515                                  code_length,
2516                                  &amp;linenumber_table,
2517                                  CHECK_NULL);
2518 
2519         } else if (LoadLocalVariableTables &amp;&amp;
2520                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2521           // Parse local variable table
2522           if (!lvt_allocated) {
2523             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2524               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2525             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2526               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2527             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2528               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2529             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2530               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2531             lvt_allocated = true;
2532           }
2533           if (lvt_cnt == max_lvt_cnt) {
2534             max_lvt_cnt &lt;&lt;= 1;
2535             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2536             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2537           }
2538           localvariable_table_start[lvt_cnt] =
2539             parse_localvariable_table(cfs,
2540                                       code_length,
2541                                       max_locals,
2542                                       code_attribute_length,
2543                                       &amp;localvariable_table_length[lvt_cnt],
2544                                       false,    // is not LVTT
2545                                       CHECK_NULL);
2546           total_lvt_length += localvariable_table_length[lvt_cnt];
2547           lvt_cnt++;
2548         } else if (LoadLocalVariableTypeTables &amp;&amp;
2549                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2550                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2551           if (!lvt_allocated) {
2552             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2553               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2554             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2555               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2556             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2557               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2558             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2559               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2560             lvt_allocated = true;
2561           }
2562           // Parse local variable type table
2563           if (lvtt_cnt == max_lvtt_cnt) {
2564             max_lvtt_cnt &lt;&lt;= 1;
2565             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2566             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2567           }
2568           localvariable_type_table_start[lvtt_cnt] =
2569             parse_localvariable_table(cfs,
2570                                       code_length,
2571                                       max_locals,
2572                                       code_attribute_length,
2573                                       &amp;localvariable_type_table_length[lvtt_cnt],
2574                                       true,     // is LVTT
2575                                       CHECK_NULL);
2576           lvtt_cnt++;
2577         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2578                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2579           // Stack map is only needed by the new verifier in JDK1.5.
2580           if (parsed_stackmap_attribute) {
2581             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2582           }
2583           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2584           stackmap_data_length = code_attribute_length;
2585           parsed_stackmap_attribute = true;
2586         } else {
2587           // Skip unknown attributes
2588           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2589         }
2590       }
2591       // check method attribute length
2592       if (_need_verify) {
2593         guarantee_property(method_attribute_length == calculated_attribute_length,
2594                            &quot;Code segment has wrong length in class file %s&quot;,
2595                            CHECK_NULL);
2596       }
2597     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2598       // Parse Exceptions attribute
2599       if (parsed_checked_exceptions_attribute) {
2600         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2601                               CHECK_NULL);
2602       }
2603       parsed_checked_exceptions_attribute = true;
2604       checked_exceptions_start =
2605             parse_checked_exceptions(cfs,
2606                                      &amp;checked_exceptions_length,
2607                                      method_attribute_length,
2608                                      CHECK_NULL);
2609     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2610       // reject multiple method parameters
2611       if (method_parameters_seen) {
2612         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2613                               CHECK_NULL);
2614       }
2615       method_parameters_seen = true;
2616       method_parameters_length = cfs-&gt;get_u1_fast();
2617       const u2 real_length = (method_parameters_length * 4u) + 1u;
2618       if (method_attribute_length != real_length) {
2619         classfile_parse_error(
2620           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2621           method_attribute_length, CHECK_NULL);
2622       }
2623       method_parameters_data = cfs-&gt;current();
2624       cfs-&gt;skip_u2_fast(method_parameters_length);
2625       cfs-&gt;skip_u2_fast(method_parameters_length);
2626       // ignore this attribute if it cannot be reflected
2627       if (!SystemDictionary::Parameter_klass_loaded())
2628         method_parameters_length = -1;
2629     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2630       if (method_attribute_length != 0) {
2631         classfile_parse_error(
2632           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2633           method_attribute_length, CHECK_NULL);
2634       }
2635       // Should we check that there hasn&#39;t already been a synthetic attribute?
2636       access_flags.set_is_synthetic();
2637     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2638       if (method_attribute_length != 0) {
2639         classfile_parse_error(
2640           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2641           method_attribute_length, CHECK_NULL);
2642       }
2643     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2644       if (method_attribute_name == vmSymbols::tag_signature()) {
2645         if (generic_signature_index != 0) {
2646           classfile_parse_error(
2647             &quot;Multiple Signature attributes for method in class file %s&quot;,
2648             CHECK_NULL);
2649         }
2650         if (method_attribute_length != 2) {
2651           classfile_parse_error(
2652             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2653             method_attribute_length, CHECK_NULL);
2654         }
2655         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2656       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2657         if (runtime_visible_annotations != NULL) {
2658           classfile_parse_error(
2659             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2660             CHECK_NULL);
2661         }
2662         runtime_visible_annotations_length = method_attribute_length;
2663         runtime_visible_annotations = cfs-&gt;current();
2664         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2665         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2666         parse_annotations(cp,
2667                           runtime_visible_annotations,
2668                           runtime_visible_annotations_length,
2669                           &amp;parsed_annotations,
2670                           _loader_data,
2671                           CHECK_NULL);
2672         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2673       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2674         if (runtime_invisible_annotations_exists) {
2675           classfile_parse_error(
2676             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2677             CHECK_NULL);
2678         }
2679         runtime_invisible_annotations_exists = true;
2680         if (PreserveAllAnnotations) {
2681           runtime_invisible_annotations_length = method_attribute_length;
2682           runtime_invisible_annotations = cfs-&gt;current();
2683           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2684         }
2685         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2686       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2687         if (runtime_visible_parameter_annotations != NULL) {
2688           classfile_parse_error(
2689             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2690             CHECK_NULL);
2691         }
2692         runtime_visible_parameter_annotations_length = method_attribute_length;
2693         runtime_visible_parameter_annotations = cfs-&gt;current();
2694         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2695         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2696       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2697         if (runtime_invisible_parameter_annotations_exists) {
2698           classfile_parse_error(
2699             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2700             CHECK_NULL);
2701         }
2702         runtime_invisible_parameter_annotations_exists = true;
2703         if (PreserveAllAnnotations) {
2704           runtime_invisible_parameter_annotations_length = method_attribute_length;
2705           runtime_invisible_parameter_annotations = cfs-&gt;current();
2706           assert(runtime_invisible_parameter_annotations != NULL,
2707             &quot;null invisible parameter annotations&quot;);
2708         }
2709         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2710       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2711         if (annotation_default != NULL) {
2712           classfile_parse_error(
2713             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2714             CHECK_NULL);
2715         }
2716         annotation_default_length = method_attribute_length;
2717         annotation_default = cfs-&gt;current();
2718         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2719         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2720       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2721         if (runtime_visible_type_annotations != NULL) {
2722           classfile_parse_error(
2723             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2724             CHECK_NULL);
2725         }
2726         runtime_visible_type_annotations_length = method_attribute_length;
2727         runtime_visible_type_annotations = cfs-&gt;current();
2728         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2729         // No need for the VM to parse Type annotations
2730         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2731       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2732         if (runtime_invisible_type_annotations_exists) {
2733           classfile_parse_error(
2734             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2735             CHECK_NULL);
2736         } else {
2737           runtime_invisible_type_annotations_exists = true;
2738         }
2739         if (PreserveAllAnnotations) {
2740           runtime_invisible_type_annotations_length = method_attribute_length;
2741           runtime_invisible_type_annotations = cfs-&gt;current();
2742           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2743         }
2744         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2745       } else {
2746         // Skip unknown attributes
2747         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2748       }
2749     } else {
2750       // Skip unknown attributes
2751       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2752     }
2753   }
2754 
2755   if (linenumber_table != NULL) {
2756     linenumber_table-&gt;write_terminator();
2757     linenumber_table_length = linenumber_table-&gt;position();
2758   }
2759 
2760   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2761   if (_need_verify) {
2762     guarantee_property(access_flags.is_native() ||
2763                        access_flags.is_abstract() ||
2764                        parsed_code_attribute,
2765                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2766                        CHECK_NULL);
2767   }
2768 
2769   // All sizing information for a Method* is finally available, now create it
2770   InlineTableSizes sizes(
2771       total_lvt_length,
2772       linenumber_table_length,
2773       exception_table_length,
2774       checked_exceptions_length,
2775       method_parameters_length,
2776       generic_signature_index,
2777       runtime_visible_annotations_length +
2778            runtime_invisible_annotations_length,
2779       runtime_visible_parameter_annotations_length +
2780            runtime_invisible_parameter_annotations_length,
2781       runtime_visible_type_annotations_length +
2782            runtime_invisible_type_annotations_length,
2783       annotation_default_length,
2784       0);
2785 
2786   Method* const m = Method::allocate(_loader_data,
2787                                      code_length,
2788                                      access_flags,
2789                                      &amp;sizes,
2790                                      ConstMethod::NORMAL,
2791                                      CHECK_NULL);
2792 
2793   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2794 
2795   // Fill in information from fixed part (access_flags already set)
2796   m-&gt;set_constants(_cp);
2797   m-&gt;set_name_index(name_index);
2798   m-&gt;set_signature_index(signature_index);
2799 
2800   ResultTypeFinder rtf(cp-&gt;symbol_at(signature_index));
2801   m-&gt;constMethod()-&gt;set_result_type(rtf.type());
2802 
2803   if (args_size &gt;= 0) {
2804     m-&gt;set_size_of_parameters(args_size);
2805   } else {
2806     m-&gt;compute_size_of_parameters(THREAD);
2807   }
2808 #ifdef ASSERT
2809   if (args_size &gt;= 0) {
2810     m-&gt;compute_size_of_parameters(THREAD);
2811     assert(args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2812   }
2813 #endif
2814 
2815   // Fill in code attribute information
2816   m-&gt;set_max_stack(max_stack);
2817   m-&gt;set_max_locals(max_locals);
2818   if (stackmap_data != NULL) {
2819     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2820                                          (u1*)stackmap_data,
2821                                          stackmap_data_length,
2822                                          CHECK_NULL);
2823   }
2824 
2825   // Copy byte codes
2826   m-&gt;set_code((u1*)code_start);
2827 
2828   // Copy line number table
2829   if (linenumber_table != NULL) {
2830     memcpy(m-&gt;compressed_linenumber_table(),
2831            linenumber_table-&gt;buffer(),
2832            linenumber_table_length);
2833   }
2834 
2835   // Copy exception table
2836   if (exception_table_length &gt; 0) {
2837     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2838                                                 m-&gt;exception_table_start(),
2839                                                 exception_table_length * sizeof(ExceptionTableElement),
2840                                                 sizeof(u2));
2841   }
2842 
2843   // Copy method parameters
2844   if (method_parameters_length &gt; 0) {
2845     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2846     for (int i = 0; i &lt; method_parameters_length; i++) {
2847       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2848       method_parameters_data += 2;
2849       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2850       method_parameters_data += 2;
2851     }
2852   }
2853 
2854   // Copy checked exceptions
2855   if (checked_exceptions_length &gt; 0) {
2856     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2857                                                 m-&gt;checked_exceptions_start(),
2858                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2859                                                 sizeof(u2));
2860   }
2861 
2862   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2863   if (total_lvt_length &gt; 0) {
2864     promoted_flags-&gt;set_has_localvariable_table();
2865     copy_localvariable_table(m-&gt;constMethod(),
2866                              lvt_cnt,
2867                              localvariable_table_length,
2868                              localvariable_table_start,
2869                              lvtt_cnt,
2870                              localvariable_type_table_length,
2871                              localvariable_type_table_start,
2872                              CHECK_NULL);
2873   }
2874 
2875   if (parsed_annotations.has_any_annotations())
2876     parsed_annotations.apply_to(methodHandle(THREAD, m));
2877 
2878   // Copy annotations
2879   copy_method_annotations(m-&gt;constMethod(),
2880                           runtime_visible_annotations,
2881                           runtime_visible_annotations_length,
2882                           runtime_invisible_annotations,
2883                           runtime_invisible_annotations_length,
2884                           runtime_visible_parameter_annotations,
2885                           runtime_visible_parameter_annotations_length,
2886                           runtime_invisible_parameter_annotations,
2887                           runtime_invisible_parameter_annotations_length,
2888                           runtime_visible_type_annotations,
2889                           runtime_visible_type_annotations_length,
2890                           runtime_invisible_type_annotations,
2891                           runtime_invisible_type_annotations_length,
2892                           annotation_default,
2893                           annotation_default_length,
2894                           CHECK_NULL);
2895 
2896   if (name == vmSymbols::finalize_method_name() &amp;&amp;
2897       signature == vmSymbols::void_method_signature()) {
2898     if (m-&gt;is_empty_method()) {
2899       _has_empty_finalizer = true;
2900     } else {
2901       _has_finalizer = true;
2902     }
2903   }
2904   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2905       signature == vmSymbols::void_method_signature() &amp;&amp;
2906       m-&gt;is_vanilla_constructor()) {
2907     _has_vanilla_constructor = true;
2908   }
2909 
2910   NOT_PRODUCT(m-&gt;verify());
2911   return m;
2912 }
2913 
2914 
2915 // The promoted_flags parameter is used to pass relevant access_flags
2916 // from the methods back up to the containing klass. These flag values
2917 // are added to klass&#39;s access_flags.
2918 // Side-effects: populates the _methods field in the parser
2919 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2920                                     bool is_interface,
2921                                     AccessFlags* promoted_flags,
2922                                     bool* has_final_method,
2923                                     bool* declares_nonstatic_concrete_methods,
2924                                     TRAPS) {
2925   assert(cfs != NULL, &quot;invariant&quot;);
2926   assert(promoted_flags != NULL, &quot;invariant&quot;);
2927   assert(has_final_method != NULL, &quot;invariant&quot;);
2928   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2929 
2930   assert(NULL == _methods, &quot;invariant&quot;);
2931 
2932   cfs-&gt;guarantee_more(2, CHECK);  // length
2933   const u2 length = cfs-&gt;get_u2_fast();
2934   if (length == 0) {
2935     _methods = Universe::the_empty_method_array();
2936   } else {
2937     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2938                                                    length,
2939                                                    NULL,
2940                                                    CHECK);
2941 
2942     for (int index = 0; index &lt; length; index++) {
2943       Method* method = parse_method(cfs,
2944                                     is_interface,
2945                                     _cp,
2946                                     promoted_flags,
2947                                     CHECK);
2948 
2949       if (method-&gt;is_final()) {
2950         *has_final_method = true;
2951       }
2952       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2953       // used for interface initialization, and default method inheritance analysis
2954       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2955         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2956         *declares_nonstatic_concrete_methods = true;
2957       }
2958       _methods-&gt;at_put(index, method);
2959     }
2960 
2961     if (_need_verify &amp;&amp; length &gt; 1) {
2962       // Check duplicated methods
2963       ResourceMark rm(THREAD);
2964       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
2965         THREAD, NameSigHash*, HASH_ROW_SIZE);
2966       initialize_hashtable(names_and_sigs);
2967       bool dup = false;
2968       const Symbol* name = NULL;
2969       const Symbol* sig = NULL;
2970       {
2971         debug_only(NoSafepointVerifier nsv;)
2972         for (int i = 0; i &lt; length; i++) {
2973           const Method* const m = _methods-&gt;at(i);
2974           name = m-&gt;name();
2975           sig = m-&gt;signature();
2976           // If no duplicates, add name/signature in hashtable names_and_sigs.
2977           if (!put_after_lookup(name, sig, names_and_sigs)) {
2978             dup = true;
2979             break;
2980           }
2981         }
2982       }
2983       if (dup) {
2984         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
2985                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
2986       }
2987     }
2988   }
2989 }
2990 
2991 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
2992   const int length = methods-&gt;length();
2993   // If JVMTI original method ordering or sharing is enabled we have to
2994   // remember the original class file ordering.
2995   // We temporarily use the vtable_index field in the Method* to store the
2996   // class file index, so we can read in after calling qsort.
2997   // Put the method ordering in the shared archive.
2998   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
2999     for (int index = 0; index &lt; length; index++) {
3000       Method* const m = methods-&gt;at(index);
3001       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3002       m-&gt;set_vtable_index(index);
3003     }
3004   }
3005   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3006   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3007   Method::sort_methods(methods);
3008 
3009   intArray* method_ordering = NULL;
3010   // If JVMTI original method ordering or sharing is enabled construct int
3011   // array remembering the original ordering
3012   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3013     method_ordering = new intArray(length, length, -1);
3014     for (int index = 0; index &lt; length; index++) {
3015       Method* const m = methods-&gt;at(index);
3016       const int old_index = m-&gt;vtable_index();
3017       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3018       method_ordering-&gt;at_put(index, old_index);
3019       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3020     }
3021   }
3022   return method_ordering;
3023 }
3024 
3025 // Parse generic_signature attribute for methods and fields
3026 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3027                                                       TRAPS) {
3028   assert(cfs != NULL, &quot;invariant&quot;);
3029 
3030   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3031   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3032   check_property(
3033     valid_symbol_at(generic_signature_index),
3034     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3035     generic_signature_index, CHECK_0);
3036   return generic_signature_index;
3037 }
3038 
3039 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3040                                                            TRAPS) {
3041 
3042   assert(cfs != NULL, &quot;invariant&quot;);
3043 
3044   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3045   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3046   check_property(
3047     valid_symbol_at(sourcefile_index),
3048     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3049     sourcefile_index, CHECK);
3050   set_class_sourcefile_index(sourcefile_index);
3051 }
3052 
3053 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3054                                                                        int length,
3055                                                                        TRAPS) {
3056   assert(cfs != NULL, &quot;invariant&quot;);
3057 
3058   const u1* const sde_buffer = cfs-&gt;current();
3059   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3060 
3061   // Don&#39;t bother storing it if there is no way to retrieve it
3062   if (JvmtiExport::can_get_source_debug_extension()) {
3063     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3064     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3065     for (int i = 0; i &lt; length; i++) {
3066       sde[i] = sde_buffer[i];
3067     }
3068     sde[length] = &#39;\0&#39;;
3069     set_class_sde_buffer((const char*)sde, length);
3070   }
3071   // Got utf8 string, set stream position forward
3072   cfs-&gt;skip_u1(length, CHECK);
3073 }
3074 
3075 
3076 // Inner classes can be static, private or protected (classic VM does this)
3077 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3078                                            JVM_ACC_PRIVATE |                \
3079                                            JVM_ACC_PROTECTED |              \
3080                                            JVM_ACC_STATIC                   \
3081                                          )
3082 
3083 // Return number of classes in the inner classes attribute table
3084 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3085                                                             const u1* const inner_classes_attribute_start,
3086                                                             bool parsed_enclosingmethod_attribute,
3087                                                             u2 enclosing_method_class_index,
3088                                                             u2 enclosing_method_method_index,
3089                                                             TRAPS) {
3090   const u1* const current_mark = cfs-&gt;current();
3091   u2 length = 0;
3092   if (inner_classes_attribute_start != NULL) {
3093     cfs-&gt;set_current(inner_classes_attribute_start);
3094     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3095     length = cfs-&gt;get_u2_fast();
3096   }
3097 
3098   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3099   // method data:
3100   //   [inner_class_info_index,
3101   //    outer_class_info_index,
3102   //    inner_name_index,
3103   //    inner_class_access_flags,
3104   //    ...
3105   //    enclosing_method_class_index,
3106   //    enclosing_method_method_index]
3107   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3108   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3109   _inner_classes = inner_classes;
3110 
3111   int index = 0;
3112   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3113   for (int n = 0; n &lt; length; n++) {
3114     // Inner class index
3115     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3116     check_property(
3117       valid_klass_reference_at(inner_class_info_index),
3118       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3119       inner_class_info_index, CHECK_0);
3120     // Outer class index
3121     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3122     check_property(
3123       outer_class_info_index == 0 ||
3124         valid_klass_reference_at(outer_class_info_index),
3125       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3126       outer_class_info_index, CHECK_0);
3127     // Inner class name
3128     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3129     check_property(
3130       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3131       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3132       inner_name_index, CHECK_0);
3133     if (_need_verify) {
3134       guarantee_property(inner_class_info_index != outer_class_info_index,
3135                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3136     }
3137     // Access flags
3138     jint flags;
3139     // JVM_ACC_MODULE is defined in JDK-9 and later.
3140     if (_major_version &gt;= JAVA_9_VERSION) {
3141       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);
3142     } else {
3143       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;
3144     }
3145     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3146       // Set abstract bit for old class files for backward compatibility
3147       flags |= JVM_ACC_ABSTRACT;
3148     }
3149     verify_legal_class_modifiers(flags, CHECK_0);
3150     AccessFlags inner_access_flags(flags);
3151 
3152     inner_classes-&gt;at_put(index++, inner_class_info_index);
3153     inner_classes-&gt;at_put(index++, outer_class_info_index);
3154     inner_classes-&gt;at_put(index++, inner_name_index);
3155     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3156   }
3157 
3158   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3159   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3160     for(int i = 0; i &lt; length * 4; i += 4) {
3161       for(int j = i + 4; j &lt; length * 4; j += 4) {
3162         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3163                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3164                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3165                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3166                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3167                             CHECK_0);
3168       }
3169     }
3170   }
3171 
3172   // Set EnclosingMethod class and method indexes.
3173   if (parsed_enclosingmethod_attribute) {
3174     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3175     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3176   }
3177   assert(index == size, &quot;wrong size&quot;);
3178 
3179   // Restore buffer&#39;s current position.
3180   cfs-&gt;set_current(current_mark);
3181 
3182   return length;
3183 }
3184 
3185 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3186                                                            const u1* const nest_members_attribute_start,
3187                                                            TRAPS) {
3188   const u1* const current_mark = cfs-&gt;current();
3189   u2 length = 0;
3190   if (nest_members_attribute_start != NULL) {
3191     cfs-&gt;set_current(nest_members_attribute_start);
3192     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3193     length = cfs-&gt;get_u2_fast();
3194   }
3195   const int size = length;
3196   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3197   _nest_members = nest_members;
3198 
3199   int index = 0;
3200   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3201   for (int n = 0; n &lt; length; n++) {
3202     const u2 class_info_index = cfs-&gt;get_u2_fast();
3203     check_property(
3204       valid_klass_reference_at(class_info_index),
3205       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3206       class_info_index, CHECK_0);
3207     nest_members-&gt;at_put(index++, class_info_index);
3208   }
3209   assert(index == size, &quot;wrong size&quot;);
3210 
3211   // Restore buffer&#39;s current position.
3212   cfs-&gt;set_current(current_mark);
3213 
3214   return length;
3215 }
3216 
3217 //  Record {
3218 //    u2 attribute_name_index;
3219 //    u4 attribute_length;
3220 //    u2 components_count;
3221 //    component_info components[components_count];
3222 //  }
3223 //  component_info {
3224 //    u2 name_index;
3225 //    u2 descriptor_index
3226 //    u2 attributes_count;
3227 //    attribute_info_attributes[attributes_count];
3228 //  }
3229 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3230                                                      const ConstantPool* cp,
3231                                                      const u1* const record_attribute_start,
3232                                                      TRAPS) {
3233   const u1* const current_mark = cfs-&gt;current();
3234   int components_count = 0;
3235   unsigned int calculate_attr_size = 0;
3236   if (record_attribute_start != NULL) {
3237     cfs-&gt;set_current(record_attribute_start);
3238     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3239     components_count = (int)cfs-&gt;get_u2_fast();
3240     calculate_attr_size = 2;
3241   }
3242 
3243   Array&lt;RecordComponent*&gt;* const record_components =
3244     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3245   _record_components = record_components;
3246 
3247   for (int x = 0; x &lt; components_count; x++) {
3248     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3249 
3250     const u2 name_index = cfs-&gt;get_u2_fast();
3251     check_property(valid_symbol_at(name_index),
3252       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3253       name_index, CHECK_0);
3254     const Symbol* const name = cp-&gt;symbol_at(name_index);
3255     verify_legal_field_name(name, CHECK_0);
3256 
3257     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3258     check_property(valid_symbol_at(descriptor_index),
3259       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3260       descriptor_index, CHECK_0);
3261     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3262     verify_legal_field_signature(name, descr, CHECK_0);
3263 
3264     const u2 attributes_count = cfs-&gt;get_u2_fast();
3265     calculate_attr_size += 6;
3266     u2 generic_sig_index = 0;
3267     const u1* runtime_visible_annotations = NULL;
3268     int runtime_visible_annotations_length = 0;
3269     const u1* runtime_invisible_annotations = NULL;
3270     int runtime_invisible_annotations_length = 0;
3271     bool runtime_invisible_annotations_exists = false;
3272     const u1* runtime_visible_type_annotations = NULL;
3273     int runtime_visible_type_annotations_length = 0;
3274     const u1* runtime_invisible_type_annotations = NULL;
3275     int runtime_invisible_type_annotations_length = 0;
3276     bool runtime_invisible_type_annotations_exists = false;
3277 
3278     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3279     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3280     for (int y = 0; y &lt; attributes_count; y++) {
3281       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3282       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3283       const u4 attribute_length = cfs-&gt;get_u4_fast();
3284       calculate_attr_size += 6;
3285       check_property(
3286         valid_symbol_at(attribute_name_index),
3287         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3288         attribute_name_index, CHECK_0);
3289 
3290       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3291       if (attribute_name == vmSymbols::tag_signature()) {
3292         if (generic_sig_index != 0) {
3293           classfile_parse_error(
3294             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3295             CHECK_0);
3296         }
3297         if (attribute_length != 2) {
3298           classfile_parse_error(
3299             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3300             attribute_length, CHECK_0);
3301         }
3302         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3303 
3304       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3305         if (runtime_visible_annotations != NULL) {
3306           classfile_parse_error(
3307             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3308         }
3309         runtime_visible_annotations_length = attribute_length;
3310         runtime_visible_annotations = cfs-&gt;current();
3311 
3312         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3313         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3314         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3315 
3316       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3317         if (runtime_invisible_annotations_exists) {
3318           classfile_parse_error(
3319             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3320         }
3321         runtime_invisible_annotations_exists = true;
3322         if (PreserveAllAnnotations) {
3323           runtime_invisible_annotations_length = attribute_length;
3324           runtime_invisible_annotations = cfs-&gt;current();
3325           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3326         }
3327         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3328 
3329       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3330         if (runtime_visible_type_annotations != NULL) {
3331           classfile_parse_error(
3332             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3333         }
3334         runtime_visible_type_annotations_length = attribute_length;
3335         runtime_visible_type_annotations = cfs-&gt;current();
3336 
3337         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3338         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3339         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3340 
3341       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3342         if (runtime_invisible_type_annotations_exists) {
3343           classfile_parse_error(
3344             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3345         }
3346         runtime_invisible_type_annotations_exists = true;
3347         if (PreserveAllAnnotations) {
3348           runtime_invisible_type_annotations_length = attribute_length;
3349           runtime_invisible_type_annotations = cfs-&gt;current();
3350           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3351         }
3352         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3353 
3354       } else {
3355         // Skip unknown attributes
3356         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3357       }
3358       calculate_attr_size += attribute_length;
3359     } // End of attributes For loop
3360 
3361     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3362                                                         runtime_visible_annotations_length,
3363                                                         runtime_invisible_annotations,
3364                                                         runtime_invisible_annotations_length,
3365                                                         CHECK_0);
3366     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3367                                                              runtime_visible_type_annotations_length,
3368                                                              runtime_invisible_type_annotations,
3369                                                              runtime_invisible_type_annotations_length,
3370                                                              CHECK_0);
3371 
3372     RecordComponent* record_component =
3373       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3374                                 attributes_count, generic_sig_index,
3375                                 annotations, type_annotations, CHECK_0);
3376     record_components-&gt;at_put(x, record_component);
3377   }  // End of component processing loop
3378 
3379   // Restore buffer&#39;s current position.
3380   cfs-&gt;set_current(current_mark);
3381   return calculate_attr_size;
3382 }
3383 
3384 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3385   set_class_synthetic_flag(true);
3386 }
3387 
3388 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3389   assert(cfs != NULL, &quot;invariant&quot;);
3390 
3391   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3392   check_property(
3393     valid_symbol_at(signature_index),
3394     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3395     signature_index, CHECK);
3396   set_class_generic_signature_index(signature_index);
3397 }
3398 
3399 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3400                                                                   ConstantPool* cp,
3401                                                                   u4 attribute_byte_length,
3402                                                                   TRAPS) {
3403   assert(cfs != NULL, &quot;invariant&quot;);
3404   assert(cp != NULL, &quot;invariant&quot;);
3405 
3406   const u1* const current_start = cfs-&gt;current();
3407 
3408   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3409                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3410                      attribute_byte_length,
3411                      CHECK);
3412 
3413   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3414 
3415   const int attribute_array_length = cfs-&gt;get_u2_fast();
3416 
3417   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3418                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3419                      CHECK);
3420 
3421 
3422   // The attribute contains a counted array of counted tuples of shorts,
3423   // represending bootstrap specifiers:
3424   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3425   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3426   // operand_count = number of shorts in attr, except for leading length
3427 
3428   // The attribute is copied into a short[] array.
3429   // The array begins with a series of short[2] pairs, one for each tuple.
3430   const int index_size = (attribute_array_length * 2);
3431 
3432   Array&lt;u2&gt;* const operands =
3433     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3434 
3435   // Eagerly assign operands so they will be deallocated with the constant
3436   // pool if there is an error.
3437   cp-&gt;set_operands(operands);
3438 
3439   int operand_fill_index = index_size;
3440   const int cp_size = cp-&gt;length();
3441 
3442   for (int n = 0; n &lt; attribute_array_length; n++) {
3443     // Store a 32-bit offset into the header of the operand array.
3444     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3445 
3446     // Read a bootstrap specifier.
3447     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3448     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3449     const u2 argument_count = cfs-&gt;get_u2_fast();
3450     check_property(
3451       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3452       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3453       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3454       bootstrap_method_index,
3455       CHECK);
3456 
3457     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3458       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3459       CHECK);
3460 
3461     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3462     operands-&gt;at_put(operand_fill_index++, argument_count);
3463 
3464     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3465     for (int j = 0; j &lt; argument_count; j++) {
3466       const u2 argument_index = cfs-&gt;get_u2_fast();
3467       check_property(
3468         valid_cp_range(argument_index, cp_size) &amp;&amp;
3469         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3470         &quot;argument_index %u has bad constant type in class file %s&quot;,
3471         argument_index,
3472         CHECK);
3473       operands-&gt;at_put(operand_fill_index++, argument_index);
3474     }
3475   }
3476   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3477                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3478                      CHECK);
3479 }
3480 
3481 bool ClassFileParser::supports_records() {
3482   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3483     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3484     Arguments::enable_preview();
3485 }
3486 
3487 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3488                                                  ConstantPool* cp,
3489                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3490                                                  TRAPS) {
3491   assert(cfs != NULL, &quot;invariant&quot;);
3492   assert(cp != NULL, &quot;invariant&quot;);
3493   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3494 
3495   // Set inner classes attribute to default sentinel
3496   _inner_classes = Universe::the_empty_short_array();
3497   // Set nest members attribute to default sentinel
3498   _nest_members = Universe::the_empty_short_array();
3499   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3500   u2 attributes_count = cfs-&gt;get_u2_fast();
3501   bool parsed_sourcefile_attribute = false;
3502   bool parsed_innerclasses_attribute = false;
3503   bool parsed_nest_members_attribute = false;
3504   bool parsed_nest_host_attribute = false;
3505   bool parsed_record_attribute = false;
3506   bool parsed_enclosingmethod_attribute = false;
3507   bool parsed_bootstrap_methods_attribute = false;
3508   const u1* runtime_visible_annotations = NULL;
3509   int runtime_visible_annotations_length = 0;
3510   const u1* runtime_invisible_annotations = NULL;
3511   int runtime_invisible_annotations_length = 0;
3512   const u1* runtime_visible_type_annotations = NULL;
3513   int runtime_visible_type_annotations_length = 0;
3514   const u1* runtime_invisible_type_annotations = NULL;
3515   int runtime_invisible_type_annotations_length = 0;
3516   bool runtime_invisible_type_annotations_exists = false;
3517   bool runtime_invisible_annotations_exists = false;
3518   bool parsed_source_debug_ext_annotations_exist = false;
3519   const u1* inner_classes_attribute_start = NULL;
3520   u4  inner_classes_attribute_length = 0;
3521   u2  enclosing_method_class_index = 0;
3522   u2  enclosing_method_method_index = 0;
3523   const u1* nest_members_attribute_start = NULL;
3524   u4  nest_members_attribute_length = 0;
3525   const u1* record_attribute_start = NULL;
3526   u4  record_attribute_length = 0;
3527 
3528   // Iterate over attributes
3529   while (attributes_count--) {
3530     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3531     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3532     const u4 attribute_length = cfs-&gt;get_u4_fast();
3533     check_property(
3534       valid_symbol_at(attribute_name_index),
3535       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3536       attribute_name_index, CHECK);
3537     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3538     if (tag == vmSymbols::tag_source_file()) {
3539       // Check for SourceFile tag
3540       if (_need_verify) {
3541         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3542       }
3543       if (parsed_sourcefile_attribute) {
3544         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3545       } else {
3546         parsed_sourcefile_attribute = true;
3547       }
3548       parse_classfile_sourcefile_attribute(cfs, CHECK);
3549     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3550       // Check for SourceDebugExtension tag
3551       if (parsed_source_debug_ext_annotations_exist) {
3552           classfile_parse_error(
3553             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3554       }
3555       parsed_source_debug_ext_annotations_exist = true;
3556       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3557     } else if (tag == vmSymbols::tag_inner_classes()) {
3558       // Check for InnerClasses tag
3559       if (parsed_innerclasses_attribute) {
3560         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3561       } else {
3562         parsed_innerclasses_attribute = true;
3563       }
3564       inner_classes_attribute_start = cfs-&gt;current();
3565       inner_classes_attribute_length = attribute_length;
3566       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3567     } else if (tag == vmSymbols::tag_synthetic()) {
3568       // Check for Synthetic tag
3569       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3570       if (attribute_length != 0) {
3571         classfile_parse_error(
3572           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3573           attribute_length, CHECK);
3574       }
3575       parse_classfile_synthetic_attribute(CHECK);
3576     } else if (tag == vmSymbols::tag_deprecated()) {
3577       // Check for Deprecatd tag - 4276120
3578       if (attribute_length != 0) {
3579         classfile_parse_error(
3580           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3581           attribute_length, CHECK);
3582       }
3583     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3584       if (tag == vmSymbols::tag_signature()) {
3585         if (_generic_signature_index != 0) {
3586           classfile_parse_error(
3587             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3588         }
3589         if (attribute_length != 2) {
3590           classfile_parse_error(
3591             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3592             attribute_length, CHECK);
3593         }
3594         parse_classfile_signature_attribute(cfs, CHECK);
3595       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3596         if (runtime_visible_annotations != NULL) {
3597           classfile_parse_error(
3598             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3599         }
3600         runtime_visible_annotations_length = attribute_length;
3601         runtime_visible_annotations = cfs-&gt;current();
3602         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3603         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3604         parse_annotations(cp,
3605                           runtime_visible_annotations,
3606                           runtime_visible_annotations_length,
3607                           parsed_annotations,
3608                           _loader_data,
3609                           CHECK);
3610         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3611       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3612         if (runtime_invisible_annotations_exists) {
3613           classfile_parse_error(
3614             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3615         }
3616         runtime_invisible_annotations_exists = true;
3617         if (PreserveAllAnnotations) {
3618           runtime_invisible_annotations_length = attribute_length;
3619           runtime_invisible_annotations = cfs-&gt;current();
3620           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3621         }
3622         cfs-&gt;skip_u1(attribute_length, CHECK);
3623       } else if (tag == vmSymbols::tag_enclosing_method()) {
3624         if (parsed_enclosingmethod_attribute) {
3625           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3626         } else {
3627           parsed_enclosingmethod_attribute = true;
3628         }
3629         guarantee_property(attribute_length == 4,
3630           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3631           attribute_length, CHECK);
3632         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3633         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3634         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3635         if (enclosing_method_class_index == 0) {
3636           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3637         }
3638         // Validate the constant pool indices and types
3639         check_property(valid_klass_reference_at(enclosing_method_class_index),
3640           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3641         if (enclosing_method_method_index != 0 &amp;&amp;
3642             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3643              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3644           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3645         }
3646       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3647                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3648         if (parsed_bootstrap_methods_attribute) {
3649           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3650         }
3651         parsed_bootstrap_methods_attribute = true;
3652         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3653       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3654         if (runtime_visible_type_annotations != NULL) {
3655           classfile_parse_error(
3656             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3657         }
3658         runtime_visible_type_annotations_length = attribute_length;
3659         runtime_visible_type_annotations = cfs-&gt;current();
3660         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3661         // No need for the VM to parse Type annotations
3662         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3663       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3664         if (runtime_invisible_type_annotations_exists) {
3665           classfile_parse_error(
3666             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3667         } else {
3668           runtime_invisible_type_annotations_exists = true;
3669         }
3670         if (PreserveAllAnnotations) {
3671           runtime_invisible_type_annotations_length = attribute_length;
3672           runtime_invisible_type_annotations = cfs-&gt;current();
3673           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3674         }
3675         cfs-&gt;skip_u1(attribute_length, CHECK);
3676       } else if (_major_version &gt;= JAVA_11_VERSION) {
3677         if (tag == vmSymbols::tag_nest_members()) {
3678           // Check for NestMembers tag
3679           if (parsed_nest_members_attribute) {
3680             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3681           } else {
3682             parsed_nest_members_attribute = true;
3683           }
3684           if (parsed_nest_host_attribute) {
3685             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3686           }
3687           nest_members_attribute_start = cfs-&gt;current();
3688           nest_members_attribute_length = attribute_length;
3689           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3690         } else if (tag == vmSymbols::tag_nest_host()) {
3691           if (parsed_nest_host_attribute) {
3692             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3693           } else {
3694             parsed_nest_host_attribute = true;
3695           }
3696           if (parsed_nest_members_attribute) {
3697             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3698           }
3699           if (_need_verify) {
3700             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3701           }
3702           cfs-&gt;guarantee_more(2, CHECK);
3703           u2 class_info_index = cfs-&gt;get_u2_fast();
3704           check_property(
3705                          valid_klass_reference_at(class_info_index),
3706                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3707                          class_info_index, CHECK);
3708           _nest_host = class_info_index;
3709         } else if (_major_version &gt;= JAVA_14_VERSION) {
3710           if (tag == vmSymbols::tag_record()) {
3711             // Skip over Record attribute if not supported or if super class is
3712             // not java.lang.Record.
3713             if (supports_records() &amp;&amp;
3714                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3715               if (parsed_record_attribute) {
3716                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3717               }
3718               // Check that class is final and not abstract.
3719               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3720                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3721               }
3722               parsed_record_attribute = true;
3723               record_attribute_start = cfs-&gt;current();
3724               record_attribute_length = attribute_length;
3725             } else if (log_is_enabled(Info, class, record)) {
3726               // Log why the Record attribute was ignored.  Note that if the
3727               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3728               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3729               // exception would have been thrown.
3730               ResourceMark rm(THREAD);
3731               if (supports_records()) {
3732                 log_info(class, record)(
3733                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3734                   _class_name-&gt;as_C_string());
3735               } else {
3736                 log_info(class, record)(
3737                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3738                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3739               }
3740             }
3741             cfs-&gt;skip_u1(attribute_length, CHECK);
3742           } else {
3743             // Unknown attribute
3744             cfs-&gt;skip_u1(attribute_length, CHECK);
3745           }
3746         } else {
3747           // Unknown attribute
3748           cfs-&gt;skip_u1(attribute_length, CHECK);
3749         }
3750       } else {
3751         // Unknown attribute
3752         cfs-&gt;skip_u1(attribute_length, CHECK);
3753       }
3754     } else {
3755       // Unknown attribute
3756       cfs-&gt;skip_u1(attribute_length, CHECK);
3757     }
3758   }
3759   _class_annotations = assemble_annotations(runtime_visible_annotations,
3760                                             runtime_visible_annotations_length,
3761                                             runtime_invisible_annotations,
3762                                             runtime_invisible_annotations_length,
3763                                             CHECK);
3764   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3765                                                  runtime_visible_type_annotations_length,
3766                                                  runtime_invisible_type_annotations,
3767                                                  runtime_invisible_type_annotations_length,
3768                                                  CHECK);
3769 
3770   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3771     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3772                             cfs,
3773                             inner_classes_attribute_start,
3774                             parsed_innerclasses_attribute,
3775                             enclosing_method_class_index,
3776                             enclosing_method_method_index,
3777                             CHECK);
3778     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3779       guarantee_property(
3780         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3781         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3782     }
3783   }
3784 
3785   if (parsed_nest_members_attribute) {
3786     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3787                             cfs,
3788                             nest_members_attribute_start,
3789                             CHECK);
3790     if (_need_verify) {
3791       guarantee_property(
3792         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3793         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3794     }
3795   }
3796 
3797   if (parsed_record_attribute) {
3798     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3799                             cfs,
3800                             cp,
3801                             record_attribute_start,
3802                             CHECK);
3803     if (_need_verify) {
3804       guarantee_property(record_attribute_length == calculated_attr_length,
3805                          &quot;Record attribute has wrong length in class file %s&quot;,
3806                          CHECK);
3807     }
3808   }
3809 
3810   if (_max_bootstrap_specifier_index &gt;= 0) {
3811     guarantee_property(parsed_bootstrap_methods_attribute,
3812                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3813   }
3814 }
3815 
3816 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3817   assert(k != NULL, &quot;invariant&quot;);
3818 
3819   if (_synthetic_flag)
3820     k-&gt;set_is_synthetic();
3821   if (_sourcefile_index != 0) {
3822     k-&gt;set_source_file_name_index(_sourcefile_index);
3823   }
3824   if (_generic_signature_index != 0) {
3825     k-&gt;set_generic_signature_index(_generic_signature_index);
3826   }
3827   if (_sde_buffer != NULL) {
3828     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3829   }
3830 }
3831 
3832 // Create the Annotations object that will
3833 // hold the annotations array for the Klass.
3834 void ClassFileParser::create_combined_annotations(TRAPS) {
3835     if (_class_annotations == NULL &amp;&amp;
3836         _class_type_annotations == NULL &amp;&amp;
3837         _fields_annotations == NULL &amp;&amp;
3838         _fields_type_annotations == NULL) {
3839       // Don&#39;t create the Annotations object unnecessarily.
3840       return;
3841     }
3842 
3843     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
3844     annotations-&gt;set_class_annotations(_class_annotations);
3845     annotations-&gt;set_class_type_annotations(_class_type_annotations);
3846     annotations-&gt;set_fields_annotations(_fields_annotations);
3847     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3848 
3849     // This is the Annotations object that will be
3850     // assigned to InstanceKlass being constructed.
3851     _combined_annotations = annotations;
3852 
3853     // The annotations arrays below has been transfered the
3854     // _combined_annotations so these fields can now be cleared.
3855     _class_annotations       = NULL;
3856     _class_type_annotations  = NULL;
3857     _fields_annotations      = NULL;
3858     _fields_type_annotations = NULL;
3859 }
3860 
3861 // Transfer ownership of metadata allocated to the InstanceKlass.
3862 void ClassFileParser::apply_parsed_class_metadata(
3863                                             InstanceKlass* this_klass,
3864                                             int java_fields_count,
3865                                             TRAPS) {
3866   assert(this_klass != NULL, &quot;invariant&quot;);
3867 
3868   _cp-&gt;set_pool_holder(this_klass);
3869   this_klass-&gt;set_constants(_cp);
3870   this_klass-&gt;set_fields(_fields, java_fields_count);
3871   this_klass-&gt;set_methods(_methods);
3872   this_klass-&gt;set_inner_classes(_inner_classes);
3873   this_klass-&gt;set_nest_members(_nest_members);
3874   this_klass-&gt;set_nest_host_index(_nest_host);
3875   this_klass-&gt;set_local_interfaces(_local_interfaces);
3876   this_klass-&gt;set_annotations(_combined_annotations);
3877   this_klass-&gt;set_record_components(_record_components);
3878   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3879   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3880   // its _super. If an OOM occurs while loading the current klass, its _super field
3881   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3882   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3883   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3884 
3885   // Clear out these fields so they don&#39;t get deallocated by the destructor
3886   clear_class_metadata();
3887 }
3888 
3889 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3890                                                        int runtime_visible_annotations_length,
3891                                                        const u1* const runtime_invisible_annotations,
3892                                                        int runtime_invisible_annotations_length,
3893                                                        TRAPS) {
3894   AnnotationArray* annotations = NULL;
3895   if (runtime_visible_annotations != NULL ||
3896       runtime_invisible_annotations != NULL) {
3897     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
3898                                           runtime_visible_annotations_length +
3899                                           runtime_invisible_annotations_length,
3900                                           CHECK_(annotations));
3901     if (runtime_visible_annotations != NULL) {
3902       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
3903         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
3904       }
3905     }
3906     if (runtime_invisible_annotations != NULL) {
3907       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3908         int append = runtime_visible_annotations_length+i;
3909         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3910       }
3911     }
3912   }
3913   return annotations;
3914 }
3915 
3916 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3917                                                         const int super_class_index,
3918                                                         const bool need_verify,
3919                                                         TRAPS) {
3920   assert(cp != NULL, &quot;invariant&quot;);
3921   const InstanceKlass* super_klass = NULL;
3922 
3923   if (super_class_index == 0) {
3924     check_property(_class_name == vmSymbols::java_lang_Object(),
3925                    &quot;Invalid superclass index %u in class file %s&quot;,
3926                    super_class_index,
3927                    CHECK_NULL);
3928   } else {
3929     check_property(valid_klass_reference_at(super_class_index),
3930                    &quot;Invalid superclass index %u in class file %s&quot;,
3931                    super_class_index,
3932                    CHECK_NULL);
3933     // The class name should be legal because it is checked when parsing constant pool.
3934     // However, make sure it is not an array type.
3935     bool is_array = false;
3936     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3937       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3938       if (need_verify)
3939         is_array = super_klass-&gt;is_array_klass();
3940     } else if (need_verify) {
3941       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3942     }
3943     if (need_verify) {
3944       guarantee_property(!is_array,
3945                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
3946     }
3947   }
3948   return super_klass;
3949 }
3950 
3951 static unsigned int compute_oop_map_count(const InstanceKlass* super,
3952                                           unsigned int nonstatic_oop_map_count,
3953                                           int first_nonstatic_oop_offset) {
3954 
3955   unsigned int map_count =
3956     NULL == super ? 0 : super-&gt;nonstatic_oop_map_count();
3957   if (nonstatic_oop_map_count &gt; 0) {
3958     // We have oops to add to map
3959     if (map_count == 0) {
3960       map_count = nonstatic_oop_map_count;
3961     }
3962     else {
3963       // Check whether we should add a new map block or whether the last one can
3964       // be extended
3965       const OopMapBlock* const first_map = super-&gt;start_of_nonstatic_oop_maps();
3966       const OopMapBlock* const last_map = first_map + map_count - 1;
3967 
3968       const int next_offset = last_map-&gt;offset() + last_map-&gt;count() * heapOopSize;
3969       if (next_offset == first_nonstatic_oop_offset) {
3970         // There is no gap bettwen superklass&#39;s last oop field and first
3971         // local oop field, merge maps.
3972         nonstatic_oop_map_count -= 1;
3973       }
3974       else {
3975         // Superklass didn&#39;t end with a oop field, add extra maps
3976         assert(next_offset &lt; first_nonstatic_oop_offset, &quot;just checking&quot;);
3977       }
3978       map_count += nonstatic_oop_map_count;
3979     }
3980   }
3981   return map_count;
3982 }
3983 
3984 #ifndef PRODUCT
3985 static void print_field_layout(const Symbol* name,
3986                                Array&lt;u2&gt;* fields,
3987                                ConstantPool* cp,
3988                                int instance_size,
3989                                int instance_fields_start,
3990                                int instance_fields_end,
3991                                int static_fields_end) {
3992 
3993   assert(name != NULL, &quot;invariant&quot;);
3994 
3995   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
3996   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
3997   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3998     if (!fs.access_flags().is_static()) {
3999       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4000         fs.offset(),
4001         fs.name()-&gt;as_klass_external_name(),
4002         fs.signature()-&gt;as_klass_external_name());
4003     }
4004   }
4005   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
4006   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
4007   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
4008   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4009     if (fs.access_flags().is_static()) {
4010       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4011         fs.offset(),
4012         fs.name()-&gt;as_klass_external_name(),
4013         fs.signature()-&gt;as_klass_external_name());
4014     }
4015   }
4016   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4017   tty-&gt;print(&quot;\n&quot;);
4018 }
4019 #endif
4020 
4021 // Values needed for oopmap and InstanceKlass creation
4022 class ClassFileParser::FieldLayoutInfo : public ResourceObj {
4023  public:
4024   int*          nonstatic_oop_offsets;
4025   unsigned int* nonstatic_oop_counts;
4026   unsigned int  nonstatic_oop_map_count;
4027   unsigned int  total_oop_map_count;
4028   int           instance_size;
4029   int           nonstatic_field_size;
4030   int           static_field_size;
4031   bool          has_nonstatic_fields;
4032 };
4033 
4034 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4035 void ClassFileParser::layout_fields(ConstantPool* cp,
4036                                     const FieldAllocationCount* fac,
4037                                     const ClassAnnotationCollector* parsed_annotations,
4038                                     FieldLayoutInfo* info,
4039                                     TRAPS) {
4040 
4041   assert(cp != NULL, &quot;invariant&quot;);
4042 
4043   // Field size and offset computation
4044   int nonstatic_field_size = _super_klass == NULL ? 0 :
4045                                _super_klass-&gt;nonstatic_field_size();
4046 
4047   // Count the contended fields by type.
4048   //
4049   // We ignore static fields, because @Contended is not supported for them.
4050   // The layout code below will also ignore the static fields.
4051   int nonstatic_contended_count = 0;
4052   FieldAllocationCount fac_contended;
4053   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4054     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4055     if (fs.is_contended()) {
4056       fac_contended.count[atype]++;
4057       if (!fs.access_flags().is_static()) {
4058         nonstatic_contended_count++;
4059       }
4060     }
4061   }
4062 
4063 
4064   // Calculate the starting byte offsets
4065   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4066   int next_static_double_offset = next_static_oop_offset +
4067                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);
4068   if (fac-&gt;count[STATIC_DOUBLE]) {
4069     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4070   }
4071 
4072   int next_static_word_offset   = next_static_double_offset +
4073                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4074   int next_static_short_offset  = next_static_word_offset +
4075                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4076   int next_static_byte_offset   = next_static_short_offset +
4077                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4078 
4079   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4080                                 nonstatic_field_size * heapOopSize;
4081 
4082   int next_nonstatic_field_offset = nonstatic_fields_start;
4083 
4084   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4085 
4086   // Class is contended, pad before all the fields
4087   if (is_contended_class) {
4088     next_nonstatic_field_offset += ContendedPaddingWidth;
4089   }
4090 
4091   // Compute the non-contended fields count.
4092   // The packing code below relies on these counts to determine if some field
4093   // can be squeezed into the alignment gap. Contended fields are obviously
4094   // exempt from that.
4095   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4096   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4097   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4098   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4099   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4100 
4101   // Total non-static fields count, including every contended field
4102   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4103                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4104                                         fac-&gt;count[NONSTATIC_OOP];
4105 
4106   const bool super_has_nonstatic_fields =
4107           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4108   const bool has_nonstatic_fields =
4109     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4110 
4111 
4112   // Prepare list of oops for oop map generation.
4113   //
4114   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4115   // regions. offset[i] is the start of the i-th region, which then has
4116   // count[i] oops following. Before we know how many regions are required,
4117   // we pessimistically allocate the maps to fit all the oops into the
4118   // distinct regions.
4119   //
4120   // TODO: We add +1 to always allocate non-zero resource arrays; we need
4121   // to figure out if we still need to do this.
4122   unsigned int nonstatic_oop_map_count = 0;
4123   unsigned int max_nonstatic_oop_maps  = fac-&gt;count[NONSTATIC_OOP] + 1;
4124 
4125   int* nonstatic_oop_offsets = NEW_RESOURCE_ARRAY_IN_THREAD(
4126             THREAD, int, max_nonstatic_oop_maps);
4127   unsigned int* const nonstatic_oop_counts  = NEW_RESOURCE_ARRAY_IN_THREAD(
4128             THREAD, unsigned int, max_nonstatic_oop_maps);
4129 
4130   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4131 
4132   bool compact_fields  = true;
4133   bool allocate_oops_first = false;
4134 
4135   // The next classes have predefined hard-coded fields offsets
4136   // (see in JavaClasses::compute_hard_coded_offsets()).
4137   // Use default fields allocation order for them.
4138   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4139       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4140        _class_name == vmSymbols::java_lang_Boolean() ||
4141        _class_name == vmSymbols::java_lang_Character() ||
4142        _class_name == vmSymbols::java_lang_Float() ||
4143        _class_name == vmSymbols::java_lang_Double() ||
4144        _class_name == vmSymbols::java_lang_Byte() ||
4145        _class_name == vmSymbols::java_lang_Short() ||
4146        _class_name == vmSymbols::java_lang_Integer() ||
4147        _class_name == vmSymbols::java_lang_Long())) {
4148     allocate_oops_first = true;     // Allocate oops first
4149     compact_fields   = false; // Don&#39;t compact fields
4150   }
4151 
4152   int next_nonstatic_oop_offset = 0;
4153   int next_nonstatic_double_offset = 0;
4154 
4155   // Rearrange fields for a given allocation style
4156   if (allocate_oops_first) {
4157     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4158     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4159     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4160                                     (nonstatic_oop_count * heapOopSize);
4161   } else {
4162     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4163     next_nonstatic_double_offset = next_nonstatic_field_offset;
4164   }
4165 
4166   int nonstatic_oop_space_count   = 0;
4167   int nonstatic_word_space_count  = 0;
4168   int nonstatic_short_space_count = 0;
4169   int nonstatic_byte_space_count  = 0;
4170   int nonstatic_oop_space_offset = 0;
4171   int nonstatic_word_space_offset = 0;
4172   int nonstatic_short_space_offset = 0;
4173   int nonstatic_byte_space_offset = 0;
4174 
4175   // Try to squeeze some of the fields into the gaps due to
4176   // long/double alignment.
4177   if (nonstatic_double_count &gt; 0) {
4178     int offset = next_nonstatic_double_offset;
4179     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4180     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4181       // Allocate available fields into the gap before double field.
4182       int length = next_nonstatic_double_offset - offset;
4183       assert(length == BytesPerInt, &quot;&quot;);
4184       nonstatic_word_space_offset = offset;
4185       if (nonstatic_word_count &gt; 0) {
4186         nonstatic_word_count      -= 1;
4187         nonstatic_word_space_count = 1; // Only one will fit
4188         length -= BytesPerInt;
4189         offset += BytesPerInt;
4190       }
4191       nonstatic_short_space_offset = offset;
4192       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4193         nonstatic_short_count       -= 1;
4194         nonstatic_short_space_count += 1;
4195         length -= BytesPerShort;
4196         offset += BytesPerShort;
4197       }
4198       nonstatic_byte_space_offset = offset;
4199       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4200         nonstatic_byte_count       -= 1;
4201         nonstatic_byte_space_count += 1;
4202         length -= 1;
4203       }
4204       // Allocate oop field in the gap if there are no other fields for that.
4205       nonstatic_oop_space_offset = offset;
4206       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4207           !allocate_oops_first) { // when oop fields not first
4208         nonstatic_oop_count      -= 1;
4209         nonstatic_oop_space_count = 1; // Only one will fit
4210         length -= heapOopSize;
4211         offset += heapOopSize;
4212       }
4213     }
4214   }
4215 
4216   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4217                                      (nonstatic_double_count * BytesPerLong);
4218   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4219                                       (nonstatic_word_count * BytesPerInt);
4220   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4221                                      (nonstatic_short_count * BytesPerShort);
4222   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4223                                        nonstatic_byte_count;
4224 
4225   // let oops jump before padding with this allocation style
4226   if (!allocate_oops_first) {
4227     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4228     if( nonstatic_oop_count &gt; 0 ) {
4229       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4230     }
4231     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4232   }
4233 
4234   // Iterate over fields again and compute correct offsets.
4235   // The field allocation type was temporarily stored in the offset slot.
4236   // oop fields are located before non-oop fields (static and non-static).
4237   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4238 
4239     // skip already laid out fields
4240     if (fs.is_offset_set()) continue;
4241 
4242     // contended instance fields are handled below
4243     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4244 
4245     int real_offset = 0;
4246     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4247 
4248     // pack the rest of the fields
4249     switch (atype) {
4250       case STATIC_OOP:
4251         real_offset = next_static_oop_offset;
4252         next_static_oop_offset += heapOopSize;
4253         break;
4254       case STATIC_BYTE:
4255         real_offset = next_static_byte_offset;
4256         next_static_byte_offset += 1;
4257         break;
4258       case STATIC_SHORT:
4259         real_offset = next_static_short_offset;
4260         next_static_short_offset += BytesPerShort;
4261         break;
4262       case STATIC_WORD:
4263         real_offset = next_static_word_offset;
4264         next_static_word_offset += BytesPerInt;
4265         break;
4266       case STATIC_DOUBLE:
4267         real_offset = next_static_double_offset;
4268         next_static_double_offset += BytesPerLong;
4269         break;
4270       case NONSTATIC_OOP:
4271         if( nonstatic_oop_space_count &gt; 0 ) {
4272           real_offset = nonstatic_oop_space_offset;
4273           nonstatic_oop_space_offset += heapOopSize;
4274           nonstatic_oop_space_count  -= 1;
4275         } else {
4276           real_offset = next_nonstatic_oop_offset;
4277           next_nonstatic_oop_offset += heapOopSize;
4278         }
4279 
4280         // Record this oop in the oop maps
4281         if( nonstatic_oop_map_count &gt; 0 &amp;&amp;
4282             nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==
4283             real_offset -
4284             int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *
4285             heapOopSize ) {
4286           // This oop is adjacent to the previous one, add to current oop map
4287           assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4288           nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;
4289         } else {
4290           // This oop is not adjacent to the previous one, create new oop map
4291           assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4292           nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
4293           nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
4294           nonstatic_oop_map_count += 1;
4295           if( first_nonstatic_oop_offset == 0 ) { // Undefined
4296             first_nonstatic_oop_offset = real_offset;
4297           }
4298         }
4299         break;
4300       case NONSTATIC_BYTE:
4301         if( nonstatic_byte_space_count &gt; 0 ) {
4302           real_offset = nonstatic_byte_space_offset;
4303           nonstatic_byte_space_offset += 1;
4304           nonstatic_byte_space_count  -= 1;
4305         } else {
4306           real_offset = next_nonstatic_byte_offset;
4307           next_nonstatic_byte_offset += 1;
4308         }
4309         break;
4310       case NONSTATIC_SHORT:
4311         if( nonstatic_short_space_count &gt; 0 ) {
4312           real_offset = nonstatic_short_space_offset;
4313           nonstatic_short_space_offset += BytesPerShort;
4314           nonstatic_short_space_count  -= 1;
4315         } else {
4316           real_offset = next_nonstatic_short_offset;
4317           next_nonstatic_short_offset += BytesPerShort;
4318         }
4319         break;
4320       case NONSTATIC_WORD:
4321         if( nonstatic_word_space_count &gt; 0 ) {
4322           real_offset = nonstatic_word_space_offset;
4323           nonstatic_word_space_offset += BytesPerInt;
4324           nonstatic_word_space_count  -= 1;
4325         } else {
4326           real_offset = next_nonstatic_word_offset;
4327           next_nonstatic_word_offset += BytesPerInt;
4328         }
4329         break;
4330       case NONSTATIC_DOUBLE:
4331         real_offset = next_nonstatic_double_offset;
4332         next_nonstatic_double_offset += BytesPerLong;
4333         break;
4334       default:
4335         ShouldNotReachHere();
4336     }
4337     fs.set_offset(real_offset);
4338   }
4339 
4340 
4341   // Handle the contended cases.
4342   //
4343   // Each contended field should not intersect the cache line with another contended field.
4344   // In the absence of alignment information, we end up with pessimistically separating
4345   // the fields with full-width padding.
4346   //
4347   // Additionally, this should not break alignment for the fields, so we round the alignment up
4348   // for each field.
4349   if (nonstatic_contended_count &gt; 0) {
4350 
4351     // if there is at least one contended field, we need to have pre-padding for them
4352     next_nonstatic_padded_offset += ContendedPaddingWidth;
4353 
4354     // collect all contended groups
4355     ResourceBitMap bm(cp-&gt;size());
4356     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4357       // skip already laid out fields
4358       if (fs.is_offset_set()) continue;
4359 
4360       if (fs.is_contended()) {
4361         bm.set_bit(fs.contended_group());
4362       }
4363     }
4364 
4365     int current_group = -1;
4366     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4367 
4368       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4369 
4370         // skip already laid out fields
4371         if (fs.is_offset_set()) continue;
4372 
4373         // skip non-contended fields and fields from different group
4374         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4375 
4376         // handle statics below
4377         if (fs.access_flags().is_static()) continue;
4378 
4379         int real_offset = 0;
4380         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4381 
4382         switch (atype) {
4383           case NONSTATIC_BYTE:
4384             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4385             real_offset = next_nonstatic_padded_offset;
4386             next_nonstatic_padded_offset += 1;
4387             break;
4388 
4389           case NONSTATIC_SHORT:
4390             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4391             real_offset = next_nonstatic_padded_offset;
4392             next_nonstatic_padded_offset += BytesPerShort;
4393             break;
4394 
4395           case NONSTATIC_WORD:
4396             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4397             real_offset = next_nonstatic_padded_offset;
4398             next_nonstatic_padded_offset += BytesPerInt;
4399             break;
4400 
4401           case NONSTATIC_DOUBLE:
4402             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4403             real_offset = next_nonstatic_padded_offset;
4404             next_nonstatic_padded_offset += BytesPerLong;
4405             break;
4406 
4407           case NONSTATIC_OOP:
4408             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4409             real_offset = next_nonstatic_padded_offset;
4410             next_nonstatic_padded_offset += heapOopSize;
4411 
4412             // Record this oop in the oop maps
4413             if( nonstatic_oop_map_count &gt; 0 &amp;&amp;
4414                 nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==
4415                 real_offset -
4416                 int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *
4417                 heapOopSize ) {
4418               // This oop is adjacent to the previous one, add to current oop map
4419               assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4420               nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;
4421             } else {
4422               // This oop is not adjacent to the previous one, create new oop map
4423               assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4424               nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
4425               nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
4426               nonstatic_oop_map_count += 1;
4427               if( first_nonstatic_oop_offset == 0 ) { // Undefined
4428                 first_nonstatic_oop_offset = real_offset;
4429               }
4430             }
4431             break;
4432 
4433           default:
4434             ShouldNotReachHere();
4435         }
4436 
4437         if (fs.contended_group() == 0) {
4438           // Contended group defines the equivalence class over the fields:
4439           // the fields within the same contended group are not inter-padded.
4440           // The only exception is default group, which does not incur the
4441           // equivalence, and so requires intra-padding.
4442           next_nonstatic_padded_offset += ContendedPaddingWidth;
4443         }
4444 
4445         fs.set_offset(real_offset);
4446       } // for
4447 
4448       // Start laying out the next group.
4449       // Note that this will effectively pad the last group in the back;
4450       // this is expected to alleviate memory contention effects for
4451       // subclass fields and/or adjacent object.
4452       // If this was the default group, the padding is already in place.
4453       if (current_group != 0) {
4454         next_nonstatic_padded_offset += ContendedPaddingWidth;
4455       }
4456     }
4457 
4458     // handle static fields
4459   }
4460 
4461   // Entire class is contended, pad in the back.
4462   // This helps to alleviate memory contention effects for subclass fields
4463   // and/or adjacent object.
4464   if (is_contended_class) {
4465     next_nonstatic_padded_offset += ContendedPaddingWidth;
4466   }
4467 
4468   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4469 
4470   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);
4471   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4472   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4473 
4474   int static_field_size         = (static_fields_end -
4475                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4476   nonstatic_field_size          = nonstatic_field_size +
4477                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4478 
4479   int instance_size             = align_object_size(instance_end / wordSize);
4480 
4481   assert(instance_size == align_object_size(align_up(
4482          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
4483           wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4484 
4485   // Invariant: nonstatic_field end/start should only change if there are
4486   // nonstatic fields in the class, or if the class is contended. We compare
4487   // against the non-aligned value, so that end alignment will not fail the
4488   // assert without actually having the fields.
4489   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4490          is_contended_class ||
4491          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4492 
4493   // Number of non-static oop map blocks allocated at end of klass.
4494   const unsigned int total_oop_map_count =
4495     compute_oop_map_count(_super_klass, nonstatic_oop_map_count,
4496                           first_nonstatic_oop_offset);
4497 
4498 #ifndef PRODUCT
4499   if (PrintFieldLayout) {
4500     print_field_layout(_class_name,
4501           _fields,
4502           cp,
4503           instance_size,
4504           nonstatic_fields_start,
4505           nonstatic_fields_end,
4506           static_fields_end);
4507   }
4508 
4509 #endif
4510   // Pass back information needed for InstanceKlass creation
4511   info-&gt;nonstatic_oop_offsets = nonstatic_oop_offsets;
4512   info-&gt;nonstatic_oop_counts = nonstatic_oop_counts;
4513   info-&gt;nonstatic_oop_map_count = nonstatic_oop_map_count;
4514   info-&gt;total_oop_map_count = total_oop_map_count;
4515   info-&gt;instance_size = instance_size;
4516   info-&gt;static_field_size = static_field_size;
4517   info-&gt;nonstatic_field_size = nonstatic_field_size;
4518   info-&gt;has_nonstatic_fields = has_nonstatic_fields;
4519 }
4520 
4521 static void fill_oop_maps(const InstanceKlass* k,
4522                           unsigned int nonstatic_oop_map_count,
4523                           const int* nonstatic_oop_offsets,
4524                           const unsigned int* nonstatic_oop_counts) {
4525 
4526   assert(k != NULL, &quot;invariant&quot;);
4527 
4528   OopMapBlock* this_oop_map = k-&gt;start_of_nonstatic_oop_maps();
4529   const InstanceKlass* const super = k-&gt;superklass();
4530   const unsigned int super_count = super ? super-&gt;nonstatic_oop_map_count() : 0;
4531   if (super_count &gt; 0) {
4532     // Copy maps from superklass
4533     OopMapBlock* super_oop_map = super-&gt;start_of_nonstatic_oop_maps();
4534     for (unsigned int i = 0; i &lt; super_count; ++i) {
4535       *this_oop_map++ = *super_oop_map++;
4536     }
4537   }
4538 
4539   if (nonstatic_oop_map_count &gt; 0) {
4540     if (super_count + nonstatic_oop_map_count &gt; k-&gt;nonstatic_oop_map_count()) {
4541       // The counts differ because there is no gap between superklass&#39;s last oop
4542       // field and the first local oop field.  Extend the last oop map copied
4543       // from the superklass instead of creating new one.
4544       nonstatic_oop_map_count--;
4545       nonstatic_oop_offsets++;
4546       this_oop_map--;
4547       this_oop_map-&gt;set_count(this_oop_map-&gt;count() + *nonstatic_oop_counts++);
4548       this_oop_map++;
4549     }
4550 
4551     // Add new map blocks, fill them
4552     while (nonstatic_oop_map_count-- &gt; 0) {
4553       this_oop_map-&gt;set_offset(*nonstatic_oop_offsets++);
4554       this_oop_map-&gt;set_count(*nonstatic_oop_counts++);
4555       this_oop_map++;
4556     }
4557     assert(k-&gt;start_of_nonstatic_oop_maps() + k-&gt;nonstatic_oop_map_count() ==
4558            this_oop_map, &quot;sanity&quot;);
4559   }
4560 }
4561 
4562 
4563 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4564   assert(ik != NULL, &quot;invariant&quot;);
4565 
4566   const Klass* const super = ik-&gt;super();
4567 
4568   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4569   // in which case we don&#39;t have to register objects as finalizable
4570   if (!_has_empty_finalizer) {
4571     if (_has_finalizer ||
4572         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4573       ik-&gt;set_has_finalizer();
4574     }
4575   }
4576 
4577 #ifdef ASSERT
4578   bool f = false;
4579   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4580                                            vmSymbols::void_method_signature());
4581   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4582       f = true;
4583   }
4584 
4585   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4586   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4587   // will not work as expected we shouldn&#39;t abort vm in this case
4588   if (!ik-&gt;has_redefined_this_or_super()) {
4589     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4590   }
4591 #endif
4592 
4593   // Check if this klass supports the java.lang.Cloneable interface
4594   if (SystemDictionary::Cloneable_klass_loaded()) {
4595     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4596       ik-&gt;set_is_cloneable();
4597     }
4598   }
4599 
4600   // Check if this klass has a vanilla default constructor
4601   if (super == NULL) {
4602     // java.lang.Object has empty default constructor
4603     ik-&gt;set_has_vanilla_constructor();
4604   } else {
4605     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4606         _has_vanilla_constructor) {
4607       ik-&gt;set_has_vanilla_constructor();
4608     }
4609 #ifdef ASSERT
4610     bool v = false;
4611     if (super-&gt;has_vanilla_constructor()) {
4612       const Method* const constructor =
4613         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4614                        vmSymbols::void_method_signature());
4615       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4616         v = true;
4617       }
4618     }
4619     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4620 #endif
4621   }
4622 
4623   // If it cannot be fast-path allocated, set a bit in the layout helper.
4624   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4625   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4626   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4627       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4628       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4629       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4630     // Forbid fast-path allocation.
4631     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4632     ik-&gt;set_layout_helper(lh);
4633   }
4634 }
4635 
4636 // utility methods for appending an array with check for duplicates
4637 
4638 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4639                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4640   // iterate over new interfaces
4641   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4642     InstanceKlass* const e = ifs-&gt;at(i);
4643     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4644     // add new interface
4645     result-&gt;append_if_missing(e);
4646   }
4647 }
4648 
4649 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4650                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4651                                                             ClassLoaderData* loader_data,
4652                                                             TRAPS) {
4653   assert(local_ifs != NULL, &quot;invariant&quot;);
4654   assert(loader_data != NULL, &quot;invariant&quot;);
4655 
4656   // Compute maximum size for transitive interfaces
4657   int max_transitive_size = 0;
4658   int super_size = 0;
4659   // Add superclass transitive interfaces size
4660   if (super != NULL) {
4661     super_size = super-&gt;transitive_interfaces()-&gt;length();
4662     max_transitive_size += super_size;
4663   }
4664   // Add local interfaces&#39; super interfaces
4665   const int local_size = local_ifs-&gt;length();
4666   for (int i = 0; i &lt; local_size; i++) {
4667     InstanceKlass* const l = local_ifs-&gt;at(i);
4668     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4669   }
4670   // Finally add local interfaces
4671   max_transitive_size += local_size;
4672   // Construct array
4673   if (max_transitive_size == 0) {
4674     // no interfaces, use canonicalized array
4675     return Universe::the_empty_instance_klass_array();
4676   } else if (max_transitive_size == super_size) {
4677     // no new local interfaces added, share superklass&#39; transitive interface array
4678     return super-&gt;transitive_interfaces();
4679   } else if (max_transitive_size == local_size) {
4680     // only local interfaces added, share local interface array
4681     return local_ifs;
4682   } else {
4683     ResourceMark rm;
4684     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4685 
4686     // Copy down from superclass
4687     if (super != NULL) {
4688       append_interfaces(result, super-&gt;transitive_interfaces());
4689     }
4690 
4691     // Copy down from local interfaces&#39; superinterfaces
4692     for (int i = 0; i &lt; local_size; i++) {
4693       InstanceKlass* const l = local_ifs-&gt;at(i);
4694       append_interfaces(result, l-&gt;transitive_interfaces());
4695     }
4696     // Finally add local interfaces
4697     append_interfaces(result, local_ifs);
4698 
4699     // length will be less than the max_transitive_size if duplicates were removed
4700     const int length = result-&gt;length();
4701     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4702     Array&lt;InstanceKlass*&gt;* const new_result =
4703       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4704     for (int i = 0; i &lt; length; i++) {
4705       InstanceKlass* const e = result-&gt;at(i);
4706       assert(e != NULL, &quot;just checking&quot;);
4707       new_result-&gt;at_put(i, e);
4708     }
4709     return new_result;
4710   }
4711 }
4712 
4713 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4714   assert(this_klass != NULL, &quot;invariant&quot;);
4715   const Klass* const super = this_klass-&gt;super();
4716 
4717   if (super != NULL) {
4718 
4719     // If the loader is not the boot loader then throw an exception if its
4720     // superclass is in package jdk.internal.reflect and its loader is not a
4721     // special reflection class loader
4722     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4723       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
4724       PackageEntry* super_package = super-&gt;package();
4725       if (super_package != NULL &amp;&amp;
4726           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4727           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4728         ResourceMark rm(THREAD);
4729         Exceptions::fthrow(
4730           THREAD_AND_LOCATION,
4731           vmSymbols::java_lang_IllegalAccessError(),
4732           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4733           this_klass-&gt;external_name(),
4734           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4735           super-&gt;external_name());
4736         return;
4737       }
4738     }
4739 
4740     Reflection::VerifyClassAccessResults vca_result =
4741       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4742     if (vca_result != Reflection::ACCESS_OK) {
4743       ResourceMark rm(THREAD);
4744       char* msg = Reflection::verify_class_access_msg(this_klass,
4745                                                       InstanceKlass::cast(super),
4746                                                       vca_result);
4747       if (msg == NULL) {
4748         bool same_module = (this_klass-&gt;module() == super-&gt;module());
4749         Exceptions::fthrow(
4750           THREAD_AND_LOCATION,
4751           vmSymbols::java_lang_IllegalAccessError(),
4752           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
4753           this_klass-&gt;external_name(),
4754           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
4755           super-&gt;external_name(),
4756           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
4757           (same_module) ? &quot;&quot; : &quot;; &quot;,
4758           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
4759       } else {
4760         // Add additional message content.
4761         Exceptions::fthrow(
4762           THREAD_AND_LOCATION,
4763           vmSymbols::java_lang_IllegalAccessError(),
4764           &quot;superclass access check failed: %s&quot;,
4765           msg);
4766       }
4767     }
4768   }
4769 }
4770 
4771 
4772 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4773   assert(this_klass != NULL, &quot;invariant&quot;);
4774   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4775   const int lng = local_interfaces-&gt;length();
4776   for (int i = lng - 1; i &gt;= 0; i--) {
4777     InstanceKlass* const k = local_interfaces-&gt;at(i);
4778     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4779     Reflection::VerifyClassAccessResults vca_result =
4780       Reflection::verify_class_access(this_klass, k, false);
4781     if (vca_result != Reflection::ACCESS_OK) {
4782       ResourceMark rm(THREAD);
4783       char* msg = Reflection::verify_class_access_msg(this_klass,
4784                                                       k,
4785                                                       vca_result);
4786       if (msg == NULL) {
4787         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4788         Exceptions::fthrow(
4789           THREAD_AND_LOCATION,
4790           vmSymbols::java_lang_IllegalAccessError(),
4791           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4792           this_klass-&gt;external_name(),
4793           k-&gt;external_name(),
4794           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4795           (same_module) ? &quot;&quot; : &quot;; &quot;,
4796           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4797       } else {
4798         // Add additional message content.
4799         Exceptions::fthrow(
4800           THREAD_AND_LOCATION,
4801           vmSymbols::java_lang_IllegalAccessError(),
4802           &quot;superinterface check failed: %s&quot;,
4803           msg);
4804       }
4805     }
4806   }
4807 }
4808 
4809 
4810 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
4811   assert(this_klass != NULL, &quot;invariant&quot;);
4812   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
4813   const int num_methods = methods-&gt;length();
4814 
4815   // go thru each method and check if it overrides a final method
4816   for (int index = 0; index &lt; num_methods; index++) {
4817     const Method* const m = methods-&gt;at(index);
4818 
4819     // skip private, static, and &lt;init&gt; methods
4820     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
4821         (m-&gt;name() != vmSymbols::object_initializer_name())) {
4822 
4823       const Symbol* const name = m-&gt;name();
4824       const Symbol* const signature = m-&gt;signature();
4825       const Klass* k = this_klass-&gt;super();
4826       const Method* super_m = NULL;
4827       while (k != NULL) {
4828         // skip supers that don&#39;t have final methods.
4829         if (k-&gt;has_final_method()) {
4830           // lookup a matching method in the super class hierarchy
4831           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
4832           if (super_m == NULL) {
4833             break; // didn&#39;t find any match; get out
4834           }
4835 
4836           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
4837               !super_m-&gt;access_flags().is_private()) {
4838             // matching method in super is final, and not static or private
4839             bool can_access = Reflection::verify_member_access(this_klass,
4840                                                                super_m-&gt;method_holder(),
4841                                                                super_m-&gt;method_holder(),
4842                                                                super_m-&gt;access_flags(),
4843                                                               false, false, CHECK);
4844             if (can_access) {
4845               // this class can access super final method and therefore override
4846               ResourceMark rm(THREAD);
4847               Exceptions::fthrow(THREAD_AND_LOCATION,
4848                                  vmSymbols::java_lang_VerifyError(),
4849                                  &quot;class %s overrides final method %s.%s%s&quot;,
4850                                  this_klass-&gt;external_name(),
4851                                  super_m-&gt;method_holder()-&gt;external_name(),
4852                                  name-&gt;as_C_string(),
4853                                  signature-&gt;as_C_string()
4854                                  );
4855               return;
4856             }
4857           }
4858 
4859           // continue to look from super_m&#39;s holder&#39;s super.
4860           k = super_m-&gt;method_holder()-&gt;super();
4861           continue;
4862         }
4863 
4864         k = k-&gt;super();
4865       }
4866     }
4867   }
4868 }
4869 
4870 
4871 // assumes that this_klass is an interface
4872 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
4873   assert(this_klass != NULL, &quot;invariant&quot;);
4874   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
4875   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
4876   const int num_methods = methods-&gt;length();
4877 
4878   for (int index = 0; index &lt; num_methods; index++) {
4879     const Method* const m = methods-&gt;at(index);
4880     // if m is static and not the init method, throw a verify error
4881     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4882       ResourceMark rm(THREAD);
4883       Exceptions::fthrow(
4884         THREAD_AND_LOCATION,
4885         vmSymbols::java_lang_VerifyError(),
4886         &quot;Illegal static method %s in interface %s&quot;,
4887         m-&gt;name()-&gt;as_C_string(),
4888         this_klass-&gt;external_name()
4889       );
4890       return;
4891     }
4892   }
4893 }
4894 
4895 // utility methods for format checking
4896 
4897 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4898   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
4899   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
4900   if (is_module) {
4901     ResourceMark rm(THREAD);
4902     Exceptions::fthrow(
4903       THREAD_AND_LOCATION,
4904       vmSymbols::java_lang_NoClassDefFoundError(),
4905       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4906       _class_name-&gt;as_C_string());
4907     return;
4908   }
4909 
4910   if (!_need_verify) { return; }
4911 
4912   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4913   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4914   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4915   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4916   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4917   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4918   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4919   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4920 
4921   if ((is_abstract &amp;&amp; is_final) ||
4922       (is_interface &amp;&amp; !is_abstract) ||
4923       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
4924       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {
4925     ResourceMark rm(THREAD);
4926     Exceptions::fthrow(
4927       THREAD_AND_LOCATION,
4928       vmSymbols::java_lang_ClassFormatError(),
4929       &quot;Illegal class modifiers in class %s: 0x%X&quot;,
4930       _class_name-&gt;as_C_string(), flags
4931     );
4932     return;
4933   }
4934 }
4935 
4936 static bool has_illegal_visibility(jint flags) {
4937   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4938   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4939   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4940 
4941   return ((is_public &amp;&amp; is_protected) ||
4942           (is_public &amp;&amp; is_private) ||
4943           (is_protected &amp;&amp; is_private));
4944 }
4945 
4946 // A legal major_version.minor_version must be one of the following:
4947 //
4948 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4949 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4950 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
4951 //
4952 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
4953   ResourceMark rm(THREAD);
4954   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
4955   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
4956     Exceptions::fthrow(
4957       THREAD_AND_LOCATION,
4958       vmSymbols::java_lang_UnsupportedClassVersionError(),
4959       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
4960       class_name-&gt;as_C_string(), major, minor);
4961     return;
4962   }
4963 
4964   if (major &gt; max_version) {
4965     Exceptions::fthrow(
4966       THREAD_AND_LOCATION,
4967       vmSymbols::java_lang_UnsupportedClassVersionError(),
4968       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
4969       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
4970       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
4971     return;
4972   }
4973 
4974   if (major &lt; JAVA_12_VERSION || minor == 0) {
4975     return;
4976   }
4977 
4978   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
4979     if (major != max_version) {
4980       Exceptions::fthrow(
4981         THREAD_AND_LOCATION,
4982         vmSymbols::java_lang_UnsupportedClassVersionError(),
4983         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
4984         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
4985         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
4986       return;
4987     }
4988 
4989     if (!Arguments::enable_preview()) {
4990       Exceptions::fthrow(
4991         THREAD_AND_LOCATION,
4992         vmSymbols::java_lang_UnsupportedClassVersionError(),
4993         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4994         class_name-&gt;as_C_string(), major, minor);
4995       return;
4996     }
4997 
4998   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4999     Exceptions::fthrow(
5000         THREAD_AND_LOCATION,
5001         vmSymbols::java_lang_UnsupportedClassVersionError(),
5002         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5003         class_name-&gt;as_C_string(), major, minor);
5004   }
5005 }
5006 
5007 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5008                                                    bool is_interface,
5009                                                    TRAPS) const {
5010   if (!_need_verify) { return; }
5011 
5012   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5013   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5014   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5015   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5016   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5017   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5018   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5019   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5020   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5021 
5022   bool is_illegal = false;
5023 
5024   if (is_interface) {
5025     if (!is_public || !is_static || !is_final || is_private ||
5026         is_protected || is_volatile || is_transient ||
5027         (major_gte_1_5 &amp;&amp; is_enum)) {
5028       is_illegal = true;
5029     }
5030   } else { // not interface
5031     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5032       is_illegal = true;
5033     }
5034   }
5035 
5036   if (is_illegal) {
5037     ResourceMark rm(THREAD);
5038     Exceptions::fthrow(
5039       THREAD_AND_LOCATION,
5040       vmSymbols::java_lang_ClassFormatError(),
5041       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5042       _class_name-&gt;as_C_string(), flags);
5043     return;
5044   }
5045 }
5046 
5047 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5048                                                     bool is_interface,
5049                                                     const Symbol* name,
5050                                                     TRAPS) const {
5051   if (!_need_verify) { return; }
5052 
5053   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5054   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5055   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5056   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5057   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5058   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5059   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5060   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5061   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5062   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5063   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5064   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5065   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5066 
5067   bool is_illegal = false;
5068 
5069   if (is_interface) {
5070     if (major_gte_8) {
5071       // Class file version is JAVA_8_VERSION or later Methods of
5072       // interfaces may set any of the flags except ACC_PROTECTED,
5073       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5074       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5075       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5076           (is_native || is_protected || is_final || is_synchronized) ||
5077           // If a specific method of a class or interface has its
5078           // ACC_ABSTRACT flag set, it must not have any of its
5079           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5080           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5081           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5082           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5083           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5084         is_illegal = true;
5085       }
5086     } else if (major_gte_1_5) {
5087       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5088       if (!is_public || is_private || is_protected || is_static || is_final ||
5089           is_synchronized || is_native || !is_abstract || is_strict) {
5090         is_illegal = true;
5091       }
5092     } else {
5093       // Class file version is pre-JAVA_1_5_VERSION
5094       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5095         is_illegal = true;
5096       }
5097     }
5098   } else { // not interface
5099     if (has_illegal_visibility(flags)) {
5100       is_illegal = true;
5101     } else {
5102       if (is_initializer) {
5103         if (is_static || is_final || is_synchronized || is_native ||
5104             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5105           is_illegal = true;
5106         }
5107       } else { // not initializer
5108         if (is_abstract) {
5109           if ((is_final || is_native || is_private || is_static ||
5110               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5111             is_illegal = true;
5112           }
5113         }
5114       }
5115     }
5116   }
5117 
5118   if (is_illegal) {
5119     ResourceMark rm(THREAD);
5120     Exceptions::fthrow(
5121       THREAD_AND_LOCATION,
5122       vmSymbols::java_lang_ClassFormatError(),
5123       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,
5124       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);
5125     return;
5126   }
5127 }
5128 
5129 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5130                                         int length,
5131                                         TRAPS) const {
5132   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5133   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5134     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5135   }
5136 }
5137 
5138 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5139 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5140 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5141 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5142 // method.  Because these names have been checked as special cases before
5143 // calling this method in verify_legal_method_name.
5144 //
5145 // This method is also called from the modular system APIs in modules.cpp
5146 // to verify the validity of module and package names.
5147 bool ClassFileParser::verify_unqualified_name(const char* name,
5148                                               unsigned int length,
5149                                               int type) {
5150   if (length == 0) return false;  // Must have at least one char.
5151   for (const char* p = name; p != name + length; p++) {
5152     switch(*p) {
5153       case JVM_SIGNATURE_DOT:
5154       case JVM_SIGNATURE_ENDCLASS:
5155       case JVM_SIGNATURE_ARRAY:
5156         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5157         return false;
5158       case JVM_SIGNATURE_SLASH:
5159         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5160         // unqualified name must not be empty
5161         if (type == ClassFileParser::LegalClass) {
5162           if (p == name || p+1 &gt;= name+length ||
5163               *(p+1) == JVM_SIGNATURE_SLASH) {
5164             return false;
5165           }
5166         } else {
5167           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5168         }
5169         break;
5170       case JVM_SIGNATURE_SPECIAL:
5171       case JVM_SIGNATURE_ENDSPECIAL:
5172         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5173         if (type == ClassFileParser::LegalMethod) {
5174           return false;
5175         }
5176     }
5177   }
5178   return true;
5179 }
5180 
5181 // Take pointer to a UTF8 byte string (not NUL-terminated).
5182 // Skip over the longest part of the string that could
5183 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5184 // Return a pointer to just past the fieldname.
5185 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5186 // being true, we saw consecutive slashes (meaning we were looking for a
5187 // qualified path but found something that was badly-formed).
5188 static const char* skip_over_field_name(const char* const name,
5189                                         bool slash_ok,
5190                                         unsigned int length) {
5191   const char* p;
5192   jboolean last_is_slash = false;
5193   jboolean not_first_ch = false;
5194 
5195   for (p = name; p != name + length; not_first_ch = true) {
5196     const char* old_p = p;
5197     jchar ch = *p;
5198     if (ch &lt; 128) {
5199       p++;
5200       // quick check for ascii
5201       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5202         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5203         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5204         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5205         last_is_slash = false;
5206         continue;
5207       }
5208       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5209         if (last_is_slash) {
5210           return NULL;  // Don&#39;t permit consecutive slashes
5211         }
5212         last_is_slash = true;
5213         continue;
5214       }
5215     }
5216     else {
5217       jint unicode_ch;
5218       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5219       p = tmp_p;
5220       last_is_slash = false;
5221       // Check if ch is Java identifier start or is Java identifier part
5222       // 4672820: call java.lang.Character methods directly without generating separate tables.
5223       EXCEPTION_MARK;
5224       // return value
5225       JavaValue result(T_BOOLEAN);
5226       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5227       JavaCallArguments args;
5228       args.push_int(unicode_ch);
5229 
5230       if (not_first_ch) {
5231         // public static boolean isJavaIdentifierPart(char ch);
5232         JavaCalls::call_static(&amp;result,
5233           SystemDictionary::Character_klass(),
5234           vmSymbols::isJavaIdentifierPart_name(),
5235           vmSymbols::int_bool_signature(),
5236           &amp;args,
5237           THREAD);
5238       } else {
5239         // public static boolean isJavaIdentifierStart(char ch);
5240         JavaCalls::call_static(&amp;result,
5241           SystemDictionary::Character_klass(),
5242           vmSymbols::isJavaIdentifierStart_name(),
5243           vmSymbols::int_bool_signature(),
5244           &amp;args,
5245           THREAD);
5246       }
5247       if (HAS_PENDING_EXCEPTION) {
5248         CLEAR_PENDING_EXCEPTION;
5249         return NULL;
5250       }
5251       if(result.get_jboolean()) {
5252         continue;
5253       }
5254     }
5255     return (not_first_ch) ? old_p : NULL;
5256   }
5257   return (not_first_ch) ? p : NULL;
5258 }
5259 
5260 // Take pointer to a UTF8 byte string (not NUL-terminated).
5261 // Skip over the longest part of the string that could
5262 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5263 // Return a pointer to just past the signature.
5264 // Return NULL if no legal signature is found.
5265 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5266                                                        bool void_ok,
5267                                                        unsigned int length,
5268                                                        TRAPS) const {
5269   unsigned int array_dim = 0;
5270   while (length &gt; 0) {
5271     switch (signature[0]) {
5272     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5273     case JVM_SIGNATURE_BOOLEAN:
5274     case JVM_SIGNATURE_BYTE:
5275     case JVM_SIGNATURE_CHAR:
5276     case JVM_SIGNATURE_SHORT:
5277     case JVM_SIGNATURE_INT:
5278     case JVM_SIGNATURE_FLOAT:
5279     case JVM_SIGNATURE_LONG:
5280     case JVM_SIGNATURE_DOUBLE:
5281       return signature + 1;
5282     case JVM_SIGNATURE_CLASS: {
5283       if (_major_version &lt; JAVA_1_5_VERSION) {
5284         // Skip over the class name if one is there
5285         const char* const p = skip_over_field_name(signature + 1, true, --length);
5286 
5287         // The next character better be a semicolon
5288         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5289           return p + 1;
5290         }
5291       }
5292       else {
5293         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
5294         signature++;
5295         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5296         // Format check signature
5297         if (c != NULL) {
5298           int newlen = c - (char*) signature;
5299           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5300           if (!legal) {
5301             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5302                                   &quot;in descriptor in class file %s&quot;,
5303                                   CHECK_0);
5304             return NULL;
5305           }
5306           return signature + newlen + 1;
5307         }
5308       }
5309       return NULL;
5310     }
5311     case JVM_SIGNATURE_ARRAY:
5312       array_dim++;
5313       if (array_dim &gt; 255) {
5314         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5315         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);
5316       }
5317       // The rest of what&#39;s there better be a legal signature
5318       signature++;
5319       length--;
5320       void_ok = false;
5321       break;
5322     default:
5323       return NULL;
5324     }
5325   }
5326   return NULL;
5327 }
5328 
5329 // Checks if name is a legal class name.
5330 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5331   if (!_need_verify || _relax_verify) { return; }
5332 
5333   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5334   char* bytes = (char*)name-&gt;bytes();
5335   unsigned int length = name-&gt;utf8_length();
5336   bool legal = false;
5337 
5338   if (length &gt; 0) {
5339     const char* p;
5340     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5341       p = skip_over_field_signature(bytes, false, length, CHECK);
5342       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5343     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5344       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5345         p = skip_over_field_name(bytes, true, length);
5346         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5347       }
5348     } else {
5349       // 4900761: relax the constraints based on JSR202 spec
5350       // Class names may be drawn from the entire Unicode character set.
5351       // Identifiers between &#39;/&#39; must be unqualified names.
5352       // The utf8 string has been verified when parsing cpool entries.
5353       legal = verify_unqualified_name(bytes, length, LegalClass);
5354     }
5355   }
5356   if (!legal) {
5357     ResourceMark rm(THREAD);
5358     assert(_class_name != NULL, &quot;invariant&quot;);
5359     Exceptions::fthrow(
5360       THREAD_AND_LOCATION,
5361       vmSymbols::java_lang_ClassFormatError(),
5362       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5363       _class_name-&gt;as_C_string()
5364     );
5365     return;
5366   }
5367 }
5368 
5369 // Checks if name is a legal field name.
5370 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5371   if (!_need_verify || _relax_verify) { return; }
5372 
5373   char* bytes = (char*)name-&gt;bytes();
5374   unsigned int length = name-&gt;utf8_length();
5375   bool legal = false;
5376 
5377   if (length &gt; 0) {
5378     if (_major_version &lt; JAVA_1_5_VERSION) {
5379       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5380         const char* p = skip_over_field_name(bytes, false, length);
5381         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5382       }
5383     } else {
5384       // 4881221: relax the constraints based on JSR202 spec
5385       legal = verify_unqualified_name(bytes, length, LegalField);
5386     }
5387   }
5388 
5389   if (!legal) {
5390     ResourceMark rm(THREAD);
5391     assert(_class_name != NULL, &quot;invariant&quot;);
5392     Exceptions::fthrow(
5393       THREAD_AND_LOCATION,
5394       vmSymbols::java_lang_ClassFormatError(),
5395       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5396       _class_name-&gt;as_C_string()
5397     );
5398     return;
5399   }
5400 }
5401 
5402 // Checks if name is a legal method name.
5403 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5404   if (!_need_verify || _relax_verify) { return; }
5405 
5406   assert(name != NULL, &quot;method name is null&quot;);
5407   char* bytes = (char*)name-&gt;bytes();
5408   unsigned int length = name-&gt;utf8_length();
5409   bool legal = false;
5410 
5411   if (length &gt; 0) {
5412     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5413       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5414         legal = true;
5415       }
5416     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5417       const char* p;
5418       p = skip_over_field_name(bytes, false, length);
5419       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5420     } else {
5421       // 4881221: relax the constraints based on JSR202 spec
5422       legal = verify_unqualified_name(bytes, length, LegalMethod);
5423     }
5424   }
5425 
5426   if (!legal) {
5427     ResourceMark rm(THREAD);
5428     assert(_class_name != NULL, &quot;invariant&quot;);
5429     Exceptions::fthrow(
5430       THREAD_AND_LOCATION,
5431       vmSymbols::java_lang_ClassFormatError(),
5432       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5433       _class_name-&gt;as_C_string()
5434     );
5435     return;
5436   }
5437 }
5438 
5439 
5440 // Checks if signature is a legal field signature.
5441 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5442                                                    const Symbol* signature,
5443                                                    TRAPS) const {
5444   if (!_need_verify) { return; }
5445 
5446   const char* const bytes = (const char* const)signature-&gt;bytes();
5447   const unsigned int length = signature-&gt;utf8_length();
5448   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5449 
5450   if (p == NULL || (p - bytes) != (int)length) {
5451     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5452   }
5453 }
5454 
5455 // Checks if signature is a legal method signature.
5456 // Returns number of parameters
5457 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5458                                                    const Symbol* signature,
5459                                                    TRAPS) const {
5460   if (!_need_verify) {
5461     // make sure caller&#39;s args_size will be less than 0 even for non-static
5462     // method so it will be recomputed in compute_size_of_parameters().
5463     return -2;
5464   }
5465 
5466   // Class initializers cannot have args for class format version &gt;= 51.
5467   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5468       signature != vmSymbols::void_method_signature() &amp;&amp;
5469       _major_version &gt;= JAVA_7_VERSION) {
5470     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5471     return 0;
5472   }
5473 
5474   unsigned int args_size = 0;
5475   const char* p = (const char*)signature-&gt;bytes();
5476   unsigned int length = signature-&gt;utf8_length();
5477   const char* nextp;
5478 
5479   // The first character must be a &#39;(&#39;
5480   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5481     length--;
5482     // Skip over legal field signatures
5483     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5484     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5485       args_size++;
5486       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5487         args_size++;
5488       }
5489       length -= nextp - p;
5490       p = nextp;
5491       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5492     }
5493     // The first non-signature thing better be a &#39;)&#39;
5494     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5495       length--;
5496       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
5497         // All internal methods must return void
5498         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5499           return args_size;
5500         }
5501       } else {
5502         // Now we better just have a return value
5503         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5504         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5505           return args_size;
5506         }
5507       }
5508     }
5509   }
5510   // Report error
5511   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5512   return 0;
5513 }
5514 
5515 int ClassFileParser::static_field_size() const {
5516   assert(_field_info != NULL, &quot;invariant&quot;);
5517   return _field_info-&gt;static_field_size;
5518 }
5519 
5520 int ClassFileParser::total_oop_map_count() const {
5521   assert(_field_info != NULL, &quot;invariant&quot;);
5522   return _field_info-&gt;total_oop_map_count;
5523 }
5524 
5525 jint ClassFileParser::layout_size() const {
5526   assert(_field_info != NULL, &quot;invariant&quot;);
5527   return _field_info-&gt;instance_size;
5528 }
5529 
5530 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5531                                          const Array&lt;Method*&gt;* methods) {
5532   assert(ik != NULL, &quot;invariant&quot;);
5533   assert(methods != NULL, &quot;invariant&quot;);
5534 
5535   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5536   // (We used to do this lazily, but now we query it in Rewriter,
5537   // which is eagerly done for every method, so we might as well do it now,
5538   // when everything is fresh in memory.)
5539   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5540 
5541   if (klass_id != vmSymbols::NO_SID) {
5542     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5543       Method* method = methods-&gt;at(j);
5544       method-&gt;init_intrinsic_id();
5545 
5546       if (CheckIntrinsics) {
5547         // Check if an intrinsic is defined for method &#39;method&#39;,
5548         // but the method is not annotated with @HotSpotIntrinsicCandidate.
5549         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
5550             !method-&gt;intrinsic_candidate()) {
5551               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5552               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
5553               method-&gt;name_and_sig_as_C_string(),
5554               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5555             );
5556           tty-&gt;cr();
5557           DEBUG_ONLY(vm_exit(1));
5558         }
5559         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
5560         // but there is no intrinsic available for it.
5561         if (method-&gt;intrinsic_candidate() &amp;&amp;
5562           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
5563             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
5564               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
5565               method-&gt;name_and_sig_as_C_string(),
5566               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5567             );
5568           tty-&gt;cr();
5569           DEBUG_ONLY(vm_exit(1));
5570         }
5571       }
5572     } // end for
5573 
5574 #ifdef ASSERT
5575     if (CheckIntrinsics) {
5576       // Check for orphan methods in the current class. A method m
5577       // of a class C is orphan if an intrinsic is defined for method m,
5578       // but class C does not declare m.
5579       // The check is potentially expensive, therefore it is available
5580       // only in debug builds.
5581 
5582       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
5583         if (vmIntrinsics::_compiledLambdaForm == id) {
5584           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
5585           // generated for the JVM from a LambdaForm and therefore no method
5586           // is defined for it.
5587           continue;
5588         }
5589 
5590         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
5591           // Check if the current class contains a method with the same
5592           // name, flags, signature.
5593           bool match = false;
5594           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5595             const Method* method = methods-&gt;at(j);
5596             if (method-&gt;intrinsic_id() == id) {
5597               match = true;
5598               break;
5599             }
5600           }
5601 
5602           if (!match) {
5603             char buf[1000];
5604             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5605                        &quot;but the method is not available in class [%s].%s&quot;,
5606                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5607                                                              buf, sizeof(buf)),
5608                         ik-&gt;name()-&gt;as_C_string(),
5609                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5610             );
5611             tty-&gt;cr();
5612             DEBUG_ONLY(vm_exit(1));
5613           }
5614         }
5615       } // end for
5616     } // CheckIntrinsics
5617 #endif // ASSERT
5618   }
5619 }
5620 
5621 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5622   if (_klass != NULL) {
5623     return _klass;
5624   }
5625 
5626   InstanceKlass* const ik =
5627     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5628 
5629   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5630 
5631   assert(_klass == ik, &quot;invariant&quot;);
5632 
5633 
5634   if (ik-&gt;should_store_fingerprint()) {
5635     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5636   }
5637 
5638   ik-&gt;set_has_passed_fingerprint_check(false);
5639   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5640     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5641     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5642     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5643       // This class matches with a class saved in an AOT library
5644       ik-&gt;set_has_passed_fingerprint_check(true);
5645     } else {
5646       ResourceMark rm;
5647       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5648                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5649     }
5650   }
5651 
5652   return ik;
5653 }
5654 
5655 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5656   assert(ik != NULL, &quot;invariant&quot;);
5657 
5658   // Set name and CLD before adding to CLD
5659   ik-&gt;set_class_loader_data(_loader_data);
5660   ik-&gt;set_name(_class_name);
5661 
5662   // Add all classes to our internal class loader list here,
5663   // including classes in the bootstrap (NULL) class loader.
5664   const bool publicize = !is_internal();
5665 
5666   _loader_data-&gt;add_class(ik, publicize);
5667 
5668   set_klass_to_deallocate(ik);
5669 
5670   assert(_field_info != NULL, &quot;invariant&quot;);
5671   assert(ik-&gt;static_field_size() == _field_info-&gt;static_field_size, &quot;sanity&quot;);
5672   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;total_oop_map_count,
5673     &quot;sanity&quot;);
5674 
5675   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5676   assert(ik-&gt;size_helper() == _field_info-&gt;instance_size, &quot;sanity&quot;);
5677 
5678   // Fill in information already parsed
5679   ik-&gt;set_should_verify_class(_need_verify);
5680 
5681   // Not yet: supers are done below to support the new subtype-checking fields
5682   ik-&gt;set_nonstatic_field_size(_field_info-&gt;nonstatic_field_size);
5683   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;has_nonstatic_fields);
5684   assert(_fac != NULL, &quot;invariant&quot;);
5685   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5686 
5687   // this transfers ownership of a lot of arrays from
5688   // the parser onto the InstanceKlass*
5689   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5690 
5691   // note that is not safe to use the fields in the parser from this point on
5692   assert(NULL == _cp, &quot;invariant&quot;);
5693   assert(NULL == _fields, &quot;invariant&quot;);
5694   assert(NULL == _methods, &quot;invariant&quot;);
5695   assert(NULL == _inner_classes, &quot;invariant&quot;);
5696   assert(NULL == _nest_members, &quot;invariant&quot;);
5697   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5698   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5699   assert(NULL == _record_components, &quot;invariant&quot;);
5700 
5701   if (_has_final_method) {
5702     ik-&gt;set_has_final_method();
5703   }
5704 
5705   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5706   // The InstanceKlass::_methods_jmethod_ids cache
5707   // is managed on the assumption that the initial cache
5708   // size is equal to the number of methods in the class. If
5709   // that changes, then InstanceKlass::idnum_can_increment()
5710   // has to be changed accordingly.
5711   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5712 
5713   ik-&gt;set_this_class_index(_this_class_index);
5714 
5715   if (is_unsafe_anonymous()) {
5716     // _this_class_index is a CONSTANT_Class entry that refers to this
5717     // anonymous class itself. If this class needs to refer to its own methods or
5718     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5719     // _this_class_index. However, because this class is anonymous (it&#39;s
5720     // not stored in SystemDictionary), _this_class_index cannot be resolved
5721     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5722     // Therefore, we must eagerly resolve _this_class_index now.
5723     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5724   }
5725 
5726   ik-&gt;set_minor_version(_minor_version);
5727   ik-&gt;set_major_version(_major_version);
5728   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5729   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
5730 
5731   if (_unsafe_anonymous_host != NULL) {
5732     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5733     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5734   }
5735 
5736   // Set PackageEntry for this_klass
5737   oop cl = ik-&gt;class_loader();
5738   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5739   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5740   ik-&gt;set_package(cld, CHECK);
5741 
5742   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5743   assert(methods != NULL, &quot;invariant&quot;);
5744   const int methods_len = methods-&gt;length();
5745 
5746   check_methods_for_intrinsics(ik, methods);
5747 
5748   // Fill in field values obtained by parse_classfile_attributes
5749   if (_parsed_annotations-&gt;has_any_annotations()) {
5750     _parsed_annotations-&gt;apply_to(ik);
5751   }
5752 
5753   apply_parsed_class_attributes(ik);
5754 
5755   // Miranda methods
5756   if ((_num_miranda_methods &gt; 0) ||
5757       // if this class introduced new miranda methods or
5758       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5759         // super class exists and this class inherited miranda methods
5760      ) {
5761        ik-&gt;set_has_miranda_methods(); // then set a flag
5762   }
5763 
5764   // Fill in information needed to compute superclasses.
5765   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5766   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5767   _transitive_interfaces = NULL;
5768 
5769   // Initialize itable offset tables
5770   klassItable::setup_itable_offset_table(ik);
5771 
5772   // Compute transitive closure of interfaces this class implements
5773   // Do final class setup
5774   fill_oop_maps(ik,
5775                 _field_info-&gt;nonstatic_oop_map_count,
5776                 _field_info-&gt;nonstatic_oop_offsets,
5777                 _field_info-&gt;nonstatic_oop_counts);
5778 
5779   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5780   set_precomputed_flags(ik);
5781 
5782   // check if this class can access its super class
5783   check_super_class_access(ik, CHECK);
5784 
5785   // check if this class can access its superinterfaces
5786   check_super_interface_access(ik, CHECK);
5787 
5788   // check if this class overrides any final method
5789   check_final_method_override(ik, CHECK);
5790 
5791   // reject static interface methods prior to Java 8
5792   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5793     check_illegal_static_method(ik, CHECK);
5794   }
5795 
5796   // Obtain this_klass&#39; module entry
5797   ModuleEntry* module_entry = ik-&gt;module();
5798   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
5799 
5800   // Obtain java.lang.Module
5801   Handle module_handle(THREAD, module_entry-&gt;module());
5802 
5803   // Allocate mirror and initialize static fields
5804   // The create_mirror() call will also call compute_modifiers()
5805   java_lang_Class::create_mirror(ik,
5806                                  Handle(THREAD, _loader_data-&gt;class_loader()),
5807                                  module_handle,
5808                                  _protection_domain,
5809                                  CHECK);
5810 
5811   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5812 
5813   // Generate any default methods - default methods are public interface methods
5814   // that have a default implementation.  This is new with Java 8.
5815   if (_has_nonstatic_concrete_methods) {
5816     DefaultMethods::generate_default_methods(ik,
5817                                              _all_mirandas,
5818                                              CHECK);
5819   }
5820 
5821   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5822   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5823       !module_entry-&gt;has_default_read_edges()) {
5824     if (!module_entry-&gt;set_has_default_read_edges()) {
5825       // We won a potential race
5826       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5827     }
5828   }
5829 
5830   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5831 
5832   if (!is_internal()) {
5833     if (log_is_enabled(Info, class, load)) {
5834       ResourceMark rm;
5835       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5836       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5837     }
5838 
5839     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5840         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5841         log_is_enabled(Info, class, preview)) {
5842       ResourceMark rm;
5843       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5844                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5845     }
5846 
5847     if (log_is_enabled(Debug, class, resolve))  {
5848       ResourceMark rm;
5849       // print out the superclass.
5850       const char * from = ik-&gt;external_name();
5851       if (ik-&gt;java_super() != NULL) {
5852         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5853                    from,
5854                    ik-&gt;java_super()-&gt;external_name());
5855       }
5856       // print out each of the interface classes referred to by this class.
5857       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5858       if (local_interfaces != NULL) {
5859         const int length = local_interfaces-&gt;length();
5860         for (int i = 0; i &lt; length; i++) {
5861           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5862           const char * to = k-&gt;external_name();
5863           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5864         }
5865       }
5866     }
5867   }
5868 
5869   JFR_ONLY(INIT_ID(ik);)
5870 
5871   // If we reach here, all is well.
5872   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5873   // in order for it to not be destroyed in the ClassFileParser destructor.
5874   set_klass_to_deallocate(NULL);
5875 
5876   // it&#39;s official
5877   set_klass(ik);
5878 
5879   debug_only(ik-&gt;verify();)
5880 }
5881 
5882 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5883   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5884   _class_name-&gt;decrement_refcount();
5885 
5886   _class_name = new_class_name;
5887   // Increment the refcount of the new name.
5888   // Now the ClassFileParser owns this name and will decrement in
5889   // the destructor.
5890   _class_name-&gt;increment_refcount();
5891 }
5892 
5893 
5894 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5895 // package by prepending its host class&#39;s package name to its class name and setting
5896 // its _class_name field.
5897 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5898   ResourceMark rm(THREAD);
5899   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
5900          &quot;Unsafe anonymous class should not be in a package&quot;);
5901   const char* host_pkg_name =
5902     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
5903 
5904   if (host_pkg_name != NULL) {
5905     int host_pkg_len = (int)strlen(host_pkg_name);
5906     int class_name_len = _class_name-&gt;utf8_length();
5907     int symbol_len = host_pkg_len + 1 + class_name_len;
5908     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
5909     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
5910                          host_pkg_name, class_name_len, _class_name-&gt;base());
5911     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
5912 
5913     // Decrement old _class_name to avoid leaking.
5914     _class_name-&gt;decrement_refcount();
5915 
5916     // Create a symbol and update the anonymous class name.
5917     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
5918     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
5919     // when the class is unloaded.
5920     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
5921   }
5922 }
5923 
5924 // If the host class and the anonymous class are in the same package then do
5925 // nothing.  If the anonymous class is in the unnamed package then move it to its
5926 // host&#39;s package.  If the classes are in different packages then throw an IAE
5927 // exception.
5928 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
5929   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
5930 
5931   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
5932                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
5933   if (anon_last_slash == NULL) {  // Unnamed package
5934     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
5935   } else {
5936     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
5937       ResourceMark rm(THREAD);
5938       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
5939         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
5940         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
5941     }
5942   }
5943 }
5944 
5945 static bool relax_format_check_for(ClassLoaderData* loader_data) {
5946   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
5947                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
5948   bool need_verify =
5949     // verifyAll
5950     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
5951     // verifyRemote
5952     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
5953   return !need_verify;
5954 }
5955 
5956 ClassFileParser::ClassFileParser(ClassFileStream* stream,
5957                                  Symbol* name,
5958                                  ClassLoaderData* loader_data,
5959                                  Handle protection_domain,
5960                                  const InstanceKlass* unsafe_anonymous_host,
5961                                  GrowableArray&lt;Handle&gt;* cp_patches,
5962                                  Publicity pub_level,
5963                                  TRAPS) :
5964   _stream(stream),
5965   _requested_name(name),
5966   _class_name(NULL),
5967   _loader_data(loader_data),
5968   _unsafe_anonymous_host(unsafe_anonymous_host),
5969   _cp_patches(cp_patches),
5970   _num_patched_klasses(0),
5971   _max_num_patched_klasses(0),
5972   _orig_cp_size(0),
5973   _first_patched_klass_resolved_index(0),
5974   _super_klass(),
5975   _cp(NULL),
5976   _fields(NULL),
5977   _methods(NULL),
5978   _inner_classes(NULL),
5979   _nest_members(NULL),
5980   _nest_host(0),
5981   _record_components(NULL),
5982   _local_interfaces(NULL),
5983   _transitive_interfaces(NULL),
5984   _combined_annotations(NULL),
5985   _class_annotations(NULL),
5986   _class_type_annotations(NULL),
5987   _fields_annotations(NULL),
5988   _fields_type_annotations(NULL),
5989   _klass(NULL),
5990   _klass_to_deallocate(NULL),
5991   _parsed_annotations(NULL),
5992   _fac(NULL),
5993   _field_info(NULL),
5994   _method_ordering(NULL),
5995   _all_mirandas(NULL),
5996   _vtable_size(0),
5997   _itable_size(0),
5998   _num_miranda_methods(0),
5999   _rt(REF_NONE),
6000   _protection_domain(protection_domain),
6001   _access_flags(),
6002   _pub_level(pub_level),
6003   _bad_constant_seen(0),
6004   _synthetic_flag(false),
6005   _sde_length(false),
6006   _sde_buffer(NULL),
6007   _sourcefile_index(0),
6008   _generic_signature_index(0),
6009   _major_version(0),
6010   _minor_version(0),
6011   _this_class_index(0),
6012   _super_class_index(0),
6013   _itfs_len(0),
6014   _java_fields_count(0),
6015   _need_verify(false),
6016   _relax_verify(false),
6017   _has_nonstatic_concrete_methods(false),
6018   _declares_nonstatic_concrete_methods(false),
6019   _has_final_method(false),
6020   _has_finalizer(false),
6021   _has_empty_finalizer(false),
6022   _has_vanilla_constructor(false),
6023   _max_bootstrap_specifier_index(-1) {
6024 
6025   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6026   _class_name-&gt;increment_refcount();
6027 
6028   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6029   assert(_loader_data != NULL, &quot;invariant&quot;);
6030   assert(stream != NULL, &quot;invariant&quot;);
6031   assert(_stream != NULL, &quot;invariant&quot;);
6032   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6033   assert(_class_name != NULL, &quot;invariant&quot;);
6034   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6035 
6036   // Figure out whether we can skip format checking (matching classic VM behavior)
6037   if (DumpSharedSpaces) {
6038     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6039     // Verification decision is based on BytecodeVerificationRemote flag
6040     // for those classes.
6041     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6042                                               BytecodeVerificationLocal;
6043   }
6044   else {
6045     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6046                                                stream-&gt;need_verify());
6047   }
6048   if (_cp_patches != NULL) {
6049     int len = _cp_patches-&gt;length();
6050     for (int i=0; i&lt;len; i++) {
6051       if (has_cp_patch_at(i)) {
6052         Handle patch = cp_patch_at(i);
6053         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6054           // We need to append the names of the patched classes to the end of the constant pool,
6055           // because a patched class may have a Utf8 name that&#39;s not already included in the
6056           // original constant pool. These class names are used when patch_constant_pool()
6057           // calls patch_class().
6058           //
6059           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6060           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6061           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6062           _max_num_patched_klasses++;
6063         }
6064       }
6065     }
6066   }
6067 
6068   // synch back verification state to stream
6069   stream-&gt;set_verify(_need_verify);
6070 
6071   // Check if verification needs to be relaxed for this class file
6072   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6073   _relax_verify = relax_format_check_for(_loader_data);
6074 
6075   parse_stream(stream, CHECK);
6076 
6077   post_process_parsed_stream(stream, _cp, CHECK);
6078 }
6079 
6080 void ClassFileParser::clear_class_metadata() {
6081   // metadata created before the instance klass is created.  Must be
6082   // deallocated if classfile parsing returns an error.
6083   _cp = NULL;
6084   _fields = NULL;
6085   _methods = NULL;
6086   _inner_classes = NULL;
6087   _nest_members = NULL;
6088   _local_interfaces = NULL;
6089   _combined_annotations = NULL;
6090   _class_annotations = _class_type_annotations = NULL;
6091   _fields_annotations = _fields_type_annotations = NULL;
6092   _record_components = NULL;
6093 }
6094 
6095 // Destructor to clean up
6096 ClassFileParser::~ClassFileParser() {
6097   _class_name-&gt;decrement_refcount();
6098 
6099   if (_cp != NULL) {
6100     MetadataFactory::free_metadata(_loader_data, _cp);
6101   }
6102   if (_fields != NULL) {
6103     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6104   }
6105 
6106   if (_methods != NULL) {
6107     // Free methods
6108     InstanceKlass::deallocate_methods(_loader_data, _methods);
6109   }
6110 
6111   // beware of the Universe::empty_blah_array!!
6112   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6113     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6114   }
6115 
6116   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6117     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6118   }
6119 
6120   if (_record_components != NULL) {
6121     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6122   }
6123 
6124   // Free interfaces
6125   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6126                                        _local_interfaces, _transitive_interfaces);
6127 
6128   if (_combined_annotations != NULL) {
6129     // After all annotations arrays have been created, they are installed into the
6130     // Annotations object that will be assigned to the InstanceKlass being created.
6131 
6132     // Deallocate the Annotations object and the installed annotations arrays.
6133     _combined_annotations-&gt;deallocate_contents(_loader_data);
6134 
6135     // If the _combined_annotations pointer is non-NULL,
6136     // then the other annotations fields should have been cleared.
6137     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6138     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6139     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6140     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6141   } else {
6142     // If the annotations arrays were not installed into the Annotations object,
6143     // then they have to be deallocated explicitly.
6144     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6145     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6146     Annotations::free_contents(_loader_data, _fields_annotations);
6147     Annotations::free_contents(_loader_data, _fields_type_annotations);
6148   }
6149 
6150   clear_class_metadata();
6151   _transitive_interfaces = NULL;
6152 
6153   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6154   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6155   // at a safepoint.
6156   if (_klass_to_deallocate != NULL) {
6157     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6158   }
6159 }
6160 
6161 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6162                                    TRAPS) {
6163 
6164   assert(stream != NULL, &quot;invariant&quot;);
6165   assert(_class_name != NULL, &quot;invariant&quot;);
6166 
6167   // BEGIN STREAM PARSING
6168   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6169   // Magic value
6170   const u4 magic = stream-&gt;get_u4_fast();
6171   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6172                      &quot;Incompatible magic value %u in class file %s&quot;,
6173                      magic, CHECK);
6174 
6175   // Version numbers
6176   _minor_version = stream-&gt;get_u2_fast();
6177   _major_version = stream-&gt;get_u2_fast();
6178 
6179   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6180     ResourceMark rm;
6181     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6182             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6183     Exceptions::fthrow(
6184       THREAD_AND_LOCATION,
6185       vmSymbols::java_lang_UnsupportedClassVersionError(),
6186       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6187       _major_version,
6188       _minor_version);
6189   }
6190 
6191   // Check version numbers - we check this even with verifier off
6192   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6193 
6194   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6195   u2 cp_size = stream-&gt;get_u2_fast();
6196 
6197   guarantee_property(
6198     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6199     cp_size, CHECK);
6200 
6201   _orig_cp_size = cp_size;
6202   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6203     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6204   }
6205   cp_size += _max_num_patched_klasses;
6206 
6207   _cp = ConstantPool::allocate(_loader_data,
6208                                cp_size,
6209                                CHECK);
6210 
6211   ConstantPool* const cp = _cp;
6212 
6213   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6214 
6215   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6216 
6217   // ACCESS FLAGS
6218   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6219 
6220   // Access flags
6221   jint flags;
6222   // JVM_ACC_MODULE is defined in JDK-9 and later.
6223   if (_major_version &gt;= JAVA_9_VERSION) {
6224     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);
6225   } else {
6226     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;
6227   }
6228 
6229   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6230     // Set abstract bit for old class files for backward compatibility
6231     flags |= JVM_ACC_ABSTRACT;
6232   }
6233 
6234   verify_legal_class_modifiers(flags, CHECK);
6235 
6236   short bad_constant = class_bad_constant_seen();
6237   if (bad_constant != 0) {
6238     // Do not throw CFE until after the access_flags are checked because if
6239     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6240     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6241   }
6242 
6243   _access_flags.set_flags(flags);
6244 
6245   // This class and superclass
6246   _this_class_index = stream-&gt;get_u2_fast();
6247   check_property(
6248     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6249       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6250     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6251     _this_class_index, CHECK);
6252 
6253   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6254   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6255 
6256   // Update _class_name to reflect the name in the constant pool
6257   update_class_name(class_name_in_cp);
6258 
6259   // Don&#39;t need to check whether this class name is legal or not.
6260   // It has been checked when constant pool is parsed.
6261   // However, make sure it is not an array type.
6262   if (_need_verify) {
6263     guarantee_property(_class_name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6264                        &quot;Bad class name in class file %s&quot;,
6265                        CHECK);
6266   }
6267 
6268   // Checks if name in class file matches requested name
6269   if (_requested_name != NULL &amp;&amp; _requested_name != _class_name) {
6270     ResourceMark rm(THREAD);
6271     Exceptions::fthrow(
6272       THREAD_AND_LOCATION,
6273       vmSymbols::java_lang_NoClassDefFoundError(),
6274       &quot;%s (wrong name: %s)&quot;,
6275       _class_name-&gt;as_C_string(),
6276       _requested_name != NULL ? _requested_name-&gt;as_C_string() : &quot;NoName&quot;
6277     );
6278     return;
6279   }
6280 
6281   // if this is an anonymous class fix up its name if it&#39;s in the unnamed
6282   // package.  Otherwise, throw IAE if it is in a different package than
6283   // its host class.
6284   if (_unsafe_anonymous_host != NULL) {
6285     fix_unsafe_anonymous_class_name(CHECK);
6286   }
6287 
6288   // Verification prevents us from creating names with dots in them, this
6289   // asserts that that&#39;s the case.
6290   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6291 
6292   if (!is_internal()) {
6293     LogTarget(Debug, class, preorder) lt;
6294     if (lt.is_enabled()){
6295       ResourceMark rm(THREAD);
6296       LogStream ls(lt);
6297       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6298       if (stream-&gt;source() != NULL) {
6299         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6300       }
6301       ls.cr();
6302     }
6303 
6304 #if INCLUDE_CDS
6305     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6306       if (!ClassLoader::has_jrt_entry()) {
6307         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6308         DumpLoadedClassList = NULL;
6309       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6310                  _unsafe_anonymous_host == NULL) {
6311         // Only dump the classes that can be stored into CDS archive.
6312         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6313         oop class_loader = _loader_data-&gt;class_loader();
6314         ResourceMark rm(THREAD);
6315         bool skip = false;
6316         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6317           // For the boot and platform class loaders, skip classes that are not found in the
6318           // java runtime image, such as those found in the --patch-module entries.
6319           // These classes can&#39;t be loaded from the archive during runtime.
6320           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6321             skip = true;
6322           }
6323 
6324           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6325             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6326             // as they can be loaded from the archive during runtime.
6327             skip = false;
6328           }
6329         }
6330         if (skip) {
6331           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6332             _class_name-&gt;as_C_string(), stream-&gt;source());
6333         } else {
6334           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6335           classlist_file-&gt;flush();
6336         }
6337       }
6338     }
6339 #endif
6340   }
6341 
6342   // SUPERKLASS
6343   _super_class_index = stream-&gt;get_u2_fast();
6344   _super_klass = parse_super_class(cp,
6345                                    _super_class_index,
6346                                    _need_verify,
6347                                    CHECK);
6348 
6349   // Interfaces
6350   _itfs_len = stream-&gt;get_u2_fast();
6351   parse_interfaces(stream,
6352                    _itfs_len,
6353                    cp,
6354                    &amp;_has_nonstatic_concrete_methods,
6355                    CHECK);
6356 
6357   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6358 
6359   // Fields (offsets are filled in later)
6360   _fac = new FieldAllocationCount();
6361   parse_fields(stream,
6362                _access_flags.is_interface(),
6363                _fac,
6364                cp,
6365                cp_size,
6366                &amp;_java_fields_count,
6367                CHECK);
6368 
6369   assert(_fields != NULL, &quot;invariant&quot;);
6370 
6371   // Methods
6372   AccessFlags promoted_flags;
6373   parse_methods(stream,
6374                 _access_flags.is_interface(),
6375                 &amp;promoted_flags,
6376                 &amp;_has_final_method,
6377                 &amp;_declares_nonstatic_concrete_methods,
6378                 CHECK);
6379 
6380   assert(_methods != NULL, &quot;invariant&quot;);
6381 
6382   // promote flags from parse_methods() to the klass&#39; flags
6383   _access_flags.add_promoted_flags(promoted_flags.as_int());
6384 
6385   if (_declares_nonstatic_concrete_methods) {
6386     _has_nonstatic_concrete_methods = true;
6387   }
6388 
6389   // Additional attributes/annotations
6390   _parsed_annotations = new ClassAnnotationCollector();
6391   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6392 
6393   assert(_inner_classes != NULL, &quot;invariant&quot;);
6394 
6395   // Finalize the Annotations metadata object,
6396   // now that all annotation arrays have been created.
6397   create_combined_annotations(CHECK);
6398 
6399   // Make sure this is the end of class file stream
6400   guarantee_property(stream-&gt;at_eos(),
6401                      &quot;Extra bytes at the end of class file %s&quot;,
6402                      CHECK);
6403 
6404   // all bytes in stream read and parsed
6405 }
6406 
6407 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6408                                                  ConstantPool* cp,
6409                                                  TRAPS) {
6410   assert(stream != NULL, &quot;invariant&quot;);
6411   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6412   assert(cp != NULL, &quot;invariant&quot;);
6413   assert(_loader_data != NULL, &quot;invariant&quot;);
6414 
6415   if (_class_name == vmSymbols::java_lang_Object()) {
6416     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6417                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6418                    CHECK);
6419   }
6420   // We check super class after class file is parsed and format is checked
6421   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6422     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6423     if (_access_flags.is_interface()) {
6424       // Before attempting to resolve the superclass, check for class format
6425       // errors not checked yet.
6426       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6427         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6428         CHECK);
6429     }
6430     Handle loader(THREAD, _loader_data-&gt;class_loader());
6431     _super_klass = (const InstanceKlass*)
6432                        SystemDictionary::resolve_super_or_fail(_class_name,
6433                                                                super_class_name,
6434                                                                loader,
6435                                                                _protection_domain,
6436                                                                true,
6437                                                                CHECK);
6438   }
6439 
6440   if (_super_klass != NULL) {
6441     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6442       _has_nonstatic_concrete_methods = true;
6443     }
6444 
6445     if (_super_klass-&gt;is_interface()) {
6446       ResourceMark rm(THREAD);
6447       Exceptions::fthrow(
6448         THREAD_AND_LOCATION,
6449         vmSymbols::java_lang_IncompatibleClassChangeError(),
6450         &quot;class %s has interface %s as super class&quot;,
6451         _class_name-&gt;as_klass_external_name(),
6452         _super_klass-&gt;external_name()
6453       );
6454       return;
6455     }
6456     // Make sure super class is not final
6457     if (_super_klass-&gt;is_final()) {
6458       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6459     }
6460   }
6461 
6462   // Compute the transitive list of all unique interfaces implemented by this class
6463   _transitive_interfaces =
6464     compute_transitive_interfaces(_super_klass,
6465                                   _local_interfaces,
6466                                   _loader_data,
6467                                   CHECK);
6468 
6469   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6470 
6471   // sort methods
6472   _method_ordering = sort_methods(_methods);
6473 
6474   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6475 
6476   Handle loader(THREAD, _loader_data-&gt;class_loader());
6477   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6478                                                     &amp;_num_miranda_methods,
6479                                                     _all_mirandas,
6480                                                     _super_klass,
6481                                                     _methods,
6482                                                     _access_flags,
6483                                                     _major_version,
6484                                                     loader,
6485                                                     _class_name,
6486                                                     _local_interfaces,
6487                                                     CHECK);
6488 
6489   // Size of Java itable (in words)
6490   _itable_size = _access_flags.is_interface() ? 0 :
6491     klassItable::compute_itable_size(_transitive_interfaces);
6492 
6493   assert(_fac != NULL, &quot;invariant&quot;);
6494   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6495 
6496   _field_info = new FieldLayoutInfo();
6497   layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6498 
6499   // Compute reference typ
6500   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6501 
6502 }
6503 
6504 void ClassFileParser::set_klass(InstanceKlass* klass) {
6505 
6506 #ifdef ASSERT
6507   if (klass != NULL) {
6508     assert(NULL == _klass, &quot;leaking?&quot;);
6509   }
6510 #endif
6511 
6512   _klass = klass;
6513 }
6514 
6515 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6516 
6517 #ifdef ASSERT
6518   if (klass != NULL) {
6519     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6520   }
6521 #endif
6522 
6523   _klass_to_deallocate = klass;
6524 }
6525 
6526 // Caller responsible for ResourceMark
6527 // clone stream with rewound position
6528 const ClassFileStream* ClassFileParser::clone_stream() const {
6529   assert(_stream != NULL, &quot;invariant&quot;);
6530 
6531   return _stream-&gt;clone();
6532 }
6533 // ----------------------------------------------------------------------------
6534 // debugging
6535 
6536 #ifdef ASSERT
6537 
6538 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6539 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6540   if (class_name != NULL) {
6541     ResourceMark rm;
6542     char* name = class_name-&gt;as_C_string();
6543     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6544   } else {
6545     return true;
6546   }
6547 }
6548 
6549 #endif
    </pre>
  </body>
</html>