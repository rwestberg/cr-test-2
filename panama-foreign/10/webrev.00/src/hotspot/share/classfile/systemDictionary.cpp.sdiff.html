<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackMapTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;
<span class="line-removed">  77 #include &quot;runtime/fieldType.hpp&quot;</span>
  78 #include &quot;runtime/handles.inline.hpp&quot;
  79 #include &quot;runtime/java.hpp&quot;
  80 #include &quot;runtime/javaCalls.hpp&quot;
  81 #include &quot;runtime/mutexLocker.hpp&quot;
  82 #include &quot;runtime/sharedRuntime.hpp&quot;
  83 #include &quot;runtime/signature.hpp&quot;
  84 #include &quot;services/classLoadingService.hpp&quot;
  85 #include &quot;services/diagnosticCommand.hpp&quot;
  86 #include &quot;services/threadService.hpp&quot;
  87 #include &quot;utilities/macros.hpp&quot;
  88 #if INCLUDE_CDS
  89 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  90 #endif
  91 #if INCLUDE_JFR
  92 #include &quot;jfr/jfr.hpp&quot;
  93 #endif
  94 
  95 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  96 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  97 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
</pre>
<hr />
<pre>
 223     if (throw_error) {
 224       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 225     } else {
 226       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 227     }
 228   }
 229   return klass;
 230 }
 231 
 232 
 233 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 234                                            bool throw_error, TRAPS)
 235 {
 236   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 237 }
 238 
 239 
 240 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 241 
 242 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified"> 243   if (FieldType::is_array(class_name)) {</span>
 244     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 245   } else {
 246     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 247   }
 248 }
 249 
 250 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 251 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 252                                                                        Handle class_loader,
 253                                                                        Handle protection_domain,
 254                                                                        TRAPS) {
<span class="line-modified"> 255   assert(class_name != NULL &amp;&amp; !FieldType::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified"> 256   if (FieldType::is_obj(class_name)) {</span>
 257     ResourceMark rm(THREAD);
 258     // Ignore wrapping L and ;.
 259     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 260                                                  class_name-&gt;utf8_length() - 2);
 261     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 262   } else {
 263     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 264   }
 265 }
 266 
 267 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 268   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 269 }
 270 
 271 // Forwards to resolve_instance_class_or_null
 272 
 273 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 274                                                      Handle class_loader,
 275                                                      Handle protection_domain,
 276                                                      TRAPS) {
<span class="line-modified"> 277   assert(FieldType::is_array(class_name), &quot;must be array&quot;);</span>



 278   Klass* k = NULL;
<span class="line-modified"> 279   FieldArrayInfo fd;</span>
<span class="line-modified"> 280   // dimension and object_key in FieldArrayInfo are assigned as a side-effect</span>
<span class="line-modified"> 281   // of this call</span>
<span class="line-modified"> 282   BasicType t = FieldType::get_array_info(class_name, fd, CHECK_NULL);</span>
<span class="line-removed"> 283   if (t == T_OBJECT) {</span>
<span class="line-removed"> 284     // naked oop &quot;k&quot; is OK here -- we assign back into it</span>
<span class="line-removed"> 285     k = SystemDictionary::resolve_instance_class_or_null(fd.object_key(),</span>
 286                                                          class_loader,
 287                                                          protection_domain,
 288                                                          CHECK_NULL);
 289     if (k != NULL) {
<span class="line-modified"> 290       k = k-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
 291     }
 292   } else {
 293     k = Universe::typeArrayKlassObj(t);
<span class="line-modified"> 294     k = TypeArrayKlass::cast(k)-&gt;array_klass(fd.dimension(), CHECK_NULL);</span>
 295   }
 296   return k;
 297 }
 298 
 299 
 300 // Must be called for any super-class or super-interface resolution
 301 // during class definition to allow class circularity checking
 302 // super-interface callers:
 303 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 304 // super-class callers:
 305 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 306 //   load_shared_class - while loading a class from shared archive
 307 //   resolve_instance_class_or_null:
 308 //     via: handle_parallel_super_load
 309 //      when resolving a class that has an existing placeholder with
 310 //      a saved superclass [i.e. a defineClass is currently in progress]
 311 //      if another thread is trying to resolve the class, it must do
 312 //      super-class checks on its own thread to catch class circularity
 313 // This last call is critical in class circularity checking for cases
 314 // where classloading is delegated to different threads and the
</pre>
<hr />
<pre>
 325 //      3.4 calls resolve_super_or_fail Base
 326 //      3.5 finds T1,Base -&gt; throws class circularity
 327 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 328 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 329 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 330 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 331 //      4.4 finds T2, Super -&gt; throws class circularity
 332 // Must be called, even if superclass is null, since this is
 333 // where the placeholder entry is created which claims this
 334 // thread is loading this class/classloader.
 335 // Be careful when modifying this code: once you have run
 336 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 337 // you need to find_and_remove it before returning.
 338 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 339 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 340                                                        Symbol* super_name,
 341                                                        Handle class_loader,
 342                                                        Handle protection_domain,
 343                                                        bool is_superclass,
 344                                                        TRAPS) {
<span class="line-modified"> 345   assert(!FieldType::is_array(super_name), &quot;invalid super class name&quot;);</span>
 346 #if INCLUDE_CDS
 347   if (DumpSharedSpaces) {
 348     // Special processing for handling UNREGISTERED shared classes.
 349     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 350         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 351     if (k) {
 352       return k;
 353     }
 354   }
 355 #endif // INCLUDE_CDS
 356 
 357   // Double-check, if child class is already loaded, just return super-class,interface
 358   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 359   // dictionary.
 360   // Make sure there&#39;s a placeholder for the *child* before resolving.
 361   // Used as a claim that this thread is currently loading superclass/classloader
 362   // Used here for ClassCircularity checks and also for heap verification
 363   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 364   // Must check ClassCircularity before checking if super class is already loaded.
 365   //
</pre>
<hr />
<pre>
 637   assert(event != NULL, &quot;invariant&quot;);
 638   assert(k != NULL, &quot;invariant&quot;);
 639   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 640   event-&gt;set_loadedClass(k);
 641   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 642   event-&gt;set_initiatingClassLoader(init_cld);
 643   event-&gt;commit();
 644 }
 645 
 646 
 647 // Be careful when modifying this code: once you have run
 648 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 649 // you need to find_and_remove it before returning.
 650 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 651 //
 652 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 653 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 654                                                                 Handle class_loader,
 655                                                                 Handle protection_domain,
 656                                                                 TRAPS) {
<span class="line-modified"> 657   assert(name != NULL &amp;&amp; !FieldType::is_array(name) &amp;&amp;</span>
<span class="line-modified"> 658          !FieldType::is_obj(name), &quot;invalid class name&quot;);</span>
 659 
 660   EventClassLoad class_load_start_event;
 661 
 662   HandleMark hm(THREAD);
 663 
 664   // Fix for 4474172; see evaluation for more details
 665   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 666   ClassLoaderData* loader_data = register_loader(class_loader);
 667   Dictionary* dictionary = loader_data-&gt;dictionary();
 668   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 669 
 670   // Do lookup to see if class already exist and the protection domain
 671   // has the right access
 672   // This call uses find which checks protection domain already matches
 673   // All subsequent calls use find_class, and set has_loaded_class so that
 674   // before we return a result we call out to java to check for valid protection domain
 675   // to allow returning the Klass* and add it to the pd_set if it is valid
 676   {
 677     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 678     if (probe != NULL) return probe;
</pre>
<hr />
<pre>
 943     // then the class loader has no entries in the dictionary.
 944     return NULL;
 945   }
 946 
 947   Dictionary* dictionary = loader_data-&gt;dictionary();
 948   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 949   return dictionary-&gt;find(d_hash, class_name,
 950                           protection_domain);
 951 }
 952 
 953 
 954 // Look for a loaded instance or array klass by name.  Do not do any loading.
 955 // return NULL in case of error.
 956 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 957                                                       Handle class_loader,
 958                                                       Handle protection_domain,
 959                                                       TRAPS) {
 960   Klass* k = NULL;
 961   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 962 
<span class="line-modified"> 963   if (FieldType::is_array(class_name)) {</span>
 964     // The name refers to an array.  Parse the name.
 965     // dimension and object_key in FieldArrayInfo are assigned as a
 966     // side-effect of this call
<span class="line-modified"> 967     FieldArrayInfo fd;</span>
<span class="line-modified"> 968     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>

 969     if (t != T_OBJECT) {
 970       k = Universe::typeArrayKlassObj(t);
 971     } else {
<span class="line-modified"> 972       k = SystemDictionary::find(fd.object_key(), class_loader, protection_domain, THREAD);</span>

 973     }
 974     if (k != NULL) {
<span class="line-modified"> 975       k = k-&gt;array_klass_or_null(fd.dimension());</span>
 976     }
 977   } else {
 978     k = find(class_name, class_loader, protection_domain, THREAD);
 979   }
 980   return k;
 981 }
 982 
 983 // Note: this method is much like resolve_from_stream, but
 984 // does not publish the classes via the SystemDictionary.
 985 // Handles unsafe_DefineAnonymousClass and redefineclasses
 986 // RedefinedClasses do not add to the class hierarchy
 987 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
 988                                               Handle class_loader,
 989                                               Handle protection_domain,
 990                                               ClassFileStream* st,
 991                                               const InstanceKlass* unsafe_anonymous_host,
 992                                               GrowableArray&lt;Handle&gt;* cp_patches,
 993                                               TRAPS) {
 994 
 995   EventClassLoad class_load_start_event;
</pre>
<hr />
<pre>
2150 }
2151 
2152 
2153 // Try to find a class name using the loader constraints.  The
2154 // loader constraints might know about a class that isn&#39;t fully loaded
2155 // yet and these will be ignored.
2156 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2157                     Symbol* class_name, Handle class_loader, TRAPS) {
2158 
2159   // First see if it has been loaded directly.
2160   // Force the protection domain to be null.  (This removes protection checks.)
2161   Handle no_protection_domain;
2162   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2163                                               no_protection_domain, CHECK_NULL);
2164   if (klass != NULL)
2165     return klass;
2166 
2167   // Now look to see if it has been loaded elsewhere, and is subject to
2168   // a loader constraint that would require this loader to return the
2169   // klass that is already loaded.
<span class="line-modified">2170   if (FieldType::is_array(class_name)) {</span>
2171     // For array classes, their Klass*s are not kept in the
2172     // constraint table. The element Klass*s are.
<span class="line-modified">2173     FieldArrayInfo fd;</span>
<span class="line-modified">2174     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(NULL));</span>

2175     if (t != T_OBJECT) {
2176       klass = Universe::typeArrayKlassObj(t);
2177     } else {
2178       MutexLocker mu(THREAD, SystemDictionary_lock);
<span class="line-modified">2179       klass = constraints()-&gt;find_constrained_klass(fd.object_key(), class_loader);</span>
2180     }
2181     // If element class already loaded, allocate array klass
2182     if (klass != NULL) {
<span class="line-modified">2183       klass = klass-&gt;array_klass_or_null(fd.dimension());</span>
2184     }
2185   } else {
2186     MutexLocker mu(THREAD, SystemDictionary_lock);
2187     // Non-array classes are easy: simply check the constraint table.
2188     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2189   }
2190 
2191   return klass;
2192 }
2193 
2194 
2195 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2196                                              Handle class_loader1,
2197                                              Handle class_loader2,
2198                                              Thread* THREAD) {
2199   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2200   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2201 
2202   Symbol* constraint_name = NULL;
<span class="line-modified">2203   // Needs to be in same scope as constraint_name in case a Symbol is created and</span>
<span class="line-modified">2204   // assigned to constraint_name.</span>
<span class="line-removed">2205   FieldArrayInfo fd;</span>
<span class="line-removed">2206   if (!FieldType::is_array(class_name)) {</span>
2207     constraint_name = class_name;
2208   } else {
2209     // For array classes, their Klass*s are not kept in the
2210     // constraint table. The element classes are.
<span class="line-modified">2211     BasicType t = FieldType::get_array_info(class_name, fd, CHECK_(false));</span>
<span class="line-modified">2212     // primitive types always pass</span>
<span class="line-modified">2213     if (t != T_OBJECT) {</span>
<span class="line-modified">2214       return true;</span>
<span class="line-removed">2215     } else {</span>
<span class="line-removed">2216       constraint_name = fd.object_key();</span>
2217     }





2218   }
2219 
2220   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2221   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2222 
2223   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2224   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2225 
2226   {
2227     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2228     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2229     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">2230     return constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">2231                                     klass2, class_loader2);</span>




2232   }
2233 }
2234 
2235 // Add entry to resolution error table to record the error when the first
2236 // attempt to resolve a reference to a class has failed.
2237 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2238                                             Symbol* error, Symbol* message) {
2239   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2240   int index = resolution_errors()-&gt;hash_to_index(hash);
2241   {
2242     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2243     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2244   }
2245 }
2246 
2247 // Delete a resolution error for RedefineClasses for a constant pool is going away
2248 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2249   resolution_errors()-&gt;delete_entry(pool);
2250 }
2251 
</pre>
<hr />
<pre>
2308 // its supertype about the meaning of a type name, as long as that
2309 // class neither calls a relevant method of the supertype, nor is
2310 // called (perhaps via an override) from the supertype.
2311 //
2312 //
2313 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2314 //
2315 // Make sure all class components (including arrays) in the given
2316 // signature will be resolved to the same class in both loaders.
2317 // Returns the name of the type that failed a loader constraint check, or
2318 // NULL if no constraint failed.  No exception except OOME is thrown.
2319 // Arrays are not added to the loader constraint table, their elements are.
2320 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2321                                                Handle loader1, Handle loader2,
2322                                                bool is_method, TRAPS)  {
2323   // Nothing to do if loaders are the same.
2324   if (loader1() == loader2()) {
2325     return NULL;
2326   }
2327 
<span class="line-modified">2328   SignatureStream sig_strm(signature, is_method);</span>
<span class="line-modified">2329   while (!sig_strm.is_done()) {</span>
<span class="line-modified">2330     if (sig_strm.is_object()) {</span>
<span class="line-modified">2331       Symbol* sig = sig_strm.as_symbol();</span>


2332       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2333         return sig;
2334       }
2335     }
<span class="line-removed">2336     sig_strm.next();</span>
2337   }
2338   return NULL;
2339 }
2340 
2341 
2342 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2343                                                        Symbol* signature,
2344                                                        TRAPS) {
2345   methodHandle empty;
2346   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2347          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2348          iid != vmIntrinsics::_invokeGeneric,
2349          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2350 
2351   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2352   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2353   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2354   methodHandle m;
2355   if (spe == NULL || spe-&gt;method() == NULL) {
2356     spe = NULL;
</pre>
<hr />
<pre>
2402         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }
2403         tty-&gt;cr();
2404     #endif //PRODUCT
2405       }
2406       (*appendix_result) = Handle(THREAD, appendix);
2407       // the target is stored in the cpCache and if a reference to this
2408       // MemberName is dropped we need a way to make sure the
2409       // class_loader containing this method is kept alive.
2410       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2411       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2412       this_key-&gt;record_dependency(m-&gt;method_holder());
2413       return mh();
2414     }
2415   }
2416   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2417 }
2418 
2419 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2420                                                      Symbol* name,
2421                                                      Symbol* signature,
<span class="line-modified">2422                                                      Klass* accessing_klass,</span>
<span class="line-modified">2423                                                      Handle *appendix_result,</span>
<span class="line-modified">2424                                                      TRAPS) {</span>
2425   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2426   Handle method_type =
2427     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2428 
2429   int ref_kind = JVM_REF_invokeVirtual;
2430   oop name_oop = StringTable::intern(name, CHECK_NULL);
2431   Handle name_str (THREAD, name_oop);
2432   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2433   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2434 
2435   // This should not happen.  JDK code should take care of that.
2436   if (accessing_klass == NULL || method_type.is_null()) {
2437     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2438   }
2439 
2440   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2441   JavaCallArguments args;
2442   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2443   args.push_int(ref_kind);
2444   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
</pre>
<hr />
<pre>
2457 
2458 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2459 // We must ensure that all class loaders everywhere will reach this class, for any client.
2460 // This is a safe bet for public classes in java.lang, such as Object and String.
2461 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2462 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2463 static bool is_always_visible_class(oop mirror) {
2464   Klass* klass = java_lang_Class::as_Klass(mirror);
2465   if (klass-&gt;is_objArray_klass()) {
2466     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2467   }
2468   if (klass-&gt;is_typeArray_klass()) {
2469     return true; // primitive array
2470   }
2471   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2472   return klass-&gt;is_public() &amp;&amp;
2473          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2474           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2475 }
2476 
<span class="line-removed">2477 </span>
<span class="line-removed">2478 // Return the Java mirror (java.lang.Class instance) for a single-character</span>
<span class="line-removed">2479 // descriptor.  This result, when available, is the same as produced by the</span>
<span class="line-removed">2480 // heavier API point of the same name that takes a Symbol.</span>
<span class="line-removed">2481 oop SystemDictionary::find_java_mirror_for_type(char signature_char) {</span>
<span class="line-removed">2482   return java_lang_Class::primitive_mirror(char2type(signature_char));</span>
<span class="line-removed">2483 }</span>
<span class="line-removed">2484 </span>
2485 // Find or construct the Java mirror (java.lang.Class instance) for a
2486 // for the given field type signature, as interpreted relative to the
2487 // given class loader.  Handles primitives, void, references, arrays,
2488 // and all other reflectable types, except method types.
2489 // N.B.  Code in reflection should use this entry point.
2490 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2491                                                    Klass* accessing_klass,
2492                                                    Handle class_loader,
2493                                                    Handle protection_domain,
2494                                                    SignatureStream::FailureMode failure_mode,
2495                                                    TRAPS) {
2496   Handle empty;
2497 
2498   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2499          &quot;one or the other, or perhaps neither&quot;);
2500 
<span class="line-modified">2501   Symbol* type = signature;</span>
2502 
2503   // What we have here must be a valid field descriptor,
2504   // and all valid field descriptors are supported.
2505   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2506   if (type-&gt;utf8_length() == 1) {</span>
2507 
2508     // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">2509     char ch = type-&gt;char_at(0);</span>
<span class="line-removed">2510     assert(is_java_primitive(char2type(ch)) || ch == JVM_SIGNATURE_VOID, &quot;&quot;);</span>
<span class="line-removed">2511     return Handle(THREAD, find_java_mirror_for_type(ch));</span>
2512 
<span class="line-modified">2513   } else if (FieldType::is_obj(type) || FieldType::is_array(type)) {</span>
2514 
2515     // It&#39;s a reference type.
2516     if (accessing_klass != NULL) {
2517       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2518       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2519     }
2520     Klass* constant_type_klass;
2521     if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">2522       constant_type_klass = resolve_or_null(type, class_loader, protection_domain,</span>
2523                                             CHECK_(empty));
2524     } else {
2525       bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">2526       constant_type_klass = resolve_or_fail(type, class_loader, protection_domain,</span>
2527                                             throw_error, CHECK_(empty));
2528     }
2529     if (constant_type_klass == NULL) {
2530       return Handle();  // report failure this way
2531     }
2532     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());
2533 
2534     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2535     if (accessing_klass != NULL) {
2536       Klass* sel_klass = constant_type_klass;
2537       bool fold_type_to_class = true;
2538       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2539                                               fold_type_to_class, CHECK_(empty));
2540     }
2541 
2542     return mirror;
2543 
2544   }
2545 
2546   // Fall through to an error.
</pre>
<hr />
<pre>
2569     return Handle();  // do not attempt from within compiler, unless it was cached
2570   }
2571 
2572   Handle class_loader, protection_domain;
2573   if (accessing_klass != NULL) {
2574     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2575     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2576   }
2577   bool can_be_cached = true;
2578   int npts = ArgumentCount(signature).size();
2579   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2580   int arg = 0;
2581   Handle rt; // the return type from the signature
2582   ResourceMark rm(THREAD);
2583   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2584     oop mirror = NULL;
2585     if (can_be_cached) {
2586       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2587       mirror = ss.as_java_mirror(Handle(), Handle(),
2588                                  SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">2589       if (mirror == NULL || (ss.is_object() &amp;&amp; !is_always_visible_class(mirror))) {</span>
2590         // Fall back to accessing_klass context.
2591         can_be_cached = false;
2592       }
2593     }
2594     if (!can_be_cached) {
2595       // Resolve, throwing a real error if it doesn&#39;t work.
2596       mirror = ss.as_java_mirror(class_loader, protection_domain,
2597                                  SignatureStream::NCDFError, CHECK_(empty));
2598     }
2599     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2600     if (ss.at_return_type())
2601       rt = Handle(THREAD, mirror);
2602     else
2603       pts-&gt;obj_at_put(arg++, mirror);
2604 
2605     // Check accessibility.
2606     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2607       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2608       mirror = NULL;  // safety
2609       // Emulate ConstantPool::verify_constant_pool_resolve.
</pre>
</td>
<td>
<hr />
<pre>
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;

  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;
  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  89 #endif
  90 #if INCLUDE_JFR
  91 #include &quot;jfr/jfr.hpp&quot;
  92 #endif
  93 
  94 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  95 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  96 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
</pre>
<hr />
<pre>
 222     if (throw_error) {
 223       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 224     } else {
 225       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 226     }
 227   }
 228   return klass;
 229 }
 230 
 231 
 232 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 233                                            bool throw_error, TRAPS)
 234 {
 235   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 236 }
 237 
 238 
 239 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 240 
 241 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
<span class="line-modified"> 242   if (Signature::is_array(class_name)) {</span>
 243     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 244   } else {
 245     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 246   }
 247 }
 248 
 249 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 250 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 251                                                                        Handle class_loader,
 252                                                                        Handle protection_domain,
 253                                                                        TRAPS) {
<span class="line-modified"> 254   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);</span>
<span class="line-modified"> 255   if (Signature::has_envelope(class_name)) {</span>
 256     ResourceMark rm(THREAD);
 257     // Ignore wrapping L and ;.
 258     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 259                                                  class_name-&gt;utf8_length() - 2);
 260     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 261   } else {
 262     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 263   }
 264 }
 265 
 266 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 267   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 268 }
 269 
 270 // Forwards to resolve_instance_class_or_null
 271 
 272 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 273                                                      Handle class_loader,
 274                                                      Handle protection_domain,
 275                                                      TRAPS) {
<span class="line-modified"> 276   assert(Signature::is_array(class_name), &quot;must be array&quot;);</span>
<span class="line-added"> 277   ResourceMark rm(THREAD);</span>
<span class="line-added"> 278   SignatureStream ss(class_name, false);</span>
<span class="line-added"> 279   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
 280   Klass* k = NULL;
<span class="line-modified"> 281   BasicType t = ss.type();</span>
<span class="line-modified"> 282   if (ss.has_envelope()) {</span>
<span class="line-modified"> 283     Symbol* obj_class = ss.as_symbol();</span>
<span class="line-modified"> 284     k = SystemDictionary::resolve_instance_class_or_null(obj_class,</span>



 285                                                          class_loader,
 286                                                          protection_domain,
 287                                                          CHECK_NULL);
 288     if (k != NULL) {
<span class="line-modified"> 289       k = k-&gt;array_klass(ndims, CHECK_NULL);</span>
 290     }
 291   } else {
 292     k = Universe::typeArrayKlassObj(t);
<span class="line-modified"> 293     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);</span>
 294   }
 295   return k;
 296 }
 297 
 298 
 299 // Must be called for any super-class or super-interface resolution
 300 // during class definition to allow class circularity checking
 301 // super-interface callers:
 302 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 303 // super-class callers:
 304 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 305 //   load_shared_class - while loading a class from shared archive
 306 //   resolve_instance_class_or_null:
 307 //     via: handle_parallel_super_load
 308 //      when resolving a class that has an existing placeholder with
 309 //      a saved superclass [i.e. a defineClass is currently in progress]
 310 //      if another thread is trying to resolve the class, it must do
 311 //      super-class checks on its own thread to catch class circularity
 312 // This last call is critical in class circularity checking for cases
 313 // where classloading is delegated to different threads and the
</pre>
<hr />
<pre>
 324 //      3.4 calls resolve_super_or_fail Base
 325 //      3.5 finds T1,Base -&gt; throws class circularity
 326 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 327 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 328 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 329 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 330 //      4.4 finds T2, Super -&gt; throws class circularity
 331 // Must be called, even if superclass is null, since this is
 332 // where the placeholder entry is created which claims this
 333 // thread is loading this class/classloader.
 334 // Be careful when modifying this code: once you have run
 335 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 336 // you need to find_and_remove it before returning.
 337 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 338 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 339                                                        Symbol* super_name,
 340                                                        Handle class_loader,
 341                                                        Handle protection_domain,
 342                                                        bool is_superclass,
 343                                                        TRAPS) {
<span class="line-modified"> 344   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);</span>
 345 #if INCLUDE_CDS
 346   if (DumpSharedSpaces) {
 347     // Special processing for handling UNREGISTERED shared classes.
 348     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 349         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 350     if (k) {
 351       return k;
 352     }
 353   }
 354 #endif // INCLUDE_CDS
 355 
 356   // Double-check, if child class is already loaded, just return super-class,interface
 357   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 358   // dictionary.
 359   // Make sure there&#39;s a placeholder for the *child* before resolving.
 360   // Used as a claim that this thread is currently loading superclass/classloader
 361   // Used here for ClassCircularity checks and also for heap verification
 362   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 363   // Must check ClassCircularity before checking if super class is already loaded.
 364   //
</pre>
<hr />
<pre>
 636   assert(event != NULL, &quot;invariant&quot;);
 637   assert(k != NULL, &quot;invariant&quot;);
 638   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 639   event-&gt;set_loadedClass(k);
 640   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 641   event-&gt;set_initiatingClassLoader(init_cld);
 642   event-&gt;commit();
 643 }
 644 
 645 
 646 // Be careful when modifying this code: once you have run
 647 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 648 // you need to find_and_remove it before returning.
 649 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 650 //
 651 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 652 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 653                                                                 Handle class_loader,
 654                                                                 Handle protection_domain,
 655                                                                 TRAPS) {
<span class="line-modified"> 656   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;</span>
<span class="line-modified"> 657          !Signature::has_envelope(name), &quot;invalid class name&quot;);</span>
 658 
 659   EventClassLoad class_load_start_event;
 660 
 661   HandleMark hm(THREAD);
 662 
 663   // Fix for 4474172; see evaluation for more details
 664   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 665   ClassLoaderData* loader_data = register_loader(class_loader);
 666   Dictionary* dictionary = loader_data-&gt;dictionary();
 667   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 668 
 669   // Do lookup to see if class already exist and the protection domain
 670   // has the right access
 671   // This call uses find which checks protection domain already matches
 672   // All subsequent calls use find_class, and set has_loaded_class so that
 673   // before we return a result we call out to java to check for valid protection domain
 674   // to allow returning the Klass* and add it to the pd_set if it is valid
 675   {
 676     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 677     if (probe != NULL) return probe;
</pre>
<hr />
<pre>
 942     // then the class loader has no entries in the dictionary.
 943     return NULL;
 944   }
 945 
 946   Dictionary* dictionary = loader_data-&gt;dictionary();
 947   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 948   return dictionary-&gt;find(d_hash, class_name,
 949                           protection_domain);
 950 }
 951 
 952 
 953 // Look for a loaded instance or array klass by name.  Do not do any loading.
 954 // return NULL in case of error.
 955 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 956                                                       Handle class_loader,
 957                                                       Handle protection_domain,
 958                                                       TRAPS) {
 959   Klass* k = NULL;
 960   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 961 
<span class="line-modified"> 962   if (Signature::is_array(class_name)) {</span>
 963     // The name refers to an array.  Parse the name.
 964     // dimension and object_key in FieldArrayInfo are assigned as a
 965     // side-effect of this call
<span class="line-modified"> 966     SignatureStream ss(class_name, false);</span>
<span class="line-modified"> 967     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added"> 968     BasicType t = ss.type();</span>
 969     if (t != T_OBJECT) {
 970       k = Universe::typeArrayKlassObj(t);
 971     } else {
<span class="line-modified"> 972       Symbol* obj_class = ss.as_symbol();</span>
<span class="line-added"> 973       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
 974     }
 975     if (k != NULL) {
<span class="line-modified"> 976       k = k-&gt;array_klass_or_null(ndims);</span>
 977     }
 978   } else {
 979     k = find(class_name, class_loader, protection_domain, THREAD);
 980   }
 981   return k;
 982 }
 983 
 984 // Note: this method is much like resolve_from_stream, but
 985 // does not publish the classes via the SystemDictionary.
 986 // Handles unsafe_DefineAnonymousClass and redefineclasses
 987 // RedefinedClasses do not add to the class hierarchy
 988 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
 989                                               Handle class_loader,
 990                                               Handle protection_domain,
 991                                               ClassFileStream* st,
 992                                               const InstanceKlass* unsafe_anonymous_host,
 993                                               GrowableArray&lt;Handle&gt;* cp_patches,
 994                                               TRAPS) {
 995 
 996   EventClassLoad class_load_start_event;
</pre>
<hr />
<pre>
2151 }
2152 
2153 
2154 // Try to find a class name using the loader constraints.  The
2155 // loader constraints might know about a class that isn&#39;t fully loaded
2156 // yet and these will be ignored.
2157 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2158                     Symbol* class_name, Handle class_loader, TRAPS) {
2159 
2160   // First see if it has been loaded directly.
2161   // Force the protection domain to be null.  (This removes protection checks.)
2162   Handle no_protection_domain;
2163   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2164                                               no_protection_domain, CHECK_NULL);
2165   if (klass != NULL)
2166     return klass;
2167 
2168   // Now look to see if it has been loaded elsewhere, and is subject to
2169   // a loader constraint that would require this loader to return the
2170   // klass that is already loaded.
<span class="line-modified">2171   if (Signature::is_array(class_name)) {</span>
2172     // For array classes, their Klass*s are not kept in the
2173     // constraint table. The element Klass*s are.
<span class="line-modified">2174     SignatureStream ss(class_name, false);</span>
<span class="line-modified">2175     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-added">2176     BasicType t = ss.type();</span>
2177     if (t != T_OBJECT) {
2178       klass = Universe::typeArrayKlassObj(t);
2179     } else {
2180       MutexLocker mu(THREAD, SystemDictionary_lock);
<span class="line-modified">2181       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);</span>
2182     }
2183     // If element class already loaded, allocate array klass
2184     if (klass != NULL) {
<span class="line-modified">2185       klass = klass-&gt;array_klass_or_null(ndims);</span>
2186     }
2187   } else {
2188     MutexLocker mu(THREAD, SystemDictionary_lock);
2189     // Non-array classes are easy: simply check the constraint table.
2190     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2191   }
2192 
2193   return klass;
2194 }
2195 
2196 
2197 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2198                                              Handle class_loader1,
2199                                              Handle class_loader2,
2200                                              Thread* THREAD) {
2201   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2202   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2203 
2204   Symbol* constraint_name = NULL;
<span class="line-modified">2205 </span>
<span class="line-modified">2206   if (!Signature::is_array(class_name)) {</span>


2207     constraint_name = class_name;
2208   } else {
2209     // For array classes, their Klass*s are not kept in the
2210     // constraint table. The element classes are.
<span class="line-modified">2211     SignatureStream ss(class_name, false);</span>
<span class="line-modified">2212     ss.skip_array_prefix();  // skip all &#39;[&#39;s</span>
<span class="line-modified">2213     if (!ss.has_envelope()) {</span>
<span class="line-modified">2214       return true;     // primitive types always pass</span>


2215     }
<span class="line-added">2216     constraint_name = ss.as_symbol();</span>
<span class="line-added">2217     // Increment refcount to keep constraint_name alive after</span>
<span class="line-added">2218     // SignatureStream is destructed. It will be decremented below</span>
<span class="line-added">2219     // before returning.</span>
<span class="line-added">2220     constraint_name-&gt;increment_refcount();</span>
2221   }
2222 
2223   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2224   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2225 
2226   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2227   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2228 
2229   {
2230     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2231     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2232     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
<span class="line-modified">2233     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,</span>
<span class="line-modified">2234                                            klass2, class_loader2);</span>
<span class="line-added">2235     if (Signature::is_array(class_name)) {</span>
<span class="line-added">2236       constraint_name-&gt;decrement_refcount();</span>
<span class="line-added">2237     }</span>
<span class="line-added">2238     return result;</span>
2239   }
2240 }
2241 
2242 // Add entry to resolution error table to record the error when the first
2243 // attempt to resolve a reference to a class has failed.
2244 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2245                                             Symbol* error, Symbol* message) {
2246   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2247   int index = resolution_errors()-&gt;hash_to_index(hash);
2248   {
2249     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2250     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2251   }
2252 }
2253 
2254 // Delete a resolution error for RedefineClasses for a constant pool is going away
2255 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2256   resolution_errors()-&gt;delete_entry(pool);
2257 }
2258 
</pre>
<hr />
<pre>
2315 // its supertype about the meaning of a type name, as long as that
2316 // class neither calls a relevant method of the supertype, nor is
2317 // called (perhaps via an override) from the supertype.
2318 //
2319 //
2320 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2321 //
2322 // Make sure all class components (including arrays) in the given
2323 // signature will be resolved to the same class in both loaders.
2324 // Returns the name of the type that failed a loader constraint check, or
2325 // NULL if no constraint failed.  No exception except OOME is thrown.
2326 // Arrays are not added to the loader constraint table, their elements are.
2327 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2328                                                Handle loader1, Handle loader2,
2329                                                bool is_method, TRAPS)  {
2330   // Nothing to do if loaders are the same.
2331   if (loader1() == loader2()) {
2332     return NULL;
2333   }
2334 
<span class="line-modified">2335   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {</span>
<span class="line-modified">2336     if (ss.is_reference()) {</span>
<span class="line-modified">2337       Symbol* sig = ss.as_symbol();</span>
<span class="line-modified">2338       // Note: In the future, if template-like types can take</span>
<span class="line-added">2339       // arguments, we will want to recognize them and dig out class</span>
<span class="line-added">2340       // names hiding inside the argument lists.</span>
2341       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2342         return sig;
2343       }
2344     }

2345   }
2346   return NULL;
2347 }
2348 
2349 
2350 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2351                                                        Symbol* signature,
2352                                                        TRAPS) {
2353   methodHandle empty;
2354   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2355          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2356          iid != vmIntrinsics::_invokeGeneric,
2357          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2358 
2359   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2360   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2361   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2362   methodHandle m;
2363   if (spe == NULL || spe-&gt;method() == NULL) {
2364     spe = NULL;
</pre>
<hr />
<pre>
2410         if (appendix != NULL) { tty-&gt;print(&quot;appendix = &quot;); appendix-&gt;print(); }
2411         tty-&gt;cr();
2412     #endif //PRODUCT
2413       }
2414       (*appendix_result) = Handle(THREAD, appendix);
2415       // the target is stored in the cpCache and if a reference to this
2416       // MemberName is dropped we need a way to make sure the
2417       // class_loader containing this method is kept alive.
2418       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2419       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2420       this_key-&gt;record_dependency(m-&gt;method_holder());
2421       return mh();
2422     }
2423   }
2424   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2425 }
2426 
2427 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2428                                                      Symbol* name,
2429                                                      Symbol* signature,
<span class="line-modified">2430                                                           Klass* accessing_klass,</span>
<span class="line-modified">2431                                                           Handle *appendix_result,</span>
<span class="line-modified">2432                                                           TRAPS) {</span>
2433   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2434   Handle method_type =
2435     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2436 
2437   int ref_kind = JVM_REF_invokeVirtual;
2438   oop name_oop = StringTable::intern(name, CHECK_NULL);
2439   Handle name_str (THREAD, name_oop);
2440   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2441   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2442 
2443   // This should not happen.  JDK code should take care of that.
2444   if (accessing_klass == NULL || method_type.is_null()) {
2445     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2446   }
2447 
2448   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2449   JavaCallArguments args;
2450   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2451   args.push_int(ref_kind);
2452   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
</pre>
<hr />
<pre>
2465 
2466 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2467 // We must ensure that all class loaders everywhere will reach this class, for any client.
2468 // This is a safe bet for public classes in java.lang, such as Object and String.
2469 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2470 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2471 static bool is_always_visible_class(oop mirror) {
2472   Klass* klass = java_lang_Class::as_Klass(mirror);
2473   if (klass-&gt;is_objArray_klass()) {
2474     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2475   }
2476   if (klass-&gt;is_typeArray_klass()) {
2477     return true; // primitive array
2478   }
2479   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2480   return klass-&gt;is_public() &amp;&amp;
2481          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2482           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2483 }
2484 








2485 // Find or construct the Java mirror (java.lang.Class instance) for a
2486 // for the given field type signature, as interpreted relative to the
2487 // given class loader.  Handles primitives, void, references, arrays,
2488 // and all other reflectable types, except method types.
2489 // N.B.  Code in reflection should use this entry point.
2490 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2491                                                    Klass* accessing_klass,
2492                                                    Handle class_loader,
2493                                                    Handle protection_domain,
2494                                                    SignatureStream::FailureMode failure_mode,
2495                                                    TRAPS) {
2496   Handle empty;
2497 
2498   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2499          &quot;one or the other, or perhaps neither&quot;);
2500 
<span class="line-modified">2501   SignatureStream ss(signature, false);</span>
2502 
2503   // What we have here must be a valid field descriptor,
2504   // and all valid field descriptors are supported.
2505   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2506   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
2507 
2508     // It&#39;s a primitive.  (Void has a primitive mirror too.)
<span class="line-modified">2509     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>


2510 
<span class="line-modified">2511   } else if (ss.is_reference()) {</span>
2512 
2513     // It&#39;s a reference type.
2514     if (accessing_klass != NULL) {
2515       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2516       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2517     }
2518     Klass* constant_type_klass;
2519     if (failure_mode == SignatureStream::ReturnNull) {
<span class="line-modified">2520       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
2521                                             CHECK_(empty));
2522     } else {
2523       bool throw_error = (failure_mode == SignatureStream::NCDFError);
<span class="line-modified">2524       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
2525                                             throw_error, CHECK_(empty));
2526     }
2527     if (constant_type_klass == NULL) {
2528       return Handle();  // report failure this way
2529     }
2530     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());
2531 
2532     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2533     if (accessing_klass != NULL) {
2534       Klass* sel_klass = constant_type_klass;
2535       bool fold_type_to_class = true;
2536       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
2537                                               fold_type_to_class, CHECK_(empty));
2538     }
2539 
2540     return mirror;
2541 
2542   }
2543 
2544   // Fall through to an error.
</pre>
<hr />
<pre>
2567     return Handle();  // do not attempt from within compiler, unless it was cached
2568   }
2569 
2570   Handle class_loader, protection_domain;
2571   if (accessing_klass != NULL) {
2572     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2573     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2574   }
2575   bool can_be_cached = true;
2576   int npts = ArgumentCount(signature).size();
2577   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2578   int arg = 0;
2579   Handle rt; // the return type from the signature
2580   ResourceMark rm(THREAD);
2581   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2582     oop mirror = NULL;
2583     if (can_be_cached) {
2584       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2585       mirror = ss.as_java_mirror(Handle(), Handle(),
2586                                  SignatureStream::ReturnNull, CHECK_(empty));
<span class="line-modified">2587       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {</span>
2588         // Fall back to accessing_klass context.
2589         can_be_cached = false;
2590       }
2591     }
2592     if (!can_be_cached) {
2593       // Resolve, throwing a real error if it doesn&#39;t work.
2594       mirror = ss.as_java_mirror(class_loader, protection_domain,
2595                                  SignatureStream::NCDFError, CHECK_(empty));
2596     }
2597     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2598     if (ss.at_return_type())
2599       rt = Handle(THREAD, mirror);
2600     else
2601       pts-&gt;obj_at_put(arg++, mirror);
2602 
2603     // Check accessibility.
2604     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2605       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2606       mirror = NULL;  // safety
2607       // Emulate ConstantPool::verify_constant_pool_resolve.
</pre>
</td>
</tr>
</table>
<center><a href="stackMapTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>