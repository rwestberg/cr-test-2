<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.inline.hpp&quot;
  34 #include &quot;classfile/moduleEntry.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/verificationType.hpp&quot;
  39 #include &quot;classfile/verifier.hpp&quot;
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;logging/logStream.hpp&quot;
  43 #include &quot;memory/allocation.hpp&quot;
  44 #include &quot;memory/metadataFactory.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/resourceArea.hpp&quot;
  47 #include &quot;memory/universe.hpp&quot;
  48 #include &quot;oops/annotations.hpp&quot;
  49 #include &quot;oops/constantPool.inline.hpp&quot;
  50 #include &quot;oops/fieldStreams.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  53 #include &quot;oops/klass.inline.hpp&quot;
  54 #include &quot;oops/klassVtable.hpp&quot;
  55 #include &quot;oops/metadata.hpp&quot;
  56 #include &quot;oops/method.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/recordComponent.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.hpp&quot;
  66 #include &quot;runtime/perfData.hpp&quot;
  67 #include &quot;runtime/reflection.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/signature.hpp&quot;
  70 #include &quot;runtime/timer.hpp&quot;
  71 #include &quot;services/classLoadingService.hpp&quot;
  72 #include &quot;services/threadService.hpp&quot;
  73 #include &quot;utilities/align.hpp&quot;
  74 #include &quot;utilities/bitMap.inline.hpp&quot;
  75 #include &quot;utilities/copy.hpp&quot;
  76 #include &quot;utilities/exceptions.hpp&quot;
  77 #include &quot;utilities/globalDefinitions.hpp&quot;
  78 #include &quot;utilities/growableArray.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 #include &quot;utilities/ostream.hpp&quot;
  81 #include &quot;utilities/resourceHash.hpp&quot;
  82 #include &quot;utilities/utf8.hpp&quot;
  83 
  84 #if INCLUDE_CDS
  85 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  86 #endif
  87 #if INCLUDE_JFR
  88 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  89 #endif
  90 
  91 // We generally try to create the oops directly when parsing, rather than
  92 // allocating temporary data structures and copying the bytes twice. A
  93 // temporary area is only needed when parsing utf8 entries in the constant
  94 // pool and when parsing line number tables.
  95 
  96 // We add assert in debug mode when class format is not checked.
  97 
  98 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
  99 #define JAVA_MIN_SUPPORTED_VERSION        45
 100 #define JAVA_PREVIEW_MINOR_VERSION        65535
 101 
 102 // Used for two backward compatibility reasons:
 103 // - to check for new additions to the class file format in JDK1.5
 104 // - to check for bug fixes in the format checker in JDK1.5
 105 #define JAVA_1_5_VERSION                  49
 106 
 107 // Used for backward compatibility reasons:
 108 // - to check for javac bug fixes that happened after 1.5
 109 // - also used as the max version when running in jdk6
 110 #define JAVA_6_VERSION                    50
 111 
 112 // Used for backward compatibility reasons:
 113 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 114 #define JAVA_7_VERSION                    51
 115 
 116 // Extension method support.
 117 #define JAVA_8_VERSION                    52
 118 
 119 #define JAVA_9_VERSION                    53
 120 
 121 #define JAVA_10_VERSION                   54
 122 
 123 #define JAVA_11_VERSION                   55
 124 
 125 #define JAVA_12_VERSION                   56
 126 
 127 #define JAVA_13_VERSION                   57
 128 
 129 #define JAVA_14_VERSION                   58
 130 
 131 #define JAVA_15_VERSION                   59
 132 
 133 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 134   assert((bad_constant == JVM_CONSTANT_Module ||
 135           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 136          &quot;Unexpected bad constant pool entry&quot;);
 137   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 138 }
 139 
 140 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 141                                                   ConstantPool* cp,
 142                                                   const int length,
 143                                                   TRAPS) {
 144   assert(stream != NULL, &quot;invariant&quot;);
 145   assert(cp != NULL, &quot;invariant&quot;);
 146 
 147   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 148   // this function (_current can be allocated in a register, with scalar
 149   // replacement of aggregates). The _current pointer is copied back to
 150   // stream() when this function returns. DON&#39;T call another method within
 151   // this method that uses stream().
 152   const ClassFileStream cfs1 = *stream;
 153   const ClassFileStream* const cfs = &amp;cfs1;
 154 
 155   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 156   debug_only(const u1* const old_current = stream-&gt;current();)
 157 
 158   // Used for batching symbol allocations.
 159   const char* names[SymbolTable::symbol_alloc_batch_size];
 160   int lengths[SymbolTable::symbol_alloc_batch_size];
 161   int indices[SymbolTable::symbol_alloc_batch_size];
 162   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 163   int names_count = 0;
 164 
 165   // parsing  Index 0 is unused
 166   for (int index = 1; index &lt; length; index++) {
 167     // Each of the following case guarantees one more byte in the stream
 168     // for the following tag or the access_flags following constant pool,
 169     // so we don&#39;t need bounds-check for reading tag.
 170     const u1 tag = cfs-&gt;get_u1_fast();
 171     switch (tag) {
 172       case JVM_CONSTANT_Class : {
 173         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 174         const u2 name_index = cfs-&gt;get_u2_fast();
 175         cp-&gt;klass_index_at_put(index, name_index);
 176         break;
 177       }
 178       case JVM_CONSTANT_Fieldref: {
 179         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 180         const u2 class_index = cfs-&gt;get_u2_fast();
 181         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Methodref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_InterfaceMethodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_String : {
 200         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 201         const u2 string_index = cfs-&gt;get_u2_fast();
 202         cp-&gt;string_index_at_put(index, string_index);
 203         break;
 204       }
 205       case JVM_CONSTANT_MethodHandle :
 206       case JVM_CONSTANT_MethodType: {
 207         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 208           classfile_parse_error(
 209             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 210             tag, CHECK);
 211         }
 212         if (tag == JVM_CONSTANT_MethodHandle) {
 213           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 214           const u1 ref_kind = cfs-&gt;get_u1_fast();
 215           const u2 method_index = cfs-&gt;get_u2_fast();
 216           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 217         }
 218         else if (tag == JVM_CONSTANT_MethodType) {
 219           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 220           const u2 signature_index = cfs-&gt;get_u2_fast();
 221           cp-&gt;method_type_index_at_put(index, signature_index);
 222         }
 223         else {
 224           ShouldNotReachHere();
 225         }
 226         break;
 227       }
 228       case JVM_CONSTANT_Dynamic : {
 229         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 230           classfile_parse_error(
 231               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 232               tag, CHECK);
 233         }
 234         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 235         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 236         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 237         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 238           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 239         }
 240         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 241         break;
 242       }
 243       case JVM_CONSTANT_InvokeDynamic : {
 244         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 245           classfile_parse_error(
 246               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 247               tag, CHECK);
 248         }
 249         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 250         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 251         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 252         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 253           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 254         }
 255         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 256         break;
 257       }
 258       case JVM_CONSTANT_Integer: {
 259         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 260         const u4 bytes = cfs-&gt;get_u4_fast();
 261         cp-&gt;int_at_put(index, (jint)bytes);
 262         break;
 263       }
 264       case JVM_CONSTANT_Float: {
 265         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 266         const u4 bytes = cfs-&gt;get_u4_fast();
 267         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 268         break;
 269       }
 270       case JVM_CONSTANT_Long: {
 271         // A mangled type might cause you to overrun allocated memory
 272         guarantee_property(index + 1 &lt; length,
 273                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 274                            index,
 275                            CHECK);
 276         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 277         const u8 bytes = cfs-&gt;get_u8_fast();
 278         cp-&gt;long_at_put(index, bytes);
 279         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 280         break;
 281       }
 282       case JVM_CONSTANT_Double: {
 283         // A mangled type might cause you to overrun allocated memory
 284         guarantee_property(index+1 &lt; length,
 285                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 286                            index,
 287                            CHECK);
 288         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 289         const u8 bytes = cfs-&gt;get_u8_fast();
 290         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 291         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 292         break;
 293       }
 294       case JVM_CONSTANT_NameAndType: {
 295         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 296         const u2 name_index = cfs-&gt;get_u2_fast();
 297         const u2 signature_index = cfs-&gt;get_u2_fast();
 298         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 299         break;
 300       }
 301       case JVM_CONSTANT_Utf8 : {
 302         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 303         u2  utf8_length = cfs-&gt;get_u2_fast();
 304         const u1* utf8_buffer = cfs-&gt;current();
 305         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 306         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 307         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 308         cfs-&gt;skip_u1_fast(utf8_length);
 309 
 310         // Before storing the symbol, make sure it&#39;s legal
 311         if (_need_verify) {
 312           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 313         }
 314 
 315         if (has_cp_patch_at(index)) {
 316           Handle patch = clear_cp_patch_at(index);
 317           guarantee_property(java_lang_String::is_instance(patch()),
 318                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 319                              index,
 320                              CHECK);
 321           const char* const str = java_lang_String::as_utf8_string(patch());
 322           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 323           utf8_buffer = (const u1*) str;
 324           utf8_length = (u2) strlen(str);
 325         }
 326 
 327         unsigned int hash;
 328         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 329                                                         utf8_length,
 330                                                         hash);
 331         if (result == NULL) {
 332           names[names_count] = (const char*)utf8_buffer;
 333           lengths[names_count] = utf8_length;
 334           indices[names_count] = index;
 335           hashValues[names_count++] = hash;
 336           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 337             SymbolTable::new_symbols(_loader_data,
 338                                      constantPoolHandle(THREAD, cp),
 339                                      names_count,
 340                                      names,
 341                                      lengths,
 342                                      indices,
 343                                      hashValues);
 344             names_count = 0;
 345           }
 346         } else {
 347           cp-&gt;symbol_at_put(index, result);
 348         }
 349         break;
 350       }
 351       case JVM_CONSTANT_Module:
 352       case JVM_CONSTANT_Package: {
 353         // Record that an error occurred in these two cases but keep parsing so
 354         // that ACC_Module can be checked for in the access_flags.  Need to
 355         // throw NoClassDefFoundError in that case.
 356         if (_major_version &gt;= JAVA_9_VERSION) {
 357           cfs-&gt;guarantee_more(3, CHECK);
 358           cfs-&gt;get_u2_fast();
 359           set_class_bad_constant_seen(tag);
 360           break;
 361         }
 362       }
 363       default: {
 364         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 365                               tag,
 366                               CHECK);
 367         break;
 368       }
 369     } // end of switch(tag)
 370   } // end of for
 371 
 372   // Allocate the remaining symbols
 373   if (names_count &gt; 0) {
 374     SymbolTable::new_symbols(_loader_data,
 375                              constantPoolHandle(THREAD, cp),
 376                              names_count,
 377                              names,
 378                              lengths,
 379                              indices,
 380                              hashValues);
 381   }
 382 
 383   // Copy _current pointer of local copy back to stream.
 384   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 385   stream-&gt;set_current(cfs1.current());
 386 
 387 }
 388 
 389 static inline bool valid_cp_range(int index, int length) {
 390   return (index &gt; 0 &amp;&amp; index &lt; length);
 391 }
 392 
 393 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 394   assert(cp != NULL, &quot;invariant&quot;);
 395   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 396     return cp-&gt;symbol_at(index);
 397   }
 398   return NULL;
 399 }
 400 
 401 #ifdef ASSERT
 402 PRAGMA_DIAG_PUSH
 403 PRAGMA_FORMAT_NONLITERAL_IGNORED
 404 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 405   ResourceMark rm(THREAD);
 406   fatal(msg, _class_name-&gt;as_C_string());
 407 }
 408 
 409 void ClassFileParser::report_assert_property_failure(const char* msg,
 410                                                      int index,
 411                                                      TRAPS) const {
 412   ResourceMark rm(THREAD);
 413   fatal(msg, index, _class_name-&gt;as_C_string());
 414 }
 415 PRAGMA_DIAG_POP
 416 #endif
 417 
 418 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 419                                          ConstantPool* const cp,
 420                                          const int length,
 421                                          TRAPS) {
 422   assert(cp != NULL, &quot;invariant&quot;);
 423   assert(stream != NULL, &quot;invariant&quot;);
 424 
 425   // parsing constant pool entries
 426   parse_constant_pool_entries(stream, cp, length, CHECK);
 427   if (class_bad_constant_seen() != 0) {
 428     // a bad CP entry has been detected previously so stop parsing and just return.
 429     return;
 430   }
 431 
 432   int index = 1;  // declared outside of loops for portability
 433   int num_klasses = 0;
 434 
 435   // first verification pass - validate cross references
 436   // and fixup class and string constants
 437   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 438     const jbyte tag = cp-&gt;tag_at(index).value();
 439     switch (tag) {
 440       case JVM_CONSTANT_Class: {
 441         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 442         break;
 443       }
 444       case JVM_CONSTANT_Fieldref:
 445         // fall through
 446       case JVM_CONSTANT_Methodref:
 447         // fall through
 448       case JVM_CONSTANT_InterfaceMethodref: {
 449         if (!_need_verify) break;
 450         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 451         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 452         check_property(valid_klass_reference_at(klass_ref_index),
 453                        &quot;Invalid constant pool index %u in class file %s&quot;,
 454                        klass_ref_index, CHECK);
 455         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 456           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 457           &quot;Invalid constant pool index %u in class file %s&quot;,
 458           name_and_type_ref_index, CHECK);
 459         break;
 460       }
 461       case JVM_CONSTANT_String: {
 462         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 463         break;
 464       }
 465       case JVM_CONSTANT_Integer:
 466         break;
 467       case JVM_CONSTANT_Float:
 468         break;
 469       case JVM_CONSTANT_Long:
 470       case JVM_CONSTANT_Double: {
 471         index++;
 472         check_property(
 473           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 474           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 475           index, CHECK);
 476         break;
 477       }
 478       case JVM_CONSTANT_NameAndType: {
 479         if (!_need_verify) break;
 480         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 481         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 482         check_property(valid_symbol_at(name_ref_index),
 483           &quot;Invalid constant pool index %u in class file %s&quot;,
 484           name_ref_index, CHECK);
 485         check_property(valid_symbol_at(signature_ref_index),
 486           &quot;Invalid constant pool index %u in class file %s&quot;,
 487           signature_ref_index, CHECK);
 488         break;
 489       }
 490       case JVM_CONSTANT_Utf8:
 491         break;
 492       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 493       case JVM_CONSTANT_UnresolvedClassInError: {
 494         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 495         break;
 496       }
 497       case JVM_CONSTANT_ClassIndex: {
 498         const int class_index = cp-&gt;klass_index_at(index);
 499         check_property(valid_symbol_at(class_index),
 500           &quot;Invalid constant pool index %u in class file %s&quot;,
 501           class_index, CHECK);
 502         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 503         break;
 504       }
 505       case JVM_CONSTANT_StringIndex: {
 506         const int string_index = cp-&gt;string_index_at(index);
 507         check_property(valid_symbol_at(string_index),
 508           &quot;Invalid constant pool index %u in class file %s&quot;,
 509           string_index, CHECK);
 510         Symbol* const sym = cp-&gt;symbol_at(string_index);
 511         cp-&gt;unresolved_string_at_put(index, sym);
 512         break;
 513       }
 514       case JVM_CONSTANT_MethodHandle: {
 515         const int ref_index = cp-&gt;method_handle_index_at(index);
 516         check_property(valid_cp_range(ref_index, length),
 517           &quot;Invalid constant pool index %u in class file %s&quot;,
 518           ref_index, CHECK);
 519         const constantTag tag = cp-&gt;tag_at(ref_index);
 520         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 521 
 522         switch (ref_kind) {
 523           case JVM_REF_getField:
 524           case JVM_REF_getStatic:
 525           case JVM_REF_putField:
 526           case JVM_REF_putStatic: {
 527             check_property(
 528               tag.is_field(),
 529               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 530               ref_index, CHECK);
 531             break;
 532           }
 533           case JVM_REF_invokeVirtual:
 534           case JVM_REF_newInvokeSpecial: {
 535             check_property(
 536               tag.is_method(),
 537               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 538               ref_index, CHECK);
 539             break;
 540           }
 541           case JVM_REF_invokeStatic:
 542           case JVM_REF_invokeSpecial: {
 543             check_property(
 544               tag.is_method() ||
 545               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 546               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 547               ref_index, CHECK);
 548             break;
 549           }
 550           case JVM_REF_invokeInterface: {
 551             check_property(
 552               tag.is_interface_method(),
 553               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 554               ref_index, CHECK);
 555             break;
 556           }
 557           default: {
 558             classfile_parse_error(
 559               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 560               index, CHECK);
 561           }
 562         } // switch(refkind)
 563         // Keep the ref_index unchanged.  It will be indirected at link-time.
 564         break;
 565       } // case MethodHandle
 566       case JVM_CONSTANT_MethodType: {
 567         const int ref_index = cp-&gt;method_type_index_at(index);
 568         check_property(valid_symbol_at(ref_index),
 569           &quot;Invalid constant pool index %u in class file %s&quot;,
 570           ref_index, CHECK);
 571         break;
 572       }
 573       case JVM_CONSTANT_Dynamic: {
 574         const int name_and_type_ref_index =
 575           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 576 
 577         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 578           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 579           &quot;Invalid constant pool index %u in class file %s&quot;,
 580           name_and_type_ref_index, CHECK);
 581         // bootstrap specifier index must be checked later,
 582         // when BootstrapMethods attr is available
 583 
 584         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 585         cp-&gt;set_has_dynamic_constant();
 586         break;
 587       }
 588       case JVM_CONSTANT_InvokeDynamic: {
 589         const int name_and_type_ref_index =
 590           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 591 
 592         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 593           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 594           &quot;Invalid constant pool index %u in class file %s&quot;,
 595           name_and_type_ref_index, CHECK);
 596         // bootstrap specifier index must be checked later,
 597         // when BootstrapMethods attr is available
 598         break;
 599       }
 600       default: {
 601         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 602         ShouldNotReachHere();
 603         break;
 604       }
 605     } // switch(tag)
 606   } // end of for
 607 
 608   _first_patched_klass_resolved_index = num_klasses;
 609   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 610 
 611   if (_cp_patches != NULL) {
 612     // need to treat this_class specially...
 613 
 614     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 615     // for now. These will be replaced with actual names of the patched classes in patch_class().
 616     Symbol* s = vmSymbols::star_name();
 617     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 618       cp-&gt;symbol_at_put(n, s);
 619     }
 620 
 621     int this_class_index;
 622     {
 623       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 624       const u1* const mark = stream-&gt;current();
 625       stream-&gt;skip_u2_fast(1); // skip flags
 626       this_class_index = stream-&gt;get_u2_fast();
 627       stream-&gt;set_current(mark);  // revert to mark
 628     }
 629 
 630     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 631       if (has_cp_patch_at(index)) {
 632         guarantee_property(index != this_class_index,
 633           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 634           index, CHECK);
 635         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 636       }
 637     }
 638   }
 639 
 640   if (!_need_verify) {
 641     return;
 642   }
 643 
 644   // second verification pass - checks the strings are of the right format.
 645   // but not yet to the other entries
 646   for (index = 1; index &lt; length; index++) {
 647     const jbyte tag = cp-&gt;tag_at(index).value();
 648     switch (tag) {
 649       case JVM_CONSTANT_UnresolvedClass: {
 650         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 651         // check the name, even if _cp_patches will overwrite it
 652         verify_legal_class_name(class_name, CHECK);
 653         break;
 654       }
 655       case JVM_CONSTANT_NameAndType: {
 656         if (_need_verify) {
 657           const int sig_index = cp-&gt;signature_ref_index_at(index);
 658           const int name_index = cp-&gt;name_ref_index_at(index);
 659           const Symbol* const name = cp-&gt;symbol_at(name_index);
 660           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 661           guarantee_property(sig-&gt;utf8_length() != 0,
 662             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 663             sig_index, CHECK);
 664           guarantee_property(name-&gt;utf8_length() != 0,
 665             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 666             name_index, CHECK);
 667 
<a name="1" id="anc1"></a><span class="line-modified"> 668           if (Signature::is_method(sig)) {</span>
 669             // Format check method name and signature
 670             verify_legal_method_name(name, CHECK);
 671             verify_legal_method_signature(name, sig, CHECK);
 672           } else {
 673             // Format check field name and signature
 674             verify_legal_field_name(name, CHECK);
 675             verify_legal_field_signature(name, sig, CHECK);
 676           }
 677         }
 678         break;
 679       }
 680       case JVM_CONSTANT_Dynamic: {
 681         const int name_and_type_ref_index =
 682           cp-&gt;name_and_type_ref_index_at(index);
 683         // already verified to be utf8
 684         const int name_ref_index =
 685           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 686         // already verified to be utf8
 687         const int signature_ref_index =
 688           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 689         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 690         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 691         if (_need_verify) {
 692           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
<a name="2" id="anc2"></a><span class="line-modified"> 693           // Need only to be sure signature is the right type.</span>
<span class="line-modified"> 694           if (Signature::is_method(signature)) {</span>

 695             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 696           }
 697         }
 698         break;
 699       }
 700       case JVM_CONSTANT_InvokeDynamic:
 701       case JVM_CONSTANT_Fieldref:
 702       case JVM_CONSTANT_Methodref:
 703       case JVM_CONSTANT_InterfaceMethodref: {
 704         const int name_and_type_ref_index =
 705           cp-&gt;name_and_type_ref_index_at(index);
 706         // already verified to be utf8
 707         const int name_ref_index =
 708           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 709         // already verified to be utf8
 710         const int signature_ref_index =
 711           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 712         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 713         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 714         if (tag == JVM_CONSTANT_Fieldref) {
 715           if (_need_verify) {
 716             // Field name and signature are verified above, when iterating NameAndType_info.
 717             // Need only to be sure signature is non-zero length and the right type.
<a name="3" id="anc3"></a><span class="line-modified"> 718             if (Signature::is_method(signature)) {</span>

 719               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 720             }
 721           }
 722         } else {
 723           if (_need_verify) {
 724             // Method name and signature are verified above, when iterating NameAndType_info.
 725             // Need only to be sure signature is non-zero length and the right type.
<a name="4" id="anc4"></a><span class="line-modified"> 726             if (!Signature::is_method(signature)) {</span>

 727               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 728             }
 729           }
 730           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 731           const unsigned int name_len = name-&gt;utf8_length();
 732           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 733               name_len != 0 &amp;&amp;
 734               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 735               name != vmSymbols::object_initializer_name()) {
 736             classfile_parse_error(
 737               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 738               name_ref_index, CHECK);
 739           }
 740         }
 741         break;
 742       }
 743       case JVM_CONSTANT_MethodHandle: {
 744         const int ref_index = cp-&gt;method_handle_index_at(index);
 745         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 746         switch (ref_kind) {
 747           case JVM_REF_invokeVirtual:
 748           case JVM_REF_invokeStatic:
 749           case JVM_REF_invokeSpecial:
 750           case JVM_REF_newInvokeSpecial: {
 751             const int name_and_type_ref_index =
 752               cp-&gt;name_and_type_ref_index_at(ref_index);
 753             const int name_ref_index =
 754               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 755             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 756             if (ref_kind == JVM_REF_newInvokeSpecial) {
 757               if (name != vmSymbols::object_initializer_name()) {
 758                 classfile_parse_error(
 759                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 760                     name_ref_index, CHECK);
 761               }
 762             } else {
 763               if (name == vmSymbols::object_initializer_name()) {
 764                 classfile_parse_error(
 765                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 766                   name_ref_index, CHECK);
 767               }
 768             }
 769             break;
 770           }
 771           // Other ref_kinds are already fully checked in previous pass.
 772         } // switch(ref_kind)
 773         break;
 774       }
 775       case JVM_CONSTANT_MethodType: {
 776         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 777         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 778         verify_legal_method_signature(no_name, signature, CHECK);
 779         break;
 780       }
 781       case JVM_CONSTANT_Utf8: {
 782         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 783       }
 784     }  // switch(tag)
 785   }  // end of for
 786 }
 787 
 788 Handle ClassFileParser::clear_cp_patch_at(int index) {
 789   Handle patch = cp_patch_at(index);
 790   _cp_patches-&gt;at_put(index, Handle());
 791   assert(!has_cp_patch_at(index), &quot;&quot;);
 792   return patch;
 793 }
 794 
 795 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 796   int name_index = _orig_cp_size + _num_patched_klasses;
 797   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 798 
 799   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 800   _num_patched_klasses ++;
 801 }
 802 
 803 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 804                                           int index,
 805                                           Handle patch,
 806                                           TRAPS) {
 807   assert(cp != NULL, &quot;invariant&quot;);
 808 
 809   BasicType patch_type = T_VOID;
 810 
 811   switch (cp-&gt;tag_at(index).value()) {
 812 
 813     case JVM_CONSTANT_UnresolvedClass: {
 814       // Patching a class means pre-resolving it.
 815       // The name in the constant pool is ignored.
 816       if (java_lang_Class::is_instance(patch())) {
 817         guarantee_property(!java_lang_Class::is_primitive(patch()),
 818                            &quot;Illegal class patch at %d in class file %s&quot;,
 819                            index, CHECK);
 820         Klass* k = java_lang_Class::as_Klass(patch());
 821         patch_class(cp, index, k, k-&gt;name());
 822       } else {
 823         guarantee_property(java_lang_String::is_instance(patch()),
 824                            &quot;Illegal class patch at %d in class file %s&quot;,
 825                            index, CHECK);
 826         Symbol* const name = java_lang_String::as_symbol(patch());
 827         patch_class(cp, index, NULL, name);
 828       }
 829       break;
 830     }
 831 
 832     case JVM_CONSTANT_String: {
 833       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 834       // references to be created first.
 835       return;
 836     }
 837     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 838     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 839     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 840     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 841     patch_prim:
 842     {
 843       jvalue value;
 844       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 845       guarantee_property(value_type == patch_type,
 846                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 847                          index, CHECK);
 848       switch (value_type) {
 849         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 850         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 851         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 852         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 853         default:       assert(false, &quot;&quot;);
 854       }
 855     } // end patch_prim label
 856     break;
 857 
 858     default: {
 859       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 860       guarantee_property(!has_cp_patch_at(index),
 861                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 862                          index, CHECK);
 863       return;
 864     }
 865   } // end of switch(tag)
 866 
 867   // On fall-through, mark the patch as used.
 868   clear_cp_patch_at(index);
 869 }
 870 class NameSigHash: public ResourceObj {
 871  public:
 872   const Symbol*       _name;       // name
 873   const Symbol*       _sig;        // signature
 874   NameSigHash*  _next;             // Next entry in hash table
 875 };
 876 
 877 static const int HASH_ROW_SIZE = 256;
 878 
 879 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 880   unsigned int raw_hash = 0;
 881   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 882   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 883 
 884   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 885 }
 886 
 887 
 888 static void initialize_hashtable(NameSigHash** table) {
 889   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 890 }
 891 // Return false if the name/sig combination is found in table.
 892 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 893 // The old format checker uses heap sort to find duplicates.
 894 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 895 // of table since we don&#39;t expect Symbol*&#39;s to move.
 896 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 897   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 898 
 899   // First lookup for duplicates
 900   int index = hash(name, sig);
 901   NameSigHash* entry = table[index];
 902   while (entry != NULL) {
 903     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 904       return false;
 905     }
 906     entry = entry-&gt;_next;
 907   }
 908 
 909   // No duplicate is found, allocate a new entry and fill it.
 910   entry = new NameSigHash();
 911   entry-&gt;_name = name;
 912   entry-&gt;_sig = sig;
 913 
 914   // Insert into hash table
 915   entry-&gt;_next = table[index];
 916   table[index] = entry;
 917 
 918   return true;
 919 }
 920 
 921 // Side-effects: populates the _local_interfaces field
 922 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,
 923                                        const int itfs_len,
 924                                        ConstantPool* const cp,
 925                                        bool* const has_nonstatic_concrete_methods,
 926                                        TRAPS) {
 927   assert(stream != NULL, &quot;invariant&quot;);
 928   assert(cp != NULL, &quot;invariant&quot;);
 929   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 930 
 931   if (itfs_len == 0) {
 932     _local_interfaces = Universe::the_empty_instance_klass_array();
 933   } else {
 934     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 935     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 936 
 937     int index;
 938     for (index = 0; index &lt; itfs_len; index++) {
 939       const u2 interface_index = stream-&gt;get_u2(CHECK);
 940       Klass* interf;
 941       check_property(
 942         valid_klass_reference_at(interface_index),
 943         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 944         interface_index, CHECK);
 945       if (cp-&gt;tag_at(interface_index).is_klass()) {
 946         interf = cp-&gt;resolved_klass_at(interface_index);
 947       } else {
 948         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 949 
 950         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 951         // But need to make sure it&#39;s not an array type.
 952         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 953                            &quot;Bad interface name in class file %s&quot;, CHECK);
 954 
 955         // Call resolve_super so classcircularity is checked
 956         interf = SystemDictionary::resolve_super_or_fail(
 957                                                   _class_name,
 958                                                   unresolved_klass,
 959                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 960                                                   _protection_domain,
 961                                                   false,
 962                                                   CHECK);
 963       }
 964 
 965       if (!interf-&gt;is_interface()) {
 966         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 967                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 968                           _class_name-&gt;as_klass_external_name(),
 969                           interf-&gt;external_name(),
 970                           interf-&gt;class_in_module_of_loader()));
 971       }
 972 
 973       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {
 974         *has_nonstatic_concrete_methods = true;
 975       }
 976       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));
 977     }
 978 
 979     if (!_need_verify || itfs_len &lt;= 1) {
 980       return;
 981     }
 982 
 983     // Check if there&#39;s any duplicates in interfaces
 984     ResourceMark rm(THREAD);
 985     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 986                                                                  NameSigHash*,
 987                                                                  HASH_ROW_SIZE);
 988     initialize_hashtable(interface_names);
 989     bool dup = false;
 990     const Symbol* name = NULL;
 991     {
 992       debug_only(NoSafepointVerifier nsv;)
 993       for (index = 0; index &lt; itfs_len; index++) {
 994         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
 995         name = k-&gt;name();
 996         // If no duplicates, add (name, NULL) in hashtable interface_names.
 997         if (!put_after_lookup(name, NULL, interface_names)) {
 998           dup = true;
 999           break;
1000         }
1001       }
1002     }
1003     if (dup) {
1004       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1005                              name-&gt;as_C_string(), CHECK);
1006     }
1007   }
1008 }
1009 
1010 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1011                                            int constantvalue_index,
1012                                            int signature_index,
1013                                            TRAPS) const {
1014   // Make sure the constant pool entry is of a type appropriate to this field
1015   guarantee_property(
1016     (constantvalue_index &gt; 0 &amp;&amp;
1017       constantvalue_index &lt; cp-&gt;length()),
1018     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1019     constantvalue_index, CHECK);
1020 
1021   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1022   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1023     case T_LONG: {
1024       guarantee_property(value_type.is_long(),
1025                          &quot;Inconsistent constant value type in class file %s&quot;,
1026                          CHECK);
1027       break;
1028     }
1029     case T_FLOAT: {
1030       guarantee_property(value_type.is_float(),
1031                          &quot;Inconsistent constant value type in class file %s&quot;,
1032                          CHECK);
1033       break;
1034     }
1035     case T_DOUBLE: {
1036       guarantee_property(value_type.is_double(),
1037                          &quot;Inconsistent constant value type in class file %s&quot;,
1038                          CHECK);
1039       break;
1040     }
1041     case T_BYTE:
1042     case T_CHAR:
1043     case T_SHORT:
1044     case T_BOOLEAN:
1045     case T_INT: {
1046       guarantee_property(value_type.is_int(),
1047                          &quot;Inconsistent constant value type in class file %s&quot;,
1048                          CHECK);
1049       break;
1050     }
1051     case T_OBJECT: {
1052       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1053                          &amp;&amp; value_type.is_string()),
1054                          &quot;Bad string initial value in class file %s&quot;,
1055                          CHECK);
1056       break;
1057     }
1058     default: {
1059       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1060                              constantvalue_index,
1061                              CHECK);
1062     }
1063   }
1064 }
1065 
1066 class AnnotationCollector : public ResourceObj{
1067 public:
1068   enum Location { _in_field, _in_method, _in_class };
1069   enum ID {
1070     _unknown = 0,
1071     _method_CallerSensitive,
1072     _method_ForceInline,
1073     _method_DontInline,
1074     _method_InjectedProfile,
1075     _method_LambdaForm_Compiled,
1076     _method_Hidden,
1077     _method_HotSpotIntrinsicCandidate,
1078     _jdk_internal_vm_annotation_Contended,
1079     _field_Stable,
1080     _jdk_internal_vm_annotation_ReservedStackAccess,
1081     _annotation_LIMIT
1082   };
1083   const Location _location;
1084   int _annotations_present;
1085   u2 _contended_group;
1086 
1087   AnnotationCollector(Location location)
1088     : _location(location), _annotations_present(0)
1089   {
1090     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1091   }
1092   // If this annotation name has an ID, report it (or _none).
1093   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);
1094   // Set the annotation name:
1095   void set_annotation(ID id) {
1096     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1097     _annotations_present |= nth_bit((int)id);
1098   }
1099 
1100   void remove_annotation(ID id) {
1101     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1102     _annotations_present &amp;= ~nth_bit((int)id);
1103   }
1104 
1105   // Report if the annotation is present.
1106   bool has_any_annotations() const { return _annotations_present != 0; }
1107   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1108 
1109   void set_contended_group(u2 group) { _contended_group = group; }
1110   u2 contended_group() const { return _contended_group; }
1111 
1112   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1113 
1114   void set_stable(bool stable) { set_annotation(_field_Stable); }
1115   bool is_stable() const { return has_annotation(_field_Stable); }
1116 };
1117 
1118 // This class also doubles as a holder for metadata cleanup.
1119 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1120 private:
1121   ClassLoaderData* _loader_data;
1122   AnnotationArray* _field_annotations;
1123   AnnotationArray* _field_type_annotations;
1124 public:
1125   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1126     AnnotationCollector(_in_field),
1127     _loader_data(loader_data),
1128     _field_annotations(NULL),
1129     _field_type_annotations(NULL) {}
1130   ~FieldAnnotationCollector();
1131   void apply_to(FieldInfo* f);
1132   AnnotationArray* field_annotations()      { return _field_annotations; }
1133   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1134 
1135   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1136   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1137 };
1138 
1139 class MethodAnnotationCollector : public AnnotationCollector{
1140 public:
1141   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1142   void apply_to(const methodHandle&amp; m);
1143 };
1144 
1145 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1146 public:
1147   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1148   void apply_to(InstanceKlass* ik);
1149 };
1150 
1151 
1152 static int skip_annotation_value(const u1*, int, int); // fwd decl
1153 
1154 // Safely increment index by val if does not pass limit
1155 #define SAFE_ADD(index, limit, val) \
1156 if (index &gt;= limit - val) return limit; \
1157 index += val;
1158 
1159 // Skip an annotation.  Return &gt;=limit if there is any problem.
1160 static int skip_annotation(const u1* buffer, int limit, int index) {
1161   assert(buffer != NULL, &quot;invariant&quot;);
1162   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1163   // value := switch (tag:u1) { ... }
1164   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1165   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1166   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1167     SAFE_ADD(index, limit, 2); // skip member
1168     index = skip_annotation_value(buffer, limit, index);
1169   }
1170   return index;
1171 }
1172 
1173 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1174 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1175   assert(buffer != NULL, &quot;invariant&quot;);
1176 
1177   // value := switch (tag:u1) {
1178   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1179   //   case e: e_class:u2 e_name:u2;
1180   //   case s: s_con:u2;
1181   //   case [: do(nval:u2) {value};
1182   //   case @: annotation;
1183   //   case s: s_con:u2;
1184   // }
1185   SAFE_ADD(index, limit, 1); // read tag
1186   const u1 tag = buffer[index - 1];
1187   switch (tag) {
1188     case &#39;B&#39;:
1189     case &#39;C&#39;:
1190     case &#39;I&#39;:
1191     case &#39;S&#39;:
1192     case &#39;Z&#39;:
1193     case &#39;D&#39;:
1194     case &#39;F&#39;:
1195     case &#39;J&#39;:
1196     case &#39;c&#39;:
1197     case &#39;s&#39;:
1198       SAFE_ADD(index, limit, 2);  // skip con or s_con
1199       break;
1200     case &#39;e&#39;:
1201       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1202       break;
1203     case &#39;[&#39;:
1204     {
1205       SAFE_ADD(index, limit, 2); // read nval
1206       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1207       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1208         index = skip_annotation_value(buffer, limit, index);
1209       }
1210     }
1211     break;
1212     case &#39;@&#39;:
1213       index = skip_annotation(buffer, limit, index);
1214       break;
1215     default:
1216       return limit;  //  bad tag byte
1217   }
1218   return index;
1219 }
1220 
1221 // Sift through annotations, looking for those significant to the VM:
1222 static void parse_annotations(const ConstantPool* const cp,
1223                               const u1* buffer, int limit,
1224                               AnnotationCollector* coll,
1225                               ClassLoaderData* loader_data,
1226                               TRAPS) {
1227 
1228   assert(cp != NULL, &quot;invariant&quot;);
1229   assert(buffer != NULL, &quot;invariant&quot;);
1230   assert(coll != NULL, &quot;invariant&quot;);
1231   assert(loader_data != NULL, &quot;invariant&quot;);
1232 
1233   // annotations := do(nann:u2) {annotation}
1234   int index = 2; // read nann
1235   if (index &gt;= limit)  return;
1236   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1237   enum {  // initial annotation layout
1238     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1239     count_off = 2,      // u2   such as 1 (one value)
1240     member_off = 4,     // utf8 such as &#39;value&#39;
1241     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1242     e_tag_val = &#39;e&#39;,
1243     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1244     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1245     e_size = 11,     // end of &#39;e&#39; annotation
1246     c_tag_val = &#39;c&#39;,    // payload is type
1247     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1248     c_size = 9,       // end of &#39;c&#39; annotation
1249     s_tag_val = &#39;s&#39;,    // payload is String
1250     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1251     s_size = 9,
1252     min_size = 6        // smallest possible size (zero members)
1253   };
1254   // Cannot add min_size to index in case of overflow MAX_INT
1255   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1256     int index0 = index;
1257     index = skip_annotation(buffer, limit, index);
1258     const u1* const abase = buffer + index0;
1259     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1260     const int count = Bytes::get_Java_u2((address)abase + count_off);
1261     const Symbol* const aname = check_symbol_at(cp, atype);
1262     if (aname == NULL)  break;  // invalid annotation name
1263     const Symbol* member = NULL;
1264     if (count &gt;= 1) {
1265       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1266       member = check_symbol_at(cp, member_index);
1267       if (member == NULL)  break;  // invalid member name
1268     }
1269 
1270     // Here is where parsing particular annotations will take place.
1271     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname);
1272     if (AnnotationCollector::_unknown == id)  continue;
1273     coll-&gt;set_annotation(id);
1274 
1275     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1276       // @Contended can optionally specify the contention group.
1277       //
1278       // Contended group defines the equivalence class over the fields:
1279       // the fields within the same contended group are not treated distinct.
1280       // The only exception is default group, which does not incur the
1281       // equivalence. Naturally, contention group for classes is meaningless.
1282       //
1283       // While the contention group is specified as String, annotation
1284       // values are already interned, and we might as well use the constant
1285       // pool index as the group tag.
1286       //
1287       u2 group_index = 0; // default contended group
1288       if (count == 1
1289         &amp;&amp; s_size == (index - index0)  // match size
1290         &amp;&amp; s_tag_val == *(abase + tag_off)
1291         &amp;&amp; member == vmSymbols::value_name()) {
1292         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1293         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1294           group_index = 0; // default contended group
1295         }
1296       }
1297       coll-&gt;set_contended_group(group_index);
1298     }
1299   }
1300 }
1301 
1302 
1303 // Parse attributes for a field.
1304 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1305                                              u2 attributes_count,
1306                                              bool is_static, u2 signature_index,
1307                                              u2* const constantvalue_index_addr,
1308                                              bool* const is_synthetic_addr,
1309                                              u2* const generic_signature_index_addr,
1310                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1311                                              TRAPS) {
1312   assert(cfs != NULL, &quot;invariant&quot;);
1313   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1314   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1315   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1316   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1317   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1318 
1319   u2 constantvalue_index = 0;
1320   u2 generic_signature_index = 0;
1321   bool is_synthetic = false;
1322   const u1* runtime_visible_annotations = NULL;
1323   int runtime_visible_annotations_length = 0;
1324   const u1* runtime_invisible_annotations = NULL;
1325   int runtime_invisible_annotations_length = 0;
1326   const u1* runtime_visible_type_annotations = NULL;
1327   int runtime_visible_type_annotations_length = 0;
1328   const u1* runtime_invisible_type_annotations = NULL;
1329   int runtime_invisible_type_annotations_length = 0;
1330   bool runtime_invisible_annotations_exists = false;
1331   bool runtime_invisible_type_annotations_exists = false;
1332   const ConstantPool* const cp = _cp;
1333 
1334   while (attributes_count--) {
1335     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1336     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1337     const u4 attribute_length = cfs-&gt;get_u4_fast();
1338     check_property(valid_symbol_at(attribute_name_index),
1339                    &quot;Invalid field attribute index %u in class file %s&quot;,
1340                    attribute_name_index,
1341                    CHECK);
1342 
1343     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1344     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1345       // ignore if non-static
1346       if (constantvalue_index != 0) {
1347         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1348       }
1349       check_property(
1350         attribute_length == 2,
1351         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1352         attribute_length, CHECK);
1353 
1354       constantvalue_index = cfs-&gt;get_u2(CHECK);
1355       if (_need_verify) {
1356         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1357       }
1358     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1359       if (attribute_length != 0) {
1360         classfile_parse_error(
1361           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1362           attribute_length, CHECK);
1363       }
1364       is_synthetic = true;
1365     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1366       if (attribute_length != 0) {
1367         classfile_parse_error(
1368           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1369           attribute_length, CHECK);
1370       }
1371     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1372       if (attribute_name == vmSymbols::tag_signature()) {
1373         if (generic_signature_index != 0) {
1374           classfile_parse_error(
1375             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1376         }
1377         if (attribute_length != 2) {
1378           classfile_parse_error(
1379             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1380             attribute_length, CHECK);
1381         }
1382         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1383       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1384         if (runtime_visible_annotations != NULL) {
1385           classfile_parse_error(
1386             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1387         }
1388         runtime_visible_annotations_length = attribute_length;
1389         runtime_visible_annotations = cfs-&gt;current();
1390         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1391         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1392         parse_annotations(cp,
1393                           runtime_visible_annotations,
1394                           runtime_visible_annotations_length,
1395                           parsed_annotations,
1396                           _loader_data,
1397                           CHECK);
1398         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1399       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1400         if (runtime_invisible_annotations_exists) {
1401           classfile_parse_error(
1402             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1403         }
1404         runtime_invisible_annotations_exists = true;
1405         if (PreserveAllAnnotations) {
1406           runtime_invisible_annotations_length = attribute_length;
1407           runtime_invisible_annotations = cfs-&gt;current();
1408           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1409         }
1410         cfs-&gt;skip_u1(attribute_length, CHECK);
1411       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1412         if (runtime_visible_type_annotations != NULL) {
1413           classfile_parse_error(
1414             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1415         }
1416         runtime_visible_type_annotations_length = attribute_length;
1417         runtime_visible_type_annotations = cfs-&gt;current();
1418         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1419         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1420       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1421         if (runtime_invisible_type_annotations_exists) {
1422           classfile_parse_error(
1423             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1424         } else {
1425           runtime_invisible_type_annotations_exists = true;
1426         }
1427         if (PreserveAllAnnotations) {
1428           runtime_invisible_type_annotations_length = attribute_length;
1429           runtime_invisible_type_annotations = cfs-&gt;current();
1430           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1431         }
1432         cfs-&gt;skip_u1(attribute_length, CHECK);
1433       } else {
1434         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1435       }
1436     } else {
1437       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1438     }
1439   }
1440 
1441   *constantvalue_index_addr = constantvalue_index;
1442   *is_synthetic_addr = is_synthetic;
1443   *generic_signature_index_addr = generic_signature_index;
1444   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1445                                             runtime_visible_annotations_length,
1446                                             runtime_invisible_annotations,
1447                                             runtime_invisible_annotations_length,
1448                                             CHECK);
1449   parsed_annotations-&gt;set_field_annotations(a);
1450   a = assemble_annotations(runtime_visible_type_annotations,
1451                            runtime_visible_type_annotations_length,
1452                            runtime_invisible_type_annotations,
1453                            runtime_invisible_type_annotations_length,
1454                            CHECK);
1455   parsed_annotations-&gt;set_field_type_annotations(a);
1456   return;
1457 }
1458 
1459 
1460 // Field allocation types. Used for computing field offsets.
1461 
1462 enum FieldAllocationType {
1463   STATIC_OOP,           // Oops
1464   STATIC_BYTE,          // Boolean, Byte, char
1465   STATIC_SHORT,         // shorts
1466   STATIC_WORD,          // ints
1467   STATIC_DOUBLE,        // aligned long or double
1468   NONSTATIC_OOP,
1469   NONSTATIC_BYTE,
1470   NONSTATIC_SHORT,
1471   NONSTATIC_WORD,
1472   NONSTATIC_DOUBLE,
1473   MAX_FIELD_ALLOCATION_TYPE,
1474   BAD_ALLOCATION_TYPE = -1
1475 };
1476 
1477 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1478   BAD_ALLOCATION_TYPE, // 0
1479   BAD_ALLOCATION_TYPE, // 1
1480   BAD_ALLOCATION_TYPE, // 2
1481   BAD_ALLOCATION_TYPE, // 3
1482   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1483   NONSTATIC_SHORT,     // T_CHAR        =  5,
1484   NONSTATIC_WORD,      // T_FLOAT       =  6,
1485   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1486   NONSTATIC_BYTE,      // T_BYTE        =  8,
1487   NONSTATIC_SHORT,     // T_SHORT       =  9,
1488   NONSTATIC_WORD,      // T_INT         = 10,
1489   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1490   NONSTATIC_OOP,       // T_OBJECT      = 12,
1491   NONSTATIC_OOP,       // T_ARRAY       = 13,
1492   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1493   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1494   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1495   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1496   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1497   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1498   BAD_ALLOCATION_TYPE, // 0
1499   BAD_ALLOCATION_TYPE, // 1
1500   BAD_ALLOCATION_TYPE, // 2
1501   BAD_ALLOCATION_TYPE, // 3
1502   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1503   STATIC_SHORT,        // T_CHAR        =  5,
1504   STATIC_WORD,         // T_FLOAT       =  6,
1505   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1506   STATIC_BYTE,         // T_BYTE        =  8,
1507   STATIC_SHORT,        // T_SHORT       =  9,
1508   STATIC_WORD,         // T_INT         = 10,
1509   STATIC_DOUBLE,       // T_LONG        = 11,
1510   STATIC_OOP,          // T_OBJECT      = 12,
1511   STATIC_OOP,          // T_ARRAY       = 13,
1512   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1513   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1514   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1515   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1516   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1517   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1518 };
1519 
1520 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {
1521   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1522   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1523   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
1524   return result;
1525 }
1526 
1527 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1528  public:
1529   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1530 
1531   FieldAllocationCount() {
1532     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1533       count[i] = 0;
1534     }
1535   }
1536 
1537   FieldAllocationType update(bool is_static, BasicType type) {
1538     FieldAllocationType atype = basic_type_to_atype(is_static, type);
1539     if (atype != BAD_ALLOCATION_TYPE) {
1540       // Make sure there is no overflow with injected fields.
1541       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1542       count[atype]++;
1543     }
1544     return atype;
1545   }
1546 };
1547 
1548 // Side-effects: populates the _fields, _fields_annotations,
1549 // _fields_type_annotations fields
1550 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1551                                    bool is_interface,
1552                                    FieldAllocationCount* const fac,
1553                                    ConstantPool* cp,
1554                                    const int cp_size,
1555                                    u2* const java_fields_count_ptr,
1556                                    TRAPS) {
1557 
1558   assert(cfs != NULL, &quot;invariant&quot;);
1559   assert(fac != NULL, &quot;invariant&quot;);
1560   assert(cp != NULL, &quot;invariant&quot;);
1561   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1562 
1563   assert(NULL == _fields, &quot;invariant&quot;);
1564   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1565   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1566 
1567   cfs-&gt;guarantee_more(2, CHECK);  // length
1568   const u2 length = cfs-&gt;get_u2_fast();
1569   *java_fields_count_ptr = length;
1570 
1571   int num_injected = 0;
1572   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1573                                                                   &amp;num_injected);
1574   const int total_fields = length + num_injected;
1575 
1576   // The field array starts with tuples of shorts
1577   // [access, name index, sig index, initial value index, byte offset].
1578   // A generic signature slot only exists for field with generic
1579   // signature attribute. And the access flag is set with
1580   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1581   // signature slots are at the end of the field array and after all
1582   // other fields data.
1583   //
1584   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1585   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1586   //       ...
1587   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1588   //       [generic signature index]
1589   //       [generic signature index]
1590   //       ...
1591   //
1592   // Allocate a temporary resource array for field data. For each field,
1593   // a slot is reserved in the temporary array for the generic signature
1594   // index. After parsing all fields, the data are copied to a permanent
1595   // array and any unused slots will be discarded.
1596   ResourceMark rm(THREAD);
1597   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1598                                               u2,
1599                                               total_fields * (FieldInfo::field_slots + 1));
1600 
1601   // The generic signature slots start after all other fields&#39; data.
1602   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1603   int num_generic_signature = 0;
1604   for (int n = 0; n &lt; length; n++) {
1605     // access_flags, name_index, descriptor_index, attributes_count
1606     cfs-&gt;guarantee_more(8, CHECK);
1607 
1608     AccessFlags access_flags;
1609     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
1610     verify_legal_field_modifiers(flags, is_interface, CHECK);
1611     access_flags.set_flags(flags);
1612 
1613     const u2 name_index = cfs-&gt;get_u2_fast();
1614     check_property(valid_symbol_at(name_index),
1615       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1616       name_index, CHECK);
1617     const Symbol* const name = cp-&gt;symbol_at(name_index);
1618     verify_legal_field_name(name, CHECK);
1619 
1620     const u2 signature_index = cfs-&gt;get_u2_fast();
1621     check_property(valid_symbol_at(signature_index),
1622       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1623       signature_index, CHECK);
1624     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1625     verify_legal_field_signature(name, sig, CHECK);
1626 
1627     u2 constantvalue_index = 0;
1628     bool is_synthetic = false;
1629     u2 generic_signature_index = 0;
1630     const bool is_static = access_flags.is_static();
1631     FieldAnnotationCollector parsed_annotations(_loader_data);
1632 
1633     const u2 attributes_count = cfs-&gt;get_u2_fast();
1634     if (attributes_count &gt; 0) {
1635       parse_field_attributes(cfs,
1636                              attributes_count,
1637                              is_static,
1638                              signature_index,
1639                              &amp;constantvalue_index,
1640                              &amp;is_synthetic,
1641                              &amp;generic_signature_index,
1642                              &amp;parsed_annotations,
1643                              CHECK);
1644 
1645       if (parsed_annotations.field_annotations() != NULL) {
1646         if (_fields_annotations == NULL) {
1647           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1648                                              _loader_data, length, NULL,
1649                                              CHECK);
1650         }
1651         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1652         parsed_annotations.set_field_annotations(NULL);
1653       }
1654       if (parsed_annotations.field_type_annotations() != NULL) {
1655         if (_fields_type_annotations == NULL) {
1656           _fields_type_annotations =
1657             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1658                                                          length,
1659                                                          NULL,
1660                                                          CHECK);
1661         }
1662         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1663         parsed_annotations.set_field_type_annotations(NULL);
1664       }
1665 
1666       if (is_synthetic) {
1667         access_flags.set_is_synthetic();
1668       }
1669       if (generic_signature_index != 0) {
1670         access_flags.set_field_has_generic_signature();
1671         fa[generic_signature_slot] = generic_signature_index;
1672         generic_signature_slot ++;
1673         num_generic_signature ++;
1674       }
1675     }
1676 
1677     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1678     field-&gt;initialize(access_flags.as_short(),
1679                       name_index,
1680                       signature_index,
1681                       constantvalue_index);
1682     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1683 
1684     // Remember how many oops we encountered and compute allocation type
1685     const FieldAllocationType atype = fac-&gt;update(is_static, type);
1686     field-&gt;set_allocation_type(atype);
1687 
1688     // After field is initialized with type, we can augment it with aux info
1689     if (parsed_annotations.has_any_annotations())
1690       parsed_annotations.apply_to(field);
1691   }
1692 
1693   int index = length;
1694   if (num_injected != 0) {
1695     for (int n = 0; n &lt; num_injected; n++) {
1696       // Check for duplicates
1697       if (injected[n].may_be_java) {
1698         const Symbol* const name      = injected[n].name();
1699         const Symbol* const signature = injected[n].signature();
1700         bool duplicate = false;
1701         for (int i = 0; i &lt; length; i++) {
1702           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1703           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1704               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1705             // Symbol is desclared in Java so skip this one
1706             duplicate = true;
1707             break;
1708           }
1709         }
1710         if (duplicate) {
1711           // These will be removed from the field array at the end
1712           continue;
1713         }
1714       }
1715 
1716       // Injected field
1717       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1718       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1719                         injected[n].name_index,
1720                         injected[n].signature_index,
1721                         0);
1722 
<a name="5" id="anc5"></a><span class="line-modified">1723       const BasicType type = Signature::basic_type(injected[n].signature());</span>
1724 
1725       // Remember how many oops we encountered and compute allocation type
1726       const FieldAllocationType atype = fac-&gt;update(false, type);
1727       field-&gt;set_allocation_type(atype);
1728       index++;
1729     }
1730   }
1731 
1732   assert(NULL == _fields, &quot;invariant&quot;);
1733 
1734   _fields =
1735     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1736                                    index * FieldInfo::field_slots + num_generic_signature,
1737                                    CHECK);
1738   // Sometimes injected fields already exist in the Java source so
1739   // the fields array could be too long.  In that case the
1740   // fields array is trimed. Also unused slots that were reserved
1741   // for generic signature indexes are discarded.
1742   {
1743     int i = 0;
1744     for (; i &lt; index * FieldInfo::field_slots; i++) {
1745       _fields-&gt;at_put(i, fa[i]);
1746     }
1747     for (int j = total_fields * FieldInfo::field_slots;
1748          j &lt; generic_signature_slot; j++) {
1749       _fields-&gt;at_put(i++, fa[j]);
1750     }
1751     assert(_fields-&gt;length() == i, &quot;&quot;);
1752   }
1753 
1754   if (_need_verify &amp;&amp; length &gt; 1) {
1755     // Check duplicated fields
1756     ResourceMark rm(THREAD);
1757     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1758       THREAD, NameSigHash*, HASH_ROW_SIZE);
1759     initialize_hashtable(names_and_sigs);
1760     bool dup = false;
1761     const Symbol* name = NULL;
1762     const Symbol* sig = NULL;
1763     {
1764       debug_only(NoSafepointVerifier nsv;)
1765       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1766         name = fs.name();
1767         sig = fs.signature();
1768         // If no duplicates, add name/signature in hashtable names_and_sigs.
1769         if (!put_after_lookup(name, sig, names_and_sigs)) {
1770           dup = true;
1771           break;
1772         }
1773       }
1774     }
1775     if (dup) {
1776       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1777                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1778     }
1779   }
1780 }
1781 
1782 
1783 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1784                                                                          u4 code_length,
1785                                                                          u4 exception_table_length,
1786                                                                          TRAPS) {
1787   assert(cfs != NULL, &quot;invariant&quot;);
1788 
1789   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1790   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1791 
1792   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1793                                                                // end_pc,
1794                                                                // handler_pc,
1795                                                                // catch_type_index
1796 
1797   // Will check legal target after parsing code array in verifier.
1798   if (_need_verify) {
1799     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1800       const u2 start_pc = cfs-&gt;get_u2_fast();
1801       const u2 end_pc = cfs-&gt;get_u2_fast();
1802       const u2 handler_pc = cfs-&gt;get_u2_fast();
1803       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1804       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1805                          &quot;Illegal exception table range in class file %s&quot;,
1806                          CHECK_NULL);
1807       guarantee_property(handler_pc &lt; code_length,
1808                          &quot;Illegal exception table handler in class file %s&quot;,
1809                          CHECK_NULL);
1810       if (catch_type_index != 0) {
1811         guarantee_property(valid_klass_reference_at(catch_type_index),
1812                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1813       }
1814     }
1815   } else {
1816     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1817   }
1818   return exception_table_start;
1819 }
1820 
1821 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1822                                              u4 code_length,
1823                                              CompressedLineNumberWriteStream**const write_stream,
1824                                              TRAPS) {
1825 
1826   const ClassFileStream* const cfs = _stream;
1827   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1828 
1829   // Each entry is a u2 start_pc, and a u2 line_number
1830   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1831 
1832   // Verify line number attribute and table length
1833   check_property(
1834     code_attribute_length == sizeof(u2) + length_in_bytes,
1835     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1836 
1837   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1838 
1839   if ((*write_stream) == NULL) {
1840     if (length_in_bytes &gt; fixed_buffer_size) {
1841       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1842     } else {
1843       (*write_stream) = new CompressedLineNumberWriteStream(
1844         _linenumbertable_buffer, fixed_buffer_size);
1845     }
1846   }
1847 
1848   while (num_entries-- &gt; 0) {
1849     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1850     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1851     guarantee_property(bci &lt; code_length,
1852         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1853     (*write_stream)-&gt;write_pair(bci, line);
1854   }
1855 }
1856 
1857 
1858 class LVT_Hash : public AllStatic {
1859  public:
1860 
1861   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1862   /*
1863    * 3-tuple start_bci/length/slot has to be unique key,
1864    * so the following comparison seems to be redundant:
1865    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1866    */
1867     return (e0.start_bci     == e1.start_bci &amp;&amp;
1868             e0.length        == e1.length &amp;&amp;
1869             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1870             e0.slot          == e1.slot);
1871   }
1872 
1873   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1874     unsigned int raw_hash = e0.start_bci;
1875 
1876     raw_hash = e0.length        + raw_hash * 37;
1877     raw_hash = e0.name_cp_index + raw_hash * 37;
1878     raw_hash = e0.slot          + raw_hash * 37;
1879 
1880     return raw_hash;
1881   }
1882 };
1883 
1884 
1885 // Class file LocalVariableTable elements.
1886 class Classfile_LVT_Element {
1887  public:
1888   u2 start_bci;
1889   u2 length;
1890   u2 name_cp_index;
1891   u2 descriptor_cp_index;
1892   u2 slot;
1893 };
1894 
1895 static void copy_lvt_element(const Classfile_LVT_Element* const src,
1896                              LocalVariableTableElement* const lvt) {
1897   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
1898   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
1899   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
1900   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
1901   lvt-&gt;signature_cp_index  = 0;
1902   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
1903 }
1904 
1905 // Function is used to parse both attributes:
1906 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
1907 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
1908                                                                              u4 code_length,
1909                                                                              u2 max_locals,
1910                                                                              u4 code_attribute_length,
1911                                                                              u2* const localvariable_table_length,
1912                                                                              bool isLVTT,
1913                                                                              TRAPS) {
1914   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
1915   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
1916   const unsigned int size =
1917     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
1918 
1919   const ConstantPool* const cp = _cp;
1920 
1921   // Verify local variable table attribute has right length
1922   if (_need_verify) {
1923     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
1924                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
1925   }
1926 
1927   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
1928   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
1929   if (!_need_verify) {
1930     cfs-&gt;skip_u2_fast(size);
1931   } else {
1932     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
1933     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
1934       const u2 start_pc = cfs-&gt;get_u2_fast();
1935       const u2 length = cfs-&gt;get_u2_fast();
1936       const u2 name_index = cfs-&gt;get_u2_fast();
1937       const u2 descriptor_index = cfs-&gt;get_u2_fast();
1938       const u2 index = cfs-&gt;get_u2_fast();
1939       // Assign to a u4 to avoid overflow
1940       const u4 end_pc = (u4)start_pc + (u4)length;
1941 
1942       if (start_pc &gt;= code_length) {
1943         classfile_parse_error(
1944           &quot;Invalid start_pc %u in %s in class file %s&quot;,
1945           start_pc, tbl_name, CHECK_NULL);
1946       }
1947       if (end_pc &gt; code_length) {
1948         classfile_parse_error(
1949           &quot;Invalid length %u in %s in class file %s&quot;,
1950           length, tbl_name, CHECK_NULL);
1951       }
1952       const int cp_size = cp-&gt;length();
1953       guarantee_property(valid_symbol_at(name_index),
1954         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
1955         name_index, tbl_name, CHECK_NULL);
1956       guarantee_property(valid_symbol_at(descriptor_index),
1957         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
1958         descriptor_index, tbl_name, CHECK_NULL);
1959 
1960       const Symbol* const name = cp-&gt;symbol_at(name_index);
1961       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
1962       verify_legal_field_name(name, CHECK_NULL);
1963       u2 extra_slot = 0;
1964       if (!isLVTT) {
1965         verify_legal_field_signature(name, sig, CHECK_NULL);
1966 
1967         // 4894874: check special cases for double and long local variables
1968         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
1969             sig == vmSymbols::type_signature(T_LONG)) {
1970           extra_slot = 1;
1971         }
1972       }
1973       guarantee_property((index + extra_slot) &lt; max_locals,
1974                           &quot;Invalid index %u in %s in class file %s&quot;,
1975                           index, tbl_name, CHECK_NULL);
1976     }
1977   }
1978   return localvariable_table_start;
1979 }
1980 
1981 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
1982                                       u4 code_attribute_length,
1983                                       bool need_verify,
1984                                       TRAPS) {
1985   assert(cfs != NULL, &quot;invariant&quot;);
1986 
1987   if (0 == code_attribute_length) {
1988     return NULL;
1989   }
1990 
1991   const u1* const stackmap_table_start = cfs-&gt;current();
1992   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
1993 
1994   // check code_attribute_length first
1995   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
1996 
1997   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
1998     return NULL;
1999   }
2000   return stackmap_table_start;
2001 }
2002 
2003 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2004                                                                             u2* const checked_exceptions_length,
2005                                                                             u4 method_attribute_length,
2006                                                                             TRAPS) {
2007   assert(cfs != NULL, &quot;invariant&quot;);
2008   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2009 
2010   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2011   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2012   const unsigned int size =
2013     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2014   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2015   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2016   if (!_need_verify) {
2017     cfs-&gt;skip_u2_fast(size);
2018   } else {
2019     // Verify each value in the checked exception table
2020     u2 checked_exception;
2021     const u2 len = *checked_exceptions_length;
2022     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2023     for (int i = 0; i &lt; len; i++) {
2024       checked_exception = cfs-&gt;get_u2_fast();
2025       check_property(
2026         valid_klass_reference_at(checked_exception),
2027         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2028         checked_exception, CHECK_NULL);
2029     }
2030   }
2031   // check exceptions attribute length
2032   if (_need_verify) {
2033     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2034                                                    sizeof(u2) * size),
2035                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2036   }
2037   return checked_exceptions_start;
2038 }
2039 
2040 void ClassFileParser::throwIllegalSignature(const char* type,
2041                                             const Symbol* name,
2042                                             const Symbol* sig,
2043                                             TRAPS) const {
2044   assert(name != NULL, &quot;invariant&quot;);
2045   assert(sig != NULL, &quot;invariant&quot;);
2046 
2047   ResourceMark rm(THREAD);
2048   Exceptions::fthrow(THREAD_AND_LOCATION,
2049       vmSymbols::java_lang_ClassFormatError(),
2050       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,
2051       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());
2052 }
2053 
2054 AnnotationCollector::ID
2055 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2056                                       const Symbol* name) {
2057   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2058   // Privileged code can use all annotations.  Other code silently drops some.
2059   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2060                           loader_data-&gt;is_platform_class_loader_data() ||
2061                           loader_data-&gt;is_unsafe_anonymous();
2062   switch (sid) {
2063     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2064       if (_location != _in_method)  break;  // only allow for methods
2065       if (!privileged)              break;  // only allow in privileged code
2066       return _method_CallerSensitive;
2067     }
2068     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2069       if (_location != _in_method)  break;  // only allow for methods
2070       if (!privileged)              break;  // only allow in privileged code
2071       return _method_ForceInline;
2072     }
2073     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2074       if (_location != _in_method)  break;  // only allow for methods
2075       if (!privileged)              break;  // only allow in privileged code
2076       return _method_DontInline;
2077     }
2078     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2079       if (_location != _in_method)  break;  // only allow for methods
2080       if (!privileged)              break;  // only allow in privileged code
2081       return _method_InjectedProfile;
2082     }
2083     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2084       if (_location != _in_method)  break;  // only allow for methods
2085       if (!privileged)              break;  // only allow in privileged code
2086       return _method_LambdaForm_Compiled;
2087     }
2088     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2089       if (_location != _in_method)  break;  // only allow for methods
2090       if (!privileged)              break;  // only allow in privileged code
2091       return _method_Hidden;
2092     }
2093     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2094       if (_location != _in_method)  break;  // only allow for methods
2095       if (!privileged)              break;  // only allow in privileged code
2096       return _method_HotSpotIntrinsicCandidate;
2097     }
2098     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2099       if (_location != _in_field)   break;  // only allow for fields
2100       if (!privileged)              break;  // only allow in privileged code
2101       return _field_Stable;
2102     }
2103     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2104       if (_location != _in_field &amp;&amp; _location != _in_class) {
2105         break;  // only allow for fields and classes
2106       }
2107       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2108         break;  // honor privileges
2109       }
2110       return _jdk_internal_vm_annotation_Contended;
2111     }
2112     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2113       if (_location != _in_method)  break;  // only allow for methods
2114       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2115       return _jdk_internal_vm_annotation_ReservedStackAccess;
2116     }
2117     default: {
2118       break;
2119     }
2120   }
2121   return AnnotationCollector::_unknown;
2122 }
2123 
2124 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2125   if (is_contended())
2126     f-&gt;set_contended_group(contended_group());
2127   if (is_stable())
2128     f-&gt;set_stable(true);
2129 }
2130 
2131 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2132   // If there&#39;s an error deallocate metadata for field annotations
2133   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2134   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2135 }
2136 
2137 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2138   if (has_annotation(_method_CallerSensitive))
2139     m-&gt;set_caller_sensitive(true);
2140   if (has_annotation(_method_ForceInline))
2141     m-&gt;set_force_inline(true);
2142   if (has_annotation(_method_DontInline))
2143     m-&gt;set_dont_inline(true);
2144   if (has_annotation(_method_InjectedProfile))
2145     m-&gt;set_has_injected_profile(true);
2146   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2147     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2148   if (has_annotation(_method_Hidden))
2149     m-&gt;set_hidden(true);
2150   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2151     m-&gt;set_intrinsic_candidate(true);
2152   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2153     m-&gt;set_has_reserved_stack_access(true);
2154 }
2155 
2156 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2157   assert(ik != NULL, &quot;invariant&quot;);
2158   ik-&gt;set_is_contended(is_contended());
2159 }
2160 
2161 #define MAX_ARGS_SIZE 255
2162 #define MAX_CODE_SIZE 65535
2163 #define INITIAL_MAX_LVT_NUMBER 256
2164 
2165 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2166  *
2167  * Rules for LVT&#39;s and LVTT&#39;s are:
2168  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2169  *   - If there are n LVT&#39;s, it is the same as if there was just
2170  *     one LVT containing all the entries from the n LVT&#39;s.
2171  *   - There may be no more than one LVT entry per local variable.
2172  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2173  *        start_pc, length, name, slot
2174  *   - There may be no more than one LVTT entry per each LVT entry.
2175  *     Each LVTT entry has to match some LVT entry.
2176  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2177  */
2178 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2179                                                int lvt_cnt,
2180                                                u2* const localvariable_table_length,
2181                                                const unsafe_u2** const localvariable_table_start,
2182                                                int lvtt_cnt,
2183                                                u2* const localvariable_type_table_length,
2184                                                const unsafe_u2** const localvariable_type_table_start,
2185                                                TRAPS) {
2186 
2187   ResourceMark rm(THREAD);
2188 
2189   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2190                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2191 
2192   LVT_HashTable* const table = new LVT_HashTable();
2193 
2194   // To fill LocalVariableTable in
2195   const Classfile_LVT_Element* cf_lvt;
2196   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2197 
2198   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2199     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2200     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2201       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2202       // If no duplicates, add LVT elem in hashtable.
2203       if (table-&gt;put(*lvt, lvt) == false
2204           &amp;&amp; _need_verify
2205           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2206         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2207                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2208                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2209                                CHECK);
2210       }
2211     }
2212   }
2213 
2214   // To merge LocalVariableTable and LocalVariableTypeTable
2215   const Classfile_LVT_Element* cf_lvtt;
2216   LocalVariableTableElement lvtt_elem;
2217 
2218   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2219     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2220     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2221       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2222       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2223       if (entry == NULL) {
2224         if (_need_verify) {
2225           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2226                                 &quot;does not match any LVT entry&quot;,
2227                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2228                                  CHECK);
2229         }
2230       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2231         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2232                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2233                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2234                                CHECK);
2235       } else {
2236         // to add generic signatures into LocalVariableTable
2237         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2238       }
2239     }
2240   }
2241 }
2242 
2243 
2244 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2245                                        const u1* runtime_visible_annotations,
2246                                        int runtime_visible_annotations_length,
2247                                        const u1* runtime_invisible_annotations,
2248                                        int runtime_invisible_annotations_length,
2249                                        const u1* runtime_visible_parameter_annotations,
2250                                        int runtime_visible_parameter_annotations_length,
2251                                        const u1* runtime_invisible_parameter_annotations,
2252                                        int runtime_invisible_parameter_annotations_length,
2253                                        const u1* runtime_visible_type_annotations,
2254                                        int runtime_visible_type_annotations_length,
2255                                        const u1* runtime_invisible_type_annotations,
2256                                        int runtime_invisible_type_annotations_length,
2257                                        const u1* annotation_default,
2258                                        int annotation_default_length,
2259                                        TRAPS) {
2260 
2261   AnnotationArray* a;
2262 
2263   if (runtime_visible_annotations_length +
2264       runtime_invisible_annotations_length &gt; 0) {
2265      a = assemble_annotations(runtime_visible_annotations,
2266                               runtime_visible_annotations_length,
2267                               runtime_invisible_annotations,
2268                               runtime_invisible_annotations_length,
2269                               CHECK);
2270      cm-&gt;set_method_annotations(a);
2271   }
2272 
2273   if (runtime_visible_parameter_annotations_length +
2274       runtime_invisible_parameter_annotations_length &gt; 0) {
2275     a = assemble_annotations(runtime_visible_parameter_annotations,
2276                              runtime_visible_parameter_annotations_length,
2277                              runtime_invisible_parameter_annotations,
2278                              runtime_invisible_parameter_annotations_length,
2279                              CHECK);
2280     cm-&gt;set_parameter_annotations(a);
2281   }
2282 
2283   if (annotation_default_length &gt; 0) {
2284     a = assemble_annotations(annotation_default,
2285                              annotation_default_length,
2286                              NULL,
2287                              0,
2288                              CHECK);
2289     cm-&gt;set_default_annotations(a);
2290   }
2291 
2292   if (runtime_visible_type_annotations_length +
2293       runtime_invisible_type_annotations_length &gt; 0) {
2294     a = assemble_annotations(runtime_visible_type_annotations,
2295                              runtime_visible_type_annotations_length,
2296                              runtime_invisible_type_annotations,
2297                              runtime_invisible_type_annotations_length,
2298                              CHECK);
2299     cm-&gt;set_type_annotations(a);
2300   }
2301 }
2302 
2303 
2304 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2305 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2306 // Method* to save footprint, so we only know the size of the resulting Method* when the
2307 // entire method attribute is parsed.
2308 //
2309 // The promoted_flags parameter is used to pass relevant access_flags
2310 // from the method back up to the containing klass. These flag values
2311 // are added to klass&#39;s access_flags.
2312 
2313 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2314                                       bool is_interface,
2315                                       const ConstantPool* cp,
2316                                       AccessFlags* const promoted_flags,
2317                                       TRAPS) {
2318   assert(cfs != NULL, &quot;invariant&quot;);
2319   assert(cp != NULL, &quot;invariant&quot;);
2320   assert(promoted_flags != NULL, &quot;invariant&quot;);
2321 
2322   ResourceMark rm(THREAD);
2323   // Parse fixed parts:
2324   // access_flags, name_index, descriptor_index, attributes_count
2325   cfs-&gt;guarantee_more(8, CHECK_NULL);
2326 
2327   int flags = cfs-&gt;get_u2_fast();
2328   const u2 name_index = cfs-&gt;get_u2_fast();
2329   const int cp_size = cp-&gt;length();
2330   check_property(
2331     valid_symbol_at(name_index),
2332     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2333     name_index, CHECK_NULL);
2334   const Symbol* const name = cp-&gt;symbol_at(name_index);
2335   verify_legal_method_name(name, CHECK_NULL);
2336 
2337   const u2 signature_index = cfs-&gt;get_u2_fast();
2338   guarantee_property(
2339     valid_symbol_at(signature_index),
2340     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2341     signature_index, CHECK_NULL);
2342   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2343 
2344   if (name == vmSymbols::class_initializer_name()) {
2345     // We ignore the other access flags for a valid class initializer.
2346     // (JVM Spec 2nd ed., chapter 4.6)
2347     if (_major_version &lt; 51) { // backward compatibility
2348       flags = JVM_ACC_STATIC;
2349     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2350       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2351     } else {
2352       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2353     }
2354   } else {
2355     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);
2356   }
2357 
2358   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {
2359     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2360   }
2361 
2362   int args_size = -1;  // only used when _need_verify is true
2363   if (_need_verify) {
2364     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2365                  verify_legal_method_signature(name, signature, CHECK_NULL);
2366     if (args_size &gt; MAX_ARGS_SIZE) {
2367       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2368     }
2369   }
2370 
2371   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2372 
2373   // Default values for code and exceptions attribute elements
2374   u2 max_stack = 0;
2375   u2 max_locals = 0;
2376   u4 code_length = 0;
2377   const u1* code_start = 0;
2378   u2 exception_table_length = 0;
2379   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2380   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2381   u2 checked_exceptions_length = 0;
2382   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2383   CompressedLineNumberWriteStream* linenumber_table = NULL;
2384   int linenumber_table_length = 0;
2385   int total_lvt_length = 0;
2386   u2 lvt_cnt = 0;
2387   u2 lvtt_cnt = 0;
2388   bool lvt_allocated = false;
2389   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2390   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2391   u2* localvariable_table_length = NULL;
2392   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2393   u2* localvariable_type_table_length = NULL;
2394   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2395   int method_parameters_length = -1;
2396   const u1* method_parameters_data = NULL;
2397   bool method_parameters_seen = false;
2398   bool parsed_code_attribute = false;
2399   bool parsed_checked_exceptions_attribute = false;
2400   bool parsed_stackmap_attribute = false;
2401   // stackmap attribute - JDK1.5
2402   const u1* stackmap_data = NULL;
2403   int stackmap_data_length = 0;
2404   u2 generic_signature_index = 0;
2405   MethodAnnotationCollector parsed_annotations;
2406   const u1* runtime_visible_annotations = NULL;
2407   int runtime_visible_annotations_length = 0;
2408   const u1* runtime_invisible_annotations = NULL;
2409   int runtime_invisible_annotations_length = 0;
2410   const u1* runtime_visible_parameter_annotations = NULL;
2411   int runtime_visible_parameter_annotations_length = 0;
2412   const u1* runtime_invisible_parameter_annotations = NULL;
2413   int runtime_invisible_parameter_annotations_length = 0;
2414   const u1* runtime_visible_type_annotations = NULL;
2415   int runtime_visible_type_annotations_length = 0;
2416   const u1* runtime_invisible_type_annotations = NULL;
2417   int runtime_invisible_type_annotations_length = 0;
2418   bool runtime_invisible_annotations_exists = false;
2419   bool runtime_invisible_type_annotations_exists = false;
2420   bool runtime_invisible_parameter_annotations_exists = false;
2421   const u1* annotation_default = NULL;
2422   int annotation_default_length = 0;
2423 
2424   // Parse code and exceptions attribute
2425   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2426   while (method_attributes_count--) {
2427     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2428     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2429     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2430     check_property(
2431       valid_symbol_at(method_attribute_name_index),
2432       &quot;Invalid method attribute name index %u in class file %s&quot;,
2433       method_attribute_name_index, CHECK_NULL);
2434 
2435     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2436     if (method_attribute_name == vmSymbols::tag_code()) {
2437       // Parse Code attribute
2438       if (_need_verify) {
2439         guarantee_property(
2440             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2441                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2442                          CHECK_NULL);
2443       }
2444       if (parsed_code_attribute) {
2445         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2446                               CHECK_NULL);
2447       }
2448       parsed_code_attribute = true;
2449 
2450       // Stack size, locals size, and code size
2451       cfs-&gt;guarantee_more(8, CHECK_NULL);
2452       max_stack = cfs-&gt;get_u2_fast();
2453       max_locals = cfs-&gt;get_u2_fast();
2454       code_length = cfs-&gt;get_u4_fast();
2455       if (_need_verify) {
2456         guarantee_property(args_size &lt;= max_locals,
2457                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2458                            CHECK_NULL);
2459         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2460                            &quot;Invalid method Code length %u in class file %s&quot;,
2461                            code_length, CHECK_NULL);
2462       }
2463       // Code pointer
2464       code_start = cfs-&gt;current();
2465       assert(code_start != NULL, &quot;null code start&quot;);
2466       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2467       cfs-&gt;skip_u1_fast(code_length);
2468 
2469       // Exception handler table
2470       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2471       exception_table_length = cfs-&gt;get_u2_fast();
2472       if (exception_table_length &gt; 0) {
2473         exception_table_start = parse_exception_table(cfs,
2474                                                       code_length,
2475                                                       exception_table_length,
2476                                                       CHECK_NULL);
2477       }
2478 
2479       // Parse additional attributes in code attribute
2480       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2481       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2482 
2483       unsigned int calculated_attribute_length = 0;
2484 
2485       calculated_attribute_length =
2486           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2487       calculated_attribute_length +=
2488         code_length +
2489         sizeof(exception_table_length) +
2490         sizeof(code_attributes_count) +
2491         exception_table_length *
2492             ( sizeof(u2) +   // start_pc
2493               sizeof(u2) +   // end_pc
2494               sizeof(u2) +   // handler_pc
2495               sizeof(u2) );  // catch_type_index
2496 
2497       while (code_attributes_count--) {
2498         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2499         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2500         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2501         calculated_attribute_length += code_attribute_length +
2502                                        sizeof(code_attribute_name_index) +
2503                                        sizeof(code_attribute_length);
2504         check_property(valid_symbol_at(code_attribute_name_index),
2505                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2506                        code_attribute_name_index,
2507                        CHECK_NULL);
2508         if (LoadLineNumberTables &amp;&amp;
2509             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2510           // Parse and compress line number table
2511           parse_linenumber_table(code_attribute_length,
2512                                  code_length,
2513                                  &amp;linenumber_table,
2514                                  CHECK_NULL);
2515 
2516         } else if (LoadLocalVariableTables &amp;&amp;
2517                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2518           // Parse local variable table
2519           if (!lvt_allocated) {
2520             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2521               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2522             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2523               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2524             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2525               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2526             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2527               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2528             lvt_allocated = true;
2529           }
2530           if (lvt_cnt == max_lvt_cnt) {
2531             max_lvt_cnt &lt;&lt;= 1;
2532             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2533             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2534           }
2535           localvariable_table_start[lvt_cnt] =
2536             parse_localvariable_table(cfs,
2537                                       code_length,
2538                                       max_locals,
2539                                       code_attribute_length,
2540                                       &amp;localvariable_table_length[lvt_cnt],
2541                                       false,    // is not LVTT
2542                                       CHECK_NULL);
2543           total_lvt_length += localvariable_table_length[lvt_cnt];
2544           lvt_cnt++;
2545         } else if (LoadLocalVariableTypeTables &amp;&amp;
2546                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2547                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2548           if (!lvt_allocated) {
2549             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2550               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2551             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2552               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2553             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2554               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2555             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2556               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2557             lvt_allocated = true;
2558           }
2559           // Parse local variable type table
2560           if (lvtt_cnt == max_lvtt_cnt) {
2561             max_lvtt_cnt &lt;&lt;= 1;
2562             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2563             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2564           }
2565           localvariable_type_table_start[lvtt_cnt] =
2566             parse_localvariable_table(cfs,
2567                                       code_length,
2568                                       max_locals,
2569                                       code_attribute_length,
2570                                       &amp;localvariable_type_table_length[lvtt_cnt],
2571                                       true,     // is LVTT
2572                                       CHECK_NULL);
2573           lvtt_cnt++;
2574         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2575                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2576           // Stack map is only needed by the new verifier in JDK1.5.
2577           if (parsed_stackmap_attribute) {
2578             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2579           }
2580           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2581           stackmap_data_length = code_attribute_length;
2582           parsed_stackmap_attribute = true;
2583         } else {
2584           // Skip unknown attributes
2585           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2586         }
2587       }
2588       // check method attribute length
2589       if (_need_verify) {
2590         guarantee_property(method_attribute_length == calculated_attribute_length,
2591                            &quot;Code segment has wrong length in class file %s&quot;,
2592                            CHECK_NULL);
2593       }
2594     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2595       // Parse Exceptions attribute
2596       if (parsed_checked_exceptions_attribute) {
2597         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2598                               CHECK_NULL);
2599       }
2600       parsed_checked_exceptions_attribute = true;
2601       checked_exceptions_start =
2602             parse_checked_exceptions(cfs,
2603                                      &amp;checked_exceptions_length,
2604                                      method_attribute_length,
2605                                      CHECK_NULL);
2606     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2607       // reject multiple method parameters
2608       if (method_parameters_seen) {
2609         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2610                               CHECK_NULL);
2611       }
2612       method_parameters_seen = true;
2613       method_parameters_length = cfs-&gt;get_u1_fast();
2614       const u2 real_length = (method_parameters_length * 4u) + 1u;
2615       if (method_attribute_length != real_length) {
2616         classfile_parse_error(
2617           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2618           method_attribute_length, CHECK_NULL);
2619       }
2620       method_parameters_data = cfs-&gt;current();
2621       cfs-&gt;skip_u2_fast(method_parameters_length);
2622       cfs-&gt;skip_u2_fast(method_parameters_length);
2623       // ignore this attribute if it cannot be reflected
2624       if (!SystemDictionary::Parameter_klass_loaded())
2625         method_parameters_length = -1;
2626     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2627       if (method_attribute_length != 0) {
2628         classfile_parse_error(
2629           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2630           method_attribute_length, CHECK_NULL);
2631       }
2632       // Should we check that there hasn&#39;t already been a synthetic attribute?
2633       access_flags.set_is_synthetic();
2634     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2635       if (method_attribute_length != 0) {
2636         classfile_parse_error(
2637           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2638           method_attribute_length, CHECK_NULL);
2639       }
2640     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2641       if (method_attribute_name == vmSymbols::tag_signature()) {
2642         if (generic_signature_index != 0) {
2643           classfile_parse_error(
2644             &quot;Multiple Signature attributes for method in class file %s&quot;,
2645             CHECK_NULL);
2646         }
2647         if (method_attribute_length != 2) {
2648           classfile_parse_error(
2649             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2650             method_attribute_length, CHECK_NULL);
2651         }
2652         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2653       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2654         if (runtime_visible_annotations != NULL) {
2655           classfile_parse_error(
2656             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2657             CHECK_NULL);
2658         }
2659         runtime_visible_annotations_length = method_attribute_length;
2660         runtime_visible_annotations = cfs-&gt;current();
2661         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2662         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2663         parse_annotations(cp,
2664                           runtime_visible_annotations,
2665                           runtime_visible_annotations_length,
2666                           &amp;parsed_annotations,
2667                           _loader_data,
2668                           CHECK_NULL);
2669         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2670       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2671         if (runtime_invisible_annotations_exists) {
2672           classfile_parse_error(
2673             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2674             CHECK_NULL);
2675         }
2676         runtime_invisible_annotations_exists = true;
2677         if (PreserveAllAnnotations) {
2678           runtime_invisible_annotations_length = method_attribute_length;
2679           runtime_invisible_annotations = cfs-&gt;current();
2680           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2681         }
2682         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2683       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2684         if (runtime_visible_parameter_annotations != NULL) {
2685           classfile_parse_error(
2686             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2687             CHECK_NULL);
2688         }
2689         runtime_visible_parameter_annotations_length = method_attribute_length;
2690         runtime_visible_parameter_annotations = cfs-&gt;current();
2691         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2692         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2693       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2694         if (runtime_invisible_parameter_annotations_exists) {
2695           classfile_parse_error(
2696             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2697             CHECK_NULL);
2698         }
2699         runtime_invisible_parameter_annotations_exists = true;
2700         if (PreserveAllAnnotations) {
2701           runtime_invisible_parameter_annotations_length = method_attribute_length;
2702           runtime_invisible_parameter_annotations = cfs-&gt;current();
2703           assert(runtime_invisible_parameter_annotations != NULL,
2704             &quot;null invisible parameter annotations&quot;);
2705         }
2706         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2707       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2708         if (annotation_default != NULL) {
2709           classfile_parse_error(
2710             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2711             CHECK_NULL);
2712         }
2713         annotation_default_length = method_attribute_length;
2714         annotation_default = cfs-&gt;current();
2715         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2716         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2717       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2718         if (runtime_visible_type_annotations != NULL) {
2719           classfile_parse_error(
2720             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2721             CHECK_NULL);
2722         }
2723         runtime_visible_type_annotations_length = method_attribute_length;
2724         runtime_visible_type_annotations = cfs-&gt;current();
2725         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2726         // No need for the VM to parse Type annotations
2727         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2728       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2729         if (runtime_invisible_type_annotations_exists) {
2730           classfile_parse_error(
2731             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2732             CHECK_NULL);
2733         } else {
2734           runtime_invisible_type_annotations_exists = true;
2735         }
2736         if (PreserveAllAnnotations) {
2737           runtime_invisible_type_annotations_length = method_attribute_length;
2738           runtime_invisible_type_annotations = cfs-&gt;current();
2739           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2740         }
2741         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2742       } else {
2743         // Skip unknown attributes
2744         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2745       }
2746     } else {
2747       // Skip unknown attributes
2748       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2749     }
2750   }
2751 
2752   if (linenumber_table != NULL) {
2753     linenumber_table-&gt;write_terminator();
2754     linenumber_table_length = linenumber_table-&gt;position();
2755   }
2756 
2757   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2758   if (_need_verify) {
2759     guarantee_property(access_flags.is_native() ||
2760                        access_flags.is_abstract() ||
2761                        parsed_code_attribute,
2762                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2763                        CHECK_NULL);
2764   }
2765 
2766   // All sizing information for a Method* is finally available, now create it
2767   InlineTableSizes sizes(
2768       total_lvt_length,
2769       linenumber_table_length,
2770       exception_table_length,
2771       checked_exceptions_length,
2772       method_parameters_length,
2773       generic_signature_index,
2774       runtime_visible_annotations_length +
2775            runtime_invisible_annotations_length,
2776       runtime_visible_parameter_annotations_length +
2777            runtime_invisible_parameter_annotations_length,
2778       runtime_visible_type_annotations_length +
2779            runtime_invisible_type_annotations_length,
2780       annotation_default_length,
2781       0);
2782 
2783   Method* const m = Method::allocate(_loader_data,
2784                                      code_length,
2785                                      access_flags,
2786                                      &amp;sizes,
2787                                      ConstMethod::NORMAL,
2788                                      CHECK_NULL);
2789 
2790   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2791 
2792   // Fill in information from fixed part (access_flags already set)
2793   m-&gt;set_constants(_cp);
2794   m-&gt;set_name_index(name_index);
2795   m-&gt;set_signature_index(signature_index);
<a name="6" id="anc6"></a><span class="line-modified">2796   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));</span>
<span class="line-modified">2797   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);</span>













2798 
2799   // Fill in code attribute information
2800   m-&gt;set_max_stack(max_stack);
2801   m-&gt;set_max_locals(max_locals);
2802   if (stackmap_data != NULL) {
2803     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2804                                          (u1*)stackmap_data,
2805                                          stackmap_data_length,
2806                                          CHECK_NULL);
2807   }
2808 
2809   // Copy byte codes
2810   m-&gt;set_code((u1*)code_start);
2811 
2812   // Copy line number table
2813   if (linenumber_table != NULL) {
2814     memcpy(m-&gt;compressed_linenumber_table(),
2815            linenumber_table-&gt;buffer(),
2816            linenumber_table_length);
2817   }
2818 
2819   // Copy exception table
2820   if (exception_table_length &gt; 0) {
2821     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2822                                                 m-&gt;exception_table_start(),
2823                                                 exception_table_length * sizeof(ExceptionTableElement),
2824                                                 sizeof(u2));
2825   }
2826 
2827   // Copy method parameters
2828   if (method_parameters_length &gt; 0) {
2829     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2830     for (int i = 0; i &lt; method_parameters_length; i++) {
2831       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2832       method_parameters_data += 2;
2833       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2834       method_parameters_data += 2;
2835     }
2836   }
2837 
2838   // Copy checked exceptions
2839   if (checked_exceptions_length &gt; 0) {
2840     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2841                                                 m-&gt;checked_exceptions_start(),
2842                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2843                                                 sizeof(u2));
2844   }
2845 
2846   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2847   if (total_lvt_length &gt; 0) {
2848     promoted_flags-&gt;set_has_localvariable_table();
2849     copy_localvariable_table(m-&gt;constMethod(),
2850                              lvt_cnt,
2851                              localvariable_table_length,
2852                              localvariable_table_start,
2853                              lvtt_cnt,
2854                              localvariable_type_table_length,
2855                              localvariable_type_table_start,
2856                              CHECK_NULL);
2857   }
2858 
2859   if (parsed_annotations.has_any_annotations())
2860     parsed_annotations.apply_to(methodHandle(THREAD, m));
2861 
2862   // Copy annotations
2863   copy_method_annotations(m-&gt;constMethod(),
2864                           runtime_visible_annotations,
2865                           runtime_visible_annotations_length,
2866                           runtime_invisible_annotations,
2867                           runtime_invisible_annotations_length,
2868                           runtime_visible_parameter_annotations,
2869                           runtime_visible_parameter_annotations_length,
2870                           runtime_invisible_parameter_annotations,
2871                           runtime_invisible_parameter_annotations_length,
2872                           runtime_visible_type_annotations,
2873                           runtime_visible_type_annotations_length,
2874                           runtime_invisible_type_annotations,
2875                           runtime_invisible_type_annotations_length,
2876                           annotation_default,
2877                           annotation_default_length,
2878                           CHECK_NULL);
2879 
2880   if (name == vmSymbols::finalize_method_name() &amp;&amp;
2881       signature == vmSymbols::void_method_signature()) {
2882     if (m-&gt;is_empty_method()) {
2883       _has_empty_finalizer = true;
2884     } else {
2885       _has_finalizer = true;
2886     }
2887   }
2888   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2889       signature == vmSymbols::void_method_signature() &amp;&amp;
2890       m-&gt;is_vanilla_constructor()) {
2891     _has_vanilla_constructor = true;
2892   }
2893 
2894   NOT_PRODUCT(m-&gt;verify());
2895   return m;
2896 }
2897 
2898 
2899 // The promoted_flags parameter is used to pass relevant access_flags
2900 // from the methods back up to the containing klass. These flag values
2901 // are added to klass&#39;s access_flags.
2902 // Side-effects: populates the _methods field in the parser
2903 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2904                                     bool is_interface,
2905                                     AccessFlags* promoted_flags,
2906                                     bool* has_final_method,
2907                                     bool* declares_nonstatic_concrete_methods,
2908                                     TRAPS) {
2909   assert(cfs != NULL, &quot;invariant&quot;);
2910   assert(promoted_flags != NULL, &quot;invariant&quot;);
2911   assert(has_final_method != NULL, &quot;invariant&quot;);
2912   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2913 
2914   assert(NULL == _methods, &quot;invariant&quot;);
2915 
2916   cfs-&gt;guarantee_more(2, CHECK);  // length
2917   const u2 length = cfs-&gt;get_u2_fast();
2918   if (length == 0) {
2919     _methods = Universe::the_empty_method_array();
2920   } else {
2921     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2922                                                    length,
2923                                                    NULL,
2924                                                    CHECK);
2925 
2926     for (int index = 0; index &lt; length; index++) {
2927       Method* method = parse_method(cfs,
2928                                     is_interface,
2929                                     _cp,
2930                                     promoted_flags,
2931                                     CHECK);
2932 
2933       if (method-&gt;is_final()) {
2934         *has_final_method = true;
2935       }
2936       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2937       // used for interface initialization, and default method inheritance analysis
2938       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2939         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2940         *declares_nonstatic_concrete_methods = true;
2941       }
2942       _methods-&gt;at_put(index, method);
2943     }
2944 
2945     if (_need_verify &amp;&amp; length &gt; 1) {
2946       // Check duplicated methods
2947       ResourceMark rm(THREAD);
2948       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
2949         THREAD, NameSigHash*, HASH_ROW_SIZE);
2950       initialize_hashtable(names_and_sigs);
2951       bool dup = false;
2952       const Symbol* name = NULL;
2953       const Symbol* sig = NULL;
2954       {
2955         debug_only(NoSafepointVerifier nsv;)
2956         for (int i = 0; i &lt; length; i++) {
2957           const Method* const m = _methods-&gt;at(i);
2958           name = m-&gt;name();
2959           sig = m-&gt;signature();
2960           // If no duplicates, add name/signature in hashtable names_and_sigs.
2961           if (!put_after_lookup(name, sig, names_and_sigs)) {
2962             dup = true;
2963             break;
2964           }
2965         }
2966       }
2967       if (dup) {
2968         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
2969                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
2970       }
2971     }
2972   }
2973 }
2974 
2975 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
2976   const int length = methods-&gt;length();
2977   // If JVMTI original method ordering or sharing is enabled we have to
2978   // remember the original class file ordering.
2979   // We temporarily use the vtable_index field in the Method* to store the
2980   // class file index, so we can read in after calling qsort.
2981   // Put the method ordering in the shared archive.
2982   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
2983     for (int index = 0; index &lt; length; index++) {
2984       Method* const m = methods-&gt;at(index);
2985       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
2986       m-&gt;set_vtable_index(index);
2987     }
2988   }
2989   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
2990   // Note that the ordering is not alphabetical, see Symbol::fast_compare
2991   Method::sort_methods(methods);
2992 
2993   intArray* method_ordering = NULL;
2994   // If JVMTI original method ordering or sharing is enabled construct int
2995   // array remembering the original ordering
2996   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
2997     method_ordering = new intArray(length, length, -1);
2998     for (int index = 0; index &lt; length; index++) {
2999       Method* const m = methods-&gt;at(index);
3000       const int old_index = m-&gt;vtable_index();
3001       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3002       method_ordering-&gt;at_put(index, old_index);
3003       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3004     }
3005   }
3006   return method_ordering;
3007 }
3008 
3009 // Parse generic_signature attribute for methods and fields
3010 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3011                                                       TRAPS) {
3012   assert(cfs != NULL, &quot;invariant&quot;);
3013 
3014   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3015   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3016   check_property(
3017     valid_symbol_at(generic_signature_index),
3018     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3019     generic_signature_index, CHECK_0);
3020   return generic_signature_index;
3021 }
3022 
3023 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3024                                                            TRAPS) {
3025 
3026   assert(cfs != NULL, &quot;invariant&quot;);
3027 
3028   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3029   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3030   check_property(
3031     valid_symbol_at(sourcefile_index),
3032     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3033     sourcefile_index, CHECK);
3034   set_class_sourcefile_index(sourcefile_index);
3035 }
3036 
3037 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3038                                                                        int length,
3039                                                                        TRAPS) {
3040   assert(cfs != NULL, &quot;invariant&quot;);
3041 
3042   const u1* const sde_buffer = cfs-&gt;current();
3043   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3044 
3045   // Don&#39;t bother storing it if there is no way to retrieve it
3046   if (JvmtiExport::can_get_source_debug_extension()) {
3047     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3048     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3049     for (int i = 0; i &lt; length; i++) {
3050       sde[i] = sde_buffer[i];
3051     }
3052     sde[length] = &#39;\0&#39;;
3053     set_class_sde_buffer((const char*)sde, length);
3054   }
3055   // Got utf8 string, set stream position forward
3056   cfs-&gt;skip_u1(length, CHECK);
3057 }
3058 
3059 
3060 // Inner classes can be static, private or protected (classic VM does this)
3061 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3062                                            JVM_ACC_PRIVATE |                \
3063                                            JVM_ACC_PROTECTED |              \
3064                                            JVM_ACC_STATIC                   \
3065                                          )
3066 
3067 // Return number of classes in the inner classes attribute table
3068 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3069                                                             const u1* const inner_classes_attribute_start,
3070                                                             bool parsed_enclosingmethod_attribute,
3071                                                             u2 enclosing_method_class_index,
3072                                                             u2 enclosing_method_method_index,
3073                                                             TRAPS) {
3074   const u1* const current_mark = cfs-&gt;current();
3075   u2 length = 0;
3076   if (inner_classes_attribute_start != NULL) {
3077     cfs-&gt;set_current(inner_classes_attribute_start);
3078     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3079     length = cfs-&gt;get_u2_fast();
3080   }
3081 
3082   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3083   // method data:
3084   //   [inner_class_info_index,
3085   //    outer_class_info_index,
3086   //    inner_name_index,
3087   //    inner_class_access_flags,
3088   //    ...
3089   //    enclosing_method_class_index,
3090   //    enclosing_method_method_index]
3091   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3092   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3093   _inner_classes = inner_classes;
3094 
3095   int index = 0;
3096   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3097   for (int n = 0; n &lt; length; n++) {
3098     // Inner class index
3099     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3100     check_property(
3101       valid_klass_reference_at(inner_class_info_index),
3102       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3103       inner_class_info_index, CHECK_0);
3104     // Outer class index
3105     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3106     check_property(
3107       outer_class_info_index == 0 ||
3108         valid_klass_reference_at(outer_class_info_index),
3109       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3110       outer_class_info_index, CHECK_0);
3111     // Inner class name
3112     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3113     check_property(
3114       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3115       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3116       inner_name_index, CHECK_0);
3117     if (_need_verify) {
3118       guarantee_property(inner_class_info_index != outer_class_info_index,
3119                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3120     }
3121     // Access flags
3122     jint flags;
3123     // JVM_ACC_MODULE is defined in JDK-9 and later.
3124     if (_major_version &gt;= JAVA_9_VERSION) {
3125       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);
3126     } else {
3127       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;
3128     }
3129     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3130       // Set abstract bit for old class files for backward compatibility
3131       flags |= JVM_ACC_ABSTRACT;
3132     }
3133     verify_legal_class_modifiers(flags, CHECK_0);
3134     AccessFlags inner_access_flags(flags);
3135 
3136     inner_classes-&gt;at_put(index++, inner_class_info_index);
3137     inner_classes-&gt;at_put(index++, outer_class_info_index);
3138     inner_classes-&gt;at_put(index++, inner_name_index);
3139     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3140   }
3141 
3142   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3143   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3144     for(int i = 0; i &lt; length * 4; i += 4) {
3145       for(int j = i + 4; j &lt; length * 4; j += 4) {
3146         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3147                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3148                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3149                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3150                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3151                             CHECK_0);
3152       }
3153     }
3154   }
3155 
3156   // Set EnclosingMethod class and method indexes.
3157   if (parsed_enclosingmethod_attribute) {
3158     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3159     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3160   }
3161   assert(index == size, &quot;wrong size&quot;);
3162 
3163   // Restore buffer&#39;s current position.
3164   cfs-&gt;set_current(current_mark);
3165 
3166   return length;
3167 }
3168 
3169 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3170                                                            const u1* const nest_members_attribute_start,
3171                                                            TRAPS) {
3172   const u1* const current_mark = cfs-&gt;current();
3173   u2 length = 0;
3174   if (nest_members_attribute_start != NULL) {
3175     cfs-&gt;set_current(nest_members_attribute_start);
3176     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3177     length = cfs-&gt;get_u2_fast();
3178   }
3179   const int size = length;
3180   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3181   _nest_members = nest_members;
3182 
3183   int index = 0;
3184   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3185   for (int n = 0; n &lt; length; n++) {
3186     const u2 class_info_index = cfs-&gt;get_u2_fast();
3187     check_property(
3188       valid_klass_reference_at(class_info_index),
3189       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3190       class_info_index, CHECK_0);
3191     nest_members-&gt;at_put(index++, class_info_index);
3192   }
3193   assert(index == size, &quot;wrong size&quot;);
3194 
3195   // Restore buffer&#39;s current position.
3196   cfs-&gt;set_current(current_mark);
3197 
3198   return length;
3199 }
3200 
3201 //  Record {
3202 //    u2 attribute_name_index;
3203 //    u4 attribute_length;
3204 //    u2 components_count;
3205 //    component_info components[components_count];
3206 //  }
3207 //  component_info {
3208 //    u2 name_index;
3209 //    u2 descriptor_index
3210 //    u2 attributes_count;
3211 //    attribute_info_attributes[attributes_count];
3212 //  }
3213 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3214                                                      const ConstantPool* cp,
3215                                                      const u1* const record_attribute_start,
3216                                                      TRAPS) {
3217   const u1* const current_mark = cfs-&gt;current();
3218   int components_count = 0;
3219   unsigned int calculate_attr_size = 0;
3220   if (record_attribute_start != NULL) {
3221     cfs-&gt;set_current(record_attribute_start);
3222     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3223     components_count = (int)cfs-&gt;get_u2_fast();
3224     calculate_attr_size = 2;
3225   }
3226 
3227   Array&lt;RecordComponent*&gt;* const record_components =
3228     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3229   _record_components = record_components;
3230 
3231   for (int x = 0; x &lt; components_count; x++) {
3232     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3233 
3234     const u2 name_index = cfs-&gt;get_u2_fast();
3235     check_property(valid_symbol_at(name_index),
3236       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3237       name_index, CHECK_0);
3238     const Symbol* const name = cp-&gt;symbol_at(name_index);
3239     verify_legal_field_name(name, CHECK_0);
3240 
3241     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3242     check_property(valid_symbol_at(descriptor_index),
3243       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3244       descriptor_index, CHECK_0);
3245     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3246     verify_legal_field_signature(name, descr, CHECK_0);
3247 
3248     const u2 attributes_count = cfs-&gt;get_u2_fast();
3249     calculate_attr_size += 6;
3250     u2 generic_sig_index = 0;
3251     const u1* runtime_visible_annotations = NULL;
3252     int runtime_visible_annotations_length = 0;
3253     const u1* runtime_invisible_annotations = NULL;
3254     int runtime_invisible_annotations_length = 0;
3255     bool runtime_invisible_annotations_exists = false;
3256     const u1* runtime_visible_type_annotations = NULL;
3257     int runtime_visible_type_annotations_length = 0;
3258     const u1* runtime_invisible_type_annotations = NULL;
3259     int runtime_invisible_type_annotations_length = 0;
3260     bool runtime_invisible_type_annotations_exists = false;
3261 
3262     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3263     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3264     for (int y = 0; y &lt; attributes_count; y++) {
3265       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3266       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3267       const u4 attribute_length = cfs-&gt;get_u4_fast();
3268       calculate_attr_size += 6;
3269       check_property(
3270         valid_symbol_at(attribute_name_index),
3271         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3272         attribute_name_index, CHECK_0);
3273 
3274       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3275       if (attribute_name == vmSymbols::tag_signature()) {
3276         if (generic_sig_index != 0) {
3277           classfile_parse_error(
3278             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3279             CHECK_0);
3280         }
3281         if (attribute_length != 2) {
3282           classfile_parse_error(
3283             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3284             attribute_length, CHECK_0);
3285         }
3286         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3287 
3288       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3289         if (runtime_visible_annotations != NULL) {
3290           classfile_parse_error(
3291             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3292         }
3293         runtime_visible_annotations_length = attribute_length;
3294         runtime_visible_annotations = cfs-&gt;current();
3295 
3296         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3297         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3298         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3299 
3300       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3301         if (runtime_invisible_annotations_exists) {
3302           classfile_parse_error(
3303             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3304         }
3305         runtime_invisible_annotations_exists = true;
3306         if (PreserveAllAnnotations) {
3307           runtime_invisible_annotations_length = attribute_length;
3308           runtime_invisible_annotations = cfs-&gt;current();
3309           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3310         }
3311         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3312 
3313       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3314         if (runtime_visible_type_annotations != NULL) {
3315           classfile_parse_error(
3316             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3317         }
3318         runtime_visible_type_annotations_length = attribute_length;
3319         runtime_visible_type_annotations = cfs-&gt;current();
3320 
3321         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3322         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3323         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3324 
3325       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3326         if (runtime_invisible_type_annotations_exists) {
3327           classfile_parse_error(
3328             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3329         }
3330         runtime_invisible_type_annotations_exists = true;
3331         if (PreserveAllAnnotations) {
3332           runtime_invisible_type_annotations_length = attribute_length;
3333           runtime_invisible_type_annotations = cfs-&gt;current();
3334           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3335         }
3336         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3337 
3338       } else {
3339         // Skip unknown attributes
3340         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3341       }
3342       calculate_attr_size += attribute_length;
3343     } // End of attributes For loop
3344 
3345     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3346                                                         runtime_visible_annotations_length,
3347                                                         runtime_invisible_annotations,
3348                                                         runtime_invisible_annotations_length,
3349                                                         CHECK_0);
3350     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3351                                                              runtime_visible_type_annotations_length,
3352                                                              runtime_invisible_type_annotations,
3353                                                              runtime_invisible_type_annotations_length,
3354                                                              CHECK_0);
3355 
3356     RecordComponent* record_component =
3357       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3358                                 attributes_count, generic_sig_index,
3359                                 annotations, type_annotations, CHECK_0);
3360     record_components-&gt;at_put(x, record_component);
3361   }  // End of component processing loop
3362 
3363   // Restore buffer&#39;s current position.
3364   cfs-&gt;set_current(current_mark);
3365   return calculate_attr_size;
3366 }
3367 
3368 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3369   set_class_synthetic_flag(true);
3370 }
3371 
3372 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3373   assert(cfs != NULL, &quot;invariant&quot;);
3374 
3375   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3376   check_property(
3377     valid_symbol_at(signature_index),
3378     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3379     signature_index, CHECK);
3380   set_class_generic_signature_index(signature_index);
3381 }
3382 
3383 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3384                                                                   ConstantPool* cp,
3385                                                                   u4 attribute_byte_length,
3386                                                                   TRAPS) {
3387   assert(cfs != NULL, &quot;invariant&quot;);
3388   assert(cp != NULL, &quot;invariant&quot;);
3389 
3390   const u1* const current_start = cfs-&gt;current();
3391 
3392   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3393                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3394                      attribute_byte_length,
3395                      CHECK);
3396 
3397   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3398 
3399   const int attribute_array_length = cfs-&gt;get_u2_fast();
3400 
3401   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3402                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3403                      CHECK);
3404 
3405 
3406   // The attribute contains a counted array of counted tuples of shorts,
3407   // represending bootstrap specifiers:
3408   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3409   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3410   // operand_count = number of shorts in attr, except for leading length
3411 
3412   // The attribute is copied into a short[] array.
3413   // The array begins with a series of short[2] pairs, one for each tuple.
3414   const int index_size = (attribute_array_length * 2);
3415 
3416   Array&lt;u2&gt;* const operands =
3417     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3418 
3419   // Eagerly assign operands so they will be deallocated with the constant
3420   // pool if there is an error.
3421   cp-&gt;set_operands(operands);
3422 
3423   int operand_fill_index = index_size;
3424   const int cp_size = cp-&gt;length();
3425 
3426   for (int n = 0; n &lt; attribute_array_length; n++) {
3427     // Store a 32-bit offset into the header of the operand array.
3428     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3429 
3430     // Read a bootstrap specifier.
3431     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3432     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3433     const u2 argument_count = cfs-&gt;get_u2_fast();
3434     check_property(
3435       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3436       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3437       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3438       bootstrap_method_index,
3439       CHECK);
3440 
3441     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3442       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3443       CHECK);
3444 
3445     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3446     operands-&gt;at_put(operand_fill_index++, argument_count);
3447 
3448     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3449     for (int j = 0; j &lt; argument_count; j++) {
3450       const u2 argument_index = cfs-&gt;get_u2_fast();
3451       check_property(
3452         valid_cp_range(argument_index, cp_size) &amp;&amp;
3453         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3454         &quot;argument_index %u has bad constant type in class file %s&quot;,
3455         argument_index,
3456         CHECK);
3457       operands-&gt;at_put(operand_fill_index++, argument_index);
3458     }
3459   }
3460   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3461                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3462                      CHECK);
3463 }
3464 
3465 bool ClassFileParser::supports_records() {
3466   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3467     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3468     Arguments::enable_preview();
3469 }
3470 
3471 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3472                                                  ConstantPool* cp,
3473                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3474                                                  TRAPS) {
3475   assert(cfs != NULL, &quot;invariant&quot;);
3476   assert(cp != NULL, &quot;invariant&quot;);
3477   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3478 
3479   // Set inner classes attribute to default sentinel
3480   _inner_classes = Universe::the_empty_short_array();
3481   // Set nest members attribute to default sentinel
3482   _nest_members = Universe::the_empty_short_array();
3483   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3484   u2 attributes_count = cfs-&gt;get_u2_fast();
3485   bool parsed_sourcefile_attribute = false;
3486   bool parsed_innerclasses_attribute = false;
3487   bool parsed_nest_members_attribute = false;
3488   bool parsed_nest_host_attribute = false;
3489   bool parsed_record_attribute = false;
3490   bool parsed_enclosingmethod_attribute = false;
3491   bool parsed_bootstrap_methods_attribute = false;
3492   const u1* runtime_visible_annotations = NULL;
3493   int runtime_visible_annotations_length = 0;
3494   const u1* runtime_invisible_annotations = NULL;
3495   int runtime_invisible_annotations_length = 0;
3496   const u1* runtime_visible_type_annotations = NULL;
3497   int runtime_visible_type_annotations_length = 0;
3498   const u1* runtime_invisible_type_annotations = NULL;
3499   int runtime_invisible_type_annotations_length = 0;
3500   bool runtime_invisible_type_annotations_exists = false;
3501   bool runtime_invisible_annotations_exists = false;
3502   bool parsed_source_debug_ext_annotations_exist = false;
3503   const u1* inner_classes_attribute_start = NULL;
3504   u4  inner_classes_attribute_length = 0;
3505   u2  enclosing_method_class_index = 0;
3506   u2  enclosing_method_method_index = 0;
3507   const u1* nest_members_attribute_start = NULL;
3508   u4  nest_members_attribute_length = 0;
3509   const u1* record_attribute_start = NULL;
3510   u4  record_attribute_length = 0;
3511 
3512   // Iterate over attributes
3513   while (attributes_count--) {
3514     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3515     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3516     const u4 attribute_length = cfs-&gt;get_u4_fast();
3517     check_property(
3518       valid_symbol_at(attribute_name_index),
3519       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3520       attribute_name_index, CHECK);
3521     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3522     if (tag == vmSymbols::tag_source_file()) {
3523       // Check for SourceFile tag
3524       if (_need_verify) {
3525         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3526       }
3527       if (parsed_sourcefile_attribute) {
3528         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3529       } else {
3530         parsed_sourcefile_attribute = true;
3531       }
3532       parse_classfile_sourcefile_attribute(cfs, CHECK);
3533     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3534       // Check for SourceDebugExtension tag
3535       if (parsed_source_debug_ext_annotations_exist) {
3536           classfile_parse_error(
3537             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3538       }
3539       parsed_source_debug_ext_annotations_exist = true;
3540       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3541     } else if (tag == vmSymbols::tag_inner_classes()) {
3542       // Check for InnerClasses tag
3543       if (parsed_innerclasses_attribute) {
3544         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3545       } else {
3546         parsed_innerclasses_attribute = true;
3547       }
3548       inner_classes_attribute_start = cfs-&gt;current();
3549       inner_classes_attribute_length = attribute_length;
3550       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3551     } else if (tag == vmSymbols::tag_synthetic()) {
3552       // Check for Synthetic tag
3553       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3554       if (attribute_length != 0) {
3555         classfile_parse_error(
3556           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3557           attribute_length, CHECK);
3558       }
3559       parse_classfile_synthetic_attribute(CHECK);
3560     } else if (tag == vmSymbols::tag_deprecated()) {
3561       // Check for Deprecatd tag - 4276120
3562       if (attribute_length != 0) {
3563         classfile_parse_error(
3564           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3565           attribute_length, CHECK);
3566       }
3567     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3568       if (tag == vmSymbols::tag_signature()) {
3569         if (_generic_signature_index != 0) {
3570           classfile_parse_error(
3571             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3572         }
3573         if (attribute_length != 2) {
3574           classfile_parse_error(
3575             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3576             attribute_length, CHECK);
3577         }
3578         parse_classfile_signature_attribute(cfs, CHECK);
3579       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3580         if (runtime_visible_annotations != NULL) {
3581           classfile_parse_error(
3582             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3583         }
3584         runtime_visible_annotations_length = attribute_length;
3585         runtime_visible_annotations = cfs-&gt;current();
3586         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3587         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3588         parse_annotations(cp,
3589                           runtime_visible_annotations,
3590                           runtime_visible_annotations_length,
3591                           parsed_annotations,
3592                           _loader_data,
3593                           CHECK);
3594         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3595       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3596         if (runtime_invisible_annotations_exists) {
3597           classfile_parse_error(
3598             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3599         }
3600         runtime_invisible_annotations_exists = true;
3601         if (PreserveAllAnnotations) {
3602           runtime_invisible_annotations_length = attribute_length;
3603           runtime_invisible_annotations = cfs-&gt;current();
3604           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3605         }
3606         cfs-&gt;skip_u1(attribute_length, CHECK);
3607       } else if (tag == vmSymbols::tag_enclosing_method()) {
3608         if (parsed_enclosingmethod_attribute) {
3609           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3610         } else {
3611           parsed_enclosingmethod_attribute = true;
3612         }
3613         guarantee_property(attribute_length == 4,
3614           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3615           attribute_length, CHECK);
3616         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3617         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3618         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3619         if (enclosing_method_class_index == 0) {
3620           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3621         }
3622         // Validate the constant pool indices and types
3623         check_property(valid_klass_reference_at(enclosing_method_class_index),
3624           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3625         if (enclosing_method_method_index != 0 &amp;&amp;
3626             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3627              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3628           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3629         }
3630       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3631                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3632         if (parsed_bootstrap_methods_attribute) {
3633           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3634         }
3635         parsed_bootstrap_methods_attribute = true;
3636         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3637       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3638         if (runtime_visible_type_annotations != NULL) {
3639           classfile_parse_error(
3640             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3641         }
3642         runtime_visible_type_annotations_length = attribute_length;
3643         runtime_visible_type_annotations = cfs-&gt;current();
3644         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3645         // No need for the VM to parse Type annotations
3646         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3647       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3648         if (runtime_invisible_type_annotations_exists) {
3649           classfile_parse_error(
3650             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3651         } else {
3652           runtime_invisible_type_annotations_exists = true;
3653         }
3654         if (PreserveAllAnnotations) {
3655           runtime_invisible_type_annotations_length = attribute_length;
3656           runtime_invisible_type_annotations = cfs-&gt;current();
3657           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3658         }
3659         cfs-&gt;skip_u1(attribute_length, CHECK);
3660       } else if (_major_version &gt;= JAVA_11_VERSION) {
3661         if (tag == vmSymbols::tag_nest_members()) {
3662           // Check for NestMembers tag
3663           if (parsed_nest_members_attribute) {
3664             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3665           } else {
3666             parsed_nest_members_attribute = true;
3667           }
3668           if (parsed_nest_host_attribute) {
3669             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3670           }
3671           nest_members_attribute_start = cfs-&gt;current();
3672           nest_members_attribute_length = attribute_length;
3673           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3674         } else if (tag == vmSymbols::tag_nest_host()) {
3675           if (parsed_nest_host_attribute) {
3676             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3677           } else {
3678             parsed_nest_host_attribute = true;
3679           }
3680           if (parsed_nest_members_attribute) {
3681             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3682           }
3683           if (_need_verify) {
3684             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3685           }
3686           cfs-&gt;guarantee_more(2, CHECK);
3687           u2 class_info_index = cfs-&gt;get_u2_fast();
3688           check_property(
3689                          valid_klass_reference_at(class_info_index),
3690                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3691                          class_info_index, CHECK);
3692           _nest_host = class_info_index;
3693         } else if (_major_version &gt;= JAVA_14_VERSION) {
3694           if (tag == vmSymbols::tag_record()) {
3695             // Skip over Record attribute if not supported or if super class is
3696             // not java.lang.Record.
3697             if (supports_records() &amp;&amp;
3698                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3699               if (parsed_record_attribute) {
3700                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3701               }
3702               // Check that class is final and not abstract.
3703               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3704                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3705               }
3706               parsed_record_attribute = true;
3707               record_attribute_start = cfs-&gt;current();
3708               record_attribute_length = attribute_length;
3709             } else if (log_is_enabled(Info, class, record)) {
3710               // Log why the Record attribute was ignored.  Note that if the
3711               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3712               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3713               // exception would have been thrown.
3714               ResourceMark rm(THREAD);
3715               if (supports_records()) {
3716                 log_info(class, record)(
3717                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3718                   _class_name-&gt;as_C_string());
3719               } else {
3720                 log_info(class, record)(
3721                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3722                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3723               }
3724             }
3725             cfs-&gt;skip_u1(attribute_length, CHECK);
3726           } else {
3727             // Unknown attribute
3728             cfs-&gt;skip_u1(attribute_length, CHECK);
3729           }
3730         } else {
3731           // Unknown attribute
3732           cfs-&gt;skip_u1(attribute_length, CHECK);
3733         }
3734       } else {
3735         // Unknown attribute
3736         cfs-&gt;skip_u1(attribute_length, CHECK);
3737       }
3738     } else {
3739       // Unknown attribute
3740       cfs-&gt;skip_u1(attribute_length, CHECK);
3741     }
3742   }
3743   _class_annotations = assemble_annotations(runtime_visible_annotations,
3744                                             runtime_visible_annotations_length,
3745                                             runtime_invisible_annotations,
3746                                             runtime_invisible_annotations_length,
3747                                             CHECK);
3748   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3749                                                  runtime_visible_type_annotations_length,
3750                                                  runtime_invisible_type_annotations,
3751                                                  runtime_invisible_type_annotations_length,
3752                                                  CHECK);
3753 
3754   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3755     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3756                             cfs,
3757                             inner_classes_attribute_start,
3758                             parsed_innerclasses_attribute,
3759                             enclosing_method_class_index,
3760                             enclosing_method_method_index,
3761                             CHECK);
3762     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3763       guarantee_property(
3764         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3765         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3766     }
3767   }
3768 
3769   if (parsed_nest_members_attribute) {
3770     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3771                             cfs,
3772                             nest_members_attribute_start,
3773                             CHECK);
3774     if (_need_verify) {
3775       guarantee_property(
3776         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3777         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3778     }
3779   }
3780 
3781   if (parsed_record_attribute) {
3782     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3783                             cfs,
3784                             cp,
3785                             record_attribute_start,
3786                             CHECK);
3787     if (_need_verify) {
3788       guarantee_property(record_attribute_length == calculated_attr_length,
3789                          &quot;Record attribute has wrong length in class file %s&quot;,
3790                          CHECK);
3791     }
3792   }
3793 
3794   if (_max_bootstrap_specifier_index &gt;= 0) {
3795     guarantee_property(parsed_bootstrap_methods_attribute,
3796                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3797   }
3798 }
3799 
3800 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3801   assert(k != NULL, &quot;invariant&quot;);
3802 
3803   if (_synthetic_flag)
3804     k-&gt;set_is_synthetic();
3805   if (_sourcefile_index != 0) {
3806     k-&gt;set_source_file_name_index(_sourcefile_index);
3807   }
3808   if (_generic_signature_index != 0) {
3809     k-&gt;set_generic_signature_index(_generic_signature_index);
3810   }
3811   if (_sde_buffer != NULL) {
3812     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3813   }
3814 }
3815 
3816 // Create the Annotations object that will
3817 // hold the annotations array for the Klass.
3818 void ClassFileParser::create_combined_annotations(TRAPS) {
3819     if (_class_annotations == NULL &amp;&amp;
3820         _class_type_annotations == NULL &amp;&amp;
3821         _fields_annotations == NULL &amp;&amp;
3822         _fields_type_annotations == NULL) {
3823       // Don&#39;t create the Annotations object unnecessarily.
3824       return;
3825     }
3826 
3827     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
3828     annotations-&gt;set_class_annotations(_class_annotations);
3829     annotations-&gt;set_class_type_annotations(_class_type_annotations);
3830     annotations-&gt;set_fields_annotations(_fields_annotations);
3831     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3832 
3833     // This is the Annotations object that will be
3834     // assigned to InstanceKlass being constructed.
3835     _combined_annotations = annotations;
3836 
3837     // The annotations arrays below has been transfered the
3838     // _combined_annotations so these fields can now be cleared.
3839     _class_annotations       = NULL;
3840     _class_type_annotations  = NULL;
3841     _fields_annotations      = NULL;
3842     _fields_type_annotations = NULL;
3843 }
3844 
3845 // Transfer ownership of metadata allocated to the InstanceKlass.
3846 void ClassFileParser::apply_parsed_class_metadata(
3847                                             InstanceKlass* this_klass,
3848                                             int java_fields_count,
3849                                             TRAPS) {
3850   assert(this_klass != NULL, &quot;invariant&quot;);
3851 
3852   _cp-&gt;set_pool_holder(this_klass);
3853   this_klass-&gt;set_constants(_cp);
3854   this_klass-&gt;set_fields(_fields, java_fields_count);
3855   this_klass-&gt;set_methods(_methods);
3856   this_klass-&gt;set_inner_classes(_inner_classes);
3857   this_klass-&gt;set_nest_members(_nest_members);
3858   this_klass-&gt;set_nest_host_index(_nest_host);
3859   this_klass-&gt;set_local_interfaces(_local_interfaces);
3860   this_klass-&gt;set_annotations(_combined_annotations);
3861   this_klass-&gt;set_record_components(_record_components);
3862   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3863   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3864   // its _super. If an OOM occurs while loading the current klass, its _super field
3865   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3866   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3867   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3868 
3869   // Clear out these fields so they don&#39;t get deallocated by the destructor
3870   clear_class_metadata();
3871 }
3872 
3873 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3874                                                        int runtime_visible_annotations_length,
3875                                                        const u1* const runtime_invisible_annotations,
3876                                                        int runtime_invisible_annotations_length,
3877                                                        TRAPS) {
3878   AnnotationArray* annotations = NULL;
3879   if (runtime_visible_annotations != NULL ||
3880       runtime_invisible_annotations != NULL) {
3881     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
3882                                           runtime_visible_annotations_length +
3883                                           runtime_invisible_annotations_length,
3884                                           CHECK_(annotations));
3885     if (runtime_visible_annotations != NULL) {
3886       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
3887         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
3888       }
3889     }
3890     if (runtime_invisible_annotations != NULL) {
3891       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3892         int append = runtime_visible_annotations_length+i;
3893         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3894       }
3895     }
3896   }
3897   return annotations;
3898 }
3899 
3900 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3901                                                         const int super_class_index,
3902                                                         const bool need_verify,
3903                                                         TRAPS) {
3904   assert(cp != NULL, &quot;invariant&quot;);
3905   const InstanceKlass* super_klass = NULL;
3906 
3907   if (super_class_index == 0) {
3908     check_property(_class_name == vmSymbols::java_lang_Object(),
3909                    &quot;Invalid superclass index %u in class file %s&quot;,
3910                    super_class_index,
3911                    CHECK_NULL);
3912   } else {
3913     check_property(valid_klass_reference_at(super_class_index),
3914                    &quot;Invalid superclass index %u in class file %s&quot;,
3915                    super_class_index,
3916                    CHECK_NULL);
3917     // The class name should be legal because it is checked when parsing constant pool.
3918     // However, make sure it is not an array type.
3919     bool is_array = false;
3920     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3921       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3922       if (need_verify)
3923         is_array = super_klass-&gt;is_array_klass();
3924     } else if (need_verify) {
3925       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3926     }
3927     if (need_verify) {
3928       guarantee_property(!is_array,
3929                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
3930     }
3931   }
3932   return super_klass;
3933 }
3934 
3935 static unsigned int compute_oop_map_count(const InstanceKlass* super,
3936                                           unsigned int nonstatic_oop_map_count,
3937                                           int first_nonstatic_oop_offset) {
3938 
3939   unsigned int map_count =
3940     NULL == super ? 0 : super-&gt;nonstatic_oop_map_count();
3941   if (nonstatic_oop_map_count &gt; 0) {
3942     // We have oops to add to map
3943     if (map_count == 0) {
3944       map_count = nonstatic_oop_map_count;
3945     }
3946     else {
3947       // Check whether we should add a new map block or whether the last one can
3948       // be extended
3949       const OopMapBlock* const first_map = super-&gt;start_of_nonstatic_oop_maps();
3950       const OopMapBlock* const last_map = first_map + map_count - 1;
3951 
3952       const int next_offset = last_map-&gt;offset() + last_map-&gt;count() * heapOopSize;
3953       if (next_offset == first_nonstatic_oop_offset) {
3954         // There is no gap bettwen superklass&#39;s last oop field and first
3955         // local oop field, merge maps.
3956         nonstatic_oop_map_count -= 1;
3957       }
3958       else {
3959         // Superklass didn&#39;t end with a oop field, add extra maps
3960         assert(next_offset &lt; first_nonstatic_oop_offset, &quot;just checking&quot;);
3961       }
3962       map_count += nonstatic_oop_map_count;
3963     }
3964   }
3965   return map_count;
3966 }
3967 
3968 #ifndef PRODUCT
3969 static void print_field_layout(const Symbol* name,
3970                                Array&lt;u2&gt;* fields,
3971                                ConstantPool* cp,
3972                                int instance_size,
3973                                int instance_fields_start,
3974                                int instance_fields_end,
3975                                int static_fields_end) {
3976 
3977   assert(name != NULL, &quot;invariant&quot;);
3978 
3979   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
3980   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
3981   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3982     if (!fs.access_flags().is_static()) {
3983       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3984         fs.offset(),
3985         fs.name()-&gt;as_klass_external_name(),
3986         fs.signature()-&gt;as_klass_external_name());
3987     }
3988   }
3989   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
3990   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
3991   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
3992   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3993     if (fs.access_flags().is_static()) {
3994       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3995         fs.offset(),
3996         fs.name()-&gt;as_klass_external_name(),
3997         fs.signature()-&gt;as_klass_external_name());
3998     }
3999   }
4000   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4001   tty-&gt;print(&quot;\n&quot;);
4002 }
4003 #endif
4004 
4005 // Values needed for oopmap and InstanceKlass creation
4006 class ClassFileParser::FieldLayoutInfo : public ResourceObj {
4007  public:
4008   int*          nonstatic_oop_offsets;
4009   unsigned int* nonstatic_oop_counts;
4010   unsigned int  nonstatic_oop_map_count;
4011   unsigned int  total_oop_map_count;
4012   int           instance_size;
4013   int           nonstatic_field_size;
4014   int           static_field_size;
4015   bool          has_nonstatic_fields;
4016 };
4017 
4018 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4019 void ClassFileParser::layout_fields(ConstantPool* cp,
4020                                     const FieldAllocationCount* fac,
4021                                     const ClassAnnotationCollector* parsed_annotations,
4022                                     FieldLayoutInfo* info,
4023                                     TRAPS) {
4024 
4025   assert(cp != NULL, &quot;invariant&quot;);
4026 
4027   // Field size and offset computation
4028   int nonstatic_field_size = _super_klass == NULL ? 0 :
4029                                _super_klass-&gt;nonstatic_field_size();
4030 
4031   // Count the contended fields by type.
4032   //
4033   // We ignore static fields, because @Contended is not supported for them.
4034   // The layout code below will also ignore the static fields.
4035   int nonstatic_contended_count = 0;
4036   FieldAllocationCount fac_contended;
4037   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4038     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4039     if (fs.is_contended()) {
4040       fac_contended.count[atype]++;
4041       if (!fs.access_flags().is_static()) {
4042         nonstatic_contended_count++;
4043       }
4044     }
4045   }
4046 
4047 
4048   // Calculate the starting byte offsets
4049   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4050   int next_static_double_offset = next_static_oop_offset +
4051                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);
4052   if (fac-&gt;count[STATIC_DOUBLE]) {
4053     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4054   }
4055 
4056   int next_static_word_offset   = next_static_double_offset +
4057                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4058   int next_static_short_offset  = next_static_word_offset +
4059                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4060   int next_static_byte_offset   = next_static_short_offset +
4061                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4062 
4063   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4064                                 nonstatic_field_size * heapOopSize;
4065 
4066   int next_nonstatic_field_offset = nonstatic_fields_start;
4067 
4068   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4069 
4070   // Class is contended, pad before all the fields
4071   if (is_contended_class) {
4072     next_nonstatic_field_offset += ContendedPaddingWidth;
4073   }
4074 
4075   // Compute the non-contended fields count.
4076   // The packing code below relies on these counts to determine if some field
4077   // can be squeezed into the alignment gap. Contended fields are obviously
4078   // exempt from that.
4079   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4080   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4081   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4082   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4083   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4084 
4085   // Total non-static fields count, including every contended field
4086   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4087                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4088                                         fac-&gt;count[NONSTATIC_OOP];
4089 
4090   const bool super_has_nonstatic_fields =
4091           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4092   const bool has_nonstatic_fields =
4093     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4094 
4095 
4096   // Prepare list of oops for oop map generation.
4097   //
4098   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4099   // regions. offset[i] is the start of the i-th region, which then has
4100   // count[i] oops following. Before we know how many regions are required,
4101   // we pessimistically allocate the maps to fit all the oops into the
4102   // distinct regions.
4103   //
4104   // TODO: We add +1 to always allocate non-zero resource arrays; we need
4105   // to figure out if we still need to do this.
4106   unsigned int nonstatic_oop_map_count = 0;
4107   unsigned int max_nonstatic_oop_maps  = fac-&gt;count[NONSTATIC_OOP] + 1;
4108 
4109   int* nonstatic_oop_offsets = NEW_RESOURCE_ARRAY_IN_THREAD(
4110             THREAD, int, max_nonstatic_oop_maps);
4111   unsigned int* const nonstatic_oop_counts  = NEW_RESOURCE_ARRAY_IN_THREAD(
4112             THREAD, unsigned int, max_nonstatic_oop_maps);
4113 
4114   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4115 
4116   bool compact_fields  = true;
4117   bool allocate_oops_first = false;
4118 
4119   // The next classes have predefined hard-coded fields offsets
4120   // (see in JavaClasses::compute_hard_coded_offsets()).
4121   // Use default fields allocation order for them.
4122   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4123       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4124        _class_name == vmSymbols::java_lang_Boolean() ||
4125        _class_name == vmSymbols::java_lang_Character() ||
4126        _class_name == vmSymbols::java_lang_Float() ||
4127        _class_name == vmSymbols::java_lang_Double() ||
4128        _class_name == vmSymbols::java_lang_Byte() ||
4129        _class_name == vmSymbols::java_lang_Short() ||
4130        _class_name == vmSymbols::java_lang_Integer() ||
4131        _class_name == vmSymbols::java_lang_Long())) {
4132     allocate_oops_first = true;     // Allocate oops first
4133     compact_fields   = false; // Don&#39;t compact fields
4134   }
4135 
4136   int next_nonstatic_oop_offset = 0;
4137   int next_nonstatic_double_offset = 0;
4138 
4139   // Rearrange fields for a given allocation style
4140   if (allocate_oops_first) {
4141     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4142     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4143     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4144                                     (nonstatic_oop_count * heapOopSize);
4145   } else {
4146     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4147     next_nonstatic_double_offset = next_nonstatic_field_offset;
4148   }
4149 
4150   int nonstatic_oop_space_count   = 0;
4151   int nonstatic_word_space_count  = 0;
4152   int nonstatic_short_space_count = 0;
4153   int nonstatic_byte_space_count  = 0;
4154   int nonstatic_oop_space_offset = 0;
4155   int nonstatic_word_space_offset = 0;
4156   int nonstatic_short_space_offset = 0;
4157   int nonstatic_byte_space_offset = 0;
4158 
4159   // Try to squeeze some of the fields into the gaps due to
4160   // long/double alignment.
4161   if (nonstatic_double_count &gt; 0) {
4162     int offset = next_nonstatic_double_offset;
4163     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4164     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4165       // Allocate available fields into the gap before double field.
4166       int length = next_nonstatic_double_offset - offset;
4167       assert(length == BytesPerInt, &quot;&quot;);
4168       nonstatic_word_space_offset = offset;
4169       if (nonstatic_word_count &gt; 0) {
4170         nonstatic_word_count      -= 1;
4171         nonstatic_word_space_count = 1; // Only one will fit
4172         length -= BytesPerInt;
4173         offset += BytesPerInt;
4174       }
4175       nonstatic_short_space_offset = offset;
4176       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4177         nonstatic_short_count       -= 1;
4178         nonstatic_short_space_count += 1;
4179         length -= BytesPerShort;
4180         offset += BytesPerShort;
4181       }
4182       nonstatic_byte_space_offset = offset;
4183       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4184         nonstatic_byte_count       -= 1;
4185         nonstatic_byte_space_count += 1;
4186         length -= 1;
4187       }
4188       // Allocate oop field in the gap if there are no other fields for that.
4189       nonstatic_oop_space_offset = offset;
4190       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4191           !allocate_oops_first) { // when oop fields not first
4192         nonstatic_oop_count      -= 1;
4193         nonstatic_oop_space_count = 1; // Only one will fit
4194         length -= heapOopSize;
4195         offset += heapOopSize;
4196       }
4197     }
4198   }
4199 
4200   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4201                                      (nonstatic_double_count * BytesPerLong);
4202   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4203                                       (nonstatic_word_count * BytesPerInt);
4204   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4205                                      (nonstatic_short_count * BytesPerShort);
4206   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4207                                        nonstatic_byte_count;
4208 
4209   // let oops jump before padding with this allocation style
4210   if (!allocate_oops_first) {
4211     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4212     if( nonstatic_oop_count &gt; 0 ) {
4213       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4214     }
4215     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4216   }
4217 
4218   // Iterate over fields again and compute correct offsets.
4219   // The field allocation type was temporarily stored in the offset slot.
4220   // oop fields are located before non-oop fields (static and non-static).
4221   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4222 
4223     // skip already laid out fields
4224     if (fs.is_offset_set()) continue;
4225 
4226     // contended instance fields are handled below
4227     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4228 
4229     int real_offset = 0;
4230     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4231 
4232     // pack the rest of the fields
4233     switch (atype) {
4234       case STATIC_OOP:
4235         real_offset = next_static_oop_offset;
4236         next_static_oop_offset += heapOopSize;
4237         break;
4238       case STATIC_BYTE:
4239         real_offset = next_static_byte_offset;
4240         next_static_byte_offset += 1;
4241         break;
4242       case STATIC_SHORT:
4243         real_offset = next_static_short_offset;
4244         next_static_short_offset += BytesPerShort;
4245         break;
4246       case STATIC_WORD:
4247         real_offset = next_static_word_offset;
4248         next_static_word_offset += BytesPerInt;
4249         break;
4250       case STATIC_DOUBLE:
4251         real_offset = next_static_double_offset;
4252         next_static_double_offset += BytesPerLong;
4253         break;
4254       case NONSTATIC_OOP:
4255         if( nonstatic_oop_space_count &gt; 0 ) {
4256           real_offset = nonstatic_oop_space_offset;
4257           nonstatic_oop_space_offset += heapOopSize;
4258           nonstatic_oop_space_count  -= 1;
4259         } else {
4260           real_offset = next_nonstatic_oop_offset;
4261           next_nonstatic_oop_offset += heapOopSize;
4262         }
4263 
4264         // Record this oop in the oop maps
4265         if( nonstatic_oop_map_count &gt; 0 &amp;&amp;
4266             nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==
4267             real_offset -
4268             int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *
4269             heapOopSize ) {
4270           // This oop is adjacent to the previous one, add to current oop map
4271           assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4272           nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;
4273         } else {
4274           // This oop is not adjacent to the previous one, create new oop map
4275           assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4276           nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
4277           nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
4278           nonstatic_oop_map_count += 1;
4279           if( first_nonstatic_oop_offset == 0 ) { // Undefined
4280             first_nonstatic_oop_offset = real_offset;
4281           }
4282         }
4283         break;
4284       case NONSTATIC_BYTE:
4285         if( nonstatic_byte_space_count &gt; 0 ) {
4286           real_offset = nonstatic_byte_space_offset;
4287           nonstatic_byte_space_offset += 1;
4288           nonstatic_byte_space_count  -= 1;
4289         } else {
4290           real_offset = next_nonstatic_byte_offset;
4291           next_nonstatic_byte_offset += 1;
4292         }
4293         break;
4294       case NONSTATIC_SHORT:
4295         if( nonstatic_short_space_count &gt; 0 ) {
4296           real_offset = nonstatic_short_space_offset;
4297           nonstatic_short_space_offset += BytesPerShort;
4298           nonstatic_short_space_count  -= 1;
4299         } else {
4300           real_offset = next_nonstatic_short_offset;
4301           next_nonstatic_short_offset += BytesPerShort;
4302         }
4303         break;
4304       case NONSTATIC_WORD:
4305         if( nonstatic_word_space_count &gt; 0 ) {
4306           real_offset = nonstatic_word_space_offset;
4307           nonstatic_word_space_offset += BytesPerInt;
4308           nonstatic_word_space_count  -= 1;
4309         } else {
4310           real_offset = next_nonstatic_word_offset;
4311           next_nonstatic_word_offset += BytesPerInt;
4312         }
4313         break;
4314       case NONSTATIC_DOUBLE:
4315         real_offset = next_nonstatic_double_offset;
4316         next_nonstatic_double_offset += BytesPerLong;
4317         break;
4318       default:
4319         ShouldNotReachHere();
4320     }
4321     fs.set_offset(real_offset);
4322   }
4323 
4324 
4325   // Handle the contended cases.
4326   //
4327   // Each contended field should not intersect the cache line with another contended field.
4328   // In the absence of alignment information, we end up with pessimistically separating
4329   // the fields with full-width padding.
4330   //
4331   // Additionally, this should not break alignment for the fields, so we round the alignment up
4332   // for each field.
4333   if (nonstatic_contended_count &gt; 0) {
4334 
4335     // if there is at least one contended field, we need to have pre-padding for them
4336     next_nonstatic_padded_offset += ContendedPaddingWidth;
4337 
4338     // collect all contended groups
4339     ResourceBitMap bm(cp-&gt;size());
4340     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4341       // skip already laid out fields
4342       if (fs.is_offset_set()) continue;
4343 
4344       if (fs.is_contended()) {
4345         bm.set_bit(fs.contended_group());
4346       }
4347     }
4348 
4349     int current_group = -1;
4350     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4351 
4352       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4353 
4354         // skip already laid out fields
4355         if (fs.is_offset_set()) continue;
4356 
4357         // skip non-contended fields and fields from different group
4358         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4359 
4360         // handle statics below
4361         if (fs.access_flags().is_static()) continue;
4362 
4363         int real_offset = 0;
4364         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4365 
4366         switch (atype) {
4367           case NONSTATIC_BYTE:
4368             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4369             real_offset = next_nonstatic_padded_offset;
4370             next_nonstatic_padded_offset += 1;
4371             break;
4372 
4373           case NONSTATIC_SHORT:
4374             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4375             real_offset = next_nonstatic_padded_offset;
4376             next_nonstatic_padded_offset += BytesPerShort;
4377             break;
4378 
4379           case NONSTATIC_WORD:
4380             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4381             real_offset = next_nonstatic_padded_offset;
4382             next_nonstatic_padded_offset += BytesPerInt;
4383             break;
4384 
4385           case NONSTATIC_DOUBLE:
4386             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4387             real_offset = next_nonstatic_padded_offset;
4388             next_nonstatic_padded_offset += BytesPerLong;
4389             break;
4390 
4391           case NONSTATIC_OOP:
4392             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4393             real_offset = next_nonstatic_padded_offset;
4394             next_nonstatic_padded_offset += heapOopSize;
4395 
4396             // Record this oop in the oop maps
4397             if( nonstatic_oop_map_count &gt; 0 &amp;&amp;
4398                 nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==
4399                 real_offset -
4400                 int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) *
4401                 heapOopSize ) {
4402               // This oop is adjacent to the previous one, add to current oop map
4403               assert(nonstatic_oop_map_count - 1 &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4404               nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;
4405             } else {
4406               // This oop is not adjacent to the previous one, create new oop map
4407               assert(nonstatic_oop_map_count &lt; max_nonstatic_oop_maps, &quot;range check&quot;);
4408               nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
4409               nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
4410               nonstatic_oop_map_count += 1;
4411               if( first_nonstatic_oop_offset == 0 ) { // Undefined
4412                 first_nonstatic_oop_offset = real_offset;
4413               }
4414             }
4415             break;
4416 
4417           default:
4418             ShouldNotReachHere();
4419         }
4420 
4421         if (fs.contended_group() == 0) {
4422           // Contended group defines the equivalence class over the fields:
4423           // the fields within the same contended group are not inter-padded.
4424           // The only exception is default group, which does not incur the
4425           // equivalence, and so requires intra-padding.
4426           next_nonstatic_padded_offset += ContendedPaddingWidth;
4427         }
4428 
4429         fs.set_offset(real_offset);
4430       } // for
4431 
4432       // Start laying out the next group.
4433       // Note that this will effectively pad the last group in the back;
4434       // this is expected to alleviate memory contention effects for
4435       // subclass fields and/or adjacent object.
4436       // If this was the default group, the padding is already in place.
4437       if (current_group != 0) {
4438         next_nonstatic_padded_offset += ContendedPaddingWidth;
4439       }
4440     }
4441 
4442     // handle static fields
4443   }
4444 
4445   // Entire class is contended, pad in the back.
4446   // This helps to alleviate memory contention effects for subclass fields
4447   // and/or adjacent object.
4448   if (is_contended_class) {
4449     next_nonstatic_padded_offset += ContendedPaddingWidth;
4450   }
4451 
4452   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4453 
4454   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);
4455   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4456   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4457 
4458   int static_field_size         = (static_fields_end -
4459                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4460   nonstatic_field_size          = nonstatic_field_size +
4461                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4462 
4463   int instance_size             = align_object_size(instance_end / wordSize);
4464 
4465   assert(instance_size == align_object_size(align_up(
4466          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
4467           wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4468 
4469   // Invariant: nonstatic_field end/start should only change if there are
4470   // nonstatic fields in the class, or if the class is contended. We compare
4471   // against the non-aligned value, so that end alignment will not fail the
4472   // assert without actually having the fields.
4473   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4474          is_contended_class ||
4475          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4476 
4477   // Number of non-static oop map blocks allocated at end of klass.
4478   const unsigned int total_oop_map_count =
4479     compute_oop_map_count(_super_klass, nonstatic_oop_map_count,
4480                           first_nonstatic_oop_offset);
4481 
4482 #ifndef PRODUCT
4483   if (PrintFieldLayout) {
4484     print_field_layout(_class_name,
4485           _fields,
4486           cp,
4487           instance_size,
4488           nonstatic_fields_start,
4489           nonstatic_fields_end,
4490           static_fields_end);
4491   }
4492 
4493 #endif
4494   // Pass back information needed for InstanceKlass creation
4495   info-&gt;nonstatic_oop_offsets = nonstatic_oop_offsets;
4496   info-&gt;nonstatic_oop_counts = nonstatic_oop_counts;
4497   info-&gt;nonstatic_oop_map_count = nonstatic_oop_map_count;
4498   info-&gt;total_oop_map_count = total_oop_map_count;
4499   info-&gt;instance_size = instance_size;
4500   info-&gt;static_field_size = static_field_size;
4501   info-&gt;nonstatic_field_size = nonstatic_field_size;
4502   info-&gt;has_nonstatic_fields = has_nonstatic_fields;
4503 }
4504 
4505 static void fill_oop_maps(const InstanceKlass* k,
4506                           unsigned int nonstatic_oop_map_count,
4507                           const int* nonstatic_oop_offsets,
4508                           const unsigned int* nonstatic_oop_counts) {
4509 
4510   assert(k != NULL, &quot;invariant&quot;);
4511 
4512   OopMapBlock* this_oop_map = k-&gt;start_of_nonstatic_oop_maps();
4513   const InstanceKlass* const super = k-&gt;superklass();
4514   const unsigned int super_count = super ? super-&gt;nonstatic_oop_map_count() : 0;
4515   if (super_count &gt; 0) {
4516     // Copy maps from superklass
4517     OopMapBlock* super_oop_map = super-&gt;start_of_nonstatic_oop_maps();
4518     for (unsigned int i = 0; i &lt; super_count; ++i) {
4519       *this_oop_map++ = *super_oop_map++;
4520     }
4521   }
4522 
4523   if (nonstatic_oop_map_count &gt; 0) {
4524     if (super_count + nonstatic_oop_map_count &gt; k-&gt;nonstatic_oop_map_count()) {
4525       // The counts differ because there is no gap between superklass&#39;s last oop
4526       // field and the first local oop field.  Extend the last oop map copied
4527       // from the superklass instead of creating new one.
4528       nonstatic_oop_map_count--;
4529       nonstatic_oop_offsets++;
4530       this_oop_map--;
4531       this_oop_map-&gt;set_count(this_oop_map-&gt;count() + *nonstatic_oop_counts++);
4532       this_oop_map++;
4533     }
4534 
4535     // Add new map blocks, fill them
4536     while (nonstatic_oop_map_count-- &gt; 0) {
4537       this_oop_map-&gt;set_offset(*nonstatic_oop_offsets++);
4538       this_oop_map-&gt;set_count(*nonstatic_oop_counts++);
4539       this_oop_map++;
4540     }
4541     assert(k-&gt;start_of_nonstatic_oop_maps() + k-&gt;nonstatic_oop_map_count() ==
4542            this_oop_map, &quot;sanity&quot;);
4543   }
4544 }
4545 
4546 
4547 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4548   assert(ik != NULL, &quot;invariant&quot;);
4549 
4550   const Klass* const super = ik-&gt;super();
4551 
4552   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4553   // in which case we don&#39;t have to register objects as finalizable
4554   if (!_has_empty_finalizer) {
4555     if (_has_finalizer ||
4556         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4557       ik-&gt;set_has_finalizer();
4558     }
4559   }
4560 
4561 #ifdef ASSERT
4562   bool f = false;
4563   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4564                                            vmSymbols::void_method_signature());
4565   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4566       f = true;
4567   }
4568 
4569   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4570   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4571   // will not work as expected we shouldn&#39;t abort vm in this case
4572   if (!ik-&gt;has_redefined_this_or_super()) {
4573     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4574   }
4575 #endif
4576 
4577   // Check if this klass supports the java.lang.Cloneable interface
4578   if (SystemDictionary::Cloneable_klass_loaded()) {
4579     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4580       ik-&gt;set_is_cloneable();
4581     }
4582   }
4583 
4584   // Check if this klass has a vanilla default constructor
4585   if (super == NULL) {
4586     // java.lang.Object has empty default constructor
4587     ik-&gt;set_has_vanilla_constructor();
4588   } else {
4589     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4590         _has_vanilla_constructor) {
4591       ik-&gt;set_has_vanilla_constructor();
4592     }
4593 #ifdef ASSERT
4594     bool v = false;
4595     if (super-&gt;has_vanilla_constructor()) {
4596       const Method* const constructor =
4597         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4598                        vmSymbols::void_method_signature());
4599       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4600         v = true;
4601       }
4602     }
4603     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4604 #endif
4605   }
4606 
4607   // If it cannot be fast-path allocated, set a bit in the layout helper.
4608   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4609   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4610   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4611       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4612       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4613       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4614     // Forbid fast-path allocation.
4615     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4616     ik-&gt;set_layout_helper(lh);
4617   }
4618 }
4619 
4620 // utility methods for appending an array with check for duplicates
4621 
4622 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4623                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4624   // iterate over new interfaces
4625   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4626     InstanceKlass* const e = ifs-&gt;at(i);
4627     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4628     // add new interface
4629     result-&gt;append_if_missing(e);
4630   }
4631 }
4632 
4633 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4634                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4635                                                             ClassLoaderData* loader_data,
4636                                                             TRAPS) {
4637   assert(local_ifs != NULL, &quot;invariant&quot;);
4638   assert(loader_data != NULL, &quot;invariant&quot;);
4639 
4640   // Compute maximum size for transitive interfaces
4641   int max_transitive_size = 0;
4642   int super_size = 0;
4643   // Add superclass transitive interfaces size
4644   if (super != NULL) {
4645     super_size = super-&gt;transitive_interfaces()-&gt;length();
4646     max_transitive_size += super_size;
4647   }
4648   // Add local interfaces&#39; super interfaces
4649   const int local_size = local_ifs-&gt;length();
4650   for (int i = 0; i &lt; local_size; i++) {
4651     InstanceKlass* const l = local_ifs-&gt;at(i);
4652     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4653   }
4654   // Finally add local interfaces
4655   max_transitive_size += local_size;
4656   // Construct array
4657   if (max_transitive_size == 0) {
4658     // no interfaces, use canonicalized array
4659     return Universe::the_empty_instance_klass_array();
4660   } else if (max_transitive_size == super_size) {
4661     // no new local interfaces added, share superklass&#39; transitive interface array
4662     return super-&gt;transitive_interfaces();
4663   } else if (max_transitive_size == local_size) {
4664     // only local interfaces added, share local interface array
4665     return local_ifs;
4666   } else {
4667     ResourceMark rm;
4668     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4669 
4670     // Copy down from superclass
4671     if (super != NULL) {
4672       append_interfaces(result, super-&gt;transitive_interfaces());
4673     }
4674 
4675     // Copy down from local interfaces&#39; superinterfaces
4676     for (int i = 0; i &lt; local_size; i++) {
4677       InstanceKlass* const l = local_ifs-&gt;at(i);
4678       append_interfaces(result, l-&gt;transitive_interfaces());
4679     }
4680     // Finally add local interfaces
4681     append_interfaces(result, local_ifs);
4682 
4683     // length will be less than the max_transitive_size if duplicates were removed
4684     const int length = result-&gt;length();
4685     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4686     Array&lt;InstanceKlass*&gt;* const new_result =
4687       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4688     for (int i = 0; i &lt; length; i++) {
4689       InstanceKlass* const e = result-&gt;at(i);
4690       assert(e != NULL, &quot;just checking&quot;);
4691       new_result-&gt;at_put(i, e);
4692     }
4693     return new_result;
4694   }
4695 }
4696 
4697 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4698   assert(this_klass != NULL, &quot;invariant&quot;);
4699   const Klass* const super = this_klass-&gt;super();
4700 
4701   if (super != NULL) {
4702 
4703     // If the loader is not the boot loader then throw an exception if its
4704     // superclass is in package jdk.internal.reflect and its loader is not a
4705     // special reflection class loader
4706     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4707       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
4708       PackageEntry* super_package = super-&gt;package();
4709       if (super_package != NULL &amp;&amp;
4710           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4711           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4712         ResourceMark rm(THREAD);
4713         Exceptions::fthrow(
4714           THREAD_AND_LOCATION,
4715           vmSymbols::java_lang_IllegalAccessError(),
4716           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4717           this_klass-&gt;external_name(),
4718           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4719           super-&gt;external_name());
4720         return;
4721       }
4722     }
4723 
4724     Reflection::VerifyClassAccessResults vca_result =
4725       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4726     if (vca_result != Reflection::ACCESS_OK) {
4727       ResourceMark rm(THREAD);
4728       char* msg = Reflection::verify_class_access_msg(this_klass,
4729                                                       InstanceKlass::cast(super),
4730                                                       vca_result);
4731       if (msg == NULL) {
4732         bool same_module = (this_klass-&gt;module() == super-&gt;module());
4733         Exceptions::fthrow(
4734           THREAD_AND_LOCATION,
4735           vmSymbols::java_lang_IllegalAccessError(),
4736           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
4737           this_klass-&gt;external_name(),
4738           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
4739           super-&gt;external_name(),
4740           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
4741           (same_module) ? &quot;&quot; : &quot;; &quot;,
4742           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
4743       } else {
4744         // Add additional message content.
4745         Exceptions::fthrow(
4746           THREAD_AND_LOCATION,
4747           vmSymbols::java_lang_IllegalAccessError(),
4748           &quot;superclass access check failed: %s&quot;,
4749           msg);
4750       }
4751     }
4752   }
4753 }
4754 
4755 
4756 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4757   assert(this_klass != NULL, &quot;invariant&quot;);
4758   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4759   const int lng = local_interfaces-&gt;length();
4760   for (int i = lng - 1; i &gt;= 0; i--) {
4761     InstanceKlass* const k = local_interfaces-&gt;at(i);
4762     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4763     Reflection::VerifyClassAccessResults vca_result =
4764       Reflection::verify_class_access(this_klass, k, false);
4765     if (vca_result != Reflection::ACCESS_OK) {
4766       ResourceMark rm(THREAD);
4767       char* msg = Reflection::verify_class_access_msg(this_klass,
4768                                                       k,
4769                                                       vca_result);
4770       if (msg == NULL) {
4771         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4772         Exceptions::fthrow(
4773           THREAD_AND_LOCATION,
4774           vmSymbols::java_lang_IllegalAccessError(),
4775           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4776           this_klass-&gt;external_name(),
4777           k-&gt;external_name(),
4778           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4779           (same_module) ? &quot;&quot; : &quot;; &quot;,
4780           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4781       } else {
4782         // Add additional message content.
4783         Exceptions::fthrow(
4784           THREAD_AND_LOCATION,
4785           vmSymbols::java_lang_IllegalAccessError(),
4786           &quot;superinterface check failed: %s&quot;,
4787           msg);
4788       }
4789     }
4790   }
4791 }
4792 
4793 
4794 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
4795   assert(this_klass != NULL, &quot;invariant&quot;);
4796   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
4797   const int num_methods = methods-&gt;length();
4798 
4799   // go thru each method and check if it overrides a final method
4800   for (int index = 0; index &lt; num_methods; index++) {
4801     const Method* const m = methods-&gt;at(index);
4802 
4803     // skip private, static, and &lt;init&gt; methods
4804     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
4805         (m-&gt;name() != vmSymbols::object_initializer_name())) {
4806 
4807       const Symbol* const name = m-&gt;name();
4808       const Symbol* const signature = m-&gt;signature();
4809       const Klass* k = this_klass-&gt;super();
4810       const Method* super_m = NULL;
4811       while (k != NULL) {
4812         // skip supers that don&#39;t have final methods.
4813         if (k-&gt;has_final_method()) {
4814           // lookup a matching method in the super class hierarchy
4815           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
4816           if (super_m == NULL) {
4817             break; // didn&#39;t find any match; get out
4818           }
4819 
4820           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
4821               !super_m-&gt;access_flags().is_private()) {
4822             // matching method in super is final, and not static or private
4823             bool can_access = Reflection::verify_member_access(this_klass,
4824                                                                super_m-&gt;method_holder(),
4825                                                                super_m-&gt;method_holder(),
4826                                                                super_m-&gt;access_flags(),
4827                                                               false, false, CHECK);
4828             if (can_access) {
4829               // this class can access super final method and therefore override
4830               ResourceMark rm(THREAD);
4831               Exceptions::fthrow(THREAD_AND_LOCATION,
4832                                  vmSymbols::java_lang_VerifyError(),
4833                                  &quot;class %s overrides final method %s.%s%s&quot;,
4834                                  this_klass-&gt;external_name(),
4835                                  super_m-&gt;method_holder()-&gt;external_name(),
4836                                  name-&gt;as_C_string(),
4837                                  signature-&gt;as_C_string()
4838                                  );
4839               return;
4840             }
4841           }
4842 
4843           // continue to look from super_m&#39;s holder&#39;s super.
4844           k = super_m-&gt;method_holder()-&gt;super();
4845           continue;
4846         }
4847 
4848         k = k-&gt;super();
4849       }
4850     }
4851   }
4852 }
4853 
4854 
4855 // assumes that this_klass is an interface
4856 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
4857   assert(this_klass != NULL, &quot;invariant&quot;);
4858   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
4859   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
4860   const int num_methods = methods-&gt;length();
4861 
4862   for (int index = 0; index &lt; num_methods; index++) {
4863     const Method* const m = methods-&gt;at(index);
4864     // if m is static and not the init method, throw a verify error
4865     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4866       ResourceMark rm(THREAD);
4867       Exceptions::fthrow(
4868         THREAD_AND_LOCATION,
4869         vmSymbols::java_lang_VerifyError(),
4870         &quot;Illegal static method %s in interface %s&quot;,
4871         m-&gt;name()-&gt;as_C_string(),
4872         this_klass-&gt;external_name()
4873       );
4874       return;
4875     }
4876   }
4877 }
4878 
4879 // utility methods for format checking
4880 
4881 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4882   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
4883   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
4884   if (is_module) {
4885     ResourceMark rm(THREAD);
4886     Exceptions::fthrow(
4887       THREAD_AND_LOCATION,
4888       vmSymbols::java_lang_NoClassDefFoundError(),
4889       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4890       _class_name-&gt;as_C_string());
4891     return;
4892   }
4893 
4894   if (!_need_verify) { return; }
4895 
4896   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4897   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4898   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4899   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4900   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4901   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4902   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4903   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4904 
4905   if ((is_abstract &amp;&amp; is_final) ||
4906       (is_interface &amp;&amp; !is_abstract) ||
4907       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
4908       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {
4909     ResourceMark rm(THREAD);
4910     Exceptions::fthrow(
4911       THREAD_AND_LOCATION,
4912       vmSymbols::java_lang_ClassFormatError(),
4913       &quot;Illegal class modifiers in class %s: 0x%X&quot;,
4914       _class_name-&gt;as_C_string(), flags
4915     );
4916     return;
4917   }
4918 }
4919 
4920 static bool has_illegal_visibility(jint flags) {
4921   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4922   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4923   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4924 
4925   return ((is_public &amp;&amp; is_protected) ||
4926           (is_public &amp;&amp; is_private) ||
4927           (is_protected &amp;&amp; is_private));
4928 }
4929 
4930 // A legal major_version.minor_version must be one of the following:
4931 //
4932 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4933 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4934 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
4935 //
4936 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
4937   ResourceMark rm(THREAD);
4938   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
4939   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
4940     Exceptions::fthrow(
4941       THREAD_AND_LOCATION,
4942       vmSymbols::java_lang_UnsupportedClassVersionError(),
4943       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
4944       class_name-&gt;as_C_string(), major, minor);
4945     return;
4946   }
4947 
4948   if (major &gt; max_version) {
4949     Exceptions::fthrow(
4950       THREAD_AND_LOCATION,
4951       vmSymbols::java_lang_UnsupportedClassVersionError(),
4952       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
4953       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
4954       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
4955     return;
4956   }
4957 
4958   if (major &lt; JAVA_12_VERSION || minor == 0) {
4959     return;
4960   }
4961 
4962   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
4963     if (major != max_version) {
4964       Exceptions::fthrow(
4965         THREAD_AND_LOCATION,
4966         vmSymbols::java_lang_UnsupportedClassVersionError(),
4967         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
4968         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
4969         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
4970       return;
4971     }
4972 
4973     if (!Arguments::enable_preview()) {
4974       Exceptions::fthrow(
4975         THREAD_AND_LOCATION,
4976         vmSymbols::java_lang_UnsupportedClassVersionError(),
4977         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4978         class_name-&gt;as_C_string(), major, minor);
4979       return;
4980     }
4981 
4982   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4983     Exceptions::fthrow(
4984         THREAD_AND_LOCATION,
4985         vmSymbols::java_lang_UnsupportedClassVersionError(),
4986         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4987         class_name-&gt;as_C_string(), major, minor);
4988   }
4989 }
4990 
4991 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4992                                                    bool is_interface,
4993                                                    TRAPS) const {
4994   if (!_need_verify) { return; }
4995 
4996   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4997   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4998   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4999   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5000   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5001   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5002   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5003   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5004   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5005 
5006   bool is_illegal = false;
5007 
5008   if (is_interface) {
5009     if (!is_public || !is_static || !is_final || is_private ||
5010         is_protected || is_volatile || is_transient ||
5011         (major_gte_1_5 &amp;&amp; is_enum)) {
5012       is_illegal = true;
5013     }
5014   } else { // not interface
5015     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5016       is_illegal = true;
5017     }
5018   }
5019 
5020   if (is_illegal) {
5021     ResourceMark rm(THREAD);
5022     Exceptions::fthrow(
5023       THREAD_AND_LOCATION,
5024       vmSymbols::java_lang_ClassFormatError(),
5025       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5026       _class_name-&gt;as_C_string(), flags);
5027     return;
5028   }
5029 }
5030 
5031 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5032                                                     bool is_interface,
5033                                                     const Symbol* name,
5034                                                     TRAPS) const {
5035   if (!_need_verify) { return; }
5036 
5037   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5038   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5039   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5040   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5041   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5042   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5043   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5044   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5045   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5046   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5047   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5048   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5049   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5050 
5051   bool is_illegal = false;
5052 
5053   if (is_interface) {
5054     if (major_gte_8) {
5055       // Class file version is JAVA_8_VERSION or later Methods of
5056       // interfaces may set any of the flags except ACC_PROTECTED,
5057       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5058       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5059       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5060           (is_native || is_protected || is_final || is_synchronized) ||
5061           // If a specific method of a class or interface has its
5062           // ACC_ABSTRACT flag set, it must not have any of its
5063           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5064           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5065           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5066           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5067           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5068         is_illegal = true;
5069       }
5070     } else if (major_gte_1_5) {
5071       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5072       if (!is_public || is_private || is_protected || is_static || is_final ||
5073           is_synchronized || is_native || !is_abstract || is_strict) {
5074         is_illegal = true;
5075       }
5076     } else {
5077       // Class file version is pre-JAVA_1_5_VERSION
5078       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5079         is_illegal = true;
5080       }
5081     }
5082   } else { // not interface
5083     if (has_illegal_visibility(flags)) {
5084       is_illegal = true;
5085     } else {
5086       if (is_initializer) {
5087         if (is_static || is_final || is_synchronized || is_native ||
5088             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5089           is_illegal = true;
5090         }
5091       } else { // not initializer
5092         if (is_abstract) {
5093           if ((is_final || is_native || is_private || is_static ||
5094               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5095             is_illegal = true;
5096           }
5097         }
5098       }
5099     }
5100   }
5101 
5102   if (is_illegal) {
5103     ResourceMark rm(THREAD);
5104     Exceptions::fthrow(
5105       THREAD_AND_LOCATION,
5106       vmSymbols::java_lang_ClassFormatError(),
5107       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,
5108       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);
5109     return;
5110   }
5111 }
5112 
5113 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5114                                         int length,
5115                                         TRAPS) const {
5116   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5117   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5118     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5119   }
5120 }
5121 
5122 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5123 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5124 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5125 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5126 // method.  Because these names have been checked as special cases before
5127 // calling this method in verify_legal_method_name.
5128 //
5129 // This method is also called from the modular system APIs in modules.cpp
5130 // to verify the validity of module and package names.
5131 bool ClassFileParser::verify_unqualified_name(const char* name,
5132                                               unsigned int length,
5133                                               int type) {
5134   if (length == 0) return false;  // Must have at least one char.
5135   for (const char* p = name; p != name + length; p++) {
5136     switch(*p) {
5137       case JVM_SIGNATURE_DOT:
5138       case JVM_SIGNATURE_ENDCLASS:
5139       case JVM_SIGNATURE_ARRAY:
5140         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5141         return false;
5142       case JVM_SIGNATURE_SLASH:
5143         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5144         // unqualified name must not be empty
5145         if (type == ClassFileParser::LegalClass) {
5146           if (p == name || p+1 &gt;= name+length ||
5147               *(p+1) == JVM_SIGNATURE_SLASH) {
5148             return false;
5149           }
5150         } else {
5151           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5152         }
5153         break;
5154       case JVM_SIGNATURE_SPECIAL:
5155       case JVM_SIGNATURE_ENDSPECIAL:
5156         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5157         if (type == ClassFileParser::LegalMethod) {
5158           return false;
5159         }
5160     }
5161   }
5162   return true;
5163 }
5164 
5165 // Take pointer to a UTF8 byte string (not NUL-terminated).
5166 // Skip over the longest part of the string that could
5167 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5168 // Return a pointer to just past the fieldname.
5169 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5170 // being true, we saw consecutive slashes (meaning we were looking for a
5171 // qualified path but found something that was badly-formed).
5172 static const char* skip_over_field_name(const char* const name,
5173                                         bool slash_ok,
5174                                         unsigned int length) {
5175   const char* p;
5176   jboolean last_is_slash = false;
5177   jboolean not_first_ch = false;
5178 
5179   for (p = name; p != name + length; not_first_ch = true) {
5180     const char* old_p = p;
5181     jchar ch = *p;
5182     if (ch &lt; 128) {
5183       p++;
5184       // quick check for ascii
5185       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5186         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5187         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5188         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5189         last_is_slash = false;
5190         continue;
5191       }
5192       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5193         if (last_is_slash) {
5194           return NULL;  // Don&#39;t permit consecutive slashes
5195         }
5196         last_is_slash = true;
5197         continue;
5198       }
5199     }
5200     else {
5201       jint unicode_ch;
5202       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5203       p = tmp_p;
5204       last_is_slash = false;
5205       // Check if ch is Java identifier start or is Java identifier part
5206       // 4672820: call java.lang.Character methods directly without generating separate tables.
5207       EXCEPTION_MARK;
5208       // return value
5209       JavaValue result(T_BOOLEAN);
5210       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5211       JavaCallArguments args;
5212       args.push_int(unicode_ch);
5213 
5214       if (not_first_ch) {
5215         // public static boolean isJavaIdentifierPart(char ch);
5216         JavaCalls::call_static(&amp;result,
5217           SystemDictionary::Character_klass(),
5218           vmSymbols::isJavaIdentifierPart_name(),
5219           vmSymbols::int_bool_signature(),
5220           &amp;args,
5221           THREAD);
5222       } else {
5223         // public static boolean isJavaIdentifierStart(char ch);
5224         JavaCalls::call_static(&amp;result,
5225           SystemDictionary::Character_klass(),
5226           vmSymbols::isJavaIdentifierStart_name(),
5227           vmSymbols::int_bool_signature(),
5228           &amp;args,
5229           THREAD);
5230       }
5231       if (HAS_PENDING_EXCEPTION) {
5232         CLEAR_PENDING_EXCEPTION;
5233         return NULL;
5234       }
5235       if(result.get_jboolean()) {
5236         continue;
5237       }
5238     }
5239     return (not_first_ch) ? old_p : NULL;
5240   }
5241   return (not_first_ch) ? p : NULL;
5242 }
5243 
5244 // Take pointer to a UTF8 byte string (not NUL-terminated).
5245 // Skip over the longest part of the string that could
5246 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5247 // Return a pointer to just past the signature.
5248 // Return NULL if no legal signature is found.
5249 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5250                                                        bool void_ok,
5251                                                        unsigned int length,
5252                                                        TRAPS) const {
5253   unsigned int array_dim = 0;
5254   while (length &gt; 0) {
5255     switch (signature[0]) {
5256     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5257     case JVM_SIGNATURE_BOOLEAN:
5258     case JVM_SIGNATURE_BYTE:
5259     case JVM_SIGNATURE_CHAR:
5260     case JVM_SIGNATURE_SHORT:
5261     case JVM_SIGNATURE_INT:
5262     case JVM_SIGNATURE_FLOAT:
5263     case JVM_SIGNATURE_LONG:
5264     case JVM_SIGNATURE_DOUBLE:
5265       return signature + 1;
5266     case JVM_SIGNATURE_CLASS: {
5267       if (_major_version &lt; JAVA_1_5_VERSION) {
5268         // Skip over the class name if one is there
5269         const char* const p = skip_over_field_name(signature + 1, true, --length);
5270 
5271         // The next character better be a semicolon
5272         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5273           return p + 1;
5274         }
5275       }
5276       else {
5277         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
5278         signature++;
5279         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5280         // Format check signature
5281         if (c != NULL) {
5282           int newlen = c - (char*) signature;
5283           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5284           if (!legal) {
5285             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5286                                   &quot;in descriptor in class file %s&quot;,
5287                                   CHECK_0);
5288             return NULL;
5289           }
5290           return signature + newlen + 1;
5291         }
5292       }
5293       return NULL;
5294     }
5295     case JVM_SIGNATURE_ARRAY:
5296       array_dim++;
5297       if (array_dim &gt; 255) {
5298         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5299         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_0);
5300       }
5301       // The rest of what&#39;s there better be a legal signature
5302       signature++;
5303       length--;
5304       void_ok = false;
5305       break;
5306     default:
5307       return NULL;
5308     }
5309   }
5310   return NULL;
5311 }
5312 
5313 // Checks if name is a legal class name.
5314 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5315   if (!_need_verify || _relax_verify) { return; }
5316 
5317   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5318   char* bytes = (char*)name-&gt;bytes();
5319   unsigned int length = name-&gt;utf8_length();
5320   bool legal = false;
5321 
5322   if (length &gt; 0) {
5323     const char* p;
5324     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5325       p = skip_over_field_signature(bytes, false, length, CHECK);
5326       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5327     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5328       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5329         p = skip_over_field_name(bytes, true, length);
5330         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5331       }
5332     } else {
5333       // 4900761: relax the constraints based on JSR202 spec
5334       // Class names may be drawn from the entire Unicode character set.
5335       // Identifiers between &#39;/&#39; must be unqualified names.
5336       // The utf8 string has been verified when parsing cpool entries.
5337       legal = verify_unqualified_name(bytes, length, LegalClass);
5338     }
5339   }
5340   if (!legal) {
5341     ResourceMark rm(THREAD);
5342     assert(_class_name != NULL, &quot;invariant&quot;);
5343     Exceptions::fthrow(
5344       THREAD_AND_LOCATION,
5345       vmSymbols::java_lang_ClassFormatError(),
5346       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5347       _class_name-&gt;as_C_string()
5348     );
5349     return;
5350   }
5351 }
5352 
5353 // Checks if name is a legal field name.
5354 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5355   if (!_need_verify || _relax_verify) { return; }
5356 
5357   char* bytes = (char*)name-&gt;bytes();
5358   unsigned int length = name-&gt;utf8_length();
5359   bool legal = false;
5360 
5361   if (length &gt; 0) {
5362     if (_major_version &lt; JAVA_1_5_VERSION) {
5363       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5364         const char* p = skip_over_field_name(bytes, false, length);
5365         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5366       }
5367     } else {
5368       // 4881221: relax the constraints based on JSR202 spec
5369       legal = verify_unqualified_name(bytes, length, LegalField);
5370     }
5371   }
5372 
5373   if (!legal) {
5374     ResourceMark rm(THREAD);
5375     assert(_class_name != NULL, &quot;invariant&quot;);
5376     Exceptions::fthrow(
5377       THREAD_AND_LOCATION,
5378       vmSymbols::java_lang_ClassFormatError(),
5379       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5380       _class_name-&gt;as_C_string()
5381     );
5382     return;
5383   }
5384 }
5385 
5386 // Checks if name is a legal method name.
5387 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5388   if (!_need_verify || _relax_verify) { return; }
5389 
5390   assert(name != NULL, &quot;method name is null&quot;);
5391   char* bytes = (char*)name-&gt;bytes();
5392   unsigned int length = name-&gt;utf8_length();
5393   bool legal = false;
5394 
5395   if (length &gt; 0) {
5396     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5397       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5398         legal = true;
5399       }
5400     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5401       const char* p;
5402       p = skip_over_field_name(bytes, false, length);
5403       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5404     } else {
5405       // 4881221: relax the constraints based on JSR202 spec
5406       legal = verify_unqualified_name(bytes, length, LegalMethod);
5407     }
5408   }
5409 
5410   if (!legal) {
5411     ResourceMark rm(THREAD);
5412     assert(_class_name != NULL, &quot;invariant&quot;);
5413     Exceptions::fthrow(
5414       THREAD_AND_LOCATION,
5415       vmSymbols::java_lang_ClassFormatError(),
5416       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5417       _class_name-&gt;as_C_string()
5418     );
5419     return;
5420   }
5421 }
5422 
5423 
5424 // Checks if signature is a legal field signature.
5425 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5426                                                    const Symbol* signature,
5427                                                    TRAPS) const {
5428   if (!_need_verify) { return; }
5429 
5430   const char* const bytes = (const char* const)signature-&gt;bytes();
5431   const unsigned int length = signature-&gt;utf8_length();
5432   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5433 
5434   if (p == NULL || (p - bytes) != (int)length) {
5435     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5436   }
5437 }
5438 
5439 // Checks if signature is a legal method signature.
5440 // Returns number of parameters
5441 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5442                                                    const Symbol* signature,
5443                                                    TRAPS) const {
5444   if (!_need_verify) {
5445     // make sure caller&#39;s args_size will be less than 0 even for non-static
5446     // method so it will be recomputed in compute_size_of_parameters().
5447     return -2;
5448   }
5449 
5450   // Class initializers cannot have args for class format version &gt;= 51.
5451   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5452       signature != vmSymbols::void_method_signature() &amp;&amp;
5453       _major_version &gt;= JAVA_7_VERSION) {
5454     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5455     return 0;
5456   }
5457 
5458   unsigned int args_size = 0;
5459   const char* p = (const char*)signature-&gt;bytes();
5460   unsigned int length = signature-&gt;utf8_length();
5461   const char* nextp;
5462 
5463   // The first character must be a &#39;(&#39;
5464   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5465     length--;
5466     // Skip over legal field signatures
5467     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5468     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5469       args_size++;
5470       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5471         args_size++;
5472       }
5473       length -= nextp - p;
5474       p = nextp;
5475       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5476     }
5477     // The first non-signature thing better be a &#39;)&#39;
5478     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5479       length--;
5480       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
5481         // All internal methods must return void
5482         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5483           return args_size;
5484         }
5485       } else {
5486         // Now we better just have a return value
5487         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5488         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5489           return args_size;
5490         }
5491       }
5492     }
5493   }
5494   // Report error
5495   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5496   return 0;
5497 }
5498 
5499 int ClassFileParser::static_field_size() const {
5500   assert(_field_info != NULL, &quot;invariant&quot;);
5501   return _field_info-&gt;static_field_size;
5502 }
5503 
5504 int ClassFileParser::total_oop_map_count() const {
5505   assert(_field_info != NULL, &quot;invariant&quot;);
5506   return _field_info-&gt;total_oop_map_count;
5507 }
5508 
5509 jint ClassFileParser::layout_size() const {
5510   assert(_field_info != NULL, &quot;invariant&quot;);
5511   return _field_info-&gt;instance_size;
5512 }
5513 
5514 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5515                                          const Array&lt;Method*&gt;* methods) {
5516   assert(ik != NULL, &quot;invariant&quot;);
5517   assert(methods != NULL, &quot;invariant&quot;);
5518 
5519   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5520   // (We used to do this lazily, but now we query it in Rewriter,
5521   // which is eagerly done for every method, so we might as well do it now,
5522   // when everything is fresh in memory.)
5523   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5524 
5525   if (klass_id != vmSymbols::NO_SID) {
5526     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5527       Method* method = methods-&gt;at(j);
5528       method-&gt;init_intrinsic_id();
5529 
5530       if (CheckIntrinsics) {
5531         // Check if an intrinsic is defined for method &#39;method&#39;,
5532         // but the method is not annotated with @HotSpotIntrinsicCandidate.
5533         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
5534             !method-&gt;intrinsic_candidate()) {
5535               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5536               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
5537               method-&gt;name_and_sig_as_C_string(),
5538               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5539             );
5540           tty-&gt;cr();
5541           DEBUG_ONLY(vm_exit(1));
5542         }
5543         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
5544         // but there is no intrinsic available for it.
5545         if (method-&gt;intrinsic_candidate() &amp;&amp;
5546           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
5547             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
5548               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
5549               method-&gt;name_and_sig_as_C_string(),
5550               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5551             );
5552           tty-&gt;cr();
5553           DEBUG_ONLY(vm_exit(1));
5554         }
5555       }
5556     } // end for
5557 
5558 #ifdef ASSERT
5559     if (CheckIntrinsics) {
5560       // Check for orphan methods in the current class. A method m
5561       // of a class C is orphan if an intrinsic is defined for method m,
5562       // but class C does not declare m.
5563       // The check is potentially expensive, therefore it is available
5564       // only in debug builds.
5565 
5566       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
5567         if (vmIntrinsics::_compiledLambdaForm == id) {
5568           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
5569           // generated for the JVM from a LambdaForm and therefore no method
5570           // is defined for it.
5571           continue;
5572         }
5573 
5574         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
5575           // Check if the current class contains a method with the same
5576           // name, flags, signature.
5577           bool match = false;
5578           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5579             const Method* method = methods-&gt;at(j);
5580             if (method-&gt;intrinsic_id() == id) {
5581               match = true;
5582               break;
5583             }
5584           }
5585 
5586           if (!match) {
5587             char buf[1000];
5588             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5589                        &quot;but the method is not available in class [%s].%s&quot;,
5590                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5591                                                              buf, sizeof(buf)),
5592                         ik-&gt;name()-&gt;as_C_string(),
5593                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5594             );
5595             tty-&gt;cr();
5596             DEBUG_ONLY(vm_exit(1));
5597           }
5598         }
5599       } // end for
5600     } // CheckIntrinsics
5601 #endif // ASSERT
5602   }
5603 }
5604 
5605 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5606   if (_klass != NULL) {
5607     return _klass;
5608   }
5609 
5610   InstanceKlass* const ik =
5611     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5612 
5613   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5614 
5615   assert(_klass == ik, &quot;invariant&quot;);
5616 
5617 
5618   if (ik-&gt;should_store_fingerprint()) {
5619     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5620   }
5621 
5622   ik-&gt;set_has_passed_fingerprint_check(false);
5623   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5624     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5625     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5626     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5627       // This class matches with a class saved in an AOT library
5628       ik-&gt;set_has_passed_fingerprint_check(true);
5629     } else {
5630       ResourceMark rm;
5631       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5632                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5633     }
5634   }
5635 
5636   return ik;
5637 }
5638 
5639 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5640   assert(ik != NULL, &quot;invariant&quot;);
5641 
5642   // Set name and CLD before adding to CLD
5643   ik-&gt;set_class_loader_data(_loader_data);
5644   ik-&gt;set_name(_class_name);
5645 
5646   // Add all classes to our internal class loader list here,
5647   // including classes in the bootstrap (NULL) class loader.
5648   const bool publicize = !is_internal();
5649 
5650   _loader_data-&gt;add_class(ik, publicize);
5651 
5652   set_klass_to_deallocate(ik);
5653 
5654   assert(_field_info != NULL, &quot;invariant&quot;);
5655   assert(ik-&gt;static_field_size() == _field_info-&gt;static_field_size, &quot;sanity&quot;);
5656   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;total_oop_map_count,
5657     &quot;sanity&quot;);
5658 
5659   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5660   assert(ik-&gt;size_helper() == _field_info-&gt;instance_size, &quot;sanity&quot;);
5661 
5662   // Fill in information already parsed
5663   ik-&gt;set_should_verify_class(_need_verify);
5664 
5665   // Not yet: supers are done below to support the new subtype-checking fields
5666   ik-&gt;set_nonstatic_field_size(_field_info-&gt;nonstatic_field_size);
5667   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;has_nonstatic_fields);
5668   assert(_fac != NULL, &quot;invariant&quot;);
5669   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5670 
5671   // this transfers ownership of a lot of arrays from
5672   // the parser onto the InstanceKlass*
5673   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5674 
5675   // note that is not safe to use the fields in the parser from this point on
5676   assert(NULL == _cp, &quot;invariant&quot;);
5677   assert(NULL == _fields, &quot;invariant&quot;);
5678   assert(NULL == _methods, &quot;invariant&quot;);
5679   assert(NULL == _inner_classes, &quot;invariant&quot;);
5680   assert(NULL == _nest_members, &quot;invariant&quot;);
5681   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5682   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5683   assert(NULL == _record_components, &quot;invariant&quot;);
5684 
5685   if (_has_final_method) {
5686     ik-&gt;set_has_final_method();
5687   }
5688 
5689   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5690   // The InstanceKlass::_methods_jmethod_ids cache
5691   // is managed on the assumption that the initial cache
5692   // size is equal to the number of methods in the class. If
5693   // that changes, then InstanceKlass::idnum_can_increment()
5694   // has to be changed accordingly.
5695   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5696 
5697   ik-&gt;set_this_class_index(_this_class_index);
5698 
5699   if (is_unsafe_anonymous()) {
5700     // _this_class_index is a CONSTANT_Class entry that refers to this
5701     // anonymous class itself. If this class needs to refer to its own methods or
5702     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5703     // _this_class_index. However, because this class is anonymous (it&#39;s
5704     // not stored in SystemDictionary), _this_class_index cannot be resolved
5705     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5706     // Therefore, we must eagerly resolve _this_class_index now.
5707     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5708   }
5709 
5710   ik-&gt;set_minor_version(_minor_version);
5711   ik-&gt;set_major_version(_major_version);
5712   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5713   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
5714 
5715   if (_unsafe_anonymous_host != NULL) {
5716     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5717     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5718   }
5719 
5720   // Set PackageEntry for this_klass
5721   oop cl = ik-&gt;class_loader();
5722   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5723   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5724   ik-&gt;set_package(cld, CHECK);
5725 
5726   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5727   assert(methods != NULL, &quot;invariant&quot;);
5728   const int methods_len = methods-&gt;length();
5729 
5730   check_methods_for_intrinsics(ik, methods);
5731 
5732   // Fill in field values obtained by parse_classfile_attributes
5733   if (_parsed_annotations-&gt;has_any_annotations()) {
5734     _parsed_annotations-&gt;apply_to(ik);
5735   }
5736 
5737   apply_parsed_class_attributes(ik);
5738 
5739   // Miranda methods
5740   if ((_num_miranda_methods &gt; 0) ||
5741       // if this class introduced new miranda methods or
5742       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5743         // super class exists and this class inherited miranda methods
5744      ) {
5745        ik-&gt;set_has_miranda_methods(); // then set a flag
5746   }
5747 
5748   // Fill in information needed to compute superclasses.
5749   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5750   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5751   _transitive_interfaces = NULL;
5752 
5753   // Initialize itable offset tables
5754   klassItable::setup_itable_offset_table(ik);
5755 
5756   // Compute transitive closure of interfaces this class implements
5757   // Do final class setup
5758   fill_oop_maps(ik,
5759                 _field_info-&gt;nonstatic_oop_map_count,
5760                 _field_info-&gt;nonstatic_oop_offsets,
5761                 _field_info-&gt;nonstatic_oop_counts);
5762 
5763   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5764   set_precomputed_flags(ik);
5765 
5766   // check if this class can access its super class
5767   check_super_class_access(ik, CHECK);
5768 
5769   // check if this class can access its superinterfaces
5770   check_super_interface_access(ik, CHECK);
5771 
5772   // check if this class overrides any final method
5773   check_final_method_override(ik, CHECK);
5774 
5775   // reject static interface methods prior to Java 8
5776   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5777     check_illegal_static_method(ik, CHECK);
5778   }
5779 
5780   // Obtain this_klass&#39; module entry
5781   ModuleEntry* module_entry = ik-&gt;module();
5782   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
5783 
5784   // Obtain java.lang.Module
5785   Handle module_handle(THREAD, module_entry-&gt;module());
5786 
5787   // Allocate mirror and initialize static fields
5788   // The create_mirror() call will also call compute_modifiers()
5789   java_lang_Class::create_mirror(ik,
5790                                  Handle(THREAD, _loader_data-&gt;class_loader()),
5791                                  module_handle,
5792                                  _protection_domain,
5793                                  CHECK);
5794 
5795   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5796 
5797   // Generate any default methods - default methods are public interface methods
5798   // that have a default implementation.  This is new with Java 8.
5799   if (_has_nonstatic_concrete_methods) {
5800     DefaultMethods::generate_default_methods(ik,
5801                                              _all_mirandas,
5802                                              CHECK);
5803   }
5804 
5805   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5806   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5807       !module_entry-&gt;has_default_read_edges()) {
5808     if (!module_entry-&gt;set_has_default_read_edges()) {
5809       // We won a potential race
5810       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5811     }
5812   }
5813 
5814   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5815 
5816   if (!is_internal()) {
5817     if (log_is_enabled(Info, class, load)) {
5818       ResourceMark rm;
5819       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5820       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5821     }
5822 
5823     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5824         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5825         log_is_enabled(Info, class, preview)) {
5826       ResourceMark rm;
5827       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5828                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5829     }
5830 
5831     if (log_is_enabled(Debug, class, resolve))  {
5832       ResourceMark rm;
5833       // print out the superclass.
5834       const char * from = ik-&gt;external_name();
5835       if (ik-&gt;java_super() != NULL) {
5836         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5837                    from,
5838                    ik-&gt;java_super()-&gt;external_name());
5839       }
5840       // print out each of the interface classes referred to by this class.
5841       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5842       if (local_interfaces != NULL) {
5843         const int length = local_interfaces-&gt;length();
5844         for (int i = 0; i &lt; length; i++) {
5845           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5846           const char * to = k-&gt;external_name();
5847           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5848         }
5849       }
5850     }
5851   }
5852 
5853   JFR_ONLY(INIT_ID(ik);)
5854 
5855   // If we reach here, all is well.
5856   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5857   // in order for it to not be destroyed in the ClassFileParser destructor.
5858   set_klass_to_deallocate(NULL);
5859 
5860   // it&#39;s official
5861   set_klass(ik);
5862 
5863   debug_only(ik-&gt;verify();)
5864 }
5865 
5866 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5867   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5868   _class_name-&gt;decrement_refcount();
5869 
5870   _class_name = new_class_name;
5871   // Increment the refcount of the new name.
5872   // Now the ClassFileParser owns this name and will decrement in
5873   // the destructor.
5874   _class_name-&gt;increment_refcount();
5875 }
5876 
5877 
5878 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5879 // package by prepending its host class&#39;s package name to its class name and setting
5880 // its _class_name field.
5881 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5882   ResourceMark rm(THREAD);
5883   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
5884          &quot;Unsafe anonymous class should not be in a package&quot;);
5885   const char* host_pkg_name =
5886     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
5887 
5888   if (host_pkg_name != NULL) {
5889     int host_pkg_len = (int)strlen(host_pkg_name);
5890     int class_name_len = _class_name-&gt;utf8_length();
5891     int symbol_len = host_pkg_len + 1 + class_name_len;
5892     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
5893     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
5894                          host_pkg_name, class_name_len, _class_name-&gt;base());
5895     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
5896 
5897     // Decrement old _class_name to avoid leaking.
5898     _class_name-&gt;decrement_refcount();
5899 
5900     // Create a symbol and update the anonymous class name.
5901     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
5902     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
5903     // when the class is unloaded.
5904     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
5905   }
5906 }
5907 
5908 // If the host class and the anonymous class are in the same package then do
5909 // nothing.  If the anonymous class is in the unnamed package then move it to its
5910 // host&#39;s package.  If the classes are in different packages then throw an IAE
5911 // exception.
5912 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
5913   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
5914 
5915   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
5916                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
5917   if (anon_last_slash == NULL) {  // Unnamed package
5918     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
5919   } else {
5920     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
5921       ResourceMark rm(THREAD);
5922       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
5923         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
5924         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
5925     }
5926   }
5927 }
5928 
5929 static bool relax_format_check_for(ClassLoaderData* loader_data) {
5930   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
5931                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
5932   bool need_verify =
5933     // verifyAll
5934     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
5935     // verifyRemote
5936     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
5937   return !need_verify;
5938 }
5939 
5940 ClassFileParser::ClassFileParser(ClassFileStream* stream,
5941                                  Symbol* name,
5942                                  ClassLoaderData* loader_data,
5943                                  Handle protection_domain,
5944                                  const InstanceKlass* unsafe_anonymous_host,
5945                                  GrowableArray&lt;Handle&gt;* cp_patches,
5946                                  Publicity pub_level,
5947                                  TRAPS) :
5948   _stream(stream),
5949   _requested_name(name),
5950   _class_name(NULL),
5951   _loader_data(loader_data),
5952   _unsafe_anonymous_host(unsafe_anonymous_host),
5953   _cp_patches(cp_patches),
5954   _num_patched_klasses(0),
5955   _max_num_patched_klasses(0),
5956   _orig_cp_size(0),
5957   _first_patched_klass_resolved_index(0),
5958   _super_klass(),
5959   _cp(NULL),
5960   _fields(NULL),
5961   _methods(NULL),
5962   _inner_classes(NULL),
5963   _nest_members(NULL),
5964   _nest_host(0),
5965   _record_components(NULL),
5966   _local_interfaces(NULL),
5967   _transitive_interfaces(NULL),
5968   _combined_annotations(NULL),
5969   _class_annotations(NULL),
5970   _class_type_annotations(NULL),
5971   _fields_annotations(NULL),
5972   _fields_type_annotations(NULL),
5973   _klass(NULL),
5974   _klass_to_deallocate(NULL),
5975   _parsed_annotations(NULL),
5976   _fac(NULL),
5977   _field_info(NULL),
5978   _method_ordering(NULL),
5979   _all_mirandas(NULL),
5980   _vtable_size(0),
5981   _itable_size(0),
5982   _num_miranda_methods(0),
5983   _rt(REF_NONE),
5984   _protection_domain(protection_domain),
5985   _access_flags(),
5986   _pub_level(pub_level),
5987   _bad_constant_seen(0),
5988   _synthetic_flag(false),
5989   _sde_length(false),
5990   _sde_buffer(NULL),
5991   _sourcefile_index(0),
5992   _generic_signature_index(0),
5993   _major_version(0),
5994   _minor_version(0),
5995   _this_class_index(0),
5996   _super_class_index(0),
5997   _itfs_len(0),
5998   _java_fields_count(0),
5999   _need_verify(false),
6000   _relax_verify(false),
6001   _has_nonstatic_concrete_methods(false),
6002   _declares_nonstatic_concrete_methods(false),
6003   _has_final_method(false),
6004   _has_finalizer(false),
6005   _has_empty_finalizer(false),
6006   _has_vanilla_constructor(false),
6007   _max_bootstrap_specifier_index(-1) {
6008 
6009   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6010   _class_name-&gt;increment_refcount();
6011 
6012   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6013   assert(_loader_data != NULL, &quot;invariant&quot;);
6014   assert(stream != NULL, &quot;invariant&quot;);
6015   assert(_stream != NULL, &quot;invariant&quot;);
6016   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6017   assert(_class_name != NULL, &quot;invariant&quot;);
6018   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6019 
6020   // Figure out whether we can skip format checking (matching classic VM behavior)
6021   if (DumpSharedSpaces) {
6022     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6023     // Verification decision is based on BytecodeVerificationRemote flag
6024     // for those classes.
6025     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6026                                               BytecodeVerificationLocal;
6027   }
6028   else {
6029     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6030                                                stream-&gt;need_verify());
6031   }
6032   if (_cp_patches != NULL) {
6033     int len = _cp_patches-&gt;length();
6034     for (int i=0; i&lt;len; i++) {
6035       if (has_cp_patch_at(i)) {
6036         Handle patch = cp_patch_at(i);
6037         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6038           // We need to append the names of the patched classes to the end of the constant pool,
6039           // because a patched class may have a Utf8 name that&#39;s not already included in the
6040           // original constant pool. These class names are used when patch_constant_pool()
6041           // calls patch_class().
6042           //
6043           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6044           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6045           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6046           _max_num_patched_klasses++;
6047         }
6048       }
6049     }
6050   }
6051 
6052   // synch back verification state to stream
6053   stream-&gt;set_verify(_need_verify);
6054 
6055   // Check if verification needs to be relaxed for this class file
6056   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6057   _relax_verify = relax_format_check_for(_loader_data);
6058 
6059   parse_stream(stream, CHECK);
6060 
6061   post_process_parsed_stream(stream, _cp, CHECK);
6062 }
6063 
6064 void ClassFileParser::clear_class_metadata() {
6065   // metadata created before the instance klass is created.  Must be
6066   // deallocated if classfile parsing returns an error.
6067   _cp = NULL;
6068   _fields = NULL;
6069   _methods = NULL;
6070   _inner_classes = NULL;
6071   _nest_members = NULL;
6072   _local_interfaces = NULL;
6073   _combined_annotations = NULL;
6074   _class_annotations = _class_type_annotations = NULL;
6075   _fields_annotations = _fields_type_annotations = NULL;
6076   _record_components = NULL;
6077 }
6078 
6079 // Destructor to clean up
6080 ClassFileParser::~ClassFileParser() {
6081   _class_name-&gt;decrement_refcount();
6082 
6083   if (_cp != NULL) {
6084     MetadataFactory::free_metadata(_loader_data, _cp);
6085   }
6086   if (_fields != NULL) {
6087     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6088   }
6089 
6090   if (_methods != NULL) {
6091     // Free methods
6092     InstanceKlass::deallocate_methods(_loader_data, _methods);
6093   }
6094 
6095   // beware of the Universe::empty_blah_array!!
6096   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6097     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6098   }
6099 
6100   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6101     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6102   }
6103 
6104   if (_record_components != NULL) {
6105     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6106   }
6107 
6108   // Free interfaces
6109   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6110                                        _local_interfaces, _transitive_interfaces);
6111 
6112   if (_combined_annotations != NULL) {
6113     // After all annotations arrays have been created, they are installed into the
6114     // Annotations object that will be assigned to the InstanceKlass being created.
6115 
6116     // Deallocate the Annotations object and the installed annotations arrays.
6117     _combined_annotations-&gt;deallocate_contents(_loader_data);
6118 
6119     // If the _combined_annotations pointer is non-NULL,
6120     // then the other annotations fields should have been cleared.
6121     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6122     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6123     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6124     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6125   } else {
6126     // If the annotations arrays were not installed into the Annotations object,
6127     // then they have to be deallocated explicitly.
6128     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6129     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6130     Annotations::free_contents(_loader_data, _fields_annotations);
6131     Annotations::free_contents(_loader_data, _fields_type_annotations);
6132   }
6133 
6134   clear_class_metadata();
6135   _transitive_interfaces = NULL;
6136 
6137   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6138   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6139   // at a safepoint.
6140   if (_klass_to_deallocate != NULL) {
6141     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6142   }
6143 }
6144 
6145 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6146                                    TRAPS) {
6147 
6148   assert(stream != NULL, &quot;invariant&quot;);
6149   assert(_class_name != NULL, &quot;invariant&quot;);
6150 
6151   // BEGIN STREAM PARSING
6152   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6153   // Magic value
6154   const u4 magic = stream-&gt;get_u4_fast();
6155   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6156                      &quot;Incompatible magic value %u in class file %s&quot;,
6157                      magic, CHECK);
6158 
6159   // Version numbers
6160   _minor_version = stream-&gt;get_u2_fast();
6161   _major_version = stream-&gt;get_u2_fast();
6162 
6163   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6164     ResourceMark rm;
6165     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6166             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6167     Exceptions::fthrow(
6168       THREAD_AND_LOCATION,
6169       vmSymbols::java_lang_UnsupportedClassVersionError(),
6170       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6171       _major_version,
6172       _minor_version);
6173   }
6174 
6175   // Check version numbers - we check this even with verifier off
6176   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6177 
6178   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6179   u2 cp_size = stream-&gt;get_u2_fast();
6180 
6181   guarantee_property(
6182     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6183     cp_size, CHECK);
6184 
6185   _orig_cp_size = cp_size;
6186   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6187     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6188   }
6189   cp_size += _max_num_patched_klasses;
6190 
6191   _cp = ConstantPool::allocate(_loader_data,
6192                                cp_size,
6193                                CHECK);
6194 
6195   ConstantPool* const cp = _cp;
6196 
6197   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6198 
6199   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6200 
6201   // ACCESS FLAGS
6202   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6203 
6204   // Access flags
6205   jint flags;
6206   // JVM_ACC_MODULE is defined in JDK-9 and later.
6207   if (_major_version &gt;= JAVA_9_VERSION) {
6208     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);
6209   } else {
6210     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;
6211   }
6212 
6213   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6214     // Set abstract bit for old class files for backward compatibility
6215     flags |= JVM_ACC_ABSTRACT;
6216   }
6217 
6218   verify_legal_class_modifiers(flags, CHECK);
6219 
6220   short bad_constant = class_bad_constant_seen();
6221   if (bad_constant != 0) {
6222     // Do not throw CFE until after the access_flags are checked because if
6223     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6224     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6225   }
6226 
6227   _access_flags.set_flags(flags);
6228 
6229   // This class and superclass
6230   _this_class_index = stream-&gt;get_u2_fast();
6231   check_property(
6232     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6233       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6234     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6235     _this_class_index, CHECK);
6236 
6237   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6238   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6239 
6240   // Update _class_name to reflect the name in the constant pool
6241   update_class_name(class_name_in_cp);
6242 
6243   // Don&#39;t need to check whether this class name is legal or not.
6244   // It has been checked when constant pool is parsed.
6245   // However, make sure it is not an array type.
6246   if (_need_verify) {
6247     guarantee_property(_class_name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6248                        &quot;Bad class name in class file %s&quot;,
6249                        CHECK);
6250   }
6251 
6252   // Checks if name in class file matches requested name
6253   if (_requested_name != NULL &amp;&amp; _requested_name != _class_name) {
6254     ResourceMark rm(THREAD);
6255     Exceptions::fthrow(
6256       THREAD_AND_LOCATION,
6257       vmSymbols::java_lang_NoClassDefFoundError(),
6258       &quot;%s (wrong name: %s)&quot;,
6259       _class_name-&gt;as_C_string(),
6260       _requested_name != NULL ? _requested_name-&gt;as_C_string() : &quot;NoName&quot;
6261     );
6262     return;
6263   }
6264 
6265   // if this is an anonymous class fix up its name if it&#39;s in the unnamed
6266   // package.  Otherwise, throw IAE if it is in a different package than
6267   // its host class.
6268   if (_unsafe_anonymous_host != NULL) {
6269     fix_unsafe_anonymous_class_name(CHECK);
6270   }
6271 
6272   // Verification prevents us from creating names with dots in them, this
6273   // asserts that that&#39;s the case.
6274   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6275 
6276   if (!is_internal()) {
6277     LogTarget(Debug, class, preorder) lt;
6278     if (lt.is_enabled()){
6279       ResourceMark rm(THREAD);
6280       LogStream ls(lt);
6281       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6282       if (stream-&gt;source() != NULL) {
6283         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6284       }
6285       ls.cr();
6286     }
6287 
6288 #if INCLUDE_CDS
6289     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6290       if (!ClassLoader::has_jrt_entry()) {
6291         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6292         DumpLoadedClassList = NULL;
6293       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6294                  _unsafe_anonymous_host == NULL) {
6295         // Only dump the classes that can be stored into CDS archive.
6296         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6297         oop class_loader = _loader_data-&gt;class_loader();
6298         ResourceMark rm(THREAD);
6299         bool skip = false;
6300         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6301           // For the boot and platform class loaders, skip classes that are not found in the
6302           // java runtime image, such as those found in the --patch-module entries.
6303           // These classes can&#39;t be loaded from the archive during runtime.
6304           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6305             skip = true;
6306           }
6307 
6308           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6309             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6310             // as they can be loaded from the archive during runtime.
6311             skip = false;
6312           }
6313         }
6314         if (skip) {
6315           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6316             _class_name-&gt;as_C_string(), stream-&gt;source());
6317         } else {
6318           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6319           classlist_file-&gt;flush();
6320         }
6321       }
6322     }
6323 #endif
6324   }
6325 
6326   // SUPERKLASS
6327   _super_class_index = stream-&gt;get_u2_fast();
6328   _super_klass = parse_super_class(cp,
6329                                    _super_class_index,
6330                                    _need_verify,
6331                                    CHECK);
6332 
6333   // Interfaces
6334   _itfs_len = stream-&gt;get_u2_fast();
6335   parse_interfaces(stream,
6336                    _itfs_len,
6337                    cp,
6338                    &amp;_has_nonstatic_concrete_methods,
6339                    CHECK);
6340 
6341   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6342 
6343   // Fields (offsets are filled in later)
6344   _fac = new FieldAllocationCount();
6345   parse_fields(stream,
6346                _access_flags.is_interface(),
6347                _fac,
6348                cp,
6349                cp_size,
6350                &amp;_java_fields_count,
6351                CHECK);
6352 
6353   assert(_fields != NULL, &quot;invariant&quot;);
6354 
6355   // Methods
6356   AccessFlags promoted_flags;
6357   parse_methods(stream,
6358                 _access_flags.is_interface(),
6359                 &amp;promoted_flags,
6360                 &amp;_has_final_method,
6361                 &amp;_declares_nonstatic_concrete_methods,
6362                 CHECK);
6363 
6364   assert(_methods != NULL, &quot;invariant&quot;);
6365 
6366   // promote flags from parse_methods() to the klass&#39; flags
6367   _access_flags.add_promoted_flags(promoted_flags.as_int());
6368 
6369   if (_declares_nonstatic_concrete_methods) {
6370     _has_nonstatic_concrete_methods = true;
6371   }
6372 
6373   // Additional attributes/annotations
6374   _parsed_annotations = new ClassAnnotationCollector();
6375   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6376 
6377   assert(_inner_classes != NULL, &quot;invariant&quot;);
6378 
6379   // Finalize the Annotations metadata object,
6380   // now that all annotation arrays have been created.
6381   create_combined_annotations(CHECK);
6382 
6383   // Make sure this is the end of class file stream
6384   guarantee_property(stream-&gt;at_eos(),
6385                      &quot;Extra bytes at the end of class file %s&quot;,
6386                      CHECK);
6387 
6388   // all bytes in stream read and parsed
6389 }
6390 
6391 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6392                                                  ConstantPool* cp,
6393                                                  TRAPS) {
6394   assert(stream != NULL, &quot;invariant&quot;);
6395   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6396   assert(cp != NULL, &quot;invariant&quot;);
6397   assert(_loader_data != NULL, &quot;invariant&quot;);
6398 
6399   if (_class_name == vmSymbols::java_lang_Object()) {
6400     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6401                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6402                    CHECK);
6403   }
6404   // We check super class after class file is parsed and format is checked
6405   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6406     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6407     if (_access_flags.is_interface()) {
6408       // Before attempting to resolve the superclass, check for class format
6409       // errors not checked yet.
6410       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6411         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6412         CHECK);
6413     }
6414     Handle loader(THREAD, _loader_data-&gt;class_loader());
6415     _super_klass = (const InstanceKlass*)
6416                        SystemDictionary::resolve_super_or_fail(_class_name,
6417                                                                super_class_name,
6418                                                                loader,
6419                                                                _protection_domain,
6420                                                                true,
6421                                                                CHECK);
6422   }
6423 
6424   if (_super_klass != NULL) {
6425     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6426       _has_nonstatic_concrete_methods = true;
6427     }
6428 
6429     if (_super_klass-&gt;is_interface()) {
6430       ResourceMark rm(THREAD);
6431       Exceptions::fthrow(
6432         THREAD_AND_LOCATION,
6433         vmSymbols::java_lang_IncompatibleClassChangeError(),
6434         &quot;class %s has interface %s as super class&quot;,
6435         _class_name-&gt;as_klass_external_name(),
6436         _super_klass-&gt;external_name()
6437       );
6438       return;
6439     }
6440     // Make sure super class is not final
6441     if (_super_klass-&gt;is_final()) {
6442       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6443     }
6444   }
6445 
6446   // Compute the transitive list of all unique interfaces implemented by this class
6447   _transitive_interfaces =
6448     compute_transitive_interfaces(_super_klass,
6449                                   _local_interfaces,
6450                                   _loader_data,
6451                                   CHECK);
6452 
6453   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6454 
6455   // sort methods
6456   _method_ordering = sort_methods(_methods);
6457 
6458   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6459 
6460   Handle loader(THREAD, _loader_data-&gt;class_loader());
6461   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6462                                                     &amp;_num_miranda_methods,
6463                                                     _all_mirandas,
6464                                                     _super_klass,
6465                                                     _methods,
6466                                                     _access_flags,
6467                                                     _major_version,
6468                                                     loader,
6469                                                     _class_name,
6470                                                     _local_interfaces,
6471                                                     CHECK);
6472 
6473   // Size of Java itable (in words)
6474   _itable_size = _access_flags.is_interface() ? 0 :
6475     klassItable::compute_itable_size(_transitive_interfaces);
6476 
6477   assert(_fac != NULL, &quot;invariant&quot;);
6478   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6479 
6480   _field_info = new FieldLayoutInfo();
6481   layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6482 
6483   // Compute reference typ
6484   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6485 
6486 }
6487 
6488 void ClassFileParser::set_klass(InstanceKlass* klass) {
6489 
6490 #ifdef ASSERT
6491   if (klass != NULL) {
6492     assert(NULL == _klass, &quot;leaking?&quot;);
6493   }
6494 #endif
6495 
6496   _klass = klass;
6497 }
6498 
6499 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6500 
6501 #ifdef ASSERT
6502   if (klass != NULL) {
6503     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6504   }
6505 #endif
6506 
6507   _klass_to_deallocate = klass;
6508 }
6509 
6510 // Caller responsible for ResourceMark
6511 // clone stream with rewound position
6512 const ClassFileStream* ClassFileParser::clone_stream() const {
6513   assert(_stream != NULL, &quot;invariant&quot;);
6514 
6515   return _stream-&gt;clone();
6516 }
6517 // ----------------------------------------------------------------------------
6518 // debugging
6519 
6520 #ifdef ASSERT
6521 
6522 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6523 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6524   if (class_name != NULL) {
6525     ResourceMark rm;
6526     char* name = class_name-&gt;as_C_string();
6527     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6528   } else {
6529     return true;
6530   }
6531 }
6532 
6533 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>