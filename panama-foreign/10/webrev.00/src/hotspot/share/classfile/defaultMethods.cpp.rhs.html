<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/defaultMethods.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/bytecodeAssembler.hpp&quot;
  27 #include &quot;classfile/defaultMethods.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;logging/log.hpp&quot;
  31 #include &quot;logging/logStream.hpp&quot;
  32 #include &quot;memory/allocation.hpp&quot;
  33 #include &quot;memory/metadataFactory.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;runtime/handles.inline.hpp&quot;
  37 #include &quot;runtime/signature.hpp&quot;
  38 #include &quot;runtime/thread.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/klass.hpp&quot;
  41 #include &quot;oops/method.hpp&quot;
  42 #include &quot;utilities/accessFlags.hpp&quot;
  43 #include &quot;utilities/exceptions.hpp&quot;
  44 #include &quot;utilities/ostream.hpp&quot;
  45 #include &quot;utilities/pair.hpp&quot;
  46 #include &quot;utilities/resourceHash.hpp&quot;
  47 
  48 typedef enum { QUALIFIED, DISQUALIFIED } QualifiedState;
  49 
  50 static void print_slot(outputStream* str, Symbol* name, Symbol* signature) {
  51   str-&gt;print(&quot;%s%s&quot;, name-&gt;as_C_string(), signature-&gt;as_C_string());
  52 }
  53 
  54 static void print_method(outputStream* str, Method* mo, bool with_class=true) {
  55   if (with_class) {
  56     str-&gt;print(&quot;%s.&quot;, mo-&gt;klass_name()-&gt;as_C_string());
  57   }
  58   print_slot(str, mo-&gt;name(), mo-&gt;signature());
  59 }
  60 
  61 /**
  62  * Perform a depth-first iteration over the class hierarchy, applying
  63  * algorithmic logic as it goes.
  64  *
  65  * This class is one half of the inheritance hierarchy analysis mechanism.
  66  * It is meant to be used in conjunction with another class, the algorithm,
  67  * which is indicated by the ALGO template parameter.  This class can be
  68  * paired with any algorithm class that provides the required methods.
  69  *
  70  * This class contains all the mechanics for iterating over the class hierarchy
  71  * starting at a particular root, without recursing (thus limiting stack growth
  72  * from this point).  It visits each superclass (if present) and superinterface
  73  * in a depth-first manner, with callbacks to the ALGO class as each class is
  74  * encountered (visit()), The algorithm can cut-off further exploration of a
  75  * particular branch by returning &#39;false&#39; from a visit() call.
  76  *
  77  * The ALGO class, must provide a visit() method, which each of which will be
  78  * called once for each node in the inheritance tree during the iteration.  In
  79  * addition, it can provide a memory block via new_node_data(), which it can
  80  * use for node-specific storage (and access via the current_data() and
  81  * data_at_depth(int) methods).
  82  *
  83  * Bare minimum needed to be an ALGO class:
  84  * class Algo : public HierarchyVisitor&lt;Algo&gt; {
  85  *   void* new_node_data() { return NULL; }
  86  *   void free_node_data(void* data) { return; }
  87  *   bool visit() { return true; }
  88  * };
  89  */
  90 template &lt;class ALGO&gt;
  91 class HierarchyVisitor : StackObj {
  92  private:
  93 
  94   class Node : public ResourceObj {
  95    public:
  96     InstanceKlass* _class;
  97     bool _super_was_visited;
  98     int _interface_index;
  99     void* _algorithm_data;
 100 
 101     Node(InstanceKlass* cls, void* data, bool visit_super)
 102         : _class(cls), _super_was_visited(!visit_super),
 103           _interface_index(0), _algorithm_data(data) {}
 104 
 105     void update(InstanceKlass* cls, void* data, bool visit_super) {
 106       _class = cls;
 107       _super_was_visited = !visit_super;
 108       _interface_index = 0;
 109       _algorithm_data = data;
 110     }
 111     int number_of_interfaces() { return _class-&gt;local_interfaces()-&gt;length(); }
 112     int interface_index() { return _interface_index; }
 113     void set_super_visited() { _super_was_visited = true; }
 114     void increment_visited_interface() { ++_interface_index; }
 115     void set_all_interfaces_visited() {
 116       _interface_index = number_of_interfaces();
 117     }
 118     bool has_visited_super() { return _super_was_visited; }
 119     bool has_visited_all_interfaces() {
 120       return interface_index() &gt;= number_of_interfaces();
 121     }
 122     InstanceKlass* interface_at(int index) {
 123       return _class-&gt;local_interfaces()-&gt;at(index);
 124     }
 125     InstanceKlass* next_super() { return _class-&gt;java_super(); }
 126     InstanceKlass* next_interface() {
 127       return interface_at(interface_index());
 128     }
 129   };
 130 
 131   bool _visited_Object;
 132 
 133   GrowableArray&lt;Node*&gt; _path;
 134   GrowableArray&lt;Node*&gt; _free_nodes;
 135 
 136   Node* current_top() const { return _path.top(); }
 137   bool has_more_nodes() const { return _path.length() &gt; 0; }
 138   void push(InstanceKlass* cls, ALGO* algo) {
 139     assert(cls != NULL, &quot;Requires a valid instance class&quot;);
 140     if (cls == SystemDictionary::Object_klass()) {
 141       _visited_Object = true;
 142     }
 143     void* data = algo-&gt;new_node_data();
 144     Node* node;
 145     if (_free_nodes.is_empty()) { // Add a new node
 146       node = new Node(cls, data, has_super(cls));
 147     } else { // Reuse existing node and data
 148       node = _free_nodes.pop();
 149       node-&gt;update(cls, data, has_super(cls));
 150     }
 151     _path.push(node);
 152   }
 153   void pop() {
 154     Node* node = _path.pop();
 155     // Make the node available for reuse
 156     _free_nodes.push(node);
 157   }
 158 
 159   // Since the starting point can be an interface, we must ensure we catch
 160   // j.l.Object as the super once in those cases. The _visited_Object flag
 161   // only ensures we don&#39;t then repeatedly enqueue Object for each interface
 162   // in the class hierarchy.
 163   bool has_super(InstanceKlass* cls) {
 164     return cls-&gt;super() != NULL &amp;&amp; (!_visited_Object || !cls-&gt;is_interface());
 165   }
 166 
 167   Node* node_at_depth(int i) const {
 168     return (i &gt;= _path.length()) ? NULL : _path.at(_path.length() - i - 1);
 169   }
 170 
 171  protected:
 172 
 173   // Resets the visitor
 174   void reset() {
 175     _visited_Object = false;
 176   }
 177 
 178   // Accessors available to the algorithm
 179   int current_depth() const { return _path.length() - 1; }
 180 
 181   InstanceKlass* class_at_depth(int i) {
 182     Node* n = node_at_depth(i);
 183     return n == NULL ? NULL : n-&gt;_class;
 184   }
 185   InstanceKlass* current_class() { return class_at_depth(0); }
 186 
 187   void* data_at_depth(int i) {
 188     Node* n = node_at_depth(i);
 189     return n == NULL ? NULL : n-&gt;_algorithm_data;
 190   }
 191   void* current_data() { return data_at_depth(0); }
 192 
 193  public:
 194   HierarchyVisitor() : _visited_Object(false), _path() {}
 195 
 196   void run(InstanceKlass* root) {
 197     ALGO* algo = static_cast&lt;ALGO*&gt;(this);
 198 
 199     push(root, algo);
 200     bool top_needs_visit = true;
 201     do {
 202       Node* top = current_top();
 203       if (top_needs_visit) {
 204         if (algo-&gt;visit() == false) {
 205           // algorithm does not want to continue along this path.  Arrange
 206           // it so that this state is immediately popped off the stack
 207           top-&gt;set_super_visited();
 208           top-&gt;set_all_interfaces_visited();
 209         }
 210         top_needs_visit = false;
 211       }
 212 
 213       if (top-&gt;has_visited_super() &amp;&amp; top-&gt;has_visited_all_interfaces()) {
 214         algo-&gt;free_node_data(top-&gt;_algorithm_data);
 215         pop();
 216       } else {
 217         InstanceKlass* next = NULL;
 218         if (top-&gt;has_visited_super() == false) {
 219           next = top-&gt;next_super();
 220           top-&gt;set_super_visited();
 221         } else {
 222           next = top-&gt;next_interface();
 223           top-&gt;increment_visited_interface();
 224         }
 225         assert(next != NULL, &quot;Otherwise we shouldn&#39;t be here&quot;);
 226         push(next, algo);
 227         top_needs_visit = true;
 228       }
 229     } while (has_more_nodes());
 230   }
 231 };
 232 
 233 class PrintHierarchy : public HierarchyVisitor&lt;PrintHierarchy&gt; {
 234  private:
 235    outputStream* _st;
 236  public:
 237   bool visit() {
 238     InstanceKlass* cls = current_class();
 239     streamIndentor si(_st, current_depth() * 2);
 240     _st-&gt;indent().print_cr(&quot;%s&quot;, cls-&gt;name()-&gt;as_C_string());
 241     return true;
 242   }
 243 
 244   void* new_node_data() { return NULL; }
 245   void free_node_data(void* data) { return; }
 246 
 247   PrintHierarchy(outputStream* st = tty) : _st(st) {}
 248 };
 249 
 250 // Used to register InstanceKlass objects and all related metadata structures
 251 // (Methods, ConstantPools) as &quot;in-use&quot; by the current thread so that they can&#39;t
 252 // be deallocated by class redefinition while we&#39;re using them.  The classes are
 253 // de-registered when this goes out of scope.
 254 //
 255 // Once a class is registered, we need not bother with methodHandles or
 256 // constantPoolHandles for it&#39;s associated metadata.
 257 class KeepAliveRegistrar : public StackObj {
 258  private:
 259   Thread* _thread;
 260   GrowableArray&lt;ConstantPool*&gt; _keep_alive;
 261 
 262  public:
 263   KeepAliveRegistrar(Thread* thread) : _thread(thread), _keep_alive(6) {
 264     assert(thread == Thread::current(), &quot;Must be current thread&quot;);
 265   }
 266 
 267   ~KeepAliveRegistrar() {
 268     for (int i = _keep_alive.length() - 1; i &gt;= 0; --i) {
 269       ConstantPool* cp = _keep_alive.at(i);
 270       int idx = _thread-&gt;metadata_handles()-&gt;find_from_end(cp);
 271       assert(idx &gt; 0, &quot;Must be in the list&quot;);
 272       _thread-&gt;metadata_handles()-&gt;remove_at(idx);
 273     }
 274   }
 275 
 276   // Register a class as &#39;in-use&#39; by the thread.  It&#39;s fine to register a class
 277   // multiple times (though perhaps inefficient)
 278   void register_class(InstanceKlass* ik) {
 279     ConstantPool* cp = ik-&gt;constants();
 280     _keep_alive.push(cp);
 281     _thread-&gt;metadata_handles()-&gt;push(cp);
 282   }
 283 };
 284 
 285 class KeepAliveVisitor : public HierarchyVisitor&lt;KeepAliveVisitor&gt; {
 286  private:
 287   KeepAliveRegistrar* _registrar;
 288 
 289  public:
 290   KeepAliveVisitor(KeepAliveRegistrar* registrar) : _registrar(registrar) {}
 291 
 292   void* new_node_data() { return NULL; }
 293   void free_node_data(void* data) { return; }
 294 
 295   bool visit() {
 296     _registrar-&gt;register_class(current_class());
 297     return true;
 298   }
 299 };
 300 
 301 
 302 // A method family contains a set of all methods that implement a single
 303 // erased method. As members of the set are collected while walking over the
 304 // hierarchy, they are tagged with a qualification state.  The qualification
 305 // state for an erased method is set to disqualified if there exists a path
 306 // from the root of hierarchy to the method that contains an interleaving
 307 // erased method defined in an interface.
 308 
 309 class MethodState {
 310  public:
 311   Method* _method;
 312   QualifiedState _state;
 313 
 314   MethodState() : _method(NULL), _state(DISQUALIFIED) {}
 315   MethodState(Method* method, QualifiedState state) : _method(method), _state(state) {}
 316 };
 317 
 318 class MethodFamily : public ResourceObj {
 319  private:
 320 
 321   GrowableArray&lt;MethodState&gt; _members;
 322 
 323   Method* _selected_target;  // Filled in later, if a unique target exists
 324   Symbol* _exception_message; // If no unique target is found
 325   Symbol* _exception_name;    // If no unique target is found
 326 
 327   MethodState* find_method(Method* method) {
 328     for (int i = 0; i &lt; _members.length(); i++) {
 329       if (_members.at(i)._method == method) {
 330         return &amp;_members.at(i);
 331       }
 332     }
 333     return NULL;
 334   }
 335 
 336   void add_method(Method* method, QualifiedState state) {
 337     MethodState method_state(method, state);
 338     _members.append(method_state);
 339   }
 340 
 341   Symbol* generate_no_defaults_message(TRAPS) const;
 342   Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;
 343   Symbol* generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const;
 344 
 345  public:
 346 
 347   MethodFamily()
 348       : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}
 349 
 350   void set_target_if_empty(Method* m) {
 351     if (_selected_target == NULL &amp;&amp; !m-&gt;is_overpass()) {
 352       _selected_target = m;
 353     }
 354   }
 355 
 356   void record_method(Method* m, QualifiedState state) {
 357     // If not in the set, add it.  If it&#39;s already in the set, then leave it
 358     // as is if state is qualified, or set it to disqualified if state is
 359     // disqualified.
 360     MethodState* method_state = find_method(m);
 361     if (method_state == NULL) {
 362       add_method(m, state);
 363     } else if (state == DISQUALIFIED) {
 364       method_state-&gt;_state = DISQUALIFIED;
 365     }
 366   }
 367 
 368   bool has_target() const { return _selected_target != NULL; }
 369   bool throws_exception() { return _exception_message != NULL; }
 370 
 371   Method* get_selected_target() { return _selected_target; }
 372   Symbol* get_exception_message() { return _exception_message; }
 373   Symbol* get_exception_name() { return _exception_name; }
 374 
 375   // Either sets the target or the exception error message
 376   void determine_target_or_set_exception_message(InstanceKlass* root, TRAPS) {
 377     if (has_target() || throws_exception()) {
 378       return;
 379     }
 380 
 381     // Qualified methods are maximally-specific methods
 382     // These include public, instance concrete (=default) and abstract methods
 383     int num_defaults = 0;
 384     int default_index = -1;
 385     for (int i = 0; i &lt; _members.length(); i++) {
 386       MethodState &amp;member = _members.at(i);
 387       if (member._state == QUALIFIED) {
 388         if (member._method-&gt;is_default_method()) {
 389           num_defaults++;
 390           default_index = i;
 391         }
 392       }
 393     }
 394 
 395     if (num_defaults == 1) {
 396       assert(_members.at(default_index)._state == QUALIFIED, &quot;&quot;);
 397       _selected_target = _members.at(default_index)._method;
 398     } else {
 399       generate_and_set_exception_message(root, num_defaults, default_index, CHECK);
 400     }
 401   }
 402 
 403   void generate_and_set_exception_message(InstanceKlass* root, int num_defaults, int default_index, TRAPS) {
 404     assert(num_defaults != 1, &quot;invariant - should&#39;ve been handled calling method&quot;);
 405 
 406     GrowableArray&lt;Method*&gt; qualified_methods;
 407     for (int i = 0; i &lt; _members.length(); i++) {
 408       MethodState&amp; member = _members.at(i);
 409       if (member._state == QUALIFIED) {
 410         qualified_methods.push(member._method);
 411       }
 412     }
 413     if (num_defaults == 0) {
 414       // If the root klass has a static method with matching name and signature
 415       // then do not generate an overpass method because it will hide the
 416       // static method during resolution.
 417       if (qualified_methods.length() == 0) {
 418         _exception_message = generate_no_defaults_message(CHECK);
 419       } else {
 420         assert(root != NULL, &quot;Null root class&quot;);
 421         _exception_message = generate_method_message(root-&gt;name(), qualified_methods.at(0), CHECK);
 422       }
 423       _exception_name = vmSymbols::java_lang_AbstractMethodError();
 424     } else {
 425       _exception_message = generate_conflicts_message(&amp;_members,CHECK);
 426       _exception_name = vmSymbols::java_lang_IncompatibleClassChangeError();
 427       LogTarget(Debug, defaultmethods) lt;
 428       if (lt.is_enabled()) {
 429         LogStream ls(lt);
 430         _exception_message-&gt;print_value_on(&amp;ls);
 431         ls.cr();
 432       }
 433     }
 434   }
 435 
 436   void print_selected(outputStream* str, int indent) const {
 437     assert(has_target(), &quot;Should be called otherwise&quot;);
 438     streamIndentor si(str, indent * 2);
 439     str-&gt;indent().print(&quot;Selected method: &quot;);
 440     print_method(str, _selected_target);
 441     Klass* method_holder = _selected_target-&gt;method_holder();
 442     if (!method_holder-&gt;is_interface()) {
 443       str-&gt;print(&quot; : in superclass&quot;);
 444     }
 445     str-&gt;cr();
 446   }
 447 
 448   void print_exception(outputStream* str, int indent) {
 449     assert(throws_exception(), &quot;Should be called otherwise&quot;);
 450     assert(_exception_name != NULL, &quot;exception_name should be set&quot;);
 451     streamIndentor si(str, indent * 2);
 452     str-&gt;indent().print_cr(&quot;%s: %s&quot;, _exception_name-&gt;as_C_string(), _exception_message-&gt;as_C_string());
 453   }
 454 };
 455 
 456 Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {
 457   return SymbolTable::new_symbol(&quot;No qualifying defaults found&quot;);
 458 }
 459 
 460 Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {
 461   stringStream ss;
 462   ss.print(&quot;Method &quot;);
 463   Symbol* name = method-&gt;name();
 464   Symbol* signature = method-&gt;signature();
 465   ss.write((const char*)klass_name-&gt;bytes(), klass_name-&gt;utf8_length());
 466   ss.print(&quot;.&quot;);
 467   ss.write((const char*)name-&gt;bytes(), name-&gt;utf8_length());
 468   ss.write((const char*)signature-&gt;bytes(), signature-&gt;utf8_length());
 469   ss.print(&quot; is abstract&quot;);
 470   return SymbolTable::new_symbol(ss.base(), (int)ss.size());
 471 }
 472 
 473 Symbol* MethodFamily::generate_conflicts_message(GrowableArray&lt;MethodState&gt;* methods, TRAPS) const {
 474   stringStream ss;
 475   ss.print(&quot;Conflicting default methods:&quot;);
 476   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
 477     Method *method = methods-&gt;at(i)._method;
 478     Symbol *klass = method-&gt;klass_name();
 479     Symbol *name = method-&gt;name();
 480     ss.print(&quot; &quot;);
 481     ss.write((const char*) klass-&gt;bytes(), klass-&gt;utf8_length());
 482     ss.print(&quot;.&quot;);
 483     ss.write((const char*) name-&gt;bytes(), name-&gt;utf8_length());
 484   }
 485   return SymbolTable::new_symbol(ss.base(), (int)ss.size());
 486 }
 487 
 488 
 489 class StateRestorerScope;
 490 
 491 // StatefulMethodFamily is a wrapper around a MethodFamily that maintains the
 492 // qualification state during hierarchy visitation, and applies that state
 493 // when adding members to the MethodFamily
 494 class StatefulMethodFamily : public ResourceObj {
 495   friend class StateRestorer;
 496  private:
 497   QualifiedState _qualification_state;
 498 
 499   void set_qualification_state(QualifiedState state) {
 500     _qualification_state = state;
 501   }
 502 
 503  protected:
 504   MethodFamily _method_family;
 505 
 506  public:
 507   StatefulMethodFamily() {
 508    _qualification_state = QUALIFIED;
 509   }
 510 
 511   void set_target_if_empty(Method* m) { _method_family.set_target_if_empty(m); }
 512 
 513   MethodFamily* get_method_family() { return &amp;_method_family; }
 514 
 515   void record_method_and_dq_further(StateRestorerScope* scope, Method* mo);
 516 };
 517 
 518 // Because we use an iterative algorithm when iterating over the type
 519 // hierarchy, we can&#39;t use traditional scoped objects which automatically do
 520 // cleanup in the destructor when the scope is exited.  StateRestorerScope (and
 521 // StateRestorer) provides a similar functionality, but for when you want a
 522 // scoped object in non-stack memory (such as in resource memory, as we do
 523 // here).  You&#39;ve just got to remember to call &#39;restore_state()&#39; on the scope when
 524 // leaving it (and marks have to be explicitly added). The scope is reusable after
 525 // &#39;restore_state()&#39; has been called.
 526 class StateRestorer : public ResourceObj {
 527  public:
 528   StatefulMethodFamily* _method;
 529   QualifiedState _state_to_restore;
 530 
 531   StateRestorer() : _method(NULL), _state_to_restore(DISQUALIFIED) {}
 532 
 533   void restore_state() { _method-&gt;set_qualification_state(_state_to_restore); }
 534 };
 535 
 536 class StateRestorerScope : public ResourceObj {
 537  private:
 538   GrowableArray&lt;StateRestorer*&gt;  _marks;
 539   GrowableArray&lt;StateRestorer*&gt;* _free_list; // Shared between scopes
 540  public:
 541   StateRestorerScope(GrowableArray&lt;StateRestorer*&gt;* free_list) : _marks(), _free_list(free_list) {}
 542 
 543   static StateRestorerScope* cast(void* data) {
 544     return static_cast&lt;StateRestorerScope*&gt;(data);
 545   }
 546 
 547   void mark(StatefulMethodFamily* family, QualifiedState qualification_state) {
 548     StateRestorer* restorer;
 549     if (!_free_list-&gt;is_empty()) {
 550       restorer = _free_list-&gt;pop();
 551     } else {
 552       restorer = new StateRestorer();
 553     }
 554     restorer-&gt;_method = family;
 555     restorer-&gt;_state_to_restore = qualification_state;
 556     _marks.append(restorer);
 557   }
 558 
 559 #ifdef ASSERT
 560   bool is_empty() {
 561     return _marks.is_empty();
 562   }
 563 #endif
 564 
 565   void restore_state() {
 566     while(!_marks.is_empty()) {
 567       StateRestorer* restorer = _marks.pop();
 568       restorer-&gt;restore_state();
 569       _free_list-&gt;push(restorer);
 570     }
 571   }
 572 };
 573 
 574 void StatefulMethodFamily::record_method_and_dq_further(StateRestorerScope* scope, Method* mo) {
 575   scope-&gt;mark(this, _qualification_state);
 576   _method_family.record_method(mo, _qualification_state);
 577 
 578   // Everything found &quot;above&quot;??? this method in the hierarchy walk is set to
 579   // disqualified
 580   set_qualification_state(DISQUALIFIED);
 581 }
 582 
 583 // Represents a location corresponding to a vtable slot for methods that
 584 // neither the class nor any of it&#39;s ancestors provide an implementaion.
 585 // Default methods may be present to fill this slot.
 586 class EmptyVtableSlot : public ResourceObj {
 587  private:
 588   Symbol* _name;
 589   Symbol* _signature;
 590   int _size_of_parameters;
 591   MethodFamily* _binding;
 592 
 593  public:
 594   EmptyVtableSlot(Method* method)
 595       : _name(method-&gt;name()), _signature(method-&gt;signature()),
 596         _size_of_parameters(method-&gt;size_of_parameters()), _binding(NULL) {}
 597 
 598   Symbol* name() const { return _name; }
 599   Symbol* signature() const { return _signature; }
 600   int size_of_parameters() const { return _size_of_parameters; }
 601 
 602   void bind_family(MethodFamily* lm) { _binding = lm; }
 603   bool is_bound() { return _binding != NULL; }
 604   MethodFamily* get_binding() { return _binding; }
 605 
 606   void print_on(outputStream* str) const {
 607     print_slot(str, name(), signature());
 608   }
 609 };
 610 
 611 static bool already_in_vtable_slots(GrowableArray&lt;EmptyVtableSlot*&gt;* slots, Method* m) {
 612   bool found = false;
 613   for (int j = 0; j &lt; slots-&gt;length(); ++j) {
 614     if (slots-&gt;at(j)-&gt;name() == m-&gt;name() &amp;&amp;
 615         slots-&gt;at(j)-&gt;signature() == m-&gt;signature() ) {
 616       found = true;
 617       break;
 618     }
 619   }
 620   return found;
 621 }
 622 
 623 static void find_empty_vtable_slots(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 624     InstanceKlass* klass, const GrowableArray&lt;Method*&gt;* mirandas, TRAPS) {
 625 
 626   assert(klass != NULL, &quot;Must be valid class&quot;);
 627 
 628   // All miranda methods are obvious candidates
 629   for (int i = 0; i &lt; mirandas-&gt;length(); ++i) {
 630     Method* m = mirandas-&gt;at(i);
 631     if (!already_in_vtable_slots(slots, m)) {
 632       slots-&gt;append(new EmptyVtableSlot(m));
 633     }
 634   }
 635 
 636   // Also any overpasses in our superclasses, that we haven&#39;t implemented.
 637   // (can&#39;t use the vtable because it is not guaranteed to be initialized yet)
 638   InstanceKlass* super = klass-&gt;java_super();
 639   while (super != NULL) {
 640     for (int i = 0; i &lt; super-&gt;methods()-&gt;length(); ++i) {
 641       Method* m = super-&gt;methods()-&gt;at(i);
 642       if (m-&gt;is_overpass() || m-&gt;is_static()) {
 643         // m is a method that would have been a miranda if not for the
 644         // default method processing that occurred on behalf of our superclass,
 645         // so it&#39;s a method we want to re-examine in this new context.  That is,
 646         // unless we have a real implementation of it in the current class.
 647         if (!already_in_vtable_slots(slots, m)) {
 648           Method *impl = klass-&gt;lookup_method(m-&gt;name(), m-&gt;signature());
 649           if (impl == NULL || impl-&gt;is_overpass() || impl-&gt;is_static()) {
 650             slots-&gt;append(new EmptyVtableSlot(m));
 651           }
 652         }
 653       }
 654     }
 655 
 656     // also any default methods in our superclasses
 657     if (super-&gt;default_methods() != NULL) {
 658       for (int i = 0; i &lt; super-&gt;default_methods()-&gt;length(); ++i) {
 659         Method* m = super-&gt;default_methods()-&gt;at(i);
 660         // m is a method that would have been a miranda if not for the
 661         // default method processing that occurred on behalf of our superclass,
 662         // so it&#39;s a method we want to re-examine in this new context.  That is,
 663         // unless we have a real implementation of it in the current class.
 664         if (!already_in_vtable_slots(slots, m)) {
 665           Method* impl = klass-&gt;lookup_method(m-&gt;name(), m-&gt;signature());
 666           if (impl == NULL || impl-&gt;is_overpass() || impl-&gt;is_static()) {
 667             slots-&gt;append(new EmptyVtableSlot(m));
 668           }
 669         }
 670       }
 671     }
 672     super = super-&gt;java_super();
 673   }
 674 
 675   LogTarget(Debug, defaultmethods) lt;
 676   if (lt.is_enabled()) {
 677     lt.print(&quot;Slots that need filling:&quot;);
 678     ResourceMark rm;
 679     LogStream ls(lt);
 680     streamIndentor si(&amp;ls);
 681     for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 682       ls.indent();
 683       slots-&gt;at(i)-&gt;print_on(&amp;ls);
 684       ls.cr();
 685     }
 686   }
 687 }
 688 
 689 // Iterates over the superinterface type hierarchy looking for all methods
 690 // with a specific erased signature.
 691 class FindMethodsByErasedSig : public HierarchyVisitor&lt;FindMethodsByErasedSig&gt; {
 692  private:
 693   // Context data
 694   Symbol* _method_name;
 695   Symbol* _method_signature;
 696   StatefulMethodFamily*  _family;
 697   bool _cur_class_is_interface;
 698   // Free lists, used as an optimization
 699   GrowableArray&lt;StateRestorerScope*&gt; _free_scopes;
 700   GrowableArray&lt;StateRestorer*&gt; _free_restorers;
 701  public:
 702   FindMethodsByErasedSig() : _free_scopes(6), _free_restorers(6) {};
 703 
 704   void prepare(Symbol* name, Symbol* signature, bool is_interf) {
 705     reset();
 706     _method_name = name;
 707     _method_signature = signature;
 708     _family = NULL;
 709     _cur_class_is_interface = is_interf;
 710   }
 711 
 712   void get_discovered_family(MethodFamily** family) {
 713       if (_family != NULL) {
 714         *family = _family-&gt;get_method_family();
 715       } else {
 716         *family = NULL;
 717       }
 718   }
 719 
 720   void* new_node_data() {
 721     if (!_free_scopes.is_empty()) {
 722       StateRestorerScope* free_scope = _free_scopes.pop();
 723       assert(free_scope-&gt;is_empty(), &quot;StateRestorerScope::_marks array not empty&quot;);
 724       return free_scope;
 725     }
 726     return new StateRestorerScope(&amp;_free_restorers);
 727   }
 728   void free_node_data(void* node_data) {
 729     StateRestorerScope* scope =  StateRestorerScope::cast(node_data);
 730     scope-&gt;restore_state();
 731     // Reuse scopes
 732     _free_scopes.push(scope);
 733   }
 734 
 735   // Find all methods on this hierarchy that match this
 736   // method&#39;s erased (name, signature)
 737   bool visit() {
 738     StateRestorerScope* scope = StateRestorerScope::cast(current_data());
 739     InstanceKlass* iklass = current_class();
 740 
 741     Method* m = iklass-&gt;find_method(_method_name, _method_signature);
 742     // Private interface methods are not candidates for default methods.
 743     // invokespecial to private interface methods doesn&#39;t use default method logic.
 744     // Private class methods are not candidates for default methods.
 745     // Private methods do not override default methods, so need to perform
 746     // default method inheritance without including private methods.
 747     // The overpasses are your supertypes&#39; errors, we do not include them.
 748     // Non-public methods in java.lang.Object are not candidates for default
 749     // methods.
 750     // Future: take access controls into account for superclass methods
 751     if (m != NULL &amp;&amp; !m-&gt;is_static() &amp;&amp; !m-&gt;is_overpass() &amp;&amp; !m-&gt;is_private() &amp;&amp;
 752      (!_cur_class_is_interface || !SystemDictionary::is_nonpublic_Object_method(m))) {
 753       if (_family == NULL) {
 754         _family = new StatefulMethodFamily();
 755       }
 756 
 757       if (iklass-&gt;is_interface()) {
 758         _family-&gt;record_method_and_dq_further(scope, m);
 759       } else {
 760         // This is the rule that methods in classes &quot;win&quot; (bad word) over
 761         // methods in interfaces. This works because of single inheritance.
 762         // Private methods in classes do not &quot;win&quot;, they will be found
 763         // first on searching, but overriding for invokevirtual needs
 764         // to find default method candidates for the same signature
 765         _family-&gt;set_target_if_empty(m);
 766       }
 767     }
 768     return true;
 769   }
 770 
 771 };
 772 
 773 
 774 
 775 static void create_defaults_and_exceptions(
 776     GrowableArray&lt;EmptyVtableSlot*&gt;* slots, InstanceKlass* klass, TRAPS);
 777 
 778 static void generate_erased_defaults(
 779     FindMethodsByErasedSig* visitor,
 780     InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {
 781 
 782   // the visitor needs to be initialized or re-initialized before use
 783   // - this facilitates reusing the same visitor instance on multiple
 784   // generation passes as an optimization
 785   visitor-&gt;prepare(slot-&gt;name(), slot-&gt;signature(), is_intf);
 786   // sets up a set of methods with the same exact erased signature
 787   visitor-&gt;run(klass);
 788 
 789   MethodFamily* family;
 790   visitor-&gt;get_discovered_family(&amp;family);
 791   if (family != NULL) {
 792     family-&gt;determine_target_or_set_exception_message(klass, CHECK);
 793     slot-&gt;bind_family(family);
 794   }
 795 }
 796 
 797 static void merge_in_new_methods(InstanceKlass* klass,
 798     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 799 static void create_default_methods( InstanceKlass* klass,
 800     GrowableArray&lt;Method*&gt;* new_methods, TRAPS);
 801 
 802 // This is the guts of the default methods implementation.  This is called just
 803 // after the classfile has been parsed if some ancestor has default methods.
 804 //
 805 // First it finds any name/signature slots that need any implementation (either
 806 // because they are miranda or a superclass&#39;s implementation is an overpass
 807 // itself).  For each slot, iterate over the hierarchy, to see if they contain a
 808 // signature that matches the slot we are looking at.
 809 //
 810 // For each slot filled, we either record the default method candidate in the
 811 // klass default_methods list or, only to handle exception cases, we create an
 812 // overpass method that throws an exception and add it to the klass methods list.
 813 // The JVM does not create bridges nor handle generic signatures here.
 814 void DefaultMethods::generate_default_methods(
 815     InstanceKlass* klass, const GrowableArray&lt;Method*&gt;* mirandas, TRAPS) {
 816   assert(klass != NULL, &quot;invariant&quot;);
 817   assert(klass != SystemDictionary::Object_klass(), &quot;Shouldn&#39;t be called for Object&quot;);
 818 
 819   // This resource mark is the bound for all memory allocation that takes
 820   // place during default method processing.  After this goes out of scope,
 821   // all (Resource) objects&#39; memory will be reclaimed.  Be careful if adding an
 822   // embedded resource mark under here as that memory can&#39;t be used outside
 823   // whatever scope it&#39;s in.
 824   ResourceMark rm(THREAD);
 825 
 826   // Keep entire hierarchy alive for the duration of the computation
 827   constantPoolHandle cp(THREAD, klass-&gt;constants());
 828   KeepAliveRegistrar keepAlive(THREAD);
 829   KeepAliveVisitor loadKeepAlive(&amp;keepAlive);
 830   loadKeepAlive.run(klass);
 831 
 832   LogTarget(Debug, defaultmethods) lt;
 833   if (lt.is_enabled()) {
 834     ResourceMark rm;
 835     lt.print(&quot;%s %s requires default method processing&quot;,
 836              klass-&gt;is_interface() ? &quot;Interface&quot; : &quot;Class&quot;,
 837              klass-&gt;name()-&gt;as_klass_external_name());
 838     LogStream ls(lt);
 839     PrintHierarchy printer(&amp;ls);
 840     printer.run(klass);
 841   }
 842 
 843   GrowableArray&lt;EmptyVtableSlot*&gt; empty_slots;
 844   find_empty_vtable_slots(&amp;empty_slots, klass, mirandas, CHECK);
 845 
 846   if (empty_slots.length() &gt; 0) {
 847     FindMethodsByErasedSig findMethodsByErasedSig;
 848     for (int i = 0; i &lt; empty_slots.length(); ++i) {
 849       EmptyVtableSlot* slot = empty_slots.at(i);
 850       LogTarget(Debug, defaultmethods) lt;
 851       if (lt.is_enabled()) {
 852         LogStream ls(lt);
 853         streamIndentor si(&amp;ls, 2);
 854         ls.indent().print(&quot;Looking for default methods for slot &quot;);
 855         slot-&gt;print_on(&amp;ls);
 856         ls.cr();
 857       }
 858       generate_erased_defaults(&amp;findMethodsByErasedSig, klass, slot, klass-&gt;is_interface(), CHECK);
 859     }
 860     log_debug(defaultmethods)(&quot;Creating defaults and overpasses...&quot;);
 861     create_defaults_and_exceptions(&amp;empty_slots, klass, CHECK);
 862   }
 863   log_debug(defaultmethods)(&quot;Default method processing complete&quot;);
 864 }
 865 
 866 static int assemble_method_error(
 867     BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message, TRAPS) {
 868 
 869   Symbol* init = vmSymbols::object_initializer_name();
 870   Symbol* sig = vmSymbols::string_void_signature();
 871 
 872   BytecodeAssembler assem(buffer, cp);
 873 
 874   assem._new(errorName);
 875   assem.dup();
 876   assem.load_string(message);
 877   assem.invokespecial(errorName, init, sig);
 878   assem.athrow();
 879 
 880   return 3; // max stack size: [ exception, exception, string ]
 881 }
 882 
 883 static Method* new_method(
 884     BytecodeConstantPool* cp, BytecodeBuffer* bytecodes, Symbol* name,
 885     Symbol* sig, AccessFlags flags, int max_stack, int params,
 886     ConstMethod::MethodType mt, TRAPS) {
 887 
 888   address code_start = 0;
 889   int code_length = 0;
 890   InlineTableSizes sizes;
 891 
 892   if (bytecodes != NULL &amp;&amp; bytecodes-&gt;length() &gt; 0) {
 893     code_start = static_cast&lt;address&gt;(bytecodes-&gt;adr_at(0));
 894     code_length = bytecodes-&gt;length();
 895   }
 896 
 897   Method* m = Method::allocate(cp-&gt;pool_holder()-&gt;class_loader_data(),
 898                                code_length, flags, &amp;sizes,
 899                                mt, CHECK_NULL);
 900 
 901   m-&gt;set_constants(NULL); // This will get filled in later
 902   m-&gt;set_name_index(cp-&gt;utf8(name));
 903   m-&gt;set_signature_index(cp-&gt;utf8(sig));
<a name="2" id="anc2"></a><span class="line-modified"> 904   m-&gt;compute_from_signature(sig);</span>

 905   m-&gt;set_size_of_parameters(params);
 906   m-&gt;set_max_stack(max_stack);
 907   m-&gt;set_max_locals(params);
 908   m-&gt;constMethod()-&gt;set_stackmap_data(NULL);
 909   m-&gt;set_code(code_start);
 910 
 911   return m;
 912 }
 913 
 914 static void switchover_constant_pool(BytecodeConstantPool* bpool,
 915     InstanceKlass* klass, GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
 916 
 917   if (new_methods-&gt;length() &gt; 0) {
 918     ConstantPool* cp = bpool-&gt;create_constant_pool(CHECK);
 919     if (cp != klass-&gt;constants()) {
 920       // Copy resolved anonymous class into new constant pool.
 921       if (klass-&gt;is_unsafe_anonymous()) {
 922         cp-&gt;klass_at_put(klass-&gt;this_class_index(), klass);
 923       }
 924       klass-&gt;class_loader_data()-&gt;add_to_deallocate_list(klass-&gt;constants());
 925       klass-&gt;set_constants(cp);
 926       cp-&gt;set_pool_holder(klass);
 927 
 928       for (int i = 0; i &lt; new_methods-&gt;length(); ++i) {
 929         new_methods-&gt;at(i)-&gt;set_constants(cp);
 930       }
 931       for (int i = 0; i &lt; klass-&gt;methods()-&gt;length(); ++i) {
 932         Method* mo = klass-&gt;methods()-&gt;at(i);
 933         mo-&gt;set_constants(cp);
 934       }
 935     }
 936   }
 937 }
 938 
 939 // Create default_methods list for the current class.
 940 // With the VM only processing erased signatures, the VM only
 941 // creates an overpass in a conflict case or a case with no candidates.
 942 // This allows virtual methods to override the overpass, but ensures
 943 // that a local method search will find the exception rather than an abstract
 944 // or default method that is not a valid candidate.
 945 //
 946 // Note that if overpass method are ever created that are not exception
 947 // throwing methods then the loader constraint checking logic for vtable and
 948 // itable creation needs to be changed to check loader constraints for the
 949 // overpass methods that do not throw exceptions.
 950 static void create_defaults_and_exceptions(GrowableArray&lt;EmptyVtableSlot*&gt;* slots,
 951     InstanceKlass* klass, TRAPS) {
 952 
 953   GrowableArray&lt;Method*&gt; overpasses;
 954   GrowableArray&lt;Method*&gt; defaults;
 955   BytecodeConstantPool bpool(klass-&gt;constants());
 956 
 957   BytecodeBuffer* buffer = NULL; // Lazily create a reusable buffer
 958   for (int i = 0; i &lt; slots-&gt;length(); ++i) {
 959     EmptyVtableSlot* slot = slots-&gt;at(i);
 960 
 961     if (slot-&gt;is_bound()) {
 962       MethodFamily* method = slot-&gt;get_binding();
 963 
 964       LogTarget(Debug, defaultmethods) lt;
 965       if (lt.is_enabled()) {
 966         ResourceMark rm(THREAD);
 967         LogStream ls(lt);
 968         ls.print(&quot;for slot: &quot;);
 969         slot-&gt;print_on(&amp;ls);
 970         ls.cr();
 971         if (method-&gt;has_target()) {
 972           method-&gt;print_selected(&amp;ls, 1);
 973         } else if (method-&gt;throws_exception()) {
 974           method-&gt;print_exception(&amp;ls, 1);
 975         }
 976       }
 977 
 978       if (method-&gt;has_target()) {
 979         Method* selected = method-&gt;get_selected_target();
 980         if (selected-&gt;method_holder()-&gt;is_interface()) {
 981           assert(!selected-&gt;is_private(), &quot;pushing private interface method as default&quot;);
 982           defaults.push(selected);
 983         }
 984       } else if (method-&gt;throws_exception()) {
 985         if (buffer == NULL) {
 986           buffer = new BytecodeBuffer();
 987         } else {
 988           buffer-&gt;clear();
 989         }
 990         int max_stack = assemble_method_error(&amp;bpool, buffer,
 991            method-&gt;get_exception_name(), method-&gt;get_exception_message(), CHECK);
 992         AccessFlags flags = accessFlags_from(
 993           JVM_ACC_PUBLIC | JVM_ACC_SYNTHETIC | JVM_ACC_BRIDGE);
 994         Method* m = new_method(&amp;bpool, buffer, slot-&gt;name(), slot-&gt;signature(),
 995           flags, max_stack, slot-&gt;size_of_parameters(),
 996           ConstMethod::OVERPASS, CHECK);
 997         // We push to the methods list:
 998         // overpass methods which are exception throwing methods
 999         if (m != NULL) {
1000           overpasses.push(m);
1001         }
1002       }
1003     }
1004   }
1005 
1006 
1007   log_debug(defaultmethods)(&quot;Created %d overpass methods&quot;, overpasses.length());
1008   log_debug(defaultmethods)(&quot;Created %d default  methods&quot;, defaults.length());
1009 
1010   if (overpasses.length() &gt; 0) {
1011     switchover_constant_pool(&amp;bpool, klass, &amp;overpasses, CHECK);
1012     merge_in_new_methods(klass, &amp;overpasses, CHECK);
1013   }
1014   if (defaults.length() &gt; 0) {
1015     create_default_methods(klass, &amp;defaults, CHECK);
1016   }
1017 }
1018 
1019 static void create_default_methods(InstanceKlass* klass,
1020     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
1021 
1022   int new_size = new_methods-&gt;length();
1023   Array&lt;Method*&gt;* total_default_methods = MetadataFactory::new_array&lt;Method*&gt;(
1024       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
1025   for (int index = 0; index &lt; new_size; index++ ) {
1026     total_default_methods-&gt;at_put(index, new_methods-&gt;at(index));
1027   }
1028   Method::sort_methods(total_default_methods, /*set_idnums=*/false);
1029 
1030   klass-&gt;set_default_methods(total_default_methods);
1031 }
1032 
1033 static void sort_methods(GrowableArray&lt;Method*&gt;* methods) {
1034   // Note that this must sort using the same key as is used for sorting
1035   // methods in InstanceKlass.
1036   bool sorted = true;
1037   for (int i = methods-&gt;length() - 1; i &gt; 0; --i) {
1038     for (int j = 0; j &lt; i; ++j) {
1039       Method* m1 = methods-&gt;at(j);
1040       Method* m2 = methods-&gt;at(j + 1);
1041       if ((uintptr_t)m1-&gt;name() &gt; (uintptr_t)m2-&gt;name()) {
1042         methods-&gt;at_put(j, m2);
1043         methods-&gt;at_put(j + 1, m1);
1044         sorted = false;
1045       }
1046     }
1047     if (sorted) break;
1048     sorted = true;
1049   }
1050 #ifdef ASSERT
1051   uintptr_t prev = 0;
1052   for (int i = 0; i &lt; methods-&gt;length(); ++i) {
1053     Method* mh = methods-&gt;at(i);
1054     uintptr_t nv = (uintptr_t)mh-&gt;name();
1055     assert(nv &gt;= prev, &quot;Incorrect overpass method ordering&quot;);
1056     prev = nv;
1057   }
1058 #endif
1059 }
1060 
1061 static void merge_in_new_methods(InstanceKlass* klass,
1062     GrowableArray&lt;Method*&gt;* new_methods, TRAPS) {
1063 
1064   enum { ANNOTATIONS, PARAMETERS, DEFAULTS, NUM_ARRAYS };
1065 
1066   Array&lt;Method*&gt;* original_methods = klass-&gt;methods();
1067   Array&lt;int&gt;* original_ordering = klass-&gt;method_ordering();
1068   Array&lt;int&gt;* merged_ordering = Universe::the_empty_int_array();
1069 
1070   int new_size = klass-&gt;methods()-&gt;length() + new_methods-&gt;length();
1071 
1072   Array&lt;Method*&gt;* merged_methods = MetadataFactory::new_array&lt;Method*&gt;(
1073       klass-&gt;class_loader_data(), new_size, NULL, CHECK);
1074 
1075   // original_ordering might be empty if this class has no methods of its own
1076   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
1077     merged_ordering = MetadataFactory::new_array&lt;int&gt;(
1078         klass-&gt;class_loader_data(), new_size, CHECK);
1079   }
1080   int method_order_index = klass-&gt;methods()-&gt;length();
1081 
1082   sort_methods(new_methods);
1083 
1084   // Perform grand merge of existing methods and new methods
1085   int orig_idx = 0;
1086   int new_idx = 0;
1087 
1088   for (int i = 0; i &lt; new_size; ++i) {
1089     Method* orig_method = NULL;
1090     Method* new_method = NULL;
1091     if (orig_idx &lt; original_methods-&gt;length()) {
1092       orig_method = original_methods-&gt;at(orig_idx);
1093     }
1094     if (new_idx &lt; new_methods-&gt;length()) {
1095       new_method = new_methods-&gt;at(new_idx);
1096     }
1097 
1098     if (orig_method != NULL &amp;&amp;
1099         (new_method == NULL || orig_method-&gt;name() &lt; new_method-&gt;name())) {
1100       merged_methods-&gt;at_put(i, orig_method);
1101       original_methods-&gt;at_put(orig_idx, NULL);
1102       if (merged_ordering-&gt;length() &gt; 0) {
1103         assert(original_ordering != NULL &amp;&amp; original_ordering-&gt;length() &gt; 0,
1104                &quot;should have original order information for this method&quot;);
1105         merged_ordering-&gt;at_put(i, original_ordering-&gt;at(orig_idx));
1106       }
1107       ++orig_idx;
1108     } else {
1109       merged_methods-&gt;at_put(i, new_method);
1110       if (merged_ordering-&gt;length() &gt; 0) {
1111         merged_ordering-&gt;at_put(i, method_order_index++);
1112       }
1113       ++new_idx;
1114     }
1115     // update idnum for new location
1116     merged_methods-&gt;at(i)-&gt;set_method_idnum(i);
1117     merged_methods-&gt;at(i)-&gt;set_orig_method_idnum(i);
1118   }
1119 
1120   // Verify correct order
1121 #ifdef ASSERT
1122   uintptr_t prev = 0;
1123   for (int i = 0; i &lt; merged_methods-&gt;length(); ++i) {
1124     Method* mo = merged_methods-&gt;at(i);
1125     uintptr_t nv = (uintptr_t)mo-&gt;name();
1126     assert(nv &gt;= prev, &quot;Incorrect method ordering&quot;);
1127     prev = nv;
1128   }
1129 #endif
1130 
1131   // Replace klass methods with new merged lists
1132   klass-&gt;set_methods(merged_methods);
1133   klass-&gt;set_initial_method_idnum(new_size);
1134   klass-&gt;set_method_ordering(merged_ordering);
1135 
1136   // Free metadata
1137   ClassLoaderData* cld = klass-&gt;class_loader_data();
1138   if (original_methods-&gt;length() &gt; 0) {
1139     MetadataFactory::free_array(cld, original_methods);
1140   }
1141   if (original_ordering != NULL &amp;&amp; original_ordering-&gt;length() &gt; 0) {
1142     MetadataFactory::free_array(cld, original_ordering);
1143   }
1144 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>