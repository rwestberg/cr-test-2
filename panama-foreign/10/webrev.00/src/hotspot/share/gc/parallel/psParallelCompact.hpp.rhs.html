<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psParallelCompact.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  26 #define SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
  27 
  28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
  29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
  30 #include &quot;gc/parallel/parMarkBitMap.hpp&quot;
  31 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.hpp&quot;
  33 #include &quot;gc/shared/collectorCounters.hpp&quot;
  34 #include &quot;oops/oop.hpp&quot;
  35 #include &quot;runtime/atomic.hpp&quot;
  36 #include &quot;runtime/orderAccess.hpp&quot;
  37 
  38 class ParallelScavengeHeap;
  39 class PSAdaptiveSizePolicy;
  40 class PSYoungGen;
  41 class PSOldGen;
  42 class ParCompactionManager;
<a name="1" id="anc1"></a>
  43 class PSParallelCompact;
<a name="2" id="anc2"></a>
  44 class MoveAndUpdateClosure;
  45 class RefProcTaskExecutor;
  46 class ParallelOldTracer;
  47 class STWGCTimer;
  48 
  49 // The SplitInfo class holds the information needed to &#39;split&#39; a source region
  50 // so that the live data can be copied to two destination *spaces*.  Normally,
  51 // all the live data in a region is copied to a single destination space (e.g.,
  52 // everything live in a region in eden is copied entirely into the old gen).
  53 // However, when the heap is nearly full, all the live data in eden may not fit
  54 // into the old gen.  Copying only some of the regions from eden to old gen
  55 // requires finding a region that does not contain a partial object (i.e., no
  56 // live object crosses the region boundary) somewhere near the last object that
  57 // does fit into the old gen.  Since it&#39;s not always possible to find such a
  58 // region, splitting is necessary for predictable behavior.
  59 //
  60 // A region is always split at the end of the partial object.  This avoids
  61 // additional tests when calculating the new location of a pointer, which is a
  62 // very hot code path.  The partial object and everything to its left will be
  63 // copied to another space (call it dest_space_1).  The live data to the right
  64 // of the partial object will be copied either within the space itself, or to a
  65 // different destination space (distinct from dest_space_1).
  66 //
  67 // Split points are identified during the summary phase, when region
  68 // destinations are computed:  data about the split, including the
  69 // partial_object_size, is recorded in a SplitInfo record and the
  70 // partial_object_size field in the summary data is set to zero.  The zeroing is
  71 // possible (and necessary) since the partial object will move to a different
  72 // destination space than anything to its right, thus the partial object should
  73 // not affect the locations of any objects to its right.
  74 //
  75 // The recorded data is used during the compaction phase, but only rarely:  when
  76 // the partial object on the split region will be copied across a destination
  77 // region boundary.  This test is made once each time a region is filled, and is
  78 // a simple address comparison, so the overhead is negligible (see
  79 // PSParallelCompact::first_src_addr()).
  80 //
  81 // Notes:
  82 //
  83 // Only regions with partial objects are split; a region without a partial
  84 // object does not need any extra bookkeeping.
  85 //
  86 // At most one region is split per space, so the amount of data required is
  87 // constant.
  88 //
  89 // A region is split only when the destination space would overflow.  Once that
  90 // happens, the destination space is abandoned and no other data (even from
  91 // other source spaces) is targeted to that destination space.  Abandoning the
  92 // destination space may leave a somewhat large unused area at the end, if a
  93 // large object caused the overflow.
  94 //
  95 // Future work:
  96 //
  97 // More bookkeeping would be required to continue to use the destination space.
  98 // The most general solution would allow data from regions in two different
  99 // source spaces to be &quot;joined&quot; in a single destination region.  At the very
 100 // least, additional code would be required in next_src_region() to detect the
 101 // join and skip to an out-of-order source region.  If the join region was also
 102 // the last destination region to which a split region was copied (the most
 103 // likely case), then additional work would be needed to get fill_region() to
 104 // stop iteration and switch to a new source region at the right point.  Basic
 105 // idea would be to use a fake value for the top of the source space.  It is
 106 // doable, if a bit tricky.
 107 //
 108 // A simpler (but less general) solution would fill the remainder of the
 109 // destination region with a dummy object and continue filling the next
 110 // destination region.
 111 
 112 class SplitInfo
 113 {
 114 public:
 115   // Return true if this split info is valid (i.e., if a split has been
 116   // recorded).  The very first region cannot have a partial object and thus is
 117   // never split, so 0 is the &#39;invalid&#39; value.
 118   bool is_valid() const { return _src_region_idx &gt; 0; }
 119 
 120   // Return true if this split holds data for the specified source region.
 121   inline bool is_split(size_t source_region) const;
 122 
 123   // The index of the split region, the size of the partial object on that
 124   // region and the destination of the partial object.
 125   size_t    src_region_idx() const   { return _src_region_idx; }
 126   size_t    partial_obj_size() const { return _partial_obj_size; }
 127   HeapWord* destination() const      { return _destination; }
 128 
 129   // The destination count of the partial object referenced by this split
 130   // (either 1 or 2).  This must be added to the destination count of the
 131   // remainder of the source region.
 132   unsigned int destination_count() const { return _destination_count; }
 133 
 134   // If a word within the partial object will be written to the first word of a
 135   // destination region, this is the address of the destination region;
 136   // otherwise this is NULL.
 137   HeapWord* dest_region_addr() const     { return _dest_region_addr; }
 138 
 139   // If a word within the partial object will be written to the first word of a
 140   // destination region, this is the address of that word within the partial
 141   // object; otherwise this is NULL.
 142   HeapWord* first_src_addr() const       { return _first_src_addr; }
 143 
 144   // Record the data necessary to split the region src_region_idx.
 145   void record(size_t src_region_idx, size_t partial_obj_size,
 146               HeapWord* destination);
 147 
 148   void clear();
 149 
 150   DEBUG_ONLY(void verify_clear();)
 151 
 152 private:
 153   size_t       _src_region_idx;
 154   size_t       _partial_obj_size;
 155   HeapWord*    _destination;
 156   unsigned int _destination_count;
 157   HeapWord*    _dest_region_addr;
 158   HeapWord*    _first_src_addr;
 159 };
 160 
 161 inline bool SplitInfo::is_split(size_t region_idx) const
 162 {
 163   return _src_region_idx == region_idx &amp;&amp; is_valid();
 164 }
 165 
 166 class SpaceInfo
 167 {
 168  public:
 169   MutableSpace* space() const { return _space; }
 170 
 171   // Where the free space will start after the collection.  Valid only after the
 172   // summary phase completes.
 173   HeapWord* new_top() const { return _new_top; }
 174 
 175   // Allows new_top to be set.
 176   HeapWord** new_top_addr() { return &amp;_new_top; }
 177 
 178   // Where the smallest allowable dense prefix ends (used only for perm gen).
 179   HeapWord* min_dense_prefix() const { return _min_dense_prefix; }
 180 
 181   // Where the dense prefix ends, or the compacted region begins.
 182   HeapWord* dense_prefix() const { return _dense_prefix; }
 183 
 184   // The start array for the (generation containing the) space, or NULL if there
 185   // is no start array.
 186   ObjectStartArray* start_array() const { return _start_array; }
 187 
 188   SplitInfo&amp; split_info() { return _split_info; }
 189 
 190   void set_space(MutableSpace* s)           { _space = s; }
 191   void set_new_top(HeapWord* addr)          { _new_top = addr; }
 192   void set_min_dense_prefix(HeapWord* addr) { _min_dense_prefix = addr; }
 193   void set_dense_prefix(HeapWord* addr)     { _dense_prefix = addr; }
 194   void set_start_array(ObjectStartArray* s) { _start_array = s; }
 195 
 196   void publish_new_top() const              { _space-&gt;set_top(_new_top); }
 197 
 198  private:
 199   MutableSpace*     _space;
 200   HeapWord*         _new_top;
 201   HeapWord*         _min_dense_prefix;
 202   HeapWord*         _dense_prefix;
 203   ObjectStartArray* _start_array;
 204   SplitInfo         _split_info;
 205 };
 206 
 207 class ParallelCompactData
 208 {
 209 public:
 210   // Sizes are in HeapWords, unless indicated otherwise.
 211   static const size_t Log2RegionSize;
 212   static const size_t RegionSize;
 213   static const size_t RegionSizeBytes;
 214 
 215   // Mask for the bits in a size_t to get an offset within a region.
 216   static const size_t RegionSizeOffsetMask;
 217   // Mask for the bits in a pointer to get an offset within a region.
 218   static const size_t RegionAddrOffsetMask;
 219   // Mask for the bits in a pointer to get the address of the start of a region.
 220   static const size_t RegionAddrMask;
 221 
 222   static const size_t Log2BlockSize;
 223   static const size_t BlockSize;
 224   static const size_t BlockSizeBytes;
 225 
 226   static const size_t BlockSizeOffsetMask;
 227   static const size_t BlockAddrOffsetMask;
 228   static const size_t BlockAddrMask;
 229 
 230   static const size_t BlocksPerRegion;
 231   static const size_t Log2BlocksPerRegion;
 232 
 233   class RegionData
 234   {
 235   public:
 236     // Destination address of the region.
 237     HeapWord* destination() const { return _destination; }
 238 
 239     // The first region containing data destined for this region.
 240     size_t source_region() const { return _source_region; }
 241 
 242     // Reuse _source_region to store the corresponding shadow region index
 243     size_t shadow_region() const { return _source_region; }
 244 
 245     // The object (if any) starting in this region and ending in a different
 246     // region that could not be updated during the main (parallel) compaction
 247     // phase.  This is different from _partial_obj_addr, which is an object that
 248     // extends onto a source region.  However, the two uses do not overlap in
 249     // time, so the same field is used to save space.
 250     HeapWord* deferred_obj_addr() const { return _partial_obj_addr; }
 251 
 252     // The starting address of the partial object extending onto the region.
 253     HeapWord* partial_obj_addr() const { return _partial_obj_addr; }
 254 
 255     // Size of the partial object extending onto the region (words).
 256     size_t partial_obj_size() const { return _partial_obj_size; }
 257 
 258     // Size of live data that lies within this region due to objects that start
 259     // in this region (words).  This does not include the partial object
 260     // extending onto the region (if any), or the part of an object that extends
 261     // onto the next region (if any).
 262     size_t live_obj_size() const { return _dc_and_los &amp; los_mask; }
 263 
 264     // Total live data that lies within the region (words).
 265     size_t data_size() const { return partial_obj_size() + live_obj_size(); }
 266 
 267     // The destination_count is the number of other regions to which data from
 268     // this region will be copied.  At the end of the summary phase, the valid
 269     // values of destination_count are
 270     //
 271     // 0 - data from the region will be compacted completely into itself, or the
 272     //     region is empty.  The region can be claimed and then filled.
 273     // 1 - data from the region will be compacted into 1 other region; some
 274     //     data from the region may also be compacted into the region itself.
 275     // 2 - data from the region will be copied to 2 other regions.
 276     //
 277     // During compaction as regions are emptied, the destination_count is
 278     // decremented (atomically) and when it reaches 0, it can be claimed and
 279     // then filled.
 280     //
 281     // A region is claimed for processing by atomically changing the
 282     // destination_count to the claimed value (dc_claimed).  After a region has
 283     // been filled, the destination_count should be set to the completed value
 284     // (dc_completed).
 285     inline uint destination_count() const;
 286     inline uint destination_count_raw() const;
 287 
 288     // Whether the block table for this region has been filled.
 289     inline bool blocks_filled() const;
 290 
 291     // Number of times the block table was filled.
 292     DEBUG_ONLY(inline size_t blocks_filled_count() const;)
 293 
 294     // The location of the java heap data that corresponds to this region.
 295     inline HeapWord* data_location() const;
 296 
 297     // The highest address referenced by objects in this region.
 298     inline HeapWord* highest_ref() const;
 299 
 300     // Whether this region is available to be claimed, has been claimed, or has
 301     // been completed.
 302     //
 303     // Minor subtlety:  claimed() returns true if the region is marked
 304     // completed(), which is desirable since a region must be claimed before it
 305     // can be completed.
 306     bool available() const { return _dc_and_los &lt; dc_one; }
 307     bool claimed()   const { return _dc_and_los &gt;= dc_claimed; }
 308     bool completed() const { return _dc_and_los &gt;= dc_completed; }
 309 
 310     // These are not atomic.
 311     void set_destination(HeapWord* addr)       { _destination = addr; }
 312     void set_source_region(size_t region)      { _source_region = region; }
 313     void set_shadow_region(size_t region)      { _source_region = region; }
 314     void set_deferred_obj_addr(HeapWord* addr) { _partial_obj_addr = addr; }
 315     void set_partial_obj_addr(HeapWord* addr)  { _partial_obj_addr = addr; }
 316     void set_partial_obj_size(size_t words)    {
 317       _partial_obj_size = (region_sz_t) words;
 318     }
 319     inline void set_blocks_filled();
 320 
 321     inline void set_destination_count(uint count);
 322     inline void set_live_obj_size(size_t words);
 323     inline void set_data_location(HeapWord* addr);
 324     inline void set_completed();
 325     inline bool claim_unsafe();
 326 
 327     // These are atomic.
 328     inline void add_live_obj(size_t words);
 329     inline void set_highest_ref(HeapWord* addr);
 330     inline void decrement_destination_count();
 331     inline bool claim();
 332 
 333     // Possible values of _shadow_state, and transition is as follows
 334     // Normal Path:
 335     // UnusedRegion -&gt; mark_normal() -&gt; NormalRegion
 336     // Shadow Path:
 337     // UnusedRegion -&gt; mark_shadow() -&gt; ShadowRegion -&gt;
 338     // mark_filled() -&gt; FilledShadow -&gt; mark_copied() -&gt; CopiedShadow
 339     static const int UnusedRegion = 0; // The region is not collected yet
 340     static const int ShadowRegion = 1; // Stolen by an idle thread, and a shadow region is created for it
 341     static const int FilledShadow = 2; // Its shadow region has been filled and ready to be copied back
 342     static const int CopiedShadow = 3; // The data of the shadow region has been copied back
 343     static const int NormalRegion = 4; // The region will be collected by the original parallel algorithm
 344 
 345     // Mark the current region as normal or shadow to enter different processing paths
 346     inline bool mark_normal();
 347     inline bool mark_shadow();
 348     // Mark the shadow region as filled and ready to be copied back
 349     inline void mark_filled();
 350     // Mark the shadow region as copied back to avoid double copying.
 351     inline bool mark_copied();
 352     // Special case: see the comment in PSParallelCompact::fill_and_update_shadow_region.
 353     // Return to the normal path here
 354     inline void shadow_to_normal();
 355 
 356 
 357     int shadow_state() { return _shadow_state; }
 358 
 359   private:
 360     // The type used to represent object sizes within a region.
 361     typedef uint region_sz_t;
 362 
 363     // Constants for manipulating the _dc_and_los field, which holds both the
 364     // destination count and live obj size.  The live obj size lives at the
 365     // least significant end so no masking is necessary when adding.
 366     static const region_sz_t dc_shift;           // Shift amount.
 367     static const region_sz_t dc_mask;            // Mask for destination count.
 368     static const region_sz_t dc_one;             // 1, shifted appropriately.
 369     static const region_sz_t dc_claimed;         // Region has been claimed.
 370     static const region_sz_t dc_completed;       // Region has been completed.
 371     static const region_sz_t los_mask;           // Mask for live obj size.
 372 
 373     HeapWord*            _destination;
 374     size_t               _source_region;
 375     HeapWord*            _partial_obj_addr;
 376     region_sz_t          _partial_obj_size;
 377     region_sz_t volatile _dc_and_los;
 378     bool        volatile _blocks_filled;
 379     int         volatile _shadow_state;
 380 
 381 #ifdef ASSERT
 382     size_t               _blocks_filled_count;   // Number of block table fills.
 383 
 384     // These enable optimizations that are only partially implemented.  Use
 385     // debug builds to prevent the code fragments from breaking.
 386     HeapWord*            _data_location;
 387     HeapWord*            _highest_ref;
 388 #endif  // #ifdef ASSERT
 389 
 390 #ifdef ASSERT
 391    public:
 392     uint                 _pushed;   // 0 until region is pushed onto a stack
 393    private:
 394 #endif
 395   };
 396 
 397   // &quot;Blocks&quot; allow shorter sections of the bitmap to be searched.  Each Block
 398   // holds an offset, which is the amount of live data in the Region to the left
 399   // of the first live object that starts in the Block.
 400   class BlockData
 401   {
 402   public:
 403     typedef unsigned short int blk_ofs_t;
 404 
 405     blk_ofs_t offset() const    { return _offset; }
 406     void set_offset(size_t val) { _offset = (blk_ofs_t)val; }
 407 
 408   private:
 409     blk_ofs_t _offset;
 410   };
 411 
 412 public:
 413   ParallelCompactData();
 414   bool initialize(MemRegion covered_region);
 415 
 416   size_t region_count() const { return _region_count; }
 417   size_t reserved_byte_size() const { return _reserved_byte_size; }
 418 
 419   // Convert region indices to/from RegionData pointers.
 420   inline RegionData* region(size_t region_idx) const;
 421   inline size_t     region(const RegionData* const region_ptr) const;
 422 
 423   size_t block_count() const { return _block_count; }
 424   inline BlockData* block(size_t block_idx) const;
 425   inline size_t     block(const BlockData* block_ptr) const;
 426 
 427   void add_obj(HeapWord* addr, size_t len);
 428   void add_obj(oop p, size_t len) { add_obj(cast_from_oop&lt;HeapWord*&gt;(p), len); }
 429 
 430   // Fill in the regions covering [beg, end) so that no data moves; i.e., the
 431   // destination of region n is simply the start of region n.  The argument beg
 432   // must be region-aligned; end need not be.
 433   void summarize_dense_prefix(HeapWord* beg, HeapWord* end);
 434 
 435   HeapWord* summarize_split_space(size_t src_region, SplitInfo&amp; split_info,
 436                                   HeapWord* destination, HeapWord* target_end,
 437                                   HeapWord** target_next);
 438   bool summarize(SplitInfo&amp; split_info,
 439                  HeapWord* source_beg, HeapWord* source_end,
 440                  HeapWord** source_next,
 441                  HeapWord* target_beg, HeapWord* target_end,
 442                  HeapWord** target_next);
 443 
 444   void clear();
 445   void clear_range(size_t beg_region, size_t end_region);
 446   void clear_range(HeapWord* beg, HeapWord* end) {
 447     clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));
 448   }
 449 
 450   // Return the number of words between addr and the start of the region
 451   // containing addr.
 452   inline size_t     region_offset(const HeapWord* addr) const;
 453 
 454   // Convert addresses to/from a region index or region pointer.
 455   inline size_t     addr_to_region_idx(const HeapWord* addr) const;
 456   inline RegionData* addr_to_region_ptr(const HeapWord* addr) const;
 457   inline HeapWord*  region_to_addr(size_t region) const;
 458   inline HeapWord*  region_to_addr(size_t region, size_t offset) const;
 459   inline HeapWord*  region_to_addr(const RegionData* region) const;
 460 
 461   inline HeapWord*  region_align_down(HeapWord* addr) const;
 462   inline HeapWord*  region_align_up(HeapWord* addr) const;
 463   inline bool       is_region_aligned(HeapWord* addr) const;
 464 
 465   // Analogous to region_offset() for blocks.
 466   size_t     block_offset(const HeapWord* addr) const;
 467   size_t     addr_to_block_idx(const HeapWord* addr) const;
 468   size_t     addr_to_block_idx(const oop obj) const {
 469     return addr_to_block_idx(cast_from_oop&lt;HeapWord*&gt;(obj));
 470   }
 471   inline BlockData* addr_to_block_ptr(const HeapWord* addr) const;
 472   inline HeapWord*  block_to_addr(size_t block) const;
 473   inline size_t     region_to_block_idx(size_t region) const;
 474 
 475   inline HeapWord*  block_align_down(HeapWord* addr) const;
 476   inline HeapWord*  block_align_up(HeapWord* addr) const;
 477   inline bool       is_block_aligned(HeapWord* addr) const;
 478 
 479   // Return the address one past the end of the partial object.
 480   HeapWord* partial_obj_end(size_t region_idx) const;
 481 
 482   // Return the location of the object after compaction.
 483   HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm);
 484 
 485   HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) {
 486     return calc_new_pointer(cast_from_oop&lt;HeapWord*&gt;(p), cm);
 487   }
 488 
 489 #ifdef  ASSERT
 490   void verify_clear(const PSVirtualSpace* vspace);
 491   void verify_clear();
 492 #endif  // #ifdef ASSERT
 493 
 494 private:
 495   bool initialize_block_data();
 496   bool initialize_region_data(size_t region_size);
 497   PSVirtualSpace* create_vspace(size_t count, size_t element_size);
 498 
 499 private:
 500   HeapWord*       _region_start;
 501 #ifdef  ASSERT
 502   HeapWord*       _region_end;
 503 #endif  // #ifdef ASSERT
 504 
 505   PSVirtualSpace* _region_vspace;
 506   size_t          _reserved_byte_size;
 507   RegionData*     _region_data;
 508   size_t          _region_count;
 509 
 510   PSVirtualSpace* _block_vspace;
 511   BlockData*      _block_data;
 512   size_t          _block_count;
 513 };
 514 
 515 inline uint
 516 ParallelCompactData::RegionData::destination_count_raw() const
 517 {
 518   return _dc_and_los &amp; dc_mask;
 519 }
 520 
 521 inline uint
 522 ParallelCompactData::RegionData::destination_count() const
 523 {
 524   return destination_count_raw() &gt;&gt; dc_shift;
 525 }
 526 
 527 inline bool
 528 ParallelCompactData::RegionData::blocks_filled() const
 529 {
 530   bool result = _blocks_filled;
 531   OrderAccess::acquire();
 532   return result;
 533 }
 534 
 535 #ifdef ASSERT
 536 inline size_t
 537 ParallelCompactData::RegionData::blocks_filled_count() const
 538 {
 539   return _blocks_filled_count;
 540 }
 541 #endif // #ifdef ASSERT
 542 
 543 inline void
 544 ParallelCompactData::RegionData::set_blocks_filled()
 545 {
 546   OrderAccess::release();
 547   _blocks_filled = true;
 548   // Debug builds count the number of times the table was filled.
 549   DEBUG_ONLY(Atomic::inc(&amp;_blocks_filled_count));
 550 }
 551 
 552 inline void
 553 ParallelCompactData::RegionData::set_destination_count(uint count)
 554 {
 555   assert(count &lt;= (dc_completed &gt;&gt; dc_shift), &quot;count too large&quot;);
 556   const region_sz_t live_sz = (region_sz_t) live_obj_size();
 557   _dc_and_los = (count &lt;&lt; dc_shift) | live_sz;
 558 }
 559 
 560 inline void ParallelCompactData::RegionData::set_live_obj_size(size_t words)
 561 {
 562   assert(words &lt;= los_mask, &quot;would overflow&quot;);
 563   _dc_and_los = destination_count_raw() | (region_sz_t)words;
 564 }
 565 
 566 inline void ParallelCompactData::RegionData::decrement_destination_count()
 567 {
 568   assert(_dc_and_los &lt; dc_claimed, &quot;already claimed&quot;);
 569   assert(_dc_and_los &gt;= dc_one, &quot;count would go negative&quot;);
 570   Atomic::add(&amp;_dc_and_los, dc_mask);
 571 }
 572 
 573 inline HeapWord* ParallelCompactData::RegionData::data_location() const
 574 {
 575   DEBUG_ONLY(return _data_location;)
 576   NOT_DEBUG(return NULL;)
 577 }
 578 
 579 inline HeapWord* ParallelCompactData::RegionData::highest_ref() const
 580 {
 581   DEBUG_ONLY(return _highest_ref;)
 582   NOT_DEBUG(return NULL;)
 583 }
 584 
 585 inline void ParallelCompactData::RegionData::set_data_location(HeapWord* addr)
 586 {
 587   DEBUG_ONLY(_data_location = addr;)
 588 }
 589 
 590 inline void ParallelCompactData::RegionData::set_completed()
 591 {
 592   assert(claimed(), &quot;must be claimed first&quot;);
 593   _dc_and_los = dc_completed | (region_sz_t) live_obj_size();
 594 }
 595 
 596 // MT-unsafe claiming of a region.  Should only be used during single threaded
 597 // execution.
 598 inline bool ParallelCompactData::RegionData::claim_unsafe()
 599 {
 600   if (available()) {
 601     _dc_and_los |= dc_claimed;
 602     return true;
 603   }
 604   return false;
 605 }
 606 
 607 inline void ParallelCompactData::RegionData::add_live_obj(size_t words)
 608 {
 609   assert(words &lt;= (size_t)los_mask - live_obj_size(), &quot;overflow&quot;);
 610   Atomic::add(&amp;_dc_and_los, static_cast&lt;region_sz_t&gt;(words));
 611 }
 612 
 613 inline void ParallelCompactData::RegionData::set_highest_ref(HeapWord* addr)
 614 {
 615 #ifdef ASSERT
 616   HeapWord* tmp = _highest_ref;
 617   while (addr &gt; tmp) {
 618     tmp = Atomic::cmpxchg(&amp;_highest_ref, tmp, addr);
 619   }
 620 #endif  // #ifdef ASSERT
 621 }
 622 
 623 inline bool ParallelCompactData::RegionData::claim()
 624 {
 625   const region_sz_t los = static_cast&lt;region_sz_t&gt;(live_obj_size());
 626   const region_sz_t old = Atomic::cmpxchg(&amp;_dc_and_los, los, dc_claimed | los);
 627   return old == los;
 628 }
 629 
 630 inline bool ParallelCompactData::RegionData::mark_normal() {
 631   return Atomic::cmpxchg(&amp;_shadow_state, UnusedRegion, NormalRegion) == UnusedRegion;
 632 }
 633 
 634 inline bool ParallelCompactData::RegionData::mark_shadow() {
 635   if (_shadow_state != UnusedRegion) return false;
 636   return Atomic::cmpxchg(&amp;_shadow_state, UnusedRegion, ShadowRegion) == UnusedRegion;
 637 }
 638 
 639 inline void ParallelCompactData::RegionData::mark_filled() {
 640   int old = Atomic::cmpxchg(&amp;_shadow_state, ShadowRegion, FilledShadow);
 641   assert(old == ShadowRegion, &quot;Fail to mark the region as filled&quot;);
 642 }
 643 
 644 inline bool ParallelCompactData::RegionData::mark_copied() {
 645   return Atomic::cmpxchg(&amp;_shadow_state, FilledShadow, CopiedShadow) == FilledShadow;
 646 }
 647 
 648 void ParallelCompactData::RegionData::shadow_to_normal() {
 649   int old = Atomic::cmpxchg(&amp;_shadow_state, ShadowRegion, NormalRegion);
 650   assert(old == ShadowRegion, &quot;Fail to mark the region as finish&quot;);
 651 }
 652 
 653 inline ParallelCompactData::RegionData*
 654 ParallelCompactData::region(size_t region_idx) const
 655 {
 656   assert(region_idx &lt;= region_count(), &quot;bad arg&quot;);
 657   return _region_data + region_idx;
 658 }
 659 
 660 inline size_t
 661 ParallelCompactData::region(const RegionData* const region_ptr) const
 662 {
 663   assert(region_ptr &gt;= _region_data, &quot;bad arg&quot;);
 664   assert(region_ptr &lt;= _region_data + region_count(), &quot;bad arg&quot;);
 665   return pointer_delta(region_ptr, _region_data, sizeof(RegionData));
 666 }
 667 
 668 inline ParallelCompactData::BlockData*
 669 ParallelCompactData::block(size_t n) const {
 670   assert(n &lt; block_count(), &quot;bad arg&quot;);
 671   return _block_data + n;
 672 }
 673 
 674 inline size_t
 675 ParallelCompactData::region_offset(const HeapWord* addr) const
 676 {
 677   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 678   assert(addr &lt;= _region_end, &quot;bad addr&quot;);
 679   return (size_t(addr) &amp; RegionAddrOffsetMask) &gt;&gt; LogHeapWordSize;
 680 }
 681 
 682 inline size_t
 683 ParallelCompactData::addr_to_region_idx(const HeapWord* addr) const
 684 {
 685   assert(addr &gt;= _region_start, &quot;bad addr &quot; PTR_FORMAT &quot; _region_start &quot; PTR_FORMAT, p2i(addr), p2i(_region_start));
 686   assert(addr &lt;= _region_end, &quot;bad addr &quot; PTR_FORMAT &quot; _region_end &quot; PTR_FORMAT, p2i(addr), p2i(_region_end));
 687   return pointer_delta(addr, _region_start) &gt;&gt; Log2RegionSize;
 688 }
 689 
 690 inline ParallelCompactData::RegionData*
 691 ParallelCompactData::addr_to_region_ptr(const HeapWord* addr) const
 692 {
 693   return region(addr_to_region_idx(addr));
 694 }
 695 
 696 inline HeapWord*
 697 ParallelCompactData::region_to_addr(size_t region) const
 698 {
 699   assert(region &lt;= _region_count, &quot;region out of range&quot;);
 700   return _region_start + (region &lt;&lt; Log2RegionSize);
 701 }
 702 
 703 inline HeapWord*
 704 ParallelCompactData::region_to_addr(const RegionData* region) const
 705 {
 706   return region_to_addr(pointer_delta(region, _region_data,
 707                                       sizeof(RegionData)));
 708 }
 709 
 710 inline HeapWord*
 711 ParallelCompactData::region_to_addr(size_t region, size_t offset) const
 712 {
 713   assert(region &lt;= _region_count, &quot;region out of range&quot;);
 714   assert(offset &lt; RegionSize, &quot;offset too big&quot;);  // This may be too strict.
 715   return region_to_addr(region) + offset;
 716 }
 717 
 718 inline HeapWord*
 719 ParallelCompactData::region_align_down(HeapWord* addr) const
 720 {
 721   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 722   assert(addr &lt; _region_end + RegionSize, &quot;bad addr&quot;);
 723   return (HeapWord*)(size_t(addr) &amp; RegionAddrMask);
 724 }
 725 
 726 inline HeapWord*
 727 ParallelCompactData::region_align_up(HeapWord* addr) const
 728 {
 729   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 730   assert(addr &lt;= _region_end, &quot;bad addr&quot;);
 731   return region_align_down(addr + RegionSizeOffsetMask);
 732 }
 733 
 734 inline bool
 735 ParallelCompactData::is_region_aligned(HeapWord* addr) const
 736 {
 737   return region_offset(addr) == 0;
 738 }
 739 
 740 inline size_t
 741 ParallelCompactData::block_offset(const HeapWord* addr) const
 742 {
 743   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 744   assert(addr &lt;= _region_end, &quot;bad addr&quot;);
 745   return (size_t(addr) &amp; BlockAddrOffsetMask) &gt;&gt; LogHeapWordSize;
 746 }
 747 
 748 inline size_t
 749 ParallelCompactData::addr_to_block_idx(const HeapWord* addr) const
 750 {
 751   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 752   assert(addr &lt;= _region_end, &quot;bad addr&quot;);
 753   return pointer_delta(addr, _region_start) &gt;&gt; Log2BlockSize;
 754 }
 755 
 756 inline ParallelCompactData::BlockData*
 757 ParallelCompactData::addr_to_block_ptr(const HeapWord* addr) const
 758 {
 759   return block(addr_to_block_idx(addr));
 760 }
 761 
 762 inline HeapWord*
 763 ParallelCompactData::block_to_addr(size_t block) const
 764 {
 765   assert(block &lt; _block_count, &quot;block out of range&quot;);
 766   return _region_start + (block &lt;&lt; Log2BlockSize);
 767 }
 768 
 769 inline size_t
 770 ParallelCompactData::region_to_block_idx(size_t region) const
 771 {
 772   return region &lt;&lt; Log2BlocksPerRegion;
 773 }
 774 
 775 inline HeapWord*
 776 ParallelCompactData::block_align_down(HeapWord* addr) const
 777 {
 778   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 779   assert(addr &lt; _region_end + RegionSize, &quot;bad addr&quot;);
 780   return (HeapWord*)(size_t(addr) &amp; BlockAddrMask);
 781 }
 782 
 783 inline HeapWord*
 784 ParallelCompactData::block_align_up(HeapWord* addr) const
 785 {
 786   assert(addr &gt;= _region_start, &quot;bad addr&quot;);
 787   assert(addr &lt;= _region_end, &quot;bad addr&quot;);
 788   return block_align_down(addr + BlockSizeOffsetMask);
 789 }
 790 
 791 inline bool
 792 ParallelCompactData::is_block_aligned(HeapWord* addr) const
 793 {
 794   return block_offset(addr) == 0;
 795 }
 796 
 797 // Abstract closure for use with ParMarkBitMap::iterate(), which will invoke the
 798 // do_addr() method.
 799 //
 800 // The closure is initialized with the number of heap words to process
 801 // (words_remaining()), and becomes &#39;full&#39; when it reaches 0.  The do_addr()
 802 // methods in subclasses should update the total as words are processed.  Since
 803 // only one subclass actually uses this mechanism to terminate iteration, the
 804 // default initial value is &gt; 0.  The implementation is here and not in the
 805 // single subclass that uses it to avoid making is_full() virtual, and thus
 806 // adding a virtual call per live object.
 807 
 808 class ParMarkBitMapClosure: public StackObj {
 809  public:
 810   typedef ParMarkBitMap::idx_t idx_t;
 811   typedef ParMarkBitMap::IterationStatus IterationStatus;
 812 
 813  public:
 814   inline ParMarkBitMapClosure(ParMarkBitMap* mbm, ParCompactionManager* cm,
 815                               size_t words = max_uintx);
 816 
 817   inline ParCompactionManager* compaction_manager() const;
 818   inline ParMarkBitMap*        bitmap() const;
 819   inline size_t                words_remaining() const;
 820   inline bool                  is_full() const;
 821   inline HeapWord*             source() const;
 822 
 823   inline void                  set_source(HeapWord* addr);
 824 
 825   virtual IterationStatus do_addr(HeapWord* addr, size_t words) = 0;
 826 
 827  protected:
 828   inline void decrement_words_remaining(size_t words);
 829 
 830  private:
 831   ParMarkBitMap* const        _bitmap;
 832   ParCompactionManager* const _compaction_manager;
 833   DEBUG_ONLY(const size_t     _initial_words_remaining;) // Useful in debugger.
 834   size_t                      _words_remaining; // Words left to copy.
 835 
 836  protected:
 837   HeapWord*                   _source;          // Next addr that would be read.
 838 };
 839 
 840 inline
 841 ParMarkBitMapClosure::ParMarkBitMapClosure(ParMarkBitMap* bitmap,
 842                                            ParCompactionManager* cm,
 843                                            size_t words):
 844   _bitmap(bitmap), _compaction_manager(cm)
 845 #ifdef  ASSERT
 846   , _initial_words_remaining(words)
 847 #endif
 848 {
 849   _words_remaining = words;
 850   _source = NULL;
 851 }
 852 
 853 inline ParCompactionManager* ParMarkBitMapClosure::compaction_manager() const {
 854   return _compaction_manager;
 855 }
 856 
 857 inline ParMarkBitMap* ParMarkBitMapClosure::bitmap() const {
 858   return _bitmap;
 859 }
 860 
 861 inline size_t ParMarkBitMapClosure::words_remaining() const {
 862   return _words_remaining;
 863 }
 864 
 865 inline bool ParMarkBitMapClosure::is_full() const {
 866   return words_remaining() == 0;
 867 }
 868 
 869 inline HeapWord* ParMarkBitMapClosure::source() const {
 870   return _source;
 871 }
 872 
 873 inline void ParMarkBitMapClosure::set_source(HeapWord* addr) {
 874   _source = addr;
 875 }
 876 
 877 inline void ParMarkBitMapClosure::decrement_words_remaining(size_t words) {
 878   assert(_words_remaining &gt;= words, &quot;processed too many words&quot;);
 879   _words_remaining -= words;
 880 }
 881 
 882 // The Parallel collector is a stop-the-world garbage collector that
 883 // does parts of the collection using parallel threads.  The collection includes
 884 // the tenured generation and the young generation.
 885 //
 886 // There are four phases of the collection.
 887 //
 888 //      - marking phase
 889 //      - summary phase
 890 //      - compacting phase
 891 //      - clean up phase
 892 //
 893 // Roughly speaking these phases correspond, respectively, to
 894 //      - mark all the live objects
 895 //      - calculate the destination of each object at the end of the collection
 896 //      - move the objects to their destination
 897 //      - update some references and reinitialize some variables
 898 //
 899 // These three phases are invoked in PSParallelCompact::invoke_no_policy().  The
 900 // marking phase is implemented in PSParallelCompact::marking_phase() and does a
 901 // complete marking of the heap.  The summary phase is implemented in
 902 // PSParallelCompact::summary_phase().  The move and update phase is implemented
 903 // in PSParallelCompact::compact().
 904 //
 905 // A space that is being collected is divided into regions and with each region
 906 // is associated an object of type ParallelCompactData.  Each region is of a
 907 // fixed size and typically will contain more than 1 object and may have parts
 908 // of objects at the front and back of the region.
 909 //
 910 // region            -----+---------------------+----------
 911 // objects covered   [ AAA  )[ BBB )[ CCC   )[ DDD     )
 912 //
 913 // The marking phase does a complete marking of all live objects in the heap.
 914 // The marking also compiles the size of the data for all live objects covered
 915 // by the region.  This size includes the part of any live object spanning onto
 916 // the region (part of AAA if it is live) from the front, all live objects
 917 // contained in the region (BBB and/or CCC if they are live), and the part of
 918 // any live objects covered by the region that extends off the region (part of
 919 // DDD if it is live).  The marking phase uses multiple GC threads and marking
 920 // is done in a bit array of type ParMarkBitMap.  The marking of the bit map is
 921 // done atomically as is the accumulation of the size of the live objects
 922 // covered by a region.
 923 //
 924 // The summary phase calculates the total live data to the left of each region
 925 // XXX.  Based on that total and the bottom of the space, it can calculate the
 926 // starting location of the live data in XXX.  The summary phase calculates for
 927 // each region XXX quantities such as
 928 //
 929 //      - the amount of live data at the beginning of a region from an object
 930 //        entering the region.
 931 //      - the location of the first live data on the region
 932 //      - a count of the number of regions receiving live data from XXX.
 933 //
 934 // See ParallelCompactData for precise details.  The summary phase also
 935 // calculates the dense prefix for the compaction.  The dense prefix is a
 936 // portion at the beginning of the space that is not moved.  The objects in the
 937 // dense prefix do need to have their object references updated.  See method
 938 // summarize_dense_prefix().
 939 //
 940 // The summary phase is done using 1 GC thread.
 941 //
 942 // The compaction phase moves objects to their new location and updates all
 943 // references in the object.
 944 //
 945 // A current exception is that objects that cross a region boundary are moved
 946 // but do not have their references updated.  References are not updated because
 947 // it cannot easily be determined if the klass pointer KKK for the object AAA
 948 // has been updated.  KKK likely resides in a region to the left of the region
 949 // containing AAA.  These AAA&#39;s have there references updated at the end in a
 950 // clean up phase.  See the method PSParallelCompact::update_deferred_objects().
 951 // An alternate strategy is being investigated for this deferral of updating.
 952 //
 953 // Compaction is done on a region basis.  A region that is ready to be filled is
 954 // put on a ready list and GC threads take region off the list and fill them.  A
 955 // region is ready to be filled if it empty of live objects.  Such a region may
 956 // have been initially empty (only contained dead objects) or may have had all
 957 // its live objects copied out already.  A region that compacts into itself is
 958 // also ready for filling.  The ready list is initially filled with empty
 959 // regions and regions compacting into themselves.  There is always at least 1
 960 // region that can be put on the ready list.  The regions are atomically added
 961 // and removed from the ready list.
 962 
 963 class TaskQueue;
 964 
 965 class PSParallelCompact : AllStatic {
 966  public:
 967   // Convenient access to type names.
 968   typedef ParMarkBitMap::idx_t idx_t;
 969   typedef ParallelCompactData::RegionData RegionData;
 970   typedef ParallelCompactData::BlockData BlockData;
 971 
 972   typedef enum {
 973     old_space_id, eden_space_id,
 974     from_space_id, to_space_id, last_space_id
 975   } SpaceId;
 976 
 977   struct UpdateDensePrefixTask : public CHeapObj&lt;mtGC&gt; {
 978     SpaceId _space_id;
 979     size_t _region_index_start;
 980     size_t _region_index_end;
 981 
 982     UpdateDensePrefixTask() :
 983         _space_id(SpaceId(0)),
 984         _region_index_start(0),
 985         _region_index_end(0) {}
 986 
 987     UpdateDensePrefixTask(SpaceId space_id,
 988                           size_t region_index_start,
 989                           size_t region_index_end) :
 990         _space_id(space_id),
 991         _region_index_start(region_index_start),
 992         _region_index_end(region_index_end) {}
 993   };
 994 
 995  public:
 996   // Inline closure decls
 997   //
 998   class IsAliveClosure: public BoolObjectClosure {
 999    public:
1000     virtual bool do_object_b(oop p);
1001   };
1002 
1003   friend class RefProcTaskProxy;
1004   friend class PSParallelCompactTest;
1005 
1006  private:
1007   static STWGCTimer           _gc_timer;
1008   static ParallelOldTracer    _gc_tracer;
1009   static elapsedTimer         _accumulated_time;
1010   static unsigned int         _total_invocations;
1011   static unsigned int         _maximum_compaction_gc_num;
1012   static jlong                _time_of_last_gc;   // ms
1013   static CollectorCounters*   _counters;
1014   static ParMarkBitMap        _mark_bitmap;
1015   static ParallelCompactData  _summary_data;
1016   static IsAliveClosure       _is_alive_closure;
1017   static SpaceInfo            _space_info[last_space_id];
1018 
1019   // Reference processing (used in ...follow_contents)
1020   static SpanSubjectToDiscoveryClosure  _span_based_discoverer;
1021   static ReferenceProcessor*  _ref_processor;
1022 
1023   // Values computed at initialization and used by dead_wood_limiter().
1024   static double _dwl_mean;
1025   static double _dwl_std_dev;
1026   static double _dwl_first_term;
1027   static double _dwl_adjustment;
1028 #ifdef  ASSERT
1029   static bool   _dwl_initialized;
1030 #endif  // #ifdef ASSERT
1031 
1032  public:
1033   static ParallelOldTracer* gc_tracer() { return &amp;_gc_tracer; }
1034 
1035  private:
1036 
1037   static void initialize_space_info();
1038 
1039   // Clear the marking bitmap and summary data that cover the specified space.
1040   static void clear_data_covering_space(SpaceId id);
1041 
1042   static void pre_compact();
1043   static void post_compact();
1044 
1045   // Mark live objects
1046   static void marking_phase(ParCompactionManager* cm,
1047                             bool maximum_heap_compaction,
1048                             ParallelOldTracer *gc_tracer);
1049 
1050   // Compute the dense prefix for the designated space.  This is an experimental
1051   // implementation currently not used in production.
1052   static HeapWord* compute_dense_prefix_via_density(const SpaceId id,
1053                                                     bool maximum_compaction);
1054 
1055   // Methods used to compute the dense prefix.
1056 
1057   // Compute the value of the normal distribution at x = density.  The mean and
1058   // standard deviation are values saved by initialize_dead_wood_limiter().
1059   static inline double normal_distribution(double density);
1060 
1061   // Initialize the static vars used by dead_wood_limiter().
1062   static void initialize_dead_wood_limiter();
1063 
1064   // Return the percentage of space that can be treated as &quot;dead wood&quot; (i.e.,
1065   // not reclaimed).
1066   static double dead_wood_limiter(double density, size_t min_percent);
1067 
1068   // Find the first (left-most) region in the range [beg, end) that has at least
1069   // dead_words of dead space to the left.  The argument beg must be the first
1070   // region in the space that is not completely live.
1071   static RegionData* dead_wood_limit_region(const RegionData* beg,
1072                                             const RegionData* end,
1073                                             size_t dead_words);
1074 
1075   // Return a pointer to the first region in the range [beg, end) that is not
1076   // completely full.
1077   static RegionData* first_dead_space_region(const RegionData* beg,
1078                                              const RegionData* end);
1079 
1080   // Return a value indicating the benefit or &#39;yield&#39; if the compacted region
1081   // were to start (or equivalently if the dense prefix were to end) at the
1082   // candidate region.  Higher values are better.
1083   //
1084   // The value is based on the amount of space reclaimed vs. the costs of (a)
1085   // updating references in the dense prefix plus (b) copying objects and
1086   // updating references in the compacted region.
1087   static inline double reclaimed_ratio(const RegionData* const candidate,
1088                                        HeapWord* const bottom,
1089                                        HeapWord* const top,
1090                                        HeapWord* const new_top);
1091 
1092   // Compute the dense prefix for the designated space.
1093   static HeapWord* compute_dense_prefix(const SpaceId id,
1094                                         bool maximum_compaction);
1095 
1096   // Return true if dead space crosses onto the specified Region; bit must be
1097   // the bit index corresponding to the first word of the Region.
1098   static inline bool dead_space_crosses_boundary(const RegionData* region,
1099                                                  idx_t bit);
1100 
1101   // Summary phase utility routine to fill dead space (if any) at the dense
1102   // prefix boundary.  Should only be called if the the dense prefix is
1103   // non-empty.
1104   static void fill_dense_prefix_end(SpaceId id);
1105 
1106   static void summarize_spaces_quick();
1107   static void summarize_space(SpaceId id, bool maximum_compaction);
1108   static void summary_phase(ParCompactionManager* cm, bool maximum_compaction);
1109 
1110   // Adjust addresses in roots.  Does not adjust addresses in heap.
1111   static void adjust_roots(ParCompactionManager* cm);
1112 
1113   DEBUG_ONLY(static void write_block_fill_histogram();)
1114 
1115   // Move objects to new locations.
1116   static void compact_perm(ParCompactionManager* cm);
1117   static void compact();
1118 
1119   // Add available regions to the stack and draining tasks to the task queue.
1120   static void prepare_region_draining_tasks(uint parallel_gc_threads);
1121 
1122   // Add dense prefix update tasks to the task queue.
1123   static void enqueue_dense_prefix_tasks(TaskQueue&amp; task_queue,
1124                                          uint parallel_gc_threads);
1125 
1126   // If objects are left in eden after a collection, try to move the boundary
1127   // and absorb them into the old gen.  Returns true if eden was emptied.
1128   static bool absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
1129                                          PSYoungGen* young_gen,
1130                                          PSOldGen* old_gen);
1131 
1132   // Reset time since last full gc
1133   static void reset_millis_since_last_gc();
1134 
1135 #ifndef PRODUCT
1136   // Print generic summary data
1137   static void print_generic_summary_data(ParallelCompactData&amp; summary_data,
1138                                          HeapWord* const beg_addr,
1139                                          HeapWord* const end_addr);
1140 #endif  // #ifndef PRODUCT
1141 
1142  public:
1143 
1144   PSParallelCompact();
1145 
1146   static void invoke(bool maximum_heap_compaction);
1147   static bool invoke_no_policy(bool maximum_heap_compaction);
1148 
1149   static void post_initialize();
1150   // Perform initialization for PSParallelCompact that requires
1151   // allocations.  This should be called during the VM initialization
1152   // at a pointer where it would be appropriate to return a JNI_ENOMEM
1153   // in the event of a failure.
1154   static bool initialize();
1155 
1156   // Closure accessors
1157   static BoolObjectClosure* is_alive_closure()     { return (BoolObjectClosure*)&amp;_is_alive_closure; }
1158 
1159   // Public accessors
1160   static elapsedTimer* accumulated_time() { return &amp;_accumulated_time; }
1161   static unsigned int total_invocations() { return _total_invocations; }
1162   static CollectorCounters* counters()    { return _counters; }
1163 
1164   // Marking support
1165   static inline bool mark_obj(oop obj);
1166   static inline bool is_marked(oop obj);
1167 
1168   template &lt;class T&gt; static inline void adjust_pointer(T* p, ParCompactionManager* cm);
1169 
1170   // Compaction support.
1171   // Return true if p is in the range [beg_addr, end_addr).
1172   static inline bool is_in(HeapWord* p, HeapWord* beg_addr, HeapWord* end_addr);
1173   static inline bool is_in(oop* p, HeapWord* beg_addr, HeapWord* end_addr);
1174 
1175   // Convenience wrappers for per-space data kept in _space_info.
1176   static inline MutableSpace*     space(SpaceId space_id);
1177   static inline HeapWord*         new_top(SpaceId space_id);
1178   static inline HeapWord*         dense_prefix(SpaceId space_id);
1179   static inline ObjectStartArray* start_array(SpaceId space_id);
1180 
1181   // Process the end of the given region range in the dense prefix.
1182   // This includes saving any object not updated.
1183   static void dense_prefix_regions_epilogue(ParCompactionManager* cm,
1184                                             size_t region_start_index,
1185                                             size_t region_end_index,
1186                                             idx_t exiting_object_offset,
1187                                             idx_t region_offset_start,
1188                                             idx_t region_offset_end);
1189 
1190   // Update a region in the dense prefix.  For each live object
1191   // in the region, update it&#39;s interior references.  For each
1192   // dead object, fill it with deadwood. Dead space at the end
1193   // of a region range will be filled to the start of the next
1194   // live object regardless of the region_index_end.  None of the
1195   // objects in the dense prefix move and dead space is dead
1196   // (holds only dead objects that don&#39;t need any processing), so
1197   // dead space can be filled in any order.
1198   static void update_and_deadwood_in_dense_prefix(ParCompactionManager* cm,
1199                                                   SpaceId space_id,
1200                                                   size_t region_index_start,
1201                                                   size_t region_index_end);
1202 
1203   // Return the address of the count + 1st live word in the range [beg, end).
1204   static HeapWord* skip_live_words(HeapWord* beg, HeapWord* end, size_t count);
1205 
1206   // Return the address of the word to be copied to dest_addr, which must be
1207   // aligned to a region boundary.
1208   static HeapWord* first_src_addr(HeapWord* const dest_addr,
1209                                   SpaceId src_space_id,
1210                                   size_t src_region_idx);
1211 
1212   // Determine the next source region, set closure.source() to the start of the
1213   // new region return the region index.  Parameter end_addr is the address one
1214   // beyond the end of source range just processed.  If necessary, switch to a
1215   // new source space and set src_space_id (in-out parameter) and src_space_top
1216   // (out parameter) accordingly.
1217   static size_t next_src_region(MoveAndUpdateClosure&amp; closure,
1218                                 SpaceId&amp; src_space_id,
1219                                 HeapWord*&amp; src_space_top,
1220                                 HeapWord* end_addr);
1221 
1222   // Decrement the destination count for each non-empty source region in the
1223   // range [beg_region, region(region_align_up(end_addr))).  If the destination
1224   // count for a region goes to 0 and it needs to be filled, enqueue it.
1225   static void decrement_destination_counts(ParCompactionManager* cm,
1226                                            SpaceId src_space_id,
1227                                            size_t beg_region,
1228                                            HeapWord* end_addr);
1229 
1230   static void fill_region(ParCompactionManager* cm, MoveAndUpdateClosure&amp; closure, size_t region);
1231   static void fill_and_update_region(ParCompactionManager* cm, size_t region);
1232 
1233   static bool steal_unavailable_region(ParCompactionManager* cm, size_t&amp; region_idx);
1234   static void fill_and_update_shadow_region(ParCompactionManager* cm, size_t region);
1235   // Copy the content of a shadow region back to its corresponding heap region
1236   static void copy_back(HeapWord* shadow_addr, HeapWord* region_addr);
1237   // Collect empty regions as shadow regions and initialize the
1238   // _next_shadow_region filed for each compact manager
1239   static void initialize_shadow_regions(uint parallel_gc_threads);
1240 
1241   // Fill in the block table for the specified region.
1242   static void fill_blocks(size_t region_idx);
1243 
1244   // Update the deferred objects in the space.
1245   static void update_deferred_objects(ParCompactionManager* cm, SpaceId id);
1246 
1247   static ParMarkBitMap* mark_bitmap() { return &amp;_mark_bitmap; }
1248   static ParallelCompactData&amp; summary_data() { return _summary_data; }
1249 
1250   // Reference Processing
1251   static ReferenceProcessor* const ref_processor() { return _ref_processor; }
1252 
1253   static STWGCTimer* gc_timer() { return &amp;_gc_timer; }
1254 
1255   // Return the SpaceId for the given address.
1256   static SpaceId space_id(HeapWord* addr);
1257 
1258   // Time since last full gc (in milliseconds).
1259   static jlong millis_since_last_gc();
1260 
1261   static void print_on_error(outputStream* st);
1262 
1263 #ifndef PRODUCT
1264   // Debugging support.
1265   static const char* space_names[last_space_id];
1266   static void print_region_ranges();
1267   static void print_dense_prefix_stats(const char* const algorithm,
1268                                        const SpaceId id,
1269                                        const bool maximum_compaction,
1270                                        HeapWord* const addr);
1271   static void summary_phase_msg(SpaceId dst_space_id,
1272                                 HeapWord* dst_beg, HeapWord* dst_end,
1273                                 SpaceId src_space_id,
1274                                 HeapWord* src_beg, HeapWord* src_end);
1275 #endif  // #ifndef PRODUCT
1276 
1277 #ifdef  ASSERT
1278   // Sanity check the new location of a word in the heap.
1279   static inline void check_new_location(HeapWord* old_addr, HeapWord* new_addr);
1280   // Verify that all the regions have been emptied.
1281   static void verify_complete(SpaceId space_id);
1282 #endif  // #ifdef ASSERT
1283 };
1284 
1285 class MoveAndUpdateClosure: public ParMarkBitMapClosure {
1286   static inline size_t calculate_words_remaining(size_t region);
1287  public:
1288   inline MoveAndUpdateClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,
1289                               size_t region);
1290 
1291   // Accessors.
1292   HeapWord* destination() const         { return _destination; }
1293   HeapWord* copy_destination() const    { return _destination + _offset; }
1294 
1295   // If the object will fit (size &lt;= words_remaining()), copy it to the current
1296   // destination, update the interior oops and the start array and return either
1297   // full (if the closure is full) or incomplete.  If the object will not fit,
1298   // return would_overflow.
1299   IterationStatus do_addr(HeapWord* addr, size_t size);
1300 
1301   // Copy enough words to fill this closure, starting at source().  Interior
1302   // oops and the start array are not updated.  Return full.
1303   IterationStatus copy_until_full();
1304 
1305   // Copy enough words to fill this closure or to the end of an object,
1306   // whichever is smaller, starting at source().  Interior oops and the start
1307   // array are not updated.
1308   void copy_partial_obj();
1309 
1310   virtual void complete_region(ParCompactionManager* cm, HeapWord* dest_addr,
1311                                PSParallelCompact::RegionData* region_ptr);
1312 
1313 protected:
1314   // Update variables to indicate that word_count words were processed.
1315   inline void update_state(size_t word_count);
1316 
1317  protected:
1318   HeapWord*               _destination;         // Next addr to be written.
1319   ObjectStartArray* const _start_array;
1320   size_t                  _offset;
1321 };
1322 
1323 inline size_t MoveAndUpdateClosure::calculate_words_remaining(size_t region) {
1324   HeapWord* dest_addr = PSParallelCompact::summary_data().region_to_addr(region);
1325   PSParallelCompact::SpaceId dest_space_id = PSParallelCompact::space_id(dest_addr);
1326   HeapWord* new_top = PSParallelCompact::new_top(dest_space_id);
1327   assert(dest_addr &lt; new_top, &quot;sanity&quot;);
1328 
1329   return MIN2(pointer_delta(new_top, dest_addr), ParallelCompactData::RegionSize);
1330 }
1331 
1332 inline
1333 MoveAndUpdateClosure::MoveAndUpdateClosure(ParMarkBitMap* bitmap,
1334                                            ParCompactionManager* cm,
1335                                            size_t region_idx) :
1336   ParMarkBitMapClosure(bitmap, cm, calculate_words_remaining(region_idx)),
1337   _destination(PSParallelCompact::summary_data().region_to_addr(region_idx)),
1338   _start_array(PSParallelCompact::start_array(PSParallelCompact::space_id(_destination))),
1339   _offset(0) { }
1340 
1341 
1342 inline void MoveAndUpdateClosure::update_state(size_t words)
1343 {
1344   decrement_words_remaining(words);
1345   _source += words;
1346   _destination += words;
1347 }
1348 
1349 class MoveAndUpdateShadowClosure: public MoveAndUpdateClosure {
1350   inline size_t calculate_shadow_offset(size_t region_idx, size_t shadow_idx);
1351 public:
1352   inline MoveAndUpdateShadowClosure(ParMarkBitMap* bitmap, ParCompactionManager* cm,
1353                        size_t region, size_t shadow);
1354 
1355   virtual void complete_region(ParCompactionManager* cm, HeapWord* dest_addr,
1356                                PSParallelCompact::RegionData* region_ptr);
1357 
1358 private:
1359   size_t _shadow;
1360 };
1361 
1362 inline size_t MoveAndUpdateShadowClosure::calculate_shadow_offset(size_t region_idx, size_t shadow_idx) {
1363   ParallelCompactData&amp; sd = PSParallelCompact::summary_data();
1364   HeapWord* dest_addr = sd.region_to_addr(region_idx);
1365   HeapWord* shadow_addr = sd.region_to_addr(shadow_idx);
1366   return pointer_delta(shadow_addr, dest_addr);
1367 }
1368 
1369 inline
1370 MoveAndUpdateShadowClosure::MoveAndUpdateShadowClosure(ParMarkBitMap *bitmap,
1371                                                        ParCompactionManager *cm,
1372                                                        size_t region,
1373                                                        size_t shadow) :
1374   MoveAndUpdateClosure(bitmap, cm, region),
1375   _shadow(shadow) {
1376   _offset = calculate_shadow_offset(region, shadow);
1377 }
1378 
1379 class UpdateOnlyClosure: public ParMarkBitMapClosure {
1380  private:
1381   const PSParallelCompact::SpaceId _space_id;
1382   ObjectStartArray* const          _start_array;
1383 
1384  public:
1385   UpdateOnlyClosure(ParMarkBitMap* mbm,
1386                     ParCompactionManager* cm,
1387                     PSParallelCompact::SpaceId space_id);
1388 
1389   // Update the object.
1390   virtual IterationStatus do_addr(HeapWord* addr, size_t words);
1391 
1392   inline void do_addr(HeapWord* addr);
1393 };
1394 
1395 class FillClosure: public ParMarkBitMapClosure {
1396  public:
1397   FillClosure(ParCompactionManager* cm, PSParallelCompact::SpaceId space_id);
1398 
1399   virtual IterationStatus do_addr(HeapWord* addr, size_t size);
1400 
1401  private:
1402   ObjectStartArray* const _start_array;
1403 };
1404 
1405 #endif // SHARE_GC_PARALLEL_PSPARALLELCOMPACT_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>