<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahTaskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahTraversalGC.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 183     if (process_refs) {
 184       rp = _heap-&gt;ref_processor();
 185     }
 186 
 187     // Step 1: Process ordinary GC roots.
 188     {
 189       ShenandoahTraversalRootsClosure roots_cl(q, rp);
 190       ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
 191       MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
 192       if (unload_classes) {
 193         _rp-&gt;roots_do(worker_id, &amp;roots_cl, NULL, &amp;code_cl);
 194       } else {
 195         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, &amp;code_cl);
 196       }
 197     }
 198   }
 199 };
 200 
 201 class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
 202 private:
<span class="line-modified"> 203   ShenandoahTaskTerminator* _terminator;</span>
 204   ShenandoahHeap* _heap;
 205 public:
<span class="line-modified"> 206   ShenandoahConcurrentTraversalCollectionTask(ShenandoahTaskTerminator* terminator) :</span>
 207     AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
 208     _terminator(terminator),
 209     _heap(ShenandoahHeap::heap()) {}
 210 
 211   void work(uint worker_id) {
 212     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 213     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 214     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 215 
 216     // Drain all outstanding work in queues.
 217     traversal_gc-&gt;main_loop(worker_id, _terminator, true);
 218   }
 219 };
 220 
 221 class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
 222 private:
 223   ShenandoahAllRootScanner* _rp;
<span class="line-modified"> 224   ShenandoahTaskTerminator* _terminator;</span>
 225   ShenandoahHeap* _heap;
 226 public:
<span class="line-modified"> 227   ShenandoahFinalTraversalCollectionTask(ShenandoahAllRootScanner* rp, ShenandoahTaskTerminator* terminator) :</span>
 228     AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
 229     _rp(rp),
 230     _terminator(terminator),
 231     _heap(ShenandoahHeap::heap()) {}
 232 
 233   void work(uint worker_id) {
 234     ShenandoahParallelWorkerSession worker_session(worker_id);
 235 
 236     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 237 
 238     ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
 239     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 240 
 241     bool process_refs = _heap-&gt;process_references();
 242     bool unload_classes = _heap-&gt;unload_classes();
 243     ReferenceProcessor* rp = NULL;
 244     if (process_refs) {
 245       rp = _heap-&gt;ref_processor();
 246     }
 247 
</pre>
<hr />
<pre>
 411 #endif
 412 
 413     {
 414       uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 415       task_queues()-&gt;reserve(nworkers);
 416       ShenandoahCSetRootScanner rp(nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);
 417       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp);
 418       _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
 419     }
 420 
 421 #if COMPILER2_OR_JVMCI
 422     DerivedPointerTable::update_pointers();
 423 #endif
 424   }
 425 
 426   if (ShenandoahPacing) {
 427     _heap-&gt;pacer()-&gt;setup_for_traversal();
 428   }
 429 }
 430 
<span class="line-modified"> 431 void ShenandoahTraversalGC::main_loop(uint w, ShenandoahTaskTerminator* t, bool sts_yield) {</span>
 432   ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
 433 
 434   // Initialize live data.
 435   jushort* ld = _heap-&gt;get_liveness_cache(w);
 436 
 437   ReferenceProcessor* rp = NULL;
 438   if (_heap-&gt;process_references()) {
 439     rp = _heap-&gt;ref_processor();
 440   }
 441   {
 442     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
 443       if (_heap-&gt;unload_classes()) {
 444         if (ShenandoahStringDedup::is_enabled()) {
 445           ShenandoahTraversalMetadataDedupClosure cl(q, rp);
 446           main_loop_work&lt;ShenandoahTraversalMetadataDedupClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 447         } else {
 448           ShenandoahTraversalMetadataClosure cl(q, rp);
 449           main_loop_work&lt;ShenandoahTraversalMetadataClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 450         }
 451       } else {
</pre>
<hr />
<pre>
 465         } else {
 466           ShenandoahTraversalMetadataDegenClosure cl(q, rp);
 467           main_loop_work&lt;ShenandoahTraversalMetadataDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 468         }
 469       } else {
 470         if (ShenandoahStringDedup::is_enabled()) {
 471           ShenandoahTraversalDedupDegenClosure cl(q, rp);
 472           main_loop_work&lt;ShenandoahTraversalDedupDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 473         } else {
 474           ShenandoahTraversalDegenClosure cl(q, rp);
 475           main_loop_work&lt;ShenandoahTraversalDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 476         }
 477       }
 478     }
 479   }
 480 
 481   _heap-&gt;flush_liveness_cache(w);
 482 }
 483 
 484 template &lt;class T&gt;
<span class="line-modified"> 485 void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
 486   ShenandoahObjToScanQueueSet* queues = task_queues();
 487   ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 488   ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
 489 
 490   uintx stride = ShenandoahMarkLoopStride;
 491 
 492   ShenandoahMarkTask task;
 493 
 494   // Process outstanding queues, if any.
 495   q = queues-&gt;claim_next();
 496   while (q != NULL) {
 497     if (_heap-&gt;check_cancelled_gc_and_yield(sts_yield)) {
 498       return;
 499     }
 500 
 501     for (uint i = 0; i &lt; stride; i++) {
 502       if (q-&gt;pop(task)) {
 503         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 504       } else {
 505         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
</pre>
<hr />
<pre>
 529       if (q-&gt;pop(task) ||
 530           queues-&gt;steal(worker_id, task)) {
 531         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 532         work++;
 533       } else {
 534         break;
 535       }
 536     }
 537 
 538     if (work == 0) {
 539       // No more work, try to terminate
 540       ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
 541       ShenandoahTerminationTimingsTracker term_tracker(worker_id);
 542       ShenandoahTerminatorTerminator tt(_heap);
 543 
 544       if (terminator-&gt;offer_termination(&amp;tt)) return;
 545     }
 546   }
 547 }
 548 
<span class="line-modified"> 549 bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(ShenandoahTaskTerminator* terminator, bool sts_yield) {</span>
 550   if (_heap-&gt;cancelled_gc()) {
 551     return true;
 552   }
 553   return false;
 554 }
 555 
 556 void ShenandoahTraversalGC::concurrent_traversal_collection() {
 557   ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
 558   if (!_heap-&gt;cancelled_gc()) {
 559     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 560     task_queues()-&gt;reserve(nworkers);
 561     ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
 562 
<span class="line-modified"> 563     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
 564     ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
 565     _heap-&gt;workers()-&gt;run_task(&amp;task);
 566   }
 567 
 568   if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
 569     preclean_weak_refs();
 570   }
 571 }
 572 
 573 void ShenandoahTraversalGC::final_traversal_collection() {
 574   _heap-&gt;make_parsable(true);
 575 
 576   if (!_heap-&gt;cancelled_gc()) {
 577 #if COMPILER2_OR_JVMCI
 578     DerivedPointerTable::clear();
 579 #endif
 580     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
 581     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 582     task_queues()-&gt;reserve(nworkers);
 583 
 584     // Finish traversal
 585     ShenandoahAllRootScanner rp(nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);
 586     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
 587 
<span class="line-modified"> 588     ShenandoahTaskTerminator terminator(nworkers, task_queues());</span>
 589     ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
 590     _heap-&gt;workers()-&gt;run_task(&amp;task);
 591 #if COMPILER2_OR_JVMCI
 592     DerivedPointerTable::update_pointers();
 593 #endif
 594   }
 595 
 596   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
 597     weak_refs_work();
 598   }
 599 
 600   if (!_heap-&gt;cancelled_gc()) {
 601     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
 602     TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
 603     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 604 
 605     // No more marking expected
 606     _heap-&gt;set_concurrent_traversal_in_progress(false);
 607     _heap-&gt;mark_complete_marking_context();
 608 
</pre>
<hr />
<pre>
 759 }
 760 
 761 ShenandoahObjToScanQueueSet* ShenandoahTraversalGC::task_queues() {
 762   return _task_queues;
 763 }
 764 
 765 class ShenandoahTraversalCancelledGCYieldClosure : public YieldClosure {
 766 private:
 767   ShenandoahHeap* const _heap;
 768 public:
 769   ShenandoahTraversalCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
 770   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
 771 };
 772 
 773 class ShenandoahTraversalPrecleanCompleteGCClosure : public VoidClosure {
 774 public:
 775   void do_void() {
 776     ShenandoahHeap* sh = ShenandoahHeap::heap();
 777     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 778     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified"> 779     ShenandoahTaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
 780     shenandoah_assert_rp_isalive_installed();
 781     traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
 782   }
 783 };
 784 
 785 class ShenandoahTraversalKeepAliveUpdateClosure : public OopClosure {
 786 private:
 787   ShenandoahObjToScanQueue* _queue;
 788   Thread* _thread;
 789   ShenandoahTraversalGC* _traversal_gc;
 790   ShenandoahMarkingContext* const _mark_context;
 791 
 792   template &lt;class T&gt;
 793   inline void do_oop_work(T* p) {
 794     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);
 795   }
 796 
 797 public:
 798   ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 799     _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
 926 
 927   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
 928   // queues and other goodies. When upstream ReferenceProcessor starts supporting
 929   // parallel precleans, we can extend this to more threads.
 930   ShenandoahPushWorkerScope scope(_heap-&gt;workers(), 1, /* check_workers = */ false);
 931 
 932   WorkGang* workers = _heap-&gt;workers();
 933   uint nworkers = workers-&gt;active_workers();
 934   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
 935   task_queues()-&gt;reserve(nworkers);
 936 
 937   ShenandoahTraversalPrecleanTask task(rp);
 938   workers-&gt;run_task(&amp;task);
 939 
 940   assert(_heap-&gt;cancelled_gc() || task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 941 }
 942 
 943 // Weak Reference Closures
 944 class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
 945   uint _worker_id;
<span class="line-modified"> 946   ShenandoahTaskTerminator* _terminator;</span>
 947   bool _reset_terminator;
 948 
 949 public:
<span class="line-modified"> 950   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
 951     _worker_id(worker_id),
 952     _terminator(t),
 953     _reset_terminator(reset_terminator) {
 954   }
 955 
 956   void do_void() {
 957     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 958 
 959     ShenandoahHeap* sh = ShenandoahHeap::heap();
 960     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 961     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 962     shenandoah_assert_rp_isalive_installed();
 963 
 964     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 965 
 966     if (_reset_terminator) {
 967       _terminator-&gt;reset_for_reuse();
 968     }
 969   }
 970 };
 971 
 972 class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
 973   uint _worker_id;
<span class="line-modified"> 974   ShenandoahTaskTerminator* _terminator;</span>
 975   bool _reset_terminator;
 976 
 977 public:
<span class="line-modified"> 978   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, ShenandoahTaskTerminator* t, bool reset_terminator = false):</span>
 979           _worker_id(worker_id),
 980           _terminator(t),
 981           _reset_terminator(reset_terminator) {
 982   }
 983 
 984   void do_void() {
 985     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 986 
 987     ShenandoahHeap* sh = ShenandoahHeap::heap();
 988     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 989     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 990     shenandoah_assert_rp_isalive_installed();
 991 
 992     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 993 
 994     if (_reset_terminator) {
 995       _terminator-&gt;reset_for_reuse();
 996     }
 997   }
 998 };
</pre>
<hr />
<pre>
1002 
1003   ShenandoahPhaseTimings::Phase phase_root = ShenandoahPhaseTimings::weakrefs;
1004 
1005   ShenandoahGCPhase phase(phase_root);
1006 
1007   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1008 
1009   // NOTE: We cannot shortcut on has_discovered_references() here, because
1010   // we will miss marking JNI Weak refs then, see implementation in
1011   // ReferenceProcessor::process_discovered_references.
1012   weak_refs_work_doit();
1013 
1014   rp-&gt;verify_no_references_recorded();
1015   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
1016 
1017 }
1018 
1019 class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
1020 private:
1021   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">1022   ShenandoahTaskTerminator* _terminator;</span>
1023 
1024 public:
1025   ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">1026                                       ShenandoahTaskTerminator* t) :</span>
1027     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
1028     _proc_task(proc_task),
1029     _terminator(t) {
1030   }
1031 
1032   void work(uint worker_id) {
1033     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1034     ShenandoahHeap* heap = ShenandoahHeap::heap();
1035     ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
1036 
1037     ShenandoahForwardedIsAliveClosure is_alive;
1038     if (!heap-&gt;is_degenerated_gc_in_progress()) {
1039       ShenandoahTraversalKeepAliveUpdateClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1040       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1041     } else {
1042       ShenandoahTraversalKeepAliveUpdateDegenClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1043       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1044     }
1045   }
1046 };
1047 
1048 class ShenandoahTraversalRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
1049 private:
1050   WorkGang* _workers;
1051 
1052 public:
1053   ShenandoahTraversalRefProcTaskExecutor(WorkGang* workers) : _workers(workers) {}
1054 
1055   // Executes a task using worker threads.
1056   void execute(ProcessTask&amp; task, uint ergo_workers) {
1057     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1058 
1059     ShenandoahHeap* heap = ShenandoahHeap::heap();
1060     ShenandoahTraversalGC* traversal_gc = heap-&gt;traversal_gc();
1061     ShenandoahPushWorkerQueuesScope scope(_workers,
1062                                           traversal_gc-&gt;task_queues(),
1063                                           ergo_workers,
1064                                           /* do_check = */ false);
1065     uint nworkers = _workers-&gt;active_workers();
1066     traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">1067     ShenandoahTaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
1068     ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
1069     _workers-&gt;run_task(&amp;proc_task_proxy);
1070   }
1071 };
1072 
1073 void ShenandoahTraversalGC::weak_refs_work_doit() {
1074   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1075 
1076   ShenandoahPhaseTimings::Phase phase_process = ShenandoahPhaseTimings::weakrefs_process;
1077 
1078   shenandoah_assert_rp_isalive_not_installed();
1079   ShenandoahForwardedIsAliveClosure is_alive;
1080   ReferenceProcessorIsAliveMutator fix_isalive(rp, &amp;is_alive);
1081 
1082   WorkGang* workers = _heap-&gt;workers();
1083   uint nworkers = workers-&gt;active_workers();
1084 
1085   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
1086   rp-&gt;set_active_mt_degree(nworkers);
1087 
1088   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
1089 
1090   // complete_gc and keep_alive closures instantiated here are only needed for
1091   // single-threaded path in RP. They share the queue 0 for tracking work, which
1092   // simplifies implementation. Since RP may decide to call complete_gc several
1093   // times, we need to be able to reuse the terminator.
1094   uint serial_worker_id = 0;
<span class="line-modified">1095   ShenandoahTaskTerminator terminator(1, task_queues());</span>
1096   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
1097   ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
1098 
1099   ShenandoahTraversalRefProcTaskExecutor executor(workers);
1100 
1101   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
1102   if (!_heap-&gt;is_degenerated_gc_in_progress()) {
1103     ShenandoahTraversalSingleThreadKeepAliveUpdateClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1104     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1105                                       &amp;complete_gc, &amp;executor,
1106                                       &amp;pt);
1107   } else {
1108     ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1109     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1110                                       &amp;complete_gc, &amp;executor,
1111                                       &amp;pt);
1112   }
1113 
1114   pt.print_all_references();
1115   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 183     if (process_refs) {
 184       rp = _heap-&gt;ref_processor();
 185     }
 186 
 187     // Step 1: Process ordinary GC roots.
 188     {
 189       ShenandoahTraversalRootsClosure roots_cl(q, rp);
 190       ShenandoahMarkCLDClosure cld_cl(&amp;roots_cl);
 191       MarkingCodeBlobClosure code_cl(&amp;roots_cl, CodeBlobToOopClosure::FixRelocations);
 192       if (unload_classes) {
 193         _rp-&gt;roots_do(worker_id, &amp;roots_cl, NULL, &amp;code_cl);
 194       } else {
 195         _rp-&gt;roots_do(worker_id, &amp;roots_cl, &amp;cld_cl, &amp;code_cl);
 196       }
 197     }
 198   }
 199 };
 200 
 201 class ShenandoahConcurrentTraversalCollectionTask : public AbstractGangTask {
 202 private:
<span class="line-modified"> 203   TaskTerminator* _terminator;</span>
 204   ShenandoahHeap* _heap;
 205 public:
<span class="line-modified"> 206   ShenandoahConcurrentTraversalCollectionTask(TaskTerminator* terminator) :</span>
 207     AbstractGangTask(&quot;Shenandoah Concurrent Traversal Collection&quot;),
 208     _terminator(terminator),
 209     _heap(ShenandoahHeap::heap()) {}
 210 
 211   void work(uint worker_id) {
 212     ShenandoahConcurrentWorkerSession worker_session(worker_id);
 213     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
 214     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 215 
 216     // Drain all outstanding work in queues.
 217     traversal_gc-&gt;main_loop(worker_id, _terminator, true);
 218   }
 219 };
 220 
 221 class ShenandoahFinalTraversalCollectionTask : public AbstractGangTask {
 222 private:
 223   ShenandoahAllRootScanner* _rp;
<span class="line-modified"> 224   TaskTerminator*           _terminator;</span>
 225   ShenandoahHeap* _heap;
 226 public:
<span class="line-modified"> 227   ShenandoahFinalTraversalCollectionTask(ShenandoahAllRootScanner* rp, TaskTerminator* terminator) :</span>
 228     AbstractGangTask(&quot;Shenandoah Final Traversal Collection&quot;),
 229     _rp(rp),
 230     _terminator(terminator),
 231     _heap(ShenandoahHeap::heap()) {}
 232 
 233   void work(uint worker_id) {
 234     ShenandoahParallelWorkerSession worker_session(worker_id);
 235 
 236     ShenandoahTraversalGC* traversal_gc = _heap-&gt;traversal_gc();
 237 
 238     ShenandoahObjToScanQueueSet* queues = traversal_gc-&gt;task_queues();
 239     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 240 
 241     bool process_refs = _heap-&gt;process_references();
 242     bool unload_classes = _heap-&gt;unload_classes();
 243     ReferenceProcessor* rp = NULL;
 244     if (process_refs) {
 245       rp = _heap-&gt;ref_processor();
 246     }
 247 
</pre>
<hr />
<pre>
 411 #endif
 412 
 413     {
 414       uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 415       task_queues()-&gt;reserve(nworkers);
 416       ShenandoahCSetRootScanner rp(nworkers, ShenandoahPhaseTimings::init_traversal_gc_work);
 417       ShenandoahInitTraversalCollectionTask traversal_task(&amp;rp);
 418       _heap-&gt;workers()-&gt;run_task(&amp;traversal_task);
 419     }
 420 
 421 #if COMPILER2_OR_JVMCI
 422     DerivedPointerTable::update_pointers();
 423 #endif
 424   }
 425 
 426   if (ShenandoahPacing) {
 427     _heap-&gt;pacer()-&gt;setup_for_traversal();
 428   }
 429 }
 430 
<span class="line-modified"> 431 void ShenandoahTraversalGC::main_loop(uint w, TaskTerminator* t, bool sts_yield) {</span>
 432   ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(w);
 433 
 434   // Initialize live data.
 435   jushort* ld = _heap-&gt;get_liveness_cache(w);
 436 
 437   ReferenceProcessor* rp = NULL;
 438   if (_heap-&gt;process_references()) {
 439     rp = _heap-&gt;ref_processor();
 440   }
 441   {
 442     if (!_heap-&gt;is_degenerated_gc_in_progress()) {
 443       if (_heap-&gt;unload_classes()) {
 444         if (ShenandoahStringDedup::is_enabled()) {
 445           ShenandoahTraversalMetadataDedupClosure cl(q, rp);
 446           main_loop_work&lt;ShenandoahTraversalMetadataDedupClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 447         } else {
 448           ShenandoahTraversalMetadataClosure cl(q, rp);
 449           main_loop_work&lt;ShenandoahTraversalMetadataClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 450         }
 451       } else {
</pre>
<hr />
<pre>
 465         } else {
 466           ShenandoahTraversalMetadataDegenClosure cl(q, rp);
 467           main_loop_work&lt;ShenandoahTraversalMetadataDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 468         }
 469       } else {
 470         if (ShenandoahStringDedup::is_enabled()) {
 471           ShenandoahTraversalDedupDegenClosure cl(q, rp);
 472           main_loop_work&lt;ShenandoahTraversalDedupDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 473         } else {
 474           ShenandoahTraversalDegenClosure cl(q, rp);
 475           main_loop_work&lt;ShenandoahTraversalDegenClosure&gt;(&amp;cl, ld, w, t, sts_yield);
 476         }
 477       }
 478     }
 479   }
 480 
 481   _heap-&gt;flush_liveness_cache(w);
 482 }
 483 
 484 template &lt;class T&gt;
<span class="line-modified"> 485 void ShenandoahTraversalGC::main_loop_work(T* cl, jushort* live_data, uint worker_id, TaskTerminator* terminator, bool sts_yield) {</span>
 486   ShenandoahObjToScanQueueSet* queues = task_queues();
 487   ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
 488   ShenandoahConcurrentMark* conc_mark = _heap-&gt;concurrent_mark();
 489 
 490   uintx stride = ShenandoahMarkLoopStride;
 491 
 492   ShenandoahMarkTask task;
 493 
 494   // Process outstanding queues, if any.
 495   q = queues-&gt;claim_next();
 496   while (q != NULL) {
 497     if (_heap-&gt;check_cancelled_gc_and_yield(sts_yield)) {
 498       return;
 499     }
 500 
 501     for (uint i = 0; i &lt; stride; i++) {
 502       if (q-&gt;pop(task)) {
 503         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 504       } else {
 505         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
</pre>
<hr />
<pre>
 529       if (q-&gt;pop(task) ||
 530           queues-&gt;steal(worker_id, task)) {
 531         conc_mark-&gt;do_task&lt;T&gt;(q, cl, live_data, &amp;task);
 532         work++;
 533       } else {
 534         break;
 535       }
 536     }
 537 
 538     if (work == 0) {
 539       // No more work, try to terminate
 540       ShenandoahSuspendibleThreadSetLeaver stsl(sts_yield &amp;&amp; ShenandoahSuspendibleWorkers);
 541       ShenandoahTerminationTimingsTracker term_tracker(worker_id);
 542       ShenandoahTerminatorTerminator tt(_heap);
 543 
 544       if (terminator-&gt;offer_termination(&amp;tt)) return;
 545     }
 546   }
 547 }
 548 
<span class="line-modified"> 549 bool ShenandoahTraversalGC::check_and_handle_cancelled_gc(TaskTerminator* terminator, bool sts_yield) {</span>
 550   if (_heap-&gt;cancelled_gc()) {
 551     return true;
 552   }
 553   return false;
 554 }
 555 
 556 void ShenandoahTraversalGC::concurrent_traversal_collection() {
 557   ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::conc_traversal);
 558   if (!_heap-&gt;cancelled_gc()) {
 559     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 560     task_queues()-&gt;reserve(nworkers);
 561     ShenandoahTerminationTracker tracker(ShenandoahPhaseTimings::conc_traversal_termination);
 562 
<span class="line-modified"> 563     TaskTerminator terminator(nworkers, task_queues());</span>
 564     ShenandoahConcurrentTraversalCollectionTask task(&amp;terminator);
 565     _heap-&gt;workers()-&gt;run_task(&amp;task);
 566   }
 567 
 568   if (!_heap-&gt;cancelled_gc() &amp;&amp; ShenandoahPreclean &amp;&amp; _heap-&gt;process_references()) {
 569     preclean_weak_refs();
 570   }
 571 }
 572 
 573 void ShenandoahTraversalGC::final_traversal_collection() {
 574   _heap-&gt;make_parsable(true);
 575 
 576   if (!_heap-&gt;cancelled_gc()) {
 577 #if COMPILER2_OR_JVMCI
 578     DerivedPointerTable::clear();
 579 #endif
 580     ShenandoahGCPhase phase_work(ShenandoahPhaseTimings::final_traversal_gc_work);
 581     uint nworkers = _heap-&gt;workers()-&gt;active_workers();
 582     task_queues()-&gt;reserve(nworkers);
 583 
 584     // Finish traversal
 585     ShenandoahAllRootScanner rp(nworkers, ShenandoahPhaseTimings::final_traversal_gc_work);
 586     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::final_traversal_gc_termination);
 587 
<span class="line-modified"> 588     TaskTerminator terminator(nworkers, task_queues());</span>
 589     ShenandoahFinalTraversalCollectionTask task(&amp;rp, &amp;terminator);
 590     _heap-&gt;workers()-&gt;run_task(&amp;task);
 591 #if COMPILER2_OR_JVMCI
 592     DerivedPointerTable::update_pointers();
 593 #endif
 594   }
 595 
 596   if (!_heap-&gt;cancelled_gc() &amp;&amp; _heap-&gt;process_references()) {
 597     weak_refs_work();
 598   }
 599 
 600   if (!_heap-&gt;cancelled_gc()) {
 601     assert(_task_queues-&gt;is_empty(), &quot;queues must be empty after traversal GC&quot;);
 602     TASKQUEUE_STATS_ONLY(_task_queues-&gt;print_taskqueue_stats());
 603     TASKQUEUE_STATS_ONLY(_task_queues-&gt;reset_taskqueue_stats());
 604 
 605     // No more marking expected
 606     _heap-&gt;set_concurrent_traversal_in_progress(false);
 607     _heap-&gt;mark_complete_marking_context();
 608 
</pre>
<hr />
<pre>
 759 }
 760 
 761 ShenandoahObjToScanQueueSet* ShenandoahTraversalGC::task_queues() {
 762   return _task_queues;
 763 }
 764 
 765 class ShenandoahTraversalCancelledGCYieldClosure : public YieldClosure {
 766 private:
 767   ShenandoahHeap* const _heap;
 768 public:
 769   ShenandoahTraversalCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
 770   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
 771 };
 772 
 773 class ShenandoahTraversalPrecleanCompleteGCClosure : public VoidClosure {
 774 public:
 775   void do_void() {
 776     ShenandoahHeap* sh = ShenandoahHeap::heap();
 777     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 778     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
<span class="line-modified"> 779     TaskTerminator terminator(1, traversal_gc-&gt;task_queues());</span>
 780     shenandoah_assert_rp_isalive_installed();
 781     traversal_gc-&gt;main_loop((uint) 0, &amp;terminator, true);
 782   }
 783 };
 784 
 785 class ShenandoahTraversalKeepAliveUpdateClosure : public OopClosure {
 786 private:
 787   ShenandoahObjToScanQueue* _queue;
 788   Thread* _thread;
 789   ShenandoahTraversalGC* _traversal_gc;
 790   ShenandoahMarkingContext* const _mark_context;
 791 
 792   template &lt;class T&gt;
 793   inline void do_oop_work(T* p) {
 794     _traversal_gc-&gt;process_oop&lt;T, false /* string dedup */, false /* degen */, true /* atomic update */&gt;(p, _thread, _queue, _mark_context);
 795   }
 796 
 797 public:
 798   ShenandoahTraversalKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
 799     _queue(q), _thread(Thread::current()),
</pre>
<hr />
<pre>
 926 
 927   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
 928   // queues and other goodies. When upstream ReferenceProcessor starts supporting
 929   // parallel precleans, we can extend this to more threads.
 930   ShenandoahPushWorkerScope scope(_heap-&gt;workers(), 1, /* check_workers = */ false);
 931 
 932   WorkGang* workers = _heap-&gt;workers();
 933   uint nworkers = workers-&gt;active_workers();
 934   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
 935   task_queues()-&gt;reserve(nworkers);
 936 
 937   ShenandoahTraversalPrecleanTask task(rp);
 938   workers-&gt;run_task(&amp;task);
 939 
 940   assert(_heap-&gt;cancelled_gc() || task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
 941 }
 942 
 943 // Weak Reference Closures
 944 class ShenandoahTraversalDrainMarkingStackClosure: public VoidClosure {
 945   uint _worker_id;
<span class="line-modified"> 946   TaskTerminator* _terminator;</span>
 947   bool _reset_terminator;
 948 
 949 public:
<span class="line-modified"> 950   ShenandoahTraversalDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
 951     _worker_id(worker_id),
 952     _terminator(t),
 953     _reset_terminator(reset_terminator) {
 954   }
 955 
 956   void do_void() {
 957     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 958 
 959     ShenandoahHeap* sh = ShenandoahHeap::heap();
 960     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 961     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 962     shenandoah_assert_rp_isalive_installed();
 963 
 964     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 965 
 966     if (_reset_terminator) {
 967       _terminator-&gt;reset_for_reuse();
 968     }
 969   }
 970 };
 971 
 972 class ShenandoahTraversalSingleThreadedDrainMarkingStackClosure: public VoidClosure {
 973   uint _worker_id;
<span class="line-modified"> 974   TaskTerminator* _terminator;</span>
 975   bool _reset_terminator;
 976 
 977 public:
<span class="line-modified"> 978   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):</span>
 979           _worker_id(worker_id),
 980           _terminator(t),
 981           _reset_terminator(reset_terminator) {
 982   }
 983 
 984   void do_void() {
 985     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 986 
 987     ShenandoahHeap* sh = ShenandoahHeap::heap();
 988     ShenandoahTraversalGC* traversal_gc = sh-&gt;traversal_gc();
 989     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
 990     shenandoah_assert_rp_isalive_installed();
 991 
 992     traversal_gc-&gt;main_loop(_worker_id, _terminator, false);
 993 
 994     if (_reset_terminator) {
 995       _terminator-&gt;reset_for_reuse();
 996     }
 997   }
 998 };
</pre>
<hr />
<pre>
1002 
1003   ShenandoahPhaseTimings::Phase phase_root = ShenandoahPhaseTimings::weakrefs;
1004 
1005   ShenandoahGCPhase phase(phase_root);
1006 
1007   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1008 
1009   // NOTE: We cannot shortcut on has_discovered_references() here, because
1010   // we will miss marking JNI Weak refs then, see implementation in
1011   // ReferenceProcessor::process_discovered_references.
1012   weak_refs_work_doit();
1013 
1014   rp-&gt;verify_no_references_recorded();
1015   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
1016 
1017 }
1018 
1019 class ShenandoahTraversalRefProcTaskProxy : public AbstractGangTask {
1020 private:
1021   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
<span class="line-modified">1022   TaskTerminator* _terminator;</span>
1023 
1024 public:
1025   ShenandoahTraversalRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
<span class="line-modified">1026                                       TaskTerminator* t) :</span>
1027     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
1028     _proc_task(proc_task),
1029     _terminator(t) {
1030   }
1031 
1032   void work(uint worker_id) {
1033     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1034     ShenandoahHeap* heap = ShenandoahHeap::heap();
1035     ShenandoahTraversalDrainMarkingStackClosure complete_gc(worker_id, _terminator);
1036 
1037     ShenandoahForwardedIsAliveClosure is_alive;
1038     if (!heap-&gt;is_degenerated_gc_in_progress()) {
1039       ShenandoahTraversalKeepAliveUpdateClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1040       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1041     } else {
1042       ShenandoahTraversalKeepAliveUpdateDegenClosure keep_alive(heap-&gt;traversal_gc()-&gt;task_queues()-&gt;queue(worker_id));
1043       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
1044     }
1045   }
1046 };
1047 
1048 class ShenandoahTraversalRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
1049 private:
1050   WorkGang* _workers;
1051 
1052 public:
1053   ShenandoahTraversalRefProcTaskExecutor(WorkGang* workers) : _workers(workers) {}
1054 
1055   // Executes a task using worker threads.
1056   void execute(ProcessTask&amp; task, uint ergo_workers) {
1057     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
1058 
1059     ShenandoahHeap* heap = ShenandoahHeap::heap();
1060     ShenandoahTraversalGC* traversal_gc = heap-&gt;traversal_gc();
1061     ShenandoahPushWorkerQueuesScope scope(_workers,
1062                                           traversal_gc-&gt;task_queues(),
1063                                           ergo_workers,
1064                                           /* do_check = */ false);
1065     uint nworkers = _workers-&gt;active_workers();
1066     traversal_gc-&gt;task_queues()-&gt;reserve(nworkers);
<span class="line-modified">1067     TaskTerminator terminator(nworkers, traversal_gc-&gt;task_queues());</span>
1068     ShenandoahTraversalRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
1069     _workers-&gt;run_task(&amp;proc_task_proxy);
1070   }
1071 };
1072 
1073 void ShenandoahTraversalGC::weak_refs_work_doit() {
1074   ReferenceProcessor* rp = _heap-&gt;ref_processor();
1075 
1076   ShenandoahPhaseTimings::Phase phase_process = ShenandoahPhaseTimings::weakrefs_process;
1077 
1078   shenandoah_assert_rp_isalive_not_installed();
1079   ShenandoahForwardedIsAliveClosure is_alive;
1080   ReferenceProcessorIsAliveMutator fix_isalive(rp, &amp;is_alive);
1081 
1082   WorkGang* workers = _heap-&gt;workers();
1083   uint nworkers = workers-&gt;active_workers();
1084 
1085   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
1086   rp-&gt;set_active_mt_degree(nworkers);
1087 
1088   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
1089 
1090   // complete_gc and keep_alive closures instantiated here are only needed for
1091   // single-threaded path in RP. They share the queue 0 for tracking work, which
1092   // simplifies implementation. Since RP may decide to call complete_gc several
1093   // times, we need to be able to reuse the terminator.
1094   uint serial_worker_id = 0;
<span class="line-modified">1095   TaskTerminator terminator(1, task_queues());</span>
1096   ShenandoahTraversalSingleThreadedDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
1097   ShenandoahPushWorkerQueuesScope scope(workers, task_queues(), 1, /* do_check = */ false);
1098 
1099   ShenandoahTraversalRefProcTaskExecutor executor(workers);
1100 
1101   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
1102   if (!_heap-&gt;is_degenerated_gc_in_progress()) {
1103     ShenandoahTraversalSingleThreadKeepAliveUpdateClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1104     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1105                                       &amp;complete_gc, &amp;executor,
1106                                       &amp;pt);
1107   } else {
1108     ShenandoahTraversalSingleThreadKeepAliveUpdateDegenClosure keep_alive(task_queues()-&gt;queue(serial_worker_id));
1109     rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive,
1110                                       &amp;complete_gc, &amp;executor,
1111                                       &amp;pt);
1112   }
1113 
1114   pt.print_all_references();
1115   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahTaskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahTraversalGC.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>