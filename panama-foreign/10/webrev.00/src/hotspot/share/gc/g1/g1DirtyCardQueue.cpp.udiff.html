<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/g1/g1DirtyCardQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentRefineThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1DirtyCardQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,26 +24,26 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;gc/g1/g1BufferNodeList.hpp&quot;
  #include &quot;gc/g1/g1CardTableEntryClosure.hpp&quot;
  #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/g1/g1ConcurrentRefineThread.hpp&quot;</span>
  #include &quot;gc/g1/g1DirtyCardQueue.hpp&quot;
  #include &quot;gc/g1/g1FreeIdSet.hpp&quot;
  #include &quot;gc/g1/g1RedirtyCardsQueue.hpp&quot;
  #include &quot;gc/g1/g1RemSet.hpp&quot;
  #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  #include &quot;gc/shared/suspendibleThreadSet.hpp&quot;
<span class="udiff-line-removed">- #include &quot;gc/shared/workgroup.hpp&quot;</span>
  #include &quot;memory/iterator.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;runtime/flags/flagSetting.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/mutexLocker.hpp&quot;</span>
<span class="udiff-line-removed">- #include &quot;runtime/orderAccess.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;runtime/atomic.hpp&quot;</span>
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/safepoint.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/globalCounter.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;utilities/macros.hpp&quot;</span>
  #include &quot;utilities/quickSort.hpp&quot;
  
  G1DirtyCardQueue::G1DirtyCardQueue(G1DirtyCardQueueSet* qset) :
    // Dirty card queues are always active, so we create them with their
    // active field set to true.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -66,22 +66,20 @@</span>
  }
  
  // Assumed to be zero by concurrent threads.
  static uint par_ids_start() { return 0; }
  
<span class="udiff-line-modified-removed">- G1DirtyCardQueueSet::G1DirtyCardQueueSet(Monitor* cbl_mon,</span>
<span class="udiff-line-removed">-                                          BufferNode::Allocator* allocator) :</span>
<span class="udiff-line-modified-added">+ G1DirtyCardQueueSet::G1DirtyCardQueueSet(BufferNode::Allocator* allocator) :</span>
    PtrQueueSet(allocator),
<span class="udiff-line-modified-removed">-   _cbl_mon(cbl_mon),</span>
<span class="udiff-line-removed">-   _completed_buffers_head(NULL),</span>
<span class="udiff-line-removed">-   _completed_buffers_tail(NULL),</span>
<span class="udiff-line-modified-added">+   _primary_refinement_thread(NULL),</span>
    _num_cards(0),
<span class="udiff-line-added">+   _completed(),</span>
<span class="udiff-line-added">+   _paused(),</span>
<span class="udiff-line-added">+   _free_ids(par_ids_start(), num_par_ids()),</span>
    _process_cards_threshold(ProcessCardsThresholdNever),
<span class="udiff-line-removed">-   _process_completed_buffers(false),</span>
    _max_cards(MaxCardsUnlimited),
    _max_cards_padding(0),
<span class="udiff-line-removed">-   _free_ids(par_ids_start(), num_par_ids()),</span>
    _mutator_refined_cards_counters(NEW_C_HEAP_ARRAY(size_t, num_par_ids(), mtGC))
  {
    ::memset(_mutator_refined_cards_counters, 0, num_par_ids() * sizeof(size_t));
    _all_active = true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,128 +104,341 @@</span>
  
  void G1DirtyCardQueueSet::handle_zero_index_for_thread(Thread* t) {
    G1ThreadLocalData::dirty_card_queue(t).handle_zero_index();
  }
  
<span class="udiff-line-modified-removed">- void G1DirtyCardQueueSet::enqueue_completed_buffer(BufferNode* cbn) {</span>
<span class="udiff-line-modified-removed">-   MonitorLocker ml(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-   cbn-&gt;set_next(NULL);</span>
<span class="udiff-line-modified-removed">-   if (_completed_buffers_tail == NULL) {</span>
<span class="udiff-line-modified-removed">-     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="udiff-line-modified-removed">-     _completed_buffers_head = cbn;</span>
<span class="udiff-line-modified-removed">-     _completed_buffers_tail = cbn;</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-modified-added">+ G1DirtyCardQueueSet::Queue::~Queue() {</span>
<span class="udiff-line-modified-added">+   assert(_head == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-modified-added">+   assert(_tail == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+ BufferNode* G1DirtyCardQueueSet::Queue::top() const {</span>
<span class="udiff-line-added">+   return Atomic::load(&amp;_head);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // An append operation atomically exchanges the new tail with the queue tail.</span>
<span class="udiff-line-added">+ // It then sets the &quot;next&quot; value of the old tail to the head of the list being</span>
<span class="udiff-line-added">+ // appended; it is an invariant that the old tail&#39;s &quot;next&quot; value is NULL.</span>
<span class="udiff-line-added">+ // But if the old tail is NULL then the queue was empty.  In this case the</span>
<span class="udiff-line-added">+ // head of the list being appended is instead stored in the queue head; it is</span>
<span class="udiff-line-added">+ // an invariant that the queue head is NULL in this case.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // This means there is a period between the exchange and the old tail update</span>
<span class="udiff-line-added">+ // where the queue sequence is split into two parts, the list from the queue</span>
<span class="udiff-line-added">+ // head to the old tail, and the list being appended.  If there are concurrent</span>
<span class="udiff-line-added">+ // push/append operations, each may introduce another such segment.  But they</span>
<span class="udiff-line-added">+ // all eventually get resolved by their respective updates of their old tail&#39;s</span>
<span class="udiff-line-added">+ // &quot;next&quot; value.  This also means that pop operations must handle a buffer</span>
<span class="udiff-line-added">+ // with a NULL &quot;next&quot; value specially.</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // A push operation is just a degenerate append, where the buffer being pushed</span>
<span class="udiff-line-added">+ // is both the head and the tail of the list being appended.</span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::Queue::append(BufferNode&amp; first, BufferNode&amp; last) {</span>
<span class="udiff-line-added">+   assert(last.next() == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   BufferNode* old_tail = Atomic::xchg(&amp;_tail, &amp;last);</span>
<span class="udiff-line-added">+   if (old_tail == NULL) {       // Was empty.</span>
<span class="udiff-line-added">+     assert(Atomic::load(&amp;_head) == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     Atomic::store(&amp;_head, &amp;first);</span>
    } else {
<span class="udiff-line-modified-removed">-     _completed_buffers_tail-&gt;set_next(cbn);</span>
<span class="udiff-line-modified-removed">-     _completed_buffers_tail = cbn;</span>
<span class="udiff-line-modified-added">+     assert(old_tail-&gt;next() == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-added">+     old_tail-&gt;set_next(&amp;first);</span>
    }
<span class="udiff-line-modified-removed">-   _num_cards += buffer_size() - cbn-&gt;index();</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-   if (!process_completed_buffers() &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       (num_cards() &gt; process_cards_threshold())) {</span>
<span class="udiff-line-modified-removed">-     set_process_completed_buffers(true);</span>
<span class="udiff-line-modified-removed">-     ml.notify_all();</span>
<span class="udiff-line-modified-added">+ // pop gets the queue head as the candidate result (returning NULL if the</span>
<span class="udiff-line-modified-added">+ // queue head was NULL), and then gets that result node&#39;s &quot;next&quot; value.  If</span>
<span class="udiff-line-modified-added">+ // that &quot;next&quot; value is NULL and the queue head hasn&#39;t changed, then there</span>
<span class="udiff-line-modified-added">+ // is only one element in the accessible part of the list (the sequence from</span>
<span class="udiff-line-added">+ // head to a node with a NULL &quot;next&quot; value).  We can&#39;t return that element,</span>
<span class="udiff-line-added">+ // because it may be the old tail of a concurrent push/append that has not</span>
<span class="udiff-line-added">+ // yet had its &quot;next&quot; field set to the new tail.  So return NULL in this case.</span>
<span class="udiff-line-added">+ // Otherwise, attempt to cmpxchg that &quot;next&quot; value into the queue head,</span>
<span class="udiff-line-added">+ // retrying the whole operation if that fails. This is the &quot;usual&quot; lock-free</span>
<span class="udiff-line-added">+ // pop from the head of a singly linked list, with the additional restriction</span>
<span class="udiff-line-added">+ // on taking the last element.</span>
<span class="udiff-line-added">+ BufferNode* G1DirtyCardQueueSet::Queue::pop() {</span>
<span class="udiff-line-added">+   Thread* current_thread = Thread::current();</span>
<span class="udiff-line-added">+   while (true) {</span>
<span class="udiff-line-added">+     // Use a critical section per iteration, rather than over the whole</span>
<span class="udiff-line-added">+     // operation.  We&#39;re not guaranteed to make progress, because of possible</span>
<span class="udiff-line-added">+     // contention on the queue head.  Lingering in one CS the whole time could</span>
<span class="udiff-line-added">+     // lead to excessive allocation of buffers, because the CS blocks return</span>
<span class="udiff-line-added">+     // of released buffers to the free list for reuse.</span>
<span class="udiff-line-added">+     GlobalCounter::CriticalSection cs(current_thread);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BufferNode* result = Atomic::load_acquire(&amp;_head);</span>
<span class="udiff-line-added">+     // Check for empty queue.  Only needs to be done on first iteration,</span>
<span class="udiff-line-added">+     // since we never take the last element, but it&#39;s messy to make use</span>
<span class="udiff-line-added">+     // of that and we expect one iteration to be the common case.</span>
<span class="udiff-line-added">+     if (result == NULL) return NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BufferNode* next = Atomic::load_acquire(BufferNode::next_ptr(*result));</span>
<span class="udiff-line-added">+     if (next != NULL) {</span>
<span class="udiff-line-added">+       next = Atomic::cmpxchg(&amp;_head, result, next);</span>
<span class="udiff-line-added">+       if (next == result) {</span>
<span class="udiff-line-added">+         // Former head successfully taken; it is not the last.</span>
<span class="udiff-line-added">+         assert(Atomic::load(&amp;_tail) != result, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+         assert(result-&gt;next() != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+         result-&gt;set_next(NULL);</span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       // cmpxchg failed; try again.</span>
<span class="udiff-line-added">+     } else if (result == Atomic::load_acquire(&amp;_head)) {</span>
<span class="udiff-line-added">+       // If follower of head is NULL and head hasn&#39;t changed, then only</span>
<span class="udiff-line-added">+       // the one element is currently accessible.  We don&#39;t take the last</span>
<span class="udiff-line-added">+       // accessible element, because there may be a concurrent add using it.</span>
<span class="udiff-line-added">+       // The check for unchanged head isn&#39;t needed for correctness, but the</span>
<span class="udiff-line-added">+       // retry on change may sometimes let us get a buffer after all.</span>
<span class="udiff-line-added">+       return NULL;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     // Head changed; try again.</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::Queue::take_all() {</span>
<span class="udiff-line-added">+   assert_at_safepoint();</span>
<span class="udiff-line-added">+   HeadTail result(Atomic::load(&amp;_head), Atomic::load(&amp;_tail));</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_head, (BufferNode*)NULL);</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_tail, (BufferNode*)NULL);</span>
<span class="udiff-line-added">+   return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::enqueue_completed_buffer(BufferNode* cbn) {</span>
<span class="udiff-line-added">+   assert(cbn != NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   // Increment _num_cards before adding to queue, so queue removal doesn&#39;t</span>
<span class="udiff-line-added">+   // need to deal with _num_cards possibly going negative.</span>
<span class="udiff-line-added">+   size_t new_num_cards = Atomic::add(&amp;_num_cards, buffer_size() - cbn-&gt;index());</span>
<span class="udiff-line-added">+   _completed.push(*cbn);</span>
<span class="udiff-line-added">+   if ((new_num_cards &gt; process_cards_threshold()) &amp;&amp;</span>
<span class="udiff-line-added">+       (_primary_refinement_thread != NULL)) {</span>
<span class="udiff-line-added">+     _primary_refinement_thread-&gt;activate();</span>
    }
<span class="udiff-line-removed">-   verify_num_cards();</span>
  }
  
  BufferNode* G1DirtyCardQueueSet::get_completed_buffer(size_t stop_at) {
<span class="udiff-line-modified-removed">-   MutexLocker x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-added">+   enqueue_previous_paused_buffers();</span>
  
<span class="udiff-line-modified-removed">-   if (num_cards() &lt;= stop_at) {</span>
<span class="udiff-line-modified-added">+   // Check for insufficient cards to satisfy request.  We only do this once,</span>
<span class="udiff-line-added">+   // up front, rather than on each iteration below, since the test is racy</span>
<span class="udiff-line-added">+   // regardless of when we do it.</span>
<span class="udiff-line-added">+   if (Atomic::load_acquire(&amp;_num_cards) &lt;= stop_at) {</span>
      return NULL;
    }
  
<span class="udiff-line-modified-removed">-   assert(num_cards() &gt; 0, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_completed_buffers_head != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-modified-removed">-   assert(_completed_buffers_tail != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   BufferNode* bn = _completed_buffers_head;</span>
<span class="udiff-line-removed">-   _num_cards -= buffer_size() - bn-&gt;index();</span>
<span class="udiff-line-removed">-   _completed_buffers_head = bn-&gt;next();</span>
<span class="udiff-line-removed">-   if (_completed_buffers_head == NULL) {</span>
<span class="udiff-line-removed">-     assert(num_cards() == 0, &quot;invariant&quot;);</span>
<span class="udiff-line-removed">-     _completed_buffers_tail = NULL;</span>
<span class="udiff-line-removed">-     set_process_completed_buffers(false);</span>
<span class="udiff-line-modified-added">+   BufferNode* result = _completed.pop();</span>
<span class="udiff-line-modified-added">+   if (result != NULL) {</span>
<span class="udiff-line-modified-added">+     Atomic::sub(&amp;_num_cards, buffer_size() - result-&gt;index());</span>
    }
<span class="udiff-line-modified-removed">-   verify_num_cards();</span>
<span class="udiff-line-removed">-   bn-&gt;set_next(NULL);</span>
<span class="udiff-line-removed">-   return bn;</span>
<span class="udiff-line-modified-added">+   return result;</span>
  }
  
  #ifdef ASSERT
  void G1DirtyCardQueueSet::verify_num_cards() const {
    size_t actual = 0;
<span class="udiff-line-modified-removed">-   BufferNode* cur = _completed_buffers_head;</span>
<span class="udiff-line-modified-removed">-   while (cur != NULL) {</span>
<span class="udiff-line-modified-added">+   BufferNode* cur = _completed.top();</span>
<span class="udiff-line-modified-added">+   for ( ; cur != NULL; cur = cur-&gt;next()) {</span>
      actual += buffer_size() - cur-&gt;index();
<span class="udiff-line-removed">-     cur = cur-&gt;next();</span>
    }
<span class="udiff-line-modified-removed">-   assert(actual == _num_cards,</span>
<span class="udiff-line-modified-added">+   assert(actual == Atomic::load(&amp;_num_cards),</span>
           &quot;Num entries in completed buffers should be &quot; SIZE_FORMAT &quot; but are &quot; SIZE_FORMAT,
<span class="udiff-line-modified-removed">-          _num_cards, actual);</span>
<span class="udiff-line-modified-added">+          Atomic::load(&amp;_num_cards), actual);</span>
  }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT</span>
  
<span class="udiff-line-modified-removed">- void G1DirtyCardQueueSet::abandon_completed_buffers() {</span>
<span class="udiff-line-modified-removed">-   BufferNode* buffers_to_delete = NULL;</span>
<span class="udiff-line-modified-added">+ G1DirtyCardQueueSet::PausedBuffers::PausedList::PausedList() :</span>
<span class="udiff-line-modified-added">+   _head(NULL), _tail(NULL),</span>
<span class="udiff-line-added">+   _safepoint_id(SafepointSynchronize::safepoint_id())</span>
<span class="udiff-line-added">+ {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::PausedBuffers::PausedList::~PausedList() {</span>
<span class="udiff-line-added">+   assert(Atomic::load(&amp;_head) == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   assert(_tail == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif // ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool G1DirtyCardQueueSet::PausedBuffers::PausedList::is_next() const {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   return _safepoint_id == SafepointSynchronize::safepoint_id();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::PausedBuffers::PausedList::add(BufferNode* node) {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   assert(is_next(), &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   BufferNode* old_head = Atomic::xchg(&amp;_head, node);</span>
<span class="udiff-line-added">+   if (old_head == NULL) {</span>
<span class="udiff-line-added">+     assert(_tail == NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     _tail = node;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     node-&gt;set_next(old_head);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::PausedList::take() {</span>
<span class="udiff-line-added">+   BufferNode* head = Atomic::load(&amp;_head);</span>
<span class="udiff-line-added">+   BufferNode* tail = _tail;</span>
<span class="udiff-line-added">+   Atomic::store(&amp;_head, (BufferNode*)NULL);</span>
<span class="udiff-line-added">+   _tail = NULL;</span>
<span class="udiff-line-added">+   return HeadTail(head, tail);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::PausedBuffers::PausedBuffers() : _plist(NULL) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::PausedBuffers::~PausedBuffers() {</span>
<span class="udiff-line-added">+   assert(is_empty(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif // ASSERT</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool G1DirtyCardQueueSet::PausedBuffers::is_empty() const {</span>
<span class="udiff-line-added">+   return Atomic::load(&amp;_plist) == NULL;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::PausedBuffers::add(BufferNode* node) {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   PausedList* plist = Atomic::load_acquire(&amp;_plist);</span>
<span class="udiff-line-added">+   if (plist != NULL) {</span>
<span class="udiff-line-added">+     // Already have a next list, so use it.  We know it&#39;s a next list because</span>
<span class="udiff-line-added">+     // of the precondition that take_previous() has already been called.</span>
<span class="udiff-line-added">+     assert(plist-&gt;is_next(), &quot;invariant&quot;);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // Try to install a new next list.</span>
<span class="udiff-line-added">+     plist = new PausedList();</span>
<span class="udiff-line-added">+     PausedList* old_plist = Atomic::cmpxchg(&amp;_plist, (PausedList*)NULL, plist);</span>
<span class="udiff-line-added">+     if (old_plist != NULL) {</span>
<span class="udiff-line-added">+       // Some other thread installed a new next list. Use it instead.</span>
<span class="udiff-line-added">+       delete plist;</span>
<span class="udiff-line-added">+       plist = old_plist;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   plist-&gt;add(node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::take_previous() {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   PausedList* previous;</span>
    {
<span class="udiff-line-modified-removed">-     MutexLocker x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-     buffers_to_delete = _completed_buffers_head;</span>
<span class="udiff-line-modified-removed">-     _completed_buffers_head = NULL;</span>
<span class="udiff-line-modified-removed">-     _completed_buffers_tail = NULL;</span>
<span class="udiff-line-modified-removed">-     _num_cards = 0;</span>
<span class="udiff-line-modified-removed">-     set_process_completed_buffers(false);</span>
<span class="udiff-line-modified-added">+     // Deal with plist in a critical section, to prevent it from being</span>
<span class="udiff-line-modified-added">+     // deleted out from under us by a concurrent take_previous().</span>
<span class="udiff-line-modified-added">+     GlobalCounter::CriticalSection cs(Thread::current());</span>
<span class="udiff-line-modified-added">+     previous = Atomic::load_acquire(&amp;_plist);</span>
<span class="udiff-line-modified-added">+     if ((previous == NULL) ||   // Nothing to take.</span>
<span class="udiff-line-modified-added">+         previous-&gt;is_next() ||  // Not from a previous safepoint.</span>
<span class="udiff-line-added">+         // Some other thread stole it.</span>
<span class="udiff-line-added">+         (Atomic::cmpxchg(&amp;_plist, previous, (PausedList*)NULL) != previous)) {</span>
<span class="udiff-line-added">+       return HeadTail();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   // We now own previous.</span>
<span class="udiff-line-added">+   HeadTail result = previous-&gt;take();</span>
<span class="udiff-line-added">+   // There might be other threads examining previous (in concurrent</span>
<span class="udiff-line-added">+   // take_previous()).  Synchronize to wait until any such threads are</span>
<span class="udiff-line-added">+   // done with such examination before deleting.</span>
<span class="udiff-line-added">+   GlobalCounter::write_synchronize();</span>
<span class="udiff-line-added">+   delete previous;</span>
<span class="udiff-line-added">+   return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::PausedBuffers::take_all() {</span>
<span class="udiff-line-added">+   assert_at_safepoint();</span>
<span class="udiff-line-added">+   HeadTail result;</span>
<span class="udiff-line-added">+   PausedList* plist = Atomic::load(&amp;_plist);</span>
<span class="udiff-line-added">+   if (plist != NULL) {</span>
<span class="udiff-line-added">+     Atomic::store(&amp;_plist, (PausedList*)NULL);</span>
<span class="udiff-line-added">+     result = plist-&gt;take();</span>
<span class="udiff-line-added">+     delete plist;</span>
    }
<span class="udiff-line-added">+   return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::record_paused_buffer(BufferNode* node) {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   assert(node-&gt;next() == NULL, &quot;precondition&quot;);</span>
<span class="udiff-line-added">+   // Cards for paused buffers are included in count, to contribute to</span>
<span class="udiff-line-added">+   // notification checking after the coming safepoint if it doesn&#39;t GC.</span>
<span class="udiff-line-added">+   // Note that this means the queue&#39;s _num_cards differs from the number</span>
<span class="udiff-line-added">+   // of cards in the queued buffers when there are paused buffers.</span>
<span class="udiff-line-added">+   Atomic::add(&amp;_num_cards, buffer_size() - node-&gt;index());</span>
<span class="udiff-line-added">+   _paused.add(node);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::enqueue_paused_buffers_aux(const HeadTail&amp; paused) {</span>
<span class="udiff-line-added">+   if (paused._head != NULL) {</span>
<span class="udiff-line-added">+     assert(paused._tail != NULL, &quot;invariant&quot;);</span>
<span class="udiff-line-added">+     // Cards from paused buffers are already recorded in the queue count.</span>
<span class="udiff-line-added">+     _completed.append(*paused._head, *paused._tail);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::enqueue_previous_paused_buffers() {</span>
<span class="udiff-line-added">+   assert_not_at_safepoint();</span>
<span class="udiff-line-added">+   // The fast-path still satisfies the precondition for record_paused_buffer</span>
<span class="udiff-line-added">+   // and PausedBuffers::add, even with a racy test.  If there are paused</span>
<span class="udiff-line-added">+   // buffers from a previous safepoint, is_empty() will return false; there</span>
<span class="udiff-line-added">+   // will have been a safepoint between recording and test, so there can&#39;t be</span>
<span class="udiff-line-added">+   // a false negative (is_empty() returns true) while such buffers are present.</span>
<span class="udiff-line-added">+   // If is_empty() is false, there are two cases:</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // (1) There were paused buffers from a previous safepoint.  A concurrent</span>
<span class="udiff-line-added">+   // caller may take and enqueue them first, but that&#39;s okay; the precondition</span>
<span class="udiff-line-added">+   // for a possible later record_paused_buffer by this thread will still hold.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // (2) There are paused buffers for a requested next safepoint.</span>
<span class="udiff-line-added">+   //</span>
<span class="udiff-line-added">+   // In each of those cases some effort may be spent detecting and dealing</span>
<span class="udiff-line-added">+   // with those circumstances; any wasted effort in such cases is expected to</span>
<span class="udiff-line-added">+   // be well compensated by the fast path.</span>
<span class="udiff-line-added">+   if (!_paused.is_empty()) {</span>
<span class="udiff-line-added">+     enqueue_paused_buffers_aux(_paused.take_previous());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::enqueue_all_paused_buffers() {</span>
<span class="udiff-line-added">+   assert_at_safepoint();</span>
<span class="udiff-line-added">+   enqueue_paused_buffers_aux(_paused.take_all());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void G1DirtyCardQueueSet::abandon_completed_buffers() {</span>
<span class="udiff-line-added">+   enqueue_all_paused_buffers();</span>
<span class="udiff-line-added">+   verify_num_cards();</span>
<span class="udiff-line-added">+   G1BufferNodeList list = take_all_completed_buffers();</span>
<span class="udiff-line-added">+   BufferNode* buffers_to_delete = list._head;</span>
    while (buffers_to_delete != NULL) {
      BufferNode* bn = buffers_to_delete;
      buffers_to_delete = bn-&gt;next();
      bn-&gt;set_next(NULL);
      deallocate_buffer(bn);
    }
  }
  
  void G1DirtyCardQueueSet::notify_if_necessary() {
<span class="udiff-line-modified-removed">-   MonitorLocker ml(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-   if (num_cards() &gt; process_cards_threshold()) {</span>
<span class="udiff-line-modified-removed">-     set_process_completed_buffers(true);</span>
<span class="udiff-line-removed">-     ml.notify_all();</span>
<span class="udiff-line-modified-added">+   if ((_primary_refinement_thread != NULL) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       (num_cards() &gt; process_cards_threshold())) {</span>
<span class="udiff-line-modified-added">+     _primary_refinement_thread-&gt;activate();</span>
    }
  }
  
<span class="udiff-line-modified-removed">- // Merge lists of buffers. Notify the processing threads.</span>
<span class="udiff-line-modified-removed">- // The source queue is emptied as a result. The queues</span>
<span class="udiff-line-removed">- // must share the monitor.</span>
<span class="udiff-line-modified-added">+ // Merge lists of buffers. The source queue set is emptied as a</span>
<span class="udiff-line-modified-added">+ // result. The queue sets must share the same allocator.</span>
  void G1DirtyCardQueueSet::merge_bufferlists(G1RedirtyCardsQueueSet* src) {
    assert(allocator() == src-&gt;allocator(), &quot;precondition&quot;);
    const G1BufferNodeList from = src-&gt;take_all_completed_buffers();
<span class="udiff-line-modified-removed">-   if (from._head == NULL) return;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   MutexLocker x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-removed">-   if (_completed_buffers_tail == NULL) {</span>
<span class="udiff-line-removed">-     assert(_completed_buffers_head == NULL, &quot;Well-formedness&quot;);</span>
<span class="udiff-line-removed">-     _completed_buffers_head = from._head;</span>
<span class="udiff-line-removed">-     _completed_buffers_tail = from._tail;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     assert(_completed_buffers_head != NULL, &quot;Well formedness&quot;);</span>
<span class="udiff-line-removed">-     _completed_buffers_tail-&gt;set_next(from._head);</span>
<span class="udiff-line-removed">-     _completed_buffers_tail = from._tail;</span>
<span class="udiff-line-modified-added">+   if (from._head != NULL) {</span>
<span class="udiff-line-modified-added">+     Atomic::add(&amp;_num_cards, from._entry_count);</span>
<span class="udiff-line-modified-added">+     _completed.append(*from._head, *from._tail);</span>
    }
<span class="udiff-line-removed">-   _num_cards += from._entry_count;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   assert(_completed_buffers_head == NULL &amp;&amp; _completed_buffers_tail == NULL ||</span>
<span class="udiff-line-removed">-          _completed_buffers_head != NULL &amp;&amp; _completed_buffers_tail != NULL,</span>
<span class="udiff-line-removed">-          &quot;Sanity&quot;);</span>
<span class="udiff-line-removed">-   verify_num_cards();</span>
  }
  
  G1BufferNodeList G1DirtyCardQueueSet::take_all_completed_buffers() {
<span class="udiff-line-modified-removed">-   MutexLocker x(_cbl_mon, Mutex::_no_safepoint_check_flag);</span>
<span class="udiff-line-modified-removed">-   G1BufferNodeList result(_completed_buffers_head, _completed_buffers_tail, _num_cards);</span>
<span class="udiff-line-modified-removed">-   _completed_buffers_head = NULL;</span>
<span class="udiff-line-modified-removed">-   _completed_buffers_tail = NULL;</span>
<span class="udiff-line-modified-removed">-   _num_cards = 0;</span>
<span class="udiff-line-modified-removed">-   return result;</span>
<span class="udiff-line-modified-added">+   enqueue_all_paused_buffers();</span>
<span class="udiff-line-modified-added">+   verify_num_cards();</span>
<span class="udiff-line-modified-added">+   HeadTail buffers = _completed.take_all();</span>
<span class="udiff-line-modified-added">+   size_t num_cards = Atomic::load(&amp;_num_cards);</span>
<span class="udiff-line-modified-added">+   Atomic::store(&amp;_num_cards, size_t(0));</span>
<span class="udiff-line-modified-added">+   return G1BufferNodeList(buffers._head, buffers._tail, num_cards);</span>
  }
  
  class G1RefineBufferedCards : public StackObj {
    BufferNode* const _node;
    CardTable::CardValue** const _node_buffer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -366,18 +577,24 @@</span>
  #endif // ASSERT
  
  bool G1DirtyCardQueueSet::process_or_enqueue_completed_buffer(BufferNode* node) {
    if (Thread::current()-&gt;is_Java_thread()) {
      // If the number of buffers exceeds the limit, make this Java
<span class="udiff-line-modified-removed">-     // thread do the processing itself.  We don&#39;t lock to access</span>
<span class="udiff-line-modified-removed">-     // buffer count or padding; it is fine to be imprecise here.  The</span>
<span class="udiff-line-modified-removed">-     // add of padding could overflow, which is treated as unlimited.</span>
<span class="udiff-line-modified-added">+     // thread do the processing itself.  Calculation is racy but we</span>
<span class="udiff-line-modified-added">+     // don&#39;t need precision here.  The add of padding could overflow,</span>
<span class="udiff-line-modified-added">+     // which is treated as unlimited.</span>
      size_t limit = max_cards() + max_cards_padding();
      if ((num_cards() &gt; limit) &amp;&amp; (limit &gt;= max_cards())) {
        if (mut_process_buffer(node)) {
          return true;
        }
<span class="udiff-line-added">+       // Buffer was incompletely processed because of a pending safepoint</span>
<span class="udiff-line-added">+       // request.  Unlike with refinement thread processing, for mutator</span>
<span class="udiff-line-added">+       // processing the buffer did not come from the completed buffer queue,</span>
<span class="udiff-line-added">+       // so it is okay to add it to the queue rather than to the paused set.</span>
<span class="udiff-line-added">+       // Indeed, it can&#39;t be added to the paused set because we didn&#39;t pass</span>
<span class="udiff-line-added">+       // through enqueue_previous_paused_buffers.</span>
      }
    }
    enqueue_completed_buffer(node);
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,18 +622,19 @@</span>
      assert_fully_consumed(node, buffer_size());
      // Done with fully processed buffer.
      deallocate_buffer(node);
      return true;
    } else {
<span class="udiff-line-modified-removed">-     // Return partially processed buffer to the queue.</span>
<span class="udiff-line-modified-removed">-     enqueue_completed_buffer(node);</span>
<span class="udiff-line-modified-added">+     // Buffer incompletely processed because there is a pending safepoint.</span>
<span class="udiff-line-modified-added">+     // Record partially processed buffer, to be finished later.</span>
<span class="udiff-line-added">+     record_paused_buffer(node);</span>
      return true;
    }
  }
  
  void G1DirtyCardQueueSet::abandon_logs() {
<span class="udiff-line-modified-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);</span>
<span class="udiff-line-modified-added">+   assert_at_safepoint();</span>
    abandon_completed_buffers();
  
    // Since abandon is done only at safepoints, we can safely manipulate
    // these queues.
    struct AbandonThreadLogClosure : public ThreadClosure {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -431,11 +649,11 @@</span>
  
  void G1DirtyCardQueueSet::concatenate_logs() {
    // Iterate over all the threads, if we find a partial log add it to
    // the global list of logs.  Temporarily turn off the limit on the number
    // of outstanding buffers.
<span class="udiff-line-modified-removed">-   assert(SafepointSynchronize::is_at_safepoint(), &quot;Must be at safepoint.&quot;);</span>
<span class="udiff-line-modified-added">+   assert_at_safepoint();</span>
    size_t old_limit = max_cards();
    set_max_cards(MaxCardsUnlimited);
  
    struct ConcatenateThreadLogClosure : public ThreadClosure {
      virtual void do_thread(Thread* t) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -446,7 +664,9 @@</span>
      }
    } closure;
    Threads::threads_do(&amp;closure);
  
    G1BarrierSet::shared_dirty_card_queue().flush();
<span class="udiff-line-added">+   enqueue_all_paused_buffers();</span>
<span class="udiff-line-added">+   verify_num_cards();</span>
    set_max_cards(old_limit);
  }
</pre>
<center><a href="g1ConcurrentRefineThread.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>