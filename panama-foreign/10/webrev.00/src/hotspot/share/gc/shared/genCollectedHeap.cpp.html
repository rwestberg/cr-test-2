<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/gc/shared/genCollectedHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/stringTable.hpp&quot;
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;classfile/vmSymbols.hpp&quot;
  32 #include &quot;code/codeCache.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;gc/serial/defNewGeneration.hpp&quot;
  35 #include &quot;gc/shared/adaptiveSizePolicy.hpp&quot;
  36 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  37 #include &quot;gc/shared/cardTableRS.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  39 #include &quot;gc/shared/collectorCounters.hpp&quot;
  40 #include &quot;gc/shared/gcId.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.hpp&quot;
  42 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  43 #include &quot;gc/shared/gcTrace.hpp&quot;
  44 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  45 #include &quot;gc/shared/genArguments.hpp&quot;
  46 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  47 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  48 #include &quot;gc/shared/genOopClosures.inline.hpp&quot;
  49 #include &quot;gc/shared/generationSpec.hpp&quot;
  50 #include &quot;gc/shared/locationPrinter.inline.hpp&quot;
  51 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  52 #include &quot;gc/shared/scavengableNMethods.hpp&quot;
  53 #include &quot;gc/shared/space.hpp&quot;
  54 #include &quot;gc/shared/strongRootsScope.hpp&quot;
  55 #include &quot;gc/shared/weakProcessor.hpp&quot;
  56 #include &quot;gc/shared/workgroup.hpp&quot;
  57 #include &quot;memory/filemap.hpp&quot;
  58 #include &quot;memory/iterator.hpp&quot;
  59 #include &quot;memory/metaspaceCounters.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/oop.inline.hpp&quot;
  63 #include &quot;runtime/biasedLocking.hpp&quot;
  64 #include &quot;runtime/flags/flagSetting.hpp&quot;
  65 #include &quot;runtime/handles.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/java.hpp&quot;
  68 #include &quot;runtime/vmThread.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/memoryService.hpp&quot;
  71 #include &quot;utilities/debug.hpp&quot;
  72 #include &quot;utilities/formatBuffer.hpp&quot;
  73 #include &quot;utilities/macros.hpp&quot;
  74 #include &quot;utilities/stack.inline.hpp&quot;
  75 #include &quot;utilities/vmError.hpp&quot;
  76 #if INCLUDE_JVMCI
  77 #include &quot;jvmci/jvmci.hpp&quot;
  78 #endif
  79 
  80 GenCollectedHeap::GenCollectedHeap(Generation::Name young,
  81                                    Generation::Name old,
  82                                    const char* policy_counters_name) :
  83   CollectedHeap(),
  84   _young_gen_spec(new GenerationSpec(young,
  85                                      NewSize,
  86                                      MaxNewSize,
  87                                      GenAlignment)),
  88   _old_gen_spec(new GenerationSpec(old,
  89                                    OldSize,
  90                                    MaxOldSize,
  91                                    GenAlignment)),
  92   _rem_set(NULL),
  93   _soft_ref_gen_policy(),
  94   _gc_policy_counters(new GCPolicyCounters(policy_counters_name, 2, 2)),
  95   _full_collections_completed(0),
  96   _process_strong_tasks(new SubTasksDone(GCH_PS_NumElements)) {
  97 }
  98 
  99 jint GenCollectedHeap::initialize() {
 100   // While there are no constraints in the GC code that HeapWordSize
 101   // be any particular value, there are multiple other areas in the
 102   // system which believe this to be true (e.g. oop-&gt;object_size in some
 103   // cases incorrectly returns the size in wordSize units rather than
 104   // HeapWordSize).
 105   guarantee(HeapWordSize == wordSize, &quot;HeapWordSize must equal wordSize&quot;);
 106 
 107   // Allocate space for the heap.
 108 
 109   ReservedHeapSpace heap_rs = allocate(HeapAlignment);
 110 
 111   if (!heap_rs.is_reserved()) {
 112     vm_shutdown_during_initialization(
 113       &quot;Could not reserve enough space for object heap&quot;);
 114     return JNI_ENOMEM;
 115   }
 116 
 117   initialize_reserved_region(heap_rs);
 118 
 119   _rem_set = create_rem_set(heap_rs.region());
 120   _rem_set-&gt;initialize();
 121   CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
 122   bs-&gt;initialize();
 123   BarrierSet::set_barrier_set(bs);
 124 
 125   ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec-&gt;max_size(), false, false);
 126   _young_gen = _young_gen_spec-&gt;init(young_rs, rem_set());
 127   ReservedSpace old_rs = heap_rs.last_part(_young_gen_spec-&gt;max_size());
 128 
 129   old_rs = old_rs.first_part(_old_gen_spec-&gt;max_size(), false, false);
 130   _old_gen = _old_gen_spec-&gt;init(old_rs, rem_set());
 131   clear_incremental_collection_failed();
 132 
 133   return JNI_OK;
 134 }
 135 
 136 CardTableRS* GenCollectedHeap::create_rem_set(const MemRegion&amp; reserved_region) {
 137   return new CardTableRS(reserved_region, false /* scan_concurrently */);
 138 }
 139 
 140 void GenCollectedHeap::initialize_size_policy(size_t init_eden_size,
 141                                               size_t init_promo_size,
 142                                               size_t init_survivor_size) {
 143   const double max_gc_pause_sec = ((double) MaxGCPauseMillis) / 1000.0;
 144   _size_policy = new AdaptiveSizePolicy(init_eden_size,
 145                                         init_promo_size,
 146                                         init_survivor_size,
 147                                         max_gc_pause_sec,
 148                                         GCTimeRatio);
 149 }
 150 
 151 ReservedHeapSpace GenCollectedHeap::allocate(size_t alignment) {
 152   // Now figure out the total size.
 153   const size_t pageSize = UseLargePages ? os::large_page_size() : os::vm_page_size();
 154   assert(alignment % pageSize == 0, &quot;Must be&quot;);
 155 
 156   // Check for overflow.
 157   size_t total_reserved = _young_gen_spec-&gt;max_size() + _old_gen_spec-&gt;max_size();
 158   if (total_reserved &lt; _young_gen_spec-&gt;max_size()) {
 159     vm_exit_during_initialization(&quot;The size of the object heap + VM data exceeds &quot;
 160                                   &quot;the maximum representable size&quot;);
 161   }
 162   assert(total_reserved % alignment == 0,
 163          &quot;Gen size; total_reserved=&quot; SIZE_FORMAT &quot;, alignment=&quot;
 164          SIZE_FORMAT, total_reserved, alignment);
 165 
 166   ReservedHeapSpace heap_rs = Universe::reserve_heap(total_reserved, alignment);
 167 
 168   os::trace_page_sizes(&quot;Heap&quot;,
 169                        MinHeapSize,
 170                        total_reserved,
 171                        alignment,
 172                        heap_rs.base(),
 173                        heap_rs.size());
 174 
 175   return heap_rs;
 176 }
 177 
 178 class GenIsScavengable : public BoolObjectClosure {
 179 public:
 180   bool do_object_b(oop obj) {
 181     return GenCollectedHeap::heap()-&gt;is_in_young(obj);
 182   }
 183 };
 184 
 185 static GenIsScavengable _is_scavengable;
 186 
 187 void GenCollectedHeap::post_initialize() {
 188   CollectedHeap::post_initialize();
 189   ref_processing_init();
 190 
 191   DefNewGeneration* def_new_gen = (DefNewGeneration*)_young_gen;
 192 
 193   initialize_size_policy(def_new_gen-&gt;eden()-&gt;capacity(),
 194                          _old_gen-&gt;capacity(),
 195                          def_new_gen-&gt;from()-&gt;capacity());
 196 
 197   MarkSweep::initialize();
 198 
 199   ScavengableNMethods::initialize(&amp;_is_scavengable);
 200 }
 201 
 202 void GenCollectedHeap::ref_processing_init() {
 203   _young_gen-&gt;ref_processor_init();
 204   _old_gen-&gt;ref_processor_init();
 205 }
 206 
 207 PreGenGCValues GenCollectedHeap::get_pre_gc_values() const {
 208   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();
 209 
 210   return PreGenGCValues(def_new_gen-&gt;used(),
 211                         def_new_gen-&gt;capacity(),
 212                         def_new_gen-&gt;eden()-&gt;used(),
 213                         def_new_gen-&gt;eden()-&gt;capacity(),
 214                         def_new_gen-&gt;from()-&gt;used(),
 215                         def_new_gen-&gt;from()-&gt;capacity(),
 216                         old_gen()-&gt;used(),
 217                         old_gen()-&gt;capacity());
 218 }
 219 
 220 GenerationSpec* GenCollectedHeap::young_gen_spec() const {
 221   return _young_gen_spec;
 222 }
 223 
 224 GenerationSpec* GenCollectedHeap::old_gen_spec() const {
 225   return _old_gen_spec;
 226 }
 227 
 228 size_t GenCollectedHeap::capacity() const {
 229   return _young_gen-&gt;capacity() + _old_gen-&gt;capacity();
 230 }
 231 
 232 size_t GenCollectedHeap::used() const {
 233   return _young_gen-&gt;used() + _old_gen-&gt;used();
 234 }
 235 
 236 void GenCollectedHeap::save_used_regions() {
 237   _old_gen-&gt;save_used_region();
 238   _young_gen-&gt;save_used_region();
 239 }
 240 
 241 size_t GenCollectedHeap::max_capacity() const {
 242   return _young_gen-&gt;max_capacity() + _old_gen-&gt;max_capacity();
 243 }
 244 
 245 // Update the _full_collections_completed counter
 246 // at the end of a stop-world full GC.
 247 unsigned int GenCollectedHeap::update_full_collections_completed() {
 248   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
 249   assert(_full_collections_completed &lt;= _total_full_collections,
 250          &quot;Can&#39;t complete more collections than were started&quot;);
 251   _full_collections_completed = _total_full_collections;
 252   ml.notify_all();
 253   return _full_collections_completed;
 254 }
 255 
 256 // Update the _full_collections_completed counter, as appropriate,
 257 // at the end of a concurrent GC cycle. Note the conditional update
 258 // below to allow this method to be called by a concurrent collector
 259 // without synchronizing in any manner with the VM thread (which
 260 // may already have initiated a STW full collection &quot;concurrently&quot;).
 261 unsigned int GenCollectedHeap::update_full_collections_completed(unsigned int count) {
 262   MonitorLocker ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);
 263   assert((_full_collections_completed &lt;= _total_full_collections) &amp;&amp;
 264          (count &lt;= _total_full_collections),
 265          &quot;Can&#39;t complete more collections than were started&quot;);
 266   if (count &gt; _full_collections_completed) {
 267     _full_collections_completed = count;
 268     ml.notify_all();
 269   }
 270   return _full_collections_completed;
 271 }
 272 
 273 // Return true if any of the following is true:
 274 // . the allocation won&#39;t fit into the current young gen heap
 275 // . gc locker is occupied (jni critical section)
 276 // . heap memory is tight -- the most recent previous collection
 277 //   was a full collection because a partial collection (would
 278 //   have) failed and is likely to fail again
 279 bool GenCollectedHeap::should_try_older_generation_allocation(size_t word_size) const {
 280   size_t young_capacity = _young_gen-&gt;capacity_before_gc();
 281   return    (word_size &gt; heap_word_size(young_capacity))
 282          || GCLocker::is_active_and_needs_gc()
 283          || incremental_collection_failed();
 284 }
 285 
 286 HeapWord* GenCollectedHeap::expand_heap_and_allocate(size_t size, bool   is_tlab) {
 287   HeapWord* result = NULL;
 288   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 289     result = _old_gen-&gt;expand_and_allocate(size, is_tlab);
 290   }
 291   if (result == NULL) {
 292     if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 293       result = _young_gen-&gt;expand_and_allocate(size, is_tlab);
 294     }
 295   }
 296   assert(result == NULL || is_in_reserved(result), &quot;result not in heap&quot;);
 297   return result;
 298 }
 299 
 300 HeapWord* GenCollectedHeap::mem_allocate_work(size_t size,
 301                                               bool is_tlab,
 302                                               bool* gc_overhead_limit_was_exceeded) {
 303   // In general gc_overhead_limit_was_exceeded should be false so
 304   // set it so here and reset it to true only if the gc time
 305   // limit is being exceeded as checked below.
 306   *gc_overhead_limit_was_exceeded = false;
 307 
 308   HeapWord* result = NULL;
 309 
 310   // Loop until the allocation is satisfied, or unsatisfied after GC.
 311   for (uint try_count = 1, gclocker_stalled_count = 0; /* return or throw */; try_count += 1) {
 312     HandleMark hm; // Discard any handles allocated in each iteration.
 313 
 314     // First allocation attempt is lock-free.
 315     Generation *young = _young_gen;
 316     assert(young-&gt;supports_inline_contig_alloc(),
 317       &quot;Otherwise, must do alloc within heap lock&quot;);
 318     if (young-&gt;should_allocate(size, is_tlab)) {
 319       result = young-&gt;par_allocate(size, is_tlab);
 320       if (result != NULL) {
 321         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 322         return result;
 323       }
 324     }
 325     uint gc_count_before;  // Read inside the Heap_lock locked region.
 326     {
 327       MutexLocker ml(Heap_lock);
 328       log_trace(gc, alloc)(&quot;GenCollectedHeap::mem_allocate_work: attempting locked slow path allocation&quot;);
 329       // Note that only large objects get a shot at being
 330       // allocated in later generations.
 331       bool first_only = !should_try_older_generation_allocation(size);
 332 
 333       result = attempt_allocation(size, is_tlab, first_only);
 334       if (result != NULL) {
 335         assert(is_in_reserved(result), &quot;result not in heap&quot;);
 336         return result;
 337       }
 338 
 339       if (GCLocker::is_active_and_needs_gc()) {
 340         if (is_tlab) {
 341           return NULL;  // Caller will retry allocating individual object.
 342         }
 343         if (!is_maximal_no_gc()) {
 344           // Try and expand heap to satisfy request.
 345           result = expand_heap_and_allocate(size, is_tlab);
 346           // Result could be null if we are out of space.
 347           if (result != NULL) {
 348             return result;
 349           }
 350         }
 351 
 352         if (gclocker_stalled_count &gt; GCLockerRetryAllocationCount) {
 353           return NULL; // We didn&#39;t get to do a GC and we didn&#39;t get any memory.
 354         }
 355 
 356         // If this thread is not in a jni critical section, we stall
 357         // the requestor until the critical section has cleared and
 358         // GC allowed. When the critical section clears, a GC is
 359         // initiated by the last thread exiting the critical section; so
 360         // we retry the allocation sequence from the beginning of the loop,
 361         // rather than causing more, now probably unnecessary, GC attempts.
 362         JavaThread* jthr = JavaThread::current();
 363         if (!jthr-&gt;in_critical()) {
 364           MutexUnlocker mul(Heap_lock);
 365           // Wait for JNI critical section to be exited
 366           GCLocker::stall_until_clear();
 367           gclocker_stalled_count += 1;
 368           continue;
 369         } else {
 370           if (CheckJNICalls) {
 371             fatal(&quot;Possible deadlock due to allocating while&quot;
 372                   &quot; in jni critical section&quot;);
 373           }
 374           return NULL;
 375         }
 376       }
 377 
 378       // Read the gc count while the heap lock is held.
 379       gc_count_before = total_collections();
 380     }
 381 
 382     VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);
 383     VMThread::execute(&amp;op);
 384     if (op.prologue_succeeded()) {
 385       result = op.result();
 386       if (op.gc_locked()) {
 387          assert(result == NULL, &quot;must be NULL if gc_locked() is true&quot;);
 388          continue;  // Retry and/or stall as necessary.
 389       }
 390 
 391       // Allocation has failed and a collection
 392       // has been done.  If the gc time limit was exceeded the
 393       // this time, return NULL so that an out-of-memory
 394       // will be thrown.  Clear gc_overhead_limit_exceeded
 395       // so that the overhead exceeded does not persist.
 396 
 397       const bool limit_exceeded = size_policy()-&gt;gc_overhead_limit_exceeded();
 398       const bool softrefs_clear = soft_ref_policy()-&gt;all_soft_refs_clear();
 399 
 400       if (limit_exceeded &amp;&amp; softrefs_clear) {
 401         *gc_overhead_limit_was_exceeded = true;
 402         size_policy()-&gt;set_gc_overhead_limit_exceeded(false);
 403         if (op.result() != NULL) {
 404           CollectedHeap::fill_with_object(op.result(), size);
 405         }
 406         return NULL;
 407       }
 408       assert(result == NULL || is_in_reserved(result),
 409              &quot;result not in heap&quot;);
 410       return result;
 411     }
 412 
 413     // Give a warning if we seem to be looping forever.
 414     if ((QueuedAllocationWarningCount &gt; 0) &amp;&amp;
 415         (try_count % QueuedAllocationWarningCount == 0)) {
 416           log_warning(gc, ergo)(&quot;GenCollectedHeap::mem_allocate_work retries %d times,&quot;
 417                                 &quot; size=&quot; SIZE_FORMAT &quot; %s&quot;, try_count, size, is_tlab ? &quot;(TLAB)&quot; : &quot;&quot;);
 418     }
 419   }
 420 }
 421 
 422 HeapWord* GenCollectedHeap::attempt_allocation(size_t size,
 423                                                bool is_tlab,
 424                                                bool first_only) {
 425   HeapWord* res = NULL;
 426 
 427   if (_young_gen-&gt;should_allocate(size, is_tlab)) {
 428     res = _young_gen-&gt;allocate(size, is_tlab);
 429     if (res != NULL || first_only) {
 430       return res;
 431     }
 432   }
 433 
 434   if (_old_gen-&gt;should_allocate(size, is_tlab)) {
 435     res = _old_gen-&gt;allocate(size, is_tlab);
 436   }
 437 
 438   return res;
 439 }
 440 
 441 HeapWord* GenCollectedHeap::mem_allocate(size_t size,
 442                                          bool* gc_overhead_limit_was_exceeded) {
 443   return mem_allocate_work(size,
 444                            false /* is_tlab */,
 445                            gc_overhead_limit_was_exceeded);
 446 }
 447 
 448 bool GenCollectedHeap::must_clear_all_soft_refs() {
 449   return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||
 450          _gc_cause == GCCause::_wb_full_gc;
 451 }
 452 
 453 void GenCollectedHeap::collect_generation(Generation* gen, bool full, size_t size,
 454                                           bool is_tlab, bool run_verification, bool clear_soft_refs,
 455                                           bool restore_marks_for_biased_locking) {
 456   FormatBuffer&lt;&gt; title(&quot;Collect gen: %s&quot;, gen-&gt;short_name());
 457   GCTraceTime(Trace, gc, phases) t1(title);
 458   TraceCollectorStats tcs(gen-&gt;counters());
 459   TraceMemoryManagerStats tmms(gen-&gt;gc_manager(), gc_cause());
 460 
 461   gen-&gt;stat_record()-&gt;invocations++;
 462   gen-&gt;stat_record()-&gt;accumulated_time.start();
 463 
 464   // Must be done anew before each collection because
 465   // a previous collection will do mangling and will
 466   // change top of some spaces.
 467   record_gen_tops_before_GC();
 468 
 469   log_trace(gc)(&quot;%s invoke=%d size=&quot; SIZE_FORMAT, heap()-&gt;is_young_gen(gen) ? &quot;Young&quot; : &quot;Old&quot;, gen-&gt;stat_record()-&gt;invocations, size * HeapWordSize);
 470 
 471   if (run_verification &amp;&amp; VerifyBeforeGC) {
 472     HandleMark hm;  // Discard invalid handles created during verification
 473     Universe::verify(&quot;Before GC&quot;);
 474   }
 475   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());
 476 
 477   if (restore_marks_for_biased_locking) {
 478     // We perform this mark word preservation work lazily
 479     // because it&#39;s only at this point that we know whether we
 480     // absolutely have to do it; we want to avoid doing it for
 481     // scavenge-only collections where it&#39;s unnecessary
 482     BiasedLocking::preserve_marks();
 483   }
 484 
 485   // Do collection work
 486   {
 487     // Note on ref discovery: For what appear to be historical reasons,
 488     // GCH enables and disabled (by enqueing) refs discovery.
 489     // In the future this should be moved into the generation&#39;s
 490     // collect method so that ref discovery and enqueueing concerns
 491     // are local to a generation. The collect method could return
 492     // an appropriate indication in the case that notification on
 493     // the ref lock was needed. This will make the treatment of
 494     // weak refs more uniform (and indeed remove such concerns
 495     // from GCH). XXX
 496 
 497     HandleMark hm;  // Discard invalid handles created during gc
 498     save_marks();   // save marks for all gens
 499     // We want to discover references, but not process them yet.
 500     // This mode is disabled in process_discovered_references if the
 501     // generation does some collection work, or in
 502     // enqueue_discovered_references if the generation returns
 503     // without doing any work.
 504     ReferenceProcessor* rp = gen-&gt;ref_processor();
 505     // If the discovery of (&quot;weak&quot;) refs in this generation is
 506     // atomic wrt other collectors in this configuration, we
 507     // are guaranteed to have empty discovered ref lists.
 508     if (rp-&gt;discovery_is_atomic()) {
 509       rp-&gt;enable_discovery();
 510       rp-&gt;setup_policy(clear_soft_refs);
 511     } else {
 512       // collect() below will enable discovery as appropriate
 513     }
 514     gen-&gt;collect(full, clear_soft_refs, size, is_tlab);
 515     if (!rp-&gt;enqueuing_is_done()) {
 516       rp-&gt;disable_discovery();
 517     } else {
 518       rp-&gt;set_enqueuing_is_done(false);
 519     }
 520     rp-&gt;verify_no_references_recorded();
 521   }
 522 
 523   COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());
 524 
 525   gen-&gt;stat_record()-&gt;accumulated_time.stop();
 526 
 527   update_gc_stats(gen, full);
 528 
 529   if (run_verification &amp;&amp; VerifyAfterGC) {
 530     HandleMark hm;  // Discard invalid handles created during verification
 531     Universe::verify(&quot;After GC&quot;);
 532   }
 533 }
 534 
 535 void GenCollectedHeap::do_collection(bool           full,
 536                                      bool           clear_all_soft_refs,
 537                                      size_t         size,
 538                                      bool           is_tlab,
 539                                      GenerationType max_generation) {
 540   ResourceMark rm;
 541   DEBUG_ONLY(Thread* my_thread = Thread::current();)
 542 
 543   assert(SafepointSynchronize::is_at_safepoint(), &quot;should be at safepoint&quot;);
 544   assert(my_thread-&gt;is_VM_thread() ||
 545          my_thread-&gt;is_ConcurrentGC_thread(),
 546          &quot;incorrect thread type capability&quot;);
 547   assert(Heap_lock-&gt;is_locked(),
 548          &quot;the requesting thread should have the Heap_lock&quot;);
 549   guarantee(!is_gc_active(), &quot;collection is not reentrant&quot;);
 550 
 551   if (GCLocker::check_active_before_gc()) {
 552     return; // GC is disabled (e.g. JNI GetXXXCritical operation)
 553   }
 554 
 555   const bool do_clear_all_soft_refs = clear_all_soft_refs ||
 556                           soft_ref_policy()-&gt;should_clear_all_soft_refs();
 557 
 558   ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());
 559 
 560   FlagSetting fl(_is_gc_active, true);
 561 
 562   bool complete = full &amp;&amp; (max_generation == OldGen);
 563   bool old_collects_young = complete &amp;&amp; !ScavengeBeforeFullGC;
 564   bool do_young_collection = !old_collects_young &amp;&amp; _young_gen-&gt;should_collect(full, size, is_tlab);
 565 
 566   const PreGenGCValues pre_gc_values = get_pre_gc_values();
 567 
 568   bool run_verification = total_collections() &gt;= VerifyGCStartAt;
 569   bool prepared_for_verification = false;
 570   bool do_full_collection = false;
 571 
 572   if (do_young_collection) {
 573     GCIdMark gc_id_mark;
 574     GCTraceCPUTime tcpu;
 575     GCTraceTime(Info, gc) t(&quot;Pause Young&quot;, NULL, gc_cause(), true);
 576 
 577     print_heap_before_gc();
 578 
 579     if (run_verification &amp;&amp; VerifyGCLevel &lt;= 0 &amp;&amp; VerifyBeforeGC) {
 580       prepare_for_verify();
 581       prepared_for_verification = true;
 582     }
 583 
 584     gc_prologue(complete);
 585     increment_total_collections(complete);
 586 
 587     collect_generation(_young_gen,
 588                        full,
 589                        size,
 590                        is_tlab,
 591                        run_verification &amp;&amp; VerifyGCLevel &lt;= 0,
 592                        do_clear_all_soft_refs,
 593                        false);
 594 
 595     if (size &gt; 0 &amp;&amp; (!is_tlab || _young_gen-&gt;supports_tlab_allocation()) &amp;&amp;
 596         size * HeapWordSize &lt;= _young_gen-&gt;unsafe_max_alloc_nogc()) {
 597       // Allocation request was met by young GC.
 598       size = 0;
 599     }
 600 
 601     // Ask if young collection is enough. If so, do the final steps for young collection,
 602     // and fallthrough to the end.
 603     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 604     if (!do_full_collection) {
 605       // Adjust generation sizes.
 606       _young_gen-&gt;compute_new_size();
 607 
 608       print_heap_change(pre_gc_values);
 609 
 610       // Track memory usage and detect low memory after GC finishes
 611       MemoryService::track_memory_usage();
 612 
 613       gc_epilogue(complete);
 614     }
 615 
 616     print_heap_after_gc();
 617 
 618   } else {
 619     // No young collection, ask if we need to perform Full collection.
 620     do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);
 621   }
 622 
 623   if (do_full_collection) {
 624     GCIdMark gc_id_mark;
 625     GCTraceCPUTime tcpu;
 626     GCTraceTime(Info, gc) t(&quot;Pause Full&quot;, NULL, gc_cause(), true);
 627 
 628     print_heap_before_gc();
 629 
 630     if (!prepared_for_verification &amp;&amp; run_verification &amp;&amp;
 631         VerifyGCLevel &lt;= 1 &amp;&amp; VerifyBeforeGC) {
 632       prepare_for_verify();
 633     }
 634 
 635     if (!do_young_collection) {
 636       gc_prologue(complete);
 637       increment_total_collections(complete);
 638     }
 639 
 640     // Accounting quirk: total full collections would be incremented when &quot;complete&quot;
 641     // is set, by calling increment_total_collections above. However, we also need to
 642     // account Full collections that had &quot;complete&quot; unset.
 643     if (!complete) {
 644       increment_total_full_collections();
 645     }
 646 
 647     collect_generation(_old_gen,
 648                        full,
 649                        size,
 650                        is_tlab,
 651                        run_verification &amp;&amp; VerifyGCLevel &lt;= 1,
 652                        do_clear_all_soft_refs,
 653                        true);
 654 
 655     // Adjust generation sizes.
 656     _old_gen-&gt;compute_new_size();
 657     _young_gen-&gt;compute_new_size();
 658 
 659     // Delete metaspaces for unloaded class loaders and clean up loader_data graph
 660     ClassLoaderDataGraph::purge();
 661     MetaspaceUtils::verify_metrics();
 662     // Resize the metaspace capacity after full collections
 663     MetaspaceGC::compute_new_size();
 664     update_full_collections_completed();
 665 
 666     print_heap_change(pre_gc_values);
 667 
 668     // Track memory usage and detect low memory after GC finishes
 669     MemoryService::track_memory_usage();
 670 
 671     // Need to tell the epilogue code we are done with Full GC, regardless what was
 672     // the initial value for &quot;complete&quot; flag.
 673     gc_epilogue(true);
 674 
 675     BiasedLocking::restore_marks();
 676 
 677     print_heap_after_gc();
 678   }
 679 }
 680 
 681 bool GenCollectedHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,
 682                                                  GenCollectedHeap::GenerationType max_gen) const {
 683   return max_gen == OldGen &amp;&amp; _old_gen-&gt;should_collect(full, size, is_tlab);
 684 }
 685 
 686 void GenCollectedHeap::register_nmethod(nmethod* nm) {
 687   ScavengableNMethods::register_nmethod(nm);
 688 }
 689 
 690 void GenCollectedHeap::unregister_nmethod(nmethod* nm) {
 691   ScavengableNMethods::unregister_nmethod(nm);
 692 }
 693 
 694 void GenCollectedHeap::verify_nmethod(nmethod* nm) {
 695   ScavengableNMethods::verify_nmethod(nm);
 696 }
 697 
 698 void GenCollectedHeap::flush_nmethod(nmethod* nm) {
 699   // Do nothing.
 700 }
 701 
 702 void GenCollectedHeap::prune_scavengable_nmethods() {
 703   ScavengableNMethods::prune_nmethods();
 704 }
 705 
 706 HeapWord* GenCollectedHeap::satisfy_failed_allocation(size_t size, bool is_tlab) {
 707   GCCauseSetter x(this, GCCause::_allocation_failure);
 708   HeapWord* result = NULL;
 709 
 710   assert(size != 0, &quot;Precondition violated&quot;);
 711   if (GCLocker::is_active_and_needs_gc()) {
 712     // GC locker is active; instead of a collection we will attempt
 713     // to expand the heap, if there&#39;s room for expansion.
 714     if (!is_maximal_no_gc()) {
 715       result = expand_heap_and_allocate(size, is_tlab);
 716     }
 717     return result;   // Could be null if we are out of space.
 718   } else if (!incremental_collection_will_fail(false /* don&#39;t consult_young */)) {
 719     // Do an incremental collection.
 720     do_collection(false,                     // full
 721                   false,                     // clear_all_soft_refs
 722                   size,                      // size
 723                   is_tlab,                   // is_tlab
 724                   GenCollectedHeap::OldGen); // max_generation
 725   } else {
 726     log_trace(gc)(&quot; :: Trying full because partial may fail :: &quot;);
 727     // Try a full collection; see delta for bug id 6266275
 728     // for the original code and why this has been simplified
 729     // with from-space allocation criteria modified and
 730     // such allocation moved out of the safepoint path.
 731     do_collection(true,                      // full
 732                   false,                     // clear_all_soft_refs
 733                   size,                      // size
 734                   is_tlab,                   // is_tlab
 735                   GenCollectedHeap::OldGen); // max_generation
 736   }
 737 
 738   result = attempt_allocation(size, is_tlab, false /*first_only*/);
 739 
 740   if (result != NULL) {
 741     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 742     return result;
 743   }
 744 
 745   // OK, collection failed, try expansion.
 746   result = expand_heap_and_allocate(size, is_tlab);
 747   if (result != NULL) {
 748     return result;
 749   }
 750 
 751   // If we reach this point, we&#39;re really out of memory. Try every trick
 752   // we can to reclaim memory. Force collection of soft references. Force
 753   // a complete compaction of the heap. Any additional methods for finding
 754   // free memory should be here, especially if they are expensive. If this
 755   // attempt fails, an OOM exception will be thrown.
 756   {
 757     UIntFlagSetting flag_change(MarkSweepAlwaysCompactCount, 1); // Make sure the heap is fully compacted
 758 
 759     do_collection(true,                      // full
 760                   true,                      // clear_all_soft_refs
 761                   size,                      // size
 762                   is_tlab,                   // is_tlab
 763                   GenCollectedHeap::OldGen); // max_generation
 764   }
 765 
 766   result = attempt_allocation(size, is_tlab, false /* first_only */);
 767   if (result != NULL) {
 768     assert(is_in_reserved(result), &quot;result not in heap&quot;);
 769     return result;
 770   }
 771 
 772   assert(!soft_ref_policy()-&gt;should_clear_all_soft_refs(),
 773     &quot;Flag should have been handled and cleared prior to this point&quot;);
 774 
 775   // What else?  We might try synchronous finalization later.  If the total
 776   // space available is large enough for the allocation, then a more
 777   // complete compaction phase than we&#39;ve tried so far might be
 778   // appropriate.
 779   return NULL;
 780 }
 781 
 782 #ifdef ASSERT
 783 class AssertNonScavengableClosure: public OopClosure {
 784 public:
 785   virtual void do_oop(oop* p) {
 786     assert(!GenCollectedHeap::heap()-&gt;is_in_partial_collection(*p),
 787       &quot;Referent should not be scavengable.&quot;);  }
 788   virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }
 789 };
 790 static AssertNonScavengableClosure assert_is_non_scavengable_closure;
 791 #endif
 792 
 793 void GenCollectedHeap::process_roots(StrongRootsScope* scope,
 794                                      ScanningOption so,
 795                                      OopClosure* strong_roots,
 796                                      CLDClosure* strong_cld_closure,
 797                                      CLDClosure* weak_cld_closure,
 798                                      CodeBlobToOopClosure* code_roots) {
 799   // General roots.
 800   assert(code_roots != NULL, &quot;code root closure should always be set&quot;);
 801   // _n_termination for _process_strong_tasks should be set up stream
 802   // in a method not running in a GC worker.  Otherwise the GC worker
 803   // could be trying to change the termination condition while the task
 804   // is executing in another GC worker.
 805 
 806   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ClassLoaderDataGraph_oops_do)) {
 807     ClassLoaderDataGraph::roots_cld_do(strong_cld_closure, weak_cld_closure);
 808   }
 809 
 810   // Only process code roots from thread stacks if we aren&#39;t visiting the entire CodeCache anyway
 811   CodeBlobToOopClosure* roots_from_code_p = (so &amp; SO_AllCodeCache) ? NULL : code_roots;
 812 
 813   bool is_par = scope-&gt;n_threads() &gt; 1;
 814   Threads::possibly_parallel_oops_do(is_par, strong_roots, roots_from_code_p);
 815 
 816   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Universe_oops_do)) {
 817     Universe::oops_do(strong_roots);
 818   }
 819   // Global (strong) JNI handles
 820   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_JNIHandles_oops_do)) {
 821     JNIHandles::oops_do(strong_roots);
 822   }
 823 
 824   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_ObjectSynchronizer_oops_do)) {
 825     ObjectSynchronizer::oops_do(strong_roots);
 826   }
 827   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_Management_oops_do)) {
 828     Management::oops_do(strong_roots);
 829   }
 830   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_jvmti_oops_do)) {
 831     JvmtiExport::oops_do(strong_roots);
 832   }
 833 #if INCLUDE_AOT
 834   if (UseAOT &amp;&amp; _process_strong_tasks-&gt;try_claim_task(GCH_PS_aot_oops_do)) {
 835     AOTLoader::oops_do(strong_roots);
 836   }
 837 #endif
 838   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_SystemDictionary_oops_do)) {
 839     SystemDictionary::oops_do(strong_roots);
 840   }
 841 
 842   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_CodeCache_oops_do)) {
 843     if (so &amp; SO_ScavengeCodeCache) {
 844       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 845 
 846       // We only visit parts of the CodeCache when scavenging.
 847       ScavengableNMethods::nmethods_do(code_roots);
 848     }
 849     if (so &amp; SO_AllCodeCache) {
 850       assert(code_roots != NULL, &quot;must supply closure for code cache&quot;);
 851 
 852       // CMSCollector uses this to do intermediate-strength collections.
 853       // We scan the entire code cache, since CodeCache::do_unloading is not called.
 854       CodeCache::blobs_do(code_roots);
 855     }
 856     // Verify that the code cache contents are not subject to
 857     // movement by a scavenging collection.
 858     DEBUG_ONLY(CodeBlobToOopClosure assert_code_is_non_scavengable(&amp;assert_is_non_scavengable_closure, !CodeBlobToOopClosure::FixRelocations));
 859     DEBUG_ONLY(ScavengableNMethods::asserted_non_scavengable_nmethods_do(&amp;assert_code_is_non_scavengable));
 860   }
 861 }
 862 
 863 void GenCollectedHeap::young_process_roots(StrongRootsScope* scope,
 864                                            OopsInGenClosure* root_closure,
 865                                            OopsInGenClosure* old_gen_closure,
 866                                            CLDClosure* cld_closure) {
 867   MarkingCodeBlobClosure mark_code_closure(root_closure, CodeBlobToOopClosure::FixRelocations);
 868 
 869   process_roots(scope, SO_ScavengeCodeCache, root_closure,
 870                 cld_closure, cld_closure, &amp;mark_code_closure);
 871 
 872   if (_process_strong_tasks-&gt;try_claim_task(GCH_PS_younger_gens)) {
 873     root_closure-&gt;reset_generation();
 874   }
 875 
 876   // When collection is parallel, all threads get to cooperate to do
 877   // old generation scanning.
 878   old_gen_closure-&gt;set_generation(_old_gen);
 879   rem_set()-&gt;younger_refs_iterate(_old_gen, old_gen_closure, scope-&gt;n_threads());
 880   old_gen_closure-&gt;reset_generation();
 881 
 882   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 883 }
 884 
 885 void GenCollectedHeap::full_process_roots(StrongRootsScope* scope,
 886                                           bool is_adjust_phase,
 887                                           ScanningOption so,
 888                                           bool only_strong_roots,
 889                                           OopsInGenClosure* root_closure,
 890                                           CLDClosure* cld_closure) {
 891   MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase);
 892   CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;
 893 
 894   process_roots(scope, so, root_closure, cld_closure, weak_cld_closure, &amp;mark_code_closure);
 895   _process_strong_tasks-&gt;all_tasks_completed(scope-&gt;n_threads());
 896 }
 897 
 898 void GenCollectedHeap::gen_process_weak_roots(OopClosure* root_closure) {
 899   WeakProcessor::oops_do(root_closure);
 900   _young_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 901   _old_gen-&gt;ref_processor()-&gt;weak_oops_do(root_closure);
 902 }
 903 
 904 bool GenCollectedHeap::no_allocs_since_save_marks() {
 905   return _young_gen-&gt;no_allocs_since_save_marks() &amp;&amp;
 906          _old_gen-&gt;no_allocs_since_save_marks();
 907 }
 908 
 909 bool GenCollectedHeap::supports_inline_contig_alloc() const {
 910   return _young_gen-&gt;supports_inline_contig_alloc();
 911 }
 912 
 913 HeapWord* volatile* GenCollectedHeap::top_addr() const {
 914   return _young_gen-&gt;top_addr();
 915 }
 916 
 917 HeapWord** GenCollectedHeap::end_addr() const {
 918   return _young_gen-&gt;end_addr();
 919 }
 920 
 921 // public collection interfaces
 922 
 923 void GenCollectedHeap::collect(GCCause::Cause cause) {
 924   if ((cause == GCCause::_wb_young_gc) ||
 925       (cause == GCCause::_gc_locker)) {
 926     // Young collection for WhiteBox or GCLocker.
 927     collect(cause, YoungGen);
 928   } else {
 929 #ifdef ASSERT
 930   if (cause == GCCause::_scavenge_alot) {
 931     // Young collection only.
 932     collect(cause, YoungGen);
 933   } else {
 934     // Stop-the-world full collection.
 935     collect(cause, OldGen);
 936   }
 937 #else
 938     // Stop-the-world full collection.
 939     collect(cause, OldGen);
 940 #endif
 941   }
 942 }
 943 
 944 void GenCollectedHeap::collect(GCCause::Cause cause, GenerationType max_generation) {
 945   // The caller doesn&#39;t have the Heap_lock
 946   assert(!Heap_lock-&gt;owned_by_self(), &quot;this thread should not own the Heap_lock&quot;);
 947   MutexLocker ml(Heap_lock);
 948   collect_locked(cause, max_generation);
 949 }
 950 
 951 void GenCollectedHeap::collect_locked(GCCause::Cause cause) {
 952   // The caller has the Heap_lock
 953   assert(Heap_lock-&gt;owned_by_self(), &quot;this thread should own the Heap_lock&quot;);
 954   collect_locked(cause, OldGen);
 955 }
 956 
 957 // this is the private collection interface
 958 // The Heap_lock is expected to be held on entry.
 959 
 960 void GenCollectedHeap::collect_locked(GCCause::Cause cause, GenerationType max_generation) {
 961   // Read the GC count while holding the Heap_lock
 962   unsigned int gc_count_before      = total_collections();
 963   unsigned int full_gc_count_before = total_full_collections();
 964 
 965   if (GCLocker::should_discard(cause, gc_count_before)) {
 966     return;
 967   }
 968 
 969   {
 970     MutexUnlocker mu(Heap_lock);  // give up heap lock, execute gets it back
 971     VM_GenCollectFull op(gc_count_before, full_gc_count_before,
 972                          cause, max_generation);
 973     VMThread::execute(&amp;op);
 974   }
 975 }
 976 
 977 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs) {
 978    do_full_collection(clear_all_soft_refs, OldGen);
 979 }
 980 
 981 void GenCollectedHeap::do_full_collection(bool clear_all_soft_refs,
 982                                           GenerationType last_generation) {
 983   do_collection(true,                   // full
 984                 clear_all_soft_refs,    // clear_all_soft_refs
 985                 0,                      // size
 986                 false,                  // is_tlab
 987                 last_generation);       // last_generation
 988   // Hack XXX FIX ME !!!
 989   // A scavenge may not have been attempted, or may have
 990   // been attempted and failed, because the old gen was too full
 991   if (gc_cause() == GCCause::_gc_locker &amp;&amp; incremental_collection_failed()) {
 992     log_debug(gc, jni)(&quot;GC locker: Trying a full collection because scavenge failed&quot;);
 993     // This time allow the old gen to be collected as well
 994     do_collection(true,                // full
 995                   clear_all_soft_refs, // clear_all_soft_refs
 996                   0,                   // size
 997                   false,               // is_tlab
 998                   OldGen);             // last_generation
 999   }
1000 }
1001 
1002 bool GenCollectedHeap::is_in_young(oop p) {
1003   bool result = cast_from_oop&lt;HeapWord*&gt;(p) &lt; _old_gen-&gt;reserved().start();
1004   assert(result == _young_gen-&gt;is_in_reserved(p),
1005          &quot;incorrect test - result=%d, p=&quot; INTPTR_FORMAT, result, p2i((void*)p));
1006   return result;
1007 }
1008 
1009 // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
1010 bool GenCollectedHeap::is_in(const void* p) const {
1011   return _young_gen-&gt;is_in(p) || _old_gen-&gt;is_in(p);
1012 }
1013 
1014 #ifdef ASSERT
1015 // Don&#39;t implement this by using is_in_young().  This method is used
1016 // in some cases to check that is_in_young() is correct.
1017 bool GenCollectedHeap::is_in_partial_collection(const void* p) {
1018   assert(is_in_reserved(p) || p == NULL,
1019     &quot;Does not work if address is non-null and outside of the heap&quot;);
1020   return p &lt; _young_gen-&gt;reserved().end() &amp;&amp; p != NULL;
1021 }
1022 #endif
1023 
1024 void GenCollectedHeap::oop_iterate(OopIterateClosure* cl) {
1025   _young_gen-&gt;oop_iterate(cl);
1026   _old_gen-&gt;oop_iterate(cl);
1027 }
1028 
1029 void GenCollectedHeap::object_iterate(ObjectClosure* cl) {
1030   _young_gen-&gt;object_iterate(cl);
1031   _old_gen-&gt;object_iterate(cl);
1032 }
1033 
1034 Space* GenCollectedHeap::space_containing(const void* addr) const {
1035   Space* res = _young_gen-&gt;space_containing(addr);
1036   if (res != NULL) {
1037     return res;
1038   }
1039   res = _old_gen-&gt;space_containing(addr);
1040   assert(res != NULL, &quot;Could not find containing space&quot;);
1041   return res;
1042 }
1043 
1044 HeapWord* GenCollectedHeap::block_start(const void* addr) const {
1045   assert(is_in_reserved(addr), &quot;block_start of address outside of heap&quot;);
1046   if (_young_gen-&gt;is_in_reserved(addr)) {
1047     assert(_young_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1048     return _young_gen-&gt;block_start(addr);
1049   }
1050 
1051   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1052   assert(_old_gen-&gt;is_in(addr), &quot;addr should be in allocated part of generation&quot;);
1053   return _old_gen-&gt;block_start(addr);
1054 }
1055 
1056 bool GenCollectedHeap::block_is_obj(const HeapWord* addr) const {
1057   assert(is_in_reserved(addr), &quot;block_is_obj of address outside of heap&quot;);
1058   assert(block_start(addr) == addr, &quot;addr must be a block start&quot;);
1059   if (_young_gen-&gt;is_in_reserved(addr)) {
1060     return _young_gen-&gt;block_is_obj(addr);
1061   }
1062 
1063   assert(_old_gen-&gt;is_in_reserved(addr), &quot;Some generation should contain the address&quot;);
1064   return _old_gen-&gt;block_is_obj(addr);
1065 }
1066 
1067 bool GenCollectedHeap::supports_tlab_allocation() const {
1068   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1069   return _young_gen-&gt;supports_tlab_allocation();
1070 }
1071 
1072 size_t GenCollectedHeap::tlab_capacity(Thread* thr) const {
1073   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1074   if (_young_gen-&gt;supports_tlab_allocation()) {
1075     return _young_gen-&gt;tlab_capacity();
1076   }
1077   return 0;
1078 }
1079 
1080 size_t GenCollectedHeap::tlab_used(Thread* thr) const {
1081   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1082   if (_young_gen-&gt;supports_tlab_allocation()) {
1083     return _young_gen-&gt;tlab_used();
1084   }
1085   return 0;
1086 }
1087 
1088 size_t GenCollectedHeap::unsafe_max_tlab_alloc(Thread* thr) const {
1089   assert(!_old_gen-&gt;supports_tlab_allocation(), &quot;Old gen supports TLAB allocation?!&quot;);
1090   if (_young_gen-&gt;supports_tlab_allocation()) {
1091     return _young_gen-&gt;unsafe_max_tlab_alloc();
1092   }
1093   return 0;
1094 }
1095 
1096 HeapWord* GenCollectedHeap::allocate_new_tlab(size_t min_size,
1097                                               size_t requested_size,
1098                                               size_t* actual_size) {
1099   bool gc_overhead_limit_was_exceeded;
1100   HeapWord* result = mem_allocate_work(requested_size /* size */,
1101                                        true /* is_tlab */,
1102                                        &amp;gc_overhead_limit_was_exceeded);
1103   if (result != NULL) {
1104     *actual_size = requested_size;
1105   }
1106 
1107   return result;
1108 }
1109 
1110 // Requires &quot;*prev_ptr&quot; to be non-NULL.  Deletes and a block of minimal size
1111 // from the list headed by &quot;*prev_ptr&quot;.
1112 static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {
1113   bool first = true;
1114   size_t min_size = 0;   // &quot;first&quot; makes this conceptually infinite.
1115   ScratchBlock **smallest_ptr, *smallest;
1116   ScratchBlock  *cur = *prev_ptr;
1117   while (cur) {
1118     assert(*prev_ptr == cur, &quot;just checking&quot;);
1119     if (first || cur-&gt;num_words &lt; min_size) {
1120       smallest_ptr = prev_ptr;
1121       smallest     = cur;
1122       min_size     = smallest-&gt;num_words;
1123       first        = false;
1124     }
1125     prev_ptr = &amp;cur-&gt;next;
1126     cur     =  cur-&gt;next;
1127   }
1128   smallest      = *smallest_ptr;
1129   *smallest_ptr = smallest-&gt;next;
1130   return smallest;
1131 }
1132 
1133 // Sort the scratch block list headed by res into decreasing size order,
1134 // and set &quot;res&quot; to the result.
1135 static void sort_scratch_list(ScratchBlock*&amp; list) {
1136   ScratchBlock* sorted = NULL;
1137   ScratchBlock* unsorted = list;
1138   while (unsorted) {
1139     ScratchBlock *smallest = removeSmallestScratch(&amp;unsorted);
1140     smallest-&gt;next  = sorted;
1141     sorted          = smallest;
1142   }
1143   list = sorted;
1144 }
1145 
1146 ScratchBlock* GenCollectedHeap::gather_scratch(Generation* requestor,
1147                                                size_t max_alloc_words) {
1148   ScratchBlock* res = NULL;
1149   _young_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1150   _old_gen-&gt;contribute_scratch(res, requestor, max_alloc_words);
1151   sort_scratch_list(res);
1152   return res;
1153 }
1154 
1155 void GenCollectedHeap::release_scratch() {
1156   _young_gen-&gt;reset_scratch();
1157   _old_gen-&gt;reset_scratch();
1158 }
1159 
1160 class GenPrepareForVerifyClosure: public GenCollectedHeap::GenClosure {
1161   void do_generation(Generation* gen) {
1162     gen-&gt;prepare_for_verify();
1163   }
1164 };
1165 
1166 void GenCollectedHeap::prepare_for_verify() {
1167   ensure_parsability(false);        // no need to retire TLABs
1168   GenPrepareForVerifyClosure blk;
1169   generation_iterate(&amp;blk, false);
1170 }
1171 
1172 void GenCollectedHeap::generation_iterate(GenClosure* cl,
1173                                           bool old_to_young) {
1174   if (old_to_young) {
1175     cl-&gt;do_generation(_old_gen);
1176     cl-&gt;do_generation(_young_gen);
1177   } else {
1178     cl-&gt;do_generation(_young_gen);
1179     cl-&gt;do_generation(_old_gen);
1180   }
1181 }
1182 
1183 bool GenCollectedHeap::is_maximal_no_gc() const {
1184   return _young_gen-&gt;is_maximal_no_gc() &amp;&amp; _old_gen-&gt;is_maximal_no_gc();
1185 }
1186 
1187 void GenCollectedHeap::save_marks() {
1188   _young_gen-&gt;save_marks();
1189   _old_gen-&gt;save_marks();
1190 }
1191 
1192 GenCollectedHeap* GenCollectedHeap::heap() {
1193   CollectedHeap* heap = Universe::heap();
1194   assert(heap != NULL, &quot;Uninitialized access to GenCollectedHeap::heap()&quot;);
1195   assert(heap-&gt;kind() == CollectedHeap::Serial, &quot;Invalid name&quot;);
1196   return (GenCollectedHeap*) heap;
1197 }
1198 
1199 #if INCLUDE_SERIALGC
1200 void GenCollectedHeap::prepare_for_compaction() {
1201   // Start by compacting into same gen.
1202   CompactPoint cp(_old_gen);
1203   _old_gen-&gt;prepare_for_compaction(&amp;cp);
1204   _young_gen-&gt;prepare_for_compaction(&amp;cp);
1205 }
1206 #endif // INCLUDE_SERIALGC
1207 
1208 void GenCollectedHeap::verify(VerifyOption option /* ignored */) {
1209   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1210   _old_gen-&gt;verify();
1211 
1212   log_debug(gc, verify)(&quot;%s&quot;, _old_gen-&gt;name());
1213   _young_gen-&gt;verify();
1214 
1215   log_debug(gc, verify)(&quot;RemSet&quot;);
1216   rem_set()-&gt;verify();
1217 }
1218 
1219 void GenCollectedHeap::print_on(outputStream* st) const {
1220   _young_gen-&gt;print_on(st);
1221   _old_gen-&gt;print_on(st);
1222   MetaspaceUtils::print_on(st);
1223 }
1224 
1225 void GenCollectedHeap::gc_threads_do(ThreadClosure* tc) const {
1226 }
1227 
1228 void GenCollectedHeap::print_gc_threads_on(outputStream* st) const {
1229 }
1230 
1231 bool GenCollectedHeap::print_location(outputStream* st, void* addr) const {
1232   return BlockLocationPrinter&lt;GenCollectedHeap&gt;::print_location(st, addr);
1233 }
1234 
1235 void GenCollectedHeap::print_tracing_info() const {
1236   if (log_is_enabled(Debug, gc, heap, exit)) {
1237     LogStreamHandle(Debug, gc, heap, exit) lsh;
1238     _young_gen-&gt;print_summary_info_on(&amp;lsh);
1239     _old_gen-&gt;print_summary_info_on(&amp;lsh);
1240   }
1241 }
1242 
1243 void GenCollectedHeap::print_heap_change(const PreGenGCValues&amp; pre_gc_values) const {
1244   const DefNewGeneration* const def_new_gen = (DefNewGeneration*) young_gen();
1245 
1246   log_info(gc, heap)(HEAP_CHANGE_FORMAT&quot; &quot;
1247                      HEAP_CHANGE_FORMAT&quot; &quot;
1248                      HEAP_CHANGE_FORMAT,
1249                      HEAP_CHANGE_FORMAT_ARGS(def_new_gen-&gt;short_name(),
1250                                              pre_gc_values.young_gen_used(),
1251                                              pre_gc_values.young_gen_capacity(),
1252                                              def_new_gen-&gt;used(),
1253                                              def_new_gen-&gt;capacity()),
1254                      HEAP_CHANGE_FORMAT_ARGS(&quot;Eden&quot;,
1255                                              pre_gc_values.eden_used(),
1256                                              pre_gc_values.eden_capacity(),
1257                                              def_new_gen-&gt;eden()-&gt;used(),
1258                                              def_new_gen-&gt;eden()-&gt;capacity()),
1259                      HEAP_CHANGE_FORMAT_ARGS(&quot;From&quot;,
1260                                              pre_gc_values.from_used(),
1261                                              pre_gc_values.from_capacity(),
1262                                              def_new_gen-&gt;from()-&gt;used(),
1263                                              def_new_gen-&gt;from()-&gt;capacity()));
1264   log_info(gc, heap)(HEAP_CHANGE_FORMAT,
1265                      HEAP_CHANGE_FORMAT_ARGS(old_gen()-&gt;short_name(),
1266                                              pre_gc_values.old_gen_used(),
1267                                              pre_gc_values.old_gen_capacity(),
1268                                              old_gen()-&gt;used(),
1269                                              old_gen()-&gt;capacity()));
1270   MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());
1271 }
1272 
1273 class GenGCPrologueClosure: public GenCollectedHeap::GenClosure {
1274  private:
1275   bool _full;
1276  public:
1277   void do_generation(Generation* gen) {
1278     gen-&gt;gc_prologue(_full);
1279   }
1280   GenGCPrologueClosure(bool full) : _full(full) {};
1281 };
1282 
1283 void GenCollectedHeap::gc_prologue(bool full) {
1284   assert(InlineCacheBuffer::is_empty(), &quot;should have cleaned up ICBuffer&quot;);
1285 
1286   // Fill TLAB&#39;s and such
1287   ensure_parsability(true);   // retire TLABs
1288 
1289   // Walk generations
1290   GenGCPrologueClosure blk(full);
1291   generation_iterate(&amp;blk, false);  // not old-to-young.
1292 };
1293 
1294 class GenGCEpilogueClosure: public GenCollectedHeap::GenClosure {
1295  private:
1296   bool _full;
1297  public:
1298   void do_generation(Generation* gen) {
1299     gen-&gt;gc_epilogue(_full);
1300   }
1301   GenGCEpilogueClosure(bool full) : _full(full) {};
1302 };
1303 
1304 void GenCollectedHeap::gc_epilogue(bool full) {
1305 #if COMPILER2_OR_JVMCI
1306   assert(DerivedPointerTable::is_empty(), &quot;derived pointer present&quot;);
1307   size_t actual_gap = pointer_delta((HeapWord*) (max_uintx-3), *(end_addr()));
1308   guarantee(is_client_compilation_mode_vm() || actual_gap &gt; (size_t)FastAllocateSizeLimit, &quot;inline allocation wraps&quot;);
1309 #endif // COMPILER2_OR_JVMCI
1310 
1311   resize_all_tlabs();
1312 
1313   GenGCEpilogueClosure blk(full);
1314   generation_iterate(&amp;blk, false);  // not old-to-young.
1315 
1316   if (!CleanChunkPoolAsync) {
1317     Chunk::clean_chunk_pool();
1318   }
1319 
1320   MetaspaceCounters::update_performance_counters();
1321   CompressedClassSpaceCounters::update_performance_counters();
1322 };
1323 
1324 #ifndef PRODUCT
1325 class GenGCSaveTopsBeforeGCClosure: public GenCollectedHeap::GenClosure {
1326  private:
1327  public:
1328   void do_generation(Generation* gen) {
1329     gen-&gt;record_spaces_top();
1330   }
1331 };
1332 
1333 void GenCollectedHeap::record_gen_tops_before_GC() {
1334   if (ZapUnusedHeapArea) {
1335     GenGCSaveTopsBeforeGCClosure blk;
1336     generation_iterate(&amp;blk, false);  // not old-to-young.
1337   }
1338 }
1339 #endif  // not PRODUCT
1340 
1341 class GenEnsureParsabilityClosure: public GenCollectedHeap::GenClosure {
1342  public:
1343   void do_generation(Generation* gen) {
1344     gen-&gt;ensure_parsability();
1345   }
1346 };
1347 
1348 void GenCollectedHeap::ensure_parsability(bool retire_tlabs) {
1349   CollectedHeap::ensure_parsability(retire_tlabs);
1350   GenEnsureParsabilityClosure ep_cl;
1351   generation_iterate(&amp;ep_cl, false);
1352 }
1353 
1354 oop GenCollectedHeap::handle_failed_promotion(Generation* old_gen,
1355                                               oop obj,
1356                                               size_t obj_size) {
1357   guarantee(old_gen == _old_gen, &quot;We only get here with an old generation&quot;);
1358   assert(obj_size == (size_t)obj-&gt;size(), &quot;bad obj_size passed in&quot;);
1359   HeapWord* result = NULL;
1360 
1361   result = old_gen-&gt;expand_and_allocate(obj_size, false);
1362 
1363   if (result != NULL) {
1364     Copy::aligned_disjoint_words(cast_from_oop&lt;HeapWord*&gt;(obj), result, obj_size);
1365   }
1366   return oop(result);
1367 }
1368 
1369 class GenTimeOfLastGCClosure: public GenCollectedHeap::GenClosure {
1370   jlong _time;   // in ms
1371   jlong _now;    // in ms
1372 
1373  public:
1374   GenTimeOfLastGCClosure(jlong now) : _time(now), _now(now) { }
1375 
1376   jlong time() { return _time; }
1377 
1378   void do_generation(Generation* gen) {
1379     _time = MIN2(_time, gen-&gt;time_of_last_gc(_now));
1380   }
1381 };
1382 
1383 jlong GenCollectedHeap::millis_since_last_gc() {
1384   // javaTimeNanos() is guaranteed to be monotonically non-decreasing
1385   // provided the underlying platform provides such a time source
1386   // (and it is bug free). So we still have to guard against getting
1387   // back a time later than &#39;now&#39;.
1388   jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
1389   GenTimeOfLastGCClosure tolgc_cl(now);
1390   // iterate over generations getting the oldest
1391   // time that a generation was collected
1392   generation_iterate(&amp;tolgc_cl, false);
1393 
1394   jlong retVal = now - tolgc_cl.time();
1395   if (retVal &lt; 0) {
1396     log_warning(gc)(&quot;millis_since_last_gc() would return : &quot; JLONG_FORMAT
1397        &quot;. returning zero instead.&quot;, retVal);
1398     return 0;
1399   }
1400   return retVal;
1401 }
    </pre>
  </body>
</html>