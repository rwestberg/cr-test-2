<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/javaAssertions.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;gc/shared/gcArguments.hpp&quot;
  33 #include &quot;gc/shared/gcConfig.hpp&quot;
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;logging/logConfiguration.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;logging/logTag.hpp&quot;
  38 #include &quot;memory/allocation.inline.hpp&quot;
  39 #include &quot;memory/filemap.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
  41 #include &quot;prims/jvmtiExport.hpp&quot;
  42 #include &quot;runtime/arguments.hpp&quot;
  43 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  44 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  45 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  46 #include &quot;runtime/globals_extension.hpp&quot;
  47 #include &quot;runtime/java.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/safepoint.hpp&quot;
  50 #include &quot;runtime/safepointMechanism.hpp&quot;
  51 #include &quot;runtime/vm_version.hpp&quot;
  52 #include &quot;services/management.hpp&quot;
  53 #include &quot;services/memTracker.hpp&quot;
  54 #include &quot;utilities/align.hpp&quot;
  55 #include &quot;utilities/defaultStream.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
  57 #include &quot;utilities/stringUtils.hpp&quot;
  58 #if INCLUDE_JFR
  59 #include &quot;jfr/jfr.hpp&quot;
  60 #endif
  61 
  62 #define DEFAULT_JAVA_LAUNCHER  &quot;generic&quot;
  63 
  64 char*  Arguments::_jvm_flags_file               = NULL;
  65 char** Arguments::_jvm_flags_array              = NULL;
  66 int    Arguments::_num_jvm_flags                = 0;
  67 char** Arguments::_jvm_args_array               = NULL;
  68 int    Arguments::_num_jvm_args                 = 0;
  69 char*  Arguments::_java_command                 = NULL;
  70 SystemProperty* Arguments::_system_properties   = NULL;
  71 const char*  Arguments::_gc_log_filename        = NULL;
  72 size_t Arguments::_conservative_max_heap_alignment = 0;
  73 Arguments::Mode Arguments::_mode                = _mixed;
  74 bool   Arguments::_java_compiler                = false;
  75 bool   Arguments::_xdebug_mode                  = false;
  76 const char*  Arguments::_java_vendor_url_bug    = NULL;
  77 const char*  Arguments::_sun_java_launcher      = DEFAULT_JAVA_LAUNCHER;
  78 bool   Arguments::_sun_java_launcher_is_altjvm  = false;
  79 
  80 // These parameters are reset in method parse_vm_init_args()
  81 bool   Arguments::_AlwaysCompileLoopMethods     = AlwaysCompileLoopMethods;
  82 bool   Arguments::_UseOnStackReplacement        = UseOnStackReplacement;
  83 bool   Arguments::_BackgroundCompilation        = BackgroundCompilation;
  84 bool   Arguments::_ClipInlining                 = ClipInlining;
  85 intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;
  86 intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;
  87 size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;
  88 
  89 bool   Arguments::_enable_preview               = false;
  90 
  91 char*  Arguments::SharedArchivePath             = NULL;
  92 char*  Arguments::SharedDynamicArchivePath      = NULL;
  93 
  94 AgentLibraryList Arguments::_libraryList;
  95 AgentLibraryList Arguments::_agentList;
  96 
  97 // These are not set by the JDK&#39;s built-in launchers, but they can be set by
  98 // programs that embed the JVM using JNI_CreateJavaVM. See comments around
  99 // JavaVMOption in jni.h.
 100 abort_hook_t     Arguments::_abort_hook         = NULL;
 101 exit_hook_t      Arguments::_exit_hook          = NULL;
 102 vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;
 103 
 104 
 105 SystemProperty *Arguments::_sun_boot_library_path = NULL;
 106 SystemProperty *Arguments::_java_library_path = NULL;
 107 SystemProperty *Arguments::_java_home = NULL;
 108 SystemProperty *Arguments::_java_class_path = NULL;
 109 SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;
 110 SystemProperty *Arguments::_vm_info = NULL;
 111 
 112 GrowableArray&lt;ModulePatchPath*&gt; *Arguments::_patch_mod_prefix = NULL;
 113 PathString *Arguments::_system_boot_class_path = NULL;
 114 bool Arguments::_has_jimage = false;
 115 
 116 char* Arguments::_ext_dirs = NULL;
 117 
 118 bool PathString::set_value(const char *value) {
 119   if (_value != NULL) {
 120     FreeHeap(_value);
 121   }
 122   _value = AllocateHeap(strlen(value)+1, mtArguments);
 123   assert(_value != NULL, &quot;Unable to allocate space for new path value&quot;);
 124   if (_value != NULL) {
 125     strcpy(_value, value);
 126   } else {
 127     // not able to allocate
 128     return false;
 129   }
 130   return true;
 131 }
 132 
 133 void PathString::append_value(const char *value) {
 134   char *sp;
 135   size_t len = 0;
 136   if (value != NULL) {
 137     len = strlen(value);
 138     if (_value != NULL) {
 139       len += strlen(_value);
 140     }
 141     sp = AllocateHeap(len+2, mtArguments);
 142     assert(sp != NULL, &quot;Unable to allocate space for new append path value&quot;);
 143     if (sp != NULL) {
 144       if (_value != NULL) {
 145         strcpy(sp, _value);
 146         strcat(sp, os::path_separator());
 147         strcat(sp, value);
 148         FreeHeap(_value);
 149       } else {
 150         strcpy(sp, value);
 151       }
 152       _value = sp;
 153     }
 154   }
 155 }
 156 
 157 PathString::PathString(const char* value) {
 158   if (value == NULL) {
 159     _value = NULL;
 160   } else {
 161     _value = AllocateHeap(strlen(value)+1, mtArguments);
 162     strcpy(_value, value);
 163   }
 164 }
 165 
 166 PathString::~PathString() {
 167   if (_value != NULL) {
 168     FreeHeap(_value);
 169     _value = NULL;
 170   }
 171 }
 172 
 173 ModulePatchPath::ModulePatchPath(const char* module_name, const char* path) {
 174   assert(module_name != NULL &amp;&amp; path != NULL, &quot;Invalid module name or path value&quot;);
 175   size_t len = strlen(module_name) + 1;
 176   _module_name = AllocateHeap(len, mtInternal);
 177   strncpy(_module_name, module_name, len); // copy the trailing null
 178   _path =  new PathString(path);
 179 }
 180 
 181 ModulePatchPath::~ModulePatchPath() {
 182   if (_module_name != NULL) {
 183     FreeHeap(_module_name);
 184     _module_name = NULL;
 185   }
 186   if (_path != NULL) {
 187     delete _path;
 188     _path = NULL;
 189   }
 190 }
 191 
 192 SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal) : PathString(value) {
 193   if (key == NULL) {
 194     _key = NULL;
 195   } else {
 196     _key = AllocateHeap(strlen(key)+1, mtArguments);
 197     strcpy(_key, key);
 198   }
 199   _next = NULL;
 200   _internal = internal;
 201   _writeable = writeable;
 202 }
 203 
 204 AgentLibrary::AgentLibrary(const char* name, const char* options,
 205                bool is_absolute_path, void* os_lib,
 206                bool instrument_lib) {
 207   _name = AllocateHeap(strlen(name)+1, mtArguments);
 208   strcpy(_name, name);
 209   if (options == NULL) {
 210     _options = NULL;
 211   } else {
 212     _options = AllocateHeap(strlen(options)+1, mtArguments);
 213     strcpy(_options, options);
 214   }
 215   _is_absolute_path = is_absolute_path;
 216   _os_lib = os_lib;
 217   _next = NULL;
 218   _state = agent_invalid;
 219   _is_static_lib = false;
 220   _is_instrument_lib = instrument_lib;
 221 }
 222 
 223 // Check if head of &#39;option&#39; matches &#39;name&#39;, and sets &#39;tail&#39; to the remaining
 224 // part of the option string.
 225 static bool match_option(const JavaVMOption *option, const char* name,
 226                          const char** tail) {
 227   size_t len = strlen(name);
 228   if (strncmp(option-&gt;optionString, name, len) == 0) {
 229     *tail = option-&gt;optionString + len;
 230     return true;
 231   } else {
 232     return false;
 233   }
 234 }
 235 
 236 // Check if &#39;option&#39; matches &#39;name&#39;. No &quot;tail&quot; is allowed.
 237 static bool match_option(const JavaVMOption *option, const char* name) {
 238   const char* tail = NULL;
 239   bool result = match_option(option, name, &amp;tail);
 240   if (tail != NULL &amp;&amp; *tail == &#39;\0&#39;) {
 241     return result;
 242   } else {
 243     return false;
 244   }
 245 }
 246 
 247 // Return true if any of the strings in null-terminated array &#39;names&#39; matches.
 248 // If tail_allowed is true, then the tail must begin with a colon; otherwise,
 249 // the option must match exactly.
 250 static bool match_option(const JavaVMOption* option, const char** names, const char** tail,
 251   bool tail_allowed) {
 252   for (/* empty */; *names != NULL; ++names) {
 253   if (match_option(option, *names, tail)) {
 254       if (**tail == &#39;\0&#39; || (tail_allowed &amp;&amp; **tail == &#39;:&#39;)) {
 255         return true;
 256       }
 257     }
 258   }
 259   return false;
 260 }
 261 
 262 #if INCLUDE_JFR
 263 static bool _has_jfr_option = false;  // is using JFR
 264 
 265 // return true on failure
 266 static bool match_jfr_option(const JavaVMOption** option) {
 267   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
 268   char* tail = NULL;
 269   if (match_option(*option, &quot;-XX:StartFlightRecording&quot;, (const char**)&amp;tail)) {
 270     _has_jfr_option = true;
 271     return Jfr::on_start_flight_recording_option(option, tail);
 272   } else if (match_option(*option, &quot;-XX:FlightRecorderOptions&quot;, (const char**)&amp;tail)) {
 273     _has_jfr_option = true;
 274     return Jfr::on_flight_recorder_option(option, tail);
 275   }
 276   return false;
 277 }
 278 
 279 bool Arguments::has_jfr_option() {
 280   return _has_jfr_option;
 281 }
 282 #endif
 283 
 284 static void logOption(const char* opt) {
 285   if (PrintVMOptions) {
 286     jio_fprintf(defaultStream::output_stream(), &quot;VM option &#39;%s&#39;\n&quot;, opt);
 287   }
 288 }
 289 
 290 bool needs_module_property_warning = false;
 291 
 292 #define MODULE_PROPERTY_PREFIX &quot;jdk.module.&quot;
 293 #define MODULE_PROPERTY_PREFIX_LEN 11
 294 #define ADDEXPORTS &quot;addexports&quot;
 295 #define ADDEXPORTS_LEN 10
 296 #define ADDREADS &quot;addreads&quot;
 297 #define ADDREADS_LEN 8
 298 #define ADDOPENS &quot;addopens&quot;
 299 #define ADDOPENS_LEN 8
 300 #define PATCH &quot;patch&quot;
 301 #define PATCH_LEN 5
 302 #define ADDMODS &quot;addmods&quot;
 303 #define ADDMODS_LEN 7
 304 #define LIMITMODS &quot;limitmods&quot;
 305 #define LIMITMODS_LEN 9
 306 #define PATH &quot;path&quot;
 307 #define PATH_LEN 4
 308 #define UPGRADE_PATH &quot;upgrade.path&quot;
 309 #define UPGRADE_PATH_LEN 12
 310 
 311 void Arguments::add_init_library(const char* name, char* options) {
 312   _libraryList.add(new AgentLibrary(name, options, false, NULL));
 313 }
 314 
 315 void Arguments::add_init_agent(const char* name, char* options, bool absolute_path) {
 316   _agentList.add(new AgentLibrary(name, options, absolute_path, NULL));
 317 }
 318 
 319 void Arguments::add_instrument_agent(const char* name, char* options, bool absolute_path) {
 320   _agentList.add(new AgentLibrary(name, options, absolute_path, NULL, true));
 321 }
 322 
 323 // Late-binding agents not started via arguments
 324 void Arguments::add_loaded_agent(AgentLibrary *agentLib) {
 325   _agentList.add(agentLib);
 326 }
 327 
 328 // Return TRUE if option matches &#39;property&#39;, or &#39;property=&#39;, or &#39;property.&#39;.
 329 static bool matches_property_suffix(const char* option, const char* property, size_t len) {
 330   return ((strncmp(option, property, len) == 0) &amp;&amp;
 331           (option[len] == &#39;=&#39; || option[len] == &#39;.&#39; || option[len] == &#39;\0&#39;));
 332 }
 333 
 334 // Return true if property starts with &quot;jdk.module.&quot; and its ensuing chars match
 335 // any of the reserved module properties.
 336 // property should be passed without the leading &quot;-D&quot;.
 337 bool Arguments::is_internal_module_property(const char* property) {
 338   assert((strncmp(property, &quot;-D&quot;, 2) != 0), &quot;Unexpected leading -D&quot;);
 339   if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {
 340     const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;
 341     if (matches_property_suffix(property_suffix, ADDEXPORTS, ADDEXPORTS_LEN) ||
 342         matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||
 343         matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||
 344         matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||
 345         matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||
 346         matches_property_suffix(property_suffix, LIMITMODS, LIMITMODS_LEN) ||
 347         matches_property_suffix(property_suffix, PATH, PATH_LEN) ||
 348         matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {
 349       return true;
 350     }
 351   }
 352   return false;
 353 }
 354 
 355 // Process java launcher properties.
 356 void Arguments::process_sun_java_launcher_properties(JavaVMInitArgs* args) {
 357   // See if sun.java.launcher or sun.java.launcher.is_altjvm is defined.
 358   // Must do this before setting up other system properties,
 359   // as some of them may depend on launcher type.
 360   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
 361     const JavaVMOption* option = args-&gt;options + index;
 362     const char* tail;
 363 
 364     if (match_option(option, &quot;-Dsun.java.launcher=&quot;, &amp;tail)) {
 365       process_java_launcher_argument(tail, option-&gt;extraInfo);
 366       continue;
 367     }
 368     if (match_option(option, &quot;-Dsun.java.launcher.is_altjvm=&quot;, &amp;tail)) {
 369       if (strcmp(tail, &quot;true&quot;) == 0) {
 370         _sun_java_launcher_is_altjvm = true;
 371       }
 372       continue;
 373     }
 374   }
 375 }
 376 
 377 // Initialize system properties key and value.
 378 void Arguments::init_system_properties() {
 379 
 380   // Set up _system_boot_class_path which is not a property but
 381   // relies heavily on argument processing and the jdk.boot.class.path.append
 382   // property. It is used to store the underlying system boot class path.
 383   _system_boot_class_path = new PathString(NULL);
 384 
 385   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.specification.name&quot;,
 386                                                            &quot;Java Virtual Machine Specification&quot;,  false));
 387   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.version&quot;, VM_Version::vm_release(),  false));
 388   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;java.vm.name&quot;, VM_Version::vm_name(),  false));
 389   PropertyList_add(&amp;_system_properties, new SystemProperty(&quot;jdk.debug&quot;, VM_Version::jdk_debug_level(),  false));
 390 
 391   // Initialize the vm.info now, but it will need updating after argument parsing.
 392   _vm_info = new SystemProperty(&quot;java.vm.info&quot;, VM_Version::vm_info_string(), true);
 393 
 394   // Following are JVMTI agent writable properties.
 395   // Properties values are set to NULL and they are
 396   // os specific they are initialized in os::init_system_properties_values().
 397   _sun_boot_library_path = new SystemProperty(&quot;sun.boot.library.path&quot;, NULL,  true);
 398   _java_library_path = new SystemProperty(&quot;java.library.path&quot;, NULL,  true);
 399   _java_home =  new SystemProperty(&quot;java.home&quot;, NULL,  true);
 400   _java_class_path = new SystemProperty(&quot;java.class.path&quot;, &quot;&quot;,  true);
 401   // jdk.boot.class.path.append is a non-writeable, internal property.
 402   // It can only be set by either:
 403   //    - -Xbootclasspath/a:
 404   //    - AddToBootstrapClassLoaderSearch during JVMTI OnLoad phase
 405   _jdk_boot_class_path_append = new SystemProperty(&quot;jdk.boot.class.path.append&quot;, &quot;&quot;, false, true);
 406 
 407   // Add to System Property list.
 408   PropertyList_add(&amp;_system_properties, _sun_boot_library_path);
 409   PropertyList_add(&amp;_system_properties, _java_library_path);
 410   PropertyList_add(&amp;_system_properties, _java_home);
 411   PropertyList_add(&amp;_system_properties, _java_class_path);
 412   PropertyList_add(&amp;_system_properties, _jdk_boot_class_path_append);
 413   PropertyList_add(&amp;_system_properties, _vm_info);
 414 
 415   // Set OS specific system properties values
 416   os::init_system_properties_values();
 417 }
 418 
 419 // Update/Initialize System properties after JDK version number is known
 420 void Arguments::init_version_specific_system_properties() {
 421   enum { bufsz = 16 };
 422   char buffer[bufsz];
 423   const char* spec_vendor = &quot;Oracle Corporation&quot;;
 424   uint32_t spec_version = JDK_Version::current().major_version();
 425 
 426   jio_snprintf(buffer, bufsz, UINT32_FORMAT, spec_version);
 427 
 428   PropertyList_add(&amp;_system_properties,
 429       new SystemProperty(&quot;java.vm.specification.vendor&quot;,  spec_vendor, false));
 430   PropertyList_add(&amp;_system_properties,
 431       new SystemProperty(&quot;java.vm.specification.version&quot;, buffer, false));
 432   PropertyList_add(&amp;_system_properties,
 433       new SystemProperty(&quot;java.vm.vendor&quot;, VM_Version::vm_vendor(),  false));
 434 }
 435 
 436 /*
 437  *  -XX argument processing:
 438  *
 439  *  -XX arguments are defined in several places, such as:
 440  *      globals.hpp, globals_&lt;cpu&gt;.hpp, globals_&lt;os&gt;.hpp, &lt;compiler&gt;_globals.hpp, or &lt;gc&gt;_globals.hpp.
 441  *  -XX arguments are parsed in parse_argument().
 442  *  -XX argument bounds checking is done in check_vm_args_consistency().
 443  *
 444  * Over time -XX arguments may change. There are mechanisms to handle common cases:
 445  *
 446  *      ALIASED: An option that is simply another name for another option. This is often
 447  *               part of the process of deprecating a flag, but not all aliases need
 448  *               to be deprecated.
 449  *
 450  *               Create an alias for an option by adding the old and new option names to the
 451  *               &quot;aliased_jvm_flags&quot; table. Delete the old variable from globals.hpp (etc).
 452  *
 453  *   DEPRECATED: An option that is supported, but a warning is printed to let the user know that
 454  *               support may be removed in the future. Both regular and aliased options may be
 455  *               deprecated.
 456  *
 457  *               Add a deprecation warning for an option (or alias) by adding an entry in the
 458  *               &quot;special_jvm_flags&quot; table and setting the &quot;deprecated_in&quot; field.
 459  *               Often an option &quot;deprecated&quot; in one major release will
 460  *               be made &quot;obsolete&quot; in the next. In this case the entry should also have its
 461  *               &quot;obsolete_in&quot; field set.
 462  *
 463  *     OBSOLETE: An option that has been removed (and deleted from globals.hpp), but is still accepted
 464  *               on the command line. A warning is printed to let the user know that option might not
 465  *               be accepted in the future.
 466  *
 467  *               Add an obsolete warning for an option by adding an entry in the &quot;special_jvm_flags&quot;
 468  *               table and setting the &quot;obsolete_in&quot; field.
 469  *
 470  *      EXPIRED: A deprecated or obsolete option that has an &quot;accept_until&quot; version less than or equal
 471  *               to the current JDK version. The system will flatly refuse to admit the existence of
 472  *               the flag. This allows a flag to die automatically over JDK releases.
 473  *
 474  *               Note that manual cleanup of expired options should be done at major JDK version upgrades:
 475  *                  - Newly expired options should be removed from the special_jvm_flags and aliased_jvm_flags tables.
 476  *                  - Newly obsolete or expired deprecated options should have their global variable
 477  *                    definitions removed (from globals.hpp, etc) and related implementations removed.
 478  *
 479  * Recommended approach for removing options:
 480  *
 481  * To remove options commonly used by customers (e.g. product -XX options), use
 482  * the 3-step model adding major release numbers to the deprecate, obsolete and expire columns.
 483  *
 484  * To remove internal options (e.g. diagnostic, experimental, develop options), use
 485  * a 2-step model adding major release numbers to the obsolete and expire columns.
 486  *
 487  * To change the name of an option, use the alias table as well as a 2-step
 488  * model adding major release numbers to the deprecate and expire columns.
 489  * Think twice about aliasing commonly used customer options.
 490  *
 491  * There are times when it is appropriate to leave a future release number as undefined.
 492  *
 493  * Tests:  Aliases should be tested in VMAliasOptions.java.
 494  *         Deprecated options should be tested in VMDeprecatedOptions.java.
 495  */
 496 
 497 // The special_jvm_flags table declares options that are being deprecated and/or obsoleted. The
 498 // &quot;deprecated_in&quot; or &quot;obsolete_in&quot; fields may be set to &quot;undefined&quot;, but not both.
 499 // When the JDK version reaches &#39;deprecated_in&#39; limit, the JVM will process this flag on
 500 // the command-line as usual, but will issue a warning.
 501 // When the JDK version reaches &#39;obsolete_in&#39; limit, the JVM will continue accepting this flag on
 502 // the command-line, while issuing a warning and ignoring the flag value.
 503 // Once the JDK version reaches &#39;expired_in&#39; limit, the JVM will flatly refuse to admit the
 504 // existence of the flag.
 505 //
 506 // MANUAL CLEANUP ON JDK VERSION UPDATES:
 507 // This table ensures that the handling of options will update automatically when the JDK
 508 // version is incremented, but the source code needs to be cleanup up manually:
 509 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 510 //   variable should be removed, as well as users of the variable.
 511 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 512 //   &quot;Obsolete Flags&quot; section of the table.
 513 // - All expired options should be removed from the table.
 514 static SpecialFlag const special_jvm_flags[] = {
 515   // -------------- Deprecated Flags --------------
 516   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 517   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
 518   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 519   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 520   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 521   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
 522   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 523   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 524   { &quot;MonitorBound&quot;,                 JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 525 
 526   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 527   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 528   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 529   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 530 
 531   // -------------- Obsolete Flags - sorted by expired_in --------------
 532   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 533   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 534   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 535   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 536   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 537   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 538   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 539   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 540   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 541   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 542   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 543   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 544   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 545 
 546 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
 547   // These entries will generate build errors.  Their purpose is to test the macros.
 548   { &quot;dep &gt; obs&quot;,                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
 549   { &quot;dep &gt; exp &quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
 550   { &quot;obs &gt; exp &quot;,                   JDK_Version::undefined(), JDK_Version::jdk(9), JDK_Version::jdk(8) },
 551   { &quot;obs &gt; exp&quot;,                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },
 552   { &quot;not deprecated or obsolete&quot;,   JDK_Version::undefined(), JDK_Version::undefined(), JDK_Version::jdk(9) },
 553   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 554   { &quot;dup option&quot;,                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::undefined() },
 555 #endif
 556 
 557   { NULL, JDK_Version(0), JDK_Version(0) }
 558 };
 559 
 560 // Flags that are aliases for other flags.
 561 typedef struct {
 562   const char* alias_name;
 563   const char* real_name;
 564 } AliasedFlag;
 565 
 566 static AliasedFlag const aliased_jvm_flags[] = {
 567   { &quot;DefaultMaxRAMFraction&quot;,    &quot;MaxRAMFraction&quot;    },
 568   { &quot;CreateMinidumpOnCrash&quot;,    &quot;CreateCoredumpOnCrash&quot; },
 569   { NULL, NULL}
 570 };
 571 
 572 // NOTE: A compatibility request will be necessary for each alias to be removed.
 573 static AliasedLoggingFlag const aliased_logging_flags[] = {
 574   { &quot;PrintCompressedOopsMode&quot;,   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },
 575   { &quot;PrintSharedSpaces&quot;,         LogLevel::Info,  true,  LOG_TAGS(cds) },
 576   { &quot;TraceBiasedLocking&quot;,        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },
 577   { &quot;TraceClassLoading&quot;,         LogLevel::Info,  true,  LOG_TAGS(class, load) },
 578   { &quot;TraceClassLoadingPreorder&quot;, LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
 579   { &quot;TraceClassPaths&quot;,           LogLevel::Info,  true,  LOG_TAGS(class, path) },
 580   { &quot;TraceClassResolution&quot;,      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
 581   { &quot;TraceClassUnloading&quot;,       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
 582   { &quot;TraceExceptions&quot;,           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
 583   { &quot;TraceLoaderConstraints&quot;,    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
 584   { &quot;TraceMonitorInflation&quot;,     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
 585   { &quot;TraceSafepointCleanupTime&quot;, LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
 586   { &quot;TraceJVMTIObjectTagging&quot;,   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
 587   { &quot;TraceRedefineClasses&quot;,      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
 588   { &quot;PrintJNIResolving&quot;,         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
 589   { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }
 590 };
 591 
 592 #ifndef PRODUCT
 593 // These options are removed in jdk9. Remove this code for jdk10.
 594 static AliasedFlag const removed_develop_logging_flags[] = {
 595   { &quot;TraceClassInitialization&quot;,   &quot;-Xlog:class+init&quot; },
 596   { &quot;TraceClassLoaderData&quot;,       &quot;-Xlog:class+loader+data&quot; },
 597   { &quot;TraceDefaultMethods&quot;,        &quot;-Xlog:defaultmethods=debug&quot; },
 598   { &quot;TraceItables&quot;,               &quot;-Xlog:itables=debug&quot; },
 599   { &quot;TraceMonitorMismatch&quot;,       &quot;-Xlog:monitormismatch=info&quot; },
 600   { &quot;TraceSafepoint&quot;,             &quot;-Xlog:safepoint=debug&quot; },
 601   { &quot;TraceStartupTime&quot;,           &quot;-Xlog:startuptime&quot; },
 602   { &quot;TraceVMOperation&quot;,           &quot;-Xlog:vmoperation=debug&quot; },
 603   { &quot;PrintVtables&quot;,               &quot;-Xlog:vtables=debug&quot; },
 604   { &quot;VerboseVerification&quot;,        &quot;-Xlog:verification&quot; },
 605   { NULL, NULL }
 606 };
 607 #endif //PRODUCT
 608 
 609 // Return true if &quot;v&quot; is less than &quot;other&quot;, where &quot;other&quot; may be &quot;undefined&quot;.
 610 static bool version_less_than(JDK_Version v, JDK_Version other) {
 611   assert(!v.is_undefined(), &quot;must be defined&quot;);
 612   if (!other.is_undefined() &amp;&amp; v.compare(other) &gt;= 0) {
 613     return false;
 614   } else {
 615     return true;
 616   }
 617 }
 618 
 619 static bool lookup_special_flag(const char *flag_name, SpecialFlag&amp; flag) {
 620   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 621     if ((strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 622       flag = special_jvm_flags[i];
 623       return true;
 624     }
 625   }
 626   return false;
 627 }
 628 
 629 bool Arguments::is_obsolete_flag(const char *flag_name, JDK_Version* version) {
 630   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 631   SpecialFlag flag;
 632   if (lookup_special_flag(flag_name, flag)) {
 633     if (!flag.obsolete_in.is_undefined()) {
 634       if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 635         *version = flag.obsolete_in;
 636         // This flag may have been marked for obsoletion in this version, but we may not
 637         // have actually removed it yet. Rather than ignoring it as soon as we reach
 638         // this version we allow some time for the removal to happen. So if the flag
 639         // still actually exists we process it as normal, but issue an adjusted warning.
 640         const JVMFlag *real_flag = JVMFlag::find_declared_flag(flag_name);
 641         if (real_flag != NULL) {
 642           char version_str[256];
 643           version-&gt;to_string(version_str, sizeof(version_str));
 644           warning(&quot;Temporarily processing option %s; support is scheduled for removal in %s&quot;,
 645                   flag_name, version_str);
 646           return false;
 647         }
 648         return true;
 649       }
 650     }
 651   }
 652   return false;
 653 }
 654 
 655 int Arguments::is_deprecated_flag(const char *flag_name, JDK_Version* version) {
 656   assert(version != NULL, &quot;Must provide a version buffer&quot;);
 657   SpecialFlag flag;
 658   if (lookup_special_flag(flag_name, flag)) {
 659     if (!flag.deprecated_in.is_undefined()) {
 660       if (version_less_than(JDK_Version::current(), flag.obsolete_in) &amp;&amp;
 661           version_less_than(JDK_Version::current(), flag.expired_in)) {
 662         *version = flag.deprecated_in;
 663         return 1;
 664       } else {
 665         return -1;
 666       }
 667     }
 668   }
 669   return 0;
 670 }
 671 
 672 #ifndef PRODUCT
 673 const char* Arguments::removed_develop_logging_flag_name(const char* name){
 674   for (size_t i = 0; removed_develop_logging_flags[i].alias_name != NULL; i++) {
 675     const AliasedFlag&amp; flag = removed_develop_logging_flags[i];
 676     if (strcmp(flag.alias_name, name) == 0) {
 677       return flag.real_name;
 678     }
 679   }
 680   return NULL;
 681 }
 682 #endif // PRODUCT
 683 
 684 const char* Arguments::real_flag_name(const char *flag_name) {
 685   for (size_t i = 0; aliased_jvm_flags[i].alias_name != NULL; i++) {
 686     const AliasedFlag&amp; flag_status = aliased_jvm_flags[i];
 687     if (strcmp(flag_status.alias_name, flag_name) == 0) {
 688         return flag_status.real_name;
 689     }
 690   }
 691   return flag_name;
 692 }
 693 
 694 #ifdef ASSERT
 695 static bool lookup_special_flag(const char *flag_name, size_t skip_index) {
 696   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 697     if ((i != skip_index) &amp;&amp; (strcmp(special_jvm_flags[i].name, flag_name) == 0)) {
 698       return true;
 699     }
 700   }
 701   return false;
 702 }
 703 
 704 // Verifies the correctness of the entries in the special_jvm_flags table.
 705 // If there is a semantic error (i.e. a bug in the table) such as the obsoletion
 706 // version being earlier than the deprecation version, then a warning is issued
 707 // and verification fails - by returning false. If it is detected that the table
 708 // is out of date, with respect to the current version, then ideally a warning is
 709 // issued but verification does not fail. This allows the VM to operate when the
 710 // version is first updated, without needing to update all the impacted flags at
 711 // the same time. In practice we can&#39;t issue the warning immediately when the version
 712 // is updated as it occurs for every test and some tests are not prepared to handle
 713 // unexpected output - see 8196739. Instead we only check if the table is up-to-date
 714 // if the check_globals flag is true, and in addition allow a grace period and only
 715 // check for stale flags when we hit build 20 (which is far enough into the 6 month
 716 // release cycle that all flag updates should have been processed, whilst still
 717 // leaving time to make the change before RDP2).
 718 // We use a gtest to call this, passing true, so that we can detect stale flags before
 719 // the end of the release cycle.
 720 
 721 static const int SPECIAL_FLAG_VALIDATION_BUILD = 20;
 722 
 723 bool Arguments::verify_special_jvm_flags(bool check_globals) {
 724   bool success = true;
 725   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
 726     const SpecialFlag&amp; flag = special_jvm_flags[i];
 727     if (lookup_special_flag(flag.name, i)) {
 728       warning(&quot;Duplicate special flag declaration \&quot;%s\&quot;&quot;, flag.name);
 729       success = false;
 730     }
 731     if (flag.deprecated_in.is_undefined() &amp;&amp;
 732         flag.obsolete_in.is_undefined()) {
 733       warning(&quot;Special flag entry \&quot;%s\&quot; must declare version deprecated and/or obsoleted in.&quot;, flag.name);
 734       success = false;
 735     }
 736 
 737     if (!flag.deprecated_in.is_undefined()) {
 738       if (!version_less_than(flag.deprecated_in, flag.obsolete_in)) {
 739         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before obsoleted.&quot;, flag.name);
 740         success = false;
 741       }
 742 
 743       if (!version_less_than(flag.deprecated_in, flag.expired_in)) {
 744         warning(&quot;Special flag entry \&quot;%s\&quot; must be deprecated before expired.&quot;, flag.name);
 745         success = false;
 746       }
 747     }
 748 
 749     if (!flag.obsolete_in.is_undefined()) {
 750       if (!version_less_than(flag.obsolete_in, flag.expired_in)) {
 751         warning(&quot;Special flag entry \&quot;%s\&quot; must be obsoleted before expired.&quot;, flag.name);
 752         success = false;
 753       }
 754 
 755       // if flag has become obsolete it should not have a &quot;globals&quot; flag defined anymore.
 756       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;
 757           !version_less_than(JDK_Version::current(), flag.obsolete_in)) {
 758         if (JVMFlag::find_declared_flag(flag.name) != NULL) {
 759           warning(&quot;Global variable for obsolete special flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);
 760           success = false;
 761         }
 762       }
 763 
 764     } else if (!flag.expired_in.is_undefined()) {
 765       warning(&quot;Special flag entry \&quot;%s\&quot; must be explicitly obsoleted before expired.&quot;, flag.name);
 766       success = false;
 767     }
 768 
 769     if (!flag.expired_in.is_undefined()) {
 770       // if flag has become expired it should not have a &quot;globals&quot; flag defined anymore.
 771       if (check_globals &amp;&amp; VM_Version::vm_build_number() &gt;= SPECIAL_FLAG_VALIDATION_BUILD &amp;&amp;
 772           !version_less_than(JDK_Version::current(), flag.expired_in)) {
 773         if (JVMFlag::find_declared_flag(flag.name) != NULL) {
 774           warning(&quot;Global variable for expired flag entry \&quot;%s\&quot; should be removed&quot;, flag.name);
 775           success = false;
 776         }
 777       }
 778     }
 779   }
 780   return success;
 781 }
 782 #endif
 783 
 784 // Parses a size specification string.
 785 bool Arguments::atojulong(const char *s, julong* result) {
 786   julong n = 0;
 787 
 788   // First char must be a digit. Don&#39;t allow negative numbers or leading spaces.
 789   if (!isdigit(*s)) {
 790     return false;
 791   }
 792 
 793   bool is_hex = (s[0] == &#39;0&#39; &amp;&amp; (s[1] == &#39;x&#39; || s[1] == &#39;X&#39;));
 794   char* remainder;
 795   errno = 0;
 796   n = strtoull(s, &amp;remainder, (is_hex ? 16 : 10));
 797   if (errno != 0) {
 798     return false;
 799   }
 800 
 801   // Fail if no number was read at all or if the remainder contains more than a single non-digit character.
 802   if (remainder == s || strlen(remainder) &gt; 1) {
 803     return false;
 804   }
 805 
 806   switch (*remainder) {
 807     case &#39;T&#39;: case &#39;t&#39;:
 808       *result = n * G * K;
 809       // Check for overflow.
 810       if (*result/((julong)G * K) != n) return false;
 811       return true;
 812     case &#39;G&#39;: case &#39;g&#39;:
 813       *result = n * G;
 814       if (*result/G != n) return false;
 815       return true;
 816     case &#39;M&#39;: case &#39;m&#39;:
 817       *result = n * M;
 818       if (*result/M != n) return false;
 819       return true;
 820     case &#39;K&#39;: case &#39;k&#39;:
 821       *result = n * K;
 822       if (*result/K != n) return false;
 823       return true;
 824     case &#39;\0&#39;:
 825       *result = n;
 826       return true;
 827     default:
 828       return false;
 829   }
 830 }
 831 
 832 Arguments::ArgsRange Arguments::check_memory_size(julong size, julong min_size, julong max_size) {
 833   if (size &lt; min_size) return arg_too_small;
 834   if (size &gt; max_size) return arg_too_big;
 835   return arg_in_range;
 836 }
 837 
 838 // Describe an argument out of range error
 839 void Arguments::describe_range_error(ArgsRange errcode) {
 840   switch(errcode) {
 841   case arg_too_big:
 842     jio_fprintf(defaultStream::error_stream(),
 843                 &quot;The specified size exceeds the maximum &quot;
 844                 &quot;representable size.\n&quot;);
 845     break;
 846   case arg_too_small:
 847   case arg_unreadable:
 848   case arg_in_range:
 849     // do nothing for now
 850     break;
 851   default:
 852     ShouldNotReachHere();
 853   }
 854 }
 855 
 856 static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {
 857   if (JVMFlag::boolAtPut(flag, &amp;value, origin) == JVMFlag::SUCCESS) {
 858     return true;
 859   } else {
 860     return false;
 861   }
 862 }
 863 
 864 static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {
 865   char* end;
 866   errno = 0;
 867   double v = strtod(value, &amp;end);
 868   if ((errno != 0) || (*end != 0)) {
 869     return false;
 870   }
 871 
 872   if (JVMFlag::doubleAtPut(flag, &amp;v, origin) == JVMFlag::SUCCESS) {
 873     return true;
 874   }
 875   return false;
 876 }
 877 
 878 static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {
 879   julong v;
 880   int int_v;
 881   intx intx_v;
 882   bool is_neg = false;
 883 
 884   if (flag == NULL) {
 885     return false;
 886   }
 887 
 888   // Check the sign first since atojulong() parses only unsigned values.
 889   if (*value == &#39;-&#39;) {
 890     if (!flag-&gt;is_intx() &amp;&amp; !flag-&gt;is_int()) {
 891       return false;
 892     }
 893     value++;
 894     is_neg = true;
 895   }
 896   if (!Arguments::atojulong(value, &amp;v)) {
 897     return false;
 898   }
 899   if (flag-&gt;is_int()) {
 900     int_v = (int) v;
 901     if (is_neg) {
 902       int_v = -int_v;
 903     }
 904     return JVMFlag::intAtPut(flag, &amp;int_v, origin) == JVMFlag::SUCCESS;
 905   } else if (flag-&gt;is_uint()) {
 906     uint uint_v = (uint) v;
 907     return JVMFlag::uintAtPut(flag, &amp;uint_v, origin) == JVMFlag::SUCCESS;
 908   } else if (flag-&gt;is_intx()) {
 909     intx_v = (intx) v;
 910     if (is_neg) {
 911       intx_v = -intx_v;
 912     }
 913     return JVMFlag::intxAtPut(flag, &amp;intx_v, origin) == JVMFlag::SUCCESS;
 914   } else if (flag-&gt;is_uintx()) {
 915     uintx uintx_v = (uintx) v;
 916     return JVMFlag::uintxAtPut(flag, &amp;uintx_v, origin) == JVMFlag::SUCCESS;
 917   } else if (flag-&gt;is_uint64_t()) {
 918     uint64_t uint64_t_v = (uint64_t) v;
 919     return JVMFlag::uint64_tAtPut(flag, &amp;uint64_t_v, origin) == JVMFlag::SUCCESS;
 920   } else if (flag-&gt;is_size_t()) {
 921     size_t size_t_v = (size_t) v;
 922     return JVMFlag::size_tAtPut(flag, &amp;size_t_v, origin) == JVMFlag::SUCCESS;
 923   } else if (flag-&gt;is_double()) {
 924     double double_v = (double) v;
 925     return JVMFlag::doubleAtPut(flag, &amp;double_v, origin) == JVMFlag::SUCCESS;
 926   } else {
 927     return false;
 928   }
 929 }
 930 
 931 static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {
 932   if (JVMFlag::ccstrAtPut(flag, &amp;value, origin) != JVMFlag::SUCCESS) return false;
 933   // Contract:  JVMFlag always returns a pointer that needs freeing.
 934   FREE_C_HEAP_ARRAY(char, value);
 935   return true;
 936 }
 937 
 938 static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {
 939   const char* old_value = &quot;&quot;;
 940   if (JVMFlag::ccstrAt(flag, &amp;old_value) != JVMFlag::SUCCESS) return false;
 941   size_t old_len = old_value != NULL ? strlen(old_value) : 0;
 942   size_t new_len = strlen(new_value);
 943   const char* value;
 944   char* free_this_too = NULL;
 945   if (old_len == 0) {
 946     value = new_value;
 947   } else if (new_len == 0) {
 948     value = old_value;
 949   } else {
 950      size_t length = old_len + 1 + new_len + 1;
 951      char* buf = NEW_C_HEAP_ARRAY(char, length, mtArguments);
 952     // each new setting adds another LINE to the switch:
 953     jio_snprintf(buf, length, &quot;%s\n%s&quot;, old_value, new_value);
 954     value = buf;
 955     free_this_too = buf;
 956   }
 957   (void) JVMFlag::ccstrAtPut(flag, &amp;value, origin);
 958   // JVMFlag always returns a pointer that needs freeing.
 959   FREE_C_HEAP_ARRAY(char, value);
 960   // JVMFlag made its own copy, so I must delete my own temp. buffer.
 961   FREE_C_HEAP_ARRAY(char, free_this_too);
 962   return true;
 963 }
 964 
 965 const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {
 966   const char* real_name = real_flag_name(arg);
 967   JDK_Version since = JDK_Version();
 968   switch (is_deprecated_flag(arg, &amp;since)) {
 969   case -1: {
 970       // Obsolete or expired, so don&#39;t process normally,
 971       // but allow for an obsolete flag we&#39;re still
 972       // temporarily allowing.
 973       if (!is_obsolete_flag(arg, &amp;since)) {
 974         return real_name;
 975       }
 976       // Note if we&#39;re not considered obsolete then we can&#39;t be expired either
 977       // as obsoletion must come first.
 978       return NULL;
 979     }
 980     case 0:
 981       return real_name;
 982     case 1: {
 983       if (warn) {
 984         char version[256];
 985         since.to_string(version, sizeof(version));
 986         if (real_name != arg) {
 987           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.&quot;,
 988                   arg, version, real_name);
 989         } else {
 990           warning(&quot;Option %s was deprecated in version %s and will likely be removed in a future release.&quot;,
 991                   arg, version);
 992         }
 993       }
 994       return real_name;
 995     }
 996   }
 997   ShouldNotReachHere();
 998   return NULL;
 999 }
1000 
1001 void log_deprecated_flag(const char* name, bool on, AliasedLoggingFlag alf) {
1002   LogTagType tagSet[] = {alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5};
1003   // Set tagset string buffer at max size of 256, large enough for any alias tagset
1004   const int max_tagset_size = 256;
1005   int max_tagset_len = max_tagset_size - 1;
1006   char tagset_buffer[max_tagset_size];
1007   tagset_buffer[0] = &#39;\0&#39;;
1008 
1009   // Write tag-set for aliased logging option, in string list form
1010   int max_tags = sizeof(tagSet)/sizeof(tagSet[0]);
1011   for (int i = 0; i &lt; max_tags &amp;&amp; tagSet[i] != LogTag::__NO_TAG; i++) {
1012     if (i &gt; 0) {
1013       strncat(tagset_buffer, &quot;+&quot;, max_tagset_len - strlen(tagset_buffer));
1014     }
1015     strncat(tagset_buffer, LogTag::name(tagSet[i]), max_tagset_len - strlen(tagset_buffer));
1016   }
1017   if (!alf.exactMatch) {
1018       strncat(tagset_buffer, &quot;*&quot;, max_tagset_len - strlen(tagset_buffer));
1019   }
1020   log_warning(arguments)(&quot;-XX:%s%s is deprecated. Will use -Xlog:%s=%s instead.&quot;,
1021                          (on) ? &quot;+&quot; : &quot;-&quot;,
1022                          name,
1023                          tagset_buffer,
1024                          (on) ? LogLevel::name(alf.level) : &quot;off&quot;);
1025 }
1026 
1027 AliasedLoggingFlag Arguments::catch_logging_aliases(const char* name, bool on){
1028   for (size_t i = 0; aliased_logging_flags[i].alias_name != NULL; i++) {
1029     const AliasedLoggingFlag&amp; alf = aliased_logging_flags[i];
1030     if (strcmp(alf.alias_name, name) == 0) {
1031       log_deprecated_flag(name, on, alf);
1032       return alf;
1033     }
1034   }
1035   AliasedLoggingFlag a = {NULL, LogLevel::Off, false, LOG_TAGS(_NO_TAG)};
1036   return a;
1037 }
1038 
1039 bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {
1040 
1041   // range of acceptable characters spelled out for portability reasons
1042 #define NAME_RANGE  &quot;[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]&quot;
1043 #define BUFLEN 255
1044   char name[BUFLEN+1];
1045   char dummy;
1046   const char* real_name;
1047   bool warn_if_deprecated = true;
1048 
1049   if (sscanf(arg, &quot;-%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1050     AliasedLoggingFlag alf = catch_logging_aliases(name, false);
1051     if (alf.alias_name != NULL){
1052       LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1053       return true;
1054     }
1055     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1056     if (real_name == NULL) {
1057       return false;
1058     }
1059     JVMFlag* flag = JVMFlag::find_flag(real_name);
1060     return set_bool_flag(flag, false, origin);
1061   }
1062   if (sscanf(arg, &quot;+%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;dummy) == 1) {
1063     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1064     if (alf.alias_name != NULL){
1065       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1066       return true;
1067     }
1068     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1069     if (real_name == NULL) {
1070       return false;
1071     }
1072     JVMFlag* flag = JVMFlag::find_flag(real_name);
1073     return set_bool_flag(flag, true, origin);
1074   }
1075 
1076   char punct;
1077   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1078     const char* value = strchr(arg, &#39;=&#39;) + 1;
1079 
1080     // this scanf pattern matches both strings (handled here) and numbers (handled later))
1081     AliasedLoggingFlag alf = catch_logging_aliases(name, true);
1082     if (alf.alias_name != NULL) {
1083       LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);
1084       return true;
1085     }
1086     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1087     if (real_name == NULL) {
1088       return false;
1089     }
1090     JVMFlag* flag = JVMFlag::find_flag(real_name);
1091     if (flag != NULL &amp;&amp; flag-&gt;is_ccstr()) {
1092       if (flag-&gt;ccstr_accumulates()) {
1093         return append_to_string_flag(flag, value, origin);
1094       } else {
1095         if (value[0] == &#39;\0&#39;) {
1096           value = NULL;
1097         }
1098         return set_string_flag(flag, value, origin);
1099       }
1100     } else {
1101       warn_if_deprecated = false; // if arg is deprecated, we&#39;ve already done warning...
1102     }
1103   }
1104 
1105   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;:%c&quot;, name, &amp;punct) == 2 &amp;&amp; punct == &#39;=&#39;) {
1106     const char* value = strchr(arg, &#39;=&#39;) + 1;
1107     // -XX:Foo:=xxx will reset the string flag to the given value.
1108     if (value[0] == &#39;\0&#39;) {
1109       value = NULL;
1110     }
1111     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1112     if (real_name == NULL) {
1113       return false;
1114     }
1115     JVMFlag* flag = JVMFlag::find_flag(real_name);
1116     return set_string_flag(flag, value, origin);
1117   }
1118 
1119 #define SIGNED_FP_NUMBER_RANGE &quot;[-0123456789.eE+]&quot;
1120 #define SIGNED_NUMBER_RANGE    &quot;[-0123456789]&quot;
1121 #define        NUMBER_RANGE    &quot;[0123456789eE+-]&quot;
1122   char value[BUFLEN + 1];
1123   char value2[BUFLEN + 1];
1124   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_NUMBER_RANGE &quot;.&quot; &quot;%&quot; XSTR(BUFLEN) NUMBER_RANGE &quot;%c&quot;, name, value, value2, &amp;dummy) == 3) {
1125     // Looks like a floating-point number -- try again with more lenient format string
1126     if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1127       real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1128       if (real_name == NULL) {
1129         return false;
1130       }
1131       JVMFlag* flag = JVMFlag::find_flag(real_name);
1132       return set_fp_numeric_flag(flag, value, origin);
1133     }
1134   }
1135 
1136 #define VALUE_RANGE &quot;[-kmgtxKMGTX0123456789abcdefABCDEF]&quot;
1137   if (sscanf(arg, &quot;%&quot; XSTR(BUFLEN) NAME_RANGE &quot;=&quot; &quot;%&quot; XSTR(BUFLEN) VALUE_RANGE &quot;%c&quot;, name, value, &amp;dummy) == 2) {
1138     real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);
1139     if (real_name == NULL) {
1140       return false;
1141     }
1142     JVMFlag* flag = JVMFlag::find_flag(real_name);
1143     return set_numeric_flag(flag, value, origin);
1144   }
1145 
1146   return false;
1147 }
1148 
1149 void Arguments::add_string(char*** bldarray, int* count, const char* arg) {
1150   assert(bldarray != NULL, &quot;illegal argument&quot;);
1151 
1152   if (arg == NULL) {
1153     return;
1154   }
1155 
1156   int new_count = *count + 1;
1157 
1158   // expand the array and add arg to the last element
1159   if (*bldarray == NULL) {
1160     *bldarray = NEW_C_HEAP_ARRAY(char*, new_count, mtArguments);
1161   } else {
1162     *bldarray = REALLOC_C_HEAP_ARRAY(char*, *bldarray, new_count, mtArguments);
1163   }
1164   (*bldarray)[*count] = os::strdup_check_oom(arg);
1165   *count = new_count;
1166 }
1167 
1168 void Arguments::build_jvm_args(const char* arg) {
1169   add_string(&amp;_jvm_args_array, &amp;_num_jvm_args, arg);
1170 }
1171 
1172 void Arguments::build_jvm_flags(const char* arg) {
1173   add_string(&amp;_jvm_flags_array, &amp;_num_jvm_flags, arg);
1174 }
1175 
1176 // utility function to return a string that concatenates all
1177 // strings in a given char** array
1178 const char* Arguments::build_resource_string(char** args, int count) {
1179   if (args == NULL || count == 0) {
1180     return NULL;
1181   }
1182   size_t length = 0;
1183   for (int i = 0; i &lt; count; i++) {
1184     length += strlen(args[i]) + 1; // add 1 for a space or NULL terminating character
1185   }
1186   char* s = NEW_RESOURCE_ARRAY(char, length);
1187   char* dst = s;
1188   for (int j = 0; j &lt; count; j++) {
1189     size_t offset = strlen(args[j]) + 1; // add 1 for a space or NULL terminating character
1190     jio_snprintf(dst, length, &quot;%s &quot;, args[j]); // jio_snprintf will replace the last space character with NULL character
1191     dst += offset;
1192     length -= offset;
1193   }
1194   return (const char*) s;
1195 }
1196 
1197 void Arguments::print_on(outputStream* st) {
1198   st-&gt;print_cr(&quot;VM Arguments:&quot;);
1199   if (num_jvm_flags() &gt; 0) {
1200     st-&gt;print(&quot;jvm_flags: &quot;); print_jvm_flags_on(st);
1201     st-&gt;cr();
1202   }
1203   if (num_jvm_args() &gt; 0) {
1204     st-&gt;print(&quot;jvm_args: &quot;); print_jvm_args_on(st);
1205     st-&gt;cr();
1206   }
1207   st-&gt;print_cr(&quot;java_command: %s&quot;, java_command() ? java_command() : &quot;&lt;unknown&gt;&quot;);
1208   if (_java_class_path != NULL) {
1209     char* path = _java_class_path-&gt;value();
1210     st-&gt;print_cr(&quot;java_class_path (initial): %s&quot;, strlen(path) == 0 ? &quot;&lt;not set&gt;&quot; : path );
1211   }
1212   st-&gt;print_cr(&quot;Launcher Type: %s&quot;, _sun_java_launcher);
1213 }
1214 
1215 void Arguments::print_summary_on(outputStream* st) {
1216   // Print the command line.  Environment variables that are helpful for
1217   // reproducing the problem are written later in the hs_err file.
1218   // flags are from setting file
1219   if (num_jvm_flags() &gt; 0) {
1220     st-&gt;print_raw(&quot;Settings File: &quot;);
1221     print_jvm_flags_on(st);
1222     st-&gt;cr();
1223   }
1224   // args are the command line and environment variable arguments.
1225   st-&gt;print_raw(&quot;Command Line: &quot;);
1226   if (num_jvm_args() &gt; 0) {
1227     print_jvm_args_on(st);
1228   }
1229   // this is the classfile and any arguments to the java program
1230   if (java_command() != NULL) {
1231     st-&gt;print(&quot;%s&quot;, java_command());
1232   }
1233   st-&gt;cr();
1234 }
1235 
1236 void Arguments::print_jvm_flags_on(outputStream* st) {
1237   if (_num_jvm_flags &gt; 0) {
1238     for (int i=0; i &lt; _num_jvm_flags; i++) {
1239       st-&gt;print(&quot;%s &quot;, _jvm_flags_array[i]);
1240     }
1241   }
1242 }
1243 
1244 void Arguments::print_jvm_args_on(outputStream* st) {
1245   if (_num_jvm_args &gt; 0) {
1246     for (int i=0; i &lt; _num_jvm_args; i++) {
1247       st-&gt;print(&quot;%s &quot;, _jvm_args_array[i]);
1248     }
1249   }
1250 }
1251 
1252 bool Arguments::process_argument(const char* arg,
1253                                  jboolean ignore_unrecognized,
1254                                  JVMFlag::Flags origin) {
1255   JDK_Version since = JDK_Version();
1256 
1257   if (parse_argument(arg, origin)) {
1258     return true;
1259   }
1260 
1261   // Determine if the flag has &#39;+&#39;, &#39;-&#39;, or &#39;=&#39; characters.
1262   bool has_plus_minus = (*arg == &#39;+&#39; || *arg == &#39;-&#39;);
1263   const char* const argname = has_plus_minus ? arg + 1 : arg;
1264 
1265   size_t arg_len;
1266   const char* equal_sign = strchr(argname, &#39;=&#39;);
1267   if (equal_sign == NULL) {
1268     arg_len = strlen(argname);
1269   } else {
1270     arg_len = equal_sign - argname;
1271   }
1272 
1273   // Only make the obsolete check for valid arguments.
1274   if (arg_len &lt;= BUFLEN) {
1275     // Construct a string which consists only of the argument name without &#39;+&#39;, &#39;-&#39;, or &#39;=&#39;.
1276     char stripped_argname[BUFLEN+1]; // +1 for &#39;\0&#39;
1277     jio_snprintf(stripped_argname, arg_len+1, &quot;%s&quot;, argname); // +1 for &#39;\0&#39;
1278     if (is_obsolete_flag(stripped_argname, &amp;since)) {
1279       char version[256];
1280       since.to_string(version, sizeof(version));
1281       warning(&quot;Ignoring option %s; support was removed in %s&quot;, stripped_argname, version);
1282       return true;
1283     }
1284 #ifndef PRODUCT
1285     else {
1286       const char* replacement;
1287       if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){
1288         log_warning(arguments)(&quot;%s has been removed. Please use %s instead.&quot;,
1289                                stripped_argname,
1290                                replacement);
1291         return false;
1292       }
1293     }
1294 #endif //PRODUCT
1295   }
1296 
1297   // For locked flags, report a custom error message if available.
1298   // Otherwise, report the standard unrecognized VM option.
1299   const JVMFlag* found_flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);
1300   if (found_flag != NULL) {
1301     char locked_message_buf[BUFLEN];
1302     JVMFlag::MsgType msg_type = found_flag-&gt;get_locked_message(locked_message_buf, BUFLEN);
1303     if (strlen(locked_message_buf) == 0) {
1304       if (found_flag-&gt;is_bool() &amp;&amp; !has_plus_minus) {
1305         jio_fprintf(defaultStream::error_stream(),
1306           &quot;Missing +/- setting for VM option &#39;%s&#39;\n&quot;, argname);
1307       } else if (!found_flag-&gt;is_bool() &amp;&amp; has_plus_minus) {
1308         jio_fprintf(defaultStream::error_stream(),
1309           &quot;Unexpected +/- setting in VM option &#39;%s&#39;\n&quot;, argname);
1310       } else {
1311         jio_fprintf(defaultStream::error_stream(),
1312           &quot;Improperly specified VM option &#39;%s&#39;\n&quot;, argname);
1313       }
1314     } else {
1315 #ifdef PRODUCT
1316       bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||
1317                          (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));
1318       if (ignore_unrecognized &amp;&amp; mismatched) {
1319         return true;
1320       }
1321 #endif
1322       jio_fprintf(defaultStream::error_stream(), &quot;%s&quot;, locked_message_buf);
1323     }
1324   } else {
1325     if (ignore_unrecognized) {
1326       return true;
1327     }
1328     jio_fprintf(defaultStream::error_stream(),
1329                 &quot;Unrecognized VM option &#39;%s&#39;\n&quot;, argname);
1330     JVMFlag* fuzzy_matched = JVMFlag::fuzzy_match((const char*)argname, arg_len, true);
1331     if (fuzzy_matched != NULL) {
1332       jio_fprintf(defaultStream::error_stream(),
1333                   &quot;Did you mean &#39;%s%s%s&#39;? &quot;,
1334                   (fuzzy_matched-&gt;is_bool()) ? &quot;(+/-)&quot; : &quot;&quot;,
1335                   fuzzy_matched-&gt;_name,
1336                   (fuzzy_matched-&gt;is_bool()) ? &quot;&quot; : &quot;=&lt;value&gt;&quot;);
1337     }
1338   }
1339 
1340   // allow for commandline &quot;commenting out&quot; options like -XX:#+Verbose
1341   return arg[0] == &#39;#&#39;;
1342 }
1343 
1344 bool Arguments::process_settings_file(const char* file_name, bool should_exist, jboolean ignore_unrecognized) {
1345   FILE* stream = fopen(file_name, &quot;rb&quot;);
1346   if (stream == NULL) {
1347     if (should_exist) {
1348       jio_fprintf(defaultStream::error_stream(),
1349                   &quot;Could not open settings file %s\n&quot;, file_name);
1350       return false;
1351     } else {
1352       return true;
1353     }
1354   }
1355 
1356   char token[1024];
1357   int  pos = 0;
1358 
1359   bool in_white_space = true;
1360   bool in_comment     = false;
1361   bool in_quote       = false;
1362   char quote_c        = 0;
1363   bool result         = true;
1364 
1365   int c = getc(stream);
1366   while(c != EOF &amp;&amp; pos &lt; (int)(sizeof(token)-1)) {
1367     if (in_white_space) {
1368       if (in_comment) {
1369         if (c == &#39;\n&#39;) in_comment = false;
1370       } else {
1371         if (c == &#39;#&#39;) in_comment = true;
1372         else if (!isspace(c)) {
1373           in_white_space = false;
1374           token[pos++] = c;
1375         }
1376       }
1377     } else {
1378       if (c == &#39;\n&#39; || (!in_quote &amp;&amp; isspace(c))) {
1379         // token ends at newline, or at unquoted whitespace
1380         // this allows a way to include spaces in string-valued options
1381         token[pos] = &#39;\0&#39;;
1382         logOption(token);
1383         result &amp;= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);
1384         build_jvm_flags(token);
1385         pos = 0;
1386         in_white_space = true;
1387         in_quote = false;
1388       } else if (!in_quote &amp;&amp; (c == &#39;\&#39;&#39; || c == &#39;&quot;&#39;)) {
1389         in_quote = true;
1390         quote_c = c;
1391       } else if (in_quote &amp;&amp; (c == quote_c)) {
1392         in_quote = false;
1393       } else {
1394         token[pos++] = c;
1395       }
1396     }
1397     c = getc(stream);
1398   }
1399   if (pos &gt; 0) {
1400     token[pos] = &#39;\0&#39;;
1401     result &amp;= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);
1402     build_jvm_flags(token);
1403   }
1404   fclose(stream);
1405   return result;
1406 }
1407 
1408 //=============================================================================================================
1409 // Parsing of properties (-D)
1410 
1411 const char* Arguments::get_property(const char* key) {
1412   return PropertyList_get_value(system_properties(), key);
1413 }
1414 
1415 bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {
1416   const char* eq = strchr(prop, &#39;=&#39;);
1417   const char* key;
1418   const char* value = &quot;&quot;;
1419 
1420   if (eq == NULL) {
1421     // property doesn&#39;t have a value, thus use passed string
1422     key = prop;
1423   } else {
1424     // property have a value, thus extract it and save to the
1425     // allocated string
1426     size_t key_len = eq - prop;
1427     char* tmp_key = AllocateHeap(key_len + 1, mtArguments);
1428 
1429     jio_snprintf(tmp_key, key_len + 1, &quot;%s&quot;, prop);
1430     key = tmp_key;
1431 
1432     value = &amp;prop[key_len + 1];
1433   }
1434 
1435   if (strcmp(key, &quot;java.compiler&quot;) == 0) {
1436     process_java_compiler_argument(value);
1437     // Record value in Arguments, but let it get passed to Java.
1438   } else if (strcmp(key, &quot;sun.java.launcher.is_altjvm&quot;) == 0) {
1439     // sun.java.launcher.is_altjvm property is
1440     // private and is processed in process_sun_java_launcher_properties();
1441     // the sun.java.launcher property is passed on to the java application
1442   } else if (strcmp(key, &quot;sun.boot.library.path&quot;) == 0) {
1443     // append is true, writable is true, internal is false
1444     PropertyList_unique_add(&amp;_system_properties, key, value, AppendProperty,
1445                             WriteableProperty, ExternalProperty);
1446   } else {
1447     if (strcmp(key, &quot;sun.java.command&quot;) == 0) {
1448       char *old_java_command = _java_command;
1449       _java_command = os::strdup_check_oom(value, mtArguments);
1450       if (old_java_command != NULL) {
1451         os::free(old_java_command);
1452       }
1453     } else if (strcmp(key, &quot;java.vendor.url.bug&quot;) == 0) {
1454       // If this property is set on the command line then its value will be
1455       // displayed in VM error logs as the URL at which to submit such logs.
1456       // Normally the URL displayed in error logs is different from the value
1457       // of this system property, so a different property should have been
1458       // used here, but we leave this as-is in case someone depends upon it.
1459       const char* old_java_vendor_url_bug = _java_vendor_url_bug;
1460       // save it in _java_vendor_url_bug, so JVM fatal error handler can access
1461       // its value without going through the property list or making a Java call.
1462       _java_vendor_url_bug = os::strdup_check_oom(value, mtArguments);
1463       if (old_java_vendor_url_bug != NULL) {
1464         os::free((void *)old_java_vendor_url_bug);
1465       }
1466     }
1467 
1468     // Create new property and add at the end of the list
1469     PropertyList_unique_add(&amp;_system_properties, key, value, AddProperty, writeable, internal);
1470   }
1471 
1472   if (key != prop) {
1473     // SystemProperty copy passed value, thus free previously allocated
1474     // memory
1475     FreeHeap((void *)key);
1476   }
1477 
1478   return true;
1479 }
1480 
1481 #if INCLUDE_CDS
1482 const char* unsupported_properties[] = { &quot;jdk.module.limitmods&quot;,
1483                                          &quot;jdk.module.upgrade.path&quot;,
1484                                          &quot;jdk.module.patch.0&quot; };
1485 const char* unsupported_options[] = { &quot;--limit-modules&quot;,
1486                                       &quot;--upgrade-module-path&quot;,
1487                                       &quot;--patch-module&quot;
1488                                     };
1489 void Arguments::check_unsupported_dumping_properties() {
1490   assert(is_dumping_archive(),
1491          &quot;this function is only used with CDS dump time&quot;);
1492   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1493   // If a vm option is found in the unsupported_options array, vm will exit with an error message.
1494   SystemProperty* sp = system_properties();
1495   while (sp != NULL) {
1496     for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1497       if (strcmp(sp-&gt;key(), unsupported_properties[i]) == 0) {
1498         vm_exit_during_initialization(
1499           &quot;Cannot use the following option when dumping the shared archive&quot;, unsupported_options[i]);
1500       }
1501     }
1502     sp = sp-&gt;next();
1503   }
1504 
1505   // Check for an exploded module build in use with -Xshare:dump.
1506   if (!has_jimage()) {
1507     vm_exit_during_initialization(&quot;Dumping the shared archive is not supported with an exploded module build&quot;);
1508   }
1509 }
1510 
1511 bool Arguments::check_unsupported_cds_runtime_properties() {
1512   assert(UseSharedSpaces, &quot;this function is only used with -Xshare:{on,auto}&quot;);
1513   assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), &quot;must be&quot;);
1514   if (ArchiveClassesAtExit != NULL) {
1515     // dynamic dumping, just return false for now.
1516     // check_unsupported_dumping_properties() will be called later to check the same set of
1517     // properties, and will exit the VM with the correct error message if the unsupported properties
1518     // are used.
1519     return false;
1520   }
1521   for (uint i = 0; i &lt; ARRAY_SIZE(unsupported_properties); i++) {
1522     if (get_property(unsupported_properties[i]) != NULL) {
1523       if (RequireSharedSpaces) {
1524         warning(&quot;CDS is disabled when the %s option is specified.&quot;, unsupported_options[i]);
1525       }
1526       return true;
1527     }
1528   }
1529   return false;
1530 }
1531 #endif
1532 
1533 //===========================================================================================================
1534 // Setting int/mixed/comp mode flags
1535 
1536 void Arguments::set_mode_flags(Mode mode) {
1537   // Set up default values for all flags.
1538   // If you add a flag to any of the branches below,
1539   // add a default value for it here.
1540   set_java_compiler(false);
1541   _mode                      = mode;
1542 
1543   // Ensure Agent_OnLoad has the correct initial values.
1544   // This may not be the final mode; mode may change later in onload phase.
1545   PropertyList_unique_add(&amp;_system_properties, &quot;java.vm.info&quot;,
1546                           VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty);
1547 
1548   UseInterpreter             = true;
1549   UseCompiler                = true;
1550   UseLoopCounter             = true;
1551 
1552   // Default values may be platform/compiler dependent -
1553   // use the saved values
1554   ClipInlining               = Arguments::_ClipInlining;
1555   AlwaysCompileLoopMethods   = Arguments::_AlwaysCompileLoopMethods;
1556   UseOnStackReplacement      = Arguments::_UseOnStackReplacement;
1557   BackgroundCompilation      = Arguments::_BackgroundCompilation;
1558   if (TieredCompilation) {
1559     if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {
1560       Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;
1561     }
1562     if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {
1563       Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;
1564     }
1565   }
1566 
1567   // Change from defaults based on mode
1568   switch (mode) {
1569   default:
1570     ShouldNotReachHere();
1571     break;
1572   case _int:
1573     UseCompiler              = false;
1574     UseLoopCounter           = false;
1575     AlwaysCompileLoopMethods = false;
1576     UseOnStackReplacement    = false;
1577     break;
1578   case _mixed:
1579     // same as default
1580     break;
1581   case _comp:
1582     UseInterpreter           = false;
1583     BackgroundCompilation    = false;
1584     ClipInlining             = false;
1585     // Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.
1586     // We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and
1587     // compile a level 4 (C2) and then continue executing it.
1588     if (TieredCompilation) {
1589       Tier3InvokeNotifyFreqLog = 0;
1590       Tier4InvocationThreshold = 0;
1591     }
1592     break;
1593   }
1594 }
1595 
1596 // Conflict: required to use shared spaces (-Xshare:on), but
1597 // incompatible command line options were chosen.
1598 static void no_shared_spaces(const char* message) {
1599   if (RequireSharedSpaces) {
1600     jio_fprintf(defaultStream::error_stream(),
1601       &quot;Class data sharing is inconsistent with other specified options.\n&quot;);
1602     vm_exit_during_initialization(&quot;Unable to use shared archive&quot;, message);
1603   } else {
1604     log_info(cds)(&quot;Unable to use shared archive: %s&quot;, message);
1605     FLAG_SET_DEFAULT(UseSharedSpaces, false);
1606   }
1607 }
1608 
1609 void set_object_alignment() {
1610   // Object alignment.
1611   assert(is_power_of_2(ObjectAlignmentInBytes), &quot;ObjectAlignmentInBytes must be power of 2&quot;);
1612   MinObjAlignmentInBytes     = ObjectAlignmentInBytes;
1613   assert(MinObjAlignmentInBytes &gt;= HeapWordsPerLong * HeapWordSize, &quot;ObjectAlignmentInBytes value is too small&quot;);
1614   MinObjAlignment            = MinObjAlignmentInBytes / HeapWordSize;
1615   assert(MinObjAlignmentInBytes == MinObjAlignment * HeapWordSize, &quot;ObjectAlignmentInBytes value is incorrect&quot;);
1616   MinObjAlignmentInBytesMask = MinObjAlignmentInBytes - 1;
1617 
1618   LogMinObjAlignmentInBytes  = exact_log2(ObjectAlignmentInBytes);
1619   LogMinObjAlignment         = LogMinObjAlignmentInBytes - LogHeapWordSize;
1620 
1621   // Oop encoding heap max
1622   OopEncodingHeapMax = (uint64_t(max_juint) + 1) &lt;&lt; LogMinObjAlignmentInBytes;
1623 
1624   if (SurvivorAlignmentInBytes == 0) {
1625     SurvivorAlignmentInBytes = ObjectAlignmentInBytes;
1626   }
1627 }
1628 
1629 size_t Arguments::max_heap_for_compressed_oops() {
1630   // Avoid sign flip.
1631   assert(OopEncodingHeapMax &gt; (uint64_t)os::vm_page_size(), &quot;Unusual page size&quot;);
1632   // We need to fit both the NULL page and the heap into the memory budget, while
1633   // keeping alignment constraints of the heap. To guarantee the latter, as the
1634   // NULL page is located before the heap, we pad the NULL page to the conservative
1635   // maximum alignment that the GC may ever impose upon the heap.
1636   size_t displacement_due_to_null_page = align_up((size_t)os::vm_page_size(),
1637                                                   _conservative_max_heap_alignment);
1638 
1639   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1640   NOT_LP64(ShouldNotReachHere(); return 0);
1641 }
1642 
1643 void Arguments::set_use_compressed_oops() {
1644 #ifndef ZERO
1645 #ifdef _LP64
1646   // MaxHeapSize is not set up properly at this point, but
1647   // the only value that can override MaxHeapSize if we are
1648   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1649   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1650 
1651   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1652     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1653       FLAG_SET_ERGO(UseCompressedOops, true);
1654     }
1655   } else {
1656     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1657       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1658       FLAG_SET_DEFAULT(UseCompressedOops, false);
1659       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1660     }
1661   }
1662 #endif // _LP64
1663 #endif // ZERO
1664 }
1665 
1666 
1667 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1668 // set_use_compressed_oops().
1669 void Arguments::set_use_compressed_klass_ptrs() {
1670 #ifndef ZERO
1671 #ifdef _LP64
1672   // UseCompressedOops must be on for UseCompressedClassPointers to be on.
1673   if (!UseCompressedOops) {
1674     if (UseCompressedClassPointers) {
1675       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1676     }
1677     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1678   } else {
1679     // Turn on UseCompressedClassPointers too
1680     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1681       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1682     }
1683     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1684     if (UseCompressedClassPointers) {
1685       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1686         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1687         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1688       }
1689     }
1690   }
1691 #endif // _LP64
1692 #endif // !ZERO
1693 }
1694 
1695 void Arguments::set_conservative_max_heap_alignment() {
1696   // The conservative maximum required alignment for the heap is the maximum of
1697   // the alignments imposed by several sources: any requirements from the heap
1698   // itself and the maximum page size we may run the VM with.
1699   size_t heap_alignment = GCConfig::arguments()-&gt;conservative_max_heap_alignment();
1700   _conservative_max_heap_alignment = MAX4(heap_alignment,
1701                                           (size_t)os::vm_allocation_granularity(),
1702                                           os::max_page_size(),
1703                                           GCArguments::compute_heap_alignment());
1704 }
1705 
1706 jint Arguments::set_ergonomics_flags() {
1707   GCConfig::initialize();
1708 
1709   set_conservative_max_heap_alignment();
1710 
1711 #ifndef ZERO
1712 #ifdef _LP64
1713   set_use_compressed_oops();
1714 
1715   // set_use_compressed_klass_ptrs() must be called after calling
1716   // set_use_compressed_oops().
1717   set_use_compressed_klass_ptrs();
1718 
1719   // Also checks that certain machines are slower with compressed oops
1720   // in vm_version initialization code.
1721 #endif // _LP64
1722 #endif // !ZERO
1723 
1724   return JNI_OK;
1725 }
1726 
1727 julong Arguments::limit_by_allocatable_memory(julong limit) {
1728   julong max_allocatable;
1729   julong result = limit;
1730   if (os::has_allocatable_memory_limit(&amp;max_allocatable)) {
1731     result = MIN2(result, max_allocatable / MaxVirtMemFraction);
1732   }
1733   return result;
1734 }
1735 
1736 // Use static initialization to get the default before parsing
1737 static const size_t DefaultHeapBaseMinAddress = HeapBaseMinAddress;
1738 
1739 void Arguments::set_heap_size() {
1740   julong phys_mem;
1741 
1742   // If the user specified one of these options, they
1743   // want specific memory sizing so do not limit memory
1744   // based on compressed oops addressability.
1745   // Also, memory limits will be calculated based on
1746   // available os physical memory, not our MaxRAM limit,
1747   // unless MaxRAM is also specified.
1748   bool override_coop_limit = (!FLAG_IS_DEFAULT(MaxRAMPercentage) ||
1749                            !FLAG_IS_DEFAULT(MaxRAMFraction) ||
1750                            !FLAG_IS_DEFAULT(MinRAMPercentage) ||
1751                            !FLAG_IS_DEFAULT(MinRAMFraction) ||
1752                            !FLAG_IS_DEFAULT(InitialRAMPercentage) ||
1753                            !FLAG_IS_DEFAULT(InitialRAMFraction) ||
1754                            !FLAG_IS_DEFAULT(MaxRAM));
1755   if (override_coop_limit) {
1756     if (FLAG_IS_DEFAULT(MaxRAM)) {
1757       phys_mem = os::physical_memory();
1758       FLAG_SET_ERGO(MaxRAM, (uint64_t)phys_mem);
1759     } else {
1760       phys_mem = (julong)MaxRAM;
1761     }
1762   } else {
1763     phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)
1764                                        : (julong)MaxRAM;
1765   }
1766 
1767 
1768   // Convert deprecated flags
1769   if (FLAG_IS_DEFAULT(MaxRAMPercentage) &amp;&amp;
1770       !FLAG_IS_DEFAULT(MaxRAMFraction))
1771     MaxRAMPercentage = 100.0 / MaxRAMFraction;
1772 
1773   if (FLAG_IS_DEFAULT(MinRAMPercentage) &amp;&amp;
1774       !FLAG_IS_DEFAULT(MinRAMFraction))
1775     MinRAMPercentage = 100.0 / MinRAMFraction;
1776 
1777   if (FLAG_IS_DEFAULT(InitialRAMPercentage) &amp;&amp;
1778       !FLAG_IS_DEFAULT(InitialRAMFraction))
1779     InitialRAMPercentage = 100.0 / InitialRAMFraction;
1780 
1781   // If the maximum heap size has not been set with -Xmx,
1782   // then set it as fraction of the size of physical memory,
1783   // respecting the maximum and minimum sizes of the heap.
1784   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1785     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1786     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1787     if (reasonable_min &lt; MaxHeapSize) {
1788       // Small physical memory, so use a minimum fraction of it for the heap
1789       reasonable_max = reasonable_min;
1790     } else {
1791       // Not-small physical memory, so require a heap at least
1792       // as large as MaxHeapSize
1793       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1794     }
1795 
1796     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1797       // Limit the heap size to ErgoHeapSizeLimit
1798       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1799     }
1800 
1801 #ifdef _LP64
1802     if (UseCompressedOops) {
1803       // Limit the heap size to the maximum possible when using compressed oops
1804       julong max_coop_heap = (julong)max_heap_for_compressed_oops();
1805 
1806       // HeapBaseMinAddress can be greater than default but not less than.
1807       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1808         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1809           // matches compressed oops printing flags
1810           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1811                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1812                                      DefaultHeapBaseMinAddress,
1813                                      DefaultHeapBaseMinAddress/G,
1814                                      HeapBaseMinAddress);
1815           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1816         }
1817       }
1818 
1819       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1820         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1821         // but it should be not less than default MaxHeapSize.
1822         max_coop_heap -= HeapBaseMinAddress;
1823       }
1824 
1825       // If user specified flags prioritizing os physical
1826       // memory limits, then disable compressed oops if
1827       // limits exceed max_coop_heap and UseCompressedOops
1828       // was not specified.
1829       if (reasonable_max &gt; max_coop_heap) {
1830         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1831           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1832             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1833             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1834             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1835           FLAG_SET_ERGO(UseCompressedOops, false);
1836           FLAG_SET_ERGO(UseCompressedClassPointers, false);
1837         } else {
1838           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1839         }
1840       }
1841     }
1842 #endif // _LP64
1843 
1844     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1845 
1846     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1847       // An initial heap size was specified on the command line,
1848       // so be sure that the maximum size is consistent.  Done
1849       // after call to limit_by_allocatable_memory because that
1850       // method might reduce the allocation size.
1851       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1852     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1853       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1854     }
1855 
1856     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
1857     FLAG_SET_ERGO(MaxHeapSize, (size_t)reasonable_max);
1858   }
1859 
1860   // If the minimum or initial heap_size have not been set or requested to be set
1861   // ergonomically, set them accordingly.
1862   if (InitialHeapSize == 0 || MinHeapSize == 0) {
1863     julong reasonable_minimum = (julong)(OldSize + NewSize);
1864 
1865     reasonable_minimum = MIN2(reasonable_minimum, (julong)MaxHeapSize);
1866 
1867     reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);
1868 
1869     if (InitialHeapSize == 0) {
1870       julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) / 100);
1871 
1872       reasonable_initial = MAX3(reasonable_initial, reasonable_minimum, (julong)MinHeapSize);
1873       reasonable_initial = MIN2(reasonable_initial, (julong)MaxHeapSize);
1874 
1875       reasonable_initial = limit_by_allocatable_memory(reasonable_initial);
1876 
1877       FLAG_SET_ERGO(InitialHeapSize, (size_t)reasonable_initial);
1878       log_trace(gc, heap)(&quot;  Initial heap size &quot; SIZE_FORMAT, InitialHeapSize);
1879     }
1880     // If the minimum heap size has not been set (via -Xms or -XX:MinHeapSize),
1881     // synchronize with InitialHeapSize to avoid errors with the default value.
1882     if (MinHeapSize == 0) {
1883       FLAG_SET_ERGO(MinHeapSize, MIN2((size_t)reasonable_minimum, InitialHeapSize));
1884       log_trace(gc, heap)(&quot;  Minimum heap size &quot; SIZE_FORMAT, MinHeapSize);
1885     }
1886   }
1887 }
1888 
1889 // This option inspects the machine and attempts to set various
1890 // parameters to be optimal for long-running, memory allocation
1891 // intensive jobs.  It is intended for machines with large
1892 // amounts of cpu and memory.
1893 jint Arguments::set_aggressive_heap_flags() {
1894   // initHeapSize is needed since _initial_heap_size is 4 bytes on a 32 bit
1895   // VM, but we may not be able to represent the total physical memory
1896   // available (like having 8gb of memory on a box but using a 32bit VM).
1897   // Thus, we need to make sure we&#39;re using a julong for intermediate
1898   // calculations.
1899   julong initHeapSize;
1900   julong total_memory = os::physical_memory();
1901 
1902   if (total_memory &lt; (julong) 256 * M) {
1903     jio_fprintf(defaultStream::error_stream(),
1904             &quot;You need at least 256mb of memory to use -XX:+AggressiveHeap\n&quot;);
1905     vm_exit(1);
1906   }
1907 
1908   // The heap size is half of available memory, or (at most)
1909   // all of possible memory less 160mb (leaving room for the OS
1910   // when using ISM).  This is the maximum; because adaptive sizing
1911   // is turned on below, the actual space used may be smaller.
1912 
1913   initHeapSize = MIN2(total_memory / (julong) 2,
1914           total_memory - (julong) 160 * M);
1915 
1916   initHeapSize = limit_by_allocatable_memory(initHeapSize);
1917 
1918   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1919     if (FLAG_SET_CMDLINE(MaxHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1920       return JNI_EINVAL;
1921     }
1922     if (FLAG_SET_CMDLINE(InitialHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1923       return JNI_EINVAL;
1924     }
1925     if (FLAG_SET_CMDLINE(MinHeapSize, initHeapSize) != JVMFlag::SUCCESS) {
1926       return JNI_EINVAL;
1927     }
1928   }
1929   if (FLAG_IS_DEFAULT(NewSize)) {
1930     // Make the young generation 3/8ths of the total heap.
1931     if (FLAG_SET_CMDLINE(NewSize,
1932             ((julong) MaxHeapSize / (julong) 8) * (julong) 3) != JVMFlag::SUCCESS) {
1933       return JNI_EINVAL;
1934     }
1935     if (FLAG_SET_CMDLINE(MaxNewSize, NewSize) != JVMFlag::SUCCESS) {
1936       return JNI_EINVAL;
1937     }
1938   }
1939 
1940 #if !defined(_ALLBSD_SOURCE) &amp;&amp; !defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
1941   FLAG_SET_DEFAULT(UseLargePages, true);
1942 #endif
1943 
1944   // Increase some data structure sizes for efficiency
1945   if (FLAG_SET_CMDLINE(BaseFootPrintEstimate, MaxHeapSize) != JVMFlag::SUCCESS) {
1946     return JNI_EINVAL;
1947   }
1948   if (FLAG_SET_CMDLINE(ResizeTLAB, false) != JVMFlag::SUCCESS) {
1949     return JNI_EINVAL;
1950   }
1951   if (FLAG_SET_CMDLINE(TLABSize, 256 * K) != JVMFlag::SUCCESS) {
1952     return JNI_EINVAL;
1953   }
1954 
1955   // See the OldPLABSize comment below, but replace &#39;after promotion&#39;
1956   // with &#39;after copying&#39;.  YoungPLABSize is the size of the survivor
1957   // space per-gc-thread buffers.  The default is 4kw.
1958   if (FLAG_SET_CMDLINE(YoungPLABSize, 256 * K) != JVMFlag::SUCCESS) { // Note: this is in words
1959     return JNI_EINVAL;
1960   }
1961 
1962   // OldPLABSize is the size of the buffers in the old gen that
1963   // UseParallelGC uses to promote live data that doesn&#39;t fit in the
1964   // survivor spaces.  At any given time, there&#39;s one for each gc thread.
1965   // The default size is 1kw. These buffers are rarely used, since the
1966   // survivor spaces are usually big enough.  For specjbb, however, there
1967   // are occasions when there&#39;s lots of live data in the young gen
1968   // and we end up promoting some of it.  We don&#39;t have a definite
1969   // explanation for why bumping OldPLABSize helps, but the theory
1970   // is that a bigger PLAB results in retaining something like the
1971   // original allocation order after promotion, which improves mutator
1972   // locality.  A minor effect may be that larger PLABs reduce the
1973   // number of PLAB allocation events during gc.  The value of 8kw
1974   // was arrived at by experimenting with specjbb.
1975   if (FLAG_SET_CMDLINE(OldPLABSize, 8 * K) != JVMFlag::SUCCESS) { // Note: this is in words
1976     return JNI_EINVAL;
1977   }
1978 
1979   // Enable parallel GC and adaptive generation sizing
1980   if (FLAG_SET_CMDLINE(UseParallelGC, true) != JVMFlag::SUCCESS) {
1981     return JNI_EINVAL;
1982   }
1983 
1984   // Encourage steady state memory management
1985   if (FLAG_SET_CMDLINE(ThresholdTolerance, 100) != JVMFlag::SUCCESS) {
1986     return JNI_EINVAL;
1987   }
1988 
1989   // This appears to improve mutator locality
1990   if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {
1991     return JNI_EINVAL;
1992   }
1993 
1994   return JNI_OK;
1995 }
1996 
1997 // This must be called after ergonomics.
1998 void Arguments::set_bytecode_flags() {
1999   if (!RewriteBytecodes) {
2000     FLAG_SET_DEFAULT(RewriteFrequentPairs, false);
2001   }
2002 }
2003 
2004 // Aggressive optimization flags
2005 jint Arguments::set_aggressive_opts_flags() {
2006 #ifdef COMPILER2
2007   if (AggressiveUnboxing) {
2008     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
2009       FLAG_SET_DEFAULT(EliminateAutoBox, true);
2010     } else if (!EliminateAutoBox) {
2011       // warning(&quot;AggressiveUnboxing is disabled because EliminateAutoBox is disabled&quot;);
2012       AggressiveUnboxing = false;
2013     }
2014     if (FLAG_IS_DEFAULT(DoEscapeAnalysis)) {
2015       FLAG_SET_DEFAULT(DoEscapeAnalysis, true);
2016     } else if (!DoEscapeAnalysis) {
2017       // warning(&quot;AggressiveUnboxing is disabled because DoEscapeAnalysis is disabled&quot;);
2018       AggressiveUnboxing = false;
2019     }
2020   }
2021   if (!FLAG_IS_DEFAULT(AutoBoxCacheMax)) {
2022     if (FLAG_IS_DEFAULT(EliminateAutoBox)) {
2023       FLAG_SET_DEFAULT(EliminateAutoBox, true);
2024     }
2025     // Feed the cache size setting into the JDK
2026     char buffer[1024];
2027     jio_snprintf(buffer, 1024, &quot;java.lang.Integer.IntegerCache.high=&quot; INTX_FORMAT, AutoBoxCacheMax);
2028     if (!add_property(buffer)) {
2029       return JNI_ENOMEM;
2030     }
2031   }
2032 #endif
2033 
2034   return JNI_OK;
2035 }
2036 
2037 //===========================================================================================================
2038 // Parsing of java.compiler property
2039 
2040 void Arguments::process_java_compiler_argument(const char* arg) {
2041   // For backwards compatibility, Djava.compiler=NONE or &quot;&quot;
2042   // causes us to switch to -Xint mode UNLESS -Xdebug
2043   // is also specified.
2044   if (strlen(arg) == 0 || strcasecmp(arg, &quot;NONE&quot;) == 0) {
2045     set_java_compiler(true);    // &quot;-Djava.compiler[=...]&quot; most recently seen.
2046   }
2047 }
2048 
2049 void Arguments::process_java_launcher_argument(const char* launcher, void* extra_info) {
2050   _sun_java_launcher = os::strdup_check_oom(launcher);
2051 }
2052 
2053 bool Arguments::created_by_java_launcher() {
2054   assert(_sun_java_launcher != NULL, &quot;property must have value&quot;);
2055   return strcmp(DEFAULT_JAVA_LAUNCHER, _sun_java_launcher) != 0;
2056 }
2057 
2058 bool Arguments::sun_java_launcher_is_altjvm() {
2059   return _sun_java_launcher_is_altjvm;
2060 }
2061 
2062 //===========================================================================================================
2063 // Parsing of main arguments
2064 
2065 unsigned int addreads_count = 0;
2066 unsigned int addexports_count = 0;
2067 unsigned int addopens_count = 0;
2068 unsigned int addmods_count = 0;
2069 unsigned int patch_mod_count = 0;
2070 
2071 // Check the consistency of vm_init_args
2072 bool Arguments::check_vm_args_consistency() {
2073   // Method for adding checks for flag consistency.
2074   // The intent is to warn the user of all possible conflicts,
2075   // before returning an error.
2076   // Note: Needs platform-dependent factoring.
2077   bool status = true;
2078 
2079   if (TLABRefillWasteFraction == 0) {
2080     jio_fprintf(defaultStream::error_stream(),
2081                 &quot;TLABRefillWasteFraction should be a denominator, &quot;
2082                 &quot;not &quot; SIZE_FORMAT &quot;\n&quot;,
2083                 TLABRefillWasteFraction);
2084     status = false;
2085   }
2086 
2087   if (PrintNMTStatistics) {
2088 #if INCLUDE_NMT
2089     if (MemTracker::tracking_level() == NMT_off) {
2090 #endif // INCLUDE_NMT
2091       warning(&quot;PrintNMTStatistics is disabled, because native memory tracking is not enabled&quot;);
2092       PrintNMTStatistics = false;
2093 #if INCLUDE_NMT
2094     }
2095 #endif
2096   }
2097 
2098   status = CompilerConfig::check_args_consistency(status);
2099 #if INCLUDE_JVMCI
2100   if (status &amp;&amp; EnableJVMCI) {
2101     PropertyList_unique_add(&amp;_system_properties, &quot;jdk.internal.vm.ci.enabled&quot;, &quot;true&quot;,
2102         AddProperty, UnwriteableProperty, InternalProperty);
2103     if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.internal.vm.ci&quot;, addmods_count++)) {
2104       return false;
2105     }
2106   }
2107 #endif
2108 
2109 #ifndef SUPPORT_RESERVED_STACK_AREA
2110   if (StackReservedPages != 0) {
2111     FLAG_SET_CMDLINE(StackReservedPages, 0);
2112     warning(&quot;Reserved Stack Area not supported on this platform&quot;);
2113   }
2114 #endif
2115 
<a name="1" id="anc1"></a><span class="line-removed">2116   if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">2117     if ((UseNUMAInterleaving &amp;&amp; !FLAG_IS_DEFAULT(UseNUMAInterleaving)) || (UseNUMA &amp;&amp; !FLAG_IS_DEFAULT(UseNUMA))) {</span>
<span class="line-removed">2118       log_warning(arguments) (&quot;NUMA support for Heap depends on the file system when AllocateHeapAt option is used.\n&quot;);</span>
<span class="line-removed">2119     }</span>
<span class="line-removed">2120   }</span>
<span class="line-removed">2121 </span>
2122   status = status &amp;&amp; GCArguments::check_args_consistency();
2123 
2124   return status;
2125 }
2126 
2127 bool Arguments::is_bad_option(const JavaVMOption* option, jboolean ignore,
2128   const char* option_type) {
2129   if (ignore) return false;
2130 
2131   const char* spacer = &quot; &quot;;
2132   if (option_type == NULL) {
2133     option_type = ++spacer; // Set both to the empty string.
2134   }
2135 
2136   jio_fprintf(defaultStream::error_stream(),
2137               &quot;Unrecognized %s%soption: %s\n&quot;, option_type, spacer,
2138               option-&gt;optionString);
2139   return true;
2140 }
2141 
2142 static const char* user_assertion_options[] = {
2143   &quot;-da&quot;, &quot;-ea&quot;, &quot;-disableassertions&quot;, &quot;-enableassertions&quot;, 0
2144 };
2145 
2146 static const char* system_assertion_options[] = {
2147   &quot;-dsa&quot;, &quot;-esa&quot;, &quot;-disablesystemassertions&quot;, &quot;-enablesystemassertions&quot;, 0
2148 };
2149 
2150 bool Arguments::parse_uintx(const char* value,
2151                             uintx* uintx_arg,
2152                             uintx min_size) {
2153 
2154   // Check the sign first since atojulong() parses only unsigned values.
2155   bool value_is_positive = !(*value == &#39;-&#39;);
2156 
2157   if (value_is_positive) {
2158     julong n;
2159     bool good_return = atojulong(value, &amp;n);
2160     if (good_return) {
2161       bool above_minimum = n &gt;= min_size;
2162       bool value_is_too_large = n &gt; max_uintx;
2163 
2164       if (above_minimum &amp;&amp; !value_is_too_large) {
2165         *uintx_arg = n;
2166         return true;
2167       }
2168     }
2169   }
2170   return false;
2171 }
2172 
2173 bool Arguments::create_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {
2174   size_t prop_len = strlen(prop_name) + strlen(prop_value) + 2;
2175   char* property = AllocateHeap(prop_len, mtArguments);
2176   int ret = jio_snprintf(property, prop_len, &quot;%s=%s&quot;, prop_name, prop_value);
2177   if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2178     FreeHeap(property);
2179     return false;
2180   }
2181   bool added = add_property(property, UnwriteableProperty, internal);
2182   FreeHeap(property);
2183   return added;
2184 }
2185 
2186 bool Arguments::create_numbered_property(const char* prop_base_name, const char* prop_value, unsigned int count) {
2187   const unsigned int props_count_limit = 1000;
2188   const int max_digits = 3;
2189   const int extra_symbols_count = 3; // includes &#39;.&#39;, &#39;=&#39;, &#39;\0&#39;
2190 
2191   // Make sure count is &lt; props_count_limit. Otherwise, memory allocation will be too small.
2192   if (count &lt; props_count_limit) {
2193     size_t prop_len = strlen(prop_base_name) + strlen(prop_value) + max_digits + extra_symbols_count;
2194     char* property = AllocateHeap(prop_len, mtArguments);
2195     int ret = jio_snprintf(property, prop_len, &quot;%s.%d=%s&quot;, prop_base_name, count, prop_value);
2196     if (ret &lt; 0 || ret &gt;= (int)prop_len) {
2197       FreeHeap(property);
2198       jio_fprintf(defaultStream::error_stream(), &quot;Failed to create property %s.%d=%s\n&quot;, prop_base_name, count, prop_value);
2199       return false;
2200     }
2201     bool added = add_property(property, UnwriteableProperty, InternalProperty);
2202     FreeHeap(property);
2203     return added;
2204   }
2205 
2206   jio_fprintf(defaultStream::error_stream(), &quot;Property count limit exceeded: %s, limit=%d\n&quot;, prop_base_name, props_count_limit);
2207   return false;
2208 }
2209 
2210 Arguments::ArgsRange Arguments::parse_memory_size(const char* s,
2211                                                   julong* long_arg,
2212                                                   julong min_size,
2213                                                   julong max_size) {
2214   if (!atojulong(s, long_arg)) return arg_unreadable;
2215   return check_memory_size(*long_arg, min_size, max_size);
2216 }
2217 
2218 // Parse JavaVMInitArgs structure
2219 
2220 jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,
2221                                    const JavaVMInitArgs *java_tool_options_args,
2222                                    const JavaVMInitArgs *java_options_args,
2223                                    const JavaVMInitArgs *cmd_line_args) {
2224   bool patch_mod_javabase = false;
2225 
2226   // Save default settings for some mode flags
2227   Arguments::_AlwaysCompileLoopMethods = AlwaysCompileLoopMethods;
2228   Arguments::_UseOnStackReplacement    = UseOnStackReplacement;
2229   Arguments::_ClipInlining             = ClipInlining;
2230   Arguments::_BackgroundCompilation    = BackgroundCompilation;
2231   if (TieredCompilation) {
2232     Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;
2233     Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;
2234   }
2235 
2236   // CDS dumping always write the archive to the default value of SharedBaseAddress.
2237   Arguments::_SharedBaseAddress = SharedBaseAddress;
2238 
2239   // Setup flags for mixed which is the default
2240   set_mode_flags(_mixed);
2241 
2242   // Parse args structure generated from java.base vm options resource
2243   jint result = parse_each_vm_init_arg(vm_options_args, &amp;patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);
2244   if (result != JNI_OK) {
2245     return result;
2246   }
2247 
2248   // Parse args structure generated from JAVA_TOOL_OPTIONS environment
2249   // variable (if present).
2250   result = parse_each_vm_init_arg(java_tool_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2251   if (result != JNI_OK) {
2252     return result;
2253   }
2254 
2255   // Parse args structure generated from the command line flags.
2256   result = parse_each_vm_init_arg(cmd_line_args, &amp;patch_mod_javabase, JVMFlag::COMMAND_LINE);
2257   if (result != JNI_OK) {
2258     return result;
2259   }
2260 
2261   // Parse args structure generated from the _JAVA_OPTIONS environment
2262   // variable (if present) (mimics classic VM)
2263   result = parse_each_vm_init_arg(java_options_args, &amp;patch_mod_javabase, JVMFlag::ENVIRON_VAR);
2264   if (result != JNI_OK) {
2265     return result;
2266   }
2267 
2268   // We need to ensure processor and memory resources have been properly
2269   // configured - which may rely on arguments we just processed - before
2270   // doing the final argument processing. Any argument processing that
2271   // needs to know about processor and memory resources must occur after
2272   // this point.
2273 
2274   os::init_container_support();
2275 
2276   // Do final processing now that all arguments have been parsed
2277   result = finalize_vm_init_args(patch_mod_javabase);
2278   if (result != JNI_OK) {
2279     return result;
2280   }
2281 
2282   return JNI_OK;
2283 }
2284 
2285 // Checks if name in command-line argument -agent{lib,path}:name[=options]
2286 // represents a valid JDWP agent.  is_path==true denotes that we
2287 // are dealing with -agentpath (case where name is a path), otherwise with
2288 // -agentlib
2289 bool valid_jdwp_agent(char *name, bool is_path) {
2290   char *_name;
2291   const char *_jdwp = &quot;jdwp&quot;;
2292   size_t _len_jdwp, _len_prefix;
2293 
2294   if (is_path) {
2295     if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {
2296       return false;
2297     }
2298 
2299     _name++;  // skip past last path separator
2300     _len_prefix = strlen(JNI_LIB_PREFIX);
2301 
2302     if (strncmp(_name, JNI_LIB_PREFIX, _len_prefix) != 0) {
2303       return false;
2304     }
2305 
2306     _name += _len_prefix;
2307     _len_jdwp = strlen(_jdwp);
2308 
2309     if (strncmp(_name, _jdwp, _len_jdwp) == 0) {
2310       _name += _len_jdwp;
2311     }
2312     else {
2313       return false;
2314     }
2315 
2316     if (strcmp(_name, JNI_LIB_SUFFIX) != 0) {
2317       return false;
2318     }
2319 
2320     return true;
2321   }
2322 
2323   if (strcmp(name, _jdwp) == 0) {
2324     return true;
2325   }
2326 
2327   return false;
2328 }
2329 
2330 int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {
2331   // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2332   assert(patch_mod_tail != NULL, &quot;Unexpected NULL patch-module value&quot;);
2333   // Find the equal sign between the module name and the path specification
2334   const char* module_equal = strchr(patch_mod_tail, &#39;=&#39;);
2335   if (module_equal == NULL) {
2336     jio_fprintf(defaultStream::output_stream(), &quot;Missing &#39;=&#39; in --patch-module specification\n&quot;);
2337     return JNI_ERR;
2338   } else {
2339     // Pick out the module name
2340     size_t module_len = module_equal - patch_mod_tail;
2341     char* module_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, module_len+1, mtArguments);
2342     if (module_name != NULL) {
2343       memcpy(module_name, patch_mod_tail, module_len);
2344       *(module_name + module_len) = &#39;\0&#39;;
2345       // The path piece begins one past the module_equal sign
2346       add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);
2347       FREE_C_HEAP_ARRAY(char, module_name);
2348       if (!create_numbered_property(&quot;jdk.module.patch&quot;, patch_mod_tail, patch_mod_count++)) {
2349         return JNI_ENOMEM;
2350       }
2351     } else {
2352       return JNI_ENOMEM;
2353     }
2354   }
2355   return JNI_OK;
2356 }
2357 
2358 // Parse -Xss memory string parameter and convert to ThreadStackSize in K.
2359 jint Arguments::parse_xss(const JavaVMOption* option, const char* tail, intx* out_ThreadStackSize) {
2360   // The min and max sizes match the values in globals.hpp, but scaled
2361   // with K. The values have been chosen so that alignment with page
2362   // size doesn&#39;t change the max value, which makes the conversions
2363   // back and forth between Xss value and ThreadStackSize value easier.
2364   // The values have also been chosen to fit inside a 32-bit signed type.
2365   const julong min_ThreadStackSize = 0;
2366   const julong max_ThreadStackSize = 1 * M;
2367 
2368   const julong min_size = min_ThreadStackSize * K;
2369   const julong max_size = max_ThreadStackSize * K;
2370 
2371   assert(is_aligned(max_size, os::vm_page_size()), &quot;Implementation assumption&quot;);
2372 
2373   julong size = 0;
2374   ArgsRange errcode = parse_memory_size(tail, &amp;size, min_size, max_size);
2375   if (errcode != arg_in_range) {
2376     bool silent = (option == NULL); // Allow testing to silence error messages
2377     if (!silent) {
2378       jio_fprintf(defaultStream::error_stream(),
2379                   &quot;Invalid thread stack size: %s\n&quot;, option-&gt;optionString);
2380       describe_range_error(errcode);
2381     }
2382     return JNI_EINVAL;
2383   }
2384 
2385   // Internally track ThreadStackSize in units of 1024 bytes.
2386   const julong size_aligned = align_up(size, K);
2387   assert(size &lt;= size_aligned,
2388          &quot;Overflow: &quot; JULONG_FORMAT &quot; &quot; JULONG_FORMAT,
2389          size, size_aligned);
2390 
2391   const julong size_in_K = size_aligned / K;
2392   assert(size_in_K &lt; (julong)max_intx,
2393          &quot;size_in_K doesn&#39;t fit in the type of ThreadStackSize: &quot; JULONG_FORMAT,
2394          size_in_K);
2395 
2396   // Check that code expanding ThreadStackSize to a page aligned number of bytes won&#39;t overflow.
2397   const julong max_expanded = align_up(size_in_K * K, os::vm_page_size());
2398   assert(max_expanded &lt; max_uintx &amp;&amp; max_expanded &gt;= size_in_K,
2399          &quot;Expansion overflowed: &quot; JULONG_FORMAT &quot; &quot; JULONG_FORMAT,
2400          max_expanded, size_in_K);
2401 
2402   *out_ThreadStackSize = (intx)size_in_K;
2403 
2404   return JNI_OK;
2405 }
2406 
2407 jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {
2408   // For match_option to return remaining or value part of option string
2409   const char* tail;
2410 
2411   // iterate over arguments
2412   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
2413     bool is_absolute_path = false;  // for -agentpath vs -agentlib
2414 
2415     const JavaVMOption* option = args-&gt;options + index;
2416 
2417     if (!match_option(option, &quot;-Djava.class.path&quot;, &amp;tail) &amp;&amp;
2418         !match_option(option, &quot;-Dsun.java.command&quot;, &amp;tail) &amp;&amp;
2419         !match_option(option, &quot;-Dsun.java.launcher&quot;, &amp;tail)) {
2420 
2421         // add all jvm options to the jvm_args string. This string
2422         // is used later to set the java.vm.args PerfData string constant.
2423         // the -Djava.class.path and the -Dsun.java.command options are
2424         // omitted from jvm_args string as each have their own PerfData
2425         // string constant object.
2426         build_jvm_args(option-&gt;optionString);
2427     }
2428 
2429     // -verbose:[class/module/gc/jni]
2430     if (match_option(option, &quot;-verbose&quot;, &amp;tail)) {
2431       if (!strcmp(tail, &quot;:class&quot;) || !strcmp(tail, &quot;&quot;)) {
2432         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, load));
2433         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, unload));
2434       } else if (!strcmp(tail, &quot;:module&quot;)) {
2435         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, load));
2436         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(module, unload));
2437       } else if (!strcmp(tail, &quot;:gc&quot;)) {
2438         LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
2439       } else if (!strcmp(tail, &quot;:jni&quot;)) {
2440         LogConfiguration::configure_stdout(LogLevel::Debug, true, LOG_TAGS(jni, resolve));
2441       }
2442     // -da / -ea / -disableassertions / -enableassertions
2443     // These accept an optional class/package name separated by a colon, e.g.,
2444     // -da:java.lang.Thread.
2445     } else if (match_option(option, user_assertion_options, &amp;tail, true)) {
2446       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2447       if (*tail == &#39;\0&#39;) {
2448         JavaAssertions::setUserClassDefault(enable);
2449       } else {
2450         assert(*tail == &#39;:&#39;, &quot;bogus match by match_option()&quot;);
2451         JavaAssertions::addOption(tail + 1, enable);
2452       }
2453     // -dsa / -esa / -disablesystemassertions / -enablesystemassertions
2454     } else if (match_option(option, system_assertion_options, &amp;tail, false)) {
2455       bool enable = option-&gt;optionString[1] == &#39;e&#39;;     // char after &#39;-&#39; is &#39;e&#39;
2456       JavaAssertions::setSystemClassDefault(enable);
2457     // -bootclasspath:
2458     } else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) {
2459         jio_fprintf(defaultStream::output_stream(),
2460           &quot;-Xbootclasspath is no longer a supported option.\n&quot;);
2461         return JNI_EINVAL;
2462     // -bootclasspath/a:
2463     } else if (match_option(option, &quot;-Xbootclasspath/a:&quot;, &amp;tail)) {
2464       Arguments::append_sysclasspath(tail);
2465     // -bootclasspath/p:
2466     } else if (match_option(option, &quot;-Xbootclasspath/p:&quot;, &amp;tail)) {
2467         jio_fprintf(defaultStream::output_stream(),
2468           &quot;-Xbootclasspath/p is no longer a supported option.\n&quot;);
2469         return JNI_EINVAL;
2470     // -Xrun
2471     } else if (match_option(option, &quot;-Xrun&quot;, &amp;tail)) {
2472       if (tail != NULL) {
2473         const char* pos = strchr(tail, &#39;:&#39;);
2474         size_t len = (pos == NULL) ? strlen(tail) : pos - tail;
2475         char* name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2476         jio_snprintf(name, len + 1, &quot;%s&quot;, tail);
2477 
2478         char *options = NULL;
2479         if(pos != NULL) {
2480           size_t len2 = strlen(pos+1) + 1; // options start after &#39;:&#39;.  Final zero must be copied.
2481           options = (char*)memcpy(NEW_C_HEAP_ARRAY(char, len2, mtArguments), pos+1, len2);
2482         }
2483 #if !INCLUDE_JVMTI
2484         if (strcmp(name, &quot;jdwp&quot;) == 0) {
2485           jio_fprintf(defaultStream::error_stream(),
2486             &quot;Debugging agents are not supported in this VM\n&quot;);
2487           return JNI_ERR;
2488         }
2489 #endif // !INCLUDE_JVMTI
2490         add_init_library(name, options);
2491       }
2492     } else if (match_option(option, &quot;--add-reads=&quot;, &amp;tail)) {
2493       if (!create_numbered_property(&quot;jdk.module.addreads&quot;, tail, addreads_count++)) {
2494         return JNI_ENOMEM;
2495       }
2496     } else if (match_option(option, &quot;--add-exports=&quot;, &amp;tail)) {
2497       if (!create_numbered_property(&quot;jdk.module.addexports&quot;, tail, addexports_count++)) {
2498         return JNI_ENOMEM;
2499       }
2500     } else if (match_option(option, &quot;--add-opens=&quot;, &amp;tail)) {
2501       if (!create_numbered_property(&quot;jdk.module.addopens&quot;, tail, addopens_count++)) {
2502         return JNI_ENOMEM;
2503       }
2504     } else if (match_option(option, &quot;--add-modules=&quot;, &amp;tail)) {
2505       if (!create_numbered_property(&quot;jdk.module.addmods&quot;, tail, addmods_count++)) {
2506         return JNI_ENOMEM;
2507       }
2508     } else if (match_option(option, &quot;--limit-modules=&quot;, &amp;tail)) {
2509       if (!create_property(&quot;jdk.module.limitmods&quot;, tail, InternalProperty)) {
2510         return JNI_ENOMEM;
2511       }
2512     } else if (match_option(option, &quot;--module-path=&quot;, &amp;tail)) {
2513       if (!create_property(&quot;jdk.module.path&quot;, tail, ExternalProperty)) {
2514         return JNI_ENOMEM;
2515       }
2516     } else if (match_option(option, &quot;--upgrade-module-path=&quot;, &amp;tail)) {
2517       if (!create_property(&quot;jdk.module.upgrade.path&quot;, tail, ExternalProperty)) {
2518         return JNI_ENOMEM;
2519       }
2520     } else if (match_option(option, &quot;--patch-module=&quot;, &amp;tail)) {
2521       // --patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
2522       int res = process_patch_mod_option(tail, patch_mod_javabase);
2523       if (res != JNI_OK) {
2524         return res;
2525       }
2526     } else if (match_option(option, &quot;--illegal-access=&quot;, &amp;tail)) {
2527       if (!create_property(&quot;jdk.module.illegalAccess&quot;, tail, ExternalProperty)) {
2528         return JNI_ENOMEM;
2529       }
2530     // -agentlib and -agentpath
2531     } else if (match_option(option, &quot;-agentlib:&quot;, &amp;tail) ||
2532           (is_absolute_path = match_option(option, &quot;-agentpath:&quot;, &amp;tail))) {
2533       if(tail != NULL) {
2534         const char* pos = strchr(tail, &#39;=&#39;);
2535         char* name;
2536         if (pos == NULL) {
2537           name = os::strdup_check_oom(tail, mtArguments);
2538         } else {
2539           size_t len = pos - tail;
2540           name = NEW_C_HEAP_ARRAY(char, len + 1, mtArguments);
2541           memcpy(name, tail, len);
2542           name[len] = &#39;\0&#39;;
2543         }
2544 
2545         char *options = NULL;
2546         if(pos != NULL) {
2547           options = os::strdup_check_oom(pos + 1, mtArguments);
2548         }
2549 #if !INCLUDE_JVMTI
2550         if (valid_jdwp_agent(name, is_absolute_path)) {
2551           jio_fprintf(defaultStream::error_stream(),
2552             &quot;Debugging agents are not supported in this VM\n&quot;);
2553           return JNI_ERR;
2554         }
2555 #endif // !INCLUDE_JVMTI
2556         add_init_agent(name, options, is_absolute_path);
2557       }
2558     // -javaagent
2559     } else if (match_option(option, &quot;-javaagent:&quot;, &amp;tail)) {
2560 #if !INCLUDE_JVMTI
2561       jio_fprintf(defaultStream::error_stream(),
2562         &quot;Instrumentation agents are not supported in this VM\n&quot;);
2563       return JNI_ERR;
2564 #else
2565       if (tail != NULL) {
2566         size_t length = strlen(tail) + 1;
2567         char *options = NEW_C_HEAP_ARRAY(char, length, mtArguments);
2568         jio_snprintf(options, length, &quot;%s&quot;, tail);
2569         add_instrument_agent(&quot;instrument&quot;, options, false);
2570         // java agents need module java.instrument
2571         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;java.instrument&quot;, addmods_count++)) {
2572           return JNI_ENOMEM;
2573         }
2574       }
2575 #endif // !INCLUDE_JVMTI
2576     // --enable_preview
2577     } else if (match_option(option, &quot;--enable-preview&quot;)) {
2578       set_enable_preview();
2579     // -Xnoclassgc
2580     } else if (match_option(option, &quot;-Xnoclassgc&quot;)) {
2581       if (FLAG_SET_CMDLINE(ClassUnloading, false) != JVMFlag::SUCCESS) {
2582         return JNI_EINVAL;
2583       }
2584     // -Xbatch
2585     } else if (match_option(option, &quot;-Xbatch&quot;)) {
2586       if (FLAG_SET_CMDLINE(BackgroundCompilation, false) != JVMFlag::SUCCESS) {
2587         return JNI_EINVAL;
2588       }
2589     // -Xmn for compatibility with other JVM vendors
2590     } else if (match_option(option, &quot;-Xmn&quot;, &amp;tail)) {
2591       julong long_initial_young_size = 0;
2592       ArgsRange errcode = parse_memory_size(tail, &amp;long_initial_young_size, 1);
2593       if (errcode != arg_in_range) {
2594         jio_fprintf(defaultStream::error_stream(),
2595                     &quot;Invalid initial young generation size: %s\n&quot;, option-&gt;optionString);
2596         describe_range_error(errcode);
2597         return JNI_EINVAL;
2598       }
2599       if (FLAG_SET_CMDLINE(MaxNewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
2600         return JNI_EINVAL;
2601       }
2602       if (FLAG_SET_CMDLINE(NewSize, (size_t)long_initial_young_size) != JVMFlag::SUCCESS) {
2603         return JNI_EINVAL;
2604       }
2605     // -Xms
2606     } else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) {
2607       julong size = 0;
2608       // an initial heap size of 0 means automatically determine
2609       ArgsRange errcode = parse_memory_size(tail, &amp;size, 0);
2610       if (errcode != arg_in_range) {
2611         jio_fprintf(defaultStream::error_stream(),
2612                     &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);
2613         describe_range_error(errcode);
2614         return JNI_EINVAL;
2615       }
2616       if (FLAG_SET_CMDLINE(MinHeapSize, (size_t)size) != JVMFlag::SUCCESS) {
2617         return JNI_EINVAL;
2618       }
2619       if (FLAG_SET_CMDLINE(InitialHeapSize, (size_t)size) != JVMFlag::SUCCESS) {
2620         return JNI_EINVAL;
2621       }
2622     // -Xmx
2623     } else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) {
2624       julong long_max_heap_size = 0;
2625       ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);
2626       if (errcode != arg_in_range) {
2627         jio_fprintf(defaultStream::error_stream(),
2628                     &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);
2629         describe_range_error(errcode);
2630         return JNI_EINVAL;
2631       }
2632       if (FLAG_SET_CMDLINE(MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) {
2633         return JNI_EINVAL;
2634       }
2635     // Xmaxf
2636     } else if (match_option(option, &quot;-Xmaxf&quot;, &amp;tail)) {
2637       char* err;
2638       int maxf = (int)(strtod(tail, &amp;err) * 100);
2639       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2640         jio_fprintf(defaultStream::error_stream(),
2641                     &quot;Bad max heap free percentage size: %s\n&quot;,
2642                     option-&gt;optionString);
2643         return JNI_EINVAL;
2644       } else {
2645         if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {
2646             return JNI_EINVAL;
2647         }
2648       }
2649     // Xminf
2650     } else if (match_option(option, &quot;-Xminf&quot;, &amp;tail)) {
2651       char* err;
2652       int minf = (int)(strtod(tail, &amp;err) * 100);
2653       if (*err != &#39;\0&#39; || *tail == &#39;\0&#39;) {
2654         jio_fprintf(defaultStream::error_stream(),
2655                     &quot;Bad min heap free percentage size: %s\n&quot;,
2656                     option-&gt;optionString);
2657         return JNI_EINVAL;
2658       } else {
2659         if (FLAG_SET_CMDLINE(MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {
2660           return JNI_EINVAL;
2661         }
2662       }
2663     // -Xss
2664     } else if (match_option(option, &quot;-Xss&quot;, &amp;tail)) {
2665       intx value = 0;
2666       jint err = parse_xss(option, tail, &amp;value);
2667       if (err != JNI_OK) {
2668         return err;
2669       }
2670       if (FLAG_SET_CMDLINE(ThreadStackSize, value) != JVMFlag::SUCCESS) {
2671         return JNI_EINVAL;
2672       }
2673     } else if (match_option(option, &quot;-Xmaxjitcodesize&quot;, &amp;tail) ||
2674                match_option(option, &quot;-XX:ReservedCodeCacheSize=&quot;, &amp;tail)) {
2675       julong long_ReservedCodeCacheSize = 0;
2676 
2677       ArgsRange errcode = parse_memory_size(tail, &amp;long_ReservedCodeCacheSize, 1);
2678       if (errcode != arg_in_range) {
2679         jio_fprintf(defaultStream::error_stream(),
2680                     &quot;Invalid maximum code cache size: %s.\n&quot;, option-&gt;optionString);
2681         return JNI_EINVAL;
2682       }
2683       if (FLAG_SET_CMDLINE(ReservedCodeCacheSize, (uintx)long_ReservedCodeCacheSize) != JVMFlag::SUCCESS) {
2684         return JNI_EINVAL;
2685       }
2686     // -green
2687     } else if (match_option(option, &quot;-green&quot;)) {
2688       jio_fprintf(defaultStream::error_stream(),
2689                   &quot;Green threads support not available\n&quot;);
2690           return JNI_EINVAL;
2691     // -native
2692     } else if (match_option(option, &quot;-native&quot;)) {
2693           // HotSpot always uses native threads, ignore silently for compatibility
2694     // -Xrs
2695     } else if (match_option(option, &quot;-Xrs&quot;)) {
2696           // Classic/EVM option, new functionality
2697       if (FLAG_SET_CMDLINE(ReduceSignalUsage, true) != JVMFlag::SUCCESS) {
2698         return JNI_EINVAL;
2699       }
2700       // -Xprof
2701     } else if (match_option(option, &quot;-Xprof&quot;)) {
2702       char version[256];
2703       // Obsolete in JDK 10
2704       JDK_Version::jdk(10).to_string(version, sizeof(version));
2705       warning(&quot;Ignoring option %s; support was removed in %s&quot;, option-&gt;optionString, version);
2706     // -Xinternalversion
2707     } else if (match_option(option, &quot;-Xinternalversion&quot;)) {
2708       jio_fprintf(defaultStream::output_stream(), &quot;%s\n&quot;,
2709                   VM_Version::internal_vm_info_string());
2710       vm_exit(0);
2711 #ifndef PRODUCT
2712     // -Xprintflags
2713     } else if (match_option(option, &quot;-Xprintflags&quot;)) {
2714       JVMFlag::printFlags(tty, false);
2715       vm_exit(0);
2716 #endif
2717     // -D
2718     } else if (match_option(option, &quot;-D&quot;, &amp;tail)) {
2719       const char* value;
2720       if (match_option(option, &quot;-Djava.endorsed.dirs=&quot;, &amp;value) &amp;&amp;
2721             *value!= &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2722         // abort if -Djava.endorsed.dirs is set
2723         jio_fprintf(defaultStream::output_stream(),
2724           &quot;-Djava.endorsed.dirs=%s is not supported. Endorsed standards and standalone APIs\n&quot;
2725           &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;, value);
2726         return JNI_EINVAL;
2727       }
2728       if (match_option(option, &quot;-Djava.ext.dirs=&quot;, &amp;value) &amp;&amp;
2729             *value != &#39;\0&#39; &amp;&amp; strcmp(value, &quot;\&quot;\&quot;&quot;) != 0) {
2730         // abort if -Djava.ext.dirs is set
2731         jio_fprintf(defaultStream::output_stream(),
2732           &quot;-Djava.ext.dirs=%s is not supported.  Use -classpath instead.\n&quot;, value);
2733         return JNI_EINVAL;
2734       }
2735       // Check for module related properties.  They must be set using the modules
2736       // options. For example: use &quot;--add-modules=java.sql&quot;, not
2737       // &quot;-Djdk.module.addmods=java.sql&quot;
2738       if (is_internal_module_property(option-&gt;optionString + 2)) {
2739         needs_module_property_warning = true;
2740         continue;
2741       }
2742       if (!add_property(tail)) {
2743         return JNI_ENOMEM;
2744       }
2745       // Out of the box management support
2746       if (match_option(option, &quot;-Dcom.sun.management&quot;, &amp;tail)) {
2747 #if INCLUDE_MANAGEMENT
2748         if (FLAG_SET_CMDLINE(ManagementServer, true) != JVMFlag::SUCCESS) {
2749           return JNI_EINVAL;
2750         }
2751         // management agent in module jdk.management.agent
2752         if (!create_numbered_property(&quot;jdk.module.addmods&quot;, &quot;jdk.management.agent&quot;, addmods_count++)) {
2753           return JNI_ENOMEM;
2754         }
2755 #else
2756         jio_fprintf(defaultStream::output_stream(),
2757           &quot;-Dcom.sun.management is not supported in this VM.\n&quot;);
2758         return JNI_ERR;
2759 #endif
2760       }
2761     // -Xint
2762     } else if (match_option(option, &quot;-Xint&quot;)) {
2763           set_mode_flags(_int);
2764     // -Xmixed
2765     } else if (match_option(option, &quot;-Xmixed&quot;)) {
2766           set_mode_flags(_mixed);
2767     // -Xcomp
2768     } else if (match_option(option, &quot;-Xcomp&quot;)) {
2769       // for testing the compiler; turn off all flags that inhibit compilation
2770           set_mode_flags(_comp);
2771     // -Xshare:dump
2772     } else if (match_option(option, &quot;-Xshare:dump&quot;)) {
2773       if (FLAG_SET_CMDLINE(DumpSharedSpaces, true) != JVMFlag::SUCCESS) {
2774         return JNI_EINVAL;
2775       }
2776     // -Xshare:on
2777     } else if (match_option(option, &quot;-Xshare:on&quot;)) {
2778       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
2779         return JNI_EINVAL;
2780       }
2781       if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
2782         return JNI_EINVAL;
2783       }
2784     // -Xshare:auto || -XX:ArchiveClassesAtExit=&lt;archive file&gt;
2785     } else if (match_option(option, &quot;-Xshare:auto&quot;)) {
2786       if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
2787         return JNI_EINVAL;
2788       }
2789       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
2790         return JNI_EINVAL;
2791       }
2792     // -Xshare:off
2793     } else if (match_option(option, &quot;-Xshare:off&quot;)) {
2794       if (FLAG_SET_CMDLINE(UseSharedSpaces, false) != JVMFlag::SUCCESS) {
2795         return JNI_EINVAL;
2796       }
2797       if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {
2798         return JNI_EINVAL;
2799       }
2800     // -Xverify
2801     } else if (match_option(option, &quot;-Xverify&quot;, &amp;tail)) {
2802       if (strcmp(tail, &quot;:all&quot;) == 0 || strcmp(tail, &quot;&quot;) == 0) {
2803         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, true) != JVMFlag::SUCCESS) {
2804           return JNI_EINVAL;
2805         }
2806         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
2807           return JNI_EINVAL;
2808         }
2809       } else if (strcmp(tail, &quot;:remote&quot;) == 0) {
2810         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
2811           return JNI_EINVAL;
2812         }
2813         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, true) != JVMFlag::SUCCESS) {
2814           return JNI_EINVAL;
2815         }
2816       } else if (strcmp(tail, &quot;:none&quot;) == 0) {
2817         if (FLAG_SET_CMDLINE(BytecodeVerificationLocal, false) != JVMFlag::SUCCESS) {
2818           return JNI_EINVAL;
2819         }
2820         if (FLAG_SET_CMDLINE(BytecodeVerificationRemote, false) != JVMFlag::SUCCESS) {
2821           return JNI_EINVAL;
2822         }
2823         warning(&quot;Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.&quot;);
2824       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized, &quot;verification&quot;)) {
2825         return JNI_EINVAL;
2826       }
2827     // -Xdebug
2828     } else if (match_option(option, &quot;-Xdebug&quot;)) {
2829       // note this flag has been used, then ignore
2830       set_xdebug_mode(true);
2831     // -Xnoagent
2832     } else if (match_option(option, &quot;-Xnoagent&quot;)) {
2833       // For compatibility with classic. HotSpot refuses to load the old style agent.dll.
2834     } else if (match_option(option, &quot;-Xloggc:&quot;, &amp;tail)) {
2835       // Deprecated flag to redirect GC output to a file. -Xloggc:&lt;filename&gt;
2836       log_warning(gc)(&quot;-Xloggc is deprecated. Will use -Xlog:gc:%s instead.&quot;, tail);
2837       _gc_log_filename = os::strdup_check_oom(tail);
2838     } else if (match_option(option, &quot;-Xlog&quot;, &amp;tail)) {
2839       bool ret = false;
2840       if (strcmp(tail, &quot;:help&quot;) == 0) {
2841         fileStream stream(defaultStream::output_stream());
2842         LogConfiguration::print_command_line_help(&amp;stream);
2843         vm_exit(0);
2844       } else if (strcmp(tail, &quot;:disable&quot;) == 0) {
2845         LogConfiguration::disable_logging();
2846         ret = true;
2847       } else if (*tail == &#39;\0&#39;) {
2848         ret = LogConfiguration::parse_command_line_arguments();
2849         assert(ret, &quot;-Xlog without arguments should never fail to parse&quot;);
2850       } else if (*tail == &#39;:&#39;) {
2851         ret = LogConfiguration::parse_command_line_arguments(tail + 1);
2852       }
2853       if (ret == false) {
2854         jio_fprintf(defaultStream::error_stream(),
2855                     &quot;Invalid -Xlog option &#39;-Xlog%s&#39;, see error log for details.\n&quot;,
2856                     tail);
2857         return JNI_EINVAL;
2858       }
2859     // JNI hooks
2860     } else if (match_option(option, &quot;-Xcheck&quot;, &amp;tail)) {
2861       if (!strcmp(tail, &quot;:jni&quot;)) {
2862 #if !INCLUDE_JNI_CHECK
2863         warning(&quot;JNI CHECKING is not supported in this VM&quot;);
2864 #else
2865         CheckJNICalls = true;
2866 #endif // INCLUDE_JNI_CHECK
2867       } else if (is_bad_option(option, args-&gt;ignoreUnrecognized,
2868                                      &quot;check&quot;)) {
2869         return JNI_EINVAL;
2870       }
2871     } else if (match_option(option, &quot;vfprintf&quot;)) {
2872       _vfprintf_hook = CAST_TO_FN_PTR(vfprintf_hook_t, option-&gt;extraInfo);
2873     } else if (match_option(option, &quot;exit&quot;)) {
2874       _exit_hook = CAST_TO_FN_PTR(exit_hook_t, option-&gt;extraInfo);
2875     } else if (match_option(option, &quot;abort&quot;)) {
2876       _abort_hook = CAST_TO_FN_PTR(abort_hook_t, option-&gt;extraInfo);
2877     // Need to keep consistency of MaxTenuringThreshold and AlwaysTenure/NeverTenure;
2878     // and the last option wins.
2879     } else if (match_option(option, &quot;-XX:+NeverTenure&quot;)) {
2880       if (FLAG_SET_CMDLINE(NeverTenure, true) != JVMFlag::SUCCESS) {
2881         return JNI_EINVAL;
2882       }
2883       if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {
2884         return JNI_EINVAL;
2885       }
2886       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {
2887         return JNI_EINVAL;
2888       }
2889     } else if (match_option(option, &quot;-XX:+AlwaysTenure&quot;)) {
2890       if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2891         return JNI_EINVAL;
2892       }
2893       if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {
2894         return JNI_EINVAL;
2895       }
2896       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, 0) != JVMFlag::SUCCESS) {
2897         return JNI_EINVAL;
2898       }
2899     } else if (match_option(option, &quot;-XX:MaxTenuringThreshold=&quot;, &amp;tail)) {
2900       uintx max_tenuring_thresh = 0;
2901       if (!parse_uintx(tail, &amp;max_tenuring_thresh, 0)) {
2902         jio_fprintf(defaultStream::error_stream(),
2903                     &quot;Improperly specified VM option \&#39;MaxTenuringThreshold=%s\&#39;\n&quot;, tail);
2904         return JNI_EINVAL;
2905       }
2906 
2907       if (FLAG_SET_CMDLINE(MaxTenuringThreshold, max_tenuring_thresh) != JVMFlag::SUCCESS) {
2908         return JNI_EINVAL;
2909       }
2910 
2911       if (MaxTenuringThreshold == 0) {
2912         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2913           return JNI_EINVAL;
2914         }
2915         if (FLAG_SET_CMDLINE(AlwaysTenure, true) != JVMFlag::SUCCESS) {
2916           return JNI_EINVAL;
2917         }
2918       } else {
2919         if (FLAG_SET_CMDLINE(NeverTenure, false) != JVMFlag::SUCCESS) {
2920           return JNI_EINVAL;
2921         }
2922         if (FLAG_SET_CMDLINE(AlwaysTenure, false) != JVMFlag::SUCCESS) {
2923           return JNI_EINVAL;
2924         }
2925       }
2926     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStderr&quot;)) {
2927       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, false) != JVMFlag::SUCCESS) {
2928         return JNI_EINVAL;
2929       }
2930       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, true) != JVMFlag::SUCCESS) {
2931         return JNI_EINVAL;
2932       }
2933     } else if (match_option(option, &quot;-XX:+DisplayVMOutputToStdout&quot;)) {
2934       if (FLAG_SET_CMDLINE(DisplayVMOutputToStderr, false) != JVMFlag::SUCCESS) {
2935         return JNI_EINVAL;
2936       }
2937       if (FLAG_SET_CMDLINE(DisplayVMOutputToStdout, true) != JVMFlag::SUCCESS) {
2938         return JNI_EINVAL;
2939       }
2940     } else if (match_option(option, &quot;-XX:+ErrorFileToStderr&quot;)) {
2941       if (FLAG_SET_CMDLINE(ErrorFileToStdout, false) != JVMFlag::SUCCESS) {
2942         return JNI_EINVAL;
2943       }
2944       if (FLAG_SET_CMDLINE(ErrorFileToStderr, true) != JVMFlag::SUCCESS) {
2945         return JNI_EINVAL;
2946       }
2947     } else if (match_option(option, &quot;-XX:+ErrorFileToStdout&quot;)) {
2948       if (FLAG_SET_CMDLINE(ErrorFileToStderr, false) != JVMFlag::SUCCESS) {
2949         return JNI_EINVAL;
2950       }
2951       if (FLAG_SET_CMDLINE(ErrorFileToStdout, true) != JVMFlag::SUCCESS) {
2952         return JNI_EINVAL;
2953       }
2954     } else if (match_option(option, &quot;-XX:+ExtendedDTraceProbes&quot;)) {
2955 #if defined(DTRACE_ENABLED)
2956       if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {
2957         return JNI_EINVAL;
2958       }
2959       if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {
2960         return JNI_EINVAL;
2961       }
2962       if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {
2963         return JNI_EINVAL;
2964       }
2965       if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {
2966         return JNI_EINVAL;
2967       }
2968 #else // defined(DTRACE_ENABLED)
2969       jio_fprintf(defaultStream::error_stream(),
2970                   &quot;ExtendedDTraceProbes flag is not applicable for this configuration\n&quot;);
2971       return JNI_EINVAL;
2972 #endif // defined(DTRACE_ENABLED)
2973 #ifdef ASSERT
2974     } else if (match_option(option, &quot;-XX:+FullGCALot&quot;)) {
2975       if (FLAG_SET_CMDLINE(FullGCALot, true) != JVMFlag::SUCCESS) {
2976         return JNI_EINVAL;
2977       }
2978       // disable scavenge before parallel mark-compact
2979       if (FLAG_SET_CMDLINE(ScavengeBeforeFullGC, false) != JVMFlag::SUCCESS) {
2980         return JNI_EINVAL;
2981       }
2982 #endif
2983 #if !INCLUDE_MANAGEMENT
2984     } else if (match_option(option, &quot;-XX:+ManagementServer&quot;)) {
2985         jio_fprintf(defaultStream::error_stream(),
2986           &quot;ManagementServer is not supported in this VM.\n&quot;);
2987         return JNI_ERR;
2988 #endif // INCLUDE_MANAGEMENT
2989 #if INCLUDE_JVMCI
2990     } else if (match_option(option, &quot;-XX:-EnableJVMCIProduct&quot;)) {
2991       if (EnableJVMCIProduct) {
2992         jio_fprintf(defaultStream::error_stream(),
2993                   &quot;-XX:-EnableJVMCIProduct cannot come after -XX:+EnableJVMCIProduct\n&quot;);
2994         return JNI_EINVAL;
2995       }
2996     } else if (match_option(option, &quot;-XX:+EnableJVMCIProduct&quot;)) {
2997       JVMFlag *jvmciFlag = JVMFlag::find_flag(&quot;EnableJVMCIProduct&quot;);
2998       // Allow this flag if it has been unlocked.
2999       if (jvmciFlag != NULL &amp;&amp; jvmciFlag-&gt;is_unlocked()) {
3000         if (!JVMCIGlobals::enable_jvmci_product_mode(origin)) {
3001           jio_fprintf(defaultStream::error_stream(),
3002             &quot;Unable to enable JVMCI in product mode&quot;);
3003           return JNI_ERR;
3004         }
3005       }
3006       // The flag was locked so process normally to report that error
3007       else if (!process_argument(&quot;EnableJVMCIProduct&quot;, args-&gt;ignoreUnrecognized, origin)) {
3008         return JNI_EINVAL;
3009       }
3010 #endif // INCLUDE_JVMCI
3011 #if INCLUDE_JFR
3012     } else if (match_jfr_option(&amp;option)) {
3013       return JNI_EINVAL;
3014 #endif
3015     } else if (match_option(option, &quot;-XX:&quot;, &amp;tail)) { // -XX:xxxx
3016       // Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have
3017       // already been handled
3018       if ((strncmp(tail, &quot;Flags=&quot;, strlen(&quot;Flags=&quot;)) != 0) &amp;&amp;
3019           (strncmp(tail, &quot;VMOptionsFile=&quot;, strlen(&quot;VMOptionsFile=&quot;)) != 0)) {
3020         if (!process_argument(tail, args-&gt;ignoreUnrecognized, origin)) {
3021           return JNI_EINVAL;
3022         }
3023       }
3024     // Unknown option
3025     } else if (is_bad_option(option, args-&gt;ignoreUnrecognized)) {
3026       return JNI_ERR;
3027     }
3028   }
3029 
3030   // PrintSharedArchiveAndExit will turn on
3031   //   -Xshare:on
3032   //   -Xlog:class+path=info
3033   if (PrintSharedArchiveAndExit) {
3034     if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {
3035       return JNI_EINVAL;
3036     }
3037     if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {
3038       return JNI_EINVAL;
3039     }
3040     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(class, path));
3041   }
3042 
3043   fix_appclasspath();
3044 
3045   return JNI_OK;
3046 }
3047 
3048 void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {
3049   // For java.base check for duplicate --patch-module options being specified on the command line.
3050   // This check is only required for java.base, all other duplicate module specifications
3051   // will be checked during module system initialization.  The module system initialization
3052   // will throw an ExceptionInInitializerError if this situation occurs.
3053   if (strcmp(module_name, JAVA_BASE_NAME) == 0) {
3054     if (*patch_mod_javabase) {
3055       vm_exit_during_initialization(&quot;Cannot specify &quot; JAVA_BASE_NAME &quot; more than once to --patch-module&quot;);
3056     } else {
3057       *patch_mod_javabase = true;
3058     }
3059   }
3060 
3061   // Create GrowableArray lazily, only if --patch-module has been specified
3062   if (_patch_mod_prefix == NULL) {
3063     _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;ModulePatchPath*&gt;(10, true);
3064   }
3065 
3066   _patch_mod_prefix-&gt;push(new ModulePatchPath(module_name, path));
3067 }
3068 
3069 // Remove all empty paths from the app classpath (if IgnoreEmptyClassPaths is enabled)
3070 //
3071 // This is necessary because some apps like to specify classpath like -cp foo.jar:${XYZ}:bar.jar
3072 // in their start-up scripts. If XYZ is empty, the classpath will look like &quot;-cp foo.jar::bar.jar&quot;.
3073 // Java treats such empty paths as if the user specified &quot;-cp foo.jar:.:bar.jar&quot;. I.e., an empty
3074 // path is treated as the current directory.
3075 //
3076 // This causes problems with CDS, which requires that all directories specified in the classpath
3077 // must be empty. In most cases, applications do NOT want to load classes from the current
3078 // directory anyway. Adding -XX:+IgnoreEmptyClassPaths will make these applications&#39; start-up
3079 // scripts compatible with CDS.
3080 void Arguments::fix_appclasspath() {
3081   if (IgnoreEmptyClassPaths) {
3082     const char separator = *os::path_separator();
3083     const char* src = _java_class_path-&gt;value();
3084 
3085     // skip over all the leading empty paths
3086     while (*src == separator) {
3087       src ++;
3088     }
3089 
3090     char* copy = os::strdup_check_oom(src, mtArguments);
3091 
3092     // trim all trailing empty paths
3093     for (char* tail = copy + strlen(copy) - 1; tail &gt;= copy &amp;&amp; *tail == separator; tail--) {
3094       *tail = &#39;\0&#39;;
3095     }
3096 
3097     char from[3] = {separator, separator, &#39;\0&#39;};
3098     char to  [2] = {separator, &#39;\0&#39;};
3099     while (StringUtils::replace_no_expand(copy, from, to) &gt; 0) {
3100       // Keep replacing &quot;::&quot; -&gt; &quot;:&quot; until we have no more &quot;::&quot; (non-windows)
3101       // Keep replacing &quot;;;&quot; -&gt; &quot;;&quot; until we have no more &quot;;;&quot; (windows)
3102     }
3103 
3104     _java_class_path-&gt;set_writeable_value(copy);
3105     FreeHeap(copy); // a copy was made by set_value, so don&#39;t need this anymore
3106   }
3107 }
3108 
3109 jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {
3110   // check if the default lib/endorsed directory exists; if so, error
3111   char path[JVM_MAXPATHLEN];
3112   const char* fileSep = os::file_separator();
3113   jio_snprintf(path, JVM_MAXPATHLEN, &quot;%s%slib%sendorsed&quot;, Arguments::get_java_home(), fileSep, fileSep);
3114 
3115   DIR* dir = os::opendir(path);
3116   if (dir != NULL) {
3117     jio_fprintf(defaultStream::output_stream(),
3118       &quot;&lt;JAVA_HOME&gt;/lib/endorsed is not supported. Endorsed standards and standalone APIs\n&quot;
3119       &quot;in modular form will be supported via the concept of upgradeable modules.\n&quot;);
3120     os::closedir(dir);
3121     return JNI_ERR;
3122   }
3123 
3124   jio_snprintf(path, JVM_MAXPATHLEN, &quot;%s%slib%sext&quot;, Arguments::get_java_home(), fileSep, fileSep);
3125   dir = os::opendir(path);
3126   if (dir != NULL) {
3127     jio_fprintf(defaultStream::output_stream(),
3128       &quot;&lt;JAVA_HOME&gt;/lib/ext exists, extensions mechanism no longer supported; &quot;
3129       &quot;Use -classpath instead.\n.&quot;);
3130     os::closedir(dir);
3131     return JNI_ERR;
3132   }
3133 
3134   // This must be done after all arguments have been processed
3135   // and the container support has been initialized since AggressiveHeap
3136   // relies on the amount of total memory available.
3137   if (AggressiveHeap) {
3138     jint result = set_aggressive_heap_flags();
3139     if (result != JNI_OK) {
3140       return result;
3141     }
3142   }
3143 
3144   // This must be done after all arguments have been processed.
3145   // java_compiler() true means set to &quot;NONE&quot; or empty.
3146   if (java_compiler() &amp;&amp; !xdebug_mode()) {
3147     // For backwards compatibility, we switch to interpreted mode if
3148     // -Djava.compiler=&quot;NONE&quot; or &quot;&quot; is specified AND &quot;-Xdebug&quot; was
3149     // not specified.
3150     set_mode_flags(_int);
3151   }
3152 
3153   // CompileThresholdScaling == 0.0 is same as -Xint: Disable compilation (enable interpreter-only mode),
3154   // but like -Xint, leave compilation thresholds unaffected.
3155   // With tiered compilation disabled, setting CompileThreshold to 0 disables compilation as well.
3156   if ((CompileThresholdScaling == 0.0) || (!TieredCompilation &amp;&amp; CompileThreshold == 0)) {
3157     set_mode_flags(_int);
3158   }
3159 
3160   // eventually fix up InitialTenuringThreshold if only MaxTenuringThreshold is set
3161   if (FLAG_IS_DEFAULT(InitialTenuringThreshold) &amp;&amp; (InitialTenuringThreshold &gt; MaxTenuringThreshold)) {
3162     FLAG_SET_ERGO(InitialTenuringThreshold, MaxTenuringThreshold);
3163   }
3164 
3165 #if !COMPILER2_OR_JVMCI
3166   // Don&#39;t degrade server performance for footprint
3167   if (FLAG_IS_DEFAULT(UseLargePages) &amp;&amp;
3168       MaxHeapSize &lt; LargePageHeapSizeThreshold) {
3169     // No need for large granularity pages w/small heaps.
3170     // Note that large pages are enabled/disabled for both the
3171     // Java heap and the code cache.
3172     FLAG_SET_DEFAULT(UseLargePages, false);
3173   }
3174 
3175   UNSUPPORTED_OPTION(ProfileInterpreter);
3176   NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));
3177 #endif
3178 
3179 
3180 #ifdef TIERED
3181   // Parse the CompilationMode flag
3182   if (!CompilationModeFlag::initialize()) {
3183     return JNI_ERR;
3184   }
3185 #else
3186   // Tiered compilation is undefined.
3187   UNSUPPORTED_OPTION(TieredCompilation);
3188 #endif
3189 
3190   if (!check_vm_args_consistency()) {
3191     return JNI_ERR;
3192   }
3193 
3194 #if INCLUDE_CDS
3195   if (DumpSharedSpaces) {
3196     // Disable biased locking now as it interferes with the clean up of
3197     // the archived Klasses and Java string objects (at dump time only).
3198     UseBiasedLocking = false;
3199 
3200     // Compiler threads may concurrently update the class metadata (such as method entries), so it&#39;s
3201     // unsafe with DumpSharedSpaces (which modifies the class metadata in place). Let&#39;s disable
3202     // compiler just to be safe.
3203     //
3204     // Note: this is not a concern for DynamicDumpSharedSpaces, which makes a copy of the class metadata
3205     // instead of modifying them in place. The copy is inaccessible to the compiler.
3206     // TODO: revisit the following for the static archive case.
3207     set_mode_flags(_int);
3208   }
3209   if (DumpSharedSpaces || ArchiveClassesAtExit != NULL) {
3210     // Always verify non-system classes during CDS dump
3211     if (!BytecodeVerificationRemote) {
3212       BytecodeVerificationRemote = true;
3213       log_info(cds)(&quot;All non-system classes will be verified (-Xverify:remote) during CDS dump time.&quot;);
3214     }
3215   }
3216   if (ArchiveClassesAtExit == NULL) {
3217     FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, false);
3218   }
3219   if (UseSharedSpaces &amp;&amp; patch_mod_javabase) {
3220     no_shared_spaces(&quot;CDS is disabled when &quot; JAVA_BASE_NAME &quot; module is patched.&quot;);
3221   }
3222   if (UseSharedSpaces &amp;&amp; !DumpSharedSpaces &amp;&amp; check_unsupported_cds_runtime_properties()) {
3223     FLAG_SET_DEFAULT(UseSharedSpaces, false);
3224   }
3225 #endif
3226 
3227 #ifndef CAN_SHOW_REGISTERS_ON_ASSERT
3228   UNSUPPORTED_OPTION(ShowRegistersOnAssert);
3229 #endif // CAN_SHOW_REGISTERS_ON_ASSERT
3230 
3231   return JNI_OK;
3232 }
3233 
3234 // Helper class for controlling the lifetime of JavaVMInitArgs
3235 // objects.  The contents of the JavaVMInitArgs are guaranteed to be
3236 // deleted on the destruction of the ScopedVMInitArgs object.
3237 class ScopedVMInitArgs : public StackObj {
3238  private:
3239   JavaVMInitArgs _args;
3240   char*          _container_name;
3241   bool           _is_set;
3242   char*          _vm_options_file_arg;
3243 
3244  public:
3245   ScopedVMInitArgs(const char *container_name) {
3246     _args.version = JNI_VERSION_1_2;
3247     _args.nOptions = 0;
3248     _args.options = NULL;
3249     _args.ignoreUnrecognized = false;
3250     _container_name = (char *)container_name;
3251     _is_set = false;
3252     _vm_options_file_arg = NULL;
3253   }
3254 
3255   // Populates the JavaVMInitArgs object represented by this
3256   // ScopedVMInitArgs object with the arguments in options.  The
3257   // allocated memory is deleted by the destructor.  If this method
3258   // returns anything other than JNI_OK, then this object is in a
3259   // partially constructed state, and should be abandoned.
3260   jint set_args(GrowableArray&lt;JavaVMOption&gt;* options) {
3261     _is_set = true;
3262     JavaVMOption* options_arr = NEW_C_HEAP_ARRAY_RETURN_NULL(
3263         JavaVMOption, options-&gt;length(), mtArguments);
3264     if (options_arr == NULL) {
3265       return JNI_ENOMEM;
3266     }
3267     _args.options = options_arr;
3268 
3269     for (int i = 0; i &lt; options-&gt;length(); i++) {
3270       options_arr[i] = options-&gt;at(i);
3271       options_arr[i].optionString = os::strdup(options_arr[i].optionString);
3272       if (options_arr[i].optionString == NULL) {
3273         // Rely on the destructor to do cleanup.
3274         _args.nOptions = i;
3275         return JNI_ENOMEM;
3276       }
3277     }
3278 
3279     _args.nOptions = options-&gt;length();
3280     _args.ignoreUnrecognized = IgnoreUnrecognizedVMOptions;
3281     return JNI_OK;
3282   }
3283 
3284   JavaVMInitArgs* get()             { return &amp;_args; }
3285   char* container_name()            { return _container_name; }
3286   bool  is_set()                    { return _is_set; }
3287   bool  found_vm_options_file_arg() { return _vm_options_file_arg != NULL; }
3288   char* vm_options_file_arg()       { return _vm_options_file_arg; }
3289 
3290   void set_vm_options_file_arg(const char *vm_options_file_arg) {
3291     if (_vm_options_file_arg != NULL) {
3292       os::free(_vm_options_file_arg);
3293     }
3294     _vm_options_file_arg = os::strdup_check_oom(vm_options_file_arg);
3295   }
3296 
3297   ~ScopedVMInitArgs() {
3298     if (_vm_options_file_arg != NULL) {
3299       os::free(_vm_options_file_arg);
3300     }
3301     if (_args.options == NULL) return;
3302     for (int i = 0; i &lt; _args.nOptions; i++) {
3303       os::free(_args.options[i].optionString);
3304     }
3305     FREE_C_HEAP_ARRAY(JavaVMOption, _args.options);
3306   }
3307 
3308   // Insert options into this option list, to replace option at
3309   // vm_options_file_pos (-XX:VMOptionsFile)
3310   jint insert(const JavaVMInitArgs* args,
3311               const JavaVMInitArgs* args_to_insert,
3312               const int vm_options_file_pos) {
3313     assert(_args.options == NULL, &quot;shouldn&#39;t be set yet&quot;);
3314     assert(args_to_insert-&gt;nOptions != 0, &quot;there should be args to insert&quot;);
3315     assert(vm_options_file_pos != -1, &quot;vm_options_file_pos should be set&quot;);
3316 
3317     int length = args-&gt;nOptions + args_to_insert-&gt;nOptions - 1;
3318     GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments)
3319               GrowableArray&lt;JavaVMOption&gt;(length, true);    // Construct new option array
3320     for (int i = 0; i &lt; args-&gt;nOptions; i++) {
3321       if (i == vm_options_file_pos) {
3322         // insert the new options starting at the same place as the
3323         // -XX:VMOptionsFile option
3324         for (int j = 0; j &lt; args_to_insert-&gt;nOptions; j++) {
3325           options-&gt;push(args_to_insert-&gt;options[j]);
3326         }
3327       } else {
3328         options-&gt;push(args-&gt;options[i]);
3329       }
3330     }
3331     // make into options array
3332     jint result = set_args(options);
3333     delete options;
3334     return result;
3335   }
3336 };
3337 
3338 jint Arguments::parse_java_options_environment_variable(ScopedVMInitArgs* args) {
3339   return parse_options_environment_variable(&quot;_JAVA_OPTIONS&quot;, args);
3340 }
3341 
3342 jint Arguments::parse_java_tool_options_environment_variable(ScopedVMInitArgs* args) {
3343   return parse_options_environment_variable(&quot;JAVA_TOOL_OPTIONS&quot;, args);
3344 }
3345 
3346 jint Arguments::parse_options_environment_variable(const char* name,
3347                                                    ScopedVMInitArgs* vm_args) {
3348   char *buffer = ::getenv(name);
3349 
3350   // Don&#39;t check this environment variable if user has special privileges
3351   // (e.g. unix su command).
3352   if (buffer == NULL || os::have_special_privileges()) {
3353     return JNI_OK;
3354   }
3355 
3356   if ((buffer = os::strdup(buffer)) == NULL) {
3357     return JNI_ENOMEM;
3358   }
3359 
3360   jio_fprintf(defaultStream::error_stream(),
3361               &quot;Picked up %s: %s\n&quot;, name, buffer);
3362 
3363   int retcode = parse_options_buffer(name, buffer, strlen(buffer), vm_args);
3364 
3365   os::free(buffer);
3366   return retcode;
3367 }
3368 
3369 jint Arguments::parse_vm_options_file(const char* file_name, ScopedVMInitArgs* vm_args) {
3370   // read file into buffer
3371   int fd = ::open(file_name, O_RDONLY);
3372   if (fd &lt; 0) {
3373     jio_fprintf(defaultStream::error_stream(),
3374                 &quot;Could not open options file &#39;%s&#39;\n&quot;,
3375                 file_name);
3376     return JNI_ERR;
3377   }
3378 
3379   struct stat stbuf;
3380   int retcode = os::stat(file_name, &amp;stbuf);
3381   if (retcode != 0) {
3382     jio_fprintf(defaultStream::error_stream(),
3383                 &quot;Could not stat options file &#39;%s&#39;\n&quot;,
3384                 file_name);
3385     os::close(fd);
3386     return JNI_ERR;
3387   }
3388 
3389   if (stbuf.st_size == 0) {
3390     // tell caller there is no option data and that is ok
3391     os::close(fd);
3392     return JNI_OK;
3393   }
3394 
3395   // &#39;+ 1&#39; for NULL termination even with max bytes
3396   size_t bytes_alloc = stbuf.st_size + 1;
3397 
3398   char *buf = NEW_C_HEAP_ARRAY_RETURN_NULL(char, bytes_alloc, mtArguments);
3399   if (NULL == buf) {
3400     jio_fprintf(defaultStream::error_stream(),
3401                 &quot;Could not allocate read buffer for options file parse\n&quot;);
3402     os::close(fd);
3403     return JNI_ENOMEM;
3404   }
3405 
3406   memset(buf, 0, bytes_alloc);
3407 
3408   // Fill buffer
3409   ssize_t bytes_read = os::read(fd, (void *)buf, (unsigned)bytes_alloc);
3410   os::close(fd);
3411   if (bytes_read &lt; 0) {
3412     FREE_C_HEAP_ARRAY(char, buf);
3413     jio_fprintf(defaultStream::error_stream(),
3414                 &quot;Could not read options file &#39;%s&#39;\n&quot;, file_name);
3415     return JNI_ERR;
3416   }
3417 
3418   if (bytes_read == 0) {
3419     // tell caller there is no option data and that is ok
3420     FREE_C_HEAP_ARRAY(char, buf);
3421     return JNI_OK;
3422   }
3423 
3424   retcode = parse_options_buffer(file_name, buf, bytes_read, vm_args);
3425 
3426   FREE_C_HEAP_ARRAY(char, buf);
3427   return retcode;
3428 }
3429 
3430 jint Arguments::parse_options_buffer(const char* name, char* buffer, const size_t buf_len, ScopedVMInitArgs* vm_args) {
3431   GrowableArray&lt;JavaVMOption&gt; *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray&lt;JavaVMOption&gt;(2, true);    // Construct option array
3432 
3433   // some pointers to help with parsing
3434   char *buffer_end = buffer + buf_len;
3435   char *opt_hd = buffer;
3436   char *wrt = buffer;
3437   char *rd = buffer;
3438 
3439   // parse all options
3440   while (rd &lt; buffer_end) {
3441     // skip leading white space from the input string
3442     while (rd &lt; buffer_end &amp;&amp; isspace(*rd)) {
3443       rd++;
3444     }
3445 
3446     if (rd &gt;= buffer_end) {
3447       break;
3448     }
3449 
3450     // Remember this is where we found the head of the token.
3451     opt_hd = wrt;
3452 
3453     // Tokens are strings of non white space characters separated
3454     // by one or more white spaces.
3455     while (rd &lt; buffer_end &amp;&amp; !isspace(*rd)) {
3456       if (*rd == &#39;\&#39;&#39; || *rd == &#39;&quot;&#39;) {      // handle a quoted string
3457         int quote = *rd;                    // matching quote to look for
3458         rd++;                               // don&#39;t copy open quote
3459         while (rd &lt; buffer_end &amp;&amp; *rd != quote) {
3460                                             // include everything (even spaces)
3461                                             // up until the close quote
3462           *wrt++ = *rd++;                   // copy to option string
3463         }
3464 
3465         if (rd &lt; buffer_end) {
3466           rd++;                             // don&#39;t copy close quote
3467         } else {
3468                                             // did not see closing quote
3469           jio_fprintf(defaultStream::error_stream(),
3470                       &quot;Unmatched quote in %s\n&quot;, name);
3471           delete options;
3472           return JNI_ERR;
3473         }
3474       } else {
3475         *wrt++ = *rd++;                     // copy to option string
3476       }
3477     }
3478 
3479     // steal a white space character and set it to NULL
3480     *wrt++ = &#39;\0&#39;;
3481     // We now have a complete token
3482 
3483     JavaVMOption option;
3484     option.optionString = opt_hd;
3485     option.extraInfo = NULL;
3486 
3487     options-&gt;append(option);                // Fill in option
3488 
3489     rd++;  // Advance to next character
3490   }
3491 
3492   // Fill out JavaVMInitArgs structure.
3493   jint status = vm_args-&gt;set_args(options);
3494 
3495   delete options;
3496   return status;
3497 }
3498 
3499 void Arguments::set_shared_spaces_flags() {
3500   if (DumpSharedSpaces) {
3501     if (RequireSharedSpaces) {
3502       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3503     }
3504     UseSharedSpaces = false;
3505 #ifdef _LP64
3506     if (!UseCompressedOops || !UseCompressedClassPointers) {
3507       vm_exit_during_initialization(
3508         &quot;Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.&quot;, NULL);
3509     }
3510   } else {
3511     if (!UseCompressedOops || !UseCompressedClassPointers) {
3512       no_shared_spaces(&quot;UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.&quot;);
3513     }
3514 #endif
3515   }
3516 }
3517 
3518 #if INCLUDE_CDS
3519 // Sharing support
3520 // Construct the path to the archive
3521 char* Arguments::get_default_shared_archive_path() {
3522   char *default_archive_path;
3523   char jvm_path[JVM_MAXPATHLEN];
3524   os::jvm_path(jvm_path, sizeof(jvm_path));
3525   char *end = strrchr(jvm_path, *os::file_separator());
3526   if (end != NULL) *end = &#39;\0&#39;;
3527   size_t jvm_path_len = strlen(jvm_path);
3528   size_t file_sep_len = strlen(os::file_separator());
3529   const size_t len = jvm_path_len + file_sep_len + 20;
3530   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
3531   jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,
3532                jvm_path, os::file_separator());
3533   return default_archive_path;
3534 }
3535 
3536 int Arguments::num_archives(const char* archive_path) {
3537   if (archive_path == NULL) {
3538     return 0;
3539   }
3540   int npaths = 1;
3541   char* p = (char*)archive_path;
3542   while (*p != &#39;\0&#39;) {
3543     if (*p == os::path_separator()[0]) {
3544       npaths++;
3545     }
3546     p++;
3547   }
3548   return npaths;
3549 }
3550 
3551 void Arguments::extract_shared_archive_paths(const char* archive_path,
3552                                          char** base_archive_path,
3553                                          char** top_archive_path) {
3554   char* begin_ptr = (char*)archive_path;
3555   char* end_ptr = strchr((char*)archive_path, os::path_separator()[0]);
3556   if (end_ptr == NULL || end_ptr == begin_ptr) {
3557     vm_exit_during_initialization(&quot;Base archive was not specified&quot;, archive_path);
3558   }
3559   size_t len = end_ptr - begin_ptr;
3560   char* cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
3561   strncpy(cur_path, begin_ptr, len);
3562   cur_path[len] = &#39;\0&#39;;
3563   FileMapInfo::check_archive((const char*)cur_path, true /*is_static*/);
3564   *base_archive_path = cur_path;
3565 
3566   begin_ptr = ++end_ptr;
3567   if (*begin_ptr == &#39;\0&#39;) {
3568     vm_exit_during_initialization(&quot;Top archive was not specified&quot;, archive_path);
3569   }
3570   end_ptr = strchr(begin_ptr, &#39;\0&#39;);
3571   assert(end_ptr != NULL, &quot;sanity&quot;);
3572   len = end_ptr - begin_ptr;
3573   cur_path = NEW_C_HEAP_ARRAY(char, len + 1, mtInternal);
3574   strncpy(cur_path, begin_ptr, len + 1);
3575   //cur_path[len] = &#39;\0&#39;;
3576   FileMapInfo::check_archive((const char*)cur_path, false /*is_static*/);
3577   *top_archive_path = cur_path;
3578 }
3579 
3580 bool Arguments::init_shared_archive_paths() {
3581   if (ArchiveClassesAtExit != NULL) {
3582     if (DumpSharedSpaces) {
3583       vm_exit_during_initialization(&quot;-XX:ArchiveClassesAtExit cannot be used with -Xshare:dump&quot;);
3584     }
3585     if (FLAG_SET_CMDLINE(DynamicDumpSharedSpaces, true) != JVMFlag::SUCCESS) {
3586       return false;
3587     }
3588     check_unsupported_dumping_properties();
3589     SharedDynamicArchivePath = os::strdup_check_oom(ArchiveClassesAtExit, mtArguments);
3590   }
3591   if (SharedArchiveFile == NULL) {
3592     SharedArchivePath = get_default_shared_archive_path();
3593   } else {
3594     int archives = num_archives(SharedArchiveFile);
3595     if (is_dumping_archive()) {
3596       if (archives &gt; 1) {
3597         vm_exit_during_initialization(
3598           &quot;Cannot have more than 1 archive file specified in -XX:SharedArchiveFile during CDS dumping&quot;);
3599       }
3600       if (DynamicDumpSharedSpaces) {
3601         if (os::same_files(SharedArchiveFile, ArchiveClassesAtExit)) {
3602           vm_exit_during_initialization(
3603             &quot;Cannot have the same archive file specified for -XX:SharedArchiveFile and -XX:ArchiveClassesAtExit&quot;,
3604             SharedArchiveFile);
3605         }
3606       }
3607     }
3608     if (!is_dumping_archive()){
3609       if (archives &gt; 2) {
3610         vm_exit_during_initialization(
3611           &quot;Cannot have more than 2 archive files specified in the -XX:SharedArchiveFile option&quot;);
3612       }
3613       if (archives == 1) {
3614         char* temp_archive_path = os::strdup_check_oom(SharedArchiveFile, mtArguments);
3615         int name_size;
3616         bool success =
3617           FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &amp;name_size, &amp;SharedArchivePath);
3618         if (!success) {
3619           SharedArchivePath = temp_archive_path;
3620         } else {
3621           SharedDynamicArchivePath = temp_archive_path;
3622         }
3623       } else {
3624         extract_shared_archive_paths((const char*)SharedArchiveFile,
3625                                       &amp;SharedArchivePath, &amp;SharedDynamicArchivePath);
3626       }
3627     } else { // CDS dumping
3628       SharedArchivePath = os::strdup_check_oom(SharedArchiveFile, mtArguments);
3629     }
3630   }
3631   return (SharedArchivePath != NULL);
3632 }
3633 #endif // INCLUDE_CDS
3634 
3635 #ifndef PRODUCT
3636 // Determine whether LogVMOutput should be implicitly turned on.
3637 static bool use_vm_log() {
3638   if (LogCompilation || !FLAG_IS_DEFAULT(LogFile) ||
3639       PrintCompilation || PrintInlining || PrintDependencies || PrintNativeNMethods ||
3640       PrintDebugInfo || PrintRelocations || PrintNMethods || PrintExceptionHandlers ||
3641       PrintAssembly || TraceDeoptimization || TraceDependencies ||
3642       (VerifyDependencies &amp;&amp; FLAG_IS_CMDLINE(VerifyDependencies))) {
3643     return true;
3644   }
3645 
3646 #ifdef COMPILER1
3647   if (PrintC1Statistics) {
3648     return true;
3649   }
3650 #endif // COMPILER1
3651 
3652 #ifdef COMPILER2
3653   if (PrintOptoAssembly || PrintOptoStatistics) {
3654     return true;
3655   }
3656 #endif // COMPILER2
3657 
3658   return false;
3659 }
3660 
3661 #endif // PRODUCT
3662 
3663 bool Arguments::args_contains_vm_options_file_arg(const JavaVMInitArgs* args) {
3664   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3665     const JavaVMOption* option = args-&gt;options + index;
3666     const char* tail;
3667     if (match_option(option, &quot;-XX:VMOptionsFile=&quot;, &amp;tail)) {
3668       return true;
3669     }
3670   }
3671   return false;
3672 }
3673 
3674 jint Arguments::insert_vm_options_file(const JavaVMInitArgs* args,
3675                                        const char* vm_options_file,
3676                                        const int vm_options_file_pos,
3677                                        ScopedVMInitArgs* vm_options_file_args,
3678                                        ScopedVMInitArgs* args_out) {
3679   jint code = parse_vm_options_file(vm_options_file, vm_options_file_args);
3680   if (code != JNI_OK) {
3681     return code;
3682   }
3683 
3684   if (vm_options_file_args-&gt;get()-&gt;nOptions &lt; 1) {
3685     return JNI_OK;
3686   }
3687 
3688   if (args_contains_vm_options_file_arg(vm_options_file_args-&gt;get())) {
3689     jio_fprintf(defaultStream::error_stream(),
3690                 &quot;A VM options file may not refer to a VM options file. &quot;
3691                 &quot;Specification of &#39;-XX:VMOptionsFile=&lt;file-name&gt;&#39; in the &quot;
3692                 &quot;options file &#39;%s&#39; in options container &#39;%s&#39; is an error.\n&quot;,
3693                 vm_options_file_args-&gt;vm_options_file_arg(),
3694                 vm_options_file_args-&gt;container_name());
3695     return JNI_EINVAL;
3696   }
3697 
3698   return args_out-&gt;insert(args, vm_options_file_args-&gt;get(),
3699                           vm_options_file_pos);
3700 }
3701 
3702 // Expand -XX:VMOptionsFile found in args_in as needed.
3703 // mod_args and args_out parameters may return values as needed.
3704 jint Arguments::expand_vm_options_as_needed(const JavaVMInitArgs* args_in,
3705                                             ScopedVMInitArgs* mod_args,
3706                                             JavaVMInitArgs** args_out) {
3707   jint code = match_special_option_and_act(args_in, mod_args);
3708   if (code != JNI_OK) {
3709     return code;
3710   }
3711 
3712   if (mod_args-&gt;is_set()) {
3713     // args_in contains -XX:VMOptionsFile and mod_args contains the
3714     // original options from args_in along with the options expanded
3715     // from the VMOptionsFile. Return a short-hand to the caller.
3716     *args_out = mod_args-&gt;get();
3717   } else {
3718     *args_out = (JavaVMInitArgs *)args_in;  // no changes so use args_in
3719   }
3720   return JNI_OK;
3721 }
3722 
3723 jint Arguments::match_special_option_and_act(const JavaVMInitArgs* args,
3724                                              ScopedVMInitArgs* args_out) {
3725   // Remaining part of option string
3726   const char* tail;
3727   ScopedVMInitArgs vm_options_file_args(args_out-&gt;container_name());
3728 
3729   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3730     const JavaVMOption* option = args-&gt;options + index;
3731     if (match_option(option, &quot;-XX:Flags=&quot;, &amp;tail)) {
3732       Arguments::set_jvm_flags_file(tail);
3733       continue;
3734     }
3735     if (match_option(option, &quot;-XX:VMOptionsFile=&quot;, &amp;tail)) {
3736       if (vm_options_file_args.found_vm_options_file_arg()) {
3737         jio_fprintf(defaultStream::error_stream(),
3738                     &quot;The option &#39;%s&#39; is already specified in the options &quot;
3739                     &quot;container &#39;%s&#39; so the specification of &#39;%s&#39; in the &quot;
3740                     &quot;same options container is an error.\n&quot;,
3741                     vm_options_file_args.vm_options_file_arg(),
3742                     vm_options_file_args.container_name(),
3743                     option-&gt;optionString);
3744         return JNI_EINVAL;
3745       }
3746       vm_options_file_args.set_vm_options_file_arg(option-&gt;optionString);
3747       // If there&#39;s a VMOptionsFile, parse that
3748       jint code = insert_vm_options_file(args, tail, index,
3749                                          &amp;vm_options_file_args, args_out);
3750       if (code != JNI_OK) {
3751         return code;
3752       }
3753       args_out-&gt;set_vm_options_file_arg(vm_options_file_args.vm_options_file_arg());
3754       if (args_out-&gt;is_set()) {
3755         // The VMOptions file inserted some options so switch &#39;args&#39;
3756         // to the new set of options, and continue processing which
3757         // preserves &quot;last option wins&quot; semantics.
3758         args = args_out-&gt;get();
3759         // The first option from the VMOptionsFile replaces the
3760         // current option.  So we back track to process the
3761         // replacement option.
3762         index--;
3763       }
3764       continue;
3765     }
3766     if (match_option(option, &quot;-XX:+PrintVMOptions&quot;)) {
3767       PrintVMOptions = true;
3768       continue;
3769     }
3770     if (match_option(option, &quot;-XX:-PrintVMOptions&quot;)) {
3771       PrintVMOptions = false;
3772       continue;
3773     }
3774     if (match_option(option, &quot;-XX:+IgnoreUnrecognizedVMOptions&quot;)) {
3775       IgnoreUnrecognizedVMOptions = true;
3776       continue;
3777     }
3778     if (match_option(option, &quot;-XX:-IgnoreUnrecognizedVMOptions&quot;)) {
3779       IgnoreUnrecognizedVMOptions = false;
3780       continue;
3781     }
3782     if (match_option(option, &quot;-XX:+PrintFlagsInitial&quot;)) {
3783       JVMFlag::printFlags(tty, false);
3784       vm_exit(0);
3785     }
3786     if (match_option(option, &quot;-XX:NativeMemoryTracking&quot;, &amp;tail)) {
3787 #if INCLUDE_NMT
3788       // The launcher did not setup nmt environment variable properly.
3789       if (!MemTracker::check_launcher_nmt_support(tail)) {
3790         warning(&quot;Native Memory Tracking did not setup properly, using wrong launcher?&quot;);
3791       }
3792 
3793       // Verify if nmt option is valid.
3794       if (MemTracker::verify_nmt_option()) {
3795         // Late initialization, still in single-threaded mode.
3796         if (MemTracker::tracking_level() &gt;= NMT_summary) {
3797           MemTracker::init();
3798         }
3799       } else {
3800         vm_exit_during_initialization(&quot;Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]&quot;, NULL);
3801       }
3802       continue;
3803 #else
3804       jio_fprintf(defaultStream::error_stream(),
3805         &quot;Native Memory Tracking is not supported in this VM\n&quot;);
3806       return JNI_ERR;
3807 #endif
3808     }
3809 
3810 #ifndef PRODUCT
3811     if (match_option(option, &quot;-XX:+PrintFlagsWithComments&quot;)) {
3812       JVMFlag::printFlags(tty, true);
3813       vm_exit(0);
3814     }
3815 #endif
3816   }
3817   return JNI_OK;
3818 }
3819 
3820 static void print_options(const JavaVMInitArgs *args) {
3821   const char* tail;
3822   for (int index = 0; index &lt; args-&gt;nOptions; index++) {
3823     const JavaVMOption *option = args-&gt;options + index;
3824     if (match_option(option, &quot;-XX:&quot;, &amp;tail)) {
3825       logOption(tail);
3826     }
3827   }
3828 }
3829 
3830 bool Arguments::handle_deprecated_print_gc_flags() {
3831   if (PrintGC) {
3832     log_warning(gc)(&quot;-XX:+PrintGC is deprecated. Will use -Xlog:gc instead.&quot;);
3833   }
3834   if (PrintGCDetails) {
3835     log_warning(gc)(&quot;-XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.&quot;);
3836   }
3837 
3838   if (_gc_log_filename != NULL) {
3839     // -Xloggc was used to specify a filename
3840     const char* gc_conf = PrintGCDetails ? &quot;gc*&quot; : &quot;gc&quot;;
3841 
3842     LogTarget(Error, logging) target;
3843     LogStream errstream(target);
3844     return LogConfiguration::parse_log_arguments(_gc_log_filename, gc_conf, NULL, NULL, &amp;errstream);
3845   } else if (PrintGC || PrintGCDetails) {
3846     LogConfiguration::configure_stdout(LogLevel::Info, !PrintGCDetails, LOG_TAGS(gc));
3847   }
3848   return true;
3849 }
3850 
3851 // Parse entry point called from JNI_CreateJavaVM
3852 
3853 jint Arguments::parse(const JavaVMInitArgs* initial_cmd_args) {
3854   assert(verify_special_jvm_flags(false), &quot;deprecated and obsolete flag table inconsistent&quot;);
3855 
3856   // Initialize ranges and constraints
3857   JVMFlagRangeList::init();
3858   JVMFlagConstraintList::init();
3859 
3860   // If flag &quot;-XX:Flags=flags-file&quot; is used it will be the first option to be processed.
3861   const char* hotspotrc = &quot;.hotspotrc&quot;;
3862   bool settings_file_specified = false;
3863   bool needs_hotspotrc_warning = false;
3864   ScopedVMInitArgs initial_vm_options_args(&quot;&quot;);
3865   ScopedVMInitArgs initial_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3866   ScopedVMInitArgs initial_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3867 
3868   // Pointers to current working set of containers
3869   JavaVMInitArgs* cur_cmd_args;
3870   JavaVMInitArgs* cur_vm_options_args;
3871   JavaVMInitArgs* cur_java_options_args;
3872   JavaVMInitArgs* cur_java_tool_options_args;
3873 
3874   // Containers for modified/expanded options
3875   ScopedVMInitArgs mod_cmd_args(&quot;cmd_line_args&quot;);
3876   ScopedVMInitArgs mod_vm_options_args(&quot;vm_options_args&quot;);
3877   ScopedVMInitArgs mod_java_tool_options_args(&quot;env_var=&#39;JAVA_TOOL_OPTIONS&#39;&quot;);
3878   ScopedVMInitArgs mod_java_options_args(&quot;env_var=&#39;_JAVA_OPTIONS&#39;&quot;);
3879 
3880 
3881   jint code =
3882       parse_java_tool_options_environment_variable(&amp;initial_java_tool_options_args);
3883   if (code != JNI_OK) {
3884     return code;
3885   }
3886 
3887   code = parse_java_options_environment_variable(&amp;initial_java_options_args);
3888   if (code != JNI_OK) {
3889     return code;
3890   }
3891 
3892   // Parse the options in the /java.base/jdk/internal/vm/options resource, if present
3893   char *vmoptions = ClassLoader::lookup_vm_options();
3894   if (vmoptions != NULL) {
3895     code = parse_options_buffer(&quot;vm options resource&quot;, vmoptions, strlen(vmoptions), &amp;initial_vm_options_args);
3896     FREE_C_HEAP_ARRAY(char, vmoptions);
3897     if (code != JNI_OK) {
3898       return code;
3899     }
3900   }
3901 
3902   code = expand_vm_options_as_needed(initial_java_tool_options_args.get(),
3903                                      &amp;mod_java_tool_options_args,
3904                                      &amp;cur_java_tool_options_args);
3905   if (code != JNI_OK) {
3906     return code;
3907   }
3908 
3909   code = expand_vm_options_as_needed(initial_cmd_args,
3910                                      &amp;mod_cmd_args,
3911                                      &amp;cur_cmd_args);
3912   if (code != JNI_OK) {
3913     return code;
3914   }
3915 
3916   code = expand_vm_options_as_needed(initial_java_options_args.get(),
3917                                      &amp;mod_java_options_args,
3918                                      &amp;cur_java_options_args);
3919   if (code != JNI_OK) {
3920     return code;
3921   }
3922 
3923   code = expand_vm_options_as_needed(initial_vm_options_args.get(),
3924                                      &amp;mod_vm_options_args,
3925                                      &amp;cur_vm_options_args);
3926   if (code != JNI_OK) {
3927     return code;
3928   }
3929 
3930   const char* flags_file = Arguments::get_jvm_flags_file();
3931   settings_file_specified = (flags_file != NULL);
3932 
3933   if (IgnoreUnrecognizedVMOptions) {
3934     cur_cmd_args-&gt;ignoreUnrecognized = true;
3935     cur_java_tool_options_args-&gt;ignoreUnrecognized = true;
3936     cur_java_options_args-&gt;ignoreUnrecognized = true;
3937   }
3938 
3939   // Parse specified settings file
3940   if (settings_file_specified) {
3941     if (!process_settings_file(flags_file, true,
3942                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3943       return JNI_EINVAL;
3944     }
3945   } else {
3946 #ifdef ASSERT
3947     // Parse default .hotspotrc settings file
3948     if (!process_settings_file(&quot;.hotspotrc&quot;, false,
3949                                cur_cmd_args-&gt;ignoreUnrecognized)) {
3950       return JNI_EINVAL;
3951     }
3952 #else
3953     struct stat buf;
3954     if (os::stat(hotspotrc, &amp;buf) == 0) {
3955       needs_hotspotrc_warning = true;
3956     }
3957 #endif
3958   }
3959 
3960   if (PrintVMOptions) {
3961     print_options(cur_java_tool_options_args);
3962     print_options(cur_cmd_args);
3963     print_options(cur_java_options_args);
3964   }
3965 
3966   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
3967   jint result = parse_vm_init_args(cur_vm_options_args,
3968                                    cur_java_tool_options_args,
3969                                    cur_java_options_args,
3970                                    cur_cmd_args);
3971 
3972   if (result != JNI_OK) {
3973     return result;
3974   }
3975 
3976 #if INCLUDE_CDS
3977   // Initialize shared archive paths which could include both base and dynamic archive paths
3978   if (!init_shared_archive_paths()) {
3979     return JNI_ENOMEM;
3980   }
3981 #endif
3982 
3983   // Delay warning until here so that we&#39;ve had a chance to process
3984   // the -XX:-PrintWarnings flag
3985   if (needs_hotspotrc_warning) {
3986     warning(&quot;%s file is present but has been ignored.  &quot;
3987             &quot;Run with -XX:Flags=%s to load the file.&quot;,
3988             hotspotrc, hotspotrc);
3989   }
3990 
3991   if (needs_module_property_warning) {
3992     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
3993             &quot; names that are reserved for internal use.&quot;);
3994   }
3995 
3996 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
3997   UNSUPPORTED_OPTION(UseLargePages);
3998 #endif
3999 
4000 #if defined(AIX)
4001   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
4002   UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);
4003 #endif
4004 
4005 #ifndef PRODUCT
4006   if (TraceBytecodesAt != 0) {
4007     TraceBytecodes = true;
4008   }
4009   if (CountCompiledCalls) {
4010     if (UseCounterDecay) {
4011       warning(&quot;UseCounterDecay disabled because CountCalls is set&quot;);
4012       UseCounterDecay = false;
4013     }
4014   }
4015 #endif // PRODUCT
4016 
4017   if (ScavengeRootsInCode == 0) {
4018     if (!FLAG_IS_DEFAULT(ScavengeRootsInCode)) {
4019       warning(&quot;Forcing ScavengeRootsInCode non-zero&quot;);
4020     }
4021     ScavengeRootsInCode = 1;
4022   }
4023 
4024   if (!handle_deprecated_print_gc_flags()) {
4025     return JNI_EINVAL;
4026   }
4027 
4028   // Set object alignment values.
4029   set_object_alignment();
4030 
4031 #if !INCLUDE_CDS
4032   if (DumpSharedSpaces || RequireSharedSpaces) {
4033     jio_fprintf(defaultStream::error_stream(),
4034       &quot;Shared spaces are not supported in this VM\n&quot;);
4035     return JNI_ERR;
4036   }
4037   if (DumpLoadedClassList != NULL) {
4038     jio_fprintf(defaultStream::error_stream(),
4039       &quot;DumpLoadedClassList is not supported in this VM\n&quot;);
4040     return JNI_ERR;
4041   }
4042   if ((UseSharedSpaces &amp;&amp; FLAG_IS_CMDLINE(UseSharedSpaces)) ||
4043       log_is_enabled(Info, cds)) {
4044     warning(&quot;Shared spaces are not supported in this VM&quot;);
4045     FLAG_SET_DEFAULT(UseSharedSpaces, false);
4046     LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(cds));
4047   }
4048   no_shared_spaces(&quot;CDS Disabled&quot;);
4049 #endif // INCLUDE_CDS
4050 
4051 #ifndef TIERED
4052   if (FLAG_IS_CMDLINE(CompilationMode)) {
4053     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);
4054   }
4055 #endif
4056 
4057   return JNI_OK;
4058 }
4059 
4060 jint Arguments::apply_ergo() {
4061   // Set flags based on ergonomics.
4062   jint result = set_ergonomics_flags();
4063   if (result != JNI_OK) return result;
4064 
4065   // Set heap size based on available physical memory
4066   set_heap_size();
4067 
4068   GCConfig::arguments()-&gt;initialize();
4069 
4070   set_shared_spaces_flags();
4071 
4072   // Initialize Metaspace flags and alignments
4073   Metaspace::ergo_initialize();
4074 
4075   // Set compiler flags after GC is selected and GC specific
4076   // flags (LoopStripMiningIter) are set.
4077   CompilerConfig::ergo_initialize();
4078 
4079   // Set bytecode rewriting flags
4080   set_bytecode_flags();
4081 
4082   // Set flags if aggressive optimization flags are enabled
4083   jint code = set_aggressive_opts_flags();
4084   if (code != JNI_OK) {
4085     return code;
4086   }
4087 
4088   // Turn off biased locking for locking debug mode flags,
4089   // which are subtly different from each other but neither works with
4090   // biased locking
4091   if (UseHeavyMonitors
4092 #ifdef COMPILER1
4093       || !UseFastLocking
4094 #endif // COMPILER1
4095 #if INCLUDE_JVMCI
4096       || !JVMCIUseFastLocking
4097 #endif
4098     ) {
4099     if (!FLAG_IS_DEFAULT(UseBiasedLocking) &amp;&amp; UseBiasedLocking) {
4100       // flag set to true on command line; warn the user that they
4101       // can&#39;t enable biased locking here
4102       warning(&quot;Biased Locking is not supported with locking debug flags&quot;
4103               &quot;; ignoring UseBiasedLocking flag.&quot; );
4104     }
4105     UseBiasedLocking = false;
4106   }
4107 
4108 #ifdef CC_INTERP
4109   // Clear flags not supported on zero.
4110   FLAG_SET_DEFAULT(ProfileInterpreter, false);
4111   FLAG_SET_DEFAULT(UseBiasedLocking, false);
4112   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));
4113   LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));
4114 #endif // CC_INTERP
4115 
4116   if (PrintAssembly &amp;&amp; FLAG_IS_DEFAULT(DebugNonSafepoints)) {
4117     warning(&quot;PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output&quot;);
4118     DebugNonSafepoints = true;
4119   }
4120 
4121   if (FLAG_IS_CMDLINE(CompressedClassSpaceSize) &amp;&amp; !UseCompressedClassPointers) {
4122     warning(&quot;Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used&quot;);
4123   }
4124 
4125   // Treat the odd case where local verification is enabled but remote
4126   // verification is not as if both were enabled.
4127   if (BytecodeVerificationLocal &amp;&amp; !BytecodeVerificationRemote) {
4128     log_info(verification)(&quot;Turning on remote verification because local verification is on&quot;);
4129     FLAG_SET_DEFAULT(BytecodeVerificationRemote, true);
4130   }
4131 
4132 #ifndef PRODUCT
4133   if (!LogVMOutput &amp;&amp; FLAG_IS_DEFAULT(LogVMOutput)) {
4134     if (use_vm_log()) {
4135       LogVMOutput = true;
4136     }
4137   }
4138 #endif // PRODUCT
4139 
4140   if (PrintCommandLineFlags) {
4141     JVMFlag::printSetFlags(tty);
4142   }
4143 
4144   // Apply CPU specific policy for the BiasedLocking
4145   if (UseBiasedLocking) {
4146     if (!VM_Version::use_biased_locking() &amp;&amp;
4147         !(FLAG_IS_CMDLINE(UseBiasedLocking))) {
4148       UseBiasedLocking = false;
4149     }
4150   }
4151 #ifdef COMPILER2
4152   if (!UseBiasedLocking) {
4153     UseOptoBiasInlining = false;
4154   }
4155 #endif
4156 
4157   return JNI_OK;
4158 }
4159 
4160 jint Arguments::adjust_after_os() {
4161   if (UseNUMA) {
<a name="2" id="anc2"></a><span class="line-modified">4162     if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {</span>
<span class="line-removed">4163       FLAG_SET_ERGO(UseNUMA, false);</span>
<span class="line-removed">4164     } else if (UseParallelGC) {</span>
4165       if (FLAG_IS_DEFAULT(MinHeapDeltaBytes)) {
4166          FLAG_SET_DEFAULT(MinHeapDeltaBytes, 64*M);
4167       }
4168     }
4169     // UseNUMAInterleaving is set to ON for all collectors and platforms when
4170     // UseNUMA is set to ON. NUMA-aware collectors will interleave old gen and
4171     // survivor spaces on top of NUMA allocation policy for the eden space.
4172     // Non NUMA-aware collectors will interleave all of the heap spaces across
4173     // NUMA nodes.
4174     if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {
4175       FLAG_SET_ERGO(UseNUMAInterleaving, true);
4176     }
4177   }
4178   return JNI_OK;
4179 }
4180 
4181 int Arguments::PropertyList_count(SystemProperty* pl) {
4182   int count = 0;
4183   while(pl != NULL) {
4184     count++;
4185     pl = pl-&gt;next();
4186   }
4187   return count;
4188 }
4189 
4190 // Return the number of readable properties.
4191 int Arguments::PropertyList_readable_count(SystemProperty* pl) {
4192   int count = 0;
4193   while(pl != NULL) {
4194     if (pl-&gt;is_readable()) {
4195       count++;
4196     }
4197     pl = pl-&gt;next();
4198   }
4199   return count;
4200 }
4201 
4202 const char* Arguments::PropertyList_get_value(SystemProperty *pl, const char* key) {
4203   assert(key != NULL, &quot;just checking&quot;);
4204   SystemProperty* prop;
4205   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
4206     if (strcmp(key, prop-&gt;key()) == 0) return prop-&gt;value();
4207   }
4208   return NULL;
4209 }
4210 
4211 // Return the value of the requested property provided that it is a readable property.
4212 const char* Arguments::PropertyList_get_readable_value(SystemProperty *pl, const char* key) {
4213   assert(key != NULL, &quot;just checking&quot;);
4214   SystemProperty* prop;
4215   // Return the property value if the keys match and the property is not internal or
4216   // it&#39;s the special internal property &quot;jdk.boot.class.path.append&quot;.
4217   for (prop = pl; prop != NULL; prop = prop-&gt;next()) {
4218     if (strcmp(key, prop-&gt;key()) == 0) {
4219       if (!prop-&gt;internal()) {
4220         return prop-&gt;value();
4221       } else if (strcmp(key, &quot;jdk.boot.class.path.append&quot;) == 0) {
4222         return prop-&gt;value();
4223       } else {
4224         // Property is internal and not jdk.boot.class.path.append so return NULL.
4225         return NULL;
4226       }
4227     }
4228   }
4229   return NULL;
4230 }
4231 
4232 const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {
4233   int count = 0;
4234   const char* ret_val = NULL;
4235 
4236   while(pl != NULL) {
4237     if(count &gt;= index) {
4238       ret_val = pl-&gt;key();
4239       break;
4240     }
4241     count++;
4242     pl = pl-&gt;next();
4243   }
4244 
4245   return ret_val;
4246 }
4247 
4248 char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {
4249   int count = 0;
4250   char* ret_val = NULL;
4251 
4252   while(pl != NULL) {
4253     if(count &gt;= index) {
4254       ret_val = pl-&gt;value();
4255       break;
4256     }
4257     count++;
4258     pl = pl-&gt;next();
4259   }
4260 
4261   return ret_val;
4262 }
4263 
4264 void Arguments::PropertyList_add(SystemProperty** plist, SystemProperty *new_p) {
4265   SystemProperty* p = *plist;
4266   if (p == NULL) {
4267     *plist = new_p;
4268   } else {
4269     while (p-&gt;next() != NULL) {
4270       p = p-&gt;next();
4271     }
4272     p-&gt;set_next(new_p);
4273   }
4274 }
4275 
4276 void Arguments::PropertyList_add(SystemProperty** plist, const char* k, const char* v,
4277                                  bool writeable, bool internal) {
4278   if (plist == NULL)
4279     return;
4280 
4281   SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);
4282   PropertyList_add(plist, new_p);
4283 }
4284 
4285 void Arguments::PropertyList_add(SystemProperty *element) {
4286   PropertyList_add(&amp;_system_properties, element);
4287 }
4288 
4289 // This add maintains unique property key in the list.
4290 void Arguments::PropertyList_unique_add(SystemProperty** plist, const char* k, const char* v,
4291                                         PropertyAppendable append, PropertyWriteable writeable,
4292                                         PropertyInternal internal) {
4293   if (plist == NULL)
4294     return;
4295 
4296   // If property key exist then update with new value.
4297   SystemProperty* prop;
4298   for (prop = *plist; prop != NULL; prop = prop-&gt;next()) {
4299     if (strcmp(k, prop-&gt;key()) == 0) {
4300       if (append == AppendProperty) {
4301         prop-&gt;append_value(v);
4302       } else {
4303         prop-&gt;set_value(v);
4304       }
4305       return;
4306     }
4307   }
4308 
4309   PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);
4310 }
4311 
4312 // Copies src into buf, replacing &quot;%%&quot; with &quot;%&quot; and &quot;%p&quot; with pid
4313 // Returns true if all of the source pointed by src has been copied over to
4314 // the destination buffer pointed by buf. Otherwise, returns false.
4315 // Notes:
4316 // 1. If the length (buflen) of the destination buffer excluding the
4317 // NULL terminator character is not long enough for holding the expanded
4318 // pid characters, it also returns false instead of returning the partially
4319 // expanded one.
4320 // 2. The passed in &quot;buflen&quot; should be large enough to hold the null terminator.
4321 bool Arguments::copy_expand_pid(const char* src, size_t srclen,
4322                                 char* buf, size_t buflen) {
4323   const char* p = src;
4324   char* b = buf;
4325   const char* src_end = &amp;src[srclen];
4326   char* buf_end = &amp;buf[buflen - 1];
4327 
4328   while (p &lt; src_end &amp;&amp; b &lt; buf_end) {
4329     if (*p == &#39;%&#39;) {
4330       switch (*(++p)) {
4331       case &#39;%&#39;:         // &quot;%%&quot; ==&gt; &quot;%&quot;
4332         *b++ = *p++;
4333         break;
4334       case &#39;p&#39;:  {       //  &quot;%p&quot; ==&gt; current process id
4335         // buf_end points to the character before the last character so
4336         // that we could write &#39;\0&#39; to the end of the buffer.
4337         size_t buf_sz = buf_end - b + 1;
4338         int ret = jio_snprintf(b, buf_sz, &quot;%d&quot;, os::current_process_id());
4339 
4340         // if jio_snprintf fails or the buffer is not long enough to hold
4341         // the expanded pid, returns false.
4342         if (ret &lt; 0 || ret &gt;= (int)buf_sz) {
4343           return false;
4344         } else {
4345           b += ret;
4346           assert(*b == &#39;\0&#39;, &quot;fail in copy_expand_pid&quot;);
4347           if (p == src_end &amp;&amp; b == buf_end + 1) {
4348             // reach the end of the buffer.
4349             return true;
4350           }
4351         }
4352         p++;
4353         break;
4354       }
4355       default :
4356         *b++ = &#39;%&#39;;
4357       }
4358     } else {
4359       *b++ = *p++;
4360     }
4361   }
4362   *b = &#39;\0&#39;;
4363   return (p == src_end); // return false if not all of the source was copied
4364 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>