<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,250 ***</span>
   */
  
  #ifndef SHARE_RUNTIME_SIGNATURE_HPP
  #define SHARE_RUNTIME_SIGNATURE_HPP
  
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  
<span class="line-modified">! // SignatureIterators iterate over a Java signature (or parts of it).</span>
<span class="line-modified">! // (Syntax according to: &quot;The Java Virtual Machine Specification&quot; by</span>
<span class="line-modified">! // Tim Lindholm &amp; Frank Yellin; section 4.3 Descriptors; p. 89ff.)</span>
  //
<span class="line-modified">! // Example: Iterating over ([Lfoo;D)I using</span>
<span class="line-modified">! //                         0123456789</span>
  //
<span class="line-modified">! // iterate_parameters() calls: do_array(2, 7); do_double();</span>
<span class="line-modified">! // iterate_returntype() calls:                              do_int();</span>
<span class="line-modified">! // iterate()            calls: do_array(2, 7); do_double(); do_int();</span>
  //
<span class="line-modified">! // is_return_type()        is: false         ; false      ; true</span>
  //
<span class="line-modified">! // NOTE: The new optimizer has an alternate, for-loop based signature</span>
<span class="line-modified">! // iterator implemented in opto/type.cpp, TypeTuple::make().</span>
  
  class SignatureIterator: public ResourceObj {
   protected:
    Symbol*      _signature;             // the signature to iterate over
<span class="line-removed">-   int          _index;                 // the current character index (only valid during iteration)</span>
<span class="line-removed">-   int          _parameter_index;       // the current parameter index (0 outside iteration phase)</span>
    BasicType    _return_type;
<span class="line-modified">! </span>
<span class="line-removed">-   void expect(char c);</span>
<span class="line-removed">-   int  parse_type();                   // returns the parameter size in words (0 for void)</span>
<span class="line-removed">-   void check_signature_end();</span>
  
   public:
    // Definitions used in generating and iterating the
    // bit field form of the signature generated by the
    // Fingerprinter.
    enum {
<span class="line-modified">!     static_feature_size    = 1,</span>
<span class="line-modified">!     is_static_bit          = 1,</span>
<span class="line-modified">! </span>
<span class="line-modified">!     result_feature_size    = 4,</span>
<span class="line-modified">!     result_feature_mask    = 0xF,</span>
<span class="line-modified">!     parameter_feature_size = 4,</span>
<span class="line-modified">!     parameter_feature_mask = 0xF,</span>
<span class="line-modified">! </span>
<span class="line-modified">!       bool_parm            = 1,</span>
<span class="line-modified">!       byte_parm            = 2,</span>
<span class="line-modified">!       char_parm            = 3,</span>
<span class="line-modified">!       short_parm           = 4,</span>
<span class="line-modified">!       int_parm             = 5,</span>
<span class="line-modified">!       long_parm            = 6,</span>
<span class="line-modified">!       float_parm           = 7,</span>
<span class="line-modified">!       double_parm          = 8,</span>
<span class="line-modified">!       obj_parm             = 9,</span>
<span class="line-modified">!       done_parm            = 10,  // marker for end of parameters</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // max parameters is wordsize minus</span>
<span class="line-removed">-     //    The sign bit, termination field, the result and static bit fields</span>
<span class="line-removed">-     max_size_of_parameters = (BitsPerLong-1 -</span>
<span class="line-removed">-                               result_feature_size - parameter_feature_size -</span>
<span class="line-removed">-                               static_feature_size) / parameter_feature_size</span>
    };
  
    // Constructors
<span class="line-modified">!   SignatureIterator(Symbol* signature);</span>
  
    // Iteration
<span class="line-modified">!   void iterate_parameters();           // iterates over parameters only</span>
<span class="line-modified">!   void iterate_parameters( uint64_t fingerprint );</span>
<span class="line-modified">!   void iterate_returntype();           // iterates over returntype only</span>
<span class="line-modified">!   void iterate();                      // iterates over whole signature</span>
<span class="line-modified">!   // Returns the word index of the current parameter;</span>
<span class="line-modified">!   int  parameter_index() const         { return _parameter_index; }</span>
<span class="line-modified">!   bool is_return_type() const          { return parameter_index() &lt; 0; }</span>
<span class="line-modified">!   BasicType get_ret_type() const       { return _return_type; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Basic types</span>
<span class="line-modified">!   virtual void do_bool  ()             = 0;</span>
<span class="line-modified">!   virtual void do_char  ()             = 0;</span>
<span class="line-modified">!   virtual void do_float ()             = 0;</span>
<span class="line-modified">!   virtual void do_double()             = 0;</span>
<span class="line-modified">!   virtual void do_byte  ()             = 0;</span>
<span class="line-modified">!   virtual void do_short ()             = 0;</span>
<span class="line-modified">!   virtual void do_int   ()             = 0;</span>
<span class="line-modified">!   virtual void do_long  ()             = 0;</span>
<span class="line-modified">!   virtual void do_void  ()             = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Object types (begin indexes the first character of the entry, end indexes the first character after the entry)</span>
<span class="line-modified">!   virtual void do_object(int begin, int end) = 0;</span>
<span class="line-removed">-   virtual void do_array (int begin, int end) = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static bool is_static(uint64_t fingerprint) {</span>
<span class="line-removed">-     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-removed">-     return fingerprint &amp; is_static_bit;</span>
    }
<span class="line-modified">!   static BasicType return_type(uint64_t fingerprint) {</span>
<span class="line-modified">!     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">!     return (BasicType) ((fingerprint &gt;&gt; static_feature_size) &amp; result_feature_mask);</span>
    }
  };
  
  
  // Specialized SignatureIterators: Used to compute signature specific values.
  
  class SignatureTypeNames : public SignatureIterator {
   protected:
    virtual void type_name(const char* name)   = 0;
  
<span class="line-modified">!   void do_bool()                       { type_name(&quot;jboolean&quot;); }</span>
<span class="line-modified">!   void do_char()                       { type_name(&quot;jchar&quot;   ); }</span>
<span class="line-modified">!   void do_float()                      { type_name(&quot;jfloat&quot;  ); }</span>
<span class="line-modified">!   void do_double()                     { type_name(&quot;jdouble&quot; ); }</span>
<span class="line-modified">!   void do_byte()                       { type_name(&quot;jbyte&quot;   ); }</span>
<span class="line-modified">!   void do_short()                      { type_name(&quot;jshort&quot;  ); }</span>
<span class="line-modified">!   void do_int()                        { type_name(&quot;jint&quot;    ); }</span>
<span class="line-modified">!   void do_long()                       { type_name(&quot;jlong&quot;   ); }</span>
<span class="line-modified">!   void do_void()                       { type_name(&quot;void&quot;    ); }</span>
<span class="line-modified">!   void do_object(int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>
<span class="line-modified">!   void do_array (int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>
  
   public:
    SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
  };
  
  
<span class="line-modified">! class SignatureInfo: public SignatureIterator {</span>
<span class="line-removed">-  protected:</span>
<span class="line-removed">-   bool      _has_iterated;             // need this because iterate cannot be called in constructor (set is virtual!)</span>
<span class="line-removed">-   bool      _has_iterated_return;</span>
<span class="line-removed">-   int       _size;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void lazy_iterate_parameters()       { if (!_has_iterated) { iterate_parameters(); _has_iterated = true; } }</span>
<span class="line-removed">-   void lazy_iterate_return()           { if (!_has_iterated_return) { iterate_returntype(); _has_iterated_return = true; } }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   virtual void set(int size, BasicType type) = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void do_bool  ()                     { set(T_BOOLEAN_size, T_BOOLEAN); }</span>
<span class="line-removed">-   void do_char  ()                     { set(T_CHAR_size   , T_CHAR   ); }</span>
<span class="line-removed">-   void do_float ()                     { set(T_FLOAT_size  , T_FLOAT  ); }</span>
<span class="line-removed">-   void do_double()                     { set(T_DOUBLE_size , T_DOUBLE ); }</span>
<span class="line-removed">-   void do_byte  ()                     { set(T_BYTE_size   , T_BYTE   ); }</span>
<span class="line-removed">-   void do_short ()                     { set(T_SHORT_size  , T_SHORT  ); }</span>
<span class="line-removed">-   void do_int   ()                     { set(T_INT_size    , T_INT    ); }</span>
<span class="line-removed">-   void do_long  ()                     { set(T_LONG_size   , T_LONG   ); }</span>
<span class="line-removed">-   void do_void  ()                     { set(T_VOID_size   , T_VOID   ); }</span>
<span class="line-removed">-   void do_object(int begin, int end)   { set(T_OBJECT_size , T_OBJECT ); }</span>
<span class="line-removed">-   void do_array (int begin, int end)   { set(T_ARRAY_size  , T_ARRAY  ); }</span>
  
   public:
<span class="line-modified">!   SignatureInfo(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified">!     _has_iterated = _has_iterated_return = false;</span>
<span class="line-removed">-     _size         = 0;</span>
<span class="line-removed">-     _return_type  = T_ILLEGAL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
  };
  
  
<span class="line-modified">! // Specialized SignatureIterator: Used to compute the argument size.</span>
<span class="line-removed">- </span>
<span class="line-removed">- class ArgumentSizeComputer: public SignatureInfo {</span>
   private:
<span class="line-modified">!   void set(int size, BasicType type)   { _size += size; }</span>
   public:
<span class="line-modified">!   ArgumentSizeComputer(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">! </span>
<span class="line-removed">-   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
  };
  
  
<span class="line-modified">! class ArgumentCount: public SignatureInfo {</span>
   private:
<span class="line-modified">!   void set(int size, BasicType type)   { _size ++; }</span>
   public:
<span class="line-modified">!   ArgumentCount(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">! </span>
<span class="line-removed">-   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
  };
  
  
  // Specialized SignatureIterator: Used to compute the result type.
  
<span class="line-modified">! class ResultTypeFinder: public SignatureInfo {</span>
<span class="line-removed">-  private:</span>
<span class="line-removed">-   void set(int size, BasicType type)   { _return_type = type; }</span>
   public:
<span class="line-modified">!   BasicType type()                     { lazy_iterate_return(); return _return_type; }</span>
<span class="line-modified">! </span>
<span class="line-removed">-   ResultTypeFinder(Symbol* signature) : SignatureInfo(signature) {}</span>
  };
  
  
  // Fingerprinter computes a unique ID for a given method. The ID
  // is a bitvector characterizing the methods signature (incl. the receiver).
  class Fingerprinter: public SignatureIterator {
   private:
<span class="line-modified">!   uint64_t _fingerprint;</span>
    int _shift_count;
<span class="line-modified">!   methodHandle mh;</span>
<span class="line-removed">- </span>
<span class="line-removed">-  public:</span>
  
<span class="line-modified">!   void do_bool()    { _fingerprint |= (((uint64_t)bool_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">!   void do_char()    { _fingerprint |= (((uint64_t)char_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">!   void do_byte()    { _fingerprint |= (((uint64_t)byte_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">!   void do_short()   { _fingerprint |= (((uint64_t)short_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">!   void do_int()     { _fingerprint |= (((uint64_t)int_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">-   void do_long()    { _fingerprint |= (((uint64_t)long_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">-   void do_float()   { _fingerprint |= (((uint64_t)float_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">-   void do_double()  { _fingerprint |= (((uint64_t)double_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   void do_object(int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">-   void do_array (int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
  
<span class="line-modified">!   void do_void()    { ShouldNotReachHere(); }</span>
  
<span class="line-modified">!   Fingerprinter(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {</span>
<span class="line-modified">!     mh = method;</span>
<span class="line-modified">!     _fingerprint = 0;</span>
    }
  
<span class="line-modified">!   uint64_t fingerprint() {</span>
<span class="line-modified">!     // See if we fingerprinted this method already</span>
<span class="line-modified">!     if (mh-&gt;constMethod()-&gt;fingerprint() != CONST64(0)) {</span>
<span class="line-removed">-       return mh-&gt;constMethod()-&gt;fingerprint();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (mh-&gt;size_of_parameters() &gt; max_size_of_parameters ) {</span>
<span class="line-removed">-       _fingerprint = (uint64_t)CONST64(-1);</span>
<span class="line-removed">-       mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-removed">-       return _fingerprint;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     assert( (int)mh-&gt;result_type() &lt;= (int)result_feature_mask, &quot;bad result type&quot;);</span>
<span class="line-modified">!     _fingerprint = mh-&gt;result_type();</span>
<span class="line-modified">!     _fingerprint &lt;&lt;= static_feature_size;</span>
<span class="line-modified">!     if (mh-&gt;is_static())  _fingerprint |= 1;</span>
<span class="line-modified">!     _shift_count = result_feature_size + static_feature_size;</span>
<span class="line-modified">!     iterate_parameters();</span>
<span class="line-modified">!     _fingerprint |= ((uint64_t)done_parm) &lt;&lt; _shift_count;// mark end of sig</span>
<span class="line-modified">!     mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-modified">!     return _fingerprint;</span>
    }
  };
  
  
  // Specialized SignatureIterator: Used for native call purposes
<span class="line-new-header">--- 23,352 ---</span>
   */
  
  #ifndef SHARE_RUNTIME_SIGNATURE_HPP
  #define SHARE_RUNTIME_SIGNATURE_HPP
  
<span class="line-added">+ #include &quot;classfile/symbolTable.hpp&quot;</span>
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;oops/method.hpp&quot;
  
<span class="line-modified">! </span>
<span class="line-modified">! // Static routines and parsing loops for processing field and method</span>
<span class="line-modified">! // descriptors.  In the HotSpot sources we call them &quot;signatures&quot;.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // A SignatureStream iterates over a Java descriptor (or parts of it).</span>
<span class="line-added">+ // The syntax is documented in the Java Virtual Machine Specification,</span>
<span class="line-added">+ // section 4.3.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // The syntax may be summarized as follows:</span>
<span class="line-added">+ //</span>
<span class="line-added">+ //     MethodType: &#39;(&#39; {FieldType}* &#39;)&#39; (FieldType | &#39;V&#39;)</span>
<span class="line-added">+ //     FieldType: PrimitiveType | ObjectType | ArrayType</span>
<span class="line-added">+ //     PrimitiveType: &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;F&#39; | &#39;I&#39; | &#39;J&#39; | &#39;S&#39; | &#39;Z&#39;</span>
<span class="line-added">+ //     ObjectType: &#39;L&#39; ClassName &#39;;&#39; | ArrayType</span>
<span class="line-added">+ //     ArrayType: &#39;[&#39; FieldType</span>
<span class="line-added">+ //     ClassName: {UnqualifiedName &#39;/&#39;}* UnqualifiedName</span>
<span class="line-added">+ //     UnqualifiedName: NameChar {NameChar}*</span>
<span class="line-added">+ //     NameChar: ANY_CHAR_EXCEPT(&#39;/&#39; | &#39;.&#39; | &#39;;&#39; | &#39;[&#39;)</span>
  //
<span class="line-modified">! // All of the concrete characters in the above grammar are given</span>
<span class="line-modified">! // standard manifest constant names of the form JVM_SIGNATURE_x.</span>
<span class="line-added">+ // Executable code uses these constant names in preference to raw</span>
<span class="line-added">+ // character constants.  Comments and assertion code sometimes use</span>
<span class="line-added">+ // the raw character constants for brevity.</span>
  //
<span class="line-modified">! // The primitive field types (like &#39;I&#39;) correspond 1-1 with type codes</span>
<span class="line-modified">! // (like T_INT) which form part of the specification of the &#39;newarray&#39;</span>
<span class="line-modified">! // instruction (JVMS 6.5, section on newarray).  These type codes are</span>
<span class="line-added">+ // widely used in the HotSpot code.  They are joined by ad hoc codes</span>
<span class="line-added">+ // like T_OBJECT and T_ARRAY (defined in HotSpot but not in the JVMS)</span>
<span class="line-added">+ // so that each &quot;basic type&quot; of field descriptor (or void return type)</span>
<span class="line-added">+ // has a corresponding T_x code.  Thus, while T_x codes play a very</span>
<span class="line-added">+ // minor role in the JVMS, they play a major role in the HotSpot</span>
<span class="line-added">+ // sources.  There are fewer than 16 such &quot;basic types&quot;, so they fit</span>
<span class="line-added">+ // nicely into bitfields.</span>
  //
<span class="line-modified">! // The syntax of ClassName overlaps slightly with the descriptor</span>
<span class="line-added">+ // syntaxes.  The strings &quot;I&quot; and &quot;(I)V&quot; are both class names</span>
<span class="line-added">+ // *and* descriptors.  If a class name contains any character other</span>
<span class="line-added">+ // than &quot;BCDFIJSZ()V&quot; it cannot be confused with a descriptor.</span>
<span class="line-added">+ // Class names inside of descriptors are always contained in an</span>
<span class="line-added">+ // &quot;envelope&quot; syntax which starts with &#39;L&#39; and ends with &#39;;&#39;.</span>
  //
<span class="line-modified">! // As a confounding factor, array types report their type name strings</span>
<span class="line-modified">! // in descriptor format.  These name strings are easy to recognize,</span>
<span class="line-added">+ // since they begin with &#39;[&#39;.  For this reason some API points on</span>
<span class="line-added">+ // HotSpot look for array descriptors as well as proper class names.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // For historical reasons some API points that accept class names and</span>
<span class="line-added">+ // array names also look for class names wrapped inside an envelope</span>
<span class="line-added">+ // (like &quot;LFoo;&quot;) and unwrap them on the fly (to a name like &quot;Foo&quot;).</span>
<span class="line-added">+ </span>
<span class="line-added">+ class Signature : AllStatic {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   static bool is_valid_array_signature(const Symbol* sig);</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Returns the basic type of a field signature (or T_VOID for &quot;V&quot;).</span>
<span class="line-added">+   // Assumes the signature is a valid field descriptor.</span>
<span class="line-added">+   // Do not apply this function to class names or method signatures.</span>
<span class="line-added">+   static BasicType basic_type(const Symbol* signature) {</span>
<span class="line-added">+     return basic_type(signature-&gt;char_at(0));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Returns T_ILLEGAL for an illegal signature char.</span>
<span class="line-added">+   static BasicType basic_type(int ch);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming it is either a class name or signature,</span>
<span class="line-added">+   // determine if it in fact cannot be a class name.</span>
<span class="line-added">+   // This means it either starts with &#39;[&#39; or ends with &#39;;&#39;</span>
<span class="line-added">+   static bool not_class_name(const Symbol* signature) {</span>
<span class="line-added">+     return (signature-&gt;starts_with(JVM_SIGNATURE_ARRAY) ||</span>
<span class="line-added">+             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming it is either a class name or signature,</span>
<span class="line-added">+   // determine if it in fact is an array descriptor.</span>
<span class="line-added">+   static bool is_array(const Symbol* signature) {</span>
<span class="line-added">+     return (signature-&gt;utf8_length() &gt; 1 &amp;&amp;</span>
<span class="line-added">+             signature-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">+             is_valid_array_signature(signature));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming it is either a class name or signature,</span>
<span class="line-added">+   // determine if it contains a class name plus &#39;;&#39;.</span>
<span class="line-added">+   static bool has_envelope(const Symbol* signature) {</span>
<span class="line-added">+     return ((signature-&gt;utf8_length() &gt; 0) &amp;&amp;</span>
<span class="line-added">+             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS) &amp;&amp;</span>
<span class="line-added">+             has_envelope(signature-&gt;char_at(0)));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Determine if this signature char introduces an</span>
<span class="line-added">+   // envelope, which is a class name plus &#39;;&#39;.</span>
<span class="line-added">+   static bool has_envelope(char signature_char) {</span>
<span class="line-added">+     return (signature_char == JVM_SIGNATURE_CLASS);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming has_envelope is true, return the symbol</span>
<span class="line-added">+   // inside the envelope, by stripping &#39;L&#39; and &#39;;&#39;.</span>
<span class="line-added">+   // Caller is responsible for decrementing the newly created</span>
<span class="line-added">+   // Symbol&#39;s refcount, use TempNewSymbol.</span>
<span class="line-added">+   static Symbol* strip_envelope(const Symbol* signature) {</span>
<span class="line-added">+     assert(has_envelope(signature), &quot;precondition&quot;);</span>
<span class="line-added">+     return SymbolTable::new_symbol((char*) signature-&gt;bytes() + 1,</span>
<span class="line-added">+                                    signature-&gt;utf8_length() - 2);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming it&#39;s either a field or method descriptor, determine</span>
<span class="line-added">+   // whether it is in fact a method descriptor:</span>
<span class="line-added">+   static bool is_method(const Symbol* signature) {</span>
<span class="line-added">+     return signature-&gt;starts_with(JVM_SIGNATURE_FUNC);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Assuming it&#39;s a method signature, determine if it must</span>
<span class="line-added">+   // return void.</span>
<span class="line-added">+   static bool is_void_method(const Symbol* signature) {</span>
<span class="line-added">+     assert(is_method(signature), &quot;signature is not for a method&quot;);</span>
<span class="line-added">+     return signature-&gt;ends_with(JVM_SIGNATURE_VOID);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ // A SignatureIterator uses a SignatureStream to produce BasicType</span>
<span class="line-added">+ // results, discarding class names.  This means it can be accelerated</span>
<span class="line-added">+ // using a fingerprint mechanism, in many cases, without loss of type</span>
<span class="line-added">+ // information.  The FingerPrinter class computes and caches this</span>
<span class="line-added">+ // reduced information for faster iteration.</span>
  
  class SignatureIterator: public ResourceObj {
<span class="line-added">+  public:</span>
<span class="line-added">+   typedef uint64_t fingerprint_t;</span>
<span class="line-added">+ </span>
   protected:
    Symbol*      _signature;             // the signature to iterate over
    BasicType    _return_type;
<span class="line-modified">!   fingerprint_t _fingerprint;</span>
  
   public:
    // Definitions used in generating and iterating the
    // bit field form of the signature generated by the
    // Fingerprinter.
    enum {
<span class="line-modified">!     fp_static_feature_size    = 1,</span>
<span class="line-modified">!     fp_is_static_bit          = 1,</span>
<span class="line-modified">! </span>
<span class="line-modified">!     fp_result_feature_size    = 4,</span>
<span class="line-modified">!     fp_result_feature_mask    = right_n_bits(fp_result_feature_size),</span>
<span class="line-modified">!     fp_parameter_feature_size = 4,</span>
<span class="line-modified">!     fp_parameter_feature_mask = right_n_bits(fp_parameter_feature_size),</span>
<span class="line-modified">! </span>
<span class="line-modified">!     fp_parameters_done        = 0,  // marker for end of parameters (must be zero)</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Parameters take up full wordsize, minus the result and static bit fields.</span>
<span class="line-modified">!     // Since fp_parameters_done is zero, termination field arises from shifting</span>
<span class="line-modified">!     // in zero bits, and therefore occupies no extra space.</span>
<span class="line-modified">!     // The sentinel value is all-zero-bits, which is impossible for a true</span>
<span class="line-modified">!     // fingerprint, since at least the result field will be non-zero.</span>
<span class="line-modified">!     fp_max_size_of_parameters = ((BitsPerLong</span>
<span class="line-modified">!                                   - (fp_result_feature_size + fp_static_feature_size))</span>
<span class="line-modified">!                                  / fp_parameter_feature_size)</span>
    };
  
<span class="line-added">+   static bool fp_is_valid_type(BasicType type, bool for_return_type = false);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Sentinel values are zero and not-zero (-1).</span>
<span class="line-added">+   // No need to protect the sign bit, since every valid return type is non-zero</span>
<span class="line-added">+   // (even T_VOID), and there are no valid parameter fields which are 0xF (T_VOID).</span>
<span class="line-added">+   static fingerprint_t zero_fingerprint() { return (fingerprint_t)0; }</span>
<span class="line-added">+   static fingerprint_t overflow_fingerprint() { return ~(fingerprint_t)0; }</span>
<span class="line-added">+   static bool fp_is_valid(fingerprint_t fingerprint) {</span>
<span class="line-added">+     return (fingerprint != zero_fingerprint()) &amp;&amp; (fingerprint != overflow_fingerprint());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Constructors
<span class="line-modified">!   SignatureIterator(Symbol* signature, fingerprint_t fingerprint = zero_fingerprint()) {</span>
<span class="line-added">+     _signature   = signature;</span>
<span class="line-added">+     _return_type = T_ILLEGAL;  // sentinel value for uninitialized</span>
<span class="line-added">+     _fingerprint = zero_fingerprint();</span>
<span class="line-added">+     if (fingerprint != _fingerprint) {</span>
<span class="line-added">+       set_fingerprint(fingerprint);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // If the fingerprint is present, we can use an accelerated loop.</span>
<span class="line-added">+   void set_fingerprint(fingerprint_t fingerprint);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Returns the set fingerprint, or zero_fingerprint()</span>
<span class="line-added">+   // if none has been set already.</span>
<span class="line-added">+   fingerprint_t fingerprint() const { return _fingerprint; }</span>
  
    // Iteration
<span class="line-modified">!   // Hey look:  There are no virtual methods in this class.</span>
<span class="line-modified">!   // So how is it customized?  By calling do_parameters_on</span>
<span class="line-modified">!   // an object which answers to &quot;do_type(BasicType)&quot;.</span>
<span class="line-modified">!   // By convention, this object is in the subclass</span>
<span class="line-modified">!   // itself, so the call is &quot;do_parameters_on(this)&quot;.</span>
<span class="line-modified">!   // The effect of this is to inline the parsing loop</span>
<span class="line-modified">!   // everywhere &quot;do_parameters_on&quot; is called.</span>
<span class="line-modified">!   // If there is a valid fingerprint in the object,</span>
<span class="line-modified">!   // an improved loop is called which just unpacks the</span>
<span class="line-modified">!   // bitfields from the fingerprint.  Otherwise, the</span>
<span class="line-modified">!   // symbol is parsed.</span>
<span class="line-modified">!   template&lt;typename T&gt; inline void do_parameters_on(T* callback); // iterates over parameters only</span>
<span class="line-modified">!   void skip_parameters();   // skips over parameters to find return type</span>
<span class="line-modified">!   BasicType return_type();  // computes the value on the fly if necessary</span>
<span class="line-modified">! </span>
<span class="line-modified">!   static bool fp_is_static(fingerprint_t fingerprint) {</span>
<span class="line-modified">!     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">!     return fingerprint &amp; fp_is_static_bit;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   static BasicType fp_return_type(fingerprint_t fingerprint) {</span>
<span class="line-modified">!     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">!     return (BasicType) ((fingerprint &gt;&gt; fp_static_feature_size) &amp; fp_result_feature_mask);</span>
    }
<span class="line-modified">!   static fingerprint_t fp_start_parameters(fingerprint_t fingerprint) {</span>
<span class="line-modified">!     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">!     return fingerprint &gt;&gt; (fp_static_feature_size + fp_result_feature_size);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   static BasicType fp_next_parameter(fingerprint_t&amp; mask) {</span>
<span class="line-added">+     int result = (mask &amp; fp_parameter_feature_mask);</span>
<span class="line-added">+     mask &gt;&gt;= fp_parameter_feature_size;</span>
<span class="line-added">+     return (BasicType) result;</span>
    }
  };
  
  
  // Specialized SignatureIterators: Used to compute signature specific values.
  
  class SignatureTypeNames : public SignatureIterator {
   protected:
    virtual void type_name(const char* name)   = 0;
  
<span class="line-modified">!   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">!   void do_type(BasicType type) {</span>
<span class="line-modified">!     switch (type) {</span>
<span class="line-modified">!     case T_BOOLEAN: type_name(&quot;jboolean&quot;); break;</span>
<span class="line-modified">!     case T_CHAR:    type_name(&quot;jchar&quot;   ); break;</span>
<span class="line-modified">!     case T_FLOAT:   type_name(&quot;jfloat&quot;  ); break;</span>
<span class="line-modified">!     case T_DOUBLE:  type_name(&quot;jdouble&quot; ); break;</span>
<span class="line-modified">!     case T_BYTE:    type_name(&quot;jbyte&quot;   ); break;</span>
<span class="line-modified">!     case T_SHORT:   type_name(&quot;jshort&quot;  ); break;</span>
<span class="line-modified">!     case T_INT:     type_name(&quot;jint&quot;    ); break;</span>
<span class="line-modified">!     case T_LONG:    type_name(&quot;jlong&quot;   ); break;</span>
<span class="line-added">+     case T_VOID:    type_name(&quot;void&quot;    ); break;</span>
<span class="line-added">+     case T_ARRAY:</span>
<span class="line-added">+     case T_OBJECT:  type_name(&quot;jobject&quot; ); break;</span>
<span class="line-added">+     default: ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
   public:
    SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
  };
  
  
<span class="line-modified">! // Specialized SignatureIterator: Used to compute the argument size.</span>
  
<span class="line-added">+ class ArgumentSizeComputer: public SignatureIterator {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   int _size;</span>
<span class="line-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">+   void do_type(BasicType type) { _size += parameter_type_word_count(type); }</span>
   public:
<span class="line-modified">!   ArgumentSizeComputer(Symbol* signature);</span>
<span class="line-modified">!   int size() { return _size; }</span>
  };
  
  
<span class="line-modified">! class ArgumentCount: public SignatureIterator {</span>
   private:
<span class="line-modified">!   int _size;</span>
<span class="line-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">+   void do_type(BasicType type) { _size++; }</span>
   public:
<span class="line-modified">!   ArgumentCount(Symbol* signature);</span>
<span class="line-modified">!   int size() { return _size; }</span>
  };
  
  
<span class="line-modified">! class ReferenceArgumentCount: public SignatureIterator {</span>
   private:
<span class="line-modified">!   int _refs;</span>
<span class="line-added">+   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">+   void do_type(BasicType type) { if (is_reference_type(type)) _refs++; }</span>
   public:
<span class="line-modified">!   ReferenceArgumentCount(Symbol* signature);</span>
<span class="line-modified">!   int count() { return _refs; }</span>
  };
  
  
  // Specialized SignatureIterator: Used to compute the result type.
  
<span class="line-modified">! class ResultTypeFinder: public SignatureIterator {</span>
   public:
<span class="line-modified">!   BasicType type() { return return_type(); }</span>
<span class="line-modified">!   ResultTypeFinder(Symbol* signature) : SignatureIterator(signature) { }</span>
  };
  
  
  // Fingerprinter computes a unique ID for a given method. The ID
  // is a bitvector characterizing the methods signature (incl. the receiver).
  class Fingerprinter: public SignatureIterator {
   private:
<span class="line-modified">!   fingerprint_t _accumulator;</span>
<span class="line-added">+   int _param_size;</span>
    int _shift_count;
<span class="line-modified">!   const Method* _method;</span>
  
<span class="line-modified">!   void initialize_accumulator() {</span>
<span class="line-modified">!     _accumulator = 0;</span>
<span class="line-modified">!     _shift_count = fp_result_feature_size + fp_static_feature_size;</span>
<span class="line-modified">!     _param_size = 0;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   // Out-of-line method does it all in constructor:</span>
<span class="line-added">+   void compute_fingerprint_and_return_type(bool static_flag = false);</span>
  
<span class="line-modified">!   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">!   void do_type(BasicType type) {</span>
<span class="line-modified">!     assert(fp_is_valid_type(type), &quot;bad parameter type&quot;);</span>
<span class="line-added">+     _accumulator |= ((fingerprint_t)type &lt;&lt; _shift_count);</span>
<span class="line-added">+     _shift_count += fp_parameter_feature_size;</span>
<span class="line-added">+     _param_size += (is_double_word_type(type) ? 2 : 1);</span>
    }
  
<span class="line-modified">!  public:</span>
<span class="line-modified">!   int size_of_parameters() const { return _param_size; }</span>
<span class="line-modified">!   // fingerprint() and return_type() are in super class</span>
  
<span class="line-modified">!   Fingerprinter(const methodHandle&amp; method)</span>
<span class="line-modified">!     : SignatureIterator(method-&gt;signature()),</span>
<span class="line-modified">!       _method(method()) {</span>
<span class="line-modified">!     compute_fingerprint_and_return_type();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   Fingerprinter(Symbol* signature, bool is_static)</span>
<span class="line-modified">!     : SignatureIterator(signature),</span>
<span class="line-modified">!       _method(NULL) {</span>
<span class="line-modified">!     compute_fingerprint_and_return_type(is_static);</span>
    }
  };
  
  
  // Specialized SignatureIterator: Used for native call purposes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,39 ***</span>
  // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
    int          _offset;                // The java stack offset
    int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
    int          _jni_offset;            // the current parameter offset, starting with 0
  
<span class="line-modified">!   void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">!   void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">!   void do_float ()                     { pass_float();  _jni_offset++; _offset++;       }</span>
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">!   void do_double()                     { pass_double(); _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">! #else</span>
<span class="line-modified">!   void do_double()                     { pass_double(); _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!   void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">!   void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">!   void do_int   ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">! #ifdef _LP64</span>
<span class="line-modified">!   void do_long  ()                     { pass_long();   _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">! #else</span>
<span class="line-modified">!   void do_long  ()                     { pass_long();   _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!   void do_void  ()                     { ShouldNotReachHere();                               }</span>
<span class="line-modified">!   void do_object(int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>
<span class="line-modified">!   void do_array (int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>
  
   public:
    methodHandle method() const          { return _method; }
    int          offset() const          { return _offset; }
    int      jni_offset() const          { return _jni_offset + _prepended; }
<span class="line-removed">- //  int     java_offset() const          { return method()-&gt;size_of_parameters() - _offset - 1; }</span>
    bool      is_static() const          { return method()-&gt;is_static(); }
    virtual void pass_int()              = 0;
    virtual void pass_long()             = 0;
<span class="line-modified">!   virtual void pass_object()           = 0;</span>
    virtual void pass_float()            = 0;
  #ifdef _LP64
    virtual void pass_double()           = 0;
  #else
    virtual void pass_double()           { pass_long(); }  // may be same as long
<span class="line-new-header">--- 381,50 ---</span>
  // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
    int          _offset;                // The java stack offset
    int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
    int          _jni_offset;            // the current parameter offset, starting with 0
  
<span class="line-modified">!   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">!   void do_type(BasicType type) {</span>
<span class="line-modified">!     switch (type) {</span>
<span class="line-modified">!     case T_BYTE:</span>
<span class="line-modified">!     case T_SHORT:</span>
<span class="line-modified">!     case T_INT:</span>
<span class="line-modified">!     case T_BOOLEAN:</span>
<span class="line-modified">!     case T_CHAR:</span>
<span class="line-modified">!       pass_int();    _jni_offset++; _offset++;</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case T_FLOAT:</span>
<span class="line-modified">!       pass_float();  _jni_offset++; _offset++;</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case T_DOUBLE: {</span>
<span class="line-modified">!       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-modified">!       pass_double(); _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case T_LONG: {</span>
<span class="line-added">+       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-added">+       pass_long();   _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case T_ARRAY:</span>
<span class="line-added">+     case T_OBJECT:</span>
<span class="line-added">+       pass_object(); _jni_offset++; _offset++;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
  
   public:
    methodHandle method() const          { return _method; }
    int          offset() const          { return _offset; }
    int      jni_offset() const          { return _jni_offset + _prepended; }
    bool      is_static() const          { return method()-&gt;is_static(); }
    virtual void pass_int()              = 0;
    virtual void pass_long()             = 0;
<span class="line-modified">!   virtual void pass_object()           = 0;  // objects, arrays, inlines</span>
    virtual void pass_float()            = 0;
  #ifdef _LP64
    virtual void pass_double()           = 0;
  #else
    virtual void pass_double()           { pass_long(); }  // may be same as long
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,99 ***</span>
      const int JNIEnv_words = 1;
      const int mirror_words = 1;
      _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
    }
  
<span class="line-modified">!   // iterate() calles the 2 virtual methods according to the following invocation syntax:</span>
    //
    // {pass_int | pass_long | pass_object}
    //
    // Arguments are handled from left to right (receiver first, if any).
    // The offset() values refer to the Java stack offsets but are 0 based and increasing.
    // The java_offset() values count down to 0, and refer to the Java TOS.
    // The jni_offset() values increase from 1 or 2, and refer to C arguments.
  
<span class="line-modified">!   void iterate() { iterate(Fingerprinter(method()).fingerprint());</span>
<span class="line-modified">!   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Optimized path if we have the bitvector form of signature</span>
<span class="line-removed">-   void iterate( uint64_t fingerprint ) {</span>
<span class="line-removed">- </span>
      if (!is_static()) {
        // handle receiver (not handled by iterate because not in signature)
        pass_object(); _jni_offset++; _offset++;
      }
<span class="line-modified">! </span>
<span class="line-removed">-     SignatureIterator::iterate_parameters( fingerprint );</span>
    }
  };
  
  
<span class="line-modified">! // Handy stream for iterating over signature</span>
  
  class SignatureStream : public StackObj {
   private:
<span class="line-modified">!   Symbol*      _signature;</span>
    int          _begin;
    int          _end;
    BasicType    _type;
<span class="line-modified">!   bool         _at_return_type;</span>
<span class="line-modified">!   Symbol*      _previous_name;     // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">!   GrowableArray&lt;Symbol*&gt;* _names;  // symbols created while parsing that need to be dereferenced</span>
<span class="line-removed">-  public:</span>
<span class="line-removed">-   bool at_return_type() const                    { return _at_return_type; }</span>
<span class="line-removed">-   bool is_done() const;</span>
<span class="line-removed">-   void next_non_primitive(int t);</span>
<span class="line-removed">-   void next() {</span>
<span class="line-removed">-     Symbol* sig = _signature;</span>
<span class="line-removed">-     int len = sig-&gt;utf8_length();</span>
<span class="line-removed">-     if (_end &gt;= len) {</span>
<span class="line-removed">-       _end = len + 1;</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     _begin = _end;</span>
<span class="line-modified">!     int t = sig-&gt;char_at(_begin);</span>
<span class="line-modified">!     switch (t) {</span>
<span class="line-modified">!       case JVM_SIGNATURE_BYTE:    _type = T_BYTE;    break;</span>
<span class="line-modified">!       case JVM_SIGNATURE_CHAR:    _type = T_CHAR;    break;</span>
<span class="line-modified">!       case JVM_SIGNATURE_DOUBLE:  _type = T_DOUBLE;  break;</span>
<span class="line-modified">!       case JVM_SIGNATURE_FLOAT:   _type = T_FLOAT;   break;</span>
<span class="line-modified">!       case JVM_SIGNATURE_INT:     _type = T_INT;     break;</span>
<span class="line-removed">-       case JVM_SIGNATURE_LONG:    _type = T_LONG;    break;</span>
<span class="line-removed">-       case JVM_SIGNATURE_SHORT:   _type = T_SHORT;   break;</span>
<span class="line-removed">-       case JVM_SIGNATURE_BOOLEAN: _type = T_BOOLEAN; break;</span>
<span class="line-removed">-       case JVM_SIGNATURE_VOID:    _type = T_VOID;    break;</span>
<span class="line-removed">-       default : next_non_primitive(t);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     _end++;</span>
    }
  
<span class="line-modified">!   SignatureStream(Symbol* signature, bool is_method = true);</span>
    ~SignatureStream();
  
<span class="line-modified">!   bool is_object() const;                        // True if this argument is an object</span>
<span class="line-modified">!   bool is_array() const;                         // True if this argument is an array</span>
<span class="line-modified">!   BasicType type() const                         { return _type; }</span>
<span class="line-modified">!   Symbol* as_symbol();</span>
<span class="line-modified">!   enum FailureMode { ReturnNull, NCDFError };</span>
<span class="line-modified">!   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">!   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">!   const u1* raw_bytes()  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">!   int       raw_length() { return _end - _begin; }</span>
  
<span class="line-modified">!   // return same as_symbol except allocation of new symbols is avoided.</span>
<span class="line-modified">!   Symbol* as_symbol_or_null();</span>
  
<span class="line-modified">!   // count the number of references in the signature</span>
<span class="line-modified">!   int reference_parameter_count();</span>
  };
  
<span class="line-modified">! #ifdef ASSERT</span>
<span class="line-modified">! class SignatureVerifier : public StackObj {</span>
    public:
      static bool is_valid_method_signature(Symbol* sig);
      static bool is_valid_type_signature(Symbol* sig);
    private:
      static ssize_t is_valid_type(const char*, ssize_t);
<span class="line-new-header">--- 438,146 ---</span>
      const int JNIEnv_words = 1;
      const int mirror_words = 1;
      _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
    }
  
<span class="line-modified">!   void iterate() { iterate(Fingerprinter(method()).fingerprint()); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // iterate() calls the 3 virtual methods according to the following invocation syntax:</span>
    //
    // {pass_int | pass_long | pass_object}
    //
    // Arguments are handled from left to right (receiver first, if any).
    // The offset() values refer to the Java stack offsets but are 0 based and increasing.
    // The java_offset() values count down to 0, and refer to the Java TOS.
    // The jni_offset() values increase from 1 or 2, and refer to C arguments.
<span class="line-added">+   // The method&#39;s return type is ignored.</span>
  
<span class="line-modified">!   void iterate(fingerprint_t fingerprint) {</span>
<span class="line-modified">!     set_fingerprint(fingerprint);</span>
      if (!is_static()) {
        // handle receiver (not handled by iterate because not in signature)
        pass_object(); _jni_offset++; _offset++;
      }
<span class="line-modified">!     do_parameters_on(this);</span>
    }
  };
  
  
<span class="line-modified">! // This is the core parsing logic for iterating over signatures.</span>
<span class="line-added">+ // All of the previous classes use this for doing their work.</span>
  
  class SignatureStream : public StackObj {
   private:
<span class="line-modified">!   const Symbol* _signature;</span>
    int          _begin;
    int          _end;
<span class="line-added">+   int          _limit;</span>
<span class="line-added">+   int          _array_prefix;  // count of &#39;[&#39; before the array element descr</span>
    BasicType    _type;
<span class="line-modified">!   int          _state;</span>
<span class="line-modified">!   Symbol*      _previous_name;    // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">!   GrowableArray&lt;Symbol*&gt;* _names; // symbols created while parsing that need to be dereferenced</span>
  
<span class="line-modified">!   inline int scan_non_primitive(BasicType type);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Symbol* find_symbol();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   enum { _s_field = 0, _s_method = 1, _s_method_return = 3 };</span>
<span class="line-modified">!   void set_done() {</span>
<span class="line-modified">!     _state |= -2;   // preserve s_method bit</span>
<span class="line-modified">!     assert(is_done(), &quot;Unable to set state to done&quot;);</span>
    }
  
<span class="line-modified">!  public:</span>
<span class="line-added">+   bool is_method_signature() const               { return (_state &amp; (int)_s_method) != 0; }</span>
<span class="line-added">+   bool at_return_type() const                    { return _state == (int)_s_method_return; }</span>
<span class="line-added">+   bool is_done() const                           { return _state &lt; 0; }</span>
<span class="line-added">+   void next();</span>
<span class="line-added">+ </span>
<span class="line-added">+   SignatureStream(const Symbol* signature, bool is_method = true);</span>
    ~SignatureStream();
  
<span class="line-modified">!   bool is_reference() const { return is_reference_type(_type); }</span>
<span class="line-modified">!   bool is_array() const     { return _type == T_ARRAY; }</span>
<span class="line-modified">!   bool is_primitive() const { return is_java_primitive(_type); }</span>
<span class="line-modified">!   BasicType type() const    { return _type; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const u1* raw_bytes() const  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">!   int       raw_length() const { return _end - _begin; }</span>
<span class="line-modified">!   int       raw_begin() const  { return _begin; }</span>
<span class="line-modified">!   int       raw_end() const    { return _end; }</span>
<span class="line-added">+   int raw_symbol_begin() const { return _begin + (has_envelope() ? 1 : 0); }</span>
<span class="line-added">+   int raw_symbol_end() const   { return _end  -  (has_envelope() ? 1 : 0); }</span>
<span class="line-added">+   char raw_char_at(int i) const {</span>
<span class="line-added">+     assert(i &lt; _limit, &quot;index for raw_char_at is over the limit&quot;);</span>
<span class="line-added">+     return _signature-&gt;char_at(i);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // True if there is an embedded class name in this type,</span>
<span class="line-modified">!   // followed by &#39;;&#39;.</span>
<span class="line-added">+   bool has_envelope() const {</span>
<span class="line-added">+     if (!Signature::has_envelope(_signature-&gt;char_at(_begin)))</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     // this should always be true, but let&#39;s test it:</span>
<span class="line-added">+     assert(_signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS, &quot;signature envelope has no semi-colon at end&quot;);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   // return the symbol for chars in symbol_begin()..symbol_end()</span>
<span class="line-modified">!   Symbol* as_symbol() {</span>
<span class="line-added">+     return find_symbol();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // in case you want only the return type:</span>
<span class="line-added">+   void skip_to_return_type();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // number of &#39;[&#39; in array prefix</span>
<span class="line-added">+   int array_prefix_length() {</span>
<span class="line-added">+     return _type == T_ARRAY ? _array_prefix : 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // In case you want only the array base type,</span>
<span class="line-added">+   // reset the stream after skipping some brackets &#39;[&#39;.</span>
<span class="line-added">+   // (The argument is clipped to array_prefix_length(),</span>
<span class="line-added">+   // and if it ends up as zero this call is a nop.</span>
<span class="line-added">+   // The default is value skips all brackets &#39;[&#39;.)</span>
<span class="line-added">+   int skip_array_prefix(int prefix_length = 9999);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // free-standing lookups (bring your own CL/PD pair)</span>
<span class="line-added">+   enum FailureMode { ReturnNull, NCDFError, CachedOrNull };</span>
<span class="line-added">+   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-added">+   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
  };
  
<span class="line-modified">! // Here is how all the SignatureIterator classes invoke the</span>
<span class="line-modified">! // SignatureStream engine to do their parsing.</span>
<span class="line-added">+ template&lt;typename T&gt; inline</span>
<span class="line-added">+ void SignatureIterator::do_parameters_on(T* callback) {</span>
<span class="line-added">+   fingerprint_t unaccumulator = _fingerprint;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Check for too many arguments, or missing fingerprint:</span>
<span class="line-added">+   if (!fp_is_valid(unaccumulator)) {</span>
<span class="line-added">+     SignatureStream ss(_signature);</span>
<span class="line-added">+     for (; !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">+       callback-&gt;do_type(ss.type());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // while we are here, capture the return type</span>
<span class="line-added">+     _return_type = ss.type();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // Optimized version of do_parameters when fingerprint is known</span>
<span class="line-added">+     assert(_return_type != T_ILLEGAL, &quot;return type already captured from fp&quot;);</span>
<span class="line-added">+     unaccumulator = fp_start_parameters(unaccumulator);</span>
<span class="line-added">+     for (BasicType type; (type = fp_next_parameter(unaccumulator)) != (BasicType)fp_parameters_done; ) {</span>
<span class="line-added">+       assert(fp_is_valid_type(type), &quot;garbled fingerprint&quot;);</span>
<span class="line-added">+       callback-&gt;do_type(type);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+  #ifdef ASSERT</span>
<span class="line-added">+  class SignatureVerifier : public StackObj {</span>
    public:
      static bool is_valid_method_signature(Symbol* sig);
      static bool is_valid_type_signature(Symbol* sig);
    private:
      static ssize_t is_valid_type(const char*, ssize_t);
</pre>
<center><a href="signature.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>