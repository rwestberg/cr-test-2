<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SIGNATURE_HPP
 26 #define SHARE_RUNTIME_SIGNATURE_HPP
 27 
<a name="2" id="anc2"></a>
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/method.hpp&quot;
 30 
<a name="3" id="anc3"></a><span class="line-modified"> 31 // SignatureIterators iterate over a Java signature (or parts of it).</span>
<span class="line-modified"> 32 // (Syntax according to: &quot;The Java Virtual Machine Specification&quot; by</span>
<span class="line-modified"> 33 // Tim Lindholm &amp; Frank Yellin; section 4.3 Descriptors; p. 89ff.)</span>















 34 //
<a name="4" id="anc4"></a><span class="line-modified"> 35 // Example: Iterating over ([Lfoo;D)I using</span>
<span class="line-modified"> 36 //                         0123456789</span>



 37 //
<a name="5" id="anc5"></a><span class="line-modified"> 38 // iterate_parameters() calls: do_array(2, 7); do_double();</span>
<span class="line-modified"> 39 // iterate_returntype() calls:                              do_int();</span>
<span class="line-modified"> 40 // iterate()            calls: do_array(2, 7); do_double(); do_int();</span>







 41 //
<a name="6" id="anc6"></a><span class="line-modified"> 42 // is_return_type()        is: false         ; false      ; true</span>





 43 //
<a name="7" id="anc7"></a><span class="line-modified"> 44 // NOTE: The new optimizer has an alternate, for-loop based signature</span>
<span class="line-modified"> 45 // iterator implemented in opto/type.cpp, TypeTuple::make().</span>


















































































 46 
 47 class SignatureIterator: public ResourceObj {
<a name="8" id="anc8"></a>


 48  protected:
 49   Symbol*      _signature;             // the signature to iterate over
<a name="9" id="anc9"></a><span class="line-removed"> 50   int          _index;                 // the current character index (only valid during iteration)</span>
<span class="line-removed"> 51   int          _parameter_index;       // the current parameter index (0 outside iteration phase)</span>
 52   BasicType    _return_type;
<a name="10" id="anc10"></a><span class="line-modified"> 53 </span>
<span class="line-removed"> 54   void expect(char c);</span>
<span class="line-removed"> 55   int  parse_type();                   // returns the parameter size in words (0 for void)</span>
<span class="line-removed"> 56   void check_signature_end();</span>
 57 
 58  public:
 59   // Definitions used in generating and iterating the
 60   // bit field form of the signature generated by the
 61   // Fingerprinter.
 62   enum {
<a name="11" id="anc11"></a><span class="line-modified"> 63     static_feature_size    = 1,</span>
<span class="line-modified"> 64     is_static_bit          = 1,</span>
<span class="line-modified"> 65 </span>
<span class="line-modified"> 66     result_feature_size    = 4,</span>
<span class="line-modified"> 67     result_feature_mask    = 0xF,</span>
<span class="line-modified"> 68     parameter_feature_size = 4,</span>
<span class="line-modified"> 69     parameter_feature_mask = 0xF,</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71       bool_parm            = 1,</span>
<span class="line-modified"> 72       byte_parm            = 2,</span>
<span class="line-modified"> 73       char_parm            = 3,</span>
<span class="line-modified"> 74       short_parm           = 4,</span>
<span class="line-modified"> 75       int_parm             = 5,</span>
<span class="line-modified"> 76       long_parm            = 6,</span>
<span class="line-modified"> 77       float_parm           = 7,</span>
<span class="line-modified"> 78       double_parm          = 8,</span>
<span class="line-modified"> 79       obj_parm             = 9,</span>
<span class="line-modified"> 80       done_parm            = 10,  // marker for end of parameters</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82     // max parameters is wordsize minus</span>
<span class="line-removed"> 83     //    The sign bit, termination field, the result and static bit fields</span>
<span class="line-removed"> 84     max_size_of_parameters = (BitsPerLong-1 -</span>
<span class="line-removed"> 85                               result_feature_size - parameter_feature_size -</span>
<span class="line-removed"> 86                               static_feature_size) / parameter_feature_size</span>
 87   };
 88 
<a name="12" id="anc12"></a>










 89   // Constructors
<a name="13" id="anc13"></a><span class="line-modified"> 90   SignatureIterator(Symbol* signature);</span>














 91 
 92   // Iteration
<a name="14" id="anc14"></a><span class="line-modified"> 93   void iterate_parameters();           // iterates over parameters only</span>
<span class="line-modified"> 94   void iterate_parameters( uint64_t fingerprint );</span>
<span class="line-modified"> 95   void iterate_returntype();           // iterates over returntype only</span>
<span class="line-modified"> 96   void iterate();                      // iterates over whole signature</span>
<span class="line-modified"> 97   // Returns the word index of the current parameter;</span>
<span class="line-modified"> 98   int  parameter_index() const         { return _parameter_index; }</span>
<span class="line-modified"> 99   bool is_return_type() const          { return parameter_index() &lt; 0; }</span>
<span class="line-modified">100   BasicType get_ret_type() const       { return _return_type; }</span>
<span class="line-modified">101 </span>
<span class="line-modified">102   // Basic types</span>
<span class="line-modified">103   virtual void do_bool  ()             = 0;</span>
<span class="line-modified">104   virtual void do_char  ()             = 0;</span>
<span class="line-modified">105   virtual void do_float ()             = 0;</span>
<span class="line-modified">106   virtual void do_double()             = 0;</span>
<span class="line-modified">107   virtual void do_byte  ()             = 0;</span>
<span class="line-modified">108   virtual void do_short ()             = 0;</span>
<span class="line-modified">109   virtual void do_int   ()             = 0;</span>
<span class="line-modified">110   virtual void do_long  ()             = 0;</span>
<span class="line-modified">111   virtual void do_void  ()             = 0;</span>
<span class="line-modified">112 </span>
<span class="line-modified">113   // Object types (begin indexes the first character of the entry, end indexes the first character after the entry)</span>
<span class="line-modified">114   virtual void do_object(int begin, int end) = 0;</span>
<span class="line-removed">115   virtual void do_array (int begin, int end) = 0;</span>
<span class="line-removed">116 </span>
<span class="line-removed">117   static bool is_static(uint64_t fingerprint) {</span>
<span class="line-removed">118     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-removed">119     return fingerprint &amp; is_static_bit;</span>
120   }
<a name="15" id="anc15"></a><span class="line-modified">121   static BasicType return_type(uint64_t fingerprint) {</span>
<span class="line-modified">122     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">123     return (BasicType) ((fingerprint &gt;&gt; static_feature_size) &amp; result_feature_mask);</span>





124   }
125 };
126 
127 
128 // Specialized SignatureIterators: Used to compute signature specific values.
129 
130 class SignatureTypeNames : public SignatureIterator {
131  protected:
132   virtual void type_name(const char* name)   = 0;
133 
<a name="16" id="anc16"></a><span class="line-modified">134   void do_bool()                       { type_name(&quot;jboolean&quot;); }</span>
<span class="line-modified">135   void do_char()                       { type_name(&quot;jchar&quot;   ); }</span>
<span class="line-modified">136   void do_float()                      { type_name(&quot;jfloat&quot;  ); }</span>
<span class="line-modified">137   void do_double()                     { type_name(&quot;jdouble&quot; ); }</span>
<span class="line-modified">138   void do_byte()                       { type_name(&quot;jbyte&quot;   ); }</span>
<span class="line-modified">139   void do_short()                      { type_name(&quot;jshort&quot;  ); }</span>
<span class="line-modified">140   void do_int()                        { type_name(&quot;jint&quot;    ); }</span>
<span class="line-modified">141   void do_long()                       { type_name(&quot;jlong&quot;   ); }</span>
<span class="line-modified">142   void do_void()                       { type_name(&quot;void&quot;    ); }</span>
<span class="line-modified">143   void do_object(int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>
<span class="line-modified">144   void do_array (int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>






145 
146  public:
147   SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
148 };
149 
150 
<a name="17" id="anc17"></a><span class="line-modified">151 class SignatureInfo: public SignatureIterator {</span>
<span class="line-removed">152  protected:</span>
<span class="line-removed">153   bool      _has_iterated;             // need this because iterate cannot be called in constructor (set is virtual!)</span>
<span class="line-removed">154   bool      _has_iterated_return;</span>
<span class="line-removed">155   int       _size;</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   void lazy_iterate_parameters()       { if (!_has_iterated) { iterate_parameters(); _has_iterated = true; } }</span>
<span class="line-removed">158   void lazy_iterate_return()           { if (!_has_iterated_return) { iterate_returntype(); _has_iterated_return = true; } }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160   virtual void set(int size, BasicType type) = 0;</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   void do_bool  ()                     { set(T_BOOLEAN_size, T_BOOLEAN); }</span>
<span class="line-removed">163   void do_char  ()                     { set(T_CHAR_size   , T_CHAR   ); }</span>
<span class="line-removed">164   void do_float ()                     { set(T_FLOAT_size  , T_FLOAT  ); }</span>
<span class="line-removed">165   void do_double()                     { set(T_DOUBLE_size , T_DOUBLE ); }</span>
<span class="line-removed">166   void do_byte  ()                     { set(T_BYTE_size   , T_BYTE   ); }</span>
<span class="line-removed">167   void do_short ()                     { set(T_SHORT_size  , T_SHORT  ); }</span>
<span class="line-removed">168   void do_int   ()                     { set(T_INT_size    , T_INT    ); }</span>
<span class="line-removed">169   void do_long  ()                     { set(T_LONG_size   , T_LONG   ); }</span>
<span class="line-removed">170   void do_void  ()                     { set(T_VOID_size   , T_VOID   ); }</span>
<span class="line-removed">171   void do_object(int begin, int end)   { set(T_OBJECT_size , T_OBJECT ); }</span>
<span class="line-removed">172   void do_array (int begin, int end)   { set(T_ARRAY_size  , T_ARRAY  ); }</span>
173 
<a name="18" id="anc18"></a>




174  public:
<a name="19" id="anc19"></a><span class="line-modified">175   SignatureInfo(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified">176     _has_iterated = _has_iterated_return = false;</span>
<span class="line-removed">177     _size         = 0;</span>
<span class="line-removed">178     _return_type  = T_ILLEGAL;</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180 </span>
181 };
182 
183 
<a name="20" id="anc20"></a><span class="line-modified">184 // Specialized SignatureIterator: Used to compute the argument size.</span>
<span class="line-removed">185 </span>
<span class="line-removed">186 class ArgumentSizeComputer: public SignatureInfo {</span>
187  private:
<a name="21" id="anc21"></a><span class="line-modified">188   void set(int size, BasicType type)   { _size += size; }</span>


189  public:
<a name="22" id="anc22"></a><span class="line-modified">190   ArgumentSizeComputer(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">191 </span>
<span class="line-removed">192   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
193 };
194 
195 
<a name="23" id="anc23"></a><span class="line-modified">196 class ArgumentCount: public SignatureInfo {</span>
197  private:
<a name="24" id="anc24"></a><span class="line-modified">198   void set(int size, BasicType type)   { _size ++; }</span>


199  public:
<a name="25" id="anc25"></a><span class="line-modified">200   ArgumentCount(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">201 </span>
<span class="line-removed">202   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
203 };
204 
205 
206 // Specialized SignatureIterator: Used to compute the result type.
207 
<a name="26" id="anc26"></a><span class="line-modified">208 class ResultTypeFinder: public SignatureInfo {</span>
<span class="line-removed">209  private:</span>
<span class="line-removed">210   void set(int size, BasicType type)   { _return_type = type; }</span>
211  public:
<a name="27" id="anc27"></a><span class="line-modified">212   BasicType type()                     { lazy_iterate_return(); return _return_type; }</span>
<span class="line-modified">213 </span>
<span class="line-removed">214   ResultTypeFinder(Symbol* signature) : SignatureInfo(signature) {}</span>
215 };
216 
217 
218 // Fingerprinter computes a unique ID for a given method. The ID
219 // is a bitvector characterizing the methods signature (incl. the receiver).
220 class Fingerprinter: public SignatureIterator {
221  private:
<a name="28" id="anc28"></a><span class="line-modified">222   uint64_t _fingerprint;</span>

223   int _shift_count;
<a name="29" id="anc29"></a><span class="line-modified">224   methodHandle mh;</span>
<span class="line-removed">225 </span>
<span class="line-removed">226  public:</span>
227 
<a name="30" id="anc30"></a><span class="line-modified">228   void do_bool()    { _fingerprint |= (((uint64_t)bool_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">229   void do_char()    { _fingerprint |= (((uint64_t)char_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">230   void do_byte()    { _fingerprint |= (((uint64_t)byte_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">231   void do_short()   { _fingerprint |= (((uint64_t)short_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">232   void do_int()     { _fingerprint |= (((uint64_t)int_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">233   void do_long()    { _fingerprint |= (((uint64_t)long_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">234   void do_float()   { _fingerprint |= (((uint64_t)float_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">235   void do_double()  { _fingerprint |= (((uint64_t)double_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237   void do_object(int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">238   void do_array (int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
239 
<a name="31" id="anc31"></a><span class="line-modified">240   void do_void()    { ShouldNotReachHere(); }</span>

241 
<a name="32" id="anc32"></a><span class="line-modified">242   Fingerprinter(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {</span>
<span class="line-modified">243     mh = method;</span>
<span class="line-modified">244     _fingerprint = 0;</span>



245   }
246 
<a name="33" id="anc33"></a><span class="line-modified">247   uint64_t fingerprint() {</span>
<span class="line-modified">248     // See if we fingerprinted this method already</span>
<span class="line-modified">249     if (mh-&gt;constMethod()-&gt;fingerprint() != CONST64(0)) {</span>
<span class="line-removed">250       return mh-&gt;constMethod()-&gt;fingerprint();</span>
<span class="line-removed">251     }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253     if (mh-&gt;size_of_parameters() &gt; max_size_of_parameters ) {</span>
<span class="line-removed">254       _fingerprint = (uint64_t)CONST64(-1);</span>
<span class="line-removed">255       mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-removed">256       return _fingerprint;</span>
<span class="line-removed">257     }</span>
258 
<a name="34" id="anc34"></a><span class="line-modified">259     assert( (int)mh-&gt;result_type() &lt;= (int)result_feature_mask, &quot;bad result type&quot;);</span>
<span class="line-modified">260     _fingerprint = mh-&gt;result_type();</span>
<span class="line-modified">261     _fingerprint &lt;&lt;= static_feature_size;</span>
<span class="line-modified">262     if (mh-&gt;is_static())  _fingerprint |= 1;</span>
<span class="line-modified">263     _shift_count = result_feature_size + static_feature_size;</span>
<span class="line-modified">264     iterate_parameters();</span>
<span class="line-modified">265     _fingerprint |= ((uint64_t)done_parm) &lt;&lt; _shift_count;// mark end of sig</span>
<span class="line-modified">266     mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-modified">267     return _fingerprint;</span>
268   }
269 };
270 
271 
272 // Specialized SignatureIterator: Used for native call purposes
273 
274 class NativeSignatureIterator: public SignatureIterator {
275  private:
276   methodHandle _method;
277 // We need separate JNI and Java offset values because in 64 bit mode,
278 // the argument offsets are not in sync with the Java stack.
279 // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
280   int          _offset;                // The java stack offset
281   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
282   int          _jni_offset;            // the current parameter offset, starting with 0
283 
<a name="35" id="anc35"></a><span class="line-modified">284   void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">285   void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">286   void do_float ()                     { pass_float();  _jni_offset++; _offset++;       }</span>
<span class="line-modified">287 #ifdef _LP64</span>
<span class="line-modified">288   void do_double()                     { pass_double(); _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">289 #else</span>
<span class="line-modified">290   void do_double()                     { pass_double(); _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">291 #endif</span>
<span class="line-modified">292   void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">293   void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">294   void do_int   ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">295 #ifdef _LP64</span>
<span class="line-modified">296   void do_long  ()                     { pass_long();   _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">297 #else</span>
<span class="line-modified">298   void do_long  ()                     { pass_long();   _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">299 #endif</span>
<span class="line-modified">300   void do_void  ()                     { ShouldNotReachHere();                               }</span>
<span class="line-modified">301   void do_object(int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>
<span class="line-modified">302   void do_array (int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>












303 
304  public:
305   methodHandle method() const          { return _method; }
306   int          offset() const          { return _offset; }
307   int      jni_offset() const          { return _jni_offset + _prepended; }
<a name="36" id="anc36"></a><span class="line-removed">308 //  int     java_offset() const          { return method()-&gt;size_of_parameters() - _offset - 1; }</span>
309   bool      is_static() const          { return method()-&gt;is_static(); }
310   virtual void pass_int()              = 0;
311   virtual void pass_long()             = 0;
<a name="37" id="anc37"></a><span class="line-modified">312   virtual void pass_object()           = 0;</span>
313   virtual void pass_float()            = 0;
314 #ifdef _LP64
315   virtual void pass_double()           = 0;
316 #else
317   virtual void pass_double()           { pass_long(); }  // may be same as long
318 #endif
319 
320   NativeSignatureIterator(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
321     _method = method;
322     _offset = 0;
323     _jni_offset = 0;
324 
325     const int JNIEnv_words = 1;
326     const int mirror_words = 1;
327     _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
328   }
329 
<a name="38" id="anc38"></a><span class="line-modified">330   // iterate() calles the 2 virtual methods according to the following invocation syntax:</span>


331   //
332   // {pass_int | pass_long | pass_object}
333   //
334   // Arguments are handled from left to right (receiver first, if any).
335   // The offset() values refer to the Java stack offsets but are 0 based and increasing.
336   // The java_offset() values count down to 0, and refer to the Java TOS.
337   // The jni_offset() values increase from 1 or 2, and refer to C arguments.
<a name="39" id="anc39"></a>
338 
<a name="40" id="anc40"></a><span class="line-modified">339   void iterate() { iterate(Fingerprinter(method()).fingerprint());</span>
<span class="line-modified">340   }</span>
<span class="line-removed">341 </span>
<span class="line-removed">342 </span>
<span class="line-removed">343   // Optimized path if we have the bitvector form of signature</span>
<span class="line-removed">344   void iterate( uint64_t fingerprint ) {</span>
<span class="line-removed">345 </span>
346     if (!is_static()) {
347       // handle receiver (not handled by iterate because not in signature)
348       pass_object(); _jni_offset++; _offset++;
349     }
<a name="41" id="anc41"></a><span class="line-modified">350 </span>
<span class="line-removed">351     SignatureIterator::iterate_parameters( fingerprint );</span>
352   }
353 };
354 
355 
<a name="42" id="anc42"></a><span class="line-modified">356 // Handy stream for iterating over signature</span>

357 
358 class SignatureStream : public StackObj {
359  private:
<a name="43" id="anc43"></a><span class="line-modified">360   Symbol*      _signature;</span>
361   int          _begin;
362   int          _end;
<a name="44" id="anc44"></a>

363   BasicType    _type;
<a name="45" id="anc45"></a><span class="line-modified">364   bool         _at_return_type;</span>
<span class="line-modified">365   Symbol*      _previous_name;     // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">366   GrowableArray&lt;Symbol*&gt;* _names;  // symbols created while parsing that need to be dereferenced</span>
<span class="line-removed">367  public:</span>
<span class="line-removed">368   bool at_return_type() const                    { return _at_return_type; }</span>
<span class="line-removed">369   bool is_done() const;</span>
<span class="line-removed">370   void next_non_primitive(int t);</span>
<span class="line-removed">371   void next() {</span>
<span class="line-removed">372     Symbol* sig = _signature;</span>
<span class="line-removed">373     int len = sig-&gt;utf8_length();</span>
<span class="line-removed">374     if (_end &gt;= len) {</span>
<span class="line-removed">375       _end = len + 1;</span>
<span class="line-removed">376       return;</span>
<span class="line-removed">377     }</span>
378 
<a name="46" id="anc46"></a><span class="line-modified">379     _begin = _end;</span>
<span class="line-modified">380     int t = sig-&gt;char_at(_begin);</span>
<span class="line-modified">381     switch (t) {</span>
<span class="line-modified">382       case JVM_SIGNATURE_BYTE:    _type = T_BYTE;    break;</span>
<span class="line-modified">383       case JVM_SIGNATURE_CHAR:    _type = T_CHAR;    break;</span>
<span class="line-modified">384       case JVM_SIGNATURE_DOUBLE:  _type = T_DOUBLE;  break;</span>
<span class="line-modified">385       case JVM_SIGNATURE_FLOAT:   _type = T_FLOAT;   break;</span>
<span class="line-modified">386       case JVM_SIGNATURE_INT:     _type = T_INT;     break;</span>
<span class="line-removed">387       case JVM_SIGNATURE_LONG:    _type = T_LONG;    break;</span>
<span class="line-removed">388       case JVM_SIGNATURE_SHORT:   _type = T_SHORT;   break;</span>
<span class="line-removed">389       case JVM_SIGNATURE_BOOLEAN: _type = T_BOOLEAN; break;</span>
<span class="line-removed">390       case JVM_SIGNATURE_VOID:    _type = T_VOID;    break;</span>
<span class="line-removed">391       default : next_non_primitive(t);</span>
<span class="line-removed">392                 return;</span>
<span class="line-removed">393     }</span>
<span class="line-removed">394     _end++;</span>
395   }
396 
<a name="47" id="anc47"></a><span class="line-modified">397   SignatureStream(Symbol* signature, bool is_method = true);</span>






398   ~SignatureStream();
399 
<a name="48" id="anc48"></a><span class="line-modified">400   bool is_object() const;                        // True if this argument is an object</span>
<span class="line-modified">401   bool is_array() const;                         // True if this argument is an array</span>
<span class="line-modified">402   BasicType type() const                         { return _type; }</span>
<span class="line-modified">403   Symbol* as_symbol();</span>
<span class="line-modified">404   enum FailureMode { ReturnNull, NCDFError };</span>
<span class="line-modified">405   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">406   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">407   const u1* raw_bytes()  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">408   int       raw_length() { return _end - _begin; }</span>






409 
<a name="49" id="anc49"></a><span class="line-modified">410   // return same as_symbol except allocation of new symbols is avoided.</span>
<span class="line-modified">411   Symbol* as_symbol_or_null();</span>







412 
<a name="50" id="anc50"></a><span class="line-modified">413   // count the number of references in the signature</span>
<span class="line-modified">414   int reference_parameter_count();</span>






















415 };
416 
<a name="51" id="anc51"></a><span class="line-modified">417 #ifdef ASSERT</span>
<span class="line-modified">418 class SignatureVerifier : public StackObj {</span>

























419   public:
420     static bool is_valid_method_signature(Symbol* sig);
421     static bool is_valid_type_signature(Symbol* sig);
422   private:
423     static ssize_t is_valid_type(const char*, ssize_t);
424 };
425 #endif
426 #endif // SHARE_RUNTIME_SIGNATURE_HPP
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>