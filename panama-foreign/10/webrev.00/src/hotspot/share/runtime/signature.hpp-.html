<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SIGNATURE_HPP
 26 #define SHARE_RUNTIME_SIGNATURE_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/method.hpp&quot;
 30 
 31 // SignatureIterators iterate over a Java signature (or parts of it).
 32 // (Syntax according to: &quot;The Java Virtual Machine Specification&quot; by
 33 // Tim Lindholm &amp; Frank Yellin; section 4.3 Descriptors; p. 89ff.)
 34 //
 35 // Example: Iterating over ([Lfoo;D)I using
 36 //                         0123456789
 37 //
 38 // iterate_parameters() calls: do_array(2, 7); do_double();
 39 // iterate_returntype() calls:                              do_int();
 40 // iterate()            calls: do_array(2, 7); do_double(); do_int();
 41 //
 42 // is_return_type()        is: false         ; false      ; true
 43 //
 44 // NOTE: The new optimizer has an alternate, for-loop based signature
 45 // iterator implemented in opto/type.cpp, TypeTuple::make().
 46 
 47 class SignatureIterator: public ResourceObj {
 48  protected:
 49   Symbol*      _signature;             // the signature to iterate over
 50   int          _index;                 // the current character index (only valid during iteration)
 51   int          _parameter_index;       // the current parameter index (0 outside iteration phase)
 52   BasicType    _return_type;
 53 
 54   void expect(char c);
 55   int  parse_type();                   // returns the parameter size in words (0 for void)
 56   void check_signature_end();
 57 
 58  public:
 59   // Definitions used in generating and iterating the
 60   // bit field form of the signature generated by the
 61   // Fingerprinter.
 62   enum {
 63     static_feature_size    = 1,
 64     is_static_bit          = 1,
 65 
 66     result_feature_size    = 4,
 67     result_feature_mask    = 0xF,
 68     parameter_feature_size = 4,
 69     parameter_feature_mask = 0xF,
 70 
 71       bool_parm            = 1,
 72       byte_parm            = 2,
 73       char_parm            = 3,
 74       short_parm           = 4,
 75       int_parm             = 5,
 76       long_parm            = 6,
 77       float_parm           = 7,
 78       double_parm          = 8,
 79       obj_parm             = 9,
 80       done_parm            = 10,  // marker for end of parameters
 81 
 82     // max parameters is wordsize minus
 83     //    The sign bit, termination field, the result and static bit fields
 84     max_size_of_parameters = (BitsPerLong-1 -
 85                               result_feature_size - parameter_feature_size -
 86                               static_feature_size) / parameter_feature_size
 87   };
 88 
 89   // Constructors
 90   SignatureIterator(Symbol* signature);
 91 
 92   // Iteration
 93   void iterate_parameters();           // iterates over parameters only
 94   void iterate_parameters( uint64_t fingerprint );
 95   void iterate_returntype();           // iterates over returntype only
 96   void iterate();                      // iterates over whole signature
 97   // Returns the word index of the current parameter;
 98   int  parameter_index() const         { return _parameter_index; }
 99   bool is_return_type() const          { return parameter_index() &lt; 0; }
100   BasicType get_ret_type() const       { return _return_type; }
101 
102   // Basic types
103   virtual void do_bool  ()             = 0;
104   virtual void do_char  ()             = 0;
105   virtual void do_float ()             = 0;
106   virtual void do_double()             = 0;
107   virtual void do_byte  ()             = 0;
108   virtual void do_short ()             = 0;
109   virtual void do_int   ()             = 0;
110   virtual void do_long  ()             = 0;
111   virtual void do_void  ()             = 0;
112 
113   // Object types (begin indexes the first character of the entry, end indexes the first character after the entry)
114   virtual void do_object(int begin, int end) = 0;
115   virtual void do_array (int begin, int end) = 0;
116 
117   static bool is_static(uint64_t fingerprint) {
118     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);
119     return fingerprint &amp; is_static_bit;
120   }
121   static BasicType return_type(uint64_t fingerprint) {
122     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);
123     return (BasicType) ((fingerprint &gt;&gt; static_feature_size) &amp; result_feature_mask);
124   }
125 };
126 
127 
128 // Specialized SignatureIterators: Used to compute signature specific values.
129 
130 class SignatureTypeNames : public SignatureIterator {
131  protected:
132   virtual void type_name(const char* name)   = 0;
133 
134   void do_bool()                       { type_name(&quot;jboolean&quot;); }
135   void do_char()                       { type_name(&quot;jchar&quot;   ); }
136   void do_float()                      { type_name(&quot;jfloat&quot;  ); }
137   void do_double()                     { type_name(&quot;jdouble&quot; ); }
138   void do_byte()                       { type_name(&quot;jbyte&quot;   ); }
139   void do_short()                      { type_name(&quot;jshort&quot;  ); }
140   void do_int()                        { type_name(&quot;jint&quot;    ); }
141   void do_long()                       { type_name(&quot;jlong&quot;   ); }
142   void do_void()                       { type_name(&quot;void&quot;    ); }
143   void do_object(int begin, int end)   { type_name(&quot;jobject&quot; ); }
144   void do_array (int begin, int end)   { type_name(&quot;jobject&quot; ); }
145 
146  public:
147   SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
148 };
149 
150 
151 class SignatureInfo: public SignatureIterator {
152  protected:
153   bool      _has_iterated;             // need this because iterate cannot be called in constructor (set is virtual!)
154   bool      _has_iterated_return;
155   int       _size;
156 
157   void lazy_iterate_parameters()       { if (!_has_iterated) { iterate_parameters(); _has_iterated = true; } }
158   void lazy_iterate_return()           { if (!_has_iterated_return) { iterate_returntype(); _has_iterated_return = true; } }
159 
160   virtual void set(int size, BasicType type) = 0;
161 
162   void do_bool  ()                     { set(T_BOOLEAN_size, T_BOOLEAN); }
163   void do_char  ()                     { set(T_CHAR_size   , T_CHAR   ); }
164   void do_float ()                     { set(T_FLOAT_size  , T_FLOAT  ); }
165   void do_double()                     { set(T_DOUBLE_size , T_DOUBLE ); }
166   void do_byte  ()                     { set(T_BYTE_size   , T_BYTE   ); }
167   void do_short ()                     { set(T_SHORT_size  , T_SHORT  ); }
168   void do_int   ()                     { set(T_INT_size    , T_INT    ); }
169   void do_long  ()                     { set(T_LONG_size   , T_LONG   ); }
170   void do_void  ()                     { set(T_VOID_size   , T_VOID   ); }
171   void do_object(int begin, int end)   { set(T_OBJECT_size , T_OBJECT ); }
172   void do_array (int begin, int end)   { set(T_ARRAY_size  , T_ARRAY  ); }
173 
174  public:
175   SignatureInfo(Symbol* signature) : SignatureIterator(signature) {
176     _has_iterated = _has_iterated_return = false;
177     _size         = 0;
178     _return_type  = T_ILLEGAL;
179   }
180 
181 };
182 
183 
184 // Specialized SignatureIterator: Used to compute the argument size.
185 
186 class ArgumentSizeComputer: public SignatureInfo {
187  private:
188   void set(int size, BasicType type)   { _size += size; }
189  public:
190   ArgumentSizeComputer(Symbol* signature) : SignatureInfo(signature) {}
191 
192   int       size()                     { lazy_iterate_parameters(); return _size; }
193 };
194 
195 
196 class ArgumentCount: public SignatureInfo {
197  private:
198   void set(int size, BasicType type)   { _size ++; }
199  public:
200   ArgumentCount(Symbol* signature) : SignatureInfo(signature) {}
201 
202   int       size()                     { lazy_iterate_parameters(); return _size; }
203 };
204 
205 
206 // Specialized SignatureIterator: Used to compute the result type.
207 
208 class ResultTypeFinder: public SignatureInfo {
209  private:
210   void set(int size, BasicType type)   { _return_type = type; }
211  public:
212   BasicType type()                     { lazy_iterate_return(); return _return_type; }
213 
214   ResultTypeFinder(Symbol* signature) : SignatureInfo(signature) {}
215 };
216 
217 
218 // Fingerprinter computes a unique ID for a given method. The ID
219 // is a bitvector characterizing the methods signature (incl. the receiver).
220 class Fingerprinter: public SignatureIterator {
221  private:
222   uint64_t _fingerprint;
223   int _shift_count;
224   methodHandle mh;
225 
226  public:
227 
228   void do_bool()    { _fingerprint |= (((uint64_t)bool_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
229   void do_char()    { _fingerprint |= (((uint64_t)char_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
230   void do_byte()    { _fingerprint |= (((uint64_t)byte_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
231   void do_short()   { _fingerprint |= (((uint64_t)short_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
232   void do_int()     { _fingerprint |= (((uint64_t)int_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
233   void do_long()    { _fingerprint |= (((uint64_t)long_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
234   void do_float()   { _fingerprint |= (((uint64_t)float_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
235   void do_double()  { _fingerprint |= (((uint64_t)double_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
236 
237   void do_object(int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
238   void do_array (int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }
239 
240   void do_void()    { ShouldNotReachHere(); }
241 
242   Fingerprinter(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
243     mh = method;
244     _fingerprint = 0;
245   }
246 
247   uint64_t fingerprint() {
248     // See if we fingerprinted this method already
249     if (mh-&gt;constMethod()-&gt;fingerprint() != CONST64(0)) {
250       return mh-&gt;constMethod()-&gt;fingerprint();
251     }
252 
253     if (mh-&gt;size_of_parameters() &gt; max_size_of_parameters ) {
254       _fingerprint = (uint64_t)CONST64(-1);
255       mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);
256       return _fingerprint;
257     }
258 
259     assert( (int)mh-&gt;result_type() &lt;= (int)result_feature_mask, &quot;bad result type&quot;);
260     _fingerprint = mh-&gt;result_type();
261     _fingerprint &lt;&lt;= static_feature_size;
262     if (mh-&gt;is_static())  _fingerprint |= 1;
263     _shift_count = result_feature_size + static_feature_size;
264     iterate_parameters();
265     _fingerprint |= ((uint64_t)done_parm) &lt;&lt; _shift_count;// mark end of sig
266     mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);
267     return _fingerprint;
268   }
269 };
270 
271 
272 // Specialized SignatureIterator: Used for native call purposes
273 
274 class NativeSignatureIterator: public SignatureIterator {
275  private:
276   methodHandle _method;
277 // We need separate JNI and Java offset values because in 64 bit mode,
278 // the argument offsets are not in sync with the Java stack.
279 // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
280   int          _offset;                // The java stack offset
281   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
282   int          _jni_offset;            // the current parameter offset, starting with 0
283 
284   void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }
285   void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }
286   void do_float ()                     { pass_float();  _jni_offset++; _offset++;       }
287 #ifdef _LP64
288   void do_double()                     { pass_double(); _jni_offset++; _offset += 2;    }
289 #else
290   void do_double()                     { pass_double(); _jni_offset += 2; _offset += 2; }
291 #endif
292   void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }
293   void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }
294   void do_int   ()                     { pass_int();    _jni_offset++; _offset++;       }
295 #ifdef _LP64
296   void do_long  ()                     { pass_long();   _jni_offset++; _offset += 2;    }
297 #else
298   void do_long  ()                     { pass_long();   _jni_offset += 2; _offset += 2; }
299 #endif
300   void do_void  ()                     { ShouldNotReachHere();                               }
301   void do_object(int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }
302   void do_array (int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }
303 
304  public:
305   methodHandle method() const          { return _method; }
306   int          offset() const          { return _offset; }
307   int      jni_offset() const          { return _jni_offset + _prepended; }
308 //  int     java_offset() const          { return method()-&gt;size_of_parameters() - _offset - 1; }
309   bool      is_static() const          { return method()-&gt;is_static(); }
310   virtual void pass_int()              = 0;
311   virtual void pass_long()             = 0;
312   virtual void pass_object()           = 0;
313   virtual void pass_float()            = 0;
314 #ifdef _LP64
315   virtual void pass_double()           = 0;
316 #else
317   virtual void pass_double()           { pass_long(); }  // may be same as long
318 #endif
319 
320   NativeSignatureIterator(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
321     _method = method;
322     _offset = 0;
323     _jni_offset = 0;
324 
325     const int JNIEnv_words = 1;
326     const int mirror_words = 1;
327     _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
328   }
329 
330   // iterate() calles the 2 virtual methods according to the following invocation syntax:
331   //
332   // {pass_int | pass_long | pass_object}
333   //
334   // Arguments are handled from left to right (receiver first, if any).
335   // The offset() values refer to the Java stack offsets but are 0 based and increasing.
336   // The java_offset() values count down to 0, and refer to the Java TOS.
337   // The jni_offset() values increase from 1 or 2, and refer to C arguments.
338 
339   void iterate() { iterate(Fingerprinter(method()).fingerprint());
340   }
341 
342 
343   // Optimized path if we have the bitvector form of signature
344   void iterate( uint64_t fingerprint ) {
345 
346     if (!is_static()) {
347       // handle receiver (not handled by iterate because not in signature)
348       pass_object(); _jni_offset++; _offset++;
349     }
350 
351     SignatureIterator::iterate_parameters( fingerprint );
352   }
353 };
354 
355 
356 // Handy stream for iterating over signature
357 
358 class SignatureStream : public StackObj {
359  private:
360   Symbol*      _signature;
361   int          _begin;
362   int          _end;
363   BasicType    _type;
364   bool         _at_return_type;
365   Symbol*      _previous_name;     // cache the previously looked up symbol to avoid lookups
366   GrowableArray&lt;Symbol*&gt;* _names;  // symbols created while parsing that need to be dereferenced
367  public:
368   bool at_return_type() const                    { return _at_return_type; }
369   bool is_done() const;
370   void next_non_primitive(int t);
371   void next() {
372     Symbol* sig = _signature;
373     int len = sig-&gt;utf8_length();
374     if (_end &gt;= len) {
375       _end = len + 1;
376       return;
377     }
378 
379     _begin = _end;
380     int t = sig-&gt;char_at(_begin);
381     switch (t) {
382       case JVM_SIGNATURE_BYTE:    _type = T_BYTE;    break;
383       case JVM_SIGNATURE_CHAR:    _type = T_CHAR;    break;
384       case JVM_SIGNATURE_DOUBLE:  _type = T_DOUBLE;  break;
385       case JVM_SIGNATURE_FLOAT:   _type = T_FLOAT;   break;
386       case JVM_SIGNATURE_INT:     _type = T_INT;     break;
387       case JVM_SIGNATURE_LONG:    _type = T_LONG;    break;
388       case JVM_SIGNATURE_SHORT:   _type = T_SHORT;   break;
389       case JVM_SIGNATURE_BOOLEAN: _type = T_BOOLEAN; break;
390       case JVM_SIGNATURE_VOID:    _type = T_VOID;    break;
391       default : next_non_primitive(t);
392                 return;
393     }
394     _end++;
395   }
396 
397   SignatureStream(Symbol* signature, bool is_method = true);
398   ~SignatureStream();
399 
400   bool is_object() const;                        // True if this argument is an object
401   bool is_array() const;                         // True if this argument is an array
402   BasicType type() const                         { return _type; }
403   Symbol* as_symbol();
404   enum FailureMode { ReturnNull, NCDFError };
405   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);
406   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);
407   const u1* raw_bytes()  { return _signature-&gt;bytes() + _begin; }
408   int       raw_length() { return _end - _begin; }
409 
410   // return same as_symbol except allocation of new symbols is avoided.
411   Symbol* as_symbol_or_null();
412 
413   // count the number of references in the signature
414   int reference_parameter_count();
415 };
416 
417 #ifdef ASSERT
418 class SignatureVerifier : public StackObj {
419   public:
420     static bool is_valid_method_signature(Symbol* sig);
421     static bool is_valid_type_signature(Symbol* sig);
422   private:
423     static ssize_t is_valid_type(const char*, ssize_t);
424 };
425 #endif
426 #endif // SHARE_RUNTIME_SIGNATURE_HPP
    </pre>
  </body>
</html>