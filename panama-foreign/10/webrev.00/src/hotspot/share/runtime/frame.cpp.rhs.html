<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/frame.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/moduleEntry.hpp&quot;
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;code/vmreg.inline.hpp&quot;
  29 #include &quot;compiler/abstractCompiler.hpp&quot;
  30 #include &quot;compiler/disassembler.hpp&quot;
  31 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/markWord.hpp&quot;
  37 #include &quot;oops/method.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/verifyOopClosure.hpp&quot;
  41 #include &quot;prims/methodHandles.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/javaCalls.hpp&quot;
  45 #include &quot;runtime/monitorChunk.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/signature.hpp&quot;
  49 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  50 #include &quot;runtime/stubRoutines.hpp&quot;
  51 #include &quot;runtime/thread.inline.hpp&quot;
  52 #include &quot;utilities/debug.hpp&quot;
  53 #include &quot;utilities/decoder.hpp&quot;
  54 #include &quot;utilities/formatBuffer.hpp&quot;
  55 
  56 RegisterMap::RegisterMap(JavaThread *thread, bool update_map) {
  57   _thread         = thread;
  58   _update_map     = update_map;
  59   clear();
  60   debug_only(_update_for_id = NULL;)
  61 #ifndef PRODUCT
  62   for (int i = 0; i &lt; reg_count ; i++ ) _location[i] = NULL;
  63 #endif /* PRODUCT */
  64 }
  65 
  66 RegisterMap::RegisterMap(const RegisterMap* map) {
  67   assert(map != this, &quot;bad initialization parameter&quot;);
  68   assert(map != NULL, &quot;RegisterMap must be present&quot;);
  69   _thread                = map-&gt;thread();
  70   _update_map            = map-&gt;update_map();
  71   _include_argument_oops = map-&gt;include_argument_oops();
  72   debug_only(_update_for_id = map-&gt;_update_for_id;)
  73   pd_initialize_from(map);
  74   if (update_map()) {
  75     for(int i = 0; i &lt; location_valid_size; i++) {
  76       LocationValidType bits = !update_map() ? 0 : map-&gt;_location_valid[i];
  77       _location_valid[i] = bits;
  78       // for whichever bits are set, pull in the corresponding map-&gt;_location
  79       int j = i*location_valid_type_size;
  80       while (bits != 0) {
  81         if ((bits &amp; 1) != 0) {
  82           assert(0 &lt;= j &amp;&amp; j &lt; reg_count, &quot;range check&quot;);
  83           _location[j] = map-&gt;_location[j];
  84         }
  85         bits &gt;&gt;= 1;
  86         j += 1;
  87       }
  88     }
  89   }
  90 }
  91 
  92 void RegisterMap::clear() {
  93   set_include_argument_oops(true);
  94   if (_update_map) {
  95     for(int i = 0; i &lt; location_valid_size; i++) {
  96       _location_valid[i] = 0;
  97     }
  98     pd_clear();
  99   } else {
 100     pd_initialize();
 101   }
 102 }
 103 
 104 #ifndef PRODUCT
 105 
 106 void RegisterMap::print_on(outputStream* st) const {
 107   st-&gt;print_cr(&quot;Register map&quot;);
 108   for(int i = 0; i &lt; reg_count; i++) {
 109 
 110     VMReg r = VMRegImpl::as_VMReg(i);
 111     intptr_t* src = (intptr_t*) location(r);
 112     if (src != NULL) {
 113 
 114       r-&gt;print_on(st);
 115       st-&gt;print(&quot; [&quot; INTPTR_FORMAT &quot;] = &quot;, p2i(src));
 116       if (((uintptr_t)src &amp; (sizeof(*src)-1)) != 0) {
 117         st-&gt;print_cr(&quot;&lt;misaligned&gt;&quot;);
 118       } else {
 119         st-&gt;print_cr(INTPTR_FORMAT, *src);
 120       }
 121     }
 122   }
 123 }
 124 
 125 void RegisterMap::print() const {
 126   print_on(tty);
 127 }
 128 
 129 #endif
 130 // This returns the pc that if you were in the debugger you&#39;d see. Not
 131 // the idealized value in the frame object. This undoes the magic conversion
 132 // that happens for deoptimized frames. In addition it makes the value the
 133 // hardware would want to see in the native frame. The only user (at this point)
 134 // is deoptimization. It likely no one else should ever use it.
 135 
 136 address frame::raw_pc() const {
 137   if (is_deoptimized_frame()) {
 138     CompiledMethod* cm = cb()-&gt;as_compiled_method_or_null();
 139     if (cm-&gt;is_method_handle_return(pc()))
 140       return cm-&gt;deopt_mh_handler_begin() - pc_return_offset;
 141     else
 142       return cm-&gt;deopt_handler_begin() - pc_return_offset;
 143   } else {
 144     return (pc() - pc_return_offset);
 145   }
 146 }
 147 
 148 // Change the pc in a frame object. This does not change the actual pc in
 149 // actual frame. To do that use patch_pc.
 150 //
 151 void frame::set_pc(address   newpc ) {
 152 #ifdef ASSERT
 153   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
 154     assert(!((nmethod*)_cb)-&gt;is_deopt_pc(_pc), &quot;invariant violation&quot;);
 155   }
 156 #endif // ASSERT
 157 
 158   // Unsafe to use the is_deoptimzed tester after changing pc
 159   _deopt_state = unknown;
 160   _pc = newpc;
 161   _cb = CodeCache::find_blob_unsafe(_pc);
 162 
 163 }
 164 
 165 // type testers
 166 bool frame::is_ignored_frame() const {
 167   return false;  // FIXME: some LambdaForm frames should be ignored
 168 }
 169 bool frame::is_deoptimized_frame() const {
 170   assert(_deopt_state != unknown, &quot;not answerable&quot;);
 171   return _deopt_state == is_deoptimized;
 172 }
 173 
 174 bool frame::is_native_frame() const {
 175   return (_cb != NULL &amp;&amp;
 176           _cb-&gt;is_nmethod() &amp;&amp;
 177           ((nmethod*)_cb)-&gt;is_native_method());
 178 }
 179 
 180 bool frame::is_java_frame() const {
 181   if (is_interpreted_frame()) return true;
 182   if (is_compiled_frame())    return true;
 183   return false;
 184 }
 185 
 186 
 187 bool frame::is_compiled_frame() const {
 188   if (_cb != NULL &amp;&amp;
 189       _cb-&gt;is_compiled() &amp;&amp;
 190       ((CompiledMethod*)_cb)-&gt;is_java_method()) {
 191     return true;
 192   }
 193   return false;
 194 }
 195 
 196 
 197 bool frame::is_runtime_frame() const {
 198   return (_cb != NULL &amp;&amp; _cb-&gt;is_runtime_stub());
 199 }
 200 
 201 bool frame::is_safepoint_blob_frame() const {
 202   return (_cb != NULL &amp;&amp; _cb-&gt;is_safepoint_stub());
 203 }
 204 
 205 // testers
 206 
 207 bool frame::is_first_java_frame() const {
 208   RegisterMap map(JavaThread::current(), false); // No update
 209   frame s;
 210   for (s = sender(&amp;map); !(s.is_java_frame() || s.is_first_frame()); s = s.sender(&amp;map));
 211   return s.is_first_frame();
 212 }
 213 
 214 
 215 bool frame::entry_frame_is_first() const {
 216   return entry_frame_call_wrapper()-&gt;is_first_frame();
 217 }
 218 
 219 JavaCallWrapper* frame::entry_frame_call_wrapper_if_safe(JavaThread* thread) const {
 220   JavaCallWrapper** jcw = entry_frame_call_wrapper_addr();
 221   address addr = (address) jcw;
 222 
 223   // addr must be within the usable part of the stack
 224   if (thread-&gt;is_in_usable_stack(addr)) {
 225     return *jcw;
 226   }
 227 
 228   return NULL;
 229 }
 230 
 231 bool frame::is_entry_frame_valid(JavaThread* thread) const {
 232   // Validate the JavaCallWrapper an entry frame must have
 233   address jcw = (address)entry_frame_call_wrapper();
 234   bool jcw_safe = (jcw &lt; thread-&gt;stack_base()) &amp;&amp; (jcw &gt; (address)fp()); // less than stack base
 235   if (!jcw_safe) {
 236     return false;
 237   }
 238 
 239   // Validate sp saved in the java frame anchor
 240   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
 241   return (jfa-&gt;last_Java_sp() &gt; sp());
 242 }
 243 
 244 bool frame::should_be_deoptimized() const {
 245   if (_deopt_state == is_deoptimized ||
 246       !is_compiled_frame() ) return false;
 247   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be an nmethod&quot;);
 248   CompiledMethod* nm = (CompiledMethod *)_cb;
 249   if (TraceDependencies) {
 250     tty-&gt;print(&quot;checking (%s) &quot;, nm-&gt;is_marked_for_deoptimization() ? &quot;true&quot; : &quot;false&quot;);
 251     nm-&gt;print_value_on(tty);
 252     tty-&gt;cr();
 253   }
 254 
 255   if( !nm-&gt;is_marked_for_deoptimization() )
 256     return false;
 257 
 258   // If at the return point, then the frame has already been popped, and
 259   // only the return needs to be executed. Don&#39;t deoptimize here.
 260   return !nm-&gt;is_at_poll_return(pc());
 261 }
 262 
 263 bool frame::can_be_deoptimized() const {
 264   if (!is_compiled_frame()) return false;
 265   CompiledMethod* nm = (CompiledMethod*)_cb;
 266 
 267   if( !nm-&gt;can_be_deoptimized() )
 268     return false;
 269 
 270   return !nm-&gt;is_at_poll_return(pc());
 271 }
 272 
 273 void frame::deoptimize(JavaThread* thread) {
 274   assert(thread-&gt;frame_anchor()-&gt;has_last_Java_frame() &amp;&amp;
 275          thread-&gt;frame_anchor()-&gt;walkable(), &quot;must be&quot;);
 276   // Schedule deoptimization of an nmethod activation with this frame.
 277   assert(_cb != NULL &amp;&amp; _cb-&gt;is_compiled(), &quot;must be&quot;);
 278 
 279   // If the call site is a MethodHandle call site use the MH deopt
 280   // handler.
 281   CompiledMethod* cm = (CompiledMethod*) _cb;
 282   address deopt = cm-&gt;is_method_handle_return(pc()) ?
 283                         cm-&gt;deopt_mh_handler_begin() :
 284                         cm-&gt;deopt_handler_begin();
 285 
 286   // Save the original pc before we patch in the new one
 287   cm-&gt;set_original_pc(this, pc());
 288   patch_pc(thread, deopt);
 289 
 290 #ifdef ASSERT
 291   {
 292     RegisterMap map(thread, false);
 293     frame check = thread-&gt;last_frame();
 294     while (id() != check.id()) {
 295       check = check.sender(&amp;map);
 296     }
 297     assert(check.is_deoptimized_frame(), &quot;missed deopt&quot;);
 298   }
 299 #endif // ASSERT
 300 }
 301 
 302 frame frame::java_sender() const {
 303   RegisterMap map(JavaThread::current(), false);
 304   frame s;
 305   for (s = sender(&amp;map); !(s.is_java_frame() || s.is_first_frame()); s = s.sender(&amp;map)) ;
 306   guarantee(s.is_java_frame(), &quot;tried to get caller of first java frame&quot;);
 307   return s;
 308 }
 309 
 310 frame frame::real_sender(RegisterMap* map) const {
 311   frame result = sender(map);
 312   while (result.is_runtime_frame() ||
 313          result.is_ignored_frame()) {
 314     result = result.sender(map);
 315   }
 316   return result;
 317 }
 318 
 319 // Interpreter frames
 320 
 321 
 322 void frame::interpreter_frame_set_locals(intptr_t* locs)  {
 323   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 324   *interpreter_frame_locals_addr() = locs;
 325 }
 326 
 327 Method* frame::interpreter_frame_method() const {
 328   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 329   Method* m = *interpreter_frame_method_addr();
 330   assert(m-&gt;is_method(), &quot;not a Method*&quot;);
 331   return m;
 332 }
 333 
 334 void frame::interpreter_frame_set_method(Method* method) {
 335   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 336   *interpreter_frame_method_addr() = method;
 337 }
 338 
 339 void frame::interpreter_frame_set_mirror(oop mirror) {
 340   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 341   *interpreter_frame_mirror_addr() = mirror;
 342 }
 343 
 344 jint frame::interpreter_frame_bci() const {
 345   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 346   address bcp = interpreter_frame_bcp();
 347   return interpreter_frame_method()-&gt;bci_from(bcp);
 348 }
 349 
 350 address frame::interpreter_frame_bcp() const {
 351   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 352   address bcp = (address)*interpreter_frame_bcp_addr();
 353   return interpreter_frame_method()-&gt;bcp_from(bcp);
 354 }
 355 
 356 void frame::interpreter_frame_set_bcp(address bcp) {
 357   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 358   *interpreter_frame_bcp_addr() = (intptr_t)bcp;
 359 }
 360 
 361 address frame::interpreter_frame_mdp() const {
 362   assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
 363   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 364   return (address)*interpreter_frame_mdp_addr();
 365 }
 366 
 367 void frame::interpreter_frame_set_mdp(address mdp) {
 368   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
 369   assert(ProfileInterpreter, &quot;must be profiling interpreter&quot;);
 370   *interpreter_frame_mdp_addr() = (intptr_t)mdp;
 371 }
 372 
 373 BasicObjectLock* frame::next_monitor_in_interpreter_frame(BasicObjectLock* current) const {
 374   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 375 #ifdef ASSERT
 376   interpreter_frame_verify_monitor(current);
 377 #endif
 378   BasicObjectLock* next = (BasicObjectLock*) (((intptr_t*) current) + interpreter_frame_monitor_size());
 379   return next;
 380 }
 381 
 382 BasicObjectLock* frame::previous_monitor_in_interpreter_frame(BasicObjectLock* current) const {
 383   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 384 #ifdef ASSERT
 385 //   // This verification needs to be checked before being enabled
 386 //   interpreter_frame_verify_monitor(current);
 387 #endif
 388   BasicObjectLock* previous = (BasicObjectLock*) (((intptr_t*) current) - interpreter_frame_monitor_size());
 389   return previous;
 390 }
 391 
 392 // Interpreter locals and expression stack locations.
 393 
 394 intptr_t* frame::interpreter_frame_local_at(int index) const {
 395   const int n = Interpreter::local_offset_in_bytes(index)/wordSize;
 396   return &amp;((*interpreter_frame_locals_addr())[n]);
 397 }
 398 
 399 intptr_t* frame::interpreter_frame_expression_stack_at(jint offset) const {
 400   const int i = offset * interpreter_frame_expression_stack_direction();
 401   const int n = i * Interpreter::stackElementWords;
 402   return &amp;(interpreter_frame_expression_stack()[n]);
 403 }
 404 
 405 jint frame::interpreter_frame_expression_stack_size() const {
 406   // Number of elements on the interpreter expression stack
 407   // Callers should span by stackElementWords
 408   int element_size = Interpreter::stackElementWords;
 409   size_t stack_size = 0;
 410   if (frame::interpreter_frame_expression_stack_direction() &lt; 0) {
 411     stack_size = (interpreter_frame_expression_stack() -
 412                   interpreter_frame_tos_address() + 1)/element_size;
 413   } else {
 414     stack_size = (interpreter_frame_tos_address() -
 415                   interpreter_frame_expression_stack() + 1)/element_size;
 416   }
 417   assert( stack_size &lt;= (size_t)max_jint, &quot;stack size too big&quot;);
 418   return ((jint)stack_size);
 419 }
 420 
 421 
 422 // (frame::interpreter_frame_sender_sp accessor is in frame_&lt;arch&gt;.cpp)
 423 
 424 const char* frame::print_name() const {
 425   if (is_native_frame())      return &quot;Native&quot;;
 426   if (is_interpreted_frame()) return &quot;Interpreted&quot;;
 427   if (is_compiled_frame()) {
 428     if (is_deoptimized_frame()) return &quot;Deoptimized&quot;;
 429     return &quot;Compiled&quot;;
 430   }
 431   if (sp() == NULL)            return &quot;Empty&quot;;
 432   return &quot;C&quot;;
 433 }
 434 
 435 void frame::print_value_on(outputStream* st, JavaThread *thread) const {
 436   NOT_PRODUCT(address begin = pc()-40;)
 437   NOT_PRODUCT(address end   = NULL;)
 438 
 439   st-&gt;print(&quot;%s frame (sp=&quot; INTPTR_FORMAT &quot; unextended sp=&quot; INTPTR_FORMAT, print_name(), p2i(sp()), p2i(unextended_sp()));
 440   if (sp() != NULL)
 441     st-&gt;print(&quot;, fp=&quot; INTPTR_FORMAT &quot;, real_fp=&quot; INTPTR_FORMAT &quot;, pc=&quot; INTPTR_FORMAT,
 442               p2i(fp()), p2i(real_fp()), p2i(pc()));
 443 
 444   if (StubRoutines::contains(pc())) {
 445     st-&gt;print_cr(&quot;)&quot;);
 446     st-&gt;print(&quot;(&quot;);
 447     StubCodeDesc* desc = StubCodeDesc::desc_for(pc());
 448     st-&gt;print(&quot;~Stub::%s&quot;, desc-&gt;name());
 449     NOT_PRODUCT(begin = desc-&gt;begin(); end = desc-&gt;end();)
 450   } else if (Interpreter::contains(pc())) {
 451     st-&gt;print_cr(&quot;)&quot;);
 452     st-&gt;print(&quot;(&quot;);
 453     InterpreterCodelet* desc = Interpreter::codelet_containing(pc());
 454     if (desc != NULL) {
 455       st-&gt;print(&quot;~&quot;);
 456       desc-&gt;print_on(st);
 457       NOT_PRODUCT(begin = desc-&gt;code_begin(); end = desc-&gt;code_end();)
 458     } else {
 459       st-&gt;print(&quot;~interpreter&quot;);
 460     }
 461   }
 462   st-&gt;print_cr(&quot;)&quot;);
 463 
 464   if (_cb != NULL) {
 465     st-&gt;print(&quot;     &quot;);
 466     _cb-&gt;print_value_on(st);
 467     st-&gt;cr();
 468 #ifndef PRODUCT
 469     if (end == NULL) {
 470       begin = _cb-&gt;code_begin();
 471       end   = _cb-&gt;code_end();
 472     }
 473 #endif
 474   }
 475   NOT_PRODUCT(if (WizardMode &amp;&amp; Verbose) Disassembler::decode(begin, end);)
 476 }
 477 
 478 
 479 void frame::print_on(outputStream* st) const {
 480   print_value_on(st,NULL);
 481   if (is_interpreted_frame()) {
 482     interpreter_frame_print_on(st);
 483   }
 484 }
 485 
 486 
 487 void frame::interpreter_frame_print_on(outputStream* st) const {
 488 #ifndef PRODUCT
 489   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 490   jint i;
 491   for (i = 0; i &lt; interpreter_frame_method()-&gt;max_locals(); i++ ) {
 492     intptr_t x = *interpreter_frame_local_at(i);
 493     st-&gt;print(&quot; - local  [&quot; INTPTR_FORMAT &quot;]&quot;, x);
 494     st-&gt;fill_to(23);
 495     st-&gt;print_cr(&quot;; #%d&quot;, i);
 496   }
 497   for (i = interpreter_frame_expression_stack_size() - 1; i &gt;= 0; --i ) {
 498     intptr_t x = *interpreter_frame_expression_stack_at(i);
 499     st-&gt;print(&quot; - stack  [&quot; INTPTR_FORMAT &quot;]&quot;, x);
 500     st-&gt;fill_to(23);
 501     st-&gt;print_cr(&quot;; #%d&quot;, i);
 502   }
 503   // locks for synchronization
 504   for (BasicObjectLock* current = interpreter_frame_monitor_end();
 505        current &lt; interpreter_frame_monitor_begin();
 506        current = next_monitor_in_interpreter_frame(current)) {
 507     st-&gt;print(&quot; - obj    [&quot;);
 508     current-&gt;obj()-&gt;print_value_on(st);
 509     st-&gt;print_cr(&quot;]&quot;);
 510     st-&gt;print(&quot; - lock   [&quot;);
 511     current-&gt;lock()-&gt;print_on(st);
 512     st-&gt;print_cr(&quot;]&quot;);
 513   }
 514   // monitor
 515   st-&gt;print_cr(&quot; - monitor[&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_monitor_begin()));
 516   // bcp
 517   st-&gt;print(&quot; - bcp    [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_bcp()));
 518   st-&gt;fill_to(23);
 519   st-&gt;print_cr(&quot;; @%d&quot;, interpreter_frame_bci());
 520   // locals
 521   st-&gt;print_cr(&quot; - locals [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_local_at(0)));
 522   // method
 523   st-&gt;print(&quot; - method [&quot; INTPTR_FORMAT &quot;]&quot;, p2i(interpreter_frame_method()));
 524   st-&gt;fill_to(23);
 525   st-&gt;print(&quot;; &quot;);
 526   interpreter_frame_method()-&gt;print_name(st);
 527   st-&gt;cr();
 528 #endif
 529 }
 530 
 531 // Print whether the frame is in the VM or OS indicating a HotSpot problem.
 532 // Otherwise, it&#39;s likely a bug in the native library that the Java code calls,
 533 // hopefully indicating where to submit bugs.
 534 void frame::print_C_frame(outputStream* st, char* buf, int buflen, address pc) {
 535   // C/C++ frame
 536   bool in_vm = os::address_is_in_vm(pc);
 537   st-&gt;print(in_vm ? &quot;V&quot; : &quot;C&quot;);
 538 
 539   int offset;
 540   bool found;
 541 
 542   // libname
 543   found = os::dll_address_to_library_name(pc, buf, buflen, &amp;offset);
 544   if (found) {
 545     // skip directory names
 546     const char *p1, *p2;
 547     p1 = buf;
 548     int len = (int)strlen(os::file_separator());
 549     while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;
 550     st-&gt;print(&quot;  [%s+0x%x]&quot;, p1, offset);
 551   } else {
 552     st-&gt;print(&quot;  &quot; PTR_FORMAT, p2i(pc));
 553   }
 554 
 555   found = os::dll_address_to_function_name(pc, buf, buflen, &amp;offset);
 556   if (found) {
 557     st-&gt;print(&quot;  %s+0x%x&quot;, buf, offset);
 558   }
 559 }
 560 
 561 // frame::print_on_error() is called by fatal error handler. Notice that we may
 562 // crash inside this function if stack frame is corrupted. The fatal error
 563 // handler can catch and handle the crash. Here we assume the frame is valid.
 564 //
 565 // First letter indicates type of the frame:
 566 //    J: Java frame (compiled)
 567 //    A: Java frame (aot compiled)
 568 //    j: Java frame (interpreted)
 569 //    V: VM frame (C/C++)
 570 //    v: Other frames running VM generated code (e.g. stubs, adapters, etc.)
 571 //    C: C/C++ frame
 572 //
 573 // We don&#39;t need detailed frame type as that in frame::print_name(). &quot;C&quot;
 574 // suggests the problem is in user lib; everything else is likely a VM bug.
 575 
 576 void frame::print_on_error(outputStream* st, char* buf, int buflen, bool verbose) const {
 577   if (_cb != NULL) {
 578     if (Interpreter::contains(pc())) {
 579       Method* m = this-&gt;interpreter_frame_method();
 580       if (m != NULL) {
 581         m-&gt;name_and_sig_as_C_string(buf, buflen);
 582         st-&gt;print(&quot;j  %s&quot;, buf);
 583         st-&gt;print(&quot;+%d&quot;, this-&gt;interpreter_frame_bci());
 584         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 585         if (module-&gt;is_named()) {
 586           module-&gt;name()-&gt;as_C_string(buf, buflen);
 587           st-&gt;print(&quot; %s&quot;, buf);
 588           if (module-&gt;version() != NULL) {
 589             module-&gt;version()-&gt;as_C_string(buf, buflen);
 590             st-&gt;print(&quot;@%s&quot;, buf);
 591           }
 592         }
 593       } else {
 594         st-&gt;print(&quot;j  &quot; PTR_FORMAT, p2i(pc()));
 595       }
 596     } else if (StubRoutines::contains(pc())) {
 597       StubCodeDesc* desc = StubCodeDesc::desc_for(pc());
 598       if (desc != NULL) {
 599         st-&gt;print(&quot;v  ~StubRoutines::%s&quot;, desc-&gt;name());
 600       } else {
 601         st-&gt;print(&quot;v  ~StubRoutines::&quot; PTR_FORMAT, p2i(pc()));
 602       }
 603     } else if (_cb-&gt;is_buffer_blob()) {
 604       st-&gt;print(&quot;v  ~BufferBlob::%s&quot;, ((BufferBlob *)_cb)-&gt;name());
 605     } else if (_cb-&gt;is_compiled()) {
 606       CompiledMethod* cm = (CompiledMethod*)_cb;
 607       Method* m = cm-&gt;method();
 608       if (m != NULL) {
 609         if (cm-&gt;is_aot()) {
 610           st-&gt;print(&quot;A %d &quot;, cm-&gt;compile_id());
 611         } else if (cm-&gt;is_nmethod()) {
 612           nmethod* nm = cm-&gt;as_nmethod();
 613           st-&gt;print(&quot;J %d%s&quot;, nm-&gt;compile_id(), (nm-&gt;is_osr_method() ? &quot;%&quot; : &quot;&quot;));
 614           st-&gt;print(&quot; %s&quot;, nm-&gt;compiler_name());
 615         }
 616         m-&gt;name_and_sig_as_C_string(buf, buflen);
 617         st-&gt;print(&quot; %s&quot;, buf);
 618         ModuleEntry* module = m-&gt;method_holder()-&gt;module();
 619         if (module-&gt;is_named()) {
 620           module-&gt;name()-&gt;as_C_string(buf, buflen);
 621           st-&gt;print(&quot; %s&quot;, buf);
 622           if (module-&gt;version() != NULL) {
 623             module-&gt;version()-&gt;as_C_string(buf, buflen);
 624             st-&gt;print(&quot;@%s&quot;, buf);
 625           }
 626         }
 627         st-&gt;print(&quot; (%d bytes) @ &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot;+&quot; INTPTR_FORMAT &quot;]&quot;,
 628                   m-&gt;code_size(), p2i(_pc), p2i(_cb-&gt;code_begin()), _pc - _cb-&gt;code_begin());
 629 #if INCLUDE_JVMCI
 630         if (cm-&gt;is_nmethod()) {
 631           nmethod* nm = cm-&gt;as_nmethod();
 632           const char* jvmciName = nm-&gt;jvmci_name();
 633           if (jvmciName != NULL) {
 634             st-&gt;print(&quot; (%s)&quot;, jvmciName);
 635           }
 636         }
 637 #endif
 638       } else {
 639         st-&gt;print(&quot;J  &quot; PTR_FORMAT, p2i(pc()));
 640       }
 641     } else if (_cb-&gt;is_runtime_stub()) {
 642       st-&gt;print(&quot;v  ~RuntimeStub::%s&quot;, ((RuntimeStub *)_cb)-&gt;name());
 643     } else if (_cb-&gt;is_deoptimization_stub()) {
 644       st-&gt;print(&quot;v  ~DeoptimizationBlob&quot;);
 645     } else if (_cb-&gt;is_exception_stub()) {
 646       st-&gt;print(&quot;v  ~ExceptionBlob&quot;);
 647     } else if (_cb-&gt;is_safepoint_stub()) {
 648       st-&gt;print(&quot;v  ~SafepointBlob&quot;);
 649     } else if (_cb-&gt;is_adapter_blob()) {
 650       st-&gt;print(&quot;v  ~AdapterBlob&quot;);
 651     } else if (_cb-&gt;is_vtable_blob()) {
 652       st-&gt;print(&quot;v  ~VtableBlob&quot;);
 653     } else if (_cb-&gt;is_method_handles_adapter_blob()) {
 654       st-&gt;print(&quot;v  ~MethodHandlesAdapterBlob&quot;);
 655     } else if (_cb-&gt;is_uncommon_trap_stub()) {
 656       st-&gt;print(&quot;v  ~UncommonTrapBlob&quot;);
 657     } else {
 658       st-&gt;print(&quot;v  blob &quot; PTR_FORMAT, p2i(pc()));
 659     }
 660   } else {
 661     print_C_frame(st, buf, buflen, pc());
 662   }
 663 }
 664 
 665 
 666 /*
 667   The interpreter_frame_expression_stack_at method in the case of SPARC needs the
 668   max_stack value of the method in order to compute the expression stack address.
 669   It uses the Method* in order to get the max_stack value but during GC this
 670   Method* value saved on the frame is changed by reverse_and_push and hence cannot
 671   be used. So we save the max_stack value in the FrameClosure object and pass it
 672   down to the interpreter_frame_expression_stack_at method
 673 */
 674 class InterpreterFrameClosure : public OffsetClosure {
 675  private:
 676   frame* _fr;
 677   OopClosure* _f;
 678   int    _max_locals;
 679   int    _max_stack;
 680 
 681  public:
 682   InterpreterFrameClosure(frame* fr, int max_locals, int max_stack,
 683                           OopClosure* f) {
 684     _fr         = fr;
 685     _max_locals = max_locals;
 686     _max_stack  = max_stack;
 687     _f          = f;
 688   }
 689 
 690   void offset_do(int offset) {
 691     oop* addr;
 692     if (offset &lt; _max_locals) {
 693       addr = (oop*) _fr-&gt;interpreter_frame_local_at(offset);
 694       assert((intptr_t*)addr &gt;= _fr-&gt;sp(), &quot;must be inside the frame&quot;);
 695       _f-&gt;do_oop(addr);
 696     } else {
 697       addr = (oop*) _fr-&gt;interpreter_frame_expression_stack_at((offset - _max_locals));
 698       // In case of exceptions, the expression stack is invalid and the esp will be reset to express
 699       // this condition. Therefore, we call f only if addr is &#39;inside&#39; the stack (i.e., addr &gt;= esp for Intel).
 700       bool in_stack;
 701       if (frame::interpreter_frame_expression_stack_direction() &gt; 0) {
 702         in_stack = (intptr_t*)addr &lt;= _fr-&gt;interpreter_frame_tos_address();
 703       } else {
 704         in_stack = (intptr_t*)addr &gt;= _fr-&gt;interpreter_frame_tos_address();
 705       }
 706       if (in_stack) {
 707         _f-&gt;do_oop(addr);
 708       }
 709     }
 710   }
 711 
 712   int max_locals()  { return _max_locals; }
 713   frame* fr()       { return _fr; }
 714 };
 715 
 716 
<a name="2" id="anc2"></a><span class="line-modified"> 717 class InterpretedArgumentOopFinder: public SignatureIterator {</span>
 718  private:
 719   OopClosure* _f;        // Closure to invoke
 720   int    _offset;        // TOS-relative offset, decremented with each argument
 721   bool   _has_receiver;  // true if the callee has a receiver
 722   frame* _fr;
 723 
<a name="3" id="anc3"></a><span class="line-modified"> 724   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 725   void do_type(BasicType type) {</span>
<span class="line-added"> 726     _offset -= parameter_type_word_count(type);</span>
 727     if (is_reference_type(type)) oop_offset_do();
<a name="4" id="anc4"></a><span class="line-modified"> 728    }</span>
 729 
 730   void oop_offset_do() {
 731     oop* addr;
 732     addr = (oop*)_fr-&gt;interpreter_frame_tos_at(_offset);
 733     _f-&gt;do_oop(addr);
 734   }
 735 
 736  public:
<a name="5" id="anc5"></a><span class="line-modified"> 737   InterpretedArgumentOopFinder(Symbol* signature, bool has_receiver, frame* fr, OopClosure* f) : SignatureIterator(signature), _has_receiver(has_receiver) {</span>
 738     // compute size of arguments
 739     int args_size = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0);
 740     assert(!fr-&gt;is_interpreted_frame() ||
 741            args_size &lt;= fr-&gt;interpreter_frame_expression_stack_size(),
 742             &quot;args cannot be on stack anymore&quot;);
 743     // initialize InterpretedArgumentOopFinder
 744     _f         = f;
 745     _fr        = fr;
 746     _offset    = args_size;
 747   }
 748 
 749   void oops_do() {
 750     if (_has_receiver) {
 751       --_offset;
 752       oop_offset_do();
 753     }
<a name="6" id="anc6"></a><span class="line-modified"> 754     do_parameters_on(this);</span>
 755   }
 756 };
 757 
 758 
 759 // Entry frame has following form (n arguments)
 760 //         +-----------+
 761 //   sp -&gt; |  last arg |
 762 //         +-----------+
 763 //         :    :::    :
 764 //         +-----------+
 765 // (sp+n)-&gt;|  first arg|
 766 //         +-----------+
 767 
 768 
 769 
 770 // visits and GC&#39;s all the arguments in entry frame
<a name="7" id="anc7"></a><span class="line-modified"> 771 class EntryFrameOopFinder: public SignatureIterator {</span>
 772  private:
 773   bool   _is_static;
 774   int    _offset;
 775   frame* _fr;
 776   OopClosure* _f;
 777 
<a name="8" id="anc8"></a><span class="line-modified"> 778   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added"> 779   void do_type(BasicType type) {</span>
<span class="line-added"> 780     // decrement offset before processing the type</span>
<span class="line-added"> 781     _offset -= parameter_type_word_count(type);</span>
 782     assert (_offset &gt;= 0, &quot;illegal offset&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 783     if (is_reference_type(type))  oop_at_offset_do(_offset);</span>
<span class="line-modified"> 784  }</span>

 785 
 786   void oop_at_offset_do(int offset) {
 787     assert (offset &gt;= 0, &quot;illegal offset&quot;);
 788     oop* addr = (oop*) _fr-&gt;entry_frame_argument_at(offset);
 789     _f-&gt;do_oop(addr);
 790   }
 791 
 792  public:
<a name="10" id="anc10"></a><span class="line-modified"> 793   EntryFrameOopFinder(frame* frame, Symbol* signature, bool is_static) : SignatureIterator(signature) {</span>
<span class="line-modified"> 794     _f = NULL; // will be set later</span>
<span class="line-modified"> 795     _fr = frame;</span>
<span class="line-modified"> 796     _is_static = is_static;</span>
<span class="line-modified"> 797     _offset = ArgumentSizeComputer(signature).size();  // pre-decremented down to zero</span>
<span class="line-modified"> 798   }</span>
 799 
 800   void arguments_do(OopClosure* f) {
 801     _f = f;
<a name="11" id="anc11"></a><span class="line-modified"> 802     if (!_is_static)  oop_at_offset_do(_offset); // do the receiver</span>
<span class="line-modified"> 803     do_parameters_on(this);</span>
 804   }
 805 
 806 };
 807 
 808 oop* frame::interpreter_callee_receiver_addr(Symbol* signature) {
 809   ArgumentSizeComputer asc(signature);
 810   int size = asc.size();
 811   return (oop *)interpreter_frame_tos_at(size);
 812 }
 813 
 814 
 815 void frame::oops_interpreted_do(OopClosure* f, const RegisterMap* map, bool query_oop_map_cache) {
 816   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
 817   assert(map != NULL, &quot;map must be set&quot;);
 818   Thread *thread = Thread::current();
 819   methodHandle m (thread, interpreter_frame_method());
 820   jint      bci = interpreter_frame_bci();
 821 
 822   assert(!Universe::heap()-&gt;is_in(m()),
 823           &quot;must be valid oop&quot;);
 824   assert(m-&gt;is_method(), &quot;checking frame value&quot;);
 825   assert((m-&gt;is_native() &amp;&amp; bci == 0)  ||
 826          (!m-&gt;is_native() &amp;&amp; bci &gt;= 0 &amp;&amp; bci &lt; m-&gt;code_size()),
 827          &quot;invalid bci value&quot;);
 828 
 829   // Handle the monitor elements in the activation
 830   for (
 831     BasicObjectLock* current = interpreter_frame_monitor_end();
 832     current &lt; interpreter_frame_monitor_begin();
 833     current = next_monitor_in_interpreter_frame(current)
 834   ) {
 835 #ifdef ASSERT
 836     interpreter_frame_verify_monitor(current);
 837 #endif
 838     current-&gt;oops_do(f);
 839   }
 840 
 841   if (m-&gt;is_native()) {
 842     f-&gt;do_oop(interpreter_frame_temp_oop_addr());
 843   }
 844 
 845   // The method pointer in the frame might be the only path to the method&#39;s
 846   // klass, and the klass needs to be kept alive while executing. The GCs
 847   // don&#39;t trace through method pointers, so the mirror of the method&#39;s klass
 848   // is installed as a GC root.
 849   f-&gt;do_oop(interpreter_frame_mirror_addr());
 850 
 851   int max_locals = m-&gt;is_native() ? m-&gt;size_of_parameters() : m-&gt;max_locals();
 852 
 853   Symbol* signature = NULL;
 854   bool has_receiver = false;
 855 
 856   // Process a callee&#39;s arguments if we are at a call site
 857   // (i.e., if we are at an invoke bytecode)
 858   // This is used sometimes for calling into the VM, not for another
 859   // interpreted or compiled frame.
 860   if (!m-&gt;is_native()) {
 861     Bytecode_invoke call = Bytecode_invoke_check(m, bci);
 862     if (call.is_valid()) {
 863       signature = call.signature();
 864       has_receiver = call.has_receiver();
 865       if (map-&gt;include_argument_oops() &amp;&amp;
 866           interpreter_frame_expression_stack_size() &gt; 0) {
 867         ResourceMark rm(thread);  // is this right ???
 868         // we are at a call site &amp; the expression stack is not empty
 869         // =&gt; process callee&#39;s arguments
 870         //
 871         // Note: The expression stack can be empty if an exception
 872         //       occurred during method resolution/execution. In all
 873         //       cases we empty the expression stack completely be-
 874         //       fore handling the exception (the exception handling
 875         //       code in the interpreter calls a blocking runtime
 876         //       routine which can cause this code to be executed).
 877         //       (was bug gri 7/27/98)
 878         oops_interpreted_arguments_do(signature, has_receiver, f);
 879       }
 880     }
 881   }
 882 
 883   InterpreterFrameClosure blk(this, max_locals, m-&gt;max_stack(), f);
 884 
 885   // process locals &amp; expression stack
 886   InterpreterOopMap mask;
 887   if (query_oop_map_cache) {
 888     m-&gt;mask_for(bci, &amp;mask);
 889   } else {
 890     OopMapCache::compute_one_oop_map(m, bci, &amp;mask);
 891   }
 892   mask.iterate_oop(&amp;blk);
 893 }
 894 
 895 
 896 void frame::oops_interpreted_arguments_do(Symbol* signature, bool has_receiver, OopClosure* f) {
 897   InterpretedArgumentOopFinder finder(signature, has_receiver, this, f);
 898   finder.oops_do();
 899 }
 900 
 901 void frame::oops_code_blob_do(OopClosure* f, CodeBlobClosure* cf, const RegisterMap* reg_map) {
 902   assert(_cb != NULL, &quot;sanity check&quot;);
 903   if (_cb-&gt;oop_maps() != NULL) {
 904     OopMapSet::oops_do(this, reg_map, f);
 905 
 906     // Preserve potential arguments for a callee. We handle this by dispatching
 907     // on the codeblob. For c2i, we do
 908     if (reg_map-&gt;include_argument_oops()) {
 909       _cb-&gt;preserve_callee_argument_oops(*this, reg_map, f);
 910     }
 911   }
 912   // In cases where perm gen is collected, GC will want to mark
 913   // oops referenced from nmethods active on thread stacks so as to
 914   // prevent them from being collected. However, this visit should be
 915   // restricted to certain phases of the collection only. The
 916   // closure decides how it wants nmethods to be traced.
 917   if (cf != NULL)
 918     cf-&gt;do_code_blob(_cb);
 919 }
 920 
<a name="12" id="anc12"></a><span class="line-modified"> 921 class CompiledArgumentOopFinder: public SignatureIterator {</span>
 922  protected:
 923   OopClosure*     _f;
 924   int             _offset;        // the current offset, incremented with each argument
 925   bool            _has_receiver;  // true if the callee has a receiver
 926   bool            _has_appendix;  // true if the call has an appendix
 927   frame           _fr;
 928   RegisterMap*    _reg_map;
 929   int             _arg_size;
 930   VMRegPair*      _regs;        // VMReg list of arguments
 931 
<a name="13" id="anc13"></a><span class="line-modified"> 932   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified"> 933   void do_type(BasicType type) {</span>
<span class="line-modified"> 934     if (is_reference_type(type))  handle_oop_offset();</span>
<span class="line-added"> 935     _offset += parameter_type_word_count(type);</span>
 936   }
 937 
 938   virtual void handle_oop_offset() {
 939     // Extract low order register number from register array.
 940     // In LP64-land, the high-order bits are valid but unhelpful.
 941     VMReg reg = _regs[_offset].first();
 942     oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);
 943     _f-&gt;do_oop(loc);
 944   }
 945 
 946  public:
<a name="14" id="anc14"></a><span class="line-modified"> 947   CompiledArgumentOopFinder(Symbol* signature, bool has_receiver, bool has_appendix, OopClosure* f, frame fr, const RegisterMap* reg_map)</span>
<span class="line-modified"> 948     : SignatureIterator(signature) {</span>
 949 
 950     // initialize CompiledArgumentOopFinder
 951     _f         = f;
 952     _offset    = 0;
 953     _has_receiver = has_receiver;
 954     _has_appendix = has_appendix;
 955     _fr        = fr;
 956     _reg_map   = (RegisterMap*)reg_map;
 957     _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);
 958 
 959     int arg_size;
 960     _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &amp;arg_size);
 961     assert(arg_size == _arg_size, &quot;wrong arg size&quot;);
 962   }
 963 
 964   void oops_do() {
 965     if (_has_receiver) {
 966       handle_oop_offset();
 967       _offset++;
 968     }
<a name="15" id="anc15"></a><span class="line-modified"> 969     do_parameters_on(this);</span>
 970     if (_has_appendix) {
 971       handle_oop_offset();
 972       _offset++;
 973     }
 974   }
 975 };
 976 
 977 void frame::oops_compiled_arguments_do(Symbol* signature, bool has_receiver, bool has_appendix,
 978                                        const RegisterMap* reg_map, OopClosure* f) {
 979   ResourceMark rm;
 980   CompiledArgumentOopFinder finder(signature, has_receiver, has_appendix, f, *this, reg_map);
 981   finder.oops_do();
 982 }
 983 
 984 
 985 // Get receiver out of callers frame, i.e. find parameter 0 in callers
 986 // frame.  Consult ADLC for where parameter 0 is to be found.  Then
 987 // check local reg_map for it being a callee-save register or argument
 988 // register, both of which are saved in the local frame.  If not found
 989 // there, it must be an in-stack argument of the caller.
 990 // Note: caller.sp() points to callee-arguments
 991 oop frame::retrieve_receiver(RegisterMap* reg_map) {
 992   frame caller = *this;
 993 
 994   // First consult the ADLC on where it puts parameter 0 for this signature.
 995   VMReg reg = SharedRuntime::name_for_receiver();
 996   oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);
 997   if (oop_adr == NULL) {
 998     guarantee(oop_adr != NULL, &quot;bad register save location&quot;);
 999     return NULL;
1000   }
1001   oop r = *oop_adr;
1002   assert(Universe::heap()-&gt;is_in_or_null(r), &quot;bad receiver: &quot; INTPTR_FORMAT &quot; (&quot; INTX_FORMAT &quot;)&quot;, p2i(r), p2i(r));
1003   return r;
1004 }
1005 
1006 
1007 BasicLock* frame::get_native_monitor() {
1008   nmethod* nm = (nmethod*)_cb;
1009   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1010          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1011   int byte_offset = in_bytes(nm-&gt;native_basic_lock_sp_offset());
1012   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1013   return (BasicLock*) &amp;sp()[byte_offset / wordSize];
1014 }
1015 
1016 oop frame::get_native_receiver() {
1017   nmethod* nm = (nmethod*)_cb;
1018   assert(_cb != NULL &amp;&amp; _cb-&gt;is_nmethod() &amp;&amp; nm-&gt;method()-&gt;is_native(),
1019          &quot;Should not call this unless it&#39;s a native nmethod&quot;);
1020   int byte_offset = in_bytes(nm-&gt;native_receiver_sp_offset());
1021   assert(byte_offset &gt;= 0, &quot;should not see invalid offset&quot;);
1022   oop owner = ((oop*) sp())[byte_offset / wordSize];
1023   assert( Universe::heap()-&gt;is_in(owner), &quot;bad receiver&quot; );
1024   return owner;
1025 }
1026 
1027 void frame::oops_entry_do(OopClosure* f, const RegisterMap* map) {
1028   assert(map != NULL, &quot;map must be set&quot;);
1029   if (map-&gt;include_argument_oops()) {
1030     // must collect argument oops, as nobody else is doing it
1031     Thread *thread = Thread::current();
1032     methodHandle m (thread, entry_frame_call_wrapper()-&gt;callee_method());
1033     EntryFrameOopFinder finder(this, m-&gt;signature(), m-&gt;is_static());
1034     finder.arguments_do(f);
1035   }
1036   // Traverse the Handle Block saved in the entry frame
1037   entry_frame_call_wrapper()-&gt;oops_do(f);
1038 }
1039 
1040 
1041 void frame::oops_do_internal(OopClosure* f, CodeBlobClosure* cf, RegisterMap* map, bool use_interpreter_oop_map_cache) {
1042 #ifndef PRODUCT
1043 #if defined(__SUNPRO_CC) &amp;&amp; __SUNPRO_CC &gt;= 0x5140
1044 #pragma error_messages(off, SEC_NULL_PTR_DEREF)
1045 #endif
1046   // simulate GC crash here to dump java thread in error report
1047   if (CrashGCForDumpingJavaThread) {
1048     char *t = NULL;
1049     *t = &#39;c&#39;;
1050   }
1051 #endif
1052   if (is_interpreted_frame()) {
1053     oops_interpreted_do(f, map, use_interpreter_oop_map_cache);
1054   } else if (is_entry_frame()) {
1055     oops_entry_do(f, map);
1056   } else if (CodeCache::contains(pc())) {
1057     oops_code_blob_do(f, cf, map);
1058   } else {
1059     ShouldNotReachHere();
1060   }
1061 }
1062 
1063 void frame::nmethods_do(CodeBlobClosure* cf) {
1064   if (_cb != NULL &amp;&amp; _cb-&gt;is_nmethod()) {
1065     cf-&gt;do_code_blob(_cb);
1066   }
1067 }
1068 
1069 
1070 // Call f closure on the interpreted Method*s in the stack.
1071 void frame::metadata_do(MetadataClosure* f) {
1072   ResourceMark rm;
1073   if (is_interpreted_frame()) {
1074     Method* m = this-&gt;interpreter_frame_method();
1075     assert(m != NULL, &quot;expecting a method in this frame&quot;);
1076     f-&gt;do_metadata(m);
1077   }
1078 }
1079 
1080 void frame::verify(const RegisterMap* map) {
1081   // for now make sure receiver type is correct
1082   if (is_interpreted_frame()) {
1083     Method* method = interpreter_frame_method();
1084     guarantee(method-&gt;is_method(), &quot;method is wrong in frame::verify&quot;);
1085     if (!method-&gt;is_static()) {
1086       // fetch the receiver
1087       oop* p = (oop*) interpreter_frame_local_at(0);
1088       // make sure we have the right receiver type
1089     }
1090   }
1091 #if COMPILER2_OR_JVMCI
1092   assert(DerivedPointerTable::is_empty(), &quot;must be empty before verify&quot;);
1093 #endif
1094   oops_do_internal(&amp;VerifyOopClosure::verify_oop, NULL, (RegisterMap*)map, false);
1095 }
1096 
1097 
1098 #ifdef ASSERT
1099 bool frame::verify_return_pc(address x) {
1100   if (StubRoutines::returns_to_call_stub(x)) {
1101     return true;
1102   }
1103   if (CodeCache::contains(x)) {
1104     return true;
1105   }
1106   if (Interpreter::contains(x)) {
1107     return true;
1108   }
1109   return false;
1110 }
1111 #endif
1112 
1113 #ifdef ASSERT
1114 void frame::interpreter_frame_verify_monitor(BasicObjectLock* value) const {
1115   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
1116   // verify that the value is in the right part of the frame
1117   address low_mark  = (address) interpreter_frame_monitor_end();
1118   address high_mark = (address) interpreter_frame_monitor_begin();
1119   address current   = (address) value;
1120 
1121   const int monitor_size = frame::interpreter_frame_monitor_size();
1122   guarantee((high_mark - current) % monitor_size  ==  0         , &quot;Misaligned top of BasicObjectLock*&quot;);
1123   guarantee( high_mark &gt; current                                , &quot;Current BasicObjectLock* higher than high_mark&quot;);
1124 
1125   guarantee((current - low_mark) % monitor_size  ==  0         , &quot;Misaligned bottom of BasicObjectLock*&quot;);
1126   guarantee( current &gt;= low_mark                               , &quot;Current BasicObjectLock* below than low_mark&quot;);
1127 }
1128 #endif
1129 
1130 #ifndef PRODUCT
1131 void frame::describe(FrameValues&amp; values, int frame_no) {
1132   // boundaries: sp and the &#39;real&#39; frame pointer
1133   values.describe(-1, sp(), err_msg(&quot;sp for #%d&quot;, frame_no), 1);
1134   intptr_t* frame_pointer = real_fp(); // Note: may differ from fp()
1135 
1136   // print frame info at the highest boundary
1137   intptr_t* info_address = MAX2(sp(), frame_pointer);
1138 
1139   if (info_address != frame_pointer) {
1140     // print frame_pointer explicitly if not marked by the frame info
1141     values.describe(-1, frame_pointer, err_msg(&quot;frame pointer for #%d&quot;, frame_no), 1);
1142   }
1143 
1144   if (is_entry_frame() || is_compiled_frame() || is_interpreted_frame() || is_native_frame()) {
1145     // Label values common to most frames
1146     values.describe(-1, unextended_sp(), err_msg(&quot;unextended_sp for #%d&quot;, frame_no));
1147   }
1148 
1149   if (is_interpreted_frame()) {
1150     Method* m = interpreter_frame_method();
1151     int bci = interpreter_frame_bci();
1152 
1153     // Label the method and current bci
1154     values.describe(-1, info_address,
1155                     FormatBuffer&lt;1024&gt;(&quot;#%d method %s @ %d&quot;, frame_no, m-&gt;name_and_sig_as_C_string(), bci), 2);
1156     values.describe(-1, info_address,
1157                     err_msg(&quot;- %d locals %d max stack&quot;, m-&gt;max_locals(), m-&gt;max_stack()), 1);
1158     if (m-&gt;max_locals() &gt; 0) {
1159       intptr_t* l0 = interpreter_frame_local_at(0);
1160       intptr_t* ln = interpreter_frame_local_at(m-&gt;max_locals() - 1);
1161       values.describe(-1, MAX2(l0, ln), err_msg(&quot;locals for #%d&quot;, frame_no), 1);
1162       // Report each local and mark as owned by this frame
1163       for (int l = 0; l &lt; m-&gt;max_locals(); l++) {
1164         intptr_t* l0 = interpreter_frame_local_at(l);
1165         values.describe(frame_no, l0, err_msg(&quot;local %d&quot;, l));
1166       }
1167     }
1168 
1169     // Compute the actual expression stack size
1170     InterpreterOopMap mask;
1171     OopMapCache::compute_one_oop_map(methodHandle(Thread::current(), m), bci, &amp;mask);
1172     intptr_t* tos = NULL;
1173     // Report each stack element and mark as owned by this frame
1174     for (int e = 0; e &lt; mask.expression_stack_size(); e++) {
1175       tos = MAX2(tos, interpreter_frame_expression_stack_at(e));
1176       values.describe(frame_no, interpreter_frame_expression_stack_at(e),
1177                       err_msg(&quot;stack %d&quot;, e));
1178     }
1179     if (tos != NULL) {
1180       values.describe(-1, tos, err_msg(&quot;expression stack for #%d&quot;, frame_no), 1);
1181     }
1182     if (interpreter_frame_monitor_begin() != interpreter_frame_monitor_end()) {
1183       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_begin(), &quot;monitors begin&quot;);
1184       values.describe(frame_no, (intptr_t*)interpreter_frame_monitor_end(), &quot;monitors end&quot;);
1185     }
1186   } else if (is_entry_frame()) {
1187     // For now just label the frame
1188     values.describe(-1, info_address, err_msg(&quot;#%d entry frame&quot;, frame_no), 2);
1189   } else if (is_compiled_frame()) {
1190     // For now just label the frame
1191     CompiledMethod* cm = (CompiledMethod*)cb();
1192     values.describe(-1, info_address,
1193                     FormatBuffer&lt;1024&gt;(&quot;#%d nmethod &quot; INTPTR_FORMAT &quot; for method %s%s%s&quot;, frame_no,
1194                                        p2i(cm),
1195                                        (cm-&gt;is_aot() ? &quot;A &quot;: &quot;J &quot;),
1196                                        cm-&gt;method()-&gt;name_and_sig_as_C_string(),
1197                                        (_deopt_state == is_deoptimized) ?
1198                                        &quot; (deoptimized)&quot; :
1199                                        ((_deopt_state == unknown) ? &quot; (state unknown)&quot; : &quot;&quot;)),
1200                     2);
1201   } else if (is_native_frame()) {
1202     // For now just label the frame
1203     nmethod* nm = cb()-&gt;as_nmethod_or_null();
1204     values.describe(-1, info_address,
1205                     FormatBuffer&lt;1024&gt;(&quot;#%d nmethod &quot; INTPTR_FORMAT &quot; for native method %s&quot;, frame_no,
1206                                        p2i(nm), nm-&gt;method()-&gt;name_and_sig_as_C_string()), 2);
1207   } else {
1208     // provide default info if not handled before
1209     char *info = (char *) &quot;special frame&quot;;
1210     if ((_cb != NULL) &amp;&amp;
1211         (_cb-&gt;name() != NULL)) {
1212       info = (char *)_cb-&gt;name();
1213     }
1214     values.describe(-1, info_address, err_msg(&quot;#%d &lt;%s&gt;&quot;, frame_no, info), 2);
1215   }
1216 
1217   // platform dependent additional data
1218   describe_pd(values, frame_no);
1219 }
1220 
1221 #endif
1222 
1223 
1224 //-----------------------------------------------------------------------------------
1225 // StackFrameStream implementation
1226 
1227 StackFrameStream::StackFrameStream(JavaThread *thread, bool update) : _reg_map(thread, update) {
1228   assert(thread-&gt;has_last_Java_frame(), &quot;sanity check&quot;);
1229   _fr = thread-&gt;last_frame();
1230   _is_done = false;
1231 }
1232 
1233 
1234 #ifndef PRODUCT
1235 
1236 void FrameValues::describe(int owner, intptr_t* location, const char* description, int priority) {
1237   FrameValue fv;
1238   fv.location = location;
1239   fv.owner = owner;
1240   fv.priority = priority;
1241   fv.description = NEW_RESOURCE_ARRAY(char, strlen(description) + 1);
1242   strcpy(fv.description, description);
1243   _values.append(fv);
1244 }
1245 
1246 
1247 #ifdef ASSERT
1248 void FrameValues::validate() {
1249   _values.sort(compare);
1250   bool error = false;
1251   FrameValue prev;
1252   prev.owner = -1;
1253   for (int i = _values.length() - 1; i &gt;= 0; i--) {
1254     FrameValue fv = _values.at(i);
1255     if (fv.owner == -1) continue;
1256     if (prev.owner == -1) {
1257       prev = fv;
1258       continue;
1259     }
1260     if (prev.location == fv.location) {
1261       if (fv.owner != prev.owner) {
1262         tty-&gt;print_cr(&quot;overlapping storage&quot;);
1263         tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(prev.location), *prev.location, prev.description);
1264         tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(fv.location), *fv.location, fv.description);
1265         error = true;
1266       }
1267     } else {
1268       prev = fv;
1269     }
1270   }
1271   assert(!error, &quot;invalid layout&quot;);
1272 }
1273 #endif // ASSERT
1274 
1275 void FrameValues::print(JavaThread* thread) {
1276   _values.sort(compare);
1277 
1278   // Sometimes values like the fp can be invalid values if the
1279   // register map wasn&#39;t updated during the walk.  Trim out values
1280   // that aren&#39;t actually in the stack of the thread.
1281   int min_index = 0;
1282   int max_index = _values.length() - 1;
1283   intptr_t* v0 = _values.at(min_index).location;
1284   intptr_t* v1 = _values.at(max_index).location;
1285 
1286   if (thread == Thread::current()) {
1287     while (!thread-&gt;is_in_stack((address)v0)) {
1288       v0 = _values.at(++min_index).location;
1289     }
1290     while (!thread-&gt;is_in_stack((address)v1)) {
1291       v1 = _values.at(--max_index).location;
1292     }
1293   } else {
1294     while (!thread-&gt;on_local_stack((address)v0)) {
1295       v0 = _values.at(++min_index).location;
1296     }
1297     while (!thread-&gt;on_local_stack((address)v1)) {
1298       v1 = _values.at(--max_index).location;
1299     }
1300   }
1301   intptr_t* min = MIN2(v0, v1);
1302   intptr_t* max = MAX2(v0, v1);
1303   intptr_t* cur = max;
1304   intptr_t* last = NULL;
1305   for (int i = max_index; i &gt;= min_index; i--) {
1306     FrameValue fv = _values.at(i);
1307     while (cur &gt; fv.location) {
1308       tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT, p2i(cur), *cur);
1309       cur--;
1310     }
1311     if (last == fv.location) {
1312       const char* spacer = &quot;          &quot; LP64_ONLY(&quot;        &quot;);
1313       tty-&gt;print_cr(&quot; %s  %s %s&quot;, spacer, spacer, fv.description);
1314     } else {
1315       tty-&gt;print_cr(&quot; &quot; INTPTR_FORMAT &quot;: &quot; INTPTR_FORMAT &quot; %s&quot;, p2i(fv.location), *fv.location, fv.description);
1316       last = fv.location;
1317       cur--;
1318     }
1319   }
1320 }
1321 
1322 #endif // ndef PRODUCT
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>