<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,13 @@</span>
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/instanceKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
  #include &quot;oops/symbol.hpp&quot;
  #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;runtime/safepointVerifiers.hpp&quot;</span>
  #include &quot;runtime/signature.hpp&quot;
  
  // Implementation of SignatureIterator
  
  // Signature syntax:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,323 +45,323 @@</span>
  // Parameter  = FieldType.
  // ReturnType = FieldType | &quot;V&quot;.
  // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;[&quot; FieldType.
  // ClassName  = string.
  
<span class="udiff-line-added">+ // The ClassName string can be any JVM-style UTF8 string except:</span>
<span class="udiff-line-added">+ //  - an empty string (the empty string is never a name of any kind)</span>
<span class="udiff-line-added">+ //  - a string which begins or ends with slash &#39;/&#39; (the package separator)</span>
<span class="udiff-line-added">+ //  - a string which contains adjacent slashes &#39;//&#39; (no empty package names)</span>
<span class="udiff-line-added">+ //  - a string which contains a semicolon &#39;;&#39; (the end-delimiter)</span>
<span class="udiff-line-added">+ //  - a string which contains a left bracket &#39;[&#39; (the array marker)</span>
<span class="udiff-line-added">+ //  - a string which contains a dot &#39;.&#39; (the external package separator)</span>
<span class="udiff-line-added">+ //</span>
<span class="udiff-line-added">+ // Other &quot;meta-looking&quot; characters, such as &#39;(&#39; and &#39;&lt;&#39; and &#39;+&#39;,</span>
<span class="udiff-line-added">+ // are perfectly legitimate within a class name, for the JVM.</span>
<span class="udiff-line-added">+ // Class names which contain double slashes (&#39;a//b&#39;) and non-initial</span>
<span class="udiff-line-added">+ // brackets (&#39;a[b]&#39;) are reserved for possible enrichment of the</span>
<span class="udiff-line-added">+ // type language.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SignatureIterator::set_fingerprint(fingerprint_t fingerprint) {</span>
<span class="udiff-line-added">+   if (!fp_is_valid(fingerprint)) {</span>
<span class="udiff-line-added">+     _fingerprint = fingerprint;</span>
<span class="udiff-line-added">+     _return_type = T_ILLEGAL;</span>
<span class="udiff-line-added">+   } else if (fingerprint != _fingerprint) {</span>
<span class="udiff-line-added">+     assert(_fingerprint == zero_fingerprint(), &quot;consistent fingerprint values&quot;);</span>
<span class="udiff-line-added">+     _fingerprint = fingerprint;</span>
<span class="udiff-line-added">+     _return_type = fp_return_type(fingerprint);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- SignatureIterator::SignatureIterator(Symbol* signature) {</span>
<span class="udiff-line-modified-removed">-   _signature       = signature;</span>
<span class="udiff-line-modified-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-added">+ BasicType SignatureIterator::return_type() {</span>
<span class="udiff-line-modified-added">+   if (_return_type == T_ILLEGAL) {</span>
<span class="udiff-line-modified-added">+     SignatureStream ss(_signature);</span>
<span class="udiff-line-added">+     ss.skip_to_return_type();</span>
<span class="udiff-line-added">+     _return_type = ss.type();</span>
<span class="udiff-line-added">+     assert(_return_type != T_ILLEGAL, &quot;illegal return type&quot;);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return _return_type;</span>
  }
  
<span class="udiff-line-modified-removed">- void SignatureIterator::expect(char c) {</span>
<span class="udiff-line-modified-removed">-   if (_signature-&gt;char_at(_index) != c) fatal(&quot;expecting %c&quot;, c);</span>
<span class="udiff-line-modified-removed">-   _index++;</span>
<span class="udiff-line-modified-added">+ bool SignatureIterator::fp_is_valid_type(BasicType type, bool for_return_type) {</span>
<span class="udiff-line-modified-added">+   assert(type != (BasicType)fp_parameters_done, &quot;fingerprint is incorrectly at done&quot;);</span>
<span class="udiff-line-modified-added">+   assert(((int)type &amp; ~fp_parameter_feature_mask) == 0, &quot;fingerprint feature mask yielded non-zero value&quot;);</span>
<span class="udiff-line-added">+   return (is_java_primitive(type) ||</span>
<span class="udiff-line-added">+           is_reference_type(type) ||</span>
<span class="udiff-line-added">+           (for_return_type &amp;&amp; type == T_VOID));</span>
  }
  
<span class="udiff-line-modified-removed">- int SignatureIterator::parse_type() {</span>
<span class="udiff-line-modified-removed">-   // Note: This function could be simplified by using &quot;return T_XXX_size;&quot;</span>
<span class="udiff-line-modified-removed">-   //       instead of the assignment and the break statements. However, it</span>
<span class="udiff-line-modified-removed">-   //       seems that the product build for win32_i486 with MS VC++ 6.0 doesn&#39;t</span>
<span class="udiff-line-modified-removed">-   //       work (stack underflow for some tests) - this seems to be a VC++ 6.0</span>
<span class="udiff-line-removed">-   //       compiler bug (was problem - gri 4/27/2000).</span>
<span class="udiff-line-removed">-   int size = -1;</span>
<span class="udiff-line-removed">-   switch(_signature-&gt;char_at(_index)) {</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_BYTE:    do_byte(); if (_parameter_index &lt; 0 ) _return_type = T_BYTE;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_BYTE_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_CHAR:    do_char(); if (_parameter_index &lt; 0 ) _return_type = T_CHAR;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_CHAR_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_DOUBLE:  do_double(); if (_parameter_index &lt; 0 ) _return_type = T_DOUBLE;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_DOUBLE_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_FLOAT:   do_float(); if (_parameter_index &lt; 0 ) _return_type = T_FLOAT;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_FLOAT_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_INT:     do_int(); if (_parameter_index &lt; 0 ) _return_type = T_INT;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_INT_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_LONG:    do_long(); if (_parameter_index &lt; 0 ) _return_type = T_LONG;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_LONG_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_SHORT:   do_short(); if (_parameter_index &lt; 0 ) _return_type = T_SHORT;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_SHORT_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_BOOLEAN: do_bool(); if (_parameter_index &lt; 0 ) _return_type = T_BOOLEAN;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_BOOLEAN_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_VOID:    do_void(); if (_parameter_index &lt; 0 ) _return_type = T_VOID;</span>
<span class="udiff-line-removed">-                                   _index++; size = T_VOID_size; break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_CLASS:</span>
<span class="udiff-line-removed">-       { int begin = ++_index;</span>
<span class="udiff-line-removed">-         Symbol* sig = _signature;</span>
<span class="udiff-line-removed">-         while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="udiff-line-removed">-         do_object(begin, _index);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       if (_parameter_index &lt; 0 ) _return_type = T_OBJECT;</span>
<span class="udiff-line-removed">-       size = T_OBJECT_size;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_ARRAY:</span>
<span class="udiff-line-removed">-       { int begin = ++_index;</span>
<span class="udiff-line-removed">-         Symbol* sig = _signature;</span>
<span class="udiff-line-removed">-         while (sig-&gt;char_at(_index) == JVM_SIGNATURE_ARRAY) {</span>
<span class="udiff-line-removed">-           _index++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (sig-&gt;char_at(_index) == JVM_SIGNATURE_CLASS) {</span>
<span class="udiff-line-removed">-           while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-           _index++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         do_array(begin, _index);</span>
<span class="udiff-line-removed">-        if (_parameter_index &lt; 0 ) _return_type = T_ARRAY;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       size = T_ARRAY_size;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       ShouldNotReachHere();</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   assert(size &gt;= 0, &quot;size must be set&quot;);</span>
<span class="udiff-line-removed">-   return size;</span>
<span class="udiff-line-modified-added">+ ArgumentSizeComputer::ArgumentSizeComputer(Symbol* signature)</span>
<span class="udiff-line-modified-added">+   : SignatureIterator(signature)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+   _size = 0;</span>
<span class="udiff-line-modified-added">+   do_parameters_on(this);  // non-virtual template execution</span>
  }
  
<span class="udiff-line-added">+ ArgumentCount::ArgumentCount(Symbol* signature)</span>
<span class="udiff-line-added">+   : SignatureIterator(signature)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   _size = 0;</span>
<span class="udiff-line-added">+   do_parameters_on(this);  // non-virtual template execution</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- void SignatureIterator::check_signature_end() {</span>
<span class="udiff-line-modified-removed">-   if (_index &lt; _signature-&gt;utf8_length()) {</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot;too many chars in signature&quot;);</span>
<span class="udiff-line-modified-removed">-     _signature-&gt;print_value_on(tty);</span>
<span class="udiff-line-modified-removed">-     tty-&gt;print_cr(&quot; @ %d&quot;, _index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ ReferenceArgumentCount::ReferenceArgumentCount(Symbol* signature)</span>
<span class="udiff-line-modified-added">+   : SignatureIterator(signature)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+   _refs = 0;</span>
<span class="udiff-line-modified-added">+   do_parameters_on(this);  // non-virtual template execution</span>
  }
  
<span class="udiff-line-added">+ void Fingerprinter::compute_fingerprint_and_return_type(bool static_flag) {</span>
<span class="udiff-line-added">+   // See if we fingerprinted this method already</span>
<span class="udiff-line-added">+   if (_method != NULL) {</span>
<span class="udiff-line-added">+     assert(!static_flag, &quot;must not be passed by caller&quot;);</span>
<span class="udiff-line-added">+     static_flag = _method-&gt;is_static();</span>
<span class="udiff-line-added">+     _fingerprint = _method-&gt;constMethod()-&gt;fingerprint();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (_fingerprint != zero_fingerprint()) {</span>
<span class="udiff-line-added">+       _return_type = _method-&gt;result_type();</span>
<span class="udiff-line-added">+       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">- void SignatureIterator::iterate_parameters() {</span>
<span class="udiff-line-modified-removed">-   // Parse parameters</span>
<span class="udiff-line-modified-removed">-   _index = 0;</span>
<span class="udiff-line-modified-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-removed">-   expect(JVM_SIGNATURE_FUNC);</span>
<span class="udiff-line-modified-removed">-   while (_signature-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) _parameter_index += parse_type();</span>
<span class="udiff-line-modified-removed">-   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="udiff-line-modified-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+     if (_method-&gt;size_of_parameters() &gt; fp_max_size_of_parameters) {</span>
<span class="udiff-line-modified-added">+       _fingerprint = overflow_fingerprint();</span>
<span class="udiff-line-modified-added">+       _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="udiff-line-modified-added">+       // as long as we are here compute the return type:</span>
<span class="udiff-line-modified-added">+       _return_type = ResultTypeFinder(_method-&gt;signature()).type();</span>
<span class="udiff-line-modified-added">+       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);</span>
<span class="udiff-line-modified-added">+       return;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-modified-removed">- // Optimized version of iterate_parameters when fingerprint is known</span>
<span class="udiff-line-modified-removed">- void SignatureIterator::iterate_parameters( uint64_t fingerprint ) {</span>
<span class="udiff-line-modified-removed">-   uint64_t saved_fingerprint = fingerprint;</span>
<span class="udiff-line-modified-added">+   // Note:  This will always take the slow path, since _fp==zero_fp.</span>
<span class="udiff-line-modified-added">+   initialize_accumulator();</span>
<span class="udiff-line-modified-added">+   do_parameters_on(this);</span>
<span class="udiff-line-added">+   assert(fp_is_valid_type(_return_type, true), &quot;bad result type&quot;);</span>
  
<span class="udiff-line-modified-removed">-   // Check for too many arguments</span>
<span class="udiff-line-modified-removed">-   if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="udiff-line-modified-removed">-     SignatureIterator::iterate_parameters();</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   // Fill in the return type and static bits:</span>
<span class="udiff-line-modified-added">+   _accumulator |= _return_type &lt;&lt; fp_static_feature_size;</span>
<span class="udiff-line-modified-added">+   if (static_flag) {</span>
<span class="udiff-line-modified-added">+     _accumulator |= fp_is_static_bit;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     _param_size += 1;  // this is the convention for Method::compute_size_of_parameters</span>
    }
  
<span class="udiff-line-modified-removed">-   assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-removed">-   fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="udiff-line-modified-removed">-   while ( 1 ) {</span>
<span class="udiff-line-modified-removed">-     switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="udiff-line-removed">-       case bool_parm:</span>
<span class="udiff-line-removed">-         do_bool();</span>
<span class="udiff-line-removed">-         _parameter_index += T_BOOLEAN_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case byte_parm:</span>
<span class="udiff-line-removed">-         do_byte();</span>
<span class="udiff-line-removed">-         _parameter_index += T_BYTE_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case char_parm:</span>
<span class="udiff-line-removed">-         do_char();</span>
<span class="udiff-line-removed">-         _parameter_index += T_CHAR_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case short_parm:</span>
<span class="udiff-line-removed">-         do_short();</span>
<span class="udiff-line-removed">-         _parameter_index += T_SHORT_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case int_parm:</span>
<span class="udiff-line-removed">-         do_int();</span>
<span class="udiff-line-removed">-         _parameter_index += T_INT_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case obj_parm:</span>
<span class="udiff-line-removed">-         do_object(0, 0);</span>
<span class="udiff-line-removed">-         _parameter_index += T_OBJECT_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case long_parm:</span>
<span class="udiff-line-removed">-         do_long();</span>
<span class="udiff-line-removed">-         _parameter_index += T_LONG_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case float_parm:</span>
<span class="udiff-line-removed">-         do_float();</span>
<span class="udiff-line-removed">-         _parameter_index += T_FLOAT_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case double_parm:</span>
<span class="udiff-line-removed">-         do_double();</span>
<span class="udiff-line-removed">-         _parameter_index += T_DOUBLE_size;</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case done_parm:</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-       default:</span>
<span class="udiff-line-removed">-         tty-&gt;print_cr(&quot;*** parameter is &quot; UINT64_FORMAT, fingerprint &amp; parameter_feature_mask);</span>
<span class="udiff-line-removed">-         tty-&gt;print_cr(&quot;*** fingerprint is &quot; PTR64_FORMAT, saved_fingerprint);</span>
<span class="udiff-line-removed">-         ShouldNotReachHere();</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     fingerprint &gt;&gt;= parameter_feature_size;</span>
<span class="udiff-line-modified-added">+   // Detect overflow.  (We counted _param_size correctly.)</span>
<span class="udiff-line-modified-added">+   if (_method == NULL &amp;&amp; _param_size &gt; fp_max_size_of_parameters) {</span>
<span class="udiff-line-modified-added">+     // We did a one-pass computation of argument size, return type,</span>
<span class="udiff-line-modified-added">+     // and fingerprint.</span>
<span class="udiff-line-modified-added">+     _fingerprint = overflow_fingerprint();</span>
<span class="udiff-line-modified-added">+     return;</span>
    }
<span class="udiff-line-removed">- }</span>
  
<span class="udiff-line-added">+   assert(_shift_count &lt; BitsPerLong,</span>
<span class="udiff-line-added">+          &quot;shift count overflow %d (%d vs. %d): %s&quot;,</span>
<span class="udiff-line-added">+          _shift_count, _param_size, fp_max_size_of_parameters,</span>
<span class="udiff-line-added">+          _signature-&gt;as_C_string());</span>
<span class="udiff-line-added">+   assert((_accumulator &gt;&gt; _shift_count) == fp_parameters_done, &quot;must be zero&quot;);</span>
  
<span class="udiff-line-modified-removed">- void SignatureIterator::iterate_returntype() {</span>
<span class="udiff-line-modified-removed">-   // Ignore parameters</span>
<span class="udiff-line-modified-removed">-   _index = 0;</span>
<span class="udiff-line-modified-removed">-   expect(JVM_SIGNATURE_FUNC);</span>
<span class="udiff-line-modified-removed">-   Symbol* sig = _signature;</span>
<span class="udiff-line-modified-removed">-   // Need to skip over each type in the signature&#39;s argument list until a</span>
<span class="udiff-line-removed">-   // closing &#39;)&#39; is found., then get the return type.  We cannot just scan</span>
<span class="udiff-line-removed">-   // for the first &#39;)&#39; because &#39;)&#39; is a legal character in a type name.</span>
<span class="udiff-line-removed">-   while (sig-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) {</span>
<span class="udiff-line-removed">-     switch(sig-&gt;char_at(_index)) {</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_BYTE:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_CHAR:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_DOUBLE:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_FLOAT:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_INT:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_LONG:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_SHORT:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_BOOLEAN:</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_VOID:</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           _index++;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_CLASS:</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       case JVM_SIGNATURE_ARRAY:</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           while (sig-&gt;char_at(++_index) == JVM_SIGNATURE_ARRAY) ;</span>
<span class="udiff-line-removed">-           if (sig-&gt;char_at(_index) == JVM_SIGNATURE_CLASS) {</span>
<span class="udiff-line-removed">-             while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="udiff-line-removed">-           } else {</span>
<span class="udiff-line-removed">-             _index++;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       default:</span>
<span class="udiff-line-removed">-         ShouldNotReachHere();</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   // This is the result, along with _return_type:</span>
<span class="udiff-line-modified-added">+   _fingerprint = _accumulator;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Cache the result on the method itself:</span>
<span class="udiff-line-modified-added">+   if (_method != NULL) {</span>
<span class="udiff-line-modified-added">+     _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
    }
<span class="udiff-line-removed">-   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="udiff-line-removed">-   // Parse return type</span>
<span class="udiff-line-removed">-   _parameter_index = -1;</span>
<span class="udiff-line-removed">-   parse_type();</span>
<span class="udiff-line-removed">-   check_signature_end();</span>
<span class="udiff-line-removed">-   _parameter_index = 0;</span>
  }
  
<span class="udiff-line-added">+ // Implementation of SignatureStream</span>
  
<span class="udiff-line-modified-removed">- void SignatureIterator::iterate() {</span>
<span class="udiff-line-modified-removed">-   // Parse parameters</span>
<span class="udiff-line-modified-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-removed">-   _index = 0;</span>
<span class="udiff-line-modified-removed">-   expect(JVM_SIGNATURE_FUNC);</span>
<span class="udiff-line-modified-removed">-   while (_signature-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) _parameter_index += parse_type();</span>
<span class="udiff-line-modified-removed">-   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="udiff-line-modified-removed">-   // Parse return type</span>
<span class="udiff-line-removed">-   _parameter_index = -1;</span>
<span class="udiff-line-removed">-   parse_type();</span>
<span class="udiff-line-removed">-   check_signature_end();</span>
<span class="udiff-line-removed">-   _parameter_index = 0;</span>
<span class="udiff-line-modified-added">+ static inline int decode_signature_char(int ch) {</span>
<span class="udiff-line-modified-added">+   switch (ch) {</span>
<span class="udiff-line-modified-added">+ #define EACH_SIG(ch, bt, ignore) \</span>
<span class="udiff-line-modified-added">+     case ch: return bt;</span>
<span class="udiff-line-modified-added">+     SIGNATURE_TYPES_DO(EACH_SIG, ignore)</span>
<span class="udiff-line-modified-added">+ #undef EACH_SIG</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   return 0;</span>
  }
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- // Implementation of SignatureStream</span>
<span class="udiff-line-modified-removed">- SignatureStream::SignatureStream(Symbol* signature, bool is_method) :</span>
<span class="udiff-line-modified-removed">-                    _signature(signature), _at_return_type(false), _previous_name(NULL), _names(NULL) {</span>
<span class="udiff-line-modified-removed">-   _begin = _end = (is_method ? 1 : 0);  // skip first &#39;(&#39; in method signatures</span>
<span class="udiff-line-modified-added">+ SignatureStream::SignatureStream(const Symbol* signature,</span>
<span class="udiff-line-modified-added">+                                  bool is_method) {</span>
<span class="udiff-line-modified-added">+   assert(!is_method || signature-&gt;starts_with(JVM_SIGNATURE_FUNC),</span>
<span class="udiff-line-modified-added">+          &quot;method signature required&quot;);</span>
<span class="udiff-line-modified-added">+   _signature = signature;</span>
<span class="udiff-line-added">+   _limit = signature-&gt;utf8_length();</span>
<span class="udiff-line-added">+   int oz = (is_method ? 1 : 0);</span>
<span class="udiff-line-added">+   _state = oz;</span>
<span class="udiff-line-added">+   assert(_state == (int)(is_method ? _s_method : _s_field), &quot;signature state incorrectly set&quot;);</span>
<span class="udiff-line-added">+   _begin = _end = oz; // skip first &#39;(&#39; in method signatures</span>
<span class="udiff-line-added">+   _array_prefix = 0;  // just for definiteness</span>
<span class="udiff-line-added">+   _previous_name = NULL;</span>
<span class="udiff-line-added">+   _names = NULL;</span>
    next();
  }
  
  SignatureStream::~SignatureStream() {
    // decrement refcount for names created during signature parsing
    if (_names != NULL) {
      for (int i = 0; i &lt; _names-&gt;length(); i++) {
        _names-&gt;at(i)-&gt;decrement_refcount();
      }
<span class="udiff-line-added">+   } else if (_previous_name != NULL &amp;&amp; !_previous_name-&gt;is_permanent()) {</span>
<span class="udiff-line-added">+     _previous_name-&gt;decrement_refcount();</span>
    }
  }
  
<span class="udiff-line-modified-removed">- bool SignatureStream::is_done() const {</span>
<span class="udiff-line-modified-removed">-   return _end &gt; _signature-&gt;utf8_length();</span>
<span class="udiff-line-modified-added">+ inline int SignatureStream::scan_non_primitive(BasicType type) {</span>
<span class="udiff-line-modified-added">+   const u1* base = _signature-&gt;bytes();</span>
<span class="udiff-line-added">+   int end = _end;</span>
<span class="udiff-line-added">+   int limit = _limit;</span>
<span class="udiff-line-added">+   const u1* tem;</span>
<span class="udiff-line-added">+   switch (type) {</span>
<span class="udiff-line-added">+   case T_OBJECT:</span>
<span class="udiff-line-added">+     tem = (const u1*) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);</span>
<span class="udiff-line-added">+     end = (tem == NULL ? limit : tem+1 - base);</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   case T_ARRAY:</span>
<span class="udiff-line-added">+     while ((end &lt; limit) &amp;&amp; ((char)base[end] == JVM_SIGNATURE_ARRAY)) { end++; }</span>
<span class="udiff-line-added">+     _array_prefix = end - _end;  // number of &#39;[&#39; chars just skipped</span>
<span class="udiff-line-added">+     if (Signature::has_envelope(base[end++])) {</span>
<span class="udiff-line-added">+       tem = (const u1*) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);</span>
<span class="udiff-line-added">+       end = (tem == NULL ? limit : tem+1 - base);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   default : ShouldNotReachHere();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return end;</span>
  }
  
<span class="udiff-line-added">+ void SignatureStream::next() {</span>
<span class="udiff-line-added">+   const Symbol* sig = _signature;</span>
<span class="udiff-line-added">+   int len = _limit;</span>
<span class="udiff-line-added">+   if (_end &gt;= len) { set_done(); return; }</span>
<span class="udiff-line-added">+   _begin = _end;</span>
<span class="udiff-line-added">+   int ch = sig-&gt;char_at(_begin);</span>
<span class="udiff-line-added">+   int btcode = decode_signature_char(ch);</span>
<span class="udiff-line-added">+   if (btcode == 0) {</span>
<span class="udiff-line-added">+     guarantee(ch == JVM_SIGNATURE_ENDFUNC, &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="udiff-line-added">+     assert(_state == _s_method, &quot;must be in method&quot;);</span>
<span class="udiff-line-added">+     _state = _s_method_return;</span>
<span class="udiff-line-added">+     _begin = ++_end;</span>
<span class="udiff-line-added">+     if (_end &gt;= len) { set_done(); return; }</span>
<span class="udiff-line-added">+     ch = sig-&gt;char_at(_begin);</span>
<span class="udiff-line-added">+     btcode = decode_signature_char(ch);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   BasicType bt = (BasicType) btcode;</span>
<span class="udiff-line-added">+   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="udiff-line-added">+   _type = bt;</span>
<span class="udiff-line-added">+   if (!is_reference_type(bt)) {</span>
<span class="udiff-line-added">+     // Skip over a single character for a primitive type (or void).</span>
<span class="udiff-line-added">+     _end++;</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   _end = scan_non_primitive(bt);</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- void SignatureStream::next_non_primitive(int t) {</span>
<span class="udiff-line-modified-removed">-   switch (t) {</span>
<span class="udiff-line-modified-removed">-     case JVM_SIGNATURE_CLASS: {</span>
<span class="udiff-line-modified-removed">-       _type = T_OBJECT;</span>
<span class="udiff-line-modified-removed">-       Symbol* sig = _signature;</span>
<span class="udiff-line-modified-removed">-       while (sig-&gt;char_at(_end++) != JVM_SIGNATURE_ENDCLASS);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     case JVM_SIGNATURE_ARRAY: {</span>
<span class="udiff-line-removed">-       _type = T_ARRAY;</span>
<span class="udiff-line-removed">-       Symbol* sig = _signature;</span>
<span class="udiff-line-removed">-       char c = sig-&gt;char_at(_end);</span>
<span class="udiff-line-removed">-       while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="udiff-line-removed">-       while (sig-&gt;char_at(_end) == JVM_SIGNATURE_ARRAY) {</span>
<span class="udiff-line-removed">-         _end++;</span>
<span class="udiff-line-removed">-         c = sig-&gt;char_at(_end);</span>
<span class="udiff-line-removed">-         while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       switch(sig-&gt;char_at(_end)) {</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_BYTE:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_CHAR:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_DOUBLE:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_FLOAT:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_INT:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_LONG:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_SHORT:</span>
<span class="udiff-line-removed">-         case JVM_SIGNATURE_BOOLEAN:_end++; break;</span>
<span class="udiff-line-removed">-         default: {</span>
<span class="udiff-line-removed">-           while (sig-&gt;char_at(_end++) != JVM_SIGNATURE_ENDCLASS);</span>
<span class="udiff-line-removed">-           break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     case JVM_SIGNATURE_ENDFUNC: _end++; next(); _at_return_type = true; break;</span>
<span class="udiff-line-removed">-     default : ShouldNotReachHere();</span>
<span class="udiff-line-modified-added">+ int SignatureStream::skip_array_prefix(int max_skip_length) {</span>
<span class="udiff-line-modified-added">+   if (_type != T_ARRAY) {</span>
<span class="udiff-line-modified-added">+     return 0;</span>
<span class="udiff-line-modified-added">+   }</span>
<span class="udiff-line-modified-added">+   if (_array_prefix &gt; max_skip_length) {</span>
<span class="udiff-line-modified-added">+     // strip some but not all levels of T_ARRAY</span>
<span class="udiff-line-modified-added">+     _array_prefix -= max_skip_length;</span>
<span class="udiff-line-modified-added">+     _begin += max_skip_length;</span>
<span class="udiff-line-modified-added">+     return max_skip_length;</span>
    }
<span class="udiff-line-added">+   // we are stripping all levels of T_ARRAY,</span>
<span class="udiff-line-added">+   // so we must decode the next character</span>
<span class="udiff-line-added">+   int whole_array_prefix = _array_prefix;</span>
<span class="udiff-line-added">+   int new_begin = _begin + whole_array_prefix;</span>
<span class="udiff-line-added">+   _begin = new_begin;</span>
<span class="udiff-line-added">+   int ch = _signature-&gt;char_at(new_begin);</span>
<span class="udiff-line-added">+   int btcode = decode_signature_char(ch);</span>
<span class="udiff-line-added">+   BasicType bt = (BasicType) btcode;</span>
<span class="udiff-line-added">+   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="udiff-line-added">+   _type = bt;</span>
<span class="udiff-line-added">+   assert(bt != T_VOID &amp;&amp; bt != T_ARRAY, &quot;bad signature type&quot;);</span>
<span class="udiff-line-added">+   // Don&#39;t bother to call scan_non_primitive, since it won&#39;t</span>
<span class="udiff-line-added">+   // change the value of _end.</span>
<span class="udiff-line-added">+   return whole_array_prefix;</span>
  }
  
<span class="udiff-line-added">+ bool Signature::is_valid_array_signature(const Symbol* sig) {</span>
<span class="udiff-line-added">+   assert(sig-&gt;utf8_length() &gt; 1, &quot;this should already have been checked&quot;);</span>
<span class="udiff-line-added">+   assert(sig-&gt;char_at(0) == JVM_SIGNATURE_ARRAY, &quot;this should already have been checked&quot;);</span>
<span class="udiff-line-added">+   // The first character is already checked</span>
<span class="udiff-line-added">+   int i = 1;</span>
<span class="udiff-line-added">+   int len = sig-&gt;utf8_length();</span>
<span class="udiff-line-added">+   // First skip all &#39;[&#39;s</span>
<span class="udiff-line-added">+   while(i &lt; len - 1 &amp;&amp; sig-&gt;char_at(i) == JVM_SIGNATURE_ARRAY) i++;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Check type</span>
<span class="udiff-line-added">+   switch(sig-&gt;char_at(i)) {</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_BYTE:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_CHAR:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_DOUBLE:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_FLOAT:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_INT:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_LONG:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_SHORT:</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_BOOLEAN:</span>
<span class="udiff-line-added">+     // If it is an array, the type is the last character</span>
<span class="udiff-line-added">+     return (i + 1 == len);</span>
<span class="udiff-line-added">+   case JVM_SIGNATURE_CLASS:</span>
<span class="udiff-line-added">+     // If it is an object, the last character must be a &#39;;&#39;</span>
<span class="udiff-line-added">+     return sig-&gt;char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">- bool SignatureStream::is_object() const {</span>
<span class="udiff-line-modified-removed">-   return _type == T_OBJECT</span>
<span class="udiff-line-modified-removed">-       || _type == T_ARRAY;</span>
<span class="udiff-line-modified-added">+ BasicType Signature::basic_type(int ch) {</span>
<span class="udiff-line-modified-added">+   int btcode = decode_signature_char(ch);</span>
<span class="udiff-line-modified-added">+   if (btcode == 0)  return T_ILLEGAL;</span>
<span class="udiff-line-added">+   return (BasicType) btcode;</span>
  }
  
<span class="udiff-line-modified-removed">- bool SignatureStream::is_array() const {</span>
<span class="udiff-line-modified-removed">-   return _type == T_ARRAY;</span>
<span class="udiff-line-modified-added">+ static const int jl_len = 10, object_len = 6, jl_object_len = jl_len + object_len;</span>
<span class="udiff-line-modified-added">+ static const char jl_str[] = &quot;java/lang/&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef ASSERT</span>
<span class="udiff-line-added">+ static bool signature_symbols_sane() {</span>
<span class="udiff-line-added">+   static bool done;</span>
<span class="udiff-line-added">+   if (done)  return true;</span>
<span class="udiff-line-added">+   done = true;</span>
<span class="udiff-line-added">+   // test some tense code that looks for common symbol names:</span>
<span class="udiff-line-added">+   assert(vmSymbols::java_lang_Object()-&gt;utf8_length() == jl_object_len &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_Object()-&gt;starts_with(jl_str, jl_len) &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_Object()-&gt;ends_with(&quot;Object&quot;, object_len) &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_Object()-&gt;is_permanent() &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_String()-&gt;utf8_length() == jl_object_len &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_String()-&gt;starts_with(jl_str, jl_len) &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_String()-&gt;ends_with(&quot;String&quot;, object_len) &amp;&amp;</span>
<span class="udiff-line-added">+          vmSymbols::java_lang_String()-&gt;is_permanent(),</span>
<span class="udiff-line-added">+          &quot;sanity&quot;);</span>
<span class="udiff-line-added">+   return true;</span>
  }
<span class="udiff-line-added">+ #endif //ASSERT</span>
  
<span class="udiff-line-modified-removed">- Symbol* SignatureStream::as_symbol() {</span>
<span class="udiff-line-modified-added">+ // returns a symbol; the caller is responsible for decrementing it</span>
<span class="udiff-line-added">+ Symbol* SignatureStream::find_symbol() {</span>
    // Create a symbol from for string _begin _end
<span class="udiff-line-modified-removed">-   int begin = _begin;</span>
<span class="udiff-line-modified-removed">-   int end   = _end;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (   _signature-&gt;char_at(_begin) == JVM_SIGNATURE_CLASS</span>
<span class="udiff-line-removed">-       &amp;&amp; _signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="udiff-line-removed">-     begin++;</span>
<span class="udiff-line-removed">-     end--;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   int begin = raw_symbol_begin();</span>
<span class="udiff-line-modified-added">+   int end   = raw_symbol_end();</span>
  
    const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
    int len = end - begin;
  
    // Quick check for common symbols in signatures
<span class="udiff-line-modified-removed">-   assert((vmSymbols::java_lang_String()-&gt;utf8_length() == 16 &amp;&amp; vmSymbols::java_lang_Object()-&gt;utf8_length() == 16), &quot;sanity&quot;);</span>
<span class="udiff-line-modified-removed">-   if (len == 16 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-       strncmp(symbol_chars, &quot;java/lang/&quot;, 10) == 0) {</span>
<span class="udiff-line-modified-removed">-     if (strncmp(&quot;String&quot;, symbol_chars + 10, 6) == 0) {</span>
<span class="udiff-line-modified-added">+   assert(signature_symbols_sane(), &quot;incorrect signature sanity check&quot;);</span>
<span class="udiff-line-modified-added">+   if (len == jl_object_len &amp;&amp;</span>
<span class="udiff-line-modified-added">+       memcmp(symbol_chars, jl_str, jl_len) == 0) {</span>
<span class="udiff-line-modified-added">+     if (memcmp(&quot;String&quot;, symbol_chars + jl_len, object_len) == 0) {</span>
        return vmSymbols::java_lang_String();
<span class="udiff-line-modified-removed">-     } else if (strncmp(&quot;Object&quot;, symbol_chars + 10, 6) == 0) {</span>
<span class="udiff-line-modified-added">+     } else if (memcmp(&quot;Object&quot;, symbol_chars + jl_len, object_len) == 0) {</span>
        return vmSymbols::java_lang_Object();
      }
    }
  
    Symbol* name = _previous_name;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,11 +370,21 @@</span>
    }
  
    // Save names for cleaning up reference count at the end of
    // SignatureStream scope.
    name = SymbolTable::new_symbol(symbol_chars, len);
<span class="udiff-line-modified-removed">-   if (!name-&gt;is_permanent()) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Only allocate the GrowableArray for the _names buffer if more than</span>
<span class="udiff-line-added">+   // one name is being processed in the signature.</span>
<span class="udiff-line-added">+   if (_previous_name != NULL &amp;&amp;</span>
<span class="udiff-line-added">+       !_previous_name-&gt;is_permanent() &amp;&amp;</span>
<span class="udiff-line-added">+       !name-&gt;is_permanent() &amp;&amp;</span>
<span class="udiff-line-added">+       _names == NULL) {</span>
<span class="udiff-line-added">+     _names =  new GrowableArray&lt;Symbol*&gt;(10);</span>
<span class="udiff-line-added">+     _names-&gt;push(_previous_name);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   if (!name-&gt;is_permanent() &amp;&amp; _previous_name != NULL) {</span>
      if (_names == NULL) {
        _names = new GrowableArray&lt;Symbol*&gt;(10);
      }
      _names-&gt;push(name);  // save new symbol for decrementing later
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,61 +392,71 @@</span>
    return name;
  }
  
  Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
                                   FailureMode failure_mode, TRAPS) {
<span class="udiff-line-modified-removed">-   if (!is_object())  return NULL;</span>
<span class="udiff-line-modified-added">+   if (!is_reference())  return NULL;</span>
    Symbol* name = as_symbol();
<span class="udiff-line-added">+   Klass* k = NULL;</span>
    if (failure_mode == ReturnNull) {
<span class="udiff-line-modified-removed">-     return SystemDictionary::resolve_or_null(name, class_loader, protection_domain, THREAD);</span>
<span class="udiff-line-modified-added">+     // Note:  SD::resolve_or_null returns NULL for most failure modes,</span>
<span class="udiff-line-added">+     // but not all.  Circularity errors, invalid PDs, etc., throw.</span>
<span class="udiff-line-added">+     k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);</span>
<span class="udiff-line-added">+   } else if (failure_mode == CachedOrNull) {</span>
<span class="udiff-line-added">+     NoSafepointVerifier nsv;  // no loading, now, we mean it!</span>
<span class="udiff-line-added">+     assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);</span>
<span class="udiff-line-added">+     k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);</span>
<span class="udiff-line-added">+     // SD::find does not trigger loading, so there should be no throws</span>
<span class="udiff-line-added">+     // Still, bad things can happen, so we CHECK_NULL and ask callers</span>
<span class="udiff-line-added">+     // to do likewise.</span>
<span class="udiff-line-added">+     return k;</span>
    } else {
<span class="udiff-line-added">+     // The only remaining failure mode is NCDFError.</span>
<span class="udiff-line-added">+     // The test here allows for an additional mode CNFException</span>
<span class="udiff-line-added">+     // if callers need to request the reflective error instead.</span>
      bool throw_error = (failure_mode == NCDFError);
<span class="udiff-line-modified-removed">-     return SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, THREAD);</span>
<span class="udiff-line-modified-added">+     k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);</span>
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return k;</span>
  }
  
  oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
                                      FailureMode failure_mode, TRAPS) {
<span class="udiff-line-modified-removed">-   if (!is_object())</span>
<span class="udiff-line-modified-added">+   if (!is_reference())</span>
      return Universe::java_mirror(type());
    Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
    if (klass == NULL)  return NULL;
    return klass-&gt;java_mirror();
  }
  
<span class="udiff-line-modified-removed">- Symbol* SignatureStream::as_symbol_or_null() {</span>
<span class="udiff-line-modified-removed">-   // Create a symbol from for string _begin _end</span>
<span class="udiff-line-modified-removed">-   ResourceMark rm;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   int begin = _begin;</span>
<span class="udiff-line-removed">-   int end   = _end;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (   _signature-&gt;char_at(_begin) == JVM_SIGNATURE_CLASS</span>
<span class="udiff-line-removed">-       &amp;&amp; _signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="udiff-line-removed">-     begin++;</span>
<span class="udiff-line-removed">-     end--;</span>
<span class="udiff-line-modified-added">+ void SignatureStream::skip_to_return_type() {</span>
<span class="udiff-line-modified-added">+   while (!at_return_type()) {</span>
<span class="udiff-line-modified-added">+     next();</span>
    }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   char* buffer = NEW_RESOURCE_ARRAY(char, end - begin);</span>
<span class="udiff-line-removed">-   for (int index = begin; index &lt; end; index++) {</span>
<span class="udiff-line-removed">-     buffer[index - begin] = _signature-&gt;char_at(index);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   Symbol* result = SymbolTable::probe(buffer, end - begin);</span>
<span class="udiff-line-removed">-   return result;</span>
  }
  
<span class="udiff-line-modified-removed">- int SignatureStream::reference_parameter_count() {</span>
<span class="udiff-line-modified-removed">-   int args_count = 0;</span>
<span class="udiff-line-modified-removed">-   for ( ; !at_return_type(); next()) {</span>
<span class="udiff-line-modified-removed">-     if (is_object()) {</span>
<span class="udiff-line-modified-removed">-       args_count++;</span>
<span class="udiff-line-modified-added">+ #ifdef ASSERT</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ extern bool signature_constants_sane(); // called from basic_types_init()</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool signature_constants_sane() {</span>
<span class="udiff-line-added">+   // for the lookup table, test every 8-bit code point, and then some:</span>
<span class="udiff-line-added">+   for (int i = -256; i &lt;= 256; i++) {</span>
<span class="udiff-line-added">+     int btcode = 0;</span>
<span class="udiff-line-added">+     switch (i) {</span>
<span class="udiff-line-added">+ #define EACH_SIG(ch, bt, ignore) \</span>
<span class="udiff-line-added">+     case ch: { btcode = bt; break; }</span>
<span class="udiff-line-added">+     SIGNATURE_TYPES_DO(EACH_SIG, ignore)</span>
<span class="udiff-line-added">+ #undef EACH_SIG</span>
      }
<span class="udiff-line-added">+     int btc = decode_signature_char(i);</span>
<span class="udiff-line-added">+     assert(btc == btcode, &quot;misconfigured table: %d =&gt; %d not %d&quot;, i, btc, btcode);</span>
    }
<span class="udiff-line-modified-removed">-   return args_count;</span>
<span class="udiff-line-modified-added">+   return true;</span>
  }
  
<span class="udiff-line-removed">- #ifdef ASSERT</span>
  bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {
    const char* method_sig = (const char*)sig-&gt;bytes();
    ssize_t len = sig-&gt;utf8_length();
    ssize_t index = 0;
    if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == JVM_SIGNATURE_FUNC) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,12 +497,12 @@</span>
      return -1;
    }
    switch (type[index]) {
      case JVM_SIGNATURE_BYTE:
      case JVM_SIGNATURE_CHAR:
<span class="udiff-line-removed">-     case JVM_SIGNATURE_DOUBLE:</span>
      case JVM_SIGNATURE_FLOAT:
<span class="udiff-line-added">+     case JVM_SIGNATURE_DOUBLE:</span>
      case JVM_SIGNATURE_INT:
      case JVM_SIGNATURE_LONG:
      case JVM_SIGNATURE_SHORT:
      case JVM_SIGNATURE_BOOLEAN:
      case JVM_SIGNATURE_VOID:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -498,6 +521,7 @@</span>
        // fall through
      default: ; // fall through
    }
    return -1;
  }
<span class="udiff-line-added">+ </span>
  #endif // ASSERT
</pre>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>