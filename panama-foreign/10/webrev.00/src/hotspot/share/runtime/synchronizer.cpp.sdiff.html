<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 100     }                                                                      \
 101   }
 102 
 103 #else //  ndef DTRACE_ENABLED
 104 
 105 #define DTRACE_MONITOR_WAIT_PROBE(obj, thread, millis, mon)    {;}
 106 #define DTRACE_MONITOR_PROBE(probe, obj, thread, mon)          {;}
 107 
 108 #endif // ndef DTRACE_ENABLED
 109 
 110 // This exists only as a workaround of dtrace bug 6254741
 111 int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {
 112   DTRACE_MONITOR_PROBE(waited, monitor, obj(), thr);
 113   return 0;
 114 }
 115 
 116 #define NINFLATIONLOCKS 256
 117 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 118 
 119 // global list of blocks of monitors
<span class="line-modified"> 120 PaddedObjectMonitor* volatile ObjectSynchronizer::g_block_list = NULL;</span>
<span class="line-modified"> 121 // Global ObjectMonitor free list. Newly allocated and deflated</span>
<span class="line-modified"> 122 // ObjectMonitors are prepended here.</span>
<span class="line-modified"> 123 ObjectMonitor* volatile ObjectSynchronizer::g_free_list = NULL;</span>
<span class="line-modified"> 124 // Global ObjectMonitor in-use list. When a JavaThread is exiting,</span>
<span class="line-modified"> 125 // ObjectMonitors on its per-thread in-use list are prepended here.</span>
<span class="line-modified"> 126 ObjectMonitor* volatile ObjectSynchronizer::g_om_in_use_list = NULL;</span>
<span class="line-modified"> 127 int ObjectSynchronizer::g_om_in_use_count = 0;  // # on g_om_in_use_list</span>
<span class="line-modified"> 128 </span>
<span class="line-modified"> 129 static volatile intptr_t gListLock = 0;   // protects global monitor lists</span>
<span class="line-modified"> 130 static volatile int g_om_free_count = 0;  // # on g_free_list</span>
<span class="line-modified"> 131 static volatile int g_om_population = 0;  // # Extant -- in circulation</span>















 132 
 133 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 134 
 135 













































































































































































































































 136 // =====================&gt; Quick functions
 137 
 138 // The quick_* forms are special fast-path variants used to improve
 139 // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
 140 // simply return false, in which case the caller will perform the necessary
 141 // state transitions and call the slow-path form.
 142 // The fast-path is designed to handle frequently arising cases in an efficient
 143 // manner and is just a degenerate &quot;optimistic&quot; variant of the slow-path.
 144 // returns true  -- to indicate the call was satisfied.
 145 // returns false -- to indicate the call needs the services of the slow-path.
 146 // A no-loitering ordinance is in effect for code in the quick_* family
 147 // operators: safepoints or indefinite blocking (blocking that might span a
 148 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 149 // entry.
 150 //
 151 // Consider: An interesting optimization is to have the JIT recognize the
 152 // following common idiom:
 153 //   synchronized (someobj) { .... ; notify(); }
 154 // That is, we find a notify() or notifyAll() call that immediately precedes
 155 // the monitorexit operation.  In that case the JIT could fuse the operations
</pre>
<hr />
<pre>
 223     // Case: light contention possibly amenable to TLE
 224     // Case: TLE inimical operations such as nested/recursive synchronization
 225 
 226     if (owner == self) {
 227       m-&gt;_recursions++;
 228       return true;
 229     }
 230 
 231     // This Java Monitor is inflated so obj&#39;s header will never be
 232     // displaced to this thread&#39;s BasicLock. Make the displaced header
 233     // non-NULL so this BasicLock is not seen as recursive nor as
 234     // being locked. We do this unconditionally so that this thread&#39;s
 235     // BasicLock cannot be mis-interpreted by any stack walkers. For
 236     // performance reasons, stack walkers generally first check for
 237     // Biased Locking in the object&#39;s header, the second check is for
 238     // stack-locking in the object&#39;s header, the third check is for
 239     // recursive stack-locking in the displaced header in the BasicLock,
 240     // and last are the inflated Java Monitor (ObjectMonitor) checks.
 241     lock-&gt;set_displaced_header(markWord::unused_mark());
 242 
<span class="line-modified"> 243     if (owner == NULL &amp;&amp; Atomic::replace_if_null(&amp;(m-&gt;_owner), self)) {</span>
 244       assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
 245       return true;
 246     }
 247   }
 248 
 249   // Note that we could inflate in quick_enter.
 250   // This is likely a useful optimization
 251   // Critically, in quick_enter() we must not:
 252   // -- perform bias revocation, or
 253   // -- block indefinitely, or
 254   // -- reach a safepoint
 255 
 256   return false;        // revert to slow-path
 257 }
 258 
 259 // -----------------------------------------------------------------------------
 260 // Monitor Enter/Exit
 261 // The interpreter and compiler assembly code tries to lock using the fast path
 262 // of this algorithm. Make sure to update that code if the following function is
 263 // changed. The implementation is extremely sensitive to race condition. Be careful.
</pre>
<hr />
<pre>
 500 //
 501 // Performance concern:
 502 // OrderAccess::storestore() calls release() which at one time stored 0
 503 // into the global volatile OrderAccess::dummy variable. This store was
 504 // unnecessary for correctness. Many threads storing into a common location
 505 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
 506 // As such, I avoided using OrderAccess::storestore(). In some cases
 507 // OrderAccess::fence() -- which incurs local latency on the executing
 508 // processor -- is a better choice as it scales on SMP systems.
 509 //
 510 // See http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot for
 511 // a discussion of coherency costs. Note that all our current reference
 512 // platforms provide strong ST-ST order, so the issue is moot on IA32,
 513 // x64, and SPARC.
 514 //
 515 // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
 516 // and explicit fences (barriers) to control for architectural reordering
 517 // performed by the CPU(s) or platform.
 518 
 519 struct SharedGlobals {
<span class="line-modified"> 520   char         _pad_prefix[DEFAULT_CACHE_LINE_SIZE];</span>
 521   // These are highly shared mostly-read variables.
 522   // To avoid false-sharing they need to be the sole occupants of a cache line.
 523   volatile int stw_random;
 524   volatile int stw_cycle;
<span class="line-modified"> 525   DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
 526   // Hot RW variable -- Sequester to avoid false-sharing
 527   volatile int hc_sequence;
<span class="line-modified"> 528   DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(volatile int));</span>
 529 };
 530 
 531 static SharedGlobals GVars;
 532 static int _forceMonitorScavenge = 0; // Scavenge required and pending
 533 
 534 static markWord read_stable_mark(oop obj) {
 535   markWord mark = obj-&gt;mark();
 536   if (!mark.is_being_inflated()) {
 537     return mark;       // normal fast-path return
 538   }
 539 
 540   int its = 0;
 541   for (;;) {
 542     markWord mark = obj-&gt;mark();
 543     if (!mark.is_being_inflated()) {
 544       return mark;    // normal fast-path return
 545     }
 546 
 547     // The object is being inflated by some other thread.
 548     // The caller of read_stable_mark() must wait for inflation to complete.
</pre>
<hr />
<pre>
 871     assert(monitor != NULL, &quot;monitor should be non-null&quot;);
 872     owner = (address) monitor-&gt;owner();
 873   }
 874 
 875   if (owner != NULL) {
 876     // owning_thread_from_monitor_owner() may also return NULL here
 877     return Threads::owning_thread_from_monitor_owner(t_list, owner);
 878   }
 879 
 880   // Unlocked case, header in place
 881   // Cannot have assertion since this object may have been
 882   // locked by another thread when reaching here.
 883   // assert(mark.is_neutral(), &quot;sanity check&quot;);
 884 
 885   return NULL;
 886 }
 887 
 888 // Visitors ...
 889 
 890 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified"> 891   PaddedObjectMonitor* block = Atomic::load_acquire(&amp;g_block_list);</span>
 892   while (block != NULL) {
 893     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
 894     for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
 895       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
 896       oop object = (oop)mid-&gt;object();
 897       if (object != NULL) {
 898         // Only process with closure if the object is set.
 899         closure-&gt;do_monitor(mid);
 900       }
 901     }
<span class="line-modified"> 902     block = (PaddedObjectMonitor*)block-&gt;_next_om;</span>


 903   }
 904 }
 905 
 906 static bool monitors_used_above_threshold() {
<span class="line-modified"> 907   if (g_om_population == 0) {</span>

 908     return false;
 909   }
<span class="line-modified"> 910   int monitors_used = g_om_population - g_om_free_count;</span>
<span class="line-modified"> 911   int monitor_usage = (monitors_used * 100LL) / g_om_population;</span>
<span class="line-modified"> 912   return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>










 913 }
 914 
 915 bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified"> 916   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified"> 917     if (monitors_used_above_threshold()) {</span>
<span class="line-modified"> 918       return true;</span>
<span class="line-removed"> 919     }</span>
 920   }
 921   return needs_monitor_scavenge();
 922 }
 923 
 924 bool ObjectSynchronizer::needs_monitor_scavenge() {
 925   if (Atomic::load(&amp;_forceMonitorScavenge) == 1) {
 926     log_info(monitorinflation)(&quot;Monitor scavenge needed, triggering safepoint cleanup.&quot;);
 927     return true;
 928   }
 929   return false;
 930 }
 931 
 932 void ObjectSynchronizer::oops_do(OopClosure* f) {
 933   // We only scan the global used list here (for moribund threads), and
 934   // the thread-local monitors in Thread::oops_do().
 935   global_used_oops_do(f);
 936 }
 937 
 938 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
 939   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified"> 940   list_oops_do(g_om_in_use_list, f);</span>
 941 }
 942 
 943 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
 944   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
 945   list_oops_do(thread-&gt;om_in_use_list, f);
 946 }
 947 
 948 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
 949   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified"> 950   ObjectMonitor* mid;</span>
<span class="line-modified"> 951   for (mid = list; mid != NULL; mid = mid-&gt;_next_om) {</span>

 952     if (mid-&gt;object() != NULL) {
 953       f-&gt;do_oop((oop*)mid-&gt;object_addr());
 954     }
 955   }
 956 }
 957 
 958 
 959 // -----------------------------------------------------------------------------
 960 // ObjectMonitor Lifecycle
 961 // -----------------------
<span class="line-modified"> 962 // Inflation unlinks monitors from the global g_free_list and</span>
<span class="line-modified"> 963 // associates them with objects.  Deflation -- which occurs at</span>
<span class="line-modified"> 964 // STW-time -- disassociates idle monitors from objects.  Such</span>
<span class="line-modified"> 965 // scavenged monitors are returned to the g_free_list.</span>
<span class="line-removed"> 966 //</span>
<span class="line-removed"> 967 // The global list is protected by gListLock.  All the critical sections</span>
<span class="line-removed"> 968 // are short and operate in constant-time.</span>
 969 //
 970 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
 971 //
 972 // Lifecycle:
<span class="line-modified"> 973 // --   unassigned and on the global free list</span>
<span class="line-modified"> 974 // --   unassigned and on a thread&#39;s private om_free_list</span>
 975 // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified"> 976 //      to the objectmonitor.</span>
 977 
 978 
 979 // Constraining monitor pool growth via MonitorBound ...
 980 //
 981 // If MonitorBound is not set (&lt;= 0), MonitorBound checks are disabled.
 982 //
 983 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
 984 // the rate of scavenging is driven primarily by GC.  As such,  we can find
 985 // an inordinate number of monitors in circulation.
 986 // To avoid that scenario we can artificially induce a STW safepoint
 987 // if the pool appears to be growing past some reasonable bound.
 988 // Generally we favor time in space-time tradeoffs, but as there&#39;s no
 989 // natural back-pressure on the # of extant monitors we need to impose some
 990 // type of limit.  Beware that if MonitorBound is set to too low a value
 991 // we could just loop. In addition, if MonitorBound is set to a low value
 992 // we&#39;ll incur more safepoints, which are harmful to performance.
 993 // See also: GuaranteedSafepointInterval
 994 //
 995 // If MonitorBound is set, the boundry applies to
<span class="line-modified"> 996 //     (g_om_population - g_om_free_count)</span>
 997 // i.e., if there are not enough ObjectMonitors on the global free list,
 998 // then a safepoint deflation is induced. Picking a good MonitorBound value
 999 // is non-trivial.
1000 
1001 static void InduceScavenge(Thread* self, const char * Whence) {
1002   // Induce STW safepoint to trim monitors
1003   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
1004   // More precisely, trigger a cleanup safepoint as the number
1005   // of active monitors passes the specified threshold.
1006   // TODO: assert thread state is reasonable
1007 
<span class="line-modified">1008   if (Atomic::xchg (&amp;_forceMonitorScavenge, 1) == 0) {</span>
1009     VMThread::check_for_forced_cleanup();
1010   }
1011 }
1012 
1013 ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {
1014   // A large MAXPRIVATE value reduces both list lock contention
1015   // and list coherency traffic, but also tends to increase the
1016   // number of ObjectMonitors in circulation as well as the STW
1017   // scavenge costs.  As usual, we lean toward time in space-time
1018   // tradeoffs.
1019   const int MAXPRIVATE = 1024;


1020   stringStream ss;
1021   for (;;) {
1022     ObjectMonitor* m;
1023 
1024     // 1: try to allocate from the thread&#39;s local om_free_list.
1025     // Threads will attempt to allocate first from their local list, then
<span class="line-modified">1026     // from the global list, and only after those attempts fail will the thread</span>
<span class="line-modified">1027     // attempt to instantiate new monitors.   Thread-local free lists take</span>
<span class="line-modified">1028     // heat off the gListLock and improve allocation latency, as well as reducing</span>
<span class="line-modified">1029     // coherency traffic on the shared global list.</span>
<span class="line-modified">1030     m = self-&gt;om_free_list;</span>
1031     if (m != NULL) {
<span class="line-removed">1032       self-&gt;om_free_list = m-&gt;_next_om;</span>
<span class="line-removed">1033       self-&gt;om_free_count--;</span>
1034       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1035       m-&gt;_next_om = self-&gt;om_in_use_list;</span>
<span class="line-removed">1036       self-&gt;om_in_use_list = m;</span>
<span class="line-removed">1037       self-&gt;om_in_use_count++;</span>
1038       return m;
1039     }
1040 
<span class="line-modified">1041     // 2: try to allocate from the global g_free_list</span>
<span class="line-removed">1042     // CONSIDER: use muxTry() instead of muxAcquire().</span>
<span class="line-removed">1043     // If the muxTry() fails then drop immediately into case 3.</span>
1044     // If we&#39;re using thread-local free lists then try
1045     // to reprovision the caller&#39;s free list.
<span class="line-modified">1046     if (g_free_list != NULL) {</span>
1047       // Reprovision the thread&#39;s om_free_list.
1048       // Use bulk transfers to reduce the allocation rate and heat
1049       // on various locks.
<span class="line-modified">1050       Thread::muxAcquire(&amp;gListLock, &quot;om_alloc(1)&quot;);</span>
<span class="line-modified">1051       for (int i = self-&gt;om_free_provision; --i &gt;= 0 &amp;&amp; g_free_list != NULL;) {</span>
<span class="line-modified">1052         g_om_free_count--;</span>
<span class="line-modified">1053         ObjectMonitor* take = g_free_list;</span>
<span class="line-modified">1054         g_free_list = take-&gt;_next_om;</span>
1055         guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
1056         take-&gt;Recycle();
1057         om_release(self, take, false);
1058       }
<span class="line-modified">1059       Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1060       self-&gt;om_free_provision += 1 + (self-&gt;om_free_provision/2);</span>
1061       if (self-&gt;om_free_provision &gt; MAXPRIVATE) self-&gt;om_free_provision = MAXPRIVATE;
1062 
<span class="line-modified">1063       const int mx = MonitorBound;</span>
<span class="line-modified">1064       if (mx &gt; 0 &amp;&amp; (g_om_population-g_om_free_count) &gt; mx) {</span>
1065         // Not enough ObjectMonitors on the global free list.
1066         // We can&#39;t safely induce a STW safepoint from om_alloc() as our thread
1067         // state may not be appropriate for such activities and callers may hold
1068         // naked oops, so instead we defer the action.
1069         InduceScavenge(self, &quot;om_alloc&quot;);
1070       }
1071       continue;
1072     }
1073 
1074     // 3: allocate a block of new ObjectMonitors
1075     // Both the local and global free lists are empty -- resort to malloc().
1076     // In the current implementation ObjectMonitors are TSM - immortal.
1077     // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
1078     // each ObjectMonitor to start at the beginning of a cache line,
1079     // so we use align_up().
1080     // A better solution would be to use C++ placement-new.
1081     // BEWARE: As it stands currently, we don&#39;t run the ctors!
1082     assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
1083     size_t neededsize = sizeof(PaddedObjectMonitor) * _BLOCKSIZE;
1084     PaddedObjectMonitor* temp;
<span class="line-modified">1085     size_t aligned_size = neededsize + (DEFAULT_CACHE_LINE_SIZE - 1);</span>
1086     void* real_malloc_addr = NEW_C_HEAP_ARRAY(char, aligned_size, mtInternal);
<span class="line-modified">1087     temp = (PaddedObjectMonitor*)align_up(real_malloc_addr, DEFAULT_CACHE_LINE_SIZE);</span>
1088     (void)memset((void *) temp, 0, neededsize);
1089 
1090     // Format the block.
1091     // initialize the linked list, each monitor points to its next
1092     // forming the single linked free list, the very first monitor
1093     // will points to next block, which forms the block list.
1094     // The trick of using the 1st element in the block as g_block_list
1095     // linkage should be reconsidered.  A better implementation would
1096     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
1097 
1098     for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">1099       temp[i]._next_om = (ObjectMonitor *)&amp;temp[i+1];</span>
1100     }
1101 
1102     // terminate the last monitor as the end of list
<span class="line-modified">1103     temp[_BLOCKSIZE - 1]._next_om = NULL;</span>
1104 
1105     // Element [0] is reserved for global list linkage
1106     temp[0].set_object(CHAINMARKER);
1107 
1108     // Consider carving out this thread&#39;s current request from the
1109     // block in hand.  This avoids some lock traffic and redundant
1110     // list activity.
1111 
<span class="line-modified">1112     // Acquire the gListLock to manipulate g_block_list and g_free_list.</span>
<span class="line-removed">1113     // An Oyama-Taura-Yonezawa scheme might be more efficient.</span>
<span class="line-removed">1114     Thread::muxAcquire(&amp;gListLock, &quot;om_alloc(2)&quot;);</span>
<span class="line-removed">1115     g_om_population += _BLOCKSIZE-1;</span>
<span class="line-removed">1116     g_om_free_count += _BLOCKSIZE-1;</span>
<span class="line-removed">1117 </span>
<span class="line-removed">1118     // Add the new block to the list of extant blocks (g_block_list).</span>
<span class="line-removed">1119     // The very first ObjectMonitor in a block is reserved and dedicated.</span>
<span class="line-removed">1120     // It serves as blocklist &quot;next&quot; linkage.</span>
<span class="line-removed">1121     temp[0]._next_om = g_block_list;</span>
<span class="line-removed">1122     // There are lock-free uses of g_block_list so make sure that</span>
<span class="line-removed">1123     // the previous stores happen before we update g_block_list.</span>
<span class="line-removed">1124     Atomic::release_store(&amp;g_block_list, temp);</span>
<span class="line-removed">1125 </span>
<span class="line-removed">1126     // Add the new string of ObjectMonitors to the global free list</span>
<span class="line-removed">1127     temp[_BLOCKSIZE - 1]._next_om = g_free_list;</span>
<span class="line-removed">1128     g_free_list = temp + 1;</span>
<span class="line-removed">1129     Thread::muxRelease(&amp;gListLock);</span>
1130   }
1131 }
1132 
1133 // Place &quot;m&quot; on the caller&#39;s private per-thread om_free_list.
1134 // In practice there&#39;s no need to clamp or limit the number of
1135 // monitors on a thread&#39;s om_free_list as the only non-allocation time
1136 // we&#39;ll call om_release() is to return a monitor to the free list after
1137 // a CAS attempt failed. This doesn&#39;t allow unbounded #s of monitors to
1138 // accumulate on a thread&#39;s free list.
1139 //
1140 // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
1141 // free list must have their object field set to null. This prevents the
1142 // scavenger -- deflate_monitor_list() -- from reclaiming them while we
1143 // are trying to release them.
1144 
1145 void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,
1146                                     bool from_per_thread_alloc) {
1147   guarantee(m-&gt;header().value() == 0, &quot;invariant&quot;);
1148   guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);


1149   stringStream ss;
1150   guarantee((m-&gt;is_busy() | m-&gt;_recursions) == 0, &quot;freeing in-use monitor: &quot;
1151             &quot;%s, recursions=&quot; INTX_FORMAT, m-&gt;is_busy_to_string(&amp;ss),
1152             m-&gt;_recursions);
1153   // _next_om is used for both per-thread in-use and free lists so
1154   // we have to remove &#39;m&#39; from the in-use list first (as needed).
1155   if (from_per_thread_alloc) {
1156     // Need to remove &#39;m&#39; from om_in_use_list.
<span class="line-modified">1157     ObjectMonitor* cur_mid_in_use = NULL;</span>
<span class="line-modified">1158     bool extracted = false;</span>
<span class="line-modified">1159     for (ObjectMonitor* mid = self-&gt;om_in_use_list; mid != NULL; cur_mid_in_use = mid, mid = mid-&gt;_next_om) {</span>
<span class="line-modified">1160       if (m == mid) {</span>
<span class="line-modified">1161         // extract from per-thread in-use list</span>
<span class="line-modified">1162         if (mid == self-&gt;om_in_use_list) {</span>
<span class="line-modified">1163           self-&gt;om_in_use_list = mid-&gt;_next_om;</span>
<span class="line-modified">1164         } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1165           cur_mid_in_use-&gt;_next_om = mid-&gt;_next_om; // maintain the current thread in-use list</span>










































1166         }
<span class="line-removed">1167         extracted = true;</span>
<span class="line-removed">1168         self-&gt;om_in_use_count--;</span>
<span class="line-removed">1169         break;</span>
1170       }
1171     }
<span class="line-modified">1172     assert(extracted, &quot;Should have extracted from in-use list&quot;);</span>













1173   }
1174 
<span class="line-modified">1175   m-&gt;_next_om = self-&gt;om_free_list;</span>
<span class="line-removed">1176   self-&gt;om_free_list = m;</span>
<span class="line-removed">1177   self-&gt;om_free_count++;</span>
1178 }
1179 
1180 // Return ObjectMonitors on a moribund thread&#39;s free and in-use
1181 // lists to the appropriate global lists. The ObjectMonitors on the
1182 // per-thread in-use list may still be in use by other threads.
1183 //
1184 // We currently call om_flush() from Threads::remove() before the
1185 // thread has been excised from the thread list and is no longer a
1186 // mutator. This means that om_flush() cannot run concurrently with
1187 // a safepoint and interleave with deflate_idle_monitors(). In
1188 // particular, this ensures that the thread&#39;s in-use monitors are
1189 // scanned by a GC safepoint, either via Thread::oops_do() (before
1190 // om_flush() is called) or via ObjectSynchronizer::oops_do() (after
1191 // om_flush() is called).
1192 
1193 void ObjectSynchronizer::om_flush(Thread* self) {
<span class="line-modified">1194   ObjectMonitor* free_list = self-&gt;om_free_list;</span>
<span class="line-removed">1195   ObjectMonitor* free_tail = NULL;</span>
<span class="line-removed">1196   int free_count = 0;</span>
<span class="line-removed">1197   if (free_list != NULL) {</span>
<span class="line-removed">1198     ObjectMonitor* s;</span>
<span class="line-removed">1199     // The thread is going away. Set &#39;free_tail&#39; to the last per-thread free</span>
<span class="line-removed">1200     // monitor which will be linked to g_free_list below under the gListLock.</span>
<span class="line-removed">1201     stringStream ss;</span>
<span class="line-removed">1202     for (s = free_list; s != NULL; s = s-&gt;_next_om) {</span>
<span class="line-removed">1203       free_count++;</span>
<span class="line-removed">1204       free_tail = s;</span>
<span class="line-removed">1205       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1206       guarantee(!s-&gt;is_busy(), &quot;must be !is_busy: %s&quot;, s-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-removed">1207     }</span>
<span class="line-removed">1208     guarantee(free_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-removed">1209     assert(self-&gt;om_free_count == free_count, &quot;free-count off&quot;);</span>
<span class="line-removed">1210     self-&gt;om_free_list = NULL;</span>
<span class="line-removed">1211     self-&gt;om_free_count = 0;</span>
<span class="line-removed">1212   }</span>
<span class="line-removed">1213 </span>
<span class="line-removed">1214   ObjectMonitor* in_use_list = self-&gt;om_in_use_list;</span>
<span class="line-removed">1215   ObjectMonitor* in_use_tail = NULL;</span>
1216   int in_use_count = 0;
<span class="line-modified">1217   if (in_use_list != NULL) {</span>










1218     // The thread is going away, however the ObjectMonitors on the
1219     // om_in_use_list may still be in-use by other threads. Link
1220     // them to in_use_tail, which will be linked into the global
<span class="line-modified">1221     // in-use list g_om_in_use_list below, under the gListLock.</span>
<span class="line-modified">1222     ObjectMonitor *cur_om;</span>
<span class="line-modified">1223     for (cur_om = in_use_list; cur_om != NULL; cur_om = cur_om-&gt;_next_om) {</span>











1224       in_use_tail = cur_om;
1225       in_use_count++;
1226     }
1227     guarantee(in_use_tail != NULL, &quot;invariant&quot;);
<span class="line-modified">1228     assert(self-&gt;om_in_use_count == in_use_count, &quot;in-use count off&quot;);</span>
<span class="line-modified">1229     self-&gt;om_in_use_list = NULL;</span>
<span class="line-modified">1230     self-&gt;om_in_use_count = 0;</span>












































1231   }
1232 
<span class="line-removed">1233   Thread::muxAcquire(&amp;gListLock, &quot;om_flush&quot;);</span>
1234   if (free_tail != NULL) {
<span class="line-modified">1235     free_tail-&gt;_next_om = g_free_list;</span>
<span class="line-removed">1236     g_free_list = free_list;</span>
<span class="line-removed">1237     g_om_free_count += free_count;</span>
1238   }
1239 
1240   if (in_use_tail != NULL) {
<span class="line-modified">1241     in_use_tail-&gt;_next_om = g_om_in_use_list;</span>
<span class="line-removed">1242     g_om_in_use_list = in_use_list;</span>
<span class="line-removed">1243     g_om_in_use_count += in_use_count;</span>
1244   }
1245 
<span class="line-removed">1246   Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1247 </span>
1248   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1249   LogStreamHandle(Info, monitorinflation) lsh_info;
1250   LogStream* ls = NULL;
1251   if (log_is_enabled(Debug, monitorinflation)) {
1252     ls = &amp;lsh_debug;
1253   } else if ((free_count != 0 || in_use_count != 0) &amp;&amp;
1254              log_is_enabled(Info, monitorinflation)) {
1255     ls = &amp;lsh_info;
1256   }
1257   if (ls != NULL) {
1258     ls-&gt;print_cr(&quot;om_flush: jt=&quot; INTPTR_FORMAT &quot;, free_count=%d&quot;
1259                  &quot;, in_use_count=%d&quot; &quot;, om_free_provision=%d&quot;,
1260                  p2i(self), free_count, in_use_count, self-&gt;om_free_provision);
1261   }
1262 }
1263 
1264 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
1265                                        const oop obj,
1266                                        ObjectSynchronizer::InflateCause cause) {
1267   assert(event != NULL, &quot;invariant&quot;);
1268   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1269   event-&gt;set_monitorClass(obj-&gt;klass());
1270   event-&gt;set_address((uintptr_t)(void*)obj);
1271   event-&gt;set_cause((u1)cause);
1272   event-&gt;commit();
1273 }
1274 
1275 // Fast path code shared by multiple functions
1276 void ObjectSynchronizer::inflate_helper(oop obj) {
1277   markWord mark = obj-&gt;mark();
1278   if (mark.has_monitor()) {
1279     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);
1280     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);
1281     return;
1282   }
1283   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1284 }
1285 
1286 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,
<span class="line-modified">1287                                            oop object,</span>
<span class="line-removed">1288                                            const InflateCause cause) {</span>
1289   // Inflate mutates the heap ...
1290   // Relaxing assertion for bug 6320749.
1291   assert(Universe::verify_in_progress() ||
1292          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1293 
1294   EventJavaMonitorInflate event;
1295 
1296   for (;;) {
1297     const markWord mark = object-&gt;mark();
1298     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1299 
1300     // The mark can be in one of the following states:
1301     // *  Inflated     - just return
1302     // *  Stack-locked - coerce it to inflated
1303     // *  INFLATING    - busy wait for conversion to complete
1304     // *  Neutral      - aggressively inflate the object.
1305     // *  BIASED       - Illegal.  We should never see this
1306 
1307     // CASE: inflated
1308     if (mark.has_monitor()) {
</pre>
<hr />
<pre>
1387       // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
1388 
1389 
1390       // fetch the displaced mark from the owner&#39;s stack.
1391       // The owner can&#39;t die or unwind past the lock while our INFLATING
1392       // object is in the mark.  Furthermore the owner can&#39;t complete
1393       // an unlock on the object, either.
1394       markWord dmw = mark.displaced_mark_helper();
1395       // Catch if the object&#39;s header is not neutral (not locked and
1396       // not marked is what we care about here).
1397       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1398 
1399       // Setup monitor fields to proper values -- prepare the monitor
1400       m-&gt;set_header(dmw);
1401 
1402       // Optimization: if the mark.locker stack address is associated
1403       // with this thread we could simply set m-&gt;_owner = self.
1404       // Note that a thread can inflate an object
1405       // that it has stack-locked -- as might happen in wait() -- directly
1406       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">1407       m-&gt;set_owner(mark.locker());</span>
1408       m-&gt;set_object(object);
1409       // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
1410 
1411       // Must preserve store ordering. The monitor state must
1412       // be stable at the time of publishing the monitor address.
1413       guarantee(object-&gt;mark() == markWord::INFLATING(), &quot;invariant&quot;);
1414       object-&gt;release_set_mark(markWord::encode(m));
1415 
1416       // Hopefully the performance counters are allocated on distinct cache lines
1417       // to avoid false sharing on MP systems ...
1418       OM_PERFDATA_OP(Inflations, inc());
1419       if (log_is_enabled(Trace, monitorinflation)) {
1420         ResourceMark rm(self);
1421         lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1422                      INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
1423                      object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());
1424       }
1425       if (event.should_commit()) {
1426         post_monitor_inflate_event(&amp;event, object, cause);
1427       }
</pre>
<hr />
<pre>
1499 // This is an unfortunate aspect of this design.
1500 
1501 // Deflate a single monitor if not in-use
1502 // Return true if deflated, false if in-use
1503 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
1504                                          ObjectMonitor** free_head_p,
1505                                          ObjectMonitor** free_tail_p) {
1506   bool deflated;
1507   // Normal case ... The monitor is associated with obj.
1508   const markWord mark = obj-&gt;mark();
1509   guarantee(mark == markWord::encode(mid), &quot;should match: mark=&quot;
1510             INTPTR_FORMAT &quot;, encoded mid=&quot; INTPTR_FORMAT, mark.value(),
1511             markWord::encode(mid).value());
1512   // Make sure that mark.monitor() and markWord::encode() agree:
1513   guarantee(mark.monitor() == mid, &quot;should match: monitor()=&quot; INTPTR_FORMAT
1514             &quot;, mid=&quot; INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));
1515   const markWord dmw = mid-&gt;header();
1516   guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1517 
1518   if (mid-&gt;is_busy()) {

1519     deflated = false;
1520   } else {
1521     // Deflate the monitor if it is no longer being used
1522     // It&#39;s idle - scavenge and return to the global free list
1523     // plain old deflation ...
1524     if (log_is_enabled(Trace, monitorinflation)) {
1525       ResourceMark rm;
1526       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
1527                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1528                                   INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(obj),
1529                                   mark.value(), obj-&gt;klass()-&gt;external_name());
1530     }
1531 
1532     // Restore the header back to obj
1533     obj-&gt;release_set_mark(dmw);
1534     mid-&gt;clear();
1535 
1536     assert(mid-&gt;object() == NULL, &quot;invariant: object=&quot; INTPTR_FORMAT,
1537            p2i(mid-&gt;object()));
1538 
1539     // Move the deflated ObjectMonitor to the working free list
1540     // defined by free_head_p and free_tail_p.
1541     if (*free_head_p == NULL) *free_head_p = mid;
1542     if (*free_tail_p != NULL) {
1543       // We append to the list so the caller can use mid-&gt;_next_om
1544       // to fix the linkages in its context.
1545       ObjectMonitor* prevtail = *free_tail_p;
1546       // Should have been cleaned up by the caller:
<span class="line-modified">1547       assert(prevtail-&gt;_next_om == NULL, &quot;cleaned up deflated?&quot;);</span>
<span class="line-modified">1548       prevtail-&gt;_next_om = mid;</span>






1549     }
1550     *free_tail_p = mid;
1551     // At this point, mid-&gt;_next_om still refers to its current
1552     // value and another ObjectMonitor&#39;s _next_om field still
1553     // refers to this ObjectMonitor. Those linkages have to be
1554     // cleaned up by the caller who has the complete context.
1555     deflated = true;
1556   }
1557   return deflated;
1558 }
1559 
<span class="line-modified">1560 // Walk a given monitor list, and deflate idle monitors</span>
<span class="line-modified">1561 // The given list could be a per-thread list or a global list</span>
<span class="line-removed">1562 // Caller acquires gListLock as needed.</span>
1563 //
1564 // In the case of parallel processing of thread local monitor lists,
1565 // work is done by Threads::parallel_threads_do() which ensures that
1566 // each Java thread is processed by exactly one worker thread, and
1567 // thus avoid conflicts that would arise when worker threads would
1568 // process the same monitor lists concurrently.
1569 //
1570 // See also ParallelSPCleanupTask and
1571 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
1572 // Threads::parallel_java_threads_do() in thread.cpp.
1573 int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,

1574                                              ObjectMonitor** free_head_p,
1575                                              ObjectMonitor** free_tail_p) {
<span class="line-removed">1576   ObjectMonitor* mid;</span>
<span class="line-removed">1577   ObjectMonitor* next;</span>
1578   ObjectMonitor* cur_mid_in_use = NULL;


1579   int deflated_count = 0;
1580 
<span class="line-modified">1581   for (mid = *list_p; mid != NULL;) {</span>




1582     oop obj = (oop) mid-&gt;object();
1583     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, free_head_p, free_tail_p)) {
1584       // Deflation succeeded and already updated free_head_p and
1585       // free_tail_p as needed. Finish the move to the local free list
1586       // by unlinking mid from the global or per-thread in-use list.
<span class="line-modified">1587       if (mid == *list_p) {</span>
<span class="line-modified">1588         *list_p = mid-&gt;_next_om;</span>
<span class="line-modified">1589       } else if (cur_mid_in_use != NULL) {</span>
<span class="line-modified">1590         cur_mid_in_use-&gt;_next_om = mid-&gt;_next_om; // maintain the current thread in-use list</span>


1591       }
<span class="line-modified">1592       next = mid-&gt;_next_om;</span>
<span class="line-removed">1593       mid-&gt;_next_om = NULL;  // This mid is current tail in the free_head_p list</span>
<span class="line-removed">1594       mid = next;</span>
1595       deflated_count++;



1596     } else {
1597       cur_mid_in_use = mid;
<span class="line-removed">1598       mid = mid-&gt;_next_om;</span>
1599     }
1600   }
1601   return deflated_count;
1602 }
1603 
1604 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
1605   counters-&gt;n_in_use = 0;              // currently associated with objects
1606   counters-&gt;n_in_circulation = 0;      // extant
1607   counters-&gt;n_scavenged = 0;           // reclaimed (global and per-thread)
1608   counters-&gt;per_thread_scavenged = 0;  // per-thread scavenge total
1609   counters-&gt;per_thread_times = 0.0;    // per-thread scavenge times
1610 }
1611 
1612 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
1613   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1614   bool deflated = false;
1615 
1616   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
1617   ObjectMonitor* free_tail_p = NULL;
1618   elapsedTimer timer;
1619 
1620   if (log_is_enabled(Info, monitorinflation)) {
1621     timer.start();
1622   }
1623 
<span class="line-removed">1624   // Prevent om_flush from changing mids in Thread dtor&#39;s during deflation</span>
<span class="line-removed">1625   // And in case the vm thread is acquiring a lock during a safepoint</span>
<span class="line-removed">1626   // See e.g. 6320749</span>
<span class="line-removed">1627   Thread::muxAcquire(&amp;gListLock, &quot;deflate_idle_monitors&quot;);</span>
<span class="line-removed">1628 </span>
1629   // Note: the thread-local monitors lists get deflated in
1630   // a separate pass. See deflate_thread_local_monitors().
1631 
<span class="line-modified">1632   // For moribund threads, scan g_om_in_use_list</span>
1633   int deflated_count = 0;
<span class="line-modified">1634   if (g_om_in_use_list) {</span>
<span class="line-modified">1635     counters-&gt;n_in_circulation += g_om_in_use_count;</span>
<span class="line-modified">1636     deflated_count = deflate_monitor_list((ObjectMonitor **)&amp;g_om_in_use_list, &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-modified">1637     g_om_in_use_count -= deflated_count;</span>
<span class="line-modified">1638     counters-&gt;n_scavenged += deflated_count;</span>
<span class="line-modified">1639     counters-&gt;n_in_use += g_om_in_use_count;</span>




1640   }
1641 
1642   if (free_head_p != NULL) {
1643     // Move the deflated ObjectMonitors back to the global free list.
<span class="line-modified">1644     guarantee(free_tail_p != NULL &amp;&amp; counters-&gt;n_scavenged &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">1645     assert(free_tail_p-&gt;_next_om == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1646     // constant-time list splice - prepend scavenged segment to g_free_list</span>
<span class="line-modified">1647     free_tail_p-&gt;_next_om = g_free_list;</span>
<span class="line-modified">1648     g_free_list = free_head_p;</span>


1649   }
<span class="line-removed">1650   Thread::muxRelease(&amp;gListLock);</span>
1651   timer.stop();
1652 
1653   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1654   LogStreamHandle(Info, monitorinflation) lsh_info;
1655   LogStream* ls = NULL;
1656   if (log_is_enabled(Debug, monitorinflation)) {
1657     ls = &amp;lsh_debug;
1658   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
1659     ls = &amp;lsh_info;
1660   }
1661   if (ls != NULL) {
1662     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);
1663   }
1664 }
1665 
1666 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
1667   // Report the cumulative time for deflating each thread&#39;s idle
1668   // monitors. Note: if the work is split among more than one
1669   // worker thread, then the reported time will likely be more
1670   // than a beginning to end measurement of the phase.
1671   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;per_thread_times, counters-&gt;per_thread_scavenged);
1672 
<span class="line-removed">1673   g_om_free_count += counters-&gt;n_scavenged;</span>
<span class="line-removed">1674 </span>
1675   if (log_is_enabled(Debug, monitorinflation)) {
1676     // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">1677     // at the Info level.</span>
1678     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
1679   } else if (log_is_enabled(Info, monitorinflation)) {
<span class="line-modified">1680     Thread::muxAcquire(&amp;gListLock, &quot;finish_deflate_idle_monitors&quot;);</span>
<span class="line-modified">1681     log_info(monitorinflation)(&quot;g_om_population=%d, g_om_in_use_count=%d, &quot;</span>
<span class="line-modified">1682                                &quot;g_om_free_count=%d&quot;, g_om_population,</span>
<span class="line-modified">1683                                g_om_in_use_count, g_om_free_count);</span>
<span class="line-modified">1684     Thread::muxRelease(&amp;gListLock);</span>
1685   }
1686 
1687   Atomic::store(&amp;_forceMonitorScavenge, 0);    // Reset
1688 
1689   OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));
1690   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));
1691 
1692   GVars.stw_random = os::random();
1693   GVars.stw_cycle++;
1694 }
1695 
1696 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
1697   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1698 
1699   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
1700   ObjectMonitor* free_tail_p = NULL;
1701   elapsedTimer timer;
1702 
1703   if (log_is_enabled(Info, safepoint, cleanup) ||
1704       log_is_enabled(Info, monitorinflation)) {
1705     timer.start();
1706   }
1707 
<span class="line-modified">1708   int deflated_count = deflate_monitor_list(thread-&gt;om_in_use_list_addr(), &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-modified">1709 </span>
<span class="line-removed">1710   Thread::muxAcquire(&amp;gListLock, &quot;deflate_thread_local_monitors&quot;);</span>
1711 
<span class="line-modified">1712   // Adjust counters</span>
<span class="line-modified">1713   counters-&gt;n_in_circulation += thread-&gt;om_in_use_count;</span>
<span class="line-removed">1714   thread-&gt;om_in_use_count -= deflated_count;</span>
<span class="line-removed">1715   counters-&gt;n_scavenged += deflated_count;</span>
<span class="line-removed">1716   counters-&gt;n_in_use += thread-&gt;om_in_use_count;</span>
<span class="line-removed">1717   counters-&gt;per_thread_scavenged += deflated_count;</span>
1718 
1719   if (free_head_p != NULL) {
1720     // Move the deflated ObjectMonitors back to the global free list.
1721     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);
<span class="line-modified">1722     assert(free_tail_p-&gt;_next_om == NULL, &quot;invariant&quot;);</span>
<span class="line-modified">1723 </span>
<span class="line-modified">1724     // constant-time list splice - prepend scavenged segment to g_free_list</span>
<span class="line-modified">1725     free_tail_p-&gt;_next_om = g_free_list;</span>
<span class="line-modified">1726     g_free_list = free_head_p;</span>


1727   }
1728 
1729   timer.stop();
<span class="line-removed">1730   // Safepoint logging cares about cumulative per_thread_times and</span>
<span class="line-removed">1731   // we&#39;ll capture most of the cost, but not the muxRelease() which</span>
<span class="line-removed">1732   // should be cheap.</span>
1733   counters-&gt;per_thread_times += timer.seconds();
1734 
<span class="line-removed">1735   Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1736 </span>
1737   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1738   LogStreamHandle(Info, monitorinflation) lsh_info;
1739   LogStream* ls = NULL;
1740   if (log_is_enabled(Debug, monitorinflation)) {
1741     ls = &amp;lsh_debug;
1742   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
1743     ls = &amp;lsh_info;
1744   }
1745   if (ls != NULL) {
1746     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);
1747   }
1748 }
1749 
1750 // Monitor cleanup on JavaThread::exit
1751 
1752 // Iterate through monitor cache and attempt to release thread&#39;s monitors
1753 // Gives up on a particular monitor if an exception occurs, but continues
1754 // the overall iteration, swallowing the exception.
1755 class ReleaseJavaMonitorsClosure: public MonitorClosure {
1756  private:
</pre>
<hr />
<pre>
1767 
1768 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
1769 // ignored.  This is meant to be called during JNI thread detach which assumes
1770 // all remaining monitors are heavyweight.  All exceptions are swallowed.
1771 // Scanning the extant monitor list can be time consuming.
1772 // A simple optimization is to add a per-thread flag that indicates a thread
1773 // called jni_monitorenter() during its lifetime.
1774 //
1775 // Instead of No_Savepoint_Verifier it might be cheaper to
1776 // use an idiom of the form:
1777 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
1778 //   &lt;code that must not run at safepoint&gt;
1779 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
1780 // Since the tests are extremely cheap we could leave them enabled
1781 // for normal product builds.
1782 
1783 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
1784   assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
1785   NoSafepointVerifier nsv;
1786   ReleaseJavaMonitorsClosure rjmc(THREAD);
<span class="line-removed">1787   Thread::muxAcquire(&amp;gListLock, &quot;release_monitors_owned_by_thread&quot;);</span>
1788   ObjectSynchronizer::monitors_iterate(&amp;rjmc);
<span class="line-removed">1789   Thread::muxRelease(&amp;gListLock);</span>
1790   THREAD-&gt;clear_pending_exception();
1791 }
1792 
1793 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
1794   switch (cause) {
1795     case inflate_cause_vm_internal:    return &quot;VM Internal&quot;;
1796     case inflate_cause_monitor_enter:  return &quot;Monitor Enter&quot;;
1797     case inflate_cause_wait:           return &quot;Monitor Wait&quot;;
1798     case inflate_cause_notify:         return &quot;Monitor Notify&quot;;
1799     case inflate_cause_hash_code:      return &quot;Monitor Hash Code&quot;;
1800     case inflate_cause_jni_enter:      return &quot;JNI Monitor Enter&quot;;
1801     case inflate_cause_jni_exit:       return &quot;JNI Monitor Exit&quot;;
1802     default:
1803       ShouldNotReachHere();
1804   }
1805   return &quot;Unknown&quot;;
1806 }
1807 
1808 //------------------------------------------------------------------------------
1809 // Debugging code
1810 
1811 u_char* ObjectSynchronizer::get_gvars_addr() {
1812   return (u_char*)&amp;GVars;
1813 }
1814 
1815 u_char* ObjectSynchronizer::get_gvars_hc_sequence_addr() {
1816   return (u_char*)&amp;GVars.hc_sequence;
1817 }
1818 
1819 size_t ObjectSynchronizer::get_gvars_size() {
1820   return sizeof(SharedGlobals);
1821 }
1822 
1823 u_char* ObjectSynchronizer::get_gvars_stw_random_addr() {
1824   return (u_char*)&amp;GVars.stw_random;
1825 }
1826 












1827 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
1828   assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1829 
1830   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1831   LogStreamHandle(Info, monitorinflation) lsh_info;
1832   LogStreamHandle(Trace, monitorinflation) lsh_trace;
1833   LogStream* ls = NULL;
1834   if (log_is_enabled(Trace, monitorinflation)) {
1835     ls = &amp;lsh_trace;
1836   } else if (log_is_enabled(Debug, monitorinflation)) {
1837     ls = &amp;lsh_debug;
1838   } else if (log_is_enabled(Info, monitorinflation)) {
1839     ls = &amp;lsh_info;
1840   }
1841   assert(ls != NULL, &quot;sanity check&quot;);
1842 
<span class="line-removed">1843   if (!on_exit) {</span>
<span class="line-removed">1844     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">1845     Thread::muxAcquire(&amp;gListLock, &quot;audit_and_print_stats&quot;);</span>
<span class="line-removed">1846   }</span>
<span class="line-removed">1847 </span>
1848   // Log counts for the global and per-thread monitor lists:
1849   int chk_om_population = log_monitor_list_counts(ls);
1850   int error_cnt = 0;
1851 
1852   ls-&gt;print_cr(&quot;Checking global lists:&quot;);
1853 
<span class="line-modified">1854   // Check g_om_population:</span>
<span class="line-modified">1855   if (g_om_population == chk_om_population) {</span>
<span class="line-modified">1856     ls-&gt;print_cr(&quot;g_om_population=%d equals chk_om_population=%d&quot;,</span>
<span class="line-modified">1857                  g_om_population, chk_om_population);</span>
1858   } else {
<span class="line-modified">1859     ls-&gt;print_cr(&quot;ERROR: g_om_population=%d is not equal to &quot;</span>
<span class="line-modified">1860                  &quot;chk_om_population=%d&quot;, g_om_population,</span>
<span class="line-modified">1861                  chk_om_population);</span>
<span class="line-modified">1862     error_cnt++;</span>




1863   }
1864 
<span class="line-modified">1865   // Check g_om_in_use_list and g_om_in_use_count:</span>
1866   chk_global_in_use_list_and_count(ls, &amp;error_cnt);
1867 
<span class="line-modified">1868   // Check g_free_list and g_om_free_count:</span>
1869   chk_global_free_list_and_count(ls, &amp;error_cnt);
1870 
<span class="line-removed">1871   if (!on_exit) {</span>
<span class="line-removed">1872     Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">1873   }</span>
<span class="line-removed">1874 </span>
1875   ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
1876 
1877   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
1878     // Check om_in_use_list and om_in_use_count:
1879     chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
1880 
1881     // Check om_free_list and om_free_count:
1882     chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
1883   }
1884 
1885   if (error_cnt == 0) {
1886     ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
1887   } else {
1888     log_error(monitorinflation)(&quot;found monitor list errors: error_cnt=%d&quot;, error_cnt);
1889   }
1890 
1891   if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
1892       (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
1893     // When exiting this log output is at the Info level. When called
1894     // at a safepoint, this log output is at the Trace level since
1895     // there can be a lot of it.
<span class="line-modified">1896     log_in_use_monitor_details(ls, on_exit);</span>
1897   }
1898 
1899   ls-&gt;flush();
1900 
1901   guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
1902 }
1903 
1904 // Check a free monitor entry; log any errors.
1905 void ObjectSynchronizer::chk_free_entry(JavaThread* jt, ObjectMonitor* n,
1906                                         outputStream * out, int *error_cnt_p) {
1907   stringStream ss;
1908   if (n-&gt;is_busy()) {
1909     if (jt != NULL) {
1910       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1911                     &quot;: free per-thread monitor must not be busy: %s&quot;, p2i(jt),
1912                     p2i(n), n-&gt;is_busy_to_string(&amp;ss));
1913     } else {
1914       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1915                     &quot;must not be busy: %s&quot;, p2i(n), n-&gt;is_busy_to_string(&amp;ss));
1916     }
</pre>
<hr />
<pre>
1927                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
1928                     p2i(n), n-&gt;header().value());
1929     }
1930     *error_cnt_p = *error_cnt_p + 1;
1931   }
1932   if (n-&gt;object() != NULL) {
1933     if (jt != NULL) {
1934       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1935                     &quot;: free per-thread monitor must have NULL _object &quot;
1936                     &quot;field: _object=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
1937                     p2i(n-&gt;object()));
1938     } else {
1939       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
1940                     &quot;must have NULL _object field: _object=&quot; INTPTR_FORMAT,
1941                     p2i(n), p2i(n-&gt;object()));
1942     }
1943     *error_cnt_p = *error_cnt_p + 1;
1944   }
1945 }
1946 


















1947 // Check the global free list and count; log the results of the checks.
1948 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
1949                                                         int *error_cnt_p) {
1950   int chk_om_free_count = 0;
<span class="line-modified">1951   for (ObjectMonitor* n = g_free_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">1952     chk_free_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1953     chk_om_free_count++;</span>









1954   }
<span class="line-modified">1955   if (g_om_free_count == chk_om_free_count) {</span>
<span class="line-modified">1956     out-&gt;print_cr(&quot;g_om_free_count=%d equals chk_om_free_count=%d&quot;,</span>
<span class="line-modified">1957                   g_om_free_count, chk_om_free_count);</span>

1958   } else {
<span class="line-modified">1959     out-&gt;print_cr(&quot;ERROR: g_om_free_count=%d is not equal to &quot;</span>
<span class="line-modified">1960                   &quot;chk_om_free_count=%d&quot;, g_om_free_count,</span>
<span class="line-modified">1961                   chk_om_free_count);</span>
<span class="line-modified">1962     *error_cnt_p = *error_cnt_p + 1;</span>



1963   }
1964 }
1965 
1966 // Check the global in-use list and count; log the results of the checks.
1967 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
1968                                                           int *error_cnt_p) {
1969   int chk_om_in_use_count = 0;
<span class="line-modified">1970   for (ObjectMonitor* n = g_om_in_use_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">1971     chk_in_use_entry(NULL /* jt */, n, out, error_cnt_p);</span>
<span class="line-modified">1972     chk_om_in_use_count++;</span>









1973   }
<span class="line-modified">1974   if (g_om_in_use_count == chk_om_in_use_count) {</span>
<span class="line-modified">1975     out-&gt;print_cr(&quot;g_om_in_use_count=%d equals chk_om_in_use_count=%d&quot;, g_om_in_use_count,</span>
<span class="line-modified">1976                   chk_om_in_use_count);</span>

1977   } else {
<span class="line-modified">1978     out-&gt;print_cr(&quot;ERROR: g_om_in_use_count=%d is not equal to chk_om_in_use_count=%d&quot;,</span>
<span class="line-modified">1979                   g_om_in_use_count, chk_om_in_use_count);</span>
<span class="line-modified">1980     *error_cnt_p = *error_cnt_p + 1;</span>


1981   }
1982 }
1983 
1984 // Check an in-use monitor entry; log any errors.
1985 void ObjectSynchronizer::chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
1986                                           outputStream * out, int *error_cnt_p) {
1987   if (n-&gt;header().value() == 0) {
1988     if (jt != NULL) {
1989       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
1990                     &quot;: in-use per-thread monitor must have non-NULL _header &quot;
1991                     &quot;field.&quot;, p2i(jt), p2i(n));
1992     } else {
1993       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
1994                     &quot;must have non-NULL _header field.&quot;, p2i(n));
1995     }
1996     *error_cnt_p = *error_cnt_p + 1;
1997   }
1998   if (n-&gt;object() == NULL) {
1999     if (jt != NULL) {
2000       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
</pre>
<hr />
<pre>
2028       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2029                     &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
2030                     &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
2031                     INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
2032                     p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
2033     } else {
2034       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2035                     &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
2036                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
2037                     INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
2038     }
2039     *error_cnt_p = *error_cnt_p + 1;
2040   }
2041 }
2042 
2043 // Check the thread&#39;s free list and count; log the results of the checks.
2044 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
2045                                                             outputStream * out,
2046                                                             int *error_cnt_p) {
2047   int chk_om_free_count = 0;
<span class="line-modified">2048   for (ObjectMonitor* n = jt-&gt;om_free_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">2049     chk_free_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2050     chk_om_free_count++;</span>









2051   }
<span class="line-modified">2052   if (jt-&gt;om_free_count == chk_om_free_count) {</span>

2053     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d equals &quot;
<span class="line-modified">2054                   &quot;chk_om_free_count=%d&quot;, p2i(jt), jt-&gt;om_free_count, chk_om_free_count);</span>
2055   } else {
2056     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d is not &quot;
<span class="line-modified">2057                   &quot;equal to chk_om_free_count=%d&quot;, p2i(jt), jt-&gt;om_free_count,</span>
2058                   chk_om_free_count);
2059     *error_cnt_p = *error_cnt_p + 1;
2060   }
2061 }
2062 
2063 // Check the thread&#39;s in-use list and count; log the results of the checks.
2064 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
2065                                                               outputStream * out,
2066                                                               int *error_cnt_p) {
2067   int chk_om_in_use_count = 0;
<span class="line-modified">2068   for (ObjectMonitor* n = jt-&gt;om_in_use_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">2069     chk_in_use_entry(jt, n, out, error_cnt_p);</span>
<span class="line-modified">2070     chk_om_in_use_count++;</span>









2071   }
<span class="line-modified">2072   if (jt-&gt;om_in_use_count == chk_om_in_use_count) {</span>

2073     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d equals &quot;
<span class="line-modified">2074                   &quot;chk_om_in_use_count=%d&quot;, p2i(jt), jt-&gt;om_in_use_count,</span>
2075                   chk_om_in_use_count);
2076   } else {
2077     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d is not &quot;
<span class="line-modified">2078                   &quot;equal to chk_om_in_use_count=%d&quot;, p2i(jt), jt-&gt;om_in_use_count,</span>
2079                   chk_om_in_use_count);
2080     *error_cnt_p = *error_cnt_p + 1;
2081   }
2082 }
2083 
2084 // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
2085 // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
2086 // indicate the associated object and its type.
<span class="line-modified">2087 void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out,</span>
<span class="line-removed">2088                                                     bool on_exit) {</span>
<span class="line-removed">2089   if (!on_exit) {</span>
<span class="line-removed">2090     // Not at VM exit so grab the global list lock.</span>
<span class="line-removed">2091     Thread::muxAcquire(&amp;gListLock, &quot;log_in_use_monitor_details&quot;);</span>
<span class="line-removed">2092   }</span>
<span class="line-removed">2093 </span>
2094   stringStream ss;
<span class="line-modified">2095   if (g_om_in_use_count &gt; 0) {</span>
2096     out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
2097     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);
2098     out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
2099                   &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2100     out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">2101     for (ObjectMonitor* n = g_om_in_use_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">2102       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2103       const markWord mark = n-&gt;header();</span>
<span class="line-modified">2104       ResourceMark rm;</span>
<span class="line-modified">2105       out-&gt;print(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(n),</span>
<span class="line-modified">2106                  n-&gt;is_busy() != 0, mark.hash() != 0, n-&gt;owner() != NULL,</span>
<span class="line-modified">2107                  p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-modified">2108       if (n-&gt;is_busy() != 0) {</span>
<span class="line-modified">2109         out-&gt;print(&quot; (%s)&quot;, n-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-modified">2110         ss.reset();</span>










2111       }
<span class="line-removed">2112       out-&gt;cr();</span>
2113     }
2114   }
2115 
<span class="line-removed">2116   if (!on_exit) {</span>
<span class="line-removed">2117     Thread::muxRelease(&amp;gListLock);</span>
<span class="line-removed">2118   }</span>
<span class="line-removed">2119 </span>
2120   out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
2121   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);
2122   out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
2123                 &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2124   out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
2125   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">2126     for (ObjectMonitor* n = jt-&gt;om_in_use_list; n != NULL; n = n-&gt;_next_om) {</span>
<span class="line-modified">2127       const oop obj = (oop) n-&gt;object();</span>
<span class="line-modified">2128       const markWord mark = n-&gt;header();</span>
<span class="line-modified">2129       ResourceMark rm;</span>
<span class="line-modified">2130       out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-modified">2131                  &quot;  %s&quot;, p2i(jt), p2i(n), n-&gt;is_busy() != 0,</span>
<span class="line-modified">2132                  mark.hash() != 0, n-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-modified">2133                  obj-&gt;klass()-&gt;external_name());</span>
<span class="line-modified">2134       if (n-&gt;is_busy() != 0) {</span>
<span class="line-modified">2135         out-&gt;print(&quot; (%s)&quot;, n-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-modified">2136         ss.reset();</span>










2137       }
<span class="line-removed">2138       out-&gt;cr();</span>
2139     }
2140   }
2141 
2142   out-&gt;flush();
2143 }
2144 
2145 // Log counts for the global and per-thread monitor lists and return
2146 // the population count.
2147 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
2148   int pop_count = 0;
2149   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2150                 &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
2151   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">2152   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;,</span>
<span class="line-modified">2153                 g_om_in_use_count, g_om_free_count, g_om_population);</span>
<span class="line-modified">2154   pop_count += g_om_in_use_count + g_om_free_count;</span>


2155 
2156   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2157                 &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
2158   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
2159 
2160   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {


2161     out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">2162                   jt-&gt;om_in_use_count, jt-&gt;om_free_count, jt-&gt;om_free_provision);</span>
<span class="line-modified">2163     pop_count += jt-&gt;om_in_use_count + jt-&gt;om_free_count;</span>
2164   }
2165   return pop_count;
2166 }
2167 
2168 #ifndef PRODUCT
2169 
2170 // Check if monitor belongs to the monitor cache
2171 // The list is grow-only so it&#39;s *relatively* safe to traverse
2172 // the list of extant blocks without taking a lock.
2173 
2174 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">2175   PaddedObjectMonitor* block = Atomic::load_acquire(&amp;g_block_list);</span>
2176   while (block != NULL) {
2177     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
2178     if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
2179       address mon = (address)monitor;
2180       address blk = (address)block;
2181       size_t diff = mon - blk;
2182       assert((diff % sizeof(PaddedObjectMonitor)) == 0, &quot;must be aligned&quot;);
2183       return 1;
2184     }
<span class="line-modified">2185     block = (PaddedObjectMonitor*)block-&gt;_next_om;</span>


2186   }
2187   return 0;
2188 }
2189 
2190 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 100     }                                                                      \
 101   }
 102 
 103 #else //  ndef DTRACE_ENABLED
 104 
 105 #define DTRACE_MONITOR_WAIT_PROBE(obj, thread, millis, mon)    {;}
 106 #define DTRACE_MONITOR_PROBE(probe, obj, thread, mon)          {;}
 107 
 108 #endif // ndef DTRACE_ENABLED
 109 
 110 // This exists only as a workaround of dtrace bug 6254741
 111 int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {
 112   DTRACE_MONITOR_PROBE(waited, monitor, obj(), thr);
 113   return 0;
 114 }
 115 
 116 #define NINFLATIONLOCKS 256
 117 static volatile intptr_t gInflationLocks[NINFLATIONLOCKS];
 118 
 119 // global list of blocks of monitors
<span class="line-modified"> 120 PaddedObjectMonitor* ObjectSynchronizer::g_block_list = NULL;</span>
<span class="line-modified"> 121 </span>
<span class="line-modified"> 122 struct ObjectMonitorListGlobals {</span>
<span class="line-modified"> 123   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
<span class="line-modified"> 124   // These are highly shared list related variables.</span>
<span class="line-modified"> 125   // To avoid false-sharing they need to be the sole occupants of a cache line.</span>
<span class="line-modified"> 126 </span>
<span class="line-modified"> 127   // Global ObjectMonitor free list. Newly allocated and deflated</span>
<span class="line-modified"> 128   // ObjectMonitors are prepended here.</span>
<span class="line-modified"> 129   ObjectMonitor* _free_list;</span>
<span class="line-modified"> 130   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-modified"> 131 </span>
<span class="line-added"> 132   // Global ObjectMonitor in-use list. When a JavaThread is exiting,</span>
<span class="line-added"> 133   // ObjectMonitors on its per-thread in-use list are prepended here.</span>
<span class="line-added"> 134   ObjectMonitor* _in_use_list;</span>
<span class="line-added"> 135   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137   int _free_count;    // # on free_list</span>
<span class="line-added"> 138   DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   int _in_use_count;  // # on in_use_list</span>
<span class="line-added"> 141   DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143   int _population;    // # Extant -- in circulation</span>
<span class="line-added"> 144   DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));</span>
<span class="line-added"> 145 };</span>
<span class="line-added"> 146 static ObjectMonitorListGlobals om_list_globals;</span>
 147 
 148 #define CHAINMARKER (cast_to_oop&lt;intptr_t&gt;(-1))
 149 
 150 
<span class="line-added"> 151 // =====================&gt; Spin-lock functions</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153 // ObjectMonitors are not lockable outside of this file. We use spin-locks</span>
<span class="line-added"> 154 // implemented using a bit in the _next_om field instead of the heavier</span>
<span class="line-added"> 155 // weight locking mechanisms for faster list management.</span>
<span class="line-added"> 156 </span>
<span class="line-added"> 157 #define OM_LOCK_BIT 0x1</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159 // Return true if the ObjectMonitor is locked.</span>
<span class="line-added"> 160 // Otherwise returns false.</span>
<span class="line-added"> 161 static bool is_locked(ObjectMonitor* om) {</span>
<span class="line-added"> 162   return ((intptr_t)om-&gt;next_om() &amp; OM_LOCK_BIT) == OM_LOCK_BIT;</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 // Mark an ObjectMonitor* with OM_LOCK_BIT and return it.</span>
<span class="line-added"> 166 static ObjectMonitor* mark_om_ptr(ObjectMonitor* om) {</span>
<span class="line-added"> 167   return (ObjectMonitor*)((intptr_t)om | OM_LOCK_BIT);</span>
<span class="line-added"> 168 }</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170 // Return the unmarked next field in an ObjectMonitor. Note: the next</span>
<span class="line-added"> 171 // field may or may not have been marked with OM_LOCK_BIT originally.</span>
<span class="line-added"> 172 static ObjectMonitor* unmarked_next(ObjectMonitor* om) {</span>
<span class="line-added"> 173   return (ObjectMonitor*)((intptr_t)om-&gt;next_om() &amp; ~OM_LOCK_BIT);</span>
<span class="line-added"> 174 }</span>
<span class="line-added"> 175 </span>
<span class="line-added"> 176 // Try to lock an ObjectMonitor. Returns true if locking was successful.</span>
<span class="line-added"> 177 // Otherwise returns false.</span>
<span class="line-added"> 178 static bool try_om_lock(ObjectMonitor* om) {</span>
<span class="line-added"> 179   // Get current next field without any OM_LOCK_BIT value.</span>
<span class="line-added"> 180   ObjectMonitor* next = unmarked_next(om);</span>
<span class="line-added"> 181   if (om-&gt;try_set_next_om(next, mark_om_ptr(next)) != next) {</span>
<span class="line-added"> 182     return false;  // Cannot lock the ObjectMonitor.</span>
<span class="line-added"> 183   }</span>
<span class="line-added"> 184   return true;</span>
<span class="line-added"> 185 }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187 // Lock an ObjectMonitor.</span>
<span class="line-added"> 188 static void om_lock(ObjectMonitor* om) {</span>
<span class="line-added"> 189   while (true) {</span>
<span class="line-added"> 190     if (try_om_lock(om)) {</span>
<span class="line-added"> 191       return;</span>
<span class="line-added"> 192     }</span>
<span class="line-added"> 193   }</span>
<span class="line-added"> 194 }</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196 // Unlock an ObjectMonitor.</span>
<span class="line-added"> 197 static void om_unlock(ObjectMonitor* om) {</span>
<span class="line-added"> 198   ObjectMonitor* next = om-&gt;next_om();</span>
<span class="line-added"> 199   guarantee(((intptr_t)next &amp; OM_LOCK_BIT) == OM_LOCK_BIT, &quot;next=&quot; INTPTR_FORMAT</span>
<span class="line-added"> 200             &quot; must have OM_LOCK_BIT=%x set.&quot;, p2i(next), OM_LOCK_BIT);</span>
<span class="line-added"> 201 </span>
<span class="line-added"> 202   next = (ObjectMonitor*)((intptr_t)next &amp; ~OM_LOCK_BIT);  // Clear OM_LOCK_BIT.</span>
<span class="line-added"> 203   om-&gt;set_next_om(next);</span>
<span class="line-added"> 204 }</span>
<span class="line-added"> 205 </span>
<span class="line-added"> 206 // Get the list head after locking it. Returns the list head or NULL</span>
<span class="line-added"> 207 // if the list is empty.</span>
<span class="line-added"> 208 static ObjectMonitor* get_list_head_locked(ObjectMonitor** list_p) {</span>
<span class="line-added"> 209   while (true) {</span>
<span class="line-added"> 210     ObjectMonitor* mid = Atomic::load(list_p);</span>
<span class="line-added"> 211     if (mid == NULL) {</span>
<span class="line-added"> 212       return NULL;  // The list is empty.</span>
<span class="line-added"> 213     }</span>
<span class="line-added"> 214     if (try_om_lock(mid)) {</span>
<span class="line-added"> 215       if (Atomic::load(list_p) != mid) {</span>
<span class="line-added"> 216         // The list head changed before we could lock it so we have to retry.</span>
<span class="line-added"> 217         om_unlock(mid);</span>
<span class="line-added"> 218         continue;</span>
<span class="line-added"> 219       }</span>
<span class="line-added"> 220       return mid;</span>
<span class="line-added"> 221     }</span>
<span class="line-added"> 222   }</span>
<span class="line-added"> 223 }</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225 #undef OM_LOCK_BIT</span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228 // =====================&gt; List Management functions</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230 // Prepend a list of ObjectMonitors to the specified *list_p. &#39;tail&#39; is</span>
<span class="line-added"> 231 // the last ObjectMonitor in the list and there are &#39;count&#39; on the list.</span>
<span class="line-added"> 232 // Also updates the specified *count_p.</span>
<span class="line-added"> 233 static void prepend_list_to_common(ObjectMonitor* list, ObjectMonitor* tail,</span>
<span class="line-added"> 234                                    int count, ObjectMonitor** list_p,</span>
<span class="line-added"> 235                                    int* count_p) {</span>
<span class="line-added"> 236   while (true) {</span>
<span class="line-added"> 237     ObjectMonitor* cur = Atomic::load(list_p);</span>
<span class="line-added"> 238     // Prepend list to *list_p.</span>
<span class="line-added"> 239     if (!try_om_lock(tail)) {</span>
<span class="line-added"> 240       // Failed to lock tail due to a list walker so try it all again.</span>
<span class="line-added"> 241       continue;</span>
<span class="line-added"> 242     }</span>
<span class="line-added"> 243     tail-&gt;set_next_om(cur);  // tail now points to cur (and unlocks tail)</span>
<span class="line-added"> 244     if (cur == NULL) {</span>
<span class="line-added"> 245       // No potential race with takers or other prependers since</span>
<span class="line-added"> 246       // *list_p is empty.</span>
<span class="line-added"> 247       if (Atomic::cmpxchg(list_p, cur, list) == cur) {</span>
<span class="line-added"> 248         // Successfully switched *list_p to the list value.</span>
<span class="line-added"> 249         Atomic::add(count_p, count);</span>
<span class="line-added"> 250         break;</span>
<span class="line-added"> 251       }</span>
<span class="line-added"> 252       // Implied else: try it all again</span>
<span class="line-added"> 253     } else {</span>
<span class="line-added"> 254       if (!try_om_lock(cur)) {</span>
<span class="line-added"> 255         continue;  // failed to lock cur so try it all again</span>
<span class="line-added"> 256       }</span>
<span class="line-added"> 257       // We locked cur so try to switch *list_p to the list value.</span>
<span class="line-added"> 258       if (Atomic::cmpxchg(list_p, cur, list) != cur) {</span>
<span class="line-added"> 259         // The list head has changed so unlock cur and try again:</span>
<span class="line-added"> 260         om_unlock(cur);</span>
<span class="line-added"> 261         continue;</span>
<span class="line-added"> 262       }</span>
<span class="line-added"> 263       Atomic::add(count_p, count);</span>
<span class="line-added"> 264       om_unlock(cur);</span>
<span class="line-added"> 265       break;</span>
<span class="line-added"> 266     }</span>
<span class="line-added"> 267   }</span>
<span class="line-added"> 268 }</span>
<span class="line-added"> 269 </span>
<span class="line-added"> 270 // Prepend a newly allocated block of ObjectMonitors to g_block_list and</span>
<span class="line-added"> 271 // om_list_globals._free_list. Also updates om_list_globals._population</span>
<span class="line-added"> 272 // and om_list_globals._free_count.</span>
<span class="line-added"> 273 void ObjectSynchronizer::prepend_block_to_lists(PaddedObjectMonitor* new_blk) {</span>
<span class="line-added"> 274   // First we handle g_block_list:</span>
<span class="line-added"> 275   while (true) {</span>
<span class="line-added"> 276     PaddedObjectMonitor* cur = Atomic::load(&amp;g_block_list);</span>
<span class="line-added"> 277     // Prepend new_blk to g_block_list. The first ObjectMonitor in</span>
<span class="line-added"> 278     // a block is reserved for use as linkage to the next block.</span>
<span class="line-added"> 279     new_blk[0].set_next_om(cur);</span>
<span class="line-added"> 280     if (Atomic::cmpxchg(&amp;g_block_list, cur, new_blk) == cur) {</span>
<span class="line-added"> 281       // Successfully switched g_block_list to the new_blk value.</span>
<span class="line-added"> 282       Atomic::add(&amp;om_list_globals._population, _BLOCKSIZE - 1);</span>
<span class="line-added"> 283       break;</span>
<span class="line-added"> 284     }</span>
<span class="line-added"> 285     // Implied else: try it all again</span>
<span class="line-added"> 286   }</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288   // Second we handle om_list_globals._free_list:</span>
<span class="line-added"> 289   prepend_list_to_common(new_blk + 1, &amp;new_blk[_BLOCKSIZE - 1], _BLOCKSIZE - 1,</span>
<span class="line-added"> 290                          &amp;om_list_globals._free_list, &amp;om_list_globals._free_count);</span>
<span class="line-added"> 291 }</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293 // Prepend a list of ObjectMonitors to om_list_globals._free_list.</span>
<span class="line-added"> 294 // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added"> 295 // on the list. Also updates om_list_globals._free_count.</span>
<span class="line-added"> 296 static void prepend_list_to_global_free_list(ObjectMonitor* list,</span>
<span class="line-added"> 297                                              ObjectMonitor* tail, int count) {</span>
<span class="line-added"> 298   prepend_list_to_common(list, tail, count, &amp;om_list_globals._free_list,</span>
<span class="line-added"> 299                          &amp;om_list_globals._free_count);</span>
<span class="line-added"> 300 }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302 // Prepend a list of ObjectMonitors to om_list_globals._in_use_list.</span>
<span class="line-added"> 303 // &#39;tail&#39; is the last ObjectMonitor in the list and there are &#39;count&#39;</span>
<span class="line-added"> 304 // on the list. Also updates om_list_globals._in_use_list.</span>
<span class="line-added"> 305 static void prepend_list_to_global_in_use_list(ObjectMonitor* list,</span>
<span class="line-added"> 306                                                ObjectMonitor* tail, int count) {</span>
<span class="line-added"> 307   prepend_list_to_common(list, tail, count, &amp;om_list_globals._in_use_list,</span>
<span class="line-added"> 308                          &amp;om_list_globals._in_use_count);</span>
<span class="line-added"> 309 }</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311 // Prepend an ObjectMonitor to the specified list. Also updates</span>
<span class="line-added"> 312 // the specified counter.</span>
<span class="line-added"> 313 static void prepend_to_common(ObjectMonitor* m, ObjectMonitor** list_p,</span>
<span class="line-added"> 314                               int* count_p) {</span>
<span class="line-added"> 315   while (true) {</span>
<span class="line-added"> 316     om_lock(m);  // Lock m so we can safely update its next field.</span>
<span class="line-added"> 317     ObjectMonitor* cur = NULL;</span>
<span class="line-added"> 318     // Lock the list head to guard against races with a list walker</span>
<span class="line-added"> 319     // thread:</span>
<span class="line-added"> 320     if ((cur = get_list_head_locked(list_p)) != NULL) {</span>
<span class="line-added"> 321       // List head is now locked so we can safely switch it.</span>
<span class="line-added"> 322       m-&gt;set_next_om(cur);  // m now points to cur (and unlocks m)</span>
<span class="line-added"> 323       Atomic::store(list_p, m);  // Switch list head to unlocked m.</span>
<span class="line-added"> 324       om_unlock(cur);</span>
<span class="line-added"> 325       break;</span>
<span class="line-added"> 326     }</span>
<span class="line-added"> 327     // The list is empty so try to set the list head.</span>
<span class="line-added"> 328     assert(cur == NULL, &quot;cur must be NULL: cur=&quot; INTPTR_FORMAT, p2i(cur));</span>
<span class="line-added"> 329     m-&gt;set_next_om(cur);  // m now points to NULL (and unlocks m)</span>
<span class="line-added"> 330     if (Atomic::cmpxchg(list_p, cur, m) == cur) {</span>
<span class="line-added"> 331       // List head is now unlocked m.</span>
<span class="line-added"> 332       break;</span>
<span class="line-added"> 333     }</span>
<span class="line-added"> 334     // Implied else: try it all again</span>
<span class="line-added"> 335   }</span>
<span class="line-added"> 336   Atomic::inc(count_p);</span>
<span class="line-added"> 337 }</span>
<span class="line-added"> 338 </span>
<span class="line-added"> 339 // Prepend an ObjectMonitor to a per-thread om_free_list.</span>
<span class="line-added"> 340 // Also updates the per-thread om_free_count.</span>
<span class="line-added"> 341 static void prepend_to_om_free_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added"> 342   prepend_to_common(m, &amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added"> 343 }</span>
<span class="line-added"> 344 </span>
<span class="line-added"> 345 // Prepend an ObjectMonitor to a per-thread om_in_use_list.</span>
<span class="line-added"> 346 // Also updates the per-thread om_in_use_count.</span>
<span class="line-added"> 347 static void prepend_to_om_in_use_list(Thread* self, ObjectMonitor* m) {</span>
<span class="line-added"> 348   prepend_to_common(m, &amp;self-&gt;om_in_use_list, &amp;self-&gt;om_in_use_count);</span>
<span class="line-added"> 349 }</span>
<span class="line-added"> 350 </span>
<span class="line-added"> 351 // Take an ObjectMonitor from the start of the specified list. Also</span>
<span class="line-added"> 352 // decrements the specified counter. Returns NULL if none are available.</span>
<span class="line-added"> 353 static ObjectMonitor* take_from_start_of_common(ObjectMonitor** list_p,</span>
<span class="line-added"> 354                                                 int* count_p) {</span>
<span class="line-added"> 355   ObjectMonitor* take = NULL;</span>
<span class="line-added"> 356   // Lock the list head to guard against races with a list walker</span>
<span class="line-added"> 357   // thread:</span>
<span class="line-added"> 358   if ((take = get_list_head_locked(list_p)) == NULL) {</span>
<span class="line-added"> 359     return NULL;  // None are available.</span>
<span class="line-added"> 360   }</span>
<span class="line-added"> 361   ObjectMonitor* next = unmarked_next(take);</span>
<span class="line-added"> 362   // Switch locked list head to next (which unlocks the list head, but</span>
<span class="line-added"> 363   // leaves take locked):</span>
<span class="line-added"> 364   Atomic::store(list_p, next);</span>
<span class="line-added"> 365   Atomic::dec(count_p);</span>
<span class="line-added"> 366   // Unlock take, but leave the next value for any lagging list</span>
<span class="line-added"> 367   // walkers. It will get cleaned up when take is prepended to</span>
<span class="line-added"> 368   // the in-use list:</span>
<span class="line-added"> 369   om_unlock(take);</span>
<span class="line-added"> 370   return take;</span>
<span class="line-added"> 371 }</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373 // Take an ObjectMonitor from the start of the om_list_globals._free_list.</span>
<span class="line-added"> 374 // Also updates om_list_globals._free_count. Returns NULL if none are</span>
<span class="line-added"> 375 // available.</span>
<span class="line-added"> 376 static ObjectMonitor* take_from_start_of_global_free_list() {</span>
<span class="line-added"> 377   return take_from_start_of_common(&amp;om_list_globals._free_list,</span>
<span class="line-added"> 378                                    &amp;om_list_globals._free_count);</span>
<span class="line-added"> 379 }</span>
<span class="line-added"> 380 </span>
<span class="line-added"> 381 // Take an ObjectMonitor from the start of a per-thread free-list.</span>
<span class="line-added"> 382 // Also updates om_free_count. Returns NULL if none are available.</span>
<span class="line-added"> 383 static ObjectMonitor* take_from_start_of_om_free_list(Thread* self) {</span>
<span class="line-added"> 384   return take_from_start_of_common(&amp;self-&gt;om_free_list, &amp;self-&gt;om_free_count);</span>
<span class="line-added"> 385 }</span>
<span class="line-added"> 386 </span>
<span class="line-added"> 387 </span>
 388 // =====================&gt; Quick functions
 389 
 390 // The quick_* forms are special fast-path variants used to improve
 391 // performance.  In the simplest case, a &quot;quick_*&quot; implementation could
 392 // simply return false, in which case the caller will perform the necessary
 393 // state transitions and call the slow-path form.
 394 // The fast-path is designed to handle frequently arising cases in an efficient
 395 // manner and is just a degenerate &quot;optimistic&quot; variant of the slow-path.
 396 // returns true  -- to indicate the call was satisfied.
 397 // returns false -- to indicate the call needs the services of the slow-path.
 398 // A no-loitering ordinance is in effect for code in the quick_* family
 399 // operators: safepoints or indefinite blocking (blocking that might span a
 400 // safepoint) are forbidden. Generally the thread_state() is _in_Java upon
 401 // entry.
 402 //
 403 // Consider: An interesting optimization is to have the JIT recognize the
 404 // following common idiom:
 405 //   synchronized (someobj) { .... ; notify(); }
 406 // That is, we find a notify() or notifyAll() call that immediately precedes
 407 // the monitorexit operation.  In that case the JIT could fuse the operations
</pre>
<hr />
<pre>
 475     // Case: light contention possibly amenable to TLE
 476     // Case: TLE inimical operations such as nested/recursive synchronization
 477 
 478     if (owner == self) {
 479       m-&gt;_recursions++;
 480       return true;
 481     }
 482 
 483     // This Java Monitor is inflated so obj&#39;s header will never be
 484     // displaced to this thread&#39;s BasicLock. Make the displaced header
 485     // non-NULL so this BasicLock is not seen as recursive nor as
 486     // being locked. We do this unconditionally so that this thread&#39;s
 487     // BasicLock cannot be mis-interpreted by any stack walkers. For
 488     // performance reasons, stack walkers generally first check for
 489     // Biased Locking in the object&#39;s header, the second check is for
 490     // stack-locking in the object&#39;s header, the third check is for
 491     // recursive stack-locking in the displaced header in the BasicLock,
 492     // and last are the inflated Java Monitor (ObjectMonitor) checks.
 493     lock-&gt;set_displaced_header(markWord::unused_mark());
 494 
<span class="line-modified"> 495     if (owner == NULL &amp;&amp; m-&gt;try_set_owner_from(NULL, self) == NULL) {</span>
 496       assert(m-&gt;_recursions == 0, &quot;invariant&quot;);
 497       return true;
 498     }
 499   }
 500 
 501   // Note that we could inflate in quick_enter.
 502   // This is likely a useful optimization
 503   // Critically, in quick_enter() we must not:
 504   // -- perform bias revocation, or
 505   // -- block indefinitely, or
 506   // -- reach a safepoint
 507 
 508   return false;        // revert to slow-path
 509 }
 510 
 511 // -----------------------------------------------------------------------------
 512 // Monitor Enter/Exit
 513 // The interpreter and compiler assembly code tries to lock using the fast path
 514 // of this algorithm. Make sure to update that code if the following function is
 515 // changed. The implementation is extremely sensitive to race condition. Be careful.
</pre>
<hr />
<pre>
 752 //
 753 // Performance concern:
 754 // OrderAccess::storestore() calls release() which at one time stored 0
 755 // into the global volatile OrderAccess::dummy variable. This store was
 756 // unnecessary for correctness. Many threads storing into a common location
 757 // causes considerable cache migration or &quot;sloshing&quot; on large SMP systems.
 758 // As such, I avoided using OrderAccess::storestore(). In some cases
 759 // OrderAccess::fence() -- which incurs local latency on the executing
 760 // processor -- is a better choice as it scales on SMP systems.
 761 //
 762 // See http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot for
 763 // a discussion of coherency costs. Note that all our current reference
 764 // platforms provide strong ST-ST order, so the issue is moot on IA32,
 765 // x64, and SPARC.
 766 //
 767 // As a general policy we use &quot;volatile&quot; to control compiler-based reordering
 768 // and explicit fences (barriers) to control for architectural reordering
 769 // performed by the CPU(s) or platform.
 770 
 771 struct SharedGlobals {
<span class="line-modified"> 772   char         _pad_prefix[OM_CACHE_LINE_SIZE];</span>
 773   // These are highly shared mostly-read variables.
 774   // To avoid false-sharing they need to be the sole occupants of a cache line.
 775   volatile int stw_random;
 776   volatile int stw_cycle;
<span class="line-modified"> 777   DEFINE_PAD_MINUS_SIZE(1, OM_CACHE_LINE_SIZE, sizeof(volatile int) * 2);</span>
 778   // Hot RW variable -- Sequester to avoid false-sharing
 779   volatile int hc_sequence;
<span class="line-modified"> 780   DEFINE_PAD_MINUS_SIZE(2, OM_CACHE_LINE_SIZE, sizeof(volatile int));</span>
 781 };
 782 
 783 static SharedGlobals GVars;
 784 static int _forceMonitorScavenge = 0; // Scavenge required and pending
 785 
 786 static markWord read_stable_mark(oop obj) {
 787   markWord mark = obj-&gt;mark();
 788   if (!mark.is_being_inflated()) {
 789     return mark;       // normal fast-path return
 790   }
 791 
 792   int its = 0;
 793   for (;;) {
 794     markWord mark = obj-&gt;mark();
 795     if (!mark.is_being_inflated()) {
 796       return mark;    // normal fast-path return
 797     }
 798 
 799     // The object is being inflated by some other thread.
 800     // The caller of read_stable_mark() must wait for inflation to complete.
</pre>
<hr />
<pre>
1123     assert(monitor != NULL, &quot;monitor should be non-null&quot;);
1124     owner = (address) monitor-&gt;owner();
1125   }
1126 
1127   if (owner != NULL) {
1128     // owning_thread_from_monitor_owner() may also return NULL here
1129     return Threads::owning_thread_from_monitor_owner(t_list, owner);
1130   }
1131 
1132   // Unlocked case, header in place
1133   // Cannot have assertion since this object may have been
1134   // locked by another thread when reaching here.
1135   // assert(mark.is_neutral(), &quot;sanity check&quot;);
1136 
1137   return NULL;
1138 }
1139 
1140 // Visitors ...
1141 
1142 void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure) {
<span class="line-modified">1143   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
1144   while (block != NULL) {
1145     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
1146     for (int i = _BLOCKSIZE - 1; i &gt; 0; i--) {
1147       ObjectMonitor* mid = (ObjectMonitor *)(block + i);
1148       oop object = (oop)mid-&gt;object();
1149       if (object != NULL) {
1150         // Only process with closure if the object is set.
1151         closure-&gt;do_monitor(mid);
1152       }
1153     }
<span class="line-modified">1154     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">1155     // used with block linkage _next_om fields).</span>
<span class="line-added">1156     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
1157   }
1158 }
1159 
1160 static bool monitors_used_above_threshold() {
<span class="line-modified">1161   int population = Atomic::load(&amp;om_list_globals._population);</span>
<span class="line-added">1162   if (population == 0) {</span>
1163     return false;
1164   }
<span class="line-modified">1165   if (MonitorUsedDeflationThreshold &gt; 0) {</span>
<span class="line-modified">1166     int monitors_used = population - Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">1167     int monitor_usage = (monitors_used * 100LL) / population;</span>
<span class="line-added">1168     return monitor_usage &gt; MonitorUsedDeflationThreshold;</span>
<span class="line-added">1169   }</span>
<span class="line-added">1170   return false;</span>
<span class="line-added">1171 }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173 // Returns true if MonitorBound is set (&gt; 0) and if the specified</span>
<span class="line-added">1174 // cnt is &gt; MonitorBound. Otherwise returns false.</span>
<span class="line-added">1175 static bool is_MonitorBound_exceeded(const int cnt) {</span>
<span class="line-added">1176   const int mx = MonitorBound;</span>
<span class="line-added">1177   return mx &gt; 0 &amp;&amp; cnt &gt; mx;</span>
1178 }
1179 
1180 bool ObjectSynchronizer::is_cleanup_needed() {
<span class="line-modified">1181   if (monitors_used_above_threshold()) {</span>
<span class="line-modified">1182     // Too many monitors in use.</span>
<span class="line-modified">1183     return true;</span>

1184   }
1185   return needs_monitor_scavenge();
1186 }
1187 
1188 bool ObjectSynchronizer::needs_monitor_scavenge() {
1189   if (Atomic::load(&amp;_forceMonitorScavenge) == 1) {
1190     log_info(monitorinflation)(&quot;Monitor scavenge needed, triggering safepoint cleanup.&quot;);
1191     return true;
1192   }
1193   return false;
1194 }
1195 
1196 void ObjectSynchronizer::oops_do(OopClosure* f) {
1197   // We only scan the global used list here (for moribund threads), and
1198   // the thread-local monitors in Thread::oops_do().
1199   global_used_oops_do(f);
1200 }
1201 
1202 void ObjectSynchronizer::global_used_oops_do(OopClosure* f) {
1203   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">1204   list_oops_do(Atomic::load(&amp;om_list_globals._in_use_list), f);</span>
1205 }
1206 
1207 void ObjectSynchronizer::thread_local_used_oops_do(Thread* thread, OopClosure* f) {
1208   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1209   list_oops_do(thread-&gt;om_in_use_list, f);
1210 }
1211 
1212 void ObjectSynchronizer::list_oops_do(ObjectMonitor* list, OopClosure* f) {
1213   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
<span class="line-modified">1214   // The oops_do() phase does not overlap with monitor deflation</span>
<span class="line-modified">1215   // so no need to lock ObjectMonitors for the list traversal.</span>
<span class="line-added">1216   for (ObjectMonitor* mid = list; mid != NULL; mid = unmarked_next(mid)) {</span>
1217     if (mid-&gt;object() != NULL) {
1218       f-&gt;do_oop((oop*)mid-&gt;object_addr());
1219     }
1220   }
1221 }
1222 
1223 
1224 // -----------------------------------------------------------------------------
1225 // ObjectMonitor Lifecycle
1226 // -----------------------
<span class="line-modified">1227 // Inflation unlinks monitors from om_list_globals._free_list or a per-thread</span>
<span class="line-modified">1228 // free list and associates them with objects. Deflation -- which occurs at</span>
<span class="line-modified">1229 // STW-time -- disassociates idle monitors from objects.</span>
<span class="line-modified">1230 // Such scavenged monitors are returned to the om_list_globals._free_list.</span>



1231 //
1232 // ObjectMonitors reside in type-stable memory (TSM) and are immortal.
1233 //
1234 // Lifecycle:
<span class="line-modified">1235 // --   unassigned and on the om_list_globals._free_list</span>
<span class="line-modified">1236 // --   unassigned and on a per-thread free list</span>
1237 // --   assigned to an object.  The object is inflated and the mark refers
<span class="line-modified">1238 //      to the ObjectMonitor.</span>
1239 
1240 
1241 // Constraining monitor pool growth via MonitorBound ...
1242 //
1243 // If MonitorBound is not set (&lt;= 0), MonitorBound checks are disabled.
1244 //
1245 // The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the
1246 // the rate of scavenging is driven primarily by GC.  As such,  we can find
1247 // an inordinate number of monitors in circulation.
1248 // To avoid that scenario we can artificially induce a STW safepoint
1249 // if the pool appears to be growing past some reasonable bound.
1250 // Generally we favor time in space-time tradeoffs, but as there&#39;s no
1251 // natural back-pressure on the # of extant monitors we need to impose some
1252 // type of limit.  Beware that if MonitorBound is set to too low a value
1253 // we could just loop. In addition, if MonitorBound is set to a low value
1254 // we&#39;ll incur more safepoints, which are harmful to performance.
1255 // See also: GuaranteedSafepointInterval
1256 //
1257 // If MonitorBound is set, the boundry applies to
<span class="line-modified">1258 //     (om_list_globals._population - om_list_globals._free_count)</span>
1259 // i.e., if there are not enough ObjectMonitors on the global free list,
1260 // then a safepoint deflation is induced. Picking a good MonitorBound value
1261 // is non-trivial.
1262 
1263 static void InduceScavenge(Thread* self, const char * Whence) {
1264   // Induce STW safepoint to trim monitors
1265   // Ultimately, this results in a call to deflate_idle_monitors() in the near future.
1266   // More precisely, trigger a cleanup safepoint as the number
1267   // of active monitors passes the specified threshold.
1268   // TODO: assert thread state is reasonable
1269 
<span class="line-modified">1270   if (Atomic::xchg(&amp;_forceMonitorScavenge, 1) == 0) {</span>
1271     VMThread::check_for_forced_cleanup();
1272   }
1273 }
1274 
1275 ObjectMonitor* ObjectSynchronizer::om_alloc(Thread* self) {
1276   // A large MAXPRIVATE value reduces both list lock contention
1277   // and list coherency traffic, but also tends to increase the
1278   // number of ObjectMonitors in circulation as well as the STW
1279   // scavenge costs.  As usual, we lean toward time in space-time
1280   // tradeoffs.
1281   const int MAXPRIVATE = 1024;
<span class="line-added">1282   NoSafepointVerifier nsv;</span>
<span class="line-added">1283 </span>
1284   stringStream ss;
1285   for (;;) {
1286     ObjectMonitor* m;
1287 
1288     // 1: try to allocate from the thread&#39;s local om_free_list.
1289     // Threads will attempt to allocate first from their local list, then
<span class="line-modified">1290     // from the global list, and only after those attempts fail will the</span>
<span class="line-modified">1291     // thread attempt to instantiate new monitors. Thread-local free lists</span>
<span class="line-modified">1292     // improve allocation latency, as well as reducing coherency traffic</span>
<span class="line-modified">1293     // on the shared global list.</span>
<span class="line-modified">1294     m = take_from_start_of_om_free_list(self);</span>
1295     if (m != NULL) {


1296       guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-modified">1297       prepend_to_om_in_use_list(self, m);</span>


1298       return m;
1299     }
1300 
<span class="line-modified">1301     // 2: try to allocate from the global om_list_globals._free_list</span>


1302     // If we&#39;re using thread-local free lists then try
1303     // to reprovision the caller&#39;s free list.
<span class="line-modified">1304     if (Atomic::load(&amp;om_list_globals._free_list) != NULL) {</span>
1305       // Reprovision the thread&#39;s om_free_list.
1306       // Use bulk transfers to reduce the allocation rate and heat
1307       // on various locks.
<span class="line-modified">1308       for (int i = self-&gt;om_free_provision; --i &gt;= 0;) {</span>
<span class="line-modified">1309         ObjectMonitor* take = take_from_start_of_global_free_list();</span>
<span class="line-modified">1310         if (take == NULL) {</span>
<span class="line-modified">1311           break;  // No more are available.</span>
<span class="line-modified">1312         }</span>
1313         guarantee(take-&gt;object() == NULL, &quot;invariant&quot;);
1314         take-&gt;Recycle();
1315         om_release(self, take, false);
1316       }
<span class="line-modified">1317       self-&gt;om_free_provision += 1 + (self-&gt;om_free_provision / 2);</span>

1318       if (self-&gt;om_free_provision &gt; MAXPRIVATE) self-&gt;om_free_provision = MAXPRIVATE;
1319 
<span class="line-modified">1320       if (is_MonitorBound_exceeded(Atomic::load(&amp;om_list_globals._population) -</span>
<span class="line-modified">1321                                    Atomic::load(&amp;om_list_globals._free_count))) {</span>
1322         // Not enough ObjectMonitors on the global free list.
1323         // We can&#39;t safely induce a STW safepoint from om_alloc() as our thread
1324         // state may not be appropriate for such activities and callers may hold
1325         // naked oops, so instead we defer the action.
1326         InduceScavenge(self, &quot;om_alloc&quot;);
1327       }
1328       continue;
1329     }
1330 
1331     // 3: allocate a block of new ObjectMonitors
1332     // Both the local and global free lists are empty -- resort to malloc().
1333     // In the current implementation ObjectMonitors are TSM - immortal.
1334     // Ideally, we&#39;d write &quot;new ObjectMonitor[_BLOCKSIZE], but we want
1335     // each ObjectMonitor to start at the beginning of a cache line,
1336     // so we use align_up().
1337     // A better solution would be to use C++ placement-new.
1338     // BEWARE: As it stands currently, we don&#39;t run the ctors!
1339     assert(_BLOCKSIZE &gt; 1, &quot;invariant&quot;);
1340     size_t neededsize = sizeof(PaddedObjectMonitor) * _BLOCKSIZE;
1341     PaddedObjectMonitor* temp;
<span class="line-modified">1342     size_t aligned_size = neededsize + (OM_CACHE_LINE_SIZE - 1);</span>
1343     void* real_malloc_addr = NEW_C_HEAP_ARRAY(char, aligned_size, mtInternal);
<span class="line-modified">1344     temp = (PaddedObjectMonitor*)align_up(real_malloc_addr, OM_CACHE_LINE_SIZE);</span>
1345     (void)memset((void *) temp, 0, neededsize);
1346 
1347     // Format the block.
1348     // initialize the linked list, each monitor points to its next
1349     // forming the single linked free list, the very first monitor
1350     // will points to next block, which forms the block list.
1351     // The trick of using the 1st element in the block as g_block_list
1352     // linkage should be reconsidered.  A better implementation would
1353     // look like: class Block { Block * next; int N; ObjectMonitor Body [N] ; }
1354 
1355     for (int i = 1; i &lt; _BLOCKSIZE; i++) {
<span class="line-modified">1356       temp[i].set_next_om((ObjectMonitor*)&amp;temp[i + 1]);</span>
1357     }
1358 
1359     // terminate the last monitor as the end of list
<span class="line-modified">1360     temp[_BLOCKSIZE - 1].set_next_om((ObjectMonitor*)NULL);</span>
1361 
1362     // Element [0] is reserved for global list linkage
1363     temp[0].set_object(CHAINMARKER);
1364 
1365     // Consider carving out this thread&#39;s current request from the
1366     // block in hand.  This avoids some lock traffic and redundant
1367     // list activity.
1368 
<span class="line-modified">1369     prepend_block_to_lists(temp);</span>

















1370   }
1371 }
1372 
1373 // Place &quot;m&quot; on the caller&#39;s private per-thread om_free_list.
1374 // In practice there&#39;s no need to clamp or limit the number of
1375 // monitors on a thread&#39;s om_free_list as the only non-allocation time
1376 // we&#39;ll call om_release() is to return a monitor to the free list after
1377 // a CAS attempt failed. This doesn&#39;t allow unbounded #s of monitors to
1378 // accumulate on a thread&#39;s free list.
1379 //
1380 // Key constraint: all ObjectMonitors on a thread&#39;s free list and the global
1381 // free list must have their object field set to null. This prevents the
1382 // scavenger -- deflate_monitor_list() -- from reclaiming them while we
1383 // are trying to release them.
1384 
1385 void ObjectSynchronizer::om_release(Thread* self, ObjectMonitor* m,
1386                                     bool from_per_thread_alloc) {
1387   guarantee(m-&gt;header().value() == 0, &quot;invariant&quot;);
1388   guarantee(m-&gt;object() == NULL, &quot;invariant&quot;);
<span class="line-added">1389   NoSafepointVerifier nsv;</span>
<span class="line-added">1390 </span>
1391   stringStream ss;
1392   guarantee((m-&gt;is_busy() | m-&gt;_recursions) == 0, &quot;freeing in-use monitor: &quot;
1393             &quot;%s, recursions=&quot; INTX_FORMAT, m-&gt;is_busy_to_string(&amp;ss),
1394             m-&gt;_recursions);
1395   // _next_om is used for both per-thread in-use and free lists so
1396   // we have to remove &#39;m&#39; from the in-use list first (as needed).
1397   if (from_per_thread_alloc) {
1398     // Need to remove &#39;m&#39; from om_in_use_list.
<span class="line-modified">1399     ObjectMonitor* mid = NULL;</span>
<span class="line-modified">1400     ObjectMonitor* next = NULL;</span>
<span class="line-modified">1401 </span>
<span class="line-modified">1402     // This list walk can only race with another list walker since</span>
<span class="line-modified">1403     // deflation can only happen at a safepoint so we don&#39;t have to</span>
<span class="line-modified">1404     // worry about an ObjectMonitor being removed from this list</span>
<span class="line-modified">1405     // while we are walking it.</span>
<span class="line-modified">1406 </span>
<span class="line-modified">1407     // Lock the list head to avoid racing with another list walker.</span>
<span class="line-added">1408     if ((mid = get_list_head_locked(&amp;self-&gt;om_in_use_list)) == NULL) {</span>
<span class="line-added">1409       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; in-use list must not be empty.&quot;, p2i(self));</span>
<span class="line-added">1410     }</span>
<span class="line-added">1411     next = unmarked_next(mid);</span>
<span class="line-added">1412     if (m == mid) {</span>
<span class="line-added">1413       // First special case:</span>
<span class="line-added">1414       // &#39;m&#39; matches mid, is the list head and is locked. Switch the list</span>
<span class="line-added">1415       // head to next which unlocks the list head, but leaves the extracted</span>
<span class="line-added">1416       // mid locked:</span>
<span class="line-added">1417       Atomic::store(&amp;self-&gt;om_in_use_list, next);</span>
<span class="line-added">1418     } else if (m == next) {</span>
<span class="line-added">1419       // Second special case:</span>
<span class="line-added">1420       // &#39;m&#39; matches next after the list head and we already have the list</span>
<span class="line-added">1421       // head locked so set mid to what we are extracting:</span>
<span class="line-added">1422       mid = next;</span>
<span class="line-added">1423       // Lock mid to prevent races with a list walker:</span>
<span class="line-added">1424       om_lock(mid);</span>
<span class="line-added">1425       // Update next to what follows mid (if anything):</span>
<span class="line-added">1426       next = unmarked_next(mid);</span>
<span class="line-added">1427       // Switch next after the list head to new next which unlocks the</span>
<span class="line-added">1428       // list head, but leaves the extracted mid locked:</span>
<span class="line-added">1429       self-&gt;om_in_use_list-&gt;set_next_om(next);</span>
<span class="line-added">1430     } else {</span>
<span class="line-added">1431       // We have to search the list to find &#39;m&#39;.</span>
<span class="line-added">1432       om_unlock(mid);  // unlock the list head</span>
<span class="line-added">1433       guarantee(next != NULL, &quot;thread=&quot; INTPTR_FORMAT &quot;: om_in_use_list=&quot; INTPTR_FORMAT</span>
<span class="line-added">1434                 &quot; is too short.&quot;, p2i(self), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">1435       // Our starting anchor is next after the list head which is the</span>
<span class="line-added">1436       // last ObjectMonitor we checked:</span>
<span class="line-added">1437       ObjectMonitor* anchor = next;</span>
<span class="line-added">1438       while ((mid = unmarked_next(anchor)) != NULL) {</span>
<span class="line-added">1439         if (m == mid) {</span>
<span class="line-added">1440           // We found &#39;m&#39; on the per-thread in-use list so extract it.</span>
<span class="line-added">1441           om_lock(anchor);  // Lock the anchor so we can safely modify it.</span>
<span class="line-added">1442           // Update next to what follows mid (if anything):</span>
<span class="line-added">1443           next = unmarked_next(mid);</span>
<span class="line-added">1444           // Switch next after the anchor to new next which unlocks the</span>
<span class="line-added">1445           // anchor, but leaves the extracted mid locked:</span>
<span class="line-added">1446           anchor-&gt;set_next_om(next);</span>
<span class="line-added">1447           break;</span>
<span class="line-added">1448         } else {</span>
<span class="line-added">1449           anchor = mid;</span>
1450         }



1451       }
1452     }
<span class="line-modified">1453 </span>
<span class="line-added">1454     if (mid == NULL) {</span>
<span class="line-added">1455       // Reached end of the list and didn&#39;t find &#39;m&#39; so:</span>
<span class="line-added">1456       fatal(&quot;thread=&quot; INTPTR_FORMAT &quot; must find m=&quot; INTPTR_FORMAT &quot;on om_in_use_list=&quot;</span>
<span class="line-added">1457             INTPTR_FORMAT, p2i(self), p2i(m), p2i(self-&gt;om_in_use_list));</span>
<span class="line-added">1458     }</span>
<span class="line-added">1459 </span>
<span class="line-added">1460     // At this point mid is disconnected from the in-use list so</span>
<span class="line-added">1461     // its lock no longer has any effects on the in-use list.</span>
<span class="line-added">1462     Atomic::dec(&amp;self-&gt;om_in_use_count);</span>
<span class="line-added">1463     // Unlock mid, but leave the next value for any lagging list</span>
<span class="line-added">1464     // walkers. It will get cleaned up when mid is prepended to</span>
<span class="line-added">1465     // the thread&#39;s free list:</span>
<span class="line-added">1466     om_unlock(mid);</span>
1467   }
1468 
<span class="line-modified">1469   prepend_to_om_free_list(self, m);</span>


1470 }
1471 
1472 // Return ObjectMonitors on a moribund thread&#39;s free and in-use
1473 // lists to the appropriate global lists. The ObjectMonitors on the
1474 // per-thread in-use list may still be in use by other threads.
1475 //
1476 // We currently call om_flush() from Threads::remove() before the
1477 // thread has been excised from the thread list and is no longer a
1478 // mutator. This means that om_flush() cannot run concurrently with
1479 // a safepoint and interleave with deflate_idle_monitors(). In
1480 // particular, this ensures that the thread&#39;s in-use monitors are
1481 // scanned by a GC safepoint, either via Thread::oops_do() (before
1482 // om_flush() is called) or via ObjectSynchronizer::oops_do() (after
1483 // om_flush() is called).
1484 
1485 void ObjectSynchronizer::om_flush(Thread* self) {
<span class="line-modified">1486   // Process the per-thread in-use list first to be consistent.</span>





















1487   int in_use_count = 0;
<span class="line-modified">1488   ObjectMonitor* in_use_list = NULL;</span>
<span class="line-added">1489   ObjectMonitor* in_use_tail = NULL;</span>
<span class="line-added">1490   NoSafepointVerifier nsv;</span>
<span class="line-added">1491 </span>
<span class="line-added">1492   // This function can race with a list walker thread so we lock the</span>
<span class="line-added">1493   // list head to prevent confusion.</span>
<span class="line-added">1494   if ((in_use_list = get_list_head_locked(&amp;self-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-added">1495     // At this point, we have locked the in-use list head so a racing</span>
<span class="line-added">1496     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-added">1497     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-added">1498     //</span>
1499     // The thread is going away, however the ObjectMonitors on the
1500     // om_in_use_list may still be in-use by other threads. Link
1501     // them to in_use_tail, which will be linked into the global
<span class="line-modified">1502     // in-use list (om_list_globals._in_use_list) below.</span>
<span class="line-modified">1503     //</span>
<span class="line-modified">1504     // Account for the in-use list head before the loop since it is</span>
<span class="line-added">1505     // already locked (by this thread):</span>
<span class="line-added">1506     in_use_tail = in_use_list;</span>
<span class="line-added">1507     in_use_count++;</span>
<span class="line-added">1508     for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL; cur_om = unmarked_next(cur_om)) {</span>
<span class="line-added">1509       if (is_locked(cur_om)) {</span>
<span class="line-added">1510         // cur_om is locked so there must be a racing walker thread ahead</span>
<span class="line-added">1511         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">1512         while (is_locked(cur_om)) {</span>
<span class="line-added">1513           os::naked_short_sleep(1);</span>
<span class="line-added">1514         }</span>
<span class="line-added">1515       }</span>
1516       in_use_tail = cur_om;
1517       in_use_count++;
1518     }
1519     guarantee(in_use_tail != NULL, &quot;invariant&quot;);
<span class="line-modified">1520     int l_om_in_use_count = Atomic::load(&amp;self-&gt;om_in_use_count);</span>
<span class="line-modified">1521     assert(l_om_in_use_count == in_use_count, &quot;in-use counts don&#39;t match: &quot;</span>
<span class="line-modified">1522           &quot;l_om_in_use_count=%d, in_use_count=%d&quot;, l_om_in_use_count, in_use_count);</span>
<span class="line-added">1523     Atomic::store(&amp;self-&gt;om_in_use_count, 0);</span>
<span class="line-added">1524     // Clear the in-use list head (which also unlocks it):</span>
<span class="line-added">1525     Atomic::store(&amp;self-&gt;om_in_use_list, (ObjectMonitor*)NULL);</span>
<span class="line-added">1526     om_unlock(in_use_list);</span>
<span class="line-added">1527   }</span>
<span class="line-added">1528 </span>
<span class="line-added">1529   int free_count = 0;</span>
<span class="line-added">1530   ObjectMonitor* free_list = NULL;</span>
<span class="line-added">1531   ObjectMonitor* free_tail = NULL;</span>
<span class="line-added">1532   // This function can race with a list walker thread so we lock the</span>
<span class="line-added">1533   // list head to prevent confusion.</span>
<span class="line-added">1534   if ((free_list = get_list_head_locked(&amp;self-&gt;om_free_list)) != NULL) {</span>
<span class="line-added">1535     // At this point, we have locked the free list head so a racing</span>
<span class="line-added">1536     // thread cannot come in after us. However, a racing thread could</span>
<span class="line-added">1537     // be ahead of us; we&#39;ll detect that and delay to let it finish.</span>
<span class="line-added">1538     //</span>
<span class="line-added">1539     // The thread is going away. Set &#39;free_tail&#39; to the last per-thread free</span>
<span class="line-added">1540     // monitor which will be linked to om_list_globals._free_list below.</span>
<span class="line-added">1541     //</span>
<span class="line-added">1542     // Account for the free list head before the loop since it is</span>
<span class="line-added">1543     // already locked (by this thread):</span>
<span class="line-added">1544     free_tail = free_list;</span>
<span class="line-added">1545     free_count++;</span>
<span class="line-added">1546     for (ObjectMonitor* s = unmarked_next(free_list); s != NULL; s = unmarked_next(s)) {</span>
<span class="line-added">1547       if (is_locked(s)) {</span>
<span class="line-added">1548         // s is locked so there must be a racing walker thread ahead</span>
<span class="line-added">1549         // of us so we&#39;ll give it a chance to finish.</span>
<span class="line-added">1550         while (is_locked(s)) {</span>
<span class="line-added">1551           os::naked_short_sleep(1);</span>
<span class="line-added">1552         }</span>
<span class="line-added">1553       }</span>
<span class="line-added">1554       free_tail = s;</span>
<span class="line-added">1555       free_count++;</span>
<span class="line-added">1556       guarantee(s-&gt;object() == NULL, &quot;invariant&quot;);</span>
<span class="line-added">1557       stringStream ss;</span>
<span class="line-added">1558       guarantee(!s-&gt;is_busy(), &quot;must be !is_busy: %s&quot;, s-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">1559     }</span>
<span class="line-added">1560     guarantee(free_tail != NULL, &quot;invariant&quot;);</span>
<span class="line-added">1561     int l_om_free_count = Atomic::load(&amp;self-&gt;om_free_count);</span>
<span class="line-added">1562     assert(l_om_free_count == free_count, &quot;free counts don&#39;t match: &quot;</span>
<span class="line-added">1563            &quot;l_om_free_count=%d, free_count=%d&quot;, l_om_free_count, free_count);</span>
<span class="line-added">1564     Atomic::store(&amp;self-&gt;om_free_count, 0);</span>
<span class="line-added">1565     Atomic::store(&amp;self-&gt;om_free_list, (ObjectMonitor*)NULL);</span>
<span class="line-added">1566     om_unlock(free_list);</span>
1567   }
1568 

1569   if (free_tail != NULL) {
<span class="line-modified">1570     prepend_list_to_global_free_list(free_list, free_tail, free_count);</span>


1571   }
1572 
1573   if (in_use_tail != NULL) {
<span class="line-modified">1574     prepend_list_to_global_in_use_list(in_use_list, in_use_tail, in_use_count);</span>


1575   }
1576 


1577   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1578   LogStreamHandle(Info, monitorinflation) lsh_info;
1579   LogStream* ls = NULL;
1580   if (log_is_enabled(Debug, monitorinflation)) {
1581     ls = &amp;lsh_debug;
1582   } else if ((free_count != 0 || in_use_count != 0) &amp;&amp;
1583              log_is_enabled(Info, monitorinflation)) {
1584     ls = &amp;lsh_info;
1585   }
1586   if (ls != NULL) {
1587     ls-&gt;print_cr(&quot;om_flush: jt=&quot; INTPTR_FORMAT &quot;, free_count=%d&quot;
1588                  &quot;, in_use_count=%d&quot; &quot;, om_free_provision=%d&quot;,
1589                  p2i(self), free_count, in_use_count, self-&gt;om_free_provision);
1590   }
1591 }
1592 
1593 static void post_monitor_inflate_event(EventJavaMonitorInflate* event,
1594                                        const oop obj,
1595                                        ObjectSynchronizer::InflateCause cause) {
1596   assert(event != NULL, &quot;invariant&quot;);
1597   assert(event-&gt;should_commit(), &quot;invariant&quot;);
1598   event-&gt;set_monitorClass(obj-&gt;klass());
1599   event-&gt;set_address((uintptr_t)(void*)obj);
1600   event-&gt;set_cause((u1)cause);
1601   event-&gt;commit();
1602 }
1603 
1604 // Fast path code shared by multiple functions
1605 void ObjectSynchronizer::inflate_helper(oop obj) {
1606   markWord mark = obj-&gt;mark();
1607   if (mark.has_monitor()) {
1608     assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), &quot;monitor is invalid&quot;);
1609     assert(mark.monitor()-&gt;header().is_neutral(), &quot;monitor must record a good object header&quot;);
1610     return;
1611   }
1612   inflate(Thread::current(), obj, inflate_cause_vm_internal);
1613 }
1614 
1615 ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,
<span class="line-modified">1616                                            oop object, const InflateCause cause) {</span>

1617   // Inflate mutates the heap ...
1618   // Relaxing assertion for bug 6320749.
1619   assert(Universe::verify_in_progress() ||
1620          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
1621 
1622   EventJavaMonitorInflate event;
1623 
1624   for (;;) {
1625     const markWord mark = object-&gt;mark();
1626     assert(!mark.has_bias_pattern(), &quot;invariant&quot;);
1627 
1628     // The mark can be in one of the following states:
1629     // *  Inflated     - just return
1630     // *  Stack-locked - coerce it to inflated
1631     // *  INFLATING    - busy wait for conversion to complete
1632     // *  Neutral      - aggressively inflate the object.
1633     // *  BIASED       - Illegal.  We should never see this
1634 
1635     // CASE: inflated
1636     if (mark.has_monitor()) {
</pre>
<hr />
<pre>
1715       // 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.
1716 
1717 
1718       // fetch the displaced mark from the owner&#39;s stack.
1719       // The owner can&#39;t die or unwind past the lock while our INFLATING
1720       // object is in the mark.  Furthermore the owner can&#39;t complete
1721       // an unlock on the object, either.
1722       markWord dmw = mark.displaced_mark_helper();
1723       // Catch if the object&#39;s header is not neutral (not locked and
1724       // not marked is what we care about here).
1725       assert(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1726 
1727       // Setup monitor fields to proper values -- prepare the monitor
1728       m-&gt;set_header(dmw);
1729 
1730       // Optimization: if the mark.locker stack address is associated
1731       // with this thread we could simply set m-&gt;_owner = self.
1732       // Note that a thread can inflate an object
1733       // that it has stack-locked -- as might happen in wait() -- directly
1734       // with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.
<span class="line-modified">1735       m-&gt;set_owner_from(NULL, mark.locker());</span>
1736       m-&gt;set_object(object);
1737       // TODO-FIXME: assert BasicLock-&gt;dhw != 0.
1738 
1739       // Must preserve store ordering. The monitor state must
1740       // be stable at the time of publishing the monitor address.
1741       guarantee(object-&gt;mark() == markWord::INFLATING(), &quot;invariant&quot;);
1742       object-&gt;release_set_mark(markWord::encode(m));
1743 
1744       // Hopefully the performance counters are allocated on distinct cache lines
1745       // to avoid false sharing on MP systems ...
1746       OM_PERFDATA_OP(Inflations, inc());
1747       if (log_is_enabled(Trace, monitorinflation)) {
1748         ResourceMark rm(self);
1749         lsh.print_cr(&quot;inflate(has_locker): object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1750                      INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(object),
1751                      object-&gt;mark().value(), object-&gt;klass()-&gt;external_name());
1752       }
1753       if (event.should_commit()) {
1754         post_monitor_inflate_event(&amp;event, object, cause);
1755       }
</pre>
<hr />
<pre>
1827 // This is an unfortunate aspect of this design.
1828 
1829 // Deflate a single monitor if not in-use
1830 // Return true if deflated, false if in-use
1831 bool ObjectSynchronizer::deflate_monitor(ObjectMonitor* mid, oop obj,
1832                                          ObjectMonitor** free_head_p,
1833                                          ObjectMonitor** free_tail_p) {
1834   bool deflated;
1835   // Normal case ... The monitor is associated with obj.
1836   const markWord mark = obj-&gt;mark();
1837   guarantee(mark == markWord::encode(mid), &quot;should match: mark=&quot;
1838             INTPTR_FORMAT &quot;, encoded mid=&quot; INTPTR_FORMAT, mark.value(),
1839             markWord::encode(mid).value());
1840   // Make sure that mark.monitor() and markWord::encode() agree:
1841   guarantee(mark.monitor() == mid, &quot;should match: monitor()=&quot; INTPTR_FORMAT
1842             &quot;, mid=&quot; INTPTR_FORMAT, p2i(mark.monitor()), p2i(mid));
1843   const markWord dmw = mid-&gt;header();
1844   guarantee(dmw.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, dmw.value());
1845 
1846   if (mid-&gt;is_busy()) {
<span class="line-added">1847     // Easy checks are first - the ObjectMonitor is busy so no deflation.</span>
1848     deflated = false;
1849   } else {
1850     // Deflate the monitor if it is no longer being used
1851     // It&#39;s idle - scavenge and return to the global free list
1852     // plain old deflation ...
1853     if (log_is_enabled(Trace, monitorinflation)) {
1854       ResourceMark rm;
1855       log_trace(monitorinflation)(&quot;deflate_monitor: &quot;
1856                                   &quot;object=&quot; INTPTR_FORMAT &quot;, mark=&quot;
1857                                   INTPTR_FORMAT &quot;, type=&#39;%s&#39;&quot;, p2i(obj),
1858                                   mark.value(), obj-&gt;klass()-&gt;external_name());
1859     }
1860 
1861     // Restore the header back to obj
1862     obj-&gt;release_set_mark(dmw);
1863     mid-&gt;clear();
1864 
1865     assert(mid-&gt;object() == NULL, &quot;invariant: object=&quot; INTPTR_FORMAT,
1866            p2i(mid-&gt;object()));
1867 
1868     // Move the deflated ObjectMonitor to the working free list
1869     // defined by free_head_p and free_tail_p.
1870     if (*free_head_p == NULL) *free_head_p = mid;
1871     if (*free_tail_p != NULL) {
1872       // We append to the list so the caller can use mid-&gt;_next_om
1873       // to fix the linkages in its context.
1874       ObjectMonitor* prevtail = *free_tail_p;
1875       // Should have been cleaned up by the caller:
<span class="line-modified">1876       // Note: Should not have to lock prevtail here since we&#39;re at a</span>
<span class="line-modified">1877       // safepoint and ObjectMonitors on the local free list should</span>
<span class="line-added">1878       // not be accessed in parallel.</span>
<span class="line-added">1879 #ifdef ASSERT</span>
<span class="line-added">1880       ObjectMonitor* l_next_om = prevtail-&gt;next_om();</span>
<span class="line-added">1881 #endif</span>
<span class="line-added">1882       assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">1883       prevtail-&gt;set_next_om(mid);</span>
1884     }
1885     *free_tail_p = mid;
1886     // At this point, mid-&gt;_next_om still refers to its current
1887     // value and another ObjectMonitor&#39;s _next_om field still
1888     // refers to this ObjectMonitor. Those linkages have to be
1889     // cleaned up by the caller who has the complete context.
1890     deflated = true;
1891   }
1892   return deflated;
1893 }
1894 
<span class="line-modified">1895 // Walk a given monitor list, and deflate idle monitors.</span>
<span class="line-modified">1896 // The given list could be a per-thread list or a global list.</span>

1897 //
1898 // In the case of parallel processing of thread local monitor lists,
1899 // work is done by Threads::parallel_threads_do() which ensures that
1900 // each Java thread is processed by exactly one worker thread, and
1901 // thus avoid conflicts that would arise when worker threads would
1902 // process the same monitor lists concurrently.
1903 //
1904 // See also ParallelSPCleanupTask and
1905 // SafepointSynchronize::do_cleanup_tasks() in safepoint.cpp and
1906 // Threads::parallel_java_threads_do() in thread.cpp.
1907 int ObjectSynchronizer::deflate_monitor_list(ObjectMonitor** list_p,
<span class="line-added">1908                                              int* count_p,</span>
1909                                              ObjectMonitor** free_head_p,
1910                                              ObjectMonitor** free_tail_p) {


1911   ObjectMonitor* cur_mid_in_use = NULL;
<span class="line-added">1912   ObjectMonitor* mid = NULL;</span>
<span class="line-added">1913   ObjectMonitor* next = NULL;</span>
1914   int deflated_count = 0;
1915 
<span class="line-modified">1916   // This list walk executes at a safepoint and does not race with any</span>
<span class="line-added">1917   // other list walkers.</span>
<span class="line-added">1918 </span>
<span class="line-added">1919   for (mid = Atomic::load(list_p); mid != NULL; mid = next) {</span>
<span class="line-added">1920     next = unmarked_next(mid);</span>
1921     oop obj = (oop) mid-&gt;object();
1922     if (obj != NULL &amp;&amp; deflate_monitor(mid, obj, free_head_p, free_tail_p)) {
1923       // Deflation succeeded and already updated free_head_p and
1924       // free_tail_p as needed. Finish the move to the local free list
1925       // by unlinking mid from the global or per-thread in-use list.
<span class="line-modified">1926       if (cur_mid_in_use == NULL) {</span>
<span class="line-modified">1927         // mid is the list head so switch the list head to next:</span>
<span class="line-modified">1928         Atomic::store(list_p, next);</span>
<span class="line-modified">1929       } else {</span>
<span class="line-added">1930         // Switch cur_mid_in_use&#39;s next field to next:</span>
<span class="line-added">1931         cur_mid_in_use-&gt;set_next_om(next);</span>
1932       }
<span class="line-modified">1933       // At this point mid is disconnected from the in-use list.</span>


1934       deflated_count++;
<span class="line-added">1935       Atomic::dec(count_p);</span>
<span class="line-added">1936       // mid is current tail in the free_head_p list so NULL terminate it:</span>
<span class="line-added">1937       mid-&gt;set_next_om(NULL);</span>
1938     } else {
1939       cur_mid_in_use = mid;

1940     }
1941   }
1942   return deflated_count;
1943 }
1944 
1945 void ObjectSynchronizer::prepare_deflate_idle_monitors(DeflateMonitorCounters* counters) {
1946   counters-&gt;n_in_use = 0;              // currently associated with objects
1947   counters-&gt;n_in_circulation = 0;      // extant
1948   counters-&gt;n_scavenged = 0;           // reclaimed (global and per-thread)
1949   counters-&gt;per_thread_scavenged = 0;  // per-thread scavenge total
1950   counters-&gt;per_thread_times = 0.0;    // per-thread scavenge times
1951 }
1952 
1953 void ObjectSynchronizer::deflate_idle_monitors(DeflateMonitorCounters* counters) {
1954   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
1955   bool deflated = false;
1956 
1957   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
1958   ObjectMonitor* free_tail_p = NULL;
1959   elapsedTimer timer;
1960 
1961   if (log_is_enabled(Info, monitorinflation)) {
1962     timer.start();
1963   }
1964 





1965   // Note: the thread-local monitors lists get deflated in
1966   // a separate pass. See deflate_thread_local_monitors().
1967 
<span class="line-modified">1968   // For moribund threads, scan om_list_globals._in_use_list</span>
1969   int deflated_count = 0;
<span class="line-modified">1970   if (Atomic::load(&amp;om_list_globals._in_use_list) != NULL) {</span>
<span class="line-modified">1971     // Update n_in_circulation before om_list_globals._in_use_count is</span>
<span class="line-modified">1972     // updated by deflation.</span>
<span class="line-modified">1973     Atomic::add(&amp;counters-&gt;n_in_circulation,</span>
<span class="line-modified">1974                 Atomic::load(&amp;om_list_globals._in_use_count));</span>
<span class="line-modified">1975 </span>
<span class="line-added">1976     deflated_count = deflate_monitor_list(&amp;om_list_globals._in_use_list,</span>
<span class="line-added">1977                                           &amp;om_list_globals._in_use_count,</span>
<span class="line-added">1978                                           &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-added">1979     Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;om_list_globals._in_use_count));</span>
1980   }
1981 
1982   if (free_head_p != NULL) {
1983     // Move the deflated ObjectMonitors back to the global free list.
<span class="line-modified">1984     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);</span>
<span class="line-modified">1985 #ifdef ASSERT</span>
<span class="line-modified">1986     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-modified">1987 #endif</span>
<span class="line-modified">1988     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-added">1989     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">1990     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
1991   }

1992   timer.stop();
1993 
1994   LogStreamHandle(Debug, monitorinflation) lsh_debug;
1995   LogStreamHandle(Info, monitorinflation) lsh_info;
1996   LogStream* ls = NULL;
1997   if (log_is_enabled(Debug, monitorinflation)) {
1998     ls = &amp;lsh_debug;
1999   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
2000     ls = &amp;lsh_info;
2001   }
2002   if (ls != NULL) {
2003     ls-&gt;print_cr(&quot;deflating global idle monitors, %3.7f secs, %d monitors&quot;, timer.seconds(), deflated_count);
2004   }
2005 }
2006 
2007 void ObjectSynchronizer::finish_deflate_idle_monitors(DeflateMonitorCounters* counters) {
2008   // Report the cumulative time for deflating each thread&#39;s idle
2009   // monitors. Note: if the work is split among more than one
2010   // worker thread, then the reported time will likely be more
2011   // than a beginning to end measurement of the phase.
2012   log_info(safepoint, cleanup)(&quot;deflating per-thread idle monitors, %3.7f secs, monitors=%d&quot;, counters-&gt;per_thread_times, counters-&gt;per_thread_scavenged);
2013 


2014   if (log_is_enabled(Debug, monitorinflation)) {
2015     // exit_globals()&#39;s call to audit_and_print_stats() is done
<span class="line-modified">2016     // at the Info level and not at a safepoint.</span>
2017     ObjectSynchronizer::audit_and_print_stats(false /* on_exit */);
2018   } else if (log_is_enabled(Info, monitorinflation)) {
<span class="line-modified">2019     log_info(monitorinflation)(&quot;global_population=%d, global_in_use_count=%d, &quot;</span>
<span class="line-modified">2020                                &quot;global_free_count=%d&quot;,</span>
<span class="line-modified">2021                                Atomic::load(&amp;om_list_globals._population),</span>
<span class="line-modified">2022                                Atomic::load(&amp;om_list_globals._in_use_count),</span>
<span class="line-modified">2023                                Atomic::load(&amp;om_list_globals._free_count));</span>
2024   }
2025 
2026   Atomic::store(&amp;_forceMonitorScavenge, 0);    // Reset
2027 
2028   OM_PERFDATA_OP(Deflations, inc(counters-&gt;n_scavenged));
2029   OM_PERFDATA_OP(MonExtant, set_value(counters-&gt;n_in_circulation));
2030 
2031   GVars.stw_random = os::random();
2032   GVars.stw_cycle++;
2033 }
2034 
2035 void ObjectSynchronizer::deflate_thread_local_monitors(Thread* thread, DeflateMonitorCounters* counters) {
2036   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2037 
2038   ObjectMonitor* free_head_p = NULL;  // Local SLL of scavenged monitors
2039   ObjectMonitor* free_tail_p = NULL;
2040   elapsedTimer timer;
2041 
2042   if (log_is_enabled(Info, safepoint, cleanup) ||
2043       log_is_enabled(Info, monitorinflation)) {
2044     timer.start();
2045   }
2046 
<span class="line-modified">2047   // Update n_in_circulation before om_in_use_count is updated by deflation.</span>
<span class="line-modified">2048   Atomic::add(&amp;counters-&gt;n_in_circulation, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>

2049 
<span class="line-modified">2050   int deflated_count = deflate_monitor_list(&amp;thread-&gt;om_in_use_list, &amp;thread-&gt;om_in_use_count, &amp;free_head_p, &amp;free_tail_p);</span>
<span class="line-modified">2051   Atomic::add(&amp;counters-&gt;n_in_use, Atomic::load(&amp;thread-&gt;om_in_use_count));</span>




2052 
2053   if (free_head_p != NULL) {
2054     // Move the deflated ObjectMonitors back to the global free list.
2055     guarantee(free_tail_p != NULL &amp;&amp; deflated_count &gt; 0, &quot;invariant&quot;);
<span class="line-modified">2056 #ifdef ASSERT</span>
<span class="line-modified">2057     ObjectMonitor* l_next_om = free_tail_p-&gt;next_om();</span>
<span class="line-modified">2058 #endif</span>
<span class="line-modified">2059     assert(l_next_om == NULL, &quot;must be NULL: _next_om=&quot; INTPTR_FORMAT, p2i(l_next_om));</span>
<span class="line-modified">2060     prepend_list_to_global_free_list(free_head_p, free_tail_p, deflated_count);</span>
<span class="line-added">2061     Atomic::add(&amp;counters-&gt;n_scavenged, deflated_count);</span>
<span class="line-added">2062     Atomic::add(&amp;counters-&gt;per_thread_scavenged, deflated_count);</span>
2063   }
2064 
2065   timer.stop();



2066   counters-&gt;per_thread_times += timer.seconds();
2067 


2068   LogStreamHandle(Debug, monitorinflation) lsh_debug;
2069   LogStreamHandle(Info, monitorinflation) lsh_info;
2070   LogStream* ls = NULL;
2071   if (log_is_enabled(Debug, monitorinflation)) {
2072     ls = &amp;lsh_debug;
2073   } else if (deflated_count != 0 &amp;&amp; log_is_enabled(Info, monitorinflation)) {
2074     ls = &amp;lsh_info;
2075   }
2076   if (ls != NULL) {
2077     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);
2078   }
2079 }
2080 
2081 // Monitor cleanup on JavaThread::exit
2082 
2083 // Iterate through monitor cache and attempt to release thread&#39;s monitors
2084 // Gives up on a particular monitor if an exception occurs, but continues
2085 // the overall iteration, swallowing the exception.
2086 class ReleaseJavaMonitorsClosure: public MonitorClosure {
2087  private:
</pre>
<hr />
<pre>
2098 
2099 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
2100 // ignored.  This is meant to be called during JNI thread detach which assumes
2101 // all remaining monitors are heavyweight.  All exceptions are swallowed.
2102 // Scanning the extant monitor list can be time consuming.
2103 // A simple optimization is to add a per-thread flag that indicates a thread
2104 // called jni_monitorenter() during its lifetime.
2105 //
2106 // Instead of No_Savepoint_Verifier it might be cheaper to
2107 // use an idiom of the form:
2108 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
2109 //   &lt;code that must not run at safepoint&gt;
2110 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
2111 // Since the tests are extremely cheap we could leave them enabled
2112 // for normal product builds.
2113 
2114 void ObjectSynchronizer::release_monitors_owned_by_thread(TRAPS) {
2115   assert(THREAD == JavaThread::current(), &quot;must be current Java thread&quot;);
2116   NoSafepointVerifier nsv;
2117   ReleaseJavaMonitorsClosure rjmc(THREAD);

2118   ObjectSynchronizer::monitors_iterate(&amp;rjmc);

2119   THREAD-&gt;clear_pending_exception();
2120 }
2121 
2122 const char* ObjectSynchronizer::inflate_cause_name(const InflateCause cause) {
2123   switch (cause) {
2124     case inflate_cause_vm_internal:    return &quot;VM Internal&quot;;
2125     case inflate_cause_monitor_enter:  return &quot;Monitor Enter&quot;;
2126     case inflate_cause_wait:           return &quot;Monitor Wait&quot;;
2127     case inflate_cause_notify:         return &quot;Monitor Notify&quot;;
2128     case inflate_cause_hash_code:      return &quot;Monitor Hash Code&quot;;
2129     case inflate_cause_jni_enter:      return &quot;JNI Monitor Enter&quot;;
2130     case inflate_cause_jni_exit:       return &quot;JNI Monitor Exit&quot;;
2131     default:
2132       ShouldNotReachHere();
2133   }
2134   return &quot;Unknown&quot;;
2135 }
2136 
2137 //------------------------------------------------------------------------------
2138 // Debugging code
2139 
2140 u_char* ObjectSynchronizer::get_gvars_addr() {
2141   return (u_char*)&amp;GVars;
2142 }
2143 
2144 u_char* ObjectSynchronizer::get_gvars_hc_sequence_addr() {
2145   return (u_char*)&amp;GVars.hc_sequence;
2146 }
2147 
2148 size_t ObjectSynchronizer::get_gvars_size() {
2149   return sizeof(SharedGlobals);
2150 }
2151 
2152 u_char* ObjectSynchronizer::get_gvars_stw_random_addr() {
2153   return (u_char*)&amp;GVars.stw_random;
2154 }
2155 
<span class="line-added">2156 // This function can be called at a safepoint or it can be called when</span>
<span class="line-added">2157 // we are trying to exit the VM. When we are trying to exit the VM, the</span>
<span class="line-added">2158 // list walker functions can run in parallel with the other list</span>
<span class="line-added">2159 // operations so spin-locking is used for safety.</span>
<span class="line-added">2160 //</span>
<span class="line-added">2161 // Calls to this function can be added in various places as a debugging</span>
<span class="line-added">2162 // aid; pass &#39;true&#39; for the &#39;on_exit&#39; parameter to have in-use monitor</span>
<span class="line-added">2163 // details logged at the Info level and &#39;false&#39; for the &#39;on_exit&#39;</span>
<span class="line-added">2164 // parameter to have in-use monitor details logged at the Trace level.</span>
<span class="line-added">2165 // deflate_monitor_list() no longer uses spin-locking so be careful</span>
<span class="line-added">2166 // when adding audit_and_print_stats() calls at a safepoint.</span>
<span class="line-added">2167 //</span>
2168 void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {
2169   assert(on_exit || SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;);
2170 
2171   LogStreamHandle(Debug, monitorinflation) lsh_debug;
2172   LogStreamHandle(Info, monitorinflation) lsh_info;
2173   LogStreamHandle(Trace, monitorinflation) lsh_trace;
2174   LogStream* ls = NULL;
2175   if (log_is_enabled(Trace, monitorinflation)) {
2176     ls = &amp;lsh_trace;
2177   } else if (log_is_enabled(Debug, monitorinflation)) {
2178     ls = &amp;lsh_debug;
2179   } else if (log_is_enabled(Info, monitorinflation)) {
2180     ls = &amp;lsh_info;
2181   }
2182   assert(ls != NULL, &quot;sanity check&quot;);
2183 





2184   // Log counts for the global and per-thread monitor lists:
2185   int chk_om_population = log_monitor_list_counts(ls);
2186   int error_cnt = 0;
2187 
2188   ls-&gt;print_cr(&quot;Checking global lists:&quot;);
2189 
<span class="line-modified">2190   // Check om_list_globals._population:</span>
<span class="line-modified">2191   if (Atomic::load(&amp;om_list_globals._population) == chk_om_population) {</span>
<span class="line-modified">2192     ls-&gt;print_cr(&quot;global_population=%d equals chk_om_population=%d&quot;,</span>
<span class="line-modified">2193                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
2194   } else {
<span class="line-modified">2195     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">2196     // log_monitor_list_counts() to return a value that doesn&#39;t match</span>
<span class="line-modified">2197     // om_list_globals._population. So far a higher value has been</span>
<span class="line-modified">2198     // seen in testing so something is being double counted by</span>
<span class="line-added">2199     // log_monitor_list_counts().</span>
<span class="line-added">2200     ls-&gt;print_cr(&quot;WARNING: global_population=%d is not equal to &quot;</span>
<span class="line-added">2201                  &quot;chk_om_population=%d&quot;,</span>
<span class="line-added">2202                  Atomic::load(&amp;om_list_globals._population), chk_om_population);</span>
2203   }
2204 
<span class="line-modified">2205   // Check om_list_globals._in_use_list and om_list_globals._in_use_count:</span>
2206   chk_global_in_use_list_and_count(ls, &amp;error_cnt);
2207 
<span class="line-modified">2208   // Check om_list_globals._free_list and om_list_globals._free_count:</span>
2209   chk_global_free_list_and_count(ls, &amp;error_cnt);
2210 




2211   ls-&gt;print_cr(&quot;Checking per-thread lists:&quot;);
2212 
2213   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
2214     // Check om_in_use_list and om_in_use_count:
2215     chk_per_thread_in_use_list_and_count(jt, ls, &amp;error_cnt);
2216 
2217     // Check om_free_list and om_free_count:
2218     chk_per_thread_free_list_and_count(jt, ls, &amp;error_cnt);
2219   }
2220 
2221   if (error_cnt == 0) {
2222     ls-&gt;print_cr(&quot;No errors found in monitor list checks.&quot;);
2223   } else {
2224     log_error(monitorinflation)(&quot;found monitor list errors: error_cnt=%d&quot;, error_cnt);
2225   }
2226 
2227   if ((on_exit &amp;&amp; log_is_enabled(Info, monitorinflation)) ||
2228       (!on_exit &amp;&amp; log_is_enabled(Trace, monitorinflation))) {
2229     // When exiting this log output is at the Info level. When called
2230     // at a safepoint, this log output is at the Trace level since
2231     // there can be a lot of it.
<span class="line-modified">2232     log_in_use_monitor_details(ls);</span>
2233   }
2234 
2235   ls-&gt;flush();
2236 
2237   guarantee(error_cnt == 0, &quot;ERROR: found monitor list errors: error_cnt=%d&quot;, error_cnt);
2238 }
2239 
2240 // Check a free monitor entry; log any errors.
2241 void ObjectSynchronizer::chk_free_entry(JavaThread* jt, ObjectMonitor* n,
2242                                         outputStream * out, int *error_cnt_p) {
2243   stringStream ss;
2244   if (n-&gt;is_busy()) {
2245     if (jt != NULL) {
2246       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2247                     &quot;: free per-thread monitor must not be busy: %s&quot;, p2i(jt),
2248                     p2i(n), n-&gt;is_busy_to_string(&amp;ss));
2249     } else {
2250       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
2251                     &quot;must not be busy: %s&quot;, p2i(n), n-&gt;is_busy_to_string(&amp;ss));
2252     }
</pre>
<hr />
<pre>
2263                     &quot;must have NULL _header field: _header=&quot; INTPTR_FORMAT,
2264                     p2i(n), n-&gt;header().value());
2265     }
2266     *error_cnt_p = *error_cnt_p + 1;
2267   }
2268   if (n-&gt;object() != NULL) {
2269     if (jt != NULL) {
2270       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2271                     &quot;: free per-thread monitor must have NULL _object &quot;
2272                     &quot;field: _object=&quot; INTPTR_FORMAT, p2i(jt), p2i(n),
2273                     p2i(n-&gt;object()));
2274     } else {
2275       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: free global monitor &quot;
2276                     &quot;must have NULL _object field: _object=&quot; INTPTR_FORMAT,
2277                     p2i(n), p2i(n-&gt;object()));
2278     }
2279     *error_cnt_p = *error_cnt_p + 1;
2280   }
2281 }
2282 
<span class="line-added">2283 // Lock the next ObjectMonitor for traversal and unlock the current</span>
<span class="line-added">2284 // ObjectMonitor. Returns the next ObjectMonitor if there is one.</span>
<span class="line-added">2285 // Otherwise returns NULL (after unlocking the current ObjectMonitor).</span>
<span class="line-added">2286 // This function is used by the various list walker functions to</span>
<span class="line-added">2287 // safely walk a list without allowing an ObjectMonitor to be moved</span>
<span class="line-added">2288 // to another list in the middle of a walk.</span>
<span class="line-added">2289 static ObjectMonitor* lock_next_for_traversal(ObjectMonitor* cur) {</span>
<span class="line-added">2290   assert(is_locked(cur), &quot;cur=&quot; INTPTR_FORMAT &quot; must be locked&quot;, p2i(cur));</span>
<span class="line-added">2291   ObjectMonitor* next = unmarked_next(cur);</span>
<span class="line-added">2292   if (next == NULL) {  // Reached the end of the list.</span>
<span class="line-added">2293     om_unlock(cur);</span>
<span class="line-added">2294     return NULL;</span>
<span class="line-added">2295   }</span>
<span class="line-added">2296   om_lock(next);   // Lock next before unlocking current to keep</span>
<span class="line-added">2297   om_unlock(cur);  // from being by-passed by another thread.</span>
<span class="line-added">2298   return next;</span>
<span class="line-added">2299 }</span>
<span class="line-added">2300 </span>
2301 // Check the global free list and count; log the results of the checks.
2302 void ObjectSynchronizer::chk_global_free_list_and_count(outputStream * out,
2303                                                         int *error_cnt_p) {
2304   int chk_om_free_count = 0;
<span class="line-modified">2305   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2306   if ((cur = get_list_head_locked(&amp;om_list_globals._free_list)) != NULL) {</span>
<span class="line-modified">2307     // Marked the global free list head so process the list.</span>
<span class="line-added">2308     while (true) {</span>
<span class="line-added">2309       chk_free_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-added">2310       chk_om_free_count++;</span>
<span class="line-added">2311 </span>
<span class="line-added">2312       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2313       if (cur == NULL) {</span>
<span class="line-added">2314         break;</span>
<span class="line-added">2315       }</span>
<span class="line-added">2316     }</span>
2317   }
<span class="line-modified">2318   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">2319   if (l_free_count == chk_om_free_count) {</span>
<span class="line-modified">2320     out-&gt;print_cr(&quot;global_free_count=%d equals chk_om_free_count=%d&quot;,</span>
<span class="line-added">2321                   l_free_count, chk_om_free_count);</span>
2322   } else {
<span class="line-modified">2323     // With fine grained locks on om_list_globals._free_list, it</span>
<span class="line-modified">2324     // is possible for an ObjectMonitor to be prepended to</span>
<span class="line-modified">2325     // om_list_globals._free_list after we started calculating</span>
<span class="line-modified">2326     // chk_om_free_count so om_list_globals._free_count may not</span>
<span class="line-added">2327     // match anymore.</span>
<span class="line-added">2328     out-&gt;print_cr(&quot;WARNING: global_free_count=%d is not equal to &quot;</span>
<span class="line-added">2329                   &quot;chk_om_free_count=%d&quot;, l_free_count, chk_om_free_count);</span>
2330   }
2331 }
2332 
2333 // Check the global in-use list and count; log the results of the checks.
2334 void ObjectSynchronizer::chk_global_in_use_list_and_count(outputStream * out,
2335                                                           int *error_cnt_p) {
2336   int chk_om_in_use_count = 0;
<span class="line-modified">2337   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2338   if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">2339     // Marked the global in-use list head so process the list.</span>
<span class="line-added">2340     while (true) {</span>
<span class="line-added">2341       chk_in_use_entry(NULL /* jt */, cur, out, error_cnt_p);</span>
<span class="line-added">2342       chk_om_in_use_count++;</span>
<span class="line-added">2343 </span>
<span class="line-added">2344       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2345       if (cur == NULL) {</span>
<span class="line-added">2346         break;</span>
<span class="line-added">2347       }</span>
<span class="line-added">2348     }</span>
2349   }
<span class="line-modified">2350   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-modified">2351   if (l_in_use_count == chk_om_in_use_count) {</span>
<span class="line-modified">2352     out-&gt;print_cr(&quot;global_in_use_count=%d equals chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">2353                   l_in_use_count, chk_om_in_use_count);</span>
2354   } else {
<span class="line-modified">2355     // With fine grained locks on the monitor lists, it is possible for</span>
<span class="line-modified">2356     // an exiting JavaThread to put its in-use ObjectMonitors on the</span>
<span class="line-modified">2357     // global in-use list after chk_om_in_use_count is calculated above.</span>
<span class="line-added">2358     out-&gt;print_cr(&quot;WARNING: global_in_use_count=%d is not equal to chk_om_in_use_count=%d&quot;,</span>
<span class="line-added">2359                   l_in_use_count, chk_om_in_use_count);</span>
2360   }
2361 }
2362 
2363 // Check an in-use monitor entry; log any errors.
2364 void ObjectSynchronizer::chk_in_use_entry(JavaThread* jt, ObjectMonitor* n,
2365                                           outputStream * out, int *error_cnt_p) {
2366   if (n-&gt;header().value() == 0) {
2367     if (jt != NULL) {
2368       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2369                     &quot;: in-use per-thread monitor must have non-NULL _header &quot;
2370                     &quot;field.&quot;, p2i(jt), p2i(n));
2371     } else {
2372       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global monitor &quot;
2373                     &quot;must have non-NULL _header field.&quot;, p2i(n));
2374     }
2375     *error_cnt_p = *error_cnt_p + 1;
2376   }
2377   if (n-&gt;object() == NULL) {
2378     if (jt != NULL) {
2379       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
</pre>
<hr />
<pre>
2407       out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;, monitor=&quot; INTPTR_FORMAT
2408                     &quot;: in-use per-thread monitor&#39;s object does not refer &quot;
2409                     &quot;to the same monitor: obj=&quot; INTPTR_FORMAT &quot;, mark=&quot;
2410                     INTPTR_FORMAT &quot;, obj_mon=&quot; INTPTR_FORMAT, p2i(jt),
2411                     p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
2412     } else {
2413       out-&gt;print_cr(&quot;ERROR: monitor=&quot; INTPTR_FORMAT &quot;: in-use global &quot;
2414                     &quot;monitor&#39;s object does not refer to the same monitor: obj=&quot;
2415                     INTPTR_FORMAT &quot;, mark=&quot; INTPTR_FORMAT &quot;, obj_mon=&quot;
2416                     INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));
2417     }
2418     *error_cnt_p = *error_cnt_p + 1;
2419   }
2420 }
2421 
2422 // Check the thread&#39;s free list and count; log the results of the checks.
2423 void ObjectSynchronizer::chk_per_thread_free_list_and_count(JavaThread *jt,
2424                                                             outputStream * out,
2425                                                             int *error_cnt_p) {
2426   int chk_om_free_count = 0;
<span class="line-modified">2427   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2428   if ((cur = get_list_head_locked(&amp;jt-&gt;om_free_list)) != NULL) {</span>
<span class="line-modified">2429     // Marked the per-thread free list head so process the list.</span>
<span class="line-added">2430     while (true) {</span>
<span class="line-added">2431       chk_free_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-added">2432       chk_om_free_count++;</span>
<span class="line-added">2433 </span>
<span class="line-added">2434       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2435       if (cur == NULL) {</span>
<span class="line-added">2436         break;</span>
<span class="line-added">2437       }</span>
<span class="line-added">2438     }</span>
2439   }
<span class="line-modified">2440   int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
<span class="line-added">2441   if (l_om_free_count == chk_om_free_count) {</span>
2442     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d equals &quot;
<span class="line-modified">2443                   &quot;chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count, chk_om_free_count);</span>
2444   } else {
2445     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_free_count=%d is not &quot;
<span class="line-modified">2446                   &quot;equal to chk_om_free_count=%d&quot;, p2i(jt), l_om_free_count,</span>
2447                   chk_om_free_count);
2448     *error_cnt_p = *error_cnt_p + 1;
2449   }
2450 }
2451 
2452 // Check the thread&#39;s in-use list and count; log the results of the checks.
2453 void ObjectSynchronizer::chk_per_thread_in_use_list_and_count(JavaThread *jt,
2454                                                               outputStream * out,
2455                                                               int *error_cnt_p) {
2456   int chk_om_in_use_count = 0;
<span class="line-modified">2457   ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2458   if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">2459     // Marked the per-thread in-use list head so process the list.</span>
<span class="line-added">2460     while (true) {</span>
<span class="line-added">2461       chk_in_use_entry(jt, cur, out, error_cnt_p);</span>
<span class="line-added">2462       chk_om_in_use_count++;</span>
<span class="line-added">2463 </span>
<span class="line-added">2464       cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2465       if (cur == NULL) {</span>
<span class="line-added">2466         break;</span>
<span class="line-added">2467       }</span>
<span class="line-added">2468     }</span>
2469   }
<span class="line-modified">2470   int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">2471   if (l_om_in_use_count == chk_om_in_use_count) {</span>
2472     out-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d equals &quot;
<span class="line-modified">2473                   &quot;chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
2474                   chk_om_in_use_count);
2475   } else {
2476     out-&gt;print_cr(&quot;ERROR: jt=&quot; INTPTR_FORMAT &quot;: om_in_use_count=%d is not &quot;
<span class="line-modified">2477                   &quot;equal to chk_om_in_use_count=%d&quot;, p2i(jt), l_om_in_use_count,</span>
2478                   chk_om_in_use_count);
2479     *error_cnt_p = *error_cnt_p + 1;
2480   }
2481 }
2482 
2483 // Log details about ObjectMonitors on the in-use lists. The &#39;BHL&#39;
2484 // flags indicate why the entry is in-use, &#39;object&#39; and &#39;object type&#39;
2485 // indicate the associated object and its type.
<span class="line-modified">2486 void ObjectSynchronizer::log_in_use_monitor_details(outputStream * out) {</span>






2487   stringStream ss;
<span class="line-modified">2488   if (Atomic::load(&amp;om_list_globals._in_use_count) &gt; 0) {</span>
2489     out-&gt;print_cr(&quot;In-use global monitor info:&quot;);
2490     out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);
2491     out-&gt;print_cr(&quot;%18s  %s  %18s  %18s&quot;,
2492                   &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2493     out-&gt;print_cr(&quot;==================  ===  ==================  ==================&quot;);
<span class="line-modified">2494     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2495     if ((cur = get_list_head_locked(&amp;om_list_globals._in_use_list)) != NULL) {</span>
<span class="line-modified">2496       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">2497       while (true) {</span>
<span class="line-modified">2498         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">2499         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">2500         ResourceMark rm;</span>
<span class="line-modified">2501         out-&gt;print(INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT &quot;  %s&quot;, p2i(cur),</span>
<span class="line-modified">2502                    cur-&gt;is_busy() != 0, mark.hash() != 0, cur-&gt;owner() != NULL,</span>
<span class="line-modified">2503                    p2i(obj), obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">2504         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">2505           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">2506           ss.reset();</span>
<span class="line-added">2507         }</span>
<span class="line-added">2508         out-&gt;cr();</span>
<span class="line-added">2509 </span>
<span class="line-added">2510         cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2511         if (cur == NULL) {</span>
<span class="line-added">2512           break;</span>
<span class="line-added">2513         }</span>
2514       }

2515     }
2516   }
2517 




2518   out-&gt;print_cr(&quot;In-use per-thread monitor info:&quot;);
2519   out-&gt;print_cr(&quot;(B -&gt; is_busy, H -&gt; has hash code, L -&gt; lock status)&quot;);
2520   out-&gt;print_cr(&quot;%18s  %18s  %s  %18s  %18s&quot;,
2521                 &quot;jt&quot;, &quot;monitor&quot;, &quot;BHL&quot;, &quot;object&quot;, &quot;object type&quot;);
2522   out-&gt;print_cr(&quot;==================  ==================  ===  ==================  ==================&quot;);
2523   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-modified">2524     ObjectMonitor* cur = NULL;</span>
<span class="line-modified">2525     if ((cur = get_list_head_locked(&amp;jt-&gt;om_in_use_list)) != NULL) {</span>
<span class="line-modified">2526       // Marked the global in-use list head so process the list.</span>
<span class="line-modified">2527       while (true) {</span>
<span class="line-modified">2528         const oop obj = (oop) cur-&gt;object();</span>
<span class="line-modified">2529         const markWord mark = cur-&gt;header();</span>
<span class="line-modified">2530         ResourceMark rm;</span>
<span class="line-modified">2531         out-&gt;print(INTPTR_FORMAT &quot;  &quot; INTPTR_FORMAT &quot;  %d%d%d  &quot; INTPTR_FORMAT</span>
<span class="line-modified">2532                    &quot;  %s&quot;, p2i(jt), p2i(cur), cur-&gt;is_busy() != 0,</span>
<span class="line-modified">2533                    mark.hash() != 0, cur-&gt;owner() != NULL, p2i(obj),</span>
<span class="line-modified">2534                    obj-&gt;klass()-&gt;external_name());</span>
<span class="line-added">2535         if (cur-&gt;is_busy() != 0) {</span>
<span class="line-added">2536           out-&gt;print(&quot; (%s)&quot;, cur-&gt;is_busy_to_string(&amp;ss));</span>
<span class="line-added">2537           ss.reset();</span>
<span class="line-added">2538         }</span>
<span class="line-added">2539         out-&gt;cr();</span>
<span class="line-added">2540 </span>
<span class="line-added">2541         cur = lock_next_for_traversal(cur);</span>
<span class="line-added">2542         if (cur == NULL) {</span>
<span class="line-added">2543           break;</span>
<span class="line-added">2544         }</span>
2545       }

2546     }
2547   }
2548 
2549   out-&gt;flush();
2550 }
2551 
2552 // Log counts for the global and per-thread monitor lists and return
2553 // the population count.
2554 int ObjectSynchronizer::log_monitor_list_counts(outputStream * out) {
2555   int pop_count = 0;
2556   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2557                 &quot;Global Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Total&quot;);
2558   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
<span class="line-modified">2559   int l_in_use_count = Atomic::load(&amp;om_list_globals._in_use_count);</span>
<span class="line-modified">2560   int l_free_count = Atomic::load(&amp;om_list_globals._free_count);</span>
<span class="line-modified">2561   out-&gt;print_cr(&quot;%18s  %10d  %10d  %10d&quot;, &quot;&quot;, l_in_use_count,</span>
<span class="line-added">2562                 l_free_count, Atomic::load(&amp;om_list_globals._population));</span>
<span class="line-added">2563   pop_count += l_in_use_count + l_free_count;</span>
2564 
2565   out-&gt;print_cr(&quot;%18s  %10s  %10s  %10s&quot;,
2566                 &quot;Per-Thread Lists:&quot;, &quot;InUse&quot;, &quot;Free&quot;, &quot;Provision&quot;);
2567   out-&gt;print_cr(&quot;==================  ==========  ==========  ==========&quot;);
2568 
2569   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {
<span class="line-added">2570     int l_om_in_use_count = Atomic::load(&amp;jt-&gt;om_in_use_count);</span>
<span class="line-added">2571     int l_om_free_count = Atomic::load(&amp;jt-&gt;om_free_count);</span>
2572     out-&gt;print_cr(INTPTR_FORMAT &quot;  %10d  %10d  %10d&quot;, p2i(jt),
<span class="line-modified">2573                   l_om_in_use_count, l_om_free_count, jt-&gt;om_free_provision);</span>
<span class="line-modified">2574     pop_count += l_om_in_use_count + l_om_free_count;</span>
2575   }
2576   return pop_count;
2577 }
2578 
2579 #ifndef PRODUCT
2580 
2581 // Check if monitor belongs to the monitor cache
2582 // The list is grow-only so it&#39;s *relatively* safe to traverse
2583 // the list of extant blocks without taking a lock.
2584 
2585 int ObjectSynchronizer::verify_objmon_isinpool(ObjectMonitor *monitor) {
<span class="line-modified">2586   PaddedObjectMonitor* block = Atomic::load(&amp;g_block_list);</span>
2587   while (block != NULL) {
2588     assert(block-&gt;object() == CHAINMARKER, &quot;must be a block header&quot;);
2589     if (monitor &gt; &amp;block[0] &amp;&amp; monitor &lt; &amp;block[_BLOCKSIZE]) {
2590       address mon = (address)monitor;
2591       address blk = (address)block;
2592       size_t diff = mon - blk;
2593       assert((diff % sizeof(PaddedObjectMonitor)) == 0, &quot;must be aligned&quot;);
2594       return 1;
2595     }
<span class="line-modified">2596     // unmarked_next() is not needed with g_block_list (no locking</span>
<span class="line-added">2597     // used with block linkage _next_om fields).</span>
<span class="line-added">2598     block = (PaddedObjectMonitor*)block-&gt;next_om();</span>
2599   }
2600   return 0;
2601 }
2602 
2603 #endif
</pre>
</td>
</tr>
</table>
<center><a href="signature.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>