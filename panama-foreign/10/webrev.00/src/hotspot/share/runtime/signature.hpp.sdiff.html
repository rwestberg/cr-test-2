<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SIGNATURE_HPP
 26 #define SHARE_RUNTIME_SIGNATURE_HPP
 27 

 28 #include &quot;memory/allocation.hpp&quot;
 29 #include &quot;oops/method.hpp&quot;
 30 
<span class="line-modified"> 31 // SignatureIterators iterate over a Java signature (or parts of it).</span>
<span class="line-modified"> 32 // (Syntax according to: &quot;The Java Virtual Machine Specification&quot; by</span>
<span class="line-modified"> 33 // Tim Lindholm &amp; Frank Yellin; section 4.3 Descriptors; p. 89ff.)</span>















 34 //
<span class="line-modified"> 35 // Example: Iterating over ([Lfoo;D)I using</span>
<span class="line-modified"> 36 //                         0123456789</span>



 37 //
<span class="line-modified"> 38 // iterate_parameters() calls: do_array(2, 7); do_double();</span>
<span class="line-modified"> 39 // iterate_returntype() calls:                              do_int();</span>
<span class="line-modified"> 40 // iterate()            calls: do_array(2, 7); do_double(); do_int();</span>







 41 //
<span class="line-modified"> 42 // is_return_type()        is: false         ; false      ; true</span>





 43 //
<span class="line-modified"> 44 // NOTE: The new optimizer has an alternate, for-loop based signature</span>
<span class="line-modified"> 45 // iterator implemented in opto/type.cpp, TypeTuple::make().</span>


















































































 46 
 47 class SignatureIterator: public ResourceObj {



 48  protected:
 49   Symbol*      _signature;             // the signature to iterate over
<span class="line-removed"> 50   int          _index;                 // the current character index (only valid during iteration)</span>
<span class="line-removed"> 51   int          _parameter_index;       // the current parameter index (0 outside iteration phase)</span>
 52   BasicType    _return_type;
<span class="line-modified"> 53 </span>
<span class="line-removed"> 54   void expect(char c);</span>
<span class="line-removed"> 55   int  parse_type();                   // returns the parameter size in words (0 for void)</span>
<span class="line-removed"> 56   void check_signature_end();</span>
 57 
 58  public:
 59   // Definitions used in generating and iterating the
 60   // bit field form of the signature generated by the
 61   // Fingerprinter.
 62   enum {
<span class="line-modified"> 63     static_feature_size    = 1,</span>
<span class="line-modified"> 64     is_static_bit          = 1,</span>
<span class="line-modified"> 65 </span>
<span class="line-modified"> 66     result_feature_size    = 4,</span>
<span class="line-modified"> 67     result_feature_mask    = 0xF,</span>
<span class="line-modified"> 68     parameter_feature_size = 4,</span>
<span class="line-modified"> 69     parameter_feature_mask = 0xF,</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71       bool_parm            = 1,</span>
<span class="line-modified"> 72       byte_parm            = 2,</span>
<span class="line-modified"> 73       char_parm            = 3,</span>
<span class="line-modified"> 74       short_parm           = 4,</span>
<span class="line-modified"> 75       int_parm             = 5,</span>
<span class="line-modified"> 76       long_parm            = 6,</span>
<span class="line-modified"> 77       float_parm           = 7,</span>
<span class="line-modified"> 78       double_parm          = 8,</span>
<span class="line-modified"> 79       obj_parm             = 9,</span>
<span class="line-modified"> 80       done_parm            = 10,  // marker for end of parameters</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82     // max parameters is wordsize minus</span>
<span class="line-removed"> 83     //    The sign bit, termination field, the result and static bit fields</span>
<span class="line-removed"> 84     max_size_of_parameters = (BitsPerLong-1 -</span>
<span class="line-removed"> 85                               result_feature_size - parameter_feature_size -</span>
<span class="line-removed"> 86                               static_feature_size) / parameter_feature_size</span>
 87   };
 88 











 89   // Constructors
<span class="line-modified"> 90   SignatureIterator(Symbol* signature);</span>














 91 
 92   // Iteration
<span class="line-modified"> 93   void iterate_parameters();           // iterates over parameters only</span>
<span class="line-modified"> 94   void iterate_parameters( uint64_t fingerprint );</span>
<span class="line-modified"> 95   void iterate_returntype();           // iterates over returntype only</span>
<span class="line-modified"> 96   void iterate();                      // iterates over whole signature</span>
<span class="line-modified"> 97   // Returns the word index of the current parameter;</span>
<span class="line-modified"> 98   int  parameter_index() const         { return _parameter_index; }</span>
<span class="line-modified"> 99   bool is_return_type() const          { return parameter_index() &lt; 0; }</span>
<span class="line-modified">100   BasicType get_ret_type() const       { return _return_type; }</span>
<span class="line-modified">101 </span>
<span class="line-modified">102   // Basic types</span>
<span class="line-modified">103   virtual void do_bool  ()             = 0;</span>
<span class="line-modified">104   virtual void do_char  ()             = 0;</span>
<span class="line-modified">105   virtual void do_float ()             = 0;</span>
<span class="line-modified">106   virtual void do_double()             = 0;</span>
<span class="line-modified">107   virtual void do_byte  ()             = 0;</span>
<span class="line-modified">108   virtual void do_short ()             = 0;</span>
<span class="line-modified">109   virtual void do_int   ()             = 0;</span>
<span class="line-modified">110   virtual void do_long  ()             = 0;</span>
<span class="line-modified">111   virtual void do_void  ()             = 0;</span>
<span class="line-modified">112 </span>
<span class="line-modified">113   // Object types (begin indexes the first character of the entry, end indexes the first character after the entry)</span>
<span class="line-modified">114   virtual void do_object(int begin, int end) = 0;</span>
<span class="line-removed">115   virtual void do_array (int begin, int end) = 0;</span>
<span class="line-removed">116 </span>
<span class="line-removed">117   static bool is_static(uint64_t fingerprint) {</span>
<span class="line-removed">118     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-removed">119     return fingerprint &amp; is_static_bit;</span>
120   }
<span class="line-modified">121   static BasicType return_type(uint64_t fingerprint) {</span>
<span class="line-modified">122     assert(fingerprint != (uint64_t)CONST64(-1), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">123     return (BasicType) ((fingerprint &gt;&gt; static_feature_size) &amp; result_feature_mask);</span>





124   }
125 };
126 
127 
128 // Specialized SignatureIterators: Used to compute signature specific values.
129 
130 class SignatureTypeNames : public SignatureIterator {
131  protected:
132   virtual void type_name(const char* name)   = 0;
133 
<span class="line-modified">134   void do_bool()                       { type_name(&quot;jboolean&quot;); }</span>
<span class="line-modified">135   void do_char()                       { type_name(&quot;jchar&quot;   ); }</span>
<span class="line-modified">136   void do_float()                      { type_name(&quot;jfloat&quot;  ); }</span>
<span class="line-modified">137   void do_double()                     { type_name(&quot;jdouble&quot; ); }</span>
<span class="line-modified">138   void do_byte()                       { type_name(&quot;jbyte&quot;   ); }</span>
<span class="line-modified">139   void do_short()                      { type_name(&quot;jshort&quot;  ); }</span>
<span class="line-modified">140   void do_int()                        { type_name(&quot;jint&quot;    ); }</span>
<span class="line-modified">141   void do_long()                       { type_name(&quot;jlong&quot;   ); }</span>
<span class="line-modified">142   void do_void()                       { type_name(&quot;void&quot;    ); }</span>
<span class="line-modified">143   void do_object(int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>
<span class="line-modified">144   void do_array (int begin, int end)   { type_name(&quot;jobject&quot; ); }</span>






145 
146  public:
147   SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
148 };
149 
150 
<span class="line-modified">151 class SignatureInfo: public SignatureIterator {</span>
<span class="line-removed">152  protected:</span>
<span class="line-removed">153   bool      _has_iterated;             // need this because iterate cannot be called in constructor (set is virtual!)</span>
<span class="line-removed">154   bool      _has_iterated_return;</span>
<span class="line-removed">155   int       _size;</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   void lazy_iterate_parameters()       { if (!_has_iterated) { iterate_parameters(); _has_iterated = true; } }</span>
<span class="line-removed">158   void lazy_iterate_return()           { if (!_has_iterated_return) { iterate_returntype(); _has_iterated_return = true; } }</span>
<span class="line-removed">159 </span>
<span class="line-removed">160   virtual void set(int size, BasicType type) = 0;</span>
<span class="line-removed">161 </span>
<span class="line-removed">162   void do_bool  ()                     { set(T_BOOLEAN_size, T_BOOLEAN); }</span>
<span class="line-removed">163   void do_char  ()                     { set(T_CHAR_size   , T_CHAR   ); }</span>
<span class="line-removed">164   void do_float ()                     { set(T_FLOAT_size  , T_FLOAT  ); }</span>
<span class="line-removed">165   void do_double()                     { set(T_DOUBLE_size , T_DOUBLE ); }</span>
<span class="line-removed">166   void do_byte  ()                     { set(T_BYTE_size   , T_BYTE   ); }</span>
<span class="line-removed">167   void do_short ()                     { set(T_SHORT_size  , T_SHORT  ); }</span>
<span class="line-removed">168   void do_int   ()                     { set(T_INT_size    , T_INT    ); }</span>
<span class="line-removed">169   void do_long  ()                     { set(T_LONG_size   , T_LONG   ); }</span>
<span class="line-removed">170   void do_void  ()                     { set(T_VOID_size   , T_VOID   ); }</span>
<span class="line-removed">171   void do_object(int begin, int end)   { set(T_OBJECT_size , T_OBJECT ); }</span>
<span class="line-removed">172   void do_array (int begin, int end)   { set(T_ARRAY_size  , T_ARRAY  ); }</span>
173 





174  public:
<span class="line-modified">175   SignatureInfo(Symbol* signature) : SignatureIterator(signature) {</span>
<span class="line-modified">176     _has_iterated = _has_iterated_return = false;</span>
<span class="line-removed">177     _size         = 0;</span>
<span class="line-removed">178     _return_type  = T_ILLEGAL;</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180 </span>
181 };
182 
183 
<span class="line-modified">184 // Specialized SignatureIterator: Used to compute the argument size.</span>
<span class="line-removed">185 </span>
<span class="line-removed">186 class ArgumentSizeComputer: public SignatureInfo {</span>
187  private:
<span class="line-modified">188   void set(int size, BasicType type)   { _size += size; }</span>


189  public:
<span class="line-modified">190   ArgumentSizeComputer(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">191 </span>
<span class="line-removed">192   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
193 };
194 
195 
<span class="line-modified">196 class ArgumentCount: public SignatureInfo {</span>
197  private:
<span class="line-modified">198   void set(int size, BasicType type)   { _size ++; }</span>


199  public:
<span class="line-modified">200   ArgumentCount(Symbol* signature) : SignatureInfo(signature) {}</span>
<span class="line-modified">201 </span>
<span class="line-removed">202   int       size()                     { lazy_iterate_parameters(); return _size; }</span>
203 };
204 
205 
206 // Specialized SignatureIterator: Used to compute the result type.
207 
<span class="line-modified">208 class ResultTypeFinder: public SignatureInfo {</span>
<span class="line-removed">209  private:</span>
<span class="line-removed">210   void set(int size, BasicType type)   { _return_type = type; }</span>
211  public:
<span class="line-modified">212   BasicType type()                     { lazy_iterate_return(); return _return_type; }</span>
<span class="line-modified">213 </span>
<span class="line-removed">214   ResultTypeFinder(Symbol* signature) : SignatureInfo(signature) {}</span>
215 };
216 
217 
218 // Fingerprinter computes a unique ID for a given method. The ID
219 // is a bitvector characterizing the methods signature (incl. the receiver).
220 class Fingerprinter: public SignatureIterator {
221  private:
<span class="line-modified">222   uint64_t _fingerprint;</span>

223   int _shift_count;
<span class="line-modified">224   methodHandle mh;</span>
<span class="line-removed">225 </span>
<span class="line-removed">226  public:</span>
227 
<span class="line-modified">228   void do_bool()    { _fingerprint |= (((uint64_t)bool_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">229   void do_char()    { _fingerprint |= (((uint64_t)char_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">230   void do_byte()    { _fingerprint |= (((uint64_t)byte_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">231   void do_short()   { _fingerprint |= (((uint64_t)short_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-modified">232   void do_int()     { _fingerprint |= (((uint64_t)int_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">233   void do_long()    { _fingerprint |= (((uint64_t)long_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">234   void do_float()   { _fingerprint |= (((uint64_t)float_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">235   void do_double()  { _fingerprint |= (((uint64_t)double_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">236 </span>
<span class="line-removed">237   void do_object(int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
<span class="line-removed">238   void do_array (int begin, int end)  { _fingerprint |= (((uint64_t)obj_parm) &lt;&lt; _shift_count); _shift_count += parameter_feature_size; }</span>
239 
<span class="line-modified">240   void do_void()    { ShouldNotReachHere(); }</span>

241 
<span class="line-modified">242   Fingerprinter(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {</span>
<span class="line-modified">243     mh = method;</span>
<span class="line-modified">244     _fingerprint = 0;</span>



245   }
246 
<span class="line-modified">247   uint64_t fingerprint() {</span>
<span class="line-modified">248     // See if we fingerprinted this method already</span>
<span class="line-modified">249     if (mh-&gt;constMethod()-&gt;fingerprint() != CONST64(0)) {</span>
<span class="line-removed">250       return mh-&gt;constMethod()-&gt;fingerprint();</span>
<span class="line-removed">251     }</span>
<span class="line-removed">252 </span>
<span class="line-removed">253     if (mh-&gt;size_of_parameters() &gt; max_size_of_parameters ) {</span>
<span class="line-removed">254       _fingerprint = (uint64_t)CONST64(-1);</span>
<span class="line-removed">255       mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-removed">256       return _fingerprint;</span>
<span class="line-removed">257     }</span>
258 
<span class="line-modified">259     assert( (int)mh-&gt;result_type() &lt;= (int)result_feature_mask, &quot;bad result type&quot;);</span>
<span class="line-modified">260     _fingerprint = mh-&gt;result_type();</span>
<span class="line-modified">261     _fingerprint &lt;&lt;= static_feature_size;</span>
<span class="line-modified">262     if (mh-&gt;is_static())  _fingerprint |= 1;</span>
<span class="line-modified">263     _shift_count = result_feature_size + static_feature_size;</span>
<span class="line-modified">264     iterate_parameters();</span>
<span class="line-modified">265     _fingerprint |= ((uint64_t)done_parm) &lt;&lt; _shift_count;// mark end of sig</span>
<span class="line-modified">266     mh-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-modified">267     return _fingerprint;</span>
268   }
269 };
270 
271 
272 // Specialized SignatureIterator: Used for native call purposes
273 
274 class NativeSignatureIterator: public SignatureIterator {
275  private:
276   methodHandle _method;
277 // We need separate JNI and Java offset values because in 64 bit mode,
278 // the argument offsets are not in sync with the Java stack.
279 // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
280   int          _offset;                // The java stack offset
281   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
282   int          _jni_offset;            // the current parameter offset, starting with 0
283 
<span class="line-modified">284   void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">285   void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">286   void do_float ()                     { pass_float();  _jni_offset++; _offset++;       }</span>
<span class="line-modified">287 #ifdef _LP64</span>
<span class="line-modified">288   void do_double()                     { pass_double(); _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">289 #else</span>
<span class="line-modified">290   void do_double()                     { pass_double(); _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">291 #endif</span>
<span class="line-modified">292   void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">293   void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">294   void do_int   ()                     { pass_int();    _jni_offset++; _offset++;       }</span>
<span class="line-modified">295 #ifdef _LP64</span>
<span class="line-modified">296   void do_long  ()                     { pass_long();   _jni_offset++; _offset += 2;    }</span>
<span class="line-modified">297 #else</span>
<span class="line-modified">298   void do_long  ()                     { pass_long();   _jni_offset += 2; _offset += 2; }</span>
<span class="line-modified">299 #endif</span>
<span class="line-modified">300   void do_void  ()                     { ShouldNotReachHere();                               }</span>
<span class="line-modified">301   void do_object(int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>
<span class="line-modified">302   void do_array (int begin, int end)   { pass_object(); _jni_offset++; _offset++;        }</span>












303 
304  public:
305   methodHandle method() const          { return _method; }
306   int          offset() const          { return _offset; }
307   int      jni_offset() const          { return _jni_offset + _prepended; }
<span class="line-removed">308 //  int     java_offset() const          { return method()-&gt;size_of_parameters() - _offset - 1; }</span>
309   bool      is_static() const          { return method()-&gt;is_static(); }
310   virtual void pass_int()              = 0;
311   virtual void pass_long()             = 0;
<span class="line-modified">312   virtual void pass_object()           = 0;</span>
313   virtual void pass_float()            = 0;
314 #ifdef _LP64
315   virtual void pass_double()           = 0;
316 #else
317   virtual void pass_double()           { pass_long(); }  // may be same as long
318 #endif
319 
320   NativeSignatureIterator(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
321     _method = method;
322     _offset = 0;
323     _jni_offset = 0;
324 
325     const int JNIEnv_words = 1;
326     const int mirror_words = 1;
327     _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
328   }
329 
<span class="line-modified">330   // iterate() calles the 2 virtual methods according to the following invocation syntax:</span>


331   //
332   // {pass_int | pass_long | pass_object}
333   //
334   // Arguments are handled from left to right (receiver first, if any).
335   // The offset() values refer to the Java stack offsets but are 0 based and increasing.
336   // The java_offset() values count down to 0, and refer to the Java TOS.
337   // The jni_offset() values increase from 1 or 2, and refer to C arguments.

338 
<span class="line-modified">339   void iterate() { iterate(Fingerprinter(method()).fingerprint());</span>
<span class="line-modified">340   }</span>
<span class="line-removed">341 </span>
<span class="line-removed">342 </span>
<span class="line-removed">343   // Optimized path if we have the bitvector form of signature</span>
<span class="line-removed">344   void iterate( uint64_t fingerprint ) {</span>
<span class="line-removed">345 </span>
346     if (!is_static()) {
347       // handle receiver (not handled by iterate because not in signature)
348       pass_object(); _jni_offset++; _offset++;
349     }
<span class="line-modified">350 </span>
<span class="line-removed">351     SignatureIterator::iterate_parameters( fingerprint );</span>
352   }
353 };
354 
355 
<span class="line-modified">356 // Handy stream for iterating over signature</span>

357 
358 class SignatureStream : public StackObj {
359  private:
<span class="line-modified">360   Symbol*      _signature;</span>
361   int          _begin;
362   int          _end;


363   BasicType    _type;
<span class="line-modified">364   bool         _at_return_type;</span>
<span class="line-modified">365   Symbol*      _previous_name;     // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">366   GrowableArray&lt;Symbol*&gt;* _names;  // symbols created while parsing that need to be dereferenced</span>
<span class="line-removed">367  public:</span>
<span class="line-removed">368   bool at_return_type() const                    { return _at_return_type; }</span>
<span class="line-removed">369   bool is_done() const;</span>
<span class="line-removed">370   void next_non_primitive(int t);</span>
<span class="line-removed">371   void next() {</span>
<span class="line-removed">372     Symbol* sig = _signature;</span>
<span class="line-removed">373     int len = sig-&gt;utf8_length();</span>
<span class="line-removed">374     if (_end &gt;= len) {</span>
<span class="line-removed">375       _end = len + 1;</span>
<span class="line-removed">376       return;</span>
<span class="line-removed">377     }</span>
378 
<span class="line-modified">379     _begin = _end;</span>
<span class="line-modified">380     int t = sig-&gt;char_at(_begin);</span>
<span class="line-modified">381     switch (t) {</span>
<span class="line-modified">382       case JVM_SIGNATURE_BYTE:    _type = T_BYTE;    break;</span>
<span class="line-modified">383       case JVM_SIGNATURE_CHAR:    _type = T_CHAR;    break;</span>
<span class="line-modified">384       case JVM_SIGNATURE_DOUBLE:  _type = T_DOUBLE;  break;</span>
<span class="line-modified">385       case JVM_SIGNATURE_FLOAT:   _type = T_FLOAT;   break;</span>
<span class="line-modified">386       case JVM_SIGNATURE_INT:     _type = T_INT;     break;</span>
<span class="line-removed">387       case JVM_SIGNATURE_LONG:    _type = T_LONG;    break;</span>
<span class="line-removed">388       case JVM_SIGNATURE_SHORT:   _type = T_SHORT;   break;</span>
<span class="line-removed">389       case JVM_SIGNATURE_BOOLEAN: _type = T_BOOLEAN; break;</span>
<span class="line-removed">390       case JVM_SIGNATURE_VOID:    _type = T_VOID;    break;</span>
<span class="line-removed">391       default : next_non_primitive(t);</span>
<span class="line-removed">392                 return;</span>
<span class="line-removed">393     }</span>
<span class="line-removed">394     _end++;</span>
395   }
396 
<span class="line-modified">397   SignatureStream(Symbol* signature, bool is_method = true);</span>






398   ~SignatureStream();
399 
<span class="line-modified">400   bool is_object() const;                        // True if this argument is an object</span>
<span class="line-modified">401   bool is_array() const;                         // True if this argument is an array</span>
<span class="line-modified">402   BasicType type() const                         { return _type; }</span>
<span class="line-modified">403   Symbol* as_symbol();</span>
<span class="line-modified">404   enum FailureMode { ReturnNull, NCDFError };</span>
<span class="line-modified">405   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">406   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-modified">407   const u1* raw_bytes()  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">408   int       raw_length() { return _end - _begin; }</span>






409 
<span class="line-modified">410   // return same as_symbol except allocation of new symbols is avoided.</span>
<span class="line-modified">411   Symbol* as_symbol_or_null();</span>







412 
<span class="line-modified">413   // count the number of references in the signature</span>
<span class="line-modified">414   int reference_parameter_count();</span>






















415 };
416 
<span class="line-modified">417 #ifdef ASSERT</span>
<span class="line-modified">418 class SignatureVerifier : public StackObj {</span>

























419   public:
420     static bool is_valid_method_signature(Symbol* sig);
421     static bool is_valid_type_signature(Symbol* sig);
422   private:
423     static ssize_t is_valid_type(const char*, ssize_t);
424 };
425 #endif
426 #endif // SHARE_RUNTIME_SIGNATURE_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SIGNATURE_HPP
 26 #define SHARE_RUNTIME_SIGNATURE_HPP
 27 
<span class="line-added"> 28 #include &quot;classfile/symbolTable.hpp&quot;</span>
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 // Static routines and parsing loops for processing field and method</span>
<span class="line-modified"> 34 // descriptors.  In the HotSpot sources we call them &quot;signatures&quot;.</span>
<span class="line-added"> 35 //</span>
<span class="line-added"> 36 // A SignatureStream iterates over a Java descriptor (or parts of it).</span>
<span class="line-added"> 37 // The syntax is documented in the Java Virtual Machine Specification,</span>
<span class="line-added"> 38 // section 4.3.</span>
<span class="line-added"> 39 //</span>
<span class="line-added"> 40 // The syntax may be summarized as follows:</span>
<span class="line-added"> 41 //</span>
<span class="line-added"> 42 //     MethodType: &#39;(&#39; {FieldType}* &#39;)&#39; (FieldType | &#39;V&#39;)</span>
<span class="line-added"> 43 //     FieldType: PrimitiveType | ObjectType | ArrayType</span>
<span class="line-added"> 44 //     PrimitiveType: &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;F&#39; | &#39;I&#39; | &#39;J&#39; | &#39;S&#39; | &#39;Z&#39;</span>
<span class="line-added"> 45 //     ObjectType: &#39;L&#39; ClassName &#39;;&#39; | ArrayType</span>
<span class="line-added"> 46 //     ArrayType: &#39;[&#39; FieldType</span>
<span class="line-added"> 47 //     ClassName: {UnqualifiedName &#39;/&#39;}* UnqualifiedName</span>
<span class="line-added"> 48 //     UnqualifiedName: NameChar {NameChar}*</span>
<span class="line-added"> 49 //     NameChar: ANY_CHAR_EXCEPT(&#39;/&#39; | &#39;.&#39; | &#39;;&#39; | &#39;[&#39;)</span>
 50 //
<span class="line-modified"> 51 // All of the concrete characters in the above grammar are given</span>
<span class="line-modified"> 52 // standard manifest constant names of the form JVM_SIGNATURE_x.</span>
<span class="line-added"> 53 // Executable code uses these constant names in preference to raw</span>
<span class="line-added"> 54 // character constants.  Comments and assertion code sometimes use</span>
<span class="line-added"> 55 // the raw character constants for brevity.</span>
 56 //
<span class="line-modified"> 57 // The primitive field types (like &#39;I&#39;) correspond 1-1 with type codes</span>
<span class="line-modified"> 58 // (like T_INT) which form part of the specification of the &#39;newarray&#39;</span>
<span class="line-modified"> 59 // instruction (JVMS 6.5, section on newarray).  These type codes are</span>
<span class="line-added"> 60 // widely used in the HotSpot code.  They are joined by ad hoc codes</span>
<span class="line-added"> 61 // like T_OBJECT and T_ARRAY (defined in HotSpot but not in the JVMS)</span>
<span class="line-added"> 62 // so that each &quot;basic type&quot; of field descriptor (or void return type)</span>
<span class="line-added"> 63 // has a corresponding T_x code.  Thus, while T_x codes play a very</span>
<span class="line-added"> 64 // minor role in the JVMS, they play a major role in the HotSpot</span>
<span class="line-added"> 65 // sources.  There are fewer than 16 such &quot;basic types&quot;, so they fit</span>
<span class="line-added"> 66 // nicely into bitfields.</span>
 67 //
<span class="line-modified"> 68 // The syntax of ClassName overlaps slightly with the descriptor</span>
<span class="line-added"> 69 // syntaxes.  The strings &quot;I&quot; and &quot;(I)V&quot; are both class names</span>
<span class="line-added"> 70 // *and* descriptors.  If a class name contains any character other</span>
<span class="line-added"> 71 // than &quot;BCDFIJSZ()V&quot; it cannot be confused with a descriptor.</span>
<span class="line-added"> 72 // Class names inside of descriptors are always contained in an</span>
<span class="line-added"> 73 // &quot;envelope&quot; syntax which starts with &#39;L&#39; and ends with &#39;;&#39;.</span>
 74 //
<span class="line-modified"> 75 // As a confounding factor, array types report their type name strings</span>
<span class="line-modified"> 76 // in descriptor format.  These name strings are easy to recognize,</span>
<span class="line-added"> 77 // since they begin with &#39;[&#39;.  For this reason some API points on</span>
<span class="line-added"> 78 // HotSpot look for array descriptors as well as proper class names.</span>
<span class="line-added"> 79 //</span>
<span class="line-added"> 80 // For historical reasons some API points that accept class names and</span>
<span class="line-added"> 81 // array names also look for class names wrapped inside an envelope</span>
<span class="line-added"> 82 // (like &quot;LFoo;&quot;) and unwrap them on the fly (to a name like &quot;Foo&quot;).</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 class Signature : AllStatic {</span>
<span class="line-added"> 85  private:</span>
<span class="line-added"> 86   static bool is_valid_array_signature(const Symbol* sig);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88  public:</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90   // Returns the basic type of a field signature (or T_VOID for &quot;V&quot;).</span>
<span class="line-added"> 91   // Assumes the signature is a valid field descriptor.</span>
<span class="line-added"> 92   // Do not apply this function to class names or method signatures.</span>
<span class="line-added"> 93   static BasicType basic_type(const Symbol* signature) {</span>
<span class="line-added"> 94     return basic_type(signature-&gt;char_at(0));</span>
<span class="line-added"> 95   }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97   // Returns T_ILLEGAL for an illegal signature char.</span>
<span class="line-added"> 98   static BasicType basic_type(int ch);</span>
<span class="line-added"> 99 </span>
<span class="line-added">100   // Assuming it is either a class name or signature,</span>
<span class="line-added">101   // determine if it in fact cannot be a class name.</span>
<span class="line-added">102   // This means it either starts with &#39;[&#39; or ends with &#39;;&#39;</span>
<span class="line-added">103   static bool not_class_name(const Symbol* signature) {</span>
<span class="line-added">104     return (signature-&gt;starts_with(JVM_SIGNATURE_ARRAY) ||</span>
<span class="line-added">105             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS));</span>
<span class="line-added">106   }</span>
<span class="line-added">107 </span>
<span class="line-added">108   // Assuming it is either a class name or signature,</span>
<span class="line-added">109   // determine if it in fact is an array descriptor.</span>
<span class="line-added">110   static bool is_array(const Symbol* signature) {</span>
<span class="line-added">111     return (signature-&gt;utf8_length() &gt; 1 &amp;&amp;</span>
<span class="line-added">112             signature-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">113             is_valid_array_signature(signature));</span>
<span class="line-added">114   }</span>
<span class="line-added">115 </span>
<span class="line-added">116   // Assuming it is either a class name or signature,</span>
<span class="line-added">117   // determine if it contains a class name plus &#39;;&#39;.</span>
<span class="line-added">118   static bool has_envelope(const Symbol* signature) {</span>
<span class="line-added">119     return ((signature-&gt;utf8_length() &gt; 0) &amp;&amp;</span>
<span class="line-added">120             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS) &amp;&amp;</span>
<span class="line-added">121             has_envelope(signature-&gt;char_at(0)));</span>
<span class="line-added">122   }</span>
<span class="line-added">123 </span>
<span class="line-added">124   // Determine if this signature char introduces an</span>
<span class="line-added">125   // envelope, which is a class name plus &#39;;&#39;.</span>
<span class="line-added">126   static bool has_envelope(char signature_char) {</span>
<span class="line-added">127     return (signature_char == JVM_SIGNATURE_CLASS);</span>
<span class="line-added">128   }</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Assuming has_envelope is true, return the symbol</span>
<span class="line-added">131   // inside the envelope, by stripping &#39;L&#39; and &#39;;&#39;.</span>
<span class="line-added">132   // Caller is responsible for decrementing the newly created</span>
<span class="line-added">133   // Symbol&#39;s refcount, use TempNewSymbol.</span>
<span class="line-added">134   static Symbol* strip_envelope(const Symbol* signature) {</span>
<span class="line-added">135     assert(has_envelope(signature), &quot;precondition&quot;);</span>
<span class="line-added">136     return SymbolTable::new_symbol((char*) signature-&gt;bytes() + 1,</span>
<span class="line-added">137                                    signature-&gt;utf8_length() - 2);</span>
<span class="line-added">138   }</span>
<span class="line-added">139 </span>
<span class="line-added">140   // Assuming it&#39;s either a field or method descriptor, determine</span>
<span class="line-added">141   // whether it is in fact a method descriptor:</span>
<span class="line-added">142   static bool is_method(const Symbol* signature) {</span>
<span class="line-added">143     return signature-&gt;starts_with(JVM_SIGNATURE_FUNC);</span>
<span class="line-added">144   }</span>
<span class="line-added">145 </span>
<span class="line-added">146   // Assuming it&#39;s a method signature, determine if it must</span>
<span class="line-added">147   // return void.</span>
<span class="line-added">148   static bool is_void_method(const Symbol* signature) {</span>
<span class="line-added">149     assert(is_method(signature), &quot;signature is not for a method&quot;);</span>
<span class="line-added">150     return signature-&gt;ends_with(JVM_SIGNATURE_VOID);</span>
<span class="line-added">151   }</span>
<span class="line-added">152 };</span>
<span class="line-added">153 </span>
<span class="line-added">154 // A SignatureIterator uses a SignatureStream to produce BasicType</span>
<span class="line-added">155 // results, discarding class names.  This means it can be accelerated</span>
<span class="line-added">156 // using a fingerprint mechanism, in many cases, without loss of type</span>
<span class="line-added">157 // information.  The FingerPrinter class computes and caches this</span>
<span class="line-added">158 // reduced information for faster iteration.</span>
159 
160 class SignatureIterator: public ResourceObj {
<span class="line-added">161  public:</span>
<span class="line-added">162   typedef uint64_t fingerprint_t;</span>
<span class="line-added">163 </span>
164  protected:
165   Symbol*      _signature;             // the signature to iterate over


166   BasicType    _return_type;
<span class="line-modified">167   fingerprint_t _fingerprint;</span>



168 
169  public:
170   // Definitions used in generating and iterating the
171   // bit field form of the signature generated by the
172   // Fingerprinter.
173   enum {
<span class="line-modified">174     fp_static_feature_size    = 1,</span>
<span class="line-modified">175     fp_is_static_bit          = 1,</span>
<span class="line-modified">176 </span>
<span class="line-modified">177     fp_result_feature_size    = 4,</span>
<span class="line-modified">178     fp_result_feature_mask    = right_n_bits(fp_result_feature_size),</span>
<span class="line-modified">179     fp_parameter_feature_size = 4,</span>
<span class="line-modified">180     fp_parameter_feature_mask = right_n_bits(fp_parameter_feature_size),</span>
<span class="line-modified">181 </span>
<span class="line-modified">182     fp_parameters_done        = 0,  // marker for end of parameters (must be zero)</span>
<span class="line-modified">183 </span>
<span class="line-modified">184     // Parameters take up full wordsize, minus the result and static bit fields.</span>
<span class="line-modified">185     // Since fp_parameters_done is zero, termination field arises from shifting</span>
<span class="line-modified">186     // in zero bits, and therefore occupies no extra space.</span>
<span class="line-modified">187     // The sentinel value is all-zero-bits, which is impossible for a true</span>
<span class="line-modified">188     // fingerprint, since at least the result field will be non-zero.</span>
<span class="line-modified">189     fp_max_size_of_parameters = ((BitsPerLong</span>
<span class="line-modified">190                                   - (fp_result_feature_size + fp_static_feature_size))</span>
<span class="line-modified">191                                  / fp_parameter_feature_size)</span>






192   };
193 
<span class="line-added">194   static bool fp_is_valid_type(BasicType type, bool for_return_type = false);</span>
<span class="line-added">195 </span>
<span class="line-added">196   // Sentinel values are zero and not-zero (-1).</span>
<span class="line-added">197   // No need to protect the sign bit, since every valid return type is non-zero</span>
<span class="line-added">198   // (even T_VOID), and there are no valid parameter fields which are 0xF (T_VOID).</span>
<span class="line-added">199   static fingerprint_t zero_fingerprint() { return (fingerprint_t)0; }</span>
<span class="line-added">200   static fingerprint_t overflow_fingerprint() { return ~(fingerprint_t)0; }</span>
<span class="line-added">201   static bool fp_is_valid(fingerprint_t fingerprint) {</span>
<span class="line-added">202     return (fingerprint != zero_fingerprint()) &amp;&amp; (fingerprint != overflow_fingerprint());</span>
<span class="line-added">203   }</span>
<span class="line-added">204 </span>
205   // Constructors
<span class="line-modified">206   SignatureIterator(Symbol* signature, fingerprint_t fingerprint = zero_fingerprint()) {</span>
<span class="line-added">207     _signature   = signature;</span>
<span class="line-added">208     _return_type = T_ILLEGAL;  // sentinel value for uninitialized</span>
<span class="line-added">209     _fingerprint = zero_fingerprint();</span>
<span class="line-added">210     if (fingerprint != _fingerprint) {</span>
<span class="line-added">211       set_fingerprint(fingerprint);</span>
<span class="line-added">212     }</span>
<span class="line-added">213   }</span>
<span class="line-added">214 </span>
<span class="line-added">215   // If the fingerprint is present, we can use an accelerated loop.</span>
<span class="line-added">216   void set_fingerprint(fingerprint_t fingerprint);</span>
<span class="line-added">217 </span>
<span class="line-added">218   // Returns the set fingerprint, or zero_fingerprint()</span>
<span class="line-added">219   // if none has been set already.</span>
<span class="line-added">220   fingerprint_t fingerprint() const { return _fingerprint; }</span>
221 
222   // Iteration
<span class="line-modified">223   // Hey look:  There are no virtual methods in this class.</span>
<span class="line-modified">224   // So how is it customized?  By calling do_parameters_on</span>
<span class="line-modified">225   // an object which answers to &quot;do_type(BasicType)&quot;.</span>
<span class="line-modified">226   // By convention, this object is in the subclass</span>
<span class="line-modified">227   // itself, so the call is &quot;do_parameters_on(this)&quot;.</span>
<span class="line-modified">228   // The effect of this is to inline the parsing loop</span>
<span class="line-modified">229   // everywhere &quot;do_parameters_on&quot; is called.</span>
<span class="line-modified">230   // If there is a valid fingerprint in the object,</span>
<span class="line-modified">231   // an improved loop is called which just unpacks the</span>
<span class="line-modified">232   // bitfields from the fingerprint.  Otherwise, the</span>
<span class="line-modified">233   // symbol is parsed.</span>
<span class="line-modified">234   template&lt;typename T&gt; inline void do_parameters_on(T* callback); // iterates over parameters only</span>
<span class="line-modified">235   void skip_parameters();   // skips over parameters to find return type</span>
<span class="line-modified">236   BasicType return_type();  // computes the value on the fly if necessary</span>
<span class="line-modified">237 </span>
<span class="line-modified">238   static bool fp_is_static(fingerprint_t fingerprint) {</span>
<span class="line-modified">239     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">240     return fingerprint &amp; fp_is_static_bit;</span>
<span class="line-modified">241   }</span>
<span class="line-modified">242   static BasicType fp_return_type(fingerprint_t fingerprint) {</span>
<span class="line-modified">243     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">244     return (BasicType) ((fingerprint &gt;&gt; fp_static_feature_size) &amp; fp_result_feature_mask);</span>





245   }
<span class="line-modified">246   static fingerprint_t fp_start_parameters(fingerprint_t fingerprint) {</span>
<span class="line-modified">247     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">248     return fingerprint &gt;&gt; (fp_static_feature_size + fp_result_feature_size);</span>
<span class="line-added">249   }</span>
<span class="line-added">250   static BasicType fp_next_parameter(fingerprint_t&amp; mask) {</span>
<span class="line-added">251     int result = (mask &amp; fp_parameter_feature_mask);</span>
<span class="line-added">252     mask &gt;&gt;= fp_parameter_feature_size;</span>
<span class="line-added">253     return (BasicType) result;</span>
254   }
255 };
256 
257 
258 // Specialized SignatureIterators: Used to compute signature specific values.
259 
260 class SignatureTypeNames : public SignatureIterator {
261  protected:
262   virtual void type_name(const char* name)   = 0;
263 
<span class="line-modified">264   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">265   void do_type(BasicType type) {</span>
<span class="line-modified">266     switch (type) {</span>
<span class="line-modified">267     case T_BOOLEAN: type_name(&quot;jboolean&quot;); break;</span>
<span class="line-modified">268     case T_CHAR:    type_name(&quot;jchar&quot;   ); break;</span>
<span class="line-modified">269     case T_FLOAT:   type_name(&quot;jfloat&quot;  ); break;</span>
<span class="line-modified">270     case T_DOUBLE:  type_name(&quot;jdouble&quot; ); break;</span>
<span class="line-modified">271     case T_BYTE:    type_name(&quot;jbyte&quot;   ); break;</span>
<span class="line-modified">272     case T_SHORT:   type_name(&quot;jshort&quot;  ); break;</span>
<span class="line-modified">273     case T_INT:     type_name(&quot;jint&quot;    ); break;</span>
<span class="line-modified">274     case T_LONG:    type_name(&quot;jlong&quot;   ); break;</span>
<span class="line-added">275     case T_VOID:    type_name(&quot;void&quot;    ); break;</span>
<span class="line-added">276     case T_ARRAY:</span>
<span class="line-added">277     case T_OBJECT:  type_name(&quot;jobject&quot; ); break;</span>
<span class="line-added">278     default: ShouldNotReachHere();</span>
<span class="line-added">279     }</span>
<span class="line-added">280   }</span>
281 
282  public:
283   SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
284 };
285 
286 
<span class="line-modified">287 // Specialized SignatureIterator: Used to compute the argument size.</span>





















288 
<span class="line-added">289 class ArgumentSizeComputer: public SignatureIterator {</span>
<span class="line-added">290  private:</span>
<span class="line-added">291   int _size;</span>
<span class="line-added">292   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">293   void do_type(BasicType type) { _size += parameter_type_word_count(type); }</span>
294  public:
<span class="line-modified">295   ArgumentSizeComputer(Symbol* signature);</span>
<span class="line-modified">296   int size() { return _size; }</span>




297 };
298 
299 
<span class="line-modified">300 class ArgumentCount: public SignatureIterator {</span>


301  private:
<span class="line-modified">302   int _size;</span>
<span class="line-added">303   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">304   void do_type(BasicType type) { _size++; }</span>
305  public:
<span class="line-modified">306   ArgumentCount(Symbol* signature);</span>
<span class="line-modified">307   int size() { return _size; }</span>

308 };
309 
310 
<span class="line-modified">311 class ReferenceArgumentCount: public SignatureIterator {</span>
312  private:
<span class="line-modified">313   int _refs;</span>
<span class="line-added">314   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">315   void do_type(BasicType type) { if (is_reference_type(type)) _refs++; }</span>
316  public:
<span class="line-modified">317   ReferenceArgumentCount(Symbol* signature);</span>
<span class="line-modified">318   int count() { return _refs; }</span>

319 };
320 
321 
322 // Specialized SignatureIterator: Used to compute the result type.
323 
<span class="line-modified">324 class ResultTypeFinder: public SignatureIterator {</span>


325  public:
<span class="line-modified">326   BasicType type() { return return_type(); }</span>
<span class="line-modified">327   ResultTypeFinder(Symbol* signature) : SignatureIterator(signature) { }</span>

328 };
329 
330 
331 // Fingerprinter computes a unique ID for a given method. The ID
332 // is a bitvector characterizing the methods signature (incl. the receiver).
333 class Fingerprinter: public SignatureIterator {
334  private:
<span class="line-modified">335   fingerprint_t _accumulator;</span>
<span class="line-added">336   int _param_size;</span>
337   int _shift_count;
<span class="line-modified">338   const Method* _method;</span>


339 
<span class="line-modified">340   void initialize_accumulator() {</span>
<span class="line-modified">341     _accumulator = 0;</span>
<span class="line-modified">342     _shift_count = fp_result_feature_size + fp_static_feature_size;</span>
<span class="line-modified">343     _param_size = 0;</span>
<span class="line-modified">344   }</span>






345 
<span class="line-modified">346   // Out-of-line method does it all in constructor:</span>
<span class="line-added">347   void compute_fingerprint_and_return_type(bool static_flag = false);</span>
348 
<span class="line-modified">349   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">350   void do_type(BasicType type) {</span>
<span class="line-modified">351     assert(fp_is_valid_type(type), &quot;bad parameter type&quot;);</span>
<span class="line-added">352     _accumulator |= ((fingerprint_t)type &lt;&lt; _shift_count);</span>
<span class="line-added">353     _shift_count += fp_parameter_feature_size;</span>
<span class="line-added">354     _param_size += (is_double_word_type(type) ? 2 : 1);</span>
355   }
356 
<span class="line-modified">357  public:</span>
<span class="line-modified">358   int size_of_parameters() const { return _param_size; }</span>
<span class="line-modified">359   // fingerprint() and return_type() are in super class</span>








360 
<span class="line-modified">361   Fingerprinter(const methodHandle&amp; method)</span>
<span class="line-modified">362     : SignatureIterator(method-&gt;signature()),</span>
<span class="line-modified">363       _method(method()) {</span>
<span class="line-modified">364     compute_fingerprint_and_return_type();</span>
<span class="line-modified">365   }</span>
<span class="line-modified">366   Fingerprinter(Symbol* signature, bool is_static)</span>
<span class="line-modified">367     : SignatureIterator(signature),</span>
<span class="line-modified">368       _method(NULL) {</span>
<span class="line-modified">369     compute_fingerprint_and_return_type(is_static);</span>
370   }
371 };
372 
373 
374 // Specialized SignatureIterator: Used for native call purposes
375 
376 class NativeSignatureIterator: public SignatureIterator {
377  private:
378   methodHandle _method;
379 // We need separate JNI and Java offset values because in 64 bit mode,
380 // the argument offsets are not in sync with the Java stack.
381 // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
382   int          _offset;                // The java stack offset
383   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
384   int          _jni_offset;            // the current parameter offset, starting with 0
385 
<span class="line-modified">386   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">387   void do_type(BasicType type) {</span>
<span class="line-modified">388     switch (type) {</span>
<span class="line-modified">389     case T_BYTE:</span>
<span class="line-modified">390     case T_SHORT:</span>
<span class="line-modified">391     case T_INT:</span>
<span class="line-modified">392     case T_BOOLEAN:</span>
<span class="line-modified">393     case T_CHAR:</span>
<span class="line-modified">394       pass_int();    _jni_offset++; _offset++;</span>
<span class="line-modified">395       break;</span>
<span class="line-modified">396     case T_FLOAT:</span>
<span class="line-modified">397       pass_float();  _jni_offset++; _offset++;</span>
<span class="line-modified">398       break;</span>
<span class="line-modified">399     case T_DOUBLE: {</span>
<span class="line-modified">400       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-modified">401       pass_double(); _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-modified">402       break;</span>
<span class="line-modified">403     }</span>
<span class="line-modified">404     case T_LONG: {</span>
<span class="line-added">405       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-added">406       pass_long();   _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-added">407       break;</span>
<span class="line-added">408     }</span>
<span class="line-added">409     case T_ARRAY:</span>
<span class="line-added">410     case T_OBJECT:</span>
<span class="line-added">411       pass_object(); _jni_offset++; _offset++;</span>
<span class="line-added">412       break;</span>
<span class="line-added">413     default:</span>
<span class="line-added">414       ShouldNotReachHere();</span>
<span class="line-added">415     }</span>
<span class="line-added">416   }</span>
417 
418  public:
419   methodHandle method() const          { return _method; }
420   int          offset() const          { return _offset; }
421   int      jni_offset() const          { return _jni_offset + _prepended; }

422   bool      is_static() const          { return method()-&gt;is_static(); }
423   virtual void pass_int()              = 0;
424   virtual void pass_long()             = 0;
<span class="line-modified">425   virtual void pass_object()           = 0;  // objects, arrays, inlines</span>
426   virtual void pass_float()            = 0;
427 #ifdef _LP64
428   virtual void pass_double()           = 0;
429 #else
430   virtual void pass_double()           { pass_long(); }  // may be same as long
431 #endif
432 
433   NativeSignatureIterator(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
434     _method = method;
435     _offset = 0;
436     _jni_offset = 0;
437 
438     const int JNIEnv_words = 1;
439     const int mirror_words = 1;
440     _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
441   }
442 
<span class="line-modified">443   void iterate() { iterate(Fingerprinter(method()).fingerprint()); }</span>
<span class="line-added">444 </span>
<span class="line-added">445   // iterate() calls the 3 virtual methods according to the following invocation syntax:</span>
446   //
447   // {pass_int | pass_long | pass_object}
448   //
449   // Arguments are handled from left to right (receiver first, if any).
450   // The offset() values refer to the Java stack offsets but are 0 based and increasing.
451   // The java_offset() values count down to 0, and refer to the Java TOS.
452   // The jni_offset() values increase from 1 or 2, and refer to C arguments.
<span class="line-added">453   // The method&#39;s return type is ignored.</span>
454 
<span class="line-modified">455   void iterate(fingerprint_t fingerprint) {</span>
<span class="line-modified">456     set_fingerprint(fingerprint);</span>





457     if (!is_static()) {
458       // handle receiver (not handled by iterate because not in signature)
459       pass_object(); _jni_offset++; _offset++;
460     }
<span class="line-modified">461     do_parameters_on(this);</span>

462   }
463 };
464 
465 
<span class="line-modified">466 // This is the core parsing logic for iterating over signatures.</span>
<span class="line-added">467 // All of the previous classes use this for doing their work.</span>
468 
469 class SignatureStream : public StackObj {
470  private:
<span class="line-modified">471   const Symbol* _signature;</span>
472   int          _begin;
473   int          _end;
<span class="line-added">474   int          _limit;</span>
<span class="line-added">475   int          _array_prefix;  // count of &#39;[&#39; before the array element descr</span>
476   BasicType    _type;
<span class="line-modified">477   int          _state;</span>
<span class="line-modified">478   Symbol*      _previous_name;    // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">479   GrowableArray&lt;Symbol*&gt;* _names; // symbols created while parsing that need to be dereferenced</span>











480 
<span class="line-modified">481   inline int scan_non_primitive(BasicType type);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483   Symbol* find_symbol();</span>
<span class="line-modified">484 </span>
<span class="line-modified">485   enum { _s_field = 0, _s_method = 1, _s_method_return = 3 };</span>
<span class="line-modified">486   void set_done() {</span>
<span class="line-modified">487     _state |= -2;   // preserve s_method bit</span>
<span class="line-modified">488     assert(is_done(), &quot;Unable to set state to done&quot;);</span>








489   }
490 
<span class="line-modified">491  public:</span>
<span class="line-added">492   bool is_method_signature() const               { return (_state &amp; (int)_s_method) != 0; }</span>
<span class="line-added">493   bool at_return_type() const                    { return _state == (int)_s_method_return; }</span>
<span class="line-added">494   bool is_done() const                           { return _state &lt; 0; }</span>
<span class="line-added">495   void next();</span>
<span class="line-added">496 </span>
<span class="line-added">497   SignatureStream(const Symbol* signature, bool is_method = true);</span>
498   ~SignatureStream();
499 
<span class="line-modified">500   bool is_reference() const { return is_reference_type(_type); }</span>
<span class="line-modified">501   bool is_array() const     { return _type == T_ARRAY; }</span>
<span class="line-modified">502   bool is_primitive() const { return is_java_primitive(_type); }</span>
<span class="line-modified">503   BasicType type() const    { return _type; }</span>
<span class="line-modified">504 </span>
<span class="line-modified">505   const u1* raw_bytes() const  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">506   int       raw_length() const { return _end - _begin; }</span>
<span class="line-modified">507   int       raw_begin() const  { return _begin; }</span>
<span class="line-modified">508   int       raw_end() const    { return _end; }</span>
<span class="line-added">509   int raw_symbol_begin() const { return _begin + (has_envelope() ? 1 : 0); }</span>
<span class="line-added">510   int raw_symbol_end() const   { return _end  -  (has_envelope() ? 1 : 0); }</span>
<span class="line-added">511   char raw_char_at(int i) const {</span>
<span class="line-added">512     assert(i &lt; _limit, &quot;index for raw_char_at is over the limit&quot;);</span>
<span class="line-added">513     return _signature-&gt;char_at(i);</span>
<span class="line-added">514   }</span>
515 
<span class="line-modified">516   // True if there is an embedded class name in this type,</span>
<span class="line-modified">517   // followed by &#39;;&#39;.</span>
<span class="line-added">518   bool has_envelope() const {</span>
<span class="line-added">519     if (!Signature::has_envelope(_signature-&gt;char_at(_begin)))</span>
<span class="line-added">520       return false;</span>
<span class="line-added">521     // this should always be true, but let&#39;s test it:</span>
<span class="line-added">522     assert(_signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS, &quot;signature envelope has no semi-colon at end&quot;);</span>
<span class="line-added">523     return true;</span>
<span class="line-added">524   }</span>
525 
<span class="line-modified">526   // return the symbol for chars in symbol_begin()..symbol_end()</span>
<span class="line-modified">527   Symbol* as_symbol() {</span>
<span class="line-added">528     return find_symbol();</span>
<span class="line-added">529   }</span>
<span class="line-added">530 </span>
<span class="line-added">531   // in case you want only the return type:</span>
<span class="line-added">532   void skip_to_return_type();</span>
<span class="line-added">533 </span>
<span class="line-added">534   // number of &#39;[&#39; in array prefix</span>
<span class="line-added">535   int array_prefix_length() {</span>
<span class="line-added">536     return _type == T_ARRAY ? _array_prefix : 0;</span>
<span class="line-added">537   }</span>
<span class="line-added">538 </span>
<span class="line-added">539   // In case you want only the array base type,</span>
<span class="line-added">540   // reset the stream after skipping some brackets &#39;[&#39;.</span>
<span class="line-added">541   // (The argument is clipped to array_prefix_length(),</span>
<span class="line-added">542   // and if it ends up as zero this call is a nop.</span>
<span class="line-added">543   // The default is value skips all brackets &#39;[&#39;.)</span>
<span class="line-added">544   int skip_array_prefix(int prefix_length = 9999);</span>
<span class="line-added">545 </span>
<span class="line-added">546   // free-standing lookups (bring your own CL/PD pair)</span>
<span class="line-added">547   enum FailureMode { ReturnNull, NCDFError, CachedOrNull };</span>
<span class="line-added">548   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-added">549   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
550 };
551 
<span class="line-modified">552 // Here is how all the SignatureIterator classes invoke the</span>
<span class="line-modified">553 // SignatureStream engine to do their parsing.</span>
<span class="line-added">554 template&lt;typename T&gt; inline</span>
<span class="line-added">555 void SignatureIterator::do_parameters_on(T* callback) {</span>
<span class="line-added">556   fingerprint_t unaccumulator = _fingerprint;</span>
<span class="line-added">557 </span>
<span class="line-added">558   // Check for too many arguments, or missing fingerprint:</span>
<span class="line-added">559   if (!fp_is_valid(unaccumulator)) {</span>
<span class="line-added">560     SignatureStream ss(_signature);</span>
<span class="line-added">561     for (; !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">562       callback-&gt;do_type(ss.type());</span>
<span class="line-added">563     }</span>
<span class="line-added">564     // while we are here, capture the return type</span>
<span class="line-added">565     _return_type = ss.type();</span>
<span class="line-added">566   } else {</span>
<span class="line-added">567     // Optimized version of do_parameters when fingerprint is known</span>
<span class="line-added">568     assert(_return_type != T_ILLEGAL, &quot;return type already captured from fp&quot;);</span>
<span class="line-added">569     unaccumulator = fp_start_parameters(unaccumulator);</span>
<span class="line-added">570     for (BasicType type; (type = fp_next_parameter(unaccumulator)) != (BasicType)fp_parameters_done; ) {</span>
<span class="line-added">571       assert(fp_is_valid_type(type), &quot;garbled fingerprint&quot;);</span>
<span class="line-added">572       callback-&gt;do_type(type);</span>
<span class="line-added">573     }</span>
<span class="line-added">574   }</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
<span class="line-added">577  #ifdef ASSERT</span>
<span class="line-added">578  class SignatureVerifier : public StackObj {</span>
579   public:
580     static bool is_valid_method_signature(Symbol* sig);
581     static bool is_valid_type_signature(Symbol* sig);
582   private:
583     static ssize_t is_valid_type(const char*, ssize_t);
584 };
585 #endif
586 #endif // SHARE_RUNTIME_SIGNATURE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="signature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>