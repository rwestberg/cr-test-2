<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/signature.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/signature.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;memory/oopFactory.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/instanceKlass.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;oops/symbol.hpp&quot;
 34 #include &quot;oops/typeArrayKlass.hpp&quot;



 35 #include &quot;runtime/signature.hpp&quot;
 36 
 37 // Implementation of SignatureIterator
 38 
 39 // Signature syntax:
 40 //
 41 // Signature  = &quot;(&quot; {Parameter} &quot;)&quot; ReturnType.
 42 // Parameter  = FieldType.
 43 // ReturnType = FieldType | &quot;V&quot;.
 44 // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;[&quot; FieldType.
 45 // ClassName  = string.
 46 
























 47 
<span class="line-modified"> 48 SignatureIterator::SignatureIterator(Symbol* signature) {</span>
<span class="line-modified"> 49   _signature       = signature;</span>
<span class="line-modified"> 50   _parameter_index = 0;</span>





 51 }
 52 
<span class="line-modified"> 53 void SignatureIterator::expect(char c) {</span>
<span class="line-modified"> 54   if (_signature-&gt;char_at(_index) != c) fatal(&quot;expecting %c&quot;, c);</span>
<span class="line-modified"> 55   _index++;</span>



 56 }
 57 
<span class="line-modified"> 58 int SignatureIterator::parse_type() {</span>
<span class="line-modified"> 59   // Note: This function could be simplified by using &quot;return T_XXX_size;&quot;</span>
<span class="line-modified"> 60   //       instead of the assignment and the break statements. However, it</span>
<span class="line-modified"> 61   //       seems that the product build for win32_i486 with MS VC++ 6.0 doesn&#39;t</span>
<span class="line-modified"> 62   //       work (stack underflow for some tests) - this seems to be a VC++ 6.0</span>
<span class="line-removed"> 63   //       compiler bug (was problem - gri 4/27/2000).</span>
<span class="line-removed"> 64   int size = -1;</span>
<span class="line-removed"> 65   switch(_signature-&gt;char_at(_index)) {</span>
<span class="line-removed"> 66     case JVM_SIGNATURE_BYTE:    do_byte(); if (_parameter_index &lt; 0 ) _return_type = T_BYTE;</span>
<span class="line-removed"> 67                                   _index++; size = T_BYTE_size; break;</span>
<span class="line-removed"> 68     case JVM_SIGNATURE_CHAR:    do_char(); if (_parameter_index &lt; 0 ) _return_type = T_CHAR;</span>
<span class="line-removed"> 69                                   _index++; size = T_CHAR_size; break;</span>
<span class="line-removed"> 70     case JVM_SIGNATURE_DOUBLE:  do_double(); if (_parameter_index &lt; 0 ) _return_type = T_DOUBLE;</span>
<span class="line-removed"> 71                                   _index++; size = T_DOUBLE_size; break;</span>
<span class="line-removed"> 72     case JVM_SIGNATURE_FLOAT:   do_float(); if (_parameter_index &lt; 0 ) _return_type = T_FLOAT;</span>
<span class="line-removed"> 73                                   _index++; size = T_FLOAT_size; break;</span>
<span class="line-removed"> 74     case JVM_SIGNATURE_INT:     do_int(); if (_parameter_index &lt; 0 ) _return_type = T_INT;</span>
<span class="line-removed"> 75                                   _index++; size = T_INT_size; break;</span>
<span class="line-removed"> 76     case JVM_SIGNATURE_LONG:    do_long(); if (_parameter_index &lt; 0 ) _return_type = T_LONG;</span>
<span class="line-removed"> 77                                   _index++; size = T_LONG_size; break;</span>
<span class="line-removed"> 78     case JVM_SIGNATURE_SHORT:   do_short(); if (_parameter_index &lt; 0 ) _return_type = T_SHORT;</span>
<span class="line-removed"> 79                                   _index++; size = T_SHORT_size; break;</span>
<span class="line-removed"> 80     case JVM_SIGNATURE_BOOLEAN: do_bool(); if (_parameter_index &lt; 0 ) _return_type = T_BOOLEAN;</span>
<span class="line-removed"> 81                                   _index++; size = T_BOOLEAN_size; break;</span>
<span class="line-removed"> 82     case JVM_SIGNATURE_VOID:    do_void(); if (_parameter_index &lt; 0 ) _return_type = T_VOID;</span>
<span class="line-removed"> 83                                   _index++; size = T_VOID_size; break;</span>
<span class="line-removed"> 84     case JVM_SIGNATURE_CLASS:</span>
<span class="line-removed"> 85       { int begin = ++_index;</span>
<span class="line-removed"> 86         Symbol* sig = _signature;</span>
<span class="line-removed"> 87         while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="line-removed"> 88         do_object(begin, _index);</span>
<span class="line-removed"> 89       }</span>
<span class="line-removed"> 90       if (_parameter_index &lt; 0 ) _return_type = T_OBJECT;</span>
<span class="line-removed"> 91       size = T_OBJECT_size;</span>
<span class="line-removed"> 92       break;</span>
<span class="line-removed"> 93     case JVM_SIGNATURE_ARRAY:</span>
<span class="line-removed"> 94       { int begin = ++_index;</span>
<span class="line-removed"> 95         Symbol* sig = _signature;</span>
<span class="line-removed"> 96         while (sig-&gt;char_at(_index) == JVM_SIGNATURE_ARRAY) {</span>
<span class="line-removed"> 97           _index++;</span>
<span class="line-removed"> 98         }</span>
<span class="line-removed"> 99         if (sig-&gt;char_at(_index) == JVM_SIGNATURE_CLASS) {</span>
<span class="line-removed">100           while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="line-removed">101         } else {</span>
<span class="line-removed">102           _index++;</span>
<span class="line-removed">103         }</span>
<span class="line-removed">104         do_array(begin, _index);</span>
<span class="line-removed">105        if (_parameter_index &lt; 0 ) _return_type = T_ARRAY;</span>
<span class="line-removed">106       }</span>
<span class="line-removed">107       size = T_ARRAY_size;</span>
<span class="line-removed">108       break;</span>
<span class="line-removed">109     default:</span>
<span class="line-removed">110       ShouldNotReachHere();</span>
<span class="line-removed">111       break;</span>
<span class="line-removed">112   }</span>
<span class="line-removed">113   assert(size &gt;= 0, &quot;size must be set&quot;);</span>
<span class="line-removed">114   return size;</span>
115 }
116 






117 
<span class="line-modified">118 void SignatureIterator::check_signature_end() {</span>
<span class="line-modified">119   if (_index &lt; _signature-&gt;utf8_length()) {</span>
<span class="line-modified">120     tty-&gt;print_cr(&quot;too many chars in signature&quot;);</span>
<span class="line-modified">121     _signature-&gt;print_value_on(tty);</span>
<span class="line-modified">122     tty-&gt;print_cr(&quot; @ %d&quot;, _index);</span>
<span class="line-removed">123   }</span>
124 }
125 












126 
<span class="line-modified">127 void SignatureIterator::iterate_parameters() {</span>
<span class="line-modified">128   // Parse parameters</span>
<span class="line-modified">129   _index = 0;</span>
<span class="line-modified">130   _parameter_index = 0;</span>
<span class="line-modified">131   expect(JVM_SIGNATURE_FUNC);</span>
<span class="line-modified">132   while (_signature-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) _parameter_index += parse_type();</span>
<span class="line-modified">133   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="line-modified">134   _parameter_index = 0;</span>
<span class="line-modified">135 }</span>
136 
<span class="line-modified">137 // Optimized version of iterate_parameters when fingerprint is known</span>
<span class="line-modified">138 void SignatureIterator::iterate_parameters( uint64_t fingerprint ) {</span>
<span class="line-modified">139   uint64_t saved_fingerprint = fingerprint;</span>

140 
<span class="line-modified">141   // Check for too many arguments</span>
<span class="line-modified">142   if (fingerprint == (uint64_t)CONST64(-1)) {</span>
<span class="line-modified">143     SignatureIterator::iterate_parameters();</span>
<span class="line-modified">144     return;</span>


145   }
146 
<span class="line-modified">147   assert(fingerprint, &quot;Fingerprint should not be 0&quot;);</span>
<span class="line-modified">148 </span>
<span class="line-modified">149   _parameter_index = 0;</span>
<span class="line-modified">150   fingerprint = fingerprint &gt;&gt; (static_feature_size + result_feature_size);</span>
<span class="line-modified">151   while ( 1 ) {</span>
<span class="line-modified">152     switch ( fingerprint &amp; parameter_feature_mask ) {</span>
<span class="line-removed">153       case bool_parm:</span>
<span class="line-removed">154         do_bool();</span>
<span class="line-removed">155         _parameter_index += T_BOOLEAN_size;</span>
<span class="line-removed">156         break;</span>
<span class="line-removed">157       case byte_parm:</span>
<span class="line-removed">158         do_byte();</span>
<span class="line-removed">159         _parameter_index += T_BYTE_size;</span>
<span class="line-removed">160         break;</span>
<span class="line-removed">161       case char_parm:</span>
<span class="line-removed">162         do_char();</span>
<span class="line-removed">163         _parameter_index += T_CHAR_size;</span>
<span class="line-removed">164         break;</span>
<span class="line-removed">165       case short_parm:</span>
<span class="line-removed">166         do_short();</span>
<span class="line-removed">167         _parameter_index += T_SHORT_size;</span>
<span class="line-removed">168         break;</span>
<span class="line-removed">169       case int_parm:</span>
<span class="line-removed">170         do_int();</span>
<span class="line-removed">171         _parameter_index += T_INT_size;</span>
<span class="line-removed">172         break;</span>
<span class="line-removed">173       case obj_parm:</span>
<span class="line-removed">174         do_object(0, 0);</span>
<span class="line-removed">175         _parameter_index += T_OBJECT_size;</span>
<span class="line-removed">176         break;</span>
<span class="line-removed">177       case long_parm:</span>
<span class="line-removed">178         do_long();</span>
<span class="line-removed">179         _parameter_index += T_LONG_size;</span>
<span class="line-removed">180         break;</span>
<span class="line-removed">181       case float_parm:</span>
<span class="line-removed">182         do_float();</span>
<span class="line-removed">183         _parameter_index += T_FLOAT_size;</span>
<span class="line-removed">184         break;</span>
<span class="line-removed">185       case double_parm:</span>
<span class="line-removed">186         do_double();</span>
<span class="line-removed">187         _parameter_index += T_DOUBLE_size;</span>
<span class="line-removed">188         break;</span>
<span class="line-removed">189       case done_parm:</span>
<span class="line-removed">190         return;</span>
<span class="line-removed">191       default:</span>
<span class="line-removed">192         tty-&gt;print_cr(&quot;*** parameter is &quot; UINT64_FORMAT, fingerprint &amp; parameter_feature_mask);</span>
<span class="line-removed">193         tty-&gt;print_cr(&quot;*** fingerprint is &quot; PTR64_FORMAT, saved_fingerprint);</span>
<span class="line-removed">194         ShouldNotReachHere();</span>
<span class="line-removed">195         break;</span>
<span class="line-removed">196     }</span>
<span class="line-removed">197     fingerprint &gt;&gt;= parameter_feature_size;</span>
198   }
<span class="line-removed">199 }</span>
200 





201 
<span class="line-modified">202 void SignatureIterator::iterate_returntype() {</span>
<span class="line-modified">203   // Ignore parameters</span>
<span class="line-modified">204   _index = 0;</span>
<span class="line-modified">205   expect(JVM_SIGNATURE_FUNC);</span>
<span class="line-modified">206   Symbol* sig = _signature;</span>
<span class="line-modified">207   // Need to skip over each type in the signature&#39;s argument list until a</span>
<span class="line-removed">208   // closing &#39;)&#39; is found., then get the return type.  We cannot just scan</span>
<span class="line-removed">209   // for the first &#39;)&#39; because &#39;)&#39; is a legal character in a type name.</span>
<span class="line-removed">210   while (sig-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) {</span>
<span class="line-removed">211     switch(sig-&gt;char_at(_index)) {</span>
<span class="line-removed">212       case JVM_SIGNATURE_BYTE:</span>
<span class="line-removed">213       case JVM_SIGNATURE_CHAR:</span>
<span class="line-removed">214       case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-removed">215       case JVM_SIGNATURE_FLOAT:</span>
<span class="line-removed">216       case JVM_SIGNATURE_INT:</span>
<span class="line-removed">217       case JVM_SIGNATURE_LONG:</span>
<span class="line-removed">218       case JVM_SIGNATURE_SHORT:</span>
<span class="line-removed">219       case JVM_SIGNATURE_BOOLEAN:</span>
<span class="line-removed">220       case JVM_SIGNATURE_VOID:</span>
<span class="line-removed">221         {</span>
<span class="line-removed">222           _index++;</span>
<span class="line-removed">223         }</span>
<span class="line-removed">224         break;</span>
<span class="line-removed">225       case JVM_SIGNATURE_CLASS:</span>
<span class="line-removed">226         {</span>
<span class="line-removed">227           while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="line-removed">228         }</span>
<span class="line-removed">229         break;</span>
<span class="line-removed">230       case JVM_SIGNATURE_ARRAY:</span>
<span class="line-removed">231         {</span>
<span class="line-removed">232           while (sig-&gt;char_at(++_index) == JVM_SIGNATURE_ARRAY) ;</span>
<span class="line-removed">233           if (sig-&gt;char_at(_index) == JVM_SIGNATURE_CLASS) {</span>
<span class="line-removed">234             while (sig-&gt;char_at(_index++) != JVM_SIGNATURE_ENDCLASS) ;</span>
<span class="line-removed">235           } else {</span>
<span class="line-removed">236             _index++;</span>
<span class="line-removed">237           }</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239         break;</span>
<span class="line-removed">240       default:</span>
<span class="line-removed">241         ShouldNotReachHere();</span>
<span class="line-removed">242         break;</span>
<span class="line-removed">243     }</span>
244   }
<span class="line-removed">245   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="line-removed">246   // Parse return type</span>
<span class="line-removed">247   _parameter_index = -1;</span>
<span class="line-removed">248   parse_type();</span>
<span class="line-removed">249   check_signature_end();</span>
<span class="line-removed">250   _parameter_index = 0;</span>
251 }
252 

253 
<span class="line-modified">254 void SignatureIterator::iterate() {</span>
<span class="line-modified">255   // Parse parameters</span>
<span class="line-modified">256   _parameter_index = 0;</span>
<span class="line-modified">257   _index = 0;</span>
<span class="line-modified">258   expect(JVM_SIGNATURE_FUNC);</span>
<span class="line-modified">259   while (_signature-&gt;char_at(_index) != JVM_SIGNATURE_ENDFUNC) _parameter_index += parse_type();</span>
<span class="line-modified">260   expect(JVM_SIGNATURE_ENDFUNC);</span>
<span class="line-modified">261   // Parse return type</span>
<span class="line-removed">262   _parameter_index = -1;</span>
<span class="line-removed">263   parse_type();</span>
<span class="line-removed">264   check_signature_end();</span>
<span class="line-removed">265   _parameter_index = 0;</span>
266 }
267 
<span class="line-modified">268 </span>
<span class="line-modified">269 // Implementation of SignatureStream</span>
<span class="line-modified">270 SignatureStream::SignatureStream(Symbol* signature, bool is_method) :</span>
<span class="line-modified">271                    _signature(signature), _at_return_type(false), _previous_name(NULL), _names(NULL) {</span>
<span class="line-modified">272   _begin = _end = (is_method ? 1 : 0);  // skip first &#39;(&#39; in method signatures</span>








273   next();
274 }
275 
276 SignatureStream::~SignatureStream() {
277   // decrement refcount for names created during signature parsing
278   if (_names != NULL) {
279     for (int i = 0; i &lt; _names-&gt;length(); i++) {
280       _names-&gt;at(i)-&gt;decrement_refcount();
281     }


282   }
283 }
284 
<span class="line-modified">285 bool SignatureStream::is_done() const {</span>
<span class="line-modified">286   return _end &gt; _signature-&gt;utf8_length();</span>






















287 }
288 


























289 
<span class="line-modified">290 void SignatureStream::next_non_primitive(int t) {</span>
<span class="line-modified">291   switch (t) {</span>
<span class="line-modified">292     case JVM_SIGNATURE_CLASS: {</span>
<span class="line-modified">293       _type = T_OBJECT;</span>
<span class="line-modified">294       Symbol* sig = _signature;</span>
<span class="line-modified">295       while (sig-&gt;char_at(_end++) != JVM_SIGNATURE_ENDCLASS);</span>
<span class="line-modified">296       break;</span>
<span class="line-modified">297     }</span>
<span class="line-modified">298     case JVM_SIGNATURE_ARRAY: {</span>
<span class="line-removed">299       _type = T_ARRAY;</span>
<span class="line-removed">300       Symbol* sig = _signature;</span>
<span class="line-removed">301       char c = sig-&gt;char_at(_end);</span>
<span class="line-removed">302       while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="line-removed">303       while (sig-&gt;char_at(_end) == JVM_SIGNATURE_ARRAY) {</span>
<span class="line-removed">304         _end++;</span>
<span class="line-removed">305         c = sig-&gt;char_at(_end);</span>
<span class="line-removed">306         while (&#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;) c = sig-&gt;char_at(_end++);</span>
<span class="line-removed">307       }</span>
<span class="line-removed">308       switch(sig-&gt;char_at(_end)) {</span>
<span class="line-removed">309         case JVM_SIGNATURE_BYTE:</span>
<span class="line-removed">310         case JVM_SIGNATURE_CHAR:</span>
<span class="line-removed">311         case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-removed">312         case JVM_SIGNATURE_FLOAT:</span>
<span class="line-removed">313         case JVM_SIGNATURE_INT:</span>
<span class="line-removed">314         case JVM_SIGNATURE_LONG:</span>
<span class="line-removed">315         case JVM_SIGNATURE_SHORT:</span>
<span class="line-removed">316         case JVM_SIGNATURE_BOOLEAN:_end++; break;</span>
<span class="line-removed">317         default: {</span>
<span class="line-removed">318           while (sig-&gt;char_at(_end++) != JVM_SIGNATURE_ENDCLASS);</span>
<span class="line-removed">319           break;</span>
<span class="line-removed">320         }</span>
<span class="line-removed">321       }</span>
<span class="line-removed">322       break;</span>
<span class="line-removed">323     }</span>
<span class="line-removed">324     case JVM_SIGNATURE_ENDFUNC: _end++; next(); _at_return_type = true; break;</span>
<span class="line-removed">325     default : ShouldNotReachHere();</span>
326   }














327 }
328 



























329 
<span class="line-modified">330 bool SignatureStream::is_object() const {</span>
<span class="line-modified">331   return _type == T_OBJECT</span>
<span class="line-modified">332       || _type == T_ARRAY;</span>

333 }
334 
<span class="line-modified">335 bool SignatureStream::is_array() const {</span>
<span class="line-modified">336   return _type == T_ARRAY;</span>

















337 }

338 
<span class="line-modified">339 Symbol* SignatureStream::as_symbol() {</span>

340   // Create a symbol from for string _begin _end
<span class="line-modified">341   int begin = _begin;</span>
<span class="line-modified">342   int end   = _end;</span>
<span class="line-removed">343 </span>
<span class="line-removed">344   if (   _signature-&gt;char_at(_begin) == JVM_SIGNATURE_CLASS</span>
<span class="line-removed">345       &amp;&amp; _signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="line-removed">346     begin++;</span>
<span class="line-removed">347     end--;</span>
<span class="line-removed">348   }</span>
349 
350   const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
351   int len = end - begin;
352 
353   // Quick check for common symbols in signatures
<span class="line-modified">354   assert((vmSymbols::java_lang_String()-&gt;utf8_length() == 16 &amp;&amp; vmSymbols::java_lang_Object()-&gt;utf8_length() == 16), &quot;sanity&quot;);</span>
<span class="line-modified">355   if (len == 16 &amp;&amp;</span>
<span class="line-modified">356       strncmp(symbol_chars, &quot;java/lang/&quot;, 10) == 0) {</span>
<span class="line-modified">357     if (strncmp(&quot;String&quot;, symbol_chars + 10, 6) == 0) {</span>
358       return vmSymbols::java_lang_String();
<span class="line-modified">359     } else if (strncmp(&quot;Object&quot;, symbol_chars + 10, 6) == 0) {</span>
360       return vmSymbols::java_lang_Object();
361     }
362   }
363 
364   Symbol* name = _previous_name;
365   if (name != NULL &amp;&amp; name-&gt;equals(symbol_chars, len)) {
366     return name;
367   }
368 
369   // Save names for cleaning up reference count at the end of
370   // SignatureStream scope.
371   name = SymbolTable::new_symbol(symbol_chars, len);
<span class="line-modified">372   if (!name-&gt;is_permanent()) {</span>










373     if (_names == NULL) {
374       _names = new GrowableArray&lt;Symbol*&gt;(10);
375     }
376     _names-&gt;push(name);  // save new symbol for decrementing later
377   }
378   _previous_name = name;
379   return name;
380 }
381 
382 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
383                                  FailureMode failure_mode, TRAPS) {
<span class="line-modified">384   if (!is_object())  return NULL;</span>
385   Symbol* name = as_symbol();

386   if (failure_mode == ReturnNull) {
<span class="line-modified">387     return SystemDictionary::resolve_or_null(name, class_loader, protection_domain, THREAD);</span>










388   } else {



389     bool throw_error = (failure_mode == NCDFError);
<span class="line-modified">390     return SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, THREAD);</span>
391   }


392 }
393 
394 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
395                                     FailureMode failure_mode, TRAPS) {
<span class="line-modified">396   if (!is_object())</span>
397     return Universe::java_mirror(type());
398   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
399   if (klass == NULL)  return NULL;
400   return klass-&gt;java_mirror();
401 }
402 
<span class="line-modified">403 Symbol* SignatureStream::as_symbol_or_null() {</span>
<span class="line-modified">404   // Create a symbol from for string _begin _end</span>
<span class="line-modified">405   ResourceMark rm;</span>
<span class="line-removed">406 </span>
<span class="line-removed">407   int begin = _begin;</span>
<span class="line-removed">408   int end   = _end;</span>
<span class="line-removed">409 </span>
<span class="line-removed">410   if (   _signature-&gt;char_at(_begin) == JVM_SIGNATURE_CLASS</span>
<span class="line-removed">411       &amp;&amp; _signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS) {</span>
<span class="line-removed">412     begin++;</span>
<span class="line-removed">413     end--;</span>
414   }
<span class="line-removed">415 </span>
<span class="line-removed">416   char* buffer = NEW_RESOURCE_ARRAY(char, end - begin);</span>
<span class="line-removed">417   for (int index = begin; index &lt; end; index++) {</span>
<span class="line-removed">418     buffer[index - begin] = _signature-&gt;char_at(index);</span>
<span class="line-removed">419   }</span>
<span class="line-removed">420   Symbol* result = SymbolTable::probe(buffer, end - begin);</span>
<span class="line-removed">421   return result;</span>
422 }
423 
<span class="line-modified">424 int SignatureStream::reference_parameter_count() {</span>
<span class="line-modified">425   int args_count = 0;</span>
<span class="line-modified">426   for ( ; !at_return_type(); next()) {</span>
<span class="line-modified">427     if (is_object()) {</span>
<span class="line-modified">428       args_count++;</span>








429     }


430   }
<span class="line-modified">431   return args_count;</span>
432 }
433 
<span class="line-removed">434 #ifdef ASSERT</span>
435 bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {
436   const char* method_sig = (const char*)sig-&gt;bytes();
437   ssize_t len = sig-&gt;utf8_length();
438   ssize_t index = 0;
439   if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == JVM_SIGNATURE_FUNC) {
440     ++index;
441     while (index &lt; len &amp;&amp; method_sig[index] != JVM_SIGNATURE_ENDFUNC) {
442       ssize_t res = is_valid_type(&amp;method_sig[index], len - index);
443       if (res == -1) {
444         return false;
445       } else {
446         index += res;
447       }
448     }
449     if (index &lt; len &amp;&amp; method_sig[index] == JVM_SIGNATURE_ENDFUNC) {
450       // check the return type
451       ++index;
452       return (is_valid_type(&amp;method_sig[index], len - index) == (len - index));
453     }
454   }
</pre>
<hr />
<pre>
459   const char* type_sig = (const char*)sig-&gt;bytes();
460   ssize_t len = sig-&gt;utf8_length();
461   return (type_sig != NULL &amp;&amp; len &gt;= 1 &amp;&amp;
462           (is_valid_type(type_sig, len) == len));
463 }
464 
465 // Checks to see if the type (not to go beyond &#39;limit&#39;) refers to a valid type.
466 // Returns -1 if it is not, or the index of the next character that is not part
467 // of the type.  The type encoding may end before &#39;limit&#39; and that&#39;s ok.
468 ssize_t SignatureVerifier::is_valid_type(const char* type, ssize_t limit) {
469   ssize_t index = 0;
470 
471   // Iterate over any number of array dimensions
472   while (index &lt; limit &amp;&amp; type[index] == JVM_SIGNATURE_ARRAY) ++index;
473   if (index &gt;= limit) {
474     return -1;
475   }
476   switch (type[index]) {
477     case JVM_SIGNATURE_BYTE:
478     case JVM_SIGNATURE_CHAR:
<span class="line-removed">479     case JVM_SIGNATURE_DOUBLE:</span>
480     case JVM_SIGNATURE_FLOAT:

481     case JVM_SIGNATURE_INT:
482     case JVM_SIGNATURE_LONG:
483     case JVM_SIGNATURE_SHORT:
484     case JVM_SIGNATURE_BOOLEAN:
485     case JVM_SIGNATURE_VOID:
486       return index + 1;
487     case JVM_SIGNATURE_CLASS:
488       for (index = index + 1; index &lt; limit; ++index) {
489         char c = type[index];
490         switch (c) {
491           case JVM_SIGNATURE_ENDCLASS:
492             return index + 1;
493           case &#39;\0&#39;: case JVM_SIGNATURE_DOT: case JVM_SIGNATURE_ARRAY:
494             return -1;
495           default: ; // fall through
496         }
497       }
498       // fall through
499     default: ; // fall through
500   }
501   return -1;
502 }

503 #endif // ASSERT
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/symbolTable.hpp&quot;
 27 #include &quot;classfile/systemDictionary.hpp&quot;
 28 #include &quot;memory/oopFactory.hpp&quot;
 29 #include &quot;memory/resourceArea.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/instanceKlass.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;oops/symbol.hpp&quot;
 34 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added"> 35 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
<span class="line-added"> 36 #include &quot;runtime/handles.inline.hpp&quot;</span>
<span class="line-added"> 37 #include &quot;runtime/safepointVerifiers.hpp&quot;</span>
 38 #include &quot;runtime/signature.hpp&quot;
 39 
 40 // Implementation of SignatureIterator
 41 
 42 // Signature syntax:
 43 //
 44 // Signature  = &quot;(&quot; {Parameter} &quot;)&quot; ReturnType.
 45 // Parameter  = FieldType.
 46 // ReturnType = FieldType | &quot;V&quot;.
 47 // FieldType  = &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;F&quot; | &quot;I&quot; | &quot;J&quot; | &quot;S&quot; | &quot;Z&quot; | &quot;L&quot; ClassName &quot;;&quot; | &quot;[&quot; FieldType.
 48 // ClassName  = string.
 49 
<span class="line-added"> 50 // The ClassName string can be any JVM-style UTF8 string except:</span>
<span class="line-added"> 51 //  - an empty string (the empty string is never a name of any kind)</span>
<span class="line-added"> 52 //  - a string which begins or ends with slash &#39;/&#39; (the package separator)</span>
<span class="line-added"> 53 //  - a string which contains adjacent slashes &#39;//&#39; (no empty package names)</span>
<span class="line-added"> 54 //  - a string which contains a semicolon &#39;;&#39; (the end-delimiter)</span>
<span class="line-added"> 55 //  - a string which contains a left bracket &#39;[&#39; (the array marker)</span>
<span class="line-added"> 56 //  - a string which contains a dot &#39;.&#39; (the external package separator)</span>
<span class="line-added"> 57 //</span>
<span class="line-added"> 58 // Other &quot;meta-looking&quot; characters, such as &#39;(&#39; and &#39;&lt;&#39; and &#39;+&#39;,</span>
<span class="line-added"> 59 // are perfectly legitimate within a class name, for the JVM.</span>
<span class="line-added"> 60 // Class names which contain double slashes (&#39;a//b&#39;) and non-initial</span>
<span class="line-added"> 61 // brackets (&#39;a[b]&#39;) are reserved for possible enrichment of the</span>
<span class="line-added"> 62 // type language.</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64 void SignatureIterator::set_fingerprint(fingerprint_t fingerprint) {</span>
<span class="line-added"> 65   if (!fp_is_valid(fingerprint)) {</span>
<span class="line-added"> 66     _fingerprint = fingerprint;</span>
<span class="line-added"> 67     _return_type = T_ILLEGAL;</span>
<span class="line-added"> 68   } else if (fingerprint != _fingerprint) {</span>
<span class="line-added"> 69     assert(_fingerprint == zero_fingerprint(), &quot;consistent fingerprint values&quot;);</span>
<span class="line-added"> 70     _fingerprint = fingerprint;</span>
<span class="line-added"> 71     _return_type = fp_return_type(fingerprint);</span>
<span class="line-added"> 72   }</span>
<span class="line-added"> 73 }</span>
 74 
<span class="line-modified"> 75 BasicType SignatureIterator::return_type() {</span>
<span class="line-modified"> 76   if (_return_type == T_ILLEGAL) {</span>
<span class="line-modified"> 77     SignatureStream ss(_signature);</span>
<span class="line-added"> 78     ss.skip_to_return_type();</span>
<span class="line-added"> 79     _return_type = ss.type();</span>
<span class="line-added"> 80     assert(_return_type != T_ILLEGAL, &quot;illegal return type&quot;);</span>
<span class="line-added"> 81   }</span>
<span class="line-added"> 82   return _return_type;</span>
 83 }
 84 
<span class="line-modified"> 85 bool SignatureIterator::fp_is_valid_type(BasicType type, bool for_return_type) {</span>
<span class="line-modified"> 86   assert(type != (BasicType)fp_parameters_done, &quot;fingerprint is incorrectly at done&quot;);</span>
<span class="line-modified"> 87   assert(((int)type &amp; ~fp_parameter_feature_mask) == 0, &quot;fingerprint feature mask yielded non-zero value&quot;);</span>
<span class="line-added"> 88   return (is_java_primitive(type) ||</span>
<span class="line-added"> 89           is_reference_type(type) ||</span>
<span class="line-added"> 90           (for_return_type &amp;&amp; type == T_VOID));</span>
 91 }
 92 
<span class="line-modified"> 93 ArgumentSizeComputer::ArgumentSizeComputer(Symbol* signature)</span>
<span class="line-modified"> 94   : SignatureIterator(signature)</span>
<span class="line-modified"> 95 {</span>
<span class="line-modified"> 96   _size = 0;</span>
<span class="line-modified"> 97   do_parameters_on(this);  // non-virtual template execution</span>




















































 98 }
 99 
<span class="line-added">100 ArgumentCount::ArgumentCount(Symbol* signature)</span>
<span class="line-added">101   : SignatureIterator(signature)</span>
<span class="line-added">102 {</span>
<span class="line-added">103   _size = 0;</span>
<span class="line-added">104   do_parameters_on(this);  // non-virtual template execution</span>
<span class="line-added">105 }</span>
106 
<span class="line-modified">107 ReferenceArgumentCount::ReferenceArgumentCount(Symbol* signature)</span>
<span class="line-modified">108   : SignatureIterator(signature)</span>
<span class="line-modified">109 {</span>
<span class="line-modified">110   _refs = 0;</span>
<span class="line-modified">111   do_parameters_on(this);  // non-virtual template execution</span>

112 }
113 
<span class="line-added">114 void Fingerprinter::compute_fingerprint_and_return_type(bool static_flag) {</span>
<span class="line-added">115   // See if we fingerprinted this method already</span>
<span class="line-added">116   if (_method != NULL) {</span>
<span class="line-added">117     assert(!static_flag, &quot;must not be passed by caller&quot;);</span>
<span class="line-added">118     static_flag = _method-&gt;is_static();</span>
<span class="line-added">119     _fingerprint = _method-&gt;constMethod()-&gt;fingerprint();</span>
<span class="line-added">120 </span>
<span class="line-added">121     if (_fingerprint != zero_fingerprint()) {</span>
<span class="line-added">122       _return_type = _method-&gt;result_type();</span>
<span class="line-added">123       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);</span>
<span class="line-added">124       return;</span>
<span class="line-added">125     }</span>
126 
<span class="line-modified">127     if (_method-&gt;size_of_parameters() &gt; fp_max_size_of_parameters) {</span>
<span class="line-modified">128       _fingerprint = overflow_fingerprint();</span>
<span class="line-modified">129       _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>
<span class="line-modified">130       // as long as we are here compute the return type:</span>
<span class="line-modified">131       _return_type = ResultTypeFinder(_method-&gt;signature()).type();</span>
<span class="line-modified">132       assert(is_java_type(_return_type), &quot;return type must be a java type&quot;);</span>
<span class="line-modified">133       return;</span>
<span class="line-modified">134     }</span>
<span class="line-modified">135   }</span>
136 
<span class="line-modified">137   // Note:  This will always take the slow path, since _fp==zero_fp.</span>
<span class="line-modified">138   initialize_accumulator();</span>
<span class="line-modified">139   do_parameters_on(this);</span>
<span class="line-added">140   assert(fp_is_valid_type(_return_type, true), &quot;bad result type&quot;);</span>
141 
<span class="line-modified">142   // Fill in the return type and static bits:</span>
<span class="line-modified">143   _accumulator |= _return_type &lt;&lt; fp_static_feature_size;</span>
<span class="line-modified">144   if (static_flag) {</span>
<span class="line-modified">145     _accumulator |= fp_is_static_bit;</span>
<span class="line-added">146   } else {</span>
<span class="line-added">147     _param_size += 1;  // this is the convention for Method::compute_size_of_parameters</span>
148   }
149 
<span class="line-modified">150   // Detect overflow.  (We counted _param_size correctly.)</span>
<span class="line-modified">151   if (_method == NULL &amp;&amp; _param_size &gt; fp_max_size_of_parameters) {</span>
<span class="line-modified">152     // We did a one-pass computation of argument size, return type,</span>
<span class="line-modified">153     // and fingerprint.</span>
<span class="line-modified">154     _fingerprint = overflow_fingerprint();</span>
<span class="line-modified">155     return;</span>













































156   }

157 
<span class="line-added">158   assert(_shift_count &lt; BitsPerLong,</span>
<span class="line-added">159          &quot;shift count overflow %d (%d vs. %d): %s&quot;,</span>
<span class="line-added">160          _shift_count, _param_size, fp_max_size_of_parameters,</span>
<span class="line-added">161          _signature-&gt;as_C_string());</span>
<span class="line-added">162   assert((_accumulator &gt;&gt; _shift_count) == fp_parameters_done, &quot;must be zero&quot;);</span>
163 
<span class="line-modified">164   // This is the result, along with _return_type:</span>
<span class="line-modified">165   _fingerprint = _accumulator;</span>
<span class="line-modified">166 </span>
<span class="line-modified">167   // Cache the result on the method itself:</span>
<span class="line-modified">168   if (_method != NULL) {</span>
<span class="line-modified">169     _method-&gt;constMethod()-&gt;set_fingerprint(_fingerprint);</span>




































170   }






171 }
172 
<span class="line-added">173 // Implementation of SignatureStream</span>
174 
<span class="line-modified">175 static inline int decode_signature_char(int ch) {</span>
<span class="line-modified">176   switch (ch) {</span>
<span class="line-modified">177 #define EACH_SIG(ch, bt, ignore) \</span>
<span class="line-modified">178     case ch: return bt;</span>
<span class="line-modified">179     SIGNATURE_TYPES_DO(EACH_SIG, ignore)</span>
<span class="line-modified">180 #undef EACH_SIG</span>
<span class="line-modified">181   }</span>
<span class="line-modified">182   return 0;</span>




183 }
184 
<span class="line-modified">185 SignatureStream::SignatureStream(const Symbol* signature,</span>
<span class="line-modified">186                                  bool is_method) {</span>
<span class="line-modified">187   assert(!is_method || signature-&gt;starts_with(JVM_SIGNATURE_FUNC),</span>
<span class="line-modified">188          &quot;method signature required&quot;);</span>
<span class="line-modified">189   _signature = signature;</span>
<span class="line-added">190   _limit = signature-&gt;utf8_length();</span>
<span class="line-added">191   int oz = (is_method ? 1 : 0);</span>
<span class="line-added">192   _state = oz;</span>
<span class="line-added">193   assert(_state == (int)(is_method ? _s_method : _s_field), &quot;signature state incorrectly set&quot;);</span>
<span class="line-added">194   _begin = _end = oz; // skip first &#39;(&#39; in method signatures</span>
<span class="line-added">195   _array_prefix = 0;  // just for definiteness</span>
<span class="line-added">196   _previous_name = NULL;</span>
<span class="line-added">197   _names = NULL;</span>
198   next();
199 }
200 
201 SignatureStream::~SignatureStream() {
202   // decrement refcount for names created during signature parsing
203   if (_names != NULL) {
204     for (int i = 0; i &lt; _names-&gt;length(); i++) {
205       _names-&gt;at(i)-&gt;decrement_refcount();
206     }
<span class="line-added">207   } else if (_previous_name != NULL &amp;&amp; !_previous_name-&gt;is_permanent()) {</span>
<span class="line-added">208     _previous_name-&gt;decrement_refcount();</span>
209   }
210 }
211 
<span class="line-modified">212 inline int SignatureStream::scan_non_primitive(BasicType type) {</span>
<span class="line-modified">213   const u1* base = _signature-&gt;bytes();</span>
<span class="line-added">214   int end = _end;</span>
<span class="line-added">215   int limit = _limit;</span>
<span class="line-added">216   const u1* tem;</span>
<span class="line-added">217   switch (type) {</span>
<span class="line-added">218   case T_OBJECT:</span>
<span class="line-added">219     tem = (const u1*) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);</span>
<span class="line-added">220     end = (tem == NULL ? limit : tem+1 - base);</span>
<span class="line-added">221     break;</span>
<span class="line-added">222 </span>
<span class="line-added">223   case T_ARRAY:</span>
<span class="line-added">224     while ((end &lt; limit) &amp;&amp; ((char)base[end] == JVM_SIGNATURE_ARRAY)) { end++; }</span>
<span class="line-added">225     _array_prefix = end - _end;  // number of &#39;[&#39; chars just skipped</span>
<span class="line-added">226     if (Signature::has_envelope(base[end++])) {</span>
<span class="line-added">227       tem = (const u1*) memchr(&amp;base[end], JVM_SIGNATURE_ENDCLASS, limit - end);</span>
<span class="line-added">228       end = (tem == NULL ? limit : tem+1 - base);</span>
<span class="line-added">229       break;</span>
<span class="line-added">230     }</span>
<span class="line-added">231     break;</span>
<span class="line-added">232 </span>
<span class="line-added">233   default : ShouldNotReachHere();</span>
<span class="line-added">234   }</span>
<span class="line-added">235   return end;</span>
236 }
237 
<span class="line-added">238 void SignatureStream::next() {</span>
<span class="line-added">239   const Symbol* sig = _signature;</span>
<span class="line-added">240   int len = _limit;</span>
<span class="line-added">241   if (_end &gt;= len) { set_done(); return; }</span>
<span class="line-added">242   _begin = _end;</span>
<span class="line-added">243   int ch = sig-&gt;char_at(_begin);</span>
<span class="line-added">244   int btcode = decode_signature_char(ch);</span>
<span class="line-added">245   if (btcode == 0) {</span>
<span class="line-added">246     guarantee(ch == JVM_SIGNATURE_ENDFUNC, &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="line-added">247     assert(_state == _s_method, &quot;must be in method&quot;);</span>
<span class="line-added">248     _state = _s_method_return;</span>
<span class="line-added">249     _begin = ++_end;</span>
<span class="line-added">250     if (_end &gt;= len) { set_done(); return; }</span>
<span class="line-added">251     ch = sig-&gt;char_at(_begin);</span>
<span class="line-added">252     btcode = decode_signature_char(ch);</span>
<span class="line-added">253   }</span>
<span class="line-added">254   BasicType bt = (BasicType) btcode;</span>
<span class="line-added">255   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="line-added">256   _type = bt;</span>
<span class="line-added">257   if (!is_reference_type(bt)) {</span>
<span class="line-added">258     // Skip over a single character for a primitive type (or void).</span>
<span class="line-added">259     _end++;</span>
<span class="line-added">260     return;</span>
<span class="line-added">261   }</span>
<span class="line-added">262   _end = scan_non_primitive(bt);</span>
<span class="line-added">263 }</span>
264 
<span class="line-modified">265 int SignatureStream::skip_array_prefix(int max_skip_length) {</span>
<span class="line-modified">266   if (_type != T_ARRAY) {</span>
<span class="line-modified">267     return 0;</span>
<span class="line-modified">268   }</span>
<span class="line-modified">269   if (_array_prefix &gt; max_skip_length) {</span>
<span class="line-modified">270     // strip some but not all levels of T_ARRAY</span>
<span class="line-modified">271     _array_prefix -= max_skip_length;</span>
<span class="line-modified">272     _begin += max_skip_length;</span>
<span class="line-modified">273     return max_skip_length;</span>



























274   }
<span class="line-added">275   // we are stripping all levels of T_ARRAY,</span>
<span class="line-added">276   // so we must decode the next character</span>
<span class="line-added">277   int whole_array_prefix = _array_prefix;</span>
<span class="line-added">278   int new_begin = _begin + whole_array_prefix;</span>
<span class="line-added">279   _begin = new_begin;</span>
<span class="line-added">280   int ch = _signature-&gt;char_at(new_begin);</span>
<span class="line-added">281   int btcode = decode_signature_char(ch);</span>
<span class="line-added">282   BasicType bt = (BasicType) btcode;</span>
<span class="line-added">283   assert(ch == type2char(bt), &quot;bad signature char %c/%d&quot;, ch, ch);</span>
<span class="line-added">284   _type = bt;</span>
<span class="line-added">285   assert(bt != T_VOID &amp;&amp; bt != T_ARRAY, &quot;bad signature type&quot;);</span>
<span class="line-added">286   // Don&#39;t bother to call scan_non_primitive, since it won&#39;t</span>
<span class="line-added">287   // change the value of _end.</span>
<span class="line-added">288   return whole_array_prefix;</span>
289 }
290 
<span class="line-added">291 bool Signature::is_valid_array_signature(const Symbol* sig) {</span>
<span class="line-added">292   assert(sig-&gt;utf8_length() &gt; 1, &quot;this should already have been checked&quot;);</span>
<span class="line-added">293   assert(sig-&gt;char_at(0) == JVM_SIGNATURE_ARRAY, &quot;this should already have been checked&quot;);</span>
<span class="line-added">294   // The first character is already checked</span>
<span class="line-added">295   int i = 1;</span>
<span class="line-added">296   int len = sig-&gt;utf8_length();</span>
<span class="line-added">297   // First skip all &#39;[&#39;s</span>
<span class="line-added">298   while(i &lt; len - 1 &amp;&amp; sig-&gt;char_at(i) == JVM_SIGNATURE_ARRAY) i++;</span>
<span class="line-added">299 </span>
<span class="line-added">300   // Check type</span>
<span class="line-added">301   switch(sig-&gt;char_at(i)) {</span>
<span class="line-added">302   case JVM_SIGNATURE_BYTE:</span>
<span class="line-added">303   case JVM_SIGNATURE_CHAR:</span>
<span class="line-added">304   case JVM_SIGNATURE_DOUBLE:</span>
<span class="line-added">305   case JVM_SIGNATURE_FLOAT:</span>
<span class="line-added">306   case JVM_SIGNATURE_INT:</span>
<span class="line-added">307   case JVM_SIGNATURE_LONG:</span>
<span class="line-added">308   case JVM_SIGNATURE_SHORT:</span>
<span class="line-added">309   case JVM_SIGNATURE_BOOLEAN:</span>
<span class="line-added">310     // If it is an array, the type is the last character</span>
<span class="line-added">311     return (i + 1 == len);</span>
<span class="line-added">312   case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">313     // If it is an object, the last character must be a &#39;;&#39;</span>
<span class="line-added">314     return sig-&gt;char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;</span>
<span class="line-added">315   }</span>
<span class="line-added">316   return false;</span>
<span class="line-added">317 }</span>
318 
<span class="line-modified">319 BasicType Signature::basic_type(int ch) {</span>
<span class="line-modified">320   int btcode = decode_signature_char(ch);</span>
<span class="line-modified">321   if (btcode == 0)  return T_ILLEGAL;</span>
<span class="line-added">322   return (BasicType) btcode;</span>
323 }
324 
<span class="line-modified">325 static const int jl_len = 10, object_len = 6, jl_object_len = jl_len + object_len;</span>
<span class="line-modified">326 static const char jl_str[] = &quot;java/lang/&quot;;</span>
<span class="line-added">327 </span>
<span class="line-added">328 #ifdef ASSERT</span>
<span class="line-added">329 static bool signature_symbols_sane() {</span>
<span class="line-added">330   static bool done;</span>
<span class="line-added">331   if (done)  return true;</span>
<span class="line-added">332   done = true;</span>
<span class="line-added">333   // test some tense code that looks for common symbol names:</span>
<span class="line-added">334   assert(vmSymbols::java_lang_Object()-&gt;utf8_length() == jl_object_len &amp;&amp;</span>
<span class="line-added">335          vmSymbols::java_lang_Object()-&gt;starts_with(jl_str, jl_len) &amp;&amp;</span>
<span class="line-added">336          vmSymbols::java_lang_Object()-&gt;ends_with(&quot;Object&quot;, object_len) &amp;&amp;</span>
<span class="line-added">337          vmSymbols::java_lang_Object()-&gt;is_permanent() &amp;&amp;</span>
<span class="line-added">338          vmSymbols::java_lang_String()-&gt;utf8_length() == jl_object_len &amp;&amp;</span>
<span class="line-added">339          vmSymbols::java_lang_String()-&gt;starts_with(jl_str, jl_len) &amp;&amp;</span>
<span class="line-added">340          vmSymbols::java_lang_String()-&gt;ends_with(&quot;String&quot;, object_len) &amp;&amp;</span>
<span class="line-added">341          vmSymbols::java_lang_String()-&gt;is_permanent(),</span>
<span class="line-added">342          &quot;sanity&quot;);</span>
<span class="line-added">343   return true;</span>
344 }
<span class="line-added">345 #endif //ASSERT</span>
346 
<span class="line-modified">347 // returns a symbol; the caller is responsible for decrementing it</span>
<span class="line-added">348 Symbol* SignatureStream::find_symbol() {</span>
349   // Create a symbol from for string _begin _end
<span class="line-modified">350   int begin = raw_symbol_begin();</span>
<span class="line-modified">351   int end   = raw_symbol_end();</span>






352 
353   const char* symbol_chars = (const char*)_signature-&gt;base() + begin;
354   int len = end - begin;
355 
356   // Quick check for common symbols in signatures
<span class="line-modified">357   assert(signature_symbols_sane(), &quot;incorrect signature sanity check&quot;);</span>
<span class="line-modified">358   if (len == jl_object_len &amp;&amp;</span>
<span class="line-modified">359       memcmp(symbol_chars, jl_str, jl_len) == 0) {</span>
<span class="line-modified">360     if (memcmp(&quot;String&quot;, symbol_chars + jl_len, object_len) == 0) {</span>
361       return vmSymbols::java_lang_String();
<span class="line-modified">362     } else if (memcmp(&quot;Object&quot;, symbol_chars + jl_len, object_len) == 0) {</span>
363       return vmSymbols::java_lang_Object();
364     }
365   }
366 
367   Symbol* name = _previous_name;
368   if (name != NULL &amp;&amp; name-&gt;equals(symbol_chars, len)) {
369     return name;
370   }
371 
372   // Save names for cleaning up reference count at the end of
373   // SignatureStream scope.
374   name = SymbolTable::new_symbol(symbol_chars, len);
<span class="line-modified">375 </span>
<span class="line-added">376   // Only allocate the GrowableArray for the _names buffer if more than</span>
<span class="line-added">377   // one name is being processed in the signature.</span>
<span class="line-added">378   if (_previous_name != NULL &amp;&amp;</span>
<span class="line-added">379       !_previous_name-&gt;is_permanent() &amp;&amp;</span>
<span class="line-added">380       !name-&gt;is_permanent() &amp;&amp;</span>
<span class="line-added">381       _names == NULL) {</span>
<span class="line-added">382     _names =  new GrowableArray&lt;Symbol*&gt;(10);</span>
<span class="line-added">383     _names-&gt;push(_previous_name);</span>
<span class="line-added">384   }</span>
<span class="line-added">385   if (!name-&gt;is_permanent() &amp;&amp; _previous_name != NULL) {</span>
386     if (_names == NULL) {
387       _names = new GrowableArray&lt;Symbol*&gt;(10);
388     }
389     _names-&gt;push(name);  // save new symbol for decrementing later
390   }
391   _previous_name = name;
392   return name;
393 }
394 
395 Klass* SignatureStream::as_klass(Handle class_loader, Handle protection_domain,
396                                  FailureMode failure_mode, TRAPS) {
<span class="line-modified">397   if (!is_reference())  return NULL;</span>
398   Symbol* name = as_symbol();
<span class="line-added">399   Klass* k = NULL;</span>
400   if (failure_mode == ReturnNull) {
<span class="line-modified">401     // Note:  SD::resolve_or_null returns NULL for most failure modes,</span>
<span class="line-added">402     // but not all.  Circularity errors, invalid PDs, etc., throw.</span>
<span class="line-added">403     k = SystemDictionary::resolve_or_null(name, class_loader, protection_domain, CHECK_NULL);</span>
<span class="line-added">404   } else if (failure_mode == CachedOrNull) {</span>
<span class="line-added">405     NoSafepointVerifier nsv;  // no loading, now, we mean it!</span>
<span class="line-added">406     assert(!HAS_PENDING_EXCEPTION, &quot;&quot;);</span>
<span class="line-added">407     k = SystemDictionary::find(name, class_loader, protection_domain, CHECK_NULL);</span>
<span class="line-added">408     // SD::find does not trigger loading, so there should be no throws</span>
<span class="line-added">409     // Still, bad things can happen, so we CHECK_NULL and ask callers</span>
<span class="line-added">410     // to do likewise.</span>
<span class="line-added">411     return k;</span>
412   } else {
<span class="line-added">413     // The only remaining failure mode is NCDFError.</span>
<span class="line-added">414     // The test here allows for an additional mode CNFException</span>
<span class="line-added">415     // if callers need to request the reflective error instead.</span>
416     bool throw_error = (failure_mode == NCDFError);
<span class="line-modified">417     k = SystemDictionary::resolve_or_fail(name, class_loader, protection_domain, throw_error, CHECK_NULL);</span>
418   }
<span class="line-added">419 </span>
<span class="line-added">420   return k;</span>
421 }
422 
423 oop SignatureStream::as_java_mirror(Handle class_loader, Handle protection_domain,
424                                     FailureMode failure_mode, TRAPS) {
<span class="line-modified">425   if (!is_reference())</span>
426     return Universe::java_mirror(type());
427   Klass* klass = as_klass(class_loader, protection_domain, failure_mode, CHECK_NULL);
428   if (klass == NULL)  return NULL;
429   return klass-&gt;java_mirror();
430 }
431 
<span class="line-modified">432 void SignatureStream::skip_to_return_type() {</span>
<span class="line-modified">433   while (!at_return_type()) {</span>
<span class="line-modified">434     next();</span>








435   }







436 }
437 
<span class="line-modified">438 #ifdef ASSERT</span>
<span class="line-modified">439 </span>
<span class="line-modified">440 extern bool signature_constants_sane(); // called from basic_types_init()</span>
<span class="line-modified">441 </span>
<span class="line-modified">442 bool signature_constants_sane() {</span>
<span class="line-added">443   // for the lookup table, test every 8-bit code point, and then some:</span>
<span class="line-added">444   for (int i = -256; i &lt;= 256; i++) {</span>
<span class="line-added">445     int btcode = 0;</span>
<span class="line-added">446     switch (i) {</span>
<span class="line-added">447 #define EACH_SIG(ch, bt, ignore) \</span>
<span class="line-added">448     case ch: { btcode = bt; break; }</span>
<span class="line-added">449     SIGNATURE_TYPES_DO(EACH_SIG, ignore)</span>
<span class="line-added">450 #undef EACH_SIG</span>
451     }
<span class="line-added">452     int btc = decode_signature_char(i);</span>
<span class="line-added">453     assert(btc == btcode, &quot;misconfigured table: %d =&gt; %d not %d&quot;, i, btc, btcode);</span>
454   }
<span class="line-modified">455   return true;</span>
456 }
457 

458 bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {
459   const char* method_sig = (const char*)sig-&gt;bytes();
460   ssize_t len = sig-&gt;utf8_length();
461   ssize_t index = 0;
462   if (method_sig != NULL &amp;&amp; len &gt; 1 &amp;&amp; method_sig[index] == JVM_SIGNATURE_FUNC) {
463     ++index;
464     while (index &lt; len &amp;&amp; method_sig[index] != JVM_SIGNATURE_ENDFUNC) {
465       ssize_t res = is_valid_type(&amp;method_sig[index], len - index);
466       if (res == -1) {
467         return false;
468       } else {
469         index += res;
470       }
471     }
472     if (index &lt; len &amp;&amp; method_sig[index] == JVM_SIGNATURE_ENDFUNC) {
473       // check the return type
474       ++index;
475       return (is_valid_type(&amp;method_sig[index], len - index) == (len - index));
476     }
477   }
</pre>
<hr />
<pre>
482   const char* type_sig = (const char*)sig-&gt;bytes();
483   ssize_t len = sig-&gt;utf8_length();
484   return (type_sig != NULL &amp;&amp; len &gt;= 1 &amp;&amp;
485           (is_valid_type(type_sig, len) == len));
486 }
487 
488 // Checks to see if the type (not to go beyond &#39;limit&#39;) refers to a valid type.
489 // Returns -1 if it is not, or the index of the next character that is not part
490 // of the type.  The type encoding may end before &#39;limit&#39; and that&#39;s ok.
491 ssize_t SignatureVerifier::is_valid_type(const char* type, ssize_t limit) {
492   ssize_t index = 0;
493 
494   // Iterate over any number of array dimensions
495   while (index &lt; limit &amp;&amp; type[index] == JVM_SIGNATURE_ARRAY) ++index;
496   if (index &gt;= limit) {
497     return -1;
498   }
499   switch (type[index]) {
500     case JVM_SIGNATURE_BYTE:
501     case JVM_SIGNATURE_CHAR:

502     case JVM_SIGNATURE_FLOAT:
<span class="line-added">503     case JVM_SIGNATURE_DOUBLE:</span>
504     case JVM_SIGNATURE_INT:
505     case JVM_SIGNATURE_LONG:
506     case JVM_SIGNATURE_SHORT:
507     case JVM_SIGNATURE_BOOLEAN:
508     case JVM_SIGNATURE_VOID:
509       return index + 1;
510     case JVM_SIGNATURE_CLASS:
511       for (index = index + 1; index &lt; limit; ++index) {
512         char c = type[index];
513         switch (c) {
514           case JVM_SIGNATURE_ENDCLASS:
515             return index + 1;
516           case &#39;\0&#39;: case JVM_SIGNATURE_DOT: case JVM_SIGNATURE_ARRAY:
517             return -1;
518           default: ; // fall through
519         }
520       }
521       // fall through
522     default: ; // fall through
523   }
524   return -1;
525 }
<span class="line-added">526 </span>
527 #endif // ASSERT
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="signature.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>