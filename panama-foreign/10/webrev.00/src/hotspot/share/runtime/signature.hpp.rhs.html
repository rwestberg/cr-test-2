<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/signature.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SIGNATURE_HPP
 26 #define SHARE_RUNTIME_SIGNATURE_HPP
 27 
<a name="2" id="anc2"></a><span class="line-added"> 28 #include &quot;classfile/symbolTable.hpp&quot;</span>
 29 #include &quot;memory/allocation.hpp&quot;
 30 #include &quot;oops/method.hpp&quot;
 31 
<a name="3" id="anc3"></a><span class="line-modified"> 32 </span>
<span class="line-modified"> 33 // Static routines and parsing loops for processing field and method</span>
<span class="line-modified"> 34 // descriptors.  In the HotSpot sources we call them &quot;signatures&quot;.</span>
<span class="line-added"> 35 //</span>
<span class="line-added"> 36 // A SignatureStream iterates over a Java descriptor (or parts of it).</span>
<span class="line-added"> 37 // The syntax is documented in the Java Virtual Machine Specification,</span>
<span class="line-added"> 38 // section 4.3.</span>
<span class="line-added"> 39 //</span>
<span class="line-added"> 40 // The syntax may be summarized as follows:</span>
<span class="line-added"> 41 //</span>
<span class="line-added"> 42 //     MethodType: &#39;(&#39; {FieldType}* &#39;)&#39; (FieldType | &#39;V&#39;)</span>
<span class="line-added"> 43 //     FieldType: PrimitiveType | ObjectType | ArrayType</span>
<span class="line-added"> 44 //     PrimitiveType: &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;F&#39; | &#39;I&#39; | &#39;J&#39; | &#39;S&#39; | &#39;Z&#39;</span>
<span class="line-added"> 45 //     ObjectType: &#39;L&#39; ClassName &#39;;&#39; | ArrayType</span>
<span class="line-added"> 46 //     ArrayType: &#39;[&#39; FieldType</span>
<span class="line-added"> 47 //     ClassName: {UnqualifiedName &#39;/&#39;}* UnqualifiedName</span>
<span class="line-added"> 48 //     UnqualifiedName: NameChar {NameChar}*</span>
<span class="line-added"> 49 //     NameChar: ANY_CHAR_EXCEPT(&#39;/&#39; | &#39;.&#39; | &#39;;&#39; | &#39;[&#39;)</span>
 50 //
<a name="4" id="anc4"></a><span class="line-modified"> 51 // All of the concrete characters in the above grammar are given</span>
<span class="line-modified"> 52 // standard manifest constant names of the form JVM_SIGNATURE_x.</span>
<span class="line-added"> 53 // Executable code uses these constant names in preference to raw</span>
<span class="line-added"> 54 // character constants.  Comments and assertion code sometimes use</span>
<span class="line-added"> 55 // the raw character constants for brevity.</span>
 56 //
<a name="5" id="anc5"></a><span class="line-modified"> 57 // The primitive field types (like &#39;I&#39;) correspond 1-1 with type codes</span>
<span class="line-modified"> 58 // (like T_INT) which form part of the specification of the &#39;newarray&#39;</span>
<span class="line-modified"> 59 // instruction (JVMS 6.5, section on newarray).  These type codes are</span>
<span class="line-added"> 60 // widely used in the HotSpot code.  They are joined by ad hoc codes</span>
<span class="line-added"> 61 // like T_OBJECT and T_ARRAY (defined in HotSpot but not in the JVMS)</span>
<span class="line-added"> 62 // so that each &quot;basic type&quot; of field descriptor (or void return type)</span>
<span class="line-added"> 63 // has a corresponding T_x code.  Thus, while T_x codes play a very</span>
<span class="line-added"> 64 // minor role in the JVMS, they play a major role in the HotSpot</span>
<span class="line-added"> 65 // sources.  There are fewer than 16 such &quot;basic types&quot;, so they fit</span>
<span class="line-added"> 66 // nicely into bitfields.</span>
 67 //
<a name="6" id="anc6"></a><span class="line-modified"> 68 // The syntax of ClassName overlaps slightly with the descriptor</span>
<span class="line-added"> 69 // syntaxes.  The strings &quot;I&quot; and &quot;(I)V&quot; are both class names</span>
<span class="line-added"> 70 // *and* descriptors.  If a class name contains any character other</span>
<span class="line-added"> 71 // than &quot;BCDFIJSZ()V&quot; it cannot be confused with a descriptor.</span>
<span class="line-added"> 72 // Class names inside of descriptors are always contained in an</span>
<span class="line-added"> 73 // &quot;envelope&quot; syntax which starts with &#39;L&#39; and ends with &#39;;&#39;.</span>
 74 //
<a name="7" id="anc7"></a><span class="line-modified"> 75 // As a confounding factor, array types report their type name strings</span>
<span class="line-modified"> 76 // in descriptor format.  These name strings are easy to recognize,</span>
<span class="line-added"> 77 // since they begin with &#39;[&#39;.  For this reason some API points on</span>
<span class="line-added"> 78 // HotSpot look for array descriptors as well as proper class names.</span>
<span class="line-added"> 79 //</span>
<span class="line-added"> 80 // For historical reasons some API points that accept class names and</span>
<span class="line-added"> 81 // array names also look for class names wrapped inside an envelope</span>
<span class="line-added"> 82 // (like &quot;LFoo;&quot;) and unwrap them on the fly (to a name like &quot;Foo&quot;).</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 class Signature : AllStatic {</span>
<span class="line-added"> 85  private:</span>
<span class="line-added"> 86   static bool is_valid_array_signature(const Symbol* sig);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88  public:</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90   // Returns the basic type of a field signature (or T_VOID for &quot;V&quot;).</span>
<span class="line-added"> 91   // Assumes the signature is a valid field descriptor.</span>
<span class="line-added"> 92   // Do not apply this function to class names or method signatures.</span>
<span class="line-added"> 93   static BasicType basic_type(const Symbol* signature) {</span>
<span class="line-added"> 94     return basic_type(signature-&gt;char_at(0));</span>
<span class="line-added"> 95   }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97   // Returns T_ILLEGAL for an illegal signature char.</span>
<span class="line-added"> 98   static BasicType basic_type(int ch);</span>
<span class="line-added"> 99 </span>
<span class="line-added">100   // Assuming it is either a class name or signature,</span>
<span class="line-added">101   // determine if it in fact cannot be a class name.</span>
<span class="line-added">102   // This means it either starts with &#39;[&#39; or ends with &#39;;&#39;</span>
<span class="line-added">103   static bool not_class_name(const Symbol* signature) {</span>
<span class="line-added">104     return (signature-&gt;starts_with(JVM_SIGNATURE_ARRAY) ||</span>
<span class="line-added">105             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS));</span>
<span class="line-added">106   }</span>
<span class="line-added">107 </span>
<span class="line-added">108   // Assuming it is either a class name or signature,</span>
<span class="line-added">109   // determine if it in fact is an array descriptor.</span>
<span class="line-added">110   static bool is_array(const Symbol* signature) {</span>
<span class="line-added">111     return (signature-&gt;utf8_length() &gt; 1 &amp;&amp;</span>
<span class="line-added">112             signature-&gt;char_at(0) == JVM_SIGNATURE_ARRAY &amp;&amp;</span>
<span class="line-added">113             is_valid_array_signature(signature));</span>
<span class="line-added">114   }</span>
<span class="line-added">115 </span>
<span class="line-added">116   // Assuming it is either a class name or signature,</span>
<span class="line-added">117   // determine if it contains a class name plus &#39;;&#39;.</span>
<span class="line-added">118   static bool has_envelope(const Symbol* signature) {</span>
<span class="line-added">119     return ((signature-&gt;utf8_length() &gt; 0) &amp;&amp;</span>
<span class="line-added">120             signature-&gt;ends_with(JVM_SIGNATURE_ENDCLASS) &amp;&amp;</span>
<span class="line-added">121             has_envelope(signature-&gt;char_at(0)));</span>
<span class="line-added">122   }</span>
<span class="line-added">123 </span>
<span class="line-added">124   // Determine if this signature char introduces an</span>
<span class="line-added">125   // envelope, which is a class name plus &#39;;&#39;.</span>
<span class="line-added">126   static bool has_envelope(char signature_char) {</span>
<span class="line-added">127     return (signature_char == JVM_SIGNATURE_CLASS);</span>
<span class="line-added">128   }</span>
<span class="line-added">129 </span>
<span class="line-added">130   // Assuming has_envelope is true, return the symbol</span>
<span class="line-added">131   // inside the envelope, by stripping &#39;L&#39; and &#39;;&#39;.</span>
<span class="line-added">132   // Caller is responsible for decrementing the newly created</span>
<span class="line-added">133   // Symbol&#39;s refcount, use TempNewSymbol.</span>
<span class="line-added">134   static Symbol* strip_envelope(const Symbol* signature) {</span>
<span class="line-added">135     assert(has_envelope(signature), &quot;precondition&quot;);</span>
<span class="line-added">136     return SymbolTable::new_symbol((char*) signature-&gt;bytes() + 1,</span>
<span class="line-added">137                                    signature-&gt;utf8_length() - 2);</span>
<span class="line-added">138   }</span>
<span class="line-added">139 </span>
<span class="line-added">140   // Assuming it&#39;s either a field or method descriptor, determine</span>
<span class="line-added">141   // whether it is in fact a method descriptor:</span>
<span class="line-added">142   static bool is_method(const Symbol* signature) {</span>
<span class="line-added">143     return signature-&gt;starts_with(JVM_SIGNATURE_FUNC);</span>
<span class="line-added">144   }</span>
<span class="line-added">145 </span>
<span class="line-added">146   // Assuming it&#39;s a method signature, determine if it must</span>
<span class="line-added">147   // return void.</span>
<span class="line-added">148   static bool is_void_method(const Symbol* signature) {</span>
<span class="line-added">149     assert(is_method(signature), &quot;signature is not for a method&quot;);</span>
<span class="line-added">150     return signature-&gt;ends_with(JVM_SIGNATURE_VOID);</span>
<span class="line-added">151   }</span>
<span class="line-added">152 };</span>
<span class="line-added">153 </span>
<span class="line-added">154 // A SignatureIterator uses a SignatureStream to produce BasicType</span>
<span class="line-added">155 // results, discarding class names.  This means it can be accelerated</span>
<span class="line-added">156 // using a fingerprint mechanism, in many cases, without loss of type</span>
<span class="line-added">157 // information.  The FingerPrinter class computes and caches this</span>
<span class="line-added">158 // reduced information for faster iteration.</span>
159 
160 class SignatureIterator: public ResourceObj {
<a name="8" id="anc8"></a><span class="line-added">161  public:</span>
<span class="line-added">162   typedef uint64_t fingerprint_t;</span>
<span class="line-added">163 </span>
164  protected:
165   Symbol*      _signature;             // the signature to iterate over
<a name="9" id="anc9"></a>

166   BasicType    _return_type;
<a name="10" id="anc10"></a><span class="line-modified">167   fingerprint_t _fingerprint;</span>



168 
169  public:
170   // Definitions used in generating and iterating the
171   // bit field form of the signature generated by the
172   // Fingerprinter.
173   enum {
<a name="11" id="anc11"></a><span class="line-modified">174     fp_static_feature_size    = 1,</span>
<span class="line-modified">175     fp_is_static_bit          = 1,</span>
<span class="line-modified">176 </span>
<span class="line-modified">177     fp_result_feature_size    = 4,</span>
<span class="line-modified">178     fp_result_feature_mask    = right_n_bits(fp_result_feature_size),</span>
<span class="line-modified">179     fp_parameter_feature_size = 4,</span>
<span class="line-modified">180     fp_parameter_feature_mask = right_n_bits(fp_parameter_feature_size),</span>
<span class="line-modified">181 </span>
<span class="line-modified">182     fp_parameters_done        = 0,  // marker for end of parameters (must be zero)</span>
<span class="line-modified">183 </span>
<span class="line-modified">184     // Parameters take up full wordsize, minus the result and static bit fields.</span>
<span class="line-modified">185     // Since fp_parameters_done is zero, termination field arises from shifting</span>
<span class="line-modified">186     // in zero bits, and therefore occupies no extra space.</span>
<span class="line-modified">187     // The sentinel value is all-zero-bits, which is impossible for a true</span>
<span class="line-modified">188     // fingerprint, since at least the result field will be non-zero.</span>
<span class="line-modified">189     fp_max_size_of_parameters = ((BitsPerLong</span>
<span class="line-modified">190                                   - (fp_result_feature_size + fp_static_feature_size))</span>
<span class="line-modified">191                                  / fp_parameter_feature_size)</span>






192   };
193 
<a name="12" id="anc12"></a><span class="line-added">194   static bool fp_is_valid_type(BasicType type, bool for_return_type = false);</span>
<span class="line-added">195 </span>
<span class="line-added">196   // Sentinel values are zero and not-zero (-1).</span>
<span class="line-added">197   // No need to protect the sign bit, since every valid return type is non-zero</span>
<span class="line-added">198   // (even T_VOID), and there are no valid parameter fields which are 0xF (T_VOID).</span>
<span class="line-added">199   static fingerprint_t zero_fingerprint() { return (fingerprint_t)0; }</span>
<span class="line-added">200   static fingerprint_t overflow_fingerprint() { return ~(fingerprint_t)0; }</span>
<span class="line-added">201   static bool fp_is_valid(fingerprint_t fingerprint) {</span>
<span class="line-added">202     return (fingerprint != zero_fingerprint()) &amp;&amp; (fingerprint != overflow_fingerprint());</span>
<span class="line-added">203   }</span>
<span class="line-added">204 </span>
205   // Constructors
<a name="13" id="anc13"></a><span class="line-modified">206   SignatureIterator(Symbol* signature, fingerprint_t fingerprint = zero_fingerprint()) {</span>
<span class="line-added">207     _signature   = signature;</span>
<span class="line-added">208     _return_type = T_ILLEGAL;  // sentinel value for uninitialized</span>
<span class="line-added">209     _fingerprint = zero_fingerprint();</span>
<span class="line-added">210     if (fingerprint != _fingerprint) {</span>
<span class="line-added">211       set_fingerprint(fingerprint);</span>
<span class="line-added">212     }</span>
<span class="line-added">213   }</span>
<span class="line-added">214 </span>
<span class="line-added">215   // If the fingerprint is present, we can use an accelerated loop.</span>
<span class="line-added">216   void set_fingerprint(fingerprint_t fingerprint);</span>
<span class="line-added">217 </span>
<span class="line-added">218   // Returns the set fingerprint, or zero_fingerprint()</span>
<span class="line-added">219   // if none has been set already.</span>
<span class="line-added">220   fingerprint_t fingerprint() const { return _fingerprint; }</span>
221 
222   // Iteration
<a name="14" id="anc14"></a><span class="line-modified">223   // Hey look:  There are no virtual methods in this class.</span>
<span class="line-modified">224   // So how is it customized?  By calling do_parameters_on</span>
<span class="line-modified">225   // an object which answers to &quot;do_type(BasicType)&quot;.</span>
<span class="line-modified">226   // By convention, this object is in the subclass</span>
<span class="line-modified">227   // itself, so the call is &quot;do_parameters_on(this)&quot;.</span>
<span class="line-modified">228   // The effect of this is to inline the parsing loop</span>
<span class="line-modified">229   // everywhere &quot;do_parameters_on&quot; is called.</span>
<span class="line-modified">230   // If there is a valid fingerprint in the object,</span>
<span class="line-modified">231   // an improved loop is called which just unpacks the</span>
<span class="line-modified">232   // bitfields from the fingerprint.  Otherwise, the</span>
<span class="line-modified">233   // symbol is parsed.</span>
<span class="line-modified">234   template&lt;typename T&gt; inline void do_parameters_on(T* callback); // iterates over parameters only</span>
<span class="line-modified">235   void skip_parameters();   // skips over parameters to find return type</span>
<span class="line-modified">236   BasicType return_type();  // computes the value on the fly if necessary</span>
<span class="line-modified">237 </span>
<span class="line-modified">238   static bool fp_is_static(fingerprint_t fingerprint) {</span>
<span class="line-modified">239     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">240     return fingerprint &amp; fp_is_static_bit;</span>
<span class="line-modified">241   }</span>
<span class="line-modified">242   static BasicType fp_return_type(fingerprint_t fingerprint) {</span>
<span class="line-modified">243     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">244     return (BasicType) ((fingerprint &gt;&gt; fp_static_feature_size) &amp; fp_result_feature_mask);</span>





245   }
<a name="15" id="anc15"></a><span class="line-modified">246   static fingerprint_t fp_start_parameters(fingerprint_t fingerprint) {</span>
<span class="line-modified">247     assert(fp_is_valid(fingerprint), &quot;invalid fingerprint&quot;);</span>
<span class="line-modified">248     return fingerprint &gt;&gt; (fp_static_feature_size + fp_result_feature_size);</span>
<span class="line-added">249   }</span>
<span class="line-added">250   static BasicType fp_next_parameter(fingerprint_t&amp; mask) {</span>
<span class="line-added">251     int result = (mask &amp; fp_parameter_feature_mask);</span>
<span class="line-added">252     mask &gt;&gt;= fp_parameter_feature_size;</span>
<span class="line-added">253     return (BasicType) result;</span>
254   }
255 };
256 
257 
258 // Specialized SignatureIterators: Used to compute signature specific values.
259 
260 class SignatureTypeNames : public SignatureIterator {
261  protected:
262   virtual void type_name(const char* name)   = 0;
263 
<a name="16" id="anc16"></a><span class="line-modified">264   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">265   void do_type(BasicType type) {</span>
<span class="line-modified">266     switch (type) {</span>
<span class="line-modified">267     case T_BOOLEAN: type_name(&quot;jboolean&quot;); break;</span>
<span class="line-modified">268     case T_CHAR:    type_name(&quot;jchar&quot;   ); break;</span>
<span class="line-modified">269     case T_FLOAT:   type_name(&quot;jfloat&quot;  ); break;</span>
<span class="line-modified">270     case T_DOUBLE:  type_name(&quot;jdouble&quot; ); break;</span>
<span class="line-modified">271     case T_BYTE:    type_name(&quot;jbyte&quot;   ); break;</span>
<span class="line-modified">272     case T_SHORT:   type_name(&quot;jshort&quot;  ); break;</span>
<span class="line-modified">273     case T_INT:     type_name(&quot;jint&quot;    ); break;</span>
<span class="line-modified">274     case T_LONG:    type_name(&quot;jlong&quot;   ); break;</span>
<span class="line-added">275     case T_VOID:    type_name(&quot;void&quot;    ); break;</span>
<span class="line-added">276     case T_ARRAY:</span>
<span class="line-added">277     case T_OBJECT:  type_name(&quot;jobject&quot; ); break;</span>
<span class="line-added">278     default: ShouldNotReachHere();</span>
<span class="line-added">279     }</span>
<span class="line-added">280   }</span>
281 
282  public:
283   SignatureTypeNames(Symbol* signature) : SignatureIterator(signature) {}
284 };
285 
286 
<a name="17" id="anc17"></a><span class="line-modified">287 // Specialized SignatureIterator: Used to compute the argument size.</span>





















288 
<a name="18" id="anc18"></a><span class="line-added">289 class ArgumentSizeComputer: public SignatureIterator {</span>
<span class="line-added">290  private:</span>
<span class="line-added">291   int _size;</span>
<span class="line-added">292   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">293   void do_type(BasicType type) { _size += parameter_type_word_count(type); }</span>
294  public:
<a name="19" id="anc19"></a><span class="line-modified">295   ArgumentSizeComputer(Symbol* signature);</span>
<span class="line-modified">296   int size() { return _size; }</span>




297 };
298 
299 
<a name="20" id="anc20"></a><span class="line-modified">300 class ArgumentCount: public SignatureIterator {</span>


301  private:
<a name="21" id="anc21"></a><span class="line-modified">302   int _size;</span>
<span class="line-added">303   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">304   void do_type(BasicType type) { _size++; }</span>
305  public:
<a name="22" id="anc22"></a><span class="line-modified">306   ArgumentCount(Symbol* signature);</span>
<span class="line-modified">307   int size() { return _size; }</span>

308 };
309 
310 
<a name="23" id="anc23"></a><span class="line-modified">311 class ReferenceArgumentCount: public SignatureIterator {</span>
312  private:
<a name="24" id="anc24"></a><span class="line-modified">313   int _refs;</span>
<span class="line-added">314   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-added">315   void do_type(BasicType type) { if (is_reference_type(type)) _refs++; }</span>
316  public:
<a name="25" id="anc25"></a><span class="line-modified">317   ReferenceArgumentCount(Symbol* signature);</span>
<span class="line-modified">318   int count() { return _refs; }</span>

319 };
320 
321 
322 // Specialized SignatureIterator: Used to compute the result type.
323 
<a name="26" id="anc26"></a><span class="line-modified">324 class ResultTypeFinder: public SignatureIterator {</span>


325  public:
<a name="27" id="anc27"></a><span class="line-modified">326   BasicType type() { return return_type(); }</span>
<span class="line-modified">327   ResultTypeFinder(Symbol* signature) : SignatureIterator(signature) { }</span>

328 };
329 
330 
331 // Fingerprinter computes a unique ID for a given method. The ID
332 // is a bitvector characterizing the methods signature (incl. the receiver).
333 class Fingerprinter: public SignatureIterator {
334  private:
<a name="28" id="anc28"></a><span class="line-modified">335   fingerprint_t _accumulator;</span>
<span class="line-added">336   int _param_size;</span>
337   int _shift_count;
<a name="29" id="anc29"></a><span class="line-modified">338   const Method* _method;</span>


339 
<a name="30" id="anc30"></a><span class="line-modified">340   void initialize_accumulator() {</span>
<span class="line-modified">341     _accumulator = 0;</span>
<span class="line-modified">342     _shift_count = fp_result_feature_size + fp_static_feature_size;</span>
<span class="line-modified">343     _param_size = 0;</span>
<span class="line-modified">344   }</span>






345 
<a name="31" id="anc31"></a><span class="line-modified">346   // Out-of-line method does it all in constructor:</span>
<span class="line-added">347   void compute_fingerprint_and_return_type(bool static_flag = false);</span>
348 
<a name="32" id="anc32"></a><span class="line-modified">349   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">350   void do_type(BasicType type) {</span>
<span class="line-modified">351     assert(fp_is_valid_type(type), &quot;bad parameter type&quot;);</span>
<span class="line-added">352     _accumulator |= ((fingerprint_t)type &lt;&lt; _shift_count);</span>
<span class="line-added">353     _shift_count += fp_parameter_feature_size;</span>
<span class="line-added">354     _param_size += (is_double_word_type(type) ? 2 : 1);</span>
355   }
356 
<a name="33" id="anc33"></a><span class="line-modified">357  public:</span>
<span class="line-modified">358   int size_of_parameters() const { return _param_size; }</span>
<span class="line-modified">359   // fingerprint() and return_type() are in super class</span>








360 
<a name="34" id="anc34"></a><span class="line-modified">361   Fingerprinter(const methodHandle&amp; method)</span>
<span class="line-modified">362     : SignatureIterator(method-&gt;signature()),</span>
<span class="line-modified">363       _method(method()) {</span>
<span class="line-modified">364     compute_fingerprint_and_return_type();</span>
<span class="line-modified">365   }</span>
<span class="line-modified">366   Fingerprinter(Symbol* signature, bool is_static)</span>
<span class="line-modified">367     : SignatureIterator(signature),</span>
<span class="line-modified">368       _method(NULL) {</span>
<span class="line-modified">369     compute_fingerprint_and_return_type(is_static);</span>
370   }
371 };
372 
373 
374 // Specialized SignatureIterator: Used for native call purposes
375 
376 class NativeSignatureIterator: public SignatureIterator {
377  private:
378   methodHandle _method;
379 // We need separate JNI and Java offset values because in 64 bit mode,
380 // the argument offsets are not in sync with the Java stack.
381 // For example a long takes up 1 &quot;C&quot; stack entry but 2 Java stack entries.
382   int          _offset;                // The java stack offset
383   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
384   int          _jni_offset;            // the current parameter offset, starting with 0
385 
<a name="35" id="anc35"></a><span class="line-modified">386   friend class SignatureIterator;  // so do_parameters_on can call do_type</span>
<span class="line-modified">387   void do_type(BasicType type) {</span>
<span class="line-modified">388     switch (type) {</span>
<span class="line-modified">389     case T_BYTE:</span>
<span class="line-modified">390     case T_SHORT:</span>
<span class="line-modified">391     case T_INT:</span>
<span class="line-modified">392     case T_BOOLEAN:</span>
<span class="line-modified">393     case T_CHAR:</span>
<span class="line-modified">394       pass_int();    _jni_offset++; _offset++;</span>
<span class="line-modified">395       break;</span>
<span class="line-modified">396     case T_FLOAT:</span>
<span class="line-modified">397       pass_float();  _jni_offset++; _offset++;</span>
<span class="line-modified">398       break;</span>
<span class="line-modified">399     case T_DOUBLE: {</span>
<span class="line-modified">400       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-modified">401       pass_double(); _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-modified">402       break;</span>
<span class="line-modified">403     }</span>
<span class="line-modified">404     case T_LONG: {</span>
<span class="line-added">405       int jni_offset = LP64_ONLY(1) NOT_LP64(2);</span>
<span class="line-added">406       pass_long();   _jni_offset += jni_offset; _offset += 2;</span>
<span class="line-added">407       break;</span>
<span class="line-added">408     }</span>
<span class="line-added">409     case T_ARRAY:</span>
<span class="line-added">410     case T_OBJECT:</span>
<span class="line-added">411       pass_object(); _jni_offset++; _offset++;</span>
<span class="line-added">412       break;</span>
<span class="line-added">413     default:</span>
<span class="line-added">414       ShouldNotReachHere();</span>
<span class="line-added">415     }</span>
<span class="line-added">416   }</span>
417 
418  public:
419   methodHandle method() const          { return _method; }
420   int          offset() const          { return _offset; }
421   int      jni_offset() const          { return _jni_offset + _prepended; }
<a name="36" id="anc36"></a>
422   bool      is_static() const          { return method()-&gt;is_static(); }
423   virtual void pass_int()              = 0;
424   virtual void pass_long()             = 0;
<a name="37" id="anc37"></a><span class="line-modified">425   virtual void pass_object()           = 0;  // objects, arrays, inlines</span>
426   virtual void pass_float()            = 0;
427 #ifdef _LP64
428   virtual void pass_double()           = 0;
429 #else
430   virtual void pass_double()           { pass_long(); }  // may be same as long
431 #endif
432 
433   NativeSignatureIterator(const methodHandle&amp; method) : SignatureIterator(method-&gt;signature()) {
434     _method = method;
435     _offset = 0;
436     _jni_offset = 0;
437 
438     const int JNIEnv_words = 1;
439     const int mirror_words = 1;
440     _prepended = !is_static() ? JNIEnv_words : JNIEnv_words + mirror_words;
441   }
442 
<a name="38" id="anc38"></a><span class="line-modified">443   void iterate() { iterate(Fingerprinter(method()).fingerprint()); }</span>
<span class="line-added">444 </span>
<span class="line-added">445   // iterate() calls the 3 virtual methods according to the following invocation syntax:</span>
446   //
447   // {pass_int | pass_long | pass_object}
448   //
449   // Arguments are handled from left to right (receiver first, if any).
450   // The offset() values refer to the Java stack offsets but are 0 based and increasing.
451   // The java_offset() values count down to 0, and refer to the Java TOS.
452   // The jni_offset() values increase from 1 or 2, and refer to C arguments.
<a name="39" id="anc39"></a><span class="line-added">453   // The method&#39;s return type is ignored.</span>
454 
<a name="40" id="anc40"></a><span class="line-modified">455   void iterate(fingerprint_t fingerprint) {</span>
<span class="line-modified">456     set_fingerprint(fingerprint);</span>





457     if (!is_static()) {
458       // handle receiver (not handled by iterate because not in signature)
459       pass_object(); _jni_offset++; _offset++;
460     }
<a name="41" id="anc41"></a><span class="line-modified">461     do_parameters_on(this);</span>

462   }
463 };
464 
465 
<a name="42" id="anc42"></a><span class="line-modified">466 // This is the core parsing logic for iterating over signatures.</span>
<span class="line-added">467 // All of the previous classes use this for doing their work.</span>
468 
469 class SignatureStream : public StackObj {
470  private:
<a name="43" id="anc43"></a><span class="line-modified">471   const Symbol* _signature;</span>
472   int          _begin;
473   int          _end;
<a name="44" id="anc44"></a><span class="line-added">474   int          _limit;</span>
<span class="line-added">475   int          _array_prefix;  // count of &#39;[&#39; before the array element descr</span>
476   BasicType    _type;
<a name="45" id="anc45"></a><span class="line-modified">477   int          _state;</span>
<span class="line-modified">478   Symbol*      _previous_name;    // cache the previously looked up symbol to avoid lookups</span>
<span class="line-modified">479   GrowableArray&lt;Symbol*&gt;* _names; // symbols created while parsing that need to be dereferenced</span>











480 
<a name="46" id="anc46"></a><span class="line-modified">481   inline int scan_non_primitive(BasicType type);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483   Symbol* find_symbol();</span>
<span class="line-modified">484 </span>
<span class="line-modified">485   enum { _s_field = 0, _s_method = 1, _s_method_return = 3 };</span>
<span class="line-modified">486   void set_done() {</span>
<span class="line-modified">487     _state |= -2;   // preserve s_method bit</span>
<span class="line-modified">488     assert(is_done(), &quot;Unable to set state to done&quot;);</span>








489   }
490 
<a name="47" id="anc47"></a><span class="line-modified">491  public:</span>
<span class="line-added">492   bool is_method_signature() const               { return (_state &amp; (int)_s_method) != 0; }</span>
<span class="line-added">493   bool at_return_type() const                    { return _state == (int)_s_method_return; }</span>
<span class="line-added">494   bool is_done() const                           { return _state &lt; 0; }</span>
<span class="line-added">495   void next();</span>
<span class="line-added">496 </span>
<span class="line-added">497   SignatureStream(const Symbol* signature, bool is_method = true);</span>
498   ~SignatureStream();
499 
<a name="48" id="anc48"></a><span class="line-modified">500   bool is_reference() const { return is_reference_type(_type); }</span>
<span class="line-modified">501   bool is_array() const     { return _type == T_ARRAY; }</span>
<span class="line-modified">502   bool is_primitive() const { return is_java_primitive(_type); }</span>
<span class="line-modified">503   BasicType type() const    { return _type; }</span>
<span class="line-modified">504 </span>
<span class="line-modified">505   const u1* raw_bytes() const  { return _signature-&gt;bytes() + _begin; }</span>
<span class="line-modified">506   int       raw_length() const { return _end - _begin; }</span>
<span class="line-modified">507   int       raw_begin() const  { return _begin; }</span>
<span class="line-modified">508   int       raw_end() const    { return _end; }</span>
<span class="line-added">509   int raw_symbol_begin() const { return _begin + (has_envelope() ? 1 : 0); }</span>
<span class="line-added">510   int raw_symbol_end() const   { return _end  -  (has_envelope() ? 1 : 0); }</span>
<span class="line-added">511   char raw_char_at(int i) const {</span>
<span class="line-added">512     assert(i &lt; _limit, &quot;index for raw_char_at is over the limit&quot;);</span>
<span class="line-added">513     return _signature-&gt;char_at(i);</span>
<span class="line-added">514   }</span>
515 
<a name="49" id="anc49"></a><span class="line-modified">516   // True if there is an embedded class name in this type,</span>
<span class="line-modified">517   // followed by &#39;;&#39;.</span>
<span class="line-added">518   bool has_envelope() const {</span>
<span class="line-added">519     if (!Signature::has_envelope(_signature-&gt;char_at(_begin)))</span>
<span class="line-added">520       return false;</span>
<span class="line-added">521     // this should always be true, but let&#39;s test it:</span>
<span class="line-added">522     assert(_signature-&gt;char_at(_end-1) == JVM_SIGNATURE_ENDCLASS, &quot;signature envelope has no semi-colon at end&quot;);</span>
<span class="line-added">523     return true;</span>
<span class="line-added">524   }</span>
525 
<a name="50" id="anc50"></a><span class="line-modified">526   // return the symbol for chars in symbol_begin()..symbol_end()</span>
<span class="line-modified">527   Symbol* as_symbol() {</span>
<span class="line-added">528     return find_symbol();</span>
<span class="line-added">529   }</span>
<span class="line-added">530 </span>
<span class="line-added">531   // in case you want only the return type:</span>
<span class="line-added">532   void skip_to_return_type();</span>
<span class="line-added">533 </span>
<span class="line-added">534   // number of &#39;[&#39; in array prefix</span>
<span class="line-added">535   int array_prefix_length() {</span>
<span class="line-added">536     return _type == T_ARRAY ? _array_prefix : 0;</span>
<span class="line-added">537   }</span>
<span class="line-added">538 </span>
<span class="line-added">539   // In case you want only the array base type,</span>
<span class="line-added">540   // reset the stream after skipping some brackets &#39;[&#39;.</span>
<span class="line-added">541   // (The argument is clipped to array_prefix_length(),</span>
<span class="line-added">542   // and if it ends up as zero this call is a nop.</span>
<span class="line-added">543   // The default is value skips all brackets &#39;[&#39;.)</span>
<span class="line-added">544   int skip_array_prefix(int prefix_length = 9999);</span>
<span class="line-added">545 </span>
<span class="line-added">546   // free-standing lookups (bring your own CL/PD pair)</span>
<span class="line-added">547   enum FailureMode { ReturnNull, NCDFError, CachedOrNull };</span>
<span class="line-added">548   Klass* as_klass(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
<span class="line-added">549   oop as_java_mirror(Handle class_loader, Handle protection_domain, FailureMode failure_mode, TRAPS);</span>
550 };
551 
<a name="51" id="anc51"></a><span class="line-modified">552 // Here is how all the SignatureIterator classes invoke the</span>
<span class="line-modified">553 // SignatureStream engine to do their parsing.</span>
<span class="line-added">554 template&lt;typename T&gt; inline</span>
<span class="line-added">555 void SignatureIterator::do_parameters_on(T* callback) {</span>
<span class="line-added">556   fingerprint_t unaccumulator = _fingerprint;</span>
<span class="line-added">557 </span>
<span class="line-added">558   // Check for too many arguments, or missing fingerprint:</span>
<span class="line-added">559   if (!fp_is_valid(unaccumulator)) {</span>
<span class="line-added">560     SignatureStream ss(_signature);</span>
<span class="line-added">561     for (; !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">562       callback-&gt;do_type(ss.type());</span>
<span class="line-added">563     }</span>
<span class="line-added">564     // while we are here, capture the return type</span>
<span class="line-added">565     _return_type = ss.type();</span>
<span class="line-added">566   } else {</span>
<span class="line-added">567     // Optimized version of do_parameters when fingerprint is known</span>
<span class="line-added">568     assert(_return_type != T_ILLEGAL, &quot;return type already captured from fp&quot;);</span>
<span class="line-added">569     unaccumulator = fp_start_parameters(unaccumulator);</span>
<span class="line-added">570     for (BasicType type; (type = fp_next_parameter(unaccumulator)) != (BasicType)fp_parameters_done; ) {</span>
<span class="line-added">571       assert(fp_is_valid_type(type), &quot;garbled fingerprint&quot;);</span>
<span class="line-added">572       callback-&gt;do_type(type);</span>
<span class="line-added">573     }</span>
<span class="line-added">574   }</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
<span class="line-added">577  #ifdef ASSERT</span>
<span class="line-added">578  class SignatureVerifier : public StackObj {</span>
579   public:
580     static bool is_valid_method_signature(Symbol* sig);
581     static bool is_valid_type_signature(Symbol* sig);
582   private:
583     static ssize_t is_valid_type(const char*, ssize_t);
584 };
585 #endif
586 #endif // SHARE_RUNTIME_SIGNATURE_HPP
<a name="52" id="anc52"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="52" type="hidden" />
</body>
</html>