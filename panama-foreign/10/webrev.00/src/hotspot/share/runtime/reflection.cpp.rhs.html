<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/jvmtiExport.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/handles.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/reflection.hpp&quot;
  50 #include &quot;runtime/reflectionUtils.hpp&quot;
  51 #include &quot;runtime/signature.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;runtime/vframe.inline.hpp&quot;
  54 
  55 static void trace_class_resolution(const Klass* to_class) {
  56   ResourceMark rm;
  57   int line_number = -1;
  58   const char * source_file = NULL;
  59   Klass* caller = NULL;
  60   JavaThread* jthread = JavaThread::current();
  61   if (jthread-&gt;has_last_Java_frame()) {
  62     vframeStream vfst(jthread);
  63     // skip over any frames belonging to java.lang.Class
  64     while (!vfst.at_end() &amp;&amp;
  65            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  66       vfst.next();
  67     }
  68     if (!vfst.at_end()) {
  69       // this frame is a likely suspect
  70       caller = vfst.method()-&gt;method_holder();
  71       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
  72       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
  73       if (s != NULL) {
  74         source_file = s-&gt;as_C_string();
  75       }
  76     }
  77   }
  78   if (caller != NULL) {
  79     const char * from = caller-&gt;external_name();
  80     const char * to = to_class-&gt;external_name();
  81     // print in a single call to reduce interleaving between threads
  82     if (source_file != NULL) {
  83       log_debug(class, resolve)(&quot;%s %s %s:%d (reflection)&quot;, from, to, source_file, line_number);
  84     } else {
  85       log_debug(class, resolve)(&quot;%s %s (reflection)&quot;, from, to);
  86     }
  87   }
  88 }
  89 
  90 
  91 oop Reflection::box(jvalue* value, BasicType type, TRAPS) {
  92   if (type == T_VOID) {
  93     return NULL;
  94   }
  95   if (is_reference_type(type)) {
  96     // regular objects are not boxed
  97     return (oop) value-&gt;l;
  98   }
  99   oop result = java_lang_boxing_object::create(type, value, CHECK_NULL);
 100   if (result == NULL) {
 101     THROW_(vmSymbols::java_lang_IllegalArgumentException(), result);
 102   }
 103   return result;
 104 }
 105 
 106 
 107 BasicType Reflection::unbox_for_primitive(oop box, jvalue* value, TRAPS) {
 108   if (box == NULL) {
 109     THROW_(vmSymbols::java_lang_IllegalArgumentException(), T_ILLEGAL);
 110   }
 111   return java_lang_boxing_object::get_value(box, value);
 112 }
 113 
 114 BasicType Reflection::unbox_for_regular_object(oop box, jvalue* value) {
 115   // Note:  box is really the unboxed oop.  It might even be a Short, etc.!
 116   value-&gt;l = cast_from_oop&lt;jobject&gt;(box);
 117   return T_OBJECT;
 118 }
 119 
 120 
 121 void Reflection::widen(jvalue* value, BasicType current_type, BasicType wide_type, TRAPS) {
 122   assert(wide_type != current_type, &quot;widen should not be called with identical types&quot;);
 123   switch (wide_type) {
 124     case T_BOOLEAN:
 125     case T_BYTE:
 126     case T_CHAR:
 127       break;  // fail
 128     case T_SHORT:
 129       switch (current_type) {
 130         case T_BYTE:
 131           value-&gt;s = (jshort) value-&gt;b;
 132           return;
 133         default:
 134           break;
 135       }
 136       break;  // fail
 137     case T_INT:
 138       switch (current_type) {
 139         case T_BYTE:
 140           value-&gt;i = (jint) value-&gt;b;
 141           return;
 142         case T_CHAR:
 143           value-&gt;i = (jint) value-&gt;c;
 144           return;
 145         case T_SHORT:
 146           value-&gt;i = (jint) value-&gt;s;
 147           return;
 148         default:
 149           break;
 150       }
 151       break;  // fail
 152     case T_LONG:
 153       switch (current_type) {
 154         case T_BYTE:
 155           value-&gt;j = (jlong) value-&gt;b;
 156           return;
 157         case T_CHAR:
 158           value-&gt;j = (jlong) value-&gt;c;
 159           return;
 160         case T_SHORT:
 161           value-&gt;j = (jlong) value-&gt;s;
 162           return;
 163         case T_INT:
 164           value-&gt;j = (jlong) value-&gt;i;
 165           return;
 166         default:
 167           break;
 168       }
 169       break;  // fail
 170     case T_FLOAT:
 171       switch (current_type) {
 172         case T_BYTE:
 173           value-&gt;f = (jfloat) value-&gt;b;
 174           return;
 175         case T_CHAR:
 176           value-&gt;f = (jfloat) value-&gt;c;
 177           return;
 178         case T_SHORT:
 179           value-&gt;f = (jfloat) value-&gt;s;
 180           return;
 181         case T_INT:
 182           value-&gt;f = (jfloat) value-&gt;i;
 183           return;
 184         case T_LONG:
 185           value-&gt;f = (jfloat) value-&gt;j;
 186           return;
 187         default:
 188           break;
 189       }
 190       break;  // fail
 191     case T_DOUBLE:
 192       switch (current_type) {
 193         case T_BYTE:
 194           value-&gt;d = (jdouble) value-&gt;b;
 195           return;
 196         case T_CHAR:
 197           value-&gt;d = (jdouble) value-&gt;c;
 198           return;
 199         case T_SHORT:
 200           value-&gt;d = (jdouble) value-&gt;s;
 201           return;
 202         case T_INT:
 203           value-&gt;d = (jdouble) value-&gt;i;
 204           return;
 205         case T_FLOAT:
 206           value-&gt;d = (jdouble) value-&gt;f;
 207           return;
 208         case T_LONG:
 209           value-&gt;d = (jdouble) value-&gt;j;
 210           return;
 211         default:
 212           break;
 213       }
 214       break;  // fail
 215     default:
 216       break;  // fail
 217   }
 218   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
 219 }
 220 
 221 
 222 BasicType Reflection::array_get(jvalue* value, arrayOop a, int index, TRAPS) {
 223   if (!a-&gt;is_within_bounds(index)) {
 224     THROW_(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), T_ILLEGAL);
 225   }
 226   if (a-&gt;is_objArray()) {
 227     value-&gt;l = cast_from_oop&lt;jobject&gt;(objArrayOop(a)-&gt;obj_at(index));
 228     return T_OBJECT;
 229   } else {
 230     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 231     BasicType type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 232     switch (type) {
 233       case T_BOOLEAN:
 234         value-&gt;z = typeArrayOop(a)-&gt;bool_at(index);
 235         break;
 236       case T_CHAR:
 237         value-&gt;c = typeArrayOop(a)-&gt;char_at(index);
 238         break;
 239       case T_FLOAT:
 240         value-&gt;f = typeArrayOop(a)-&gt;float_at(index);
 241         break;
 242       case T_DOUBLE:
 243         value-&gt;d = typeArrayOop(a)-&gt;double_at(index);
 244         break;
 245       case T_BYTE:
 246         value-&gt;b = typeArrayOop(a)-&gt;byte_at(index);
 247         break;
 248       case T_SHORT:
 249         value-&gt;s = typeArrayOop(a)-&gt;short_at(index);
 250         break;
 251       case T_INT:
 252         value-&gt;i = typeArrayOop(a)-&gt;int_at(index);
 253         break;
 254       case T_LONG:
 255         value-&gt;j = typeArrayOop(a)-&gt;long_at(index);
 256         break;
 257       default:
 258         return T_ILLEGAL;
 259     }
 260     return type;
 261   }
 262 }
 263 
 264 
 265 void Reflection::array_set(jvalue* value, arrayOop a, int index, BasicType value_type, TRAPS) {
 266   if (!a-&gt;is_within_bounds(index)) {
 267     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());
 268   }
 269   if (a-&gt;is_objArray()) {
 270     if (value_type == T_OBJECT) {
 271       oop obj = (oop) value-&gt;l;
 272       if (obj != NULL) {
 273         Klass* element_klass = ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass();
 274         if (!obj-&gt;is_a(element_klass)) {
 275           THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;array element type mismatch&quot;);
 276         }
 277       }
 278       objArrayOop(a)-&gt;obj_at_put(index, obj);
 279     }
 280   } else {
 281     assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
 282     BasicType array_type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
 283     if (array_type != value_type) {
 284       // The widen operation can potentially throw an exception, but cannot block,
 285       // so typeArrayOop a is safe if the call succeeds.
 286       widen(value, value_type, array_type, CHECK);
 287     }
 288     switch (array_type) {
 289       case T_BOOLEAN:
 290         typeArrayOop(a)-&gt;bool_at_put(index, value-&gt;z);
 291         break;
 292       case T_CHAR:
 293         typeArrayOop(a)-&gt;char_at_put(index, value-&gt;c);
 294         break;
 295       case T_FLOAT:
 296         typeArrayOop(a)-&gt;float_at_put(index, value-&gt;f);
 297         break;
 298       case T_DOUBLE:
 299         typeArrayOop(a)-&gt;double_at_put(index, value-&gt;d);
 300         break;
 301       case T_BYTE:
 302         typeArrayOop(a)-&gt;byte_at_put(index, value-&gt;b);
 303         break;
 304       case T_SHORT:
 305         typeArrayOop(a)-&gt;short_at_put(index, value-&gt;s);
 306         break;
 307       case T_INT:
 308         typeArrayOop(a)-&gt;int_at_put(index, value-&gt;i);
 309         break;
 310       case T_LONG:
 311         typeArrayOop(a)-&gt;long_at_put(index, value-&gt;j);
 312         break;
 313       default:
 314         THROW(vmSymbols::java_lang_IllegalArgumentException());
 315     }
 316   }
 317 }
 318 
 319 static Klass* basic_type_mirror_to_arrayklass(oop basic_type_mirror, TRAPS) {
 320   assert(java_lang_Class::is_primitive(basic_type_mirror), &quot;just checking&quot;);
 321   BasicType type = java_lang_Class::primitive_type(basic_type_mirror);
 322   if (type == T_VOID) {
 323     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 324   }
 325   else {
 326     return Universe::typeArrayKlassObj(type);
 327   }
 328 }
 329 
 330 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 331   if (element_mirror == NULL) {
 332     THROW_0(vmSymbols::java_lang_NullPointerException());
 333   }
 334   if (length &lt; 0) {
 335     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 336   }
 337   if (java_lang_Class::is_primitive(element_mirror)) {
 338     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 339     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 340   } else {
 341     Klass* k = java_lang_Class::as_Klass(element_mirror);
 342     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 343       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 344     }
 345     return oopFactory::new_objArray(k, length, THREAD);
 346   }
 347 }
 348 
 349 
 350 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 351   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 352   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 353 
 354   if (element_mirror == NULL) {
 355     THROW_0(vmSymbols::java_lang_NullPointerException());
 356   }
 357 
 358   int len = dim_array-&gt;length();
 359   if (len &lt;= 0 || len &gt; MAX_DIM) {
 360     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 361   }
 362 
 363   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 364   for (int i = 0; i &lt; len; i++) {
 365     int d = dim_array-&gt;int_at(i);
 366     if (d &lt; 0) {
 367       THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, d));
 368     }
 369     dimensions[i] = d;
 370   }
 371 
 372   Klass* klass;
 373   int dim = len;
 374   if (java_lang_Class::is_primitive(element_mirror)) {
 375     klass = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 376   } else {
 377     klass = java_lang_Class::as_Klass(element_mirror);
 378     if (klass-&gt;is_array_klass()) {
 379       int k_dim = ArrayKlass::cast(klass)-&gt;dimension();
 380       if (k_dim + len &gt; MAX_DIM) {
 381         THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 382       }
 383       dim += k_dim;
 384     }
 385   }
 386   klass = klass-&gt;array_klass(dim, CHECK_NULL);
 387   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(len, dimensions, CHECK_NULL);
 388   assert(obj-&gt;is_array(), &quot;just checking&quot;);
 389   return arrayOop(obj);
 390 }
 391 
 392 
 393 static bool under_unsafe_anonymous_host(const InstanceKlass* ik, const InstanceKlass* unsafe_anonymous_host) {
 394   DEBUG_ONLY(int inf_loop_check = 1000 * 1000 * 1000);
 395   for (;;) {
 396     const InstanceKlass* hc = ik-&gt;unsafe_anonymous_host();
 397     if (hc == NULL)        return false;
 398     if (hc == unsafe_anonymous_host)  return true;
 399     ik = hc;
 400 
 401     // There&#39;s no way to make a host class loop short of patching memory.
 402     // Therefore there cannot be a loop here unless there&#39;s another bug.
 403     // Still, let&#39;s check for it.
 404     assert(--inf_loop_check &gt; 0, &quot;no unsafe_anonymous_host loop&quot;);
 405   }
 406 }
 407 
 408 static bool can_relax_access_check_for(const Klass* accessor,
 409                                        const Klass* accessee,
 410                                        bool classloader_only) {
 411 
 412   const InstanceKlass* accessor_ik = InstanceKlass::cast(accessor);
 413   const InstanceKlass* accessee_ik = InstanceKlass::cast(accessee);
 414 
 415   // If either is on the other&#39;s unsafe_anonymous_host chain, access is OK,
 416   // because one is inside the other.
 417   if (under_unsafe_anonymous_host(accessor_ik, accessee_ik) ||
 418     under_unsafe_anonymous_host(accessee_ik, accessor_ik))
 419     return true;
 420 
 421   if (RelaxAccessControlCheck &amp;&amp;
 422     accessor_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION &amp;&amp;
 423     accessee_ik-&gt;major_version() &lt; Verifier::NO_RELAX_ACCESS_CTRL_CHECK_VERSION) {
 424     return classloader_only &amp;&amp;
 425       Verifier::relax_access_for(accessor_ik-&gt;class_loader()) &amp;&amp;
 426       accessor_ik-&gt;protection_domain() == accessee_ik-&gt;protection_domain() &amp;&amp;
 427       accessor_ik-&gt;class_loader() == accessee_ik-&gt;class_loader();
 428   }
 429 
 430   return false;
 431 }
 432 
 433 /*
 434     Type Accessibility check for public types: Callee Type T is accessible to Caller Type S if:
 435 
 436                         Callee T in             Callee T in package PT,
 437                         unnamed module          runtime module MT
 438  ------------------------------------------------------------------------------------------------
 439 
 440  Caller S in package     If MS is loose: YES      If same classloader/package (PS == PT): YES
 441  PS, runtime module MS   If MS can read T&#39;s       If same runtime module: (MS == MT): YES
 442                          unnamed module: YES
 443                                                   Else if (MS can read MT (establish readability) &amp;&amp;
 444                                                     ((MT exports PT to MS or to all modules) ||
 445                                                      (MT is open))): YES
 446 
 447  ------------------------------------------------------------------------------------------------
 448  Caller S in unnamed         YES                  Readability exists because unnamed module
 449  module UM                                            &quot;reads&quot; all modules
 450                                                   if (MT exports PT to UM or to all modules): YES
 451 
 452  ------------------------------------------------------------------------------------------------
 453 
 454  Note: a loose module is a module that can read all current and future unnamed modules.
 455 */
 456 Reflection::VerifyClassAccessResults Reflection::verify_class_access(
 457   const Klass* current_class, const InstanceKlass* new_class, bool classloader_only) {
 458 
 459   // Verify that current_class can access new_class.  If the classloader_only
 460   // flag is set, we automatically allow any accesses in which current_class
 461   // doesn&#39;t have a classloader.
 462   if ((current_class == NULL) ||
 463       (current_class == new_class) ||
 464       is_same_class_package(current_class, new_class)) {
 465     return ACCESS_OK;
 466   }
 467   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 468   // succeed trivially.
 469   if (SystemDictionary::reflect_MagicAccessorImpl_klass_is_loaded() &amp;&amp;
 470       current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 471     return ACCESS_OK;
 472   }
 473 
 474   // module boundaries
 475   if (new_class-&gt;is_public()) {
 476     // Ignore modules for DumpSharedSpaces because we do not have any package
 477     // or module information for modules other than java.base.
 478     if (DumpSharedSpaces) {
 479       return ACCESS_OK;
 480     }
 481 
 482     // Find the module entry for current_class, the accessor
 483     ModuleEntry* module_from = current_class-&gt;module();
 484     // Find the module entry for new_class, the accessee
 485     ModuleEntry* module_to = new_class-&gt;module();
 486 
 487     // both in same (possibly unnamed) module
 488     if (module_from == module_to) {
 489       return ACCESS_OK;
 490     }
 491 
 492     // Acceptable access to a type in an unnamed module. Note that since
 493     // unnamed modules can read all unnamed modules, this also handles the
 494     // case where module_from is also unnamed but in a different class loader.
 495     if (!module_to-&gt;is_named() &amp;&amp;
 496         (module_from-&gt;can_read_all_unnamed() || module_from-&gt;can_read(module_to))) {
 497       return ACCESS_OK;
 498     }
 499 
 500     // Establish readability, check if module_from is allowed to read module_to.
 501     if (!module_from-&gt;can_read(module_to)) {
 502       return MODULE_NOT_READABLE;
 503     }
 504 
 505     // Access is allowed if module_to is open, i.e. all its packages are unqualifiedly exported
 506     if (module_to-&gt;is_open()) {
 507       return ACCESS_OK;
 508     }
 509 
 510     PackageEntry* package_to = new_class-&gt;package();
 511     assert(package_to != NULL, &quot;can not obtain new_class&#39; package&quot;);
 512 
 513     {
 514       MutexLocker m1(Module_lock);
 515 
 516       // Once readability is established, if module_to exports T unqualifiedly,
 517       // (to all modules), than whether module_from is in the unnamed module
 518       // or not does not matter, access is allowed.
 519       if (package_to-&gt;is_unqual_exported()) {
 520         return ACCESS_OK;
 521       }
 522 
 523       // Access is allowed if both 1 &amp; 2 hold:
 524       //   1. Readability, module_from can read module_to (established above).
 525       //   2. Either module_to exports T to module_from qualifiedly.
 526       //      or
 527       //      module_to exports T to all unnamed modules and module_from is unnamed.
 528       //      or
 529       //      module_to exports T unqualifiedly to all modules (checked above).
 530       if (!package_to-&gt;is_qexported_to(module_from)) {
 531         return TYPE_NOT_EXPORTED;
 532       }
 533     }
 534     return ACCESS_OK;
 535   }
 536 
 537   if (can_relax_access_check_for(current_class, new_class, classloader_only)) {
 538     return ACCESS_OK;
 539   }
 540   return OTHER_PROBLEM;
 541 }
 542 
 543 // Return an error message specific to the specified Klass*&#39;s and result.
 544 // This function must be called from within a block containing a ResourceMark.
 545 char* Reflection::verify_class_access_msg(const Klass* current_class,
 546                                           const InstanceKlass* new_class,
 547                                           const VerifyClassAccessResults result) {
 548   assert(result != ACCESS_OK, &quot;must be failure result&quot;);
 549   char * msg = NULL;
 550   if (result != OTHER_PROBLEM &amp;&amp; new_class != NULL &amp;&amp; current_class != NULL) {
 551     // Find the module entry for current_class, the accessor
 552     ModuleEntry* module_from = current_class-&gt;module();
 553     const char * module_from_name = module_from-&gt;is_named() ? module_from-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 554     const char * current_class_name = current_class-&gt;external_name();
 555 
 556     // Find the module entry for new_class, the accessee
 557     ModuleEntry* module_to = NULL;
 558     module_to = new_class-&gt;module();
 559     const char * module_to_name = module_to-&gt;is_named() ? module_to-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
 560     const char * new_class_name = new_class-&gt;external_name();
 561 
 562     if (result == MODULE_NOT_READABLE) {
 563       assert(module_from-&gt;is_named(), &quot;Unnamed modules can read all modules&quot;);
 564       if (module_to-&gt;is_named()) {
 565         size_t len = 100 + strlen(current_class_name) + 2*strlen(module_from_name) +
 566           strlen(new_class_name) + 2*strlen(module_to_name);
 567         msg = NEW_RESOURCE_ARRAY(char, len);
 568         jio_snprintf(msg, len - 1,
 569           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not read module %s&quot;,
 570           current_class_name, module_from_name, new_class_name,
 571           module_to_name, module_from_name, module_to_name);
 572       } else {
 573         oop jlm = module_to-&gt;module();
 574         assert(jlm != NULL, &quot;Null jlm in module_to ModuleEntry&quot;);
 575         intptr_t identity_hash = jlm-&gt;identity_hash();
 576         size_t len = 160 + strlen(current_class_name) + 2*strlen(module_from_name) +
 577           strlen(new_class_name) + 2*sizeof(uintx);
 578         msg = NEW_RESOURCE_ARRAY(char, len);
 579         jio_snprintf(msg, len - 1,
 580           &quot;class %s (in module %s) cannot access class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) because module %s does not read unnamed module @&quot; SIZE_FORMAT_HEX,
 581           current_class_name, module_from_name, new_class_name, uintx(identity_hash),
 582           module_from_name, uintx(identity_hash));
 583       }
 584 
 585     } else if (result == TYPE_NOT_EXPORTED) {
 586       assert(new_class-&gt;package() != NULL,
 587              &quot;Unnamed packages are always exported&quot;);
 588       const char * package_name =
 589         new_class-&gt;package()-&gt;name()-&gt;as_klass_external_name();
 590       assert(module_to-&gt;is_named(), &quot;Unnamed modules export all packages&quot;);
 591       if (module_from-&gt;is_named()) {
 592         size_t len = 118 + strlen(current_class_name) + 2*strlen(module_from_name) +
 593           strlen(new_class_name) + 2*strlen(module_to_name) + strlen(package_name);
 594         msg = NEW_RESOURCE_ARRAY(char, len);
 595         jio_snprintf(msg, len - 1,
 596           &quot;class %s (in module %s) cannot access class %s (in module %s) because module %s does not export %s to module %s&quot;,
 597           current_class_name, module_from_name, new_class_name,
 598           module_to_name, module_to_name, package_name, module_from_name);
 599       } else {
 600         oop jlm = module_from-&gt;module();
 601         assert(jlm != NULL, &quot;Null jlm in module_from ModuleEntry&quot;);
 602         intptr_t identity_hash = jlm-&gt;identity_hash();
 603         size_t len = 170 + strlen(current_class_name) + strlen(new_class_name) +
 604           2*strlen(module_to_name) + strlen(package_name) + 2*sizeof(uintx);
 605         msg = NEW_RESOURCE_ARRAY(char, len);
 606         jio_snprintf(msg, len - 1,
 607           &quot;class %s (in unnamed module @&quot; SIZE_FORMAT_HEX &quot;) cannot access class %s (in module %s) because module %s does not export %s to unnamed module @&quot; SIZE_FORMAT_HEX,
 608           current_class_name, uintx(identity_hash), new_class_name, module_to_name,
 609           module_to_name, package_name, uintx(identity_hash));
 610       }
 611     } else {
 612         ShouldNotReachHere();
 613     }
 614   }  // result != OTHER_PROBLEM...
 615   return msg;
 616 }
 617 
 618 bool Reflection::verify_member_access(const Klass* current_class,
 619                                       const Klass* resolved_class,
 620                                       const Klass* member_class,
 621                                       AccessFlags access,
 622                                       bool classloader_only,
 623                                       bool protected_restriction,
 624                                       TRAPS) {
 625   // Verify that current_class can access a member of member_class, where that
 626   // field&#39;s access bits are &quot;access&quot;.  We assume that we&#39;ve already verified
 627   // that current_class can access member_class.
 628   //
 629   // If the classloader_only flag is set, we automatically allow any accesses
 630   // in which current_class doesn&#39;t have a classloader.
 631   //
 632   // &quot;resolved_class&quot; is the runtime type of &quot;member_class&quot;. Sometimes we don&#39;t
 633   // need this distinction (e.g. if all we have is the runtime type, or during
 634   // class file parsing when we only care about the static type); in that case
 635   // callers should ensure that resolved_class == member_class.
 636   //
 637   if ((current_class == NULL) ||
 638       (current_class == member_class) ||
 639       access.is_public()) {
 640     return true;
 641   }
 642 
 643   const Klass* host_class = current_class;
 644   if (current_class-&gt;is_instance_klass() &amp;&amp;
 645       InstanceKlass::cast(current_class)-&gt;is_unsafe_anonymous()) {
 646     host_class = InstanceKlass::cast(current_class)-&gt;unsafe_anonymous_host();
 647     assert(host_class != NULL, &quot;Unsafe anonymous class has null host class&quot;);
 648     assert(!(host_class-&gt;is_instance_klass() &amp;&amp;
 649            InstanceKlass::cast(host_class)-&gt;is_unsafe_anonymous()),
 650            &quot;unsafe_anonymous_host should not be unsafe anonymous itself&quot;);
 651   }
 652   if (host_class == member_class) {
 653     return true;
 654   }
 655 
 656   if (access.is_protected()) {
 657     if (!protected_restriction) {
 658       // See if current_class (or outermost host class) is a subclass of member_class
 659       // An interface may not access protected members of j.l.Object
 660       if (!host_class-&gt;is_interface() &amp;&amp; host_class-&gt;is_subclass_of(member_class)) {
 661         if (access.is_static() || // static fields are ok, see 6622385
 662             current_class == resolved_class ||
 663             member_class == resolved_class ||
 664             host_class-&gt;is_subclass_of(resolved_class) ||
 665             resolved_class-&gt;is_subclass_of(host_class)) {
 666           return true;
 667         }
 668       }
 669     }
 670   }
 671 
 672   // package access
 673   if (!access.is_private() &amp;&amp; is_same_class_package(current_class, member_class)) {
 674     return true;
 675   }
 676 
 677   // private access between different classes needs a nestmate check, but
 678   // not for unsafe anonymous classes - so check host_class
 679   if (access.is_private() &amp;&amp; host_class == current_class) {
 680     if (current_class-&gt;is_instance_klass() &amp;&amp; member_class-&gt;is_instance_klass() ) {
 681       InstanceKlass* cur_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(current_class));
 682       InstanceKlass* field_ik = const_cast&lt;InstanceKlass*&gt;(InstanceKlass::cast(member_class));
 683       // Nestmate access checks may require resolution and validation of the nest-host.
 684       // It is up to the caller to check for pending exceptions and handle appropriately.
 685       bool access = cur_ik-&gt;has_nestmate_access_to(field_ik, CHECK_false);
 686       if (access) {
 687         guarantee(resolved_class-&gt;is_subclass_of(member_class), &quot;must be!&quot;);
 688         return true;
 689       }
 690     }
 691   }
 692 
 693   // Allow all accesses from jdk/internal/reflect/MagicAccessorImpl subclasses to
 694   // succeed trivially.
 695   if (current_class-&gt;is_subclass_of(SystemDictionary::reflect_MagicAccessorImpl_klass())) {
 696     return true;
 697   }
 698 
 699   // Check for special relaxations
 700   return can_relax_access_check_for(current_class, member_class, classloader_only);
 701 }
 702 
 703 bool Reflection::is_same_class_package(const Klass* class1, const Klass* class2) {
 704   return InstanceKlass::cast(class1)-&gt;is_same_class_package(class2);
 705 }
 706 
 707 // Checks that the &#39;outer&#39; klass has declared &#39;inner&#39; as being an inner klass. If not,
 708 // throw an incompatible class change exception
 709 // If inner_is_member, require the inner to be a member of the outer.
 710 // If !inner_is_member, require the inner to be unsafe anonymous (a non-member).
 711 // Caller is responsible for figuring out in advance which case must be true.
 712 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
 713                                        bool inner_is_member, TRAPS) {
 714   InnerClassesIterator iter(outer);
 715   constantPoolHandle cp   (THREAD, outer-&gt;constants());
 716   for (; !iter.done(); iter.next()) {
 717     int ioff = iter.inner_class_info_index();
 718     int ooff = iter.outer_class_info_index();
 719 
 720     if (inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff != 0) {
 721       if (cp-&gt;klass_name_at_matches(outer, ooff) &amp;&amp;
 722           cp-&gt;klass_name_at_matches(inner, ioff)) {
 723         Klass* o = cp-&gt;klass_at(ooff, CHECK);
 724         if (o == outer) {
 725           Klass* i = cp-&gt;klass_at(ioff, CHECK);
 726           if (i == inner) {
 727             return;
 728           }
 729         }
 730       }
 731     }
 732 
 733     if (!inner_is_member &amp;&amp; ioff != 0 &amp;&amp; ooff == 0 &amp;&amp;
 734         cp-&gt;klass_name_at_matches(inner, ioff)) {
 735       Klass* i = cp-&gt;klass_at(ioff, CHECK);
 736       if (i == inner) {
 737         return;
 738       }
 739     }
 740   }
 741 
 742   // &#39;inner&#39; not declared as an inner klass in outer
 743   ResourceMark rm(THREAD);
 744   Exceptions::fthrow(
 745     THREAD_AND_LOCATION,
 746     vmSymbols::java_lang_IncompatibleClassChangeError(),
 747     &quot;%s and %s disagree on InnerClasses attribute&quot;,
 748     outer-&gt;external_name(),
 749     inner-&gt;external_name()
 750   );
 751 }
 752 
 753 // Utility method converting a single SignatureStream element into java.lang.Class instance
 754 static oop get_mirror_from_signature(const methodHandle&amp; method,
 755                                      SignatureStream* ss,
 756                                      TRAPS) {
 757 
 758 
 759   if (is_reference_type(ss-&gt;type())) {
 760     Symbol* name = ss-&gt;as_symbol();
 761     oop loader = method-&gt;method_holder()-&gt;class_loader();
 762     oop protection_domain = method-&gt;method_holder()-&gt;protection_domain();
 763     const Klass* k = SystemDictionary::resolve_or_fail(name,
 764                                                        Handle(THREAD, loader),
 765                                                        Handle(THREAD, protection_domain),
 766                                                        true,
 767                                                        CHECK_NULL);
 768     if (log_is_enabled(Debug, class, resolve)) {
 769       trace_class_resolution(k);
 770     }
 771     return k-&gt;java_mirror();
 772   }
 773 
 774   assert(ss-&gt;type() != T_VOID || ss-&gt;at_return_type(),
 775     &quot;T_VOID should only appear as return type&quot;);
 776 
 777   return java_lang_Class::primitive_mirror(ss-&gt;type());
 778 }
 779 
 780 static objArrayHandle get_parameter_types(const methodHandle&amp; method,
 781                                           int parameter_count,
 782                                           oop* return_type,
 783                                           TRAPS) {
 784   // Allocate array holding parameter types (java.lang.Class instances)
 785   objArrayOop m = oopFactory::new_objArray(SystemDictionary::Class_klass(), parameter_count, CHECK_(objArrayHandle()));
 786   objArrayHandle mirrors(THREAD, m);
 787   int index = 0;
 788   // Collect parameter types
 789   ResourceMark rm(THREAD);
 790   Symbol*  signature = method-&gt;signature();
 791   SignatureStream ss(signature);
 792   while (!ss.at_return_type()) {
 793     oop mirror = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 794     mirrors-&gt;obj_at_put(index++, mirror);
 795     ss.next();
 796   }
 797   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 798   if (return_type != NULL) {
 799     // Collect return type as well
 800     assert(ss.at_return_type(), &quot;return type should be present&quot;);
 801     *return_type = get_mirror_from_signature(method, &amp;ss, CHECK_(objArrayHandle()));
 802   }
 803   return mirrors;
 804 }
 805 
 806 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 807   return method-&gt;resolved_checked_exceptions(THREAD);
 808 }
 809 
 810 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
<a name="2" id="anc2"></a><span class="line-added"> 811   SignatureStream ss(signature, false);</span>
 812   // Basic types
<a name="3" id="anc3"></a><span class="line-modified"> 813   BasicType type = ss.is_reference() ? T_OBJECT : ss.type();</span>
 814   if (type != T_OBJECT) {
 815     return Handle(THREAD, Universe::java_mirror(type));
 816   }
 817 
 818   Klass* result =
 819     SystemDictionary::resolve_or_fail(signature,
 820                                       Handle(THREAD, k-&gt;class_loader()),
 821                                       Handle(THREAD, k-&gt;protection_domain()),
 822                                       true, CHECK_(Handle()));
 823 
 824   if (log_is_enabled(Debug, class, resolve)) {
 825     trace_class_resolution(result);
 826   }
 827 
 828   oop nt = result-&gt;java_mirror();
 829   return Handle(THREAD, nt);
 830 }
 831 
 832 
 833 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 834   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
 835   assert(!method()-&gt;is_initializer() ||
 836          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()),
 837          &quot;should call new_constructor instead&quot;);
 838   InstanceKlass* holder = method-&gt;method_holder();
 839   int slot = method-&gt;method_idnum();
 840 
 841   Symbol*  signature  = method-&gt;signature();
 842   int parameter_count = ArgumentCount(signature).size();
 843   oop return_type_oop = NULL;
 844   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 845   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 846 
 847   Handle return_type(THREAD, return_type_oop);
 848 
 849   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 850 
 851   if (exception_types.is_null()) return NULL;
 852 
 853   Symbol*  method_name = method-&gt;name();
 854   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 855   Handle name = Handle(THREAD, name_oop);
 856   if (name == NULL) return NULL;
 857 
 858   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 859 
 860   Handle mh = java_lang_reflect_Method::create(CHECK_NULL);
 861 
 862   java_lang_reflect_Method::set_clazz(mh(), holder-&gt;java_mirror());
 863   java_lang_reflect_Method::set_slot(mh(), slot);
 864   java_lang_reflect_Method::set_name(mh(), name());
 865   java_lang_reflect_Method::set_return_type(mh(), return_type());
 866   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 867   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 868   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 869   java_lang_reflect_Method::set_override(mh(), false);
 870   if (method-&gt;generic_signature() != NULL) {
 871     Symbol*  gs = method-&gt;generic_signature();
 872     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 873     java_lang_reflect_Method::set_signature(mh(), sig());
 874   }
 875   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 876   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 877   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 878   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 879   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 880   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 881   return mh();
 882 }
 883 
 884 
 885 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
 886   assert(method()-&gt;is_initializer(), &quot;should call new_method instead&quot;);
 887 
 888   InstanceKlass* holder = method-&gt;method_holder();
 889   int slot = method-&gt;method_idnum();
 890 
 891   Symbol*  signature  = method-&gt;signature();
 892   int parameter_count = ArgumentCount(signature).size();
 893   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 894   if (parameter_types.is_null()) return NULL;
 895 
 896   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 897   if (exception_types.is_null()) return NULL;
 898 
 899   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 900 
 901   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 902 
 903   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 904   java_lang_reflect_Constructor::set_slot(ch(), slot);
 905   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 906   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
 907   java_lang_reflect_Constructor::set_modifiers(ch(), modifiers);
 908   java_lang_reflect_Constructor::set_override(ch(), false);
 909   if (method-&gt;generic_signature() != NULL) {
 910     Symbol*  gs = method-&gt;generic_signature();
 911     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 912     java_lang_reflect_Constructor::set_signature(ch(), sig());
 913   }
 914   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 915   java_lang_reflect_Constructor::set_annotations(ch(), an_oop);
 916   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 917   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 918   return ch();
 919 }
 920 
 921 
 922 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 923   Symbol*  field_name = fd-&gt;name();
 924   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 925   Handle name = Handle(THREAD, name_oop);
 926   Symbol*  signature  = fd-&gt;signature();
 927   InstanceKlass* holder = fd-&gt;field_holder();
 928   Handle type = new_type(signature, holder, CHECK_NULL);
 929   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 930 
 931   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 932   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 933   java_lang_reflect_Field::set_name(rh(), name());
 934   java_lang_reflect_Field::set_type(rh(), type());
 935   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
 936   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);
 937   java_lang_reflect_Field::set_override(rh(), false);
 938   if (fd-&gt;has_generic_signature()) {
 939     Symbol*  gs = fd-&gt;generic_signature();
 940     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 941     java_lang_reflect_Field::set_signature(rh(), sig());
 942   }
 943   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 944   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 945   return rh();
 946 }
 947 
 948 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 949                               int flags, TRAPS) {
 950 
 951   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 952 
 953   if(NULL != sym) {
 954     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 955     java_lang_reflect_Parameter::set_name(rh(), name());
 956   } else {
 957     java_lang_reflect_Parameter::set_name(rh(), NULL);
 958   }
 959 
 960   java_lang_reflect_Parameter::set_modifiers(rh(), flags);
 961   java_lang_reflect_Parameter::set_executable(rh(), method());
 962   java_lang_reflect_Parameter::set_index(rh(), index);
 963   return rh();
 964 }
 965 
 966 
 967 static methodHandle resolve_interface_call(InstanceKlass* klass,
 968                                            const methodHandle&amp; method,
 969                                            Klass* recv_klass,
 970                                            Handle receiver,
 971                                            TRAPS) {
 972 
 973   assert(!method.is_null() , &quot;method should not be null&quot;);
 974 
 975   CallInfo info;
 976   Symbol*  signature  = method-&gt;signature();
 977   Symbol*  name       = method-&gt;name();
 978   LinkResolver::resolve_interface_call(info, receiver, recv_klass,
 979                                        LinkInfo(klass, name, signature),
 980                                        true,
 981                                        CHECK_(methodHandle()));
 982   return methodHandle(THREAD, info.selected_method());
 983 }
 984 
 985 // Conversion
 986 static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror, TRAPS) {
 987   assert(java_lang_Class::is_primitive(basic_type_mirror),
 988     &quot;just checking&quot;);
 989   return java_lang_Class::primitive_type(basic_type_mirror);
 990 }
 991 
 992 // Narrowing of basic types. Used to create correct jvalues for
 993 // boolean, byte, char and short return return values from interpreter
 994 // which are returned as ints. Throws IllegalArgumentException.
 995 static void narrow(jvalue* value, BasicType narrow_type, TRAPS) {
 996   switch (narrow_type) {
 997   case T_BOOLEAN:
 998     value-&gt;z = (jboolean) (value-&gt;i &amp; 1);
 999     return;
1000   case T_BYTE:
1001     value-&gt;b = (jbyte)value-&gt;i;
1002     return;
1003   case T_CHAR:
1004     value-&gt;c = (jchar)value-&gt;i;
1005     return;
1006   case T_SHORT:
1007     value-&gt;s = (jshort)value-&gt;i;
1008     return;
1009   default:
1010     break; // fail
1011   }
1012   THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1013 }
1014 
1015 
1016 // Method call (shared by invoke_method and invoke_constructor)
1017 static oop invoke(InstanceKlass* klass,
1018                   const methodHandle&amp; reflected_method,
1019                   Handle receiver,
1020                   bool override,
1021                   objArrayHandle ptypes,
1022                   BasicType rtype,
1023                   objArrayHandle args,
1024                   bool is_method_invoke,
1025                   TRAPS) {
1026 
1027   ResourceMark rm(THREAD);
1028 
1029   methodHandle method;      // actual method to invoke
1030   Klass* target_klass;      // target klass, receiver&#39;s klass for non-static
1031 
1032   // Ensure klass is initialized
1033   klass-&gt;initialize(CHECK_NULL);
1034 
1035   bool is_static = reflected_method-&gt;is_static();
1036   if (is_static) {
1037     // ignore receiver argument
1038     method = reflected_method;
1039     target_klass = klass;
1040   } else {
1041     // check for null receiver
1042     if (receiver.is_null()) {
1043       THROW_0(vmSymbols::java_lang_NullPointerException());
1044     }
1045     // Check class of receiver against class declaring method
1046     if (!receiver-&gt;is_a(klass)) {
1047       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;object is not an instance of declaring class&quot;);
1048     }
1049     // target klass is receiver&#39;s klass
1050     target_klass = receiver-&gt;klass();
1051     // no need to resolve if method is private or &lt;init&gt;
1052     if (reflected_method-&gt;is_private() || reflected_method-&gt;name() == vmSymbols::object_initializer_name()) {
1053       method = reflected_method;
1054     } else {
1055       // resolve based on the receiver
1056       if (reflected_method-&gt;method_holder()-&gt;is_interface()) {
1057         // resolve interface call
1058         //
1059         // Match resolution errors with those thrown due to reflection inlining
1060         // Linktime resolution &amp; IllegalAccessCheck already done by Class.getMethod()
1061         method = resolve_interface_call(klass, reflected_method, target_klass, receiver, THREAD);
1062         if (HAS_PENDING_EXCEPTION) {
1063           // Method resolution threw an exception; wrap it in an InvocationTargetException
1064           oop resolution_exception = PENDING_EXCEPTION;
1065           CLEAR_PENDING_EXCEPTION;
1066           // JVMTI has already reported the pending exception
1067           // JVMTI internal flag reset is needed in order to report InvocationTargetException
1068           if (THREAD-&gt;is_Java_thread()) {
1069             JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1070           }
1071           JavaCallArguments args(Handle(THREAD, resolution_exception));
1072           THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1073                       vmSymbols::throwable_void_signature(),
1074                       &amp;args);
1075         }
1076       }  else {
1077         // if the method can be overridden, we resolve using the vtable index.
1078         assert(!reflected_method-&gt;has_itable_index(), &quot;&quot;);
1079         int index = reflected_method-&gt;vtable_index();
1080         method = reflected_method;
1081         if (index != Method::nonvirtual_vtable_index) {
1082           method = methodHandle(THREAD, target_klass-&gt;method_at_vtable(index));
1083         }
1084         if (!method.is_null()) {
1085           // Check for abstract methods as well
1086           if (method-&gt;is_abstract()) {
1087             // new default: 6531596
1088             ResourceMark rm(THREAD);
1089             stringStream ss;
1090             ss.print(&quot;&#39;&quot;);
1091             Method::print_external_name(&amp;ss, target_klass, method-&gt;name(), method-&gt;signature());
1092             ss.print(&quot;&#39;&quot;);
1093             Handle h_origexception = Exceptions::new_exception(THREAD,
1094               vmSymbols::java_lang_AbstractMethodError(), ss.as_string());
1095             JavaCallArguments args(h_origexception);
1096             THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1097               vmSymbols::throwable_void_signature(),
1098               &amp;args);
1099           }
1100         }
1101       }
1102     }
1103   }
1104 
1105   // I believe this is a ShouldNotGetHere case which requires
1106   // an internal vtable bug. If you ever get this please let Karen know.
1107   if (method.is_null()) {
1108     ResourceMark rm(THREAD);
1109     stringStream ss;
1110     ss.print(&quot;&#39;&quot;);
1111     Method::print_external_name(&amp;ss, klass,
1112                                      reflected_method-&gt;name(),
1113                                      reflected_method-&gt;signature());
1114     ss.print(&quot;&#39;&quot;);
1115     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), ss.as_string());
1116   }
1117 
1118   assert(ptypes-&gt;is_objArray(), &quot;just checking&quot;);
1119   int args_len = args.is_null() ? 0 : args-&gt;length();
1120   // Check number of arguments
1121   if (ptypes-&gt;length() != args_len) {
1122     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1123                 &quot;wrong number of arguments&quot;);
1124   }
1125 
1126   // Create object to contain parameters for the JavaCall
1127   JavaCallArguments java_args(method-&gt;size_of_parameters());
1128 
1129   if (!is_static) {
1130     java_args.push_oop(receiver);
1131   }
1132 
1133   for (int i = 0; i &lt; args_len; i++) {
1134     oop type_mirror = ptypes-&gt;obj_at(i);
1135     oop arg = args-&gt;obj_at(i);
1136     if (java_lang_Class::is_primitive(type_mirror)) {
1137       jvalue value;
1138       BasicType ptype = basic_type_mirror_to_basic_type(type_mirror, CHECK_NULL);
1139       BasicType atype = Reflection::unbox_for_primitive(arg, &amp;value, CHECK_NULL);
1140       if (ptype != atype) {
1141         Reflection::widen(&amp;value, atype, ptype, CHECK_NULL);
1142       }
1143       switch (ptype) {
1144         case T_BOOLEAN:     java_args.push_int(value.z);    break;
1145         case T_CHAR:        java_args.push_int(value.c);    break;
1146         case T_BYTE:        java_args.push_int(value.b);    break;
1147         case T_SHORT:       java_args.push_int(value.s);    break;
1148         case T_INT:         java_args.push_int(value.i);    break;
1149         case T_LONG:        java_args.push_long(value.j);   break;
1150         case T_FLOAT:       java_args.push_float(value.f);  break;
1151         case T_DOUBLE:      java_args.push_double(value.d); break;
1152         default:
1153           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;argument type mismatch&quot;);
1154       }
1155     } else {
1156       if (arg != NULL) {
1157         Klass* k = java_lang_Class::as_Klass(type_mirror);
1158         if (!arg-&gt;is_a(k)) {
1159           THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1160                       &quot;argument type mismatch&quot;);
1161         }
1162       }
1163       Handle arg_handle(THREAD, arg);         // Create handle for argument
1164       java_args.push_oop(arg_handle); // Push handle
1165     }
1166   }
1167 
1168   assert(java_args.size_of_parameters() == method-&gt;size_of_parameters(),
1169     &quot;just checking&quot;);
1170 
1171   // All oops (including receiver) is passed in as Handles. An potential oop is returned as an
1172   // oop (i.e., NOT as an handle)
1173   JavaValue result(rtype);
1174   JavaCalls::call(&amp;result, method, &amp;java_args, THREAD);
1175 
1176   if (HAS_PENDING_EXCEPTION) {
1177     // Method threw an exception; wrap it in an InvocationTargetException
1178     oop target_exception = PENDING_EXCEPTION;
1179     CLEAR_PENDING_EXCEPTION;
1180     // JVMTI has already reported the pending exception
1181     // JVMTI internal flag reset is needed in order to report InvocationTargetException
1182     if (THREAD-&gt;is_Java_thread()) {
1183       JvmtiExport::clear_detected_exception((JavaThread*)THREAD);
1184     }
1185 
1186     JavaCallArguments args(Handle(THREAD, target_exception));
1187     THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),
1188                 vmSymbols::throwable_void_signature(),
1189                 &amp;args);
1190   } else {
1191     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1192       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1193     }
1194     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1195   }
1196 }
1197 
1198 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1199 // of java.lang.reflect.Constructor
1200 
1201 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1202   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1203   int slot               = java_lang_reflect_Method::slot(method_mirror);
1204   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1205   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1206 
1207   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1208   BasicType rtype;
1209   if (java_lang_Class::is_primitive(return_type_mirror)) {
1210     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
1211   } else {
1212     rtype = T_OBJECT;
1213   }
1214 
1215   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1216   Method* m = klass-&gt;method_with_idnum(slot);
1217   if (m == NULL) {
1218     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1219   }
1220   methodHandle method(THREAD, m);
1221 
1222   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1223 }
1224 
1225 
1226 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1227   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1228   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1229   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1230   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1231 
1232   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1233   Method* m = klass-&gt;method_with_idnum(slot);
1234   if (m == NULL) {
1235     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1236   }
1237   methodHandle method(THREAD, m);
1238   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1239 
1240   // Make sure klass gets initialize
1241   klass-&gt;initialize(CHECK_NULL);
1242 
1243   // Create new instance (the receiver)
1244   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
1245   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1246 
1247   // Ignore result from call and return receiver
1248   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1249   return receiver();
1250 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>