<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/interpreter/bytecodeUtils.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;classfile/systemDictionary.hpp&quot;
  28 #include &quot;gc/shared/gcLocker.hpp&quot;
  29 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
  31 #include &quot;runtime/signature.hpp&quot;
  32 #include &quot;runtime/safepointVerifiers.hpp&quot;
  33 #include &quot;utilities/events.hpp&quot;
  34 #include &quot;utilities/ostream.hpp&quot;
  35 
  36 class SimulatedOperandStack;
  37 class ExceptionMessageBuilder;
  38 
  39 // The entries of a SimulatedOperandStack. They carry the analysis
  40 // information gathered for the slot.
  41 class StackSlotAnalysisData {
  42  private:
  43 
  44   friend class SimulatedOperandStack;
  45   friend class ExceptionMessageBuilder;
  46 
  47   unsigned int _bci:17;    // The bci of the bytecode that pushed the current value on the operand stack.
  48                            // INVALID if ambiguous, e.g. after a control flow merge.
  49                            // 16 bits for bci (max bytecode size) and one for INVALID.
  50   unsigned int _type:15;   // The BasicType of the value on the operand stack.
  51 
  52   // Merges this slot data with the given one and returns the result. If
  53   // the bcis of the two merged objects are different, the bci of the result
  54   // will be undefined. If the types are different, the result type is T_CONFLICT.
  55   // (An exception is if one type is an array and the other is object, then
  56   // the result type will be T_OBJECT).
  57   StackSlotAnalysisData merge(StackSlotAnalysisData other);
  58 
  59  public:
  60 
  61   // Creates a new object with an invalid bci and the given type.
  62   StackSlotAnalysisData(BasicType type = T_CONFLICT);
  63 
  64   // Creates a new object with the given bci and type.
  65   StackSlotAnalysisData(int bci, BasicType type);
  66 
  67   enum {
  68     // An invalid bytecode index, as &gt; 65535.
  69     INVALID = 0x1FFFF
  70   };
  71 
  72   // Returns the bci. If the bci is invalid, INVALID is returned.
  73   unsigned int get_bci();
  74 
  75   // Returns true, if the bci is not invalid.
  76   bool has_bci() { return get_bci() != INVALID; }
  77 
  78   // Returns the type of the slot data.
  79   BasicType get_type();
  80 };
  81 
  82 // A stack consisting of SimulatedOperandStackEntries.
  83 // This represents the analysis information for the operand stack
  84 // for a given bytecode at a given bci.
  85 // It also holds an additional field that serves to collect
  86 // information whether local slots were written.
  87 class SimulatedOperandStack: CHeapObj&lt;mtInternal&gt; {
  88 
  89  private:
  90 
  91   friend class ExceptionMessageBuilder;
  92   friend class StackSlotAnalysisData;
  93 
  94   // The stack.
  95   GrowableArray&lt;StackSlotAnalysisData&gt; _stack;
  96 
  97   // Optimized bytecode can reuse local variable slots for several
  98   // local variables.
  99   // If there is no variable name information, we print &#39;parameter&lt;i&gt;&#39;
 100   // if a parameter maps to a local slot. Once a local slot has been
 101   // written, we don&#39;t know any more whether it was written as the
 102   // corresponding parameter, or whether another local has been
 103   // mapped to the slot. So we don&#39;t want to print &#39;parameter&lt;i&gt;&#39; any
 104   // more, but &#39;local&lt;i&gt;&#39;. Similary for &#39;this&#39;.
 105   // Therefore, during the analysis, we mark a bit for local slots that
 106   // get written and propagate this information.
 107   // We only run the analysis for 64 slots. If a method has more
 108   // parameters, we print &#39;local&lt;i&gt;&#39; in all cases.
 109   uint64_t _written_local_slots;
 110 
 111   SimulatedOperandStack(): _written_local_slots(0) { };
 112   SimulatedOperandStack(const SimulatedOperandStack &amp;copy);
 113 
 114   // Pushes the given slot data.
 115   void push_raw(StackSlotAnalysisData slotData);
 116 
 117   // Like push_raw, but if the slotData has type long or double, we push two.
 118   void push(StackSlotAnalysisData slotData);
 119 
 120   // Like push(slotData), but using bci/type to create an instance of
 121   // StackSlotAnalysisData first.
 122   void push(int bci, BasicType type);
 123 
 124   // Pops the given number of entries.
 125   void pop(int slots);
 126 
 127   // Merges this with the given stack by merging all entries. The
 128   // size of the stacks must be the same.
 129   void merge(SimulatedOperandStack const&amp; other);
 130 
 131  public:
 132 
 133   // Returns the size of the stack.
 134   int get_size() const;
 135 
 136   // Returns the slot data at the given index. Slot 0 is top of stack.
 137   StackSlotAnalysisData get_slot_data(int slot);
 138 
 139   // Mark that local slot i was written.
 140   void set_local_slot_written(int i);
 141 
 142   // Check whether local slot i was written by this or a previous bytecode.
 143   bool local_slot_was_written(int i);
 144 };
 145 
 146 // Helper class to build internal exception messages for exceptions
 147 // that are thrown because prerequisites to execute a bytecode
 148 // are not met.
 149 // E.g., if a NPE is thrown because an iload can not be executed
 150 // by the VM because the reference to load from is null.
 151 //
 152 // It analyses the bytecode to assemble Java-like message text
 153 // to give precise information where in a larger expression the
 154 // exception occured.
 155 //
 156 // To assemble this message text, it is needed to know how
 157 // operand stack slot entries were pushed on the operand stack.
 158 // This class contains an analysis over the bytecodes to compute
 159 // this information. The information is stored in a
 160 // SimulatedOperandStack for each bytecode.
 161 class ExceptionMessageBuilder : public StackObj {
 162 
 163   // The stacks for each bytecode.
 164   GrowableArray&lt;SimulatedOperandStack*&gt;* _stacks;
 165 
 166   // The method.
 167   Method* _method;
 168 
 169   // The number of entries used (the sum of all entries of all stacks).
 170   int _nr_of_entries;
 171 
 172   // If true, we have added at least one new stack.
 173   bool _added_one;
 174 
 175   // If true, we have processed all bytecodes.
 176   bool _all_processed;
 177 
 178   // The maximum number of entries we want to use. This is used to
 179   // limit the amount of memory we waste for insane methods (as they
 180   // appear in JCK tests).
 181   static const int _max_entries = 1000000;
 182 
 183   static const int _max_cause_detail = 5;
 184 
 185   // Merges the stack the the given bci with the given stack. If there
 186   // is no stack at the bci, we just put the given stack there. This
 187   // method doesn&#39;t takes ownership of the stack.
 188   void merge(int bci, SimulatedOperandStack* stack);
 189 
 190   // Processes the instruction at the given bci in the method. Returns
 191   // the size of the instruction.
 192   int do_instruction(int bci);
 193 
 194   bool print_NPE_cause0(outputStream *os, int bci, int slot, int max_detail,
 195                         bool inner_expr = false, const char *prefix = NULL);
 196 
 197  public:
 198 
 199   // Creates an ExceptionMessageBuilder object and runs the analysis
 200   // building SimulatedOperandStacks for each bytecode in the given
 201   // method (the method must be rewritten already). Note that you&#39;re
 202   // not allowed to use this object when crossing a safepoint! If the
 203   // bci is != -1, we only create the stacks as far as needed to get a
 204   // stack for the bci.
 205   ExceptionMessageBuilder(Method* method, int bci = -1);
 206 
 207   // Releases the resources.
 208   ~ExceptionMessageBuilder();
 209 
 210   // Returns the number of stacks (this is the size of the method).
 211   int get_size() { return _stacks-&gt;length() - 1; }
 212 
 213   // Assuming that a NullPointerException was thrown at the given bci,
 214   // we return the nr of the slot holding the null reference. If this
 215   // NPE is created by hand, we return -2 as the slot. If there
 216   // cannot be a NullPointerException at the bci, -1 is returned.
 217   int get_NPE_null_slot(int bci);
 218 
 219   // Prints a java-like expression for the bytecode that pushed
 220   // the value to the given slot being live at the given bci.
 221   // It constructs the expression by recursing backwards over the
 222   // bytecode using the results of the analysis done in the
 223   // constructor of ExceptionMessageBuilder.
 224   //  os:   The stream to print the message to.
 225   //  bci:  The index of the bytecode that caused the NPE.
 226   //  slot: The slot on the operand stack that contains null.
 227   //        The slots are numbered from TOS downwards, i.e.,
 228   //        TOS has the slot number 0, that below 1 and so on.
 229   //
 230   // Returns false if nothing was printed, else true.
 231   bool print_NPE_cause(outputStream *os, int bci, int slot);
 232 
 233   // Prints a string describing the failed action.
 234   void print_NPE_failed_action(outputStream *os, int bci);
 235 };
 236 
 237 // Replaces the following well-known class names:
 238 //   java.lang.Object -&gt; Object
 239 //   java.lang.String -&gt; String
 240 static char *trim_well_known_class_names_from_signature(char *signature) {
 241   size_t len = strlen(signature);
 242   size_t skip_len = strlen(&quot;java.lang.&quot;);
 243   size_t min_pattern_len = strlen(&quot;java.lang.String&quot;);
 244   if (len &lt; min_pattern_len) return signature;
 245 
 246   for (size_t isrc = 0, idst = 0; isrc &lt;= len; isrc++, idst++) {
 247     // We must be careful not to trim names like test.java.lang.String.
 248     if ((isrc == 0 &amp;&amp; strncmp(signature + isrc, &quot;java.lang.Object&quot;, min_pattern_len) == 0) ||
 249         (isrc == 0 &amp;&amp; strncmp(signature + isrc, &quot;java.lang.String&quot;, min_pattern_len) == 0) ||
 250         (isrc &gt; 1  &amp;&amp; strncmp(signature + isrc-2, &quot;, java.lang.Object&quot;, min_pattern_len+2) == 0) ||
 251         (isrc &gt; 1  &amp;&amp; strncmp(signature + isrc-2, &quot;, java.lang.String&quot;, min_pattern_len+2) == 0)   ) {
 252       isrc += skip_len;
 253     }
 254     if (idst != isrc) {
 255       signature[idst] = signature[isrc];
 256     }
 257   }
 258   return signature;
 259 }
 260 
 261 // Replaces the following well-known class names:
 262 //   java.lang.Object -&gt; Object
 263 //   java.lang.String -&gt; String
 264 static void print_klass_name(outputStream *os, Symbol *klass) {
 265   const char *name = klass-&gt;as_klass_external_name();
 266   if (strcmp(name, &quot;java.lang.Object&quot;) == 0) name = &quot;Object&quot;;
 267   if (strcmp(name, &quot;java.lang.String&quot;) == 0) name = &quot;String&quot;;
 268   os-&gt;print(&quot;%s&quot;, name);
 269 }
 270 
 271 // Prints the name of the method that is described at constant pool
 272 // index cp_index in the constant pool of method &#39;method&#39;.
 273 static void print_method_name(outputStream *os, Method* method, int cp_index) {
 274   ResourceMark rm;
 275   ConstantPool* cp  = method-&gt;constants();
 276   Symbol* klass     = cp-&gt;klass_ref_at_noresolve(cp_index);
 277   Symbol* name      = cp-&gt;name_ref_at(cp_index);
 278   Symbol* signature = cp-&gt;signature_ref_at(cp_index);
 279 
 280   print_klass_name(os, klass);
 281   os-&gt;print(&quot;.%s(&quot;, name-&gt;as_C_string());
 282   stringStream sig;
 283   signature-&gt;print_as_signature_external_parameters(&amp;sig);
 284   os-&gt;print(&quot;%s)&quot;, trim_well_known_class_names_from_signature(sig.as_string()));
 285 }
 286 
 287 // Prints the name of the field that is described at constant pool
 288 // index cp_index in the constant pool of method &#39;method&#39;.
 289 static void print_field_and_class(outputStream *os, Method* method, int cp_index) {
 290   ResourceMark rm;
 291   ConstantPool* cp = method-&gt;constants();
 292   Symbol* klass    = cp-&gt;klass_ref_at_noresolve(cp_index);
 293   Symbol *name     = cp-&gt;name_ref_at(cp_index);
 294   print_klass_name(os, klass);
 295   os-&gt;print(&quot;.%s&quot;, name-&gt;as_C_string());
 296 }
 297 
 298 // Returns the name of the field that is described at constant pool
 299 // index cp_index in the constant pool of method &#39;method&#39;.
 300 static char const* get_field_name(Method* method, int cp_index) {
 301   Symbol* name = method-&gt;constants()-&gt;name_ref_at(cp_index);
 302   return name-&gt;as_C_string();
 303 }
 304 
 305 static void print_local_var(outputStream *os, unsigned int bci, Method* method, int slot, bool is_parameter) {
 306   if (method-&gt;has_localvariable_table()) {
 307     for (int i = 0; i &lt; method-&gt;localvariable_table_length(); i++) {
 308       LocalVariableTableElement* elem = method-&gt;localvariable_table_start() + i;
 309       unsigned int start = elem-&gt;start_bci;
 310       unsigned int end = start + elem-&gt;length;
 311 
 312       if ((bci &gt;= start) &amp;&amp; (bci &lt; end) &amp;&amp; (elem-&gt;slot == slot)) {
 313         ConstantPool* cp = method-&gt;constants();
 314         char *var =  cp-&gt;symbol_at(elem-&gt;name_cp_index)-&gt;as_C_string();
 315         os-&gt;print(&quot;%s&quot;, var);
 316 
 317         return;
 318       }
 319     }
 320   }
 321 
 322   // Handle at least some cases we know.
 323   if (!method-&gt;is_static() &amp;&amp; (slot == 0) &amp;&amp; is_parameter) {
 324     os-&gt;print(&quot;this&quot;);
 325   } else {
 326     int curr = method-&gt;is_static() ? 0 : 1;
 327     SignatureStream ss(method-&gt;signature());
 328     int param_index = 1;
 329     bool found = false;
 330 
 331     for (SignatureStream ss(method-&gt;signature()); !ss.is_done(); ss.next()) {
 332       if (ss.at_return_type()) {
 333         continue;
 334       }
 335       int size = type2size[ss.type()];
 336       if ((slot &gt;= curr) &amp;&amp; (slot &lt; curr + size)) {
 337         found = true;
 338         break;
 339       }
 340       param_index += 1;
 341       curr += size;
 342     }
 343 
 344     if (found &amp;&amp; is_parameter) {
 345       os-&gt;print(&quot;&lt;parameter%d&gt;&quot;, param_index);
 346     } else {
 347       // This is the best we can do.
 348       os-&gt;print(&quot;&lt;local%d&gt;&quot;, slot);
 349     }
 350   }
 351 }
 352 
 353 StackSlotAnalysisData::StackSlotAnalysisData(BasicType type) : _bci(INVALID), _type(type) {}
 354 
 355 StackSlotAnalysisData::StackSlotAnalysisData(int bci, BasicType type) : _bci(bci), _type(type) {
 356   assert(bci &gt;= 0, &quot;BCI must be &gt;= 0&quot;);
 357   assert(bci &lt; 65536, &quot;BCI must be &lt; 65536&quot;);
 358 }
 359 
 360 unsigned int StackSlotAnalysisData::get_bci() {
 361   return _bci;
 362 }
 363 
 364 BasicType StackSlotAnalysisData::get_type() {
 365   return (BasicType)_type;
 366 }
 367 
 368 StackSlotAnalysisData StackSlotAnalysisData::merge(StackSlotAnalysisData other) {
 369   if (get_type() != other.get_type()) {
 370     if (((get_type() == T_OBJECT) || (get_type() == T_ARRAY)) &amp;&amp;
 371         ((other.get_type() == T_OBJECT) || (other.get_type() == T_ARRAY))) {
 372       if (get_bci() == other.get_bci()) {
 373         return StackSlotAnalysisData(get_bci(), T_OBJECT);
 374       } else {
 375         return StackSlotAnalysisData(T_OBJECT);
 376       }
 377     } else {
 378       return StackSlotAnalysisData(T_CONFLICT);
 379     }
 380   }
 381 
 382   if (get_bci() == other.get_bci()) {
 383     return *this;
 384   } else {
 385     return StackSlotAnalysisData(get_type());
 386   }
 387 }
 388 
 389 SimulatedOperandStack::SimulatedOperandStack(const SimulatedOperandStack &amp;copy) {
 390   for (int i = 0; i &lt; copy.get_size(); i++) {
 391     push_raw(copy._stack.at(i));
 392   }
 393   _written_local_slots = copy._written_local_slots;
 394 }
 395 
 396 void SimulatedOperandStack::push_raw(StackSlotAnalysisData slotData) {
 397   if (slotData.get_type() == T_VOID) {
 398     return;
 399   }
 400 
 401   _stack.push(slotData);
 402 }
 403 
 404 void SimulatedOperandStack::push(StackSlotAnalysisData slotData) {
 405   if (type2size[slotData.get_type()] == 2) {
 406     push_raw(slotData);
 407     push_raw(slotData);
 408   } else {
 409     push_raw(slotData);
 410   }
 411 }
 412 
 413 void SimulatedOperandStack::push(int bci, BasicType type) {
 414   push(StackSlotAnalysisData(bci, type));
 415 }
 416 
 417 void SimulatedOperandStack::pop(int slots) {
 418   for (int i = 0; i &lt; slots; ++i) {
 419     _stack.pop();
 420   }
 421 
 422   assert(get_size() &gt;= 0, &quot;Popped too many slots&quot;);
 423 }
 424 
 425 void SimulatedOperandStack::merge(SimulatedOperandStack const&amp; other) {
 426   assert(get_size() == other.get_size(), &quot;Stacks not of same size&quot;);
 427 
 428   for (int i = get_size() - 1; i &gt;= 0; --i) {
 429     _stack.at_put(i, _stack.at(i).merge(other._stack.at(i)));
 430   }
 431   _written_local_slots = _written_local_slots | other._written_local_slots;
 432 }
 433 
 434 int SimulatedOperandStack::get_size() const {
 435   return _stack.length();
 436 }
 437 
 438 StackSlotAnalysisData SimulatedOperandStack::get_slot_data(int slot) {
 439   assert(slot &gt;= 0, &quot;Slot=%d &lt; 0&quot;, slot);
 440   assert(slot &lt; get_size(), &quot;Slot=%d &gt;= size=%d&quot;, slot, get_size());
 441 
 442   return _stack.at(get_size() - slot - 1);
 443 }
 444 
 445 void SimulatedOperandStack::set_local_slot_written(int i) {
 446   // Local slots &gt; 63 are very unlikely. Consider these
 447   // as written all the time. Saves space and complexity
 448   // for dynamic data size.
 449   if (i &gt; 63) return;
 450   _written_local_slots = _written_local_slots | (1ULL &lt;&lt; i);
 451 }
 452 
 453 bool SimulatedOperandStack::local_slot_was_written(int i) {
 454   if (i &gt; 63) return true;
 455   return (_written_local_slots &amp; (1ULL &lt;&lt; i)) != 0;
 456 }
 457 
 458 ExceptionMessageBuilder::ExceptionMessageBuilder(Method* method, int bci) :
 459                     _method(method), _nr_of_entries(0),
 460                     _added_one(true), _all_processed(false) {
 461 
 462   ConstMethod* const_method = method-&gt;constMethod();
 463   const int len = const_method-&gt;code_size();
 464 
 465   assert(bci &gt;= 0, &quot;BCI too low: %d&quot;, bci);
 466   assert(bci &lt; len, &quot;BCI too large: %d size: %d&quot;, bci, len);
 467 
 468   _stacks = new GrowableArray&lt;SimulatedOperandStack*&gt; (len + 1);
 469 
 470   for (int i = 0; i &lt;= len; ++i) {
 471     _stacks-&gt;push(NULL);
 472   }
 473 
 474   // Initialize stack a bci 0.
 475   _stacks-&gt;at_put(0, new SimulatedOperandStack());
 476 
 477   // And initialize the start of all exception handlers.
 478   if (const_method-&gt;has_exception_handler()) {
 479     ExceptionTableElement *et = const_method-&gt;exception_table_start();
 480     for (int i = 0; i &lt; const_method-&gt;exception_table_length(); ++i) {
 481       u2 index = et[i].handler_pc;
 482 
 483       if (_stacks-&gt;at(index) == NULL) {
 484         _stacks-&gt;at_put(index, new SimulatedOperandStack());
 485         _stacks-&gt;at(index)-&gt;push(index, T_OBJECT);
 486       }
 487     }
 488   }
 489 
 490   // Do this until each bytecode has a stack or we haven&#39;t
 491   // added a new stack in one iteration.
 492   while (!_all_processed &amp;&amp; _added_one) {
 493     _all_processed = true;
 494     _added_one = false;
 495 
 496     for (int i = 0; i &lt; len; ) {
 497       // Analyse bytecode i. Step by size of the analyzed bytecode to next bytecode.
 498       i += do_instruction(i);
 499 
 500       // If we want the data only for a certain bci, we can possibly end early.
 501       if ((bci == i) &amp;&amp; (_stacks-&gt;at(i) != NULL)) {
 502         _all_processed = true;
 503         break;
 504       }
 505 
 506       if (_nr_of_entries &gt; _max_entries) {
 507         return;
 508       }
 509     }
 510   }
 511 }
 512 
 513 ExceptionMessageBuilder::~ExceptionMessageBuilder() {
 514   if (_stacks != NULL) {
 515     for (int i = 0; i &lt; _stacks-&gt;length(); ++i) {
 516       delete _stacks-&gt;at(i);
 517     }
 518   }
 519 }
 520 
 521 void ExceptionMessageBuilder::merge(int bci, SimulatedOperandStack* stack) {
 522   assert(stack != _stacks-&gt;at(bci), &quot;Cannot merge itself&quot;);
 523 
 524   if (_stacks-&gt;at(bci) != NULL) {
 525     stack-&gt;merge(*_stacks-&gt;at(bci));
 526   } else {
 527     // Got a new stack, so count the entries.
 528     _nr_of_entries += stack-&gt;get_size();
 529   }
 530 
 531   // Replace the stack at this bci with a copy of our new merged stack.
 532   delete _stacks-&gt;at(bci);
 533   _stacks-&gt;at_put(bci, new SimulatedOperandStack(*stack));
 534 }
 535 
 536 int ExceptionMessageBuilder::do_instruction(int bci) {
 537   ConstMethod* const_method = _method-&gt;constMethod();
 538   address code_base = _method-&gt;constMethod()-&gt;code_base();
 539 
 540   // We use the java code, since we don&#39;t want to cope with all the fast variants.
 541   int len = Bytecodes::java_length_at(_method, code_base + bci);
 542 
 543   // If we have no stack for this bci, we cannot process the bytecode now.
 544   if (_stacks-&gt;at(bci) == NULL) {
 545     _all_processed = false;
 546     return len;
 547   }
 548 
 549   // Make a local copy of the stack for this bci to work on.
 550   SimulatedOperandStack* stack = new SimulatedOperandStack(*_stacks-&gt;at(bci));
 551 
 552   // dest_bci is != -1 if we branch.
 553   int dest_bci = -1;
 554 
 555   // This is for table and lookup switch.
 556   static const int initial_length = 2;
 557   GrowableArray&lt;int&gt; dests(initial_length);
 558 
 559   bool flow_ended = false;
 560 
 561   // Get the bytecode.
 562   bool is_wide = false;
 563   Bytecodes::Code raw_code = Bytecodes::code_at(_method, code_base + bci);
 564   Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + bci);
 565   int pos = bci + 1;
 566 
 567   if (code == Bytecodes::_wide) {
 568     is_wide = true;
 569     code = Bytecodes::java_code_at(_method, code_base + bci + 1);
 570     pos += 1;
 571   }
 572 
 573   // Now simulate the action of each bytecode.
 574   switch (code) {
 575     case Bytecodes::_nop:
 576     case Bytecodes::_aconst_null:
 577     case Bytecodes::_iconst_m1:
 578     case Bytecodes::_iconst_0:
 579     case Bytecodes::_iconst_1:
 580     case Bytecodes::_iconst_2:
 581     case Bytecodes::_iconst_3:
 582     case Bytecodes::_iconst_4:
 583     case Bytecodes::_iconst_5:
 584     case Bytecodes::_lconst_0:
 585     case Bytecodes::_lconst_1:
 586     case Bytecodes::_fconst_0:
 587     case Bytecodes::_fconst_1:
 588     case Bytecodes::_fconst_2:
 589     case Bytecodes::_dconst_0:
 590     case Bytecodes::_dconst_1:
 591     case Bytecodes::_bipush:
 592     case Bytecodes::_sipush:
 593     case Bytecodes::_iload:
 594     case Bytecodes::_lload:
 595     case Bytecodes::_fload:
 596     case Bytecodes::_dload:
 597     case Bytecodes::_aload:
 598     case Bytecodes::_iload_0:
 599     case Bytecodes::_iload_1:
 600     case Bytecodes::_iload_2:
 601     case Bytecodes::_iload_3:
 602     case Bytecodes::_lload_0:
 603     case Bytecodes::_lload_1:
 604     case Bytecodes::_lload_2:
 605     case Bytecodes::_lload_3:
 606     case Bytecodes::_fload_0:
 607     case Bytecodes::_fload_1:
 608     case Bytecodes::_fload_2:
 609     case Bytecodes::_fload_3:
 610     case Bytecodes::_dload_0:
 611     case Bytecodes::_dload_1:
 612     case Bytecodes::_dload_2:
 613     case Bytecodes::_dload_3:
 614     case Bytecodes::_aload_0:
 615     case Bytecodes::_aload_1:
 616     case Bytecodes::_aload_2:
 617     case Bytecodes::_aload_3:
 618     case Bytecodes::_iinc:
 619     case Bytecodes::_new:
 620       stack-&gt;push(bci, Bytecodes::result_type(code));
 621       break;
 622 
 623     case Bytecodes::_ldc:
 624     case Bytecodes::_ldc_w:
 625     case Bytecodes::_ldc2_w: {
 626       int cp_index;
 627       ConstantPool* cp = _method-&gt;constants();
 628 
 629       if (code == Bytecodes::_ldc) {
 630         cp_index = *(uint8_t*) (code_base + pos);
 631 
 632         if (raw_code == Bytecodes::_fast_aldc) {
 633           cp_index = cp-&gt;object_to_cp_index(cp_index);
 634         }
 635       } else {
 636         if (raw_code == Bytecodes::_fast_aldc_w) {
 637           cp_index = Bytes::get_native_u2(code_base + pos);
 638           cp_index = cp-&gt;object_to_cp_index(cp_index);
 639         }
 640         else {
 641           cp_index = Bytes::get_Java_u2(code_base + pos);
 642         }
 643       }
 644 
 645       constantTag tag = cp-&gt;tag_at(cp_index);
 646       if (tag.is_klass()  || tag.is_unresolved_klass() ||
 647           tag.is_method() || tag.is_interface_method() ||
 648           tag.is_field()  || tag.is_string()) {
 649         stack-&gt;push(bci, T_OBJECT);
 650       } else if (tag.is_int()) {
 651         stack-&gt;push(bci, T_INT);
 652       } else if (tag.is_long()) {
 653         stack-&gt;push(bci, T_LONG);
 654       } else if (tag.is_float()) {
 655         stack-&gt;push(bci, T_FLOAT);
 656       } else if (tag.is_double()) {
 657         stack-&gt;push(bci, T_DOUBLE);
 658       } else {
 659         assert(false, &quot;Unexpected tag&quot;);
 660       }
 661       break;
 662     }
 663 
 664     case Bytecodes::_iaload:
 665     case Bytecodes::_faload:
 666     case Bytecodes::_aaload:
 667     case Bytecodes::_baload:
 668     case Bytecodes::_caload:
 669     case Bytecodes::_saload:
 670     case Bytecodes::_laload:
 671     case Bytecodes::_daload:
 672       stack-&gt;pop(2);
 673       stack-&gt;push(bci, Bytecodes::result_type(code));
 674       break;
 675 
 676     case Bytecodes::_istore:
 677     case Bytecodes::_lstore:
 678     case Bytecodes::_fstore:
 679     case Bytecodes::_dstore:
 680     case Bytecodes::_astore:
 681       int index;
 682       if (is_wide) {
 683         index = Bytes::get_Java_u2(code_base + bci + 2);
 684       } else {
 685         index = *(uint8_t*) (code_base + bci + 1);
 686       }
 687       stack-&gt;set_local_slot_written(index);
 688       stack-&gt;pop(-Bytecodes::depth(code));
 689       break;
 690     case Bytecodes::_istore_0:
 691     case Bytecodes::_lstore_0:
 692     case Bytecodes::_fstore_0:
 693     case Bytecodes::_dstore_0:
 694     case Bytecodes::_astore_0:
 695       stack-&gt;set_local_slot_written(0);
 696       stack-&gt;pop(-Bytecodes::depth(code));
 697       break;
 698     case Bytecodes::_istore_1:
 699     case Bytecodes::_fstore_1:
 700     case Bytecodes::_lstore_1:
 701     case Bytecodes::_dstore_1:
 702     case Bytecodes::_astore_1:
 703       stack-&gt;set_local_slot_written(1);
 704       stack-&gt;pop(-Bytecodes::depth(code));
 705       break;
 706     case Bytecodes::_istore_2:
 707     case Bytecodes::_lstore_2:
 708     case Bytecodes::_fstore_2:
 709     case Bytecodes::_dstore_2:
 710     case Bytecodes::_astore_2:
 711       stack-&gt;set_local_slot_written(2);
 712       stack-&gt;pop(-Bytecodes::depth(code));
 713       break;
 714     case Bytecodes::_istore_3:
 715     case Bytecodes::_lstore_3:
 716     case Bytecodes::_fstore_3:
 717     case Bytecodes::_dstore_3:
 718     case Bytecodes::_astore_3:
 719       stack-&gt;set_local_slot_written(3);
 720       stack-&gt;pop(-Bytecodes::depth(code));
 721       break;
 722     case Bytecodes::_iastore:
 723     case Bytecodes::_lastore:
 724     case Bytecodes::_fastore:
 725     case Bytecodes::_dastore:
 726     case Bytecodes::_aastore:
 727     case Bytecodes::_bastore:
 728     case Bytecodes::_castore:
 729     case Bytecodes::_sastore:
 730     case Bytecodes::_pop:
 731     case Bytecodes::_pop2:
 732     case Bytecodes::_monitorenter:
 733     case Bytecodes::_monitorexit:
 734     case Bytecodes::_breakpoint:
 735       stack-&gt;pop(-Bytecodes::depth(code));
 736       break;
 737 
 738     case Bytecodes::_dup:
 739       stack-&gt;push_raw(stack-&gt;get_slot_data(0));
 740       break;
 741 
 742     case Bytecodes::_dup_x1: {
 743       StackSlotAnalysisData top1 = stack-&gt;get_slot_data(0);
 744       StackSlotAnalysisData top2 = stack-&gt;get_slot_data(1);
 745       stack-&gt;pop(2);
 746       stack-&gt;push_raw(top1);
 747       stack-&gt;push_raw(top2);
 748       stack-&gt;push_raw(top1);
 749       break;
 750     }
 751 
 752     case Bytecodes::_dup_x2: {
 753       StackSlotAnalysisData top1 = stack-&gt;get_slot_data(0);
 754       StackSlotAnalysisData top2 = stack-&gt;get_slot_data(1);
 755       StackSlotAnalysisData top3 = stack-&gt;get_slot_data(2);
 756       stack-&gt;pop(3);
 757       stack-&gt;push_raw(top1);
 758       stack-&gt;push_raw(top3);
 759       stack-&gt;push_raw(top2);
 760       stack-&gt;push_raw(top1);
 761       break;
 762     }
 763 
 764     case Bytecodes::_dup2:
 765       stack-&gt;push_raw(stack-&gt;get_slot_data(1));
 766       // The former &#39;0&#39; entry is now at &#39;1&#39;.
 767       stack-&gt;push_raw(stack-&gt;get_slot_data(1));
 768       break;
 769 
 770     case Bytecodes::_dup2_x1: {
 771       StackSlotAnalysisData top1 = stack-&gt;get_slot_data(0);
 772       StackSlotAnalysisData top2 = stack-&gt;get_slot_data(1);
 773       StackSlotAnalysisData top3 = stack-&gt;get_slot_data(2);
 774       stack-&gt;pop(3);
 775       stack-&gt;push_raw(top2);
 776       stack-&gt;push_raw(top1);
 777       stack-&gt;push_raw(top3);
 778       stack-&gt;push_raw(top2);
 779       stack-&gt;push_raw(top1);
 780       break;
 781     }
 782 
 783     case Bytecodes::_dup2_x2: {
 784       StackSlotAnalysisData top1 = stack-&gt;get_slot_data(0);
 785       StackSlotAnalysisData top2 = stack-&gt;get_slot_data(1);
 786       StackSlotAnalysisData top3 = stack-&gt;get_slot_data(2);
 787       StackSlotAnalysisData top4 = stack-&gt;get_slot_data(3);
 788       stack-&gt;pop(4);
 789       stack-&gt;push_raw(top2);
 790       stack-&gt;push_raw(top1);
 791       stack-&gt;push_raw(top4);
 792       stack-&gt;push_raw(top3);
 793       stack-&gt;push_raw(top2);
 794       stack-&gt;push_raw(top1);
 795       break;
 796     }
 797 
 798     case Bytecodes::_swap: {
 799       StackSlotAnalysisData top1 = stack-&gt;get_slot_data(0);
 800       StackSlotAnalysisData top2 = stack-&gt;get_slot_data(1);
 801       stack-&gt;pop(2);
 802       stack-&gt;push(top1);
 803       stack-&gt;push(top2);
 804       break;
 805     }
 806 
 807     case Bytecodes::_iadd:
 808     case Bytecodes::_ladd:
 809     case Bytecodes::_fadd:
 810     case Bytecodes::_dadd:
 811     case Bytecodes::_isub:
 812     case Bytecodes::_lsub:
 813     case Bytecodes::_fsub:
 814     case Bytecodes::_dsub:
 815     case Bytecodes::_imul:
 816     case Bytecodes::_lmul:
 817     case Bytecodes::_fmul:
 818     case Bytecodes::_dmul:
 819     case Bytecodes::_idiv:
 820     case Bytecodes::_ldiv:
 821     case Bytecodes::_fdiv:
 822     case Bytecodes::_ddiv:
 823     case Bytecodes::_irem:
 824     case Bytecodes::_lrem:
 825     case Bytecodes::_frem:
 826     case Bytecodes::_drem:
 827     case Bytecodes::_iand:
 828     case Bytecodes::_land:
 829     case Bytecodes::_ior:
 830     case Bytecodes::_lor:
 831     case Bytecodes::_ixor:
 832     case Bytecodes::_lxor:
 833       stack-&gt;pop(2 * type2size[Bytecodes::result_type(code)]);
 834       stack-&gt;push(bci, Bytecodes::result_type(code));
 835       break;
 836 
 837     case Bytecodes::_ineg:
 838     case Bytecodes::_lneg:
 839     case Bytecodes::_fneg:
 840     case Bytecodes::_dneg:
 841       stack-&gt;pop(type2size[Bytecodes::result_type(code)]);
 842       stack-&gt;push(bci, Bytecodes::result_type(code));
 843       break;
 844 
 845     case Bytecodes::_ishl:
 846     case Bytecodes::_lshl:
 847     case Bytecodes::_ishr:
 848     case Bytecodes::_lshr:
 849     case Bytecodes::_iushr:
 850     case Bytecodes::_lushr:
 851       stack-&gt;pop(1 + type2size[Bytecodes::result_type(code)]);
 852       stack-&gt;push(bci, Bytecodes::result_type(code));
 853       break;
 854 
 855     case Bytecodes::_i2l:
 856     case Bytecodes::_i2f:
 857     case Bytecodes::_i2d:
 858     case Bytecodes::_f2i:
 859     case Bytecodes::_f2l:
 860     case Bytecodes::_f2d:
 861     case Bytecodes::_i2b:
 862     case Bytecodes::_i2c:
 863     case Bytecodes::_i2s:
 864       stack-&gt;pop(1);
 865       stack-&gt;push(bci, Bytecodes::result_type(code));
 866       break;
 867 
 868     case Bytecodes::_l2i:
 869     case Bytecodes::_l2f:
 870     case Bytecodes::_l2d:
 871     case Bytecodes::_d2i:
 872     case Bytecodes::_d2l:
 873     case Bytecodes::_d2f:
 874       stack-&gt;pop(2);
 875       stack-&gt;push(bci, Bytecodes::result_type(code));
 876       break;
 877 
 878     case Bytecodes::_lcmp:
 879     case Bytecodes::_fcmpl:
 880     case Bytecodes::_fcmpg:
 881     case Bytecodes::_dcmpl:
 882     case Bytecodes::_dcmpg:
 883       stack-&gt;pop(1 - Bytecodes::depth(code));
 884       stack-&gt;push(bci, T_INT);
 885       break;
 886 
 887     case Bytecodes::_ifeq:
 888     case Bytecodes::_ifne:
 889     case Bytecodes::_iflt:
 890     case Bytecodes::_ifge:
 891     case Bytecodes::_ifgt:
 892     case Bytecodes::_ifle:
 893     case Bytecodes::_if_icmpeq:
 894     case Bytecodes::_if_icmpne:
 895     case Bytecodes::_if_icmplt:
 896     case Bytecodes::_if_icmpge:
 897     case Bytecodes::_if_icmpgt:
 898     case Bytecodes::_if_icmple:
 899     case Bytecodes::_if_acmpeq:
 900     case Bytecodes::_if_acmpne:
 901     case Bytecodes::_ifnull:
 902     case Bytecodes::_ifnonnull:
 903       stack-&gt;pop(-Bytecodes::depth(code));
 904       dest_bci = bci + (int16_t) Bytes::get_Java_u2(code_base + pos);
 905       break;
 906 
 907     case Bytecodes::_jsr:
 908       // NOTE: Bytecodes has wrong depth for jsr.
 909       stack-&gt;push(bci, T_ADDRESS);
 910       dest_bci = bci + (int16_t) Bytes::get_Java_u2(code_base + pos);
 911       flow_ended = true;
 912       break;
 913 
 914     case Bytecodes::_jsr_w: {
 915       // NOTE: Bytecodes has wrong depth for jsr.
 916       stack-&gt;push(bci, T_ADDRESS);
 917       dest_bci = bci + (int32_t) Bytes::get_Java_u4(code_base + pos);
 918       flow_ended = true;
 919       break;
 920     }
 921 
 922     case Bytecodes::_ret:
 923       // We don&#39;t track local variables, so we cannot know were we
 924       // return. This makes the stacks imprecise, but we have to
 925       // live with that.
 926       flow_ended = true;
 927       break;
 928 
 929     case Bytecodes::_tableswitch: {
 930       stack-&gt;pop(1);
 931       pos = (pos + 3) &amp; ~3;
 932       dest_bci = bci + (int32_t) Bytes::get_Java_u4(code_base + pos);
 933       int low = (int32_t) Bytes::get_Java_u4(code_base + pos + 4);
 934       int high = (int32_t) Bytes::get_Java_u4(code_base + pos + 8);
 935 
 936       for (int64_t i = low; i &lt;= high; ++i) {
 937         dests.push(bci + (int32_t) Bytes::get_Java_u4(code_base + pos + 12 + 4 * (i - low)));
 938       }
 939 
 940       break;
 941     }
 942 
 943     case Bytecodes::_lookupswitch: {
 944       stack-&gt;pop(1);
 945       pos = (pos + 3) &amp; ~3;
 946       dest_bci = bci + (int32_t) Bytes::get_Java_u4(code_base + pos);
 947       int nr_of_dests = (int32_t) Bytes::get_Java_u4(code_base + pos + 4);
 948 
 949       for (int i = 0; i &lt; nr_of_dests; ++i) {
 950         dests.push(bci + (int32_t) Bytes::get_Java_u4(code_base + pos + 12 + 8 * i));
 951       }
 952 
 953       break;
 954     }
 955 
 956     case Bytecodes::_ireturn:
 957     case Bytecodes::_lreturn:
 958     case Bytecodes::_freturn:
 959     case Bytecodes::_dreturn:
 960     case Bytecodes::_areturn:
 961     case Bytecodes::_return:
 962     case Bytecodes::_athrow:
 963       stack-&gt;pop(-Bytecodes::depth(code));
 964       flow_ended = true;
 965       break;
 966 
 967     case Bytecodes::_getstatic:
 968     case Bytecodes::_getfield: {
 969       // Find out the type of the field accessed.
 970       int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
 971       ConstantPool* cp = _method-&gt;constants();
 972       int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
 973       int type_index = cp-&gt;signature_ref_index_at(name_and_type_index);
 974       Symbol* signature = cp-&gt;symbol_at(type_index);
 975       // Simulate the bytecode: pop the address, push the &#39;value&#39; loaded
 976       // from the field.
 977       stack-&gt;pop(1 - Bytecodes::depth(code));
 978       stack-&gt;push(bci, Signature::basic_type(signature));
 979       break;
 980     }
 981 
 982     case Bytecodes::_putstatic:
 983     case Bytecodes::_putfield: {
 984       int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
 985       ConstantPool* cp = _method-&gt;constants();
 986       int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
 987       int type_index = cp-&gt;signature_ref_index_at(name_and_type_index);
 988       Symbol* signature = cp-&gt;symbol_at(type_index);
 989       BasicType bt = Signature::basic_type(signature);
 990       stack-&gt;pop(type2size[bt] - Bytecodes::depth(code) - 1);
 991       break;
 992     }
 993 
 994     case Bytecodes::_invokevirtual:
 995     case Bytecodes::_invokespecial:
 996     case Bytecodes::_invokestatic:
 997     case Bytecodes::_invokeinterface:
 998     case Bytecodes::_invokedynamic: {
 999       ConstantPool* cp = _method-&gt;constants();
1000       int cp_index;
1001 
1002       if (code == Bytecodes::_invokedynamic) {
1003         cp_index = ((int) Bytes::get_native_u4(code_base + pos));
1004       } else {
1005         cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1006       }
1007 
1008       int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
1009       int type_index = cp-&gt;signature_ref_index_at(name_and_type_index);
1010       Symbol* signature = cp-&gt;symbol_at(type_index);
1011 
1012       if ((code != Bytecodes::_invokestatic) &amp;&amp; (code != Bytecodes::_invokedynamic)) {
1013         // Pop receiver.
1014         stack-&gt;pop(1);
1015       }
1016 
1017       stack-&gt;pop(ArgumentSizeComputer(signature).size());
1018       ResultTypeFinder result_type(signature);
1019       stack-&gt;push(bci, result_type.type());
1020       break;
1021     }
1022 
1023     case Bytecodes::_newarray:
1024     case Bytecodes::_anewarray:
1025     case Bytecodes::_instanceof:
1026       stack-&gt;pop(1);
1027       stack-&gt;push(bci, Bytecodes::result_type(code));
1028       break;
1029 
1030     case Bytecodes::_arraylength:
1031       // The return type of arraylength is wrong in the bytecodes table (T_VOID).
1032       stack-&gt;pop(1);
1033       stack-&gt;push(bci, T_INT);
1034       break;
1035 
1036     case Bytecodes::_checkcast:
1037       break;
1038 
1039     case Bytecodes::_multianewarray:
1040       stack-&gt;pop(*(uint8_t*) (code_base + pos + 2));
1041       stack-&gt;push(bci, T_OBJECT);
1042       break;
1043 
1044    case Bytecodes::_goto:
1045       stack-&gt;pop(-Bytecodes::depth(code));
1046       dest_bci = bci + (int16_t) Bytes::get_Java_u2(code_base + pos);
1047       flow_ended = true;
1048       break;
1049 
1050 
1051    case Bytecodes::_goto_w:
1052       stack-&gt;pop(-Bytecodes::depth(code));
1053       dest_bci = bci + (int32_t) Bytes::get_Java_u4(code_base + pos);
1054       flow_ended = true;
1055       break;
1056 
1057     default:
1058       // Allow at least the bcis which have stack info to work.
1059       _all_processed = false;
1060       _added_one = false;
1061       delete stack;
1062 
1063       return len;
1064   }
1065 
1066   // Put new stack to the next instruction, if we might reach it from
1067   // this bci.
1068   if (!flow_ended) {
1069     if (_stacks-&gt;at(bci + len) == NULL) {
1070       _added_one = true;
1071     }
1072     merge(bci + len, stack);
1073   }
1074 
1075   // Put the stack to the branch target too.
1076   if (dest_bci != -1) {
1077     if (_stacks-&gt;at(dest_bci) == NULL) {
1078       _added_one = true;
1079     }
1080     merge(dest_bci, stack);
1081   }
1082 
1083   // If we have more than one branch target, process these too.
1084   for (int64_t i = 0; i &lt; dests.length(); ++i) {
1085     if (_stacks-&gt;at(dests.at(i)) == NULL) {
1086       _added_one = true;
1087     }
1088     merge(dests.at(i), stack);
1089   }
1090 
1091   delete stack;
1092 
1093   return len;
1094 }
1095 
1096 #define INVALID_BYTECODE_ENCOUNTERED -1
1097 #define NPE_EXPLICIT_CONSTRUCTED -2
1098 int ExceptionMessageBuilder::get_NPE_null_slot(int bci) {
1099   // Get the bytecode.
1100   address code_base = _method-&gt;constMethod()-&gt;code_base();
1101   Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + bci);
1102   int pos = bci + 1;  // Position of argument of the bytecode.
1103   if (code == Bytecodes::_wide) {
1104     code = Bytecodes::java_code_at(_method, code_base + bci + 1);
1105     pos += 1;
1106   }
1107 
1108   switch (code) {
1109     case Bytecodes::_getfield:
1110     case Bytecodes::_arraylength:
1111     case Bytecodes::_athrow:
1112     case Bytecodes::_monitorenter:
1113     case Bytecodes::_monitorexit:
1114       return 0;
1115     case Bytecodes::_iaload:
1116     case Bytecodes::_faload:
1117     case Bytecodes::_aaload:
1118     case Bytecodes::_baload:
1119     case Bytecodes::_caload:
1120     case Bytecodes::_saload:
1121     case Bytecodes::_laload:
1122     case Bytecodes::_daload:
1123       return 1;
1124     case Bytecodes::_iastore:
1125     case Bytecodes::_fastore:
1126     case Bytecodes::_aastore:
1127     case Bytecodes::_bastore:
1128     case Bytecodes::_castore:
1129     case Bytecodes::_sastore:
1130       return 2;
1131     case Bytecodes::_lastore:
1132     case Bytecodes::_dastore:
1133       return 3;
1134     case Bytecodes::_putfield: {
1135         int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1136         ConstantPool* cp = _method-&gt;constants();
1137         int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
1138         int type_index = cp-&gt;signature_ref_index_at(name_and_type_index);
1139         Symbol* signature = cp-&gt;symbol_at(type_index);
1140         BasicType bt = Signature::basic_type(signature);
1141         return type2size[bt];
1142       }
1143     case Bytecodes::_invokevirtual:
1144     case Bytecodes::_invokespecial:
1145     case Bytecodes::_invokeinterface: {
1146         int cp_index = Bytes::get_native_u2(code_base+ pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1147         ConstantPool* cp = _method-&gt;constants();
1148         int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
1149         int name_index = cp-&gt;name_ref_index_at(name_and_type_index);
1150         Symbol* name = cp-&gt;symbol_at(name_index);
1151 
1152         // Assume the the call of a constructor can never cause a NullPointerException
1153         // (which is true in Java). This is mainly used to avoid generating wrong
1154         // messages for NullPointerExceptions created explicitly by new in Java code.
1155         if (name != vmSymbols::object_initializer_name()) {
1156           int     type_index = cp-&gt;signature_ref_index_at(name_and_type_index);
1157           Symbol* signature  = cp-&gt;symbol_at(type_index);
1158           // The &#39;this&#39; parameter was null. Return the slot of it.
1159           return ArgumentSizeComputer(signature).size();
1160         } else {
1161           return NPE_EXPLICIT_CONSTRUCTED;
1162         }
1163       }
1164 
1165     default:
1166       break;
1167   }
1168 
1169   return INVALID_BYTECODE_ENCOUNTERED;
1170 }
1171 
1172 bool ExceptionMessageBuilder::print_NPE_cause(outputStream* os, int bci, int slot) {
1173   if (print_NPE_cause0(os, bci, slot, _max_cause_detail, false, &quot; because \&quot;&quot;)) {
1174     os-&gt;print(&quot;\&quot; is null&quot;);
1175     return true;
1176   }
1177   return false;
1178 }
1179 
1180 // Recursively print what was null.
1181 //
1182 // Go to the bytecode that pushed slot &#39;slot&#39; on the operand stack
1183 // at bytecode &#39;bci&#39;. Compute a message for that bytecode. If
1184 // necessary (array, field), recur further.
1185 // At most do max_detail recursions.
1186 // Prefix is used to print a proper beginning of the whole
1187 // sentence.
1188 // inner_expr is used to omit some text, like &#39;static&#39; in
1189 // inner expressions like array subscripts.
1190 //
1191 // Returns true if something was printed.
1192 //
1193 bool ExceptionMessageBuilder::print_NPE_cause0(outputStream* os, int bci, int slot,
1194                                                int max_detail,
1195                                                bool inner_expr, const char *prefix) {
1196   assert(bci &gt;= 0, &quot;BCI too low&quot;);
1197   assert(bci &lt; get_size(), &quot;BCI too large&quot;);
1198 
1199   if (max_detail &lt;= 0) {
1200     return false;
1201   }
1202 
1203   if (_stacks-&gt;at(bci) == NULL) {
1204     return false;
1205   }
1206 
1207   SimulatedOperandStack* stack = _stacks-&gt;at(bci);
1208   assert(slot &gt;= 0, &quot;Slot nr. too low&quot;);
1209   assert(slot &lt; stack-&gt;get_size(), &quot;Slot nr. too large&quot;);
1210 
1211   StackSlotAnalysisData slotData = stack-&gt;get_slot_data(slot);
1212 
1213   if (!slotData.has_bci()) {
1214     return false;
1215   }
1216 
1217   // Get the bytecode.
1218   unsigned int source_bci = slotData.get_bci();
1219   address code_base = _method-&gt;constMethod()-&gt;code_base();
1220   Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + source_bci);
1221   bool is_wide = false;
1222   int pos = source_bci + 1;
1223 
1224   if (code == Bytecodes::_wide) {
1225     is_wide = true;
1226     code = Bytecodes::java_code_at(_method, code_base + source_bci + 1);
1227     pos += 1;
1228   }
1229 
1230   if (max_detail == _max_cause_detail &amp;&amp;
1231       prefix != NULL &amp;&amp;
1232       code != Bytecodes::_invokevirtual &amp;&amp;
1233       code != Bytecodes::_invokespecial &amp;&amp;
1234       code != Bytecodes::_invokestatic &amp;&amp;
1235       code != Bytecodes::_invokeinterface) {
1236     os-&gt;print(&quot;%s&quot;, prefix);
1237   }
1238 
1239   switch (code) {
1240     case Bytecodes::_iload_0:
1241     case Bytecodes::_aload_0:
1242       print_local_var(os, source_bci, _method, 0, !stack-&gt;local_slot_was_written(0));
1243       return true;
1244 
1245     case Bytecodes::_iload_1:
1246     case Bytecodes::_aload_1:
1247       print_local_var(os, source_bci, _method, 1, !stack-&gt;local_slot_was_written(1));
1248       return true;
1249 
1250     case Bytecodes::_iload_2:
1251     case Bytecodes::_aload_2:
1252       print_local_var(os, source_bci, _method, 2, !stack-&gt;local_slot_was_written(2));
1253       return true;
1254 
1255     case Bytecodes::_iload_3:
1256     case Bytecodes::_aload_3:
1257       print_local_var(os, source_bci, _method, 3, !stack-&gt;local_slot_was_written(3));
1258       return true;
1259 
1260     case Bytecodes::_iload:
1261     case Bytecodes::_aload: {
1262       int index;
1263       if (is_wide) {
1264         index = Bytes::get_Java_u2(code_base + source_bci + 2);
1265       } else {
1266         index = *(uint8_t*) (code_base + source_bci + 1);
1267       }
1268       print_local_var(os, source_bci, _method, index, !stack-&gt;local_slot_was_written(index));
1269       return true;
1270     }
1271 
1272     case Bytecodes::_aconst_null:
1273       os-&gt;print(&quot;null&quot;);
1274       return true;
1275     case Bytecodes::_iconst_m1:
1276       os-&gt;print(&quot;-1&quot;);
1277       return true;
1278     case Bytecodes::_iconst_0:
1279       os-&gt;print(&quot;0&quot;);
1280       return true;
1281     case Bytecodes::_iconst_1:
1282       os-&gt;print(&quot;1&quot;);
1283       return true;
1284     case Bytecodes::_iconst_2:
1285       os-&gt;print(&quot;2&quot;);
1286       return true;
1287     case Bytecodes::_iconst_3:
1288       os-&gt;print(&quot;3&quot;);
1289       return true;
1290     case Bytecodes::_iconst_4:
1291       os-&gt;print(&quot;4&quot;);
1292       return true;
1293     case Bytecodes::_iconst_5:
1294       os-&gt;print(&quot;5&quot;);
1295       return true;
1296     case Bytecodes::_bipush: {
1297       jbyte con = *(jbyte*) (code_base + source_bci + 1);
1298       os-&gt;print(&quot;%d&quot;, con);
1299       return true;
1300     }
1301     case Bytecodes::_sipush: {
1302       u2 con = Bytes::get_Java_u2(code_base + source_bci + 1);
1303       os-&gt;print(&quot;%d&quot;, con);
1304       return true;
1305     }
1306    case Bytecodes::_iaload:
1307    case Bytecodes::_aaload: {
1308       // Print the &#39;name&#39; of the array. Go back to the bytecode that
1309       // pushed the array reference on the operand stack.
1310      if (!print_NPE_cause0(os, source_bci, 1, max_detail - 1, inner_expr)) {
1311         //  Returned false. Max recursion depth was reached. Print dummy.
1312         os-&gt;print(&quot;&lt;array&gt;&quot;);
1313       }
1314       os-&gt;print(&quot;[&quot;);
1315       // Print the index expression. Go back to the bytecode that
1316       // pushed the index on the operand stack.
1317       // inner_expr == true so we don&#39;t print unwanted strings
1318       // as &quot;The return value of&#39;&quot;. And don&#39;t decrement max_detail so we always
1319       // get a value here and only cancel out on the dereference.
1320       if (!print_NPE_cause0(os, source_bci, 0, max_detail, true)) {
1321         // Returned false. We don&#39;t print complex array index expressions. Print placeholder.
1322         os-&gt;print(&quot;...&quot;);
1323       }
1324       os-&gt;print(&quot;]&quot;);
1325       return true;
1326     }
1327 
1328     case Bytecodes::_getstatic: {
1329       int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;
1330       print_field_and_class(os, _method, cp_index);
1331       return true;
1332     }
1333 
1334     case Bytecodes::_getfield: {
1335       // Print the sender. Go back to the bytecode that
1336       // pushed the sender on the operand stack.
1337       if (print_NPE_cause0(os, source_bci, 0, max_detail - 1, inner_expr)) {
1338         os-&gt;print(&quot;.&quot;);
1339       }
1340       int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;
1341       os-&gt;print(&quot;%s&quot;, get_field_name(_method, cp_index));
1342       return true;
1343     }
1344 
1345     case Bytecodes::_invokevirtual:
1346     case Bytecodes::_invokespecial:
1347     case Bytecodes::_invokestatic:
1348     case Bytecodes::_invokeinterface: {
1349       int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1350       if (max_detail == _max_cause_detail &amp;&amp; !inner_expr) {
1351         os-&gt;print(&quot; because the return value of \&quot;&quot;);
1352       }
1353       print_method_name(os, _method, cp_index);
1354       return true;
1355     }
1356 
1357     default: break;
1358   }
1359   return false;
1360 }
1361 
1362 void ExceptionMessageBuilder::print_NPE_failed_action(outputStream *os, int bci) {
1363 
1364   // Get the bytecode.
1365   address code_base = _method-&gt;constMethod()-&gt;code_base();
1366   Bytecodes::Code code = Bytecodes::java_code_at(_method, code_base + bci);
1367   int pos = bci + 1;
1368   if (code == Bytecodes::_wide) {
1369     code = Bytecodes::java_code_at(_method, code_base + bci + 1);
1370     pos += 1;
1371   }
1372 
1373   switch (code) {
1374     case Bytecodes::_iaload:
1375       os-&gt;print(&quot;Cannot load from int array&quot;); break;
1376     case Bytecodes::_faload:
1377       os-&gt;print(&quot;Cannot load from float array&quot;); break;
1378     case Bytecodes::_aaload:
1379       os-&gt;print(&quot;Cannot load from object array&quot;); break;
1380     case Bytecodes::_baload:
1381       os-&gt;print(&quot;Cannot load from byte/boolean array&quot;); break;
1382     case Bytecodes::_caload:
1383       os-&gt;print(&quot;Cannot load from char array&quot;); break;
1384     case Bytecodes::_saload:
1385       os-&gt;print(&quot;Cannot load from short array&quot;); break;
1386     case Bytecodes::_laload:
1387       os-&gt;print(&quot;Cannot load from long array&quot;); break;
1388     case Bytecodes::_daload:
1389       os-&gt;print(&quot;Cannot load from double array&quot;); break;
1390 
1391     case Bytecodes::_iastore:
1392       os-&gt;print(&quot;Cannot store to int array&quot;); break;
1393     case Bytecodes::_fastore:
1394       os-&gt;print(&quot;Cannot store to float array&quot;); break;
1395     case Bytecodes::_aastore:
1396       os-&gt;print(&quot;Cannot store to object array&quot;); break;
1397     case Bytecodes::_bastore:
1398       os-&gt;print(&quot;Cannot store to byte/boolean array&quot;); break;
1399     case Bytecodes::_castore:
1400       os-&gt;print(&quot;Cannot store to char array&quot;); break;
1401     case Bytecodes::_sastore:
1402       os-&gt;print(&quot;Cannot store to short array&quot;); break;
1403     case Bytecodes::_lastore:
1404       os-&gt;print(&quot;Cannot store to long array&quot;); break;
1405     case Bytecodes::_dastore:
1406       os-&gt;print(&quot;Cannot store to double array&quot;); break;
1407 
1408     case Bytecodes::_arraylength:
1409       os-&gt;print(&quot;Cannot read the array length&quot;); break;
1410     case Bytecodes::_athrow:
1411       os-&gt;print(&quot;Cannot throw exception&quot;); break;
1412     case Bytecodes::_monitorenter:
1413       os-&gt;print(&quot;Cannot enter synchronized block&quot;); break;
1414     case Bytecodes::_monitorexit:
1415       os-&gt;print(&quot;Cannot exit synchronized block&quot;); break;
1416     case Bytecodes::_getfield: {
1417         int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1418         ConstantPool* cp = _method-&gt;constants();
1419         int name_and_type_index = cp-&gt;name_and_type_ref_index_at(cp_index);
1420         int name_index = cp-&gt;name_ref_index_at(name_and_type_index);
1421         Symbol* name = cp-&gt;symbol_at(name_index);
1422         os-&gt;print(&quot;Cannot read field \&quot;%s\&quot;&quot;, name-&gt;as_C_string());
1423       } break;
1424     case Bytecodes::_putfield: {
1425         int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1426         os-&gt;print(&quot;Cannot assign field \&quot;%s\&quot;&quot;, get_field_name(_method, cp_index));
1427       } break;
1428     case Bytecodes::_invokevirtual:
1429     case Bytecodes::_invokespecial:
1430     case Bytecodes::_invokeinterface: {
1431         int cp_index = Bytes::get_native_u2(code_base+ pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);
1432         os-&gt;print(&quot;Cannot invoke \&quot;&quot;);
1433         print_method_name(os, _method, cp_index);
1434         os-&gt;print(&quot;\&quot;&quot;);
1435       } break;
1436 
1437     default:
1438       assert(0, &quot;We should have checked this bytecode in get_NPE_null_slot().&quot;);
1439       break;
1440   }
1441 }
1442 
1443 // Main API
1444 bool BytecodeUtils::get_NPE_message_at(outputStream* ss, Method* method, int bci) {
1445 
1446   NoSafepointVerifier _nsv;   // Cannot use this object over a safepoint.
1447 
1448   // If this NPE was created via reflection, we have no real NPE.
1449   if (method-&gt;method_holder() ==
1450       SystemDictionary::reflect_NativeConstructorAccessorImpl_klass()) {
1451     return false;
1452   }
1453 
1454   // Analyse the bytecodes.
1455   ResourceMark rm;
1456   ExceptionMessageBuilder emb(method, bci);
1457 
1458   // The slot of the operand stack that contains the null reference.
1459   // Also checks for NPE explicitly constructed and returns NPE_EXPLICIT_CONSTRUCTED.
1460   int slot = emb.get_NPE_null_slot(bci);
1461 
1462   // Build the message.
1463   if (slot == NPE_EXPLICIT_CONSTRUCTED) {
1464     // We don&#39;t want to print a message.
1465     return false;
1466   } else if (slot == INVALID_BYTECODE_ENCOUNTERED) {
1467     // We encountered a bytecode that does not dereference a reference.
1468     DEBUG_ONLY(ss-&gt;print(&quot;There cannot be a NullPointerException at bci %d of method %s&quot;,
1469                          bci, method-&gt;external_name()));
1470     NOT_DEBUG(return false);
1471   } else {
1472     // Print string describing which action (bytecode) could not be
1473     // performed because of the null reference.
1474     emb.print_NPE_failed_action(ss, bci);
1475     // Print a description of what is null.
1476     if (!emb.print_NPE_cause(ss, bci, slot)) {
1477       // Nothing was printed. End the sentence without the &#39;because&#39;
1478       // subordinate sentence.
1479     }
1480   }
1481   return true;
1482 }
    </pre>
  </body>
</html>