<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdeps/share/classes/com/sun/tools/javap/JavapTask.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javap;
  27 
  28 import java.io.EOFException;
  29 import java.io.FileNotFoundException;
  30 import java.io.FilterInputStream;
  31 import java.io.InputStream;
  32 import java.io.IOException;
  33 import java.io.OutputStream;
  34 import java.io.PrintWriter;
  35 import java.io.Reader;
  36 import java.io.StringWriter;
  37 import java.io.Writer;
  38 import java.net.URI;
  39 import java.net.URISyntaxException;
  40 import java.net.URL;
  41 import java.net.URLConnection;
  42 import java.nio.file.NoSuchFileException;
  43 import java.security.DigestInputStream;
  44 import java.security.MessageDigest;
  45 import java.security.NoSuchAlgorithmException;
  46 import java.text.MessageFormat;
  47 import java.util.ArrayList;
  48 import java.util.Arrays;
  49 import java.util.EnumSet;
  50 import java.util.HashMap;
  51 import java.util.Iterator;
  52 import java.util.List;
  53 import java.util.Locale;
  54 import java.util.Map;
  55 import java.util.MissingResourceException;
  56 import java.util.Objects;
  57 import java.util.ResourceBundle;
  58 import java.util.Set;
  59 
  60 import javax.lang.model.element.Modifier;
  61 import javax.lang.model.element.NestingKind;
  62 import javax.tools.Diagnostic;
  63 import javax.tools.DiagnosticListener;
  64 import javax.tools.JavaFileManager;
  65 import javax.tools.JavaFileManager.Location;
  66 import javax.tools.JavaFileObject;
  67 import javax.tools.StandardJavaFileManager;
  68 import javax.tools.StandardLocation;
  69 
  70 import com.sun.tools.classfile.*;
  71 
  72 /**
  73  *  &quot;Main&quot; class for javap, normally accessed from the command line
  74  *  via Main, or from JSR199 via DisassemblerTool.
  75  *
  76  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  77  *  If you write code that depends on this, you do so at your own risk.
  78  *  This code and its internal interfaces are subject to change or
  79  *  deletion without notice.&lt;/b&gt;
  80  */
  81 public class JavapTask implements DisassemblerTool.DisassemblerTask, Messages {
  82     public class BadArgs extends Exception {
  83         static final long serialVersionUID = 8765093759964640721L;
  84         BadArgs(String key, Object... args) {
  85             super(JavapTask.this.getMessage(key, args));
  86             this.key = key;
  87             this.args = args;
  88         }
  89 
  90         BadArgs showUsage(boolean b) {
  91             showUsage = b;
  92             return this;
  93         }
  94 
  95         final String key;
  96         final Object[] args;
  97         boolean showUsage;
  98     }
  99 
 100     static abstract class Option {
 101         Option(boolean hasArg, String... aliases) {
 102             this.hasArg = hasArg;
 103             this.aliases = aliases;
 104         }
 105 
 106         boolean matches(String opt) {
 107             for (String a: aliases) {
 108                 if (a.equals(opt))
 109                     return true;
 110             }
 111             return false;
 112         }
 113 
 114         boolean ignoreRest() {
 115             return false;
 116         }
 117 
 118         abstract void process(JavapTask task, String opt, String arg) throws BadArgs;
 119 
 120         final boolean hasArg;
 121         final String[] aliases;
 122     }
 123 
 124     static final Option[] recognizedOptions = {
 125 
 126         new Option(false, &quot;-help&quot;, &quot;--help&quot;, &quot;-?&quot;, &quot;-h&quot;) {
 127             @Override
 128             void process(JavapTask task, String opt, String arg) {
 129                 task.options.help = true;
 130             }
 131         },
 132 
 133         new Option(false, &quot;-version&quot;) {
 134             @Override
 135             void process(JavapTask task, String opt, String arg) {
 136                 task.options.version = true;
 137             }
 138         },
 139 
 140         new Option(false, &quot;-fullversion&quot;) {
 141             @Override
 142             void process(JavapTask task, String opt, String arg) {
 143                 task.options.fullVersion = true;
 144             }
 145         },
 146 
 147         new Option(false, &quot;-v&quot;, &quot;-verbose&quot;, &quot;-all&quot;) {
 148             @Override
 149             void process(JavapTask task, String opt, String arg) {
 150                 task.options.verbose = true;
 151                 task.options.showDescriptors = true;
 152                 task.options.showFlags = true;
 153                 task.options.showAllAttrs = true;
 154             }
 155         },
 156 
 157         new Option(false, &quot;-l&quot;) {
 158             @Override
 159             void process(JavapTask task, String opt, String arg) {
 160                 task.options.showLineAndLocalVariableTables = true;
 161             }
 162         },
 163 
 164         new Option(false, &quot;-public&quot;) {
 165             @Override
 166             void process(JavapTask task, String opt, String arg) {
 167                 task.options.accessOptions.add(opt);
 168                 task.options.showAccess = AccessFlags.ACC_PUBLIC;
 169             }
 170         },
 171 
 172         new Option(false, &quot;-protected&quot;) {
 173             @Override
 174             void process(JavapTask task, String opt, String arg) {
 175                 task.options.accessOptions.add(opt);
 176                 task.options.showAccess = AccessFlags.ACC_PROTECTED;
 177             }
 178         },
 179 
 180         new Option(false, &quot;-package&quot;) {
 181             @Override
 182             void process(JavapTask task, String opt, String arg) {
 183                 task.options.accessOptions.add(opt);
 184                 task.options.showAccess = 0;
 185             }
 186         },
 187 
 188         new Option(false, &quot;-p&quot;, &quot;-private&quot;) {
 189             @Override
 190             void process(JavapTask task, String opt, String arg) {
 191                 if (!task.options.accessOptions.contains(&quot;-p&quot;) &amp;&amp;
 192                         !task.options.accessOptions.contains(&quot;-private&quot;)) {
 193                     task.options.accessOptions.add(opt);
 194                 }
 195                 task.options.showAccess = AccessFlags.ACC_PRIVATE;
 196             }
 197         },
 198 
 199         new Option(false, &quot;-c&quot;) {
 200             @Override
 201             void process(JavapTask task, String opt, String arg) {
 202                 task.options.showDisassembled = true;
 203             }
 204         },
 205 
 206         new Option(false, &quot;-s&quot;) {
 207             @Override
 208             void process(JavapTask task, String opt, String arg) {
 209                 task.options.showDescriptors = true;
 210             }
 211         },
 212 
 213         new Option(false, &quot;-sysinfo&quot;) {
 214             @Override
 215             void process(JavapTask task, String opt, String arg) {
 216                 task.options.sysInfo = true;
 217             }
 218         },
 219 
 220         new Option(false, &quot;-XDdetails&quot;) {
 221             @Override
 222             void process(JavapTask task, String opt, String arg) {
 223                 task.options.details = EnumSet.allOf(InstructionDetailWriter.Kind.class);
 224             }
 225 
 226         },
 227 
 228         new Option(false, &quot;-XDdetails:&quot;) {
 229             @Override
 230             boolean matches(String opt) {
 231                 int sep = opt.indexOf(&quot;:&quot;);
 232                 return sep != -1 &amp;&amp; super.matches(opt.substring(0, sep + 1));
 233             }
 234 
 235             @Override
 236             void process(JavapTask task, String opt, String arg) throws BadArgs {
 237                 int sep = opt.indexOf(&quot;:&quot;);
 238                 for (String v: opt.substring(sep + 1).split(&quot;[,: ]+&quot;)) {
 239                     if (!handleArg(task, v))
 240                         throw task.new BadArgs(&quot;err.invalid.arg.for.option&quot;, v);
 241                 }
 242             }
 243 
 244             boolean handleArg(JavapTask task, String arg) {
 245                 if (arg.length() == 0)
 246                     return true;
 247 
 248                 if (arg.equals(&quot;all&quot;)) {
 249                     task.options.details = EnumSet.allOf(InstructionDetailWriter.Kind.class);
 250                     return true;
 251                 }
 252 
 253                 boolean on = true;
 254                 if (arg.startsWith(&quot;-&quot;)) {
 255                     on = false;
 256                     arg = arg.substring(1);
 257                 }
 258 
 259                 for (InstructionDetailWriter.Kind k: InstructionDetailWriter.Kind.values()) {
 260                     if (arg.equalsIgnoreCase(k.option)) {
 261                         if (on)
 262                             task.options.details.add(k);
 263                         else
 264                             task.options.details.remove(k);
 265                         return true;
 266                     }
 267                 }
 268                 return false;
 269             }
 270         },
 271 
 272         new Option(false, &quot;-constants&quot;) {
 273             @Override
 274             void process(JavapTask task, String opt, String arg) {
 275                 task.options.showConstants = true;
 276             }
 277         },
 278 
 279         new Option(false, &quot;-XDinner&quot;) {
 280             @Override
 281             void process(JavapTask task, String opt, String arg) {
 282                 task.options.showInnerClasses = true;
 283             }
 284         },
 285 
 286         new Option(false, &quot;-XDindent:&quot;) {
 287             @Override
 288             boolean matches(String opt) {
 289                 int sep = opt.indexOf(&quot;:&quot;);
 290                 return sep != -1 &amp;&amp; super.matches(opt.substring(0, sep + 1));
 291             }
 292 
 293             @Override
 294             void process(JavapTask task, String opt, String arg) throws BadArgs {
 295                 int sep = opt.indexOf(&quot;:&quot;);
 296                 try {
 297                     int i = Integer.valueOf(opt.substring(sep + 1));
 298                     if (i &gt; 0) // silently ignore invalid values
 299                         task.options.indentWidth = i;
 300                 } catch (NumberFormatException e) {
 301                 }
 302             }
 303         },
 304 
 305         new Option(false, &quot;-XDtab:&quot;) {
 306             @Override
 307             boolean matches(String opt) {
 308                 int sep = opt.indexOf(&quot;:&quot;);
 309                 return sep != -1 &amp;&amp; super.matches(opt.substring(0, sep + 1));
 310             }
 311 
 312             @Override
 313             void process(JavapTask task, String opt, String arg) throws BadArgs {
 314                 int sep = opt.indexOf(&quot;:&quot;);
 315                 try {
 316                     int i = Integer.valueOf(opt.substring(sep + 1));
 317                     if (i &gt; 0) // silently ignore invalid values
 318                         task.options.tabColumn = i;
 319                 } catch (NumberFormatException e) {
 320                 }
 321             }
 322         },
 323 
 324         new Option(true, &quot;--module&quot;, &quot;-m&quot;) {
 325             @Override
 326             void process(JavapTask task, String opt, String arg) throws BadArgs {
 327                 task.options.moduleName = arg;
 328             }
 329         },
 330 
 331         // this option is processed by the launcher, and cannot be used when invoked via
 332         // an API like ToolProvider. It exists here to be documented in the command-line help.
 333         new Option(false, &quot;-J&quot;) {
 334             @Override
 335             boolean matches(String opt) {
 336                 return opt.startsWith(&quot;-J&quot;);
 337             }
 338 
 339             @Override
 340             void process(JavapTask task, String opt, String arg) throws BadArgs {
 341                 throw task.new BadArgs(&quot;err.only.for.launcher&quot;);
 342             }
 343         }
 344 
 345     };
 346 
 347     public JavapTask() {
 348         context = new Context();
 349         context.put(Messages.class, this);
 350         options = Options.instance(context);
 351         attributeFactory = new Attribute.Factory();
 352     }
 353 
 354     public JavapTask(Writer out,
 355             JavaFileManager fileManager,
 356             DiagnosticListener&lt;? super JavaFileObject&gt; diagnosticListener) {
 357         this();
 358         this.log = getPrintWriterForWriter(out);
 359         this.fileManager = fileManager;
 360         this.diagnosticListener = diagnosticListener;
 361     }
 362 
 363     public JavapTask(Writer out,
 364             JavaFileManager fileManager,
 365             DiagnosticListener&lt;? super JavaFileObject&gt; diagnosticListener,
 366             Iterable&lt;String&gt; options,
 367             Iterable&lt;String&gt; classes) {
 368         this(out, fileManager, diagnosticListener);
 369 
 370         this.classes = new ArrayList&lt;&gt;();
 371         for (String classname: classes) {
 372             Objects.requireNonNull(classname);
 373             this.classes.add(classname);
 374         }
 375 
 376         try {
 377             if (options != null)
 378                 handleOptions(options, false);
 379         } catch (BadArgs e) {
 380             throw new IllegalArgumentException(e.getMessage());
 381         }
 382     }
 383 
 384     public void setLocale(Locale locale) {
 385         if (locale == null)
 386             locale = Locale.getDefault();
 387         task_locale = locale;
 388     }
 389 
 390     public void setLog(Writer log) {
 391         this.log = getPrintWriterForWriter(log);
 392     }
 393 
 394     public void setLog(OutputStream s) {
 395         setLog(getPrintWriterForStream(s));
 396     }
 397 
 398     private static PrintWriter getPrintWriterForStream(OutputStream s) {
 399         return new PrintWriter(s == null ? System.err : s, true);
 400     }
 401 
 402     private static PrintWriter getPrintWriterForWriter(Writer w) {
 403         if (w == null)
 404             return getPrintWriterForStream(null);
 405         else if (w instanceof PrintWriter)
 406             return (PrintWriter) w;
 407         else
 408             return new PrintWriter(w, true);
 409     }
 410 
 411     public void setDiagnosticListener(DiagnosticListener&lt;? super JavaFileObject&gt; dl) {
 412         diagnosticListener = dl;
 413     }
 414 
 415     public void setDiagnosticListener(OutputStream s) {
 416         setDiagnosticListener(getDiagnosticListenerForStream(s));
 417     }
 418 
 419     private DiagnosticListener&lt;JavaFileObject&gt; getDiagnosticListenerForStream(OutputStream s) {
 420         return getDiagnosticListenerForWriter(getPrintWriterForStream(s));
 421     }
 422 
 423     private DiagnosticListener&lt;JavaFileObject&gt; getDiagnosticListenerForWriter(Writer w) {
 424         final PrintWriter pw = getPrintWriterForWriter(w);
 425         return diagnostic -&gt; {
 426             switch (diagnostic.getKind()) {
 427                 case ERROR:
 428                     pw.print(getMessage(&quot;err.prefix&quot;));
 429                     break;
 430                 case WARNING:
 431                     pw.print(getMessage(&quot;warn.prefix&quot;));
 432                     break;
 433                 case NOTE:
 434                     pw.print(getMessage(&quot;note.prefix&quot;));
 435                     break;
 436             }
 437             pw.print(&quot; &quot;);
 438             pw.println(diagnostic.getMessage(null));
 439         };
 440     }
 441 
 442     /** Result codes.
 443      */
 444     static final int
 445         EXIT_OK = 0,        // Compilation completed with no errors.
 446         EXIT_ERROR = 1,     // Completed but reported errors.
 447         EXIT_CMDERR = 2,    // Bad command-line arguments
 448         EXIT_SYSERR = 3,    // System error or resource exhaustion.
 449         EXIT_ABNORMAL = 4;  // Compiler terminated abnormally
 450 
 451     int run(String[] args) {
 452         try {
 453             try {
 454                 handleOptions(args);
 455 
 456                 // the following gives consistent behavior with javac
 457                 if (classes == null || classes.size() == 0) {
 458                     if (options.help || options.version || options.fullVersion)
 459                         return EXIT_OK;
 460                     else
 461                         return EXIT_CMDERR;
 462                 }
 463 
 464                 return run();
 465             } finally {
 466                 if (defaultFileManager != null) {
 467                     try {
 468                         defaultFileManager.close();
 469                         defaultFileManager = null;
 470                     } catch (IOException e) {
 471                         throw new InternalError(e);
 472                     }
 473                 }
 474             }
 475         } catch (BadArgs e) {
 476             reportError(e.key, e.args);
 477             if (e.showUsage) {
 478                 printLines(getMessage(&quot;main.usage.summary&quot;, progname));
 479             }
 480             return EXIT_CMDERR;
 481         } catch (InternalError e) {
 482             Object[] e_args;
 483             if (e.getCause() == null)
 484                 e_args = e.args;
 485             else {
 486                 e_args = new Object[e.args.length + 1];
 487                 e_args[0] = e.getCause();
 488                 System.arraycopy(e.args, 0, e_args, 1, e.args.length);
 489             }
 490             reportError(&quot;err.internal.error&quot;, e_args);
 491             return EXIT_ABNORMAL;
 492         } finally {
 493             log.flush();
 494         }
 495     }
 496 
 497     public void handleOptions(String[] args) throws BadArgs {
 498         handleOptions(Arrays.asList(args), true);
 499     }
 500 
 501     private void handleOptions(Iterable&lt;String&gt; args, boolean allowClasses) throws BadArgs {
 502         if (log == null) {
 503             log = getPrintWriterForStream(System.out);
 504             if (diagnosticListener == null)
 505               diagnosticListener = getDiagnosticListenerForStream(System.err);
 506         } else {
 507             if (diagnosticListener == null)
 508               diagnosticListener = getDiagnosticListenerForWriter(log);
 509         }
 510 
 511 
 512         if (fileManager == null)
 513             fileManager = getDefaultFileManager(diagnosticListener, log);
 514 
 515         Iterator&lt;String&gt; iter = args.iterator();
 516         boolean noArgs = !iter.hasNext();
 517 
 518         while (iter.hasNext()) {
 519             String arg = iter.next();
 520             if (arg.startsWith(&quot;-&quot;))
 521                 handleOption(arg, iter);
 522             else if (allowClasses) {
 523                 if (classes == null)
 524                     classes = new ArrayList&lt;&gt;();
 525                 classes.add(arg);
 526                 while (iter.hasNext())
 527                     classes.add(iter.next());
 528             } else
 529                 throw new BadArgs(&quot;err.unknown.option&quot;, arg).showUsage(true);
 530         }
 531 
 532         if (options.accessOptions.size() &gt; 1) {
 533             StringBuilder sb = new StringBuilder();
 534             for (String opt: options.accessOptions) {
 535                 if (sb.length() &gt; 0)
 536                     sb.append(&quot; &quot;);
 537                 sb.append(opt);
 538             }
 539             throw new BadArgs(&quot;err.incompatible.options&quot;, sb);
 540         }
 541 
 542         if ((classes == null || classes.size() == 0) &amp;&amp;
 543                 !(noArgs || options.help || options.version || options.fullVersion)) {
 544             throw new BadArgs(&quot;err.no.classes.specified&quot;);
 545         }
 546 
 547         if (noArgs || options.help)
 548             showHelp();
 549 
 550         if (options.version || options.fullVersion)
 551             showVersion(options.fullVersion);
 552     }
 553 
 554     private void handleOption(String name, Iterator&lt;String&gt; rest) throws BadArgs {
 555         for (Option o: recognizedOptions) {
 556             if (o.matches(name)) {
 557                 if (o.hasArg) {
 558                     if (rest.hasNext())
 559                         o.process(this, name, rest.next());
 560                     else
 561                         throw new BadArgs(&quot;err.missing.arg&quot;, name).showUsage(true);
 562                 } else
 563                     o.process(this, name, null);
 564 
 565                 if (o.ignoreRest()) {
 566                     while (rest.hasNext())
 567                         rest.next();
 568                 }
 569                 return;
 570             }
 571         }
 572 
 573         try {
 574             if (fileManager.handleOption(name, rest))
 575                 return;
 576         } catch (IllegalArgumentException e) {
 577             throw new BadArgs(&quot;err.invalid.use.of.option&quot;, name).showUsage(true);
 578         }
 579 
 580         throw new BadArgs(&quot;err.unknown.option&quot;, name).showUsage(true);
 581     }
 582 
 583     public Boolean call() {
 584         return run() == 0;
 585     }
 586 
 587     public int run() {
 588         if (classes == null || classes.isEmpty()) {
 589             return EXIT_ERROR;
 590         }
 591 
 592         context.put(PrintWriter.class, log);
 593         ClassWriter classWriter = ClassWriter.instance(context);
 594         SourceWriter sourceWriter = SourceWriter.instance(context);
 595         sourceWriter.setFileManager(fileManager);
 596 
 597         if (options.moduleName != null) {
 598             try {
 599                 moduleLocation = findModule(options.moduleName);
 600                 if (moduleLocation == null) {
 601                     reportError(&quot;err.cant.find.module&quot;, options.moduleName);
 602                     return EXIT_ERROR;
 603                 }
 604             } catch (IOException e) {
 605                 reportError(&quot;err.cant.find.module.ex&quot;, options.moduleName, e);
 606                 return EXIT_ERROR;
 607             }
 608         }
 609 
 610         int result = EXIT_OK;
 611 
 612         for (String className: classes) {
 613             try {
 614                 result = writeClass(classWriter, className);
 615             } catch (ConstantPoolException e) {
 616                 reportError(&quot;err.bad.constant.pool&quot;, className, e.getLocalizedMessage());
 617                 result = EXIT_ERROR;
 618             } catch (EOFException e) {
 619                 reportError(&quot;err.end.of.file&quot;, className);
 620                 result = EXIT_ERROR;
 621             } catch (FileNotFoundException | NoSuchFileException e) {
 622                 reportError(&quot;err.file.not.found&quot;, e.getLocalizedMessage());
 623                 result = EXIT_ERROR;
 624             } catch (IOException e) {
 625                 //e.printStackTrace();
 626                 Object msg = e.getLocalizedMessage();
 627                 if (msg == null) {
 628                     msg = e;
 629                 }
 630                 reportError(&quot;err.ioerror&quot;, className, msg);
 631                 result = EXIT_ERROR;
 632             } catch (OutOfMemoryError e) {
 633                 reportError(&quot;err.nomem&quot;);
 634                 result = EXIT_ERROR;
 635             } catch (Throwable t) {
 636                 StringWriter sw = new StringWriter();
 637                 PrintWriter pw = new PrintWriter(sw);
 638                 t.printStackTrace(pw);
 639                 pw.close();
 640                 reportError(&quot;err.crash&quot;, t.toString(), sw.toString());
 641                 result = EXIT_ABNORMAL;
 642             }
 643         }
 644 
 645         return result;
 646     }
 647 
 648     protected int writeClass(ClassWriter classWriter, String className)
 649             throws IOException, ConstantPoolException {
 650         JavaFileObject fo = open(className);
 651         if (fo == null) {
 652             reportError(&quot;err.class.not.found&quot;, className);
 653             return EXIT_ERROR;
 654         }
 655 
 656         ClassFileInfo cfInfo = read(fo);
 657         if (!className.endsWith(&quot;.class&quot;)) {
 658             if (cfInfo.cf.this_class == 0) {
 659                 if (!className.equals(&quot;module-info&quot;)) {
 660                     reportWarning(&quot;warn.unexpected.class&quot;, fo.getName(), className);
 661                 }
 662             } else {
 663                 String cfName = cfInfo.cf.getName();
 664                 if (!cfName.replaceAll(&quot;[/$]&quot;, &quot;.&quot;).equals(className.replaceAll(&quot;[/$]&quot;, &quot;.&quot;))) {
 665                     reportWarning(&quot;warn.unexpected.class&quot;, fo.getName(), className);
 666                 }
 667             }
 668         }
 669         write(cfInfo);
 670 
 671         if (options.showInnerClasses) {
 672             ClassFile cf = cfInfo.cf;
 673             Attribute a = cf.getAttribute(Attribute.InnerClasses);
 674             if (a instanceof InnerClasses_attribute) {
 675                 InnerClasses_attribute inners = (InnerClasses_attribute) a;
 676                 try {
 677                     int result = EXIT_OK;
 678                     for (int i = 0; i &lt; inners.classes.length; i++) {
 679                         int outerIndex = inners.classes[i].outer_class_info_index;
 680                         ConstantPool.CONSTANT_Class_info outerClassInfo = cf.constant_pool.getClassInfo(outerIndex);
 681                         String outerClassName = outerClassInfo.getName();
 682                         if (outerClassName.equals(cf.getName())) {
 683                             int innerIndex = inners.classes[i].inner_class_info_index;
 684                             ConstantPool.CONSTANT_Class_info innerClassInfo = cf.constant_pool.getClassInfo(innerIndex);
 685                             String innerClassName = innerClassInfo.getName();
 686                             classWriter.println(&quot;// inner class &quot; + innerClassName.replaceAll(&quot;[/$]&quot;, &quot;.&quot;));
 687                             classWriter.println();
 688                             result = writeClass(classWriter, innerClassName);
 689                             if (result != EXIT_OK) return result;
 690                         }
 691                     }
 692                     return result;
 693                 } catch (ConstantPoolException e) {
 694                     reportError(&quot;err.bad.innerclasses.attribute&quot;, className);
 695                     return EXIT_ERROR;
 696                 }
 697             } else if (a != null) {
 698                 reportError(&quot;err.bad.innerclasses.attribute&quot;, className);
 699                 return EXIT_ERROR;
 700             }
 701         }
 702 
 703         return EXIT_OK;
 704     }
 705 
 706     protected JavaFileObject open(String className) throws IOException {
 707         // for compatibility, first see if it is a class name
 708         JavaFileObject fo = getClassFileObject(className);
 709         if (fo != null)
 710             return fo;
 711 
 712         // see if it is an inner class, by replacing dots to $, starting from the right
 713         String cn = className;
 714         int lastDot;
 715         while ((lastDot = cn.lastIndexOf(&quot;.&quot;)) != -1) {
 716             cn = cn.substring(0, lastDot) + &quot;$&quot; + cn.substring(lastDot + 1);
 717             fo = getClassFileObject(cn);
 718             if (fo != null)
 719                 return fo;
 720         }
 721 
 722         if (!className.endsWith(&quot;.class&quot;))
 723             return null;
 724 
 725         if (fileManager instanceof StandardJavaFileManager) {
 726             StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;
 727             try {
 728                 fo = sfm.getJavaFileObjects(className).iterator().next();
 729                 if (fo != null &amp;&amp; fo.getLastModified() != 0) {
 730                     return fo;
 731                 }
 732             } catch (IllegalArgumentException ignore) {
 733             }
 734         }
 735 
 736         // see if it is a URL, and if so, wrap it in just enough of a JavaFileObject
 737         // to suit javap&#39;s needs
 738         if (className.matches(&quot;^[A-Za-z]+:.*&quot;)) {
 739             try {
 740                 final URI uri = new URI(className);
 741                 final URL url = uri.toURL();
 742                 final URLConnection conn = url.openConnection();
 743                 conn.setUseCaches(false);
 744                 return new JavaFileObject() {
 745                     public Kind getKind() {
 746                         return JavaFileObject.Kind.CLASS;
 747                     }
 748 
 749                     public boolean isNameCompatible(String simpleName, Kind kind) {
 750                         throw new UnsupportedOperationException();
 751                     }
 752 
 753                     public NestingKind getNestingKind() {
 754                         throw new UnsupportedOperationException();
 755                     }
 756 
 757                     public Modifier getAccessLevel() {
 758                         throw new UnsupportedOperationException();
 759                     }
 760 
 761                     public URI toUri() {
 762                         return uri;
 763                     }
 764 
 765                     public String getName() {
 766                         return uri.toString();
 767                     }
 768 
 769                     public InputStream openInputStream() throws IOException {
 770                         return conn.getInputStream();
 771                     }
 772 
 773                     public OutputStream openOutputStream() throws IOException {
 774                         throw new UnsupportedOperationException();
 775                     }
 776 
 777                     public Reader openReader(boolean ignoreEncodingErrors) throws IOException {
 778                         throw new UnsupportedOperationException();
 779                     }
 780 
 781                     public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
 782                         throw new UnsupportedOperationException();
 783                     }
 784 
 785                     public Writer openWriter() throws IOException {
 786                         throw new UnsupportedOperationException();
 787                     }
 788 
 789                     public long getLastModified() {
 790                         return conn.getLastModified();
 791                     }
 792 
 793                     public boolean delete() {
 794                         throw new UnsupportedOperationException();
 795                     }
 796 
 797                 };
 798             } catch (URISyntaxException | IOException ignore) {
 799             }
 800         }
 801 
 802         return null;
 803     }
 804 
 805     public static class ClassFileInfo {
 806         ClassFileInfo(JavaFileObject fo, ClassFile cf, byte[] digest, int size) {
 807             this.fo = fo;
 808             this.cf = cf;
 809             this.digest = digest;
 810             this.size = size;
 811         }
 812         public final JavaFileObject fo;
 813         public final ClassFile cf;
 814         public final byte[] digest;
 815         public final int size;
 816     }
 817 
 818     public ClassFileInfo read(JavaFileObject fo) throws IOException, ConstantPoolException {
 819         InputStream in = fo.openInputStream();
 820         try {
 821             SizeInputStream sizeIn = null;
 822             MessageDigest md  = null;
 823             if (options.sysInfo || options.verbose) {
 824                 try {
 825                     md = MessageDigest.getInstance(&quot;SHA-256&quot;);
 826                 } catch (NoSuchAlgorithmException ignore) {
 827                 }
 828                 in = new DigestInputStream(in, md);
 829                 in = sizeIn = new SizeInputStream(in);
 830             }
 831 
 832             ClassFile cf = ClassFile.read(in, attributeFactory);
 833             byte[] digest = (md == null) ? null : md.digest();
 834             int size = (sizeIn == null) ? -1 : sizeIn.size();
 835             return new ClassFileInfo(fo, cf, digest, size);
 836         } finally {
 837             in.close();
 838         }
 839     }
 840 
 841     public void write(ClassFileInfo info) {
 842         ClassWriter classWriter = ClassWriter.instance(context);
 843         if (options.sysInfo || options.verbose) {
 844             classWriter.setFile(info.fo.toUri());
 845             classWriter.setLastModified(info.fo.getLastModified());
 846             classWriter.setDigest(&quot;SHA-256&quot;, info.digest);
 847             classWriter.setFileSize(info.size);
 848         }
 849 
 850         classWriter.write(info.cf);
 851     }
 852 
 853     protected void setClassFile(ClassFile classFile) {
 854         ClassWriter classWriter = ClassWriter.instance(context);
 855         classWriter.setClassFile(classFile);
 856     }
 857 
 858     protected void setMethod(Method enclosingMethod) {
 859         ClassWriter classWriter = ClassWriter.instance(context);
 860         classWriter.setMethod(enclosingMethod);
 861     }
 862 
 863     protected void write(Attribute value) {
 864         AttributeWriter attrWriter = AttributeWriter.instance(context);
 865         ClassWriter classWriter = ClassWriter.instance(context);
 866         ClassFile cf = classWriter.getClassFile();
 867         attrWriter.write(cf, value, cf.constant_pool);
 868     }
 869 
 870     protected void write(Attributes attrs) {
 871         AttributeWriter attrWriter = AttributeWriter.instance(context);
 872         ClassWriter classWriter = ClassWriter.instance(context);
 873         ClassFile cf = classWriter.getClassFile();
 874         attrWriter.write(cf, attrs, cf.constant_pool);
 875     }
 876 
 877     protected void write(ConstantPool constant_pool) {
 878         ConstantWriter constantWriter = ConstantWriter.instance(context);
 879         constantWriter.writeConstantPool(constant_pool);
 880     }
 881 
 882     protected void write(ConstantPool constant_pool, int value) {
 883         ConstantWriter constantWriter = ConstantWriter.instance(context);
 884         constantWriter.write(value);
 885     }
 886 
 887     protected void write(ConstantPool.CPInfo value) {
 888         ConstantWriter constantWriter = ConstantWriter.instance(context);
 889         constantWriter.println(value);
 890     }
 891 
 892     protected void write(Field value) {
 893         ClassWriter classWriter = ClassWriter.instance(context);
 894         classWriter.writeField(value);
 895     }
 896 
 897     protected void write(Method value) {
 898         ClassWriter classWriter = ClassWriter.instance(context);
 899         classWriter.writeMethod(value);
 900     }
 901 
 902     private JavaFileManager getDefaultFileManager(final DiagnosticListener&lt;? super JavaFileObject&gt; dl, PrintWriter log) {
 903         if (defaultFileManager == null)
 904             defaultFileManager = JavapFileManager.create(dl, log);
 905         return defaultFileManager;
 906     }
 907 
 908     private JavaFileObject getClassFileObject(String className) throws IOException {
 909         try {
 910             JavaFileObject fo;
 911             if (moduleLocation != null) {
 912                 fo = fileManager.getJavaFileForInput(moduleLocation, className, JavaFileObject.Kind.CLASS);
 913             } else {
 914                 fo = fileManager.getJavaFileForInput(StandardLocation.PLATFORM_CLASS_PATH, className, JavaFileObject.Kind.CLASS);
 915                 if (fo == null)
 916                     fo = fileManager.getJavaFileForInput(StandardLocation.CLASS_PATH, className, JavaFileObject.Kind.CLASS);
 917             }
 918             return fo;
 919         } catch (IllegalArgumentException e) {
 920             return null;
 921         }
 922     }
 923 
 924     private Location findModule(String moduleName) throws IOException {
 925         Location[] locns = {
 926             StandardLocation.UPGRADE_MODULE_PATH,
 927             StandardLocation.SYSTEM_MODULES,
 928             StandardLocation.MODULE_PATH
 929         };
 930         for (Location segment: locns) {
 931             for (Set&lt;Location&gt; set: fileManager.listLocationsForModules(segment)) {
 932                 Location result = null;
 933                 for (Location l: set) {
 934                     String name = fileManager.inferModuleName(l);
 935                     if (name.equals(moduleName)) {
 936                         if (result == null)
 937                             result = l;
 938                         else
 939                             throw new IOException(&quot;multiple definitions found for &quot; + moduleName);
 940                     }
 941                 }
 942                 if (result != null)
 943                     return result;
 944             }
 945         }
 946         return null;
 947     }
 948 
 949     private void showHelp() {
 950         printLines(getMessage(&quot;main.usage&quot;, progname));
 951         for (Option o: recognizedOptions) {
 952             String name = o.aliases[0].replaceAll(&quot;^-+&quot;, &quot;&quot;).replaceAll(&quot;-+&quot;, &quot;_&quot;); // there must always be at least one name
 953             if (name.startsWith(&quot;X&quot;) || name.equals(&quot;fullversion&quot;))
 954                 continue;
 955             printLines(getMessage(&quot;main.opt.&quot; + name));
 956         }
 957 
 958         String[] fmOptions = {
 959             &quot;--module-path&quot;, &quot;--system&quot;,
 960             &quot;--class-path&quot;, &quot;-classpath&quot;, &quot;-cp&quot;,
 961             &quot;-bootclasspath&quot;,
 962             &quot;--multi-release&quot;
 963         };
 964 
 965         for (String o: fmOptions) {
 966             if (fileManager.isSupportedOption(o) == -1)
 967                 continue;
 968             String name = o.replaceAll(&quot;^-+&quot;, &quot;&quot;).replaceAll(&quot;-+&quot;, &quot;_&quot;);
 969             printLines(getMessage(&quot;main.opt.&quot; + name));
 970         }
 971 
 972         printLines(getMessage(&quot;main.usage.foot&quot;));
 973     }
 974 
 975     private void showVersion(boolean full) {
 976         printLines(version(full ? &quot;full&quot; : &quot;release&quot;));
 977     }
 978 
 979     private void printLines(String msg) {
 980         log.println(msg.replace(&quot;\n&quot;, nl));
 981     }
 982 
 983     private static final String nl = System.getProperty(&quot;line.separator&quot;);
 984 
 985     private static final String versionRBName = &quot;com.sun.tools.javap.resources.version&quot;;
 986     private static ResourceBundle versionRB;
 987 
 988     private String version(String key) {
 989         // key=version:  mm.nn.oo[-milestone]
 990         // key=full:     mm.mm.oo[-milestone]-build
 991         if (versionRB == null) {
 992             try {
 993                 versionRB = ResourceBundle.getBundle(versionRBName);
 994             } catch (MissingResourceException e) {
 995                 return getMessage(&quot;version.resource.missing&quot;, System.getProperty(&quot;java.version&quot;));
 996             }
 997         }
 998         try {
 999             return versionRB.getString(key);
1000         }
1001         catch (MissingResourceException e) {
1002             return getMessage(&quot;version.unknown&quot;, System.getProperty(&quot;java.version&quot;));
1003         }
1004     }
1005 
1006     private void reportError(String key, Object... args) {
1007         diagnosticListener.report(createDiagnostic(Diagnostic.Kind.ERROR, key, args));
1008     }
1009 
1010     private void reportNote(String key, Object... args) {
1011         diagnosticListener.report(createDiagnostic(Diagnostic.Kind.NOTE, key, args));
1012     }
1013 
1014     private void reportWarning(String key, Object... args) {
1015         diagnosticListener.report(createDiagnostic(Diagnostic.Kind.WARNING, key, args));
1016     }
1017 
1018     private Diagnostic&lt;JavaFileObject&gt; createDiagnostic(
1019             final Diagnostic.Kind kind, final String key, final Object... args) {
1020         return new Diagnostic&lt;JavaFileObject&gt;() {
1021             public Kind getKind() {
1022                 return kind;
1023             }
1024 
1025             public JavaFileObject getSource() {
1026                 return null;
1027             }
1028 
1029             public long getPosition() {
1030                 return Diagnostic.NOPOS;
1031             }
1032 
1033             public long getStartPosition() {
1034                 return Diagnostic.NOPOS;
1035             }
1036 
1037             public long getEndPosition() {
1038                 return Diagnostic.NOPOS;
1039             }
1040 
1041             public long getLineNumber() {
1042                 return Diagnostic.NOPOS;
1043             }
1044 
1045             public long getColumnNumber() {
1046                 return Diagnostic.NOPOS;
1047             }
1048 
1049             public String getCode() {
1050                 return key;
1051             }
1052 
1053             public String getMessage(Locale locale) {
1054                 return JavapTask.this.getMessage(locale, key, args);
1055             }
1056 
1057             @Override
1058             public String toString() {
1059                 return getClass().getName() + &quot;[key=&quot; + key + &quot;,args=&quot; + Arrays.asList(args) + &quot;]&quot;;
1060             }
1061 
1062         };
1063 
1064     }
1065 
1066     public String getMessage(String key, Object... args) {
1067         return getMessage(task_locale, key, args);
1068     }
1069 
1070     public String getMessage(Locale locale, String key, Object... args) {
1071         if (bundles == null) {
1072             // could make this a HashMap&lt;Locale,SoftReference&lt;ResourceBundle&gt;&gt;
1073             // and for efficiency, keep a hard reference to the bundle for the task
1074             // locale
1075             bundles = new HashMap&lt;&gt;();
1076         }
1077 
1078         if (locale == null)
1079             locale = Locale.getDefault();
1080 
1081         ResourceBundle b = bundles.get(locale);
1082         if (b == null) {
1083             try {
1084                 b = ResourceBundle.getBundle(&quot;com.sun.tools.javap.resources.javap&quot;, locale);
1085                 bundles.put(locale, b);
1086             } catch (MissingResourceException e) {
1087                 throw new InternalError(&quot;Cannot find javap resource bundle for locale &quot; + locale);
1088             }
1089         }
1090 
1091         try {
1092             return MessageFormat.format(b.getString(key), args);
1093         } catch (MissingResourceException e) {
1094             throw new InternalError(e, key);
1095         }
1096     }
1097 
1098     protected Context context;
1099     JavaFileManager fileManager;
1100     JavaFileManager defaultFileManager;
1101     PrintWriter log;
1102     DiagnosticListener&lt;? super JavaFileObject&gt; diagnosticListener;
1103     List&lt;String&gt; classes;
1104     Location moduleLocation;
1105     Options options;
1106     //ResourceBundle bundle;
1107     Locale task_locale;
1108     Map&lt;Locale, ResourceBundle&gt; bundles;
1109     protected Attribute.Factory attributeFactory;
1110 
1111     private static final String progname = &quot;javap&quot;;
1112 
1113     private static class SizeInputStream extends FilterInputStream {
1114         SizeInputStream(InputStream in) {
1115             super(in);
1116         }
1117 
1118         int size() {
1119             return size;
1120         }
1121 
1122         @Override
1123         public int read(byte[] buf, int offset, int length) throws IOException {
1124             int n = super.read(buf, offset, length);
1125             if (n &gt; 0)
1126                 size += n;
1127             return n;
1128         }
1129 
1130         @Override
1131         public int read() throws IOException {
1132             int b = super.read();
1133             size += 1;
1134             return b;
1135         }
1136 
1137         private int size;
1138     }
1139 }
    </pre>
  </body>
</html>