<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/net/DatagramSocket.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.net;
  27 
  28 import java.io.IOException;
  29 import java.io.UncheckedIOException;
  30 import java.nio.channels.DatagramChannel;
  31 import java.security.AccessController;
  32 import java.security.PrivilegedExceptionAction;
  33 import java.util.Objects;
  34 import java.util.Set;
  35 import java.util.Collections;
  36 
  37 /**
  38  * This class represents a socket for sending and receiving datagram packets.
  39  *
  40  * &lt;p&gt;A datagram socket is the sending or receiving point for a packet
  41  * delivery service. Each packet sent or received on a datagram socket
  42  * is individually addressed and routed. Multiple packets sent from
  43  * one machine to another may be routed differently, and may arrive in
  44  * any order.
  45  *
  46  * &lt;p&gt; Where possible, a newly constructed {@code DatagramSocket} has the
  47  * {@link StandardSocketOptions#SO_BROADCAST SO_BROADCAST} socket option enabled so as
  48  * to allow the transmission of broadcast datagrams. In order to receive
  49  * broadcast packets a DatagramSocket should be bound to the wildcard address.
  50  * In some implementations, broadcast packets may also be received when
  51  * a DatagramSocket is bound to a more specific address.
  52  * &lt;p&gt;
  53  * Example:
  54  * &lt;pre&gt;{@code
  55  *              DatagramSocket s = new DatagramSocket(null);
  56  *              s.bind(new InetSocketAddress(8888));
  57  * }&lt;/pre&gt;
  58  * Which is equivalent to:
  59  * &lt;pre&gt;{@code
  60  *              DatagramSocket s = new DatagramSocket(8888);
  61  * }&lt;/pre&gt;
  62  * Both cases will create a DatagramSocket able to receive broadcasts on
  63  * UDP port 8888.
  64  *
  65  * &lt;p&gt; The {@code DatagramSocket} class defines convenience
  66  * methods to set and get several socket options. This class also
  67  * defines the {@link #setOption(SocketOption,Object) setOption}
  68  * and {@link #getOption(SocketOption) getOption} methods to set
  69  * and query socket options.
  70  * A {@code DatagramSocket} supports the following socket options:
  71  * &lt;blockquote&gt;
  72  * &lt;a id=&quot;SocketOptions&quot;&gt;&lt;/a&gt;
  73  * &lt;table class=&quot;striped&quot;&gt;
  74  * &lt;caption style=&quot;display:none&quot;&gt;Socket options&lt;/caption&gt;
  75  * &lt;thead&gt;
  76  *   &lt;tr&gt;
  77  *     &lt;th scope=&quot;col&quot;&gt;Option Name&lt;/th&gt;
  78  *     &lt;th scope=&quot;col&quot;&gt;Description&lt;/th&gt;
  79  *   &lt;/tr&gt;
  80  * &lt;/thead&gt;
  81  * &lt;tbody&gt;
  82  *   &lt;tr&gt;
  83  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} &lt;/th&gt;
  84  *     &lt;td&gt; The size of the socket send buffer &lt;/td&gt;
  85  *   &lt;/tr&gt;
  86  *   &lt;tr&gt;
  87  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} &lt;/th&gt;
  88  *     &lt;td&gt; The size of the socket receive buffer &lt;/td&gt;
  89  *   &lt;/tr&gt;
  90  *   &lt;tr&gt;
  91  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} &lt;/th&gt;
  92  *     &lt;td&gt; Re-use address &lt;/td&gt;
  93  *   &lt;/tr&gt;
  94  *   &lt;tr&gt;
  95  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} &lt;/th&gt;
  96  *     &lt;td&gt; Allow transmission of broadcast datagrams &lt;/td&gt;
  97  *   &lt;/tr&gt;
  98  *   &lt;tr&gt;
  99  *     &lt;th scope=&quot;row&quot;&gt; {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} &lt;/th&gt;
 100  *     &lt;td&gt; The Type of Service (ToS) octet in the Internet Protocol (IP) header &lt;/td&gt;
 101  *   &lt;/tr&gt;
 102  * &lt;/tbody&gt;
 103  * &lt;/table&gt;
 104  * &lt;/blockquote&gt;
 105  * An implementation may also support additional options. In particular an implementation
 106  * may support &lt;a href=&quot;MulticastSocket.html#MulticastOptions&quot;&gt;multicast options&lt;/a&gt; which
 107  * can be useful when using a plain {@code DatagramSocket} to send datagrams to a
 108  * multicast group.
 109  *
 110  * @author  Pavani Diwanji
 111  * @see     java.net.DatagramPacket
 112  * @see     java.nio.channels.DatagramChannel
 113  * @since 1.0
 114  */
 115 public class DatagramSocket implements java.io.Closeable {
 116     /**
 117      * Various states of this socket.
 118      */
 119     private boolean bound = false;
 120     private boolean closed = false;
<a name="1" id="anc1"></a><span class="line-modified"> 121     private Object closeLock = new Object();</span>

 122 
 123     /*
 124      * The implementation of this DatagramSocket.
 125      */
 126     private final DatagramSocketImpl impl;
 127 
 128     /**
 129      * Are we using an older DatagramSocketImpl?
 130      */
 131     final boolean oldImpl;
 132 
 133     /**
 134      * Set when a socket is ST_CONNECTED until we are certain
 135      * that any packets which might have been received prior
 136      * to calling connect() but not read by the application
 137      * have been read. During this time we check the source
 138      * address of all packets received to be sure they are from
 139      * the connected destination. Other packets are read but
 140      * silently dropped.
 141      */
 142     private boolean explicitFilter = false;
 143     private int bytesLeftToFilter;
 144     /*
 145      * Connection state:
 146      * ST_NOT_CONNECTED = socket not connected
 147      * ST_CONNECTED = socket connected
 148      * ST_CONNECTED_NO_IMPL = socket connected but not at impl level
 149      */
 150     static final int ST_NOT_CONNECTED = 0;
 151     static final int ST_CONNECTED = 1;
 152     static final int ST_CONNECTED_NO_IMPL = 2;
 153 
 154     int connectState = ST_NOT_CONNECTED;
 155 
 156     /*
 157      * Connected address &amp; port
 158      */
 159     InetAddress connectedAddress = null;
 160     int connectedPort = -1;
 161 
 162     /**
 163      * Connects this socket to a remote socket address (IP address + port number).
 164      * Binds socket if not already bound.
 165      *
 166      * @param   address The remote address.
 167      * @param   port    The remote port
 168      * @throws  SocketException if binding the socket fails.
 169      */
 170     private synchronized void connectInternal(InetAddress address, int port) throws SocketException {
 171         if (port &lt; 0 || port &gt; 0xFFFF) {
 172             throw new IllegalArgumentException(&quot;connect: &quot; + port);
 173         }
 174         if (address == null) {
 175             throw new IllegalArgumentException(&quot;connect: null address&quot;);
 176         }
 177         checkAddress (address, &quot;connect&quot;);
 178         if (isClosed())
 179             return;
 180         SecurityManager security = System.getSecurityManager();
 181         if (security != null) {
 182             if (address.isMulticastAddress()) {
 183                 security.checkMulticast(address);
 184             } else {
 185                 security.checkConnect(address.getHostAddress(), port);
 186                 security.checkAccept(address.getHostAddress(), port);
 187             }
 188         }
 189 
 190         if (!isBound())
 191           bind(new InetSocketAddress(0));
 192 
 193         // old impls do not support connect/disconnect
 194         if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &amp;&amp;
 195              ((AbstractPlainDatagramSocketImpl)impl).nativeConnectDisabled())) {
 196             connectState = ST_CONNECTED_NO_IMPL;
 197         } else {
 198             try {
 199                 getImpl().connect(address, port);
 200 
 201                 // socket is now connected by the impl
 202                 connectState = ST_CONNECTED;
 203                 // Do we need to filter some packets?
 204                 int avail = getImpl().dataAvailable();
 205                 if (avail == -1) {
 206                     throw new SocketException();
 207                 }
 208                 explicitFilter = avail &gt; 0;
 209                 if (explicitFilter) {
 210                     bytesLeftToFilter = getReceiveBufferSize();
 211                 }
 212             } catch (SocketException se) {
 213 
 214                 // connection will be emulated by DatagramSocket
 215                 connectState = ST_CONNECTED_NO_IMPL;
 216             }
 217         }
 218 
 219         connectedAddress = address;
 220         connectedPort = port;
 221     }
 222 
 223 
 224     /**
 225      * Constructs a datagram socket and binds it to any available port
 226      * on the local host machine.  The socket will be bound to the
 227      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 228      * an IP address chosen by the kernel.
 229      *
 230      * &lt;p&gt;If there is a security manager,
 231      * its {@code checkListen} method is first called
 232      * with 0 as its argument to ensure the operation is allowed.
 233      * This could result in a SecurityException.
 234      *
 235      * @throws     SocketException  if the socket could not be opened,
 236      *               or the socket could not bind to the specified local port.
 237      * @throws     SecurityException  if a security manager exists and its
 238      *             {@code checkListen} method doesn&#39;t allow the operation.
 239      *
 240      * @see SecurityManager#checkListen
 241      */
 242     public DatagramSocket() throws SocketException {
 243         this(new InetSocketAddress(0));
 244     }
 245 
 246     /**
 247      * Creates an unbound datagram socket with the specified
 248      * DatagramSocketImpl.
 249      *
 250      * @param impl an instance of a &lt;B&gt;DatagramSocketImpl&lt;/B&gt;
 251      *        the subclass wishes to use on the DatagramSocket.
 252      * @since   1.4
 253      */
 254     protected DatagramSocket(DatagramSocketImpl impl) {
 255         if (impl == null)
 256             throw new NullPointerException();
 257         this.impl = impl;
 258         this.oldImpl = checkOldImpl(impl);
 259     }
 260 
 261     /**
 262      * Creates a datagram socket, bound to the specified local
 263      * socket address.
 264      * &lt;p&gt;
 265      * If, if the address is {@code null}, creates an unbound socket.
 266      *
 267      * &lt;p&gt;If there is a security manager,
 268      * its {@code checkListen} method is first called
 269      * with the port from the socket address
 270      * as its argument to ensure the operation is allowed.
 271      * This could result in a SecurityException.
 272      *
 273      * @param bindaddr local socket address to bind, or {@code null}
 274      *                 for an unbound socket.
 275      *
 276      * @throws     SocketException  if the socket could not be opened,
 277      *               or the socket could not bind to the specified local port.
 278      * @throws     SecurityException  if a security manager exists and its
 279      *             {@code checkListen} method doesn&#39;t allow the operation.
 280      *
 281      * @see SecurityManager#checkListen
 282      * @since   1.4
 283      */
 284     public DatagramSocket(SocketAddress bindaddr) throws SocketException {
 285         // Special case initialization for the DatagramChannel socket adaptor.
 286         if (this instanceof sun.nio.ch.DatagramSocketAdaptor) {
 287             this.impl = null;  // no DatagramSocketImpl
 288             this.oldImpl = false;
 289             return;
 290         }
 291 
 292         // create a datagram socket.
 293         boolean multicast = (this instanceof MulticastSocket);
 294         this.impl = createImpl(multicast);
<a name="2" id="anc2"></a>


 295         this.oldImpl = checkOldImpl(impl);
 296         if (bindaddr != null) {
 297             try {
 298                 bind(bindaddr);
 299             } finally {
 300                 if (!isBound())
 301                     close();
 302             }
 303         }
 304     }
 305 
 306     /**
 307      * Constructs a datagram socket and binds it to the specified port
 308      * on the local host machine.  The socket will be bound to the
 309      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 310      * an IP address chosen by the kernel.
 311      *
 312      * &lt;p&gt;If there is a security manager,
 313      * its {@code checkListen} method is first called
 314      * with the {@code port} argument
 315      * as its argument to ensure the operation is allowed.
 316      * This could result in a SecurityException.
 317      *
 318      * @param      port port to use.
 319      * @throws     SocketException  if the socket could not be opened,
 320      *               or the socket could not bind to the specified local port.
 321      * @throws     SecurityException  if a security manager exists and its
 322      *             {@code checkListen} method doesn&#39;t allow the operation.
 323      *
 324      * @see SecurityManager#checkListen
 325      */
 326     public DatagramSocket(int port) throws SocketException {
 327         this(port, null);
 328     }
 329 
 330     /**
 331      * Creates a datagram socket, bound to the specified local
 332      * address.  The local port must be between 0 and 65535 inclusive.
 333      * If the IP address is 0.0.0.0, the socket will be bound to the
 334      * {@link InetAddress#isAnyLocalAddress wildcard} address,
 335      * an IP address chosen by the kernel.
 336      *
 337      * &lt;p&gt;If there is a security manager,
 338      * its {@code checkListen} method is first called
 339      * with the {@code port} argument
 340      * as its argument to ensure the operation is allowed.
 341      * This could result in a SecurityException.
 342      *
 343      * @param port local port to use
 344      * @param laddr local address to bind
 345      *
 346      * @throws     SocketException  if the socket could not be opened,
 347      *               or the socket could not bind to the specified local port.
 348      * @throws     SecurityException  if a security manager exists and its
 349      *             {@code checkListen} method doesn&#39;t allow the operation.
 350      *
 351      * @see SecurityManager#checkListen
 352      * @since   1.1
 353      */
 354     public DatagramSocket(int port, InetAddress laddr) throws SocketException {
 355         this(new InetSocketAddress(laddr, port));
 356     }
 357 
 358     /**
 359      * Return true if the given DatagramSocketImpl is an &quot;old&quot; impl. An old impl
 360      * is one that doesn&#39;t implement the abstract methods added in Java SE 1.4.
 361      */
 362     private static boolean checkOldImpl(DatagramSocketImpl impl) {
 363         // DatagramSocketImpl.peekData() is a protected method, therefore we need to use
 364         // getDeclaredMethod, therefore we need permission to access the member
 365         try {
 366             AccessController.doPrivileged(
 367                 new PrivilegedExceptionAction&lt;&gt;() {
 368                     public Void run() throws NoSuchMethodException {
 369                         Class&lt;?&gt;[] cl = new Class&lt;?&gt;[1];
 370                         cl[0] = DatagramPacket.class;
 371                         impl.getClass().getDeclaredMethod(&quot;peekData&quot;, cl);
 372                         return null;
 373                     }
 374                 });
 375             return false;
 376         } catch (java.security.PrivilegedActionException e) {
 377             return true;
 378         }
 379     }
 380 
 381     static Class&lt;?&gt; implClass = null;
 382 
 383     /**
 384      * Creates a DatagramSocketImpl.
 385      * @param multicast true if the DatagramSocketImpl is for a MulticastSocket
 386      */
 387     private static DatagramSocketImpl createImpl(boolean multicast) throws SocketException {
 388         DatagramSocketImpl impl;
 389         DatagramSocketImplFactory factory = DatagramSocket.factory;
 390         if (factory != null) {
 391             impl = factory.createDatagramSocketImpl();
 392         } else {
 393             impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);
 394         }
<a name="3" id="anc3"></a><span class="line-removed"> 395         // creates a udp socket</span>
<span class="line-removed"> 396         impl.create();</span>
 397         return impl;
 398     }
 399 
 400     /**
<a name="4" id="anc4"></a><span class="line-modified"> 401      * Return the {@code DatagramSocketImpl} attached to this socket.</span>

 402      *
 403      * @return  the {@code DatagramSocketImpl} attached to that
 404      *          DatagramSocket
<a name="5" id="anc5"></a><span class="line-modified"> 405      * @throws SocketException never thrown</span>
 406      * @since 1.4
 407      */
<a name="6" id="anc6"></a><span class="line-modified"> 408     DatagramSocketImpl getImpl() throws SocketException {</span>








 409         return impl;
 410     }
 411 
 412     /**
 413      * Binds this DatagramSocket to a specific address and port.
 414      * &lt;p&gt;
 415      * If the address is {@code null}, then the system will pick up
 416      * an ephemeral port and a valid local address to bind the socket.
 417      *
 418      * @param   addr The address and port to bind to.
 419      * @throws  SocketException if any error happens during the bind, or if the
 420      *          socket is already bound.
 421      * @throws  SecurityException  if a security manager exists and its
 422      *             {@code checkListen} method doesn&#39;t allow the operation.
 423      * @throws IllegalArgumentException if addr is a SocketAddress subclass
 424      *         not supported by this socket.
 425      * @since 1.4
 426      */
 427     public synchronized void bind(SocketAddress addr) throws SocketException {
 428         if (isClosed())
 429             throw new SocketException(&quot;Socket is closed&quot;);
 430         if (isBound())
 431             throw new SocketException(&quot;already bound&quot;);
 432         if (addr == null)
 433             addr = new InetSocketAddress(0);
 434         if (!(addr instanceof InetSocketAddress))
 435             throw new IllegalArgumentException(&quot;Unsupported address type!&quot;);
 436         InetSocketAddress epoint = (InetSocketAddress) addr;
 437         if (epoint.isUnresolved())
 438             throw new SocketException(&quot;Unresolved address&quot;);
 439         InetAddress iaddr = epoint.getAddress();
 440         int port = epoint.getPort();
 441         checkAddress(iaddr, &quot;bind&quot;);
 442         SecurityManager sec = System.getSecurityManager();
 443         if (sec != null) {
 444             sec.checkListen(port);
 445         }
 446         try {
 447             getImpl().bind(port, iaddr);
 448         } catch (SocketException e) {
 449             getImpl().close();
 450             throw e;
 451         }
 452         bound = true;
 453     }
 454 
 455     void checkAddress (InetAddress addr, String op) {
 456         if (addr == null) {
 457             return;
 458         }
 459         if (!(addr instanceof Inet4Address || addr instanceof Inet6Address)) {
 460             throw new IllegalArgumentException(op + &quot;: invalid address type&quot;);
 461         }
 462     }
 463 
 464     /**
 465      * Connects the socket to a remote address for this socket. When a
 466      * socket is connected to a remote address, packets may only be
 467      * sent to or received from that address. By default a datagram
 468      * socket is not connected. If the socket is already closed,
 469      * then this method has no effect.
 470      *
 471      * &lt;p&gt; If this socket is not bound then this method will first cause the
 472      * socket to be bound to an address that is assigned automatically,
 473      * as if invoking the {@link #bind bind} method with a parameter of
 474      * {@code null}. If the remote destination to which the socket is connected
 475      * does not exist, or is otherwise unreachable, and if an ICMP destination
 476      * unreachable packet has been received for that address, then a subsequent
 477      * call to send or receive may throw a PortUnreachableException. Note,
 478      * there is no guarantee that the exception will be thrown.
 479      *
 480      * &lt;p&gt; If a security manager has been installed then it is invoked to check
 481      * access to the remote address. Specifically, if the given {@code address}
 482      * is a {@link InetAddress#isMulticastAddress multicast address},
 483      * the security manager&#39;s {@link
 484      * java.lang.SecurityManager#checkMulticast(InetAddress)
 485      * checkMulticast} method is invoked with the given {@code address}.
 486      * Otherwise, the security manager&#39;s {@link
 487      * java.lang.SecurityManager#checkConnect(String,int) checkConnect}
 488      * and {@link java.lang.SecurityManager#checkAccept checkAccept} methods
 489      * are invoked, with the given {@code address} and {@code port}, to
 490      * verify that datagrams are permitted to be sent and received
 491      * respectively.
 492      *
 493      * &lt;p&gt; Care should be taken to ensure that a connected datagram socket
 494      * is not shared with untrusted code. When a socket is connected,
 495      * {@link #receive receive} and {@link #send send} &lt;b&gt;will not perform
 496      * any security checks&lt;/b&gt; on incoming and outgoing packets, other than
 497      * matching the packet&#39;s and the socket&#39;s address and port. On a send
 498      * operation, if the packet&#39;s address is set and the packet&#39;s address
 499      * and the socket&#39;s address do not match, an {@code IllegalArgumentException}
 500      * will be thrown. A socket connected to a multicast address may only
 501      * be used to send packets.
 502      *
 503      * @param address the remote address for the socket
 504      *
 505      * @param port the remote port for the socket.
 506      *
 507      * @throws IllegalArgumentException
 508      *         if the address is null, or the port is out of range.
 509      *
 510      * @throws SecurityException
 511      *         if a security manager has been installed and it does
 512      *         not permit access to the given remote address
 513      *
 514      * @throws UncheckedIOException
 515      *         may be thrown if connect fails, for example, if the
 516      *         destination address is non-routable
 517      *
 518      * @see #disconnect
 519      *
 520      * @since 1.2
 521      */
 522     public void connect(InetAddress address, int port) {
 523         try {
 524             connectInternal(address, port);
 525         } catch (SocketException se) {
 526             throw new UncheckedIOException(&quot;connect failed&quot;, se);
 527         }
 528     }
 529 
 530     /**
 531      * Connects this socket to a remote socket address (IP address + port number).
 532      *
 533      * &lt;p&gt; If given an {@link InetSocketAddress InetSocketAddress}, this method
 534      * behaves as if invoking {@link #connect(InetAddress,int) connect(InetAddress,int)}
 535      * with the given socket addresses IP address and port number, except that the
 536      * {@code SocketException} that may be raised is not wrapped in an
 537      * {@code UncheckedIOException}.
 538      *
 539      * @param   addr    The remote address.
 540      *
 541      * @throws  SocketException
 542      *          if the connect fails
 543      *
 544      * @throws IllegalArgumentException
 545      *         if {@code addr} is {@code null}, or {@code addr} is a SocketAddress
 546      *         subclass not supported by this socket
 547      *
 548      * @throws SecurityException
 549      *         if a security manager has been installed and it does
 550      *         not permit access to the given remote address
 551      *
 552      * @since 1.4
 553      */
 554     public void connect(SocketAddress addr) throws SocketException {
 555         if (addr == null)
 556             throw new IllegalArgumentException(&quot;Address can&#39;t be null&quot;);
 557         if (!(addr instanceof InetSocketAddress))
 558             throw new IllegalArgumentException(&quot;Unsupported address type&quot;);
 559         InetSocketAddress epoint = (InetSocketAddress) addr;
 560         if (epoint.isUnresolved())
 561             throw new SocketException(&quot;Unresolved address&quot;);
 562         connectInternal(epoint.getAddress(), epoint.getPort());
 563     }
 564 
 565     /**
 566      * Disconnects the socket. If the socket is closed or not connected,
 567      * then this method has no effect.
 568      *
 569      * @apiNote If this method throws an UncheckedIOException, the socket
 570      *          may be left in an unspecified state. It is strongly
 571      *          recommended that the socket be closed when disconnect
 572      *          fails.
 573      *
 574      * @throws  UncheckedIOException
 575      *          may be thrown if disconnect fails to dissolve the
 576      *          association and restore the socket to a consistent state.
 577      *
 578      * @see #connect
 579      *
 580      * @since 1.2
 581      */
 582     public void disconnect() {
 583         synchronized (this) {
 584             if (isClosed())
 585                 return;
 586             if (connectState == ST_CONNECTED) {
 587                 impl.disconnect ();
 588             }
 589             connectedAddress = null;
 590             connectedPort = -1;
 591             connectState = ST_NOT_CONNECTED;
 592             explicitFilter = false;
 593         }
 594     }
 595 
 596     /**
 597      * Returns the binding state of the socket.
 598      * &lt;p&gt;
 599      * If the socket was bound prior to being {@link #close closed},
 600      * then this method will continue to return {@code true}
 601      * after the socket is closed.
 602      *
 603      * @return true if the socket successfully bound to an address
 604      * @since 1.4
 605      */
 606     public boolean isBound() {
 607         return bound;
 608     }
 609 
 610     /**
 611      * Returns the connection state of the socket.
 612      * &lt;p&gt;
 613      * If the socket was connected prior to being {@link #close closed},
 614      * then this method will continue to return {@code true}
 615      * after the socket is closed.
 616      *
 617      * @return true if the socket successfully connected to a server
 618      * @since 1.4
 619      */
 620     public boolean isConnected() {
 621         return connectState != ST_NOT_CONNECTED;
 622     }
 623 
 624     /**
 625      * Returns the address to which this socket is connected. Returns
 626      * {@code null} if the socket is not connected.
 627      * &lt;p&gt;
 628      * If the socket was connected prior to being {@link #close closed},
 629      * then this method will continue to return the connected address
 630      * after the socket is closed.
 631      *
 632      * @return the address to which this socket is connected.
 633      * @since 1.2
 634      */
 635     public InetAddress getInetAddress() {
 636         return connectedAddress;
 637     }
 638 
 639     /**
 640      * Returns the port number to which this socket is connected.
 641      * Returns {@code -1} if the socket is not connected.
 642      * &lt;p&gt;
 643      * If the socket was connected prior to being {@link #close closed},
 644      * then this method will continue to return the connected port number
 645      * after the socket is closed.
 646      *
 647      * @return the port number to which this socket is connected.
 648      * @since 1.2
 649      */
 650     public int getPort() {
 651         return connectedPort;
 652     }
 653 
 654     /**
 655      * Returns the address of the endpoint this socket is connected to, or
 656      * {@code null} if it is unconnected.
 657      * &lt;p&gt;
 658      * If the socket was connected prior to being {@link #close closed},
 659      * then this method will continue to return the connected address
 660      * after the socket is closed.
 661      *
 662      * @return a {@code SocketAddress} representing the remote
 663      *         endpoint of this socket, or {@code null} if it is
 664      *         not connected yet.
 665      * @see #getInetAddress()
 666      * @see #getPort()
 667      * @see #connect(SocketAddress)
 668      * @since 1.4
 669      */
 670     public SocketAddress getRemoteSocketAddress() {
 671         if (!isConnected())
 672             return null;
 673         return new InetSocketAddress(getInetAddress(), getPort());
 674     }
 675 
 676     /**
 677      * Returns the address of the endpoint this socket is bound to.
 678      *
 679      * @return a {@code SocketAddress} representing the local endpoint of this
 680      *         socket, or {@code null} if it is closed or not bound yet.
 681      * @see #getLocalAddress()
 682      * @see #getLocalPort()
 683      * @see #bind(SocketAddress)
 684      * @since 1.4
 685      */
 686     public SocketAddress getLocalSocketAddress() {
 687         if (isClosed())
 688             return null;
 689         if (!isBound())
 690             return null;
 691         return new InetSocketAddress(getLocalAddress(), getLocalPort());
 692     }
 693 
 694     /**
 695      * Sends a datagram packet from this socket. The
 696      * {@code DatagramPacket} includes information indicating the
 697      * data to be sent, its length, the IP address of the remote host,
 698      * and the port number on the remote host.
 699      *
 700      * &lt;p&gt;If there is a security manager, and the socket is not currently
 701      * connected to a remote address, this method first performs some
 702      * security checks. First, if {@code p.getAddress().isMulticastAddress()}
 703      * is true, this method calls the
 704      * security manager&#39;s {@code checkMulticast} method
 705      * with {@code p.getAddress()} as its argument.
 706      * If the evaluation of that expression is false,
 707      * this method instead calls the security manager&#39;s
 708      * {@code checkConnect} method with arguments
 709      * {@code p.getAddress().getHostAddress()} and
 710      * {@code p.getPort()}. Each call to a security manager method
 711      * could result in a SecurityException if the operation is not allowed.
 712      *
 713      * @param      p   the {@code DatagramPacket} to be sent.
 714      *
 715      * @throws     IOException  if an I/O error occurs.
 716      * @throws     SecurityException  if a security manager exists and its
 717      *             {@code checkMulticast} or {@code checkConnect}
 718      *             method doesn&#39;t allow the send.
 719      * @throws     PortUnreachableException may be thrown if the socket is connected
 720      *             to a currently unreachable destination. Note, there is no
 721      *             guarantee that the exception will be thrown.
 722      * @throws     java.nio.channels.IllegalBlockingModeException
 723      *             if this socket has an associated channel,
 724      *             and the channel is in non-blocking mode.
 725      * @throws     IllegalArgumentException if the socket is connected,
 726      *             and connected address and packet address differ, or
 727      *             if the socket is not connected and the packet address
 728      *             is not set or if its port is out of range.
 729      *
 730      * @see        java.net.DatagramPacket
 731      * @see        SecurityManager#checkMulticast(InetAddress)
 732      * @see        SecurityManager#checkConnect
 733      * @revised 1.4
 734      * @spec JSR-51
 735      */
 736     public void send(DatagramPacket p) throws IOException  {
 737         synchronized (p) {
 738             if (isClosed())
 739                 throw new SocketException(&quot;Socket is closed&quot;);
 740             InetAddress packetAddress = p.getAddress();
 741             int packetPort = p.getPort();
 742             checkAddress (packetAddress, &quot;send&quot;);
 743             if (connectState == ST_NOT_CONNECTED) {
 744                 if (packetAddress == null) {
 745                     throw new IllegalArgumentException(&quot;Address not set&quot;);
 746                 }
 747                 if (packetPort &lt; 0 || packetPort &gt; 0xFFFF)
 748                     throw new IllegalArgumentException(&quot;port out of range:&quot; + packetPort);
 749                 // check the address is ok with the security manager on every send.
 750                 SecurityManager security = System.getSecurityManager();
 751 
 752                 // The reason you want to synchronize on datagram packet
 753                 // is because you don&#39;t want an applet to change the address
 754                 // while you are trying to send the packet for example
 755                 // after the security check but before the send.
 756                 if (security != null) {
 757                     if (packetAddress.isMulticastAddress()) {
 758                         security.checkMulticast(packetAddress);
 759                     } else {
 760                         security.checkConnect(packetAddress.getHostAddress(),
 761                                 packetPort);
 762                     }
 763                 }
 764             } else {
 765                 // we&#39;re connected
 766                 if (packetAddress == null) {
 767                     p.setAddress(connectedAddress);
 768                     p.setPort(connectedPort);
 769                 } else if ((!packetAddress.equals(connectedAddress)) ||
 770                         packetPort != connectedPort) {
 771                     throw new IllegalArgumentException(&quot;connected address &quot; +
 772                                                        &quot;and packet address&quot; +
 773                                                        &quot; differ&quot;);
 774                 }
 775             }
 776             // Check whether the socket is bound
 777             if (!isBound())
 778                 bind(new InetSocketAddress(0));
 779             // call the  method to send
 780             getImpl().send(p);
 781         }
 782     }
 783 
 784     /**
 785      * Receives a datagram packet from this socket. When this method
 786      * returns, the {@code DatagramPacket}&#39;s buffer is filled with
 787      * the data received. The datagram packet also contains the sender&#39;s
 788      * IP address, and the port number on the sender&#39;s machine.
 789      * &lt;p&gt;
 790      * This method blocks until a datagram is received. The
 791      * {@code length} field of the datagram packet object contains
 792      * the length of the received message. If the message is longer than
 793      * the packet&#39;s length, the message is truncated.
 794      * &lt;p&gt;
 795      * If there is a security manager, and the socket is not currently
 796      * connected to a remote address, a packet cannot be received if the
 797      * security manager&#39;s {@code checkAccept} method does not allow it.
 798      * Datagrams that are not permitted by the security manager are silently
 799      * discarded.
 800      *
 801      * @param      p   the {@code DatagramPacket} into which to place
 802      *                 the incoming data.
 803      * @throws     IOException  if an I/O error occurs.
 804      * @throws     SocketTimeoutException  if setSoTimeout was previously called
 805      *                 and the timeout has expired.
 806      * @throws     PortUnreachableException may be thrown if the socket is connected
 807      *             to a currently unreachable destination. Note, there is no guarantee that the
 808      *             exception will be thrown.
 809      * @throws     java.nio.channels.IllegalBlockingModeException
 810      *             if this socket has an associated channel,
 811      *             and the channel is in non-blocking mode.
 812      * @see        java.net.DatagramPacket
 813      * @see        java.net.DatagramSocket
 814      * @revised 1.4
 815      * @spec JSR-51
 816      */
 817     public synchronized void receive(DatagramPacket p) throws IOException {
 818         synchronized (p) {
 819             if (!isBound())
 820                 bind(new InetSocketAddress(0));
 821             if (connectState == ST_NOT_CONNECTED) {
 822                 // check the address is ok with the security manager before every recv.
 823                 SecurityManager security = System.getSecurityManager();
 824                 if (security != null) {
 825                     while(true) {
 826                         String peekAd = null;
 827                         int peekPort = 0;
 828                         // peek at the packet to see who it is from.
 829                         if (!oldImpl) {
 830                             // We can use the new peekData() API
 831                             DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 832                             peekPort = getImpl().peekData(peekPacket);
 833                             peekAd = peekPacket.getAddress().getHostAddress();
 834                         } else {
 835                             InetAddress adr = new InetAddress();
 836                             peekPort = getImpl().peek(adr);
 837                             peekAd = adr.getHostAddress();
 838                         }
 839                         try {
 840                             security.checkAccept(peekAd, peekPort);
 841                             // security check succeeded - so now break
 842                             // and recv the packet.
 843                             break;
 844                         } catch (SecurityException se) {
 845                             // Throw away the offending packet by consuming
 846                             // it in a tmp buffer.
 847                             DatagramPacket tmp = new DatagramPacket(new byte[1], 1);
 848                             getImpl().receive(tmp);
 849 
 850                             // silently discard the offending packet
 851                             // and continue: unknown/malicious
 852                             // entities on nets should not make
 853                             // runtime throw security exception and
 854                             // disrupt the applet by sending random
 855                             // datagram packets.
 856                             continue;
 857                         }
 858                     } // end of while
 859                 }
 860             }
 861             DatagramPacket tmp = null;
 862             if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {
 863                 // We have to do the filtering the old fashioned way since
 864                 // the native impl doesn&#39;t support connect or the connect
 865                 // via the impl failed, or .. &quot;explicitFilter&quot; may be set when
 866                 // a socket is connected via the impl, for a period of time
 867                 // when packets from other sources might be queued on socket.
 868                 boolean stop = false;
 869                 while (!stop) {
 870                     InetAddress peekAddress = null;
 871                     int peekPort = -1;
 872                     // peek at the packet to see who it is from.
 873                     if (!oldImpl) {
 874                         // We can use the new peekData() API
 875                         DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);
 876                         peekPort = getImpl().peekData(peekPacket);
 877                         peekAddress = peekPacket.getAddress();
 878                     } else {
 879                         // this api only works for IPv4
 880                         peekAddress = new InetAddress();
 881                         peekPort = getImpl().peek(peekAddress);
 882                     }
 883                     if ((!connectedAddress.equals(peekAddress)) ||
 884                         (connectedPort != peekPort)) {
 885                         // throw the packet away and silently continue
 886                         tmp = new DatagramPacket(
 887                                                 new byte[1024], 1024);
 888                         getImpl().receive(tmp);
 889                         if (explicitFilter) {
 890                             if (checkFiltering(tmp)) {
 891                                 stop = true;
 892                             }
 893                         }
 894                     } else {
 895                         stop = true;
 896                     }
 897                 }
 898             }
 899             // If the security check succeeds, or the datagram is
 900             // connected then receive the packet
 901             getImpl().receive(p);
 902             if (explicitFilter &amp;&amp; tmp == null) {
 903                 // packet was not filtered, account for it here
 904                 checkFiltering(p);
 905             }
 906         }
 907     }
 908 
 909     private boolean checkFiltering(DatagramPacket p) throws SocketException {
 910         bytesLeftToFilter -= p.getLength();
 911         if (bytesLeftToFilter &lt;= 0 || getImpl().dataAvailable() &lt;= 0) {
 912             explicitFilter = false;
 913             return true;
 914         }
 915         return false;
 916     }
 917 
 918     /**
 919      * Gets the local address to which the socket is bound.
 920      *
 921      * &lt;p&gt;If there is a security manager, its
 922      * {@code checkConnect} method is first called
 923      * with the host address and {@code -1}
 924      * as its arguments to see if the operation is allowed.
 925      *
 926      * @see SecurityManager#checkConnect
 927      * @return  the local address to which the socket is bound,
 928      *          {@code null} if the socket is closed, or
 929      *          an {@code InetAddress} representing
 930      *          {@link InetAddress#isAnyLocalAddress wildcard}
 931      *          address if either the socket is not bound, or
 932      *          the security manager {@code checkConnect}
 933      *          method does not allow the operation
 934      * @since   1.1
 935      */
 936     public InetAddress getLocalAddress() {
 937         if (isClosed())
 938             return null;
 939         InetAddress in;
 940         try {
 941             in = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);
 942             if (in.isAnyLocalAddress()) {
 943                 in = InetAddress.anyLocalAddress();
 944             }
 945             SecurityManager s = System.getSecurityManager();
 946             if (s != null) {
 947                 s.checkConnect(in.getHostAddress(), -1);
 948             }
 949         } catch (Exception e) {
 950             in = InetAddress.anyLocalAddress(); // &quot;0.0.0.0&quot;
 951         }
 952         return in;
 953     }
 954 
 955     /**
 956      * Returns the port number on the local host to which this socket
 957      * is bound.
 958      *
 959      * @return  the port number on the local host to which this socket is bound,
 960      *          {@code -1} if the socket is closed, or
 961      *          {@code 0} if it is not bound yet.
 962      */
 963     public int getLocalPort() {
 964         if (isClosed())
 965             return -1;
 966         try {
 967             return getImpl().getLocalPort();
 968         } catch (Exception e) {
 969             return 0;
 970         }
 971     }
 972 
 973     /**
 974      * Enable/disable SO_TIMEOUT with the specified timeout, in
 975      * milliseconds. With this option set to a positive timeout value,
 976      * a call to receive() for this DatagramSocket
 977      * will block for only this amount of time.  If the timeout expires,
 978      * a &lt;B&gt;java.net.SocketTimeoutException&lt;/B&gt; is raised, though the
 979      * DatagramSocket is still valid. A timeout of zero is interpreted
 980      * as an infinite timeout.
 981      * The option &lt;B&gt;must&lt;/B&gt; be enabled prior to entering the blocking
 982      * operation to have effect.
 983      *
 984      * @param timeout the specified timeout in milliseconds.
 985      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
 986      * @throws IllegalArgumentException if {@code timeout} is negative
 987      * @since   1.1
 988      * @see #getSoTimeout()
 989      */
 990     public synchronized void setSoTimeout(int timeout) throws SocketException {
 991         if (isClosed())
 992             throw new SocketException(&quot;Socket is closed&quot;);
 993         if (timeout &lt; 0)
 994             throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);
 995         getImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);
 996     }
 997 
 998     /**
 999      * Retrieve setting for SO_TIMEOUT.  0 returns implies that the
1000      * option is disabled (i.e., timeout of infinity).
1001      *
1002      * @return the setting for SO_TIMEOUT
1003      * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.
1004      * @since   1.1
1005      * @see #setSoTimeout(int)
1006      */
1007     public synchronized int getSoTimeout() throws SocketException {
1008         if (isClosed())
1009             throw new SocketException(&quot;Socket is closed&quot;);
1010         if (getImpl() == null)
1011             return 0;
1012         Object o = getImpl().getOption(SocketOptions.SO_TIMEOUT);
1013         /* extra type safety */
1014         if (o instanceof Integer) {
1015             return ((Integer) o).intValue();
1016         } else {
1017             return 0;
1018         }
1019     }
1020 
1021     /**
1022      * Sets the SO_SNDBUF option to the specified value for this
1023      * {@code DatagramSocket}. The SO_SNDBUF option is used by the
1024      * network implementation as a hint to size the underlying
1025      * network I/O buffers. The SO_SNDBUF setting may also be used
1026      * by the network implementation to determine the maximum size
1027      * of the packet that can be sent on this socket.
1028      * &lt;p&gt;
1029      * As SO_SNDBUF is a hint, applications that want to verify
1030      * what size the buffer is should call {@link #getSendBufferSize()}.
1031      * &lt;p&gt;
1032      * Increasing the buffer size may allow multiple outgoing packets
1033      * to be queued by the network implementation when the send rate
1034      * is high.
1035      * &lt;p&gt;
1036      * Note: If {@link #send(DatagramPacket)} is used to send a
1037      * {@code DatagramPacket} that is larger than the setting
1038      * of SO_SNDBUF then it is implementation specific if the
1039      * packet is sent or discarded.
1040      *
1041      * @param size the size to which to set the send buffer
1042      * size. This value must be greater than 0.
1043      *
1044      * @throws    SocketException if there is an error
1045      * in the underlying protocol, such as an UDP error.
1046      * @throws    IllegalArgumentException if the value is 0 or is
1047      * negative.
1048      * @see #getSendBufferSize()
1049      * @since 1.2
1050      */
1051     public synchronized void setSendBufferSize(int size) throws SocketException {
1052         if (!(size &gt; 0)) {
1053             throw new IllegalArgumentException(&quot;negative send size&quot;);
1054         }
1055         if (isClosed())
1056             throw new SocketException(&quot;Socket is closed&quot;);
1057         getImpl().setOption(SocketOptions.SO_SNDBUF, size);
1058     }
1059 
1060     /**
1061      * Get value of the SO_SNDBUF option for this {@code DatagramSocket}, that is the
1062      * buffer size used by the platform for output on this {@code DatagramSocket}.
1063      *
1064      * @return the value of the SO_SNDBUF option for this {@code DatagramSocket}
1065      * @throws    SocketException if there is an error in
1066      * the underlying protocol, such as an UDP error.
1067      * @see #setSendBufferSize
1068      * @since 1.2
1069      */
1070     public synchronized int getSendBufferSize() throws SocketException {
1071         if (isClosed())
1072             throw new SocketException(&quot;Socket is closed&quot;);
1073         int result = 0;
1074         Object o = getImpl().getOption(SocketOptions.SO_SNDBUF);
1075         if (o instanceof Integer) {
1076             result = ((Integer)o).intValue();
1077         }
1078         return result;
1079     }
1080 
1081     /**
1082      * Sets the SO_RCVBUF option to the specified value for this
1083      * {@code DatagramSocket}. The SO_RCVBUF option is used by
1084      * the network implementation as a hint to size the underlying
1085      * network I/O buffers. The SO_RCVBUF setting may also be used
1086      * by the network implementation to determine the maximum size
1087      * of the packet that can be received on this socket.
1088      * &lt;p&gt;
1089      * Because SO_RCVBUF is a hint, applications that want to
1090      * verify what size the buffers were set to should call
1091      * {@link #getReceiveBufferSize()}.
1092      * &lt;p&gt;
1093      * Increasing SO_RCVBUF may allow the network implementation
1094      * to buffer multiple packets when packets arrive faster than
1095      * are being received using {@link #receive(DatagramPacket)}.
1096      * &lt;p&gt;
1097      * Note: It is implementation specific if a packet larger
1098      * than SO_RCVBUF can be received.
1099      *
1100      * @param size the size to which to set the receive buffer
1101      * size. This value must be greater than 0.
1102      *
1103      * @throws    SocketException if there is an error in
1104      * the underlying protocol, such as an UDP error.
1105      * @throws    IllegalArgumentException if the value is 0 or is
1106      * negative.
1107      * @see #getReceiveBufferSize()
1108      * @since 1.2
1109      */
1110     public synchronized void setReceiveBufferSize(int size) throws SocketException {
1111         if (size &lt;= 0) {
1112             throw new IllegalArgumentException(&quot;invalid receive size&quot;);
1113         }
1114         if (isClosed())
1115             throw new SocketException(&quot;Socket is closed&quot;);
1116         getImpl().setOption(SocketOptions.SO_RCVBUF, size);
1117     }
1118 
1119     /**
1120      * Get value of the SO_RCVBUF option for this {@code DatagramSocket}, that is the
1121      * buffer size used by the platform for input on this {@code DatagramSocket}.
1122      *
1123      * @return the value of the SO_RCVBUF option for this {@code DatagramSocket}
1124      * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.
1125      * @see #setReceiveBufferSize(int)
1126      * @since 1.2
1127      */
1128     public synchronized int getReceiveBufferSize() throws SocketException {
1129         if (isClosed())
1130             throw new SocketException(&quot;Socket is closed&quot;);
1131         int result = 0;
1132         Object o = getImpl().getOption(SocketOptions.SO_RCVBUF);
1133         if (o instanceof Integer) {
1134             result = ((Integer)o).intValue();
1135         }
1136         return result;
1137     }
1138 
1139     /**
1140      * Enable/disable the SO_REUSEADDR socket option.
1141      * &lt;p&gt;
1142      * For UDP sockets it may be necessary to bind more than one
1143      * socket to the same socket address. This is typically for the
1144      * purpose of receiving multicast packets
1145      * (See {@link java.net.MulticastSocket}). The
1146      * {@code SO_REUSEADDR} socket option allows multiple
1147      * sockets to be bound to the same socket address if the
1148      * {@code SO_REUSEADDR} socket option is enabled prior
1149      * to binding the socket using {@link #bind(SocketAddress)}.
1150      * &lt;p&gt;
1151      * Note: This functionality is not supported by all existing platforms,
1152      * so it is implementation specific whether this option will be ignored
1153      * or not. However, if it is not supported then
1154      * {@link #getReuseAddress()} will always return {@code false}.
1155      * &lt;p&gt;
1156      * When a {@code DatagramSocket} is created the initial setting
1157      * of {@code SO_REUSEADDR} is disabled.
1158      * &lt;p&gt;
1159      * The behaviour when {@code SO_REUSEADDR} is enabled or
1160      * disabled after a socket is bound (See {@link #isBound()})
1161      * is not defined.
1162      *
1163      * @param on  whether to enable or disable the
1164      * @throws    SocketException if an error occurs enabling or
1165      *            disabling the {@code SO_REUSEADDR} socket option,
1166      *            or the socket is closed.
1167      * @since 1.4
1168      * @see #getReuseAddress()
1169      * @see #bind(SocketAddress)
1170      * @see #isBound()
1171      * @see #isClosed()
1172      */
1173     public synchronized void setReuseAddress(boolean on) throws SocketException {
1174         if (isClosed())
1175             throw new SocketException(&quot;Socket is closed&quot;);
1176         // Integer instead of Boolean for compatibility with older DatagramSocketImpl
1177         if (oldImpl)
1178             getImpl().setOption(SocketOptions.SO_REUSEADDR, on?-1:0);
1179         else
1180             getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));
1181     }
1182 
1183     /**
1184      * Tests if SO_REUSEADDR is enabled.
1185      *
1186      * @return a {@code boolean} indicating whether or not SO_REUSEADDR is enabled.
1187      * @throws    SocketException if there is an error
1188      * in the underlying protocol, such as an UDP error.
1189      * @since   1.4
1190      * @see #setReuseAddress(boolean)
1191      */
1192     public synchronized boolean getReuseAddress() throws SocketException {
1193         if (isClosed())
1194             throw new SocketException(&quot;Socket is closed&quot;);
1195         Object o = getImpl().getOption(SocketOptions.SO_REUSEADDR);
1196         return ((Boolean)o).booleanValue();
1197     }
1198 
1199     /**
1200      * Enable/disable SO_BROADCAST.
1201      *
1202      * &lt;p&gt; Some operating systems may require that the Java virtual machine be
1203      * started with implementation specific privileges to enable this option or
1204      * send broadcast datagrams.
1205      *
1206      * @param  on
1207      *         whether or not to have broadcast turned on.
1208      *
1209      * @throws  SocketException
1210      *          if there is an error in the underlying protocol, such as an UDP
1211      *          error.
1212      *
1213      * @since 1.4
1214      * @see #getBroadcast()
1215      */
1216     public synchronized void setBroadcast(boolean on) throws SocketException {
1217         if (isClosed())
1218             throw new SocketException(&quot;Socket is closed&quot;);
1219         getImpl().setOption(SocketOptions.SO_BROADCAST, Boolean.valueOf(on));
1220     }
1221 
1222     /**
1223      * Tests if SO_BROADCAST is enabled.
1224      * @return a {@code boolean} indicating whether or not SO_BROADCAST is enabled.
1225      * @throws    SocketException if there is an error
1226      * in the underlying protocol, such as an UDP error.
1227      * @since 1.4
1228      * @see #setBroadcast(boolean)
1229      */
1230     public synchronized boolean getBroadcast() throws SocketException {
1231         if (isClosed())
1232             throw new SocketException(&quot;Socket is closed&quot;);
1233         return ((Boolean)(getImpl().getOption(SocketOptions.SO_BROADCAST))).booleanValue();
1234     }
1235 
1236     /**
1237      * Sets traffic class or type-of-service octet in the IP
1238      * datagram header for datagrams sent from this DatagramSocket.
1239      * As the underlying network implementation may ignore this
1240      * value applications should consider it a hint.
1241      *
1242      * &lt;P&gt; The tc &lt;B&gt;must&lt;/B&gt; be in the range {@code 0 &lt;= tc &lt;=
1243      * 255} or an IllegalArgumentException will be thrown.
1244      * &lt;p&gt;Notes:
1245      * &lt;p&gt;For Internet Protocol v4 the value consists of an
1246      * {@code integer}, the least significant 8 bits of which
1247      * represent the value of the TOS octet in IP packets sent by
1248      * the socket.
1249      * RFC 1349 defines the TOS values as follows:
1250      *
1251      * &lt;UL&gt;
1252      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWCOST (0x02)&lt;/CODE&gt;&lt;/LI&gt;
1253      * &lt;LI&gt;&lt;CODE&gt;IPTOS_RELIABILITY (0x04)&lt;/CODE&gt;&lt;/LI&gt;
1254      * &lt;LI&gt;&lt;CODE&gt;IPTOS_THROUGHPUT (0x08)&lt;/CODE&gt;&lt;/LI&gt;
1255      * &lt;LI&gt;&lt;CODE&gt;IPTOS_LOWDELAY (0x10)&lt;/CODE&gt;&lt;/LI&gt;
1256      * &lt;/UL&gt;
1257      * The last low order bit is always ignored as this
1258      * corresponds to the MBZ (must be zero) bit.
1259      * &lt;p&gt;
1260      * Setting bits in the precedence field may result in a
1261      * SocketException indicating that the operation is not
1262      * permitted.
1263      * &lt;p&gt;
1264      * for Internet Protocol v6 {@code tc} is the value that
1265      * would be placed into the sin6_flowinfo field of the IP header.
1266      *
1267      * @param tc        an {@code int} value for the bitset.
1268      * @throws SocketException if there is an error setting the
1269      * traffic class or type-of-service
1270      * @since 1.4
1271      * @see #getTrafficClass
1272      */
1273     public synchronized void setTrafficClass(int tc) throws SocketException {
1274         if (tc &lt; 0 || tc &gt; 255)
1275             throw new IllegalArgumentException(&quot;tc is not in range 0 -- 255&quot;);
1276 
1277         if (isClosed())
1278             throw new SocketException(&quot;Socket is closed&quot;);
1279         try {
1280             getImpl().setOption(SocketOptions.IP_TOS, tc);
1281         } catch (SocketException se) {
1282             // not supported if socket already connected
1283             // Solaris returns error in such cases
1284             if(!isConnected())
1285                 throw se;
1286         }
1287     }
1288 
1289     /**
1290      * Gets traffic class or type-of-service in the IP datagram
1291      * header for packets sent from this DatagramSocket.
1292      * &lt;p&gt;
1293      * As the underlying network implementation may ignore the
1294      * traffic class or type-of-service set using {@link #setTrafficClass(int)}
1295      * this method may return a different value than was previously
1296      * set using the {@link #setTrafficClass(int)} method on this
1297      * DatagramSocket.
1298      *
1299      * @return the traffic class or type-of-service already set
1300      * @throws SocketException if there is an error obtaining the
1301      * traffic class or type-of-service value.
1302      * @since 1.4
1303      * @see #setTrafficClass(int)
1304      */
1305     public synchronized int getTrafficClass() throws SocketException {
1306         if (isClosed())
1307             throw new SocketException(&quot;Socket is closed&quot;);
1308         return ((Integer)(getImpl().getOption(SocketOptions.IP_TOS))).intValue();
1309     }
1310 
1311     /**
1312      * Closes this datagram socket.
1313      * &lt;p&gt;
1314      * Any thread currently blocked in {@link #receive} upon this socket
1315      * will throw a {@link SocketException}.
1316      *
1317      * &lt;p&gt; If this socket has an associated channel then the channel is closed
1318      * as well.
1319      *
1320      * @revised 1.4
1321      * @spec JSR-51
1322      */
1323     public void close() {
1324         synchronized(closeLock) {
1325             if (isClosed())
1326                 return;
1327             impl.close();
1328             closed = true;
1329         }
1330     }
1331 
1332     /**
1333      * Returns whether the socket is closed or not.
1334      *
1335      * @return true if the socket has been closed
1336      * @since 1.4
1337      */
1338     public boolean isClosed() {
1339         synchronized(closeLock) {
1340             return closed;
1341         }
1342     }
1343 
1344     /**
1345      * Returns the unique {@link java.nio.channels.DatagramChannel} object
1346      * associated with this datagram socket, if any.
1347      *
1348      * &lt;p&gt; A datagram socket will have a channel if, and only if, the channel
1349      * itself was created via the {@link java.nio.channels.DatagramChannel#open
1350      * DatagramChannel.open} method.
1351      *
1352      * @return  the datagram channel associated with this datagram socket,
1353      *          or {@code null} if this socket was not created for a channel
1354      *
1355      * @since 1.4
1356      * @spec JSR-51
1357      */
1358     public DatagramChannel getChannel() {
1359         return null;
1360     }
1361 
1362     /**
1363      * User defined factory for all datagram sockets.
1364      */
1365     private static volatile DatagramSocketImplFactory factory;
1366 
1367     /**
1368      * Sets the datagram socket implementation factory for the
1369      * application. The factory can be specified only once.
1370      * &lt;p&gt;
1371      * When an application creates a new datagram socket, the socket
1372      * implementation factory&#39;s {@code createDatagramSocketImpl} method is
1373      * called to create the actual datagram socket implementation.
1374      * &lt;p&gt;
1375      * Passing {@code null} to the method is a no-op unless the factory
1376      * was already set.
1377      *
1378      * &lt;p&gt;If there is a security manager, this method first calls
1379      * the security manager&#39;s {@code checkSetFactory} method
1380      * to ensure the operation is allowed.
1381      * This could result in a SecurityException.
1382      *
1383      * @param      fac   the desired factory.
1384      * @throws     IOException  if an I/O error occurs when setting the
1385      *              datagram socket factory.
1386      * @throws     SocketException  if the factory is already defined.
1387      * @throws     SecurityException  if a security manager exists and its
1388      *             {@code checkSetFactory} method doesn&#39;t allow the operation.
1389      * @see       java.net.DatagramSocketImplFactory#createDatagramSocketImpl()
1390      * @see       SecurityManager#checkSetFactory
1391      * @since 1.3
1392      */
1393     public static synchronized void
1394     setDatagramSocketImplFactory(DatagramSocketImplFactory fac)
1395        throws IOException
1396     {
1397         if (factory != null) {
1398             throw new SocketException(&quot;factory already defined&quot;);
1399         }
1400         SecurityManager security = System.getSecurityManager();
1401         if (security != null) {
1402             security.checkSetFactory();
1403         }
1404         factory = fac;
1405     }
1406 
1407     /**
1408      * Sets the value of a socket option.
1409      *
1410      * @param &lt;T&gt; The type of the socket option value
1411      * @param name The socket option
1412      * @param value The value of the socket option. A value of {@code null}
1413      *              may be valid for some options.
1414      *
1415      * @return this DatagramSocket
1416      *
1417      * @throws UnsupportedOperationException if the datagram socket
1418      *         does not support the option.
1419      *
1420      * @throws IllegalArgumentException if the value is not valid for
1421      *         the option.
1422      *
1423      * @throws IOException if an I/O error occurs, or if the socket is closed.
1424      *
1425      * @throws SecurityException if a security manager is set and if the socket
1426      *         option requires a security permission and if the caller does
1427      *         not have the required permission.
1428      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1429      *         do not require any security permission.
1430      *
1431      * @throws NullPointerException if name is {@code null}
1432      *
1433      * @since 9
1434      */
1435     public &lt;T&gt; DatagramSocket setOption(SocketOption&lt;T&gt; name, T value)
1436         throws IOException
1437     {
1438         Objects.requireNonNull(name);
1439         if (isClosed())
1440             throw new SocketException(&quot;Socket is closed&quot;);
1441         getImpl().setOption(name, value);
1442         return this;
1443     }
1444 
1445     /**
1446      * Returns the value of a socket option.
1447      *
1448      * @param &lt;T&gt; The type of the socket option value
1449      * @param name The socket option
1450      *
1451      * @return The value of the socket option.
1452      *
1453      * @throws UnsupportedOperationException if the datagram socket
1454      *         does not support the option.
1455      *
1456      * @throws IOException if an I/O error occurs, or if the socket is closed.
1457      *
1458      * @throws NullPointerException if name is {@code null}
1459      *
1460      * @throws SecurityException if a security manager is set and if the socket
1461      *         option requires a security permission and if the caller does
1462      *         not have the required permission.
1463      *         {@link java.net.StandardSocketOptions StandardSocketOptions}
1464      *         do not require any security permission.
1465      *
1466      * @since 9
1467      */
1468     public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
1469         Objects.requireNonNull(name);
1470         if (isClosed())
1471             throw new SocketException(&quot;Socket is closed&quot;);
1472         return getImpl().getOption(name);
1473     }
1474 
1475     private static Set&lt;SocketOption&lt;?&gt;&gt; options;
1476     private static boolean optionsSet = false;
1477 
1478     /**
1479      * Returns a set of the socket options supported by this socket.
1480      *
1481      * This method will continue to return the set of options even after
1482      * the socket has been closed.
1483      *
1484      * @return A set of the socket options supported by this socket. This set
1485      *        may be empty if the socket&#39;s DatagramSocketImpl cannot be created.
1486      *
1487      * @since 9
1488      */
1489     public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
1490         synchronized(DatagramSocket.class) {
1491             if (optionsSet) {
1492                 return options;
1493             }
1494             try {
1495                 DatagramSocketImpl impl = getImpl();
1496                 options = Collections.unmodifiableSet(impl.supportedOptions());
1497             } catch (IOException e) {
1498                 options = Collections.emptySet();
1499             }
1500             optionsSet = true;
1501             return options;
1502         }
1503     }
1504 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>