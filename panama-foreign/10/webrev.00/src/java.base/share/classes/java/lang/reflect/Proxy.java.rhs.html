<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/Proxy.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import java.lang.module.ModuleDescriptor;
  29 import java.security.AccessController;
  30 import java.security.PrivilegedAction;
  31 import java.util.Arrays;
  32 import java.util.Collections;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.IdentityHashMap;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Objects;
  39 import java.util.Set;
  40 import java.util.concurrent.atomic.AtomicInteger;
  41 import java.util.concurrent.atomic.AtomicLong;
  42 
  43 import jdk.internal.access.JavaLangAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 import jdk.internal.loader.BootLoader;
  46 import jdk.internal.module.Modules;
  47 import jdk.internal.misc.VM;
  48 import jdk.internal.reflect.CallerSensitive;
  49 import jdk.internal.reflect.Reflection;
  50 import jdk.internal.loader.ClassLoaderValue;
  51 import sun.reflect.misc.ReflectUtil;
  52 import sun.security.action.GetBooleanAction;
  53 import sun.security.action.GetPropertyAction;
  54 import sun.security.util.SecurityConstants;
  55 
  56 import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;
  57 
  58 
  59 /**
  60  *
  61  * {@code Proxy} provides static methods for creating objects that act like instances
  62  * of interfaces but allow for customized method invocation.
  63  * To create a proxy instance for some interface {@code Foo}:
  64  * &lt;pre&gt;{@code
  65  *     InvocationHandler handler = new MyInvocationHandler(...);
  66  *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
  67  *                                          new Class&lt;?&gt;[] { Foo.class },
  68  *                                          handler);
  69  * }&lt;/pre&gt;
  70  *
  71  * &lt;p&gt;
  72  * A &lt;em&gt;proxy class&lt;/em&gt; is a class created at runtime that implements a specified
  73  * list of interfaces, known as &lt;em&gt;proxy interfaces&lt;/em&gt;. A &lt;em&gt;proxy instance&lt;/em&gt;
  74  * is an instance of a proxy class.
  75  *
  76  * Each proxy instance has an associated &lt;i&gt;invocation handler&lt;/i&gt;
  77  * object, which implements the interface {@link InvocationHandler}.
  78  * A method invocation on a proxy instance through one of its proxy
  79  * interfaces will be dispatched to the {@link InvocationHandler#invoke
  80  * invoke} method of the instance&#39;s invocation handler, passing the proxy
  81  * instance, a {@code java.lang.reflect.Method} object identifying
  82  * the method that was invoked, and an array of type {@code Object}
  83  * containing the arguments.  The invocation handler processes the
  84  * encoded method invocation as appropriate and the result that it
  85  * returns will be returned as the result of the method invocation on
  86  * the proxy instance.
  87  *
  88  * &lt;p&gt;A proxy class has the following properties:
  89  *
  90  * &lt;ul&gt;
  91  * &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
  92  * of class names that begin with the string {@code &quot;$Proxy&quot;}
  93  * should be, however, reserved for proxy classes.
  94  *
  95  * &lt;li&gt;The package and module in which a proxy class is defined is specified
  96  * &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.
  97  *
  98  * &lt;li&gt;A proxy class is &lt;em&gt;final and non-abstract&lt;/em&gt;.
  99  *
 100  * &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
 101  *
 102  * &lt;li&gt;A proxy class implements exactly the interfaces specified at its
 103  * creation, in the same order. Invoking {@link Class#getInterfaces() getInterfaces}
 104  * on its {@code Class} object will return an array containing the same
 105  * list of interfaces (in the order specified at its creation), invoking
 106  * {@link Class#getMethods getMethods} on its {@code Class} object will return
 107  * an array of {@code Method} objects that include all of the
 108  * methods in those interfaces, and invoking {@code getMethod} will
 109  * find methods in the proxy interfaces as would be expected.
 110  *
 111  * &lt;li&gt;The {@link java.security.ProtectionDomain} of a proxy class
 112  * is the same as that of system classes loaded by the bootstrap class
 113  * loader, such as {@code java.lang.Object}, because the code for a
 114  * proxy class is generated by trusted system code.  This protection
 115  * domain will typically be granted {@code java.security.AllPermission}.
 116  *
 117  * &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method can be used
 118  * to determine if a given class is a proxy class.
 119  * &lt;/ul&gt;
 120  *
 121  * &lt;p&gt;A proxy instance has the following properties:
 122  *
 123  * &lt;ul&gt;
 124  * &lt;li&gt;Given a proxy instance {@code proxy} and one of the
 125  * interfaces, {@code Foo}, implemented by its proxy class, the
 126  * following expression will return true:
 127  * &lt;pre&gt;
 128  *     {@code proxy instanceof Foo}
 129  * &lt;/pre&gt;
 130  * and the following cast operation will succeed (rather than throwing
 131  * a {@code ClassCastException}):
 132  * &lt;pre&gt;
 133  *     {@code (Foo) proxy}
 134  * &lt;/pre&gt;
 135  *
 136  * &lt;li&gt;Each proxy instance has an associated invocation handler, the one
 137  * that was passed to its constructor.  The static
 138  * {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method
 139  * will return the invocation handler associated with the proxy instance
 140  * passed as its argument.
 141  *
 142  * &lt;li&gt;An interface method invocation on a proxy instance will be
 143  * encoded and dispatched to the invocation handler&#39;s {@link
 144  * InvocationHandler#invoke invoke} method as described in the
 145  * documentation for that method.
 146  *
 147  * &lt;li&gt;An invocation of the {@code hashCode},
 148  * {@code equals}, or {@code toString} methods declared in
 149  * {@code java.lang.Object} on a proxy instance will be encoded and
 150  * dispatched to the invocation handler&#39;s {@code invoke} method in
 151  * the same manner as interface method invocations are encoded and
 152  * dispatched, as described above.  The declaring class of the
 153  * {@code Method} object passed to {@code invoke} will be
 154  * {@code java.lang.Object}.  Other public methods of a proxy
 155  * instance inherited from {@code java.lang.Object} are not
 156  * overridden by a proxy class, so invocations of those methods behave
 157  * like they do for instances of {@code java.lang.Object}.
 158  * &lt;/ul&gt;
 159  *
 160  * &lt;h2&gt;&lt;a id=&quot;membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;&lt;/h2&gt;
 161  *
 162  * The package and module to which a proxy class belongs are chosen such that
 163  * the accessibility of the proxy class is in line with the accessibility of
 164  * the proxy interfaces. Specifically, the package and the module membership
 165  * of a proxy class defined via the
 166  * {@link Proxy#getProxyClass(ClassLoader, Class[])} or
 167  * {@link Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 168  * methods is specified as follows:
 169  *
 170  * &lt;ol&gt;
 171  * &lt;li&gt;If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt;
 172  *     packages:
 173  * &lt;ol type=&quot;a&quot;&gt;
 174  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 175  *     &lt;em&gt;public&lt;/em&gt; in a package exported by the
 176  *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified
 177  *     loader. The name of the package is unspecified.&lt;/li&gt;
 178  *
 179  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 180  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
 181  *     non-public interfaces. All the non-public interfaces must be in the same
 182  *     package and module; otherwise, proxying them is
 183  *     &lt;a href=&quot;#restrictions&quot;&gt;not possible&lt;/a&gt;.&lt;/li&gt;
 184  * &lt;/ol&gt;
 185  * &lt;/li&gt;
 186  * &lt;li&gt;If at least one proxy interface is in a package that is
 187  *     &lt;em&gt;non-exported&lt;/em&gt; and &lt;em&gt;non-open&lt;/em&gt;:
 188  * &lt;ol type=&quot;a&quot;&gt;
 189  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 190  *     &lt;em&gt;public&lt;/em&gt; in a &lt;em&gt;non-exported&lt;/em&gt;, &lt;em&gt;non-open&lt;/em&gt; package of
 191  *     &lt;a href=&quot;#dynamicmodule&quot;&gt;&lt;em&gt;dynamic module&lt;/em&gt;.&lt;/a&gt;
 192  *     The names of the package and the module are unspecified.&lt;/li&gt;
 193  *
 194  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 195  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
 196  *     non-public interfaces. All the non-public interfaces must be in the same
 197  *     package and module; otherwise, proxying them is
 198  *     &lt;a href=&quot;#restrictions&quot;&gt;not possible&lt;/a&gt;.&lt;/li&gt;
 199  * &lt;/ol&gt;
 200  * &lt;/li&gt;
 201  * &lt;/ol&gt;
 202  *
 203  * &lt;p&gt;
 204  * Note that if proxy interfaces with a mix of accessibilities -- for example,
 205  * an exported public interface and a non-exported non-public interface -- are
 206  * proxied by the same instance, then the proxy class&#39;s accessibility is
 207  * governed by the least accessible proxy interface.
 208  * &lt;p&gt;
 209  * Note that it is possible for arbitrary code to obtain access to a proxy class
 210  * in an open package with {@link AccessibleObject#setAccessible setAccessible},
 211  * whereas a proxy class in a non-open package is never accessible to
 212  * code outside the module of the proxy class.
 213  *
 214  * &lt;p&gt;
 215  * Throughout this specification, a &quot;non-exported package&quot; refers to a package
 216  * that is not exported to all modules, and a &quot;non-open package&quot; refers to
 217  * a package that is not open to all modules.  Specifically, these terms refer to
 218  * a package that either is not exported/open by its containing module or is
 219  * exported/open in a qualified fashion by its containing module.
 220  *
 221  * &lt;h3&gt;&lt;a id=&quot;dynamicmodule&quot;&gt;Dynamic Modules&lt;/a&gt;&lt;/h3&gt;
 222  * &lt;p&gt;
 223  * A dynamic module is a named module generated at runtime. A proxy class
 224  * defined in a dynamic module is encapsulated and not accessible to any module.
 225  * Calling {@link Constructor#newInstance(Object...)} on a proxy class in
 226  * a dynamic module will throw {@code IllegalAccessException};
 227  * {@code Proxy.newProxyInstance} method should be used instead.
 228  *
 229  * &lt;p&gt;
 230  * A dynamic module can read the modules of all of the superinterfaces of a proxy
 231  * class and the modules of the types referenced by all public method signatures
 232  * of a proxy class.  If a superinterface or a referenced type, say {@code T},
 233  * is in a non-exported package, the {@linkplain Module module} of {@code T} is
 234  * updated to export the package of {@code T} to the dynamic module.
 235  *
 236  * &lt;h3&gt;Methods Duplicated in Multiple Proxy Interfaces&lt;/h3&gt;
 237  *
 238  * &lt;p&gt;When two or more proxy interfaces contain a method with
 239  * the same name and parameter signature, the order of the proxy class&#39;s
 240  * interfaces becomes significant.  When such a &lt;i&gt;duplicate method&lt;/i&gt;
 241  * is invoked on a proxy instance, the {@code Method} object passed
 242  * to the invocation handler will not necessarily be the one whose
 243  * declaring class is assignable from the reference type of the interface
 244  * that the proxy&#39;s method was invoked through.  This limitation exists
 245  * because the corresponding method implementation in the generated proxy
 246  * class cannot determine which interface it was invoked through.
 247  * Therefore, when a duplicate method is invoked on a proxy instance,
 248  * the {@code Method} object for the method in the foremost interface
 249  * that contains the method (either directly or inherited through a
 250  * superinterface) in the proxy class&#39;s list of interfaces is passed to
 251  * the invocation handler&#39;s {@code invoke} method, regardless of the
 252  * reference type through which the method invocation occurred.
 253  *
 254  * &lt;p&gt;If a proxy interface contains a method with the same name and
 255  * parameter signature as the {@code hashCode}, {@code equals},
 256  * or {@code toString} methods of {@code java.lang.Object},
 257  * when such a method is invoked on a proxy instance, the
 258  * {@code Method} object passed to the invocation handler will have
 259  * {@code java.lang.Object} as its declaring class.  In other words,
 260  * the public, non-final methods of {@code java.lang.Object}
 261  * logically precede all of the proxy interfaces for the determination of
 262  * which {@code Method} object to pass to the invocation handler.
 263  *
 264  * &lt;p&gt;Note also that when a duplicate method is dispatched to an
 265  * invocation handler, the {@code invoke} method may only throw
 266  * checked exception types that are assignable to one of the exception
 267  * types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
 268  * the proxy interfaces that it can be invoked through.  If the
 269  * {@code invoke} method throws a checked exception that is not
 270  * assignable to any of the exception types declared by the method in one
 271  * of the proxy interfaces that it can be invoked through, then an
 272  * unchecked {@code UndeclaredThrowableException} will be thrown by
 273  * the invocation on the proxy instance.  This restriction means that not
 274  * all of the exception types returned by invoking
 275  * {@code getExceptionTypes} on the {@code Method} object
 276  * passed to the {@code invoke} method can necessarily be thrown
 277  * successfully by the {@code invoke} method.
 278  *
 279  * @author      Peter Jones
 280  * @see         InvocationHandler
 281  * @since       1.3
 282  * @revised 9
 283  * @spec JPMS
 284  */
 285 public class Proxy implements java.io.Serializable {
 286     @java.io.Serial
 287     private static final long serialVersionUID = -2222568056686623797L;
 288 
 289     /** parameter types of a proxy class constructor */
 290     private static final Class&lt;?&gt;[] constructorParams =
 291         { InvocationHandler.class };
 292 
 293     /**
 294      * a cache of proxy constructors with
 295      * {@link Constructor#setAccessible(boolean) accessible} flag already set
 296      */
 297     private static final ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache =
 298         new ClassLoaderValue&lt;&gt;();
 299 
<a name="2" id="anc2"></a>






 300     /**
 301      * the invocation handler for this proxy instance.
 302      * @serial
 303      */
 304     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 305     protected InvocationHandler h;
 306 
 307     /**
 308      * Prohibits instantiation.
 309      */
 310     private Proxy() {
 311     }
 312 
 313     /**
 314      * Constructs a new {@code Proxy} instance from a subclass
 315      * (typically, a dynamic proxy class) with the specified value
 316      * for its invocation handler.
 317      *
 318      * @param  h the invocation handler for this proxy instance
 319      *
 320      * @throws NullPointerException if the given invocation handler, {@code h},
 321      *         is {@code null}.
 322      */
 323     protected Proxy(InvocationHandler h) {
 324         Objects.requireNonNull(h);
 325         this.h = h;
 326     }
 327 
 328     /**
 329      * Returns the {@code java.lang.Class} object for a proxy class
 330      * given a class loader and an array of interfaces.  The proxy class
 331      * will be defined by the specified class loader and will implement
 332      * all of the supplied interfaces.  If any of the given interfaces
 333      * is non-public, the proxy class will be non-public. If a proxy class
 334      * for the same permutation of interfaces has already been defined by the
 335      * class loader, then the existing proxy class will be returned; otherwise,
 336      * a proxy class for those interfaces will be generated dynamically
 337      * and defined by the class loader.
 338      *
 339      * @param   loader the class loader to define the proxy class
 340      * @param   interfaces the list of interfaces for the proxy class
 341      *          to implement
 342      * @return  a proxy class that is defined in the specified class loader
 343      *          and that implements the specified interfaces
 344      * @throws  IllegalArgumentException if any of the &lt;a href=&quot;#restrictions&quot;&gt;
 345      *          restrictions&lt;/a&gt; on the parameters are violated
 346      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
 347      *          and any of the following conditions is met:
 348      *          &lt;ul&gt;
 349      *             &lt;li&gt; the given {@code loader} is {@code null} and
 350      *             the caller&#39;s class loader is not {@code null} and the
 351      *             invocation of {@link SecurityManager#checkPermission
 352      *             s.checkPermission} with
 353      *             {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
 354      *             denies access.&lt;/li&gt;
 355      *             &lt;li&gt; for each proxy interface, {@code intf},
 356      *             the caller&#39;s class loader is not the same as or an
 357      *             ancestor of the class loader for {@code intf} and
 358      *             invocation of {@link SecurityManager#checkPackageAccess
 359      *             s.checkPackageAccess()} denies access to {@code intf}.&lt;/li&gt;
 360      *          &lt;/ul&gt;
 361      * @throws  NullPointerException if the {@code interfaces} array
 362      *          argument or any of its elements are {@code null}
 363      *
 364      * @deprecated Proxy classes generated in a named module are encapsulated
 365      *      and not accessible to code outside its module.
 366      *      {@link Constructor#newInstance(Object...) Constructor.newInstance}
 367      *      will throw {@code IllegalAccessException} when it is called on
 368      *      an inaccessible proxy class.
 369      *      Use {@link #newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 370      *      to create a proxy instance instead.
 371      *
 372      * @see &lt;a href=&quot;#membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;
 373      * @revised 9
 374      * @spec JPMS
 375      */
 376     @Deprecated
 377     @CallerSensitive
 378     public static Class&lt;?&gt; getProxyClass(ClassLoader loader,
 379                                          Class&lt;?&gt;... interfaces)
 380         throws IllegalArgumentException
 381     {
 382         Class&lt;?&gt; caller = System.getSecurityManager() == null
 383                               ? null
 384                               : Reflection.getCallerClass();
 385 
 386         return getProxyConstructor(caller, loader, interfaces)
 387             .getDeclaringClass();
 388     }
 389 
 390     /**
 391      * Returns the {@code Constructor} object of a proxy class that takes a
 392      * single argument of type {@link InvocationHandler}, given a class loader
 393      * and an array of interfaces. The returned constructor will have the
 394      * {@link Constructor#setAccessible(boolean) accessible} flag already set.
 395      *
 396      * @param   caller passed from a public-facing @CallerSensitive method if
 397      *                 SecurityManager is set or {@code null} if there&#39;s no
 398      *                 SecurityManager
 399      * @param   loader the class loader to define the proxy class
 400      * @param   interfaces the list of interfaces for the proxy class
 401      *          to implement
 402      * @return  a Constructor of the proxy class taking single
 403      *          {@code InvocationHandler} parameter
 404      */
 405     private static Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,
 406                                                       ClassLoader loader,
 407                                                       Class&lt;?&gt;... interfaces)
 408     {
 409         // optimization for single interface
 410         if (interfaces.length == 1) {
 411             Class&lt;?&gt; intf = interfaces[0];
 412             if (caller != null) {
 413                 checkProxyAccess(caller, loader, intf);
 414             }
 415             return proxyCache.sub(intf).computeIfAbsent(
 416                 loader,
 417                 (ld, clv) -&gt; new ProxyBuilder(ld, clv.key()).build()
 418             );
 419         } else {
 420             // interfaces cloned
 421             final Class&lt;?&gt;[] intfsArray = interfaces.clone();
 422             if (caller != null) {
 423                 checkProxyAccess(caller, loader, intfsArray);
 424             }
 425             final List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);
 426             return proxyCache.sub(intfs).computeIfAbsent(
 427                 loader,
 428                 (ld, clv) -&gt; new ProxyBuilder(ld, clv.key()).build()
 429             );
 430         }
 431     }
 432 
 433     /*
 434      * Check permissions required to create a Proxy class.
 435      *
 436      * To define a proxy class, it performs the access checks as in
 437      * Class.forName (VM will invoke ClassLoader.checkPackageAccess):
 438      * 1. &quot;getClassLoader&quot; permission check if loader == null
 439      * 2. checkPackageAccess on the interfaces it implements
 440      *
 441      * To get a constructor and new instance of a proxy class, it performs
 442      * the package access check on the interfaces it implements
 443      * as in Class.getConstructor.
 444      *
 445      * If an interface is non-public, the proxy class must be defined by
 446      * the defining loader of the interface.  If the caller&#39;s class loader
 447      * is not the same as the defining loader of the interface, the VM
 448      * will throw IllegalAccessError when the generated proxy class is
 449      * being defined.
 450      */
 451     private static void checkProxyAccess(Class&lt;?&gt; caller,
 452                                          ClassLoader loader,
 453                                          Class&lt;?&gt; ... interfaces)
 454     {
 455         SecurityManager sm = System.getSecurityManager();
 456         if (sm != null) {
 457             ClassLoader ccl = caller.getClassLoader();
 458             if (loader == null &amp;&amp; ccl != null) {
 459                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 460             }
 461             ReflectUtil.checkProxyPackageAccess(ccl, interfaces);
 462         }
 463     }
 464 
 465     /**
 466      * Builder for a proxy class.
 467      *
 468      * If the module is not specified in this ProxyBuilder constructor,
 469      * it will map from the given loader and interfaces to the module
 470      * in which the proxy class will be defined.
 471      */
 472     private static final class ProxyBuilder {
 473         private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 474 
 475         // prefix for all proxy class names
 476         private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;
 477 
 478         // next number to use for generation of unique proxy class names
 479         private static final AtomicLong nextUniqueNumber = new AtomicLong();
 480 
 481         // a reverse cache of defined proxy classes
 482         private static final ClassLoaderValue&lt;Boolean&gt; reverseProxyCache =
 483             new ClassLoaderValue&lt;&gt;();
 484 
 485         private static Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) {
 486             String proxyPkg = null;     // package to define proxy class in
 487             int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
 488 
 489             /*
 490              * Record the package of a non-public proxy interface so that the
 491              * proxy class will be defined in the same package.  Verify that
 492              * all non-public proxy interfaces are in the same package.
 493              */
 494             for (Class&lt;?&gt; intf : interfaces) {
 495                 int flags = intf.getModifiers();
 496                 if (!Modifier.isPublic(flags)) {
 497                     accessFlags = Modifier.FINAL;  // non-public, final
 498                     String pkg = intf.getPackageName();
 499                     if (proxyPkg == null) {
 500                         proxyPkg = pkg;
 501                     } else if (!pkg.equals(proxyPkg)) {
 502                         throw new IllegalArgumentException(
 503                                 &quot;non-public interfaces from different packages&quot;);
 504                     }
 505                 }
 506             }
 507 
 508             if (proxyPkg == null) {
 509                 // all proxy interfaces are public
 510                 proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + &quot;.&quot; + m.getName()
 511                                        : PROXY_PACKAGE_PREFIX;
 512             } else if (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) {
 513                 throw new IllegalArgumentException(
 514                         &quot;Unnamed package cannot be added to &quot; + m);
 515             }
 516 
 517             if (m.isNamed()) {
 518                 if (!m.getDescriptor().packages().contains(proxyPkg)) {
 519                     throw new InternalError(proxyPkg + &quot; not exist in &quot; + m.getName());
 520                 }
 521             }
 522 
 523             /*
 524              * Choose a name for the proxy class to generate.
 525              */
 526             long num = nextUniqueNumber.getAndIncrement();
 527             String proxyName = proxyPkg.isEmpty()
 528                                     ? proxyClassNamePrefix + num
 529                                     : proxyPkg + &quot;.&quot; + proxyClassNamePrefix + num;
 530 
 531             ClassLoader loader = getLoader(m);
 532             trace(proxyName, m, loader, interfaces);
 533 
 534             /*
 535              * Generate the specified proxy class.
 536              */
<a name="3" id="anc3"></a><span class="line-modified"> 537             byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);</span>


 538             try {
 539                 Class&lt;?&gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile,
 540                                               null, &quot;__dynamic_proxy__&quot;);
 541                 reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);
 542                 return pc;
 543             } catch (ClassFormatError e) {
 544                 /*
 545                  * A ClassFormatError here means that (barring bugs in the
 546                  * proxy class generation code) there was some other
 547                  * invalid aspect of the arguments supplied to the proxy
 548                  * class creation (such as virtual machine limitations
 549                  * exceeded).
 550                  */
 551                 throw new IllegalArgumentException(e.toString());
 552             }
 553         }
 554 
 555         /**
 556          * Test if given class is a class defined by
 557          * {@link #defineProxyClass(Module, List)}
 558          */
 559         static boolean isProxyClass(Class&lt;?&gt; c) {
 560             return Objects.equals(reverseProxyCache.sub(c).get(c.getClassLoader()),
 561                                   Boolean.TRUE);
 562         }
 563 
 564         private static boolean isExportedType(Class&lt;?&gt; c) {
 565             String pn = c.getPackageName();
 566             return Modifier.isPublic(c.getModifiers()) &amp;&amp; c.getModule().isExported(pn);
 567         }
 568 
 569         private static boolean isPackagePrivateType(Class&lt;?&gt; c) {
 570             return !Modifier.isPublic(c.getModifiers());
 571         }
 572 
 573         private static String toDetails(Class&lt;?&gt; c) {
 574             String access = &quot;unknown&quot;;
 575             if (isExportedType(c)) {
 576                 access = &quot;exported&quot;;
 577             } else if (isPackagePrivateType(c)) {
 578                 access = &quot;package-private&quot;;
 579             } else {
 580                 access = &quot;module-private&quot;;
 581             }
 582             ClassLoader ld = c.getClassLoader();
 583             return String.format(&quot;   %s/%s %s loader %s&quot;,
 584                     c.getModule().getName(), c.getName(), access, ld);
 585         }
 586 
 587         static void trace(String cn,
 588                           Module module,
 589                           ClassLoader loader,
 590                           List&lt;Class&lt;?&gt;&gt; interfaces) {
 591             if (isDebug()) {
 592                 System.err.format(&quot;PROXY: %s/%s defined by %s%n&quot;,
 593                                   module.getName(), cn, loader);
 594             }
 595             if (isDebug(&quot;debug&quot;)) {
 596                 interfaces.forEach(c -&gt; System.out.println(toDetails(c)));
 597             }
 598         }
 599 
 600         private static final String DEBUG =
 601             GetPropertyAction.privilegedGetProperty(&quot;jdk.proxy.debug&quot;, &quot;&quot;);
 602 
 603         private static boolean isDebug() {
 604             return !DEBUG.isEmpty();
 605         }
 606         private static boolean isDebug(String flag) {
 607             return DEBUG.equals(flag);
 608         }
 609 
 610         // ProxyBuilder instance members start here....
 611 
 612         private final List&lt;Class&lt;?&gt;&gt; interfaces;
 613         private final Module module;
 614         ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) {
 615             if (!VM.isModuleSystemInited()) {
 616                 throw new InternalError(&quot;Proxy is not supported until &quot;
 617                         + &quot;module system is fully initialized&quot;);
 618             }
 619             if (interfaces.size() &gt; 65535) {
 620                 throw new IllegalArgumentException(&quot;interface limit exceeded: &quot;
 621                         + interfaces.size());
 622             }
 623 
 624             Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);
 625 
 626             // IAE if violates any restrictions specified in newProxyInstance
 627             validateProxyInterfaces(loader, interfaces, refTypes);
 628 
 629             this.interfaces = interfaces;
 630             this.module = mapToModule(loader, interfaces, refTypes);
 631             assert getLoader(module) == loader;
 632         }
 633 
 634         ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) {
 635             this(loader, Collections.singletonList(intf));
 636         }
 637 
 638         /**
 639          * Generate a proxy class and return its proxy Constructor with
 640          * accessible flag already set. If the target module does not have access
 641          * to any interface types, IllegalAccessError will be thrown by the VM
 642          * at defineClass time.
 643          *
 644          * Must call the checkProxyAccess method to perform permission checks
 645          * before calling this.
 646          */
 647         Constructor&lt;?&gt; build() {
 648             Class&lt;?&gt; proxyClass = defineProxyClass(module, interfaces);
 649             final Constructor&lt;?&gt; cons;
 650             try {
 651                 cons = proxyClass.getConstructor(constructorParams);
 652             } catch (NoSuchMethodException e) {
 653                 throw new InternalError(e.toString(), e);
 654             }
 655             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 656                 public Void run() {
 657                     cons.setAccessible(true);
 658                     return null;
 659                 }
 660             });
 661             return cons;
 662         }
 663 
 664         /**
 665          * Validate the given proxy interfaces and the given referenced types
 666          * are visible to the defining loader.
 667          *
 668          * @throws IllegalArgumentException if it violates the restrictions
 669          *         specified in {@link Proxy#newProxyInstance}
 670          */
 671         private static void validateProxyInterfaces(ClassLoader loader,
 672                                                     List&lt;Class&lt;?&gt;&gt; interfaces,
 673                                                     Set&lt;Class&lt;?&gt;&gt; refTypes)
 674         {
 675             Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.size());
 676             for (Class&lt;?&gt; intf : interfaces) {
 677                 /*
 678                  * Verify that the class loader resolves the name of this
 679                  * interface to the same Class object.
 680                  */
 681                 ensureVisible(loader, intf);
 682 
 683                 /*
 684                  * Verify that the Class object actually represents an
 685                  * interface.
 686                  */
 687                 if (!intf.isInterface()) {
 688                     throw new IllegalArgumentException(intf.getName() + &quot; is not an interface&quot;);
 689                 }
 690 
 691                 /*
 692                  * Verify that this interface is not a duplicate.
 693                  */
 694                 if (interfaceSet.put(intf, Boolean.TRUE) != null) {
 695                     throw new IllegalArgumentException(&quot;repeated interface: &quot; + intf.getName());
 696                 }
 697             }
 698 
 699             for (Class&lt;?&gt; type : refTypes) {
 700                 ensureVisible(loader, type);
 701             }
 702         }
 703 
 704         /*
 705          * Returns all types referenced by all public non-static method signatures of
 706          * the proxy interfaces
 707          */
 708         private static Set&lt;Class&lt;?&gt;&gt; referencedTypes(ClassLoader loader,
 709                                                      List&lt;Class&lt;?&gt;&gt; interfaces) {
 710             var types = new HashSet&lt;Class&lt;?&gt;&gt;();
 711             for (var intf : interfaces) {
 712                 for (Method m : intf.getMethods()) {
 713                     if (!Modifier.isStatic(m.getModifiers())) {
 714                         addElementType(types, m.getReturnType());
 715                         addElementTypes(types, m.getSharedParameterTypes());
 716                         addElementTypes(types, m.getSharedExceptionTypes());
 717                     }
 718                 }
 719             }
 720             return types;
 721         }
 722 
 723         private static void addElementTypes(HashSet&lt;Class&lt;?&gt;&gt; types,
 724                                             Class&lt;?&gt; ... classes) {
 725             for (var cls : classes) {
 726                 addElementType(types, cls);
 727             }
 728         }
 729 
 730         private static void addElementType(HashSet&lt;Class&lt;?&gt;&gt; types,
 731                                            Class&lt;?&gt; cls) {
 732             var type = getElementType(cls);
 733             if (!type.isPrimitive()) {
 734                 types.add(type);
 735             }
 736         }
 737 
 738         /**
 739          * Returns the module that the generated proxy class belongs to.
 740          *
 741          * If all proxy interfaces are public and in exported packages,
 742          * then the proxy class is in unnamed module.
 743          *
 744          * If any of proxy interface is package-private, then the proxy class
 745          * is in the same module of the package-private interface.
 746          *
 747          * If all proxy interfaces are public and at least one in a non-exported
 748          * package, then the proxy class is in a dynamic module in a
 749          * non-exported package.  Reads edge and qualified exports are added
 750          * for dynamic module to access.
 751          */
 752         private static Module mapToModule(ClassLoader loader,
 753                                           List&lt;Class&lt;?&gt;&gt; interfaces,
 754                                           Set&lt;Class&lt;?&gt;&gt; refTypes) {
 755             Map&lt;Class&lt;?&gt;, Module&gt; modulePrivateTypes = new HashMap&lt;&gt;();
 756             Map&lt;Class&lt;?&gt;, Module&gt; packagePrivateTypes = new HashMap&lt;&gt;();
 757             for (Class&lt;?&gt; intf : interfaces) {
 758                 Module m = intf.getModule();
 759                 if (Modifier.isPublic(intf.getModifiers())) {
 760                     // module-private types
 761                     if (!m.isExported(intf.getPackageName())) {
 762                         modulePrivateTypes.put(intf, m);
 763                     }
 764                 } else {
 765                     packagePrivateTypes.put(intf, m);
 766                 }
 767             }
 768 
 769             // all proxy interfaces are public and exported, the proxy class
 770             // is in unnamed module.  Such proxy class is accessible to
 771             // any unnamed module and named module that can read unnamed module
 772             if (packagePrivateTypes.isEmpty() &amp;&amp; modulePrivateTypes.isEmpty()) {
 773                 return loader != null ? loader.getUnnamedModule()
 774                                       : BootLoader.getUnnamedModule();
 775             }
 776 
 777             if (packagePrivateTypes.size() &gt; 0) {
 778                 // all package-private types must be in the same runtime package
 779                 // i.e. same package name and same module (named or unnamed)
 780                 //
 781                 // Configuration will fail if M1 and in M2 defined by the same loader
 782                 // and both have the same package p (so no need to check class loader)
 783                 if (packagePrivateTypes.size() &gt; 1 &amp;&amp;
 784                         (packagePrivateTypes.keySet().stream()  // more than one package
 785                                  .map(Class::getPackageName).distinct().count() &gt; 1 ||
 786                          packagePrivateTypes.values().stream()  // or more than one module
 787                                  .distinct().count() &gt; 1)) {
 788                     throw new IllegalArgumentException(
 789                             &quot;non-public interfaces from different packages&quot;);
 790                 }
 791 
 792                 // all package-private types are in the same module (named or unnamed)
 793                 Module target = null;
 794                 for (Module m : packagePrivateTypes.values()) {
 795                     if (getLoader(m) != loader) {
 796                         // the specified loader is not the same class loader
 797                         // of the non-public interface
 798                         throw new IllegalArgumentException(
 799                                 &quot;non-public interface is not defined by the given loader&quot;);
 800                     }
 801                     target = m;
 802                 }
 803 
 804                 // validate if the target module can access all other interfaces
 805                 for (Class&lt;?&gt; intf : interfaces) {
 806                     Module m = intf.getModule();
 807                     if (m == target) continue;
 808 
 809                     if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {
 810                         throw new IllegalArgumentException(target + &quot; can&#39;t access &quot; + intf.getName());
 811                     }
 812                 }
 813 
 814                 // return the module of the package-private interface
 815                 return target;
 816             }
 817 
 818             // All proxy interfaces are public and at least one in a non-exported
 819             // package.  So maps to a dynamic proxy module and add reads edge
 820             // and qualified exports, if necessary
 821             Module target = getDynamicModule(loader);
 822 
 823             // set up proxy class access to proxy interfaces and types
 824             // referenced in the method signature
 825             Set&lt;Class&lt;?&gt;&gt; types = new HashSet&lt;&gt;(interfaces);
 826             types.addAll(refTypes);
 827             for (Class&lt;?&gt; c : types) {
 828                 ensureAccess(target, c);
 829             }
 830             return target;
 831         }
 832 
 833         /*
 834          * Ensure the given module can access the given class.
 835          */
 836         private static void ensureAccess(Module target, Class&lt;?&gt; c) {
 837             Module m = c.getModule();
 838             // add read edge and qualified export for the target module to access
 839             if (!target.canRead(m)) {
 840                 Modules.addReads(target, m);
 841             }
 842             String pn = c.getPackageName();
 843             if (!m.isExported(pn, target)) {
 844                 Modules.addExports(m, pn, target);
 845             }
 846         }
 847 
 848         /*
 849          * Ensure the given class is visible to the class loader.
 850          */
 851         private static void ensureVisible(ClassLoader ld, Class&lt;?&gt; c) {
 852             Class&lt;?&gt; type = null;
 853             try {
 854                 type = Class.forName(c.getName(), false, ld);
 855             } catch (ClassNotFoundException e) {
 856             }
 857             if (type != c) {
 858                 throw new IllegalArgumentException(c.getName() +
 859                         &quot; referenced from a method is not visible from class loader&quot;);
 860             }
 861         }
 862 
 863         private static Class&lt;?&gt; getElementType(Class&lt;?&gt; type) {
 864             Class&lt;?&gt; e = type;
 865             while (e.isArray()) {
 866                 e = e.getComponentType();
 867             }
 868             return e;
 869         }
 870 
 871         private static final ClassLoaderValue&lt;Module&gt; dynProxyModules =
 872             new ClassLoaderValue&lt;&gt;();
 873         private static final AtomicInteger counter = new AtomicInteger();
 874 
 875         /*
 876          * Define a dynamic module for the generated proxy classes in
 877          * a non-exported package named com.sun.proxy.$MODULE.
 878          *
 879          * Each class loader will have one dynamic module.
 880          */
 881         private static Module getDynamicModule(ClassLoader loader) {
 882             return dynProxyModules.computeIfAbsent(loader, (ld, clv) -&gt; {
 883                 // create a dynamic module and setup module access
 884                 String mn = &quot;jdk.proxy&quot; + counter.incrementAndGet();
 885                 String pn = PROXY_PACKAGE_PREFIX + &quot;.&quot; + mn;
 886                 ModuleDescriptor descriptor =
 887                     ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))
 888                                     .packages(Set.of(pn))
 889                                     .build();
 890                 Module m = Modules.defineModule(ld, descriptor, null);
 891                 Modules.addReads(m, Proxy.class.getModule());
 892                 // java.base to create proxy instance
 893                 Modules.addExports(m, pn, Object.class.getModule());
 894                 return m;
 895             });
 896         }
 897     }
 898 
 899     /**
 900      * Returns a proxy instance for the specified interfaces
 901      * that dispatches method invocations to the specified invocation
 902      * handler.
 903      * &lt;p&gt;
 904      * &lt;a id=&quot;restrictions&quot;&gt;{@code IllegalArgumentException} will be thrown
 905      * if any of the following restrictions is violated:&lt;/a&gt;
 906      * &lt;ul&gt;
 907      * &lt;li&gt;All of {@code Class} objects in the given {@code interfaces} array
 908      * must represent interfaces, not classes or primitive types.
 909      *
 910      * &lt;li&gt;No two elements in the {@code interfaces} array may
 911      * refer to identical {@code Class} objects.
 912      *
 913      * &lt;li&gt;All of the interface types must be visible by name through the
 914      * specified class loader. In other words, for class loader
 915      * {@code cl} and every interface {@code i}, the following
 916      * expression must be true:&lt;p&gt;
 917      * {@code Class.forName(i.getName(), false, cl) == i}
 918      *
 919      * &lt;li&gt;All of the types referenced by all
 920      * public method signatures of the specified interfaces
 921      * and those inherited by their superinterfaces
 922      * must be visible by name through the specified class loader.
 923      *
 924      * &lt;li&gt;All non-public interfaces must be in the same package
 925      * and module, defined by the specified class loader and
 926      * the module of the non-public interfaces can access all of
 927      * the interface types; otherwise, it would not be possible for
 928      * the proxy class to implement all of the interfaces,
 929      * regardless of what package it is defined in.
 930      *
 931      * &lt;li&gt;For any set of member methods of the specified interfaces
 932      * that have the same signature:
 933      * &lt;ul&gt;
 934      * &lt;li&gt;If the return type of any of the methods is a primitive
 935      * type or void, then all of the methods must have that same
 936      * return type.
 937      * &lt;li&gt;Otherwise, one of the methods must have a return type that
 938      * is assignable to all of the return types of the rest of the
 939      * methods.
 940      * &lt;/ul&gt;
 941      *
 942      * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
 943      * on classes by the virtual machine.  For example, the VM may limit
 944      * the number of interfaces that a class may implement to 65535; in
 945      * that case, the size of the {@code interfaces} array must not
 946      * exceed 65535.
 947      * &lt;/ul&gt;
 948      *
 949      * &lt;p&gt;Note that the order of the specified proxy interfaces is
 950      * significant: two requests for a proxy class with the same combination
 951      * of interfaces but in a different order will result in two distinct
 952      * proxy classes.
 953      *
 954      * @param   loader the class loader to define the proxy class
 955      * @param   interfaces the list of interfaces for the proxy class
 956      *          to implement
 957      * @param   h the invocation handler to dispatch method invocations to
 958      * @return  a proxy instance with the specified invocation handler of a
 959      *          proxy class that is defined by the specified class loader
 960      *          and that implements the specified interfaces
 961      * @throws  IllegalArgumentException if any of the &lt;a href=&quot;#restrictions&quot;&gt;
 962      *          restrictions&lt;/a&gt; on the parameters are violated
 963      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
 964      *          and any of the following conditions is met:
 965      *          &lt;ul&gt;
 966      *          &lt;li&gt; the given {@code loader} is {@code null} and
 967      *               the caller&#39;s class loader is not {@code null} and the
 968      *               invocation of {@link SecurityManager#checkPermission
 969      *               s.checkPermission} with
 970      *               {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
 971      *               denies access;&lt;/li&gt;
 972      *          &lt;li&gt; for each proxy interface, {@code intf},
 973      *               the caller&#39;s class loader is not the same as or an
 974      *               ancestor of the class loader for {@code intf} and
 975      *               invocation of {@link SecurityManager#checkPackageAccess
 976      *               s.checkPackageAccess()} denies access to {@code intf};&lt;/li&gt;
 977      *          &lt;li&gt; any of the given proxy interfaces is non-public and the
 978      *               caller class is not in the same {@linkplain Package runtime package}
 979      *               as the non-public interface and the invocation of
 980      *               {@link SecurityManager#checkPermission s.checkPermission} with
 981      *               {@code ReflectPermission(&quot;newProxyInPackage.{package name}&quot;)}
 982      *               permission denies access.&lt;/li&gt;
 983      *          &lt;/ul&gt;
 984      * @throws  NullPointerException if the {@code interfaces} array
 985      *          argument or any of its elements are {@code null}, or
 986      *          if the invocation handler, {@code h}, is
 987      *          {@code null}
 988      *
 989      * @see &lt;a href=&quot;#membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;
 990      * @revised 9
 991      * @spec JPMS
 992      */
 993     @CallerSensitive
 994     public static Object newProxyInstance(ClassLoader loader,
 995                                           Class&lt;?&gt;[] interfaces,
 996                                           InvocationHandler h) {
 997         Objects.requireNonNull(h);
 998 
 999         final Class&lt;?&gt; caller = System.getSecurityManager() == null
1000                                     ? null
1001                                     : Reflection.getCallerClass();
1002 
1003         /*
1004          * Look up or generate the designated proxy class and its constructor.
1005          */
1006         Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);
1007 
1008         return newProxyInstance(caller, cons, h);
1009     }
1010 
1011     private static Object newProxyInstance(Class&lt;?&gt; caller, // null if no SecurityManager
1012                                            Constructor&lt;?&gt; cons,
1013                                            InvocationHandler h) {
1014         /*
1015          * Invoke its constructor with the designated invocation handler.
1016          */
1017         try {
1018             if (caller != null) {
1019                 checkNewProxyPermission(caller, cons.getDeclaringClass());
1020             }
1021 
1022             return cons.newInstance(new Object[]{h});
1023         } catch (IllegalAccessException | InstantiationException e) {
1024             throw new InternalError(e.toString(), e);
1025         } catch (InvocationTargetException e) {
1026             Throwable t = e.getCause();
1027             if (t instanceof RuntimeException) {
1028                 throw (RuntimeException) t;
1029             } else {
1030                 throw new InternalError(t.toString(), t);
1031             }
1032         }
1033     }
1034 
1035     private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) {
1036         SecurityManager sm = System.getSecurityManager();
1037         if (sm != null) {
1038             if (ReflectUtil.isNonPublicProxyClass(proxyClass)) {
1039                 ClassLoader ccl = caller.getClassLoader();
1040                 ClassLoader pcl = proxyClass.getClassLoader();
1041 
1042                 // do permission check if the caller is in a different runtime package
1043                 // of the proxy class
1044                 String pkg = proxyClass.getPackageName();
1045                 String callerPkg = caller.getPackageName();
1046 
1047                 if (pcl != ccl || !pkg.equals(callerPkg)) {
1048                     sm.checkPermission(new ReflectPermission(&quot;newProxyInPackage.&quot; + pkg));
1049                 }
1050             }
1051         }
1052     }
1053 
1054     /**
1055      * Returns the class loader for the given module.
1056      */
1057     private static ClassLoader getLoader(Module m) {
1058         PrivilegedAction&lt;ClassLoader&gt; pa = m::getClassLoader;
1059         return AccessController.doPrivileged(pa);
1060     }
1061 
1062     /**
1063      * Returns true if the given class is a proxy class.
1064      *
1065      * @implNote The reliability of this method is important for the ability
1066      * to use it to make security decisions, so its implementation should
1067      * not just test if the class in question extends {@code Proxy}.
1068      *
1069      * @param   cl the class to test
1070      * @return  {@code true} if the class is a proxy class and
1071      *          {@code false} otherwise
1072      * @throws  NullPointerException if {@code cl} is {@code null}
1073      *
1074      * @revised 9
1075      * @spec JPMS
1076      */
1077     public static boolean isProxyClass(Class&lt;?&gt; cl) {
1078         return Proxy.class.isAssignableFrom(cl) &amp;&amp; ProxyBuilder.isProxyClass(cl);
1079     }
1080 
1081     /**
1082      * Returns the invocation handler for the specified proxy instance.
1083      *
1084      * @param   proxy the proxy instance to return the invocation handler for
1085      * @return  the invocation handler for the proxy instance
1086      * @throws  IllegalArgumentException if the argument is not a
1087      *          proxy instance
1088      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
1089      *          and the caller&#39;s class loader is not the same as or an
1090      *          ancestor of the class loader for the invocation handler
1091      *          and invocation of {@link SecurityManager#checkPackageAccess
1092      *          s.checkPackageAccess()} denies access to the invocation
1093      *          handler&#39;s class.
1094      */
1095     @CallerSensitive
1096     public static InvocationHandler getInvocationHandler(Object proxy)
1097         throws IllegalArgumentException
1098     {
1099         /*
1100          * Verify that the object is actually a proxy instance.
1101          */
1102         if (!isProxyClass(proxy.getClass())) {
1103             throw new IllegalArgumentException(&quot;not a proxy instance&quot;);
1104         }
1105 
1106         final Proxy p = (Proxy) proxy;
1107         final InvocationHandler ih = p.h;
1108         if (System.getSecurityManager() != null) {
1109             Class&lt;?&gt; ihClass = ih.getClass();
1110             Class&lt;?&gt; caller = Reflection.getCallerClass();
1111             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),
1112                                                     ihClass.getClassLoader()))
1113             {
1114                 ReflectUtil.checkPackageAccess(ihClass);
1115             }
1116         }
1117 
1118         return ih;
1119     }
1120 
1121     private static final String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;
1122 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>