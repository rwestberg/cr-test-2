<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/reflect/Proxy.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import java.lang.module.ModuleDescriptor;
  29 import java.security.AccessController;
  30 import java.security.PrivilegedAction;
  31 import java.util.Arrays;
  32 import java.util.Collections;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.IdentityHashMap;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Objects;
  39 import java.util.Set;
  40 import java.util.concurrent.atomic.AtomicInteger;
  41 import java.util.concurrent.atomic.AtomicLong;
  42 
  43 import jdk.internal.access.JavaLangAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 import jdk.internal.loader.BootLoader;
  46 import jdk.internal.module.Modules;
  47 import jdk.internal.misc.VM;
  48 import jdk.internal.reflect.CallerSensitive;
  49 import jdk.internal.reflect.Reflection;
  50 import jdk.internal.loader.ClassLoaderValue;
  51 import sun.reflect.misc.ReflectUtil;
  52 import sun.security.action.GetBooleanAction;
  53 import sun.security.action.GetPropertyAction;
  54 import sun.security.util.SecurityConstants;
  55 
  56 import static java.lang.module.ModuleDescriptor.Modifier.SYNTHETIC;
  57 
  58 
  59 /**
  60  *
  61  * {@code Proxy} provides static methods for creating objects that act like instances
  62  * of interfaces but allow for customized method invocation.
  63  * To create a proxy instance for some interface {@code Foo}:
  64  * &lt;pre&gt;{@code
  65  *     InvocationHandler handler = new MyInvocationHandler(...);
  66  *     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
  67  *                                          new Class&lt;?&gt;[] { Foo.class },
  68  *                                          handler);
  69  * }&lt;/pre&gt;
  70  *
  71  * &lt;p&gt;
  72  * A &lt;em&gt;proxy class&lt;/em&gt; is a class created at runtime that implements a specified
  73  * list of interfaces, known as &lt;em&gt;proxy interfaces&lt;/em&gt;. A &lt;em&gt;proxy instance&lt;/em&gt;
  74  * is an instance of a proxy class.
  75  *
  76  * Each proxy instance has an associated &lt;i&gt;invocation handler&lt;/i&gt;
  77  * object, which implements the interface {@link InvocationHandler}.
  78  * A method invocation on a proxy instance through one of its proxy
  79  * interfaces will be dispatched to the {@link InvocationHandler#invoke
  80  * invoke} method of the instance&#39;s invocation handler, passing the proxy
  81  * instance, a {@code java.lang.reflect.Method} object identifying
  82  * the method that was invoked, and an array of type {@code Object}
  83  * containing the arguments.  The invocation handler processes the
  84  * encoded method invocation as appropriate and the result that it
  85  * returns will be returned as the result of the method invocation on
  86  * the proxy instance.
  87  *
  88  * &lt;p&gt;A proxy class has the following properties:
  89  *
  90  * &lt;ul&gt;
  91  * &lt;li&gt;The unqualified name of a proxy class is unspecified.  The space
  92  * of class names that begin with the string {@code &quot;$Proxy&quot;}
  93  * should be, however, reserved for proxy classes.
  94  *
  95  * &lt;li&gt;The package and module in which a proxy class is defined is specified
  96  * &lt;a href=&quot;#membership&quot;&gt;below&lt;/a&gt;.
  97  *
  98  * &lt;li&gt;A proxy class is &lt;em&gt;final and non-abstract&lt;/em&gt;.
  99  *
 100  * &lt;li&gt;A proxy class extends {@code java.lang.reflect.Proxy}.
 101  *
 102  * &lt;li&gt;A proxy class implements exactly the interfaces specified at its
 103  * creation, in the same order. Invoking {@link Class#getInterfaces() getInterfaces}
 104  * on its {@code Class} object will return an array containing the same
 105  * list of interfaces (in the order specified at its creation), invoking
 106  * {@link Class#getMethods getMethods} on its {@code Class} object will return
 107  * an array of {@code Method} objects that include all of the
 108  * methods in those interfaces, and invoking {@code getMethod} will
 109  * find methods in the proxy interfaces as would be expected.
 110  *
 111  * &lt;li&gt;The {@link java.security.ProtectionDomain} of a proxy class
 112  * is the same as that of system classes loaded by the bootstrap class
 113  * loader, such as {@code java.lang.Object}, because the code for a
 114  * proxy class is generated by trusted system code.  This protection
 115  * domain will typically be granted {@code java.security.AllPermission}.
 116  *
 117  * &lt;li&gt;The {@link Proxy#isProxyClass Proxy.isProxyClass} method can be used
 118  * to determine if a given class is a proxy class.
 119  * &lt;/ul&gt;
 120  *
 121  * &lt;p&gt;A proxy instance has the following properties:
 122  *
 123  * &lt;ul&gt;
 124  * &lt;li&gt;Given a proxy instance {@code proxy} and one of the
 125  * interfaces, {@code Foo}, implemented by its proxy class, the
 126  * following expression will return true:
 127  * &lt;pre&gt;
 128  *     {@code proxy instanceof Foo}
 129  * &lt;/pre&gt;
 130  * and the following cast operation will succeed (rather than throwing
 131  * a {@code ClassCastException}):
 132  * &lt;pre&gt;
 133  *     {@code (Foo) proxy}
 134  * &lt;/pre&gt;
 135  *
 136  * &lt;li&gt;Each proxy instance has an associated invocation handler, the one
 137  * that was passed to its constructor.  The static
 138  * {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method
 139  * will return the invocation handler associated with the proxy instance
 140  * passed as its argument.
 141  *
 142  * &lt;li&gt;An interface method invocation on a proxy instance will be
 143  * encoded and dispatched to the invocation handler&#39;s {@link
 144  * InvocationHandler#invoke invoke} method as described in the
 145  * documentation for that method.
 146  *
 147  * &lt;li&gt;An invocation of the {@code hashCode},
 148  * {@code equals}, or {@code toString} methods declared in
 149  * {@code java.lang.Object} on a proxy instance will be encoded and
 150  * dispatched to the invocation handler&#39;s {@code invoke} method in
 151  * the same manner as interface method invocations are encoded and
 152  * dispatched, as described above.  The declaring class of the
 153  * {@code Method} object passed to {@code invoke} will be
 154  * {@code java.lang.Object}.  Other public methods of a proxy
 155  * instance inherited from {@code java.lang.Object} are not
 156  * overridden by a proxy class, so invocations of those methods behave
 157  * like they do for instances of {@code java.lang.Object}.
 158  * &lt;/ul&gt;
 159  *
 160  * &lt;h2&gt;&lt;a id=&quot;membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;&lt;/h2&gt;
 161  *
 162  * The package and module to which a proxy class belongs are chosen such that
 163  * the accessibility of the proxy class is in line with the accessibility of
 164  * the proxy interfaces. Specifically, the package and the module membership
 165  * of a proxy class defined via the
 166  * {@link Proxy#getProxyClass(ClassLoader, Class[])} or
 167  * {@link Proxy#newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 168  * methods is specified as follows:
 169  *
 170  * &lt;ol&gt;
 171  * &lt;li&gt;If all the proxy interfaces are in &lt;em&gt;exported&lt;/em&gt; or &lt;em&gt;open&lt;/em&gt;
 172  *     packages:
 173  * &lt;ol type=&quot;a&quot;&gt;
 174  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 175  *     &lt;em&gt;public&lt;/em&gt; in a package exported by the
 176  *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified
 177  *     loader. The name of the package is unspecified.&lt;/li&gt;
 178  *
 179  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 180  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
 181  *     non-public interfaces. All the non-public interfaces must be in the same
 182  *     package and module; otherwise, proxying them is
 183  *     &lt;a href=&quot;#restrictions&quot;&gt;not possible&lt;/a&gt;.&lt;/li&gt;
 184  * &lt;/ol&gt;
 185  * &lt;/li&gt;
 186  * &lt;li&gt;If at least one proxy interface is in a package that is
 187  *     &lt;em&gt;non-exported&lt;/em&gt; and &lt;em&gt;non-open&lt;/em&gt;:
 188  * &lt;ol type=&quot;a&quot;&gt;
 189  * &lt;li&gt;if all the proxy interfaces are &lt;em&gt;public&lt;/em&gt;, then the proxy class is
 190  *     &lt;em&gt;public&lt;/em&gt; in a &lt;em&gt;non-exported&lt;/em&gt;, &lt;em&gt;non-open&lt;/em&gt; package of
 191  *     &lt;a href=&quot;#dynamicmodule&quot;&gt;&lt;em&gt;dynamic module&lt;/em&gt;.&lt;/a&gt;
 192  *     The names of the package and the module are unspecified.&lt;/li&gt;
 193  *
 194  * &lt;li&gt;if at least one of all the proxy interfaces is &lt;em&gt;non-public&lt;/em&gt;, then
 195  *     the proxy class is &lt;em&gt;non-public&lt;/em&gt; in the package and module of the
 196  *     non-public interfaces. All the non-public interfaces must be in the same
 197  *     package and module; otherwise, proxying them is
 198  *     &lt;a href=&quot;#restrictions&quot;&gt;not possible&lt;/a&gt;.&lt;/li&gt;
 199  * &lt;/ol&gt;
 200  * &lt;/li&gt;
 201  * &lt;/ol&gt;
 202  *
 203  * &lt;p&gt;
 204  * Note that if proxy interfaces with a mix of accessibilities -- for example,
 205  * an exported public interface and a non-exported non-public interface -- are
 206  * proxied by the same instance, then the proxy class&#39;s accessibility is
 207  * governed by the least accessible proxy interface.
 208  * &lt;p&gt;
 209  * Note that it is possible for arbitrary code to obtain access to a proxy class
 210  * in an open package with {@link AccessibleObject#setAccessible setAccessible},
 211  * whereas a proxy class in a non-open package is never accessible to
 212  * code outside the module of the proxy class.
 213  *
 214  * &lt;p&gt;
 215  * Throughout this specification, a &quot;non-exported package&quot; refers to a package
 216  * that is not exported to all modules, and a &quot;non-open package&quot; refers to
 217  * a package that is not open to all modules.  Specifically, these terms refer to
 218  * a package that either is not exported/open by its containing module or is
 219  * exported/open in a qualified fashion by its containing module.
 220  *
 221  * &lt;h3&gt;&lt;a id=&quot;dynamicmodule&quot;&gt;Dynamic Modules&lt;/a&gt;&lt;/h3&gt;
 222  * &lt;p&gt;
 223  * A dynamic module is a named module generated at runtime. A proxy class
 224  * defined in a dynamic module is encapsulated and not accessible to any module.
 225  * Calling {@link Constructor#newInstance(Object...)} on a proxy class in
 226  * a dynamic module will throw {@code IllegalAccessException};
 227  * {@code Proxy.newProxyInstance} method should be used instead.
 228  *
 229  * &lt;p&gt;
 230  * A dynamic module can read the modules of all of the superinterfaces of a proxy
 231  * class and the modules of the types referenced by all public method signatures
 232  * of a proxy class.  If a superinterface or a referenced type, say {@code T},
 233  * is in a non-exported package, the {@linkplain Module module} of {@code T} is
 234  * updated to export the package of {@code T} to the dynamic module.
 235  *
 236  * &lt;h3&gt;Methods Duplicated in Multiple Proxy Interfaces&lt;/h3&gt;
 237  *
 238  * &lt;p&gt;When two or more proxy interfaces contain a method with
 239  * the same name and parameter signature, the order of the proxy class&#39;s
 240  * interfaces becomes significant.  When such a &lt;i&gt;duplicate method&lt;/i&gt;
 241  * is invoked on a proxy instance, the {@code Method} object passed
 242  * to the invocation handler will not necessarily be the one whose
 243  * declaring class is assignable from the reference type of the interface
 244  * that the proxy&#39;s method was invoked through.  This limitation exists
 245  * because the corresponding method implementation in the generated proxy
 246  * class cannot determine which interface it was invoked through.
 247  * Therefore, when a duplicate method is invoked on a proxy instance,
 248  * the {@code Method} object for the method in the foremost interface
 249  * that contains the method (either directly or inherited through a
 250  * superinterface) in the proxy class&#39;s list of interfaces is passed to
 251  * the invocation handler&#39;s {@code invoke} method, regardless of the
 252  * reference type through which the method invocation occurred.
 253  *
 254  * &lt;p&gt;If a proxy interface contains a method with the same name and
 255  * parameter signature as the {@code hashCode}, {@code equals},
 256  * or {@code toString} methods of {@code java.lang.Object},
 257  * when such a method is invoked on a proxy instance, the
 258  * {@code Method} object passed to the invocation handler will have
 259  * {@code java.lang.Object} as its declaring class.  In other words,
 260  * the public, non-final methods of {@code java.lang.Object}
 261  * logically precede all of the proxy interfaces for the determination of
 262  * which {@code Method} object to pass to the invocation handler.
 263  *
 264  * &lt;p&gt;Note also that when a duplicate method is dispatched to an
 265  * invocation handler, the {@code invoke} method may only throw
 266  * checked exception types that are assignable to one of the exception
 267  * types in the {@code throws} clause of the method in &lt;i&gt;all&lt;/i&gt; of
 268  * the proxy interfaces that it can be invoked through.  If the
 269  * {@code invoke} method throws a checked exception that is not
 270  * assignable to any of the exception types declared by the method in one
 271  * of the proxy interfaces that it can be invoked through, then an
 272  * unchecked {@code UndeclaredThrowableException} will be thrown by
 273  * the invocation on the proxy instance.  This restriction means that not
 274  * all of the exception types returned by invoking
 275  * {@code getExceptionTypes} on the {@code Method} object
 276  * passed to the {@code invoke} method can necessarily be thrown
 277  * successfully by the {@code invoke} method.
 278  *
 279  * @author      Peter Jones
 280  * @see         InvocationHandler
 281  * @since       1.3
 282  * @revised 9
 283  * @spec JPMS
 284  */
 285 public class Proxy implements java.io.Serializable {
 286     @java.io.Serial
 287     private static final long serialVersionUID = -2222568056686623797L;
 288 
 289     /** parameter types of a proxy class constructor */
 290     private static final Class&lt;?&gt;[] constructorParams =
 291         { InvocationHandler.class };
 292 
 293     /**
 294      * a cache of proxy constructors with
 295      * {@link Constructor#setAccessible(boolean) accessible} flag already set
 296      */
 297     private static final ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache =
 298         new ClassLoaderValue&lt;&gt;();
 299 
 300     /**
 301      * System property to revert to generation of proxy class files for version 1.5 (V49).
 302      * Set to &quot;true&quot; to generate v49 class file format.
 303      */
 304     private static final boolean PROXY_GENERATOR_V49 =
 305             GetBooleanAction.privilegedGetProperty(&quot;jdk.proxy.ProxyGenerator.v49&quot;);
 306 
 307     /**
 308      * the invocation handler for this proxy instance.
 309      * @serial
 310      */
 311     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
 312     protected InvocationHandler h;
 313 
 314     /**
 315      * Prohibits instantiation.
 316      */
 317     private Proxy() {
 318     }
 319 
 320     /**
 321      * Constructs a new {@code Proxy} instance from a subclass
 322      * (typically, a dynamic proxy class) with the specified value
 323      * for its invocation handler.
 324      *
 325      * @param  h the invocation handler for this proxy instance
 326      *
 327      * @throws NullPointerException if the given invocation handler, {@code h},
 328      *         is {@code null}.
 329      */
 330     protected Proxy(InvocationHandler h) {
 331         Objects.requireNonNull(h);
 332         this.h = h;
 333     }
 334 
 335     /**
 336      * Returns the {@code java.lang.Class} object for a proxy class
 337      * given a class loader and an array of interfaces.  The proxy class
 338      * will be defined by the specified class loader and will implement
 339      * all of the supplied interfaces.  If any of the given interfaces
 340      * is non-public, the proxy class will be non-public. If a proxy class
 341      * for the same permutation of interfaces has already been defined by the
 342      * class loader, then the existing proxy class will be returned; otherwise,
 343      * a proxy class for those interfaces will be generated dynamically
 344      * and defined by the class loader.
 345      *
 346      * @param   loader the class loader to define the proxy class
 347      * @param   interfaces the list of interfaces for the proxy class
 348      *          to implement
 349      * @return  a proxy class that is defined in the specified class loader
 350      *          and that implements the specified interfaces
 351      * @throws  IllegalArgumentException if any of the &lt;a href=&quot;#restrictions&quot;&gt;
 352      *          restrictions&lt;/a&gt; on the parameters are violated
 353      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
 354      *          and any of the following conditions is met:
 355      *          &lt;ul&gt;
 356      *             &lt;li&gt; the given {@code loader} is {@code null} and
 357      *             the caller&#39;s class loader is not {@code null} and the
 358      *             invocation of {@link SecurityManager#checkPermission
 359      *             s.checkPermission} with
 360      *             {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
 361      *             denies access.&lt;/li&gt;
 362      *             &lt;li&gt; for each proxy interface, {@code intf},
 363      *             the caller&#39;s class loader is not the same as or an
 364      *             ancestor of the class loader for {@code intf} and
 365      *             invocation of {@link SecurityManager#checkPackageAccess
 366      *             s.checkPackageAccess()} denies access to {@code intf}.&lt;/li&gt;
 367      *          &lt;/ul&gt;
 368      * @throws  NullPointerException if the {@code interfaces} array
 369      *          argument or any of its elements are {@code null}
 370      *
 371      * @deprecated Proxy classes generated in a named module are encapsulated
 372      *      and not accessible to code outside its module.
 373      *      {@link Constructor#newInstance(Object...) Constructor.newInstance}
 374      *      will throw {@code IllegalAccessException} when it is called on
 375      *      an inaccessible proxy class.
 376      *      Use {@link #newProxyInstance(ClassLoader, Class[], InvocationHandler)}
 377      *      to create a proxy instance instead.
 378      *
 379      * @see &lt;a href=&quot;#membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;
 380      * @revised 9
 381      * @spec JPMS
 382      */
 383     @Deprecated
 384     @CallerSensitive
 385     public static Class&lt;?&gt; getProxyClass(ClassLoader loader,
 386                                          Class&lt;?&gt;... interfaces)
 387         throws IllegalArgumentException
 388     {
 389         Class&lt;?&gt; caller = System.getSecurityManager() == null
 390                               ? null
 391                               : Reflection.getCallerClass();
 392 
 393         return getProxyConstructor(caller, loader, interfaces)
 394             .getDeclaringClass();
 395     }
 396 
 397     /**
 398      * Returns the {@code Constructor} object of a proxy class that takes a
 399      * single argument of type {@link InvocationHandler}, given a class loader
 400      * and an array of interfaces. The returned constructor will have the
 401      * {@link Constructor#setAccessible(boolean) accessible} flag already set.
 402      *
 403      * @param   caller passed from a public-facing @CallerSensitive method if
 404      *                 SecurityManager is set or {@code null} if there&#39;s no
 405      *                 SecurityManager
 406      * @param   loader the class loader to define the proxy class
 407      * @param   interfaces the list of interfaces for the proxy class
 408      *          to implement
 409      * @return  a Constructor of the proxy class taking single
 410      *          {@code InvocationHandler} parameter
 411      */
 412     private static Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,
 413                                                       ClassLoader loader,
 414                                                       Class&lt;?&gt;... interfaces)
 415     {
 416         // optimization for single interface
 417         if (interfaces.length == 1) {
 418             Class&lt;?&gt; intf = interfaces[0];
 419             if (caller != null) {
 420                 checkProxyAccess(caller, loader, intf);
 421             }
 422             return proxyCache.sub(intf).computeIfAbsent(
 423                 loader,
 424                 (ld, clv) -&gt; new ProxyBuilder(ld, clv.key()).build()
 425             );
 426         } else {
 427             // interfaces cloned
 428             final Class&lt;?&gt;[] intfsArray = interfaces.clone();
 429             if (caller != null) {
 430                 checkProxyAccess(caller, loader, intfsArray);
 431             }
 432             final List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);
 433             return proxyCache.sub(intfs).computeIfAbsent(
 434                 loader,
 435                 (ld, clv) -&gt; new ProxyBuilder(ld, clv.key()).build()
 436             );
 437         }
 438     }
 439 
 440     /*
 441      * Check permissions required to create a Proxy class.
 442      *
 443      * To define a proxy class, it performs the access checks as in
 444      * Class.forName (VM will invoke ClassLoader.checkPackageAccess):
 445      * 1. &quot;getClassLoader&quot; permission check if loader == null
 446      * 2. checkPackageAccess on the interfaces it implements
 447      *
 448      * To get a constructor and new instance of a proxy class, it performs
 449      * the package access check on the interfaces it implements
 450      * as in Class.getConstructor.
 451      *
 452      * If an interface is non-public, the proxy class must be defined by
 453      * the defining loader of the interface.  If the caller&#39;s class loader
 454      * is not the same as the defining loader of the interface, the VM
 455      * will throw IllegalAccessError when the generated proxy class is
 456      * being defined.
 457      */
 458     private static void checkProxyAccess(Class&lt;?&gt; caller,
 459                                          ClassLoader loader,
 460                                          Class&lt;?&gt; ... interfaces)
 461     {
 462         SecurityManager sm = System.getSecurityManager();
 463         if (sm != null) {
 464             ClassLoader ccl = caller.getClassLoader();
 465             if (loader == null &amp;&amp; ccl != null) {
 466                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 467             }
 468             ReflectUtil.checkProxyPackageAccess(ccl, interfaces);
 469         }
 470     }
 471 
 472     /**
 473      * Builder for a proxy class.
 474      *
 475      * If the module is not specified in this ProxyBuilder constructor,
 476      * it will map from the given loader and interfaces to the module
 477      * in which the proxy class will be defined.
 478      */
 479     private static final class ProxyBuilder {
 480         private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 481 
 482         // prefix for all proxy class names
 483         private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;
 484 
 485         // next number to use for generation of unique proxy class names
 486         private static final AtomicLong nextUniqueNumber = new AtomicLong();
 487 
 488         // a reverse cache of defined proxy classes
 489         private static final ClassLoaderValue&lt;Boolean&gt; reverseProxyCache =
 490             new ClassLoaderValue&lt;&gt;();
 491 
 492         private static Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) {
 493             String proxyPkg = null;     // package to define proxy class in
 494             int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
 495 
 496             /*
 497              * Record the package of a non-public proxy interface so that the
 498              * proxy class will be defined in the same package.  Verify that
 499              * all non-public proxy interfaces are in the same package.
 500              */
 501             for (Class&lt;?&gt; intf : interfaces) {
 502                 int flags = intf.getModifiers();
 503                 if (!Modifier.isPublic(flags)) {
 504                     accessFlags = Modifier.FINAL;  // non-public, final
 505                     String pkg = intf.getPackageName();
 506                     if (proxyPkg == null) {
 507                         proxyPkg = pkg;
 508                     } else if (!pkg.equals(proxyPkg)) {
 509                         throw new IllegalArgumentException(
 510                                 &quot;non-public interfaces from different packages&quot;);
 511                     }
 512                 }
 513             }
 514 
 515             if (proxyPkg == null) {
 516                 // all proxy interfaces are public
 517                 proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + &quot;.&quot; + m.getName()
 518                                        : PROXY_PACKAGE_PREFIX;
 519             } else if (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) {
 520                 throw new IllegalArgumentException(
 521                         &quot;Unnamed package cannot be added to &quot; + m);
 522             }
 523 
 524             if (m.isNamed()) {
 525                 if (!m.getDescriptor().packages().contains(proxyPkg)) {
 526                     throw new InternalError(proxyPkg + &quot; not exist in &quot; + m.getName());
 527                 }
 528             }
 529 
 530             /*
 531              * Choose a name for the proxy class to generate.
 532              */
 533             long num = nextUniqueNumber.getAndIncrement();
 534             String proxyName = proxyPkg.isEmpty()
 535                                     ? proxyClassNamePrefix + num
 536                                     : proxyPkg + &quot;.&quot; + proxyClassNamePrefix + num;
 537 
 538             ClassLoader loader = getLoader(m);
 539             trace(proxyName, m, loader, interfaces);
 540 
 541             /*
 542              * Generate the specified proxy class.
 543              */
 544             byte[] proxyClassFile = PROXY_GENERATOR_V49
 545                     ? ProxyGenerator_v49.generateProxyClass(proxyName, interfaces, accessFlags)
 546                     : ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, accessFlags);
 547             try {
 548                 Class&lt;?&gt; pc = JLA.defineClass(loader, proxyName, proxyClassFile,
 549                                               null, &quot;__dynamic_proxy__&quot;);
 550                 reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);
 551                 return pc;
 552             } catch (ClassFormatError e) {
 553                 /*
 554                  * A ClassFormatError here means that (barring bugs in the
 555                  * proxy class generation code) there was some other
 556                  * invalid aspect of the arguments supplied to the proxy
 557                  * class creation (such as virtual machine limitations
 558                  * exceeded).
 559                  */
 560                 throw new IllegalArgumentException(e.toString());
 561             }
 562         }
 563 
 564         /**
 565          * Test if given class is a class defined by
 566          * {@link #defineProxyClass(Module, List)}
 567          */
 568         static boolean isProxyClass(Class&lt;?&gt; c) {
 569             return Objects.equals(reverseProxyCache.sub(c).get(c.getClassLoader()),
 570                                   Boolean.TRUE);
 571         }
 572 
 573         private static boolean isExportedType(Class&lt;?&gt; c) {
 574             String pn = c.getPackageName();
 575             return Modifier.isPublic(c.getModifiers()) &amp;&amp; c.getModule().isExported(pn);
 576         }
 577 
 578         private static boolean isPackagePrivateType(Class&lt;?&gt; c) {
 579             return !Modifier.isPublic(c.getModifiers());
 580         }
 581 
 582         private static String toDetails(Class&lt;?&gt; c) {
 583             String access = &quot;unknown&quot;;
 584             if (isExportedType(c)) {
 585                 access = &quot;exported&quot;;
 586             } else if (isPackagePrivateType(c)) {
 587                 access = &quot;package-private&quot;;
 588             } else {
 589                 access = &quot;module-private&quot;;
 590             }
 591             ClassLoader ld = c.getClassLoader();
 592             return String.format(&quot;   %s/%s %s loader %s&quot;,
 593                     c.getModule().getName(), c.getName(), access, ld);
 594         }
 595 
 596         static void trace(String cn,
 597                           Module module,
 598                           ClassLoader loader,
 599                           List&lt;Class&lt;?&gt;&gt; interfaces) {
 600             if (isDebug()) {
 601                 System.err.format(&quot;PROXY: %s/%s defined by %s%n&quot;,
 602                                   module.getName(), cn, loader);
 603             }
 604             if (isDebug(&quot;debug&quot;)) {
 605                 interfaces.forEach(c -&gt; System.out.println(toDetails(c)));
 606             }
 607         }
 608 
 609         private static final String DEBUG =
 610             GetPropertyAction.privilegedGetProperty(&quot;jdk.proxy.debug&quot;, &quot;&quot;);
 611 
 612         private static boolean isDebug() {
 613             return !DEBUG.isEmpty();
 614         }
 615         private static boolean isDebug(String flag) {
 616             return DEBUG.equals(flag);
 617         }
 618 
 619         // ProxyBuilder instance members start here....
 620 
 621         private final List&lt;Class&lt;?&gt;&gt; interfaces;
 622         private final Module module;
 623         ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) {
 624             if (!VM.isModuleSystemInited()) {
 625                 throw new InternalError(&quot;Proxy is not supported until &quot;
 626                         + &quot;module system is fully initialized&quot;);
 627             }
 628             if (interfaces.size() &gt; 65535) {
 629                 throw new IllegalArgumentException(&quot;interface limit exceeded: &quot;
 630                         + interfaces.size());
 631             }
 632 
 633             Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);
 634 
 635             // IAE if violates any restrictions specified in newProxyInstance
 636             validateProxyInterfaces(loader, interfaces, refTypes);
 637 
 638             this.interfaces = interfaces;
 639             this.module = mapToModule(loader, interfaces, refTypes);
 640             assert getLoader(module) == loader;
 641         }
 642 
 643         ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) {
 644             this(loader, Collections.singletonList(intf));
 645         }
 646 
 647         /**
 648          * Generate a proxy class and return its proxy Constructor with
 649          * accessible flag already set. If the target module does not have access
 650          * to any interface types, IllegalAccessError will be thrown by the VM
 651          * at defineClass time.
 652          *
 653          * Must call the checkProxyAccess method to perform permission checks
 654          * before calling this.
 655          */
 656         Constructor&lt;?&gt; build() {
 657             Class&lt;?&gt; proxyClass = defineProxyClass(module, interfaces);
 658             final Constructor&lt;?&gt; cons;
 659             try {
 660                 cons = proxyClass.getConstructor(constructorParams);
 661             } catch (NoSuchMethodException e) {
 662                 throw new InternalError(e.toString(), e);
 663             }
 664             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 665                 public Void run() {
 666                     cons.setAccessible(true);
 667                     return null;
 668                 }
 669             });
 670             return cons;
 671         }
 672 
 673         /**
 674          * Validate the given proxy interfaces and the given referenced types
 675          * are visible to the defining loader.
 676          *
 677          * @throws IllegalArgumentException if it violates the restrictions
 678          *         specified in {@link Proxy#newProxyInstance}
 679          */
 680         private static void validateProxyInterfaces(ClassLoader loader,
 681                                                     List&lt;Class&lt;?&gt;&gt; interfaces,
 682                                                     Set&lt;Class&lt;?&gt;&gt; refTypes)
 683         {
 684             Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.size());
 685             for (Class&lt;?&gt; intf : interfaces) {
 686                 /*
 687                  * Verify that the class loader resolves the name of this
 688                  * interface to the same Class object.
 689                  */
 690                 ensureVisible(loader, intf);
 691 
 692                 /*
 693                  * Verify that the Class object actually represents an
 694                  * interface.
 695                  */
 696                 if (!intf.isInterface()) {
 697                     throw new IllegalArgumentException(intf.getName() + &quot; is not an interface&quot;);
 698                 }
 699 
 700                 /*
 701                  * Verify that this interface is not a duplicate.
 702                  */
 703                 if (interfaceSet.put(intf, Boolean.TRUE) != null) {
 704                     throw new IllegalArgumentException(&quot;repeated interface: &quot; + intf.getName());
 705                 }
 706             }
 707 
 708             for (Class&lt;?&gt; type : refTypes) {
 709                 ensureVisible(loader, type);
 710             }
 711         }
 712 
 713         /*
 714          * Returns all types referenced by all public non-static method signatures of
 715          * the proxy interfaces
 716          */
 717         private static Set&lt;Class&lt;?&gt;&gt; referencedTypes(ClassLoader loader,
 718                                                      List&lt;Class&lt;?&gt;&gt; interfaces) {
 719             var types = new HashSet&lt;Class&lt;?&gt;&gt;();
 720             for (var intf : interfaces) {
 721                 for (Method m : intf.getMethods()) {
 722                     if (!Modifier.isStatic(m.getModifiers())) {
 723                         addElementType(types, m.getReturnType());
 724                         addElementTypes(types, m.getSharedParameterTypes());
 725                         addElementTypes(types, m.getSharedExceptionTypes());
 726                     }
 727                 }
 728             }
 729             return types;
 730         }
 731 
 732         private static void addElementTypes(HashSet&lt;Class&lt;?&gt;&gt; types,
 733                                             Class&lt;?&gt; ... classes) {
 734             for (var cls : classes) {
 735                 addElementType(types, cls);
 736             }
 737         }
 738 
 739         private static void addElementType(HashSet&lt;Class&lt;?&gt;&gt; types,
 740                                            Class&lt;?&gt; cls) {
 741             var type = getElementType(cls);
 742             if (!type.isPrimitive()) {
 743                 types.add(type);
 744             }
 745         }
 746 
 747         /**
 748          * Returns the module that the generated proxy class belongs to.
 749          *
 750          * If all proxy interfaces are public and in exported packages,
 751          * then the proxy class is in unnamed module.
 752          *
 753          * If any of proxy interface is package-private, then the proxy class
 754          * is in the same module of the package-private interface.
 755          *
 756          * If all proxy interfaces are public and at least one in a non-exported
 757          * package, then the proxy class is in a dynamic module in a
 758          * non-exported package.  Reads edge and qualified exports are added
 759          * for dynamic module to access.
 760          */
 761         private static Module mapToModule(ClassLoader loader,
 762                                           List&lt;Class&lt;?&gt;&gt; interfaces,
 763                                           Set&lt;Class&lt;?&gt;&gt; refTypes) {
 764             Map&lt;Class&lt;?&gt;, Module&gt; modulePrivateTypes = new HashMap&lt;&gt;();
 765             Map&lt;Class&lt;?&gt;, Module&gt; packagePrivateTypes = new HashMap&lt;&gt;();
 766             for (Class&lt;?&gt; intf : interfaces) {
 767                 Module m = intf.getModule();
 768                 if (Modifier.isPublic(intf.getModifiers())) {
 769                     // module-private types
 770                     if (!m.isExported(intf.getPackageName())) {
 771                         modulePrivateTypes.put(intf, m);
 772                     }
 773                 } else {
 774                     packagePrivateTypes.put(intf, m);
 775                 }
 776             }
 777 
 778             // all proxy interfaces are public and exported, the proxy class
 779             // is in unnamed module.  Such proxy class is accessible to
 780             // any unnamed module and named module that can read unnamed module
 781             if (packagePrivateTypes.isEmpty() &amp;&amp; modulePrivateTypes.isEmpty()) {
 782                 return loader != null ? loader.getUnnamedModule()
 783                                       : BootLoader.getUnnamedModule();
 784             }
 785 
 786             if (packagePrivateTypes.size() &gt; 0) {
 787                 // all package-private types must be in the same runtime package
 788                 // i.e. same package name and same module (named or unnamed)
 789                 //
 790                 // Configuration will fail if M1 and in M2 defined by the same loader
 791                 // and both have the same package p (so no need to check class loader)
 792                 if (packagePrivateTypes.size() &gt; 1 &amp;&amp;
 793                         (packagePrivateTypes.keySet().stream()  // more than one package
 794                                  .map(Class::getPackageName).distinct().count() &gt; 1 ||
 795                          packagePrivateTypes.values().stream()  // or more than one module
 796                                  .distinct().count() &gt; 1)) {
 797                     throw new IllegalArgumentException(
 798                             &quot;non-public interfaces from different packages&quot;);
 799                 }
 800 
 801                 // all package-private types are in the same module (named or unnamed)
 802                 Module target = null;
 803                 for (Module m : packagePrivateTypes.values()) {
 804                     if (getLoader(m) != loader) {
 805                         // the specified loader is not the same class loader
 806                         // of the non-public interface
 807                         throw new IllegalArgumentException(
 808                                 &quot;non-public interface is not defined by the given loader&quot;);
 809                     }
 810                     target = m;
 811                 }
 812 
 813                 // validate if the target module can access all other interfaces
 814                 for (Class&lt;?&gt; intf : interfaces) {
 815                     Module m = intf.getModule();
 816                     if (m == target) continue;
 817 
 818                     if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {
 819                         throw new IllegalArgumentException(target + &quot; can&#39;t access &quot; + intf.getName());
 820                     }
 821                 }
 822 
 823                 // return the module of the package-private interface
 824                 return target;
 825             }
 826 
 827             // All proxy interfaces are public and at least one in a non-exported
 828             // package.  So maps to a dynamic proxy module and add reads edge
 829             // and qualified exports, if necessary
 830             Module target = getDynamicModule(loader);
 831 
 832             // set up proxy class access to proxy interfaces and types
 833             // referenced in the method signature
 834             Set&lt;Class&lt;?&gt;&gt; types = new HashSet&lt;&gt;(interfaces);
 835             types.addAll(refTypes);
 836             for (Class&lt;?&gt; c : types) {
 837                 ensureAccess(target, c);
 838             }
 839             return target;
 840         }
 841 
 842         /*
 843          * Ensure the given module can access the given class.
 844          */
 845         private static void ensureAccess(Module target, Class&lt;?&gt; c) {
 846             Module m = c.getModule();
 847             // add read edge and qualified export for the target module to access
 848             if (!target.canRead(m)) {
 849                 Modules.addReads(target, m);
 850             }
 851             String pn = c.getPackageName();
 852             if (!m.isExported(pn, target)) {
 853                 Modules.addExports(m, pn, target);
 854             }
 855         }
 856 
 857         /*
 858          * Ensure the given class is visible to the class loader.
 859          */
 860         private static void ensureVisible(ClassLoader ld, Class&lt;?&gt; c) {
 861             Class&lt;?&gt; type = null;
 862             try {
 863                 type = Class.forName(c.getName(), false, ld);
 864             } catch (ClassNotFoundException e) {
 865             }
 866             if (type != c) {
 867                 throw new IllegalArgumentException(c.getName() +
 868                         &quot; referenced from a method is not visible from class loader&quot;);
 869             }
 870         }
 871 
 872         private static Class&lt;?&gt; getElementType(Class&lt;?&gt; type) {
 873             Class&lt;?&gt; e = type;
 874             while (e.isArray()) {
 875                 e = e.getComponentType();
 876             }
 877             return e;
 878         }
 879 
 880         private static final ClassLoaderValue&lt;Module&gt; dynProxyModules =
 881             new ClassLoaderValue&lt;&gt;();
 882         private static final AtomicInteger counter = new AtomicInteger();
 883 
 884         /*
 885          * Define a dynamic module for the generated proxy classes in
 886          * a non-exported package named com.sun.proxy.$MODULE.
 887          *
 888          * Each class loader will have one dynamic module.
 889          */
 890         private static Module getDynamicModule(ClassLoader loader) {
 891             return dynProxyModules.computeIfAbsent(loader, (ld, clv) -&gt; {
 892                 // create a dynamic module and setup module access
 893                 String mn = &quot;jdk.proxy&quot; + counter.incrementAndGet();
 894                 String pn = PROXY_PACKAGE_PREFIX + &quot;.&quot; + mn;
 895                 ModuleDescriptor descriptor =
 896                     ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))
 897                                     .packages(Set.of(pn))
 898                                     .build();
 899                 Module m = Modules.defineModule(ld, descriptor, null);
 900                 Modules.addReads(m, Proxy.class.getModule());
 901                 // java.base to create proxy instance
 902                 Modules.addExports(m, pn, Object.class.getModule());
 903                 return m;
 904             });
 905         }
 906     }
 907 
 908     /**
 909      * Returns a proxy instance for the specified interfaces
 910      * that dispatches method invocations to the specified invocation
 911      * handler.
 912      * &lt;p&gt;
 913      * &lt;a id=&quot;restrictions&quot;&gt;{@code IllegalArgumentException} will be thrown
 914      * if any of the following restrictions is violated:&lt;/a&gt;
 915      * &lt;ul&gt;
 916      * &lt;li&gt;All of {@code Class} objects in the given {@code interfaces} array
 917      * must represent interfaces, not classes or primitive types.
 918      *
 919      * &lt;li&gt;No two elements in the {@code interfaces} array may
 920      * refer to identical {@code Class} objects.
 921      *
 922      * &lt;li&gt;All of the interface types must be visible by name through the
 923      * specified class loader. In other words, for class loader
 924      * {@code cl} and every interface {@code i}, the following
 925      * expression must be true:&lt;p&gt;
 926      * {@code Class.forName(i.getName(), false, cl) == i}
 927      *
 928      * &lt;li&gt;All of the types referenced by all
 929      * public method signatures of the specified interfaces
 930      * and those inherited by their superinterfaces
 931      * must be visible by name through the specified class loader.
 932      *
 933      * &lt;li&gt;All non-public interfaces must be in the same package
 934      * and module, defined by the specified class loader and
 935      * the module of the non-public interfaces can access all of
 936      * the interface types; otherwise, it would not be possible for
 937      * the proxy class to implement all of the interfaces,
 938      * regardless of what package it is defined in.
 939      *
 940      * &lt;li&gt;For any set of member methods of the specified interfaces
 941      * that have the same signature:
 942      * &lt;ul&gt;
 943      * &lt;li&gt;If the return type of any of the methods is a primitive
 944      * type or void, then all of the methods must have that same
 945      * return type.
 946      * &lt;li&gt;Otherwise, one of the methods must have a return type that
 947      * is assignable to all of the return types of the rest of the
 948      * methods.
 949      * &lt;/ul&gt;
 950      *
 951      * &lt;li&gt;The resulting proxy class must not exceed any limits imposed
 952      * on classes by the virtual machine.  For example, the VM may limit
 953      * the number of interfaces that a class may implement to 65535; in
 954      * that case, the size of the {@code interfaces} array must not
 955      * exceed 65535.
 956      * &lt;/ul&gt;
 957      *
 958      * &lt;p&gt;Note that the order of the specified proxy interfaces is
 959      * significant: two requests for a proxy class with the same combination
 960      * of interfaces but in a different order will result in two distinct
 961      * proxy classes.
 962      *
 963      * @param   loader the class loader to define the proxy class
 964      * @param   interfaces the list of interfaces for the proxy class
 965      *          to implement
 966      * @param   h the invocation handler to dispatch method invocations to
 967      * @return  a proxy instance with the specified invocation handler of a
 968      *          proxy class that is defined by the specified class loader
 969      *          and that implements the specified interfaces
 970      * @throws  IllegalArgumentException if any of the &lt;a href=&quot;#restrictions&quot;&gt;
 971      *          restrictions&lt;/a&gt; on the parameters are violated
 972      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
 973      *          and any of the following conditions is met:
 974      *          &lt;ul&gt;
 975      *          &lt;li&gt; the given {@code loader} is {@code null} and
 976      *               the caller&#39;s class loader is not {@code null} and the
 977      *               invocation of {@link SecurityManager#checkPermission
 978      *               s.checkPermission} with
 979      *               {@code RuntimePermission(&quot;getClassLoader&quot;)} permission
 980      *               denies access;&lt;/li&gt;
 981      *          &lt;li&gt; for each proxy interface, {@code intf},
 982      *               the caller&#39;s class loader is not the same as or an
 983      *               ancestor of the class loader for {@code intf} and
 984      *               invocation of {@link SecurityManager#checkPackageAccess
 985      *               s.checkPackageAccess()} denies access to {@code intf};&lt;/li&gt;
 986      *          &lt;li&gt; any of the given proxy interfaces is non-public and the
 987      *               caller class is not in the same {@linkplain Package runtime package}
 988      *               as the non-public interface and the invocation of
 989      *               {@link SecurityManager#checkPermission s.checkPermission} with
 990      *               {@code ReflectPermission(&quot;newProxyInPackage.{package name}&quot;)}
 991      *               permission denies access.&lt;/li&gt;
 992      *          &lt;/ul&gt;
 993      * @throws  NullPointerException if the {@code interfaces} array
 994      *          argument or any of its elements are {@code null}, or
 995      *          if the invocation handler, {@code h}, is
 996      *          {@code null}
 997      *
 998      * @see &lt;a href=&quot;#membership&quot;&gt;Package and Module Membership of Proxy Class&lt;/a&gt;
 999      * @revised 9
1000      * @spec JPMS
1001      */
1002     @CallerSensitive
1003     public static Object newProxyInstance(ClassLoader loader,
1004                                           Class&lt;?&gt;[] interfaces,
1005                                           InvocationHandler h) {
1006         Objects.requireNonNull(h);
1007 
1008         final Class&lt;?&gt; caller = System.getSecurityManager() == null
1009                                     ? null
1010                                     : Reflection.getCallerClass();
1011 
1012         /*
1013          * Look up or generate the designated proxy class and its constructor.
1014          */
1015         Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);
1016 
1017         return newProxyInstance(caller, cons, h);
1018     }
1019 
1020     private static Object newProxyInstance(Class&lt;?&gt; caller, // null if no SecurityManager
1021                                            Constructor&lt;?&gt; cons,
1022                                            InvocationHandler h) {
1023         /*
1024          * Invoke its constructor with the designated invocation handler.
1025          */
1026         try {
1027             if (caller != null) {
1028                 checkNewProxyPermission(caller, cons.getDeclaringClass());
1029             }
1030 
1031             return cons.newInstance(new Object[]{h});
1032         } catch (IllegalAccessException | InstantiationException e) {
1033             throw new InternalError(e.toString(), e);
1034         } catch (InvocationTargetException e) {
1035             Throwable t = e.getCause();
1036             if (t instanceof RuntimeException) {
1037                 throw (RuntimeException) t;
1038             } else {
1039                 throw new InternalError(t.toString(), t);
1040             }
1041         }
1042     }
1043 
1044     private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass) {
1045         SecurityManager sm = System.getSecurityManager();
1046         if (sm != null) {
1047             if (ReflectUtil.isNonPublicProxyClass(proxyClass)) {
1048                 ClassLoader ccl = caller.getClassLoader();
1049                 ClassLoader pcl = proxyClass.getClassLoader();
1050 
1051                 // do permission check if the caller is in a different runtime package
1052                 // of the proxy class
1053                 String pkg = proxyClass.getPackageName();
1054                 String callerPkg = caller.getPackageName();
1055 
1056                 if (pcl != ccl || !pkg.equals(callerPkg)) {
1057                     sm.checkPermission(new ReflectPermission(&quot;newProxyInPackage.&quot; + pkg));
1058                 }
1059             }
1060         }
1061     }
1062 
1063     /**
1064      * Returns the class loader for the given module.
1065      */
1066     private static ClassLoader getLoader(Module m) {
1067         PrivilegedAction&lt;ClassLoader&gt; pa = m::getClassLoader;
1068         return AccessController.doPrivileged(pa);
1069     }
1070 
1071     /**
1072      * Returns true if the given class is a proxy class.
1073      *
1074      * @implNote The reliability of this method is important for the ability
1075      * to use it to make security decisions, so its implementation should
1076      * not just test if the class in question extends {@code Proxy}.
1077      *
1078      * @param   cl the class to test
1079      * @return  {@code true} if the class is a proxy class and
1080      *          {@code false} otherwise
1081      * @throws  NullPointerException if {@code cl} is {@code null}
1082      *
1083      * @revised 9
1084      * @spec JPMS
1085      */
1086     public static boolean isProxyClass(Class&lt;?&gt; cl) {
1087         return Proxy.class.isAssignableFrom(cl) &amp;&amp; ProxyBuilder.isProxyClass(cl);
1088     }
1089 
1090     /**
1091      * Returns the invocation handler for the specified proxy instance.
1092      *
1093      * @param   proxy the proxy instance to return the invocation handler for
1094      * @return  the invocation handler for the proxy instance
1095      * @throws  IllegalArgumentException if the argument is not a
1096      *          proxy instance
1097      * @throws  SecurityException if a security manager, &lt;em&gt;s&lt;/em&gt;, is present
1098      *          and the caller&#39;s class loader is not the same as or an
1099      *          ancestor of the class loader for the invocation handler
1100      *          and invocation of {@link SecurityManager#checkPackageAccess
1101      *          s.checkPackageAccess()} denies access to the invocation
1102      *          handler&#39;s class.
1103      */
1104     @CallerSensitive
1105     public static InvocationHandler getInvocationHandler(Object proxy)
1106         throws IllegalArgumentException
1107     {
1108         /*
1109          * Verify that the object is actually a proxy instance.
1110          */
1111         if (!isProxyClass(proxy.getClass())) {
1112             throw new IllegalArgumentException(&quot;not a proxy instance&quot;);
1113         }
1114 
1115         final Proxy p = (Proxy) proxy;
1116         final InvocationHandler ih = p.h;
1117         if (System.getSecurityManager() != null) {
1118             Class&lt;?&gt; ihClass = ih.getClass();
1119             Class&lt;?&gt; caller = Reflection.getCallerClass();
1120             if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),
1121                                                     ihClass.getClassLoader()))
1122             {
1123                 ReflectUtil.checkPackageAccess(ihClass);
1124             }
1125         }
1126 
1127         return ih;
1128     }
1129 
1130     private static final String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;
1131 }
    </pre>
  </body>
</html>