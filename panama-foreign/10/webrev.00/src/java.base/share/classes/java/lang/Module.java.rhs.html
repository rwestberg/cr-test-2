<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Module.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.io.IOException;
  29 import java.io.InputStream;
  30 import java.lang.annotation.Annotation;
  31 import java.lang.module.Configuration;
  32 import java.lang.module.ModuleReference;
  33 import java.lang.module.ModuleDescriptor;
  34 import java.lang.module.ModuleDescriptor.Exports;
  35 import java.lang.module.ModuleDescriptor.Opens;
  36 import java.lang.module.ModuleDescriptor.Version;
  37 import java.lang.module.ResolvedModule;
  38 import java.lang.reflect.AnnotatedElement;
  39 import java.net.URI;
  40 import java.net.URL;
  41 import java.security.AccessController;
  42 import java.security.PrivilegedAction;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Objects;
  49 import java.util.Optional;
  50 import java.util.Set;
  51 import java.util.concurrent.ConcurrentHashMap;
  52 import java.util.function.Function;
  53 import java.util.stream.Collectors;
  54 import java.util.stream.Stream;
  55 
  56 import jdk.internal.loader.BuiltinClassLoader;
  57 import jdk.internal.loader.BootLoader;
  58 import jdk.internal.loader.ClassLoaders;
  59 import jdk.internal.module.IllegalAccessLogger;
  60 import jdk.internal.module.ModuleLoaderMap;
  61 import jdk.internal.module.ServicesCatalog;
  62 import jdk.internal.module.Resources;
  63 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  64 import jdk.internal.org.objectweb.asm.Attribute;
  65 import jdk.internal.org.objectweb.asm.ClassReader;
  66 import jdk.internal.org.objectweb.asm.ClassVisitor;
  67 import jdk.internal.org.objectweb.asm.ClassWriter;
  68 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  69 import jdk.internal.org.objectweb.asm.Opcodes;
  70 import jdk.internal.reflect.CallerSensitive;
  71 import jdk.internal.reflect.Reflection;
  72 import sun.security.util.SecurityConstants;
  73 
  74 /**
  75  * Represents a run-time module, either {@link #isNamed() named} or unnamed.
  76  *
  77  * &lt;p&gt; Named modules have a {@link #getName() name} and are constructed by the
  78  * Java Virtual Machine when a graph of modules is defined to the Java virtual
  79  * machine to create a {@linkplain ModuleLayer module layer}. &lt;/p&gt;
  80  *
  81  * &lt;p&gt; An unnamed module does not have a name. There is an unnamed module for
  82  * each {@link ClassLoader ClassLoader}, obtained by invoking its {@link
  83  * ClassLoader#getUnnamedModule() getUnnamedModule} method. All types that are
  84  * not in a named module are members of their defining class loader&#39;s unnamed
  85  * module. &lt;/p&gt;
  86  *
  87  * &lt;p&gt; The package names that are parameters or returned by methods defined in
  88  * this class are the fully-qualified names of the packages as defined in
  89  * section 6.5.3 of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, for
  90  * example, {@code &quot;java.lang&quot;}. &lt;/p&gt;
  91  *
  92  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a method
  93  * in this class causes a {@link NullPointerException NullPointerException} to
  94  * be thrown. &lt;/p&gt;
  95  *
  96  * @since 9
  97  * @spec JPMS
  98  * @see Class#getModule()
  99  */
 100 
 101 public final class Module implements AnnotatedElement {
 102 
 103     // the layer that contains this module, can be null
 104     private final ModuleLayer layer;
 105 
 106     // module name and loader, these fields are read by VM
 107     private final String name;
 108     private final ClassLoader loader;
 109 
 110     // the module descriptor
 111     private final ModuleDescriptor descriptor;
 112 
 113 
 114     /**
 115      * Creates a new named Module. The resulting Module will be defined to the
 116      * VM but will not read any other modules, will not have any exports setup
 117      * and will not be registered in the service catalog.
 118      */
 119     Module(ModuleLayer layer,
 120            ClassLoader loader,
 121            ModuleDescriptor descriptor,
 122            URI uri)
 123     {
 124         this.layer = layer;
 125         this.name = descriptor.name();
 126         this.loader = loader;
 127         this.descriptor = descriptor;
 128 
 129         // define module to VM
 130 
 131         boolean isOpen = descriptor.isOpen() || descriptor.isAutomatic();
 132         Version version = descriptor.version().orElse(null);
 133         String vs = Objects.toString(version, null);
 134         String loc = Objects.toString(uri, null);
<a name="2" id="anc2"></a><span class="line-modified"> 135         Object[] packages = descriptor.packages().toArray();</span>
 136         defineModule0(this, isOpen, vs, loc, packages);
 137     }
 138 
 139 
 140     /**
 141      * Create the unnamed Module for the given ClassLoader.
 142      *
 143      * @see ClassLoader#getUnnamedModule
 144      */
 145     Module(ClassLoader loader) {
 146         this.layer = null;
 147         this.name = null;
 148         this.loader = loader;
 149         this.descriptor = null;
 150     }
 151 
 152 
 153     /**
 154      * Creates a named module but without defining the module to the VM.
 155      *
 156      * @apiNote This constructor is for VM white-box testing.
 157      */
 158     Module(ClassLoader loader, ModuleDescriptor descriptor) {
 159         this.layer = null;
 160         this.name = descriptor.name();
 161         this.loader = loader;
 162         this.descriptor = descriptor;
 163     }
 164 
 165 
 166     /**
 167      * Returns {@code true} if this module is a named module.
 168      *
 169      * @return {@code true} if this is a named module
 170      *
 171      * @see ClassLoader#getUnnamedModule()
 172      */
 173     public boolean isNamed() {
 174         return name != null;
 175     }
 176 
 177     /**
 178      * Returns the module name or {@code null} if this module is an unnamed
 179      * module.
 180      *
 181      * @return The module name
 182      */
 183     public String getName() {
 184         return name;
 185     }
 186 
 187     /**
 188      * Returns the {@code ClassLoader} for this module.
 189      *
 190      * &lt;p&gt; If there is a security manager then its {@code checkPermission}
 191      * method if first called with a {@code RuntimePermission(&quot;getClassLoader&quot;)}
 192      * permission to check that the caller is allowed to get access to the
 193      * class loader. &lt;/p&gt;
 194      *
 195      * @return The class loader for this module
 196      *
 197      * @throws SecurityException
 198      *         If denied by the security manager
 199      */
 200     public ClassLoader getClassLoader() {
 201         SecurityManager sm = System.getSecurityManager();
 202         if (sm != null) {
 203             sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 204         }
 205         return loader;
 206     }
 207 
 208     /**
 209      * Returns the module descriptor for this module or {@code null} if this
 210      * module is an unnamed module.
 211      *
 212      * @return The module descriptor for this module
 213      */
 214     public ModuleDescriptor getDescriptor() {
 215         return descriptor;
 216     }
 217 
 218     /**
 219      * Returns the module layer that contains this module or {@code null} if
 220      * this module is not in a module layer.
 221      *
 222      * A module layer contains named modules and therefore this method always
 223      * returns {@code null} when invoked on an unnamed module.
 224      *
 225      * &lt;p&gt; &lt;a href=&quot;reflect/Proxy.html#dynamicmodule&quot;&gt;Dynamic modules&lt;/a&gt; are
 226      * named modules that are generated at runtime. A dynamic module may or may
 227      * not be in a module layer. &lt;/p&gt;
 228      *
 229      * @return The module layer that contains this module
 230      *
 231      * @see java.lang.reflect.Proxy
 232      */
 233     public ModuleLayer getLayer() {
 234         if (isNamed()) {
 235             ModuleLayer layer = this.layer;
 236             if (layer != null)
 237                 return layer;
 238 
 239             // special-case java.base as it is created before the boot layer
 240             if (loader == null &amp;&amp; name.equals(&quot;java.base&quot;)) {
 241                 return ModuleLayer.boot();
 242             }
 243         }
 244         return null;
 245     }
 246 
 247     // --
 248 
 249     // special Module to mean &quot;all unnamed modules&quot;
 250     private static final Module ALL_UNNAMED_MODULE = new Module(null);
 251     private static final Set&lt;Module&gt; ALL_UNNAMED_MODULE_SET = Set.of(ALL_UNNAMED_MODULE);
 252 
 253     // special Module to mean &quot;everyone&quot;
 254     private static final Module EVERYONE_MODULE = new Module(null);
 255     private static final Set&lt;Module&gt; EVERYONE_SET = Set.of(EVERYONE_MODULE);
 256 
 257     /**
 258      * The holder of data structures to support readability, exports, and
 259      * service use added at runtime with the reflective APIs.
 260      */
 261     private static class ReflectionData {
 262         /**
 263          * A module (1st key) reads another module (2nd key)
 264          */
 265         static final WeakPairMap&lt;Module, Module, Boolean&gt; reads =
 266             new WeakPairMap&lt;&gt;();
 267 
 268         /**
 269          * A module (1st key) exports or opens a package to another module
 270          * (2nd key). The map value is a map of package name to a boolean
 271          * that indicates if the package is opened.
 272          */
 273         static final WeakPairMap&lt;Module, Module, Map&lt;String, Boolean&gt;&gt; exports =
 274             new WeakPairMap&lt;&gt;();
 275 
 276         /**
 277          * A module (1st key) uses a service (2nd key)
 278          */
 279         static final WeakPairMap&lt;Module, Class&lt;?&gt;, Boolean&gt; uses =
 280             new WeakPairMap&lt;&gt;();
 281     }
 282 
 283 
 284     // -- readability --
 285 
 286     // the modules that this module reads
 287     private volatile Set&lt;Module&gt; reads;
 288 
 289     /**
 290      * Indicates if this module reads the given module. This method returns
 291      * {@code true} if invoked to test if this module reads itself. It also
 292      * returns {@code true} if invoked on an unnamed module (as unnamed
 293      * modules read all modules).
 294      *
 295      * @param  other
 296      *         The other module
 297      *
 298      * @return {@code true} if this module reads {@code other}
 299      *
 300      * @see #addReads(Module)
 301      */
 302     public boolean canRead(Module other) {
 303         Objects.requireNonNull(other);
 304 
 305         // an unnamed module reads all modules
 306         if (!this.isNamed())
 307             return true;
 308 
 309         // all modules read themselves
 310         if (other == this)
 311             return true;
 312 
 313         // check if this module reads other
 314         if (other.isNamed()) {
 315             Set&lt;Module&gt; reads = this.reads; // volatile read
 316             if (reads != null &amp;&amp; reads.contains(other))
 317                 return true;
 318         }
 319 
 320         // check if this module reads the other module reflectively
 321         if (ReflectionData.reads.containsKeyPair(this, other))
 322             return true;
 323 
 324         // if other is an unnamed module then check if this module reads
 325         // all unnamed modules
 326         if (!other.isNamed()
 327             &amp;&amp; ReflectionData.reads.containsKeyPair(this, ALL_UNNAMED_MODULE))
 328             return true;
 329 
 330         return false;
 331     }
 332 
 333     /**
 334      * If the caller&#39;s module is this module then update this module to read
 335      * the given module.
 336      *
 337      * This method is a no-op if {@code other} is this module (all modules read
 338      * themselves), this module is an unnamed module (as unnamed modules read
 339      * all modules), or this module already reads {@code other}.
 340      *
 341      * @implNote &lt;em&gt;Read edges&lt;/em&gt; added by this method are &lt;em&gt;weak&lt;/em&gt; and
 342      * do not prevent {@code other} from being GC&#39;ed when this module is
 343      * strongly reachable.
 344      *
 345      * @param  other
 346      *         The other module
 347      *
 348      * @return this module
 349      *
 350      * @throws IllegalCallerException
 351      *         If this is a named module and the caller&#39;s module is not this
 352      *         module
 353      *
 354      * @see #canRead
 355      */
 356     @CallerSensitive
 357     public Module addReads(Module other) {
 358         Objects.requireNonNull(other);
 359         if (this.isNamed()) {
 360             Module caller = getCallerModule(Reflection.getCallerClass());
 361             if (caller != this) {
 362                 throw new IllegalCallerException(caller + &quot; != &quot; + this);
 363             }
 364             implAddReads(other, true);
 365         }
 366         return this;
 367     }
 368 
 369     /**
 370      * Updates this module to read another module.
 371      *
 372      * @apiNote Used by the --add-reads command line option.
 373      */
 374     void implAddReads(Module other) {
 375         implAddReads(other, true);
 376     }
 377 
 378     /**
 379      * Updates this module to read all unnamed modules.
 380      *
 381      * @apiNote Used by the --add-reads command line option.
 382      */
 383     void implAddReadsAllUnnamed() {
 384         implAddReads(Module.ALL_UNNAMED_MODULE, true);
 385     }
 386 
 387     /**
 388      * Updates this module to read another module without notifying the VM.
 389      *
 390      * @apiNote This method is for VM white-box testing.
 391      */
 392     void implAddReadsNoSync(Module other) {
 393         implAddReads(other, false);
 394     }
 395 
 396     /**
 397      * Makes the given {@code Module} readable to this module.
 398      *
 399      * If {@code syncVM} is {@code true} then the VM is notified.
 400      */
 401     private void implAddReads(Module other, boolean syncVM) {
 402         Objects.requireNonNull(other);
 403         if (!canRead(other)) {
 404             // update VM first, just in case it fails
 405             if (syncVM) {
 406                 if (other == ALL_UNNAMED_MODULE) {
 407                     addReads0(this, null);
 408                 } else {
 409                     addReads0(this, other);
 410                 }
 411             }
 412 
 413             // add reflective read
 414             ReflectionData.reads.putIfAbsent(this, other, Boolean.TRUE);
 415         }
 416     }
 417 
 418 
 419     // -- exported and open packages --
 420 
 421     // the packages are open to other modules, can be null
 422     // if the value contains EVERYONE_MODULE then the package is open to all
 423     private volatile Map&lt;String, Set&lt;Module&gt;&gt; openPackages;
 424 
 425     // the packages that are exported, can be null
 426     // if the value contains EVERYONE_MODULE then the package is exported to all
 427     private volatile Map&lt;String, Set&lt;Module&gt;&gt; exportedPackages;
 428 
 429     /**
 430      * Returns {@code true} if this module exports the given package to at
 431      * least the given module.
 432      *
 433      * &lt;p&gt; This method returns {@code true} if invoked to test if a package in
 434      * this module is exported to itself. It always returns {@code true} when
 435      * invoked on an unnamed module. A package that is {@link #isOpen open} to
 436      * the given module is considered exported to that module at run-time and
 437      * so this method returns {@code true} if the package is open to the given
 438      * module. &lt;/p&gt;
 439      *
 440      * &lt;p&gt; This method does not check if the given module reads this module. &lt;/p&gt;
 441      *
 442      * @param  pn
 443      *         The package name
 444      * @param  other
 445      *         The other module
 446      *
 447      * @return {@code true} if this module exports the package to at least the
 448      *         given module
 449      *
 450      * @see ModuleDescriptor#exports()
 451      * @see #addExports(String,Module)
 452      */
 453     public boolean isExported(String pn, Module other) {
 454         Objects.requireNonNull(pn);
 455         Objects.requireNonNull(other);
 456         return implIsExportedOrOpen(pn, other, /*open*/false);
 457     }
 458 
 459     /**
 460      * Returns {@code true} if this module has &lt;em&gt;opened&lt;/em&gt; a package to at
 461      * least the given module.
 462      *
 463      * &lt;p&gt; This method returns {@code true} if invoked to test if a package in
 464      * this module is open to itself. It returns {@code true} when invoked on an
 465      * {@link ModuleDescriptor#isOpen open} module with a package in the module.
 466      * It always returns {@code true} when invoked on an unnamed module. &lt;/p&gt;
 467      *
 468      * &lt;p&gt; This method does not check if the given module reads this module. &lt;/p&gt;
 469      *
 470      * @param  pn
 471      *         The package name
 472      * @param  other
 473      *         The other module
 474      *
 475      * @return {@code true} if this module has &lt;em&gt;opened&lt;/em&gt; the package
 476      *         to at least the given module
 477      *
 478      * @see ModuleDescriptor#opens()
 479      * @see #addOpens(String,Module)
 480      * @see java.lang.reflect.AccessibleObject#setAccessible(boolean)
 481      * @see java.lang.invoke.MethodHandles#privateLookupIn
 482      */
 483     public boolean isOpen(String pn, Module other) {
 484         Objects.requireNonNull(pn);
 485         Objects.requireNonNull(other);
 486         return implIsExportedOrOpen(pn, other, /*open*/true);
 487     }
 488 
 489     /**
 490      * Returns {@code true} if this module exports the given package
 491      * unconditionally.
 492      *
 493      * &lt;p&gt; This method always returns {@code true} when invoked on an unnamed
 494      * module. A package that is {@link #isOpen(String) opened} unconditionally
 495      * is considered exported unconditionally at run-time and so this method
 496      * returns {@code true} if the package is opened unconditionally. &lt;/p&gt;
 497      *
 498      * &lt;p&gt; This method does not check if the given module reads this module. &lt;/p&gt;
 499      *
 500      * @param  pn
 501      *         The package name
 502      *
 503      * @return {@code true} if this module exports the package unconditionally
 504      *
 505      * @see ModuleDescriptor#exports()
 506      */
 507     public boolean isExported(String pn) {
 508         Objects.requireNonNull(pn);
 509         return implIsExportedOrOpen(pn, EVERYONE_MODULE, /*open*/false);
 510     }
 511 
 512     /**
 513      * Returns {@code true} if this module has &lt;em&gt;opened&lt;/em&gt; a package
 514      * unconditionally.
 515      *
 516      * &lt;p&gt; This method always returns {@code true} when invoked on an unnamed
 517      * module. Additionally, it always returns {@code true} when invoked on an
 518      * {@link ModuleDescriptor#isOpen open} module with a package in the
 519      * module. &lt;/p&gt;
 520      *
 521      * &lt;p&gt; This method does not check if the given module reads this module. &lt;/p&gt;
 522      *
 523      * @param  pn
 524      *         The package name
 525      *
 526      * @return {@code true} if this module has &lt;em&gt;opened&lt;/em&gt; the package
 527      *         unconditionally
 528      *
 529      * @see ModuleDescriptor#opens()
 530      */
 531     public boolean isOpen(String pn) {
 532         Objects.requireNonNull(pn);
 533         return implIsExportedOrOpen(pn, EVERYONE_MODULE, /*open*/true);
 534     }
 535 
 536 
 537     /**
 538      * Returns {@code true} if this module exports or opens the given package
 539      * to the given module. If the other module is {@code EVERYONE_MODULE} then
 540      * this method tests if the package is exported or opened unconditionally.
 541      */
 542     private boolean implIsExportedOrOpen(String pn, Module other, boolean open) {
 543         // all packages in unnamed modules are open
 544         if (!isNamed())
 545             return true;
 546 
 547         // all packages are exported/open to self
 548         if (other == this &amp;&amp; descriptor.packages().contains(pn))
 549             return true;
 550 
 551         // all packages in open and automatic modules are open
 552         if (descriptor.isOpen() || descriptor.isAutomatic())
 553             return descriptor.packages().contains(pn);
 554 
 555         // exported/opened via module declaration/descriptor
 556         if (isStaticallyExportedOrOpen(pn, other, open))
 557             return true;
 558 
 559         // exported via addExports/addOpens
 560         if (isReflectivelyExportedOrOpen(pn, other, open))
 561             return true;
 562 
 563         // not exported or open to other
 564         return false;
 565     }
 566 
 567     /**
 568      * Returns {@code true} if this module exports or opens a package to
 569      * the given module via its module declaration or CLI options.
 570      */
 571     private boolean isStaticallyExportedOrOpen(String pn, Module other, boolean open) {
 572         // test if package is open to everyone or &lt;other&gt;
 573         Map&lt;String, Set&lt;Module&gt;&gt; openPackages = this.openPackages;
 574         if (openPackages != null &amp;&amp; allows(openPackages.get(pn), other)) {
 575             return true;
 576         }
 577 
 578         if (!open) {
 579             // test package is exported to everyone or &lt;other&gt;
 580             Map&lt;String, Set&lt;Module&gt;&gt; exportedPackages = this.exportedPackages;
 581             if (exportedPackages != null &amp;&amp; allows(exportedPackages.get(pn), other)) {
 582                 return true;
 583             }
 584         }
 585 
 586         return false;
 587     }
 588 
 589     /**
 590      * Returns {@code true} if targets is non-null and contains EVERYONE_MODULE
 591      * or the given module. Also returns true if the given module is an unnamed
 592      * module and targets contains ALL_UNNAMED_MODULE.
 593      */
 594     private boolean allows(Set&lt;Module&gt; targets, Module module) {
 595        if (targets != null) {
 596            if (targets.contains(EVERYONE_MODULE))
 597                return true;
 598            if (module != EVERYONE_MODULE) {
 599                if (targets.contains(module))
 600                    return true;
 601                if (!module.isNamed() &amp;&amp; targets.contains(ALL_UNNAMED_MODULE))
 602                    return true;
 603            }
 604         }
 605         return false;
 606     }
 607 
 608     /**
 609      * Returns {@code true} if this module reflectively exports or opens the
 610      * given package to the given module.
 611      */
 612     private boolean isReflectivelyExportedOrOpen(String pn, Module other, boolean open) {
 613         // exported or open to all modules
 614         Map&lt;String, Boolean&gt; exports = ReflectionData.exports.get(this, EVERYONE_MODULE);
 615         if (exports != null) {
 616             Boolean b = exports.get(pn);
 617             if (b != null) {
 618                 boolean isOpen = b.booleanValue();
 619                 if (!open || isOpen) return true;
 620             }
 621         }
 622 
 623         if (other != EVERYONE_MODULE) {
 624 
 625             // exported or open to other
 626             exports = ReflectionData.exports.get(this, other);
 627             if (exports != null) {
 628                 Boolean b = exports.get(pn);
 629                 if (b != null) {
 630                     boolean isOpen = b.booleanValue();
 631                     if (!open || isOpen) return true;
 632                 }
 633             }
 634 
 635             // other is an unnamed module &amp;&amp; exported or open to all unnamed
 636             if (!other.isNamed()) {
 637                 exports = ReflectionData.exports.get(this, ALL_UNNAMED_MODULE);
 638                 if (exports != null) {
 639                     Boolean b = exports.get(pn);
 640                     if (b != null) {
 641                         boolean isOpen = b.booleanValue();
 642                         if (!open || isOpen) return true;
 643                     }
 644                 }
 645             }
 646 
 647         }
 648 
 649         return false;
 650     }
 651 
 652     /**
 653      * Returns {@code true} if this module reflectively exports the
 654      * given package to the given module.
 655      */
 656     boolean isReflectivelyExported(String pn, Module other) {
 657         return isReflectivelyExportedOrOpen(pn, other, false);
 658     }
 659 
 660     /**
 661      * Returns {@code true} if this module reflectively opens the
 662      * given package to the given module.
 663      */
 664     boolean isReflectivelyOpened(String pn, Module other) {
 665         return isReflectivelyExportedOrOpen(pn, other, true);
 666     }
 667 
 668 
 669     /**
 670      * If the caller&#39;s module is this module then update this module to export
 671      * the given package to the given module.
 672      *
 673      * &lt;p&gt; This method has no effect if the package is already exported (or
 674      * &lt;em&gt;open&lt;/em&gt;) to the given module. &lt;/p&gt;
 675      *
 676      * @apiNote As specified in section 5.4.3 of the &lt;cite&gt;The Java&amp;trade;
 677      * Virtual Machine Specification &lt;/cite&gt;, if an attempt to resolve a
 678      * symbolic reference fails because of a linkage error, then subsequent
 679      * attempts to resolve the reference always fail with the same error that
 680      * was thrown as a result of the initial resolution attempt.
 681      *
 682      * @param  pn
 683      *         The package name
 684      * @param  other
 685      *         The module
 686      *
 687      * @return this module
 688      *
 689      * @throws IllegalArgumentException
 690      *         If {@code pn} is {@code null}, or this is a named module and the
 691      *         package {@code pn} is not a package in this module
 692      * @throws IllegalCallerException
 693      *         If this is a named module and the caller&#39;s module is not this
 694      *         module
 695      *
 696      * @jvms 5.4.3 Resolution
 697      * @see #isExported(String,Module)
 698      */
 699     @CallerSensitive
 700     public Module addExports(String pn, Module other) {
 701         if (pn == null)
 702             throw new IllegalArgumentException(&quot;package is null&quot;);
 703         Objects.requireNonNull(other);
 704 
 705         if (isNamed()) {
 706             Module caller = getCallerModule(Reflection.getCallerClass());
 707             if (caller != this) {
 708                 throw new IllegalCallerException(caller + &quot; != &quot; + this);
 709             }
 710             implAddExportsOrOpens(pn, other, /*open*/false, /*syncVM*/true);
 711         }
 712 
 713         return this;
 714     }
 715 
 716     /**
 717      * If this module has &lt;em&gt;opened&lt;/em&gt; a package to at least the caller
 718      * module then update this module to open the package to the given module.
 719      * Opening a package with this method allows all types in the package,
 720      * and all their members, not just public types and their public members,
 721      * to be reflected on by the given module when using APIs that support
 722      * private access or a way to bypass or suppress default Java language
 723      * access control checks.
 724      *
 725      * &lt;p&gt; This method has no effect if the package is already &lt;em&gt;open&lt;/em&gt;
 726      * to the given module. &lt;/p&gt;
 727      *
 728      * @apiNote This method can be used for cases where a &lt;em&gt;consumer
 729      * module&lt;/em&gt; uses a qualified opens to open a package to an &lt;em&gt;API
 730      * module&lt;/em&gt; but where the reflective access to the members of classes in
 731      * the consumer module is delegated to code in another module. Code in the
 732      * API module can use this method to open the package in the consumer module
 733      * to the other module.
 734      *
 735      * @param  pn
 736      *         The package name
 737      * @param  other
 738      *         The module
 739      *
 740      * @return this module
 741      *
 742      * @throws IllegalArgumentException
 743      *         If {@code pn} is {@code null}, or this is a named module and the
 744      *         package {@code pn} is not a package in this module
 745      * @throws IllegalCallerException
 746      *         If this is a named module and this module has not opened the
 747      *         package to at least the caller&#39;s module
 748      *
 749      * @see #isOpen(String,Module)
 750      * @see java.lang.reflect.AccessibleObject#setAccessible(boolean)
 751      * @see java.lang.invoke.MethodHandles#privateLookupIn
 752      */
 753     @CallerSensitive
 754     public Module addOpens(String pn, Module other) {
 755         if (pn == null)
 756             throw new IllegalArgumentException(&quot;package is null&quot;);
 757         Objects.requireNonNull(other);
 758 
 759         if (isNamed()) {
 760             Module caller = getCallerModule(Reflection.getCallerClass());
 761             if (caller != this &amp;&amp; (caller == null || !isOpen(pn, caller)))
 762                 throw new IllegalCallerException(pn + &quot; is not open to &quot; + caller);
 763             implAddExportsOrOpens(pn, other, /*open*/true, /*syncVM*/true);
 764         }
 765 
 766         return this;
 767     }
 768 
 769 
 770     /**
 771      * Updates this module to export a package unconditionally.
 772      *
 773      * @apiNote This method is for JDK tests only.
 774      */
 775     void implAddExports(String pn) {
 776         implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, false, true);
 777     }
 778 
 779     /**
 780      * Updates this module to export a package to another module.
 781      *
 782      * @apiNote Used by Instrumentation::redefineModule and --add-exports
 783      */
 784     void implAddExports(String pn, Module other) {
 785         implAddExportsOrOpens(pn, other, false, true);
 786     }
 787 
 788     /**
 789      * Updates this module to export a package to all unnamed modules.
 790      *
 791      * @apiNote Used by the --add-exports command line option.
 792      */
 793     void implAddExportsToAllUnnamed(String pn) {
 794         implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, false, true);
 795     }
 796 
 797     /**
 798      * Updates this export to export a package unconditionally without
 799      * notifying the VM.
 800      *
 801      * @apiNote This method is for VM white-box testing.
 802      */
 803     void implAddExportsNoSync(String pn) {
 804         implAddExportsOrOpens(pn.replace(&#39;/&#39;, &#39;.&#39;), Module.EVERYONE_MODULE, false, false);
 805     }
 806 
 807     /**
 808      * Updates a module to export a package to another module without
 809      * notifying the VM.
 810      *
 811      * @apiNote This method is for VM white-box testing.
 812      */
 813     void implAddExportsNoSync(String pn, Module other) {
 814         implAddExportsOrOpens(pn.replace(&#39;/&#39;, &#39;.&#39;), other, false, false);
 815     }
 816 
 817     /**
 818      * Updates this module to open a package unconditionally.
 819      *
 820      * @apiNote This method is for JDK tests only.
 821      */
 822     void implAddOpens(String pn) {
 823         implAddExportsOrOpens(pn, Module.EVERYONE_MODULE, true, true);
 824     }
 825 
 826     /**
 827      * Updates this module to open a package to another module.
 828      *
 829      * @apiNote Used by Instrumentation::redefineModule and --add-opens
 830      */
 831     void implAddOpens(String pn, Module other) {
 832         implAddExportsOrOpens(pn, other, true, true);
 833     }
 834 
 835     /**
 836      * Updates this module to open a package to all unnamed modules.
 837      *
 838      * @apiNote Used by the --add-opens command line option.
 839      */
 840     void implAddOpensToAllUnnamed(String pn) {
 841         implAddExportsOrOpens(pn, Module.ALL_UNNAMED_MODULE, true, true);
 842     }
 843 
 844     /**
 845      * Updates a module to export or open a module to another module.
 846      *
 847      * If {@code syncVM} is {@code true} then the VM is notified.
 848      */
 849     private void implAddExportsOrOpens(String pn,
 850                                        Module other,
 851                                        boolean open,
 852                                        boolean syncVM) {
 853         Objects.requireNonNull(other);
 854         Objects.requireNonNull(pn);
 855 
 856         // all packages are open in unnamed, open, and automatic modules
 857         if (!isNamed() || descriptor.isOpen() || descriptor.isAutomatic())
 858             return;
 859 
 860         // check if the package is already exported/open to other
 861         if (implIsExportedOrOpen(pn, other, open)) {
 862 
 863             // if the package is exported/open for illegal access then we need
 864             // to record that it has also been exported/opened reflectively so
 865             // that the IllegalAccessLogger doesn&#39;t emit a warning.
 866             boolean needToAdd = false;
 867             if (!other.isNamed()) {
 868                 IllegalAccessLogger l = IllegalAccessLogger.illegalAccessLogger();
 869                 if (l != null) {
 870                     if (open) {
 871                         needToAdd = l.isOpenForIllegalAccess(this, pn);
 872                     } else {
 873                         needToAdd = l.isExportedForIllegalAccess(this, pn);
 874                     }
 875                 }
 876             }
 877             if (!needToAdd) {
 878                 // nothing to do
 879                 return;
 880             }
 881         }
 882 
 883         // can only export a package in the module
 884         if (!descriptor.packages().contains(pn)) {
 885             throw new IllegalArgumentException(&quot;package &quot; + pn
 886                                                + &quot; not in contents&quot;);
 887         }
 888 
 889         // update VM first, just in case it fails
 890         if (syncVM) {
 891             if (other == EVERYONE_MODULE) {
 892                 addExportsToAll0(this, pn);
 893             } else if (other == ALL_UNNAMED_MODULE) {
 894                 addExportsToAllUnnamed0(this, pn);
 895             } else {
 896                 addExports0(this, pn, other);
 897             }
 898         }
 899 
 900         // add package name to exports if absent
 901         Map&lt;String, Boolean&gt; map = ReflectionData.exports
 902             .computeIfAbsent(this, other,
 903                              (m1, m2) -&gt; new ConcurrentHashMap&lt;&gt;());
 904         if (open) {
 905             map.put(pn, Boolean.TRUE);  // may need to promote from FALSE to TRUE
 906         } else {
 907             map.putIfAbsent(pn, Boolean.FALSE);
 908         }
 909     }
 910 
 911     /**
<a name="3" id="anc3"></a><span class="line-modified"> 912      * Updates a module to open all packages in the given sets to all unnamed</span>
<span class="line-modified"> 913      * modules.</span>
 914      *
 915      * @apiNote Used during startup to open packages for illegal access.
 916      */
<a name="4" id="anc4"></a><span class="line-modified"> 917     void implAddOpensToAllUnnamed(Set&lt;String&gt; concealedPkgs, Set&lt;String&gt; exportedPkgs) {</span>
 918         if (jdk.internal.misc.VM.isModuleSystemInited()) {
 919             throw new IllegalStateException(&quot;Module system already initialized&quot;);
 920         }
 921 
 922         // replace this module&#39;s openPackages map with a new map that opens
 923         // the packages to all unnamed modules.
 924         Map&lt;String, Set&lt;Module&gt;&gt; openPackages = this.openPackages;
 925         if (openPackages == null) {
<a name="5" id="anc5"></a><span class="line-modified"> 926             openPackages = new HashMap&lt;&gt;((4 * (concealedPkgs.size() + exportedPkgs.size()) / 3) + 1);</span>
 927         } else {
 928             openPackages = new HashMap&lt;&gt;(openPackages);
 929         }
<a name="6" id="anc6"></a><span class="line-modified"> 930         implAddOpensToAllUnnamed(concealedPkgs, openPackages);</span>
<span class="line-modified"> 931         implAddOpensToAllUnnamed(exportedPkgs, openPackages);</span>
<span class="line-added"> 932         this.openPackages = openPackages;</span>
<span class="line-added"> 933     }</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935     private void implAddOpensToAllUnnamed(Set&lt;String&gt; pkgs, Map&lt;String, Set&lt;Module&gt;&gt; openPackages) {</span>
<span class="line-added"> 936         for (String pn : pkgs) {</span>
 937             Set&lt;Module&gt; prev = openPackages.putIfAbsent(pn, ALL_UNNAMED_MODULE_SET);
 938             if (prev != null) {
 939                 prev.add(ALL_UNNAMED_MODULE);
 940             }
 941 
 942             // update VM to export the package
 943             addExportsToAllUnnamed0(this, pn);
 944         }
<a name="7" id="anc7"></a>
 945     }
 946 
<a name="8" id="anc8"></a>
 947     // -- services --
 948 
 949     /**
 950      * If the caller&#39;s module is this module then update this module to add a
 951      * service dependence on the given service type. This method is intended
 952      * for use by frameworks that invoke {@link java.util.ServiceLoader
 953      * ServiceLoader} on behalf of other modules or where the framework is
 954      * passed a reference to the service type by other code. This method is
 955      * a no-op when invoked on an unnamed module or an automatic module.
 956      *
 957      * &lt;p&gt; This method does not cause {@link Configuration#resolveAndBind
 958      * resolveAndBind} to be re-run. &lt;/p&gt;
 959      *
 960      * @param  service
 961      *         The service type
 962      *
 963      * @return this module
 964      *
 965      * @throws IllegalCallerException
 966      *         If this is a named module and the caller&#39;s module is not this
 967      *         module
 968      *
 969      * @see #canUse(Class)
 970      * @see ModuleDescriptor#uses()
 971      */
 972     @CallerSensitive
 973     public Module addUses(Class&lt;?&gt; service) {
 974         Objects.requireNonNull(service);
 975 
 976         if (isNamed() &amp;&amp; !descriptor.isAutomatic()) {
 977             Module caller = getCallerModule(Reflection.getCallerClass());
 978             if (caller != this) {
 979                 throw new IllegalCallerException(caller + &quot; != &quot; + this);
 980             }
 981             implAddUses(service);
 982         }
 983 
 984         return this;
 985     }
 986 
 987     /**
 988      * Update this module to add a service dependence on the given service
 989      * type.
 990      */
 991     void implAddUses(Class&lt;?&gt; service) {
 992         if (!canUse(service)) {
 993             ReflectionData.uses.putIfAbsent(this, service, Boolean.TRUE);
 994         }
 995     }
 996 
 997 
 998     /**
 999      * Indicates if this module has a service dependence on the given service
1000      * type. This method always returns {@code true} when invoked on an unnamed
1001      * module or an automatic module.
1002      *
1003      * @param  service
1004      *         The service type
1005      *
1006      * @return {@code true} if this module uses service type {@code st}
1007      *
1008      * @see #addUses(Class)
1009      */
1010     public boolean canUse(Class&lt;?&gt; service) {
1011         Objects.requireNonNull(service);
1012 
1013         if (!isNamed())
1014             return true;
1015 
1016         if (descriptor.isAutomatic())
1017             return true;
1018 
1019         // uses was declared
1020         if (descriptor.uses().contains(service.getName()))
1021             return true;
1022 
1023         // uses added via addUses
1024         return ReflectionData.uses.containsKeyPair(this, service);
1025     }
1026 
1027 
1028 
1029     // -- packages --
1030 
1031     /**
1032      * Returns the set of package names for the packages in this module.
1033      *
1034      * &lt;p&gt; For named modules, the returned set contains an element for each
1035      * package in the module. &lt;/p&gt;
1036      *
1037      * &lt;p&gt; For unnamed modules, this method is the equivalent to invoking the
1038      * {@link ClassLoader#getDefinedPackages() getDefinedPackages} method of
1039      * this module&#39;s class loader and returning the set of package names. &lt;/p&gt;
1040      *
1041      * @return the set of the package names of the packages in this module
1042      */
1043     public Set&lt;String&gt; getPackages() {
1044         if (isNamed()) {
1045             return descriptor.packages();
1046         } else {
1047             // unnamed module
1048             Stream&lt;Package&gt; packages;
1049             if (loader == null) {
1050                 packages = BootLoader.packages();
1051             } else {
1052                 packages = loader.packages();
1053             }
1054             return packages.map(Package::getName).collect(Collectors.toSet());
1055         }
1056     }
1057 
1058 
1059     // -- creating Module objects --
1060 
1061     /**
1062      * Defines all module in a configuration to the runtime.
1063      *
1064      * @return a map of module name to runtime {@code Module}
1065      *
1066      * @throws IllegalArgumentException
1067      *         If the function maps a module to the null or platform class loader
1068      * @throws IllegalStateException
1069      *         If the module cannot be defined to the VM or its packages overlap
1070      *         with another module mapped to the same class loader
1071      */
1072     static Map&lt;String, Module&gt; defineModules(Configuration cf,
1073                                              Function&lt;String, ClassLoader&gt; clf,
1074                                              ModuleLayer layer)
1075     {
1076         boolean isBootLayer = (ModuleLayer.boot() == null);
1077 
<a name="9" id="anc9"></a><span class="line-modified">1078         int numModules = cf.modules().size();</span>
<span class="line-added">1079         int cap = (int)(numModules / 0.75f + 1.0f);</span>
1080         Map&lt;String, Module&gt; nameToModule = new HashMap&lt;&gt;(cap);
<a name="10" id="anc10"></a>
1081 
<a name="11" id="anc11"></a><span class="line-modified">1082         // to avoid repeated lookups and reduce iteration overhead, we create</span>
<span class="line-added">1083         // arrays holding correlated information about each module.</span>
<span class="line-added">1084         ResolvedModule[] resolvedModules = new ResolvedModule[numModules];</span>
<span class="line-added">1085         Module[] modules = new Module[numModules];</span>
<span class="line-added">1086         ClassLoader[] classLoaders = new ClassLoader[numModules];</span>
<span class="line-added">1087 </span>
<span class="line-added">1088         resolvedModules = cf.modules().toArray(resolvedModules);</span>
<span class="line-added">1089 </span>
<span class="line-added">1090         // record that we want to bind the layer to non-boot and non-platform</span>
<span class="line-added">1091         // module loaders as a final step</span>
<span class="line-added">1092         HashSet&lt;ClassLoader&gt; toBindLoaders = new HashSet&lt;&gt;(4);</span>
1093         boolean hasPlatformModules = false;
1094 
1095         // map each module to a class loader
<a name="12" id="anc12"></a><span class="line-modified">1096         ClassLoader pcl = ClassLoaders.platformClassLoader();</span>
<span class="line-modified">1097 </span>
<span class="line-added">1098         for (int index = 0; index &lt; numModules; index++) {</span>
<span class="line-added">1099             String name = resolvedModules[index].name();</span>
1100             ClassLoader loader = clf.apply(name);
<a name="13" id="anc13"></a><span class="line-modified">1101 </span>
<span class="line-modified">1102             if (loader == null || loader == pcl) {</span>
1103                 if (!(clf instanceof ModuleLoaderMap.Mapper)) {
1104                     throw new IllegalArgumentException(&quot;loader can&#39;t be &#39;null&#39;&quot;
1105                             + &quot; or the platform class loader&quot;);
1106                 }
1107                 hasPlatformModules = true;
1108             } else {
<a name="14" id="anc14"></a><span class="line-modified">1109                 toBindLoaders.add(loader);</span>
1110             }
<a name="15" id="anc15"></a><span class="line-added">1111 </span>
<span class="line-added">1112             classLoaders[index] = loader;</span>
1113         }
1114 
1115         // define each module in the configuration to the VM
<a name="16" id="anc16"></a><span class="line-modified">1116         for (int index = 0; index &lt; numModules; index++) {</span>
<span class="line-modified">1117             ModuleReference mref = resolvedModules[index].reference();</span>
1118             ModuleDescriptor descriptor = mref.descriptor();
1119             String name = descriptor.name();
<a name="17" id="anc17"></a><span class="line-modified">1120             ClassLoader loader = classLoaders[index];</span>
1121             Module m;
1122             if (loader == null &amp;&amp; name.equals(&quot;java.base&quot;)) {
1123                 // java.base is already defined to the VM
1124                 m = Object.class.getModule();
1125             } else {
1126                 URI uri = mref.location().orElse(null);
1127                 m = new Module(layer, loader, descriptor, uri);
1128             }
1129             nameToModule.put(name, m);
<a name="18" id="anc18"></a><span class="line-added">1130             modules[index] = m;</span>
1131         }
1132 
1133         // setup readability and exports/opens
<a name="19" id="anc19"></a><span class="line-modified">1134         for (int index = 0; index &lt; numModules; index++) {</span>
<span class="line-added">1135             ResolvedModule resolvedModule = resolvedModules[index];</span>
1136             ModuleReference mref = resolvedModule.reference();
1137             ModuleDescriptor descriptor = mref.descriptor();
<a name="20" id="anc20"></a><span class="line-modified">1138             Module m = modules[index];</span>



1139 
1140             // reads
1141             Set&lt;Module&gt; reads = new HashSet&lt;&gt;();
1142 
1143             // name -&gt; source Module when in parent layer
1144             Map&lt;String, Module&gt; nameToSource = Map.of();
1145 
1146             for (ResolvedModule other : resolvedModule.reads()) {
1147                 Module m2 = null;
1148                 if (other.configuration() == cf) {
1149                     // this configuration
1150                     m2 = nameToModule.get(other.name());
1151                     assert m2 != null;
1152                 } else {
1153                     // parent layer
1154                     for (ModuleLayer parent: layer.parents()) {
1155                         m2 = findModule(parent, other);
1156                         if (m2 != null)
1157                             break;
1158                     }
1159                     assert m2 != null;
1160                     if (nameToSource.isEmpty())
1161                         nameToSource = new HashMap&lt;&gt;();
1162                     nameToSource.put(other.name(), m2);
1163                 }
1164                 reads.add(m2);
1165 
1166                 // update VM view
1167                 addReads0(m, m2);
1168             }
1169             m.reads = reads;
1170 
1171             // automatic modules read all unnamed modules
1172             if (descriptor.isAutomatic()) {
1173                 m.implAddReads(ALL_UNNAMED_MODULE, true);
1174             }
1175 
1176             // exports and opens, skipped for open and automatic
1177             if (!descriptor.isOpen() &amp;&amp; !descriptor.isAutomatic()) {
1178                 if (isBootLayer &amp;&amp; descriptor.opens().isEmpty()) {
1179                     // no open packages, no qualified exports to modules in parent layers
1180                     initExports(m, nameToModule);
1181                 } else {
1182                     initExportsAndOpens(m, nameToSource, nameToModule, layer.parents());
1183                 }
1184             }
1185         }
1186 
1187         // if there are modules defined to the boot or platform class loaders
1188         // then register the modules in the class loader&#39;s services catalog
1189         if (hasPlatformModules) {
<a name="21" id="anc21"></a>
1190             ServicesCatalog bootCatalog = BootLoader.getServicesCatalog();
1191             ServicesCatalog pclCatalog = ServicesCatalog.getServicesCatalog(pcl);
<a name="22" id="anc22"></a><span class="line-modified">1192             for (int index = 0; index &lt; numModules; index++) {</span>
<span class="line-added">1193                 ResolvedModule resolvedModule = resolvedModules[index];</span>
1194                 ModuleReference mref = resolvedModule.reference();
1195                 ModuleDescriptor descriptor = mref.descriptor();
1196                 if (!descriptor.provides().isEmpty()) {
<a name="23" id="anc23"></a><span class="line-modified">1197                     Module m = modules[index];</span>
<span class="line-modified">1198                     ClassLoader loader = classLoaders[index];</span>

1199                     if (loader == null) {
1200                         bootCatalog.register(m);
1201                     } else if (loader == pcl) {
1202                         pclCatalog.register(m);
1203                     }
1204                 }
1205             }
1206         }
1207 
1208         // record that there is a layer with modules defined to the class loader
<a name="24" id="anc24"></a><span class="line-modified">1209         for (ClassLoader loader : toBindLoaders) {</span>
1210             layer.bindToLoader(loader);
1211         }
1212 
1213         return nameToModule;
1214     }
1215 
1216     /**
1217      * Find the runtime Module corresponding to the given ResolvedModule
1218      * in the given parent layer (or its parents).
1219      */
1220     private static Module findModule(ModuleLayer parent,
1221                                      ResolvedModule resolvedModule) {
1222         Configuration cf = resolvedModule.configuration();
1223         String dn = resolvedModule.name();
1224         return parent.layers()
1225                 .filter(l -&gt; l.configuration() == cf)
1226                 .findAny()
1227                 .map(layer -&gt; {
1228                     Optional&lt;Module&gt; om = layer.findModule(dn);
1229                     assert om.isPresent() : dn + &quot; not found in layer&quot;;
1230                     Module m = om.get();
1231                     assert m.getLayer() == layer : m + &quot; not in expected layer&quot;;
1232                     return m;
1233                 })
1234                 .orElse(null);
1235     }
1236 
1237     /**
1238      * Initialize/setup a module&#39;s exports.
1239      *
1240      * @param m the module
1241      * @param nameToModule map of module name to Module (for qualified exports)
1242      */
1243     private static void initExports(Module m, Map&lt;String, Module&gt; nameToModule) {
1244         Map&lt;String, Set&lt;Module&gt;&gt; exportedPackages = new HashMap&lt;&gt;();
1245 
1246         for (Exports exports : m.getDescriptor().exports()) {
1247             String source = exports.source();
1248             if (exports.isQualified()) {
1249                 // qualified exports
1250                 Set&lt;Module&gt; targets = new HashSet&lt;&gt;();
1251                 for (String target : exports.targets()) {
1252                     Module m2 = nameToModule.get(target);
1253                     if (m2 != null) {
1254                         addExports0(m, source, m2);
1255                         targets.add(m2);
1256                     }
1257                 }
1258                 if (!targets.isEmpty()) {
1259                     exportedPackages.put(source, targets);
1260                 }
1261             } else {
1262                 // unqualified exports
1263                 addExportsToAll0(m, source);
1264                 exportedPackages.put(source, EVERYONE_SET);
1265             }
1266         }
1267 
1268         if (!exportedPackages.isEmpty())
1269             m.exportedPackages = exportedPackages;
1270     }
1271 
1272     /**
1273      * Initialize/setup a module&#39;s exports.
1274      *
1275      * @param m the module
1276      * @param nameToSource map of module name to Module for modules that m reads
1277      * @param nameToModule map of module name to Module for modules in the layer
1278      *                     under construction
1279      * @param parents the parent layers
1280      */
1281     private static void initExportsAndOpens(Module m,
1282                                             Map&lt;String, Module&gt; nameToSource,
1283                                             Map&lt;String, Module&gt; nameToModule,
1284                                             List&lt;ModuleLayer&gt; parents) {
1285         ModuleDescriptor descriptor = m.getDescriptor();
1286         Map&lt;String, Set&lt;Module&gt;&gt; openPackages = new HashMap&lt;&gt;();
1287         Map&lt;String, Set&lt;Module&gt;&gt; exportedPackages = new HashMap&lt;&gt;();
1288 
1289         // process the open packages first
1290         for (Opens opens : descriptor.opens()) {
1291             String source = opens.source();
1292 
1293             if (opens.isQualified()) {
1294                 // qualified opens
1295                 Set&lt;Module&gt; targets = new HashSet&lt;&gt;();
1296                 for (String target : opens.targets()) {
1297                     Module m2 = findModule(target, nameToSource, nameToModule, parents);
1298                     if (m2 != null) {
1299                         addExports0(m, source, m2);
1300                         targets.add(m2);
1301                     }
1302                 }
1303                 if (!targets.isEmpty()) {
1304                     openPackages.put(source, targets);
1305                 }
1306             } else {
1307                 // unqualified opens
1308                 addExportsToAll0(m, source);
1309                 openPackages.put(source, EVERYONE_SET);
1310             }
1311         }
1312 
1313         // next the exports, skipping exports when the package is open
1314         for (Exports exports : descriptor.exports()) {
1315             String source = exports.source();
1316 
1317             // skip export if package is already open to everyone
1318             Set&lt;Module&gt; openToTargets = openPackages.get(source);
1319             if (openToTargets != null &amp;&amp; openToTargets.contains(EVERYONE_MODULE))
1320                 continue;
1321 
1322             if (exports.isQualified()) {
1323                 // qualified exports
1324                 Set&lt;Module&gt; targets = new HashSet&lt;&gt;();
1325                 for (String target : exports.targets()) {
1326                     Module m2 = findModule(target, nameToSource, nameToModule, parents);
1327                     if (m2 != null) {
1328                         // skip qualified export if already open to m2
1329                         if (openToTargets == null || !openToTargets.contains(m2)) {
1330                             addExports0(m, source, m2);
1331                             targets.add(m2);
1332                         }
1333                     }
1334                 }
1335                 if (!targets.isEmpty()) {
1336                     exportedPackages.put(source, targets);
1337                 }
1338             } else {
1339                 // unqualified exports
1340                 addExportsToAll0(m, source);
1341                 exportedPackages.put(source, EVERYONE_SET);
1342             }
1343         }
1344 
1345         if (!openPackages.isEmpty())
1346             m.openPackages = openPackages;
1347         if (!exportedPackages.isEmpty())
1348             m.exportedPackages = exportedPackages;
1349     }
1350 
1351     /**
1352      * Find the runtime Module with the given name. The module name is the
1353      * name of a target module in a qualified exports or opens directive.
1354      *
1355      * @param target The target module to find
1356      * @param nameToSource The modules in parent layers that are read
1357      * @param nameToModule The modules in the layer under construction
1358      * @param parents The parent layers
1359      */
1360     private static Module findModule(String target,
1361                                      Map&lt;String, Module&gt; nameToSource,
1362                                      Map&lt;String, Module&gt; nameToModule,
1363                                      List&lt;ModuleLayer&gt; parents) {
1364         Module m = nameToSource.get(target);
1365         if (m == null) {
1366             m = nameToModule.get(target);
1367             if (m == null) {
1368                 for (ModuleLayer parent : parents) {
1369                     m = parent.findModule(target).orElse(null);
1370                     if (m != null) break;
1371                 }
1372             }
1373         }
1374         return m;
1375     }
1376 
1377 
1378     // -- annotations --
1379 
1380     /**
1381      * {@inheritDoc}
1382      * This method returns {@code null} when invoked on an unnamed module.
1383      */
1384     @Override
1385     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1386         return moduleInfoClass().getDeclaredAnnotation(annotationClass);
1387     }
1388 
1389     /**
1390      * {@inheritDoc}
1391      * This method returns an empty array when invoked on an unnamed module.
1392      */
1393     @Override
1394     public Annotation[] getAnnotations() {
1395         return moduleInfoClass().getAnnotations();
1396     }
1397 
1398     /**
1399      * {@inheritDoc}
1400      * This method returns an empty array when invoked on an unnamed module.
1401      */
1402     @Override
1403     public Annotation[] getDeclaredAnnotations() {
1404         return moduleInfoClass().getDeclaredAnnotations();
1405     }
1406 
1407     // cached class file with annotations
1408     private volatile Class&lt;?&gt; moduleInfoClass;
1409 
1410     private Class&lt;?&gt; moduleInfoClass() {
1411         Class&lt;?&gt; clazz = this.moduleInfoClass;
1412         if (clazz != null)
1413             return clazz;
1414 
1415         synchronized (this) {
1416             clazz = this.moduleInfoClass;
1417             if (clazz == null) {
1418                 if (isNamed()) {
1419                     PrivilegedAction&lt;Class&lt;?&gt;&gt; pa = this::loadModuleInfoClass;
1420                     clazz = AccessController.doPrivileged(pa);
1421                 }
1422                 if (clazz == null) {
1423                     class DummyModuleInfo { }
1424                     clazz = DummyModuleInfo.class;
1425                 }
1426                 this.moduleInfoClass = clazz;
1427             }
1428             return clazz;
1429         }
1430     }
1431 
1432     private Class&lt;?&gt; loadModuleInfoClass() {
1433         Class&lt;?&gt; clazz = null;
1434         try (InputStream in = getResourceAsStream(&quot;module-info.class&quot;)) {
1435             if (in != null)
1436                 clazz = loadModuleInfoClass(in);
1437         } catch (Exception ignore) { }
1438         return clazz;
1439     }
1440 
1441     /**
1442      * Loads module-info.class as a package-private interface in a class loader
1443      * that is a child of this module&#39;s class loader.
1444      */
1445     private Class&lt;?&gt; loadModuleInfoClass(InputStream in) throws IOException {
1446         final String MODULE_INFO = &quot;module-info&quot;;
1447 
1448         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
1449                                          + ClassWriter.COMPUTE_FRAMES);
1450 
1451         ClassVisitor cv = new ClassVisitor(Opcodes.ASM7, cw) {
1452             @Override
1453             public void visit(int version,
1454                               int access,
1455                               String name,
1456                               String signature,
1457                               String superName,
1458                               String[] interfaces) {
1459                 cw.visit(version,
1460                         Opcodes.ACC_INTERFACE
1461                             + Opcodes.ACC_ABSTRACT
1462                             + Opcodes.ACC_SYNTHETIC,
1463                         MODULE_INFO,
1464                         null,
1465                         &quot;java/lang/Object&quot;,
1466                         null);
1467             }
1468             @Override
1469             public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
1470                 // keep annotations
1471                 return super.visitAnnotation(desc, visible);
1472             }
1473             @Override
1474             public void visitAttribute(Attribute attr) {
1475                 // drop non-annotation attributes
1476             }
1477             @Override
1478             public ModuleVisitor visitModule(String name, int flags, String version) {
1479                 // drop Module attribute
1480                 return null;
1481             }
1482         };
1483 
1484         ClassReader cr = new ClassReader(in);
1485         cr.accept(cv, 0);
1486         byte[] bytes = cw.toByteArray();
1487 
1488         ClassLoader cl = new ClassLoader(loader) {
1489             @Override
1490             protected Class&lt;?&gt; findClass(String cn)throws ClassNotFoundException {
1491                 if (cn.equals(MODULE_INFO)) {
1492                     return super.defineClass(cn, bytes, 0, bytes.length);
1493                 } else {
1494                     throw new ClassNotFoundException(cn);
1495                 }
1496             }
1497         };
1498 
1499         try {
1500             return cl.loadClass(MODULE_INFO);
1501         } catch (ClassNotFoundException e) {
1502             throw new InternalError(e);
1503         }
1504     }
1505 
1506 
1507     // -- misc --
1508 
1509 
1510     /**
1511      * Returns an input stream for reading a resource in this module.
1512      * The {@code name} parameter is a {@code &#39;/&#39;}-separated path name that
1513      * identifies the resource. As with {@link Class#getResourceAsStream
1514      * Class.getResourceAsStream}, this method delegates to the module&#39;s class
1515      * loader {@link ClassLoader#findResource(String,String)
1516      * findResource(String,String)} method, invoking it with the module name
1517      * (or {@code null} when the module is unnamed) and the name of the
1518      * resource. If the resource name has a leading slash then it is dropped
1519      * before delegation.
1520      *
1521      * &lt;p&gt; A resource in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
1522      * it cannot be located by code in other modules. Whether a resource can be
1523      * located or not is determined as follows: &lt;/p&gt;
1524      *
1525      * &lt;ul&gt;
1526      *     &lt;li&gt; If the resource name ends with  &quot;{@code .class}&quot; then it is not
1527      *     encapsulated. &lt;/li&gt;
1528      *
1529      *     &lt;li&gt; A &lt;em&gt;package name&lt;/em&gt; is derived from the resource name. If
1530      *     the package name is a {@linkplain #getPackages() package} in the
1531      *     module then the resource can only be located by the caller of this
1532      *     method when the package is {@linkplain #isOpen(String,Module) open}
1533      *     to at least the caller&#39;s module. If the resource is not in a
1534      *     package in the module then the resource is not encapsulated. &lt;/li&gt;
1535      * &lt;/ul&gt;
1536      *
1537      * &lt;p&gt; In the above, the &lt;em&gt;package name&lt;/em&gt; for a resource is derived
1538      * from the subsequence of characters that precedes the last {@code &#39;/&#39;} in
1539      * the name and then replacing each {@code &#39;/&#39;} character in the subsequence
1540      * with {@code &#39;.&#39;}. A leading slash is ignored when deriving the package
1541      * name. As an example, the package name derived for a resource named
1542      * &quot;{@code a/b/c/foo.properties}&quot; is &quot;{@code a.b.c}&quot;. A resource name
1543      * with the name &quot;{@code META-INF/MANIFEST.MF}&quot; is never encapsulated
1544      * because &quot;{@code META-INF}&quot; is not a legal package name. &lt;/p&gt;
1545      *
1546      * &lt;p&gt; This method returns {@code null} if the resource is not in this
1547      * module, the resource is encapsulated and cannot be located by the caller,
1548      * or access to the resource is denied by the security manager. &lt;/p&gt;
1549      *
1550      * @param  name
1551      *         The resource name
1552      *
1553      * @return An input stream for reading the resource or {@code null}
1554      *
1555      * @throws IOException
1556      *         If an I/O error occurs
1557      *
1558      * @see Class#getResourceAsStream(String)
1559      */
1560     @CallerSensitive
1561     public InputStream getResourceAsStream(String name) throws IOException {
1562         if (name.startsWith(&quot;/&quot;)) {
1563             name = name.substring(1);
1564         }
1565 
1566         if (isNamed() &amp;&amp; Resources.canEncapsulate(name)) {
1567             Module caller = getCallerModule(Reflection.getCallerClass());
1568             if (caller != this &amp;&amp; caller != Object.class.getModule()) {
1569                 String pn = Resources.toPackageName(name);
1570                 if (getPackages().contains(pn)) {
1571                     if (caller == null &amp;&amp; !isOpen(pn)) {
1572                         // no caller, package not open
1573                         return null;
1574                     }
1575                     if (!isOpen(pn, caller)) {
1576                         // package not open to caller
1577                         return null;
1578                     }
1579                 }
1580             }
1581         }
1582 
1583         String mn = this.name;
1584 
1585         // special-case built-in class loaders to avoid URL connection
1586         if (loader == null) {
1587             return BootLoader.findResourceAsStream(mn, name);
1588         } else if (loader instanceof BuiltinClassLoader) {
1589             return ((BuiltinClassLoader) loader).findResourceAsStream(mn, name);
1590         }
1591 
1592         // locate resource in module
1593         URL url = loader.findResource(mn, name);
1594         if (url != null) {
1595             try {
1596                 return url.openStream();
1597             } catch (SecurityException e) { }
1598         }
1599 
1600         return null;
1601     }
1602 
1603     /**
1604      * Returns the string representation of this module. For a named module,
1605      * the representation is the string {@code &quot;module&quot;}, followed by a space,
1606      * and then the module name. For an unnamed module, the representation is
1607      * the string {@code &quot;unnamed module&quot;}, followed by a space, and then an
1608      * implementation specific string that identifies the unnamed module.
1609      *
1610      * @return The string representation of this module
1611      */
1612     @Override
1613     public String toString() {
1614         if (isNamed()) {
1615             return &quot;module &quot; + name;
1616         } else {
1617             String id = Integer.toHexString(System.identityHashCode(this));
1618             return &quot;unnamed module @&quot; + id;
1619         }
1620     }
1621 
1622     /**
1623      * Returns the module that a given caller class is a member of. Returns
1624      * {@code null} if the caller is {@code null}.
1625      */
1626     private Module getCallerModule(Class&lt;?&gt; caller) {
1627         return (caller != null) ? caller.getModule() : null;
1628     }
1629 
1630 
1631     // -- native methods --
1632 
1633     // JVM_DefineModule
1634     private static native void defineModule0(Module module,
1635                                              boolean isOpen,
1636                                              String version,
1637                                              String location,
<a name="25" id="anc25"></a><span class="line-modified">1638                                              Object[] pns);</span>
1639 
1640     // JVM_AddReadsModule
1641     private static native void addReads0(Module from, Module to);
1642 
1643     // JVM_AddModuleExports
1644     private static native void addExports0(Module from, String pn, Module to);
1645 
1646     // JVM_AddModuleExportsToAll
1647     private static native void addExportsToAll0(Module from, String pn);
1648 
1649     // JVM_AddModuleExportsToAllUnnamed
1650     private static native void addExportsToAllUnnamed0(Module from, String pn);
1651 }
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>