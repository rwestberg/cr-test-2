<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/provider/certpath/OCSPResponse.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.provider.certpath;
  27 
  28 import java.io.*;
  29 import java.security.*;
  30 import java.security.cert.CertificateException;
  31 import java.security.cert.CertificateParsingException;
  32 import java.security.cert.CertPathValidatorException;
  33 import java.security.cert.CertPathValidatorException.BasicReason;
  34 import java.security.cert.CRLReason;
  35 import java.security.cert.TrustAnchor;
  36 import java.security.cert.X509Certificate;
  37 import java.util.ArrayList;
  38 import java.util.Arrays;
  39 import java.util.Collections;
  40 import java.util.Date;
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Set;
  45 import javax.security.auth.x500.X500Principal;
  46 
  47 import sun.security.util.HexDumpEncoder;
  48 import sun.security.action.GetIntegerAction;
  49 import sun.security.x509.*;
  50 import sun.security.util.*;
  51 
  52 /**
  53  * This class is used to process an OCSP response.
  54  * The OCSP Response is defined
  55  * in RFC 2560 and the ASN.1 encoding is as follows:
  56  * &lt;pre&gt;
  57  *
  58  *  OCSPResponse ::= SEQUENCE {
  59  *      responseStatus         OCSPResponseStatus,
  60  *      responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }
  61  *
  62  *   OCSPResponseStatus ::= ENUMERATED {
  63  *       successful            (0),  --Response has valid confirmations
  64  *       malformedRequest      (1),  --Illegal confirmation request
  65  *       internalError         (2),  --Internal error in issuer
  66  *       tryLater              (3),  --Try again later
  67  *                                   --(4) is not used
  68  *       sigRequired           (5),  --Must sign the request
  69  *       unauthorized          (6)   --Request unauthorized
  70  *   }
  71  *
  72  *   ResponseBytes ::=       SEQUENCE {
  73  *       responseType   OBJECT IDENTIFIER,
  74  *       response       OCTET STRING }
  75  *
  76  *   BasicOCSPResponse       ::= SEQUENCE {
  77  *      tbsResponseData      ResponseData,
  78  *      signatureAlgorithm   AlgorithmIdentifier,
  79  *      signature            BIT STRING,
  80  *      certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }
  81  *
  82  *   The value for signature SHALL be computed on the hash of the DER
  83  *   encoding ResponseData.
  84  *
  85  *   ResponseData ::= SEQUENCE {
  86  *      version              [0] EXPLICIT Version DEFAULT v1,
  87  *      responderID              ResponderID,
  88  *      producedAt               GeneralizedTime,
  89  *      responses                SEQUENCE OF SingleResponse,
  90  *      responseExtensions   [1] EXPLICIT Extensions OPTIONAL }
  91  *
  92  *   ResponderID ::= CHOICE {
  93  *      byName               [1] Name,
  94  *      byKey                [2] KeyHash }
  95  *
  96  *   KeyHash ::= OCTET STRING -- SHA-1 hash of responder&#39;s public key
  97  *   (excluding the tag and length fields)
  98  *
  99  *   SingleResponse ::= SEQUENCE {
 100  *      certID                       CertID,
 101  *      certStatus                   CertStatus,
 102  *      thisUpdate                   GeneralizedTime,
 103  *      nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
 104  *      singleExtensions   [1]       EXPLICIT Extensions OPTIONAL }
 105  *
 106  *   CertStatus ::= CHOICE {
 107  *       good        [0]     IMPLICIT NULL,
 108  *       revoked     [1]     IMPLICIT RevokedInfo,
 109  *       unknown     [2]     IMPLICIT UnknownInfo }
 110  *
 111  *   RevokedInfo ::= SEQUENCE {
 112  *       revocationTime              GeneralizedTime,
 113  *       revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }
 114  *
 115  *   UnknownInfo ::= NULL -- this can be replaced with an enumeration
 116  *
 117  * &lt;/pre&gt;
 118  *
 119  * @author      Ram Marti
 120  */
 121 
 122 public final class OCSPResponse {
 123 
 124     public enum ResponseStatus {
 125         SUCCESSFUL,            // Response has valid confirmations
 126         MALFORMED_REQUEST,     // Illegal request
 127         INTERNAL_ERROR,        // Internal error in responder
 128         TRY_LATER,             // Try again later
 129         UNUSED,                // is not used
 130         SIG_REQUIRED,          // Must sign the request
 131         UNAUTHORIZED           // Request unauthorized
 132     };
 133     private static final ResponseStatus[] rsvalues = ResponseStatus.values();
 134 
 135     private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);
 136     private static final boolean dump = debug != null &amp;&amp; Debug.isOn(&quot;ocsp&quot;);
 137     private static final ObjectIdentifier OCSP_BASIC_RESPONSE_OID =
 138         ObjectIdentifier.newInternal(new int[] { 1, 3, 6, 1, 5, 5, 7, 48, 1, 1});
 139     private static final int CERT_STATUS_GOOD = 0;
 140     private static final int CERT_STATUS_REVOKED = 1;
 141     private static final int CERT_STATUS_UNKNOWN = 2;
 142 
 143     // ResponderID CHOICE tags
 144     private static final int NAME_TAG = 1;
 145     private static final int KEY_TAG = 2;
 146 
 147     // Object identifier for the OCSPSigning key purpose
 148     private static final String KP_OCSP_SIGNING_OID = &quot;1.3.6.1.5.5.7.3.9&quot;;
 149 
 150     // Default maximum clock skew in milliseconds (15 minutes)
 151     // allowed when checking validity of OCSP responses
 152     private static final int DEFAULT_MAX_CLOCK_SKEW = 900000;
 153 
 154     /**
 155      * Integer value indicating the maximum allowable clock skew,
 156      * in milliseconds, to be used for the OCSP check.
 157      */
 158     private static final int MAX_CLOCK_SKEW = initializeClockSkew();
 159 
 160     /**
 161      * Initialize the maximum allowable clock skew by getting the OCSP
 162      * clock skew system property. If the property has not been set, or if its
 163      * value is negative, set the skew to the default.
 164      */
 165     private static int initializeClockSkew() {
 166         Integer tmp = java.security.AccessController.doPrivileged(
 167                 new GetIntegerAction(&quot;com.sun.security.ocsp.clockSkew&quot;));
 168         if (tmp == null || tmp &lt; 0) {
 169             return DEFAULT_MAX_CLOCK_SKEW;
 170         }
 171         // Convert to milliseconds, as the system property will be
 172         // specified in seconds
 173         return tmp * 1000;
 174     }
 175 
 176     // an array of all of the CRLReasons (used in SingleResponse)
 177     private static final CRLReason[] values = CRLReason.values();
 178 
 179     private final ResponseStatus responseStatus;
 180     private final Map&lt;CertId, SingleResponse&gt; singleResponseMap;
 181     private final AlgorithmId sigAlgId;
 182     private final byte[] signature;
 183     private final byte[] tbsResponseData;
 184     private final byte[] responseNonce;
 185     private List&lt;X509CertImpl&gt; certs;
 186     private X509CertImpl signerCert = null;
 187     private final ResponderId respId;
 188     private Date producedAtDate = null;
 189     private final Map&lt;String, java.security.cert.Extension&gt; responseExtensions;
 190 
 191     /*
 192      * Create an OCSP response from its ASN.1 DER encoding.
 193      *
 194      * @param bytes The DER-encoded bytes for an OCSP response
 195      */
 196     public OCSPResponse(byte[] bytes) throws IOException {
 197         if (dump) {
 198             HexDumpEncoder hexEnc = new HexDumpEncoder();
 199             debug.println(&quot;OCSPResponse bytes...\n\n&quot; +
 200                 hexEnc.encode(bytes) + &quot;\n&quot;);
 201         }
 202         DerValue der = new DerValue(bytes);
 203         if (der.tag != DerValue.tag_Sequence) {
 204             throw new IOException(&quot;Bad encoding in OCSP response: &quot; +
 205                 &quot;expected ASN.1 SEQUENCE tag.&quot;);
 206         }
 207         DerInputStream derIn = der.getData();
 208 
 209         // responseStatus
 210         int status = derIn.getEnumerated();
 211         if (status &gt;= 0 &amp;&amp; status &lt; rsvalues.length) {
 212             responseStatus = rsvalues[status];
 213         } else {
 214             // unspecified responseStatus
 215             throw new IOException(&quot;Unknown OCSPResponse status: &quot; + status);
 216         }
 217         if (debug != null) {
 218             debug.println(&quot;OCSP response status: &quot; + responseStatus);
 219         }
 220         if (responseStatus != ResponseStatus.SUCCESSFUL) {
 221             // no need to continue, responseBytes are not set.
 222             singleResponseMap = Collections.emptyMap();
 223             certs = new ArrayList&lt;X509CertImpl&gt;();
 224             sigAlgId = null;
 225             signature = null;
 226             tbsResponseData = null;
 227             responseNonce = null;
 228             responseExtensions = Collections.emptyMap();
 229             respId = null;
 230             return;
 231         }
 232 
 233         // responseBytes
 234         der = derIn.getDerValue();
 235         if (!der.isContextSpecific((byte)0)) {
 236             throw new IOException(&quot;Bad encoding in responseBytes element &quot; +
 237                 &quot;of OCSP response: expected ASN.1 context specific tag 0.&quot;);
 238         }
 239         DerValue tmp = der.data.getDerValue();
 240         if (tmp.tag != DerValue.tag_Sequence) {
 241             throw new IOException(&quot;Bad encoding in responseBytes element &quot; +
 242                 &quot;of OCSP response: expected ASN.1 SEQUENCE tag.&quot;);
 243         }
 244 
 245         // responseType
 246         derIn = tmp.data;
 247         ObjectIdentifier responseType = derIn.getOID();
 248         if (responseType.equals((Object)OCSP_BASIC_RESPONSE_OID)) {
 249             if (debug != null) {
 250                 debug.println(&quot;OCSP response type: basic&quot;);
 251             }
 252         } else {
 253             if (debug != null) {
 254                 debug.println(&quot;OCSP response type: &quot; + responseType);
 255             }
 256             throw new IOException(&quot;Unsupported OCSP response type: &quot; +
 257                                   responseType);
 258         }
 259 
 260         // BasicOCSPResponse
 261         DerInputStream basicOCSPResponse =
 262             new DerInputStream(derIn.getOctetString());
 263 
 264         DerValue[] seqTmp = basicOCSPResponse.getSequence(2);
 265         if (seqTmp.length &lt; 3) {
 266             throw new IOException(&quot;Unexpected BasicOCSPResponse value&quot;);
 267         }
 268 
 269         DerValue responseData = seqTmp[0];
 270 
 271         // Need the DER encoded ResponseData to verify the signature later
 272         tbsResponseData = seqTmp[0].toByteArray();
 273 
 274         // tbsResponseData
 275         if (responseData.tag != DerValue.tag_Sequence) {
 276             throw new IOException(&quot;Bad encoding in tbsResponseData &quot; +
 277                 &quot;element of OCSP response: expected ASN.1 SEQUENCE tag.&quot;);
 278         }
 279         DerInputStream seqDerIn = responseData.data;
 280         DerValue seq = seqDerIn.getDerValue();
 281 
 282         // version
 283         if (seq.isContextSpecific((byte)0)) {
 284             // seq[0] is version
 285             if (seq.isConstructed() &amp;&amp; seq.isContextSpecific()) {
 286                 //System.out.println (&quot;version is available&quot;);
 287                 seq = seq.data.getDerValue();
 288                 int version = seq.getInteger();
 289                 if (seq.data.available() != 0) {
 290                     throw new IOException(&quot;Bad encoding in version &quot; +
 291                         &quot; element of OCSP response: bad format&quot;);
 292                 }
 293                 seq = seqDerIn.getDerValue();
 294             }
 295         }
 296 
 297         // responderID
 298         respId = new ResponderId(seq.toByteArray());
 299         if (debug != null) {
 300             debug.println(&quot;Responder ID: &quot; + respId);
 301         }
 302 
 303         // producedAt
 304         seq = seqDerIn.getDerValue();
 305         producedAtDate = seq.getGeneralizedTime();
 306         if (debug != null) {
 307             debug.println(&quot;OCSP response produced at: &quot; + producedAtDate);
 308         }
 309 
 310         // responses
 311         DerValue[] singleResponseDer = seqDerIn.getSequence(1);
 312         singleResponseMap = new HashMap&lt;&gt;(singleResponseDer.length);
 313         if (debug != null) {
 314             debug.println(&quot;OCSP number of SingleResponses: &quot;
 315                           + singleResponseDer.length);
 316         }
 317         for (DerValue srDer : singleResponseDer) {
 318             SingleResponse singleResponse = new SingleResponse(srDer);
 319             singleResponseMap.put(singleResponse.getCertId(), singleResponse);
 320         }
 321 
 322         // responseExtensions
 323         Map&lt;String, java.security.cert.Extension&gt; tmpExtMap = new HashMap&lt;&gt;();
 324         if (seqDerIn.available() &gt; 0) {
 325             seq = seqDerIn.getDerValue();
 326             if (seq.isContextSpecific((byte)1)) {
 327                 tmpExtMap = parseExtensions(seq);
 328             }
 329         }
 330         responseExtensions = tmpExtMap;
 331 
 332         // Attach the nonce value if found in the extension map
 333         Extension nonceExt = (Extension)tmpExtMap.get(
 334                 PKIXExtensions.OCSPNonce_Id.toString());
 335         responseNonce = (nonceExt != null) ?
 336                 nonceExt.getExtensionValue() : null;
 337         if (debug != null &amp;&amp; responseNonce != null) {
 338             debug.println(&quot;Response nonce: &quot; + Arrays.toString(responseNonce));
 339         }
 340 
 341         // signatureAlgorithmId
 342         sigAlgId = AlgorithmId.parse(seqTmp[1]);
 343 
 344         // signature
 345         signature = seqTmp[2].getBitString();
 346 
 347         // if seq[3] is available , then it is a sequence of certificates
 348         if (seqTmp.length &gt; 3) {
 349             // certs are available
 350             DerValue seqCert = seqTmp[3];
 351             if (!seqCert.isContextSpecific((byte)0)) {
 352                 throw new IOException(&quot;Bad encoding in certs element of &quot; +
 353                     &quot;OCSP response: expected ASN.1 context specific tag 0.&quot;);
 354             }
 355             DerValue[] derCerts = seqCert.getData().getSequence(3);
 356             certs = new ArrayList&lt;X509CertImpl&gt;(derCerts.length);
 357             try {
 358                 for (int i = 0; i &lt; derCerts.length; i++) {
 359                     X509CertImpl cert =
 360                         new X509CertImpl(derCerts[i].toByteArray());
 361                     certs.add(cert);
 362 
 363                     if (debug != null) {
 364                         debug.println(&quot;OCSP response cert #&quot; + (i + 1) + &quot;: &quot; +
 365                             cert.getSubjectX500Principal());
 366                     }
 367                 }
 368             } catch (CertificateException ce) {
 369                 throw new IOException(&quot;Bad encoding in X509 Certificate&quot;, ce);
 370             }
 371         } else {
 372             certs = new ArrayList&lt;X509CertImpl&gt;();
 373         }
 374     }
 375 
 376     void verify(List&lt;CertId&gt; certIds, IssuerInfo issuerInfo,
 377             X509Certificate responderCert, Date date, byte[] nonce,
 378             String variant)
 379         throws CertPathValidatorException
 380     {
 381         switch (responseStatus) {
 382             case SUCCESSFUL:
 383                 break;
 384             case TRY_LATER:
 385             case INTERNAL_ERROR:
 386                 throw new CertPathValidatorException(
 387                     &quot;OCSP response error: &quot; + responseStatus, null, null, -1,
 388                     BasicReason.UNDETERMINED_REVOCATION_STATUS);
 389             case UNAUTHORIZED:
 390             default:
 391                 throw new CertPathValidatorException(&quot;OCSP response error: &quot; +
 392                                                      responseStatus);
 393         }
 394 
 395         // Check that the response includes a response for all of the
 396         // certs that were supplied in the request
 397         for (CertId certId : certIds) {
 398             SingleResponse sr = getSingleResponse(certId);
 399             if (sr == null) {
 400                 if (debug != null) {
 401                     debug.println(&quot;No response found for CertId: &quot; + certId);
 402                 }
 403                 throw new CertPathValidatorException(
 404                     &quot;OCSP response does not include a response for a &quot; +
 405                     &quot;certificate supplied in the OCSP request&quot;);
 406             }
 407             if (debug != null) {
 408                 debug.println(&quot;Status of certificate (with serial number &quot; +
 409                     certId.getSerialNumber() + &quot;) is: &quot; + sr.getCertStatus());
 410             }
 411         }
 412 
 413         // Locate the signer cert
 414         if (signerCert == null) {
 415             // Add the Issuing CA cert and/or Trusted Responder cert to the list
 416             // of certs from the OCSP response
 417             try {
 418                 if (issuerInfo.getCertificate() != null) {
 419                     certs.add(X509CertImpl.toImpl(issuerInfo.getCertificate()));
 420                 }
 421                 if (responderCert != null) {
 422                     certs.add(X509CertImpl.toImpl(responderCert));
 423                 }
 424             } catch (CertificateException ce) {
 425                 throw new CertPathValidatorException(
 426                     &quot;Invalid issuer or trusted responder certificate&quot;, ce);
 427             }
 428 
 429             if (respId.getType() == ResponderId.Type.BY_NAME) {
 430                 X500Principal rName = respId.getResponderName();
 431                 for (X509CertImpl cert : certs) {
 432                     if (cert.getSubjectX500Principal().equals(rName)) {
 433                         signerCert = cert;
 434                         break;
 435                     }
 436                 }
 437             } else if (respId.getType() == ResponderId.Type.BY_KEY) {
 438                 KeyIdentifier ridKeyId = respId.getKeyIdentifier();
 439                 for (X509CertImpl cert : certs) {
 440                     // Match responder&#39;s key identifier against the cert&#39;s SKID
 441                     // This will match if the SKID is encoded using the 160-bit
 442                     // SHA-1 hash method as defined in RFC 5280.
 443                     KeyIdentifier certKeyId = cert.getSubjectKeyId();
 444                     if (certKeyId != null &amp;&amp; ridKeyId.equals(certKeyId)) {
 445                         signerCert = cert;
 446                         break;
 447                     } else {
 448                         // The certificate does not have a SKID or may have
 449                         // been using a different algorithm (ex: see RFC 7093).
 450                         // Check if the responder&#39;s key identifier matches
 451                         // against a newly generated key identifier of the
 452                         // cert&#39;s public key using the 160-bit SHA-1 method.
 453                         try {
 454                             certKeyId = new KeyIdentifier(cert.getPublicKey());
 455                         } catch (IOException e) {
 456                             // ignore
 457                         }
 458                         if (ridKeyId.equals(certKeyId)) {
 459                             signerCert = cert;
 460                             break;
 461                         }
 462                     }
 463                 }
 464             }
 465         }
 466 
 467         // Check whether the signer cert returned by the responder is trusted
 468         if (signerCert != null) {
 469             // Check if the response is signed by the issuing CA
 470             if (signerCert.getSubjectX500Principal().equals(
 471                     issuerInfo.getName()) &amp;&amp;
 472                     signerCert.getPublicKey().equals(
 473                             issuerInfo.getPublicKey())) {
 474                 if (debug != null) {
 475                     debug.println(&quot;OCSP response is signed by the target&#39;s &quot; +
 476                         &quot;Issuing CA&quot;);
 477                 }
 478                 // cert is trusted, now verify the signed response
 479 
 480             // Check if the response is signed by a trusted responder
 481             } else if (signerCert.equals(responderCert)) {
 482                 if (debug != null) {
 483                     debug.println(&quot;OCSP response is signed by a Trusted &quot; +
 484                         &quot;Responder&quot;);
 485                 }
 486                 // cert is trusted, now verify the signed response
 487 
 488             // Check if the response is signed by an authorized responder
 489             } else if (signerCert.getIssuerX500Principal().equals(
 490                     issuerInfo.getName())) {
 491 
 492                 // Check for the OCSPSigning key purpose
 493                 try {
 494                     List&lt;String&gt; keyPurposes = signerCert.getExtendedKeyUsage();
 495                     if (keyPurposes == null ||
 496                         !keyPurposes.contains(KP_OCSP_SIGNING_OID)) {
 497                         throw new CertPathValidatorException(
 498                             &quot;Responder&#39;s certificate not valid for signing &quot; +
 499                             &quot;OCSP responses&quot;);
 500                     }
 501                 } catch (CertificateParsingException cpe) {
 502                     // assume cert is not valid for signing
 503                     throw new CertPathValidatorException(
 504                         &quot;Responder&#39;s certificate not valid for signing &quot; +
 505                         &quot;OCSP responses&quot;, cpe);
 506                 }
 507 
 508                 // Check algorithm constraints specified in security property
 509                 // &quot;jdk.certpath.disabledAlgorithms&quot;.
 510                 AlgorithmChecker algChecker =
 511                         new AlgorithmChecker(issuerInfo.getAnchor(), date,
 512                                 variant);
 513                 algChecker.init(false);
 514                 algChecker.check(signerCert, Collections.&lt;String&gt;emptySet());
 515 
 516                 // check the validity
 517                 try {
 518                     if (date == null) {
 519                         signerCert.checkValidity();
 520                     } else {
 521                         signerCert.checkValidity(date);
 522                     }
 523                 } catch (CertificateException e) {
 524                     throw new CertPathValidatorException(
 525                         &quot;Responder&#39;s certificate not within the &quot; +
 526                         &quot;validity period&quot;, e);
 527                 }
 528 
 529                 // check for revocation
 530                 //
 531                 // A CA may specify that an OCSP client can trust a
 532                 // responder for the lifetime of the responder&#39;s
 533                 // certificate. The CA does so by including the
 534                 // extension id-pkix-ocsp-nocheck.
 535                 //
 536                 Extension noCheck =
 537                     signerCert.getExtension(PKIXExtensions.OCSPNoCheck_Id);
 538                 if (noCheck != null) {
 539                     if (debug != null) {
 540                         debug.println(&quot;Responder&#39;s certificate includes &quot; +
 541                             &quot;the extension id-pkix-ocsp-nocheck.&quot;);
 542                     }
 543                 } else {
 544                     // we should do the revocation checking of the
 545                     // authorized responder in a future update.
 546                 }
 547 
 548                 // verify the signature
 549                 try {
 550                     signerCert.verify(issuerInfo.getPublicKey());
 551                     if (debug != null) {
 552                         debug.println(&quot;OCSP response is signed by an &quot; +
 553                             &quot;Authorized Responder&quot;);
 554                     }
 555                     // cert is trusted, now verify the signed response
 556 
 557                 } catch (GeneralSecurityException e) {
 558                     signerCert = null;
 559                 }
 560             } else {
 561                 throw new CertPathValidatorException(
 562                     &quot;Responder&#39;s certificate is not authorized to sign &quot; +
 563                     &quot;OCSP responses&quot;);
 564             }
 565         }
 566 
 567         // Confirm that the signed response was generated using the public
 568         // key from the trusted responder cert
 569         if (signerCert != null) {
 570             // Check algorithm constraints specified in security property
 571             // &quot;jdk.certpath.disabledAlgorithms&quot;.
 572             AlgorithmChecker.check(signerCert.getPublicKey(), sigAlgId, variant);
 573 
 574             if (!verifySignature(signerCert)) {
 575                 throw new CertPathValidatorException(
 576                     &quot;Error verifying OCSP Response&#39;s signature&quot;);
 577             }
 578         } else {
 579             // Need responder&#39;s cert in order to verify the signature
 580             throw new CertPathValidatorException(
 581                 &quot;Unable to verify OCSP Response&#39;s signature&quot;);
 582         }
 583 
 584         if (nonce != null) {
 585             if (responseNonce != null &amp;&amp; !Arrays.equals(nonce, responseNonce)) {
 586                 throw new CertPathValidatorException(&quot;Nonces don&#39;t match&quot;);
 587             }
 588         }
 589 
 590         // Check freshness of OCSPResponse
 591         long now = (date == null) ? System.currentTimeMillis() : date.getTime();
 592         Date nowPlusSkew = new Date(now + MAX_CLOCK_SKEW);
 593         Date nowMinusSkew = new Date(now - MAX_CLOCK_SKEW);
 594         for (SingleResponse sr : singleResponseMap.values()) {
 595             if (debug != null) {
 596                 String until = &quot;&quot;;
 597                 if (sr.nextUpdate != null) {
 598                     until = &quot; until &quot; + sr.nextUpdate;
 599                 }
 600                 debug.println(&quot;OCSP response validity interval is from &quot; +
 601                         sr.thisUpdate + until);
 602                 debug.println(&quot;Checking validity of OCSP response on &quot; +
 603                         new Date(now) + &quot; with allowed interval between &quot; +
 604                         nowMinusSkew + &quot; and &quot; + nowPlusSkew);
 605             }
 606 
 607             // Check that the test date is within the validity interval:
 608             //   [ thisUpdate - MAX_CLOCK_SKEW,
 609             //     MAX(thisUpdate, nextUpdate) + MAX_CLOCK_SKEW ]
 610             if (nowPlusSkew.before(sr.thisUpdate) ||
 611                     nowMinusSkew.after(
 612                     sr.nextUpdate != null ? sr.nextUpdate : sr.thisUpdate))
 613             {
 614                 throw new CertPathValidatorException(
 615                                       &quot;Response is unreliable: its validity &quot; +
 616                                       &quot;interval is out-of-date&quot;);
 617             }
 618         }
 619     }
 620 
 621     /**
 622      * Returns the OCSP ResponseStatus.
 623      *
 624      * @return the {@code ResponseStatus} for this OCSP response
 625      */
 626     public ResponseStatus getResponseStatus() {
 627         return responseStatus;
 628     }
 629 
 630     /*
 631      * Verify the signature of the OCSP response.
 632      */
 633     private boolean verifySignature(X509Certificate cert)
 634         throws CertPathValidatorException {
 635 
 636         try {
 637             Signature respSignature = Signature.getInstance(sigAlgId.getName());
 638             respSignature.initVerify(cert.getPublicKey());
 639             respSignature.update(tbsResponseData);
 640 
 641             if (respSignature.verify(signature)) {
 642                 if (debug != null) {
 643                     debug.println(&quot;Verified signature of OCSP Response&quot;);
 644                 }
 645                 return true;
 646 
 647             } else {
 648                 if (debug != null) {
 649                     debug.println(
 650                         &quot;Error verifying signature of OCSP Response&quot;);
 651                 }
 652                 return false;
 653             }
 654         } catch (InvalidKeyException | NoSuchAlgorithmException |
 655                  SignatureException e)
 656         {
 657             throw new CertPathValidatorException(e);
 658         }
 659     }
 660 
 661     /**
 662      * Returns the SingleResponse of the specified CertId, or null if
 663      * there is no response for that CertId.
 664      *
 665      * @param certId the {@code CertId} for a {@code SingleResponse} to be
 666      * searched for in the OCSP response.
 667      *
 668      * @return the {@code SingleResponse} for the provided {@code CertId},
 669      * or {@code null} if it is not found.
 670      */
 671     public SingleResponse getSingleResponse(CertId certId) {
 672         return singleResponseMap.get(certId);
 673     }
 674 
 675     /**
 676      * Return a set of all CertIds in this {@code OCSPResponse}
 677      *
 678      * @return an unmodifiable set containing every {@code CertId} in this
 679      *      response.
 680      */
 681     public Set&lt;CertId&gt; getCertIds() {
 682         return Collections.unmodifiableSet(singleResponseMap.keySet());
 683     }
 684 
 685     /*
 686      * Returns the certificate for the authority that signed the OCSP response.
 687      */
 688     X509Certificate getSignerCertificate() {
 689         return signerCert; // set in verify()
 690     }
 691 
 692     /**
 693      * Get the {@code ResponderId} from this {@code OCSPResponse}
 694      *
 695      * @return the {@code ResponderId} from this response or {@code null}
 696      *      if no responder ID is in the body of the response (e.g. a
 697      *      response with a status other than SUCCESS.
 698      */
 699     public ResponderId getResponderId() {
 700         return respId;
 701     }
 702 
 703     /**
 704      * Provide a String representation of an OCSPResponse
 705      *
 706      * @return a human-readable representation of the OCSPResponse
 707      */
 708     @Override
 709     public String toString() {
 710         StringBuilder sb = new StringBuilder();
 711         sb.append(&quot;OCSP Response:\n&quot;);
 712         sb.append(&quot;Response Status: &quot;).append(responseStatus).append(&quot;\n&quot;);
 713         sb.append(&quot;Responder ID: &quot;).append(respId).append(&quot;\n&quot;);
 714         sb.append(&quot;Produced at: &quot;).append(producedAtDate).append(&quot;\n&quot;);
 715         int count = singleResponseMap.size();
 716         sb.append(count).append(count == 1 ?
 717                 &quot; response:\n&quot; : &quot; responses:\n&quot;);
 718         for (SingleResponse sr : singleResponseMap.values()) {
 719             sb.append(sr).append(&quot;\n&quot;);
 720         }
 721         if (responseExtensions != null &amp;&amp; responseExtensions.size() &gt; 0) {
 722             count = responseExtensions.size();
 723             sb.append(count).append(count == 1 ?
 724                     &quot; extension:\n&quot; : &quot; extensions:\n&quot;);
 725             for (String extId : responseExtensions.keySet()) {
 726                 sb.append(responseExtensions.get(extId)).append(&quot;\n&quot;);
 727             }
 728         }
 729 
 730         return sb.toString();
 731     }
 732 
 733     /**
 734      * Build a String-Extension map from DER encoded data.
 735      * @param derVal A {@code DerValue} object built from a SEQUENCE of
 736      *      extensions
 737      *
 738      * @return a {@code Map} using the OID in string form as the keys.  If no
 739      *      extensions are found or an empty SEQUENCE is passed in, then
 740      *      an empty {@code Map} will be returned.
 741      *
 742      * @throws IOException if any decoding errors occur.
 743      */
 744     private static Map&lt;String, java.security.cert.Extension&gt;
 745         parseExtensions(DerValue derVal) throws IOException {
 746         DerValue[] extDer = derVal.data.getSequence(3);
 747         Map&lt;String, java.security.cert.Extension&gt; extMap =
 748                 new HashMap&lt;&gt;(extDer.length);
 749 
 750         for (DerValue extDerVal : extDer) {
 751             Extension ext = new Extension(extDerVal);
 752             if (debug != null) {
 753                 debug.println(&quot;Extension: &quot; + ext);
 754             }
 755             // We don&#39;t support any extensions yet. Therefore, if it
 756             // is critical we must throw an exception because we
 757             // don&#39;t know how to process it.
 758             if (ext.isCritical()) {
 759                 throw new IOException(&quot;Unsupported OCSP critical extension: &quot; +
 760                         ext.getExtensionId());
 761             }
 762             extMap.put(ext.getId(), ext);
 763         }
 764 
 765         return extMap;
 766     }
 767 
 768     /*
 769      * A class representing a single OCSP response.
 770      */
 771     public static final class SingleResponse implements OCSP.RevocationStatus {
 772         private final CertId certId;
 773         private final CertStatus certStatus;
 774         private final Date thisUpdate;
 775         private final Date nextUpdate;
 776         private final Date revocationTime;
 777         private final CRLReason revocationReason;
 778         private final Map&lt;String, java.security.cert.Extension&gt; singleExtensions;
 779 
 780         private SingleResponse(DerValue der) throws IOException {
 781             if (der.tag != DerValue.tag_Sequence) {
 782                 throw new IOException(&quot;Bad ASN.1 encoding in SingleResponse&quot;);
 783             }
 784             DerInputStream tmp = der.data;
 785 
 786             certId = new CertId(tmp.getDerValue().data);
 787             DerValue derVal = tmp.getDerValue();
 788             short tag = (byte)(derVal.tag &amp; 0x1f);
 789             if (tag ==  CERT_STATUS_REVOKED) {
 790                 certStatus = CertStatus.REVOKED;
 791                 revocationTime = derVal.data.getGeneralizedTime();
 792                 if (derVal.data.available() != 0) {
 793                     DerValue dv = derVal.data.getDerValue();
 794                     tag = (byte)(dv.tag &amp; 0x1f);
 795                     if (tag == 0) {
 796                         int reason = dv.data.getEnumerated();
 797                         // if reason out-of-range just leave as UNSPECIFIED
 798                         if (reason &gt;= 0 &amp;&amp; reason &lt; values.length) {
 799                             revocationReason = values[reason];
 800                         } else {
 801                             revocationReason = CRLReason.UNSPECIFIED;
 802                         }
 803                     } else {
 804                         revocationReason = CRLReason.UNSPECIFIED;
 805                     }
 806                 } else {
 807                     revocationReason = CRLReason.UNSPECIFIED;
 808                 }
 809                 // RevokedInfo
 810                 if (debug != null) {
 811                     debug.println(&quot;Revocation time: &quot; + revocationTime);
 812                     debug.println(&quot;Revocation reason: &quot; + revocationReason);
 813                 }
 814             } else {
 815                 revocationTime = null;
 816                 revocationReason = null;
 817                 if (tag == CERT_STATUS_GOOD) {
 818                     certStatus = CertStatus.GOOD;
 819                 } else if (tag == CERT_STATUS_UNKNOWN) {
 820                     certStatus = CertStatus.UNKNOWN;
 821                 } else {
 822                     throw new IOException(&quot;Invalid certificate status&quot;);
 823                 }
 824             }
 825 
 826             thisUpdate = tmp.getGeneralizedTime();
 827             if (debug != null) {
 828                 debug.println(&quot;thisUpdate: &quot; + thisUpdate);
 829             }
 830 
 831             // Parse optional fields like nextUpdate and singleExtensions
 832             Date tmpNextUpdate = null;
 833             Map&lt;String, java.security.cert.Extension&gt; tmpMap = null;
 834 
 835             // Check for the first optional item, it could be nextUpdate
 836             // [CONTEXT 0] or singleExtensions [CONTEXT 1]
 837             if (tmp.available() &gt; 0) {
 838                 derVal = tmp.getDerValue();
 839 
 840                 // nextUpdate processing
 841                 if (derVal.isContextSpecific((byte)0)) {
 842                     tmpNextUpdate = derVal.data.getGeneralizedTime();
 843                     if (debug != null) {
 844                         debug.println(&quot;nextUpdate: &quot; + tmpNextUpdate);
 845                     }
 846 
 847                     // If more data exists in the singleResponse, it
 848                     // can only be singleExtensions.  Get this DER value
 849                     // for processing in the next block
 850                     derVal = tmp.available() &gt; 0 ? tmp.getDerValue() : null;
 851                 }
 852 
 853                 // singleExtensions processing
 854                 if (derVal != null) {
 855                     if (derVal.isContextSpecific((byte)1)) {
 856                         tmpMap = parseExtensions(derVal);
 857 
 858                         // There should not be any other items in the
 859                         // singleResponse at this point.
 860                         if (tmp.available() &gt; 0) {
 861                             throw new IOException(tmp.available() +
 862                                 &quot; bytes of additional data in singleResponse&quot;);
 863                         }
 864                     } else {
 865                         // Unknown item in the singleResponse
 866                         throw new IOException(&quot;Unsupported singleResponse &quot; +
 867                             &quot;item, tag = &quot; + String.format(&quot;%02X&quot;, derVal.tag));
 868                     }
 869                 }
 870             }
 871 
 872             nextUpdate = tmpNextUpdate;
 873             singleExtensions = (tmpMap != null) ? tmpMap :
 874                     Collections.emptyMap();
 875             if (debug != null) {
 876                 for (java.security.cert.Extension ext :
 877                         singleExtensions.values()) {
 878                    debug.println(&quot;singleExtension: &quot; + ext);
 879                 }
 880             }
 881         }
 882 
 883         /*
 884          * Return the certificate&#39;s revocation status code
 885          */
 886         @Override
 887         public CertStatus getCertStatus() {
 888             return certStatus;
 889         }
 890 
 891         /**
 892          * Get the Cert ID that this SingleResponse is for.
 893          *
 894          * @return the {@code CertId} for this {@code SingleResponse}
 895          */
 896         public CertId getCertId() {
 897             return certId;
 898         }
 899 
 900         /**
 901          * Get the {@code thisUpdate} field from this {@code SingleResponse}.
 902          *
 903          * @return a {@link Date} object containing the thisUpdate date
 904          */
 905         public Date getThisUpdate() {
 906             return (thisUpdate != null ? (Date) thisUpdate.clone() : null);
 907         }
 908 
 909         /**
 910          * Get the {@code nextUpdate} field from this {@code SingleResponse}.
 911          *
 912          * @return a {@link Date} object containing the nexUpdate date or
 913          * {@code null} if a nextUpdate field is not present in the response.
 914          */
 915         public Date getNextUpdate() {
 916             return (nextUpdate != null ? (Date) nextUpdate.clone() : null);
 917         }
 918 
 919         /**
 920          * Get the {@code revocationTime} field from this
 921          * {@code SingleResponse}.
 922          *
 923          * @return a {@link Date} object containing the revocationTime date or
 924          * {@code null} if the {@code SingleResponse} does not have a status
 925          * of {@code REVOKED}.
 926          */
 927         @Override
 928         public Date getRevocationTime() {
 929             return (revocationTime != null ? (Date) revocationTime.clone() :
 930                     null);
 931         }
 932 
 933         /**
 934          * Get the {@code revocationReason} field for the
 935          * {@code SingleResponse}.
 936          *
 937          * @return a {@link CRLReason} containing the revocation reason, or
 938          * {@code null} if a revocation reason was not provided or the
 939          * response status is not {@code REVOKED}.
 940          */
 941         @Override
 942         public CRLReason getRevocationReason() {
 943             return revocationReason;
 944         }
 945 
 946         /**
 947          * Get the {@code singleExtensions} for this {@code SingleResponse}.
 948          *
 949          * @return a {@link Map} of {@link Extension} objects, keyed by
 950          * their OID value in string form.
 951          */
 952         @Override
 953         public Map&lt;String, java.security.cert.Extension&gt; getSingleExtensions() {
 954             return Collections.unmodifiableMap(singleExtensions);
 955         }
 956 
 957         /**
 958          * Construct a string representation of a single OCSP response.
 959          */
 960         @Override public String toString() {
 961             StringBuilder sb = new StringBuilder();
 962             sb.append(&quot;SingleResponse:\n&quot;);
 963             sb.append(certId);
 964             sb.append(&quot;\nCertStatus: &quot;).append(certStatus).append(&quot;\n&quot;);
 965             if (certStatus == CertStatus.REVOKED) {
 966                 sb.append(&quot;revocationTime is &quot;);
 967                 sb.append(revocationTime).append(&quot;\n&quot;);
 968                 sb.append(&quot;revocationReason is &quot;);
 969                 sb.append(revocationReason).append(&quot;\n&quot;);
 970             }
 971             sb.append(&quot;thisUpdate is &quot;).append(thisUpdate).append(&quot;\n&quot;);
 972             if (nextUpdate != null) {
 973                 sb.append(&quot;nextUpdate is &quot;).append(nextUpdate).append(&quot;\n&quot;);
 974             }
 975             for (java.security.cert.Extension ext : singleExtensions.values()) {
 976                 sb.append(&quot;singleExtension: &quot;);
 977                 sb.append(ext.toString()).append(&quot;\n&quot;);
 978             }
 979             return sb.toString();
 980         }
 981     }
 982 
 983     /**
 984      * Helper class that allows consumers to pass in issuer information.  This
 985      * will always consist of the issuer&#39;s name and public key, but may also
 986      * contain a certificate if the originating data is in that form.  The
 987      * trust anchor for the certificate chain will be included for certpath
 988      * disabled algorithm checking.
 989      */
 990     static final class IssuerInfo {
 991         private final TrustAnchor anchor;
 992         private final X509Certificate certificate;
 993         private final X500Principal name;
 994         private final PublicKey pubKey;
 995 
 996         IssuerInfo(TrustAnchor anchor) {
 997             this(anchor, (anchor != null) ? anchor.getTrustedCert() : null);
 998         }
 999 
1000         IssuerInfo(X509Certificate issuerCert) {
1001             this(null, issuerCert);
1002         }
1003 
1004         IssuerInfo(TrustAnchor anchor, X509Certificate issuerCert) {
1005             if (anchor == null &amp;&amp; issuerCert == null) {
1006                 throw new NullPointerException(&quot;TrustAnchor and issuerCert &quot; +
1007                         &quot;cannot be null&quot;);
1008             }
1009             this.anchor = anchor;
1010             if (issuerCert != null) {
1011                 name = issuerCert.getSubjectX500Principal();
1012                 pubKey = issuerCert.getPublicKey();
1013                 certificate = issuerCert;
1014             } else {
1015                 name = anchor.getCA();
1016                 pubKey = anchor.getCAPublicKey();
1017                 certificate = anchor.getTrustedCert();
1018             }
1019         }
1020 
1021         /**
1022          * Get the certificate in this IssuerInfo if present.
1023          *
1024          * @return the {@code X509Certificate} used to create this IssuerInfo
1025          * object, or {@code null} if a certificate was not used in its
1026          * creation.
1027          */
1028         X509Certificate getCertificate() {
1029             return certificate;
1030         }
1031 
1032         /**
1033          * Get the name of this issuer.
1034          *
1035          * @return an {@code X500Principal} corresponding to this issuer&#39;s
1036          * name.  If derived from an issuer&#39;s {@code X509Certificate} this
1037          * would be equivalent to the certificate subject name.
1038          */
1039         X500Principal getName() {
1040             return name;
1041         }
1042 
1043         /**
1044          * Get the public key for this issuer.
1045          *
1046          * @return a {@code PublicKey} for this issuer.
1047          */
1048         PublicKey getPublicKey() {
1049             return pubKey;
1050         }
1051 
1052         /**
1053          * Get the TrustAnchor for the certificate chain.
1054          *
1055          * @return a {@code TrustAnchor}.
1056          */
1057         TrustAnchor getAnchor() {
1058             return anchor;
1059         }
1060 
1061         /**
1062          * Create a string representation of this IssuerInfo.
1063          *
1064          * @return a {@code String} form of this IssuerInfo object.
1065          */
1066         @Override
1067         public String toString() {
1068             StringBuilder sb = new StringBuilder();
1069             sb.append(&quot;Issuer Info:\n&quot;);
1070             sb.append(&quot;Name: &quot;).append(name.toString()).append(&quot;\n&quot;);
1071             sb.append(&quot;Public Key:\n&quot;).append(pubKey.toString()).append(&quot;\n&quot;);
1072             return sb.toString();
1073         }
1074     }
1075 }
    </pre>
  </body>
</html>