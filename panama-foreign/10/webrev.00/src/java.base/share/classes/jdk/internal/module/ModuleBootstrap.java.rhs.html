<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.module;
  27 
  28 import java.io.File;
  29 import java.io.PrintStream;
  30 import java.lang.module.Configuration;
  31 import java.lang.module.ModuleDescriptor;
  32 import java.lang.module.ModuleFinder;
  33 import java.lang.module.ModuleReference;
  34 import java.lang.module.ResolvedModule;
  35 import java.net.URI;
  36 import java.nio.file.Path;
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.Iterator;
  42 import java.util.LinkedHashMap;
  43 import java.util.List;
  44 import java.util.Map;
  45 import java.util.NoSuchElementException;
  46 import java.util.Objects;
  47 import java.util.Optional;
  48 import java.util.Set;
  49 import java.util.function.Function;
  50 import java.util.stream.Collectors;
  51 
  52 import jdk.internal.loader.BootLoader;
  53 import jdk.internal.loader.BuiltinClassLoader;
  54 import jdk.internal.access.JavaLangAccess;
  55 import jdk.internal.access.JavaLangModuleAccess;
  56 import jdk.internal.access.SharedSecrets;
  57 import jdk.internal.perf.PerfCounter;
  58 
  59 /**
  60  * Initializes/boots the module system.
  61  *
  62  * The {@link #boot() boot} method is called early in the startup to initialize
  63  * the module system. In summary, the boot method creates a Configuration by
  64  * resolving a set of module names specified via the launcher (or equivalent)
  65  * -m and --add-modules options. The modules are located on a module path that
  66  * is constructed from the upgrade module path, system modules, and application
  67  * module path. The Configuration is instantiated as the boot layer with each
  68  * module in the configuration defined to a class loader.
  69  */
  70 
  71 public final class ModuleBootstrap {
  72     private ModuleBootstrap() { }
  73 
  74     private static final String JAVA_BASE = &quot;java.base&quot;;
  75 
  76     // the token for &quot;all default modules&quot;
  77     private static final String ALL_DEFAULT = &quot;ALL-DEFAULT&quot;;
  78 
  79     // the token for &quot;all unnamed modules&quot;
  80     private static final String ALL_UNNAMED = &quot;ALL-UNNAMED&quot;;
  81 
  82     // the token for &quot;all system modules&quot;
  83     private static final String ALL_SYSTEM = &quot;ALL-SYSTEM&quot;;
  84 
  85     // the token for &quot;all modules on the module path&quot;
  86     private static final String ALL_MODULE_PATH = &quot;ALL-MODULE-PATH&quot;;
  87 
  88     // access to java.lang/module
  89     private static final JavaLangModuleAccess JLMA
  90         = SharedSecrets.getJavaLangModuleAccess();
  91 
  92     // The ModulePatcher for the initial configuration
  93     private static final ModulePatcher patcher = initModulePatcher();
  94 
  95     /**
  96      * Returns the ModulePatcher for the initial configuration.
  97      */
  98     public static ModulePatcher patcher() {
  99         return patcher;
 100     }
 101 
 102     // ModuleFinders for the initial configuration
 103     private static volatile ModuleFinder unlimitedFinder;
 104     private static volatile ModuleFinder limitedFinder;
 105 
 106     /**
 107      * Returns the ModuleFinder for the initial configuration before
 108      * observability is limited by the --limit-modules command line option.
 109      *
 110      * @apiNote Used to support locating modules {@code java.instrument} and
 111      * {@code jdk.management.agent} modules when they are loaded dynamically.
 112      */
 113     public static ModuleFinder unlimitedFinder() {
 114         ModuleFinder finder = unlimitedFinder;
 115         if (finder == null) {
 116             return ModuleFinder.ofSystem();
 117         } else {
 118             return finder;
 119         }
 120     }
 121 
 122     /**
 123      * Returns the ModuleFinder for the initial configuration.
 124      *
 125      * @apiNote Used to support &quot;{@code java --list-modules}&quot;.
 126      */
 127     public static ModuleFinder limitedFinder() {
 128         ModuleFinder finder = limitedFinder;
 129         if (finder == null) {
 130             return unlimitedFinder();
 131         } else {
 132             return finder;
 133         }
 134     }
 135 
 136     /**
 137      * Initialize the module system, returning the boot layer.
 138      *
 139      * @see java.lang.System#initPhase2(boolean, boolean)
 140      */
 141     public static ModuleLayer boot() throws Exception {
 142 
<a name="2" id="anc2"></a><span class="line-modified"> 143         Counters.start();</span>
 144 
<a name="3" id="anc3"></a><span class="line-modified"> 145         // Step 0: Command line options</span>
 146 
 147         ModuleFinder upgradeModulePath = finderFor(&quot;jdk.module.upgrade.path&quot;);
 148         ModuleFinder appModulePath = finderFor(&quot;jdk.module.path&quot;);
 149         boolean isPatched = patcher.hasPatches();
 150 
 151         String mainModule = System.getProperty(&quot;jdk.module.main&quot;);
 152         Set&lt;String&gt; addModules = addModules();
 153         Set&lt;String&gt; limitModules = limitModules();
 154 
 155         PrintStream traceOutput = null;
 156         String trace = getAndRemoveProperty(&quot;jdk.module.showModuleResolution&quot;);
 157         if (trace != null &amp;&amp; Boolean.parseBoolean(trace))
 158             traceOutput = System.out;
 159 
<a name="4" id="anc4"></a><span class="line-added"> 160         Counters.add(&quot;jdk.module.boot.0.commandLineTime&quot;);</span>
 161 
 162         // Step 1: The observable system modules, either all system modules
 163         // or the system modules pre-generated for the initial module (the
 164         // initial module may be the unnamed module). If the system modules
 165         // are pre-generated for the initial module then resolution can be
 166         // skipped.
 167 
<a name="5" id="anc5"></a>

 168         SystemModules systemModules = null;
 169         ModuleFinder systemModuleFinder;
 170 
 171         boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);
 172         boolean needResolution = true;
 173         boolean canArchive = false;
 174         boolean hasSplitPackages;
 175         boolean hasIncubatorModules;
 176 
 177         // If the java heap was archived at CDS dump time and the environment
 178         // at dump time matches the current environment then use the archived
 179         // system modules and finder.
 180         ArchivedModuleGraph archivedModuleGraph = ArchivedModuleGraph.get(mainModule);
 181         if (archivedModuleGraph != null
 182                 &amp;&amp; !haveModulePath
 183                 &amp;&amp; addModules.isEmpty()
 184                 &amp;&amp; limitModules.isEmpty()
 185                 &amp;&amp; !isPatched) {
 186             systemModuleFinder = archivedModuleGraph.finder();
 187             hasSplitPackages = archivedModuleGraph.hasSplitPackages();
 188             hasIncubatorModules = archivedModuleGraph.hasIncubatorModules();
 189             needResolution = (traceOutput != null);
 190         } else {
 191             if (!haveModulePath &amp;&amp; addModules.isEmpty() &amp;&amp; limitModules.isEmpty()) {
 192                 systemModules = SystemModuleFinders.systemModules(mainModule);
 193                 if (systemModules != null &amp;&amp; !isPatched) {
 194                     needResolution = (traceOutput != null);
 195                     canArchive = true;
 196                 }
 197             }
 198             if (systemModules == null) {
 199                 // all system modules are observable
 200                 systemModules = SystemModuleFinders.allSystemModules();
 201             }
 202             if (systemModules != null) {
 203                 // images build
 204                 systemModuleFinder = SystemModuleFinders.of(systemModules);
 205             } else {
 206                 // exploded build or testing
 207                 systemModules = new ExplodedSystemModules();
 208                 systemModuleFinder = SystemModuleFinders.ofSystem();
 209             }
 210 
 211             hasSplitPackages = systemModules.hasSplitPackages();
 212             hasIncubatorModules = systemModules.hasIncubatorModules();
 213             // not using the archived module graph - avoid accidental use
 214             archivedModuleGraph = null;
 215         }
 216 
<a name="6" id="anc6"></a><span class="line-modified"> 217         Counters.add(&quot;jdk.module.boot.1.systemModulesTime&quot;);</span>

 218 
 219         // Step 2: Define and load java.base. This patches all classes loaded
 220         // to date so that they are members of java.base. Once java.base is
 221         // loaded then resources in java.base are available for error messages
 222         // needed from here on.
 223 
<a name="7" id="anc7"></a>

 224         ModuleReference base = systemModuleFinder.find(JAVA_BASE).orElse(null);
 225         if (base == null)
 226             throw new InternalError(JAVA_BASE + &quot; not found&quot;);
 227         URI baseUri = base.location().orElse(null);
 228         if (baseUri == null)
 229             throw new InternalError(JAVA_BASE + &quot; does not have a location&quot;);
 230         BootLoader.loadModule(base);
 231         Modules.defineModule(null, base.descriptor(), baseUri);
 232 
<a name="8" id="anc8"></a>


 233         // Step 2a: Scan all modules when --validate-modules specified
 234 
 235         if (getAndRemoveProperty(&quot;jdk.module.validation&quot;) != null) {
 236             int errors = ModulePathValidator.scanAllModules(System.out);
 237             if (errors &gt; 0) {
 238                 fail(&quot;Validation of module path failed&quot;);
 239             }
 240         }
 241 
<a name="9" id="anc9"></a><span class="line-added"> 242         Counters.add(&quot;jdk.module.boot.2.defineBaseTime&quot;);</span>
 243 
 244         // Step 3: If resolution is needed then create the module finder and
 245         // the set of root modules to resolve.
 246 
<a name="10" id="anc10"></a>

 247         ModuleFinder savedModuleFinder = null;
 248         ModuleFinder finder;
 249         Set&lt;String&gt; roots;
 250         if (needResolution) {
 251 
 252             // upgraded modules override the modules in the run-time image
 253             if (upgradeModulePath != null)
 254                 systemModuleFinder = ModuleFinder.compose(upgradeModulePath,
 255                                                           systemModuleFinder);
 256 
 257             // The module finder: [--upgrade-module-path] system [--module-path]
 258             if (appModulePath != null) {
 259                 finder = ModuleFinder.compose(systemModuleFinder, appModulePath);
 260             } else {
 261                 finder = systemModuleFinder;
 262             }
 263 
 264             // The root modules to resolve
 265             roots = new HashSet&lt;&gt;();
 266 
 267             // launcher -m option to specify the main/initial module
 268             if (mainModule != null)
 269                 roots.add(mainModule);
 270 
 271             // additional module(s) specified by --add-modules
 272             boolean addAllDefaultModules = false;
 273             boolean addAllSystemModules = false;
 274             boolean addAllApplicationModules = false;
 275             for (String mod : addModules) {
 276                 switch (mod) {
 277                     case ALL_DEFAULT:
 278                         addAllDefaultModules = true;
 279                         break;
 280                     case ALL_SYSTEM:
 281                         addAllSystemModules = true;
 282                         break;
 283                     case ALL_MODULE_PATH:
 284                         addAllApplicationModules = true;
 285                         break;
 286                     default:
 287                         roots.add(mod);
 288                 }
 289             }
 290 
 291             // --limit-modules
 292             savedModuleFinder = finder;
 293             if (!limitModules.isEmpty()) {
 294                 finder = limitFinder(finder, limitModules, roots);
 295             }
 296 
 297             // If there is no initial module specified then assume that the initial
 298             // module is the unnamed module of the application class loader. This
 299             // is implemented by resolving all observable modules that export an
 300             // API. Modules that have the DO_NOT_RESOLVE_BY_DEFAULT bit set in
 301             // their ModuleResolution attribute flags are excluded from the
 302             // default set of roots.
 303             if (mainModule == null || addAllDefaultModules) {
 304                 roots.addAll(DefaultRoots.compute(systemModuleFinder, finder));
 305             }
 306 
 307             // If `--add-modules ALL-SYSTEM` is specified then all observable system
 308             // modules will be resolved.
 309             if (addAllSystemModules) {
 310                 ModuleFinder f = finder;  // observable modules
 311                 systemModuleFinder.findAll()
 312                     .stream()
 313                     .map(ModuleReference::descriptor)
 314                     .map(ModuleDescriptor::name)
 315                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 316                     .forEach(mn -&gt; roots.add(mn));
 317             }
 318 
 319             // If `--add-modules ALL-MODULE-PATH` is specified then all observable
 320             // modules on the application module path will be resolved.
 321             if (appModulePath != null &amp;&amp; addAllApplicationModules) {
 322                 ModuleFinder f = finder;  // observable modules
 323                 appModulePath.findAll()
 324                     .stream()
 325                     .map(ModuleReference::descriptor)
 326                     .map(ModuleDescriptor::name)
 327                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 328                     .forEach(mn -&gt; roots.add(mn));
 329             }
 330         } else {
 331             // no resolution case
 332             finder = systemModuleFinder;
 333             roots = null;
 334         }
 335 
<a name="11" id="anc11"></a><span class="line-modified"> 336         Counters.add(&quot;jdk.module.boot.3.optionsAndRootsTime&quot;);</span>
 337 
 338         // Step 4: Resolve the root modules, with service binding, to create
 339         // the configuration for the boot layer. If resolution is not needed
 340         // then create the configuration for the boot layer from the
 341         // readability graph created at link time.
 342 
<a name="12" id="anc12"></a>

 343         Configuration cf;
 344         if (needResolution) {
 345             cf = Modules.newBootLayerConfiguration(finder, roots, traceOutput);
 346         } else {
 347             if (archivedModuleGraph != null) {
 348                 cf = archivedModuleGraph.configuration();
 349             } else {
 350                 Map&lt;String, Set&lt;String&gt;&gt; map = systemModules.moduleReads();
 351                 cf = JLMA.newConfiguration(systemModuleFinder, map);
 352             }
 353         }
 354 
 355         // check that modules specified to --patch-module are resolved
 356         if (isPatched) {
 357             patcher.patchedModules()
 358                     .stream()
 359                     .filter(mn -&gt; !cf.findModule(mn).isPresent())
 360                     .forEach(mn -&gt; warnUnknownModule(PATCH_MODULE, mn));
 361         }
 362 
<a name="13" id="anc13"></a><span class="line-modified"> 363         Counters.add(&quot;jdk.module.boot.4.resolveTime&quot;);</span>

 364 
 365         // Step 5: Map the modules in the configuration to class loaders.
 366         // The static configuration provides the mapping of standard and JDK
 367         // modules to the boot and platform loaders. All other modules (JDK
 368         // tool modules, and both explicit and automatic modules on the
 369         // application module path) are defined to the application class
 370         // loader.
 371 
<a name="14" id="anc14"></a>

 372         // mapping of modules to class loaders
 373         Function&lt;String, ClassLoader&gt; clf = ModuleLoaderMap.mappingFunction(cf);
 374 
 375         // check that all modules to be mapped to the boot loader will be
 376         // loaded from the runtime image
 377         if (haveModulePath) {
 378             for (ResolvedModule resolvedModule : cf.modules()) {
 379                 ModuleReference mref = resolvedModule.reference();
 380                 String name = mref.descriptor().name();
 381                 ClassLoader cl = clf.apply(name);
 382                 if (cl == null) {
 383                     if (upgradeModulePath != null
 384                             &amp;&amp; upgradeModulePath.find(name).isPresent())
 385                         fail(name + &quot;: cannot be loaded from upgrade module path&quot;);
 386                     if (!systemModuleFinder.find(name).isPresent())
 387                         fail(name + &quot;: cannot be loaded from application module path&quot;);
 388                 }
 389             }
 390         }
 391 
 392         // check for split packages in the modules mapped to the built-in loaders
 393         if (hasSplitPackages || isPatched || haveModulePath) {
 394             checkSplitPackages(cf, clf);
 395         }
 396 
 397         // load/register the modules with the built-in class loaders
 398         loadModules(cf, clf);
<a name="15" id="anc15"></a><span class="line-modified"> 399         Counters.add(&quot;jdk.module.boot.5.loadModulesTime&quot;);</span>


 400 
 401         // Step 6: Define all modules to the VM
 402 
<a name="16" id="anc16"></a>
 403         ModuleLayer bootLayer = ModuleLayer.empty().defineModules(cf, clf);
<a name="17" id="anc17"></a><span class="line-modified"> 404         Counters.add(&quot;jdk.module.boot.6.layerCreateTime&quot;);</span>

 405 
 406         // Step 7: Miscellaneous
 407 
 408         // check incubating status
 409         if (hasIncubatorModules || haveModulePath) {
 410             checkIncubatingStatus(cf);
 411         }
 412 
 413         // --add-reads, --add-exports/--add-opens, and --illegal-access
<a name="18" id="anc18"></a>
 414         addExtraReads(bootLayer);
 415         boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);
 416 
 417         Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen;
 418         Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen;
 419         if (archivedModuleGraph != null) {
 420             concealedPackagesToOpen = archivedModuleGraph.concealedPackagesToOpen();
 421             exportedPackagesToOpen = archivedModuleGraph.exportedPackagesToOpen();
 422         } else {
 423             concealedPackagesToOpen = systemModules.concealedPackagesToOpen();
 424             exportedPackagesToOpen = systemModules.exportedPackagesToOpen();
 425         }
 426         addIllegalAccess(upgradeModulePath,
 427                          concealedPackagesToOpen,
 428                          exportedPackagesToOpen,
 429                          bootLayer,
 430                          extraExportsOrOpens);
<a name="19" id="anc19"></a><span class="line-modified"> 431         Counters.add(&quot;jdk.module.boot.7.adjustModulesTime&quot;);</span>
 432 
 433         // save module finders for later use
 434         if (savedModuleFinder != null) {
 435             unlimitedFinder = new SafeModuleFinder(savedModuleFinder);
 436             if (savedModuleFinder != finder)
 437                 limitedFinder = new SafeModuleFinder(finder);
 438         }
 439 
 440         // Module graph can be archived at CDS dump time. Only allow the
 441         // unnamed module case for now.
 442         if (canArchive &amp;&amp; (mainModule == null)) {
 443             ArchivedModuleGraph.archive(mainModule,
 444                                         hasSplitPackages,
 445                                         hasIncubatorModules,
 446                                         systemModuleFinder,
 447                                         cf,
 448                                         concealedPackagesToOpen,
 449                                         exportedPackagesToOpen);
 450         }
 451 
 452         // total time to initialize
<a name="20" id="anc20"></a><span class="line-modified"> 453         Counters.publish(&quot;jdk.module.boot.totalTime&quot;);</span>

 454 
 455         return bootLayer;
 456     }
 457 
 458     /**
 459      * Load/register the modules to the built-in class loaders.
 460      */
 461     private static void loadModules(Configuration cf,
 462                                     Function&lt;String, ClassLoader&gt; clf) {
 463         for (ResolvedModule resolvedModule : cf.modules()) {
 464             ModuleReference mref = resolvedModule.reference();
 465             String name = resolvedModule.name();
 466             ClassLoader loader = clf.apply(name);
 467             if (loader == null) {
 468                 // skip java.base as it is already loaded
 469                 if (!name.equals(JAVA_BASE)) {
 470                     BootLoader.loadModule(mref);
 471                 }
 472             } else if (loader instanceof BuiltinClassLoader) {
 473                 ((BuiltinClassLoader) loader).loadModule(mref);
 474             }
 475         }
 476     }
 477 
 478     /**
 479      * Checks for split packages between modules defined to the built-in class
 480      * loaders.
 481      */
 482     private static void checkSplitPackages(Configuration cf,
 483                                            Function&lt;String, ClassLoader&gt; clf) {
 484         Map&lt;String, String&gt; packageToModule = new HashMap&lt;&gt;();
 485         for (ResolvedModule resolvedModule : cf.modules()) {
 486             ModuleDescriptor descriptor = resolvedModule.reference().descriptor();
 487             String name = descriptor.name();
 488             ClassLoader loader = clf.apply(name);
 489             if (loader == null || loader instanceof BuiltinClassLoader) {
 490                 for (String p : descriptor.packages()) {
 491                     String other = packageToModule.putIfAbsent(p, name);
 492                     if (other != null) {
 493                         String msg = &quot;Package &quot; + p + &quot; in both module &quot;
 494                                      + name + &quot; and module &quot; + other;
 495                         throw new LayerInstantiationException(msg);
 496                     }
 497                 }
 498             }
 499         }
 500     }
 501 
 502     /**
 503      * Returns a ModuleFinder that limits observability to the given root
 504      * modules, their transitive dependences, plus a set of other modules.
 505      */
 506     private static ModuleFinder limitFinder(ModuleFinder finder,
 507                                             Set&lt;String&gt; roots,
 508                                             Set&lt;String&gt; otherMods)
 509     {
 510         // resolve all root modules
 511         Configuration cf = Configuration.empty().resolve(finder,
 512                                                          ModuleFinder.of(),
 513                                                          roots);
 514 
 515         // module name -&gt; reference
 516         Map&lt;String, ModuleReference&gt; map = new HashMap&lt;&gt;();
 517 
 518         // root modules and their transitive dependences
 519         cf.modules().stream()
 520             .map(ResolvedModule::reference)
 521             .forEach(mref -&gt; map.put(mref.descriptor().name(), mref));
 522 
 523         // additional modules
 524         otherMods.stream()
 525             .map(finder::find)
 526             .flatMap(Optional::stream)
 527             .forEach(mref -&gt; map.putIfAbsent(mref.descriptor().name(), mref));
 528 
 529         // set of modules that are observable
 530         Set&lt;ModuleReference&gt; mrefs = new HashSet&lt;&gt;(map.values());
 531 
 532         return new ModuleFinder() {
 533             @Override
 534             public Optional&lt;ModuleReference&gt; find(String name) {
 535                 return Optional.ofNullable(map.get(name));
 536             }
 537             @Override
 538             public Set&lt;ModuleReference&gt; findAll() {
 539                 return mrefs;
 540             }
 541         };
 542     }
 543 
 544     /**
 545      * Creates a finder from the module path that is the value of the given
 546      * system property and optionally patched by --patch-module
 547      */
 548     private static ModuleFinder finderFor(String prop) {
 549         String s = System.getProperty(prop);
 550         if (s == null) {
 551             return null;
 552         } else {
 553             String[] dirs = s.split(File.pathSeparator);
 554             Path[] paths = new Path[dirs.length];
 555             int i = 0;
 556             for (String dir: dirs) {
 557                 paths[i++] = Path.of(dir);
 558             }
 559             return ModulePath.of(patcher, paths);
 560         }
 561     }
 562 
 563     /**
 564      * Initialize the module patcher for the initial configuration passed on the
 565      * value of the --patch-module options.
 566      */
 567     private static ModulePatcher initModulePatcher() {
 568         Map&lt;String, List&lt;String&gt;&gt; map = decode(&quot;jdk.module.patch.&quot;,
 569                                                File.pathSeparator,
 570                                                false);
 571         return new ModulePatcher(map);
 572     }
 573 
 574     /**
 575      * Returns the set of module names specified by --add-module options.
 576      */
 577     private static Set&lt;String&gt; addModules() {
 578         String prefix = &quot;jdk.module.addmods.&quot;;
 579         int index = 0;
 580         // the system property is removed after decoding
 581         String value = getAndRemoveProperty(prefix + index);
 582         if (value == null) {
 583             return Set.of();
 584         } else {
 585             Set&lt;String&gt; modules = new HashSet&lt;&gt;();
 586             while (value != null) {
 587                 for (String s : value.split(&quot;,&quot;)) {
 588                     if (!s.isEmpty())
 589                         modules.add(s);
 590                 }
 591                 index++;
 592                 value = getAndRemoveProperty(prefix + index);
 593             }
 594             return modules;
 595         }
 596     }
 597 
 598     /**
 599      * Returns the set of module names specified by --limit-modules.
 600      */
 601     private static Set&lt;String&gt; limitModules() {
 602         String value = getAndRemoveProperty(&quot;jdk.module.limitmods&quot;);
 603         if (value == null) {
 604             return Set.of();
 605         } else {
 606             Set&lt;String&gt; names = new HashSet&lt;&gt;();
 607             for (String name : value.split(&quot;,&quot;)) {
 608                 if (name.length() &gt; 0) names.add(name);
 609             }
 610             return names;
 611         }
 612     }
 613 
 614     /**
 615      * Process the --add-reads options to add any additional read edges that
 616      * are specified on the command-line.
 617      */
 618     private static void addExtraReads(ModuleLayer bootLayer) {
 619 
 620         // decode the command line options
 621         Map&lt;String, List&lt;String&gt;&gt; map = decode(&quot;jdk.module.addreads.&quot;);
 622         if (map.isEmpty())
 623             return;
 624 
 625         for (Map.Entry&lt;String, List&lt;String&gt;&gt; e : map.entrySet()) {
 626 
 627             // the key is $MODULE
 628             String mn = e.getKey();
 629             Optional&lt;Module&gt; om = bootLayer.findModule(mn);
 630             if (!om.isPresent()) {
 631                 warnUnknownModule(ADD_READS, mn);
 632                 continue;
 633             }
 634             Module m = om.get();
 635 
 636             // the value is the set of other modules (by name)
 637             for (String name : e.getValue()) {
 638                 if (ALL_UNNAMED.equals(name)) {
 639                     Modules.addReadsAllUnnamed(m);
 640                 } else {
 641                     om = bootLayer.findModule(name);
 642                     if (om.isPresent()) {
 643                         Modules.addReads(m, om.get());
 644                     } else {
 645                         warnUnknownModule(ADD_READS, name);
 646                     }
 647                 }
 648             }
 649         }
 650     }
 651 
 652     /**
 653      * Process the --add-exports and --add-opens options to export/open
 654      * additional packages specified on the command-line.
 655      */
 656     private static boolean addExtraExportsAndOpens(ModuleLayer bootLayer) {
 657         boolean extraExportsOrOpens = false;
 658 
 659         // --add-exports
 660         String prefix = &quot;jdk.module.addexports.&quot;;
 661         Map&lt;String, List&lt;String&gt;&gt; extraExports = decode(prefix);
 662         if (!extraExports.isEmpty()) {
 663             addExtraExportsOrOpens(bootLayer, extraExports, false);
 664             extraExportsOrOpens = true;
 665         }
 666 
 667 
 668         // --add-opens
 669         prefix = &quot;jdk.module.addopens.&quot;;
 670         Map&lt;String, List&lt;String&gt;&gt; extraOpens = decode(prefix);
 671         if (!extraOpens.isEmpty()) {
 672             addExtraExportsOrOpens(bootLayer, extraOpens, true);
 673             extraExportsOrOpens = true;
 674         }
 675 
 676         return extraExportsOrOpens;
 677     }
 678 
 679     private static void addExtraExportsOrOpens(ModuleLayer bootLayer,
 680                                                Map&lt;String, List&lt;String&gt;&gt; map,
 681                                                boolean opens)
 682     {
 683         String option = opens ? ADD_OPENS : ADD_EXPORTS;
 684         for (Map.Entry&lt;String, List&lt;String&gt;&gt; e : map.entrySet()) {
 685 
 686             // the key is $MODULE/$PACKAGE
 687             String key = e.getKey();
 688             String[] s = key.split(&quot;/&quot;);
 689             if (s.length != 2)
 690                 fail(unableToParse(option, &quot;&lt;module&gt;/&lt;package&gt;&quot;, key));
 691 
 692             String mn = s[0];
 693             String pn = s[1];
 694             if (mn.isEmpty() || pn.isEmpty())
 695                 fail(unableToParse(option, &quot;&lt;module&gt;/&lt;package&gt;&quot;, key));
 696 
 697             // The exporting module is in the boot layer
 698             Module m;
 699             Optional&lt;Module&gt; om = bootLayer.findModule(mn);
 700             if (!om.isPresent()) {
 701                 warnUnknownModule(option, mn);
 702                 continue;
 703             }
 704 
 705             m = om.get();
 706 
 707             if (!m.getDescriptor().packages().contains(pn)) {
 708                 warn(&quot;package &quot; + pn + &quot; not in &quot; + mn);
 709                 continue;
 710             }
 711 
 712             // the value is the set of modules to export to (by name)
 713             for (String name : e.getValue()) {
 714                 boolean allUnnamed = false;
 715                 Module other = null;
 716                 if (ALL_UNNAMED.equals(name)) {
 717                     allUnnamed = true;
 718                 } else {
 719                     om = bootLayer.findModule(name);
 720                     if (om.isPresent()) {
 721                         other = om.get();
 722                     } else {
 723                         warnUnknownModule(option, name);
 724                         continue;
 725                     }
 726                 }
 727                 if (allUnnamed) {
 728                     if (opens) {
 729                         Modules.addOpensToAllUnnamed(m, pn);
 730                     } else {
 731                         Modules.addExportsToAllUnnamed(m, pn);
 732                     }
 733                 } else {
 734                     if (opens) {
 735                         Modules.addOpens(m, pn, other);
 736                     } else {
 737                         Modules.addExports(m, pn, other);
 738                     }
 739                 }
 740 
 741             }
 742         }
 743     }
 744 
 745     /**
 746      * Process the --illegal-access option (and its default) to open packages
 747      * of system modules in the boot layer to code in unnamed modules.
 748      */
 749     private static void addIllegalAccess(ModuleFinder upgradeModulePath,
 750                                          Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen,
 751                                          Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen,
 752                                          ModuleLayer bootLayer,
 753                                          boolean extraExportsOrOpens) {
 754         String value = getAndRemoveProperty(&quot;jdk.module.illegalAccess&quot;);
 755         IllegalAccessLogger.Mode mode = IllegalAccessLogger.Mode.ONESHOT;
 756         if (value != null) {
 757             switch (value) {
 758                 case &quot;deny&quot;:
 759                     return;
 760                 case &quot;permit&quot;:
 761                     break;
 762                 case &quot;warn&quot;:
 763                     mode = IllegalAccessLogger.Mode.WARN;
 764                     break;
 765                 case &quot;debug&quot;:
 766                     mode = IllegalAccessLogger.Mode.DEBUG;
 767                     break;
 768                 default:
 769                     fail(&quot;Value specified to --illegal-access not recognized:&quot;
 770                             + &quot; &#39;&quot; + value + &quot;&#39;&quot;);
 771                     return;
 772             }
 773         }
 774         IllegalAccessLogger.Builder builder
 775             = new IllegalAccessLogger.Builder(mode, System.err);
 776 
 777         if (concealedPackagesToOpen.isEmpty() &amp;&amp; exportedPackagesToOpen.isEmpty()) {
 778             // need to generate (exploded build)
 779             IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());
 780             concealedPackagesToOpen = maps.concealedPackagesToOpen();
 781             exportedPackagesToOpen = maps.exportedPackagesToOpen();
 782         }
 783 
 784         // open specific packages in the system modules
<a name="21" id="anc21"></a><span class="line-added"> 785         Set&lt;String&gt; emptySet = Set.of();</span>
 786         for (Module m : bootLayer.modules()) {
 787             ModuleDescriptor descriptor = m.getDescriptor();
 788             String name = m.getName();
 789 
 790             // skip open modules
 791             if (descriptor.isOpen()) {
 792                 continue;
 793             }
 794 
 795             // skip modules loaded from the upgrade module path
 796             if (upgradeModulePath != null
 797                 &amp;&amp; upgradeModulePath.find(name).isPresent()) {
 798                 continue;
 799             }
 800 
<a name="22" id="anc22"></a><span class="line-modified"> 801             Set&lt;String&gt; concealedPackages = concealedPackagesToOpen.getOrDefault(name, emptySet);</span>
<span class="line-modified"> 802             Set&lt;String&gt; exportedPackages = exportedPackagesToOpen.getOrDefault(name, emptySet);</span>
 803 
 804             // refresh the set of concealed and exported packages if needed
 805             if (extraExportsOrOpens) {
 806                 concealedPackages = new HashSet&lt;&gt;(concealedPackages);
 807                 exportedPackages = new HashSet&lt;&gt;(exportedPackages);
 808                 Iterator&lt;String&gt; iterator = concealedPackages.iterator();
 809                 while (iterator.hasNext()) {
 810                     String pn = iterator.next();
 811                     if (m.isExported(pn, BootLoader.getUnnamedModule())) {
 812                         // concealed package is exported to ALL-UNNAMED
 813                         iterator.remove();
 814                         exportedPackages.add(pn);
 815                     }
 816                 }
 817                 iterator = exportedPackages.iterator();
 818                 while (iterator.hasNext()) {
 819                     String pn = iterator.next();
 820                     if (m.isOpen(pn, BootLoader.getUnnamedModule())) {
 821                         // exported package is opened to ALL-UNNAMED
 822                         iterator.remove();
 823                     }
 824                 }
 825             }
 826 
 827             // log reflective access to all types in concealed packages
 828             builder.logAccessToConcealedPackages(m, concealedPackages);
 829 
 830             // log reflective access to non-public members/types in exported packages
 831             builder.logAccessToExportedPackages(m, exportedPackages);
 832 
 833             // open the packages to unnamed modules
 834             JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
<a name="23" id="anc23"></a><span class="line-modified"> 835             jla.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);</span>

 836         }
 837 
 838         builder.complete();
 839     }
 840 
 841     /**
 842      * Decodes the values of --add-reads, -add-exports, --add-opens or
 843      * --patch-modules options that are encoded in system properties.
 844      *
 845      * @param prefix the system property prefix
 846      * @praam regex the regex for splitting the RHS of the option value
 847      */
 848     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix,
 849                                                     String regex,
 850                                                     boolean allowDuplicates) {
 851         int index = 0;
 852         // the system property is removed after decoding
 853         String value = getAndRemoveProperty(prefix + index);
 854         if (value == null)
 855             return Map.of();
 856 
 857         Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
 858 
 859         while (value != null) {
 860 
 861             int pos = value.indexOf(&#39;=&#39;);
 862             if (pos == -1)
 863                 fail(unableToParse(option(prefix), &quot;&lt;module&gt;=&lt;value&gt;&quot;, value));
 864             if (pos == 0)
 865                 fail(unableToParse(option(prefix), &quot;&lt;module&gt;=&lt;value&gt;&quot;, value));
 866 
 867             // key is &lt;module&gt; or &lt;module&gt;/&lt;package&gt;
 868             String key = value.substring(0, pos);
 869 
 870             String rhs = value.substring(pos+1);
 871             if (rhs.isEmpty())
 872                 fail(unableToParse(option(prefix), &quot;&lt;module&gt;=&lt;value&gt;&quot;, value));
 873 
 874             // value is &lt;module&gt;(,&lt;module&gt;)* or &lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*
 875             if (!allowDuplicates &amp;&amp; map.containsKey(key))
 876                 fail(key + &quot; specified more than once to &quot; + option(prefix));
 877             List&lt;String&gt; values = map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;());
 878             int ntargets = 0;
 879             for (String s : rhs.split(regex)) {
 880                 if (!s.isEmpty()) {
 881                     values.add(s);
 882                     ntargets++;
 883                 }
 884             }
 885             if (ntargets == 0)
 886                 fail(&quot;Target must be specified: &quot; + option(prefix) + &quot; &quot; + value);
 887 
 888             index++;
 889             value = getAndRemoveProperty(prefix + index);
 890         }
 891 
 892         return map;
 893     }
 894 
 895     /**
 896      * Decodes the values of --add-reads, -add-exports or --add-opens
 897      * which use the &quot;,&quot; to separate the RHS of the option value.
 898      */
 899     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix) {
 900         return decode(prefix, &quot;,&quot;, true);
 901     }
 902 
 903     /**
 904      * Gets and remove the named system property
 905      */
 906     private static String getAndRemoveProperty(String key) {
 907         return (String)System.getProperties().remove(key);
 908     }
 909 
 910     /**
 911      * Checks incubating status of modules in the configuration
 912      */
 913     private static void checkIncubatingStatus(Configuration cf) {
 914         String incubating = null;
 915         for (ResolvedModule resolvedModule : cf.modules()) {
 916             ModuleReference mref = resolvedModule.reference();
 917 
 918             // emit warning if the WARN_INCUBATING module resolution bit set
 919             if (ModuleResolution.hasIncubatingWarning(mref)) {
 920                 String mn = mref.descriptor().name();
 921                 if (incubating == null) {
 922                     incubating = mn;
 923                 } else {
 924                     incubating += &quot;, &quot; + mn;
 925                 }
 926             }
 927         }
 928         if (incubating != null)
 929             warn(&quot;Using incubator modules: &quot; + incubating);
 930     }
 931 
 932     /**
 933      * Throws a RuntimeException with the given message
 934      */
 935     static void fail(String m) {
 936         throw new RuntimeException(m);
 937     }
 938 
 939     static void warn(String m) {
 940         System.err.println(&quot;WARNING: &quot; + m);
 941     }
 942 
 943     static void warnUnknownModule(String option, String mn) {
 944         warn(&quot;Unknown module: &quot; + mn + &quot; specified to &quot; + option);
 945     }
 946 
 947     static String unableToParse(String option, String text, String value) {
 948         return &quot;Unable to parse &quot; +  option + &quot; &quot; + text + &quot;: &quot; + value;
 949     }
 950 
 951     private static final String ADD_MODULES  = &quot;--add-modules&quot;;
 952     private static final String ADD_EXPORTS  = &quot;--add-exports&quot;;
 953     private static final String ADD_OPENS    = &quot;--add-opens&quot;;
 954     private static final String ADD_READS    = &quot;--add-reads&quot;;
 955     private static final String PATCH_MODULE = &quot;--patch-module&quot;;
 956 
 957 
 958     /*
 959      * Returns the command-line option name corresponds to the specified
 960      * system property prefix.
 961      */
 962     static String option(String prefix) {
 963         switch (prefix) {
 964             case &quot;jdk.module.addexports.&quot;:
 965                 return ADD_EXPORTS;
 966             case &quot;jdk.module.addopens.&quot;:
 967                 return ADD_OPENS;
 968             case &quot;jdk.module.addreads.&quot;:
 969                 return ADD_READS;
 970             case &quot;jdk.module.patch.&quot;:
 971                 return PATCH_MODULE;
 972             case &quot;jdk.module.addmods.&quot;:
 973                 return ADD_MODULES;
 974             default:
 975                 throw new IllegalArgumentException(prefix);
 976         }
 977     }
 978 
<a name="24" id="anc24"></a>


















 979     /**
 980      * Wraps a (potentially not thread safe) ModuleFinder created during startup
 981      * for use after startup.
 982      */
 983     static class SafeModuleFinder implements ModuleFinder {
 984         private final Set&lt;ModuleReference&gt; mrefs;
 985         private volatile Map&lt;String, ModuleReference&gt; nameToModule;
 986 
 987         SafeModuleFinder(ModuleFinder finder) {
 988             this.mrefs = Collections.unmodifiableSet(finder.findAll());
 989         }
 990         @Override
 991         public Optional&lt;ModuleReference&gt; find(String name) {
 992             Objects.requireNonNull(name);
 993             Map&lt;String, ModuleReference&gt; nameToModule = this.nameToModule;
 994             if (nameToModule == null) {
 995                 this.nameToModule = nameToModule = mrefs.stream()
 996                         .collect(Collectors.toMap(m -&gt; m.descriptor().name(),
 997                                                   Function.identity()));
 998             }
 999             return Optional.ofNullable(nameToModule.get(name));
1000         }
1001         @Override
1002         public Set&lt;ModuleReference&gt; findAll() {
1003             return mrefs;
1004         }
1005     }
1006 
1007     /**
1008      * Counters for startup performance analysis.
1009      */
1010     static class Counters {
1011         private static final boolean PUBLISH_COUNTERS;
1012         private static final boolean PRINT_COUNTERS;
1013         private static Map&lt;String, Long&gt; counters;
<a name="25" id="anc25"></a><span class="line-added">1014         private static long startTime;</span>
<span class="line-added">1015         private static long previousTime;</span>
<span class="line-added">1016 </span>
1017         static {
1018             String s = System.getProperty(&quot;jdk.module.boot.usePerfData&quot;);
1019             if (s == null) {
1020                 PUBLISH_COUNTERS = false;
1021                 PRINT_COUNTERS = false;
1022             } else {
1023                 PUBLISH_COUNTERS = true;
1024                 PRINT_COUNTERS = s.equals(&quot;debug&quot;);
1025                 counters = new LinkedHashMap&lt;&gt;();  // preserve insert order
1026             }
1027         }
1028 
1029         /**
<a name="26" id="anc26"></a><span class="line-modified">1030          * Start counting time.</span>
<span class="line-added">1031          */</span>
<span class="line-added">1032         static void start() {</span>
<span class="line-added">1033             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1034                 startTime = previousTime = System.nanoTime();</span>
<span class="line-added">1035             }</span>
<span class="line-added">1036         }</span>
<span class="line-added">1037 </span>
<span class="line-added">1038         /**</span>
<span class="line-added">1039          * Add a counter - storing the time difference between now and the</span>
<span class="line-added">1040          * previous add or the start.</span>
1041          */
<a name="27" id="anc27"></a><span class="line-modified">1042         static void add(String name) {</span>
<span class="line-modified">1043             if (PUBLISH_COUNTERS) {</span>
<span class="line-modified">1044                 long current = System.nanoTime();</span>
<span class="line-added">1045                 long elapsed = current - previousTime;</span>
<span class="line-added">1046                 previousTime = current;</span>
<span class="line-added">1047                 counters.put(name, elapsed);</span>
1048             }
1049         }
1050 
1051         /**
1052          * Publish the counters to the instrumentation buffer or stdout.
1053          */
<a name="28" id="anc28"></a><span class="line-modified">1054         static void publish(String totalTimeName) {</span>
<span class="line-modified">1055             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1056                 long currentTime = System.nanoTime();</span>
1057                 for (Map.Entry&lt;String, Long&gt; e : counters.entrySet()) {
1058                     String name = e.getKey();
1059                     long value = e.getValue();
<a name="29" id="anc29"></a><span class="line-modified">1060                     PerfCounter.newPerfCounter(name).set(value);</span>

1061                     if (PRINT_COUNTERS)
1062                         System.out.println(name + &quot; = &quot; + value);
1063                 }
<a name="30" id="anc30"></a><span class="line-added">1064                 long elapsedTotal = currentTime - startTime;</span>
<span class="line-added">1065                 PerfCounter.newPerfCounter(totalTimeName).set(elapsedTotal);</span>
<span class="line-added">1066                 if (PRINT_COUNTERS)</span>
<span class="line-added">1067                     System.out.println(totalTimeName + &quot; = &quot; + elapsedTotal);</span>
1068             }
1069         }
1070     }
1071 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>