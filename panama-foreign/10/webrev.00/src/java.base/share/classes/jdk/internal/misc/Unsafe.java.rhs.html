<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
  36 import static jdk.internal.misc.UnsafeConstants.*;
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
  43  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
  54  */
  55 
  56 public final class Unsafe {
  57 
  58     private static native void registerNatives();
  59     static {
  60         registerNatives();
  61     }
  62 
  63     private Unsafe() {}
  64 
  65     private static final Unsafe theUnsafe = new Unsafe();
  66 
  67     /**
  68      * Provides the caller with the capability of performing unsafe
  69      * operations.
  70      *
  71      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  72      * by the caller, since it can be used to read and write data at arbitrary
  73      * memory addresses.  It must never be passed to untrusted code.
  74      *
  75      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  76      * small number of hardware instructions (on typical machines).  Compilers
  77      * are encouraged to optimize these methods accordingly.
  78      *
  79      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  80      *
  81      * &lt;pre&gt; {@code
  82      * class MyTrustedClass {
  83      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  84      *   ...
  85      *   private long myCountAddress = ...;
  86      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  87      * }}&lt;/pre&gt;
  88      *
  89      * (It may assist compilers to make the local variable {@code final}.)
  90      */
  91     public static Unsafe getUnsafe() {
  92         return theUnsafe;
  93     }
  94 
  95     /// peek and poke operations
  96     /// (compilers should optimize these to memory ops)
  97 
  98     // These work on object fields in the Java heap.
  99     // They will not work on elements of packed arrays.
 100 
 101     /**
 102      * Fetches a value from a given Java variable.
 103      * More specifically, fetches a field or array element within the given
 104      * object {@code o} at the given offset, or (if {@code o} is null)
 105      * from the memory address whose numerical value is the given offset.
 106      * &lt;p&gt;
 107      * The results are undefined unless one of the following cases is true:
 108      * &lt;ul&gt;
 109      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 110      * the {@link java.lang.reflect.Field} of some Java field and the object
 111      * referred to by {@code o} is of a class compatible with that
 112      * field&#39;s class.
 113      *
 114      * &lt;li&gt;The offset and object reference {@code o} (either null or
 115      * non-null) were both obtained via {@link #staticFieldOffset}
 116      * and {@link #staticFieldBase} (respectively) from the
 117      * reflective {@link Field} representation of some Java field.
 118      *
 119      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 120      * is an integer of the form {@code B+N*S}, where {@code N} is
 121      * a valid index into the array, and {@code B} and {@code S} are
 122      * the values obtained by {@link #arrayBaseOffset} and {@link
 123      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 124      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 125      *
 126      * &lt;/ul&gt;
 127      * &lt;p&gt;
 128      * If one of the above cases is true, the call references a specific Java
 129      * variable (field or array element).  However, the results are undefined
 130      * if that variable is not in fact of the type returned by this method.
 131      * &lt;p&gt;
 132      * This method refers to a variable by means of two parameters, and so
 133      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 134      * for Java variables.  When the object reference is null, this method
 135      * uses its offset as an absolute address.  This is similar in operation
 136      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 137      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 138      * However, because Java variables may have a different layout in memory
 139      * from non-Java variables, programmers should not assume that these
 140      * two addressing modes are ever equivalent.  Also, programmers should
 141      * remember that offsets from the double-register addressing mode cannot
 142      * be portably confused with longs used in the single-register addressing
 143      * mode.
 144      *
 145      * @param o Java heap object in which the variable resides, if any, else
 146      *        null
 147      * @param offset indication of where the variable resides in a Java heap
 148      *        object, if any, else a memory address locating the variable
 149      *        statically
 150      * @return the value fetched from the indicated Java variable
 151      * @throws RuntimeException No defined exceptions are thrown, not even
 152      *         {@link NullPointerException}
 153      */
 154     @HotSpotIntrinsicCandidate
 155     public native int getInt(Object o, long offset);
 156 
 157     /**
 158      * Stores a value into a given Java variable.
 159      * &lt;p&gt;
 160      * The first two parameters are interpreted exactly as with
 161      * {@link #getInt(Object, long)} to refer to a specific
 162      * Java variable (field or array element).  The given value
 163      * is stored into that variable.
 164      * &lt;p&gt;
 165      * The variable must be of the same type as the method
 166      * parameter {@code x}.
 167      *
 168      * @param o Java heap object in which the variable resides, if any, else
 169      *        null
 170      * @param offset indication of where the variable resides in a Java heap
 171      *        object, if any, else a memory address locating the variable
 172      *        statically
 173      * @param x the value to store into the indicated Java variable
 174      * @throws RuntimeException No defined exceptions are thrown, not even
 175      *         {@link NullPointerException}
 176      */
 177     @HotSpotIntrinsicCandidate
 178     public native void putInt(Object o, long offset, int x);
 179 
 180     /**
 181      * Fetches a reference value from a given Java variable.
 182      * @see #getInt(Object, long)
 183      */
 184     @HotSpotIntrinsicCandidate
 185     public native Object getReference(Object o, long offset);
 186 
 187     /**
 188      * Stores a reference value into a given Java variable.
 189      * &lt;p&gt;
 190      * Unless the reference {@code x} being stored is either null
 191      * or matches the field type, the results are undefined.
 192      * If the reference {@code o} is non-null, card marks or
 193      * other store barriers for that object (if the VM requires them)
 194      * are updated.
 195      * @see #putInt(Object, long, int)
 196      */
 197     @HotSpotIntrinsicCandidate
 198     public native void putReference(Object o, long offset, Object x);
 199 
 200     /** @see #getInt(Object, long) */
 201     @HotSpotIntrinsicCandidate
 202     public native boolean getBoolean(Object o, long offset);
 203 
 204     /** @see #putInt(Object, long, int) */
 205     @HotSpotIntrinsicCandidate
 206     public native void    putBoolean(Object o, long offset, boolean x);
 207 
 208     /** @see #getInt(Object, long) */
 209     @HotSpotIntrinsicCandidate
 210     public native byte    getByte(Object o, long offset);
 211 
 212     /** @see #putInt(Object, long, int) */
 213     @HotSpotIntrinsicCandidate
 214     public native void    putByte(Object o, long offset, byte x);
 215 
 216     /** @see #getInt(Object, long) */
 217     @HotSpotIntrinsicCandidate
 218     public native short   getShort(Object o, long offset);
 219 
 220     /** @see #putInt(Object, long, int) */
 221     @HotSpotIntrinsicCandidate
 222     public native void    putShort(Object o, long offset, short x);
 223 
 224     /** @see #getInt(Object, long) */
 225     @HotSpotIntrinsicCandidate
 226     public native char    getChar(Object o, long offset);
 227 
 228     /** @see #putInt(Object, long, int) */
 229     @HotSpotIntrinsicCandidate
 230     public native void    putChar(Object o, long offset, char x);
 231 
 232     /** @see #getInt(Object, long) */
 233     @HotSpotIntrinsicCandidate
 234     public native long    getLong(Object o, long offset);
 235 
 236     /** @see #putInt(Object, long, int) */
 237     @HotSpotIntrinsicCandidate
 238     public native void    putLong(Object o, long offset, long x);
 239 
 240     /** @see #getInt(Object, long) */
 241     @HotSpotIntrinsicCandidate
 242     public native float   getFloat(Object o, long offset);
 243 
 244     /** @see #putInt(Object, long, int) */
 245     @HotSpotIntrinsicCandidate
 246     public native void    putFloat(Object o, long offset, float x);
 247 
 248     /** @see #getInt(Object, long) */
 249     @HotSpotIntrinsicCandidate
 250     public native double  getDouble(Object o, long offset);
 251 
 252     /** @see #putInt(Object, long, int) */
 253     @HotSpotIntrinsicCandidate
 254     public native void    putDouble(Object o, long offset, double x);
 255 
 256     /**
 257      * Fetches a native pointer from a given memory address.  If the address is
 258      * zero, or does not point into a block obtained from {@link
 259      * #allocateMemory}, the results are undefined.
 260      *
 261      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 262      * an unsigned number to a Java long.  The pointer may be indexed by any
 263      * given byte offset, simply by adding that offset (as a simple integer) to
 264      * the long representing the pointer.  The number of bytes actually read
 265      * from the target address may be determined by consulting {@link
 266      * #addressSize}.
 267      *
 268      * @see #allocateMemory
 269      * @see #getInt(Object, long)
 270      */
 271     @ForceInline
 272     public long getAddress(Object o, long offset) {
 273         if (ADDRESS_SIZE == 4) {
 274             return Integer.toUnsignedLong(getInt(o, offset));
 275         } else {
 276             return getLong(o, offset);
 277         }
 278     }
 279 
 280     /**
 281      * Stores a native pointer into a given memory address.  If the address is
 282      * zero, or does not point into a block obtained from {@link
 283      * #allocateMemory}, the results are undefined.
 284      *
 285      * &lt;p&gt;The number of bytes actually written at the target address may be
 286      * determined by consulting {@link #addressSize}.
 287      *
 288      * @see #allocateMemory
 289      * @see #putInt(Object, long, int)
 290      */
 291     @ForceInline
 292     public void putAddress(Object o, long offset, long x) {
 293         if (ADDRESS_SIZE == 4) {
 294             putInt(o, offset, (int)x);
 295         } else {
 296             putLong(o, offset, x);
 297         }
 298     }
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM&#39;s compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     public native Object getUncompressedObject(long address);
 310 
 311     // These work on values in the C heap.
 312 
 313     /**
 314      * Fetches a value from a given memory address.  If the address is zero, or
 315      * does not point into a block obtained from {@link #allocateMemory}, the
 316      * results are undefined.
 317      *
 318      * @see #allocateMemory
 319      */
 320     @ForceInline
 321     public byte getByte(long address) {
 322         return getByte(null, address);
 323     }
 324 
 325     /**
 326      * Stores a value into a given memory address.  If the address is zero, or
 327      * does not point into a block obtained from {@link #allocateMemory}, the
 328      * results are undefined.
 329      *
 330      * @see #getByte(long)
 331      */
 332     @ForceInline
 333     public void putByte(long address, byte x) {
 334         putByte(null, address, x);
 335     }
 336 
 337     /** @see #getByte(long) */
 338     @ForceInline
 339     public short getShort(long address) {
 340         return getShort(null, address);
 341     }
 342 
 343     /** @see #putByte(long, byte) */
 344     @ForceInline
 345     public void putShort(long address, short x) {
 346         putShort(null, address, x);
 347     }
 348 
 349     /** @see #getByte(long) */
 350     @ForceInline
 351     public char getChar(long address) {
 352         return getChar(null, address);
 353     }
 354 
 355     /** @see #putByte(long, byte) */
 356     @ForceInline
 357     public void putChar(long address, char x) {
 358         putChar(null, address, x);
 359     }
 360 
 361     /** @see #getByte(long) */
 362     @ForceInline
 363     public int getInt(long address) {
 364         return getInt(null, address);
 365     }
 366 
 367     /** @see #putByte(long, byte) */
 368     @ForceInline
 369     public void putInt(long address, int x) {
 370         putInt(null, address, x);
 371     }
 372 
 373     /** @see #getByte(long) */
 374     @ForceInline
 375     public long getLong(long address) {
 376         return getLong(null, address);
 377     }
 378 
 379     /** @see #putByte(long, byte) */
 380     @ForceInline
 381     public void putLong(long address, long x) {
 382         putLong(null, address, x);
 383     }
 384 
 385     /** @see #getByte(long) */
 386     @ForceInline
 387     public float getFloat(long address) {
 388         return getFloat(null, address);
 389     }
 390 
 391     /** @see #putByte(long, byte) */
 392     @ForceInline
 393     public void putFloat(long address, float x) {
 394         putFloat(null, address, x);
 395     }
 396 
 397     /** @see #getByte(long) */
 398     @ForceInline
 399     public double getDouble(long address) {
 400         return getDouble(null, address);
 401     }
 402 
 403     /** @see #putByte(long, byte) */
 404     @ForceInline
 405     public void putDouble(long address, double x) {
 406         putDouble(null, address, x);
 407     }
 408 
 409     /** @see #getAddress(Object, long) */
 410     @ForceInline
 411     public long getAddress(long address) {
 412         return getAddress(null, address);
 413     }
 414 
 415     /** @see #putAddress(Object, long, long) */
 416     @ForceInline
 417     public void putAddress(long address, long x) {
 418         putAddress(null, address, x);
 419     }
 420 
 421 
 422 
 423     /// helper methods for validating various types of objects/values
 424 
 425     /**
 426      * Create an exception reflecting that some of the input was invalid
 427      *
 428      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 429      * sure arguments are checked before the methods are called. While
 430      * some rudimentary checks are performed on the input, the checks
 431      * are best effort and when performance is an overriding priority,
 432      * as when methods of this class are optimized by the runtime
 433      * compiler, some or all checks (if any) may be elided. Hence, the
 434      * caller must not rely on the checks and corresponding
 435      * exceptions!
 436      *
 437      * @return an exception object
 438      */
 439     private RuntimeException invalidInput() {
 440         return new IllegalArgumentException();
 441     }
 442 
 443     /**
 444      * Check if a value is 32-bit clean (32 MSB are all zero)
 445      *
 446      * @param value the 64-bit value to check
 447      *
 448      * @return true if the value is 32-bit clean
 449      */
 450     private boolean is32BitClean(long value) {
 451         return value &gt;&gt;&gt; 32 == 0;
 452     }
 453 
 454     /**
 455      * Check the validity of a size (the equivalent of a size_t)
 456      *
 457      * @throws RuntimeException if the size is invalid
 458      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 459      *         go undetected, which will lead to unpredictable
 460      *         behavior)
 461      */
 462     private void checkSize(long size) {
 463         if (ADDRESS_SIZE == 4) {
 464             // Note: this will also check for negative sizes
 465             if (!is32BitClean(size)) {
 466                 throw invalidInput();
 467             }
 468         } else if (size &lt; 0) {
 469             throw invalidInput();
 470         }
 471     }
 472 
 473     /**
 474      * Check the validity of a native address (the equivalent of void*)
 475      *
 476      * @throws RuntimeException if the address is invalid
 477      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 478      *         go undetected, which will lead to unpredictable
 479      *         behavior)
 480      */
 481     private void checkNativeAddress(long address) {
 482         if (ADDRESS_SIZE == 4) {
 483             // Accept both zero and sign extended pointers. A valid
 484             // pointer will, after the +1 below, either have produced
 485             // the value 0x0 or 0x1. Masking off the low bit allows
 486             // for testing against 0.
 487             if ((((address &gt;&gt; 32) + 1) &amp; ~1) != 0) {
 488                 throw invalidInput();
 489             }
 490         }
 491     }
 492 
 493     /**
 494      * Check the validity of an offset, relative to a base object
 495      *
 496      * @param o the base object
 497      * @param offset the offset to check
 498      *
 499      * @throws RuntimeException if the size is invalid
 500      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 501      *         go undetected, which will lead to unpredictable
 502      *         behavior)
 503      */
 504     private void checkOffset(Object o, long offset) {
 505         if (ADDRESS_SIZE == 4) {
 506             // Note: this will also check for negative offsets
 507             if (!is32BitClean(offset)) {
 508                 throw invalidInput();
 509             }
 510         } else if (offset &lt; 0) {
 511             throw invalidInput();
 512         }
 513     }
 514 
 515     /**
 516      * Check the validity of a double-register pointer
 517      *
 518      * Note: This code deliberately does *not* check for NPE for (at
 519      * least) three reasons:
 520      *
 521      * 1) NPE is not just NULL/0 - there is a range of values all
 522      * resulting in an NPE, which is not trivial to check for
 523      *
 524      * 2) It is the responsibility of the callers of Unsafe methods
 525      * to verify the input, so throwing an exception here is not really
 526      * useful - passing in a NULL pointer is a critical error and the
 527      * must not expect an exception to be thrown anyway.
 528      *
 529      * 3) the actual operations will detect NULL pointers anyway by
 530      * means of traps and signals (like SIGSEGV).
 531      *
 532      * @param o Java heap object, or null
 533      * @param offset indication of where the variable resides in a Java heap
 534      *        object, if any, else a memory address locating the variable
 535      *        statically
 536      *
 537      * @throws RuntimeException if the pointer is invalid
 538      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 539      *         go undetected, which will lead to unpredictable
 540      *         behavior)
 541      */
 542     private void checkPointer(Object o, long offset) {
 543         if (o == null) {
 544             checkNativeAddress(offset);
 545         } else {
 546             checkOffset(o, offset);
 547         }
 548     }
 549 
 550     /**
 551      * Check if a type is a primitive array type
 552      *
 553      * @param c the type to check
 554      *
 555      * @return true if the type is a primitive array type
 556      */
 557     private void checkPrimitiveArray(Class&lt;?&gt; c) {
 558         Class&lt;?&gt; componentType = c.getComponentType();
 559         if (componentType == null || !componentType.isPrimitive()) {
 560             throw invalidInput();
 561         }
 562     }
 563 
 564     /**
 565      * Check that a pointer is a valid primitive array type pointer
 566      *
 567      * Note: pointers off-heap are considered to be primitive arrays
 568      *
 569      * @throws RuntimeException if the pointer is invalid
 570      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 571      *         go undetected, which will lead to unpredictable
 572      *         behavior)
 573      */
 574     private void checkPrimitivePointer(Object o, long offset) {
 575         checkPointer(o, offset);
 576 
 577         if (o != null) {
 578             // If on heap, it must be a primitive array
 579             checkPrimitiveArray(o.getClass());
 580         }
 581     }
 582 
 583 
 584     /// wrappers for malloc, realloc, free:
 585 
<a name="2" id="anc2"></a><span class="line-added"> 586     /**</span>
<span class="line-added"> 587      * Round up allocation size to a multiple of HeapWordSize.</span>
<span class="line-added"> 588      */</span>
<span class="line-added"> 589     private long alignToHeapWordSize(long bytes) {</span>
<span class="line-added"> 590         if (bytes &gt;= 0) {</span>
<span class="line-added"> 591             return (bytes + ADDRESS_SIZE - 1) &amp; ~(ADDRESS_SIZE - 1);</span>
<span class="line-added"> 592         } else {</span>
<span class="line-added"> 593             throw invalidInput();</span>
<span class="line-added"> 594         }</span>
<span class="line-added"> 595     }</span>
<span class="line-added"> 596 </span>
 597     /**
 598      * Allocates a new block of native memory, of the given size in bytes.  The
 599      * contents of the memory are uninitialized; they will generally be
 600      * garbage.  The resulting native pointer will never be zero, and will be
 601      * aligned for all value types.  Dispose of this memory by calling {@link
 602      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 603      *
 604      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 605      * sure arguments are checked before the methods are called. While
 606      * some rudimentary checks are performed on the input, the checks
 607      * are best effort and when performance is an overriding priority,
 608      * as when methods of this class are optimized by the runtime
 609      * compiler, some or all checks (if any) may be elided. Hence, the
 610      * caller must not rely on the checks and corresponding
 611      * exceptions!
 612      *
 613      * @throws RuntimeException if the size is negative or too large
 614      *         for the native size_t type
 615      *
 616      * @throws OutOfMemoryError if the allocation is refused by the system
 617      *
 618      * @see #getByte(long)
 619      * @see #putByte(long, byte)
 620      */
 621     public long allocateMemory(long bytes) {
<a name="3" id="anc3"></a><span class="line-added"> 622         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added"> 623 </span>
 624         allocateMemoryChecks(bytes);
 625 
 626         if (bytes == 0) {
 627             return 0;
 628         }
 629 
 630         long p = allocateMemory0(bytes);
 631         if (p == 0) {
 632             throw new OutOfMemoryError();
 633         }
 634 
 635         return p;
 636     }
 637 
 638     /**
 639      * Validate the arguments to allocateMemory
 640      *
 641      * @throws RuntimeException if the arguments are invalid
 642      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 643      *         go undetected, which will lead to unpredictable
 644      *         behavior)
 645      */
 646     private void allocateMemoryChecks(long bytes) {
 647         checkSize(bytes);
 648     }
 649 
 650     /**
 651      * Resizes a new block of native memory, to the given size in bytes.  The
 652      * contents of the new block past the size of the old block are
 653      * uninitialized; they will generally be garbage.  The resulting native
 654      * pointer will be zero if and only if the requested size is zero.  The
 655      * resulting native pointer will be aligned for all value types.  Dispose
 656      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 657      * #reallocateMemory}.  The address passed to this method may be null, in
 658      * which case an allocation will be performed.
 659      *
 660      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 661      * sure arguments are checked before the methods are called. While
 662      * some rudimentary checks are performed on the input, the checks
 663      * are best effort and when performance is an overriding priority,
 664      * as when methods of this class are optimized by the runtime
 665      * compiler, some or all checks (if any) may be elided. Hence, the
 666      * caller must not rely on the checks and corresponding
 667      * exceptions!
 668      *
 669      * @throws RuntimeException if the size is negative or too large
 670      *         for the native size_t type
 671      *
 672      * @throws OutOfMemoryError if the allocation is refused by the system
 673      *
 674      * @see #allocateMemory
 675      */
 676     public long reallocateMemory(long address, long bytes) {
<a name="4" id="anc4"></a><span class="line-added"> 677         bytes = alignToHeapWordSize(bytes);</span>
<span class="line-added"> 678 </span>
 679         reallocateMemoryChecks(address, bytes);
 680 
 681         if (bytes == 0) {
 682             freeMemory(address);
 683             return 0;
 684         }
 685 
 686         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 687         if (p == 0) {
 688             throw new OutOfMemoryError();
 689         }
 690 
 691         return p;
 692     }
 693 
 694     /**
 695      * Validate the arguments to reallocateMemory
 696      *
 697      * @throws RuntimeException if the arguments are invalid
 698      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 699      *         go undetected, which will lead to unpredictable
 700      *         behavior)
 701      */
 702     private void reallocateMemoryChecks(long address, long bytes) {
 703         checkPointer(null, address);
 704         checkSize(bytes);
 705     }
 706 
 707     /**
 708      * Sets all bytes in a given block of memory to a fixed value
 709      * (usually zero).
 710      *
 711      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 712      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 713      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 714      * the offset supplies an absolute base address.
 715      *
 716      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 717      * by the address and length parameters.  If the effective address and
 718      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 719      * If the effective address and length are (resp.) even modulo 4 or 2,
 720      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 721      *
 722      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 723      * sure arguments are checked before the methods are called. While
 724      * some rudimentary checks are performed on the input, the checks
 725      * are best effort and when performance is an overriding priority,
 726      * as when methods of this class are optimized by the runtime
 727      * compiler, some or all checks (if any) may be elided. Hence, the
 728      * caller must not rely on the checks and corresponding
 729      * exceptions!
 730      *
 731      * @throws RuntimeException if any of the arguments is invalid
 732      *
 733      * @since 1.7
 734      */
 735     public void setMemory(Object o, long offset, long bytes, byte value) {
 736         setMemoryChecks(o, offset, bytes, value);
 737 
 738         if (bytes == 0) {
 739             return;
 740         }
 741 
 742         setMemory0(o, offset, bytes, value);
 743     }
 744 
 745     /**
 746      * Sets all bytes in a given block of memory to a fixed value
 747      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 748      * as discussed in {@link #getInt(Object,long)}.
 749      *
 750      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 751      */
 752     public void setMemory(long address, long bytes, byte value) {
 753         setMemory(null, address, bytes, value);
 754     }
 755 
 756     /**
 757      * Validate the arguments to setMemory
 758      *
 759      * @throws RuntimeException if the arguments are invalid
 760      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 761      *         go undetected, which will lead to unpredictable
 762      *         behavior)
 763      */
 764     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 765         checkPrimitivePointer(o, offset);
 766         checkSize(bytes);
 767     }
 768 
 769     /**
 770      * Sets all bytes in a given block of memory to a copy of another
 771      * block.
 772      *
 773      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 774      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 775      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 776      * the offset supplies an absolute base address.
 777      *
 778      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 779      * by the address and length parameters.  If the effective addresses and
 780      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 781      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 782      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 783      *
 784      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 785      * sure arguments are checked before the methods are called. While
 786      * some rudimentary checks are performed on the input, the checks
 787      * are best effort and when performance is an overriding priority,
 788      * as when methods of this class are optimized by the runtime
 789      * compiler, some or all checks (if any) may be elided. Hence, the
 790      * caller must not rely on the checks and corresponding
 791      * exceptions!
 792      *
 793      * @throws RuntimeException if any of the arguments is invalid
 794      *
 795      * @since 1.7
 796      */
 797     public void copyMemory(Object srcBase, long srcOffset,
 798                            Object destBase, long destOffset,
 799                            long bytes) {
 800         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 801 
 802         if (bytes == 0) {
 803             return;
 804         }
 805 
 806         copyMemory0(srcBase, srcOffset, destBase, destOffset, bytes);
 807     }
 808 
 809     /**
 810      * Sets all bytes in a given block of memory to a copy of another
 811      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 812      * as discussed in {@link #getInt(Object,long)}.
 813      *
 814      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 815      */
 816     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 817         copyMemory(null, srcAddress, null, destAddress, bytes);
 818     }
 819 
 820     /**
 821      * Validate the arguments to copyMemory
 822      *
 823      * @throws RuntimeException if any of the arguments is invalid
 824      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 825      *         go undetected, which will lead to unpredictable
 826      *         behavior)
 827      */
 828     private void copyMemoryChecks(Object srcBase, long srcOffset,
 829                                   Object destBase, long destOffset,
 830                                   long bytes) {
 831         checkSize(bytes);
 832         checkPrimitivePointer(srcBase, srcOffset);
 833         checkPrimitivePointer(destBase, destOffset);
 834     }
 835 
 836     /**
 837      * Copies all elements from one block of memory to another block,
 838      * *unconditionally* byte swapping the elements on the fly.
 839      *
 840      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 841      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 842      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 843      * the offset supplies an absolute base address.
 844      *
 845      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 846      * sure arguments are checked before the methods are called. While
 847      * some rudimentary checks are performed on the input, the checks
 848      * are best effort and when performance is an overriding priority,
 849      * as when methods of this class are optimized by the runtime
 850      * compiler, some or all checks (if any) may be elided. Hence, the
 851      * caller must not rely on the checks and corresponding
 852      * exceptions!
 853      *
 854      * @throws RuntimeException if any of the arguments is invalid
 855      *
 856      * @since 9
 857      */
 858     public void copySwapMemory(Object srcBase, long srcOffset,
 859                                Object destBase, long destOffset,
 860                                long bytes, long elemSize) {
 861         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 862 
 863         if (bytes == 0) {
 864             return;
 865         }
 866 
 867         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 868     }
 869 
 870     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 871                                       Object destBase, long destOffset,
 872                                       long bytes, long elemSize) {
 873         checkSize(bytes);
 874 
 875         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 876             throw invalidInput();
 877         }
 878         if (bytes % elemSize != 0) {
 879             throw invalidInput();
 880         }
 881 
 882         checkPrimitivePointer(srcBase, srcOffset);
 883         checkPrimitivePointer(destBase, destOffset);
 884     }
 885 
 886    /**
 887      * Copies all elements from one block of memory to another block, byte swapping the
 888      * elements on the fly.
 889      *
 890      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 891      * discussed in {@link #getInt(Object,long)}.
 892      *
 893      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 894      */
 895     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 896         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 897     }
 898 
 899     /**
 900      * Disposes of a block of native memory, as obtained from {@link
 901      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 902      * this method may be null, in which case no action is taken.
 903      *
 904      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 905      * sure arguments are checked before the methods are called. While
 906      * some rudimentary checks are performed on the input, the checks
 907      * are best effort and when performance is an overriding priority,
 908      * as when methods of this class are optimized by the runtime
 909      * compiler, some or all checks (if any) may be elided. Hence, the
 910      * caller must not rely on the checks and corresponding
 911      * exceptions!
 912      *
 913      * @throws RuntimeException if any of the arguments is invalid
 914      *
 915      * @see #allocateMemory
 916      */
 917     public void freeMemory(long address) {
 918         freeMemoryChecks(address);
 919 
 920         if (address == 0) {
 921             return;
 922         }
 923 
 924         freeMemory0(address);
 925     }
 926 
 927     /**
 928      * Validate the arguments to freeMemory
 929      *
 930      * @throws RuntimeException if the arguments are invalid
 931      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 932      *         go undetected, which will lead to unpredictable
 933      *         behavior)
 934      */
 935     private void freeMemoryChecks(long address) {
 936         checkPointer(null, address);
 937     }
 938 
 939     /**
 940      * Ensure writeback of a specified virtual memory address range
 941      * from cache to physical memory. All bytes in the address range
 942      * are guaranteed to have been written back to physical memory on
 943      * return from this call i.e. subsequently executed store
 944      * instructions are guaranteed not to be visible before the
 945      * writeback is completed.
 946      *
 947      * @param address
 948      *        the lowest byte address that must be guaranteed written
 949      *        back to memory. bytes at lower addresses may also be
 950      *        written back.
 951      *
 952      * @param length
 953      *        the length in bytes of the region starting at address
 954      *        that must be guaranteed written back to memory.
 955      *
 956      * @throws RuntimeException if memory writeback is not supported
 957      *         on the current hardware of if the arguments are invalid.
 958      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 959      *         go undetected, which will lead to unpredictable
 960      *         behavior)
 961      *
 962      * @since 14
 963      */
 964 
 965     public void writebackMemory(long address, long length) {
 966         checkWritebackEnabled();
 967         checkWritebackMemory(address, length);
 968 
 969         // perform any required pre-writeback barrier
 970         writebackPreSync0();
 971 
 972         // write back one cache line at a time
 973         long line = dataCacheLineAlignDown(address);
 974         long end = address + length;
 975         while (line &lt; end) {
 976             writeback0(line);
 977             line += dataCacheLineFlushSize();
 978         }
 979 
 980         // perform any required post-writeback barrier
 981         writebackPostSync0();
 982     }
 983 
 984     /**
 985      * Validate the arguments to writebackMemory
 986      *
 987      * @throws RuntimeException if the arguments are invalid
 988      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 989      *         go undetected, which will lead to unpredictable
 990      *         behavior)
 991      */
 992     private void checkWritebackMemory(long address, long length) {
 993         checkNativeAddress(address);
 994         checkSize(length);
 995     }
 996 
 997     /**
 998      * Validate that the current hardware supports memory writeback.
 999      * (&lt;em&gt;Note:&lt;/em&gt; this is a belt and braces check.  Clients are
1000      * expected to test whether writeback is enabled by calling
1001      * ({@link isWritebackEnabled #isWritebackEnabled} and avoid
1002      * calling method {@link writeback #writeback} if it is disabled).
1003      *
1004      *
1005      * @throws RuntimeException if memory writeback is not supported
1006      */
1007     private void checkWritebackEnabled() {
1008         if (!isWritebackEnabled()) {
1009             throw new RuntimeException(&quot;writebackMemory not enabled!&quot;);
1010         }
1011     }
1012 
1013     /**
1014      * force writeback of an individual cache line.
1015      *
1016      * @param address
1017      *        the start address of the cache line to be written back
1018      */
1019     @HotSpotIntrinsicCandidate
1020     private native void writeback0(long address);
1021 
1022      /**
1023       * Serialize writeback operations relative to preceding memory writes.
1024       */
1025     @HotSpotIntrinsicCandidate
1026     private native void writebackPreSync0();
1027 
1028      /**
1029       * Serialize writeback operations relative to following memory writes.
1030       */
1031     @HotSpotIntrinsicCandidate
1032     private native void writebackPostSync0();
1033 
1034     /// random queries
1035 
1036     /**
1037      * This constant differs from all results that will ever be returned from
1038      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
1039      * or {@link #arrayBaseOffset}.
1040      */
1041     public static final int INVALID_FIELD_OFFSET = -1;
1042 
1043     /**
1044      * Reports the location of a given field in the storage allocation of its
1045      * class.  Do not expect to perform any sort of arithmetic on this offset;
1046      * it is just a cookie which is passed to the unsafe heap memory accessors.
1047      *
1048      * &lt;p&gt;Any given field will always have the same offset and base, and no
1049      * two distinct fields of the same class will ever have the same offset
1050      * and base.
1051      *
1052      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1053      * although the Sun JVM does not use the most significant 32 bits.
1054      * However, JVM implementations which store static fields at absolute
1055      * addresses can use long offsets and null base pointers to express
1056      * the field locations in a form usable by {@link #getInt(Object,long)}.
1057      * Therefore, code which will be ported to such JVMs on 64-bit platforms
1058      * must preserve all bits of static field offsets.
1059      * @see #getInt(Object, long)
1060      */
1061     public long objectFieldOffset(Field f) {
1062         if (f == null) {
1063             throw new NullPointerException();
1064         }
1065 
1066         return objectFieldOffset0(f);
1067     }
1068 
1069     /**
1070      * Reports the location of the field with a given name in the storage
1071      * allocation of its class.
1072      *
1073      * @throws NullPointerException if any parameter is {@code null}.
1074      * @throws InternalError if there is no field named {@code name} declared
1075      *         in class {@code c}, i.e., if {@code c.getDeclaredField(name)}
1076      *         would throw {@code java.lang.NoSuchFieldException}.
1077      *
1078      * @see #objectFieldOffset(Field)
1079      */
1080     public long objectFieldOffset(Class&lt;?&gt; c, String name) {
1081         if (c == null || name == null) {
1082             throw new NullPointerException();
1083         }
1084 
1085         return objectFieldOffset1(c, name);
1086     }
1087 
1088     /**
1089      * Reports the location of a given static field, in conjunction with {@link
1090      * #staticFieldBase}.
1091      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
1092      * it is just a cookie which is passed to the unsafe heap memory accessors.
1093      *
1094      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
1095      * fields of the same class will ever have the same offset.
1096      *
1097      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1098      * although the Sun JVM does not use the most significant 32 bits.
1099      * It is hard to imagine a JVM technology which needs more than
1100      * a few bits to encode an offset within a non-array object,
1101      * However, for consistency with other methods in this class,
1102      * this method reports its result as a long value.
1103      * @see #getInt(Object, long)
1104      */
1105     public long staticFieldOffset(Field f) {
1106         if (f == null) {
1107             throw new NullPointerException();
1108         }
1109 
1110         return staticFieldOffset0(f);
1111     }
1112 
1113     /**
1114      * Reports the location of a given static field, in conjunction with {@link
1115      * #staticFieldOffset}.
1116      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
1117      * given class can be accessed via methods like {@link #getInt(Object,
1118      * long)}.  This value may be null.  This value may refer to an object
1119      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
1120      * not be used in any way except as argument to the get and put routines in
1121      * this class.
1122      */
1123     public Object staticFieldBase(Field f) {
1124         if (f == null) {
1125             throw new NullPointerException();
1126         }
1127 
1128         return staticFieldBase0(f);
1129     }
1130 
1131     /**
1132      * Detects if the given class may need to be initialized. This is often
1133      * needed in conjunction with obtaining the static field base of a
1134      * class.
1135      * @return false only if a call to {@code ensureClassInitialized} would have no effect
1136      */
1137     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
1138         if (c == null) {
1139             throw new NullPointerException();
1140         }
1141 
1142         return shouldBeInitialized0(c);
1143     }
1144 
1145     /**
1146      * Ensures the given class has been initialized. This is often
1147      * needed in conjunction with obtaining the static field base of a
1148      * class.
1149      */
1150     public void ensureClassInitialized(Class&lt;?&gt; c) {
1151         if (c == null) {
1152             throw new NullPointerException();
1153         }
1154 
1155         ensureClassInitialized0(c);
1156     }
1157 
1158     /**
1159      * Reports the offset of the first element in the storage allocation of a
1160      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
1161      * for the same class, you may use that scale factor, together with this
1162      * base offset, to form new offsets to access elements of arrays of the
1163      * given class.
1164      *
1165      * @see #getInt(Object, long)
1166      * @see #putInt(Object, long, int)
1167      */
1168     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
1169         if (arrayClass == null) {
1170             throw new NullPointerException();
1171         }
1172 
1173         return arrayBaseOffset0(arrayClass);
1174     }
1175 
1176 
1177     /** The value of {@code arrayBaseOffset(boolean[].class)} */
1178     public static final int ARRAY_BOOLEAN_BASE_OFFSET
1179             = theUnsafe.arrayBaseOffset(boolean[].class);
1180 
1181     /** The value of {@code arrayBaseOffset(byte[].class)} */
1182     public static final int ARRAY_BYTE_BASE_OFFSET
1183             = theUnsafe.arrayBaseOffset(byte[].class);
1184 
1185     /** The value of {@code arrayBaseOffset(short[].class)} */
1186     public static final int ARRAY_SHORT_BASE_OFFSET
1187             = theUnsafe.arrayBaseOffset(short[].class);
1188 
1189     /** The value of {@code arrayBaseOffset(char[].class)} */
1190     public static final int ARRAY_CHAR_BASE_OFFSET
1191             = theUnsafe.arrayBaseOffset(char[].class);
1192 
1193     /** The value of {@code arrayBaseOffset(int[].class)} */
1194     public static final int ARRAY_INT_BASE_OFFSET
1195             = theUnsafe.arrayBaseOffset(int[].class);
1196 
1197     /** The value of {@code arrayBaseOffset(long[].class)} */
1198     public static final int ARRAY_LONG_BASE_OFFSET
1199             = theUnsafe.arrayBaseOffset(long[].class);
1200 
1201     /** The value of {@code arrayBaseOffset(float[].class)} */
1202     public static final int ARRAY_FLOAT_BASE_OFFSET
1203             = theUnsafe.arrayBaseOffset(float[].class);
1204 
1205     /** The value of {@code arrayBaseOffset(double[].class)} */
1206     public static final int ARRAY_DOUBLE_BASE_OFFSET
1207             = theUnsafe.arrayBaseOffset(double[].class);
1208 
1209     /** The value of {@code arrayBaseOffset(Object[].class)} */
1210     public static final int ARRAY_OBJECT_BASE_OFFSET
1211             = theUnsafe.arrayBaseOffset(Object[].class);
1212 
1213     /**
1214      * Reports the scale factor for addressing elements in the storage
1215      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1216      * will generally not work properly with accessors like {@link
1217      * #getByte(Object, long)}, so the scale factor for such classes is reported
1218      * as zero.
1219      *
1220      * @see #arrayBaseOffset
1221      * @see #getInt(Object, long)
1222      * @see #putInt(Object, long, int)
1223      */
1224     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1225         if (arrayClass == null) {
1226             throw new NullPointerException();
1227         }
1228 
1229         return arrayIndexScale0(arrayClass);
1230     }
1231 
1232 
1233     /** The value of {@code arrayIndexScale(boolean[].class)} */
1234     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1235             = theUnsafe.arrayIndexScale(boolean[].class);
1236 
1237     /** The value of {@code arrayIndexScale(byte[].class)} */
1238     public static final int ARRAY_BYTE_INDEX_SCALE
1239             = theUnsafe.arrayIndexScale(byte[].class);
1240 
1241     /** The value of {@code arrayIndexScale(short[].class)} */
1242     public static final int ARRAY_SHORT_INDEX_SCALE
1243             = theUnsafe.arrayIndexScale(short[].class);
1244 
1245     /** The value of {@code arrayIndexScale(char[].class)} */
1246     public static final int ARRAY_CHAR_INDEX_SCALE
1247             = theUnsafe.arrayIndexScale(char[].class);
1248 
1249     /** The value of {@code arrayIndexScale(int[].class)} */
1250     public static final int ARRAY_INT_INDEX_SCALE
1251             = theUnsafe.arrayIndexScale(int[].class);
1252 
1253     /** The value of {@code arrayIndexScale(long[].class)} */
1254     public static final int ARRAY_LONG_INDEX_SCALE
1255             = theUnsafe.arrayIndexScale(long[].class);
1256 
1257     /** The value of {@code arrayIndexScale(float[].class)} */
1258     public static final int ARRAY_FLOAT_INDEX_SCALE
1259             = theUnsafe.arrayIndexScale(float[].class);
1260 
1261     /** The value of {@code arrayIndexScale(double[].class)} */
1262     public static final int ARRAY_DOUBLE_INDEX_SCALE
1263             = theUnsafe.arrayIndexScale(double[].class);
1264 
1265     /** The value of {@code arrayIndexScale(Object[].class)} */
1266     public static final int ARRAY_OBJECT_INDEX_SCALE
1267             = theUnsafe.arrayIndexScale(Object[].class);
1268 
1269     /**
1270      * Reports the size in bytes of a native pointer, as stored via {@link
1271      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1272      * other primitive types (as stored in native memory blocks) is determined
1273      * fully by their information content.
1274      */
1275     public int addressSize() {
1276         return ADDRESS_SIZE;
1277     }
1278 
1279     /** The value of {@code addressSize()} */
1280     public static final int ADDRESS_SIZE = ADDRESS_SIZE0;
1281 
1282     /**
1283      * Reports the size in bytes of a native memory page (whatever that is).
1284      * This value will always be a power of two.
1285      */
1286     public int pageSize() { return PAGE_SIZE; }
1287 
1288     /**
1289      * Reports the size in bytes of a data cache line written back by
1290      * the hardware cache line flush operation available to the JVM or
1291      * 0 if data cache line flushing is not enabled.
1292      */
1293     public int dataCacheLineFlushSize() { return DATA_CACHE_LINE_FLUSH_SIZE; }
1294 
1295     /**
1296      * Rounds down address to a data cache line boundary as
1297      * determined by {@link #dataCacheLineFlushSize}
1298      * @return the rounded down address
1299      */
1300     public long dataCacheLineAlignDown(long address) {
1301         return (address &amp; ~(DATA_CACHE_LINE_FLUSH_SIZE - 1));
1302     }
1303 
1304     /**
1305      * Returns true if data cache line writeback
1306      */
1307     public static boolean isWritebackEnabled() { return DATA_CACHE_LINE_FLUSH_SIZE != 0; }
1308 
1309     /// random trusted operations from JNI:
1310 
1311     /**
1312      * Tells the VM to define a class, without security checks.  By default, the
1313      * class loader and protection domain come from the caller&#39;s class.
1314      */
1315     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1316                                 ClassLoader loader,
1317                                 ProtectionDomain protectionDomain) {
1318         if (b == null) {
1319             throw new NullPointerException();
1320         }
1321         if (len &lt; 0) {
1322             throw new ArrayIndexOutOfBoundsException();
1323         }
1324 
1325         return defineClass0(name, b, off, len, loader, protectionDomain);
1326     }
1327 
1328     public native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
1329                                         ClassLoader loader,
1330                                         ProtectionDomain protectionDomain);
1331 
1332     /**
1333      * Defines a class but does not make it known to the class loader or system dictionary.
1334      * &lt;p&gt;
1335      * For each CP entry, the corresponding CP patch must either be null or have
1336      * the a format that matches its tag:
1337      * &lt;ul&gt;
1338      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
1339      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
1340      * &lt;li&gt;Class: any java.lang.Class object
1341      * &lt;li&gt;String: any object (not just a java.lang.String)
1342      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
1343      * &lt;/ul&gt;
1344      * @param hostClass context for linkage, access control, protection domain, and class loader
1345      * @param data      bytes of a class file
1346      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
1347      */
1348     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
1349         if (hostClass == null || data == null) {
1350             throw new NullPointerException();
1351         }
1352         if (hostClass.isArray() || hostClass.isPrimitive()) {
1353             throw new IllegalArgumentException();
1354         }
1355 
1356         return defineAnonymousClass0(hostClass, data, cpPatches);
1357     }
1358 
1359     /**
1360      * Allocates an instance but does not run any constructor.
1361      * Initializes the class if it has not yet been.
1362      */
1363     @HotSpotIntrinsicCandidate
1364     public native Object allocateInstance(Class&lt;?&gt; cls)
1365         throws InstantiationException;
1366 
1367     /**
1368      * Allocates an array of a given type, but does not do zeroing.
1369      * &lt;p&gt;
1370      * This method should only be used in the very rare cases where a high-performance code
1371      * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.
1372      * In an overwhelming majority of cases, a normal Java allocation should be used instead.
1373      * &lt;p&gt;
1374      * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents
1375      * before allowing untrusted code, or code in other threads, to observe the reference
1376      * to the newly allocated array. In addition, the publication of the array reference must be
1377      * safe according to the Java Memory Model requirements.
1378      * &lt;p&gt;
1379      * The safest approach to deal with an uninitialized array is to keep the reference to it in local
1380      * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either
1381      * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,
1382      * or issuing a {@link #storeFence} before publishing the reference.
1383      * &lt;p&gt;
1384      * @implnote This method can only allocate primitive arrays, to avoid garbage reference
1385      * elements that could break heap integrity.
1386      *
1387      * @param componentType array component type to allocate
1388      * @param length array size to allocate
1389      * @throws IllegalArgumentException if component type is null, or not a primitive class;
1390      *                                  or the length is negative
1391      */
1392     public Object allocateUninitializedArray(Class&lt;?&gt; componentType, int length) {
1393        if (componentType == null) {
1394            throw new IllegalArgumentException(&quot;Component type is null&quot;);
1395        }
1396        if (!componentType.isPrimitive()) {
1397            throw new IllegalArgumentException(&quot;Component type is not primitive&quot;);
1398        }
1399        if (length &lt; 0) {
1400            throw new IllegalArgumentException(&quot;Negative length&quot;);
1401        }
1402        return allocateUninitializedArray0(componentType, length);
1403     }
1404 
1405     @HotSpotIntrinsicCandidate
1406     private Object allocateUninitializedArray0(Class&lt;?&gt; componentType, int length) {
1407        // These fallbacks provide zeroed arrays, but intrinsic is not required to
1408        // return the zeroed arrays.
1409        if (componentType == byte.class)    return new byte[length];
1410        if (componentType == boolean.class) return new boolean[length];
1411        if (componentType == short.class)   return new short[length];
1412        if (componentType == char.class)    return new char[length];
1413        if (componentType == int.class)     return new int[length];
1414        if (componentType == float.class)   return new float[length];
1415        if (componentType == long.class)    return new long[length];
1416        if (componentType == double.class)  return new double[length];
1417        return null;
1418     }
1419 
1420     /** Throws the exception without telling the verifier. */
1421     public native void throwException(Throwable ee);
1422 
1423     /**
1424      * Atomically updates Java variable to {@code x} if it is currently
1425      * holding {@code expected}.
1426      *
1427      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1428      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1429      *
1430      * @return {@code true} if successful
1431      */
1432     @HotSpotIntrinsicCandidate
1433     public final native boolean compareAndSetReference(Object o, long offset,
1434                                                        Object expected,
1435                                                        Object x);
1436 
1437     @HotSpotIntrinsicCandidate
1438     public final native Object compareAndExchangeReference(Object o, long offset,
1439                                                            Object expected,
1440                                                            Object x);
1441 
1442     @HotSpotIntrinsicCandidate
1443     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1444                                                            Object expected,
1445                                                            Object x) {
1446         return compareAndExchangeReference(o, offset, expected, x);
1447     }
1448 
1449     @HotSpotIntrinsicCandidate
1450     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1451                                                            Object expected,
1452                                                            Object x) {
1453         return compareAndExchangeReference(o, offset, expected, x);
1454     }
1455 
1456     @HotSpotIntrinsicCandidate
1457     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1458                                                          Object expected,
1459                                                          Object x) {
1460         return compareAndSetReference(o, offset, expected, x);
1461     }
1462 
1463     @HotSpotIntrinsicCandidate
1464     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1465                                                            Object expected,
1466                                                            Object x) {
1467         return compareAndSetReference(o, offset, expected, x);
1468     }
1469 
1470     @HotSpotIntrinsicCandidate
1471     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1472                                                            Object expected,
1473                                                            Object x) {
1474         return compareAndSetReference(o, offset, expected, x);
1475     }
1476 
1477     @HotSpotIntrinsicCandidate
1478     public final boolean weakCompareAndSetReference(Object o, long offset,
1479                                                     Object expected,
1480                                                     Object x) {
1481         return compareAndSetReference(o, offset, expected, x);
1482     }
1483 
1484     /**
1485      * Atomically updates Java variable to {@code x} if it is currently
1486      * holding {@code expected}.
1487      *
1488      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1489      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1490      *
1491      * @return {@code true} if successful
1492      */
1493     @HotSpotIntrinsicCandidate
1494     public final native boolean compareAndSetInt(Object o, long offset,
1495                                                  int expected,
1496                                                  int x);
1497 
1498     @HotSpotIntrinsicCandidate
1499     public final native int compareAndExchangeInt(Object o, long offset,
1500                                                   int expected,
1501                                                   int x);
1502 
1503     @HotSpotIntrinsicCandidate
1504     public final int compareAndExchangeIntAcquire(Object o, long offset,
1505                                                          int expected,
1506                                                          int x) {
1507         return compareAndExchangeInt(o, offset, expected, x);
1508     }
1509 
1510     @HotSpotIntrinsicCandidate
1511     public final int compareAndExchangeIntRelease(Object o, long offset,
1512                                                          int expected,
1513                                                          int x) {
1514         return compareAndExchangeInt(o, offset, expected, x);
1515     }
1516 
1517     @HotSpotIntrinsicCandidate
1518     public final boolean weakCompareAndSetIntPlain(Object o, long offset,
1519                                                    int expected,
1520                                                    int x) {
1521         return compareAndSetInt(o, offset, expected, x);
1522     }
1523 
1524     @HotSpotIntrinsicCandidate
1525     public final boolean weakCompareAndSetIntAcquire(Object o, long offset,
1526                                                      int expected,
1527                                                      int x) {
1528         return compareAndSetInt(o, offset, expected, x);
1529     }
1530 
1531     @HotSpotIntrinsicCandidate
1532     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1533                                                      int expected,
1534                                                      int x) {
1535         return compareAndSetInt(o, offset, expected, x);
1536     }
1537 
1538     @HotSpotIntrinsicCandidate
1539     public final boolean weakCompareAndSetInt(Object o, long offset,
1540                                               int expected,
1541                                               int x) {
1542         return compareAndSetInt(o, offset, expected, x);
1543     }
1544 
1545     @HotSpotIntrinsicCandidate
1546     public final byte compareAndExchangeByte(Object o, long offset,
1547                                              byte expected,
1548                                              byte x) {
1549         long wordOffset = offset &amp; ~3;
1550         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1551         if (BIG_ENDIAN) {
1552             shift = 24 - shift;
1553         }
1554         int mask           = 0xFF &lt;&lt; shift;
1555         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1556         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1557         int fullWord;
1558         do {
1559             fullWord = getIntVolatile(o, wordOffset);
1560             if ((fullWord &amp; mask) != maskedExpected)
1561                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1562         } while (!weakCompareAndSetInt(o, wordOffset,
1563                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1564         return expected;
1565     }
1566 
1567     @HotSpotIntrinsicCandidate
1568     public final boolean compareAndSetByte(Object o, long offset,
1569                                            byte expected,
1570                                            byte x) {
1571         return compareAndExchangeByte(o, offset, expected, x) == expected;
1572     }
1573 
1574     @HotSpotIntrinsicCandidate
1575     public final boolean weakCompareAndSetByte(Object o, long offset,
1576                                                byte expected,
1577                                                byte x) {
1578         return compareAndSetByte(o, offset, expected, x);
1579     }
1580 
1581     @HotSpotIntrinsicCandidate
1582     public final boolean weakCompareAndSetByteAcquire(Object o, long offset,
1583                                                       byte expected,
1584                                                       byte x) {
1585         return weakCompareAndSetByte(o, offset, expected, x);
1586     }
1587 
1588     @HotSpotIntrinsicCandidate
1589     public final boolean weakCompareAndSetByteRelease(Object o, long offset,
1590                                                       byte expected,
1591                                                       byte x) {
1592         return weakCompareAndSetByte(o, offset, expected, x);
1593     }
1594 
1595     @HotSpotIntrinsicCandidate
1596     public final boolean weakCompareAndSetBytePlain(Object o, long offset,
1597                                                     byte expected,
1598                                                     byte x) {
1599         return weakCompareAndSetByte(o, offset, expected, x);
1600     }
1601 
1602     @HotSpotIntrinsicCandidate
1603     public final byte compareAndExchangeByteAcquire(Object o, long offset,
1604                                                     byte expected,
1605                                                     byte x) {
1606         return compareAndExchangeByte(o, offset, expected, x);
1607     }
1608 
1609     @HotSpotIntrinsicCandidate
1610     public final byte compareAndExchangeByteRelease(Object o, long offset,
1611                                                     byte expected,
1612                                                     byte x) {
1613         return compareAndExchangeByte(o, offset, expected, x);
1614     }
1615 
1616     @HotSpotIntrinsicCandidate
1617     public final short compareAndExchangeShort(Object o, long offset,
1618                                                short expected,
1619                                                short x) {
1620         if ((offset &amp; 3) == 3) {
1621             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1622         }
1623         long wordOffset = offset &amp; ~3;
1624         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1625         if (BIG_ENDIAN) {
1626             shift = 16 - shift;
1627         }
1628         int mask           = 0xFFFF &lt;&lt; shift;
1629         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1630         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1631         int fullWord;
1632         do {
1633             fullWord = getIntVolatile(o, wordOffset);
1634             if ((fullWord &amp; mask) != maskedExpected) {
1635                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1636             }
1637         } while (!weakCompareAndSetInt(o, wordOffset,
1638                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1639         return expected;
1640     }
1641 
1642     @HotSpotIntrinsicCandidate
1643     public final boolean compareAndSetShort(Object o, long offset,
1644                                             short expected,
1645                                             short x) {
1646         return compareAndExchangeShort(o, offset, expected, x) == expected;
1647     }
1648 
1649     @HotSpotIntrinsicCandidate
1650     public final boolean weakCompareAndSetShort(Object o, long offset,
1651                                                 short expected,
1652                                                 short x) {
1653         return compareAndSetShort(o, offset, expected, x);
1654     }
1655 
1656     @HotSpotIntrinsicCandidate
1657     public final boolean weakCompareAndSetShortAcquire(Object o, long offset,
1658                                                        short expected,
1659                                                        short x) {
1660         return weakCompareAndSetShort(o, offset, expected, x);
1661     }
1662 
1663     @HotSpotIntrinsicCandidate
1664     public final boolean weakCompareAndSetShortRelease(Object o, long offset,
1665                                                        short expected,
1666                                                        short x) {
1667         return weakCompareAndSetShort(o, offset, expected, x);
1668     }
1669 
1670     @HotSpotIntrinsicCandidate
1671     public final boolean weakCompareAndSetShortPlain(Object o, long offset,
1672                                                      short expected,
1673                                                      short x) {
1674         return weakCompareAndSetShort(o, offset, expected, x);
1675     }
1676 
1677 
1678     @HotSpotIntrinsicCandidate
1679     public final short compareAndExchangeShortAcquire(Object o, long offset,
1680                                                      short expected,
1681                                                      short x) {
1682         return compareAndExchangeShort(o, offset, expected, x);
1683     }
1684 
1685     @HotSpotIntrinsicCandidate
1686     public final short compareAndExchangeShortRelease(Object o, long offset,
1687                                                     short expected,
1688                                                     short x) {
1689         return compareAndExchangeShort(o, offset, expected, x);
1690     }
1691 
1692     @ForceInline
1693     private char s2c(short s) {
1694         return (char) s;
1695     }
1696 
1697     @ForceInline
1698     private short c2s(char s) {
1699         return (short) s;
1700     }
1701 
1702     @ForceInline
1703     public final boolean compareAndSetChar(Object o, long offset,
1704                                            char expected,
1705                                            char x) {
1706         return compareAndSetShort(o, offset, c2s(expected), c2s(x));
1707     }
1708 
1709     @ForceInline
1710     public final char compareAndExchangeChar(Object o, long offset,
1711                                              char expected,
1712                                              char x) {
1713         return s2c(compareAndExchangeShort(o, offset, c2s(expected), c2s(x)));
1714     }
1715 
1716     @ForceInline
1717     public final char compareAndExchangeCharAcquire(Object o, long offset,
1718                                             char expected,
1719                                             char x) {
1720         return s2c(compareAndExchangeShortAcquire(o, offset, c2s(expected), c2s(x)));
1721     }
1722 
1723     @ForceInline
1724     public final char compareAndExchangeCharRelease(Object o, long offset,
1725                                             char expected,
1726                                             char x) {
1727         return s2c(compareAndExchangeShortRelease(o, offset, c2s(expected), c2s(x)));
1728     }
1729 
1730     @ForceInline
1731     public final boolean weakCompareAndSetChar(Object o, long offset,
1732                                                char expected,
1733                                                char x) {
1734         return weakCompareAndSetShort(o, offset, c2s(expected), c2s(x));
1735     }
1736 
1737     @ForceInline
1738     public final boolean weakCompareAndSetCharAcquire(Object o, long offset,
1739                                                       char expected,
1740                                                       char x) {
1741         return weakCompareAndSetShortAcquire(o, offset, c2s(expected), c2s(x));
1742     }
1743 
1744     @ForceInline
1745     public final boolean weakCompareAndSetCharRelease(Object o, long offset,
1746                                                       char expected,
1747                                                       char x) {
1748         return weakCompareAndSetShortRelease(o, offset, c2s(expected), c2s(x));
1749     }
1750 
1751     @ForceInline
1752     public final boolean weakCompareAndSetCharPlain(Object o, long offset,
1753                                                     char expected,
1754                                                     char x) {
1755         return weakCompareAndSetShortPlain(o, offset, c2s(expected), c2s(x));
1756     }
1757 
1758     /**
1759      * The JVM converts integral values to boolean values using two
1760      * different conventions, byte testing against zero and truncation
1761      * to least-significant bit.
1762      *
1763      * &lt;p&gt;The JNI documents specify that, at least for returning
1764      * values from native methods, a Java boolean value is converted
1765      * to the value-set 0..1 by first truncating to a byte (0..255 or
1766      * maybe -128..127) and then testing against zero. Thus, Java
1767      * booleans in non-Java data structures are by convention
1768      * represented as 8-bit containers containing either zero (for
1769      * false) or any non-zero value (for true).
1770      *
1771      * &lt;p&gt;Java booleans in the heap are also stored in bytes, but are
1772      * strongly normalized to the value-set 0..1 (i.e., they are
1773      * truncated to the least-significant bit).
1774      *
1775      * &lt;p&gt;The main reason for having different conventions for
1776      * conversion is performance: Truncation to the least-significant
1777      * bit can be usually implemented with fewer (machine)
1778      * instructions than byte testing against zero.
1779      *
1780      * &lt;p&gt;A number of Unsafe methods load boolean values from the heap
1781      * as bytes. Unsafe converts those values according to the JNI
1782      * rules (i.e, using the &quot;testing against zero&quot; convention). The
1783      * method {@code byte2bool} implements that conversion.
1784      *
1785      * @param b the byte to be converted to boolean
1786      * @return the result of the conversion
1787      */
1788     @ForceInline
1789     private boolean byte2bool(byte b) {
1790         return b != 0;
1791     }
1792 
1793     /**
1794      * Convert a boolean value to a byte. The return value is strongly
1795      * normalized to the value-set 0..1 (i.e., the value is truncated
1796      * to the least-significant bit). See {@link #byte2bool(byte)} for
1797      * more details on conversion conventions.
1798      *
1799      * @param b the boolean to be converted to byte (and then normalized)
1800      * @return the result of the conversion
1801      */
1802     @ForceInline
1803     private byte bool2byte(boolean b) {
1804         return b ? (byte)1 : (byte)0;
1805     }
1806 
1807     @ForceInline
1808     public final boolean compareAndSetBoolean(Object o, long offset,
1809                                               boolean expected,
1810                                               boolean x) {
1811         return compareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1812     }
1813 
1814     @ForceInline
1815     public final boolean compareAndExchangeBoolean(Object o, long offset,
1816                                                    boolean expected,
1817                                                    boolean x) {
1818         return byte2bool(compareAndExchangeByte(o, offset, bool2byte(expected), bool2byte(x)));
1819     }
1820 
1821     @ForceInline
1822     public final boolean compareAndExchangeBooleanAcquire(Object o, long offset,
1823                                                     boolean expected,
1824                                                     boolean x) {
1825         return byte2bool(compareAndExchangeByteAcquire(o, offset, bool2byte(expected), bool2byte(x)));
1826     }
1827 
1828     @ForceInline
1829     public final boolean compareAndExchangeBooleanRelease(Object o, long offset,
1830                                                        boolean expected,
1831                                                        boolean x) {
1832         return byte2bool(compareAndExchangeByteRelease(o, offset, bool2byte(expected), bool2byte(x)));
1833     }
1834 
1835     @ForceInline
1836     public final boolean weakCompareAndSetBoolean(Object o, long offset,
1837                                                   boolean expected,
1838                                                   boolean x) {
1839         return weakCompareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1840     }
1841 
1842     @ForceInline
1843     public final boolean weakCompareAndSetBooleanAcquire(Object o, long offset,
1844                                                          boolean expected,
1845                                                          boolean x) {
1846         return weakCompareAndSetByteAcquire(o, offset, bool2byte(expected), bool2byte(x));
1847     }
1848 
1849     @ForceInline
1850     public final boolean weakCompareAndSetBooleanRelease(Object o, long offset,
1851                                                          boolean expected,
1852                                                          boolean x) {
1853         return weakCompareAndSetByteRelease(o, offset, bool2byte(expected), bool2byte(x));
1854     }
1855 
1856     @ForceInline
1857     public final boolean weakCompareAndSetBooleanPlain(Object o, long offset,
1858                                                        boolean expected,
1859                                                        boolean x) {
1860         return weakCompareAndSetBytePlain(o, offset, bool2byte(expected), bool2byte(x));
1861     }
1862 
1863     /**
1864      * Atomically updates Java variable to {@code x} if it is currently
1865      * holding {@code expected}.
1866      *
1867      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1868      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1869      *
1870      * @return {@code true} if successful
1871      */
1872     @ForceInline
1873     public final boolean compareAndSetFloat(Object o, long offset,
1874                                             float expected,
1875                                             float x) {
1876         return compareAndSetInt(o, offset,
1877                                  Float.floatToRawIntBits(expected),
1878                                  Float.floatToRawIntBits(x));
1879     }
1880 
1881     @ForceInline
1882     public final float compareAndExchangeFloat(Object o, long offset,
1883                                                float expected,
1884                                                float x) {
1885         int w = compareAndExchangeInt(o, offset,
1886                                       Float.floatToRawIntBits(expected),
1887                                       Float.floatToRawIntBits(x));
1888         return Float.intBitsToFloat(w);
1889     }
1890 
1891     @ForceInline
1892     public final float compareAndExchangeFloatAcquire(Object o, long offset,
1893                                                   float expected,
1894                                                   float x) {
1895         int w = compareAndExchangeIntAcquire(o, offset,
1896                                              Float.floatToRawIntBits(expected),
1897                                              Float.floatToRawIntBits(x));
1898         return Float.intBitsToFloat(w);
1899     }
1900 
1901     @ForceInline
1902     public final float compareAndExchangeFloatRelease(Object o, long offset,
1903                                                   float expected,
1904                                                   float x) {
1905         int w = compareAndExchangeIntRelease(o, offset,
1906                                              Float.floatToRawIntBits(expected),
1907                                              Float.floatToRawIntBits(x));
1908         return Float.intBitsToFloat(w);
1909     }
1910 
1911     @ForceInline
1912     public final boolean weakCompareAndSetFloatPlain(Object o, long offset,
1913                                                      float expected,
1914                                                      float x) {
1915         return weakCompareAndSetIntPlain(o, offset,
1916                                      Float.floatToRawIntBits(expected),
1917                                      Float.floatToRawIntBits(x));
1918     }
1919 
1920     @ForceInline
1921     public final boolean weakCompareAndSetFloatAcquire(Object o, long offset,
1922                                                        float expected,
1923                                                        float x) {
1924         return weakCompareAndSetIntAcquire(o, offset,
1925                                             Float.floatToRawIntBits(expected),
1926                                             Float.floatToRawIntBits(x));
1927     }
1928 
1929     @ForceInline
1930     public final boolean weakCompareAndSetFloatRelease(Object o, long offset,
1931                                                        float expected,
1932                                                        float x) {
1933         return weakCompareAndSetIntRelease(o, offset,
1934                                             Float.floatToRawIntBits(expected),
1935                                             Float.floatToRawIntBits(x));
1936     }
1937 
1938     @ForceInline
1939     public final boolean weakCompareAndSetFloat(Object o, long offset,
1940                                                 float expected,
1941                                                 float x) {
1942         return weakCompareAndSetInt(o, offset,
1943                                              Float.floatToRawIntBits(expected),
1944                                              Float.floatToRawIntBits(x));
1945     }
1946 
1947     /**
1948      * Atomically updates Java variable to {@code x} if it is currently
1949      * holding {@code expected}.
1950      *
1951      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1952      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1953      *
1954      * @return {@code true} if successful
1955      */
1956     @ForceInline
1957     public final boolean compareAndSetDouble(Object o, long offset,
1958                                              double expected,
1959                                              double x) {
1960         return compareAndSetLong(o, offset,
1961                                  Double.doubleToRawLongBits(expected),
1962                                  Double.doubleToRawLongBits(x));
1963     }
1964 
1965     @ForceInline
1966     public final double compareAndExchangeDouble(Object o, long offset,
1967                                                  double expected,
1968                                                  double x) {
1969         long w = compareAndExchangeLong(o, offset,
1970                                         Double.doubleToRawLongBits(expected),
1971                                         Double.doubleToRawLongBits(x));
1972         return Double.longBitsToDouble(w);
1973     }
1974 
1975     @ForceInline
1976     public final double compareAndExchangeDoubleAcquire(Object o, long offset,
1977                                                         double expected,
1978                                                         double x) {
1979         long w = compareAndExchangeLongAcquire(o, offset,
1980                                                Double.doubleToRawLongBits(expected),
1981                                                Double.doubleToRawLongBits(x));
1982         return Double.longBitsToDouble(w);
1983     }
1984 
1985     @ForceInline
1986     public final double compareAndExchangeDoubleRelease(Object o, long offset,
1987                                                         double expected,
1988                                                         double x) {
1989         long w = compareAndExchangeLongRelease(o, offset,
1990                                                Double.doubleToRawLongBits(expected),
1991                                                Double.doubleToRawLongBits(x));
1992         return Double.longBitsToDouble(w);
1993     }
1994 
1995     @ForceInline
1996     public final boolean weakCompareAndSetDoublePlain(Object o, long offset,
1997                                                       double expected,
1998                                                       double x) {
1999         return weakCompareAndSetLongPlain(o, offset,
2000                                      Double.doubleToRawLongBits(expected),
2001                                      Double.doubleToRawLongBits(x));
2002     }
2003 
2004     @ForceInline
2005     public final boolean weakCompareAndSetDoubleAcquire(Object o, long offset,
2006                                                         double expected,
2007                                                         double x) {
2008         return weakCompareAndSetLongAcquire(o, offset,
2009                                              Double.doubleToRawLongBits(expected),
2010                                              Double.doubleToRawLongBits(x));
2011     }
2012 
2013     @ForceInline
2014     public final boolean weakCompareAndSetDoubleRelease(Object o, long offset,
2015                                                         double expected,
2016                                                         double x) {
2017         return weakCompareAndSetLongRelease(o, offset,
2018                                              Double.doubleToRawLongBits(expected),
2019                                              Double.doubleToRawLongBits(x));
2020     }
2021 
2022     @ForceInline
2023     public final boolean weakCompareAndSetDouble(Object o, long offset,
2024                                                  double expected,
2025                                                  double x) {
2026         return weakCompareAndSetLong(o, offset,
2027                                               Double.doubleToRawLongBits(expected),
2028                                               Double.doubleToRawLongBits(x));
2029     }
2030 
2031     /**
2032      * Atomically updates Java variable to {@code x} if it is currently
2033      * holding {@code expected}.
2034      *
2035      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
2036      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
2037      *
2038      * @return {@code true} if successful
2039      */
2040     @HotSpotIntrinsicCandidate
2041     public final native boolean compareAndSetLong(Object o, long offset,
2042                                                   long expected,
2043                                                   long x);
2044 
2045     @HotSpotIntrinsicCandidate
2046     public final native long compareAndExchangeLong(Object o, long offset,
2047                                                     long expected,
2048                                                     long x);
2049 
2050     @HotSpotIntrinsicCandidate
2051     public final long compareAndExchangeLongAcquire(Object o, long offset,
2052                                                            long expected,
2053                                                            long x) {
2054         return compareAndExchangeLong(o, offset, expected, x);
2055     }
2056 
2057     @HotSpotIntrinsicCandidate
2058     public final long compareAndExchangeLongRelease(Object o, long offset,
2059                                                            long expected,
2060                                                            long x) {
2061         return compareAndExchangeLong(o, offset, expected, x);
2062     }
2063 
2064     @HotSpotIntrinsicCandidate
2065     public final boolean weakCompareAndSetLongPlain(Object o, long offset,
2066                                                     long expected,
2067                                                     long x) {
2068         return compareAndSetLong(o, offset, expected, x);
2069     }
2070 
2071     @HotSpotIntrinsicCandidate
2072     public final boolean weakCompareAndSetLongAcquire(Object o, long offset,
2073                                                       long expected,
2074                                                       long x) {
2075         return compareAndSetLong(o, offset, expected, x);
2076     }
2077 
2078     @HotSpotIntrinsicCandidate
2079     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
2080                                                       long expected,
2081                                                       long x) {
2082         return compareAndSetLong(o, offset, expected, x);
2083     }
2084 
2085     @HotSpotIntrinsicCandidate
2086     public final boolean weakCompareAndSetLong(Object o, long offset,
2087                                                long expected,
2088                                                long x) {
2089         return compareAndSetLong(o, offset, expected, x);
2090     }
2091 
2092     /**
2093      * Fetches a reference value from a given Java variable, with volatile
2094      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
2095      */
2096     @HotSpotIntrinsicCandidate
2097     public native Object getReferenceVolatile(Object o, long offset);
2098 
2099     /**
2100      * Stores a reference value into a given Java variable, with
2101      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
2102      */
2103     @HotSpotIntrinsicCandidate
2104     public native void putReferenceVolatile(Object o, long offset, Object x);
2105 
2106     /** Volatile version of {@link #getInt(Object, long)}  */
2107     @HotSpotIntrinsicCandidate
2108     public native int     getIntVolatile(Object o, long offset);
2109 
2110     /** Volatile version of {@link #putInt(Object, long, int)}  */
2111     @HotSpotIntrinsicCandidate
2112     public native void    putIntVolatile(Object o, long offset, int x);
2113 
2114     /** Volatile version of {@link #getBoolean(Object, long)}  */
2115     @HotSpotIntrinsicCandidate
2116     public native boolean getBooleanVolatile(Object o, long offset);
2117 
2118     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
2119     @HotSpotIntrinsicCandidate
2120     public native void    putBooleanVolatile(Object o, long offset, boolean x);
2121 
2122     /** Volatile version of {@link #getByte(Object, long)}  */
2123     @HotSpotIntrinsicCandidate
2124     public native byte    getByteVolatile(Object o, long offset);
2125 
2126     /** Volatile version of {@link #putByte(Object, long, byte)}  */
2127     @HotSpotIntrinsicCandidate
2128     public native void    putByteVolatile(Object o, long offset, byte x);
2129 
2130     /** Volatile version of {@link #getShort(Object, long)}  */
2131     @HotSpotIntrinsicCandidate
2132     public native short   getShortVolatile(Object o, long offset);
2133 
2134     /** Volatile version of {@link #putShort(Object, long, short)}  */
2135     @HotSpotIntrinsicCandidate
2136     public native void    putShortVolatile(Object o, long offset, short x);
2137 
2138     /** Volatile version of {@link #getChar(Object, long)}  */
2139     @HotSpotIntrinsicCandidate
2140     public native char    getCharVolatile(Object o, long offset);
2141 
2142     /** Volatile version of {@link #putChar(Object, long, char)}  */
2143     @HotSpotIntrinsicCandidate
2144     public native void    putCharVolatile(Object o, long offset, char x);
2145 
2146     /** Volatile version of {@link #getLong(Object, long)}  */
2147     @HotSpotIntrinsicCandidate
2148     public native long    getLongVolatile(Object o, long offset);
2149 
2150     /** Volatile version of {@link #putLong(Object, long, long)}  */
2151     @HotSpotIntrinsicCandidate
2152     public native void    putLongVolatile(Object o, long offset, long x);
2153 
2154     /** Volatile version of {@link #getFloat(Object, long)}  */
2155     @HotSpotIntrinsicCandidate
2156     public native float   getFloatVolatile(Object o, long offset);
2157 
2158     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2159     @HotSpotIntrinsicCandidate
2160     public native void    putFloatVolatile(Object o, long offset, float x);
2161 
2162     /** Volatile version of {@link #getDouble(Object, long)}  */
2163     @HotSpotIntrinsicCandidate
2164     public native double  getDoubleVolatile(Object o, long offset);
2165 
2166     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2167     @HotSpotIntrinsicCandidate
2168     public native void    putDoubleVolatile(Object o, long offset, double x);
2169 
2170 
2171 
2172     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2173     @HotSpotIntrinsicCandidate
2174     public final Object getReferenceAcquire(Object o, long offset) {
2175         return getReferenceVolatile(o, offset);
2176     }
2177 
2178     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2179     @HotSpotIntrinsicCandidate
2180     public final boolean getBooleanAcquire(Object o, long offset) {
2181         return getBooleanVolatile(o, offset);
2182     }
2183 
2184     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2185     @HotSpotIntrinsicCandidate
2186     public final byte getByteAcquire(Object o, long offset) {
2187         return getByteVolatile(o, offset);
2188     }
2189 
2190     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2191     @HotSpotIntrinsicCandidate
2192     public final short getShortAcquire(Object o, long offset) {
2193         return getShortVolatile(o, offset);
2194     }
2195 
2196     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2197     @HotSpotIntrinsicCandidate
2198     public final char getCharAcquire(Object o, long offset) {
2199         return getCharVolatile(o, offset);
2200     }
2201 
2202     /** Acquire version of {@link #getIntVolatile(Object, long)} */
2203     @HotSpotIntrinsicCandidate
2204     public final int getIntAcquire(Object o, long offset) {
2205         return getIntVolatile(o, offset);
2206     }
2207 
2208     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2209     @HotSpotIntrinsicCandidate
2210     public final float getFloatAcquire(Object o, long offset) {
2211         return getFloatVolatile(o, offset);
2212     }
2213 
2214     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2215     @HotSpotIntrinsicCandidate
2216     public final long getLongAcquire(Object o, long offset) {
2217         return getLongVolatile(o, offset);
2218     }
2219 
2220     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2221     @HotSpotIntrinsicCandidate
2222     public final double getDoubleAcquire(Object o, long offset) {
2223         return getDoubleVolatile(o, offset);
2224     }
2225 
2226     /*
2227       * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2228       * that do not guarantee immediate visibility of the store to
2229       * other threads. This method is generally only useful if the
2230       * underlying field is a Java volatile (or if an array cell, one
2231       * that is otherwise only accessed using volatile accesses).
2232       *
2233       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2234       */
2235 
2236     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2237     @HotSpotIntrinsicCandidate
2238     public final void putReferenceRelease(Object o, long offset, Object x) {
2239         putReferenceVolatile(o, offset, x);
2240     }
2241 
2242     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2243     @HotSpotIntrinsicCandidate
2244     public final void putBooleanRelease(Object o, long offset, boolean x) {
2245         putBooleanVolatile(o, offset, x);
2246     }
2247 
2248     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2249     @HotSpotIntrinsicCandidate
2250     public final void putByteRelease(Object o, long offset, byte x) {
2251         putByteVolatile(o, offset, x);
2252     }
2253 
2254     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2255     @HotSpotIntrinsicCandidate
2256     public final void putShortRelease(Object o, long offset, short x) {
2257         putShortVolatile(o, offset, x);
2258     }
2259 
2260     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2261     @HotSpotIntrinsicCandidate
2262     public final void putCharRelease(Object o, long offset, char x) {
2263         putCharVolatile(o, offset, x);
2264     }
2265 
2266     /** Release version of {@link #putIntVolatile(Object, long, int)} */
2267     @HotSpotIntrinsicCandidate
2268     public final void putIntRelease(Object o, long offset, int x) {
2269         putIntVolatile(o, offset, x);
2270     }
2271 
2272     /** Release version of {@link #putFloatVolatile(Object, long, float)} */
2273     @HotSpotIntrinsicCandidate
2274     public final void putFloatRelease(Object o, long offset, float x) {
2275         putFloatVolatile(o, offset, x);
2276     }
2277 
2278     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2279     @HotSpotIntrinsicCandidate
2280     public final void putLongRelease(Object o, long offset, long x) {
2281         putLongVolatile(o, offset, x);
2282     }
2283 
2284     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2285     @HotSpotIntrinsicCandidate
2286     public final void putDoubleRelease(Object o, long offset, double x) {
2287         putDoubleVolatile(o, offset, x);
2288     }
2289 
2290     // ------------------------------ Opaque --------------------------------------
2291 
2292     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2293     @HotSpotIntrinsicCandidate
2294     public final Object getReferenceOpaque(Object o, long offset) {
2295         return getReferenceVolatile(o, offset);
2296     }
2297 
2298     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2299     @HotSpotIntrinsicCandidate
2300     public final boolean getBooleanOpaque(Object o, long offset) {
2301         return getBooleanVolatile(o, offset);
2302     }
2303 
2304     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2305     @HotSpotIntrinsicCandidate
2306     public final byte getByteOpaque(Object o, long offset) {
2307         return getByteVolatile(o, offset);
2308     }
2309 
2310     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2311     @HotSpotIntrinsicCandidate
2312     public final short getShortOpaque(Object o, long offset) {
2313         return getShortVolatile(o, offset);
2314     }
2315 
2316     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2317     @HotSpotIntrinsicCandidate
2318     public final char getCharOpaque(Object o, long offset) {
2319         return getCharVolatile(o, offset);
2320     }
2321 
2322     /** Opaque version of {@link #getIntVolatile(Object, long)} */
2323     @HotSpotIntrinsicCandidate
2324     public final int getIntOpaque(Object o, long offset) {
2325         return getIntVolatile(o, offset);
2326     }
2327 
2328     /** Opaque version of {@link #getFloatVolatile(Object, long)} */
2329     @HotSpotIntrinsicCandidate
2330     public final float getFloatOpaque(Object o, long offset) {
2331         return getFloatVolatile(o, offset);
2332     }
2333 
2334     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2335     @HotSpotIntrinsicCandidate
2336     public final long getLongOpaque(Object o, long offset) {
2337         return getLongVolatile(o, offset);
2338     }
2339 
2340     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2341     @HotSpotIntrinsicCandidate
2342     public final double getDoubleOpaque(Object o, long offset) {
2343         return getDoubleVolatile(o, offset);
2344     }
2345 
2346     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2347     @HotSpotIntrinsicCandidate
2348     public final void putReferenceOpaque(Object o, long offset, Object x) {
2349         putReferenceVolatile(o, offset, x);
2350     }
2351 
2352     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2353     @HotSpotIntrinsicCandidate
2354     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2355         putBooleanVolatile(o, offset, x);
2356     }
2357 
2358     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2359     @HotSpotIntrinsicCandidate
2360     public final void putByteOpaque(Object o, long offset, byte x) {
2361         putByteVolatile(o, offset, x);
2362     }
2363 
2364     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2365     @HotSpotIntrinsicCandidate
2366     public final void putShortOpaque(Object o, long offset, short x) {
2367         putShortVolatile(o, offset, x);
2368     }
2369 
2370     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2371     @HotSpotIntrinsicCandidate
2372     public final void putCharOpaque(Object o, long offset, char x) {
2373         putCharVolatile(o, offset, x);
2374     }
2375 
2376     /** Opaque version of {@link #putIntVolatile(Object, long, int)} */
2377     @HotSpotIntrinsicCandidate
2378     public final void putIntOpaque(Object o, long offset, int x) {
2379         putIntVolatile(o, offset, x);
2380     }
2381 
2382     /** Opaque version of {@link #putFloatVolatile(Object, long, float)} */
2383     @HotSpotIntrinsicCandidate
2384     public final void putFloatOpaque(Object o, long offset, float x) {
2385         putFloatVolatile(o, offset, x);
2386     }
2387 
2388     /** Opaque version of {@link #putLongVolatile(Object, long, long)} */
2389     @HotSpotIntrinsicCandidate
2390     public final void putLongOpaque(Object o, long offset, long x) {
2391         putLongVolatile(o, offset, x);
2392     }
2393 
2394     /** Opaque version of {@link #putDoubleVolatile(Object, long, double)} */
2395     @HotSpotIntrinsicCandidate
2396     public final void putDoubleOpaque(Object o, long offset, double x) {
2397         putDoubleVolatile(o, offset, x);
2398     }
2399 
2400     /**
2401      * Unblocks the given thread blocked on {@code park}, or, if it is
2402      * not blocked, causes the subsequent call to {@code park} not to
2403      * block.  Note: this operation is &quot;unsafe&quot; solely because the
2404      * caller must somehow ensure that the thread has not been
2405      * destroyed. Nothing special is usually required to ensure this
2406      * when called from Java (in which there will ordinarily be a live
2407      * reference to the thread) but this is not nearly-automatically
2408      * so when calling from native code.
2409      *
2410      * @param thread the thread to unpark.
2411      */
2412     @HotSpotIntrinsicCandidate
2413     public native void unpark(Object thread);
2414 
2415     /**
2416      * Blocks current thread, returning when a balancing
2417      * {@code unpark} occurs, or a balancing {@code unpark} has
2418      * already occurred, or the thread is interrupted, or, if not
2419      * absolute and time is not zero, the given time nanoseconds have
2420      * elapsed, or if absolute, the given deadline in milliseconds
2421      * since Epoch has passed, or spuriously (i.e., returning for no
2422      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
2423      * because {@code unpark} is, so it would be strange to place it
2424      * elsewhere.
2425      */
2426     @HotSpotIntrinsicCandidate
2427     public native void park(boolean isAbsolute, long time);
2428 
2429     /**
2430      * Gets the load average in the system run queue assigned
2431      * to the available processors averaged over various periods of time.
2432      * This method retrieves the given {@code nelem} samples and
2433      * assigns to the elements of the given {@code loadavg} array.
2434      * The system imposes a maximum of 3 samples, representing
2435      * averages over the last 1,  5,  and  15 minutes, respectively.
2436      *
2437      * @param loadavg an array of double of size nelems
2438      * @param nelems the number of samples to be retrieved and
2439      *        must be 1 to 3.
2440      *
2441      * @return the number of samples actually retrieved; or -1
2442      *         if the load average is unobtainable.
2443      */
2444     public int getLoadAverage(double[] loadavg, int nelems) {
2445         if (nelems &lt; 0 || nelems &gt; 3 || nelems &gt; loadavg.length) {
2446             throw new ArrayIndexOutOfBoundsException();
2447         }
2448 
2449         return getLoadAverage0(loadavg, nelems);
2450     }
2451 
2452     // The following contain CAS-based Java implementations used on
2453     // platforms not supporting native instructions
2454 
2455     /**
2456      * Atomically adds the given value to the current value of a field
2457      * or array element within the given object {@code o}
2458      * at the given {@code offset}.
2459      *
2460      * @param o object/array to update the field/element in
2461      * @param offset field/element offset
2462      * @param delta the value to add
2463      * @return the previous value
2464      * @since 1.8
2465      */
2466     @HotSpotIntrinsicCandidate
2467     public final int getAndAddInt(Object o, long offset, int delta) {
2468         int v;
2469         do {
2470             v = getIntVolatile(o, offset);
2471         } while (!weakCompareAndSetInt(o, offset, v, v + delta));
2472         return v;
2473     }
2474 
2475     @ForceInline
2476     public final int getAndAddIntRelease(Object o, long offset, int delta) {
2477         int v;
2478         do {
2479             v = getInt(o, offset);
2480         } while (!weakCompareAndSetIntRelease(o, offset, v, v + delta));
2481         return v;
2482     }
2483 
2484     @ForceInline
2485     public final int getAndAddIntAcquire(Object o, long offset, int delta) {
2486         int v;
2487         do {
2488             v = getIntAcquire(o, offset);
2489         } while (!weakCompareAndSetIntAcquire(o, offset, v, v + delta));
2490         return v;
2491     }
2492 
2493     /**
2494      * Atomically adds the given value to the current value of a field
2495      * or array element within the given object {@code o}
2496      * at the given {@code offset}.
2497      *
2498      * @param o object/array to update the field/element in
2499      * @param offset field/element offset
2500      * @param delta the value to add
2501      * @return the previous value
2502      * @since 1.8
2503      */
2504     @HotSpotIntrinsicCandidate
2505     public final long getAndAddLong(Object o, long offset, long delta) {
2506         long v;
2507         do {
2508             v = getLongVolatile(o, offset);
2509         } while (!weakCompareAndSetLong(o, offset, v, v + delta));
2510         return v;
2511     }
2512 
2513     @ForceInline
2514     public final long getAndAddLongRelease(Object o, long offset, long delta) {
2515         long v;
2516         do {
2517             v = getLong(o, offset);
2518         } while (!weakCompareAndSetLongRelease(o, offset, v, v + delta));
2519         return v;
2520     }
2521 
2522     @ForceInline
2523     public final long getAndAddLongAcquire(Object o, long offset, long delta) {
2524         long v;
2525         do {
2526             v = getLongAcquire(o, offset);
2527         } while (!weakCompareAndSetLongAcquire(o, offset, v, v + delta));
2528         return v;
2529     }
2530 
2531     @HotSpotIntrinsicCandidate
2532     public final byte getAndAddByte(Object o, long offset, byte delta) {
2533         byte v;
2534         do {
2535             v = getByteVolatile(o, offset);
2536         } while (!weakCompareAndSetByte(o, offset, v, (byte) (v + delta)));
2537         return v;
2538     }
2539 
2540     @ForceInline
2541     public final byte getAndAddByteRelease(Object o, long offset, byte delta) {
2542         byte v;
2543         do {
2544             v = getByte(o, offset);
2545         } while (!weakCompareAndSetByteRelease(o, offset, v, (byte) (v + delta)));
2546         return v;
2547     }
2548 
2549     @ForceInline
2550     public final byte getAndAddByteAcquire(Object o, long offset, byte delta) {
2551         byte v;
2552         do {
2553             v = getByteAcquire(o, offset);
2554         } while (!weakCompareAndSetByteAcquire(o, offset, v, (byte) (v + delta)));
2555         return v;
2556     }
2557 
2558     @HotSpotIntrinsicCandidate
2559     public final short getAndAddShort(Object o, long offset, short delta) {
2560         short v;
2561         do {
2562             v = getShortVolatile(o, offset);
2563         } while (!weakCompareAndSetShort(o, offset, v, (short) (v + delta)));
2564         return v;
2565     }
2566 
2567     @ForceInline
2568     public final short getAndAddShortRelease(Object o, long offset, short delta) {
2569         short v;
2570         do {
2571             v = getShort(o, offset);
2572         } while (!weakCompareAndSetShortRelease(o, offset, v, (short) (v + delta)));
2573         return v;
2574     }
2575 
2576     @ForceInline
2577     public final short getAndAddShortAcquire(Object o, long offset, short delta) {
2578         short v;
2579         do {
2580             v = getShortAcquire(o, offset);
2581         } while (!weakCompareAndSetShortAcquire(o, offset, v, (short) (v + delta)));
2582         return v;
2583     }
2584 
2585     @ForceInline
2586     public final char getAndAddChar(Object o, long offset, char delta) {
2587         return (char) getAndAddShort(o, offset, (short) delta);
2588     }
2589 
2590     @ForceInline
2591     public final char getAndAddCharRelease(Object o, long offset, char delta) {
2592         return (char) getAndAddShortRelease(o, offset, (short) delta);
2593     }
2594 
2595     @ForceInline
2596     public final char getAndAddCharAcquire(Object o, long offset, char delta) {
2597         return (char) getAndAddShortAcquire(o, offset, (short) delta);
2598     }
2599 
2600     @ForceInline
2601     public final float getAndAddFloat(Object o, long offset, float delta) {
2602         int expectedBits;
2603         float v;
2604         do {
2605             // Load and CAS with the raw bits to avoid issues with NaNs and
2606             // possible bit conversion from signaling NaNs to quiet NaNs that
2607             // may result in the loop not terminating.
2608             expectedBits = getIntVolatile(o, offset);
2609             v = Float.intBitsToFloat(expectedBits);
2610         } while (!weakCompareAndSetInt(o, offset,
2611                                                 expectedBits, Float.floatToRawIntBits(v + delta)));
2612         return v;
2613     }
2614 
2615     @ForceInline
2616     public final float getAndAddFloatRelease(Object o, long offset, float delta) {
2617         int expectedBits;
2618         float v;
2619         do {
2620             // Load and CAS with the raw bits to avoid issues with NaNs and
2621             // possible bit conversion from signaling NaNs to quiet NaNs that
2622             // may result in the loop not terminating.
2623             expectedBits = getInt(o, offset);
2624             v = Float.intBitsToFloat(expectedBits);
2625         } while (!weakCompareAndSetIntRelease(o, offset,
2626                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2627         return v;
2628     }
2629 
2630     @ForceInline
2631     public final float getAndAddFloatAcquire(Object o, long offset, float delta) {
2632         int expectedBits;
2633         float v;
2634         do {
2635             // Load and CAS with the raw bits to avoid issues with NaNs and
2636             // possible bit conversion from signaling NaNs to quiet NaNs that
2637             // may result in the loop not terminating.
2638             expectedBits = getIntAcquire(o, offset);
2639             v = Float.intBitsToFloat(expectedBits);
2640         } while (!weakCompareAndSetIntAcquire(o, offset,
2641                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2642         return v;
2643     }
2644 
2645     @ForceInline
2646     public final double getAndAddDouble(Object o, long offset, double delta) {
2647         long expectedBits;
2648         double v;
2649         do {
2650             // Load and CAS with the raw bits to avoid issues with NaNs and
2651             // possible bit conversion from signaling NaNs to quiet NaNs that
2652             // may result in the loop not terminating.
2653             expectedBits = getLongVolatile(o, offset);
2654             v = Double.longBitsToDouble(expectedBits);
2655         } while (!weakCompareAndSetLong(o, offset,
2656                                                  expectedBits, Double.doubleToRawLongBits(v + delta)));
2657         return v;
2658     }
2659 
2660     @ForceInline
2661     public final double getAndAddDoubleRelease(Object o, long offset, double delta) {
2662         long expectedBits;
2663         double v;
2664         do {
2665             // Load and CAS with the raw bits to avoid issues with NaNs and
2666             // possible bit conversion from signaling NaNs to quiet NaNs that
2667             // may result in the loop not terminating.
2668             expectedBits = getLong(o, offset);
2669             v = Double.longBitsToDouble(expectedBits);
2670         } while (!weakCompareAndSetLongRelease(o, offset,
2671                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2672         return v;
2673     }
2674 
2675     @ForceInline
2676     public final double getAndAddDoubleAcquire(Object o, long offset, double delta) {
2677         long expectedBits;
2678         double v;
2679         do {
2680             // Load and CAS with the raw bits to avoid issues with NaNs and
2681             // possible bit conversion from signaling NaNs to quiet NaNs that
2682             // may result in the loop not terminating.
2683             expectedBits = getLongAcquire(o, offset);
2684             v = Double.longBitsToDouble(expectedBits);
2685         } while (!weakCompareAndSetLongAcquire(o, offset,
2686                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2687         return v;
2688     }
2689 
2690     /**
2691      * Atomically exchanges the given value with the current value of
2692      * a field or array element within the given object {@code o}
2693      * at the given {@code offset}.
2694      *
2695      * @param o object/array to update the field/element in
2696      * @param offset field/element offset
2697      * @param newValue new value
2698      * @return the previous value
2699      * @since 1.8
2700      */
2701     @HotSpotIntrinsicCandidate
2702     public final int getAndSetInt(Object o, long offset, int newValue) {
2703         int v;
2704         do {
2705             v = getIntVolatile(o, offset);
2706         } while (!weakCompareAndSetInt(o, offset, v, newValue));
2707         return v;
2708     }
2709 
2710     @ForceInline
2711     public final int getAndSetIntRelease(Object o, long offset, int newValue) {
2712         int v;
2713         do {
2714             v = getInt(o, offset);
2715         } while (!weakCompareAndSetIntRelease(o, offset, v, newValue));
2716         return v;
2717     }
2718 
2719     @ForceInline
2720     public final int getAndSetIntAcquire(Object o, long offset, int newValue) {
2721         int v;
2722         do {
2723             v = getIntAcquire(o, offset);
2724         } while (!weakCompareAndSetIntAcquire(o, offset, v, newValue));
2725         return v;
2726     }
2727 
2728     /**
2729      * Atomically exchanges the given value with the current value of
2730      * a field or array element within the given object {@code o}
2731      * at the given {@code offset}.
2732      *
2733      * @param o object/array to update the field/element in
2734      * @param offset field/element offset
2735      * @param newValue new value
2736      * @return the previous value
2737      * @since 1.8
2738      */
2739     @HotSpotIntrinsicCandidate
2740     public final long getAndSetLong(Object o, long offset, long newValue) {
2741         long v;
2742         do {
2743             v = getLongVolatile(o, offset);
2744         } while (!weakCompareAndSetLong(o, offset, v, newValue));
2745         return v;
2746     }
2747 
2748     @ForceInline
2749     public final long getAndSetLongRelease(Object o, long offset, long newValue) {
2750         long v;
2751         do {
2752             v = getLong(o, offset);
2753         } while (!weakCompareAndSetLongRelease(o, offset, v, newValue));
2754         return v;
2755     }
2756 
2757     @ForceInline
2758     public final long getAndSetLongAcquire(Object o, long offset, long newValue) {
2759         long v;
2760         do {
2761             v = getLongAcquire(o, offset);
2762         } while (!weakCompareAndSetLongAcquire(o, offset, v, newValue));
2763         return v;
2764     }
2765 
2766     /**
2767      * Atomically exchanges the given reference value with the current
2768      * reference value of a field or array element within the given
2769      * object {@code o} at the given {@code offset}.
2770      *
2771      * @param o object/array to update the field/element in
2772      * @param offset field/element offset
2773      * @param newValue new value
2774      * @return the previous value
2775      * @since 1.8
2776      */
2777     @HotSpotIntrinsicCandidate
2778     public final Object getAndSetReference(Object o, long offset, Object newValue) {
2779         Object v;
2780         do {
2781             v = getReferenceVolatile(o, offset);
2782         } while (!weakCompareAndSetReference(o, offset, v, newValue));
2783         return v;
2784     }
2785 
2786     @ForceInline
2787     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
2788         Object v;
2789         do {
2790             v = getReference(o, offset);
2791         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
2792         return v;
2793     }
2794 
2795     @ForceInline
2796     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
2797         Object v;
2798         do {
2799             v = getReferenceAcquire(o, offset);
2800         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
2801         return v;
2802     }
2803 
2804     @HotSpotIntrinsicCandidate
2805     public final byte getAndSetByte(Object o, long offset, byte newValue) {
2806         byte v;
2807         do {
2808             v = getByteVolatile(o, offset);
2809         } while (!weakCompareAndSetByte(o, offset, v, newValue));
2810         return v;
2811     }
2812 
2813     @ForceInline
2814     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
2815         byte v;
2816         do {
2817             v = getByte(o, offset);
2818         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
2819         return v;
2820     }
2821 
2822     @ForceInline
2823     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
2824         byte v;
2825         do {
2826             v = getByteAcquire(o, offset);
2827         } while (!weakCompareAndSetByteAcquire(o, offset, v, newValue));
2828         return v;
2829     }
2830 
2831     @ForceInline
2832     public final boolean getAndSetBoolean(Object o, long offset, boolean newValue) {
2833         return byte2bool(getAndSetByte(o, offset, bool2byte(newValue)));
2834     }
2835 
2836     @ForceInline
2837     public final boolean getAndSetBooleanRelease(Object o, long offset, boolean newValue) {
2838         return byte2bool(getAndSetByteRelease(o, offset, bool2byte(newValue)));
2839     }
2840 
2841     @ForceInline
2842     public final boolean getAndSetBooleanAcquire(Object o, long offset, boolean newValue) {
2843         return byte2bool(getAndSetByteAcquire(o, offset, bool2byte(newValue)));
2844     }
2845 
2846     @HotSpotIntrinsicCandidate
2847     public final short getAndSetShort(Object o, long offset, short newValue) {
2848         short v;
2849         do {
2850             v = getShortVolatile(o, offset);
2851         } while (!weakCompareAndSetShort(o, offset, v, newValue));
2852         return v;
2853     }
2854 
2855     @ForceInline
2856     public final short getAndSetShortRelease(Object o, long offset, short newValue) {
2857         short v;
2858         do {
2859             v = getShort(o, offset);
2860         } while (!weakCompareAndSetShortRelease(o, offset, v, newValue));
2861         return v;
2862     }
2863 
2864     @ForceInline
2865     public final short getAndSetShortAcquire(Object o, long offset, short newValue) {
2866         short v;
2867         do {
2868             v = getShortAcquire(o, offset);
2869         } while (!weakCompareAndSetShortAcquire(o, offset, v, newValue));
2870         return v;
2871     }
2872 
2873     @ForceInline
2874     public final char getAndSetChar(Object o, long offset, char newValue) {
2875         return s2c(getAndSetShort(o, offset, c2s(newValue)));
2876     }
2877 
2878     @ForceInline
2879     public final char getAndSetCharRelease(Object o, long offset, char newValue) {
2880         return s2c(getAndSetShortRelease(o, offset, c2s(newValue)));
2881     }
2882 
2883     @ForceInline
2884     public final char getAndSetCharAcquire(Object o, long offset, char newValue) {
2885         return s2c(getAndSetShortAcquire(o, offset, c2s(newValue)));
2886     }
2887 
2888     @ForceInline
2889     public final float getAndSetFloat(Object o, long offset, float newValue) {
2890         int v = getAndSetInt(o, offset, Float.floatToRawIntBits(newValue));
2891         return Float.intBitsToFloat(v);
2892     }
2893 
2894     @ForceInline
2895     public final float getAndSetFloatRelease(Object o, long offset, float newValue) {
2896         int v = getAndSetIntRelease(o, offset, Float.floatToRawIntBits(newValue));
2897         return Float.intBitsToFloat(v);
2898     }
2899 
2900     @ForceInline
2901     public final float getAndSetFloatAcquire(Object o, long offset, float newValue) {
2902         int v = getAndSetIntAcquire(o, offset, Float.floatToRawIntBits(newValue));
2903         return Float.intBitsToFloat(v);
2904     }
2905 
2906     @ForceInline
2907     public final double getAndSetDouble(Object o, long offset, double newValue) {
2908         long v = getAndSetLong(o, offset, Double.doubleToRawLongBits(newValue));
2909         return Double.longBitsToDouble(v);
2910     }
2911 
2912     @ForceInline
2913     public final double getAndSetDoubleRelease(Object o, long offset, double newValue) {
2914         long v = getAndSetLongRelease(o, offset, Double.doubleToRawLongBits(newValue));
2915         return Double.longBitsToDouble(v);
2916     }
2917 
2918     @ForceInline
2919     public final double getAndSetDoubleAcquire(Object o, long offset, double newValue) {
2920         long v = getAndSetLongAcquire(o, offset, Double.doubleToRawLongBits(newValue));
2921         return Double.longBitsToDouble(v);
2922     }
2923 
2924 
2925     // The following contain CAS-based Java implementations used on
2926     // platforms not supporting native instructions
2927 
2928     @ForceInline
2929     public final boolean getAndBitwiseOrBoolean(Object o, long offset, boolean mask) {
2930         return byte2bool(getAndBitwiseOrByte(o, offset, bool2byte(mask)));
2931     }
2932 
2933     @ForceInline
2934     public final boolean getAndBitwiseOrBooleanRelease(Object o, long offset, boolean mask) {
2935         return byte2bool(getAndBitwiseOrByteRelease(o, offset, bool2byte(mask)));
2936     }
2937 
2938     @ForceInline
2939     public final boolean getAndBitwiseOrBooleanAcquire(Object o, long offset, boolean mask) {
2940         return byte2bool(getAndBitwiseOrByteAcquire(o, offset, bool2byte(mask)));
2941     }
2942 
2943     @ForceInline
2944     public final boolean getAndBitwiseAndBoolean(Object o, long offset, boolean mask) {
2945         return byte2bool(getAndBitwiseAndByte(o, offset, bool2byte(mask)));
2946     }
2947 
2948     @ForceInline
2949     public final boolean getAndBitwiseAndBooleanRelease(Object o, long offset, boolean mask) {
2950         return byte2bool(getAndBitwiseAndByteRelease(o, offset, bool2byte(mask)));
2951     }
2952 
2953     @ForceInline
2954     public final boolean getAndBitwiseAndBooleanAcquire(Object o, long offset, boolean mask) {
2955         return byte2bool(getAndBitwiseAndByteAcquire(o, offset, bool2byte(mask)));
2956     }
2957 
2958     @ForceInline
2959     public final boolean getAndBitwiseXorBoolean(Object o, long offset, boolean mask) {
2960         return byte2bool(getAndBitwiseXorByte(o, offset, bool2byte(mask)));
2961     }
2962 
2963     @ForceInline
2964     public final boolean getAndBitwiseXorBooleanRelease(Object o, long offset, boolean mask) {
2965         return byte2bool(getAndBitwiseXorByteRelease(o, offset, bool2byte(mask)));
2966     }
2967 
2968     @ForceInline
2969     public final boolean getAndBitwiseXorBooleanAcquire(Object o, long offset, boolean mask) {
2970         return byte2bool(getAndBitwiseXorByteAcquire(o, offset, bool2byte(mask)));
2971     }
2972 
2973 
2974     @ForceInline
2975     public final byte getAndBitwiseOrByte(Object o, long offset, byte mask) {
2976         byte current;
2977         do {
2978             current = getByteVolatile(o, offset);
2979         } while (!weakCompareAndSetByte(o, offset,
2980                                                   current, (byte) (current | mask)));
2981         return current;
2982     }
2983 
2984     @ForceInline
2985     public final byte getAndBitwiseOrByteRelease(Object o, long offset, byte mask) {
2986         byte current;
2987         do {
2988             current = getByte(o, offset);
2989         } while (!weakCompareAndSetByteRelease(o, offset,
2990                                                  current, (byte) (current | mask)));
2991         return current;
2992     }
2993 
2994     @ForceInline
2995     public final byte getAndBitwiseOrByteAcquire(Object o, long offset, byte mask) {
2996         byte current;
2997         do {
2998             // Plain read, the value is a hint, the acquire CAS does the work
2999             current = getByte(o, offset);
3000         } while (!weakCompareAndSetByteAcquire(o, offset,
3001                                                  current, (byte) (current | mask)));
3002         return current;
3003     }
3004 
3005     @ForceInline
3006     public final byte getAndBitwiseAndByte(Object o, long offset, byte mask) {
3007         byte current;
3008         do {
3009             current = getByteVolatile(o, offset);
3010         } while (!weakCompareAndSetByte(o, offset,
3011                                                   current, (byte) (current &amp; mask)));
3012         return current;
3013     }
3014 
3015     @ForceInline
3016     public final byte getAndBitwiseAndByteRelease(Object o, long offset, byte mask) {
3017         byte current;
3018         do {
3019             current = getByte(o, offset);
3020         } while (!weakCompareAndSetByteRelease(o, offset,
3021                                                  current, (byte) (current &amp; mask)));
3022         return current;
3023     }
3024 
3025     @ForceInline
3026     public final byte getAndBitwiseAndByteAcquire(Object o, long offset, byte mask) {
3027         byte current;
3028         do {
3029             // Plain read, the value is a hint, the acquire CAS does the work
3030             current = getByte(o, offset);
3031         } while (!weakCompareAndSetByteAcquire(o, offset,
3032                                                  current, (byte) (current &amp; mask)));
3033         return current;
3034     }
3035 
3036     @ForceInline
3037     public final byte getAndBitwiseXorByte(Object o, long offset, byte mask) {
3038         byte current;
3039         do {
3040             current = getByteVolatile(o, offset);
3041         } while (!weakCompareAndSetByte(o, offset,
3042                                                   current, (byte) (current ^ mask)));
3043         return current;
3044     }
3045 
3046     @ForceInline
3047     public final byte getAndBitwiseXorByteRelease(Object o, long offset, byte mask) {
3048         byte current;
3049         do {
3050             current = getByte(o, offset);
3051         } while (!weakCompareAndSetByteRelease(o, offset,
3052                                                  current, (byte) (current ^ mask)));
3053         return current;
3054     }
3055 
3056     @ForceInline
3057     public final byte getAndBitwiseXorByteAcquire(Object o, long offset, byte mask) {
3058         byte current;
3059         do {
3060             // Plain read, the value is a hint, the acquire CAS does the work
3061             current = getByte(o, offset);
3062         } while (!weakCompareAndSetByteAcquire(o, offset,
3063                                                  current, (byte) (current ^ mask)));
3064         return current;
3065     }
3066 
3067 
3068     @ForceInline
3069     public final char getAndBitwiseOrChar(Object o, long offset, char mask) {
3070         return s2c(getAndBitwiseOrShort(o, offset, c2s(mask)));
3071     }
3072 
3073     @ForceInline
3074     public final char getAndBitwiseOrCharRelease(Object o, long offset, char mask) {
3075         return s2c(getAndBitwiseOrShortRelease(o, offset, c2s(mask)));
3076     }
3077 
3078     @ForceInline
3079     public final char getAndBitwiseOrCharAcquire(Object o, long offset, char mask) {
3080         return s2c(getAndBitwiseOrShortAcquire(o, offset, c2s(mask)));
3081     }
3082 
3083     @ForceInline
3084     public final char getAndBitwiseAndChar(Object o, long offset, char mask) {
3085         return s2c(getAndBitwiseAndShort(o, offset, c2s(mask)));
3086     }
3087 
3088     @ForceInline
3089     public final char getAndBitwiseAndCharRelease(Object o, long offset, char mask) {
3090         return s2c(getAndBitwiseAndShortRelease(o, offset, c2s(mask)));
3091     }
3092 
3093     @ForceInline
3094     public final char getAndBitwiseAndCharAcquire(Object o, long offset, char mask) {
3095         return s2c(getAndBitwiseAndShortAcquire(o, offset, c2s(mask)));
3096     }
3097 
3098     @ForceInline
3099     public final char getAndBitwiseXorChar(Object o, long offset, char mask) {
3100         return s2c(getAndBitwiseXorShort(o, offset, c2s(mask)));
3101     }
3102 
3103     @ForceInline
3104     public final char getAndBitwiseXorCharRelease(Object o, long offset, char mask) {
3105         return s2c(getAndBitwiseXorShortRelease(o, offset, c2s(mask)));
3106     }
3107 
3108     @ForceInline
3109     public final char getAndBitwiseXorCharAcquire(Object o, long offset, char mask) {
3110         return s2c(getAndBitwiseXorShortAcquire(o, offset, c2s(mask)));
3111     }
3112 
3113 
3114     @ForceInline
3115     public final short getAndBitwiseOrShort(Object o, long offset, short mask) {
3116         short current;
3117         do {
3118             current = getShortVolatile(o, offset);
3119         } while (!weakCompareAndSetShort(o, offset,
3120                                                 current, (short) (current | mask)));
3121         return current;
3122     }
3123 
3124     @ForceInline
3125     public final short getAndBitwiseOrShortRelease(Object o, long offset, short mask) {
3126         short current;
3127         do {
3128             current = getShort(o, offset);
3129         } while (!weakCompareAndSetShortRelease(o, offset,
3130                                                current, (short) (current | mask)));
3131         return current;
3132     }
3133 
3134     @ForceInline
3135     public final short getAndBitwiseOrShortAcquire(Object o, long offset, short mask) {
3136         short current;
3137         do {
3138             // Plain read, the value is a hint, the acquire CAS does the work
3139             current = getShort(o, offset);
3140         } while (!weakCompareAndSetShortAcquire(o, offset,
3141                                                current, (short) (current | mask)));
3142         return current;
3143     }
3144 
3145     @ForceInline
3146     public final short getAndBitwiseAndShort(Object o, long offset, short mask) {
3147         short current;
3148         do {
3149             current = getShortVolatile(o, offset);
3150         } while (!weakCompareAndSetShort(o, offset,
3151                                                 current, (short) (current &amp; mask)));
3152         return current;
3153     }
3154 
3155     @ForceInline
3156     public final short getAndBitwiseAndShortRelease(Object o, long offset, short mask) {
3157         short current;
3158         do {
3159             current = getShort(o, offset);
3160         } while (!weakCompareAndSetShortRelease(o, offset,
3161                                                current, (short) (current &amp; mask)));
3162         return current;
3163     }
3164 
3165     @ForceInline
3166     public final short getAndBitwiseAndShortAcquire(Object o, long offset, short mask) {
3167         short current;
3168         do {
3169             // Plain read, the value is a hint, the acquire CAS does the work
3170             current = getShort(o, offset);
3171         } while (!weakCompareAndSetShortAcquire(o, offset,
3172                                                current, (short) (current &amp; mask)));
3173         return current;
3174     }
3175 
3176     @ForceInline
3177     public final short getAndBitwiseXorShort(Object o, long offset, short mask) {
3178         short current;
3179         do {
3180             current = getShortVolatile(o, offset);
3181         } while (!weakCompareAndSetShort(o, offset,
3182                                                 current, (short) (current ^ mask)));
3183         return current;
3184     }
3185 
3186     @ForceInline
3187     public final short getAndBitwiseXorShortRelease(Object o, long offset, short mask) {
3188         short current;
3189         do {
3190             current = getShort(o, offset);
3191         } while (!weakCompareAndSetShortRelease(o, offset,
3192                                                current, (short) (current ^ mask)));
3193         return current;
3194     }
3195 
3196     @ForceInline
3197     public final short getAndBitwiseXorShortAcquire(Object o, long offset, short mask) {
3198         short current;
3199         do {
3200             // Plain read, the value is a hint, the acquire CAS does the work
3201             current = getShort(o, offset);
3202         } while (!weakCompareAndSetShortAcquire(o, offset,
3203                                                current, (short) (current ^ mask)));
3204         return current;
3205     }
3206 
3207 
3208     @ForceInline
3209     public final int getAndBitwiseOrInt(Object o, long offset, int mask) {
3210         int current;
3211         do {
3212             current = getIntVolatile(o, offset);
3213         } while (!weakCompareAndSetInt(o, offset,
3214                                                 current, current | mask));
3215         return current;
3216     }
3217 
3218     @ForceInline
3219     public final int getAndBitwiseOrIntRelease(Object o, long offset, int mask) {
3220         int current;
3221         do {
3222             current = getInt(o, offset);
3223         } while (!weakCompareAndSetIntRelease(o, offset,
3224                                                current, current | mask));
3225         return current;
3226     }
3227 
3228     @ForceInline
3229     public final int getAndBitwiseOrIntAcquire(Object o, long offset, int mask) {
3230         int current;
3231         do {
3232             // Plain read, the value is a hint, the acquire CAS does the work
3233             current = getInt(o, offset);
3234         } while (!weakCompareAndSetIntAcquire(o, offset,
3235                                                current, current | mask));
3236         return current;
3237     }
3238 
3239     /**
3240      * Atomically replaces the current value of a field or array element within
3241      * the given object with the result of bitwise AND between the current value
3242      * and mask.
3243      *
3244      * @param o object/array to update the field/element in
3245      * @param offset field/element offset
3246      * @param mask the mask value
3247      * @return the previous value
3248      * @since 9
3249      */
3250     @ForceInline
3251     public final int getAndBitwiseAndInt(Object o, long offset, int mask) {
3252         int current;
3253         do {
3254             current = getIntVolatile(o, offset);
3255         } while (!weakCompareAndSetInt(o, offset,
3256                                                 current, current &amp; mask));
3257         return current;
3258     }
3259 
3260     @ForceInline
3261     public final int getAndBitwiseAndIntRelease(Object o, long offset, int mask) {
3262         int current;
3263         do {
3264             current = getInt(o, offset);
3265         } while (!weakCompareAndSetIntRelease(o, offset,
3266                                                current, current &amp; mask));
3267         return current;
3268     }
3269 
3270     @ForceInline
3271     public final int getAndBitwiseAndIntAcquire(Object o, long offset, int mask) {
3272         int current;
3273         do {
3274             // Plain read, the value is a hint, the acquire CAS does the work
3275             current = getInt(o, offset);
3276         } while (!weakCompareAndSetIntAcquire(o, offset,
3277                                                current, current &amp; mask));
3278         return current;
3279     }
3280 
3281     @ForceInline
3282     public final int getAndBitwiseXorInt(Object o, long offset, int mask) {
3283         int current;
3284         do {
3285             current = getIntVolatile(o, offset);
3286         } while (!weakCompareAndSetInt(o, offset,
3287                                                 current, current ^ mask));
3288         return current;
3289     }
3290 
3291     @ForceInline
3292     public final int getAndBitwiseXorIntRelease(Object o, long offset, int mask) {
3293         int current;
3294         do {
3295             current = getInt(o, offset);
3296         } while (!weakCompareAndSetIntRelease(o, offset,
3297                                                current, current ^ mask));
3298         return current;
3299     }
3300 
3301     @ForceInline
3302     public final int getAndBitwiseXorIntAcquire(Object o, long offset, int mask) {
3303         int current;
3304         do {
3305             // Plain read, the value is a hint, the acquire CAS does the work
3306             current = getInt(o, offset);
3307         } while (!weakCompareAndSetIntAcquire(o, offset,
3308                                                current, current ^ mask));
3309         return current;
3310     }
3311 
3312 
3313     @ForceInline
3314     public final long getAndBitwiseOrLong(Object o, long offset, long mask) {
3315         long current;
3316         do {
3317             current = getLongVolatile(o, offset);
3318         } while (!weakCompareAndSetLong(o, offset,
3319                                                 current, current | mask));
3320         return current;
3321     }
3322 
3323     @ForceInline
3324     public final long getAndBitwiseOrLongRelease(Object o, long offset, long mask) {
3325         long current;
3326         do {
3327             current = getLong(o, offset);
3328         } while (!weakCompareAndSetLongRelease(o, offset,
3329                                                current, current | mask));
3330         return current;
3331     }
3332 
3333     @ForceInline
3334     public final long getAndBitwiseOrLongAcquire(Object o, long offset, long mask) {
3335         long current;
3336         do {
3337             // Plain read, the value is a hint, the acquire CAS does the work
3338             current = getLong(o, offset);
3339         } while (!weakCompareAndSetLongAcquire(o, offset,
3340                                                current, current | mask));
3341         return current;
3342     }
3343 
3344     @ForceInline
3345     public final long getAndBitwiseAndLong(Object o, long offset, long mask) {
3346         long current;
3347         do {
3348             current = getLongVolatile(o, offset);
3349         } while (!weakCompareAndSetLong(o, offset,
3350                                                 current, current &amp; mask));
3351         return current;
3352     }
3353 
3354     @ForceInline
3355     public final long getAndBitwiseAndLongRelease(Object o, long offset, long mask) {
3356         long current;
3357         do {
3358             current = getLong(o, offset);
3359         } while (!weakCompareAndSetLongRelease(o, offset,
3360                                                current, current &amp; mask));
3361         return current;
3362     }
3363 
3364     @ForceInline
3365     public final long getAndBitwiseAndLongAcquire(Object o, long offset, long mask) {
3366         long current;
3367         do {
3368             // Plain read, the value is a hint, the acquire CAS does the work
3369             current = getLong(o, offset);
3370         } while (!weakCompareAndSetLongAcquire(o, offset,
3371                                                current, current &amp; mask));
3372         return current;
3373     }
3374 
3375     @ForceInline
3376     public final long getAndBitwiseXorLong(Object o, long offset, long mask) {
3377         long current;
3378         do {
3379             current = getLongVolatile(o, offset);
3380         } while (!weakCompareAndSetLong(o, offset,
3381                                                 current, current ^ mask));
3382         return current;
3383     }
3384 
3385     @ForceInline
3386     public final long getAndBitwiseXorLongRelease(Object o, long offset, long mask) {
3387         long current;
3388         do {
3389             current = getLong(o, offset);
3390         } while (!weakCompareAndSetLongRelease(o, offset,
3391                                                current, current ^ mask));
3392         return current;
3393     }
3394 
3395     @ForceInline
3396     public final long getAndBitwiseXorLongAcquire(Object o, long offset, long mask) {
3397         long current;
3398         do {
3399             // Plain read, the value is a hint, the acquire CAS does the work
3400             current = getLong(o, offset);
3401         } while (!weakCompareAndSetLongAcquire(o, offset,
3402                                                current, current ^ mask));
3403         return current;
3404     }
3405 
3406 
3407 
3408     /**
3409      * Ensures that loads before the fence will not be reordered with loads and
3410      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
3411      *
3412      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
3413      * (an &quot;acquire fence&quot;).
3414      *
3415      * A pure LoadLoad fence is not provided, since the addition of LoadStore
3416      * is almost always desired, and most current hardware instructions that
3417      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
3418      * @since 1.8
3419      */
3420     @HotSpotIntrinsicCandidate
3421     public native void loadFence();
3422 
3423     /**
3424      * Ensures that loads and stores before the fence will not be reordered with
3425      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
3426      *
3427      * Corresponds to C11 atomic_thread_fence(memory_order_release)
3428      * (a &quot;release fence&quot;).
3429      *
3430      * A pure StoreStore fence is not provided, since the addition of LoadStore
3431      * is almost always desired, and most current hardware instructions that
3432      * provide a StoreStore barrier also provide a LoadStore barrier for free.
3433      * @since 1.8
3434      */
3435     @HotSpotIntrinsicCandidate
3436     public native void storeFence();
3437 
3438     /**
3439      * Ensures that loads and stores before the fence will not be reordered
3440      * with loads and stores after the fence.  Implies the effects of both
3441      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
3442      * barrier.
3443      *
3444      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
3445      * @since 1.8
3446      */
3447     @HotSpotIntrinsicCandidate
3448     public native void fullFence();
3449 
3450     /**
3451      * Ensures that loads before the fence will not be reordered with
3452      * loads after the fence.
3453      */
3454     public final void loadLoadFence() {
3455         loadFence();
3456     }
3457 
3458     /**
3459      * Ensures that stores before the fence will not be reordered with
3460      * stores after the fence.
3461      */
3462     public final void storeStoreFence() {
3463         storeFence();
3464     }
3465 
3466 
3467     /**
3468      * Throws IllegalAccessError; for use by the VM for access control
3469      * error support.
3470      * @since 1.8
3471      */
3472     private static void throwIllegalAccessError() {
3473         throw new IllegalAccessError();
3474     }
3475 
3476     /**
3477      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3478      * @since 13
3479      */
3480     private static void throwNoSuchMethodError() {
3481         throw new NoSuchMethodError();
3482     }
3483 
3484     /**
3485      * @return Returns true if the native byte ordering of this
3486      * platform is big-endian, false if it is little-endian.
3487      */
3488     public final boolean isBigEndian() { return BIG_ENDIAN; }
3489 
3490     /**
3491      * @return Returns true if this platform is capable of performing
3492      * accesses at addresses which are not aligned for the type of the
3493      * primitive type being accessed, false otherwise.
3494      */
3495     public final boolean unalignedAccess() { return UNALIGNED_ACCESS; }
3496 
3497     /**
3498      * Fetches a value at some byte offset into a given Java object.
3499      * More specifically, fetches a value within the given object
3500      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3501      * null) from the memory address whose numerical value is the
3502      * given offset.  &lt;p&gt;
3503      *
3504      * The specification of this method is the same as {@link
3505      * #getLong(Object, long)} except that the offset does not need to
3506      * have been obtained from {@link #objectFieldOffset} on the
3507      * {@link java.lang.reflect.Field} of some Java field.  The value
3508      * in memory is raw data, and need not correspond to any Java
3509      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3510      * must be entirely within the allocated object.  The endianness
3511      * of the value in memory is the endianness of the native platform.
3512      *
3513      * &lt;p&gt; The read will be atomic with respect to the largest power
3514      * of two that divides the GCD of the offset and the storage size.
3515      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
3516      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3517      * respectively.  There are no other guarantees of atomicity.
3518      * &lt;p&gt;
3519      * 8-byte atomicity is only guaranteed on platforms on which
3520      * support atomic accesses to longs.
3521      *
3522      * @param o Java heap object in which the value resides, if any, else
3523      *        null
3524      * @param offset The offset in bytes from the start of the object
3525      * @return the value fetched from the indicated object
3526      * @throws RuntimeException No defined exceptions are thrown, not even
3527      *         {@link NullPointerException}
3528      * @since 9
3529      */
3530     @HotSpotIntrinsicCandidate
3531     public final long getLongUnaligned(Object o, long offset) {
3532         if ((offset &amp; 7) == 0) {
3533             return getLong(o, offset);
3534         } else if ((offset &amp; 3) == 0) {
3535             return makeLong(getInt(o, offset),
3536                             getInt(o, offset + 4));
3537         } else if ((offset &amp; 1) == 0) {
3538             return makeLong(getShort(o, offset),
3539                             getShort(o, offset + 2),
3540                             getShort(o, offset + 4),
3541                             getShort(o, offset + 6));
3542         } else {
3543             return makeLong(getByte(o, offset),
3544                             getByte(o, offset + 1),
3545                             getByte(o, offset + 2),
3546                             getByte(o, offset + 3),
3547                             getByte(o, offset + 4),
3548                             getByte(o, offset + 5),
3549                             getByte(o, offset + 6),
3550                             getByte(o, offset + 7));
3551         }
3552     }
3553     /**
3554      * As {@link #getLongUnaligned(Object, long)} but with an
3555      * additional argument which specifies the endianness of the value
3556      * as stored in memory.
3557      *
3558      * @param o Java heap object in which the variable resides
3559      * @param offset The offset in bytes from the start of the object
3560      * @param bigEndian The endianness of the value
3561      * @return the value fetched from the indicated object
3562      * @since 9
3563      */
3564     public final long getLongUnaligned(Object o, long offset, boolean bigEndian) {
3565         return convEndian(bigEndian, getLongUnaligned(o, offset));
3566     }
3567 
3568     /** @see #getLongUnaligned(Object, long) */
3569     @HotSpotIntrinsicCandidate
3570     public final int getIntUnaligned(Object o, long offset) {
3571         if ((offset &amp; 3) == 0) {
3572             return getInt(o, offset);
3573         } else if ((offset &amp; 1) == 0) {
3574             return makeInt(getShort(o, offset),
3575                            getShort(o, offset + 2));
3576         } else {
3577             return makeInt(getByte(o, offset),
3578                            getByte(o, offset + 1),
3579                            getByte(o, offset + 2),
3580                            getByte(o, offset + 3));
3581         }
3582     }
3583     /** @see #getLongUnaligned(Object, long, boolean) */
3584     public final int getIntUnaligned(Object o, long offset, boolean bigEndian) {
3585         return convEndian(bigEndian, getIntUnaligned(o, offset));
3586     }
3587 
3588     /** @see #getLongUnaligned(Object, long) */
3589     @HotSpotIntrinsicCandidate
3590     public final short getShortUnaligned(Object o, long offset) {
3591         if ((offset &amp; 1) == 0) {
3592             return getShort(o, offset);
3593         } else {
3594             return makeShort(getByte(o, offset),
3595                              getByte(o, offset + 1));
3596         }
3597     }
3598     /** @see #getLongUnaligned(Object, long, boolean) */
3599     public final short getShortUnaligned(Object o, long offset, boolean bigEndian) {
3600         return convEndian(bigEndian, getShortUnaligned(o, offset));
3601     }
3602 
3603     /** @see #getLongUnaligned(Object, long) */
3604     @HotSpotIntrinsicCandidate
3605     public final char getCharUnaligned(Object o, long offset) {
3606         if ((offset &amp; 1) == 0) {
3607             return getChar(o, offset);
3608         } else {
3609             return (char)makeShort(getByte(o, offset),
3610                                    getByte(o, offset + 1));
3611         }
3612     }
3613 
3614     /** @see #getLongUnaligned(Object, long, boolean) */
3615     public final char getCharUnaligned(Object o, long offset, boolean bigEndian) {
3616         return convEndian(bigEndian, getCharUnaligned(o, offset));
3617     }
3618 
3619     /**
3620      * Stores a value at some byte offset into a given Java object.
3621      * &lt;p&gt;
3622      * The specification of this method is the same as {@link
3623      * #getLong(Object, long)} except that the offset does not need to
3624      * have been obtained from {@link #objectFieldOffset} on the
3625      * {@link java.lang.reflect.Field} of some Java field.  The value
3626      * in memory is raw data, and need not correspond to any Java
3627      * variable.  The endianness of the value in memory is the
3628      * endianness of the native platform.
3629      * &lt;p&gt;
3630      * The write will be atomic with respect to the largest power of
3631      * two that divides the GCD of the offset and the storage size.
3632      * For example, putLongUnaligned will make atomic writes of 2-, 4-,
3633      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3634      * respectively.  There are no other guarantees of atomicity.
3635      * &lt;p&gt;
3636      * 8-byte atomicity is only guaranteed on platforms on which
3637      * support atomic accesses to longs.
3638      *
3639      * @param o Java heap object in which the value resides, if any, else
3640      *        null
3641      * @param offset The offset in bytes from the start of the object
3642      * @param x the value to store
3643      * @throws RuntimeException No defined exceptions are thrown, not even
3644      *         {@link NullPointerException}
3645      * @since 9
3646      */
3647     @HotSpotIntrinsicCandidate
3648     public final void putLongUnaligned(Object o, long offset, long x) {
3649         if ((offset &amp; 7) == 0) {
3650             putLong(o, offset, x);
3651         } else if ((offset &amp; 3) == 0) {
3652             putLongParts(o, offset,
3653                          (int)(x &gt;&gt; 0),
3654                          (int)(x &gt;&gt;&gt; 32));
3655         } else if ((offset &amp; 1) == 0) {
3656             putLongParts(o, offset,
3657                          (short)(x &gt;&gt;&gt; 0),
3658                          (short)(x &gt;&gt;&gt; 16),
3659                          (short)(x &gt;&gt;&gt; 32),
3660                          (short)(x &gt;&gt;&gt; 48));
3661         } else {
3662             putLongParts(o, offset,
3663                          (byte)(x &gt;&gt;&gt; 0),
3664                          (byte)(x &gt;&gt;&gt; 8),
3665                          (byte)(x &gt;&gt;&gt; 16),
3666                          (byte)(x &gt;&gt;&gt; 24),
3667                          (byte)(x &gt;&gt;&gt; 32),
3668                          (byte)(x &gt;&gt;&gt; 40),
3669                          (byte)(x &gt;&gt;&gt; 48),
3670                          (byte)(x &gt;&gt;&gt; 56));
3671         }
3672     }
3673 
3674     /**
3675      * As {@link #putLongUnaligned(Object, long, long)} but with an additional
3676      * argument which specifies the endianness of the value as stored in memory.
3677      * @param o Java heap object in which the value resides
3678      * @param offset The offset in bytes from the start of the object
3679      * @param x the value to store
3680      * @param bigEndian The endianness of the value
3681      * @throws RuntimeException No defined exceptions are thrown, not even
3682      *         {@link NullPointerException}
3683      * @since 9
3684      */
3685     public final void putLongUnaligned(Object o, long offset, long x, boolean bigEndian) {
3686         putLongUnaligned(o, offset, convEndian(bigEndian, x));
3687     }
3688 
3689     /** @see #putLongUnaligned(Object, long, long) */
3690     @HotSpotIntrinsicCandidate
3691     public final void putIntUnaligned(Object o, long offset, int x) {
3692         if ((offset &amp; 3) == 0) {
3693             putInt(o, offset, x);
3694         } else if ((offset &amp; 1) == 0) {
3695             putIntParts(o, offset,
3696                         (short)(x &gt;&gt; 0),
3697                         (short)(x &gt;&gt;&gt; 16));
3698         } else {
3699             putIntParts(o, offset,
3700                         (byte)(x &gt;&gt;&gt; 0),
3701                         (byte)(x &gt;&gt;&gt; 8),
3702                         (byte)(x &gt;&gt;&gt; 16),
3703                         (byte)(x &gt;&gt;&gt; 24));
3704         }
3705     }
3706     /** @see #putLongUnaligned(Object, long, long, boolean) */
3707     public final void putIntUnaligned(Object o, long offset, int x, boolean bigEndian) {
3708         putIntUnaligned(o, offset, convEndian(bigEndian, x));
3709     }
3710 
3711     /** @see #putLongUnaligned(Object, long, long) */
3712     @HotSpotIntrinsicCandidate
3713     public final void putShortUnaligned(Object o, long offset, short x) {
3714         if ((offset &amp; 1) == 0) {
3715             putShort(o, offset, x);
3716         } else {
3717             putShortParts(o, offset,
3718                           (byte)(x &gt;&gt;&gt; 0),
3719                           (byte)(x &gt;&gt;&gt; 8));
3720         }
3721     }
3722     /** @see #putLongUnaligned(Object, long, long, boolean) */
3723     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
3724         putShortUnaligned(o, offset, convEndian(bigEndian, x));
3725     }
3726 
3727     /** @see #putLongUnaligned(Object, long, long) */
3728     @HotSpotIntrinsicCandidate
3729     public final void putCharUnaligned(Object o, long offset, char x) {
3730         putShortUnaligned(o, offset, (short)x);
3731     }
3732     /** @see #putLongUnaligned(Object, long, long, boolean) */
3733     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
3734         putCharUnaligned(o, offset, convEndian(bigEndian, x));
3735     }
3736 
3737     private static int pickPos(int top, int pos) { return BIG_ENDIAN ? top - pos : pos; }
3738 
3739     // These methods construct integers from bytes.  The byte ordering
3740     // is the native endianness of this platform.
3741     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3742         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
3743               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
3744               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
3745               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
3746               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
3747               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
3748               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
3749               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
3750     }
3751     private static long makeLong(short i0, short i1, short i2, short i3) {
3752         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
3753               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
3754               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
3755               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
3756     }
3757     private static long makeLong(int i0, int i1) {
3758         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
3759              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
3760     }
3761     private static int makeInt(short i0, short i1) {
3762         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
3763              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
3764     }
3765     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
3766         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
3767               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
3768               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
3769               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
3770     }
3771     private static short makeShort(byte i0, byte i1) {
3772         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
3773                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
3774     }
3775 
3776     private static byte  pick(byte  le, byte  be) { return BIG_ENDIAN ? be : le; }
3777     private static short pick(short le, short be) { return BIG_ENDIAN ? be : le; }
3778     private static int   pick(int   le, int   be) { return BIG_ENDIAN ? be : le; }
3779 
3780     // These methods write integers to memory from smaller parts
3781     // provided by their caller.  The ordering in which these parts
3782     // are written is the native endianness of this platform.
3783     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3784         putByte(o, offset + 0, pick(i0, i7));
3785         putByte(o, offset + 1, pick(i1, i6));
3786         putByte(o, offset + 2, pick(i2, i5));
3787         putByte(o, offset + 3, pick(i3, i4));
3788         putByte(o, offset + 4, pick(i4, i3));
3789         putByte(o, offset + 5, pick(i5, i2));
3790         putByte(o, offset + 6, pick(i6, i1));
3791         putByte(o, offset + 7, pick(i7, i0));
3792     }
3793     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
3794         putShort(o, offset + 0, pick(i0, i3));
3795         putShort(o, offset + 2, pick(i1, i2));
3796         putShort(o, offset + 4, pick(i2, i1));
3797         putShort(o, offset + 6, pick(i3, i0));
3798     }
3799     private void putLongParts(Object o, long offset, int i0, int i1) {
3800         putInt(o, offset + 0, pick(i0, i1));
3801         putInt(o, offset + 4, pick(i1, i0));
3802     }
3803     private void putIntParts(Object o, long offset, short i0, short i1) {
3804         putShort(o, offset + 0, pick(i0, i1));
3805         putShort(o, offset + 2, pick(i1, i0));
3806     }
3807     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
3808         putByte(o, offset + 0, pick(i0, i3));
3809         putByte(o, offset + 1, pick(i1, i2));
3810         putByte(o, offset + 2, pick(i2, i1));
3811         putByte(o, offset + 3, pick(i3, i0));
3812     }
3813     private void putShortParts(Object o, long offset, byte i0, byte i1) {
3814         putByte(o, offset + 0, pick(i0, i1));
3815         putByte(o, offset + 1, pick(i1, i0));
3816     }
3817 
3818     // Zero-extend an integer
3819     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
3820     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
3821     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
3822     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
3823     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
3824 
3825     // Maybe byte-reverse an integer
3826     private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }
3827     private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }
3828     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }
3829     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }
3830 
3831 
3832 
3833     private native long allocateMemory0(long bytes);
3834     private native long reallocateMemory0(long address, long bytes);
3835     private native void freeMemory0(long address);
3836     private native void setMemory0(Object o, long offset, long bytes, byte value);
3837     @HotSpotIntrinsicCandidate
3838     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3839     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3840     private native long objectFieldOffset0(Field f);
3841     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3842     private native long staticFieldOffset0(Field f);
3843     private native Object staticFieldBase0(Field f);
3844     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3845     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3846     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3847     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
3848     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3849     private native int getLoadAverage0(double[] loadavg, int nelems);
3850 
3851 
3852     /**
3853      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3854      *
3855      * @param directBuffer a direct byte buffer
3856      * @throws NullPointerException     if {@code directBuffer} is null
3857      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3858      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3859      *                                  {@link java.nio.Buffer#duplicate duplicate}
3860      */
3861     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3862         if (!directBuffer.isDirect())
3863             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3864 
3865         DirectBuffer db = (DirectBuffer) directBuffer;
3866         if (db.attachment() != null)
3867             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
3868 
3869         Cleaner cleaner = db.cleaner();
3870         if (cleaner != null) {
3871             cleaner.clean();
3872         }
3873     }
3874 
3875     // The following deprecated methods are used by JSR 166.
3876 
3877     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3878     public final Object getObject(Object o, long offset) {
3879         return getReference(o, offset);
3880     }
3881     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3882     public final Object getObjectVolatile(Object o, long offset) {
3883         return getReferenceVolatile(o, offset);
3884     }
3885     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3886     public final Object getObjectAcquire(Object o, long offset) {
3887         return getReferenceAcquire(o, offset);
3888     }
3889     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3890     public final Object getObjectOpaque(Object o, long offset) {
3891         return getReferenceOpaque(o, offset);
3892     }
3893 
3894 
3895     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3896     public final void putObject(Object o, long offset, Object x) {
3897         putReference(o, offset, x);
3898     }
3899     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3900     public final void putObjectVolatile(Object o, long offset, Object x) {
3901         putReferenceVolatile(o, offset, x);
3902     }
3903     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3904     public final void putObjectOpaque(Object o, long offset, Object x) {
3905         putReferenceOpaque(o, offset, x);
3906     }
3907     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3908     public final void putObjectRelease(Object o, long offset, Object x) {
3909         putReferenceRelease(o, offset, x);
3910     }
3911 
3912 
3913     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3914     public final Object getAndSetObject(Object o, long offset, Object newValue) {
3915         return getAndSetReference(o, offset, newValue);
3916     }
3917     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3918     public final Object getAndSetObjectAcquire(Object o, long offset, Object newValue) {
3919         return getAndSetReferenceAcquire(o, offset, newValue);
3920     }
3921     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3922     public final Object getAndSetObjectRelease(Object o, long offset, Object newValue) {
3923         return getAndSetReferenceRelease(o, offset, newValue);
3924     }
3925 
3926 
3927     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3928     public final boolean compareAndSetObject(Object o, long offset, Object expected, Object x) {
3929         return compareAndSetReference(o, offset, expected, x);
3930     }
3931     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3932     public final Object compareAndExchangeObject(Object o, long offset, Object expected, Object x) {
3933         return compareAndExchangeReference(o, offset, expected, x);
3934     }
3935     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3936     public final Object compareAndExchangeObjectAcquire(Object o, long offset, Object expected, Object x) {
3937         return compareAndExchangeReferenceAcquire(o, offset, expected, x);
3938     }
3939     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3940     public final Object compareAndExchangeObjectRelease(Object o, long offset, Object expected, Object x) {
3941         return compareAndExchangeReferenceRelease(o, offset, expected, x);
3942     }
3943 
3944 
3945     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3946     public final boolean weakCompareAndSetObject(Object o, long offset, Object expected, Object x) {
3947         return weakCompareAndSetReference(o, offset, expected, x);
3948     }
3949     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3950     public final boolean weakCompareAndSetObjectAcquire(Object o, long offset, Object expected, Object x) {
3951         return weakCompareAndSetReferenceAcquire(o, offset, expected, x);
3952     }
3953     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3954     public final boolean weakCompareAndSetObjectPlain(Object o, long offset, Object expected, Object x) {
3955         return weakCompareAndSetReferencePlain(o, offset, expected, x);
3956     }
3957     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3958     public final boolean weakCompareAndSetObjectRelease(Object o, long offset, Object expected, Object x) {
3959         return weakCompareAndSetReferenceRelease(o, offset, expected, x);
3960     }
3961 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>