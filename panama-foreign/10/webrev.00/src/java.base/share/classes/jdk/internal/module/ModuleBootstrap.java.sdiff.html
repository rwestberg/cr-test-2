<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../sun/security/provider/certpath/OCSPResponse.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/module/ModuleBootstrap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 123      * Returns the ModuleFinder for the initial configuration.
 124      *
 125      * @apiNote Used to support &quot;{@code java --list-modules}&quot;.
 126      */
 127     public static ModuleFinder limitedFinder() {
 128         ModuleFinder finder = limitedFinder;
 129         if (finder == null) {
 130             return unlimitedFinder();
 131         } else {
 132             return finder;
 133         }
 134     }
 135 
 136     /**
 137      * Initialize the module system, returning the boot layer.
 138      *
 139      * @see java.lang.System#initPhase2(boolean, boolean)
 140      */
 141     public static ModuleLayer boot() throws Exception {
 142 
<span class="line-modified"> 143         // Step 0: Command line options</span>
 144 
<span class="line-modified"> 145         long t0 = System.nanoTime();</span>
 146 
 147         ModuleFinder upgradeModulePath = finderFor(&quot;jdk.module.upgrade.path&quot;);
 148         ModuleFinder appModulePath = finderFor(&quot;jdk.module.path&quot;);
 149         boolean isPatched = patcher.hasPatches();
 150 
 151         String mainModule = System.getProperty(&quot;jdk.module.main&quot;);
 152         Set&lt;String&gt; addModules = addModules();
 153         Set&lt;String&gt; limitModules = limitModules();
 154 
 155         PrintStream traceOutput = null;
 156         String trace = getAndRemoveProperty(&quot;jdk.module.showModuleResolution&quot;);
 157         if (trace != null &amp;&amp; Boolean.parseBoolean(trace))
 158             traceOutput = System.out;
 159 

 160 
 161         // Step 1: The observable system modules, either all system modules
 162         // or the system modules pre-generated for the initial module (the
 163         // initial module may be the unnamed module). If the system modules
 164         // are pre-generated for the initial module then resolution can be
 165         // skipped.
 166 
<span class="line-removed"> 167         long t1 = System.nanoTime();</span>
<span class="line-removed"> 168 </span>
 169         SystemModules systemModules = null;
 170         ModuleFinder systemModuleFinder;
 171 
 172         boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);
 173         boolean needResolution = true;
 174         boolean canArchive = false;
 175         boolean hasSplitPackages;
 176         boolean hasIncubatorModules;
 177 
 178         // If the java heap was archived at CDS dump time and the environment
 179         // at dump time matches the current environment then use the archived
 180         // system modules and finder.
 181         ArchivedModuleGraph archivedModuleGraph = ArchivedModuleGraph.get(mainModule);
 182         if (archivedModuleGraph != null
 183                 &amp;&amp; !haveModulePath
 184                 &amp;&amp; addModules.isEmpty()
 185                 &amp;&amp; limitModules.isEmpty()
 186                 &amp;&amp; !isPatched) {
 187             systemModuleFinder = archivedModuleGraph.finder();
 188             hasSplitPackages = archivedModuleGraph.hasSplitPackages();
</pre>
<hr />
<pre>
 198             }
 199             if (systemModules == null) {
 200                 // all system modules are observable
 201                 systemModules = SystemModuleFinders.allSystemModules();
 202             }
 203             if (systemModules != null) {
 204                 // images build
 205                 systemModuleFinder = SystemModuleFinders.of(systemModules);
 206             } else {
 207                 // exploded build or testing
 208                 systemModules = new ExplodedSystemModules();
 209                 systemModuleFinder = SystemModuleFinders.ofSystem();
 210             }
 211 
 212             hasSplitPackages = systemModules.hasSplitPackages();
 213             hasIncubatorModules = systemModules.hasIncubatorModules();
 214             // not using the archived module graph - avoid accidental use
 215             archivedModuleGraph = null;
 216         }
 217 
<span class="line-modified"> 218         Counters.add(&quot;jdk.module.boot.1.systemModulesTime&quot;, t1);</span>
<span class="line-removed"> 219 </span>
 220 
 221         // Step 2: Define and load java.base. This patches all classes loaded
 222         // to date so that they are members of java.base. Once java.base is
 223         // loaded then resources in java.base are available for error messages
 224         // needed from here on.
 225 
<span class="line-removed"> 226         long t2 = System.nanoTime();</span>
<span class="line-removed"> 227 </span>
 228         ModuleReference base = systemModuleFinder.find(JAVA_BASE).orElse(null);
 229         if (base == null)
 230             throw new InternalError(JAVA_BASE + &quot; not found&quot;);
 231         URI baseUri = base.location().orElse(null);
 232         if (baseUri == null)
 233             throw new InternalError(JAVA_BASE + &quot; does not have a location&quot;);
 234         BootLoader.loadModule(base);
 235         Modules.defineModule(null, base.descriptor(), baseUri);
 236 
<span class="line-removed"> 237         Counters.add(&quot;jdk.module.boot.2.defineBaseTime&quot;, t2);</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239 </span>
 240         // Step 2a: Scan all modules when --validate-modules specified
 241 
 242         if (getAndRemoveProperty(&quot;jdk.module.validation&quot;) != null) {
 243             int errors = ModulePathValidator.scanAllModules(System.out);
 244             if (errors &gt; 0) {
 245                 fail(&quot;Validation of module path failed&quot;);
 246             }
 247         }
 248 

 249 
 250         // Step 3: If resolution is needed then create the module finder and
 251         // the set of root modules to resolve.
 252 
<span class="line-removed"> 253         long t3 = System.nanoTime();</span>
<span class="line-removed"> 254 </span>
 255         ModuleFinder savedModuleFinder = null;
 256         ModuleFinder finder;
 257         Set&lt;String&gt; roots;
 258         if (needResolution) {
 259 
 260             // upgraded modules override the modules in the run-time image
 261             if (upgradeModulePath != null)
 262                 systemModuleFinder = ModuleFinder.compose(upgradeModulePath,
 263                                                           systemModuleFinder);
 264 
 265             // The module finder: [--upgrade-module-path] system [--module-path]
 266             if (appModulePath != null) {
 267                 finder = ModuleFinder.compose(systemModuleFinder, appModulePath);
 268             } else {
 269                 finder = systemModuleFinder;
 270             }
 271 
 272             // The root modules to resolve
 273             roots = new HashSet&lt;&gt;();
 274 
</pre>
<hr />
<pre>
 324                     .forEach(mn -&gt; roots.add(mn));
 325             }
 326 
 327             // If `--add-modules ALL-MODULE-PATH` is specified then all observable
 328             // modules on the application module path will be resolved.
 329             if (appModulePath != null &amp;&amp; addAllApplicationModules) {
 330                 ModuleFinder f = finder;  // observable modules
 331                 appModulePath.findAll()
 332                     .stream()
 333                     .map(ModuleReference::descriptor)
 334                     .map(ModuleDescriptor::name)
 335                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 336                     .forEach(mn -&gt; roots.add(mn));
 337             }
 338         } else {
 339             // no resolution case
 340             finder = systemModuleFinder;
 341             roots = null;
 342         }
 343 
<span class="line-modified"> 344         Counters.add(&quot;jdk.module.boot.3.optionsAndRootsTime&quot;, t3);</span>
 345 
 346         // Step 4: Resolve the root modules, with service binding, to create
 347         // the configuration for the boot layer. If resolution is not needed
 348         // then create the configuration for the boot layer from the
 349         // readability graph created at link time.
 350 
<span class="line-removed"> 351         long t4 = System.nanoTime();</span>
<span class="line-removed"> 352 </span>
 353         Configuration cf;
 354         if (needResolution) {
 355             cf = Modules.newBootLayerConfiguration(finder, roots, traceOutput);
 356         } else {
 357             if (archivedModuleGraph != null) {
 358                 cf = archivedModuleGraph.configuration();
 359             } else {
 360                 Map&lt;String, Set&lt;String&gt;&gt; map = systemModules.moduleReads();
 361                 cf = JLMA.newConfiguration(systemModuleFinder, map);
 362             }
 363         }
 364 
 365         // check that modules specified to --patch-module are resolved
 366         if (isPatched) {
 367             patcher.patchedModules()
 368                     .stream()
 369                     .filter(mn -&gt; !cf.findModule(mn).isPresent())
 370                     .forEach(mn -&gt; warnUnknownModule(PATCH_MODULE, mn));
 371         }
 372 
<span class="line-modified"> 373         Counters.add(&quot;jdk.module.boot.4.resolveTime&quot;, t4);</span>
<span class="line-removed"> 374 </span>
 375 
 376         // Step 5: Map the modules in the configuration to class loaders.
 377         // The static configuration provides the mapping of standard and JDK
 378         // modules to the boot and platform loaders. All other modules (JDK
 379         // tool modules, and both explicit and automatic modules on the
 380         // application module path) are defined to the application class
 381         // loader.
 382 
<span class="line-removed"> 383         long t5 = System.nanoTime();</span>
<span class="line-removed"> 384 </span>
 385         // mapping of modules to class loaders
 386         Function&lt;String, ClassLoader&gt; clf = ModuleLoaderMap.mappingFunction(cf);
 387 
 388         // check that all modules to be mapped to the boot loader will be
 389         // loaded from the runtime image
 390         if (haveModulePath) {
 391             for (ResolvedModule resolvedModule : cf.modules()) {
 392                 ModuleReference mref = resolvedModule.reference();
 393                 String name = mref.descriptor().name();
 394                 ClassLoader cl = clf.apply(name);
 395                 if (cl == null) {
 396                     if (upgradeModulePath != null
 397                             &amp;&amp; upgradeModulePath.find(name).isPresent())
 398                         fail(name + &quot;: cannot be loaded from upgrade module path&quot;);
 399                     if (!systemModuleFinder.find(name).isPresent())
 400                         fail(name + &quot;: cannot be loaded from application module path&quot;);
 401                 }
 402             }
 403         }
 404 
 405         // check for split packages in the modules mapped to the built-in loaders
 406         if (hasSplitPackages || isPatched || haveModulePath) {
 407             checkSplitPackages(cf, clf);
 408         }
 409 
 410         // load/register the modules with the built-in class loaders
 411         loadModules(cf, clf);
<span class="line-modified"> 412 </span>
<span class="line-removed"> 413         Counters.add(&quot;jdk.module.boot.5.loadModulesTime&quot;, t5);</span>
<span class="line-removed"> 414 </span>
 415 
 416         // Step 6: Define all modules to the VM
 417 
<span class="line-removed"> 418         long t6 = System.nanoTime();</span>
 419         ModuleLayer bootLayer = ModuleLayer.empty().defineModules(cf, clf);
<span class="line-modified"> 420         Counters.add(&quot;jdk.module.boot.6.layerCreateTime&quot;, t6);</span>
<span class="line-removed"> 421 </span>
 422 
 423         // Step 7: Miscellaneous
 424 
 425         // check incubating status
 426         if (hasIncubatorModules || haveModulePath) {
 427             checkIncubatingStatus(cf);
 428         }
 429 
 430         // --add-reads, --add-exports/--add-opens, and --illegal-access
<span class="line-removed"> 431         long t7 = System.nanoTime();</span>
 432         addExtraReads(bootLayer);
 433         boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);
 434 
 435         Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen;
 436         Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen;
 437         if (archivedModuleGraph != null) {
 438             concealedPackagesToOpen = archivedModuleGraph.concealedPackagesToOpen();
 439             exportedPackagesToOpen = archivedModuleGraph.exportedPackagesToOpen();
 440         } else {
 441             concealedPackagesToOpen = systemModules.concealedPackagesToOpen();
 442             exportedPackagesToOpen = systemModules.exportedPackagesToOpen();
 443         }
 444         addIllegalAccess(upgradeModulePath,
 445                          concealedPackagesToOpen,
 446                          exportedPackagesToOpen,
 447                          bootLayer,
 448                          extraExportsOrOpens);
<span class="line-modified"> 449         Counters.add(&quot;jdk.module.boot.7.adjustModulesTime&quot;, t7);</span>
 450 
 451         // save module finders for later use
 452         if (savedModuleFinder != null) {
 453             unlimitedFinder = new SafeModuleFinder(savedModuleFinder);
 454             if (savedModuleFinder != finder)
 455                 limitedFinder = new SafeModuleFinder(finder);
 456         }
 457 
 458         // Module graph can be archived at CDS dump time. Only allow the
 459         // unnamed module case for now.
 460         if (canArchive &amp;&amp; (mainModule == null)) {
 461             ArchivedModuleGraph.archive(mainModule,
 462                                         hasSplitPackages,
 463                                         hasIncubatorModules,
 464                                         systemModuleFinder,
 465                                         cf,
 466                                         concealedPackagesToOpen,
 467                                         exportedPackagesToOpen);
 468         }
 469 
 470         // total time to initialize
<span class="line-modified"> 471         Counters.add(&quot;jdk.module.boot.totalTime&quot;, t0);</span>
<span class="line-removed"> 472         Counters.publish();</span>
 473 
 474         return bootLayer;
 475     }
 476 
 477     /**
 478      * Load/register the modules to the built-in class loaders.
 479      */
 480     private static void loadModules(Configuration cf,
 481                                     Function&lt;String, ClassLoader&gt; clf) {
 482         for (ResolvedModule resolvedModule : cf.modules()) {
 483             ModuleReference mref = resolvedModule.reference();
 484             String name = resolvedModule.name();
 485             ClassLoader loader = clf.apply(name);
 486             if (loader == null) {
 487                 // skip java.base as it is already loaded
 488                 if (!name.equals(JAVA_BASE)) {
 489                     BootLoader.loadModule(mref);
 490                 }
 491             } else if (loader instanceof BuiltinClassLoader) {
 492                 ((BuiltinClassLoader) loader).loadModule(mref);
</pre>
<hr />
<pre>
 784                 case &quot;debug&quot;:
 785                     mode = IllegalAccessLogger.Mode.DEBUG;
 786                     break;
 787                 default:
 788                     fail(&quot;Value specified to --illegal-access not recognized:&quot;
 789                             + &quot; &#39;&quot; + value + &quot;&#39;&quot;);
 790                     return;
 791             }
 792         }
 793         IllegalAccessLogger.Builder builder
 794             = new IllegalAccessLogger.Builder(mode, System.err);
 795 
 796         if (concealedPackagesToOpen.isEmpty() &amp;&amp; exportedPackagesToOpen.isEmpty()) {
 797             // need to generate (exploded build)
 798             IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());
 799             concealedPackagesToOpen = maps.concealedPackagesToOpen();
 800             exportedPackagesToOpen = maps.exportedPackagesToOpen();
 801         }
 802 
 803         // open specific packages in the system modules

 804         for (Module m : bootLayer.modules()) {
 805             ModuleDescriptor descriptor = m.getDescriptor();
 806             String name = m.getName();
 807 
 808             // skip open modules
 809             if (descriptor.isOpen()) {
 810                 continue;
 811             }
 812 
 813             // skip modules loaded from the upgrade module path
 814             if (upgradeModulePath != null
 815                 &amp;&amp; upgradeModulePath.find(name).isPresent()) {
 816                 continue;
 817             }
 818 
<span class="line-modified"> 819             Set&lt;String&gt; concealedPackages = concealedPackagesToOpen.getOrDefault(name, Set.of());</span>
<span class="line-modified"> 820             Set&lt;String&gt; exportedPackages = exportedPackagesToOpen.getOrDefault(name, Set.of());</span>
 821 
 822             // refresh the set of concealed and exported packages if needed
 823             if (extraExportsOrOpens) {
 824                 concealedPackages = new HashSet&lt;&gt;(concealedPackages);
 825                 exportedPackages = new HashSet&lt;&gt;(exportedPackages);
 826                 Iterator&lt;String&gt; iterator = concealedPackages.iterator();
 827                 while (iterator.hasNext()) {
 828                     String pn = iterator.next();
 829                     if (m.isExported(pn, BootLoader.getUnnamedModule())) {
 830                         // concealed package is exported to ALL-UNNAMED
 831                         iterator.remove();
 832                         exportedPackages.add(pn);
 833                     }
 834                 }
 835                 iterator = exportedPackages.iterator();
 836                 while (iterator.hasNext()) {
 837                     String pn = iterator.next();
 838                     if (m.isOpen(pn, BootLoader.getUnnamedModule())) {
 839                         // exported package is opened to ALL-UNNAMED
 840                         iterator.remove();
 841                     }
 842                 }
 843             }
 844 
 845             // log reflective access to all types in concealed packages
 846             builder.logAccessToConcealedPackages(m, concealedPackages);
 847 
 848             // log reflective access to non-public members/types in exported packages
 849             builder.logAccessToExportedPackages(m, exportedPackages);
 850 
 851             // open the packages to unnamed modules
 852             JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
<span class="line-modified"> 853             jla.addOpensToAllUnnamed(m, concat(concealedPackages.iterator(),</span>
<span class="line-removed"> 854                                                exportedPackages.iterator()));</span>
 855         }
 856 
 857         builder.complete();
 858     }
 859 
 860     /**
 861      * Decodes the values of --add-reads, -add-exports, --add-opens or
 862      * --patch-modules options that are encoded in system properties.
 863      *
 864      * @param prefix the system property prefix
 865      * @praam regex the regex for splitting the RHS of the option value
 866      */
 867     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix,
 868                                                     String regex,
 869                                                     boolean allowDuplicates) {
 870         int index = 0;
 871         // the system property is removed after decoding
 872         String value = getAndRemoveProperty(prefix + index);
 873         if (value == null)
 874             return Map.of();
</pre>
<hr />
<pre>
 978      * Returns the command-line option name corresponds to the specified
 979      * system property prefix.
 980      */
 981     static String option(String prefix) {
 982         switch (prefix) {
 983             case &quot;jdk.module.addexports.&quot;:
 984                 return ADD_EXPORTS;
 985             case &quot;jdk.module.addopens.&quot;:
 986                 return ADD_OPENS;
 987             case &quot;jdk.module.addreads.&quot;:
 988                 return ADD_READS;
 989             case &quot;jdk.module.patch.&quot;:
 990                 return PATCH_MODULE;
 991             case &quot;jdk.module.addmods.&quot;:
 992                 return ADD_MODULES;
 993             default:
 994                 throw new IllegalArgumentException(prefix);
 995         }
 996     }
 997 
<span class="line-removed"> 998     /**</span>
<span class="line-removed"> 999      * Returns an iterator that yields all elements of the first iterator</span>
<span class="line-removed">1000      * followed by all the elements of the second iterator.</span>
<span class="line-removed">1001      */</span>
<span class="line-removed">1002     static &lt;T&gt; Iterator&lt;T&gt; concat(Iterator&lt;T&gt; iterator1, Iterator&lt;T&gt; iterator2) {</span>
<span class="line-removed">1003         return new Iterator&lt;T&gt;() {</span>
<span class="line-removed">1004             @Override</span>
<span class="line-removed">1005             public boolean hasNext() {</span>
<span class="line-removed">1006                 return iterator1.hasNext() || iterator2.hasNext();</span>
<span class="line-removed">1007             }</span>
<span class="line-removed">1008             @Override</span>
<span class="line-removed">1009             public T next() {</span>
<span class="line-removed">1010                 if (iterator1.hasNext()) return iterator1.next();</span>
<span class="line-removed">1011                 if (iterator2.hasNext()) return iterator2.next();</span>
<span class="line-removed">1012                 throw new NoSuchElementException();</span>
<span class="line-removed">1013             }</span>
<span class="line-removed">1014         };</span>
<span class="line-removed">1015     }</span>
<span class="line-removed">1016 </span>
1017     /**
1018      * Wraps a (potentially not thread safe) ModuleFinder created during startup
1019      * for use after startup.
1020      */
1021     static class SafeModuleFinder implements ModuleFinder {
1022         private final Set&lt;ModuleReference&gt; mrefs;
1023         private volatile Map&lt;String, ModuleReference&gt; nameToModule;
1024 
1025         SafeModuleFinder(ModuleFinder finder) {
1026             this.mrefs = Collections.unmodifiableSet(finder.findAll());
1027         }
1028         @Override
1029         public Optional&lt;ModuleReference&gt; find(String name) {
1030             Objects.requireNonNull(name);
1031             Map&lt;String, ModuleReference&gt; nameToModule = this.nameToModule;
1032             if (nameToModule == null) {
1033                 this.nameToModule = nameToModule = mrefs.stream()
1034                         .collect(Collectors.toMap(m -&gt; m.descriptor().name(),
1035                                                   Function.identity()));
1036             }
1037             return Optional.ofNullable(nameToModule.get(name));
1038         }
1039         @Override
1040         public Set&lt;ModuleReference&gt; findAll() {
1041             return mrefs;
1042         }
1043     }
1044 
1045     /**
1046      * Counters for startup performance analysis.
1047      */
1048     static class Counters {
1049         private static final boolean PUBLISH_COUNTERS;
1050         private static final boolean PRINT_COUNTERS;
1051         private static Map&lt;String, Long&gt; counters;



1052         static {
1053             String s = System.getProperty(&quot;jdk.module.boot.usePerfData&quot;);
1054             if (s == null) {
1055                 PUBLISH_COUNTERS = false;
1056                 PRINT_COUNTERS = false;
1057             } else {
1058                 PUBLISH_COUNTERS = true;
1059                 PRINT_COUNTERS = s.equals(&quot;debug&quot;);
1060                 counters = new LinkedHashMap&lt;&gt;();  // preserve insert order
1061             }
1062         }
1063 
1064         /**
<span class="line-modified">1065          * Add a counter</span>










1066          */
<span class="line-modified">1067         static void add(String name, long start) {</span>
<span class="line-modified">1068             if (PUBLISH_COUNTERS || PRINT_COUNTERS) {</span>
<span class="line-modified">1069                 counters.put(name, (System.nanoTime() - start));</span>



1070             }
1071         }
1072 
1073         /**
1074          * Publish the counters to the instrumentation buffer or stdout.
1075          */
<span class="line-modified">1076         static void publish() {</span>
<span class="line-modified">1077             if (PUBLISH_COUNTERS || PRINT_COUNTERS) {</span>

1078                 for (Map.Entry&lt;String, Long&gt; e : counters.entrySet()) {
1079                     String name = e.getKey();
1080                     long value = e.getValue();
<span class="line-modified">1081                     if (PUBLISH_COUNTERS)</span>
<span class="line-removed">1082                         PerfCounter.newPerfCounter(name).set(value);</span>
1083                     if (PRINT_COUNTERS)
1084                         System.out.println(name + &quot; = &quot; + value);
1085                 }




1086             }
1087         }
1088     }
1089 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 123      * Returns the ModuleFinder for the initial configuration.
 124      *
 125      * @apiNote Used to support &quot;{@code java --list-modules}&quot;.
 126      */
 127     public static ModuleFinder limitedFinder() {
 128         ModuleFinder finder = limitedFinder;
 129         if (finder == null) {
 130             return unlimitedFinder();
 131         } else {
 132             return finder;
 133         }
 134     }
 135 
 136     /**
 137      * Initialize the module system, returning the boot layer.
 138      *
 139      * @see java.lang.System#initPhase2(boolean, boolean)
 140      */
 141     public static ModuleLayer boot() throws Exception {
 142 
<span class="line-modified"> 143         Counters.start();</span>
 144 
<span class="line-modified"> 145         // Step 0: Command line options</span>
 146 
 147         ModuleFinder upgradeModulePath = finderFor(&quot;jdk.module.upgrade.path&quot;);
 148         ModuleFinder appModulePath = finderFor(&quot;jdk.module.path&quot;);
 149         boolean isPatched = patcher.hasPatches();
 150 
 151         String mainModule = System.getProperty(&quot;jdk.module.main&quot;);
 152         Set&lt;String&gt; addModules = addModules();
 153         Set&lt;String&gt; limitModules = limitModules();
 154 
 155         PrintStream traceOutput = null;
 156         String trace = getAndRemoveProperty(&quot;jdk.module.showModuleResolution&quot;);
 157         if (trace != null &amp;&amp; Boolean.parseBoolean(trace))
 158             traceOutput = System.out;
 159 
<span class="line-added"> 160         Counters.add(&quot;jdk.module.boot.0.commandLineTime&quot;);</span>
 161 
 162         // Step 1: The observable system modules, either all system modules
 163         // or the system modules pre-generated for the initial module (the
 164         // initial module may be the unnamed module). If the system modules
 165         // are pre-generated for the initial module then resolution can be
 166         // skipped.
 167 


 168         SystemModules systemModules = null;
 169         ModuleFinder systemModuleFinder;
 170 
 171         boolean haveModulePath = (appModulePath != null || upgradeModulePath != null);
 172         boolean needResolution = true;
 173         boolean canArchive = false;
 174         boolean hasSplitPackages;
 175         boolean hasIncubatorModules;
 176 
 177         // If the java heap was archived at CDS dump time and the environment
 178         // at dump time matches the current environment then use the archived
 179         // system modules and finder.
 180         ArchivedModuleGraph archivedModuleGraph = ArchivedModuleGraph.get(mainModule);
 181         if (archivedModuleGraph != null
 182                 &amp;&amp; !haveModulePath
 183                 &amp;&amp; addModules.isEmpty()
 184                 &amp;&amp; limitModules.isEmpty()
 185                 &amp;&amp; !isPatched) {
 186             systemModuleFinder = archivedModuleGraph.finder();
 187             hasSplitPackages = archivedModuleGraph.hasSplitPackages();
</pre>
<hr />
<pre>
 197             }
 198             if (systemModules == null) {
 199                 // all system modules are observable
 200                 systemModules = SystemModuleFinders.allSystemModules();
 201             }
 202             if (systemModules != null) {
 203                 // images build
 204                 systemModuleFinder = SystemModuleFinders.of(systemModules);
 205             } else {
 206                 // exploded build or testing
 207                 systemModules = new ExplodedSystemModules();
 208                 systemModuleFinder = SystemModuleFinders.ofSystem();
 209             }
 210 
 211             hasSplitPackages = systemModules.hasSplitPackages();
 212             hasIncubatorModules = systemModules.hasIncubatorModules();
 213             // not using the archived module graph - avoid accidental use
 214             archivedModuleGraph = null;
 215         }
 216 
<span class="line-modified"> 217         Counters.add(&quot;jdk.module.boot.1.systemModulesTime&quot;);</span>

 218 
 219         // Step 2: Define and load java.base. This patches all classes loaded
 220         // to date so that they are members of java.base. Once java.base is
 221         // loaded then resources in java.base are available for error messages
 222         // needed from here on.
 223 


 224         ModuleReference base = systemModuleFinder.find(JAVA_BASE).orElse(null);
 225         if (base == null)
 226             throw new InternalError(JAVA_BASE + &quot; not found&quot;);
 227         URI baseUri = base.location().orElse(null);
 228         if (baseUri == null)
 229             throw new InternalError(JAVA_BASE + &quot; does not have a location&quot;);
 230         BootLoader.loadModule(base);
 231         Modules.defineModule(null, base.descriptor(), baseUri);
 232 



 233         // Step 2a: Scan all modules when --validate-modules specified
 234 
 235         if (getAndRemoveProperty(&quot;jdk.module.validation&quot;) != null) {
 236             int errors = ModulePathValidator.scanAllModules(System.out);
 237             if (errors &gt; 0) {
 238                 fail(&quot;Validation of module path failed&quot;);
 239             }
 240         }
 241 
<span class="line-added"> 242         Counters.add(&quot;jdk.module.boot.2.defineBaseTime&quot;);</span>
 243 
 244         // Step 3: If resolution is needed then create the module finder and
 245         // the set of root modules to resolve.
 246 


 247         ModuleFinder savedModuleFinder = null;
 248         ModuleFinder finder;
 249         Set&lt;String&gt; roots;
 250         if (needResolution) {
 251 
 252             // upgraded modules override the modules in the run-time image
 253             if (upgradeModulePath != null)
 254                 systemModuleFinder = ModuleFinder.compose(upgradeModulePath,
 255                                                           systemModuleFinder);
 256 
 257             // The module finder: [--upgrade-module-path] system [--module-path]
 258             if (appModulePath != null) {
 259                 finder = ModuleFinder.compose(systemModuleFinder, appModulePath);
 260             } else {
 261                 finder = systemModuleFinder;
 262             }
 263 
 264             // The root modules to resolve
 265             roots = new HashSet&lt;&gt;();
 266 
</pre>
<hr />
<pre>
 316                     .forEach(mn -&gt; roots.add(mn));
 317             }
 318 
 319             // If `--add-modules ALL-MODULE-PATH` is specified then all observable
 320             // modules on the application module path will be resolved.
 321             if (appModulePath != null &amp;&amp; addAllApplicationModules) {
 322                 ModuleFinder f = finder;  // observable modules
 323                 appModulePath.findAll()
 324                     .stream()
 325                     .map(ModuleReference::descriptor)
 326                     .map(ModuleDescriptor::name)
 327                     .filter(mn -&gt; f.find(mn).isPresent())  // observable
 328                     .forEach(mn -&gt; roots.add(mn));
 329             }
 330         } else {
 331             // no resolution case
 332             finder = systemModuleFinder;
 333             roots = null;
 334         }
 335 
<span class="line-modified"> 336         Counters.add(&quot;jdk.module.boot.3.optionsAndRootsTime&quot;);</span>
 337 
 338         // Step 4: Resolve the root modules, with service binding, to create
 339         // the configuration for the boot layer. If resolution is not needed
 340         // then create the configuration for the boot layer from the
 341         // readability graph created at link time.
 342 


 343         Configuration cf;
 344         if (needResolution) {
 345             cf = Modules.newBootLayerConfiguration(finder, roots, traceOutput);
 346         } else {
 347             if (archivedModuleGraph != null) {
 348                 cf = archivedModuleGraph.configuration();
 349             } else {
 350                 Map&lt;String, Set&lt;String&gt;&gt; map = systemModules.moduleReads();
 351                 cf = JLMA.newConfiguration(systemModuleFinder, map);
 352             }
 353         }
 354 
 355         // check that modules specified to --patch-module are resolved
 356         if (isPatched) {
 357             patcher.patchedModules()
 358                     .stream()
 359                     .filter(mn -&gt; !cf.findModule(mn).isPresent())
 360                     .forEach(mn -&gt; warnUnknownModule(PATCH_MODULE, mn));
 361         }
 362 
<span class="line-modified"> 363         Counters.add(&quot;jdk.module.boot.4.resolveTime&quot;);</span>

 364 
 365         // Step 5: Map the modules in the configuration to class loaders.
 366         // The static configuration provides the mapping of standard and JDK
 367         // modules to the boot and platform loaders. All other modules (JDK
 368         // tool modules, and both explicit and automatic modules on the
 369         // application module path) are defined to the application class
 370         // loader.
 371 


 372         // mapping of modules to class loaders
 373         Function&lt;String, ClassLoader&gt; clf = ModuleLoaderMap.mappingFunction(cf);
 374 
 375         // check that all modules to be mapped to the boot loader will be
 376         // loaded from the runtime image
 377         if (haveModulePath) {
 378             for (ResolvedModule resolvedModule : cf.modules()) {
 379                 ModuleReference mref = resolvedModule.reference();
 380                 String name = mref.descriptor().name();
 381                 ClassLoader cl = clf.apply(name);
 382                 if (cl == null) {
 383                     if (upgradeModulePath != null
 384                             &amp;&amp; upgradeModulePath.find(name).isPresent())
 385                         fail(name + &quot;: cannot be loaded from upgrade module path&quot;);
 386                     if (!systemModuleFinder.find(name).isPresent())
 387                         fail(name + &quot;: cannot be loaded from application module path&quot;);
 388                 }
 389             }
 390         }
 391 
 392         // check for split packages in the modules mapped to the built-in loaders
 393         if (hasSplitPackages || isPatched || haveModulePath) {
 394             checkSplitPackages(cf, clf);
 395         }
 396 
 397         // load/register the modules with the built-in class loaders
 398         loadModules(cf, clf);
<span class="line-modified"> 399         Counters.add(&quot;jdk.module.boot.5.loadModulesTime&quot;);</span>


 400 
 401         // Step 6: Define all modules to the VM
 402 

 403         ModuleLayer bootLayer = ModuleLayer.empty().defineModules(cf, clf);
<span class="line-modified"> 404         Counters.add(&quot;jdk.module.boot.6.layerCreateTime&quot;);</span>

 405 
 406         // Step 7: Miscellaneous
 407 
 408         // check incubating status
 409         if (hasIncubatorModules || haveModulePath) {
 410             checkIncubatingStatus(cf);
 411         }
 412 
 413         // --add-reads, --add-exports/--add-opens, and --illegal-access

 414         addExtraReads(bootLayer);
 415         boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);
 416 
 417         Map&lt;String, Set&lt;String&gt;&gt; concealedPackagesToOpen;
 418         Map&lt;String, Set&lt;String&gt;&gt; exportedPackagesToOpen;
 419         if (archivedModuleGraph != null) {
 420             concealedPackagesToOpen = archivedModuleGraph.concealedPackagesToOpen();
 421             exportedPackagesToOpen = archivedModuleGraph.exportedPackagesToOpen();
 422         } else {
 423             concealedPackagesToOpen = systemModules.concealedPackagesToOpen();
 424             exportedPackagesToOpen = systemModules.exportedPackagesToOpen();
 425         }
 426         addIllegalAccess(upgradeModulePath,
 427                          concealedPackagesToOpen,
 428                          exportedPackagesToOpen,
 429                          bootLayer,
 430                          extraExportsOrOpens);
<span class="line-modified"> 431         Counters.add(&quot;jdk.module.boot.7.adjustModulesTime&quot;);</span>
 432 
 433         // save module finders for later use
 434         if (savedModuleFinder != null) {
 435             unlimitedFinder = new SafeModuleFinder(savedModuleFinder);
 436             if (savedModuleFinder != finder)
 437                 limitedFinder = new SafeModuleFinder(finder);
 438         }
 439 
 440         // Module graph can be archived at CDS dump time. Only allow the
 441         // unnamed module case for now.
 442         if (canArchive &amp;&amp; (mainModule == null)) {
 443             ArchivedModuleGraph.archive(mainModule,
 444                                         hasSplitPackages,
 445                                         hasIncubatorModules,
 446                                         systemModuleFinder,
 447                                         cf,
 448                                         concealedPackagesToOpen,
 449                                         exportedPackagesToOpen);
 450         }
 451 
 452         // total time to initialize
<span class="line-modified"> 453         Counters.publish(&quot;jdk.module.boot.totalTime&quot;);</span>

 454 
 455         return bootLayer;
 456     }
 457 
 458     /**
 459      * Load/register the modules to the built-in class loaders.
 460      */
 461     private static void loadModules(Configuration cf,
 462                                     Function&lt;String, ClassLoader&gt; clf) {
 463         for (ResolvedModule resolvedModule : cf.modules()) {
 464             ModuleReference mref = resolvedModule.reference();
 465             String name = resolvedModule.name();
 466             ClassLoader loader = clf.apply(name);
 467             if (loader == null) {
 468                 // skip java.base as it is already loaded
 469                 if (!name.equals(JAVA_BASE)) {
 470                     BootLoader.loadModule(mref);
 471                 }
 472             } else if (loader instanceof BuiltinClassLoader) {
 473                 ((BuiltinClassLoader) loader).loadModule(mref);
</pre>
<hr />
<pre>
 765                 case &quot;debug&quot;:
 766                     mode = IllegalAccessLogger.Mode.DEBUG;
 767                     break;
 768                 default:
 769                     fail(&quot;Value specified to --illegal-access not recognized:&quot;
 770                             + &quot; &#39;&quot; + value + &quot;&#39;&quot;);
 771                     return;
 772             }
 773         }
 774         IllegalAccessLogger.Builder builder
 775             = new IllegalAccessLogger.Builder(mode, System.err);
 776 
 777         if (concealedPackagesToOpen.isEmpty() &amp;&amp; exportedPackagesToOpen.isEmpty()) {
 778             // need to generate (exploded build)
 779             IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());
 780             concealedPackagesToOpen = maps.concealedPackagesToOpen();
 781             exportedPackagesToOpen = maps.exportedPackagesToOpen();
 782         }
 783 
 784         // open specific packages in the system modules
<span class="line-added"> 785         Set&lt;String&gt; emptySet = Set.of();</span>
 786         for (Module m : bootLayer.modules()) {
 787             ModuleDescriptor descriptor = m.getDescriptor();
 788             String name = m.getName();
 789 
 790             // skip open modules
 791             if (descriptor.isOpen()) {
 792                 continue;
 793             }
 794 
 795             // skip modules loaded from the upgrade module path
 796             if (upgradeModulePath != null
 797                 &amp;&amp; upgradeModulePath.find(name).isPresent()) {
 798                 continue;
 799             }
 800 
<span class="line-modified"> 801             Set&lt;String&gt; concealedPackages = concealedPackagesToOpen.getOrDefault(name, emptySet);</span>
<span class="line-modified"> 802             Set&lt;String&gt; exportedPackages = exportedPackagesToOpen.getOrDefault(name, emptySet);</span>
 803 
 804             // refresh the set of concealed and exported packages if needed
 805             if (extraExportsOrOpens) {
 806                 concealedPackages = new HashSet&lt;&gt;(concealedPackages);
 807                 exportedPackages = new HashSet&lt;&gt;(exportedPackages);
 808                 Iterator&lt;String&gt; iterator = concealedPackages.iterator();
 809                 while (iterator.hasNext()) {
 810                     String pn = iterator.next();
 811                     if (m.isExported(pn, BootLoader.getUnnamedModule())) {
 812                         // concealed package is exported to ALL-UNNAMED
 813                         iterator.remove();
 814                         exportedPackages.add(pn);
 815                     }
 816                 }
 817                 iterator = exportedPackages.iterator();
 818                 while (iterator.hasNext()) {
 819                     String pn = iterator.next();
 820                     if (m.isOpen(pn, BootLoader.getUnnamedModule())) {
 821                         // exported package is opened to ALL-UNNAMED
 822                         iterator.remove();
 823                     }
 824                 }
 825             }
 826 
 827             // log reflective access to all types in concealed packages
 828             builder.logAccessToConcealedPackages(m, concealedPackages);
 829 
 830             // log reflective access to non-public members/types in exported packages
 831             builder.logAccessToExportedPackages(m, exportedPackages);
 832 
 833             // open the packages to unnamed modules
 834             JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
<span class="line-modified"> 835             jla.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);</span>

 836         }
 837 
 838         builder.complete();
 839     }
 840 
 841     /**
 842      * Decodes the values of --add-reads, -add-exports, --add-opens or
 843      * --patch-modules options that are encoded in system properties.
 844      *
 845      * @param prefix the system property prefix
 846      * @praam regex the regex for splitting the RHS of the option value
 847      */
 848     private static Map&lt;String, List&lt;String&gt;&gt; decode(String prefix,
 849                                                     String regex,
 850                                                     boolean allowDuplicates) {
 851         int index = 0;
 852         // the system property is removed after decoding
 853         String value = getAndRemoveProperty(prefix + index);
 854         if (value == null)
 855             return Map.of();
</pre>
<hr />
<pre>
 959      * Returns the command-line option name corresponds to the specified
 960      * system property prefix.
 961      */
 962     static String option(String prefix) {
 963         switch (prefix) {
 964             case &quot;jdk.module.addexports.&quot;:
 965                 return ADD_EXPORTS;
 966             case &quot;jdk.module.addopens.&quot;:
 967                 return ADD_OPENS;
 968             case &quot;jdk.module.addreads.&quot;:
 969                 return ADD_READS;
 970             case &quot;jdk.module.patch.&quot;:
 971                 return PATCH_MODULE;
 972             case &quot;jdk.module.addmods.&quot;:
 973                 return ADD_MODULES;
 974             default:
 975                 throw new IllegalArgumentException(prefix);
 976         }
 977     }
 978 



















 979     /**
 980      * Wraps a (potentially not thread safe) ModuleFinder created during startup
 981      * for use after startup.
 982      */
 983     static class SafeModuleFinder implements ModuleFinder {
 984         private final Set&lt;ModuleReference&gt; mrefs;
 985         private volatile Map&lt;String, ModuleReference&gt; nameToModule;
 986 
 987         SafeModuleFinder(ModuleFinder finder) {
 988             this.mrefs = Collections.unmodifiableSet(finder.findAll());
 989         }
 990         @Override
 991         public Optional&lt;ModuleReference&gt; find(String name) {
 992             Objects.requireNonNull(name);
 993             Map&lt;String, ModuleReference&gt; nameToModule = this.nameToModule;
 994             if (nameToModule == null) {
 995                 this.nameToModule = nameToModule = mrefs.stream()
 996                         .collect(Collectors.toMap(m -&gt; m.descriptor().name(),
 997                                                   Function.identity()));
 998             }
 999             return Optional.ofNullable(nameToModule.get(name));
1000         }
1001         @Override
1002         public Set&lt;ModuleReference&gt; findAll() {
1003             return mrefs;
1004         }
1005     }
1006 
1007     /**
1008      * Counters for startup performance analysis.
1009      */
1010     static class Counters {
1011         private static final boolean PUBLISH_COUNTERS;
1012         private static final boolean PRINT_COUNTERS;
1013         private static Map&lt;String, Long&gt; counters;
<span class="line-added">1014         private static long startTime;</span>
<span class="line-added">1015         private static long previousTime;</span>
<span class="line-added">1016 </span>
1017         static {
1018             String s = System.getProperty(&quot;jdk.module.boot.usePerfData&quot;);
1019             if (s == null) {
1020                 PUBLISH_COUNTERS = false;
1021                 PRINT_COUNTERS = false;
1022             } else {
1023                 PUBLISH_COUNTERS = true;
1024                 PRINT_COUNTERS = s.equals(&quot;debug&quot;);
1025                 counters = new LinkedHashMap&lt;&gt;();  // preserve insert order
1026             }
1027         }
1028 
1029         /**
<span class="line-modified">1030          * Start counting time.</span>
<span class="line-added">1031          */</span>
<span class="line-added">1032         static void start() {</span>
<span class="line-added">1033             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1034                 startTime = previousTime = System.nanoTime();</span>
<span class="line-added">1035             }</span>
<span class="line-added">1036         }</span>
<span class="line-added">1037 </span>
<span class="line-added">1038         /**</span>
<span class="line-added">1039          * Add a counter - storing the time difference between now and the</span>
<span class="line-added">1040          * previous add or the start.</span>
1041          */
<span class="line-modified">1042         static void add(String name) {</span>
<span class="line-modified">1043             if (PUBLISH_COUNTERS) {</span>
<span class="line-modified">1044                 long current = System.nanoTime();</span>
<span class="line-added">1045                 long elapsed = current - previousTime;</span>
<span class="line-added">1046                 previousTime = current;</span>
<span class="line-added">1047                 counters.put(name, elapsed);</span>
1048             }
1049         }
1050 
1051         /**
1052          * Publish the counters to the instrumentation buffer or stdout.
1053          */
<span class="line-modified">1054         static void publish(String totalTimeName) {</span>
<span class="line-modified">1055             if (PUBLISH_COUNTERS) {</span>
<span class="line-added">1056                 long currentTime = System.nanoTime();</span>
1057                 for (Map.Entry&lt;String, Long&gt; e : counters.entrySet()) {
1058                     String name = e.getKey();
1059                     long value = e.getValue();
<span class="line-modified">1060                     PerfCounter.newPerfCounter(name).set(value);</span>

1061                     if (PRINT_COUNTERS)
1062                         System.out.println(name + &quot; = &quot; + value);
1063                 }
<span class="line-added">1064                 long elapsedTotal = currentTime - startTime;</span>
<span class="line-added">1065                 PerfCounter.newPerfCounter(totalTimeName).set(elapsedTotal);</span>
<span class="line-added">1066                 if (PRINT_COUNTERS)</span>
<span class="line-added">1067                     System.out.println(totalTimeName + &quot; = &quot; + elapsedTotal);</span>
1068             }
1069         }
1070     }
1071 }
</pre>
</td>
</tr>
</table>
<center><a href="../misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../sun/security/provider/certpath/OCSPResponse.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>