<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
  36 import static jdk.internal.misc.UnsafeConstants.*;
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
  43  * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
  54  */
  55 
  56 public final class Unsafe {
  57 
  58     private static native void registerNatives();
  59     static {
  60         registerNatives();
  61     }
  62 
  63     private Unsafe() {}
  64 
  65     private static final Unsafe theUnsafe = new Unsafe();
  66 
  67     /**
  68      * Provides the caller with the capability of performing unsafe
  69      * operations.
  70      *
  71      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  72      * by the caller, since it can be used to read and write data at arbitrary
  73      * memory addresses.  It must never be passed to untrusted code.
  74      *
  75      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  76      * small number of hardware instructions (on typical machines).  Compilers
  77      * are encouraged to optimize these methods accordingly.
  78      *
  79      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  80      *
  81      * &lt;pre&gt; {@code
  82      * class MyTrustedClass {
  83      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  84      *   ...
  85      *   private long myCountAddress = ...;
  86      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  87      * }}&lt;/pre&gt;
  88      *
  89      * (It may assist compilers to make the local variable {@code final}.)
  90      */
  91     public static Unsafe getUnsafe() {
  92         return theUnsafe;
  93     }
  94 
  95     /// peek and poke operations
  96     /// (compilers should optimize these to memory ops)
  97 
  98     // These work on object fields in the Java heap.
  99     // They will not work on elements of packed arrays.
 100 
 101     /**
 102      * Fetches a value from a given Java variable.
 103      * More specifically, fetches a field or array element within the given
 104      * object {@code o} at the given offset, or (if {@code o} is null)
 105      * from the memory address whose numerical value is the given offset.
 106      * &lt;p&gt;
 107      * The results are undefined unless one of the following cases is true:
 108      * &lt;ul&gt;
 109      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 110      * the {@link java.lang.reflect.Field} of some Java field and the object
 111      * referred to by {@code o} is of a class compatible with that
 112      * field&#39;s class.
 113      *
 114      * &lt;li&gt;The offset and object reference {@code o} (either null or
 115      * non-null) were both obtained via {@link #staticFieldOffset}
 116      * and {@link #staticFieldBase} (respectively) from the
 117      * reflective {@link Field} representation of some Java field.
 118      *
 119      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 120      * is an integer of the form {@code B+N*S}, where {@code N} is
 121      * a valid index into the array, and {@code B} and {@code S} are
 122      * the values obtained by {@link #arrayBaseOffset} and {@link
 123      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 124      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 125      *
 126      * &lt;/ul&gt;
 127      * &lt;p&gt;
 128      * If one of the above cases is true, the call references a specific Java
 129      * variable (field or array element).  However, the results are undefined
 130      * if that variable is not in fact of the type returned by this method.
 131      * &lt;p&gt;
 132      * This method refers to a variable by means of two parameters, and so
 133      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 134      * for Java variables.  When the object reference is null, this method
 135      * uses its offset as an absolute address.  This is similar in operation
 136      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 137      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 138      * However, because Java variables may have a different layout in memory
 139      * from non-Java variables, programmers should not assume that these
 140      * two addressing modes are ever equivalent.  Also, programmers should
 141      * remember that offsets from the double-register addressing mode cannot
 142      * be portably confused with longs used in the single-register addressing
 143      * mode.
 144      *
 145      * @param o Java heap object in which the variable resides, if any, else
 146      *        null
 147      * @param offset indication of where the variable resides in a Java heap
 148      *        object, if any, else a memory address locating the variable
 149      *        statically
 150      * @return the value fetched from the indicated Java variable
 151      * @throws RuntimeException No defined exceptions are thrown, not even
 152      *         {@link NullPointerException}
 153      */
 154     @HotSpotIntrinsicCandidate
 155     public native int getInt(Object o, long offset);
 156 
 157     /**
 158      * Stores a value into a given Java variable.
 159      * &lt;p&gt;
 160      * The first two parameters are interpreted exactly as with
 161      * {@link #getInt(Object, long)} to refer to a specific
 162      * Java variable (field or array element).  The given value
 163      * is stored into that variable.
 164      * &lt;p&gt;
 165      * The variable must be of the same type as the method
 166      * parameter {@code x}.
 167      *
 168      * @param o Java heap object in which the variable resides, if any, else
 169      *        null
 170      * @param offset indication of where the variable resides in a Java heap
 171      *        object, if any, else a memory address locating the variable
 172      *        statically
 173      * @param x the value to store into the indicated Java variable
 174      * @throws RuntimeException No defined exceptions are thrown, not even
 175      *         {@link NullPointerException}
 176      */
 177     @HotSpotIntrinsicCandidate
 178     public native void putInt(Object o, long offset, int x);
 179 
 180     /**
 181      * Fetches a reference value from a given Java variable.
 182      * @see #getInt(Object, long)
 183      */
 184     @HotSpotIntrinsicCandidate
 185     public native Object getReference(Object o, long offset);
 186 
 187     /**
 188      * Stores a reference value into a given Java variable.
 189      * &lt;p&gt;
 190      * Unless the reference {@code x} being stored is either null
 191      * or matches the field type, the results are undefined.
 192      * If the reference {@code o} is non-null, card marks or
 193      * other store barriers for that object (if the VM requires them)
 194      * are updated.
 195      * @see #putInt(Object, long, int)
 196      */
 197     @HotSpotIntrinsicCandidate
 198     public native void putReference(Object o, long offset, Object x);
 199 
 200     /** @see #getInt(Object, long) */
 201     @HotSpotIntrinsicCandidate
 202     public native boolean getBoolean(Object o, long offset);
 203 
 204     /** @see #putInt(Object, long, int) */
 205     @HotSpotIntrinsicCandidate
 206     public native void    putBoolean(Object o, long offset, boolean x);
 207 
 208     /** @see #getInt(Object, long) */
 209     @HotSpotIntrinsicCandidate
 210     public native byte    getByte(Object o, long offset);
 211 
 212     /** @see #putInt(Object, long, int) */
 213     @HotSpotIntrinsicCandidate
 214     public native void    putByte(Object o, long offset, byte x);
 215 
 216     /** @see #getInt(Object, long) */
 217     @HotSpotIntrinsicCandidate
 218     public native short   getShort(Object o, long offset);
 219 
 220     /** @see #putInt(Object, long, int) */
 221     @HotSpotIntrinsicCandidate
 222     public native void    putShort(Object o, long offset, short x);
 223 
 224     /** @see #getInt(Object, long) */
 225     @HotSpotIntrinsicCandidate
 226     public native char    getChar(Object o, long offset);
 227 
 228     /** @see #putInt(Object, long, int) */
 229     @HotSpotIntrinsicCandidate
 230     public native void    putChar(Object o, long offset, char x);
 231 
 232     /** @see #getInt(Object, long) */
 233     @HotSpotIntrinsicCandidate
 234     public native long    getLong(Object o, long offset);
 235 
 236     /** @see #putInt(Object, long, int) */
 237     @HotSpotIntrinsicCandidate
 238     public native void    putLong(Object o, long offset, long x);
 239 
 240     /** @see #getInt(Object, long) */
 241     @HotSpotIntrinsicCandidate
 242     public native float   getFloat(Object o, long offset);
 243 
 244     /** @see #putInt(Object, long, int) */
 245     @HotSpotIntrinsicCandidate
 246     public native void    putFloat(Object o, long offset, float x);
 247 
 248     /** @see #getInt(Object, long) */
 249     @HotSpotIntrinsicCandidate
 250     public native double  getDouble(Object o, long offset);
 251 
 252     /** @see #putInt(Object, long, int) */
 253     @HotSpotIntrinsicCandidate
 254     public native void    putDouble(Object o, long offset, double x);
 255 
 256     /**
 257      * Fetches a native pointer from a given memory address.  If the address is
 258      * zero, or does not point into a block obtained from {@link
 259      * #allocateMemory}, the results are undefined.
 260      *
 261      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 262      * an unsigned number to a Java long.  The pointer may be indexed by any
 263      * given byte offset, simply by adding that offset (as a simple integer) to
 264      * the long representing the pointer.  The number of bytes actually read
 265      * from the target address may be determined by consulting {@link
 266      * #addressSize}.
 267      *
 268      * @see #allocateMemory
 269      * @see #getInt(Object, long)
 270      */
 271     @ForceInline
 272     public long getAddress(Object o, long offset) {
 273         if (ADDRESS_SIZE == 4) {
 274             return Integer.toUnsignedLong(getInt(o, offset));
 275         } else {
 276             return getLong(o, offset);
 277         }
 278     }
 279 
 280     /**
 281      * Stores a native pointer into a given memory address.  If the address is
 282      * zero, or does not point into a block obtained from {@link
 283      * #allocateMemory}, the results are undefined.
 284      *
 285      * &lt;p&gt;The number of bytes actually written at the target address may be
 286      * determined by consulting {@link #addressSize}.
 287      *
 288      * @see #allocateMemory
 289      * @see #putInt(Object, long, int)
 290      */
 291     @ForceInline
 292     public void putAddress(Object o, long offset, long x) {
 293         if (ADDRESS_SIZE == 4) {
 294             putInt(o, offset, (int)x);
 295         } else {
 296             putLong(o, offset, x);
 297         }
 298     }
 299 
 300     // These read VM internal data.
 301 
 302     /**
 303      * Fetches an uncompressed reference value from a given native variable
 304      * ignoring the VM&#39;s compressed references mode.
 305      *
 306      * @param address a memory address locating the variable
 307      * @return the value fetched from the indicated native variable
 308      */
 309     public native Object getUncompressedObject(long address);
 310 
 311     // These work on values in the C heap.
 312 
 313     /**
 314      * Fetches a value from a given memory address.  If the address is zero, or
 315      * does not point into a block obtained from {@link #allocateMemory}, the
 316      * results are undefined.
 317      *
 318      * @see #allocateMemory
 319      */
 320     @ForceInline
 321     public byte getByte(long address) {
 322         return getByte(null, address);
 323     }
 324 
 325     /**
 326      * Stores a value into a given memory address.  If the address is zero, or
 327      * does not point into a block obtained from {@link #allocateMemory}, the
 328      * results are undefined.
 329      *
 330      * @see #getByte(long)
 331      */
 332     @ForceInline
 333     public void putByte(long address, byte x) {
 334         putByte(null, address, x);
 335     }
 336 
 337     /** @see #getByte(long) */
 338     @ForceInline
 339     public short getShort(long address) {
 340         return getShort(null, address);
 341     }
 342 
 343     /** @see #putByte(long, byte) */
 344     @ForceInline
 345     public void putShort(long address, short x) {
 346         putShort(null, address, x);
 347     }
 348 
 349     /** @see #getByte(long) */
 350     @ForceInline
 351     public char getChar(long address) {
 352         return getChar(null, address);
 353     }
 354 
 355     /** @see #putByte(long, byte) */
 356     @ForceInline
 357     public void putChar(long address, char x) {
 358         putChar(null, address, x);
 359     }
 360 
 361     /** @see #getByte(long) */
 362     @ForceInline
 363     public int getInt(long address) {
 364         return getInt(null, address);
 365     }
 366 
 367     /** @see #putByte(long, byte) */
 368     @ForceInline
 369     public void putInt(long address, int x) {
 370         putInt(null, address, x);
 371     }
 372 
 373     /** @see #getByte(long) */
 374     @ForceInline
 375     public long getLong(long address) {
 376         return getLong(null, address);
 377     }
 378 
 379     /** @see #putByte(long, byte) */
 380     @ForceInline
 381     public void putLong(long address, long x) {
 382         putLong(null, address, x);
 383     }
 384 
 385     /** @see #getByte(long) */
 386     @ForceInline
 387     public float getFloat(long address) {
 388         return getFloat(null, address);
 389     }
 390 
 391     /** @see #putByte(long, byte) */
 392     @ForceInline
 393     public void putFloat(long address, float x) {
 394         putFloat(null, address, x);
 395     }
 396 
 397     /** @see #getByte(long) */
 398     @ForceInline
 399     public double getDouble(long address) {
 400         return getDouble(null, address);
 401     }
 402 
 403     /** @see #putByte(long, byte) */
 404     @ForceInline
 405     public void putDouble(long address, double x) {
 406         putDouble(null, address, x);
 407     }
 408 
 409     /** @see #getAddress(Object, long) */
 410     @ForceInline
 411     public long getAddress(long address) {
 412         return getAddress(null, address);
 413     }
 414 
 415     /** @see #putAddress(Object, long, long) */
 416     @ForceInline
 417     public void putAddress(long address, long x) {
 418         putAddress(null, address, x);
 419     }
 420 
 421 
 422 
 423     /// helper methods for validating various types of objects/values
 424 
 425     /**
 426      * Create an exception reflecting that some of the input was invalid
 427      *
 428      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 429      * sure arguments are checked before the methods are called. While
 430      * some rudimentary checks are performed on the input, the checks
 431      * are best effort and when performance is an overriding priority,
 432      * as when methods of this class are optimized by the runtime
 433      * compiler, some or all checks (if any) may be elided. Hence, the
 434      * caller must not rely on the checks and corresponding
 435      * exceptions!
 436      *
 437      * @return an exception object
 438      */
 439     private RuntimeException invalidInput() {
 440         return new IllegalArgumentException();
 441     }
 442 
 443     /**
 444      * Check if a value is 32-bit clean (32 MSB are all zero)
 445      *
 446      * @param value the 64-bit value to check
 447      *
 448      * @return true if the value is 32-bit clean
 449      */
 450     private boolean is32BitClean(long value) {
 451         return value &gt;&gt;&gt; 32 == 0;
 452     }
 453 
 454     /**
 455      * Check the validity of a size (the equivalent of a size_t)
 456      *
 457      * @throws RuntimeException if the size is invalid
 458      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 459      *         go undetected, which will lead to unpredictable
 460      *         behavior)
 461      */
 462     private void checkSize(long size) {
 463         if (ADDRESS_SIZE == 4) {
 464             // Note: this will also check for negative sizes
 465             if (!is32BitClean(size)) {
 466                 throw invalidInput();
 467             }
 468         } else if (size &lt; 0) {
 469             throw invalidInput();
 470         }
 471     }
 472 
 473     /**
 474      * Check the validity of a native address (the equivalent of void*)
 475      *
 476      * @throws RuntimeException if the address is invalid
 477      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 478      *         go undetected, which will lead to unpredictable
 479      *         behavior)
 480      */
 481     private void checkNativeAddress(long address) {
 482         if (ADDRESS_SIZE == 4) {
 483             // Accept both zero and sign extended pointers. A valid
 484             // pointer will, after the +1 below, either have produced
 485             // the value 0x0 or 0x1. Masking off the low bit allows
 486             // for testing against 0.
 487             if ((((address &gt;&gt; 32) + 1) &amp; ~1) != 0) {
 488                 throw invalidInput();
 489             }
 490         }
 491     }
 492 
 493     /**
 494      * Check the validity of an offset, relative to a base object
 495      *
 496      * @param o the base object
 497      * @param offset the offset to check
 498      *
 499      * @throws RuntimeException if the size is invalid
 500      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 501      *         go undetected, which will lead to unpredictable
 502      *         behavior)
 503      */
 504     private void checkOffset(Object o, long offset) {
 505         if (ADDRESS_SIZE == 4) {
 506             // Note: this will also check for negative offsets
 507             if (!is32BitClean(offset)) {
 508                 throw invalidInput();
 509             }
 510         } else if (offset &lt; 0) {
 511             throw invalidInput();
 512         }
 513     }
 514 
 515     /**
 516      * Check the validity of a double-register pointer
 517      *
 518      * Note: This code deliberately does *not* check for NPE for (at
 519      * least) three reasons:
 520      *
 521      * 1) NPE is not just NULL/0 - there is a range of values all
 522      * resulting in an NPE, which is not trivial to check for
 523      *
 524      * 2) It is the responsibility of the callers of Unsafe methods
 525      * to verify the input, so throwing an exception here is not really
 526      * useful - passing in a NULL pointer is a critical error and the
 527      * must not expect an exception to be thrown anyway.
 528      *
 529      * 3) the actual operations will detect NULL pointers anyway by
 530      * means of traps and signals (like SIGSEGV).
 531      *
 532      * @param o Java heap object, or null
 533      * @param offset indication of where the variable resides in a Java heap
 534      *        object, if any, else a memory address locating the variable
 535      *        statically
 536      *
 537      * @throws RuntimeException if the pointer is invalid
 538      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 539      *         go undetected, which will lead to unpredictable
 540      *         behavior)
 541      */
 542     private void checkPointer(Object o, long offset) {
 543         if (o == null) {
 544             checkNativeAddress(offset);
 545         } else {
 546             checkOffset(o, offset);
 547         }
 548     }
 549 
 550     /**
 551      * Check if a type is a primitive array type
 552      *
 553      * @param c the type to check
 554      *
 555      * @return true if the type is a primitive array type
 556      */
 557     private void checkPrimitiveArray(Class&lt;?&gt; c) {
 558         Class&lt;?&gt; componentType = c.getComponentType();
 559         if (componentType == null || !componentType.isPrimitive()) {
 560             throw invalidInput();
 561         }
 562     }
 563 
 564     /**
 565      * Check that a pointer is a valid primitive array type pointer
 566      *
 567      * Note: pointers off-heap are considered to be primitive arrays
 568      *
 569      * @throws RuntimeException if the pointer is invalid
 570      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 571      *         go undetected, which will lead to unpredictable
 572      *         behavior)
 573      */
 574     private void checkPrimitivePointer(Object o, long offset) {
 575         checkPointer(o, offset);
 576 
 577         if (o != null) {
 578             // If on heap, it must be a primitive array
 579             checkPrimitiveArray(o.getClass());
 580         }
 581     }
 582 
 583 
 584     /// wrappers for malloc, realloc, free:
 585 
<a name="2" id="anc2"></a>










 586     /**
 587      * Allocates a new block of native memory, of the given size in bytes.  The
 588      * contents of the memory are uninitialized; they will generally be
 589      * garbage.  The resulting native pointer will never be zero, and will be
 590      * aligned for all value types.  Dispose of this memory by calling {@link
 591      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 592      *
 593      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 594      * sure arguments are checked before the methods are called. While
 595      * some rudimentary checks are performed on the input, the checks
 596      * are best effort and when performance is an overriding priority,
 597      * as when methods of this class are optimized by the runtime
 598      * compiler, some or all checks (if any) may be elided. Hence, the
 599      * caller must not rely on the checks and corresponding
 600      * exceptions!
 601      *
 602      * @throws RuntimeException if the size is negative or too large
 603      *         for the native size_t type
 604      *
 605      * @throws OutOfMemoryError if the allocation is refused by the system
 606      *
 607      * @see #getByte(long)
 608      * @see #putByte(long, byte)
 609      */
 610     public long allocateMemory(long bytes) {
<a name="3" id="anc3"></a>

 611         allocateMemoryChecks(bytes);
 612 
 613         if (bytes == 0) {
 614             return 0;
 615         }
 616 
 617         long p = allocateMemory0(bytes);
 618         if (p == 0) {
 619             throw new OutOfMemoryError();
 620         }
 621 
 622         return p;
 623     }
 624 
 625     /**
 626      * Validate the arguments to allocateMemory
 627      *
 628      * @throws RuntimeException if the arguments are invalid
 629      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 630      *         go undetected, which will lead to unpredictable
 631      *         behavior)
 632      */
 633     private void allocateMemoryChecks(long bytes) {
 634         checkSize(bytes);
 635     }
 636 
 637     /**
 638      * Resizes a new block of native memory, to the given size in bytes.  The
 639      * contents of the new block past the size of the old block are
 640      * uninitialized; they will generally be garbage.  The resulting native
 641      * pointer will be zero if and only if the requested size is zero.  The
 642      * resulting native pointer will be aligned for all value types.  Dispose
 643      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 644      * #reallocateMemory}.  The address passed to this method may be null, in
 645      * which case an allocation will be performed.
 646      *
 647      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 648      * sure arguments are checked before the methods are called. While
 649      * some rudimentary checks are performed on the input, the checks
 650      * are best effort and when performance is an overriding priority,
 651      * as when methods of this class are optimized by the runtime
 652      * compiler, some or all checks (if any) may be elided. Hence, the
 653      * caller must not rely on the checks and corresponding
 654      * exceptions!
 655      *
 656      * @throws RuntimeException if the size is negative or too large
 657      *         for the native size_t type
 658      *
 659      * @throws OutOfMemoryError if the allocation is refused by the system
 660      *
 661      * @see #allocateMemory
 662      */
 663     public long reallocateMemory(long address, long bytes) {
<a name="4" id="anc4"></a>

 664         reallocateMemoryChecks(address, bytes);
 665 
 666         if (bytes == 0) {
 667             freeMemory(address);
 668             return 0;
 669         }
 670 
 671         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 672         if (p == 0) {
 673             throw new OutOfMemoryError();
 674         }
 675 
 676         return p;
 677     }
 678 
 679     /**
 680      * Validate the arguments to reallocateMemory
 681      *
 682      * @throws RuntimeException if the arguments are invalid
 683      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 684      *         go undetected, which will lead to unpredictable
 685      *         behavior)
 686      */
 687     private void reallocateMemoryChecks(long address, long bytes) {
 688         checkPointer(null, address);
 689         checkSize(bytes);
 690     }
 691 
 692     /**
 693      * Sets all bytes in a given block of memory to a fixed value
 694      * (usually zero).
 695      *
 696      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 697      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 698      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 699      * the offset supplies an absolute base address.
 700      *
 701      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 702      * by the address and length parameters.  If the effective address and
 703      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 704      * If the effective address and length are (resp.) even modulo 4 or 2,
 705      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 706      *
 707      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 708      * sure arguments are checked before the methods are called. While
 709      * some rudimentary checks are performed on the input, the checks
 710      * are best effort and when performance is an overriding priority,
 711      * as when methods of this class are optimized by the runtime
 712      * compiler, some or all checks (if any) may be elided. Hence, the
 713      * caller must not rely on the checks and corresponding
 714      * exceptions!
 715      *
 716      * @throws RuntimeException if any of the arguments is invalid
 717      *
 718      * @since 1.7
 719      */
 720     public void setMemory(Object o, long offset, long bytes, byte value) {
 721         setMemoryChecks(o, offset, bytes, value);
 722 
 723         if (bytes == 0) {
 724             return;
 725         }
 726 
 727         setMemory0(o, offset, bytes, value);
 728     }
 729 
 730     /**
 731      * Sets all bytes in a given block of memory to a fixed value
 732      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 733      * as discussed in {@link #getInt(Object,long)}.
 734      *
 735      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 736      */
 737     public void setMemory(long address, long bytes, byte value) {
 738         setMemory(null, address, bytes, value);
 739     }
 740 
 741     /**
 742      * Validate the arguments to setMemory
 743      *
 744      * @throws RuntimeException if the arguments are invalid
 745      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 746      *         go undetected, which will lead to unpredictable
 747      *         behavior)
 748      */
 749     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 750         checkPrimitivePointer(o, offset);
 751         checkSize(bytes);
 752     }
 753 
 754     /**
 755      * Sets all bytes in a given block of memory to a copy of another
 756      * block.
 757      *
 758      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 759      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 760      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 761      * the offset supplies an absolute base address.
 762      *
 763      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 764      * by the address and length parameters.  If the effective addresses and
 765      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 766      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 767      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 768      *
 769      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 770      * sure arguments are checked before the methods are called. While
 771      * some rudimentary checks are performed on the input, the checks
 772      * are best effort and when performance is an overriding priority,
 773      * as when methods of this class are optimized by the runtime
 774      * compiler, some or all checks (if any) may be elided. Hence, the
 775      * caller must not rely on the checks and corresponding
 776      * exceptions!
 777      *
 778      * @throws RuntimeException if any of the arguments is invalid
 779      *
 780      * @since 1.7
 781      */
 782     public void copyMemory(Object srcBase, long srcOffset,
 783                            Object destBase, long destOffset,
 784                            long bytes) {
 785         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 786 
 787         if (bytes == 0) {
 788             return;
 789         }
 790 
 791         copyMemory0(srcBase, srcOffset, destBase, destOffset, bytes);
 792     }
 793 
 794     /**
 795      * Sets all bytes in a given block of memory to a copy of another
 796      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 797      * as discussed in {@link #getInt(Object,long)}.
 798      *
 799      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 800      */
 801     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 802         copyMemory(null, srcAddress, null, destAddress, bytes);
 803     }
 804 
 805     /**
 806      * Validate the arguments to copyMemory
 807      *
 808      * @throws RuntimeException if any of the arguments is invalid
 809      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 810      *         go undetected, which will lead to unpredictable
 811      *         behavior)
 812      */
 813     private void copyMemoryChecks(Object srcBase, long srcOffset,
 814                                   Object destBase, long destOffset,
 815                                   long bytes) {
 816         checkSize(bytes);
 817         checkPrimitivePointer(srcBase, srcOffset);
 818         checkPrimitivePointer(destBase, destOffset);
 819     }
 820 
 821     /**
 822      * Copies all elements from one block of memory to another block,
 823      * *unconditionally* byte swapping the elements on the fly.
 824      *
 825      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 826      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 827      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 828      * the offset supplies an absolute base address.
 829      *
 830      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 831      * sure arguments are checked before the methods are called. While
 832      * some rudimentary checks are performed on the input, the checks
 833      * are best effort and when performance is an overriding priority,
 834      * as when methods of this class are optimized by the runtime
 835      * compiler, some or all checks (if any) may be elided. Hence, the
 836      * caller must not rely on the checks and corresponding
 837      * exceptions!
 838      *
 839      * @throws RuntimeException if any of the arguments is invalid
 840      *
 841      * @since 9
 842      */
 843     public void copySwapMemory(Object srcBase, long srcOffset,
 844                                Object destBase, long destOffset,
 845                                long bytes, long elemSize) {
 846         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 847 
 848         if (bytes == 0) {
 849             return;
 850         }
 851 
 852         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 853     }
 854 
 855     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 856                                       Object destBase, long destOffset,
 857                                       long bytes, long elemSize) {
 858         checkSize(bytes);
 859 
 860         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 861             throw invalidInput();
 862         }
 863         if (bytes % elemSize != 0) {
 864             throw invalidInput();
 865         }
 866 
 867         checkPrimitivePointer(srcBase, srcOffset);
 868         checkPrimitivePointer(destBase, destOffset);
 869     }
 870 
 871    /**
 872      * Copies all elements from one block of memory to another block, byte swapping the
 873      * elements on the fly.
 874      *
 875      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
 876      * discussed in {@link #getInt(Object,long)}.
 877      *
 878      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
 879      */
 880     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
 881         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
 882     }
 883 
 884     /**
 885      * Disposes of a block of native memory, as obtained from {@link
 886      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
 887      * this method may be null, in which case no action is taken.
 888      *
 889      * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make
 890      * sure arguments are checked before the methods are called. While
 891      * some rudimentary checks are performed on the input, the checks
 892      * are best effort and when performance is an overriding priority,
 893      * as when methods of this class are optimized by the runtime
 894      * compiler, some or all checks (if any) may be elided. Hence, the
 895      * caller must not rely on the checks and corresponding
 896      * exceptions!
 897      *
 898      * @throws RuntimeException if any of the arguments is invalid
 899      *
 900      * @see #allocateMemory
 901      */
 902     public void freeMemory(long address) {
 903         freeMemoryChecks(address);
 904 
 905         if (address == 0) {
 906             return;
 907         }
 908 
 909         freeMemory0(address);
 910     }
 911 
 912     /**
 913      * Validate the arguments to freeMemory
 914      *
 915      * @throws RuntimeException if the arguments are invalid
 916      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 917      *         go undetected, which will lead to unpredictable
 918      *         behavior)
 919      */
 920     private void freeMemoryChecks(long address) {
 921         checkPointer(null, address);
 922     }
 923 
 924     /**
 925      * Ensure writeback of a specified virtual memory address range
 926      * from cache to physical memory. All bytes in the address range
 927      * are guaranteed to have been written back to physical memory on
 928      * return from this call i.e. subsequently executed store
 929      * instructions are guaranteed not to be visible before the
 930      * writeback is completed.
 931      *
 932      * @param address
 933      *        the lowest byte address that must be guaranteed written
 934      *        back to memory. bytes at lower addresses may also be
 935      *        written back.
 936      *
 937      * @param length
 938      *        the length in bytes of the region starting at address
 939      *        that must be guaranteed written back to memory.
 940      *
 941      * @throws RuntimeException if memory writeback is not supported
 942      *         on the current hardware of if the arguments are invalid.
 943      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 944      *         go undetected, which will lead to unpredictable
 945      *         behavior)
 946      *
 947      * @since 14
 948      */
 949 
 950     public void writebackMemory(long address, long length) {
 951         checkWritebackEnabled();
 952         checkWritebackMemory(address, length);
 953 
 954         // perform any required pre-writeback barrier
 955         writebackPreSync0();
 956 
 957         // write back one cache line at a time
 958         long line = dataCacheLineAlignDown(address);
 959         long end = address + length;
 960         while (line &lt; end) {
 961             writeback0(line);
 962             line += dataCacheLineFlushSize();
 963         }
 964 
 965         // perform any required post-writeback barrier
 966         writebackPostSync0();
 967     }
 968 
 969     /**
 970      * Validate the arguments to writebackMemory
 971      *
 972      * @throws RuntimeException if the arguments are invalid
 973      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 974      *         go undetected, which will lead to unpredictable
 975      *         behavior)
 976      */
 977     private void checkWritebackMemory(long address, long length) {
 978         checkNativeAddress(address);
 979         checkSize(length);
 980     }
 981 
 982     /**
 983      * Validate that the current hardware supports memory writeback.
 984      * (&lt;em&gt;Note:&lt;/em&gt; this is a belt and braces check.  Clients are
 985      * expected to test whether writeback is enabled by calling
 986      * ({@link isWritebackEnabled #isWritebackEnabled} and avoid
 987      * calling method {@link writeback #writeback} if it is disabled).
 988      *
 989      *
 990      * @throws RuntimeException if memory writeback is not supported
 991      */
 992     private void checkWritebackEnabled() {
 993         if (!isWritebackEnabled()) {
 994             throw new RuntimeException(&quot;writebackMemory not enabled!&quot;);
 995         }
 996     }
 997 
 998     /**
 999      * force writeback of an individual cache line.
1000      *
1001      * @param address
1002      *        the start address of the cache line to be written back
1003      */
1004     @HotSpotIntrinsicCandidate
1005     private native void writeback0(long address);
1006 
1007      /**
1008       * Serialize writeback operations relative to preceding memory writes.
1009       */
1010     @HotSpotIntrinsicCandidate
1011     private native void writebackPreSync0();
1012 
1013      /**
1014       * Serialize writeback operations relative to following memory writes.
1015       */
1016     @HotSpotIntrinsicCandidate
1017     private native void writebackPostSync0();
1018 
1019     /// random queries
1020 
1021     /**
1022      * This constant differs from all results that will ever be returned from
1023      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
1024      * or {@link #arrayBaseOffset}.
1025      */
1026     public static final int INVALID_FIELD_OFFSET = -1;
1027 
1028     /**
1029      * Reports the location of a given field in the storage allocation of its
1030      * class.  Do not expect to perform any sort of arithmetic on this offset;
1031      * it is just a cookie which is passed to the unsafe heap memory accessors.
1032      *
1033      * &lt;p&gt;Any given field will always have the same offset and base, and no
1034      * two distinct fields of the same class will ever have the same offset
1035      * and base.
1036      *
1037      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1038      * although the Sun JVM does not use the most significant 32 bits.
1039      * However, JVM implementations which store static fields at absolute
1040      * addresses can use long offsets and null base pointers to express
1041      * the field locations in a form usable by {@link #getInt(Object,long)}.
1042      * Therefore, code which will be ported to such JVMs on 64-bit platforms
1043      * must preserve all bits of static field offsets.
1044      * @see #getInt(Object, long)
1045      */
1046     public long objectFieldOffset(Field f) {
1047         if (f == null) {
1048             throw new NullPointerException();
1049         }
1050 
1051         return objectFieldOffset0(f);
1052     }
1053 
1054     /**
1055      * Reports the location of the field with a given name in the storage
1056      * allocation of its class.
1057      *
1058      * @throws NullPointerException if any parameter is {@code null}.
1059      * @throws InternalError if there is no field named {@code name} declared
1060      *         in class {@code c}, i.e., if {@code c.getDeclaredField(name)}
1061      *         would throw {@code java.lang.NoSuchFieldException}.
1062      *
1063      * @see #objectFieldOffset(Field)
1064      */
1065     public long objectFieldOffset(Class&lt;?&gt; c, String name) {
1066         if (c == null || name == null) {
1067             throw new NullPointerException();
1068         }
1069 
1070         return objectFieldOffset1(c, name);
1071     }
1072 
1073     /**
1074      * Reports the location of a given static field, in conjunction with {@link
1075      * #staticFieldBase}.
1076      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
1077      * it is just a cookie which is passed to the unsafe heap memory accessors.
1078      *
1079      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
1080      * fields of the same class will ever have the same offset.
1081      *
1082      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1083      * although the Sun JVM does not use the most significant 32 bits.
1084      * It is hard to imagine a JVM technology which needs more than
1085      * a few bits to encode an offset within a non-array object,
1086      * However, for consistency with other methods in this class,
1087      * this method reports its result as a long value.
1088      * @see #getInt(Object, long)
1089      */
1090     public long staticFieldOffset(Field f) {
1091         if (f == null) {
1092             throw new NullPointerException();
1093         }
1094 
1095         return staticFieldOffset0(f);
1096     }
1097 
1098     /**
1099      * Reports the location of a given static field, in conjunction with {@link
1100      * #staticFieldOffset}.
1101      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
1102      * given class can be accessed via methods like {@link #getInt(Object,
1103      * long)}.  This value may be null.  This value may refer to an object
1104      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
1105      * not be used in any way except as argument to the get and put routines in
1106      * this class.
1107      */
1108     public Object staticFieldBase(Field f) {
1109         if (f == null) {
1110             throw new NullPointerException();
1111         }
1112 
1113         return staticFieldBase0(f);
1114     }
1115 
1116     /**
1117      * Detects if the given class may need to be initialized. This is often
1118      * needed in conjunction with obtaining the static field base of a
1119      * class.
1120      * @return false only if a call to {@code ensureClassInitialized} would have no effect
1121      */
1122     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
1123         if (c == null) {
1124             throw new NullPointerException();
1125         }
1126 
1127         return shouldBeInitialized0(c);
1128     }
1129 
1130     /**
1131      * Ensures the given class has been initialized. This is often
1132      * needed in conjunction with obtaining the static field base of a
1133      * class.
1134      */
1135     public void ensureClassInitialized(Class&lt;?&gt; c) {
1136         if (c == null) {
1137             throw new NullPointerException();
1138         }
1139 
1140         ensureClassInitialized0(c);
1141     }
1142 
1143     /**
1144      * Reports the offset of the first element in the storage allocation of a
1145      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
1146      * for the same class, you may use that scale factor, together with this
1147      * base offset, to form new offsets to access elements of arrays of the
1148      * given class.
1149      *
1150      * @see #getInt(Object, long)
1151      * @see #putInt(Object, long, int)
1152      */
1153     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
1154         if (arrayClass == null) {
1155             throw new NullPointerException();
1156         }
1157 
1158         return arrayBaseOffset0(arrayClass);
1159     }
1160 
1161 
1162     /** The value of {@code arrayBaseOffset(boolean[].class)} */
1163     public static final int ARRAY_BOOLEAN_BASE_OFFSET
1164             = theUnsafe.arrayBaseOffset(boolean[].class);
1165 
1166     /** The value of {@code arrayBaseOffset(byte[].class)} */
1167     public static final int ARRAY_BYTE_BASE_OFFSET
1168             = theUnsafe.arrayBaseOffset(byte[].class);
1169 
1170     /** The value of {@code arrayBaseOffset(short[].class)} */
1171     public static final int ARRAY_SHORT_BASE_OFFSET
1172             = theUnsafe.arrayBaseOffset(short[].class);
1173 
1174     /** The value of {@code arrayBaseOffset(char[].class)} */
1175     public static final int ARRAY_CHAR_BASE_OFFSET
1176             = theUnsafe.arrayBaseOffset(char[].class);
1177 
1178     /** The value of {@code arrayBaseOffset(int[].class)} */
1179     public static final int ARRAY_INT_BASE_OFFSET
1180             = theUnsafe.arrayBaseOffset(int[].class);
1181 
1182     /** The value of {@code arrayBaseOffset(long[].class)} */
1183     public static final int ARRAY_LONG_BASE_OFFSET
1184             = theUnsafe.arrayBaseOffset(long[].class);
1185 
1186     /** The value of {@code arrayBaseOffset(float[].class)} */
1187     public static final int ARRAY_FLOAT_BASE_OFFSET
1188             = theUnsafe.arrayBaseOffset(float[].class);
1189 
1190     /** The value of {@code arrayBaseOffset(double[].class)} */
1191     public static final int ARRAY_DOUBLE_BASE_OFFSET
1192             = theUnsafe.arrayBaseOffset(double[].class);
1193 
1194     /** The value of {@code arrayBaseOffset(Object[].class)} */
1195     public static final int ARRAY_OBJECT_BASE_OFFSET
1196             = theUnsafe.arrayBaseOffset(Object[].class);
1197 
1198     /**
1199      * Reports the scale factor for addressing elements in the storage
1200      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1201      * will generally not work properly with accessors like {@link
1202      * #getByte(Object, long)}, so the scale factor for such classes is reported
1203      * as zero.
1204      *
1205      * @see #arrayBaseOffset
1206      * @see #getInt(Object, long)
1207      * @see #putInt(Object, long, int)
1208      */
1209     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1210         if (arrayClass == null) {
1211             throw new NullPointerException();
1212         }
1213 
1214         return arrayIndexScale0(arrayClass);
1215     }
1216 
1217 
1218     /** The value of {@code arrayIndexScale(boolean[].class)} */
1219     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1220             = theUnsafe.arrayIndexScale(boolean[].class);
1221 
1222     /** The value of {@code arrayIndexScale(byte[].class)} */
1223     public static final int ARRAY_BYTE_INDEX_SCALE
1224             = theUnsafe.arrayIndexScale(byte[].class);
1225 
1226     /** The value of {@code arrayIndexScale(short[].class)} */
1227     public static final int ARRAY_SHORT_INDEX_SCALE
1228             = theUnsafe.arrayIndexScale(short[].class);
1229 
1230     /** The value of {@code arrayIndexScale(char[].class)} */
1231     public static final int ARRAY_CHAR_INDEX_SCALE
1232             = theUnsafe.arrayIndexScale(char[].class);
1233 
1234     /** The value of {@code arrayIndexScale(int[].class)} */
1235     public static final int ARRAY_INT_INDEX_SCALE
1236             = theUnsafe.arrayIndexScale(int[].class);
1237 
1238     /** The value of {@code arrayIndexScale(long[].class)} */
1239     public static final int ARRAY_LONG_INDEX_SCALE
1240             = theUnsafe.arrayIndexScale(long[].class);
1241 
1242     /** The value of {@code arrayIndexScale(float[].class)} */
1243     public static final int ARRAY_FLOAT_INDEX_SCALE
1244             = theUnsafe.arrayIndexScale(float[].class);
1245 
1246     /** The value of {@code arrayIndexScale(double[].class)} */
1247     public static final int ARRAY_DOUBLE_INDEX_SCALE
1248             = theUnsafe.arrayIndexScale(double[].class);
1249 
1250     /** The value of {@code arrayIndexScale(Object[].class)} */
1251     public static final int ARRAY_OBJECT_INDEX_SCALE
1252             = theUnsafe.arrayIndexScale(Object[].class);
1253 
1254     /**
1255      * Reports the size in bytes of a native pointer, as stored via {@link
1256      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1257      * other primitive types (as stored in native memory blocks) is determined
1258      * fully by their information content.
1259      */
1260     public int addressSize() {
1261         return ADDRESS_SIZE;
1262     }
1263 
1264     /** The value of {@code addressSize()} */
1265     public static final int ADDRESS_SIZE = ADDRESS_SIZE0;
1266 
1267     /**
1268      * Reports the size in bytes of a native memory page (whatever that is).
1269      * This value will always be a power of two.
1270      */
1271     public int pageSize() { return PAGE_SIZE; }
1272 
1273     /**
1274      * Reports the size in bytes of a data cache line written back by
1275      * the hardware cache line flush operation available to the JVM or
1276      * 0 if data cache line flushing is not enabled.
1277      */
1278     public int dataCacheLineFlushSize() { return DATA_CACHE_LINE_FLUSH_SIZE; }
1279 
1280     /**
1281      * Rounds down address to a data cache line boundary as
1282      * determined by {@link #dataCacheLineFlushSize}
1283      * @return the rounded down address
1284      */
1285     public long dataCacheLineAlignDown(long address) {
1286         return (address &amp; ~(DATA_CACHE_LINE_FLUSH_SIZE - 1));
1287     }
1288 
1289     /**
1290      * Returns true if data cache line writeback
1291      */
1292     public static boolean isWritebackEnabled() { return DATA_CACHE_LINE_FLUSH_SIZE != 0; }
1293 
1294     /// random trusted operations from JNI:
1295 
1296     /**
1297      * Tells the VM to define a class, without security checks.  By default, the
1298      * class loader and protection domain come from the caller&#39;s class.
1299      */
1300     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1301                                 ClassLoader loader,
1302                                 ProtectionDomain protectionDomain) {
1303         if (b == null) {
1304             throw new NullPointerException();
1305         }
1306         if (len &lt; 0) {
1307             throw new ArrayIndexOutOfBoundsException();
1308         }
1309 
1310         return defineClass0(name, b, off, len, loader, protectionDomain);
1311     }
1312 
1313     public native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
1314                                         ClassLoader loader,
1315                                         ProtectionDomain protectionDomain);
1316 
1317     /**
1318      * Defines a class but does not make it known to the class loader or system dictionary.
1319      * &lt;p&gt;
1320      * For each CP entry, the corresponding CP patch must either be null or have
1321      * the a format that matches its tag:
1322      * &lt;ul&gt;
1323      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
1324      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
1325      * &lt;li&gt;Class: any java.lang.Class object
1326      * &lt;li&gt;String: any object (not just a java.lang.String)
1327      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
1328      * &lt;/ul&gt;
1329      * @param hostClass context for linkage, access control, protection domain, and class loader
1330      * @param data      bytes of a class file
1331      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
1332      */
1333     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
1334         if (hostClass == null || data == null) {
1335             throw new NullPointerException();
1336         }
1337         if (hostClass.isArray() || hostClass.isPrimitive()) {
1338             throw new IllegalArgumentException();
1339         }
1340 
1341         return defineAnonymousClass0(hostClass, data, cpPatches);
1342     }
1343 
1344     /**
1345      * Allocates an instance but does not run any constructor.
1346      * Initializes the class if it has not yet been.
1347      */
1348     @HotSpotIntrinsicCandidate
1349     public native Object allocateInstance(Class&lt;?&gt; cls)
1350         throws InstantiationException;
1351 
1352     /**
1353      * Allocates an array of a given type, but does not do zeroing.
1354      * &lt;p&gt;
1355      * This method should only be used in the very rare cases where a high-performance code
1356      * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.
1357      * In an overwhelming majority of cases, a normal Java allocation should be used instead.
1358      * &lt;p&gt;
1359      * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents
1360      * before allowing untrusted code, or code in other threads, to observe the reference
1361      * to the newly allocated array. In addition, the publication of the array reference must be
1362      * safe according to the Java Memory Model requirements.
1363      * &lt;p&gt;
1364      * The safest approach to deal with an uninitialized array is to keep the reference to it in local
1365      * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either
1366      * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,
1367      * or issuing a {@link #storeFence} before publishing the reference.
1368      * &lt;p&gt;
1369      * @implnote This method can only allocate primitive arrays, to avoid garbage reference
1370      * elements that could break heap integrity.
1371      *
1372      * @param componentType array component type to allocate
1373      * @param length array size to allocate
1374      * @throws IllegalArgumentException if component type is null, or not a primitive class;
1375      *                                  or the length is negative
1376      */
1377     public Object allocateUninitializedArray(Class&lt;?&gt; componentType, int length) {
1378        if (componentType == null) {
1379            throw new IllegalArgumentException(&quot;Component type is null&quot;);
1380        }
1381        if (!componentType.isPrimitive()) {
1382            throw new IllegalArgumentException(&quot;Component type is not primitive&quot;);
1383        }
1384        if (length &lt; 0) {
1385            throw new IllegalArgumentException(&quot;Negative length&quot;);
1386        }
1387        return allocateUninitializedArray0(componentType, length);
1388     }
1389 
1390     @HotSpotIntrinsicCandidate
1391     private Object allocateUninitializedArray0(Class&lt;?&gt; componentType, int length) {
1392        // These fallbacks provide zeroed arrays, but intrinsic is not required to
1393        // return the zeroed arrays.
1394        if (componentType == byte.class)    return new byte[length];
1395        if (componentType == boolean.class) return new boolean[length];
1396        if (componentType == short.class)   return new short[length];
1397        if (componentType == char.class)    return new char[length];
1398        if (componentType == int.class)     return new int[length];
1399        if (componentType == float.class)   return new float[length];
1400        if (componentType == long.class)    return new long[length];
1401        if (componentType == double.class)  return new double[length];
1402        return null;
1403     }
1404 
1405     /** Throws the exception without telling the verifier. */
1406     public native void throwException(Throwable ee);
1407 
1408     /**
1409      * Atomically updates Java variable to {@code x} if it is currently
1410      * holding {@code expected}.
1411      *
1412      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1413      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1414      *
1415      * @return {@code true} if successful
1416      */
1417     @HotSpotIntrinsicCandidate
1418     public final native boolean compareAndSetReference(Object o, long offset,
1419                                                        Object expected,
1420                                                        Object x);
1421 
1422     @HotSpotIntrinsicCandidate
1423     public final native Object compareAndExchangeReference(Object o, long offset,
1424                                                            Object expected,
1425                                                            Object x);
1426 
1427     @HotSpotIntrinsicCandidate
1428     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1429                                                            Object expected,
1430                                                            Object x) {
1431         return compareAndExchangeReference(o, offset, expected, x);
1432     }
1433 
1434     @HotSpotIntrinsicCandidate
1435     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1436                                                            Object expected,
1437                                                            Object x) {
1438         return compareAndExchangeReference(o, offset, expected, x);
1439     }
1440 
1441     @HotSpotIntrinsicCandidate
1442     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1443                                                          Object expected,
1444                                                          Object x) {
1445         return compareAndSetReference(o, offset, expected, x);
1446     }
1447 
1448     @HotSpotIntrinsicCandidate
1449     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1450                                                            Object expected,
1451                                                            Object x) {
1452         return compareAndSetReference(o, offset, expected, x);
1453     }
1454 
1455     @HotSpotIntrinsicCandidate
1456     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1457                                                            Object expected,
1458                                                            Object x) {
1459         return compareAndSetReference(o, offset, expected, x);
1460     }
1461 
1462     @HotSpotIntrinsicCandidate
1463     public final boolean weakCompareAndSetReference(Object o, long offset,
1464                                                     Object expected,
1465                                                     Object x) {
1466         return compareAndSetReference(o, offset, expected, x);
1467     }
1468 
1469     /**
1470      * Atomically updates Java variable to {@code x} if it is currently
1471      * holding {@code expected}.
1472      *
1473      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1474      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1475      *
1476      * @return {@code true} if successful
1477      */
1478     @HotSpotIntrinsicCandidate
1479     public final native boolean compareAndSetInt(Object o, long offset,
1480                                                  int expected,
1481                                                  int x);
1482 
1483     @HotSpotIntrinsicCandidate
1484     public final native int compareAndExchangeInt(Object o, long offset,
1485                                                   int expected,
1486                                                   int x);
1487 
1488     @HotSpotIntrinsicCandidate
1489     public final int compareAndExchangeIntAcquire(Object o, long offset,
1490                                                          int expected,
1491                                                          int x) {
1492         return compareAndExchangeInt(o, offset, expected, x);
1493     }
1494 
1495     @HotSpotIntrinsicCandidate
1496     public final int compareAndExchangeIntRelease(Object o, long offset,
1497                                                          int expected,
1498                                                          int x) {
1499         return compareAndExchangeInt(o, offset, expected, x);
1500     }
1501 
1502     @HotSpotIntrinsicCandidate
1503     public final boolean weakCompareAndSetIntPlain(Object o, long offset,
1504                                                    int expected,
1505                                                    int x) {
1506         return compareAndSetInt(o, offset, expected, x);
1507     }
1508 
1509     @HotSpotIntrinsicCandidate
1510     public final boolean weakCompareAndSetIntAcquire(Object o, long offset,
1511                                                      int expected,
1512                                                      int x) {
1513         return compareAndSetInt(o, offset, expected, x);
1514     }
1515 
1516     @HotSpotIntrinsicCandidate
1517     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1518                                                      int expected,
1519                                                      int x) {
1520         return compareAndSetInt(o, offset, expected, x);
1521     }
1522 
1523     @HotSpotIntrinsicCandidate
1524     public final boolean weakCompareAndSetInt(Object o, long offset,
1525                                               int expected,
1526                                               int x) {
1527         return compareAndSetInt(o, offset, expected, x);
1528     }
1529 
1530     @HotSpotIntrinsicCandidate
1531     public final byte compareAndExchangeByte(Object o, long offset,
1532                                              byte expected,
1533                                              byte x) {
1534         long wordOffset = offset &amp; ~3;
1535         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1536         if (BIG_ENDIAN) {
1537             shift = 24 - shift;
1538         }
1539         int mask           = 0xFF &lt;&lt; shift;
1540         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1541         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1542         int fullWord;
1543         do {
1544             fullWord = getIntVolatile(o, wordOffset);
1545             if ((fullWord &amp; mask) != maskedExpected)
1546                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1547         } while (!weakCompareAndSetInt(o, wordOffset,
1548                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1549         return expected;
1550     }
1551 
1552     @HotSpotIntrinsicCandidate
1553     public final boolean compareAndSetByte(Object o, long offset,
1554                                            byte expected,
1555                                            byte x) {
1556         return compareAndExchangeByte(o, offset, expected, x) == expected;
1557     }
1558 
1559     @HotSpotIntrinsicCandidate
1560     public final boolean weakCompareAndSetByte(Object o, long offset,
1561                                                byte expected,
1562                                                byte x) {
1563         return compareAndSetByte(o, offset, expected, x);
1564     }
1565 
1566     @HotSpotIntrinsicCandidate
1567     public final boolean weakCompareAndSetByteAcquire(Object o, long offset,
1568                                                       byte expected,
1569                                                       byte x) {
1570         return weakCompareAndSetByte(o, offset, expected, x);
1571     }
1572 
1573     @HotSpotIntrinsicCandidate
1574     public final boolean weakCompareAndSetByteRelease(Object o, long offset,
1575                                                       byte expected,
1576                                                       byte x) {
1577         return weakCompareAndSetByte(o, offset, expected, x);
1578     }
1579 
1580     @HotSpotIntrinsicCandidate
1581     public final boolean weakCompareAndSetBytePlain(Object o, long offset,
1582                                                     byte expected,
1583                                                     byte x) {
1584         return weakCompareAndSetByte(o, offset, expected, x);
1585     }
1586 
1587     @HotSpotIntrinsicCandidate
1588     public final byte compareAndExchangeByteAcquire(Object o, long offset,
1589                                                     byte expected,
1590                                                     byte x) {
1591         return compareAndExchangeByte(o, offset, expected, x);
1592     }
1593 
1594     @HotSpotIntrinsicCandidate
1595     public final byte compareAndExchangeByteRelease(Object o, long offset,
1596                                                     byte expected,
1597                                                     byte x) {
1598         return compareAndExchangeByte(o, offset, expected, x);
1599     }
1600 
1601     @HotSpotIntrinsicCandidate
1602     public final short compareAndExchangeShort(Object o, long offset,
1603                                                short expected,
1604                                                short x) {
1605         if ((offset &amp; 3) == 3) {
1606             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1607         }
1608         long wordOffset = offset &amp; ~3;
1609         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1610         if (BIG_ENDIAN) {
1611             shift = 16 - shift;
1612         }
1613         int mask           = 0xFFFF &lt;&lt; shift;
1614         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1615         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1616         int fullWord;
1617         do {
1618             fullWord = getIntVolatile(o, wordOffset);
1619             if ((fullWord &amp; mask) != maskedExpected) {
1620                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1621             }
1622         } while (!weakCompareAndSetInt(o, wordOffset,
1623                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1624         return expected;
1625     }
1626 
1627     @HotSpotIntrinsicCandidate
1628     public final boolean compareAndSetShort(Object o, long offset,
1629                                             short expected,
1630                                             short x) {
1631         return compareAndExchangeShort(o, offset, expected, x) == expected;
1632     }
1633 
1634     @HotSpotIntrinsicCandidate
1635     public final boolean weakCompareAndSetShort(Object o, long offset,
1636                                                 short expected,
1637                                                 short x) {
1638         return compareAndSetShort(o, offset, expected, x);
1639     }
1640 
1641     @HotSpotIntrinsicCandidate
1642     public final boolean weakCompareAndSetShortAcquire(Object o, long offset,
1643                                                        short expected,
1644                                                        short x) {
1645         return weakCompareAndSetShort(o, offset, expected, x);
1646     }
1647 
1648     @HotSpotIntrinsicCandidate
1649     public final boolean weakCompareAndSetShortRelease(Object o, long offset,
1650                                                        short expected,
1651                                                        short x) {
1652         return weakCompareAndSetShort(o, offset, expected, x);
1653     }
1654 
1655     @HotSpotIntrinsicCandidate
1656     public final boolean weakCompareAndSetShortPlain(Object o, long offset,
1657                                                      short expected,
1658                                                      short x) {
1659         return weakCompareAndSetShort(o, offset, expected, x);
1660     }
1661 
1662 
1663     @HotSpotIntrinsicCandidate
1664     public final short compareAndExchangeShortAcquire(Object o, long offset,
1665                                                      short expected,
1666                                                      short x) {
1667         return compareAndExchangeShort(o, offset, expected, x);
1668     }
1669 
1670     @HotSpotIntrinsicCandidate
1671     public final short compareAndExchangeShortRelease(Object o, long offset,
1672                                                     short expected,
1673                                                     short x) {
1674         return compareAndExchangeShort(o, offset, expected, x);
1675     }
1676 
1677     @ForceInline
1678     private char s2c(short s) {
1679         return (char) s;
1680     }
1681 
1682     @ForceInline
1683     private short c2s(char s) {
1684         return (short) s;
1685     }
1686 
1687     @ForceInline
1688     public final boolean compareAndSetChar(Object o, long offset,
1689                                            char expected,
1690                                            char x) {
1691         return compareAndSetShort(o, offset, c2s(expected), c2s(x));
1692     }
1693 
1694     @ForceInline
1695     public final char compareAndExchangeChar(Object o, long offset,
1696                                              char expected,
1697                                              char x) {
1698         return s2c(compareAndExchangeShort(o, offset, c2s(expected), c2s(x)));
1699     }
1700 
1701     @ForceInline
1702     public final char compareAndExchangeCharAcquire(Object o, long offset,
1703                                             char expected,
1704                                             char x) {
1705         return s2c(compareAndExchangeShortAcquire(o, offset, c2s(expected), c2s(x)));
1706     }
1707 
1708     @ForceInline
1709     public final char compareAndExchangeCharRelease(Object o, long offset,
1710                                             char expected,
1711                                             char x) {
1712         return s2c(compareAndExchangeShortRelease(o, offset, c2s(expected), c2s(x)));
1713     }
1714 
1715     @ForceInline
1716     public final boolean weakCompareAndSetChar(Object o, long offset,
1717                                                char expected,
1718                                                char x) {
1719         return weakCompareAndSetShort(o, offset, c2s(expected), c2s(x));
1720     }
1721 
1722     @ForceInline
1723     public final boolean weakCompareAndSetCharAcquire(Object o, long offset,
1724                                                       char expected,
1725                                                       char x) {
1726         return weakCompareAndSetShortAcquire(o, offset, c2s(expected), c2s(x));
1727     }
1728 
1729     @ForceInline
1730     public final boolean weakCompareAndSetCharRelease(Object o, long offset,
1731                                                       char expected,
1732                                                       char x) {
1733         return weakCompareAndSetShortRelease(o, offset, c2s(expected), c2s(x));
1734     }
1735 
1736     @ForceInline
1737     public final boolean weakCompareAndSetCharPlain(Object o, long offset,
1738                                                     char expected,
1739                                                     char x) {
1740         return weakCompareAndSetShortPlain(o, offset, c2s(expected), c2s(x));
1741     }
1742 
1743     /**
1744      * The JVM converts integral values to boolean values using two
1745      * different conventions, byte testing against zero and truncation
1746      * to least-significant bit.
1747      *
1748      * &lt;p&gt;The JNI documents specify that, at least for returning
1749      * values from native methods, a Java boolean value is converted
1750      * to the value-set 0..1 by first truncating to a byte (0..255 or
1751      * maybe -128..127) and then testing against zero. Thus, Java
1752      * booleans in non-Java data structures are by convention
1753      * represented as 8-bit containers containing either zero (for
1754      * false) or any non-zero value (for true).
1755      *
1756      * &lt;p&gt;Java booleans in the heap are also stored in bytes, but are
1757      * strongly normalized to the value-set 0..1 (i.e., they are
1758      * truncated to the least-significant bit).
1759      *
1760      * &lt;p&gt;The main reason for having different conventions for
1761      * conversion is performance: Truncation to the least-significant
1762      * bit can be usually implemented with fewer (machine)
1763      * instructions than byte testing against zero.
1764      *
1765      * &lt;p&gt;A number of Unsafe methods load boolean values from the heap
1766      * as bytes. Unsafe converts those values according to the JNI
1767      * rules (i.e, using the &quot;testing against zero&quot; convention). The
1768      * method {@code byte2bool} implements that conversion.
1769      *
1770      * @param b the byte to be converted to boolean
1771      * @return the result of the conversion
1772      */
1773     @ForceInline
1774     private boolean byte2bool(byte b) {
1775         return b != 0;
1776     }
1777 
1778     /**
1779      * Convert a boolean value to a byte. The return value is strongly
1780      * normalized to the value-set 0..1 (i.e., the value is truncated
1781      * to the least-significant bit). See {@link #byte2bool(byte)} for
1782      * more details on conversion conventions.
1783      *
1784      * @param b the boolean to be converted to byte (and then normalized)
1785      * @return the result of the conversion
1786      */
1787     @ForceInline
1788     private byte bool2byte(boolean b) {
1789         return b ? (byte)1 : (byte)0;
1790     }
1791 
1792     @ForceInline
1793     public final boolean compareAndSetBoolean(Object o, long offset,
1794                                               boolean expected,
1795                                               boolean x) {
1796         return compareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1797     }
1798 
1799     @ForceInline
1800     public final boolean compareAndExchangeBoolean(Object o, long offset,
1801                                                    boolean expected,
1802                                                    boolean x) {
1803         return byte2bool(compareAndExchangeByte(o, offset, bool2byte(expected), bool2byte(x)));
1804     }
1805 
1806     @ForceInline
1807     public final boolean compareAndExchangeBooleanAcquire(Object o, long offset,
1808                                                     boolean expected,
1809                                                     boolean x) {
1810         return byte2bool(compareAndExchangeByteAcquire(o, offset, bool2byte(expected), bool2byte(x)));
1811     }
1812 
1813     @ForceInline
1814     public final boolean compareAndExchangeBooleanRelease(Object o, long offset,
1815                                                        boolean expected,
1816                                                        boolean x) {
1817         return byte2bool(compareAndExchangeByteRelease(o, offset, bool2byte(expected), bool2byte(x)));
1818     }
1819 
1820     @ForceInline
1821     public final boolean weakCompareAndSetBoolean(Object o, long offset,
1822                                                   boolean expected,
1823                                                   boolean x) {
1824         return weakCompareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
1825     }
1826 
1827     @ForceInline
1828     public final boolean weakCompareAndSetBooleanAcquire(Object o, long offset,
1829                                                          boolean expected,
1830                                                          boolean x) {
1831         return weakCompareAndSetByteAcquire(o, offset, bool2byte(expected), bool2byte(x));
1832     }
1833 
1834     @ForceInline
1835     public final boolean weakCompareAndSetBooleanRelease(Object o, long offset,
1836                                                          boolean expected,
1837                                                          boolean x) {
1838         return weakCompareAndSetByteRelease(o, offset, bool2byte(expected), bool2byte(x));
1839     }
1840 
1841     @ForceInline
1842     public final boolean weakCompareAndSetBooleanPlain(Object o, long offset,
1843                                                        boolean expected,
1844                                                        boolean x) {
1845         return weakCompareAndSetBytePlain(o, offset, bool2byte(expected), bool2byte(x));
1846     }
1847 
1848     /**
1849      * Atomically updates Java variable to {@code x} if it is currently
1850      * holding {@code expected}.
1851      *
1852      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1853      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1854      *
1855      * @return {@code true} if successful
1856      */
1857     @ForceInline
1858     public final boolean compareAndSetFloat(Object o, long offset,
1859                                             float expected,
1860                                             float x) {
1861         return compareAndSetInt(o, offset,
1862                                  Float.floatToRawIntBits(expected),
1863                                  Float.floatToRawIntBits(x));
1864     }
1865 
1866     @ForceInline
1867     public final float compareAndExchangeFloat(Object o, long offset,
1868                                                float expected,
1869                                                float x) {
1870         int w = compareAndExchangeInt(o, offset,
1871                                       Float.floatToRawIntBits(expected),
1872                                       Float.floatToRawIntBits(x));
1873         return Float.intBitsToFloat(w);
1874     }
1875 
1876     @ForceInline
1877     public final float compareAndExchangeFloatAcquire(Object o, long offset,
1878                                                   float expected,
1879                                                   float x) {
1880         int w = compareAndExchangeIntAcquire(o, offset,
1881                                              Float.floatToRawIntBits(expected),
1882                                              Float.floatToRawIntBits(x));
1883         return Float.intBitsToFloat(w);
1884     }
1885 
1886     @ForceInline
1887     public final float compareAndExchangeFloatRelease(Object o, long offset,
1888                                                   float expected,
1889                                                   float x) {
1890         int w = compareAndExchangeIntRelease(o, offset,
1891                                              Float.floatToRawIntBits(expected),
1892                                              Float.floatToRawIntBits(x));
1893         return Float.intBitsToFloat(w);
1894     }
1895 
1896     @ForceInline
1897     public final boolean weakCompareAndSetFloatPlain(Object o, long offset,
1898                                                      float expected,
1899                                                      float x) {
1900         return weakCompareAndSetIntPlain(o, offset,
1901                                      Float.floatToRawIntBits(expected),
1902                                      Float.floatToRawIntBits(x));
1903     }
1904 
1905     @ForceInline
1906     public final boolean weakCompareAndSetFloatAcquire(Object o, long offset,
1907                                                        float expected,
1908                                                        float x) {
1909         return weakCompareAndSetIntAcquire(o, offset,
1910                                             Float.floatToRawIntBits(expected),
1911                                             Float.floatToRawIntBits(x));
1912     }
1913 
1914     @ForceInline
1915     public final boolean weakCompareAndSetFloatRelease(Object o, long offset,
1916                                                        float expected,
1917                                                        float x) {
1918         return weakCompareAndSetIntRelease(o, offset,
1919                                             Float.floatToRawIntBits(expected),
1920                                             Float.floatToRawIntBits(x));
1921     }
1922 
1923     @ForceInline
1924     public final boolean weakCompareAndSetFloat(Object o, long offset,
1925                                                 float expected,
1926                                                 float x) {
1927         return weakCompareAndSetInt(o, offset,
1928                                              Float.floatToRawIntBits(expected),
1929                                              Float.floatToRawIntBits(x));
1930     }
1931 
1932     /**
1933      * Atomically updates Java variable to {@code x} if it is currently
1934      * holding {@code expected}.
1935      *
1936      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1937      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1938      *
1939      * @return {@code true} if successful
1940      */
1941     @ForceInline
1942     public final boolean compareAndSetDouble(Object o, long offset,
1943                                              double expected,
1944                                              double x) {
1945         return compareAndSetLong(o, offset,
1946                                  Double.doubleToRawLongBits(expected),
1947                                  Double.doubleToRawLongBits(x));
1948     }
1949 
1950     @ForceInline
1951     public final double compareAndExchangeDouble(Object o, long offset,
1952                                                  double expected,
1953                                                  double x) {
1954         long w = compareAndExchangeLong(o, offset,
1955                                         Double.doubleToRawLongBits(expected),
1956                                         Double.doubleToRawLongBits(x));
1957         return Double.longBitsToDouble(w);
1958     }
1959 
1960     @ForceInline
1961     public final double compareAndExchangeDoubleAcquire(Object o, long offset,
1962                                                         double expected,
1963                                                         double x) {
1964         long w = compareAndExchangeLongAcquire(o, offset,
1965                                                Double.doubleToRawLongBits(expected),
1966                                                Double.doubleToRawLongBits(x));
1967         return Double.longBitsToDouble(w);
1968     }
1969 
1970     @ForceInline
1971     public final double compareAndExchangeDoubleRelease(Object o, long offset,
1972                                                         double expected,
1973                                                         double x) {
1974         long w = compareAndExchangeLongRelease(o, offset,
1975                                                Double.doubleToRawLongBits(expected),
1976                                                Double.doubleToRawLongBits(x));
1977         return Double.longBitsToDouble(w);
1978     }
1979 
1980     @ForceInline
1981     public final boolean weakCompareAndSetDoublePlain(Object o, long offset,
1982                                                       double expected,
1983                                                       double x) {
1984         return weakCompareAndSetLongPlain(o, offset,
1985                                      Double.doubleToRawLongBits(expected),
1986                                      Double.doubleToRawLongBits(x));
1987     }
1988 
1989     @ForceInline
1990     public final boolean weakCompareAndSetDoubleAcquire(Object o, long offset,
1991                                                         double expected,
1992                                                         double x) {
1993         return weakCompareAndSetLongAcquire(o, offset,
1994                                              Double.doubleToRawLongBits(expected),
1995                                              Double.doubleToRawLongBits(x));
1996     }
1997 
1998     @ForceInline
1999     public final boolean weakCompareAndSetDoubleRelease(Object o, long offset,
2000                                                         double expected,
2001                                                         double x) {
2002         return weakCompareAndSetLongRelease(o, offset,
2003                                              Double.doubleToRawLongBits(expected),
2004                                              Double.doubleToRawLongBits(x));
2005     }
2006 
2007     @ForceInline
2008     public final boolean weakCompareAndSetDouble(Object o, long offset,
2009                                                  double expected,
2010                                                  double x) {
2011         return weakCompareAndSetLong(o, offset,
2012                                               Double.doubleToRawLongBits(expected),
2013                                               Double.doubleToRawLongBits(x));
2014     }
2015 
2016     /**
2017      * Atomically updates Java variable to {@code x} if it is currently
2018      * holding {@code expected}.
2019      *
2020      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
2021      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
2022      *
2023      * @return {@code true} if successful
2024      */
2025     @HotSpotIntrinsicCandidate
2026     public final native boolean compareAndSetLong(Object o, long offset,
2027                                                   long expected,
2028                                                   long x);
2029 
2030     @HotSpotIntrinsicCandidate
2031     public final native long compareAndExchangeLong(Object o, long offset,
2032                                                     long expected,
2033                                                     long x);
2034 
2035     @HotSpotIntrinsicCandidate
2036     public final long compareAndExchangeLongAcquire(Object o, long offset,
2037                                                            long expected,
2038                                                            long x) {
2039         return compareAndExchangeLong(o, offset, expected, x);
2040     }
2041 
2042     @HotSpotIntrinsicCandidate
2043     public final long compareAndExchangeLongRelease(Object o, long offset,
2044                                                            long expected,
2045                                                            long x) {
2046         return compareAndExchangeLong(o, offset, expected, x);
2047     }
2048 
2049     @HotSpotIntrinsicCandidate
2050     public final boolean weakCompareAndSetLongPlain(Object o, long offset,
2051                                                     long expected,
2052                                                     long x) {
2053         return compareAndSetLong(o, offset, expected, x);
2054     }
2055 
2056     @HotSpotIntrinsicCandidate
2057     public final boolean weakCompareAndSetLongAcquire(Object o, long offset,
2058                                                       long expected,
2059                                                       long x) {
2060         return compareAndSetLong(o, offset, expected, x);
2061     }
2062 
2063     @HotSpotIntrinsicCandidate
2064     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
2065                                                       long expected,
2066                                                       long x) {
2067         return compareAndSetLong(o, offset, expected, x);
2068     }
2069 
2070     @HotSpotIntrinsicCandidate
2071     public final boolean weakCompareAndSetLong(Object o, long offset,
2072                                                long expected,
2073                                                long x) {
2074         return compareAndSetLong(o, offset, expected, x);
2075     }
2076 
2077     /**
2078      * Fetches a reference value from a given Java variable, with volatile
2079      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
2080      */
2081     @HotSpotIntrinsicCandidate
2082     public native Object getReferenceVolatile(Object o, long offset);
2083 
2084     /**
2085      * Stores a reference value into a given Java variable, with
2086      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
2087      */
2088     @HotSpotIntrinsicCandidate
2089     public native void putReferenceVolatile(Object o, long offset, Object x);
2090 
2091     /** Volatile version of {@link #getInt(Object, long)}  */
2092     @HotSpotIntrinsicCandidate
2093     public native int     getIntVolatile(Object o, long offset);
2094 
2095     /** Volatile version of {@link #putInt(Object, long, int)}  */
2096     @HotSpotIntrinsicCandidate
2097     public native void    putIntVolatile(Object o, long offset, int x);
2098 
2099     /** Volatile version of {@link #getBoolean(Object, long)}  */
2100     @HotSpotIntrinsicCandidate
2101     public native boolean getBooleanVolatile(Object o, long offset);
2102 
2103     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
2104     @HotSpotIntrinsicCandidate
2105     public native void    putBooleanVolatile(Object o, long offset, boolean x);
2106 
2107     /** Volatile version of {@link #getByte(Object, long)}  */
2108     @HotSpotIntrinsicCandidate
2109     public native byte    getByteVolatile(Object o, long offset);
2110 
2111     /** Volatile version of {@link #putByte(Object, long, byte)}  */
2112     @HotSpotIntrinsicCandidate
2113     public native void    putByteVolatile(Object o, long offset, byte x);
2114 
2115     /** Volatile version of {@link #getShort(Object, long)}  */
2116     @HotSpotIntrinsicCandidate
2117     public native short   getShortVolatile(Object o, long offset);
2118 
2119     /** Volatile version of {@link #putShort(Object, long, short)}  */
2120     @HotSpotIntrinsicCandidate
2121     public native void    putShortVolatile(Object o, long offset, short x);
2122 
2123     /** Volatile version of {@link #getChar(Object, long)}  */
2124     @HotSpotIntrinsicCandidate
2125     public native char    getCharVolatile(Object o, long offset);
2126 
2127     /** Volatile version of {@link #putChar(Object, long, char)}  */
2128     @HotSpotIntrinsicCandidate
2129     public native void    putCharVolatile(Object o, long offset, char x);
2130 
2131     /** Volatile version of {@link #getLong(Object, long)}  */
2132     @HotSpotIntrinsicCandidate
2133     public native long    getLongVolatile(Object o, long offset);
2134 
2135     /** Volatile version of {@link #putLong(Object, long, long)}  */
2136     @HotSpotIntrinsicCandidate
2137     public native void    putLongVolatile(Object o, long offset, long x);
2138 
2139     /** Volatile version of {@link #getFloat(Object, long)}  */
2140     @HotSpotIntrinsicCandidate
2141     public native float   getFloatVolatile(Object o, long offset);
2142 
2143     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2144     @HotSpotIntrinsicCandidate
2145     public native void    putFloatVolatile(Object o, long offset, float x);
2146 
2147     /** Volatile version of {@link #getDouble(Object, long)}  */
2148     @HotSpotIntrinsicCandidate
2149     public native double  getDoubleVolatile(Object o, long offset);
2150 
2151     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2152     @HotSpotIntrinsicCandidate
2153     public native void    putDoubleVolatile(Object o, long offset, double x);
2154 
2155 
2156 
2157     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2158     @HotSpotIntrinsicCandidate
2159     public final Object getReferenceAcquire(Object o, long offset) {
2160         return getReferenceVolatile(o, offset);
2161     }
2162 
2163     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2164     @HotSpotIntrinsicCandidate
2165     public final boolean getBooleanAcquire(Object o, long offset) {
2166         return getBooleanVolatile(o, offset);
2167     }
2168 
2169     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2170     @HotSpotIntrinsicCandidate
2171     public final byte getByteAcquire(Object o, long offset) {
2172         return getByteVolatile(o, offset);
2173     }
2174 
2175     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2176     @HotSpotIntrinsicCandidate
2177     public final short getShortAcquire(Object o, long offset) {
2178         return getShortVolatile(o, offset);
2179     }
2180 
2181     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2182     @HotSpotIntrinsicCandidate
2183     public final char getCharAcquire(Object o, long offset) {
2184         return getCharVolatile(o, offset);
2185     }
2186 
2187     /** Acquire version of {@link #getIntVolatile(Object, long)} */
2188     @HotSpotIntrinsicCandidate
2189     public final int getIntAcquire(Object o, long offset) {
2190         return getIntVolatile(o, offset);
2191     }
2192 
2193     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2194     @HotSpotIntrinsicCandidate
2195     public final float getFloatAcquire(Object o, long offset) {
2196         return getFloatVolatile(o, offset);
2197     }
2198 
2199     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2200     @HotSpotIntrinsicCandidate
2201     public final long getLongAcquire(Object o, long offset) {
2202         return getLongVolatile(o, offset);
2203     }
2204 
2205     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2206     @HotSpotIntrinsicCandidate
2207     public final double getDoubleAcquire(Object o, long offset) {
2208         return getDoubleVolatile(o, offset);
2209     }
2210 
2211     /*
2212       * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2213       * that do not guarantee immediate visibility of the store to
2214       * other threads. This method is generally only useful if the
2215       * underlying field is a Java volatile (or if an array cell, one
2216       * that is otherwise only accessed using volatile accesses).
2217       *
2218       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2219       */
2220 
2221     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2222     @HotSpotIntrinsicCandidate
2223     public final void putReferenceRelease(Object o, long offset, Object x) {
2224         putReferenceVolatile(o, offset, x);
2225     }
2226 
2227     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2228     @HotSpotIntrinsicCandidate
2229     public final void putBooleanRelease(Object o, long offset, boolean x) {
2230         putBooleanVolatile(o, offset, x);
2231     }
2232 
2233     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2234     @HotSpotIntrinsicCandidate
2235     public final void putByteRelease(Object o, long offset, byte x) {
2236         putByteVolatile(o, offset, x);
2237     }
2238 
2239     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2240     @HotSpotIntrinsicCandidate
2241     public final void putShortRelease(Object o, long offset, short x) {
2242         putShortVolatile(o, offset, x);
2243     }
2244 
2245     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2246     @HotSpotIntrinsicCandidate
2247     public final void putCharRelease(Object o, long offset, char x) {
2248         putCharVolatile(o, offset, x);
2249     }
2250 
2251     /** Release version of {@link #putIntVolatile(Object, long, int)} */
2252     @HotSpotIntrinsicCandidate
2253     public final void putIntRelease(Object o, long offset, int x) {
2254         putIntVolatile(o, offset, x);
2255     }
2256 
2257     /** Release version of {@link #putFloatVolatile(Object, long, float)} */
2258     @HotSpotIntrinsicCandidate
2259     public final void putFloatRelease(Object o, long offset, float x) {
2260         putFloatVolatile(o, offset, x);
2261     }
2262 
2263     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2264     @HotSpotIntrinsicCandidate
2265     public final void putLongRelease(Object o, long offset, long x) {
2266         putLongVolatile(o, offset, x);
2267     }
2268 
2269     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2270     @HotSpotIntrinsicCandidate
2271     public final void putDoubleRelease(Object o, long offset, double x) {
2272         putDoubleVolatile(o, offset, x);
2273     }
2274 
2275     // ------------------------------ Opaque --------------------------------------
2276 
2277     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2278     @HotSpotIntrinsicCandidate
2279     public final Object getReferenceOpaque(Object o, long offset) {
2280         return getReferenceVolatile(o, offset);
2281     }
2282 
2283     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2284     @HotSpotIntrinsicCandidate
2285     public final boolean getBooleanOpaque(Object o, long offset) {
2286         return getBooleanVolatile(o, offset);
2287     }
2288 
2289     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2290     @HotSpotIntrinsicCandidate
2291     public final byte getByteOpaque(Object o, long offset) {
2292         return getByteVolatile(o, offset);
2293     }
2294 
2295     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2296     @HotSpotIntrinsicCandidate
2297     public final short getShortOpaque(Object o, long offset) {
2298         return getShortVolatile(o, offset);
2299     }
2300 
2301     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2302     @HotSpotIntrinsicCandidate
2303     public final char getCharOpaque(Object o, long offset) {
2304         return getCharVolatile(o, offset);
2305     }
2306 
2307     /** Opaque version of {@link #getIntVolatile(Object, long)} */
2308     @HotSpotIntrinsicCandidate
2309     public final int getIntOpaque(Object o, long offset) {
2310         return getIntVolatile(o, offset);
2311     }
2312 
2313     /** Opaque version of {@link #getFloatVolatile(Object, long)} */
2314     @HotSpotIntrinsicCandidate
2315     public final float getFloatOpaque(Object o, long offset) {
2316         return getFloatVolatile(o, offset);
2317     }
2318 
2319     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2320     @HotSpotIntrinsicCandidate
2321     public final long getLongOpaque(Object o, long offset) {
2322         return getLongVolatile(o, offset);
2323     }
2324 
2325     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2326     @HotSpotIntrinsicCandidate
2327     public final double getDoubleOpaque(Object o, long offset) {
2328         return getDoubleVolatile(o, offset);
2329     }
2330 
2331     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2332     @HotSpotIntrinsicCandidate
2333     public final void putReferenceOpaque(Object o, long offset, Object x) {
2334         putReferenceVolatile(o, offset, x);
2335     }
2336 
2337     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2338     @HotSpotIntrinsicCandidate
2339     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2340         putBooleanVolatile(o, offset, x);
2341     }
2342 
2343     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2344     @HotSpotIntrinsicCandidate
2345     public final void putByteOpaque(Object o, long offset, byte x) {
2346         putByteVolatile(o, offset, x);
2347     }
2348 
2349     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2350     @HotSpotIntrinsicCandidate
2351     public final void putShortOpaque(Object o, long offset, short x) {
2352         putShortVolatile(o, offset, x);
2353     }
2354 
2355     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2356     @HotSpotIntrinsicCandidate
2357     public final void putCharOpaque(Object o, long offset, char x) {
2358         putCharVolatile(o, offset, x);
2359     }
2360 
2361     /** Opaque version of {@link #putIntVolatile(Object, long, int)} */
2362     @HotSpotIntrinsicCandidate
2363     public final void putIntOpaque(Object o, long offset, int x) {
2364         putIntVolatile(o, offset, x);
2365     }
2366 
2367     /** Opaque version of {@link #putFloatVolatile(Object, long, float)} */
2368     @HotSpotIntrinsicCandidate
2369     public final void putFloatOpaque(Object o, long offset, float x) {
2370         putFloatVolatile(o, offset, x);
2371     }
2372 
2373     /** Opaque version of {@link #putLongVolatile(Object, long, long)} */
2374     @HotSpotIntrinsicCandidate
2375     public final void putLongOpaque(Object o, long offset, long x) {
2376         putLongVolatile(o, offset, x);
2377     }
2378 
2379     /** Opaque version of {@link #putDoubleVolatile(Object, long, double)} */
2380     @HotSpotIntrinsicCandidate
2381     public final void putDoubleOpaque(Object o, long offset, double x) {
2382         putDoubleVolatile(o, offset, x);
2383     }
2384 
2385     /**
2386      * Unblocks the given thread blocked on {@code park}, or, if it is
2387      * not blocked, causes the subsequent call to {@code park} not to
2388      * block.  Note: this operation is &quot;unsafe&quot; solely because the
2389      * caller must somehow ensure that the thread has not been
2390      * destroyed. Nothing special is usually required to ensure this
2391      * when called from Java (in which there will ordinarily be a live
2392      * reference to the thread) but this is not nearly-automatically
2393      * so when calling from native code.
2394      *
2395      * @param thread the thread to unpark.
2396      */
2397     @HotSpotIntrinsicCandidate
2398     public native void unpark(Object thread);
2399 
2400     /**
2401      * Blocks current thread, returning when a balancing
2402      * {@code unpark} occurs, or a balancing {@code unpark} has
2403      * already occurred, or the thread is interrupted, or, if not
2404      * absolute and time is not zero, the given time nanoseconds have
2405      * elapsed, or if absolute, the given deadline in milliseconds
2406      * since Epoch has passed, or spuriously (i.e., returning for no
2407      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
2408      * because {@code unpark} is, so it would be strange to place it
2409      * elsewhere.
2410      */
2411     @HotSpotIntrinsicCandidate
2412     public native void park(boolean isAbsolute, long time);
2413 
2414     /**
2415      * Gets the load average in the system run queue assigned
2416      * to the available processors averaged over various periods of time.
2417      * This method retrieves the given {@code nelem} samples and
2418      * assigns to the elements of the given {@code loadavg} array.
2419      * The system imposes a maximum of 3 samples, representing
2420      * averages over the last 1,  5,  and  15 minutes, respectively.
2421      *
2422      * @param loadavg an array of double of size nelems
2423      * @param nelems the number of samples to be retrieved and
2424      *        must be 1 to 3.
2425      *
2426      * @return the number of samples actually retrieved; or -1
2427      *         if the load average is unobtainable.
2428      */
2429     public int getLoadAverage(double[] loadavg, int nelems) {
2430         if (nelems &lt; 0 || nelems &gt; 3 || nelems &gt; loadavg.length) {
2431             throw new ArrayIndexOutOfBoundsException();
2432         }
2433 
2434         return getLoadAverage0(loadavg, nelems);
2435     }
2436 
2437     // The following contain CAS-based Java implementations used on
2438     // platforms not supporting native instructions
2439 
2440     /**
2441      * Atomically adds the given value to the current value of a field
2442      * or array element within the given object {@code o}
2443      * at the given {@code offset}.
2444      *
2445      * @param o object/array to update the field/element in
2446      * @param offset field/element offset
2447      * @param delta the value to add
2448      * @return the previous value
2449      * @since 1.8
2450      */
2451     @HotSpotIntrinsicCandidate
2452     public final int getAndAddInt(Object o, long offset, int delta) {
2453         int v;
2454         do {
2455             v = getIntVolatile(o, offset);
2456         } while (!weakCompareAndSetInt(o, offset, v, v + delta));
2457         return v;
2458     }
2459 
2460     @ForceInline
2461     public final int getAndAddIntRelease(Object o, long offset, int delta) {
2462         int v;
2463         do {
2464             v = getInt(o, offset);
2465         } while (!weakCompareAndSetIntRelease(o, offset, v, v + delta));
2466         return v;
2467     }
2468 
2469     @ForceInline
2470     public final int getAndAddIntAcquire(Object o, long offset, int delta) {
2471         int v;
2472         do {
2473             v = getIntAcquire(o, offset);
2474         } while (!weakCompareAndSetIntAcquire(o, offset, v, v + delta));
2475         return v;
2476     }
2477 
2478     /**
2479      * Atomically adds the given value to the current value of a field
2480      * or array element within the given object {@code o}
2481      * at the given {@code offset}.
2482      *
2483      * @param o object/array to update the field/element in
2484      * @param offset field/element offset
2485      * @param delta the value to add
2486      * @return the previous value
2487      * @since 1.8
2488      */
2489     @HotSpotIntrinsicCandidate
2490     public final long getAndAddLong(Object o, long offset, long delta) {
2491         long v;
2492         do {
2493             v = getLongVolatile(o, offset);
2494         } while (!weakCompareAndSetLong(o, offset, v, v + delta));
2495         return v;
2496     }
2497 
2498     @ForceInline
2499     public final long getAndAddLongRelease(Object o, long offset, long delta) {
2500         long v;
2501         do {
2502             v = getLong(o, offset);
2503         } while (!weakCompareAndSetLongRelease(o, offset, v, v + delta));
2504         return v;
2505     }
2506 
2507     @ForceInline
2508     public final long getAndAddLongAcquire(Object o, long offset, long delta) {
2509         long v;
2510         do {
2511             v = getLongAcquire(o, offset);
2512         } while (!weakCompareAndSetLongAcquire(o, offset, v, v + delta));
2513         return v;
2514     }
2515 
2516     @HotSpotIntrinsicCandidate
2517     public final byte getAndAddByte(Object o, long offset, byte delta) {
2518         byte v;
2519         do {
2520             v = getByteVolatile(o, offset);
2521         } while (!weakCompareAndSetByte(o, offset, v, (byte) (v + delta)));
2522         return v;
2523     }
2524 
2525     @ForceInline
2526     public final byte getAndAddByteRelease(Object o, long offset, byte delta) {
2527         byte v;
2528         do {
2529             v = getByte(o, offset);
2530         } while (!weakCompareAndSetByteRelease(o, offset, v, (byte) (v + delta)));
2531         return v;
2532     }
2533 
2534     @ForceInline
2535     public final byte getAndAddByteAcquire(Object o, long offset, byte delta) {
2536         byte v;
2537         do {
2538             v = getByteAcquire(o, offset);
2539         } while (!weakCompareAndSetByteAcquire(o, offset, v, (byte) (v + delta)));
2540         return v;
2541     }
2542 
2543     @HotSpotIntrinsicCandidate
2544     public final short getAndAddShort(Object o, long offset, short delta) {
2545         short v;
2546         do {
2547             v = getShortVolatile(o, offset);
2548         } while (!weakCompareAndSetShort(o, offset, v, (short) (v + delta)));
2549         return v;
2550     }
2551 
2552     @ForceInline
2553     public final short getAndAddShortRelease(Object o, long offset, short delta) {
2554         short v;
2555         do {
2556             v = getShort(o, offset);
2557         } while (!weakCompareAndSetShortRelease(o, offset, v, (short) (v + delta)));
2558         return v;
2559     }
2560 
2561     @ForceInline
2562     public final short getAndAddShortAcquire(Object o, long offset, short delta) {
2563         short v;
2564         do {
2565             v = getShortAcquire(o, offset);
2566         } while (!weakCompareAndSetShortAcquire(o, offset, v, (short) (v + delta)));
2567         return v;
2568     }
2569 
2570     @ForceInline
2571     public final char getAndAddChar(Object o, long offset, char delta) {
2572         return (char) getAndAddShort(o, offset, (short) delta);
2573     }
2574 
2575     @ForceInline
2576     public final char getAndAddCharRelease(Object o, long offset, char delta) {
2577         return (char) getAndAddShortRelease(o, offset, (short) delta);
2578     }
2579 
2580     @ForceInline
2581     public final char getAndAddCharAcquire(Object o, long offset, char delta) {
2582         return (char) getAndAddShortAcquire(o, offset, (short) delta);
2583     }
2584 
2585     @ForceInline
2586     public final float getAndAddFloat(Object o, long offset, float delta) {
2587         int expectedBits;
2588         float v;
2589         do {
2590             // Load and CAS with the raw bits to avoid issues with NaNs and
2591             // possible bit conversion from signaling NaNs to quiet NaNs that
2592             // may result in the loop not terminating.
2593             expectedBits = getIntVolatile(o, offset);
2594             v = Float.intBitsToFloat(expectedBits);
2595         } while (!weakCompareAndSetInt(o, offset,
2596                                                 expectedBits, Float.floatToRawIntBits(v + delta)));
2597         return v;
2598     }
2599 
2600     @ForceInline
2601     public final float getAndAddFloatRelease(Object o, long offset, float delta) {
2602         int expectedBits;
2603         float v;
2604         do {
2605             // Load and CAS with the raw bits to avoid issues with NaNs and
2606             // possible bit conversion from signaling NaNs to quiet NaNs that
2607             // may result in the loop not terminating.
2608             expectedBits = getInt(o, offset);
2609             v = Float.intBitsToFloat(expectedBits);
2610         } while (!weakCompareAndSetIntRelease(o, offset,
2611                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2612         return v;
2613     }
2614 
2615     @ForceInline
2616     public final float getAndAddFloatAcquire(Object o, long offset, float delta) {
2617         int expectedBits;
2618         float v;
2619         do {
2620             // Load and CAS with the raw bits to avoid issues with NaNs and
2621             // possible bit conversion from signaling NaNs to quiet NaNs that
2622             // may result in the loop not terminating.
2623             expectedBits = getIntAcquire(o, offset);
2624             v = Float.intBitsToFloat(expectedBits);
2625         } while (!weakCompareAndSetIntAcquire(o, offset,
2626                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2627         return v;
2628     }
2629 
2630     @ForceInline
2631     public final double getAndAddDouble(Object o, long offset, double delta) {
2632         long expectedBits;
2633         double v;
2634         do {
2635             // Load and CAS with the raw bits to avoid issues with NaNs and
2636             // possible bit conversion from signaling NaNs to quiet NaNs that
2637             // may result in the loop not terminating.
2638             expectedBits = getLongVolatile(o, offset);
2639             v = Double.longBitsToDouble(expectedBits);
2640         } while (!weakCompareAndSetLong(o, offset,
2641                                                  expectedBits, Double.doubleToRawLongBits(v + delta)));
2642         return v;
2643     }
2644 
2645     @ForceInline
2646     public final double getAndAddDoubleRelease(Object o, long offset, double delta) {
2647         long expectedBits;
2648         double v;
2649         do {
2650             // Load and CAS with the raw bits to avoid issues with NaNs and
2651             // possible bit conversion from signaling NaNs to quiet NaNs that
2652             // may result in the loop not terminating.
2653             expectedBits = getLong(o, offset);
2654             v = Double.longBitsToDouble(expectedBits);
2655         } while (!weakCompareAndSetLongRelease(o, offset,
2656                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2657         return v;
2658     }
2659 
2660     @ForceInline
2661     public final double getAndAddDoubleAcquire(Object o, long offset, double delta) {
2662         long expectedBits;
2663         double v;
2664         do {
2665             // Load and CAS with the raw bits to avoid issues with NaNs and
2666             // possible bit conversion from signaling NaNs to quiet NaNs that
2667             // may result in the loop not terminating.
2668             expectedBits = getLongAcquire(o, offset);
2669             v = Double.longBitsToDouble(expectedBits);
2670         } while (!weakCompareAndSetLongAcquire(o, offset,
2671                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
2672         return v;
2673     }
2674 
2675     /**
2676      * Atomically exchanges the given value with the current value of
2677      * a field or array element within the given object {@code o}
2678      * at the given {@code offset}.
2679      *
2680      * @param o object/array to update the field/element in
2681      * @param offset field/element offset
2682      * @param newValue new value
2683      * @return the previous value
2684      * @since 1.8
2685      */
2686     @HotSpotIntrinsicCandidate
2687     public final int getAndSetInt(Object o, long offset, int newValue) {
2688         int v;
2689         do {
2690             v = getIntVolatile(o, offset);
2691         } while (!weakCompareAndSetInt(o, offset, v, newValue));
2692         return v;
2693     }
2694 
2695     @ForceInline
2696     public final int getAndSetIntRelease(Object o, long offset, int newValue) {
2697         int v;
2698         do {
2699             v = getInt(o, offset);
2700         } while (!weakCompareAndSetIntRelease(o, offset, v, newValue));
2701         return v;
2702     }
2703 
2704     @ForceInline
2705     public final int getAndSetIntAcquire(Object o, long offset, int newValue) {
2706         int v;
2707         do {
2708             v = getIntAcquire(o, offset);
2709         } while (!weakCompareAndSetIntAcquire(o, offset, v, newValue));
2710         return v;
2711     }
2712 
2713     /**
2714      * Atomically exchanges the given value with the current value of
2715      * a field or array element within the given object {@code o}
2716      * at the given {@code offset}.
2717      *
2718      * @param o object/array to update the field/element in
2719      * @param offset field/element offset
2720      * @param newValue new value
2721      * @return the previous value
2722      * @since 1.8
2723      */
2724     @HotSpotIntrinsicCandidate
2725     public final long getAndSetLong(Object o, long offset, long newValue) {
2726         long v;
2727         do {
2728             v = getLongVolatile(o, offset);
2729         } while (!weakCompareAndSetLong(o, offset, v, newValue));
2730         return v;
2731     }
2732 
2733     @ForceInline
2734     public final long getAndSetLongRelease(Object o, long offset, long newValue) {
2735         long v;
2736         do {
2737             v = getLong(o, offset);
2738         } while (!weakCompareAndSetLongRelease(o, offset, v, newValue));
2739         return v;
2740     }
2741 
2742     @ForceInline
2743     public final long getAndSetLongAcquire(Object o, long offset, long newValue) {
2744         long v;
2745         do {
2746             v = getLongAcquire(o, offset);
2747         } while (!weakCompareAndSetLongAcquire(o, offset, v, newValue));
2748         return v;
2749     }
2750 
2751     /**
2752      * Atomically exchanges the given reference value with the current
2753      * reference value of a field or array element within the given
2754      * object {@code o} at the given {@code offset}.
2755      *
2756      * @param o object/array to update the field/element in
2757      * @param offset field/element offset
2758      * @param newValue new value
2759      * @return the previous value
2760      * @since 1.8
2761      */
2762     @HotSpotIntrinsicCandidate
2763     public final Object getAndSetReference(Object o, long offset, Object newValue) {
2764         Object v;
2765         do {
2766             v = getReferenceVolatile(o, offset);
2767         } while (!weakCompareAndSetReference(o, offset, v, newValue));
2768         return v;
2769     }
2770 
2771     @ForceInline
2772     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
2773         Object v;
2774         do {
2775             v = getReference(o, offset);
2776         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
2777         return v;
2778     }
2779 
2780     @ForceInline
2781     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
2782         Object v;
2783         do {
2784             v = getReferenceAcquire(o, offset);
2785         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
2786         return v;
2787     }
2788 
2789     @HotSpotIntrinsicCandidate
2790     public final byte getAndSetByte(Object o, long offset, byte newValue) {
2791         byte v;
2792         do {
2793             v = getByteVolatile(o, offset);
2794         } while (!weakCompareAndSetByte(o, offset, v, newValue));
2795         return v;
2796     }
2797 
2798     @ForceInline
2799     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
2800         byte v;
2801         do {
2802             v = getByte(o, offset);
2803         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
2804         return v;
2805     }
2806 
2807     @ForceInline
2808     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
2809         byte v;
2810         do {
2811             v = getByteAcquire(o, offset);
2812         } while (!weakCompareAndSetByteAcquire(o, offset, v, newValue));
2813         return v;
2814     }
2815 
2816     @ForceInline
2817     public final boolean getAndSetBoolean(Object o, long offset, boolean newValue) {
2818         return byte2bool(getAndSetByte(o, offset, bool2byte(newValue)));
2819     }
2820 
2821     @ForceInline
2822     public final boolean getAndSetBooleanRelease(Object o, long offset, boolean newValue) {
2823         return byte2bool(getAndSetByteRelease(o, offset, bool2byte(newValue)));
2824     }
2825 
2826     @ForceInline
2827     public final boolean getAndSetBooleanAcquire(Object o, long offset, boolean newValue) {
2828         return byte2bool(getAndSetByteAcquire(o, offset, bool2byte(newValue)));
2829     }
2830 
2831     @HotSpotIntrinsicCandidate
2832     public final short getAndSetShort(Object o, long offset, short newValue) {
2833         short v;
2834         do {
2835             v = getShortVolatile(o, offset);
2836         } while (!weakCompareAndSetShort(o, offset, v, newValue));
2837         return v;
2838     }
2839 
2840     @ForceInline
2841     public final short getAndSetShortRelease(Object o, long offset, short newValue) {
2842         short v;
2843         do {
2844             v = getShort(o, offset);
2845         } while (!weakCompareAndSetShortRelease(o, offset, v, newValue));
2846         return v;
2847     }
2848 
2849     @ForceInline
2850     public final short getAndSetShortAcquire(Object o, long offset, short newValue) {
2851         short v;
2852         do {
2853             v = getShortAcquire(o, offset);
2854         } while (!weakCompareAndSetShortAcquire(o, offset, v, newValue));
2855         return v;
2856     }
2857 
2858     @ForceInline
2859     public final char getAndSetChar(Object o, long offset, char newValue) {
2860         return s2c(getAndSetShort(o, offset, c2s(newValue)));
2861     }
2862 
2863     @ForceInline
2864     public final char getAndSetCharRelease(Object o, long offset, char newValue) {
2865         return s2c(getAndSetShortRelease(o, offset, c2s(newValue)));
2866     }
2867 
2868     @ForceInline
2869     public final char getAndSetCharAcquire(Object o, long offset, char newValue) {
2870         return s2c(getAndSetShortAcquire(o, offset, c2s(newValue)));
2871     }
2872 
2873     @ForceInline
2874     public final float getAndSetFloat(Object o, long offset, float newValue) {
2875         int v = getAndSetInt(o, offset, Float.floatToRawIntBits(newValue));
2876         return Float.intBitsToFloat(v);
2877     }
2878 
2879     @ForceInline
2880     public final float getAndSetFloatRelease(Object o, long offset, float newValue) {
2881         int v = getAndSetIntRelease(o, offset, Float.floatToRawIntBits(newValue));
2882         return Float.intBitsToFloat(v);
2883     }
2884 
2885     @ForceInline
2886     public final float getAndSetFloatAcquire(Object o, long offset, float newValue) {
2887         int v = getAndSetIntAcquire(o, offset, Float.floatToRawIntBits(newValue));
2888         return Float.intBitsToFloat(v);
2889     }
2890 
2891     @ForceInline
2892     public final double getAndSetDouble(Object o, long offset, double newValue) {
2893         long v = getAndSetLong(o, offset, Double.doubleToRawLongBits(newValue));
2894         return Double.longBitsToDouble(v);
2895     }
2896 
2897     @ForceInline
2898     public final double getAndSetDoubleRelease(Object o, long offset, double newValue) {
2899         long v = getAndSetLongRelease(o, offset, Double.doubleToRawLongBits(newValue));
2900         return Double.longBitsToDouble(v);
2901     }
2902 
2903     @ForceInline
2904     public final double getAndSetDoubleAcquire(Object o, long offset, double newValue) {
2905         long v = getAndSetLongAcquire(o, offset, Double.doubleToRawLongBits(newValue));
2906         return Double.longBitsToDouble(v);
2907     }
2908 
2909 
2910     // The following contain CAS-based Java implementations used on
2911     // platforms not supporting native instructions
2912 
2913     @ForceInline
2914     public final boolean getAndBitwiseOrBoolean(Object o, long offset, boolean mask) {
2915         return byte2bool(getAndBitwiseOrByte(o, offset, bool2byte(mask)));
2916     }
2917 
2918     @ForceInline
2919     public final boolean getAndBitwiseOrBooleanRelease(Object o, long offset, boolean mask) {
2920         return byte2bool(getAndBitwiseOrByteRelease(o, offset, bool2byte(mask)));
2921     }
2922 
2923     @ForceInline
2924     public final boolean getAndBitwiseOrBooleanAcquire(Object o, long offset, boolean mask) {
2925         return byte2bool(getAndBitwiseOrByteAcquire(o, offset, bool2byte(mask)));
2926     }
2927 
2928     @ForceInline
2929     public final boolean getAndBitwiseAndBoolean(Object o, long offset, boolean mask) {
2930         return byte2bool(getAndBitwiseAndByte(o, offset, bool2byte(mask)));
2931     }
2932 
2933     @ForceInline
2934     public final boolean getAndBitwiseAndBooleanRelease(Object o, long offset, boolean mask) {
2935         return byte2bool(getAndBitwiseAndByteRelease(o, offset, bool2byte(mask)));
2936     }
2937 
2938     @ForceInline
2939     public final boolean getAndBitwiseAndBooleanAcquire(Object o, long offset, boolean mask) {
2940         return byte2bool(getAndBitwiseAndByteAcquire(o, offset, bool2byte(mask)));
2941     }
2942 
2943     @ForceInline
2944     public final boolean getAndBitwiseXorBoolean(Object o, long offset, boolean mask) {
2945         return byte2bool(getAndBitwiseXorByte(o, offset, bool2byte(mask)));
2946     }
2947 
2948     @ForceInline
2949     public final boolean getAndBitwiseXorBooleanRelease(Object o, long offset, boolean mask) {
2950         return byte2bool(getAndBitwiseXorByteRelease(o, offset, bool2byte(mask)));
2951     }
2952 
2953     @ForceInline
2954     public final boolean getAndBitwiseXorBooleanAcquire(Object o, long offset, boolean mask) {
2955         return byte2bool(getAndBitwiseXorByteAcquire(o, offset, bool2byte(mask)));
2956     }
2957 
2958 
2959     @ForceInline
2960     public final byte getAndBitwiseOrByte(Object o, long offset, byte mask) {
2961         byte current;
2962         do {
2963             current = getByteVolatile(o, offset);
2964         } while (!weakCompareAndSetByte(o, offset,
2965                                                   current, (byte) (current | mask)));
2966         return current;
2967     }
2968 
2969     @ForceInline
2970     public final byte getAndBitwiseOrByteRelease(Object o, long offset, byte mask) {
2971         byte current;
2972         do {
2973             current = getByte(o, offset);
2974         } while (!weakCompareAndSetByteRelease(o, offset,
2975                                                  current, (byte) (current | mask)));
2976         return current;
2977     }
2978 
2979     @ForceInline
2980     public final byte getAndBitwiseOrByteAcquire(Object o, long offset, byte mask) {
2981         byte current;
2982         do {
2983             // Plain read, the value is a hint, the acquire CAS does the work
2984             current = getByte(o, offset);
2985         } while (!weakCompareAndSetByteAcquire(o, offset,
2986                                                  current, (byte) (current | mask)));
2987         return current;
2988     }
2989 
2990     @ForceInline
2991     public final byte getAndBitwiseAndByte(Object o, long offset, byte mask) {
2992         byte current;
2993         do {
2994             current = getByteVolatile(o, offset);
2995         } while (!weakCompareAndSetByte(o, offset,
2996                                                   current, (byte) (current &amp; mask)));
2997         return current;
2998     }
2999 
3000     @ForceInline
3001     public final byte getAndBitwiseAndByteRelease(Object o, long offset, byte mask) {
3002         byte current;
3003         do {
3004             current = getByte(o, offset);
3005         } while (!weakCompareAndSetByteRelease(o, offset,
3006                                                  current, (byte) (current &amp; mask)));
3007         return current;
3008     }
3009 
3010     @ForceInline
3011     public final byte getAndBitwiseAndByteAcquire(Object o, long offset, byte mask) {
3012         byte current;
3013         do {
3014             // Plain read, the value is a hint, the acquire CAS does the work
3015             current = getByte(o, offset);
3016         } while (!weakCompareAndSetByteAcquire(o, offset,
3017                                                  current, (byte) (current &amp; mask)));
3018         return current;
3019     }
3020 
3021     @ForceInline
3022     public final byte getAndBitwiseXorByte(Object o, long offset, byte mask) {
3023         byte current;
3024         do {
3025             current = getByteVolatile(o, offset);
3026         } while (!weakCompareAndSetByte(o, offset,
3027                                                   current, (byte) (current ^ mask)));
3028         return current;
3029     }
3030 
3031     @ForceInline
3032     public final byte getAndBitwiseXorByteRelease(Object o, long offset, byte mask) {
3033         byte current;
3034         do {
3035             current = getByte(o, offset);
3036         } while (!weakCompareAndSetByteRelease(o, offset,
3037                                                  current, (byte) (current ^ mask)));
3038         return current;
3039     }
3040 
3041     @ForceInline
3042     public final byte getAndBitwiseXorByteAcquire(Object o, long offset, byte mask) {
3043         byte current;
3044         do {
3045             // Plain read, the value is a hint, the acquire CAS does the work
3046             current = getByte(o, offset);
3047         } while (!weakCompareAndSetByteAcquire(o, offset,
3048                                                  current, (byte) (current ^ mask)));
3049         return current;
3050     }
3051 
3052 
3053     @ForceInline
3054     public final char getAndBitwiseOrChar(Object o, long offset, char mask) {
3055         return s2c(getAndBitwiseOrShort(o, offset, c2s(mask)));
3056     }
3057 
3058     @ForceInline
3059     public final char getAndBitwiseOrCharRelease(Object o, long offset, char mask) {
3060         return s2c(getAndBitwiseOrShortRelease(o, offset, c2s(mask)));
3061     }
3062 
3063     @ForceInline
3064     public final char getAndBitwiseOrCharAcquire(Object o, long offset, char mask) {
3065         return s2c(getAndBitwiseOrShortAcquire(o, offset, c2s(mask)));
3066     }
3067 
3068     @ForceInline
3069     public final char getAndBitwiseAndChar(Object o, long offset, char mask) {
3070         return s2c(getAndBitwiseAndShort(o, offset, c2s(mask)));
3071     }
3072 
3073     @ForceInline
3074     public final char getAndBitwiseAndCharRelease(Object o, long offset, char mask) {
3075         return s2c(getAndBitwiseAndShortRelease(o, offset, c2s(mask)));
3076     }
3077 
3078     @ForceInline
3079     public final char getAndBitwiseAndCharAcquire(Object o, long offset, char mask) {
3080         return s2c(getAndBitwiseAndShortAcquire(o, offset, c2s(mask)));
3081     }
3082 
3083     @ForceInline
3084     public final char getAndBitwiseXorChar(Object o, long offset, char mask) {
3085         return s2c(getAndBitwiseXorShort(o, offset, c2s(mask)));
3086     }
3087 
3088     @ForceInline
3089     public final char getAndBitwiseXorCharRelease(Object o, long offset, char mask) {
3090         return s2c(getAndBitwiseXorShortRelease(o, offset, c2s(mask)));
3091     }
3092 
3093     @ForceInline
3094     public final char getAndBitwiseXorCharAcquire(Object o, long offset, char mask) {
3095         return s2c(getAndBitwiseXorShortAcquire(o, offset, c2s(mask)));
3096     }
3097 
3098 
3099     @ForceInline
3100     public final short getAndBitwiseOrShort(Object o, long offset, short mask) {
3101         short current;
3102         do {
3103             current = getShortVolatile(o, offset);
3104         } while (!weakCompareAndSetShort(o, offset,
3105                                                 current, (short) (current | mask)));
3106         return current;
3107     }
3108 
3109     @ForceInline
3110     public final short getAndBitwiseOrShortRelease(Object o, long offset, short mask) {
3111         short current;
3112         do {
3113             current = getShort(o, offset);
3114         } while (!weakCompareAndSetShortRelease(o, offset,
3115                                                current, (short) (current | mask)));
3116         return current;
3117     }
3118 
3119     @ForceInline
3120     public final short getAndBitwiseOrShortAcquire(Object o, long offset, short mask) {
3121         short current;
3122         do {
3123             // Plain read, the value is a hint, the acquire CAS does the work
3124             current = getShort(o, offset);
3125         } while (!weakCompareAndSetShortAcquire(o, offset,
3126                                                current, (short) (current | mask)));
3127         return current;
3128     }
3129 
3130     @ForceInline
3131     public final short getAndBitwiseAndShort(Object o, long offset, short mask) {
3132         short current;
3133         do {
3134             current = getShortVolatile(o, offset);
3135         } while (!weakCompareAndSetShort(o, offset,
3136                                                 current, (short) (current &amp; mask)));
3137         return current;
3138     }
3139 
3140     @ForceInline
3141     public final short getAndBitwiseAndShortRelease(Object o, long offset, short mask) {
3142         short current;
3143         do {
3144             current = getShort(o, offset);
3145         } while (!weakCompareAndSetShortRelease(o, offset,
3146                                                current, (short) (current &amp; mask)));
3147         return current;
3148     }
3149 
3150     @ForceInline
3151     public final short getAndBitwiseAndShortAcquire(Object o, long offset, short mask) {
3152         short current;
3153         do {
3154             // Plain read, the value is a hint, the acquire CAS does the work
3155             current = getShort(o, offset);
3156         } while (!weakCompareAndSetShortAcquire(o, offset,
3157                                                current, (short) (current &amp; mask)));
3158         return current;
3159     }
3160 
3161     @ForceInline
3162     public final short getAndBitwiseXorShort(Object o, long offset, short mask) {
3163         short current;
3164         do {
3165             current = getShortVolatile(o, offset);
3166         } while (!weakCompareAndSetShort(o, offset,
3167                                                 current, (short) (current ^ mask)));
3168         return current;
3169     }
3170 
3171     @ForceInline
3172     public final short getAndBitwiseXorShortRelease(Object o, long offset, short mask) {
3173         short current;
3174         do {
3175             current = getShort(o, offset);
3176         } while (!weakCompareAndSetShortRelease(o, offset,
3177                                                current, (short) (current ^ mask)));
3178         return current;
3179     }
3180 
3181     @ForceInline
3182     public final short getAndBitwiseXorShortAcquire(Object o, long offset, short mask) {
3183         short current;
3184         do {
3185             // Plain read, the value is a hint, the acquire CAS does the work
3186             current = getShort(o, offset);
3187         } while (!weakCompareAndSetShortAcquire(o, offset,
3188                                                current, (short) (current ^ mask)));
3189         return current;
3190     }
3191 
3192 
3193     @ForceInline
3194     public final int getAndBitwiseOrInt(Object o, long offset, int mask) {
3195         int current;
3196         do {
3197             current = getIntVolatile(o, offset);
3198         } while (!weakCompareAndSetInt(o, offset,
3199                                                 current, current | mask));
3200         return current;
3201     }
3202 
3203     @ForceInline
3204     public final int getAndBitwiseOrIntRelease(Object o, long offset, int mask) {
3205         int current;
3206         do {
3207             current = getInt(o, offset);
3208         } while (!weakCompareAndSetIntRelease(o, offset,
3209                                                current, current | mask));
3210         return current;
3211     }
3212 
3213     @ForceInline
3214     public final int getAndBitwiseOrIntAcquire(Object o, long offset, int mask) {
3215         int current;
3216         do {
3217             // Plain read, the value is a hint, the acquire CAS does the work
3218             current = getInt(o, offset);
3219         } while (!weakCompareAndSetIntAcquire(o, offset,
3220                                                current, current | mask));
3221         return current;
3222     }
3223 
3224     /**
3225      * Atomically replaces the current value of a field or array element within
3226      * the given object with the result of bitwise AND between the current value
3227      * and mask.
3228      *
3229      * @param o object/array to update the field/element in
3230      * @param offset field/element offset
3231      * @param mask the mask value
3232      * @return the previous value
3233      * @since 9
3234      */
3235     @ForceInline
3236     public final int getAndBitwiseAndInt(Object o, long offset, int mask) {
3237         int current;
3238         do {
3239             current = getIntVolatile(o, offset);
3240         } while (!weakCompareAndSetInt(o, offset,
3241                                                 current, current &amp; mask));
3242         return current;
3243     }
3244 
3245     @ForceInline
3246     public final int getAndBitwiseAndIntRelease(Object o, long offset, int mask) {
3247         int current;
3248         do {
3249             current = getInt(o, offset);
3250         } while (!weakCompareAndSetIntRelease(o, offset,
3251                                                current, current &amp; mask));
3252         return current;
3253     }
3254 
3255     @ForceInline
3256     public final int getAndBitwiseAndIntAcquire(Object o, long offset, int mask) {
3257         int current;
3258         do {
3259             // Plain read, the value is a hint, the acquire CAS does the work
3260             current = getInt(o, offset);
3261         } while (!weakCompareAndSetIntAcquire(o, offset,
3262                                                current, current &amp; mask));
3263         return current;
3264     }
3265 
3266     @ForceInline
3267     public final int getAndBitwiseXorInt(Object o, long offset, int mask) {
3268         int current;
3269         do {
3270             current = getIntVolatile(o, offset);
3271         } while (!weakCompareAndSetInt(o, offset,
3272                                                 current, current ^ mask));
3273         return current;
3274     }
3275 
3276     @ForceInline
3277     public final int getAndBitwiseXorIntRelease(Object o, long offset, int mask) {
3278         int current;
3279         do {
3280             current = getInt(o, offset);
3281         } while (!weakCompareAndSetIntRelease(o, offset,
3282                                                current, current ^ mask));
3283         return current;
3284     }
3285 
3286     @ForceInline
3287     public final int getAndBitwiseXorIntAcquire(Object o, long offset, int mask) {
3288         int current;
3289         do {
3290             // Plain read, the value is a hint, the acquire CAS does the work
3291             current = getInt(o, offset);
3292         } while (!weakCompareAndSetIntAcquire(o, offset,
3293                                                current, current ^ mask));
3294         return current;
3295     }
3296 
3297 
3298     @ForceInline
3299     public final long getAndBitwiseOrLong(Object o, long offset, long mask) {
3300         long current;
3301         do {
3302             current = getLongVolatile(o, offset);
3303         } while (!weakCompareAndSetLong(o, offset,
3304                                                 current, current | mask));
3305         return current;
3306     }
3307 
3308     @ForceInline
3309     public final long getAndBitwiseOrLongRelease(Object o, long offset, long mask) {
3310         long current;
3311         do {
3312             current = getLong(o, offset);
3313         } while (!weakCompareAndSetLongRelease(o, offset,
3314                                                current, current | mask));
3315         return current;
3316     }
3317 
3318     @ForceInline
3319     public final long getAndBitwiseOrLongAcquire(Object o, long offset, long mask) {
3320         long current;
3321         do {
3322             // Plain read, the value is a hint, the acquire CAS does the work
3323             current = getLong(o, offset);
3324         } while (!weakCompareAndSetLongAcquire(o, offset,
3325                                                current, current | mask));
3326         return current;
3327     }
3328 
3329     @ForceInline
3330     public final long getAndBitwiseAndLong(Object o, long offset, long mask) {
3331         long current;
3332         do {
3333             current = getLongVolatile(o, offset);
3334         } while (!weakCompareAndSetLong(o, offset,
3335                                                 current, current &amp; mask));
3336         return current;
3337     }
3338 
3339     @ForceInline
3340     public final long getAndBitwiseAndLongRelease(Object o, long offset, long mask) {
3341         long current;
3342         do {
3343             current = getLong(o, offset);
3344         } while (!weakCompareAndSetLongRelease(o, offset,
3345                                                current, current &amp; mask));
3346         return current;
3347     }
3348 
3349     @ForceInline
3350     public final long getAndBitwiseAndLongAcquire(Object o, long offset, long mask) {
3351         long current;
3352         do {
3353             // Plain read, the value is a hint, the acquire CAS does the work
3354             current = getLong(o, offset);
3355         } while (!weakCompareAndSetLongAcquire(o, offset,
3356                                                current, current &amp; mask));
3357         return current;
3358     }
3359 
3360     @ForceInline
3361     public final long getAndBitwiseXorLong(Object o, long offset, long mask) {
3362         long current;
3363         do {
3364             current = getLongVolatile(o, offset);
3365         } while (!weakCompareAndSetLong(o, offset,
3366                                                 current, current ^ mask));
3367         return current;
3368     }
3369 
3370     @ForceInline
3371     public final long getAndBitwiseXorLongRelease(Object o, long offset, long mask) {
3372         long current;
3373         do {
3374             current = getLong(o, offset);
3375         } while (!weakCompareAndSetLongRelease(o, offset,
3376                                                current, current ^ mask));
3377         return current;
3378     }
3379 
3380     @ForceInline
3381     public final long getAndBitwiseXorLongAcquire(Object o, long offset, long mask) {
3382         long current;
3383         do {
3384             // Plain read, the value is a hint, the acquire CAS does the work
3385             current = getLong(o, offset);
3386         } while (!weakCompareAndSetLongAcquire(o, offset,
3387                                                current, current ^ mask));
3388         return current;
3389     }
3390 
3391 
3392 
3393     /**
3394      * Ensures that loads before the fence will not be reordered with loads and
3395      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
3396      *
3397      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
3398      * (an &quot;acquire fence&quot;).
3399      *
3400      * A pure LoadLoad fence is not provided, since the addition of LoadStore
3401      * is almost always desired, and most current hardware instructions that
3402      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
3403      * @since 1.8
3404      */
3405     @HotSpotIntrinsicCandidate
3406     public native void loadFence();
3407 
3408     /**
3409      * Ensures that loads and stores before the fence will not be reordered with
3410      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
3411      *
3412      * Corresponds to C11 atomic_thread_fence(memory_order_release)
3413      * (a &quot;release fence&quot;).
3414      *
3415      * A pure StoreStore fence is not provided, since the addition of LoadStore
3416      * is almost always desired, and most current hardware instructions that
3417      * provide a StoreStore barrier also provide a LoadStore barrier for free.
3418      * @since 1.8
3419      */
3420     @HotSpotIntrinsicCandidate
3421     public native void storeFence();
3422 
3423     /**
3424      * Ensures that loads and stores before the fence will not be reordered
3425      * with loads and stores after the fence.  Implies the effects of both
3426      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
3427      * barrier.
3428      *
3429      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
3430      * @since 1.8
3431      */
3432     @HotSpotIntrinsicCandidate
3433     public native void fullFence();
3434 
3435     /**
3436      * Ensures that loads before the fence will not be reordered with
3437      * loads after the fence.
3438      */
3439     public final void loadLoadFence() {
3440         loadFence();
3441     }
3442 
3443     /**
3444      * Ensures that stores before the fence will not be reordered with
3445      * stores after the fence.
3446      */
3447     public final void storeStoreFence() {
3448         storeFence();
3449     }
3450 
3451 
3452     /**
3453      * Throws IllegalAccessError; for use by the VM for access control
3454      * error support.
3455      * @since 1.8
3456      */
3457     private static void throwIllegalAccessError() {
3458         throw new IllegalAccessError();
3459     }
3460 
3461     /**
3462      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3463      * @since 13
3464      */
3465     private static void throwNoSuchMethodError() {
3466         throw new NoSuchMethodError();
3467     }
3468 
3469     /**
3470      * @return Returns true if the native byte ordering of this
3471      * platform is big-endian, false if it is little-endian.
3472      */
3473     public final boolean isBigEndian() { return BIG_ENDIAN; }
3474 
3475     /**
3476      * @return Returns true if this platform is capable of performing
3477      * accesses at addresses which are not aligned for the type of the
3478      * primitive type being accessed, false otherwise.
3479      */
3480     public final boolean unalignedAccess() { return UNALIGNED_ACCESS; }
3481 
3482     /**
3483      * Fetches a value at some byte offset into a given Java object.
3484      * More specifically, fetches a value within the given object
3485      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3486      * null) from the memory address whose numerical value is the
3487      * given offset.  &lt;p&gt;
3488      *
3489      * The specification of this method is the same as {@link
3490      * #getLong(Object, long)} except that the offset does not need to
3491      * have been obtained from {@link #objectFieldOffset} on the
3492      * {@link java.lang.reflect.Field} of some Java field.  The value
3493      * in memory is raw data, and need not correspond to any Java
3494      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3495      * must be entirely within the allocated object.  The endianness
3496      * of the value in memory is the endianness of the native platform.
3497      *
3498      * &lt;p&gt; The read will be atomic with respect to the largest power
3499      * of two that divides the GCD of the offset and the storage size.
3500      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
3501      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3502      * respectively.  There are no other guarantees of atomicity.
3503      * &lt;p&gt;
3504      * 8-byte atomicity is only guaranteed on platforms on which
3505      * support atomic accesses to longs.
3506      *
3507      * @param o Java heap object in which the value resides, if any, else
3508      *        null
3509      * @param offset The offset in bytes from the start of the object
3510      * @return the value fetched from the indicated object
3511      * @throws RuntimeException No defined exceptions are thrown, not even
3512      *         {@link NullPointerException}
3513      * @since 9
3514      */
3515     @HotSpotIntrinsicCandidate
3516     public final long getLongUnaligned(Object o, long offset) {
3517         if ((offset &amp; 7) == 0) {
3518             return getLong(o, offset);
3519         } else if ((offset &amp; 3) == 0) {
3520             return makeLong(getInt(o, offset),
3521                             getInt(o, offset + 4));
3522         } else if ((offset &amp; 1) == 0) {
3523             return makeLong(getShort(o, offset),
3524                             getShort(o, offset + 2),
3525                             getShort(o, offset + 4),
3526                             getShort(o, offset + 6));
3527         } else {
3528             return makeLong(getByte(o, offset),
3529                             getByte(o, offset + 1),
3530                             getByte(o, offset + 2),
3531                             getByte(o, offset + 3),
3532                             getByte(o, offset + 4),
3533                             getByte(o, offset + 5),
3534                             getByte(o, offset + 6),
3535                             getByte(o, offset + 7));
3536         }
3537     }
3538     /**
3539      * As {@link #getLongUnaligned(Object, long)} but with an
3540      * additional argument which specifies the endianness of the value
3541      * as stored in memory.
3542      *
3543      * @param o Java heap object in which the variable resides
3544      * @param offset The offset in bytes from the start of the object
3545      * @param bigEndian The endianness of the value
3546      * @return the value fetched from the indicated object
3547      * @since 9
3548      */
3549     public final long getLongUnaligned(Object o, long offset, boolean bigEndian) {
3550         return convEndian(bigEndian, getLongUnaligned(o, offset));
3551     }
3552 
3553     /** @see #getLongUnaligned(Object, long) */
3554     @HotSpotIntrinsicCandidate
3555     public final int getIntUnaligned(Object o, long offset) {
3556         if ((offset &amp; 3) == 0) {
3557             return getInt(o, offset);
3558         } else if ((offset &amp; 1) == 0) {
3559             return makeInt(getShort(o, offset),
3560                            getShort(o, offset + 2));
3561         } else {
3562             return makeInt(getByte(o, offset),
3563                            getByte(o, offset + 1),
3564                            getByte(o, offset + 2),
3565                            getByte(o, offset + 3));
3566         }
3567     }
3568     /** @see #getLongUnaligned(Object, long, boolean) */
3569     public final int getIntUnaligned(Object o, long offset, boolean bigEndian) {
3570         return convEndian(bigEndian, getIntUnaligned(o, offset));
3571     }
3572 
3573     /** @see #getLongUnaligned(Object, long) */
3574     @HotSpotIntrinsicCandidate
3575     public final short getShortUnaligned(Object o, long offset) {
3576         if ((offset &amp; 1) == 0) {
3577             return getShort(o, offset);
3578         } else {
3579             return makeShort(getByte(o, offset),
3580                              getByte(o, offset + 1));
3581         }
3582     }
3583     /** @see #getLongUnaligned(Object, long, boolean) */
3584     public final short getShortUnaligned(Object o, long offset, boolean bigEndian) {
3585         return convEndian(bigEndian, getShortUnaligned(o, offset));
3586     }
3587 
3588     /** @see #getLongUnaligned(Object, long) */
3589     @HotSpotIntrinsicCandidate
3590     public final char getCharUnaligned(Object o, long offset) {
3591         if ((offset &amp; 1) == 0) {
3592             return getChar(o, offset);
3593         } else {
3594             return (char)makeShort(getByte(o, offset),
3595                                    getByte(o, offset + 1));
3596         }
3597     }
3598 
3599     /** @see #getLongUnaligned(Object, long, boolean) */
3600     public final char getCharUnaligned(Object o, long offset, boolean bigEndian) {
3601         return convEndian(bigEndian, getCharUnaligned(o, offset));
3602     }
3603 
3604     /**
3605      * Stores a value at some byte offset into a given Java object.
3606      * &lt;p&gt;
3607      * The specification of this method is the same as {@link
3608      * #getLong(Object, long)} except that the offset does not need to
3609      * have been obtained from {@link #objectFieldOffset} on the
3610      * {@link java.lang.reflect.Field} of some Java field.  The value
3611      * in memory is raw data, and need not correspond to any Java
3612      * variable.  The endianness of the value in memory is the
3613      * endianness of the native platform.
3614      * &lt;p&gt;
3615      * The write will be atomic with respect to the largest power of
3616      * two that divides the GCD of the offset and the storage size.
3617      * For example, putLongUnaligned will make atomic writes of 2-, 4-,
3618      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3619      * respectively.  There are no other guarantees of atomicity.
3620      * &lt;p&gt;
3621      * 8-byte atomicity is only guaranteed on platforms on which
3622      * support atomic accesses to longs.
3623      *
3624      * @param o Java heap object in which the value resides, if any, else
3625      *        null
3626      * @param offset The offset in bytes from the start of the object
3627      * @param x the value to store
3628      * @throws RuntimeException No defined exceptions are thrown, not even
3629      *         {@link NullPointerException}
3630      * @since 9
3631      */
3632     @HotSpotIntrinsicCandidate
3633     public final void putLongUnaligned(Object o, long offset, long x) {
3634         if ((offset &amp; 7) == 0) {
3635             putLong(o, offset, x);
3636         } else if ((offset &amp; 3) == 0) {
3637             putLongParts(o, offset,
3638                          (int)(x &gt;&gt; 0),
3639                          (int)(x &gt;&gt;&gt; 32));
3640         } else if ((offset &amp; 1) == 0) {
3641             putLongParts(o, offset,
3642                          (short)(x &gt;&gt;&gt; 0),
3643                          (short)(x &gt;&gt;&gt; 16),
3644                          (short)(x &gt;&gt;&gt; 32),
3645                          (short)(x &gt;&gt;&gt; 48));
3646         } else {
3647             putLongParts(o, offset,
3648                          (byte)(x &gt;&gt;&gt; 0),
3649                          (byte)(x &gt;&gt;&gt; 8),
3650                          (byte)(x &gt;&gt;&gt; 16),
3651                          (byte)(x &gt;&gt;&gt; 24),
3652                          (byte)(x &gt;&gt;&gt; 32),
3653                          (byte)(x &gt;&gt;&gt; 40),
3654                          (byte)(x &gt;&gt;&gt; 48),
3655                          (byte)(x &gt;&gt;&gt; 56));
3656         }
3657     }
3658 
3659     /**
3660      * As {@link #putLongUnaligned(Object, long, long)} but with an additional
3661      * argument which specifies the endianness of the value as stored in memory.
3662      * @param o Java heap object in which the value resides
3663      * @param offset The offset in bytes from the start of the object
3664      * @param x the value to store
3665      * @param bigEndian The endianness of the value
3666      * @throws RuntimeException No defined exceptions are thrown, not even
3667      *         {@link NullPointerException}
3668      * @since 9
3669      */
3670     public final void putLongUnaligned(Object o, long offset, long x, boolean bigEndian) {
3671         putLongUnaligned(o, offset, convEndian(bigEndian, x));
3672     }
3673 
3674     /** @see #putLongUnaligned(Object, long, long) */
3675     @HotSpotIntrinsicCandidate
3676     public final void putIntUnaligned(Object o, long offset, int x) {
3677         if ((offset &amp; 3) == 0) {
3678             putInt(o, offset, x);
3679         } else if ((offset &amp; 1) == 0) {
3680             putIntParts(o, offset,
3681                         (short)(x &gt;&gt; 0),
3682                         (short)(x &gt;&gt;&gt; 16));
3683         } else {
3684             putIntParts(o, offset,
3685                         (byte)(x &gt;&gt;&gt; 0),
3686                         (byte)(x &gt;&gt;&gt; 8),
3687                         (byte)(x &gt;&gt;&gt; 16),
3688                         (byte)(x &gt;&gt;&gt; 24));
3689         }
3690     }
3691     /** @see #putLongUnaligned(Object, long, long, boolean) */
3692     public final void putIntUnaligned(Object o, long offset, int x, boolean bigEndian) {
3693         putIntUnaligned(o, offset, convEndian(bigEndian, x));
3694     }
3695 
3696     /** @see #putLongUnaligned(Object, long, long) */
3697     @HotSpotIntrinsicCandidate
3698     public final void putShortUnaligned(Object o, long offset, short x) {
3699         if ((offset &amp; 1) == 0) {
3700             putShort(o, offset, x);
3701         } else {
3702             putShortParts(o, offset,
3703                           (byte)(x &gt;&gt;&gt; 0),
3704                           (byte)(x &gt;&gt;&gt; 8));
3705         }
3706     }
3707     /** @see #putLongUnaligned(Object, long, long, boolean) */
3708     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
3709         putShortUnaligned(o, offset, convEndian(bigEndian, x));
3710     }
3711 
3712     /** @see #putLongUnaligned(Object, long, long) */
3713     @HotSpotIntrinsicCandidate
3714     public final void putCharUnaligned(Object o, long offset, char x) {
3715         putShortUnaligned(o, offset, (short)x);
3716     }
3717     /** @see #putLongUnaligned(Object, long, long, boolean) */
3718     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
3719         putCharUnaligned(o, offset, convEndian(bigEndian, x));
3720     }
3721 
3722     private static int pickPos(int top, int pos) { return BIG_ENDIAN ? top - pos : pos; }
3723 
3724     // These methods construct integers from bytes.  The byte ordering
3725     // is the native endianness of this platform.
3726     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3727         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
3728               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
3729               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
3730               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
3731               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
3732               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
3733               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
3734               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
3735     }
3736     private static long makeLong(short i0, short i1, short i2, short i3) {
3737         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
3738               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
3739               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
3740               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
3741     }
3742     private static long makeLong(int i0, int i1) {
3743         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
3744              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
3745     }
3746     private static int makeInt(short i0, short i1) {
3747         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
3748              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
3749     }
3750     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
3751         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
3752               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
3753               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
3754               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
3755     }
3756     private static short makeShort(byte i0, byte i1) {
3757         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
3758                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
3759     }
3760 
3761     private static byte  pick(byte  le, byte  be) { return BIG_ENDIAN ? be : le; }
3762     private static short pick(short le, short be) { return BIG_ENDIAN ? be : le; }
3763     private static int   pick(int   le, int   be) { return BIG_ENDIAN ? be : le; }
3764 
3765     // These methods write integers to memory from smaller parts
3766     // provided by their caller.  The ordering in which these parts
3767     // are written is the native endianness of this platform.
3768     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
3769         putByte(o, offset + 0, pick(i0, i7));
3770         putByte(o, offset + 1, pick(i1, i6));
3771         putByte(o, offset + 2, pick(i2, i5));
3772         putByte(o, offset + 3, pick(i3, i4));
3773         putByte(o, offset + 4, pick(i4, i3));
3774         putByte(o, offset + 5, pick(i5, i2));
3775         putByte(o, offset + 6, pick(i6, i1));
3776         putByte(o, offset + 7, pick(i7, i0));
3777     }
3778     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
3779         putShort(o, offset + 0, pick(i0, i3));
3780         putShort(o, offset + 2, pick(i1, i2));
3781         putShort(o, offset + 4, pick(i2, i1));
3782         putShort(o, offset + 6, pick(i3, i0));
3783     }
3784     private void putLongParts(Object o, long offset, int i0, int i1) {
3785         putInt(o, offset + 0, pick(i0, i1));
3786         putInt(o, offset + 4, pick(i1, i0));
3787     }
3788     private void putIntParts(Object o, long offset, short i0, short i1) {
3789         putShort(o, offset + 0, pick(i0, i1));
3790         putShort(o, offset + 2, pick(i1, i0));
3791     }
3792     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
3793         putByte(o, offset + 0, pick(i0, i3));
3794         putByte(o, offset + 1, pick(i1, i2));
3795         putByte(o, offset + 2, pick(i2, i1));
3796         putByte(o, offset + 3, pick(i3, i0));
3797     }
3798     private void putShortParts(Object o, long offset, byte i0, byte i1) {
3799         putByte(o, offset + 0, pick(i0, i1));
3800         putByte(o, offset + 1, pick(i1, i0));
3801     }
3802 
3803     // Zero-extend an integer
3804     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
3805     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
3806     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
3807     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
3808     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
3809 
3810     // Maybe byte-reverse an integer
3811     private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }
3812     private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }
3813     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }
3814     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }
3815 
3816 
3817 
3818     private native long allocateMemory0(long bytes);
3819     private native long reallocateMemory0(long address, long bytes);
3820     private native void freeMemory0(long address);
3821     private native void setMemory0(Object o, long offset, long bytes, byte value);
3822     @HotSpotIntrinsicCandidate
3823     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
3824     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
3825     private native long objectFieldOffset0(Field f);
3826     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
3827     private native long staticFieldOffset0(Field f);
3828     private native Object staticFieldBase0(Field f);
3829     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
3830     private native void ensureClassInitialized0(Class&lt;?&gt; c);
3831     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
3832     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
3833     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
3834     private native int getLoadAverage0(double[] loadavg, int nelems);
3835 
3836 
3837     /**
3838      * Invokes the given direct byte buffer&#39;s cleaner, if any.
3839      *
3840      * @param directBuffer a direct byte buffer
3841      * @throws NullPointerException     if {@code directBuffer} is null
3842      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
3843      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
3844      *                                  {@link java.nio.Buffer#duplicate duplicate}
3845      */
3846     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
3847         if (!directBuffer.isDirect())
3848             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
3849 
3850         DirectBuffer db = (DirectBuffer) directBuffer;
3851         if (db.attachment() != null)
3852             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
3853 
3854         Cleaner cleaner = db.cleaner();
3855         if (cleaner != null) {
3856             cleaner.clean();
3857         }
3858     }
3859 
3860     // The following deprecated methods are used by JSR 166.
3861 
3862     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3863     public final Object getObject(Object o, long offset) {
3864         return getReference(o, offset);
3865     }
3866     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3867     public final Object getObjectVolatile(Object o, long offset) {
3868         return getReferenceVolatile(o, offset);
3869     }
3870     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3871     public final Object getObjectAcquire(Object o, long offset) {
3872         return getReferenceAcquire(o, offset);
3873     }
3874     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3875     public final Object getObjectOpaque(Object o, long offset) {
3876         return getReferenceOpaque(o, offset);
3877     }
3878 
3879 
3880     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3881     public final void putObject(Object o, long offset, Object x) {
3882         putReference(o, offset, x);
3883     }
3884     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3885     public final void putObjectVolatile(Object o, long offset, Object x) {
3886         putReferenceVolatile(o, offset, x);
3887     }
3888     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3889     public final void putObjectOpaque(Object o, long offset, Object x) {
3890         putReferenceOpaque(o, offset, x);
3891     }
3892     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3893     public final void putObjectRelease(Object o, long offset, Object x) {
3894         putReferenceRelease(o, offset, x);
3895     }
3896 
3897 
3898     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3899     public final Object getAndSetObject(Object o, long offset, Object newValue) {
3900         return getAndSetReference(o, offset, newValue);
3901     }
3902     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3903     public final Object getAndSetObjectAcquire(Object o, long offset, Object newValue) {
3904         return getAndSetReferenceAcquire(o, offset, newValue);
3905     }
3906     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3907     public final Object getAndSetObjectRelease(Object o, long offset, Object newValue) {
3908         return getAndSetReferenceRelease(o, offset, newValue);
3909     }
3910 
3911 
3912     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3913     public final boolean compareAndSetObject(Object o, long offset, Object expected, Object x) {
3914         return compareAndSetReference(o, offset, expected, x);
3915     }
3916     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3917     public final Object compareAndExchangeObject(Object o, long offset, Object expected, Object x) {
3918         return compareAndExchangeReference(o, offset, expected, x);
3919     }
3920     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3921     public final Object compareAndExchangeObjectAcquire(Object o, long offset, Object expected, Object x) {
3922         return compareAndExchangeReferenceAcquire(o, offset, expected, x);
3923     }
3924     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3925     public final Object compareAndExchangeObjectRelease(Object o, long offset, Object expected, Object x) {
3926         return compareAndExchangeReferenceRelease(o, offset, expected, x);
3927     }
3928 
3929 
3930     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3931     public final boolean weakCompareAndSetObject(Object o, long offset, Object expected, Object x) {
3932         return weakCompareAndSetReference(o, offset, expected, x);
3933     }
3934     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3935     public final boolean weakCompareAndSetObjectAcquire(Object o, long offset, Object expected, Object x) {
3936         return weakCompareAndSetReferenceAcquire(o, offset, expected, x);
3937     }
3938     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3939     public final boolean weakCompareAndSetObjectPlain(Object o, long offset, Object expected, Object x) {
3940         return weakCompareAndSetReferencePlain(o, offset, expected, x);
3941     }
3942     @Deprecated(since=&quot;12&quot;, forRemoval=true)
3943     public final boolean weakCompareAndSetObjectRelease(Object o, long offset, Object expected, Object x) {
3944         return weakCompareAndSetReferenceRelease(o, offset, expected, x);
3945     }
3946 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>