<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.*;
  36 import java.util.AbstractMap.SimpleEntry;
  37 import java.util.Map.Entry;
  38 import java.util.function.Predicate;
  39 import java.util.stream.Collectors;
  40 
  41 import javax.lang.model.SourceVersion;
  42 import javax.lang.model.element.AnnotationMirror;
  43 import javax.lang.model.element.AnnotationValue;
  44 import javax.lang.model.element.Element;
  45 import javax.lang.model.element.ElementKind;
  46 import javax.lang.model.element.ExecutableElement;
  47 import javax.lang.model.element.Modifier;
  48 import javax.lang.model.element.ModuleElement;
  49 import javax.lang.model.element.ModuleElement.RequiresDirective;
  50 import javax.lang.model.element.PackageElement;
  51 import javax.lang.model.element.RecordComponentElement;
  52 import javax.lang.model.element.TypeElement;
  53 import javax.lang.model.element.TypeParameterElement;
  54 import javax.lang.model.element.VariableElement;
  55 import javax.lang.model.type.ArrayType;
  56 import javax.lang.model.type.DeclaredType;
  57 import javax.lang.model.type.ErrorType;
  58 import javax.lang.model.type.ExecutableType;
  59 import javax.lang.model.type.NoType;
  60 import javax.lang.model.type.PrimitiveType;
  61 import javax.lang.model.type.TypeMirror;
  62 import javax.lang.model.type.TypeVariable;
  63 import javax.lang.model.type.WildcardType;
  64 import javax.lang.model.util.ElementFilter;
  65 import javax.lang.model.util.ElementKindVisitor14;
  66 import javax.lang.model.util.Elements;
  67 import javax.lang.model.util.SimpleElementVisitor14;
  68 import javax.lang.model.util.SimpleTypeVisitor9;
  69 import javax.lang.model.util.TypeKindVisitor9;
  70 import javax.lang.model.util.Types;
  71 import javax.tools.FileObject;
  72 import javax.tools.JavaFileManager;
  73 import javax.tools.JavaFileManager.Location;
  74 import javax.tools.StandardLocation;
  75 
  76 import com.sun.source.doctree.DocCommentTree;
  77 import com.sun.source.doctree.DocTree;
  78 import com.sun.source.doctree.DocTree.Kind;
  79 import com.sun.source.doctree.ParamTree;
  80 import com.sun.source.doctree.SerialFieldTree;
  81 import com.sun.source.doctree.UnknownBlockTagTree;
  82 import com.sun.source.tree.CompilationUnitTree;
  83 import com.sun.source.tree.LineMap;
  84 import com.sun.source.util.DocSourcePositions;
  85 import com.sun.source.util.DocTrees;
  86 import com.sun.source.util.TreePath;
  87 import com.sun.tools.javac.model.JavacTypes;
  88 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
  89 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
  90 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
  91 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
  92 import jdk.javadoc.internal.doclets.toolkit.Messages;
  93 import jdk.javadoc.internal.doclets.toolkit.Resources;
  94 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
  95 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
  97 import jdk.javadoc.internal.tool.DocEnvImpl;
  98 
  99 import static javax.lang.model.element.ElementKind.*;
 100 import static javax.lang.model.element.Modifier.*;
 101 import static javax.lang.model.type.TypeKind.*;
 102 
 103 import static com.sun.source.doctree.DocTree.Kind.*;
 104 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 105 
 106 /**
 107  * Utilities Class for Doclets.
 108  *
 109  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 110  *  If you write code that depends on this, you do so at your own risk.
 111  *  This code and its internal interfaces are subject to change or
 112  *  deletion without notice.&lt;/b&gt;
 113  */
 114 public class Utils {
 115     public final BaseConfiguration configuration;
 116     private final BaseOptions options;
 117     private final Messages messages;
 118     private final Resources resources;
 119     public final DocTrees docTrees;
 120     public final Elements elementUtils;
 121     public final Types typeUtils;
 122     private final JavaScriptScanner javaScriptScanner;
 123 
 124     public Utils(BaseConfiguration c) {
 125         configuration = c;
 126         options = configuration.getOptions();
 127         messages = configuration.getMessages();
 128         resources = configuration.getResources();
 129         elementUtils = c.docEnv.getElementUtils();
 130         typeUtils = c.docEnv.getTypeUtils();
 131         docTrees = c.docEnv.getDocTrees();
 132         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 133     }
 134 
 135     // our own little symbol table
 136     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 137 
 138     public TypeMirror getSymbol(String signature) {
 139         TypeMirror type = symtab.get(signature);
 140         if (type == null) {
 141             TypeElement typeElement = elementUtils.getTypeElement(signature);
 142             if (typeElement == null)
 143                 return null;
 144             type = typeElement.asType();
 145             if (type == null)
 146                 return null;
 147             symtab.put(signature, type);
 148         }
 149         return type;
 150     }
 151 
 152     public TypeMirror getObjectType() {
 153         return getSymbol(&quot;java.lang.Object&quot;);
 154     }
 155 
 156     public TypeMirror getExceptionType() {
 157         return getSymbol(&quot;java.lang.Exception&quot;);
 158     }
 159 
 160     public TypeMirror getErrorType() {
 161         return getSymbol(&quot;java.lang.Error&quot;);
 162     }
 163 
 164     public TypeMirror getSerializableType() {
 165         return getSymbol(&quot;java.io.Serializable&quot;);
 166     }
 167 
 168     public TypeMirror getExternalizableType() {
 169         return getSymbol(&quot;java.io.Externalizable&quot;);
 170     }
 171 
 172     public TypeMirror getIllegalArgumentExceptionType() {
 173         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 174     }
 175 
 176     public TypeMirror getNullPointerExceptionType() {
 177         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 178     }
 179 
 180     public TypeMirror getDeprecatedType() {
 181         return getSymbol(&quot;java.lang.Deprecated&quot;);
 182     }
 183 
 184     public TypeMirror getFunctionalInterface() {
 185         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 186     }
 187 
 188     /**
 189      * Return array of class members whose documentation is to be generated.
 190      * If the member is deprecated do not include such a member in the
 191      * returned array.
 192      *
 193      * @param  members    Array of members to choose from.
 194      * @return List       List of eligible members for whom
 195      *                    documentation is getting generated.
 196      */
 197     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 198         List&lt;Element&gt; excludeList = members.stream()
 199                 .filter((member) -&gt; (!isDeprecated(member)))
 200                 .sorted(makeGeneralPurposeComparator())
 201                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));
 202         return excludeList;
 203     }
 204 
 205     /**
 206      * Search for the given method in the given class.
 207      *
 208      * @param  te        Class to search into.
 209      * @param  method    Method to be searched.
 210      * @return ExecutableElement Method found, null otherwise.
 211      */
 212     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 213         for (Element m : getMethods(te)) {
 214             if (executableMembersEqual(method, (ExecutableElement)m)) {
 215                 return (ExecutableElement)m;
 216             }
 217         }
 218         return null;
 219     }
 220 
 221     /**
 222      * Test whether a class is a subclass of another class.
 223      *
 224      * @param t1 the candidate superclass.
 225      * @param t2 the target
 226      * @return true if t1 is a superclass of t2.
 227      */
 228     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 229         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 230     }
 231 
 232     /**
 233      * @param e1 the first method to compare.
 234      * @param e2 the second method to compare.
 235      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 236      */
 237 
 238     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 239         // TODO: investigate if Elements.hides(..) will work here.
 240         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 241             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 242             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 243             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 244                     parameters1.size() == parameters2.size()) {
 245                 int j;
 246                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 247                     VariableElement v1 = parameters1.get(j);
 248                     VariableElement v2 = parameters2.get(j);
 249                     String t1 = getTypeName(v1.asType(), true);
 250                     String t2 = getTypeName(v2.asType(), true);
 251                     if (!(t1.equals(t2) ||
 252                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 253                         break;
 254                     }
 255                 }
 256                 if (j == parameters1.size()) {
 257                 return true;
 258                 }
 259             }
 260             return false;
 261         } else {
 262             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 263                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 264                     e1.equals(e2);
 265         }
 266     }
 267 
 268     /**
 269      * According to
 270      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 271      * all the outer classes and static inner classes are core classes.
 272      */
 273     public boolean isCoreClass(TypeElement e) {
 274         return getEnclosingTypeElement(e) == null || isStatic(e);
 275     }
 276 
 277     public Location getLocationForPackage(PackageElement pd) {
 278         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 279 
 280         if (mdle == null)
 281             return defaultLocation();
 282 
 283         return getLocationForModule(mdle);
 284     }
 285 
 286     public Location getLocationForModule(ModuleElement mdle) {
 287         Location loc = configuration.workArounds.getLocationForModule(mdle);
 288         if (loc != null)
 289             return loc;
 290 
 291         return defaultLocation();
 292     }
 293 
 294     private Location defaultLocation() {
 295         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 296         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 297                 ? StandardLocation.SOURCE_PATH
 298                 : StandardLocation.CLASS_PATH;
 299     }
 300 
 301     public boolean isAnnotated(TypeMirror e) {
 302         return !e.getAnnotationMirrors().isEmpty();
 303     }
 304 
 305     public boolean isAnnotated(Element e) {
 306         return !e.getAnnotationMirrors().isEmpty();
 307     }
 308 
 309     @SuppressWarnings(&quot;preview&quot;)
 310     public boolean isAnnotationType(Element e) {
 311         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 312             @Override
 313             public Boolean visitExecutable(ExecutableElement e, Void p) {
 314                 return visit(e.getEnclosingElement());
 315             }
 316 
 317             @Override
 318             public Boolean visitUnknown(Element e, Void p) {
 319                 return false;
 320             }
 321 
 322             @Override
 323             protected Boolean defaultAction(Element e, Void p) {
 324                 return e.getKind() == ANNOTATION_TYPE;
 325             }
 326         }.visit(e);
 327     }
 328 
 329     /**
 330      * An Enum implementation is almost identical, thus this method returns if
 331      * this element represents a CLASS or an ENUM
 332      * @param e element
 333      * @return true if class or enum
 334      */
 335     public boolean isClass(Element e) {
 336         return e.getKind().isClass();
 337     }
 338 
 339     public boolean isConstructor(Element e) {
 340          return e.getKind() == CONSTRUCTOR;
 341     }
 342 
 343     public boolean isEnum(Element e) {
 344         return e.getKind() == ENUM;
 345     }
 346 
 347     boolean isEnumConstant(Element e) {
 348         return e.getKind() == ENUM_CONSTANT;
 349     }
 350 
 351     public boolean isField(Element e) {
 352         return e.getKind() == FIELD;
 353     }
 354 
 355     public boolean isInterface(Element e) {
 356         return e.getKind() == INTERFACE;
 357     }
 358 
 359     public boolean isMethod(Element e) {
 360         return e.getKind() == METHOD;
 361     }
 362 
 363     public boolean isModule(Element e) {
 364         return e.getKind() == ElementKind.MODULE;
 365     }
 366 
 367     public boolean isPackage(Element e) {
 368         return e.getKind() == ElementKind.PACKAGE;
 369     }
 370 
 371     public boolean isAbstract(Element e) {
 372         return e.getModifiers().contains(Modifier.ABSTRACT);
 373     }
 374 
 375     public boolean isDefault(Element e) {
 376         return e.getModifiers().contains(Modifier.DEFAULT);
 377     }
 378 
 379     public boolean isPackagePrivate(Element e) {
 380         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 381     }
 382 
 383     public boolean isPrivate(Element e) {
 384         return e.getModifiers().contains(Modifier.PRIVATE);
 385     }
 386 
 387     public boolean isProtected(Element e) {
 388         return e.getModifiers().contains(Modifier.PROTECTED);
 389     }
 390 
 391     public boolean isPublic(Element e) {
 392         return e.getModifiers().contains(Modifier.PUBLIC);
 393     }
 394 
 395     public boolean isProperty(String name) {
 396         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 397     }
 398 
 399     public String getPropertyName(String name) {
 400         return isProperty(name)
 401                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 402                 : name;
 403     }
 404 
 405     public String getPropertyLabel(String name) {
 406         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 407     }
 408 
 409     public boolean isOverviewElement(Element e) {
 410         return e.getKind() == ElementKind.OTHER;
 411     }
 412 
 413     public boolean isStatic(Element e) {
 414         return e.getModifiers().contains(Modifier.STATIC);
 415     }
 416 
 417     public boolean isSerializable(TypeElement e) {
 418         return typeUtils.isSubtype(e.asType(), getSerializableType());
 419     }
 420 
 421     public boolean isExternalizable(TypeElement e) {
 422         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 423     }
 424 
 425     @SuppressWarnings(&quot;preview&quot;)
 426     public boolean isRecord(TypeElement e) {
 427         return e.getKind() == ElementKind.RECORD;
 428     }
 429 
 430     @SuppressWarnings(&quot;preview&quot;)
 431     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 432         TypeElement te = (TypeElement) ee.getEnclosingElement();
 433         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 434         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 435         if (stateComps.size() != params.size()) {
 436             return false;
 437         }
 438 
 439         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 440         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 441         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 442             VariableElement param = paramIter.next();
 443             RecordComponentElement comp = stateIter.next();
 444             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 445                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 446                 return false;
 447             }
 448         }
 449 
 450         return true;
 451     }
 452 
 453     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 454         return configuration.workArounds.getSerializableFields(aclass);
 455     }
 456 
 457     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 458         return configuration.workArounds.getSerializationMethods(aclass);
 459     }
 460 
 461     public boolean definesSerializableFields(TypeElement aclass) {
 462         return configuration.workArounds.definesSerializableFields( aclass);
 463     }
 464 
 465     @SuppressWarnings(&quot;preview&quot;)
 466     public String modifiersToString(Element e, boolean trailingSpace) {
 467         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 468         modifiers.remove(NATIVE);
 469         modifiers.remove(STRICTFP);
 470         modifiers.remove(SYNCHRONIZED);
 471 
 472         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 473             final StringBuilder sb = new StringBuilder();
 474 
 475             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 476                 if (modifiers.contains(PUBLIC)) {
 477                     append(&quot;public&quot;);
 478                 } else if (modifiers.contains(PROTECTED)) {
 479                     append(&quot;protected&quot;);
 480                 } else if (modifiers.contains(PRIVATE)) {
 481                     append(&quot;private&quot;);
 482                 }
 483             }
 484 
 485             void addStatic(Set&lt;Modifier&gt; modifiers) {
 486                 if (modifiers.contains(STATIC)) {
 487                     append(&quot;static&quot;);
 488                 }
 489             }
 490 
 491             void addModifiers(Set&lt;Modifier&gt; modifiers) {
 492                 modifiers.stream().map(Modifier::toString).forEach(this::append);
 493             }
 494 
 495             void append(String s) {
 496                 if (sb.length() &gt; 0) {
 497                     sb.append(&quot; &quot;);
 498                 }
 499                 sb.append(s);
 500             }
 501 
 502             String finalString(String s) {
 503                 append(s);
 504                 if (trailingSpace) {
 505                     sb.append(&quot; &quot;);
 506                     }
 507                 return sb.toString();
 508             }
 509 
 510             @Override
 511             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 512                 addVisibilityModifier(mods);
 513                 addStatic(mods);
 514                 return finalString(&quot;interface&quot;);
 515             }
 516 
 517             @Override
 518             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 519                 addVisibilityModifier(mods);
 520                 addStatic(mods);
 521                 return finalString(&quot;enum&quot;);
 522             }
 523 
 524             @Override
 525             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 526                 addVisibilityModifier(mods);
 527                 addStatic(mods);
 528                 return finalString(&quot;@interface&quot;);
 529             }
 530 
 531             @Override
 532             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 533                 mods.remove(FINAL); // suppress the implicit `final`
 534                 return visitTypeAsClass(e, mods);
 535             }
 536 
 537             @Override
 538             @SuppressWarnings(&quot;preview&quot;)
 539             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 540                 addModifiers(mods);
 541                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 542                 return finalString(keyword);
 543             }
 544 
 545             @Override
 546             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 547                 addModifiers(mods);
 548                 return sb.toString().trim();
 549             }
 550 
 551         }.visit(e, modifiers);
 552     }
 553 
 554     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 555         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 556                 configuration.docEnv.getSourceVersion()
 557                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 558     }
 559 
 560     public boolean isNoType(TypeMirror t) {
 561         return t.getKind() == NONE;
 562     }
 563 
 564     public boolean isOrdinaryClass(TypeElement te) {
 565         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 566             return false;
 567         }
 568         if (isError(te) || isException(te)) {
 569             return false;
 570         }
 571         return true;
 572     }
 573 
 574     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 575         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 576                 &amp;&amp; !isLinkable(enclosingTypeElement);
 577     }
 578 
 579     public boolean isError(TypeElement te) {
 580         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 581             return false;
 582         }
 583         return typeUtils.isSubtype(te.asType(), getErrorType());
 584     }
 585 
 586     public boolean isException(TypeElement te) {
 587         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 588             return false;
 589         }
 590         return typeUtils.isSubtype(te.asType(), getExceptionType());
 591     }
 592 
 593     public boolean isPrimitive(TypeMirror t) {
 594         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 595 
 596             @Override
 597             public Boolean visitNoType(NoType t, Void p) {
 598                 return t.getKind() == VOID;
 599             }
 600             @Override
 601             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 602                 return true;
 603             }
 604             @Override
 605             public Boolean visitArray(ArrayType t, Void p) {
 606                 return visit(t.getComponentType());
 607             }
 608             @Override
 609             protected Boolean defaultAction(TypeMirror e, Void p) {
 610                 return false;
 611             }
 612         }.visit(t);
 613     }
 614 
 615     public boolean isExecutableElement(Element e) {
 616         ElementKind kind = e.getKind();
 617         switch (kind) {
 618             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 619                 return true;
 620             default:
 621                 return false;
 622         }
 623     }
 624 
 625     public boolean isVariableElement(Element e) {
 626         ElementKind kind = e.getKind();
 627         switch(kind) {
 628               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 629               case LOCAL_VARIABLE: case PARAMETER:
 630               case RESOURCE_VARIABLE:
 631                   return true;
 632               default:
 633                   return false;
 634         }
 635     }
 636 
 637     public boolean isTypeElement(Element e) {
 638         switch (e.getKind()) {
 639             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 640                 return true;
 641             default:
 642                 return false;
 643         }
 644     }
 645 
 646     /**
 647      * Get the signature. It is the parameter list, type is qualified.
 648      * For instance, for a method {@code mymethod(String x, int y)},
 649      * it will return {@code(java.lang.String,int)}.
 650      *
 651      * @param e
 652      * @return String
 653      */
 654     public String signature(ExecutableElement e) {
 655         return makeSignature(e, true);
 656     }
 657 
 658     /**
 659      * Get flat signature.  All types are not qualified.
 660      * Return a String, which is the flat signature of this member.
 661      * It is the parameter list, type is not qualified.
 662      * For instance, for a method {@code mymethod(String x, int y)},
 663      * it will return {@code (String, int)}.
 664      */
 665     public String flatSignature(ExecutableElement e) {
 666         return makeSignature(e, false);
 667     }
 668 
 669     public String makeSignature(ExecutableElement e, boolean full) {
 670         return makeSignature(e, full, false);
 671     }
 672 
 673     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {
 674         StringBuilder result = new StringBuilder();
 675         result.append(&quot;(&quot;);
 676         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();
 677         while (iterator.hasNext()) {
 678             VariableElement next = iterator.next();
 679             TypeMirror type = next.asType();
 680             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 681             if (iterator.hasNext()) {
 682                 result.append(&quot;, &quot;);
 683             }
 684         }
 685         if (e.isVarArgs()) {
 686             int len = result.length();
 687             result.replace(len - 2, len, &quot;...&quot;);
 688         }
 689         result.append(&quot;)&quot;);
 690         return result.toString();
 691     }
 692 
 693     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 694         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 695             final StringBuilder sb = new StringBuilder();
 696 
 697             @Override
 698             public StringBuilder visitArray(ArrayType t, Void p) {
 699                 TypeMirror componentType = t.getComponentType();
 700                 visit(componentType);
 701                 sb.append(&quot;[]&quot;);
 702                 return sb;
 703             }
 704 
 705             @Override
 706             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 707                 Element e = t.asElement();
 708                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 709                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 710                 if (typeArguments.isEmpty() || noTypeParameters) {
 711                     return sb;
 712                 }
 713                 sb.append(&quot;&lt;&quot;);
 714                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 715                 while (iterator.hasNext()) {
 716                     TypeMirror ta = iterator.next();
 717                     visit(ta);
 718                     if (iterator.hasNext()) {
 719                         sb.append(&quot;, &quot;);
 720                     }
 721                 }
 722                 sb.append(&quot;&gt;&quot;);
 723                 return sb;
 724             }
 725 
 726             @Override
 727             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 728                 Element e = t.asElement();
 729                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 730                 return sb;
 731             }
 732 
 733             @Override
 734             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 735                 sb.append(&quot;?&quot;);
 736                 TypeMirror upperBound = t.getExtendsBound();
 737                 if (upperBound != null) {
 738                     sb.append(&quot; extends &quot;);
 739                     visit(upperBound);
 740                 }
 741                 TypeMirror superBound = t.getSuperBound();
 742                 if (superBound != null) {
 743                     sb.append(&quot; super &quot;);
 744                     visit(superBound);
 745                 }
 746                 return sb;
 747             }
 748 
 749             @Override
 750             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 751                 return sb.append(e);
 752             }
 753         }.visit(t).toString();
 754     }
 755 
 756     public boolean isArrayType(TypeMirror t) {
 757         return t.getKind() == ARRAY;
 758     }
 759 
 760     public boolean isDeclaredType(TypeMirror t) {
 761         return t.getKind() == DECLARED;
 762     }
 763 
 764     public boolean isErrorType(TypeMirror t) {
 765         return t.getKind() == ERROR;
 766     }
 767 
 768     public boolean isIntersectionType(TypeMirror t) {
 769         return t.getKind() == INTERSECTION;
 770     }
 771 
 772     public boolean isTypeParameterElement(Element e) {
 773         return e.getKind() == TYPE_PARAMETER;
 774     }
 775 
 776     public boolean isTypeVariable(TypeMirror t) {
 777         return t.getKind() == TYPEVAR;
 778     }
 779 
 780     public boolean isVoid(TypeMirror t) {
 781         return t.getKind() == VOID;
 782     }
 783 
 784     public boolean isWildCard(TypeMirror t) {
 785         return t.getKind() == WILDCARD;
 786     }
 787 
 788     public boolean ignoreBounds(TypeMirror bound) {
 789         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 790     }
 791 
 792     /*
 793      * a direct port of TypeVariable.getBounds
 794      */
 795     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 796         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 797         if (!bounds.isEmpty()) {
 798             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 799             if (ignoreBounds(upperBound)) {
 800                 return Collections.emptyList();
 801             }
 802         }
 803         return bounds;
 804     }
 805 
 806     /**
 807      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 808      * if it is a constructor.
 809      * @param site the contextual type
 810      * @param ee the ExecutableElement
 811      * @return the return type
 812      */
 813     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 814         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 815     }
 816 
 817     /**
 818      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 819      * member of a given declared type. This might cause type-variable substitution to kick in.
 820      * @param site the contextual type.
 821      * @param ee the method declaration.
 822      * @return the instantiated method type.
 823      */
 824     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 825         return shouldInstantiate(site, ee) ?
 826                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 827                 (ExecutableType)ee.asType();
 828     }
 829 
 830     /**
 831      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 832      * member of a given declared type. This might cause type-variable substitution to kick in.
 833      * @param site the contextual type.
 834      * @param ve the field declaration.
 835      * @return the instantiated field type.
 836      */
 837     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 838         return shouldInstantiate(site, ve) ?
 839                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 840                 ve.asType();
 841     }
 842 
 843     /*
 844      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 845      * to which the member belongs to is the same as the one under consideration, (iii) if the
 846      * delcaration to which the member belongs to is not generic.
 847      */
 848     private boolean shouldInstantiate(TypeElement site, Element e) {
 849         return site != null &amp;&amp;
 850                 site != e.getEnclosingElement() &amp;&amp;
 851                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 852     }
 853 
 854     /**
 855      * Return the type containing the method that this method overrides.
 856      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 857      */
 858     public TypeMirror overriddenType(ExecutableElement method) {
 859         return configuration.workArounds.overriddenType(method);
 860     }
 861 
 862     private  TypeMirror getType(TypeMirror t) {
 863         return (isNoType(t)) ? getObjectType() : t;
 864     }
 865 
 866     public TypeMirror getSuperType(TypeElement te) {
 867         TypeMirror t = te.getSuperclass();
 868         return getType(t);
 869     }
 870 
 871     /**
 872      * Return the class that originally defined the method that
 873      * is overridden by the current definition, or null if no
 874      * such class exists.
 875      *
 876      * @return a TypeElement representing the superclass that
 877      * originally defined this method, null if this method does
 878      * not override a definition in a superclass.
 879      */
 880     public TypeElement overriddenClass(ExecutableElement ee) {
 881         TypeMirror type = overriddenType(ee);
 882         return (type != null) ? asTypeElement(type) : null;
 883     }
 884 
 885     public ExecutableElement overriddenMethod(ExecutableElement method) {
 886         if (isStatic(method)) {
 887             return null;
 888         }
 889         final TypeElement origin = getEnclosingTypeElement(method);
 890         for (TypeMirror t = getSuperType(origin);
 891                 t.getKind() == DECLARED;
 892                 t = getSuperType(asTypeElement(t))) {
 893             TypeElement te = asTypeElement(t);
 894             if (te == null) {
 895                 return null;
 896             }
 897             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 898             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 899                 ExecutableElement ee = (ExecutableElement)e;
 900                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 901                         !isSimpleOverride(ee)) {
 902                     return ee;
 903                 }
 904             }
 905             if (t.equals(getObjectType()))
 906                 return null;
 907         }
 908         return null;
 909     }
 910 
 911     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 912         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
 913         for (TypeElement te : typeElements) {
 914             set.add(te);
 915         }
 916         return set;
 917     }
 918 
 919     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 920         return getBlockTags(member, SERIAL_DATA);
 921     }
 922 
 923     public FileObject getFileObject(TypeElement te) {
 924         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 925     }
 926 
 927     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 928         return getDeclaredType(Collections.emptyList(), enclosing, target);
 929     }
 930 
 931     /**
 932      * Finds the declaration of the enclosing&#39;s type parameter.
 933      *
 934      * @param values
 935      * @param enclosing a TypeElement whose type arguments  we desire
 936      * @param target the TypeMirror of the type as described by the enclosing
 937      * @return
 938      */
 939     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 940             TypeElement enclosing, TypeMirror target) {
 941         TypeElement targetElement = asTypeElement(target);
 942         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 943         if (targetTypeArgs.isEmpty()) {
 944             return target;
 945         }
 946 
 947         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 948         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 949 
 950         if (enclosingTypeArgs.isEmpty()) {
 951             for (TypeMirror te : values) {
 952                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 953                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 954                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 955                         targetTypeArgTypes.add(typeArguments.get(i));
 956                     }
 957                     break;
 958                 }
 959             }
 960             // we found no matches in the hierarchy
 961             if (targetTypeArgTypes.isEmpty()) {
 962                 return target;
 963             }
 964         } else {
 965             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 966                 return target;
 967             }
 968             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 969                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
 970                 targetTypeArgTypes.add(tpe.asType());
 971             }
 972         }
 973         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
 974                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
 975         return dt;
 976     }
 977 
 978     /**
 979      * Returns all the implemented super-interfaces of a given type,
 980      * in the case of classes, include all the super-interfaces of
 981      * the supertype. The super-interfaces are collected before the
 982      * super-interfaces of the supertype.
 983      *
 984      * @param  te the type element to get the super-interfaces for.
 985      * @return the list of super-interfaces.
 986      */
 987     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
 988         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
 989         getAllInterfaces(te.asType(), results);
 990         return results;
 991     }
 992 
 993     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
 994         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
 995         TypeMirror superType = null;
 996         for (TypeMirror intfac : intfacs) {
 997             if (intfac == getObjectType())
 998                 continue;
 999             TypeElement e = asTypeElement(intfac);
1000             if (isInterface(e)) {
1001                 if (isPublic(e) || isLinkable(e))
1002                     results.add(intfac);
1003 
1004                 getAllInterfaces(intfac, results);
1005             } else {
1006                 // Save the supertype for later.
1007                 superType = intfac;
1008             }
1009         }
1010         // Collect the super-interfaces of the supertype.
1011         if (superType != null)
1012             getAllInterfaces(superType, results);
1013     }
1014 
1015     /**
1016      * Lookup for a class within this package.
1017      *
1018      * @return TypeElement of found class, or null if not found.
1019      */
1020     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1021         for (TypeElement c : getAllClasses(pkg)) {
1022             if (getSimpleName(c).equals(className)) {
1023                 return c;
1024             }
1025         }
1026         return null;
1027     }
1028 
1029     /**
1030      * TODO: FIXME: port to javax.lang.model
1031      * Find a class within the context of this class. Search order: qualified name, in this class
1032      * (inner), in this package, in the class imports, in the package imports. Return the
1033      * TypeElement if found, null if not found.
1034      */
1035     //### The specified search order is not the normal rule the
1036     //### compiler would use.  Leave as specified or change it?
1037     public TypeElement findClass(Element element, String className) {
1038         TypeElement encl = getEnclosingTypeElement(element);
1039         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1040         if (searchResult == null) {
1041             encl = getEnclosingTypeElement(encl);
1042             //Expand search space to include enclosing class.
1043             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1044                 encl = getEnclosingTypeElement(encl);
1045             }
1046             searchResult = encl == null
1047                     ? null
1048                     : configuration.workArounds.searchClass(encl, className);
1049         }
1050         return searchResult;
1051     }
1052 
1053     /**
1054      * Enclose in quotes, used for paths and filenames that contains spaces
1055      */
1056     public String quote(String filepath) {
1057         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1058     }
1059 
1060     /**
1061      * Parse the package name.  We only want to display package name up to
1062      * 2 levels.
1063      */
1064     public String parsePackageName(PackageElement p) {
1065         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1066         int index = -1;
1067         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1068             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1069         }
1070         if (index != -1) {
1071             pkgname = pkgname.substring(0, index);
1072         }
1073         return pkgname;
1074     }
1075 
1076     /**
1077      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1078      * @param originalStr the string to modify.
1079      * @param oldStr the string to replace.
1080      * @param newStr the string to insert in place of the old string.
1081      */
1082     public String replaceText(String originalStr, String oldStr,
1083             String newStr) {
1084         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1085             return originalStr;
1086         }
1087         return originalStr.replace(oldStr, newStr);
1088     }
1089 
1090     /**
1091      * Given an annotation, return true if it should be documented and false
1092      * otherwise.
1093      *
1094      * @param annotation the annotation to check.
1095      *
1096      * @return true return true if it should be documented and false otherwise.
1097      */
1098     public boolean isDocumentedAnnotation(TypeElement annotation) {
1099         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1100             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1101                     Documented.class.getName())) {
1102                 return true;
1103             }
1104         }
1105         return false;
1106     }
1107 
1108     /**
1109      * Returns true if this class is linkable and false if we can&#39;t link to it.
1110      *
1111      * &lt;p&gt;
1112      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1113      * protected.
1114      *
1115      * @return true if this class is linkable and false if we can&#39;t link to the
1116      * desired class.
1117      */
1118     public boolean isLinkable(TypeElement typeElem) {
1119         return
1120             (typeElem != null &amp;&amp;
1121                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1122             (configuration.extern.isExternal(typeElem) &amp;&amp;
1123                 (isPublic(typeElem) || isProtected(typeElem)));
1124     }
1125 
1126     /**
1127      * Returns true if an element is linkable in the context of a given type element.
1128      *
1129      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1130      * Otherwise, the element is linkable if any of the following are true:
1131      * &lt;ul&gt;
1132      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1133      * &lt;li&gt;it is inherited from an undocumented supertype
1134      * &lt;li&gt;it is a public or protected member of an external API
1135      * &lt;/ul&gt;
1136      *
1137      * @param typeElem the type element
1138      * @param elem the element
1139      * @return whether or not the element is linkable
1140      */
1141     public boolean isLinkable(TypeElement typeElem, Element elem) {
1142         if (isTypeElement(elem)) {
1143             return isLinkable((TypeElement) elem); // defer to existing behavior
1144         }
1145 
1146         if (isIncluded(elem)) {
1147             return true;
1148         }
1149 
1150         // Allow for the behavior that members of undocumented supertypes
1151         // may be included in documented types
1152         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1153             return true;
1154         }
1155 
1156         // Allow for external members
1157         return isLinkable(typeElem)
1158                     &amp;&amp; configuration.extern.isExternal(typeElem)
1159                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1160     }
1161 
1162     /**
1163      * Return this type as a {@code TypeElement} if it represents a class
1164      * interface or annotation.  Array dimensions are ignored.
1165      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1166      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1167      * annotation, return this as a {@code TypeElement}.
1168      * If this is a primitive type, return null.
1169      *
1170      * @return the {@code TypeElement} of this type,
1171      *         or null if it is a primitive type.
1172      */
1173     public TypeElement asTypeElement(TypeMirror t) {
1174         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1175 
1176             @Override
1177             public TypeElement visitDeclared(DeclaredType t, Void p) {
1178                 return (TypeElement) t.asElement();
1179             }
1180 
1181             @Override
1182             public TypeElement visitArray(ArrayType t, Void p) {
1183                 return visit(t.getComponentType());
1184             }
1185 
1186             @Override
1187             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1188                /* TODO, this may not be an optimal fix.
1189                 * if we have an annotated type @DA T, then erasure returns a
1190                 * none, in this case we use asElement instead.
1191                 */
1192                 if (isAnnotated(t)) {
1193                     return visit(typeUtils.asElement(t).asType());
1194                 }
1195                 return visit(typeUtils.erasure(t));
1196             }
1197 
1198             @Override
1199             public TypeElement visitWildcard(WildcardType t, Void p) {
1200                 return visit(typeUtils.erasure(t));
1201             }
1202 
1203             @Override
1204             public TypeElement visitError(ErrorType t, Void p) {
1205                 return (TypeElement)t.asElement();
1206             }
1207 
1208             @Override
1209             protected TypeElement defaultAction(TypeMirror e, Void p) {
1210                 return super.defaultAction(e, p);
1211             }
1212         }.visit(t);
1213     }
1214 
1215     public TypeMirror getComponentType(TypeMirror t) {
1216         while (isArrayType(t)) {
1217             t = ((ArrayType) t).getComponentType();
1218         }
1219         return t;
1220     }
1221 
1222     /**
1223      * Return the type&#39;s dimension information, as a string.
1224      * &lt;p&gt;
1225      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1226      *
1227      * @return the type&#39;s dimension information as a string.
1228      */
1229     public String getDimension(TypeMirror t) {
1230         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1231             StringBuilder dimension = new StringBuilder(&quot;&quot;);
1232             @Override
1233             public String visitArray(ArrayType t, Void p) {
1234                 dimension.append(&quot;[]&quot;);
1235                 return visit(t.getComponentType());
1236             }
1237 
1238             @Override
1239             protected String defaultAction(TypeMirror e, Void p) {
1240                 return dimension.toString();
1241             }
1242 
1243         }.visit(t);
1244     }
1245 
1246     public TypeElement getSuperClass(TypeElement te) {
1247         if (isInterface(te) || isAnnotationType(te) ||
1248                 te.asType().equals(getObjectType())) {
1249             return null;
1250         }
1251         TypeMirror superclass = te.getSuperclass();
1252         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1253             superclass = getObjectType();
1254         }
1255         return asTypeElement(superclass);
1256     }
1257 
1258     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1259         if (isAnnotationType(te) || isInterface(te) ||
1260                 te.asType().equals(getObjectType())) {
1261             return null;
1262         }
1263         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1264         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1265     }
1266 
1267     /**
1268      * Given a class, return the closest visible super class.
1269      * @param type the TypeMirror to be interrogated
1270      * @return  the closest visible super class.  Return null if it cannot
1271      *          be found.
1272      */
1273 
1274     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1275         return getFirstVisibleSuperClass(asTypeElement(type));
1276     }
1277 
1278 
1279     /**
1280      * Given a class, return the closest visible super class.
1281      *
1282      * @param te the TypeElement to be interrogated
1283      * @return the closest visible super class.  Return null if it cannot
1284      *         be found..
1285      */
1286     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1287         TypeMirror superType = te.getSuperclass();
1288         if (isNoType(superType)) {
1289             superType = getObjectType();
1290         }
1291         TypeElement superClass = asTypeElement(superType);
1292         // skip &quot;hidden&quot; classes
1293         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1294                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1295             TypeMirror supersuperType = superClass.getSuperclass();
1296             TypeElement supersuperClass = asTypeElement(supersuperType);
1297             if (supersuperClass == null
1298                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1299                 break;
1300             }
1301             superType = supersuperType;
1302             superClass = supersuperClass;
1303         }
1304         if (te.asType().equals(superType)) {
1305             return null;
1306         }
1307         return superType;
1308     }
1309 
1310     /**
1311      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1312      *
1313      * @param te the TypeElement to check.
1314      * @param lowerCaseOnly true if you want the name returned in lower case.
1315      *                      If false, the first letter of the name is capitalized.
1316      * @return
1317      */
1318 
1319     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1320         String typeName = &quot;&quot;;
1321         if (isInterface(te)) {
1322             typeName = &quot;doclet.Interface&quot;;
1323         } else if (isException(te)) {
1324             typeName = &quot;doclet.Exception&quot;;
1325         } else if (isError(te)) {
1326             typeName = &quot;doclet.Error&quot;;
1327         } else if (isAnnotationType(te)) {
1328             typeName = &quot;doclet.AnnotationType&quot;;
1329         } else if (isEnum(te)) {
1330             typeName = &quot;doclet.Enum&quot;;
1331         } else if (isOrdinaryClass(te)) {
1332             typeName = &quot;doclet.Class&quot;;
1333         }
1334         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1335         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1336     }
1337 
1338     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1339 
1340     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1341         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1342 
1343             @Override
1344             public String visitArray(ArrayType t, Void p) {
1345                 return visit(t.getComponentType());
1346             }
1347 
1348             @Override
1349             public String visitDeclared(DeclaredType t, Void p) {
1350                 TypeElement te = asTypeElement(t);
1351                 return fullyQualified
1352                         ? te.getQualifiedName().toString()
1353                         : getSimpleName(te);
1354             }
1355 
1356             @Override
1357             public String visitExecutable(ExecutableType t, Void p) {
1358                 return t.toString();
1359             }
1360 
1361             @Override
1362             public String visitPrimitive(PrimitiveType t, Void p) {
1363                 return t.toString();
1364             }
1365 
1366             @Override
1367             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1368                 return getSimpleName(t.asElement());
1369             }
1370 
1371             @Override
1372             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1373                 return t.toString();
1374             }
1375 
1376             @Override
1377             protected String defaultAction(TypeMirror e, Void p) {
1378                 return e.toString();
1379             }
1380         }.visit(t);
1381     }
1382 
1383     /**
1384      * Replace all tabs in a string with the appropriate number of spaces.
1385      * The string may be a multi-line string.
1386      * @param text the text for which the tabs should be expanded
1387      * @return the text with all tabs expanded
1388      */
1389     public String replaceTabs(String text) {
1390         if (!text.contains(&quot;\t&quot;))
1391             return text;
1392 
1393         final int tabLength = options.sourceTabSize();
1394         final String whitespace = &quot; &quot;.repeat(tabLength);
1395         final int textLength = text.length();
1396         StringBuilder result = new StringBuilder(textLength);
1397         int pos = 0;
1398         int lineLength = 0;
1399         for (int i = 0; i &lt; textLength; i++) {
1400             char ch = text.charAt(i);
1401             switch (ch) {
1402                 case &#39;\n&#39;: case &#39;\r&#39;:
1403                     lineLength = 0;
1404                     break;
1405                 case &#39;\t&#39;:
1406                     result.append(text, pos, i);
1407                     int spaceCount = tabLength - lineLength % tabLength;
1408                     result.append(whitespace, 0, spaceCount);
1409                     lineLength += spaceCount;
1410                     pos = i + 1;
1411                     break;
1412                 default:
1413                     lineLength++;
1414             }
1415         }
1416         result.append(text, pos, textLength);
1417         return result.toString();
1418     }
1419 
1420     public CharSequence normalizeNewlines(CharSequence text) {
1421         StringBuilder sb = new StringBuilder();
1422         final int textLength = text.length();
1423         final String NL = DocletConstants.NL;
1424         int pos = 0;
1425         for (int i = 0; i &lt; textLength; i++) {
1426             char ch = text.charAt(i);
1427             switch (ch) {
1428                 case &#39;\n&#39;:
1429                     sb.append(text, pos, i);
1430                     sb.append(NL);
1431                     pos = i + 1;
1432                     break;
1433                 case &#39;\r&#39;:
1434                     sb.append(text, pos, i);
1435                     sb.append(NL);
1436                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1437                         i++;
1438                     pos = i + 1;
1439                     break;
1440             }
1441         }
1442         sb.append(text, pos, textLength);
1443         return sb;
1444     }
1445 
1446     /**
1447      * Returns a locale independent lower cased String. That is, it
1448      * always uses US locale, this is a clone of the one in StringUtils.
1449      * @param s to convert
1450      * @return converted String
1451      */
1452     public static String toLowerCase(String s) {
1453         return s.toLowerCase(Locale.US);
1454     }
1455 
1456     /**
1457      * Return true if the given Element is deprecated.
1458      *
1459      * @param e the Element to check.
1460      * @return true if the given Element is deprecated.
1461      */
1462     public boolean isDeprecated(Element e) {
1463         if (isPackage(e)) {
1464             return configuration.workArounds.isDeprecated0(e);
1465         }
1466         return elementUtils.isDeprecated(e);
1467     }
1468 
1469     /**
1470      * Return true if the given Element is deprecated for removal.
1471      *
1472      * @param e the Element to check.
1473      * @return true if the given Element is deprecated for removal.
1474      */
1475     public boolean isDeprecatedForRemoval(Element e) {
1476         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1477         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1478         for (AnnotationMirror anno : annotationList) {
1479             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1480                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1481                 if (!pairs.isEmpty()) {
1482                     for (ExecutableElement element : pairs.keySet()) {
1483                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1484                             return Boolean.parseBoolean((pairs.get(element)).toString());
1485                         }
1486                     }
1487                 }
1488             }
1489         }
1490         return false;
1491     }
1492 
1493     /**
1494      * A convenience method to get property name from the name of the
1495      * getter or setter method.
1496      * @param e the input method.
1497      * @return the name of the property of the given setter of getter.
1498      */
1499     public String propertyName(ExecutableElement e) {
1500         String name = getSimpleName(e);
1501         String propertyName = null;
1502         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1503             propertyName = name.substring(3);
1504         } else if (name.startsWith(&quot;is&quot;)) {
1505             propertyName = name.substring(2);
1506         }
1507         if ((propertyName == null) || propertyName.isEmpty()){
1508             return &quot;&quot;;
1509         }
1510         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1511                 + propertyName.substring(1);
1512     }
1513 
1514     /**
1515      * Returns true if the element is included, contains &amp;#64;hidden tag,
1516      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1517      * tag.
1518      * @param e the queried element
1519      * @return true if it exists, false otherwise
1520      */
1521     public boolean hasHiddenTag(Element e) {
1522         // prevent needless tests on elements which are not included
1523         if (!isIncluded(e)) {
1524             return false;
1525         }
1526         if (options.javafx() &amp;&amp;
1527                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1528             return true;
1529         }
1530         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1531     }
1532 
1533     /**
1534      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1535      * @param m a method
1536      * @return true if there are no comments, false otherwise
1537      */
1538     public boolean isSimpleOverride(ExecutableElement m) {
1539         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1540             return false;
1541         }
1542 
1543         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1544             return false;
1545 
1546         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1547         return fullBody.isEmpty() ||
1548                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1549     }
1550 
1551     /**
1552      * In case of JavaFX mode on, filters out classes that are private,
1553      * package private, these are not documented in JavaFX mode, also
1554      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1555      *
1556      * @param classlist a collection of TypeElements
1557      * @param javafx set to true if in JavaFX mode.
1558      * @return list of filtered classes.
1559      */
1560     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1561             boolean javafx) {
1562         SortedSet&lt;TypeElement&gt; filteredOutClasses =
1563                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
1564         if (!javafx) {
1565             for (Element te : classlist) {
1566                 if (!hasHiddenTag(te)) {
1567                     filteredOutClasses.add((TypeElement)te);
1568                 }
1569             }
1570             return filteredOutClasses;
1571         }
1572         for (Element e : classlist) {
1573             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1574                 continue;
1575             }
1576             filteredOutClasses.add((TypeElement)e);
1577         }
1578         return filteredOutClasses;
1579     }
1580 
1581     /**
1582      * Compares two elements.
1583      * @param e1 first Element
1584      * @param e2 second Element
1585      * @return a true if they are the same, false otherwise.
1586      */
1587     public boolean elementsEqual(Element e1, Element e2) {
1588         if (e1.getKind() != e2.getKind()) {
1589             return false;
1590         }
1591         String s1 = getSimpleName(e1);
1592         String s2 = getSimpleName(e2);
1593         if (compareStrings(s1, s2) == 0) {
1594             String f1 = getFullyQualifiedName(e1, true);
1595             String f2 = getFullyQualifiedName(e2, true);
1596             return compareStrings(f1, f2) == 0;
1597         }
1598         return false;
1599     }
1600 
1601     /**
1602      * A general purpose case insensitive String comparator, which compares
1603      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1604      *
1605      * @param s1 first String to compare.
1606      * @param s2 second String to compare.
1607      * @return a negative integer, zero, or a positive integer as the first
1608      *         argument is less than, equal to, or greater than the second.
1609      */
1610     public int compareStrings(String s1, String s2) {
1611         return compareStrings(true, s1, s2);
1612     }
1613 
1614     /**
1615      * A general purpose case sensitive String comparator, which
1616      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1617      *
1618      * @param s1 first String to compare.
1619      * @param s2 second String to compare.
1620      * @return a negative integer, zero, or a positive integer as the first
1621      *         argument is less than, equal to, or greater than the second.
1622      */
1623     public int compareCaseCompare(String s1, String s2) {
1624         return compareStrings(false, s1, s2);
1625     }
1626 
1627     private DocCollator tertiaryCollator = null;
1628     private DocCollator secondaryCollator = null;
1629 
1630     private int compareStrings(boolean caseSensitive, String s1, String s2) {
1631         if (caseSensitive) {
1632             if (tertiaryCollator == null) {
1633                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1634             }
1635             return tertiaryCollator.compare(s1, s2);
1636         }
1637         if (secondaryCollator == null) {
1638             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1639         }
1640         return secondaryCollator.compare(s1, s2);
1641     }
1642 
1643     private static class DocCollator {
1644         private final Map&lt;String, CollationKey&gt; keys;
1645         private final Collator instance;
1646         private final int MAX_SIZE = 1000;
1647         private DocCollator(Locale locale, int strength) {
1648             instance = createCollator(locale);
1649             instance.setStrength(strength);
1650 
1651             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1652                 private static final long serialVersionUID = 1L;
1653                 @Override
1654                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1655                     return size() &gt; MAX_SIZE;
1656                 }
1657             };
1658         }
1659 
1660         CollationKey getKey(String s) {
1661             return keys.computeIfAbsent(s, instance :: getCollationKey);
1662         }
1663 
1664         public int compare(String s1, String s2) {
1665             return getKey(s1).compareTo(getKey(s2));
1666         }
1667 
1668         private Collator createCollator(Locale locale) {
1669             Collator baseCollator = Collator.getInstance(locale);
1670             if (baseCollator instanceof RuleBasedCollator) {
1671                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1672                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1673                 try {
1674                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1675                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1676                 } catch (ParseException e) {
1677                     throw new RuntimeException(e);
1678                 }
1679             }
1680             return baseCollator;
1681         }
1682     }
1683 
1684     private Comparator&lt;Element&gt; moduleComparator = null;
1685     /**
1686      * Comparator for ModuleElements, simply compares the fully qualified names
1687      * @return a Comparator
1688      */
1689     public Comparator&lt;Element&gt; makeModuleComparator() {
1690         if (moduleComparator == null) {
1691             moduleComparator = new Utils.ElementComparator() {
1692                 @Override
1693                 public int compare(Element mod1, Element mod2) {
1694                     return compareFullyQualifiedNames(mod1, mod2);
1695                 }
1696             };
1697         }
1698         return moduleComparator;
1699     }
1700 
1701     private Comparator&lt;Element&gt; allClassesComparator = null;
1702     /**
1703      * Returns a Comparator for all classes, compares the simple names of
1704      * TypeElement, if equal then the fully qualified names.
1705      *
1706      * @return Comparator
1707      */
1708     public Comparator&lt;Element&gt; makeAllClassesComparator() {
1709         if (allClassesComparator == null) {
1710             allClassesComparator = new Utils.ElementComparator() {
1711                 @Override
1712                 public int compare(Element e1, Element e2) {
1713                     int result = compareNames(e1, e2);
1714                     if (result == 0)
1715                         result = compareFullyQualifiedNames(e1, e2);
1716 
1717                     return result;
1718                 }
1719             };
1720         }
1721         return allClassesComparator;
1722     }
1723 
1724     private Comparator&lt;Element&gt; packageComparator = null;
1725     /**
1726      * Returns a Comparator for packages, by comparing the fully qualified names.
1727      *
1728      * @return a Comparator
1729      */
1730     public Comparator&lt;Element&gt; makePackageComparator() {
1731         if (packageComparator == null) {
1732             packageComparator = new Utils.ElementComparator() {
1733                 @Override
1734                 public int compare(Element pkg1, Element pkg2) {
1735                     return compareFullyQualifiedNames(pkg1, pkg2);
1736                 }
1737             };
1738         }
1739         return packageComparator;
1740     }
1741 
1742     private Comparator&lt;Element&gt; deprecatedComparator = null;
1743     /**
1744      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the
1745      * fully qualified names.
1746      *
1747      * @return a Comparator
1748      */
1749     public Comparator&lt;Element&gt; makeDeprecatedComparator() {
1750         if (deprecatedComparator == null) {
1751             deprecatedComparator = new Utils.ElementComparator() {
1752                 @Override
1753                 public int compare(Element e1, Element e2) {
1754                     return compareFullyQualifiedNames(e1, e2);
1755                 }
1756             };
1757         }
1758         return deprecatedComparator;
1759     }
1760 
1761     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;
1762     /**
1763      * Returns a Comparator for SerialFieldTree.
1764      * @return a Comparator
1765      */
1766     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1767         if (serialFieldTreeComparator == null) {
1768             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1769                 String s1 = o1.getName().toString();
1770                 String s2 = o2.getName().toString();
1771                 return s1.compareTo(s2);
1772             };
1773         }
1774         return serialFieldTreeComparator;
1775     }
1776 
1777     /**
1778      * Returns a general purpose comparator.
1779      * @return a Comparator
1780      */
1781     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1782         return makeClassUseComparator();
1783     }
1784 
1785     private Comparator&lt;Element&gt; overrideUseComparator = null;
1786     /**
1787      * Returns a Comparator for overrides and implements,
1788      * used primarily on methods, compares the name first,
1789      * then compares the simple names of the enclosing
1790      * TypeElement and the fully qualified name of the enclosing TypeElement.
1791      * @return a Comparator
1792      */
1793     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1794         if (overrideUseComparator == null) {
1795             overrideUseComparator = new Utils.ElementComparator() {
1796                 @Override
1797                 public int compare(Element o1, Element o2) {
1798                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1799                     if (result != 0) {
1800                         return result;
1801                     }
1802                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1803                         TypeElement t1 = getEnclosingTypeElement(o1);
1804                         TypeElement t2 = getEnclosingTypeElement(o2);
1805                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
1806                         if (result != 0)
1807                             return result;
1808                     }
1809                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
1810                     if (result != 0)
1811                         return result;
1812                     return compareElementKinds(o1, o2);
1813                 }
1814             };
1815         }
1816         return overrideUseComparator;
1817     }
1818 
1819     private Comparator&lt;Element&gt; indexUseComparator = null;
1820     /**
1821      *  Returns a Comparator for index file presentations, and are sorted as follows.
1822      *  If comparing modules and/or packages then simply compare the qualified names,
1823      *  if comparing a module or a package with a type/member then compare the
1824      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,
1825      *  otherwise:
1826      *  1. compare the ElementKind ex: Module, Package, Interface etc.
1827      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),
1828      *      a case insensitive comparison of parameter the type signatures
1829      *  2b. if equal, case sensitive comparison of the type signatures
1830      *  3. finally, if equal, compare the FQNs of the entities
1831      * @return a comparator for index file use
1832      */
1833     public Comparator&lt;Element&gt; makeIndexUseComparator() {
1834         if (indexUseComparator == null) {
1835             indexUseComparator = new Utils.ElementComparator() {
1836                 /**
1837                  * Compares two elements.
1838                  *
1839                  * @param e1 - an element.
1840                  * @param e2 - an element.
1841                  * @return a negative integer, zero, or a positive integer as the first
1842                  * argument is less than, equal to, or greater than the second.
1843                  */
1844                 @Override
1845                 public int compare(Element e1, Element e2) {
1846                     int result;
1847                     // first, compare names as appropriate
1848                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {
1849                         result = compareFullyQualifiedNames(e1, e2);
1850                     } else if (isModule(e1) || isPackage(e1)) {
1851                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));
1852                     } else if (isModule(e2) || isPackage(e2)) {
1853                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));
1854                     } else {
1855                         result = compareNames(e1, e2);
1856                     }
1857                     if (result != 0) {
1858                         return result;
1859                     }
1860                     // if names are the same, compare element kinds
1861                     result = compareElementKinds(e1, e2);
1862                     if (result != 0) {
1863                         return result;
1864                     }
1865                     // if element kinds are the same, and are methods,
1866                     // compare the method parameters
1867                     if (hasParameters(e1)) {
1868                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
1869                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
1870                         result = compareParameters(false, parameters1, parameters2);
1871                         if (result != 0) {
1872                             return result;
1873                         }
1874                         result = compareParameters(true, parameters1, parameters2);
1875                         if (result != 0) {
1876                             return result;
1877                         }
1878                     }
1879                     // else fall back on fully qualified names
1880                     return compareFullyQualifiedNames(e1, e2);
1881                 }
1882             };
1883         }
1884         return indexUseComparator;
1885     }
1886 
1887     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;
1888     /**
1889      * Compares the FullyQualifiedNames of two TypeMirrors
1890      * @return
1891      */
1892     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {
1893         if (typeMirrorClassUseComparator == null) {
1894             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {
1895                 String s1 = getQualifiedTypeName(type1);
1896                 String s2 = getQualifiedTypeName(type2);
1897                 return compareStrings(s1, s2);
1898             };
1899         }
1900         return typeMirrorClassUseComparator;
1901     }
1902 
1903     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;
1904     /**
1905      * Compares the SimpleNames of TypeMirrors if equal then the
1906      * FullyQualifiedNames of TypeMirrors.
1907      *
1908      * @return
1909      */
1910     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {
1911         if (typeMirrorIndexUseComparator == null) {
1912             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {
1913                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));
1914                 if (result != 0)
1915                     return result;
1916                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));
1917             };
1918         }
1919         return typeMirrorIndexUseComparator;
1920     }
1921 
1922     /**
1923      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1924      * getQualified name, returns  the qualified name of the Reference type
1925      * otherwise the primitive name.
1926      * @param t the type whose name is to be obtained.
1927      * @return the fully qualified name of Reference type or the primitive name
1928      */
1929     public String getQualifiedTypeName(TypeMirror t) {
1930         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1931             @Override
1932             public String visitDeclared(DeclaredType t, Void p) {
1933                 return getFullyQualifiedName(t.asElement());
1934             }
1935 
1936             @Override
1937             public String visitArray(ArrayType t, Void p) {
1938                return visit(t.getComponentType());
1939             }
1940 
1941             @Override
1942             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1943                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1944                 // it to be compatible with the old world, now if we decide to do so
1945                 // care must be taken to avoid collisions.
1946                 // return getFullyQualifiedName(t.asElement());
1947                 return t.toString();
1948             }
1949 
1950             @Override
1951             protected String defaultAction(TypeMirror t, Void p) {
1952                 return t.toString();
1953             }
1954 
1955         }.visit(t);
1956     }
1957 
1958     /**
1959      * A generic utility which returns the fully qualified names of an entity,
1960      * if the entity is not qualifiable then its enclosing entity, it is upto
1961      * the caller to add the elements name as required.
1962      * @param e the element to get FQN for.
1963      * @return the name
1964      */
1965     public String getFullyQualifiedName(Element e) {
1966         return getFullyQualifiedName(e, true);
1967     }
1968 
1969     @SuppressWarnings(&quot;preview&quot;)
1970     public String getFullyQualifiedName(Element e, final boolean outer) {
1971         return new SimpleElementVisitor14&lt;String, Void&gt;() {
1972             @Override
1973             public String visitModule(ModuleElement e, Void p) {
1974                 return e.getQualifiedName().toString();
1975             }
1976 
1977             @Override
1978             public String visitPackage(PackageElement e, Void p) {
1979                 return e.getQualifiedName().toString();
1980             }
1981 
1982             @Override
1983             public String visitType(TypeElement e, Void p) {
1984                 return e.getQualifiedName().toString();
1985             }
1986 
1987             @Override
1988             protected String defaultAction(Element e, Void p) {
1989                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1990             }
1991         }.visit(e);
1992     }
1993 
1994     private Comparator&lt;Element&gt; classUseComparator = null;
1995     /**
1996      * Comparator for ClassUse presentations, and sorts as follows:
1997      * 1. member names
1998      * 2. then fully qualified member names
1999      * 3. then parameter types if applicable
2000      * 4. finally the element kinds ie. package, class, interface etc.
2001      * @return a comparator to sort classes and members for class use
2002      */
2003     public Comparator&lt;Element&gt; makeClassUseComparator() {
2004         if (classUseComparator == null) {
2005             classUseComparator = new Utils.ElementComparator() {
2006                 /**
2007                  * Compares two Elements.
2008                  *
2009                  * @param e1 - an element.
2010                  * @param e2 - an element.
2011                  * @return a negative integer, zero, or a positive integer as the first
2012                  * argument is less than, equal to, or greater than the second.
2013                  */
2014                 @Override
2015                 public int compare(Element e1, Element e2) {
2016                     int result = compareNames(e1, e2);
2017                     if (result != 0) {
2018                         return result;
2019                     }
2020                     result = compareFullyQualifiedNames(e1, e2);
2021                     if (result != 0) {
2022                         return result;
2023                     }
2024                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
2025                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
2026                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
2027                         result = compareParameters(false, parameters1, parameters2);
2028                         if (result != 0) {
2029                             return result;
2030                         }
2031                         result = compareParameters(true, parameters1, parameters2);
2032                     }
2033                     if (result != 0) {
2034                         return result;
2035                     }
2036                     return compareElementKinds(e1, e2);
2037                 }
2038             };
2039         }
2040         return classUseComparator;
2041     }
2042 
2043     /**
2044      * A general purpose comparator to sort Element entities, basically provides the building blocks
2045      * for creating specific comparators for an use-case.
2046      */
2047     private abstract class ElementComparator implements Comparator&lt;Element&gt; {
2048         public ElementComparator() { }
2049 
2050         /**
2051          * compares two parameter arrays by first comparing the length of the arrays, and
2052          * then each Type of the parameter in the array.
2053          * @param params1 the first parameter array.
2054          * @param params2 the first parameter array.
2055          * @return a negative integer, zero, or a positive integer as the first
2056          *         argument is less than, equal to, or greater than the second.
2057          */
2058         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
2059                                                                List&lt;? extends VariableElement&gt; params2) {
2060 
2061             return compareStrings(caseSensitive, getParametersAsString(params1),
2062                                                  getParametersAsString(params2));
2063         }
2064 
2065         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {
2066             StringBuilder sb = new StringBuilder();
2067             for (VariableElement param : params) {
2068                 TypeMirror t = param.asType();
2069                 // prefix P for primitive and R for reference types, thus items will
2070                 // be ordered lexically and correctly.
2071                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);
2072             }
2073             return sb.toString();
2074         }
2075 
2076         private String getTypeCode(TypeMirror t) {
2077             return new SimpleTypeVisitor9&lt;String, Void&gt;() {
2078 
2079                 @Override
2080                 public String visitPrimitive(PrimitiveType t, Void p) {
2081                     return &quot;P&quot;;
2082                 }
2083                 @Override
2084                 public String visitArray(ArrayType t, Void p) {
2085                     return visit(t.getComponentType());
2086                 }
2087                 @Override
2088                 protected String defaultAction(TypeMirror e, Void p) {
2089                     return &quot;R&quot;;
2090                 }
2091 
2092             }.visit(t);
2093         }
2094 
2095         /**
2096          * Compares two Elements, typically the name of a method,
2097          * field or constructor.
2098          * @param e1 the first Element.
2099          * @param e2 the second Element.
2100          * @return a negative integer, zero, or a positive integer as the first
2101          *         argument is less than, equal to, or greater than the second.
2102          */
2103         protected int compareNames(Element e1, Element e2) {
2104             return compareStrings(getSimpleName(e1), getSimpleName(e2));
2105         }
2106 
2107         /**
2108          * Compares the fully qualified names of the entities
2109          * @param e1 the first Element.
2110          * @param e2 the first Element.
2111          * @return a negative integer, zero, or a positive integer as the first
2112          *         argument is less than, equal to, or greater than the second.
2113          */
2114         protected int compareFullyQualifiedNames(Element e1, Element e2) {
2115             // add simplename to be compatible
2116             String thisElement = getFullyQualifiedName(e1);
2117             String thatElement = getFullyQualifiedName(e2);
2118             return compareStrings(thisElement, thatElement);
2119         }
2120 
2121         protected int compareElementKinds(Element e1, Element e2) {
2122             return Integer.compare(getKindIndex(e1), getKindIndex(e2));
2123         }
2124 
2125         private int getKindIndex(Element e) {
2126             switch (e.getKind()) {
2127                 case MODULE:            return 0;
2128                 case PACKAGE:           return 1;
2129                 case CLASS:             return 2;
2130                 case ENUM:              return 3;
2131                 case ENUM_CONSTANT:     return 4;
2132                 case RECORD:            return 5;
2133                 case INTERFACE:         return 6;
2134                 case ANNOTATION_TYPE:   return 7;
2135                 case FIELD:             return 8;
2136                 case CONSTRUCTOR:       return 9;
2137                 case METHOD:            return 10;
2138                 default: throw new IllegalArgumentException(e.getKind().toString());
2139             }
2140         }
2141 
2142         @SuppressWarnings(&quot;preview&quot;)
2143         boolean hasParameters(Element e) {
2144             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2145                 @Override
2146                 public Boolean visitExecutable(ExecutableElement e, Void p) {
2147                     return true;
2148                 }
2149 
2150                 @Override
2151                 protected Boolean defaultAction(Element e, Void p) {
2152                     return false;
2153                 }
2154 
2155             }.visit(e);
2156         }
2157 
2158         /**
2159          * The fully qualified names of the entities, used solely by the comparator.
2160          *
2161          * @return a negative integer, zero, or a positive integer as the first argument is less
2162          * than, equal to, or greater than the second.
2163          */
2164         @SuppressWarnings(&quot;preview&quot;)
2165         private String getFullyQualifiedName(Element e) {
2166             return new SimpleElementVisitor14&lt;String, Void&gt;() {
2167                 @Override
2168                 public String visitModule(ModuleElement e, Void p) {
2169                     return e.getQualifiedName().toString();
2170                 }
2171 
2172                 @Override
2173                 public String visitPackage(PackageElement e, Void p) {
2174                     return e.getQualifiedName().toString();
2175                 }
2176 
2177                 @Override
2178                 public String visitExecutable(ExecutableElement e, Void p) {
2179                     // For backward compatibility
2180                     return getFullyQualifiedName(e.getEnclosingElement())
2181                             + &quot;.&quot; + e.getSimpleName().toString();
2182                 }
2183 
2184                 @Override
2185                 public String visitType(TypeElement e, Void p) {
2186                     return e.getQualifiedName().toString();
2187                 }
2188 
2189                 @Override
2190                 protected String defaultAction(Element e, Void p) {
2191                     return getEnclosingTypeElement(e).getQualifiedName().toString()
2192                             + &quot;.&quot; + e.getSimpleName().toString();
2193                 }
2194             }.visit(e);
2195         }
2196     }
2197 
2198     /**
2199      * Returns a Comparator for SearchIndexItems representing types. Items are
2200      * compared by short name, or full string representation if names are equal.
2201      *
2202      * @return a Comparator
2203      */
2204     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {
2205         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2206             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());
2207             if (result == 0) {
2208                 // TreeSet needs this to be consistent with equal so we do
2209                 // a plain comparison of string representations as fallback.
2210                 result = sii1.toString().compareTo(sii2.toString());
2211             }
2212             return result;
2213         };
2214     }
2215 
2216     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;
2217     /**
2218      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.
2219      * Items are compared by label (member name plus signature for members, package name for
2220      * packages, and module name for modules). If labels are equal then full string
2221      * representation is compared.
2222      *
2223      * @return a Comparator
2224      */
2225     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {
2226         if (genericSearchIndexComparator == null) {
2227             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2228                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());
2229                 if (result == 0) {
2230                     // TreeSet needs this to be consistent with equal so we do
2231                     // a plain comparison of string representations as fallback.
2232                     result = sii1.toString().compareTo(sii2.toString());
2233                 }
2234                 return result;
2235             };
2236         }
2237         return genericSearchIndexComparator;
2238     }
2239 
2240     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2241         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2242         out.addAll(getClasses(pkg));
2243         out.addAll(getEnums(pkg));
2244         out.addAll(getAnnotationTypes(pkg));
2245         out.addAll(getRecords(pkg));
2246         return out;
2247     }
2248 
2249     // Element related methods
2250     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2251         List&lt;Element&gt; members = getAnnotationFields(aClass);
2252         members.addAll(getAnnotationMethods(aClass));
2253         return members;
2254     }
2255 
2256     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2257         return getItems0(aClass, true, FIELD);
2258     }
2259 
2260     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2261         return getItems0(aClass, true, FIELD);
2262     }
2263 
2264     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2265         return getItems0(aClass, true, METHOD);
2266     }
2267 
2268     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2269         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2270     }
2271 
2272     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2273         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2274     }
2275 
2276     @SuppressWarnings(&quot;preview&quot;)
2277     public List&lt;TypeElement&gt; getRecords(Element e) {
2278         return convertToTypeElement(getItems(e, true, RECORD));
2279     }
2280 
2281     @SuppressWarnings(&quot;preview&quot;)
2282     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
2283         return convertToTypeElement(getItems(e, false, RECORD));
2284     }
2285 
2286     public List&lt;VariableElement&gt; getFields(Element e) {
2287         return convertToVariableElement(getItems(e, true, FIELD));
2288     }
2289 
2290     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2291         return convertToVariableElement(getItems(e, false, FIELD));
2292     }
2293 
2294     public List&lt;TypeElement&gt; getClasses(Element e) {
2295        return convertToTypeElement(getItems(e, true, CLASS));
2296     }
2297 
2298     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2299        return convertToTypeElement(getItems(e, false, CLASS));
2300     }
2301 
2302     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2303         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2304     }
2305 
2306     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2307         return convertToExecutableElement(getItems(e, true, METHOD));
2308     }
2309 
2310     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2311         return convertToExecutableElement(getItems(e, false, METHOD));
2312     }
2313 
2314     public int getOrdinalValue(VariableElement member) {
2315         if (member == null || member.getKind() != ENUM_CONSTANT) {
2316             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2317         }
2318         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2319     }
2320 
2321     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2322     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2323         if (modulePackageMap == null) {
2324             modulePackageMap = new HashMap&lt;&gt;();
2325             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
2326             pkgs.forEach((pkg) -&gt; {
2327                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2328                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2329             });
2330         }
2331         return modulePackageMap;
2332     }
2333 
2334     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2335         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2336         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2337         // get all the requires for the element in question
2338         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2339             ModuleElement dep = rd.getDependency();
2340             // add the dependency to work queue
2341             if (!result.containsKey(dep)) {
2342                 if (rd.isTransitive()) {
2343                     queue.addLast(dep);
2344                 }
2345             }
2346             // add all exports for the primary module
2347             result.put(rd.getDependency(), getModifiers(rd));
2348         }
2349 
2350         // add only requires public for subsequent module dependencies
2351         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2352             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2353                 ModuleElement dep = rd.getDependency();
2354                 if (!result.containsKey(dep)) {
2355                     if (rd.isTransitive()) {
2356                         result.put(dep, getModifiers(rd));
2357                         queue.addLast(dep);
2358                     }
2359                 }
2360             }
2361         }
2362         return result;
2363     }
2364 
2365     public String getModifiers(RequiresDirective rd) {
2366         StringBuilder modifiers = new StringBuilder();
2367         String sep=&quot;&quot;;
2368         if (rd.isTransitive()) {
2369             modifiers.append(&quot;transitive&quot;);
2370             sep = &quot; &quot;;
2371         }
2372         if (rd.isStatic()) {
2373             modifiers.append(sep);
2374             modifiers.append(&quot;static&quot;);
2375         }
2376         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2377     }
2378 
2379     public long getLineNumber(Element e) {
2380         TreePath path = getTreePath(e);
2381         if (path == null) { // maybe null if synthesized
2382             TypeElement encl = getEnclosingTypeElement(e);
2383             path = getTreePath(encl);
2384         }
2385         CompilationUnitTree cu = path.getCompilationUnit();
2386         LineMap lineMap = cu.getLineMap();
2387         DocSourcePositions spos = docTrees.getSourcePositions();
2388         long pos = spos.getStartPosition(cu, path.getLeaf());
2389         return lineMap.getLineNumber(pos);
2390     }
2391 
2392     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
2393         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2394         for (Element e : list) {
2395             out.add((ExecutableElement)e);
2396         }
2397         return out;
2398     }
2399 
2400     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
2401         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
2402         for (Element e : list) {
2403             out.add((TypeElement)e);
2404         }
2405         return out;
2406     }
2407 
2408     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
2409         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2410         for (Element e : list) {
2411             out.add((VariableElement) e);
2412         }
2413         return out;
2414     }
2415 
2416     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
2417         return convertToTypeElement(getItems(e, true, INTERFACE));
2418     }
2419 
2420     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2421         return convertToTypeElement(getItems(e, false, INTERFACE));
2422     }
2423 
2424     public List&lt;Element&gt; getEnumConstants(Element e) {
2425         return getItems(e, true, ENUM_CONSTANT);
2426     }
2427 
2428     public List&lt;TypeElement&gt; getEnums(Element e) {
2429         return convertToTypeElement(getItems(e, true, ENUM));
2430     }
2431 
2432     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2433         return convertToTypeElement(getItems(e, false, ENUM));
2434     }
2435 
2436     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2437         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2438         clist.addAll(getInterfacesUnfiltered(e));
2439         clist.addAll(getAnnotationTypesUnfiltered(e));
2440         clist.addAll(getRecordsUnfiltered(e));
2441         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2442         oset.addAll(clist);
2443         return oset;
2444     }
2445 
2446     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2447     /**
2448      * Returns a list containing classes and interfaces,
2449      * including annotation types.
2450      * @param e Element
2451      * @return List
2452      */
2453     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2454         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2455         if (oset != null)
2456             return oset;
2457         List&lt;TypeElement&gt; clist = getClasses(e);
2458         clist.addAll(getInterfaces(e));
2459         clist.addAll(getAnnotationTypes(e));
2460         clist.addAll(getEnums(e));
2461         clist.addAll(getRecords(e));
2462         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2463         oset.addAll(clist);
2464         cachedClasses.put(e, oset);
2465         return oset;
2466     }
2467 
2468     /*
2469      * Get all the elements unfiltered and filter them finally based
2470      * on its visibility, this works differently from the other getters.
2471      */
2472     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2473         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2474         for (TypeElement te : getClassesUnfiltered(e)) {
2475             if (!filter || configuration.docEnv.isSelected(te)) {
2476                 olist.add(te);
2477             }
2478         }
2479         for (TypeElement te : getInterfacesUnfiltered(e)) {
2480             if (!filter || configuration.docEnv.isSelected(te)) {
2481                 olist.add(te);
2482             }
2483         }
2484         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2485             if (!filter || configuration.docEnv.isSelected(te)) {
2486                 olist.add(te);
2487             }
2488         }
2489         for (TypeElement te : getEnumsUnfiltered(e)) {
2490             if (!filter || configuration.docEnv.isSelected(te)) {
2491                 olist.add(te);
2492             }
2493         }
2494         return olist;
2495     }
2496 
2497     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2498         return getInnerClasses(e, true);
2499     }
2500 
2501     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2502         return getInnerClasses(e, false);
2503     }
2504 
2505     /**
2506      * Returns a list of classes that are not errors or exceptions
2507      * @param e Element
2508      * @return List
2509      */
2510     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2511         return getClasses(e).stream()
2512                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2513                 .collect(Collectors.toList());
2514     }
2515 
2516     public List&lt;TypeElement&gt; getErrors(Element e) {
2517         return getClasses(e)
2518                 .stream()
2519                 .filter(this::isError)
2520                 .collect(Collectors.toList());
2521     }
2522 
2523     public List&lt;TypeElement&gt; getExceptions(Element e) {
2524         return getClasses(e)
2525                 .stream()
2526                 .filter(this::isException)
2527                 .collect(Collectors.toList());
2528     }
2529 
2530     @SuppressWarnings(&quot;preview&quot;)
2531     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2532         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2533         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2534 
2535             @Override
2536             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2537                 recursiveGetItems(elements, e, filter, select);
2538                 return elements;
2539             }
2540 
2541             @Override
2542             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2543                 return getItems0(e0, filter, select);
2544             }
2545 
2546         }.visit(e);
2547     }
2548 
2549     EnumSet&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2550     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2551         list.addAll(getItems0(e, filter, select));
2552         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2553         for (Element c : classes) {
2554             list.addAll(getItems0(c, filter, select));
2555             if (isTypeElement(c)) {
2556                 recursiveGetItems(list, c, filter, select);
2557             }
2558         }
2559     }
2560 
2561     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2562         EnumSet&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2563         return getItems0(te, filter, kinds);
2564     }
2565 
2566     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2567         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2568         for (Element e : te.getEnclosedElements()) {
2569             if (kinds.contains(e.getKind())) {
2570                 if (!filter || shouldDocument(e)) {
2571                     elements.add(e);
2572                 }
2573             }
2574         }
2575         return elements;
2576     }
2577 
2578     @SuppressWarnings(&quot;preview&quot;)
2579     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2580 
2581     @SuppressWarnings(&quot;preview&quot;)
2582     public boolean shouldDocument(Element e) {
2583         if (shouldDocumentVisitor == null) {
2584             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2585                 private boolean hasSource(TypeElement e) {
2586                     return configuration.docEnv.getFileKind(e) ==
2587                             javax.tools.JavaFileObject.Kind.SOURCE;
2588                 }
2589 
2590                 // handle types
2591                 @Override
2592                 public Boolean visitType(TypeElement e, Void p) {
2593                     // treat inner classes etc as members
2594                     if (e.getNestingKind().isNested()) {
2595                         return defaultAction(e, p);
2596                     }
2597                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2598                 }
2599 
2600                 // handle everything else
2601                 @Override
2602                 protected Boolean defaultAction(Element e, Void p) {
2603                     return configuration.docEnv.isSelected(e);
2604                 }
2605 
2606                 @Override
2607                 public Boolean visitUnknown(Element e, Void p) {
2608                     throw new AssertionError(&quot;unknown element: &quot; + e);
2609                 }
2610             };
2611         }
2612         return shouldDocumentVisitor.visit(e);
2613     }
2614 
2615     /*
2616      * nameCache is maintained for improving the comparator
2617      * performance, noting that the Collator used by the comparators
2618      * use Strings, as of this writing.
2619      * TODO: when those APIs handle charSequences, the use of
2620      * this nameCache must be re-investigated and removed.
2621      */
2622     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2623 
2624     /**
2625      * Returns the name of the element after the last dot of the package name.
2626      * This emulates the behavior of the old doclet.
2627      * @param e an element whose name is required
2628      * @return the name
2629      */
2630     public String getSimpleName(Element e) {
2631         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2632     }
2633 
2634     @SuppressWarnings(&quot;preview&quot;)
2635     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2636 
2637     @SuppressWarnings(&quot;preview&quot;)
2638     private String getSimpleName0(Element e) {
2639         if (snvisitor == null) {
2640             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2641                 @Override
2642                 public String visitModule(ModuleElement e, Void p) {
2643                     return e.getQualifiedName().toString();  // temp fix for 8182736
2644                 }
2645 
2646                 @Override
2647                 public String visitType(TypeElement e, Void p) {
2648                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2649                     Element enclosed = e.getEnclosingElement();
2650                     while (enclosed != null
2651                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2652                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2653                         enclosed = enclosed.getEnclosingElement();
2654                     }
2655                     return sb.toString();
2656                 }
2657 
2658                 @Override
2659                 public String visitExecutable(ExecutableElement e, Void p) {
2660                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2661                         return e.getEnclosingElement().getSimpleName().toString();
2662                     }
2663                     return e.getSimpleName().toString();
2664                 }
2665 
2666                 @Override
2667                 protected String defaultAction(Element e, Void p) {
2668                     return e.getSimpleName().toString();
2669                 }
2670             };
2671         }
2672         return snvisitor.visit(e);
2673     }
2674 
2675     public TypeElement getEnclosingTypeElement(Element e) {
2676         if (e.getKind() == ElementKind.PACKAGE)
2677             return null;
2678         Element encl = e.getEnclosingElement();
2679         ElementKind kind = encl.getKind();
2680         if (kind == ElementKind.PACKAGE)
2681             return null;
2682         while (!(kind.isClass() || kind.isInterface())) {
2683             encl = encl.getEnclosingElement();
2684             kind = encl.getKind();
2685         }
2686         return (TypeElement)encl;
2687     }
2688 
2689     private ConstantValueExpression cve = null;
2690 
2691     public String constantValueExpresion(VariableElement ve) {
2692         if (cve == null)
2693             cve = new ConstantValueExpression();
2694         return cve.constantValueExpression(configuration.workArounds, ve);
2695     }
2696 
2697     private static class ConstantValueExpression {
2698         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2699             return new TypeKindVisitor9&lt;String, Object&gt;() {
2700                 /* TODO: we need to fix this correctly.
2701                  * we have a discrepancy here, note the use of getConstValue
2702                  * vs. getConstantValue, at some point we need to use
2703                  * getConstantValue.
2704                  * In the legacy world byte and char primitives appear as Integer values,
2705                  * thus a byte value of 127 will appear as 127, but in the new world,
2706                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2707                  * chars will be  translated to \n, \r etc. however, in the new world,
2708                  * they will be printed as decimal values. The new world is correct,
2709                  * and we should fix this by using getConstantValue and the visitor to
2710                  * address this in the future.
2711                  */
2712                 @Override
2713                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2714                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2715                 }
2716 
2717                 @Override
2718                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2719                     return sourceForm(((Double)val), &#39;d&#39;);
2720                 }
2721 
2722                 @Override
2723                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2724                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2725                 }
2726 
2727                 @Override
2728                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2729                     return val + &quot;L&quot;;
2730                 }
2731 
2732                 @Override
2733                 protected String defaultAction(TypeMirror e, Object val) {
2734                     if (val == null)
2735                         return null;
2736                     else if (val instanceof Character)
2737                         return sourceForm(((Character)val));
2738                     else if (val instanceof Byte)
2739                         return sourceForm(((Byte)val));
2740                     else if (val instanceof String)
2741                         return sourceForm((String)val);
2742                     return val.toString(); // covers int, short
2743                 }
2744             }.visit(ve.asType(), workArounds.getConstValue(ve));
2745         }
2746 
2747         // where
2748         private String sourceForm(double v, char suffix) {
2749             if (Double.isNaN(v))
2750                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2751             if (v == Double.POSITIVE_INFINITY)
2752                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2753             if (v == Double.NEGATIVE_INFINITY)
2754                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2755             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2756         }
2757 
2758         private  String sourceForm(char c) {
2759             StringBuilder buf = new StringBuilder(8);
2760             buf.append(&#39;\&#39;&#39;);
2761             sourceChar(c, buf);
2762             buf.append(&#39;\&#39;&#39;);
2763             return buf.toString();
2764         }
2765 
2766         private String sourceForm(byte c) {
2767             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2768         }
2769 
2770         private String sourceForm(String s) {
2771             StringBuilder buf = new StringBuilder(s.length() + 5);
2772             buf.append(&#39;\&quot;&#39;);
2773             for (int i=0; i&lt;s.length(); i++) {
2774                 char c = s.charAt(i);
2775                 sourceChar(c, buf);
2776             }
2777             buf.append(&#39;\&quot;&#39;);
2778             return buf.toString();
2779         }
2780 
2781         private void sourceChar(char c, StringBuilder buf) {
2782             switch (c) {
2783             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2784             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2785             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2786             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2787             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2788             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2789             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2790             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2791             default:
2792                 if (isPrintableAscii(c)) {
2793                     buf.append(c); return;
2794                 }
2795                 unicodeEscape(c, buf);
2796                 return;
2797             }
2798         }
2799 
2800         private void unicodeEscape(char c, StringBuilder buf) {
2801             final String chars = &quot;0123456789abcdef&quot;;
2802             buf.append(&quot;\\u&quot;);
2803             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2804             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2805             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2806             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2807         }
2808         private boolean isPrintableAscii(char c) {
2809             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2810         }
2811     }
2812 
2813     public boolean isEnclosingPackageIncluded(TypeElement te) {
2814         return isIncluded(containingPackage(te));
2815     }
2816 
2817     public boolean isIncluded(Element e) {
2818         return configuration.docEnv.isIncluded(e);
2819     }
2820 
2821     @SuppressWarnings(&quot;preview&quot;)
2822     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2823     @SuppressWarnings(&quot;preview&quot;)
2824     public boolean isSpecified(Element e) {
2825         if (specifiedVisitor == null) {
2826             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2827                 @Override
2828                 public Boolean visitModule(ModuleElement e, Void p) {
2829                     return configuration.getSpecifiedModuleElements().contains(e);
2830                 }
2831 
2832                 @Override
2833                 public Boolean visitPackage(PackageElement e, Void p) {
2834                     return configuration.getSpecifiedPackageElements().contains(e);
2835                 }
2836 
2837                 @Override
2838                 public Boolean visitType(TypeElement e, Void p) {
2839                     return configuration.getSpecifiedTypeElements().contains(e);
2840                 }
2841 
2842                 @Override
2843                 protected Boolean defaultAction(Element e, Void p) {
2844                     return false;
2845                 }
2846             };
2847         }
2848         return specifiedVisitor.visit(e);
2849     }
2850 
2851     /**
2852      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2853      *
2854      * @param pkg
2855      * @return
2856      */
2857     public String getPackageName(PackageElement pkg) {
2858         if (pkg == null || pkg.isUnnamed()) {
2859             return DocletConstants.DEFAULT_PACKAGE_NAME;
2860         }
2861         return pkg.getQualifiedName().toString();
2862     }
2863 
2864     /**
2865      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2866      *
2867      * @param mdle a ModuleElement
2868      * @return
2869      */
2870     public String getModuleName(ModuleElement mdle) {
2871         if (mdle == null || mdle.isUnnamed()) {
2872             return DocletConstants.DEFAULT_ELEMENT_NAME;
2873         }
2874         return mdle.getQualifiedName().toString();
2875     }
2876 
2877     public boolean isAttribute(DocTree doctree) {
2878         return isKind(doctree, ATTRIBUTE);
2879     }
2880 
2881     public boolean isAuthor(DocTree doctree) {
2882         return isKind(doctree, AUTHOR);
2883     }
2884 
2885     public boolean isComment(DocTree doctree) {
2886         return isKind(doctree, COMMENT);
2887     }
2888 
2889     public boolean isDeprecated(DocTree doctree) {
2890         return isKind(doctree, DEPRECATED);
2891     }
2892 
2893     public boolean isDocComment(DocTree doctree) {
2894         return isKind(doctree, DOC_COMMENT);
2895     }
2896 
2897     public boolean isDocRoot(DocTree doctree) {
2898         return isKind(doctree, DOC_ROOT);
2899     }
2900 
2901     public boolean isEndElement(DocTree doctree) {
2902         return isKind(doctree, END_ELEMENT);
2903     }
2904 
2905     public boolean isEntity(DocTree doctree) {
2906         return isKind(doctree, ENTITY);
2907     }
2908 
2909     public boolean isErroneous(DocTree doctree) {
2910         return isKind(doctree, ERRONEOUS);
2911     }
2912 
2913     public boolean isException(DocTree doctree) {
2914         return isKind(doctree, EXCEPTION);
2915     }
2916 
2917     public boolean isIdentifier(DocTree doctree) {
2918         return isKind(doctree, IDENTIFIER);
2919     }
2920 
2921     public boolean isInheritDoc(DocTree doctree) {
2922         return isKind(doctree, INHERIT_DOC);
2923     }
2924 
2925     public boolean isLink(DocTree doctree) {
2926         return isKind(doctree, LINK);
2927     }
2928 
2929     public boolean isLinkPlain(DocTree doctree) {
2930         return isKind(doctree, LINK_PLAIN);
2931     }
2932 
2933     public boolean isLiteral(DocTree doctree) {
2934         return isKind(doctree, LITERAL);
2935     }
2936 
2937     public boolean isOther(DocTree doctree) {
2938         return doctree.getKind() == DocTree.Kind.OTHER;
2939     }
2940 
2941     public boolean isParam(DocTree doctree) {
2942         return isKind(doctree, PARAM);
2943     }
2944 
2945     public boolean isReference(DocTree doctree) {
2946         return isKind(doctree, REFERENCE);
2947     }
2948 
2949     public boolean isReturn(DocTree doctree) {
2950         return isKind(doctree, RETURN);
2951     }
2952 
2953     public boolean isSee(DocTree doctree) {
2954         return isKind(doctree, SEE);
2955     }
2956 
2957     public boolean isSerial(DocTree doctree) {
2958         return isKind(doctree, SERIAL);
2959     }
2960 
2961     public boolean isSerialData(DocTree doctree) {
2962         return isKind(doctree, SERIAL_DATA);
2963     }
2964 
2965     public boolean isSerialField(DocTree doctree) {
2966         return isKind(doctree, SERIAL_FIELD);
2967     }
2968 
2969     public boolean isSince(DocTree doctree) {
2970         return isKind(doctree, SINCE);
2971     }
2972 
2973     public boolean isStartElement(DocTree doctree) {
2974         return isKind(doctree, START_ELEMENT);
2975     }
2976 
2977     public boolean isText(DocTree doctree) {
2978         return isKind(doctree, TEXT);
2979     }
2980 
2981     public boolean isThrows(DocTree doctree) {
2982         return isKind(doctree, THROWS);
2983     }
2984 
2985     public boolean isUnknownBlockTag(DocTree doctree) {
2986         return isKind(doctree, UNKNOWN_BLOCK_TAG);
2987     }
2988 
2989     public boolean isUnknownInlineTag(DocTree doctree) {
2990         return isKind(doctree, UNKNOWN_INLINE_TAG);
2991     }
2992 
2993     public boolean isValue(DocTree doctree) {
2994         return isKind(doctree, VALUE);
2995     }
2996 
2997     public boolean isVersion(DocTree doctree) {
2998         return isKind(doctree, VERSION);
2999     }
3000 
3001     private boolean isKind(DocTree doctree, DocTree.Kind match) {
3002         return  doctree.getKind() == match;
3003     }
3004 
3005     private final WeakSoftHashMap wksMap = new WeakSoftHashMap(this);
3006 
3007     public CommentHelper getCommentHelper(Element element) {
3008         return wksMap.computeIfAbsent(element);
3009     }
3010 
3011     public void removeCommentHelper(Element element) {
3012         wksMap.remove(element);
3013     }
3014 
3015     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
3016         DocCommentTree dcTree = getDocCommentTree(element);
3017         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
3018     }
3019 
3020     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
3021         return getBlockTags(element).stream()
3022                 .filter(t -&gt; t.getKind() != ERRONEOUS)
3023                 .filter(filter)
3024                 .collect(Collectors.toList());
3025     }
3026 
3027     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
3028         return getBlockTags(element, t -&gt; t.getKind() == kind);
3029     }
3030 
3031     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
3032         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
3033     }
3034 
3035     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
3036         return getBlockTags(element, t -&gt; {
3037             if (taglet instanceof BaseTaglet) {
3038                 return ((BaseTaglet) taglet).accepts(t);
3039             } else if (t instanceof UnknownBlockTagTree) {
3040                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
3041             } else {
3042                 return false;
3043             }
3044         });
3045     }
3046 
3047     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3048         return hasBlockTag(element, kind, null);
3049     }
3050 
3051     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3052         CommentHelper ch = getCommentHelper(element);
3053         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3054                 ? tagName.substring(1)
3055                 : tagName;
3056         for (DocTree dt : getBlockTags(element, kind)) {
3057             if (dt.getKind() == kind) {
3058                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3059                     return true;
3060                 }
3061             }
3062         }
3063         return false;
3064     }
3065 
3066     /**
3067      * Gets a TreePath for an Element. Note this method is called very
3068      * frequently, care must be taken to ensure this method is lithe
3069      * and efficient.
3070      * @param e an Element
3071      * @return TreePath
3072      */
3073     public TreePath getTreePath(Element e) {
3074         DocCommentDuo duo = dcTreeCache.get(e);
3075         if (duo != null &amp;&amp; duo.treePath != null) {
3076             return duo.treePath;
3077         }
3078         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
3079         if (duo != null &amp;&amp; duo.treePath != null) {
3080             return duo.treePath;
3081         }
3082         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3083         TreePath path = elementToTreePath.get(e);
3084         if (path != null || elementToTreePath.containsKey(e)) {
3085             // expedite the path and one that is a null
3086             return path;
3087         }
3088         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3089     }
3090 
3091     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3092 
3093     /**
3094      * Retrieves the doc comments for a given element.
3095      * @param element
3096      * @return DocCommentTree for the Element
3097      */
3098     public DocCommentTree getDocCommentTree0(Element element) {
3099 
3100         DocCommentDuo duo = null;
3101 
3102         ElementKind kind = element.getKind();
3103         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3104             duo = dcTreeCache.get(element); // local cache
3105             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {
3106                 // package-info.java
3107                 duo = getDocCommentTuple(element);
3108             }
3109             if (duo == null) {
3110                 // package.html or overview.html
3111                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3112             }
3113         } else {
3114             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
3115             if (duo == null) {
3116                 duo = dcTreeCache.get(element); // local cache
3117             }
3118             if (duo == null) {
3119                 duo = getDocCommentTuple(element); // get the real mccoy
3120             }
3121         }
3122 
3123         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3124         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3125         if (!dcTreeCache.containsKey(element)) {
3126             if (docCommentTree != null &amp;&amp; path != null) {
3127                 if (!configuration.isAllowScriptInComments()) {
3128                     try {
3129                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3130                             throw new JavaScriptScanner.Fault();
3131                         });
3132                     } catch (JavaScriptScanner.Fault jsf) {
3133                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3134                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3135                     }
3136                 }
3137                 configuration.workArounds.runDocLint(path);
3138             }
3139             dcTreeCache.put(element, duo);
3140         }
3141         return docCommentTree;
3142     }
3143 
3144     private DocCommentDuo getDocCommentTuple(Element element) {
3145         // prevent nasty things downstream with overview element
3146         if (element.getKind() != ElementKind.OTHER) {
3147             TreePath path = getTreePath(element);
3148             if (path != null) {
3149                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
3150                 return new DocCommentDuo(path, docCommentTree);
3151             }
3152         }
3153         return null;
3154     }
3155 
3156     public void checkJavaScriptInOption(String name, String value) {
3157         if (!configuration.isAllowScriptInComments()) {
3158             DocCommentTree dct = configuration.cmtUtils.parse(
3159                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
3160 
3161             if (dct == null)
3162                 return;
3163 
3164             try {
3165                 javaScriptScanner.scan(dct, null, p -&gt; {
3166                     throw new JavaScriptScanner.Fault();
3167                 });
3168             } catch (JavaScriptScanner.Fault jsf) {
3169                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3170                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3171             }
3172         }
3173     }
3174 
3175     boolean isValidDuo(DocCommentDuo duo) {
3176         return duo != null &amp;&amp; duo.dcTree != null;
3177     }
3178 
3179     public DocCommentTree getDocCommentTree(Element element) {
3180         CommentHelper ch = wksMap.get(element);
3181         if (ch != null) {
3182             return ch.dctree;
3183         }
3184         DocCommentTree dcTree = getDocCommentTree0(element);
3185         if (dcTree != null) {
3186             wksMap.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
3187         }
3188         return dcTree;
3189     }
3190 
3191     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3192         DocCommentTree docCommentTree = getDocCommentTree(element);
3193         return docCommentTree == null
3194                 ? Collections.emptyList()
3195                 : docCommentTree.getPreamble();
3196     }
3197 
3198     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3199         DocCommentTree docCommentTree = getDocCommentTree(element);
3200             return (docCommentTree == null)
3201                     ? Collections.emptyList()
3202                     : docCommentTree.getFullBody();
3203     }
3204 
3205     public List&lt;? extends DocTree&gt; getBody(Element element) {
3206         DocCommentTree docCommentTree = getDocCommentTree(element);
3207         return (docCommentTree == null)
3208                 ? Collections.emptyList()
3209                 : docCommentTree.getFullBody();
3210     }
3211 
3212     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
3213         return getBlockTags(element, DEPRECATED);
3214     }
3215 
3216     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3217         return getBlockTags(element, PROVIDES);
3218     }
3219 
3220     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3221         return getBlockTags(element, SEE);
3222     }
3223 
3224     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3225         return getBlockTags(element, SERIAL);
3226     }
3227 
3228     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3229         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3230     }
3231 
3232     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3233         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3234     }
3235 
3236     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3237         return getParamTrees(element, true);
3238     }
3239 
3240     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3241         return getParamTrees(element, false);
3242     }
3243 
3244     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3245         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3246         for (DocTree dt : getBlockTags(element, PARAM)) {
3247             ParamTree pt = (ParamTree) dt;
3248             if (pt.isTypeParameter() == isTypeParameters) {
3249                 out.add(pt);
3250             }
3251         }
3252         return out;
3253     }
3254 
3255     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
3256         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();
3257         for (DocTree dt : getBlockTags(element, RETURN)) {
3258             out.add(dt);
3259         }
3260         return out;
3261     }
3262 
3263     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3264         return getBlockTags(element, USES);
3265     }
3266 
3267     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3268         DocCommentTree dcTree = getDocCommentTree(element);
3269         if (dcTree == null) {
3270             return Collections.emptyList();
3271         }
3272         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();
3273         for (DocTree dt : dcTree.getFirstSentence()) {
3274             out.add(dt);
3275         }
3276         return out;
3277     }
3278 
3279     public ModuleElement containingModule(Element e) {
3280         return elementUtils.getModuleOf(e);
3281     }
3282 
3283     public PackageElement containingPackage(Element e) {
3284         return elementUtils.getPackageOf(e);
3285     }
3286 
3287     public TypeElement getTopMostContainingTypeElement(Element e) {
3288         if (isPackage(e)) {
3289             return null;
3290         }
3291         TypeElement outer = getEnclosingTypeElement(e);
3292         if (outer == null)
3293             return (TypeElement)e;
3294         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3295             outer = getEnclosingTypeElement(outer);
3296         }
3297         return outer;
3298     }
3299 
3300     static class WeakSoftHashMap implements Map&lt;Element, CommentHelper&gt; {
3301 
3302         private final WeakHashMap&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; wkMap;
3303         private final Utils utils;
3304         public WeakSoftHashMap(Utils utils) {
3305             wkMap = new WeakHashMap&lt;&gt;();
3306             this.utils = utils;
3307         }
3308 
3309         @Override
3310         public boolean containsKey(Object key) {
3311             return wkMap.containsKey(key);
3312         }
3313 
3314         @Override
3315         public Collection&lt;CommentHelper&gt; values() {
3316             Set&lt;CommentHelper&gt; out = new LinkedHashSet&lt;&gt;();
3317             for (SoftReference&lt;CommentHelper&gt; v : wkMap.values()) {
3318                 out.add(v.get());
3319             }
3320             return out;
3321         }
3322 
3323         @Override
3324         public boolean containsValue(Object value) {
3325             return wkMap.containsValue(new SoftReference&lt;&gt;((CommentHelper)value));
3326         }
3327 
3328         @Override
3329         public CommentHelper remove(Object key) {
3330             SoftReference&lt;CommentHelper&gt; value = wkMap.remove(key);
3331             return value == null ? null : value.get();
3332         }
3333 
3334 
3335         @Override
3336         public CommentHelper put(Element key, CommentHelper value) {
3337             SoftReference&lt;CommentHelper&gt; nvalue = wkMap.put(key, new SoftReference&lt;&gt;(value));
3338             return nvalue == null ? null : nvalue.get();
3339         }
3340 
3341         @Override
3342         public CommentHelper get(Object key) {
3343             SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);
3344             return value == null ? null : value.get();
3345         }
3346 
3347         @Override
3348         public int size() {
3349             return wkMap.size();
3350         }
3351 
3352         @Override
3353         public boolean isEmpty() {
3354             return wkMap.isEmpty();
3355         }
3356 
3357         @Override
3358         public void clear() {
3359             wkMap.clear();
3360         }
3361 
3362         public CommentHelper computeIfAbsent(Element key) {
3363             if (wkMap.containsKey(key)) {
3364                 SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);
3365                 if (value != null) {
3366                     CommentHelper cvalue = value.get();
3367                     if (cvalue != null) {
3368                         return cvalue;
3369                     }
3370                 }
3371             }
3372             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3373                     utils.getDocCommentTree(key));
3374             wkMap.put(key, new SoftReference&lt;&gt;(newValue));
3375             return newValue;
3376         }
3377 
3378 
3379         @Override
3380         public void putAll(Map&lt;? extends Element, ? extends CommentHelper&gt; map) {
3381             for (Map.Entry&lt;? extends Element, ? extends CommentHelper&gt; entry : map.entrySet()) {
3382                 put(entry.getKey(), entry.getValue());
3383             }
3384         }
3385 
3386         @Override
3387         public Set&lt;Element&gt; keySet() {
3388             return wkMap.keySet();
3389         }
3390 
3391         @Override
3392         public Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; entrySet() {
3393             Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; out = new LinkedHashSet&lt;&gt;();
3394             for (Element e : wkMap.keySet()) {
3395                 SimpleEntry&lt;Element, CommentHelper&gt; n = new SimpleEntry&lt;&gt;(e, get(e));
3396                 out.add(n);
3397             }
3398             return out;
3399         }
3400     }
3401 
3402     /**
3403      * A simple pair container.
3404      * @param &lt;K&gt; first a value
3405      * @param &lt;L&gt; second another value
3406      */
3407     public static class Pair&lt;K, L&gt; {
3408         public final K first;
3409         public final L second;
3410 
3411         public Pair(K first, L second) {
3412             this.first = first;
3413             this.second = second;
3414         }
3415 
3416         public String toString() {
3417             StringBuffer out = new StringBuffer();
3418             out.append(first + &quot;:&quot; + second);
3419             return out.toString();
3420         }
3421     }
3422 }
    </pre>
  </body>
</html>