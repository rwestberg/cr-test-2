diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/AbstractLayout.java
@@ -54,10 +54,17 @@
 
     Optional<String> optName() {
         return Optional.ofNullable((String)annotations.get(NAME));
     }
 
+    // memory layout annotation key for abi native type
+    static final String NATIVE_TYPE = "abi/native-type";
+
+    Optional<SystemABI.Type> optABIType() {
+        return Optional.ofNullable((SystemABI.Type)annotations.get(NATIVE_TYPE));
+    }
+
     @Override
     public AbstractLayout withName(String name) {
         return withAnnotation(NAME, name);
     }
 
@@ -71,10 +78,15 @@
     @Override
     public final Optional<String> name() {
         return optName();
     }
 
+    @Override
+    public final Optional<SystemABI.Type> abiType() {
+        return optABIType();
+    }
+
     abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);
 
     @Override
     public AbstractLayout withBitAlignment(long alignmentBits) {
         checkAlignment(alignmentBits);
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayout.java
@@ -224,10 +224,17 @@
      * @return the layout <em>name</em> (if any).
      * @see MemoryLayout#withName(String)
      */
     Optional<String> name();
 
+    /**
+     * Return the ABI <em>type</em> (if any) associated with this layout.
+     *
+     * @return the layout ABI <em>type</em> (if any).
+     */
+    Optional<SystemABI.Type> abiType();
+
     /**
      * Creates a new layout which features the desired layout <em>name</em>.
      *
      * @param name the layout name.
      * @return a new layout which is the same as this layout, except for the <em>name</em> associated to it.
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryLayouts.java
@@ -24,12 +24,10 @@
  *
  */
 
 package jdk.incubator.foreign;
 
-import jdk.internal.foreign.abi.ArgumentClass;
-import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
 
 import java.nio.ByteOrder;
 
 import static jdk.incubator.foreign.SystemABI.ABI_AARCH64;
@@ -287,205 +285,206 @@
 
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
 
 
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
 
         /**
          * The {@code char} native type.
          */
-        public static final ValueLayout C_CHAR = C_SCHAR;
+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.SSE);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.SSE);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code long double} native type.
          */
         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.X87);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_DOUBLE);
 
         /**
          * The {@code complex long double} native type.
          */
         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.COMPLEX_X87);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.COMPLEX_LONG_DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.POINTER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
     }
 
     /**
      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
      */
     public static final class WinABI {
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
         
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
         /**
          * The {@code char} native type.
          */
         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.SSE);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.SSE);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, ArgumentClassImpl.POINTER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
 
         public static ValueLayout asVarArg(ValueLayout l) {
            return l.withAnnotation(Windowsx64ABI.VARARGS_ANNOTATION_NAME, "true");
         }
     }
@@ -496,92 +495,92 @@
     public static final class AArch64ABI {
         /**
          * The {@code _Bool} native type.
          */
         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.BOOL);
 
         /**
          * The {@code unsigned char} native type.
          */
         public static final ValueLayout C_UCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_CHAR);
 
         /**
          * The {@code signed char} native type.
          */
         public static final ValueLayout C_SCHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SIGNED_CHAR);
 
         /**
          * The {@code char} native type.
          */
         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.CHAR);
 
         /**
          * The {@code short} native type.
          */
         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.SHORT);
 
         /**
          * The {@code unsigned short} native type.
          */
         public static final ValueLayout C_USHORT = MemoryLayouts.BITS_16_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_SHORT);
 
         /**
          * The {@code int} native type.
          */
         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.INT);
 
         /**
          * The {@code unsigned int} native type.
          */
         public static final ValueLayout C_UINT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_INT);
 
         /**
          * The {@code long} native type.
          */
         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG);
 
         /**
          * The {@code unsigned long} native type.
          */
         public static final ValueLayout C_ULONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG);
 
         /**
          * The {@code long long} native type.
          */
         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.LONG_LONG);
 
         /**
          * The {@code unsigned long long} native type.
          */
         public static final ValueLayout C_ULONGLONG = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.INTEGER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.UNSIGNED_LONG_LONG);
 
         /**
          * The {@code float} native type.
          */
         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.VECTOR);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.FLOAT);
 
         /**
          * The {@code double} native type.
          */
         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.VECTOR);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.DOUBLE);
 
         /**
          * The {@code T*} native type.
          */
         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
-                .withAnnotation(ArgumentClass.ABI_CLASS, jdk.internal.foreign.abi.aarch64.ArgumentClassImpl.POINTER);
+                .withAnnotation(AbstractLayout.NATIVE_TYPE, SystemABI.Type.POINTER);
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/SystemABI.java
@@ -30,16 +30,16 @@
 import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
 import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
+import java.util.Optional;
 
 /**
  * This class models a system application binary interface (ABI).
  */
 public interface SystemABI {
-
     /**
      * The name of the SysV ABI
      */
     String ABI_SYSV = "SysV";
 
@@ -108,6 +108,98 @@
         } else if (arch.equals("aarch64")) {
             return AArch64ABI.getInstance();
         }
         throw new UnsupportedOperationException("Unsupported os or arch: " + os + ", " + arch);
     }
+
+    public enum Type {
+        /**
+         * The {@code _Bool} native type.
+         */
+        BOOL,
+
+        /**
+         * The {@code unsigned char} native type.
+         */
+        UNSIGNED_CHAR,
+
+        /**
+         * The {@code signed char} native type.
+         */
+        SIGNED_CHAR,
+
+        /**
+         * The {@code char} native type.
+         */
+        CHAR,
+
+        /**
+         * The {@code short} native type.
+         */
+        SHORT,
+
+        /**
+         * The {@code unsigned short} native type.
+         */
+        UNSIGNED_SHORT,
+
+        /**
+         * The {@code int} native type.
+         */
+        INT,
+
+        /**
+         * The {@code unsigned int} native type.
+         */
+        UNSIGNED_INT,
+
+        /**
+         * The {@code long} native type.
+         */
+        LONG,
+
+        /**
+         * The {@code unsigned long} native type.
+         */
+        UNSIGNED_LONG,
+
+        /**
+         * The {@code long long} native type.
+         */
+        LONG_LONG,
+
+        /**
+         * The {@code unsigned long long} native type.
+         */
+        UNSIGNED_LONG_LONG,
+
+        /**
+         * The {@code float} native type.
+         */
+        FLOAT,
+
+        /**
+         * The {@code double} native type.
+         */
+        DOUBLE,
+
+        /**
+         * The {@code long double} native type.
+         */
+        LONG_DOUBLE,
+
+        /**
+         * The {@code complex long double} native type.
+         */
+        COMPLEX_LONG_DOUBLE,
+
+        /**
+         * The {@code T*} native type.
+         */
+        POINTER;
+    }
+
+    /**
+     * Returns memory layout for the given native type if supported by the platform ABI.
+     */
+    public Optional<MemoryLayout> layoutFor(Type type);
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ArgumentClass.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ArgumentClass.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ArgumentClass.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- *  This code is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 only, as
- *  published by the Free Software Foundation.  Oracle designates this
- *  particular file as subject to the "Classpath" exception as provided
- *  by Oracle in the LICENSE file that accompanied this code.
- *
- *  This code is distributed in the hope that it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  version 2 for more details (a copy is included in the LICENSE file that
- *  accompanied this code).
- *
- *  You should have received a copy of the GNU General Public License version
- *  2 along with this work; if not, write to the Free Software Foundation,
- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- *  or visit www.oracle.com if you need additional information or have any
- *  questions.
- *
- */
-
-package jdk.internal.foreign.abi;
-
-public interface ArgumentClass {
-
-    String ABI_CLASS = "abi/class";
-
-    boolean isIntegral();
-
-    boolean isPointer();
-
-    boolean isIndirect();
-}
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64ABI.java
@@ -25,10 +25,11 @@
  */
 package jdk.internal.foreign.abi.aarch64;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SystemABI;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.abi.*;
@@ -38,12 +39,15 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.util.function.Function;
 import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
 
 import static sun.security.action.GetPropertyAction.privilegedGetProperty;
+import static jdk.incubator.foreign.MemoryLayouts.AArch64ABI.*;
 
 /**
  * ABI implementation based on ARM document "Procedure Call Standard for
  * the ARM 64-bit Architecture".
  */
@@ -70,7 +74,38 @@
     @Override
     public String name() {
         return SystemABI.ABI_AARCH64;
     }
 
+    @Override
+    public Optional<MemoryLayout> layoutFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL -> Optional.of(C_BOOL);
+            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
+            case SIGNED_CHAR -> Optional.of(C_SCHAR);
+            case CHAR -> Optional.of(C_CHAR);
+            case SHORT -> Optional.of(C_SHORT);
+            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
+            case INT -> Optional.of(C_INT);
+            case UNSIGNED_INT -> Optional.of(C_UINT);
+            case LONG -> Optional.of(C_LONG);
+            case UNSIGNED_LONG -> Optional.of(C_ULONG);
+            case LONG_LONG -> Optional.of(C_LONGLONG);
+            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
+            case FLOAT -> Optional.of(C_FLOAT);
+            case DOUBLE -> Optional.of(C_DOUBLE);
+            case POINTER -> Optional.of(C_POINTER);
+            default -> Optional.empty();
+        };
+    }
 
+    static ArgumentClassImpl argumentClassFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
+                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
+                    ArgumentClassImpl.INTEGER;
+            case FLOAT, DOUBLE -> ArgumentClassImpl.VECTOR;
+            case POINTER -> ArgumentClassImpl.POINTER;
+            default -> null;
+        };
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/ArgumentClassImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/ArgumentClassImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/ArgumentClassImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/ArgumentClassImpl.java
@@ -21,24 +21,20 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.aarch64;
 
-import jdk.internal.foreign.abi.ArgumentClass;
-
-public enum ArgumentClassImpl implements ArgumentClass {
+enum ArgumentClassImpl {
     POINTER, INTEGER, VECTOR, MEMORY;
 
     public boolean isIntegral() {
         return this == INTEGER || this == POINTER;
     }
 
-    @Override
     public boolean isPointer() {
         return this == POINTER;
     }
 
-    @Override
     public boolean isIndirect() {
         return this == MEMORY;
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -160,11 +160,14 @@
         INTEGER,
         FLOAT,
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        ArgumentClassImpl clazz = (ArgumentClassImpl)Utils.getAnnotation(type, ArgumentClassImpl.ABI_CLASS);
+        var optAbiType = type.abiType();
+        //padding not allowed here
+        ArgumentClassImpl clazz = optAbiType.map(AArch64ABI::argumentClassFor).
+            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
@@ -195,18 +198,18 @@
         MemoryLayout baseType = groupLayout.memberLayouts().get(0);
 
         if (!(baseType instanceof ValueLayout))
             return false;
 
-        ArgumentClassImpl baseArgClass =
-            (ArgumentClassImpl)Utils.getAnnotation(baseType, ArgumentClassImpl.ABI_CLASS);
+        var optAbiType = baseType.abiType();
+        ArgumentClassImpl baseArgClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
         if (baseArgClass != ArgumentClassImpl.VECTOR)
            return false;
 
         for (MemoryLayout elem : groupLayout.memberLayouts()) {
-            ArgumentClassImpl argClass =
-                (ArgumentClassImpl)Utils.getAnnotation(elem, ArgumentClassImpl.ABI_CLASS);
+            optAbiType = elem.abiType();
+            ArgumentClassImpl argClass = optAbiType.map(AArch64ABI::argumentClassFor).orElse(null);
             if (!(elem instanceof ValueLayout) ||
                     elem.bitSize() != baseType.bitSize() ||
                     elem.bitAlignment() != baseType.bitAlignment() ||
                     baseArgClass != argClass) {
                 return false;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/ArgumentClassImpl.java
@@ -20,13 +20,11 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi.x64;
 
-import jdk.internal.foreign.abi.ArgumentClass;
-
-public enum ArgumentClassImpl implements ArgumentClass {
+public enum ArgumentClassImpl {
     POINTER, INTEGER, SSE, SSEUP, X87, X87UP, COMPLEX_X87, NO_CLASS, MEMORY;
 
     public ArgumentClassImpl merge(ArgumentClassImpl other) {
         if (this == other) {
             return this;
@@ -63,15 +61,13 @@
 
     public boolean isIntegral() {
         return this == INTEGER || this == POINTER;
     }
 
-    @Override
     public boolean isPointer() {
         return this == POINTER;
     }
 
-    @Override
     public boolean isIndirect() {
         return this == MEMORY;
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -427,12 +427,14 @@
     }
 
 
     private static List<ArgumentClassImpl> classifyValueType(ValueLayout type) {
         ArrayList<ArgumentClassImpl> classes = new ArrayList<>();
-
-        ArgumentClassImpl clazz = (ArgumentClassImpl)Utils.getAnnotation(type, ArgumentClassImpl.ABI_CLASS);
+        var optAbiType = type.abiType();
+        //padding not allowed here
+        ArgumentClassImpl clazz = optAbiType.map(SysVx64ABI::argumentClassFor).
+            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
         if (clazz == ArgumentClassImpl.POINTER) {
@@ -519,11 +521,12 @@
     }
 
     // TODO: handle zero length arrays
     // TODO: Handle nested structs (and primitives)
     private static List<ArgumentClassImpl> classifyStructType(GroupLayout type) {
-        ArgumentClassImpl clazz = (ArgumentClassImpl)Utils.getAnnotation(type, ArgumentClassImpl.ABI_CLASS);
+        var optAbiType = type.abiType();
+        var clazz = optAbiType.map(SysVx64ABI::argumentClassFor).orElse(null);
         if (clazz == ArgumentClassImpl.COMPLEX_X87) {
             return COMPLEX_X87_CLASSES;
         }
 
         long nWords = Utils.alignUp((type.byteSize()), 8) / 8;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVx64ABI.java
@@ -25,10 +25,11 @@
 package jdk.internal.foreign.abi.x64.sysv;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.GroupLayout;
 import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SystemABI;
 import jdk.internal.foreign.MemoryAddressImpl;
@@ -40,10 +41,11 @@
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.util.*;
 
 import static sun.security.action.GetPropertyAction.privilegedGetProperty;
+import static jdk.incubator.foreign.MemoryLayouts.SysV.*;
 
 /**
  * ABI implementation based on System V ABI AMD64 supplement v.0.99.6
  */
 public class SysVx64ABI implements SystemABI {
@@ -75,6 +77,43 @@
 
     @Override
     public String name() {
         return SystemABI.ABI_SYSV;
     }
+
+    @Override
+    public Optional<MemoryLayout> layoutFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL -> Optional.of(C_BOOL);
+            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
+            case SIGNED_CHAR -> Optional.of(C_SCHAR);
+            case CHAR -> Optional.of(C_CHAR);
+            case SHORT -> Optional.of(C_SHORT);
+            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
+            case INT -> Optional.of(C_INT);
+            case UNSIGNED_INT -> Optional.of(C_UINT);
+            case LONG -> Optional.of(C_LONG);
+            case UNSIGNED_LONG -> Optional.of(C_ULONG);
+            case LONG_LONG -> Optional.of(C_LONGLONG);
+            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
+            case FLOAT -> Optional.of(C_FLOAT);
+            case DOUBLE -> Optional.of(C_DOUBLE);
+            case LONG_DOUBLE -> Optional.of(C_LONGDOUBLE);
+            case COMPLEX_LONG_DOUBLE -> Optional.of(C_COMPLEX_LONGDOUBLE);
+            case POINTER -> Optional.of(C_POINTER);
+            default -> Optional.empty();
+        };
+    }
+
+    static ArgumentClassImpl argumentClassFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
+                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
+                    ArgumentClassImpl.INTEGER;
+            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;
+            case LONG_DOUBLE -> ArgumentClassImpl.X87;
+            case COMPLEX_LONG_DOUBLE -> ArgumentClassImpl.COMPLEX_X87;
+            case POINTER -> ArgumentClassImpl.POINTER;
+            default -> null;
+        };
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -159,11 +159,14 @@
         FLOAT,
         VARARG_FLOAT
     }
 
     private static TypeClass classifyValueType(ValueLayout type) {
-        ArgumentClassImpl clazz = (ArgumentClassImpl)Utils.getAnnotation(type, ArgumentClassImpl.ABI_CLASS);
+        var optAbiType = type.abiType();
+        //padding not allowed here
+        ArgumentClassImpl clazz = optAbiType.map(Windowsx64ABI::argumentClassFor).
+            orElseThrow(()->new IllegalStateException("Unexpected value layout: could not determine ABI class"));
         if (clazz == null) {
             //padding not allowed here
             throw new IllegalStateException("Unexpected value layout: could not determine ABI class");
         }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/Windowsx64ABI.java
@@ -24,18 +24,23 @@
  */
 package jdk.internal.foreign.abi.x64.windows;
 
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.SystemABI;
 import jdk.internal.foreign.MemoryAddressImpl;
+import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.*;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
+import java.util.Objects;
+import java.util.Optional;
 
 import static sun.security.action.GetPropertyAction.privilegedGetProperty;
+import static jdk.incubator.foreign.MemoryLayouts.WinABI.*;
 
 /**
  * ABI implementation based on Windows ABI AMD64 supplement v.0.99.6
  */
 public class Windowsx64ABI implements SystemABI {
@@ -70,6 +75,39 @@
 
     @Override
     public String name() {
         return SystemABI.ABI_WINDOWS;
     }
+
+    @Override
+    public Optional<MemoryLayout> layoutFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL -> Optional.of(C_BOOL);
+            case UNSIGNED_CHAR -> Optional.of(C_UCHAR);
+            case SIGNED_CHAR -> Optional.of(C_SCHAR);
+            case CHAR -> Optional.of(C_CHAR);
+            case SHORT -> Optional.of(C_SHORT);
+            case UNSIGNED_SHORT -> Optional.of(C_USHORT);
+            case INT -> Optional.of(C_INT);
+            case UNSIGNED_INT -> Optional.of(C_UINT);
+            case LONG -> Optional.of(C_LONG);
+            case UNSIGNED_LONG -> Optional.of(C_ULONG);
+            case LONG_LONG -> Optional.of(C_LONGLONG);
+            case UNSIGNED_LONG_LONG -> Optional.of(C_ULONGLONG);
+            case FLOAT -> Optional.of(C_FLOAT);
+            case DOUBLE -> Optional.of(C_DOUBLE);
+            case POINTER -> Optional.of(C_POINTER);
+            default -> Optional.empty();
+        };
+    }
+
+    static ArgumentClassImpl argumentClassFor(Type type) {
+        return switch (Objects.requireNonNull(type)) {
+            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
+                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG ->
+                    ArgumentClassImpl.INTEGER;
+            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;
+            case POINTER -> ArgumentClassImpl.POINTER;
+            default -> null;
+        };
+    }
 }
diff a/test/jdk/java/foreign/NativeTestHelper.java b/test/jdk/java/foreign/NativeTestHelper.java
--- a/test/jdk/java/foreign/NativeTestHelper.java
+++ b/test/jdk/java/foreign/NativeTestHelper.java
@@ -23,26 +23,35 @@
  */
 
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayouts.WinABI;
 import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.SystemABI.Type;
 import jdk.incubator.foreign.ValueLayout;
 import jdk.internal.foreign.Utils;
-import jdk.internal.foreign.abi.ArgumentClass;
+import java.util.function.Predicate;
 
 import static jdk.incubator.foreign.SystemABI.ABI_WINDOWS;
 
 public class NativeTestHelper {
 
     public static final SystemABI ABI = SystemABI.getInstance();
 
     public static boolean isIntegral(MemoryLayout layout) {
-        return ((ArgumentClass)Utils.getAnnotation(layout, ArgumentClass.ABI_CLASS)).isIntegral();
+        var optAbiType = layout.abiType();
+        if (!optAbiType.isPresent()) {
+            return false;
+        }
+        return switch(optAbiType.get()) {
+            case BOOL, UNSIGNED_CHAR, SIGNED_CHAR, CHAR, SHORT, UNSIGNED_SHORT,
+                INT, UNSIGNED_INT, LONG, UNSIGNED_LONG, LONG_LONG, UNSIGNED_LONG_LONG -> true;
+            default -> false;
+        };
     }
 
     public static boolean isPointer(MemoryLayout layout) {
-        return ((ArgumentClass)Utils.getAnnotation(layout, ArgumentClass.ABI_CLASS)).isPointer();
+        return layout.abiType().filter(Predicate.isEqual(Type.POINTER)).isPresent();
     }
 
     public static ValueLayout asVarArg(ValueLayout layout) {
         return ABI.name().equals(ABI_WINDOWS) ? WinABI.asVarArg(layout) : layout;
     }
