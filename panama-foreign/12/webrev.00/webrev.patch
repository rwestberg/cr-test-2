diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
@@ -22,40 +22,288 @@
  */
 package jdk.internal.foreign.abi;
 
 import jdk.incubator.foreign.MemoryLayout;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Objects;
 
+/**
+ * The binding operators defined in the Binding class can be combined into argument and return value processing 'recipes'.
+ *
+ * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the
+ * stack, or push them onto the stack.
+ *
+ * In the description of each binding we talk about 'boxing' and 'unboxing'.
+ *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine
+ *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.
+ *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.
+ *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.
+ *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.
+ * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,
+ * the CONVERT_ADDRESS operator 'unboxes' a MemoryAddress to a long, but 'boxes' a long to a MemoryAddress.
+ *
+ * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are
+ * ABI-specific). Note that each argument has it's own recipe, which is indicated by '[number]:' (though, the only
+ * example that has multiple arguments is the one using varargs).
+ *
+ * --------------------
+ *
+ * void f(int i);
+ *
+ * Argument bindings:
+ * 0: MOVE(rcx, int.class) // move an 'int' into the RCX register
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ *
+ * void f(int* i);
+ *
+ * Argument bindings:
+ * 0: CONVERT_ADDRESS // the 'MemoryAddress' is converted into a 'long'
+ *    MOVE(rcx, long.class) // the 'long' is moved into the RCX register
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ *
+ * int* f();
+ *
+ * Argument bindings:
+ * none
+ *
+ * Return bindings:
+ * 0: MOVE(rax, long) // load a 'long' from the RAX register
+ *    CONVERT_ADDRESS // convert the 'long' into a 'MemoryAddress'
+ *
+ * --------------------
+ *
+ * typedef struct { // fits into single register
+ *   int x;
+ *   int y;
+ * } MyStruct;
+ *
+ * void f(MyStruct ms);
+ *
+ * Argument bindings:
+ * 0: DEREFERENCE(0, long.class) // From the struct's memory region, load a 'long' from offset '0'
+ *    MOVE(rcx, long.class) // and copy that into the RCX regitster
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ *
+ * typedef struct { // does not fit into single register
+ *   long long x;
+ *   long long y;
+ * } MyStruct;
+ *
+ * void f(MyStruct ms);
+ *
+ * For the Windows ABI:
+ *
+ * Argument bindings:
+ * 0: COPY(16, 8) // copy the memory region containing the struct
+ *    BASE_ADDRESS // take the base address of the copy
+ *    CONVERT_ADDRESS // converts the base address to a 'long'
+ *    MOVE(rcx, long.class) // moves the 'long' into the RCX register
+ *
+ * Return bindings:
+ * none
+ *
+ * For the SysV ABI:
+ *
+ * Argument bindings:
+ * 0: DUP // duplicates the MemoryRegion operand
+ *    DEREFERENCE(0, long.class) // loads a 'long' from offset '0'
+ *    MOVE(rdx, long.class) // moves the long into the RDX register
+ *    DEREFERENCE(8, long.class) // loads a 'long' from offset '8'
+ *    MOVE(rcx, long.class) // moves the long into the RCX register
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ *
+ * typedef struct { // fits into single register
+ *   int x;
+ *   int y;
+ * } MyStruct;
+ *
+ * MyStruct f();
+ *
+ * Argument bindings:
+ * none
+ *
+ * Return bindings:
+ * 0: ALLOCATE(GroupLayout(C_INT, C_INT)) // allocate a buffer with the memory layout of the struct
+ *    DUP // duplicate the allocated buffer
+ *    MOVE(rax, long.class) // loads a 'long' from rax
+ *    DEREFERENCE(0, long.class) // stores a 'long' at offset 0
+ *
+ * --------------------
+ *
+ * typedef struct { // does not fit into single register
+ *   long long x;
+ *   long long y;
+ * } MyStruct;
+ *
+ * MyStruct f();
+ *
+ * !! uses synthetic argument, which is a pointer to a pre-allocated buffer
+ *
+ * Argument bindings:
+ * 0: CONVERT_ADDRESS // unbox the MemoryAddress synthetic argument
+ *    MOVE(rcx, long.class) // moves the 'long' into the RCX register
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ *
+ * void f(int dummy, ...); // varargs
+ *
+ * f(0, 10f); // passing a float
+ *
+ * Argument bindings:
+ * 0: MOVE(rcx, int.class) // moves the 'int dummy' into the RCX register
+ *
+ * 1: DUP // duplicates the '10f' argument
+ *    MOVE(rdx, float.class) // move one copy into the RDX register
+ *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register
+ *
+ * Return bindings:
+ * none
+ *
+ * --------------------
+ */
 public abstract class Binding {
-    static final int MOVE_TAG = 0;
-    static final int DEREFERENCE_TAG = 1;
-    static final int COPY_BUFFER_TAG = 2;
-    static final int ALLOC_BUFFER_TAG = 3;
-    static final int BOX_ADDRESS_TAG = 4;
-    static final int BASE_ADDRESS_TAG = 5;
-    static final int DUP_TAG = 6;
+    enum Tag {
+        MOVE,
+        DEREFERENCE,
+        COPY_BUFFER,
+        ALLOC_BUFFER,
+        CONVERT_ADDRESS,
+        BASE_ADDRESS,
+        DUP
+    }
 
-    private final int tag;
+    private final Tag tag;
 
-    private Binding(int tag) {
+    private Binding(Tag tag) {
         this.tag = tag;
     }
 
-    public int tag() {
+    public Tag tag() {
         return tag;
     }
 
+    private static void checkType(Class<?> type) {
+        if (!type.isPrimitive() || type == void.class || type == boolean.class)
+            throw new IllegalArgumentException("Illegal type: " + type);
+    }
+
+    public static Move move(VMStorage storage, Class<?> type) {
+        checkType(type);
+        return new Move(storage, type);
+    }
+
+    public static Dereference dereference(long offset, Class<?> type) {
+        checkType(type);
+        if (offset < 0)
+            throw new IllegalArgumentException("Negative offset: " + offset);
+        return new Dereference(offset, type);
+    }
+
+    public static Copy copy(MemoryLayout layout) {
+        return new Copy(layout.byteSize(), layout.byteAlignment());
+    }
+
+    public static Allocate allocate(MemoryLayout layout) {
+        return new Allocate(layout.byteSize(), layout.byteAlignment());
+    }
+
+    public static ConvertAddress convertAddress() {
+        return ConvertAddress.INSTANCE;
+    }
+
+    public static BaseAddress baseAddress() {
+        return BaseAddress.INSTANCE;
+    }
+
+    public static Dup dup() {
+        return Dup.INSTANCE;
+    }
+
+
+    public static Binding.Builder builder() {
+        return new Binding.Builder();
+    }
+
     /**
-     * Moves from a primitve to a VMStorage
+     * A builder helper class for generating lists of Bindings
+     */
+    public static class Builder {
+        private final List<Binding> bindings = new ArrayList<>();
+
+        public Binding.Builder move(VMStorage storage, Class<?> type) {
+            bindings.add(Binding.move(storage, type));
+            return this;
+        }
+
+        public Binding.Builder dereference(long offset, Class<?> type) {
+            bindings.add(Binding.dereference(offset, type));
+            return this;
+        }
+
+        public Binding.Builder copy(MemoryLayout layout) {
+            bindings.add(Binding.copy(layout));
+            return this;
+        }
+
+        public Binding.Builder allocate(MemoryLayout layout) {
+            bindings.add(Binding.allocate(layout));
+            return this;
+        }
+
+        public Binding.Builder convertAddress() {
+            bindings.add(Binding.convertAddress());
+            return this;
+        }
+
+        public Binding.Builder baseAddress() {
+            bindings.add(Binding.baseAddress());
+            return this;
+        }
+
+        public Binding.Builder dup() {
+            bindings.add(Binding.dup());
+            return this;
+        }
+
+        public List<Binding> build() {
+            return new ArrayList<>(bindings);
+        }
+    }
+
+    /**
+     * MOVE([storage location], [type])
+     *   When unboxing: pops a [type] from the operand stack, and moves it to [storage location]
+     *   When boxing: loads a [type] from [storage location], and pushes it onto the operand stack
+     * The [type] must be one of byte, short, char, int, long, float, or double
      */
     public static class Move extends Binding {
         private final VMStorage storage;
         private final Class<?> type;
 
-        public Move(VMStorage storage, Class<?> type) {
-            super(MOVE_TAG);
+        private Move(VMStorage storage, Class<?> type) {
+            super(Tag.MOVE);
             this.storage = storage;
             this.type = type;
         }
 
         public VMStorage storage() {
@@ -89,18 +337,23 @@
             return Objects.hash(tag(), storage, type);
         }
     }
 
     /**
-     * Loads or stores a Java primitive to a MemorySegment at a certain offset
+     * DEREFERENCE([offset into memory region], [type])
+     *   When unboxing: pops a MemorySegment from the operand stack,
+     *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack
+     *   When boxing: pops a [type], and then a MemorySegment from the operand stack,
+     *     and then stores [type] to [offset into memory region] of the MemorySegment
+     * The [type] must be one of byte, short, char, int, long, float, or double
      */
     public static class Dereference extends Binding {
         private final long offset;
         private final Class<?> type;
 
-        public Dereference(long offset, Class<?> type) {
-            super(DEREFERENCE_TAG);
+        private Dereference(long offset, Class<?> type) {
+            super(Tag.DEREFERENCE);
             this.offset = offset;
             this.type = type;
         }
 
         public long offset() {
@@ -134,18 +387,21 @@
             return Objects.hash(tag(), offset, type);
         }
     }
 
     /**
-     * Copies from a MemoryAddress into a newly allocated MemorySegment
+     * COPY([size], [alignment])
+     *   Creates a new MemorySegment with the given [size] and [alignment],
+     *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,
+     *     and pushes the new buffer onto the operand stack
      */
     public static class Copy extends Binding {
         private final long size;
         private final long alignment;
 
-        public Copy(long size, long alignment) {
-            super(COPY_BUFFER_TAG);
+        private Copy(long size, long alignment) {
+            super(Tag.COPY_BUFFER);
             this.size = size;
             this.alignment = alignment;
         }
 
         public long size() {
@@ -179,20 +435,21 @@
             return Objects.hash(tag(), size, alignment);
         }
     }
 
     /**
-     * Allocates a MemorySegment
+     * ALLOCATE([size], [alignment])
+     *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.
      */
-    public static class AllocateBuffer extends Binding {
+    public static class Allocate extends Binding {
         private final long size;
         private final long alignment;
 
-        public AllocateBuffer(MemoryLayout layout) {
-            super(ALLOC_BUFFER_TAG);
-            this.size = layout.byteSize();
-            this.alignment = layout.byteAlignment();
+        private Allocate(long size, long alignment) {
+            super(Tag.ALLOC_BUFFER);
+            this.size = size;
+            this.alignment = alignment;
         }
 
         public long size() {
             return size;
         }
@@ -212,11 +469,11 @@
 
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
             if (o == null || getClass() != o.getClass()) return false;
-            AllocateBuffer that = (AllocateBuffer) o;
+            Allocate that = (Allocate) o;
             return size == that.size &&
                     alignment == that.alignment;
         }
 
         @Override
@@ -224,15 +481,20 @@
             return Objects.hash(tag(), size, alignment);
         }
     }
 
     /**
-     * Boxes or unboxes a MemoryAddress to a long and vice versa (depending on box/unbox interpreter)
+     * CONVERT_ADDRESS()
+     *   When unboxing: pops a 'MemoryAddress' from the operand stack, converts it to a 'long',
+     *     and pushes that onto the operand stack
+     *   When boxing: pops a 'long' from the operand stack, converts it to a 'MemoryAddress',
+     *     and pushes that onto the operand stack
      */
-    public static class BoxAddress extends Binding {
-        public BoxAddress() {
-            super(BOX_ADDRESS_TAG);
+    public static class ConvertAddress extends Binding {
+        private static final ConvertAddress INSTANCE = new ConvertAddress();
+        private ConvertAddress() {
+            super(Tag.CONVERT_ADDRESS);
         }
 
         @Override
         public String toString() {
             return "BoxAddress{" +
@@ -240,26 +502,29 @@
                     "}";
         }
 
         @Override
         public int hashCode() {
-            return tag();
+            return tag().hashCode();
         }
 
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
             return o != null && getClass() == o.getClass();
         }
     }
 
     /**
-     * Takes the base address of a MemorySegment
+     * BASE_ADDRESS()
+     *   Pops a MemorySegment from the operand stack, and takes the base address of the segment
+     *   (the MemoryAddress that points to the start), and pushes that onto the operand stack
      */
     public static class BaseAddress extends Binding {
-        public BaseAddress() {
-            super(BASE_ADDRESS_TAG);
+        private static final BaseAddress INSTANCE = new BaseAddress();
+        private BaseAddress() {
+            super(Tag.BASE_ADDRESS);
         }
 
         @Override
         public String toString() {
             return "BaseAddress{" +
@@ -267,26 +532,29 @@
                     "}";
         }
 
         @Override
         public int hashCode() {
-            return tag();
+            return tag().hashCode();
         }
 
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
             return o != null && getClass() == o.getClass();
         }
     }
 
     /**
-     * Duplicates a value on top of the interpreter stack
+     * DUP()
+     *   Duplicates the value on the top of the operand stack (without popping it!),
+     *   and pushes the duplicate onto the operand stack
      */
     public static class Dup extends Binding {
-        public Dup() {
-            super(DUP_TAG);
+        private static final Dup INSTANCE = new Dup();
+        private Dup() {
+            super(Tag.DUP);
         }
 
         @Override
         public String toString() {
             return "Dup{" +
@@ -294,11 +562,11 @@
                     "}";
         }
 
         @Override
         public int hashCode() {
-            return tag();
+            return tag().hashCode();
         }
 
         @Override
         public boolean equals(Object o) {
             if (this == o) return true;
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/BindingInterpreter.java
@@ -48,87 +48,80 @@
             MemoryAddress> ptrFunction, List<? super MemorySegment> buffers) {
         Deque<Object> stack = new ArrayDeque<>();
         stack.push(arg);
         for (Binding b : bindings) {
             switch (b.tag()) {
-                case Binding.MOVE_TAG: {
+                case MOVE -> {
                     Binding.Move binding = (Binding.Move) b;
                     MemoryAddress ptr = ptrFunction.apply(binding.storage());
                     writeOverSized(ptr, binding.type(), stack.pop());
-                } break;
-                case Binding.DEREFERENCE_TAG: {
+                }
+                case DEREFERENCE -> {
                     Binding.Dereference deref = (Binding.Dereference) b;
                     MemorySegment operand = (MemorySegment) stack.pop();
                     MemoryAddress baseAddress = operand.baseAddress();
                     MemoryAddress readAddress = baseAddress.addOffset(deref.offset());
                     stack.push(read(readAddress, deref.type()));
-                } break;
-                case Binding.COPY_BUFFER_TAG: {
+                }
+                case COPY_BUFFER -> {
                     Binding.Copy binding = (Binding.Copy) b;
                     MemorySegment operand = (MemorySegment) stack.pop();
                     assert operand.byteSize() == binding.size() : "operand size mismatch";
                     MemorySegment copy = MemorySegment.allocateNative(binding.size(), binding.alignment());
                     MemoryAddress.copy(operand.baseAddress(), copy.baseAddress(), binding.size());
                     buffers.add(copy);
                     stack.push(copy);
-                } break;
-                case Binding.ALLOC_BUFFER_TAG: {
-                    throw new UnsupportedOperationException();
                 }
-                case Binding.BOX_ADDRESS_TAG: {
+                case ALLOC_BUFFER ->
+                    throw new UnsupportedOperationException();
+                case CONVERT_ADDRESS ->
                     stack.push(MemoryAddressImpl.addressof((MemoryAddress) stack.pop()));
-                } break;
-                case Binding.BASE_ADDRESS_TAG: {
+                case BASE_ADDRESS ->
                     stack.push(((MemorySegment) stack.pop()).baseAddress());
-                } break;
-                case Binding.DUP_TAG: {
+                case DUP ->
                     stack.push(stack.peekLast());
-                } break;
-                default: throw new IllegalArgumentException("Unsupported tag: " + b);
+                default -> throw new IllegalArgumentException("Unsupported tag: " + b);
             }
         }
     }
 
     static Object box(List<Binding> bindings, Function<VMStorage, MemoryAddress> ptrFunction) {
         Deque<Object> stack = new ArrayDeque<>();
         for (Binding b : bindings) {
             switch (b.tag()) {
-                case Binding.MOVE_TAG: {
+                case MOVE -> {
                     Binding.Move binding = (Binding.Move) b;
                     MemoryAddress ptr = ptrFunction.apply(binding.storage());
                     stack.push(read(ptr, binding.type()));
-                } break;
-                case Binding.DEREFERENCE_TAG: {
+                }
+                case DEREFERENCE -> {
                     Binding.Dereference binding = (Binding.Dereference) b;
                     Object value = stack.pop();
                     MemorySegment operand = (MemorySegment) stack.pop();
                     MemoryAddress baseAddress = operand.baseAddress();
                     MemoryAddress writeAddress = baseAddress.addOffset(binding.offset());
                     write(writeAddress, binding.type(), value);
-                } break;
-                case Binding.COPY_BUFFER_TAG: {
+                }
+                case COPY_BUFFER -> {
                     Binding.Copy binding = (Binding.Copy) b;
                     MemoryAddress operand = (MemoryAddress) stack.pop();
                     operand = Utils.resizeNativeAddress(operand, binding.size());
                     MemorySegment copy = MemorySegment.allocateNative(binding.size(), binding.alignment());
                     MemoryAddress.copy(operand, copy.baseAddress(), binding.size());
                     stack.push(copy); // leaked
-                } break;
-                case Binding.ALLOC_BUFFER_TAG: {
-                    Binding.AllocateBuffer binding = (Binding.AllocateBuffer) b;
+                }
+                case ALLOC_BUFFER -> {
+                    Binding.Allocate binding = (Binding.Allocate) b;
                     stack.push(MemorySegment.allocateNative(binding.size(), binding.alignment()));
-                } break;
-                case Binding.BOX_ADDRESS_TAG: {
+                }
+                case CONVERT_ADDRESS ->
                     stack.push(MemoryAddress.ofLong((long) stack.pop()));
-                } break;
-                case Binding.BASE_ADDRESS_TAG: {
+                case BASE_ADDRESS ->
                     stack.push(((MemorySegment) stack.pop()).baseAddress());
-                } break;
-                case Binding.DUP_TAG: {
+                case DUP ->
                     stack.push(stack.peekLast());
-                } break;
-                default: throw new IllegalArgumentException("Unsupported tag: " + b);
+                default -> throw new IllegalArgumentException("Unsupported tag: " + b);
             }
         }
 
        return stack.pop();
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
@@ -104,43 +104,41 @@
         Deque<Class<?>> stack = new ArrayDeque<>();
         stack.push(inType);
 
         for (Binding b : bindings) {
             switch (b.tag()) {
-                case Binding.MOVE_TAG: {
+                case MOVE -> {
                     Class<?> actualType = stack.pop();
                     Class<?> expectedType = ((Binding.Move) b).type();
                     checkType(actualType, expectedType);
-                } break;
-                case Binding.DEREFERENCE_TAG: {
+                }
+                case DEREFERENCE -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemorySegment.class);
                     Class<?> newType = ((Binding.Dereference) b).type();
                     stack.push(newType);
-                } break;
-                case Binding.BASE_ADDRESS_TAG: {
+                }
+                case BASE_ADDRESS -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemorySegment.class);
                     stack.push(MemoryAddress.class);
-                } break;
-                case Binding.BOX_ADDRESS_TAG: {
+                }
+                case CONVERT_ADDRESS -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemoryAddress.class);
                     stack.push(long.class);
-                } break;
-                case Binding.ALLOC_BUFFER_TAG: {
-                    stack.push(MemorySegment.class);
-                } break;
-                case Binding.COPY_BUFFER_TAG: {
+                }
+                case ALLOC_BUFFER ->
+                    throw new UnsupportedOperationException();
+                case COPY_BUFFER -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemorySegment.class);
                     stack.push(MemorySegment.class);
-                } break;
-                case Binding.DUP_TAG: {
+                }
+                case DUP ->
                     stack.push(stack.peekLast());
-                } break;
-                default: throw new IllegalArgumentException("Unknown binding: " + b);
+                default -> throw new IllegalArgumentException("Unknown binding: " + b);
             }
         }
 
         if (!stack.isEmpty()) {
             throw new IllegalArgumentException("Stack must be empty after recipe");
@@ -150,42 +148,41 @@
     private static void verifyBoxBindings(Class<?> outType, List<Binding> bindings) {
         Deque<Class<?>> stack = new ArrayDeque<>();
 
         for (Binding b : bindings) {
             switch (b.tag()) {
-                case Binding.MOVE_TAG: {
+                case MOVE -> {
                     Class<?> newType = ((Binding.Move) b).type();
                     stack.push(newType);
-                } break;
-                case Binding.DEREFERENCE_TAG: {
+                }
+                case DEREFERENCE -> {
                     Class<?> storeType = stack.pop();
                     checkType(storeType, ((Binding.Dereference) b).type());
                     Class<?> segmentType = stack.pop();
                     checkType(segmentType, MemorySegment.class);
-                } break;
-                case Binding.BOX_ADDRESS_TAG: {
+                }
+                case CONVERT_ADDRESS -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, long.class);
                     stack.push(MemoryAddress.class);
-                } break;
-                case Binding.BASE_ADDRESS_TAG: {
+                }
+                case BASE_ADDRESS -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemorySegment.class);
                     stack.push(MemoryAddress.class);
-                } break;
-                case Binding.ALLOC_BUFFER_TAG: {
+                }
+                case ALLOC_BUFFER -> {
                     stack.push(MemorySegment.class);
-                } break;
-                case Binding.COPY_BUFFER_TAG: {
+                }
+                case COPY_BUFFER -> {
                     Class<?> actualType = stack.pop();
                     checkType(actualType, MemoryAddress.class);
                     stack.push(MemorySegment.class);
-                } break;
-                case Binding.DUP_TAG: {
+                }
+                case DUP ->
                     stack.push(stack.peekLast());
-                } break;
-                default: throw new IllegalArgumentException("Unknown binding: " + b);
+                default -> throw new IllegalArgumentException("Unknown binding: " + b);
             }
         }
 
         if (stack.size() != 1) {
             throw new IllegalArgumentException("Stack must contain exactly 1 value");
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -42,11 +42,10 @@
 import jdk.internal.foreign.abi.VMStorage;
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
 
 import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;
 
@@ -299,11 +298,11 @@
 
         protected BindingCalculator(boolean forArguments) {
             this.storageCalculator = new StorageCalculator(forArguments);
         }
 
-        protected void spillStructUnbox(List<Binding> bindings, MemoryLayout layout) {
+        protected void spillStructUnbox(Binding.Builder bindings, MemoryLayout layout) {
             // If a struct has been assigned register or HFA class but
             // there are not enough free registers to hold the entire
             // struct, it must be passed on the stack. I.e. not split
             // between registers and stack.
 
@@ -311,32 +310,32 @@
             while (offset < layout.byteSize()) {
                 long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);
                 VMStorage storage =
                     storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);
                 if (offset + STACK_SLOT_SIZE < layout.byteSize()) {
-                    bindings.add(new Binding.Dup());
+                    bindings.dup();
                 }
-                bindings.add(new Binding.Dereference(offset, long.class));
-                bindings.add(new Binding.Move(storage, long.class));
+                bindings.dereference(offset, long.class)
+                        .move(storage, long.class);
                 offset += STACK_SLOT_SIZE;
             }
         }
 
-        protected void spillStructBox(List<Binding> bindings, MemoryLayout layout) {
+        protected void spillStructBox(Binding.Builder bindings, MemoryLayout layout) {
             // If a struct has been assigned register or HFA class but
             // there are not enough free registers to hold the entire
             // struct, it must be passed on the stack. I.e. not split
             // between registers and stack.
 
             long offset = 0;
             while (offset < layout.byteSize()) {
                 long copy = Math.min(layout.byteSize() - offset, STACK_SLOT_SIZE);
                 VMStorage storage =
                     storageCalculator.stackAlloc(copy, STACK_SLOT_SIZE);
-                bindings.add(new Binding.Dup());
-                bindings.add(new Binding.Move(storage, long.class));
-                bindings.add(new Binding.Dereference(offset, long.class));
+                bindings.dup()
+                        .move(storage, long.class)
+                        .dereference(offset, long.class);
                 offset += STACK_SLOT_SIZE;
             }
         }
 
         abstract List<Binding> getBindings(Class<?> carrier, MemoryLayout layout);
@@ -349,20 +348,20 @@
             super(forArguments);
         }
 
         @Override
         List<Binding> getIndirectBindings() {
-            List<Binding> bindings = new ArrayList<>();
-            bindings.add(new Binding.BoxAddress());
-            bindings.add(new Binding.Move(INDIRECT_RESULT, long.class));
-            return bindings;
+            return Binding.builder()
+                .convertAddress()
+                .move(INDIRECT_RESULT, long.class)
+                .build();
         }
 
         @Override
         List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyType(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass) {
                 case STRUCT_REGISTER: {
                     assert carrier == MemorySegment.class;
                     VMStorage[] regs = storageCalculator.regAlloc(
                         StorageClasses.INTEGER, layout);
@@ -372,29 +371,29 @@
                         while (offset < layout.byteSize()) {
                             final long copy = Math.min(layout.byteSize() - offset, 8);
                             VMStorage storage = regs[regIndex++];
                             Class<?> type = SharedUtils.primitiveCarrierForSize(copy);
                             if (offset + copy < layout.byteSize()) {
-                                bindings.add(new Binding.Dup());
+                                bindings.dup();
                             }
-                            bindings.add(new Binding.Dereference(offset, type));
-                            bindings.add(new Binding.Move(storage, type));
+                            bindings.dereference(offset, type)
+                                    .move(storage, type);
                             offset += copy;
                         }
                     } else {
                         spillStructUnbox(bindings, layout);
                     }
                     break;
                 }
                 case STRUCT_REFERENCE: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.Copy(layout.byteSize(), layout.byteAlignment()));
-                    bindings.add(new Binding.BaseAddress());
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.copy(layout)
+                            .baseAddress()
+                            .convertAddress();
                     VMStorage storage = storageCalculator.nextStorage(
                         StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
+                    bindings.move(storage, long.class);
                     break;
                 }
                 case STRUCT_HFA: {
                     assert carrier == MemorySegment.class;
                     GroupLayout group = (GroupLayout)layout;
@@ -405,141 +404,141 @@
                         for (int i = 0; i < group.memberLayouts().size(); i++) {
                             VMStorage storage = regs[i];
                             final long size = group.memberLayouts().get(i).byteSize();
                             Class<?> type = SharedUtils.primitiveCarrierForSize(size);
                             if (i + 1 < group.memberLayouts().size()) {
-                                bindings.add(new Binding.Dup());
+                                bindings.dup();
                             }
-                            bindings.add(new Binding.Dereference(offset, type));
-                            bindings.add(new Binding.Move(storage, type));
+                            bindings.dereference(offset, type)
+                                    .move(storage, type);
                             offset += size;
                         }
                     } else {
                         spillStructUnbox(bindings, layout);
                     }
                     break;
                 }
                 case POINTER: {
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.convertAddress();
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
+                    bindings.move(storage, long.class);
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.VECTOR, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 
     static class BoxBindingCalculator extends BindingCalculator{
         BoxBindingCalculator(boolean forArguments) {
             super(forArguments);
         }
 
         @Override
         List<Binding> getIndirectBindings() {
-            List<Binding> bindings = new ArrayList<>();
-            bindings.add(new Binding.Move(INDIRECT_RESULT, long.class));
-            bindings.add(new Binding.BoxAddress());
-            return bindings;
+            return Binding.builder()
+                .move(INDIRECT_RESULT, long.class)
+                .convertAddress()
+                .build();
         }
 
         @SuppressWarnings("fallthrough")
         @Override
         List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyType(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass) {
                 case STRUCT_REGISTER: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.AllocateBuffer(layout));
+                    bindings.allocate(layout);
                     VMStorage[] regs = storageCalculator.regAlloc(
                         StorageClasses.INTEGER, layout);
                     if (regs != null) {
                         int regIndex = 0;
                         long offset = 0;
                         while (offset < layout.byteSize()) {
                             final long copy = Math.min(layout.byteSize() - offset, 8);
                             VMStorage storage = regs[regIndex++];
-                            bindings.add(new Binding.Dup());
+                            bindings.dup();
                             Class<?> type = SharedUtils.primitiveCarrierForSize(copy);
-                            bindings.add(new Binding.Move(storage, type));
-                            bindings.add(new Binding.Dereference(offset, type));
+                            bindings.move(storage, type)
+                                    .dereference(offset, type);
                             offset += copy;
                         }
                     } else {
                         spillStructBox(bindings, layout);
                     }
                     break;
                 }
                 case STRUCT_REFERENCE: {
                     assert carrier == MemorySegment.class;
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.move(storage, long.class)
+                            .convertAddress();
                     // ASSERT SCOPE OF BOXED ADDRESS HERE
                     // caveat. buffer should instead go out of scope after call
-                    bindings.add(new Binding.Copy(layout.byteSize(), layout.byteAlignment()));
+                    bindings.copy(layout);
                     break;
                 }
                 case STRUCT_HFA: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.AllocateBuffer(layout));
+                    bindings.allocate(layout);
                     GroupLayout group = (GroupLayout)layout;
                     VMStorage[] regs = storageCalculator.regAlloc(
                         StorageClasses.VECTOR, group.memberLayouts().size());
                     if (regs != null) {
                         long offset = 0;
                         for (int i = 0; i < group.memberLayouts().size(); i++) {
                             VMStorage storage = regs[i];
                             final long size = group.memberLayouts().get(i).byteSize();
                             Class<?> type = SharedUtils.primitiveCarrierForSize(size);
-                            bindings.add(new Binding.Dup());
-                            bindings.add(new Binding.Move(storage, type));
-                            bindings.add(new Binding.Dereference(offset, type));
+                            bindings.dup()
+                                    .move(storage, type)
+                                    .dereference(offset, type);
                             offset += size;
                         }
                     } else {
                         spillStructBox(bindings, layout);
                     }
                     break;
                 }
                 case POINTER: {
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.move(storage, long.class)
+                            .convertAddress();
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage =
                         storageCalculator.nextStorage(StorageClasses.VECTOR, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -53,10 +53,11 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static jdk.internal.foreign.abi.x64.sysv.SysVx64ABI.MAX_INTEGER_ARGUMENT_REGISTERS;
 import static jdk.internal.foreign.abi.x64.sysv.SysVx64ABI.MAX_VECTOR_ARGUMENT_REGISTERS;
 
 /**
@@ -117,11 +118,11 @@
         }
 
         if (!forUpcall) {
             //add extra binding for number of used vector registers (used for variadic calls)
             csb.addArgumentBindings(long.class, MemoryLayouts.SysV.C_LONG,
-                    List.of(new Binding.Move(rax, long.class)));
+                    Binding.builder().move(rax, long.class).build());
         }
 
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
 
@@ -305,11 +306,11 @@
         }
 
         @Override
         List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyLayout(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass.kind) {
                 case STRUCT: {
                     assert carrier == MemorySegment.class;
                     VMStorage[] regs = storageCalculator.structStorages(argumentClass);
                     int regIndex = 0;
@@ -317,38 +318,38 @@
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         VMStorage storage = regs[regIndex++];
                         Class<?> type = SharedUtils.primitiveCarrierForSize(copy);
                         if (offset + copy < layout.byteSize()) {
-                            bindings.add(new Binding.Dup());
+                            bindings.dup();
                         }
-                        bindings.add(new Binding.Dereference(offset, type));
-                        bindings.add(new Binding.Move(storage, type));
+                        bindings.dereference(offset, type)
+                                .move(storage, type);
                         offset += copy;
                     }
                     break;
                 }
                 case POINTER: {
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.convertAddress();
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);
-                    bindings.add(new Binding.Move(storage, long.class));
+                    bindings.move(storage, long.class);
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 
     static class BoxBindingCalculator extends BindingCalculator {
 
@@ -358,49 +359,49 @@
 
         @SuppressWarnings("fallthrough")
         @Override
         List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyLayout(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass.kind) {
                 case STRUCT: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.AllocateBuffer(layout));
+                    bindings.allocate(layout);
                     VMStorage[] regs = storageCalculator.structStorages(argumentClass);
                     int regIndex = 0;
                     long offset = 0;
                     while (offset < layout.byteSize()) {
                         final long copy = Math.min(layout.byteSize() - offset, 8);
                         VMStorage storage = regs[regIndex++];
-                        bindings.add(new Binding.Dup());
+                        bindings.dup();
                         Class<?> type = SharedUtils.primitiveCarrierForSize(copy);
-                        bindings.add(new Binding.Move(storage, type));
-                        bindings.add(new Binding.Dereference(offset, type));
+                        bindings.move(storage, type)
+                                .dereference(offset, type);
                         offset += copy;
                     }
                     break;
                 }
                 case POINTER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);
-                    bindings.add(new Binding.Move(storage, long.class));
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.move(storage, long.class)
+                            .convertAddress();
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 
     // layout classification
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -43,11 +43,10 @@
 import jdk.internal.foreign.abi.x64.ArgumentClassImpl;
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
 
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static jdk.internal.foreign.abi.x64.windows.Windowsx64ABI.VARARGS_ANNOTATION_NAME;
@@ -262,60 +261,60 @@
         }
 
         @Override
         public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyType(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass) {
                 case STRUCT_REGISTER: {
                     assert carrier == MemorySegment.class;
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
                     Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());
-                    bindings.add(new Binding.Dereference(0, type));
-                    bindings.add(new Binding.Move(storage, type));
+                    bindings.dereference(0, type)
+                            .move(storage, type);
                     break;
                 }
                 case STRUCT_REFERENCE: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.Copy(layout.byteSize(), layout.byteAlignment()));
-                    bindings.add(new Binding.BaseAddress());
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.copy(layout)
+                            .baseAddress()
+                            .convertAddress();
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
+                    bindings.move(storage, long.class);
                     break;
                 }
                 case POINTER: {
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.convertAddress();
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
+                    bindings.move(storage, long.class);
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case VARARG_FLOAT: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);
                     if (!INSTANCE.isStackType(storage.type())) { // need extra for register arg
                         VMStorage extraStorage = storageCalculator.extraVarargsStorage();
-                        bindings.add(new Binding.Dup());
-                        bindings.add(new Binding.Move(extraStorage, carrier));
+                        bindings.dup()
+                                .move(extraStorage, carrier);
                     }
 
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 
     static class BoxBindingCalculator implements BindingCalculator {
         private final StorageCalculator storageCalculator;
@@ -326,50 +325,50 @@
 
         @SuppressWarnings("fallthrough")
         @Override
         public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {
             TypeClass argumentClass = classifyType(layout);
-            List<Binding> bindings = new ArrayList<>();
+            Binding.Builder bindings = Binding.builder();
             switch (argumentClass) {
                 case STRUCT_REGISTER: {
                     assert carrier == MemorySegment.class;
-                    bindings.add(new Binding.AllocateBuffer(layout));
-                    bindings.add(new Binding.Dup());
+                    bindings.allocate(layout)
+                            .dup();
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
                     Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());
-                    bindings.add(new Binding.Move(storage, type));
-                    bindings.add(new Binding.Dereference(0, type));
+                    bindings.move(storage, type)
+                            .dereference(0, type);
                     break;
                 }
                 case STRUCT_REFERENCE: {
                     assert carrier == MemorySegment.class;
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.move(storage, long.class)
+                            .convertAddress();
                     // ASSERT SCOPE OF BOXED ADDRESS HERE
                     // caveat. buffer should instead go out of scope after call
-                    bindings.add(new Binding.Copy(layout.byteSize(), layout.byteAlignment()));
+                    bindings.copy(layout);
                     break;
                 }
                 case POINTER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, long.class));
-                    bindings.add(new Binding.BoxAddress());
+                    bindings.move(storage, long.class)
+                            .convertAddress();
                     break;
                 }
                 case INTEGER: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 case FLOAT: {
                     VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR, layout);
-                    bindings.add(new Binding.Move(storage, carrier));
+                    bindings.move(storage, carrier);
                     break;
                 }
                 default:
                     throw new UnsupportedOperationException("Unhandled class " + argumentClass);
             }
-            return bindings;
+            return bindings.build();
         }
     }
 }
diff a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestAarch64CallArranger.java
@@ -43,10 +43,11 @@
 import org.testng.annotations.Test;
 
 import java.lang.invoke.MethodType;
 
 import static jdk.incubator.foreign.MemoryLayouts.AArch64ABI.*;
+import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
 
@@ -84,20 +85,20 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(r0, int.class) },
-            { new Binding.Move(r1, int.class) },
-            { new Binding.Move(r2, int.class) },
-            { new Binding.Move(r3, int.class) },
-            { new Binding.Move(r4, int.class) },
-            { new Binding.Move(r5, int.class) },
-            { new Binding.Move(r6, int.class) },
-            { new Binding.Move(r7, int.class) },
-            { new Binding.Move(stackStorage(0), int.class) },
-            { new Binding.Move(stackStorage(1), int.class) },
+            { move(r0, int.class) },
+            { move(r1, int.class) },
+            { move(r2, int.class) },
+            { move(r3, int.class) },
+            { move(r4, int.class) },
+            { move(r5, int.class) },
+            { move(r6, int.class) },
+            { move(r7, int.class) },
+            { move(stackStorage(0), int.class) },
+            { move(stackStorage(1), int.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -113,14 +114,14 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(r0, int.class) },
-            { new Binding.Move(r1, int.class) },
-            { new Binding.Move(v0, float.class) },
-            { new Binding.Move(v1, float.class) },
+            { move(r0, int.class) },
+            { move(r1, int.class) },
+            { move(v0, float.class) },
+            { move(v1, float.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -146,30 +147,30 @@
     public static Object[][] structs() {
         MemoryLayout struct2 = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);
         return new Object[][]{
             // struct s { int32_t a, b; double c; };
             { MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE), new Binding[] {
-                new Binding.Dup(),
+                dup(),
                     // s.a & s.b
-                    new Binding.Dereference(0, long.class), new Binding.Move(r0, long.class),
+                    dereference(0, long.class), move(r0, long.class),
                     // s.c --> note AArch64 passes this in an *integer* register
-                    new Binding.Dereference(8, long.class), new Binding.Move(r1, long.class),
+                    dereference(8, long.class), move(r1, long.class),
             }},
             // struct s { int32_t a, b; double c; int32_t d };
             { struct2, new Binding[] {
-                new Binding.Copy(struct2.byteSize(), struct2.byteAlignment()),
-                new Binding.BaseAddress(),
-                new Binding.BoxAddress(),
-                new Binding.Move(r0, long.class)
+                copy(struct2),
+                baseAddress(),
+                convertAddress(),
+                move(r0, long.class)
             }},
             // struct s { int32_t a[2]; float b[2] };
             { MemoryLayout.ofStruct(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {
-                new Binding.Dup(),
+                dup(),
                     // s.a[0] & s.a[1]
-                    new Binding.Dereference(0, long.class), new Binding.Move(r0, long.class),
+                    dereference(0, long.class), move(r0, long.class),
                     // s.b[0] & s.b[1]
-                    new Binding.Dereference(8, long.class), new Binding.Move(r1, long.class),
+                    dereference(8, long.class), move(r1, long.class),
             }},
         };
     }
 
     @Test
@@ -186,22 +187,22 @@
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             {
-                new Binding.Copy(struct1.byteSize(), struct1.byteAlignment()),
-                new Binding.BaseAddress(),
-                new Binding.BoxAddress(),
-                new Binding.Move(r0, long.class)
+                copy(struct1),
+                baseAddress(),
+                convertAddress(),
+                move(r0, long.class)
             },
             {
-                new Binding.Copy(struct2.byteSize(), struct2.byteAlignment()),
-                new Binding.BaseAddress(),
-                new Binding.BoxAddress(),
-                new Binding.Move(r1, long.class)
+                copy(struct2),
+                baseAddress(),
+                convertAddress(),
+                move(r1, long.class)
             },
-            { new Binding.Move(r2, int.class) }
+            { move(r2, int.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -218,12 +219,12 @@
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));
         assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             {
-                new Binding.BoxAddress(),
-                new Binding.Move(r8, long.class)
+                convertAddress(),
+                move(r8, long.class)
             }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
@@ -242,17 +243,17 @@
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{});
 
         checkReturnBindings(callingSequence, new Binding[]{
-            new Binding.AllocateBuffer(struct),
-            new Binding.Dup(),
-            new Binding.Move(r0, long.class),
-            new Binding.Dereference(0, long.class),
-            new Binding.Dup(),
-            new Binding.Move(r1, long.class),
-            new Binding.Dereference(8, long.class),
+            allocate(struct),
+            dup(),
+            move(r0, long.class),
+            dereference(0, long.class),
+            dup(),
+            move(r1, long.class),
+            dereference(8, long.class),
         });
     }
 
     @Test
     public void testStructHFA1() {
@@ -266,29 +267,29 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(v0, float.class) },
-            { new Binding.Move(r0, int.class) },
+            { move(v0, float.class) },
+            { move(r0, int.class) },
             {
-                new Binding.Dup(),
-                new Binding.Dereference(0, int.class),
-                new Binding.Move(v1, int.class),
-                new Binding.Dereference(4, int.class),
-                new Binding.Move(v2, int.class)
+                dup(),
+                dereference(0, int.class),
+                move(v1, int.class),
+                dereference(4, int.class),
+                move(v2, int.class)
             }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{
-            new Binding.AllocateBuffer(hfa),
-            new Binding.Dup(),
-            new Binding.Move(v0, int.class),
-            new Binding.Dereference(0, int.class),
-            new Binding.Dup(),
-            new Binding.Move(v1, int.class),
-            new Binding.Dereference(4, int.class),
+            allocate(hfa),
+            dup(),
+            move(v0, int.class),
+            dereference(0, int.class),
+            dup(),
+            move(v1, int.class),
+            dereference(4, int.class),
         });
     }
 
     @Test
     public void testStructHFA3() {
@@ -303,35 +304,35 @@
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             {
-                new Binding.Dup(),
-                new Binding.Dereference(0, int.class),
-                new Binding.Move(v0, int.class),
-                new Binding.Dup(),
-                new Binding.Dereference(4, int.class),
-                new Binding.Move(v1, int.class),
-                new Binding.Dereference(8, int.class),
-                new Binding.Move(v2, int.class)
+                dup(),
+                dereference(0, int.class),
+                move(v0, int.class),
+                dup(),
+                dereference(4, int.class),
+                move(v1, int.class),
+                dereference(8, int.class),
+                move(v2, int.class)
             },
             {
-                new Binding.Dup(),
-                new Binding.Dereference(0, int.class),
-                new Binding.Move(v3, int.class),
-                new Binding.Dup(),
-                new Binding.Dereference(4, int.class),
-                new Binding.Move(v4, int.class),
-                new Binding.Dereference(8, int.class),
-                new Binding.Move(v5, int.class)
+                dup(),
+                dereference(0, int.class),
+                move(v3, int.class),
+                dup(),
+                dereference(4, int.class),
+                move(v4, int.class),
+                dereference(8, int.class),
+                move(v5, int.class)
             },
             {
-                new Binding.Dup(),
-                new Binding.Dereference(0, long.class),
-                new Binding.Move(stackStorage(0), long.class),
-                new Binding.Dereference(8, long.class),
-                new Binding.Move(stackStorage(1), long.class),
+                dup(),
+                dereference(0, long.class),
+                move(stackStorage(0), long.class),
+                dereference(8, long.class),
+                move(stackStorage(1), long.class),
             }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
diff a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestSysVCallArranger.java
@@ -45,10 +45,11 @@
 
 import java.lang.invoke.MethodType;
 
 import static jdk.incubator.foreign.MemoryLayouts.SysV.*;
 import static jdk.incubator.foreign.MemoryLayouts.WinABI.C_POINTER;
+import static jdk.internal.foreign.abi.Binding.*;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertFalse;
 import static org.testng.Assert.assertTrue;
 
@@ -64,11 +65,11 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rax, long.class) }
+            { move(rax, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 0);
@@ -86,17 +87,17 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rdi, int.class) },
-            { new Binding.Move(rsi, int.class) },
-            { new Binding.Move(rdx, int.class) },
-            { new Binding.Move(rcx, int.class) },
-            { new Binding.Move(r8, int.class) },
-            { new Binding.Move(r9, int.class) },
-            { new Binding.Move(rax, long.class) },
+            { move(rdi, int.class) },
+            { move(rsi, int.class) },
+            { move(rdx, int.class) },
+            { move(rcx, int.class) },
+            { move(r8, int.class) },
+            { move(r9, int.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 0);
@@ -116,19 +117,19 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(xmm0, double.class) },
-            { new Binding.Move(xmm1, double.class) },
-            { new Binding.Move(xmm2, double.class) },
-            { new Binding.Move(xmm3, double.class) },
-            { new Binding.Move(xmm4, double.class) },
-            { new Binding.Move(xmm5, double.class) },
-            { new Binding.Move(xmm6, double.class) },
-            { new Binding.Move(xmm7, double.class) },
-            { new Binding.Move(rax, long.class) },
+            { move(xmm0, double.class) },
+            { move(xmm1, double.class) },
+            { move(xmm2, double.class) },
+            { move(xmm3, double.class) },
+            { move(xmm4, double.class) },
+            { move(xmm5, double.class) },
+            { move(xmm6, double.class) },
+            { move(xmm7, double.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 8);
@@ -150,29 +151,29 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rdi, long.class) },
-            { new Binding.Move(rsi, long.class) },
-            { new Binding.Move(rdx, long.class) },
-            { new Binding.Move(rcx, long.class) },
-            { new Binding.Move(r8, long.class) },
-            { new Binding.Move(r9, long.class) },
-            { new Binding.Move(stackStorage(0), long.class) },
-            { new Binding.Move(stackStorage(1), long.class) },
-            { new Binding.Move(xmm0, float.class) },
-            { new Binding.Move(xmm1, float.class) },
-            { new Binding.Move(xmm2, float.class) },
-            { new Binding.Move(xmm3, float.class) },
-            { new Binding.Move(xmm4, float.class) },
-            { new Binding.Move(xmm5, float.class) },
-            { new Binding.Move(xmm6, float.class) },
-            { new Binding.Move(xmm7, float.class) },
-            { new Binding.Move(stackStorage(2), float.class) },
-            { new Binding.Move(stackStorage(3), float.class) },
-            { new Binding.Move(rax, long.class) },
+            { move(rdi, long.class) },
+            { move(rsi, long.class) },
+            { move(rdx, long.class) },
+            { move(rcx, long.class) },
+            { move(r8, long.class) },
+            { move(r9, long.class) },
+            { move(stackStorage(0), long.class) },
+            { move(stackStorage(1), long.class) },
+            { move(xmm0, float.class) },
+            { move(xmm1, float.class) },
+            { move(xmm2, float.class) },
+            { move(xmm3, float.class) },
+            { move(xmm4, float.class) },
+            { move(xmm5, float.class) },
+            { move(xmm6, float.class) },
+            { move(xmm7, float.class) },
+            { move(stackStorage(2), float.class) },
+            { move(stackStorage(3), float.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 8);
@@ -206,24 +207,25 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rdi, int.class) },
-            { new Binding.Move(rsi, int.class) },
-            { new Binding.Dup(),
-                new Binding.Dereference(0, long.class), new Binding.Move(rdx, long.class),
-                new Binding.Dereference(8, long.class), new Binding.Move(xmm0, long.class)
+            { move(rdi, int.class) },
+            { move(rsi, int.class) },
+            {
+                dup(),
+                dereference(0, long.class), move(rdx, long.class),
+                dereference(8, long.class), move(xmm0, long.class)
             },
-            { new Binding.Move(rcx, int.class) },
-            { new Binding.Move(r8, int.class) },
-            { new Binding.Move(xmm1, double.class) },
-            { new Binding.Move(xmm2, double.class) },
-            { new Binding.Move(r9, int.class) },
-            { new Binding.Move(stackStorage(0), int.class) },
-            { new Binding.Move(stackStorage(1), int.class) },
-            { new Binding.Move(rax, long.class) },
+            { move(rcx, int.class) },
+            { move(r8, int.class) },
+            { move(xmm1, double.class) },
+            { move(xmm2, double.class) },
+            { move(r9, int.class) },
+            { move(stackStorage(0), int.class) },
+            { move(stackStorage(1), int.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 3);
@@ -247,12 +249,12 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.BoxAddress(), new Binding.Move(rdi, long.class) },
-            { new Binding.Move(rax, long.class) },
+            { convertAddress(), move(rdi, long.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 0);
@@ -269,11 +271,11 @@
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
             expectedBindings,
-            { new Binding.Move(rax, long.class) },
+            { move(rax, long.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
 
         assertEquals(bindings.nVectorArgs, 0);
@@ -282,35 +284,35 @@
 
     @DataProvider
     public static Object[][] structs() {
         return new Object[][]{
             { MemoryLayout.ofStruct(C_ULONG), new Binding[]{
-                    new Binding.Dereference(0, long.class), new Binding.Move(rdi, long.class)
+                    dereference(0, long.class), move(rdi, long.class)
                 }
             },
             { MemoryLayout.ofStruct(C_ULONG, C_ULONG), new Binding[]{
-                    new Binding.Dup(),
-                    new Binding.Dereference(0, long.class), new Binding.Move(rdi, long.class),
-                    new Binding.Dereference(8, long.class), new Binding.Move(rsi, long.class)
+                    dup(),
+                    dereference(0, long.class), move(rdi, long.class),
+                    dereference(8, long.class), move(rsi, long.class)
                 }
             },
             { MemoryLayout.ofStruct(C_ULONG, C_ULONG, C_ULONG), new Binding[]{
-                    new Binding.Dup(),
-                    new Binding.Dereference(0, long.class), new Binding.Move(stackStorage(0), long.class),
-                    new Binding.Dup(),
-                    new Binding.Dereference(8, long.class), new Binding.Move(stackStorage(1), long.class),
-                    new Binding.Dereference(16, long.class), new Binding.Move(stackStorage(2), long.class)
+                    dup(),
+                    dereference(0, long.class), move(stackStorage(0), long.class),
+                    dup(),
+                    dereference(8, long.class), move(stackStorage(1), long.class),
+                    dereference(16, long.class), move(stackStorage(2), long.class)
                 }
             },
             { MemoryLayout.ofStruct(C_ULONG, C_ULONG, C_ULONG, C_ULONG), new Binding[]{
-                    new Binding.Dup(),
-                    new Binding.Dereference(0, long.class), new Binding.Move(stackStorage(0), long.class),
-                    new Binding.Dup(),
-                    new Binding.Dereference(8, long.class), new Binding.Move(stackStorage(1), long.class),
-                    new Binding.Dup(),
-                    new Binding.Dereference(16, long.class), new Binding.Move(stackStorage(2), long.class),
-                    new Binding.Dereference(24, long.class), new Binding.Move(stackStorage(3), long.class)
+                    dup(),
+                    dereference(0, long.class), move(stackStorage(0), long.class),
+                    dup(),
+                    dereference(8, long.class), move(stackStorage(1), long.class),
+                    dup(),
+                    dereference(16, long.class), move(stackStorage(2), long.class),
+                    dereference(24, long.class), move(stackStorage(3), long.class)
                 }
             },
         };
     }
 
@@ -326,21 +328,21 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class));
         assertEquals(callingSequence.functionDesc(), descAddArgument(fd, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rax, long.class) }
+            { move(rax, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[] {
-            new Binding.AllocateBuffer(struct),
-            new Binding.Dup(),
-            new Binding.Move(rax, long.class),
-            new Binding.Dereference(0, long.class),
-            new Binding.Dup(),
-            new Binding.Move(rdx, long.class),
-            new Binding.Dereference(8, long.class)
+            allocate(struct),
+            dup(),
+            move(rax, long.class),
+            dereference(0, long.class),
+            dup(),
+            move(rdx, long.class),
+            dereference(8, long.class)
         });
 
         assertEquals(bindings.nVectorArgs, 0);
     }
 
@@ -356,12 +358,12 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class, long.class));
         assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER, C_LONG));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.BoxAddress(), new Binding.Move(rdi, long.class) },
-            { new Binding.Move(rax, long.class) }
+            { convertAddress(), move(rdi, long.class) },
+            { move(rax, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[] {});
 
         assertEquals(bindings.nVectorArgs, 0);
diff a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
--- a/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
+++ b/test/jdk/java/foreign/callarranger/TestWindowsCallArranger.java
@@ -44,10 +44,12 @@
 
 import java.lang.invoke.MethodType;
 
 import static jdk.incubator.foreign.MemoryLayouts.WinABI.*;
 import static jdk.incubator.foreign.MemoryLayouts.WinABI.asVarArg;
+import static jdk.internal.foreign.abi.Binding.*;
+import static jdk.internal.foreign.abi.Binding.copy;
 import static jdk.internal.foreign.abi.x64.X86_64Architecture.*;
 import static org.testng.Assert.*;
 
 public class TestWindowsCallArranger extends CallArrangerTestBase {
 
@@ -76,14 +78,14 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rcx, int.class) },
-            { new Binding.Move(rdx, int.class) },
-            { new Binding.Move(r8, int.class) },
-            { new Binding.Move(r9, int.class) }
+            { move(rcx, int.class) },
+            { move(rdx, int.class) },
+            { move(r8, int.class) },
+            { move(r9, int.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -97,14 +99,14 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(xmm0, double.class) },
-            { new Binding.Move(xmm1, double.class) },
-            { new Binding.Move(xmm2, double.class) },
-            { new Binding.Move(xmm3, double.class) }
+            { move(xmm0, double.class) },
+            { move(xmm1, double.class) },
+            { move(xmm2, double.class) },
+            { move(xmm3, double.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -120,18 +122,18 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rcx, long.class) },
-            { new Binding.Move(rdx, long.class) },
-            { new Binding.Move(xmm2, float.class) },
-            { new Binding.Move(xmm3, float.class) },
-            { new Binding.Move(stackStorage(0), long.class) },
-            { new Binding.Move(stackStorage(1), long.class) },
-            { new Binding.Move(stackStorage(2), float.class) },
-            { new Binding.Move(stackStorage(3), float.class) }
+            { move(rcx, long.class) },
+            { move(rdx, long.class) },
+            { move(xmm2, float.class) },
+            { move(xmm3, float.class) },
+            { move(stackStorage(0), long.class) },
+            { move(stackStorage(1), long.class) },
+            { move(stackStorage(2), float.class) },
+            { move(stackStorage(3), float.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -150,24 +152,26 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rcx, int.class) },
-            { new Binding.Move(rdx, int.class) },
-            { new Binding.Copy(structLayout.byteSize(), structLayout.byteAlignment()),
-                new Binding.BaseAddress(),
-                new Binding.BoxAddress(),
-                new Binding.Move(r8, long.class) },
-            { new Binding.Move(r9, int.class) },
-            { new Binding.Move(stackStorage(0), int.class) },
-            { new Binding.Move(stackStorage(1), double.class) },
-            { new Binding.Move(stackStorage(2), double.class) },
-            { new Binding.Move(stackStorage(3), double.class) },
-            { new Binding.Move(stackStorage(4), int.class) },
-            { new Binding.Move(stackStorage(5), int.class) },
-            { new Binding.Move(stackStorage(6), int.class) }
+            { move(rcx, int.class) },
+            { move(rdx, int.class) },
+            {
+                copy(structLayout),
+                baseAddress(),
+                convertAddress(),
+                move(r8, long.class)
+            },
+            { move(r9, int.class) },
+            { move(stackStorage(0), int.class) },
+            { move(stackStorage(1), double.class) },
+            { move(stackStorage(2), double.class) },
+            { move(stackStorage(3), double.class) },
+            { move(stackStorage(4), int.class) },
+            { move(stackStorage(5), int.class) },
+            { move(stackStorage(6), int.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -183,15 +187,15 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Move(rcx, int.class) },
-            { new Binding.Move(xmm1, double.class) },
-            { new Binding.Move(r8, int.class) },
-            { new Binding.Dup(), new Binding.Move(r9, double.class), new Binding.Move(xmm3, double.class) },
-            { new Binding.Move(stackStorage(0), double.class) },
+            { move(rcx, int.class) },
+            { move(xmm1, double.class) },
+            { move(r8, int.class) },
+            { dup(), move(r9, double.class), move(xmm3, double.class) },
+            { move(stackStorage(0), double.class) },
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -216,11 +220,11 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Dereference(0, long.class), new Binding.Move(rcx, long.class) }
+            { dereference(0, long.class), move(rcx, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -245,14 +249,16 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.Copy(struct.byteSize(), struct.byteAlignment()),
-                    new Binding.BaseAddress(),
-                    new Binding.BoxAddress(),
-                    new Binding.Move(rcx, long.class) }
+            {
+                copy(struct),
+                baseAddress(),
+                convertAddress(),
+                move(rcx, long.class)
+            }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -274,11 +280,11 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), mt);
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.BoxAddress(), new Binding.Move(rcx, long.class) }
+            { convertAddress(), move(rcx, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 
@@ -296,14 +302,14 @@
         assertEquals(callingSequence.functionDesc(), fd);
 
         checkArgumentBindings(callingSequence, new Binding[][]{});
 
         checkReturnBindings(callingSequence,
-            new Binding[]{ new Binding.AllocateBuffer(struct),
-                new Binding.Dup(),
-                new Binding.Move(rax, long.class),
-                new Binding.Dereference(0, long.class) });
+            new Binding[]{ allocate(struct),
+                dup(),
+                move(rax, long.class),
+                dereference(0, long.class) });
     }
 
     @Test
     public void testIMR() {
         MemoryLayout struct = MemoryLayout.ofStruct(C_ULONGLONG, C_ULONGLONG);
@@ -316,11 +322,11 @@
         CallingSequence callingSequence = bindings.callingSequence;
         assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class));
         assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(false, C_POINTER));
 
         checkArgumentBindings(callingSequence, new Binding[][]{
-            { new Binding.BoxAddress(), new Binding.Move(rcx, long.class) }
+            { convertAddress(), move(rcx, long.class) }
         });
 
         checkReturnBindings(callingSequence, new Binding[]{});
     }
 }
