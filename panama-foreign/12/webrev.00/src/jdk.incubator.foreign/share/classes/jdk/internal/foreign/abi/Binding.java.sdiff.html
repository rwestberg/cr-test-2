<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
 25 import jdk.incubator.foreign.MemoryLayout;
 26 


 27 import java.util.Objects;
 28 

























































































































































 29 public abstract class Binding {
<span class="line-modified"> 30     static final int MOVE_TAG = 0;</span>
<span class="line-modified"> 31     static final int DEREFERENCE_TAG = 1;</span>
<span class="line-modified"> 32     static final int COPY_BUFFER_TAG = 2;</span>
<span class="line-modified"> 33     static final int ALLOC_BUFFER_TAG = 3;</span>
<span class="line-modified"> 34     static final int BOX_ADDRESS_TAG = 4;</span>
<span class="line-modified"> 35     static final int BASE_ADDRESS_TAG = 5;</span>
<span class="line-modified"> 36     static final int DUP_TAG = 6;</span>


 37 
<span class="line-modified"> 38     private final int tag;</span>
 39 
<span class="line-modified"> 40     private Binding(int tag) {</span>
 41         this.tag = tag;
 42     }
 43 
<span class="line-modified"> 44     public int tag() {</span>
 45         return tag;
 46     }
 47 










































 48     /**
<span class="line-modified"> 49      * Moves from a primitve to a VMStorage</span>

















































 50      */
 51     public static class Move extends Binding {
 52         private final VMStorage storage;
 53         private final Class&lt;?&gt; type;
 54 
<span class="line-modified"> 55         public Move(VMStorage storage, Class&lt;?&gt; type) {</span>
<span class="line-modified"> 56             super(MOVE_TAG);</span>
 57             this.storage = storage;
 58             this.type = type;
 59         }
 60 
 61         public VMStorage storage() {
 62             return storage;
 63         }
 64 
 65         public Class&lt;?&gt; type() {
 66             return type;
 67         }
 68 
 69         @Override
 70         public String toString() {
 71             return &quot;Move{&quot; +
 72                     &quot;tag=&quot; + tag() +
 73                     &quot;, storage=&quot; + storage +
 74                     &quot;, type=&quot; + type +
 75                     &#39;}&#39;;
 76         }
 77 
 78         @Override
 79         public boolean equals(Object o) {
 80             if (this == o) return true;
 81             if (o == null || getClass() != o.getClass()) return false;
 82             Move move = (Move) o;
 83             return storage.equals(move.storage) &amp;&amp;
 84                     type.equals(move.type);
 85         }
 86 
 87         @Override
 88         public int hashCode() {
 89             return Objects.hash(tag(), storage, type);
 90         }
 91     }
 92 
 93     /**
<span class="line-modified"> 94      * Loads or stores a Java primitive to a MemorySegment at a certain offset</span>





 95      */
 96     public static class Dereference extends Binding {
 97         private final long offset;
 98         private final Class&lt;?&gt; type;
 99 
<span class="line-modified">100         public Dereference(long offset, Class&lt;?&gt; type) {</span>
<span class="line-modified">101             super(DEREFERENCE_TAG);</span>
102             this.offset = offset;
103             this.type = type;
104         }
105 
106         public long offset() {
107             return offset;
108         }
109 
110         public Class&lt;?&gt; type() {
111             return type;
112         }
113 
114         @Override
115         public String toString() {
116             return &quot;Dereference{&quot; +
117                     &quot;tag=&quot; + tag() +
118                     &quot;, offset=&quot; + offset +
119                     &quot;, type=&quot; + type +
120                     &#39;}&#39;;
121         }
122 
123         @Override
124         public boolean equals(Object o) {
125             if (this == o) return true;
126             if (o == null || getClass() != o.getClass()) return false;
127             Dereference that = (Dereference) o;
128             return offset == that.offset &amp;&amp;
129                     type.equals(that.type);
130         }
131 
132         @Override
133         public int hashCode() {
134             return Objects.hash(tag(), offset, type);
135         }
136     }
137 
138     /**
<span class="line-modified">139      * Copies from a MemoryAddress into a newly allocated MemorySegment</span>



140      */
141     public static class Copy extends Binding {
142         private final long size;
143         private final long alignment;
144 
<span class="line-modified">145         public Copy(long size, long alignment) {</span>
<span class="line-modified">146             super(COPY_BUFFER_TAG);</span>
147             this.size = size;
148             this.alignment = alignment;
149         }
150 
151         public long size() {
152             return size;
153         }
154 
155         public long alignment() {
156             return alignment;
157         }
158 
159         @Override
160         public String toString() {
161             return &quot;Copy{&quot; +
162                     &quot;tag=&quot; + tag() +
163                     &quot;, size=&quot; + size +
164                     &quot;, alignment=&quot; + alignment +
165                     &#39;}&#39;;
166         }
167 
168         @Override
169         public boolean equals(Object o) {
170             if (this == o) return true;
171             if (o == null || getClass() != o.getClass()) return false;
172             Copy copy = (Copy) o;
173             return size == copy.size &amp;&amp;
174                     alignment == copy.alignment;
175         }
176 
177         @Override
178         public int hashCode() {
179             return Objects.hash(tag(), size, alignment);
180         }
181     }
182 
183     /**
<span class="line-modified">184      * Allocates a MemorySegment</span>

185      */
<span class="line-modified">186     public static class AllocateBuffer extends Binding {</span>
187         private final long size;
188         private final long alignment;
189 
<span class="line-modified">190         public AllocateBuffer(MemoryLayout layout) {</span>
<span class="line-modified">191             super(ALLOC_BUFFER_TAG);</span>
<span class="line-modified">192             this.size = layout.byteSize();</span>
<span class="line-modified">193             this.alignment = layout.byteAlignment();</span>
194         }
195 
196         public long size() {
197             return size;
198         }
199 
200         public long alignment() {
201             return alignment;
202         }
203 
204         @Override
205         public String toString() {
206             return &quot;AllocateBuffer{&quot; +
207                     &quot;tag=&quot; + tag() +
208                     &quot;size=&quot; + size +
209                     &quot;, alignment=&quot; + alignment +
210                     &#39;}&#39;;
211         }
212 
213         @Override
214         public boolean equals(Object o) {
215             if (this == o) return true;
216             if (o == null || getClass() != o.getClass()) return false;
<span class="line-modified">217             AllocateBuffer that = (AllocateBuffer) o;</span>
218             return size == that.size &amp;&amp;
219                     alignment == that.alignment;
220         }
221 
222         @Override
223         public int hashCode() {
224             return Objects.hash(tag(), size, alignment);
225         }
226     }
227 
228     /**
<span class="line-modified">229      * Boxes or unboxes a MemoryAddress to a long and vice versa (depending on box/unbox interpreter)</span>




230      */
<span class="line-modified">231     public static class BoxAddress extends Binding {</span>
<span class="line-modified">232         public BoxAddress() {</span>
<span class="line-modified">233             super(BOX_ADDRESS_TAG);</span>

234         }
235 
236         @Override
237         public String toString() {
238             return &quot;BoxAddress{&quot; +
239                     &quot;tag=&quot; + tag() +
240                     &quot;}&quot;;
241         }
242 
243         @Override
244         public int hashCode() {
<span class="line-modified">245             return tag();</span>
246         }
247 
248         @Override
249         public boolean equals(Object o) {
250             if (this == o) return true;
251             return o != null &amp;&amp; getClass() == o.getClass();
252         }
253     }
254 
255     /**
<span class="line-modified">256      * Takes the base address of a MemorySegment</span>


257      */
258     public static class BaseAddress extends Binding {
<span class="line-modified">259         public BaseAddress() {</span>
<span class="line-modified">260             super(BASE_ADDRESS_TAG);</span>

261         }
262 
263         @Override
264         public String toString() {
265             return &quot;BaseAddress{&quot; +
266                     &quot;tag=&quot; + tag() +
267                     &quot;}&quot;;
268         }
269 
270         @Override
271         public int hashCode() {
<span class="line-modified">272             return tag();</span>
273         }
274 
275         @Override
276         public boolean equals(Object o) {
277             if (this == o) return true;
278             return o != null &amp;&amp; getClass() == o.getClass();
279         }
280     }
281 
282     /**
<span class="line-modified">283      * Duplicates a value on top of the interpreter stack</span>


284      */
285     public static class Dup extends Binding {
<span class="line-modified">286         public Dup() {</span>
<span class="line-modified">287             super(DUP_TAG);</span>

288         }
289 
290         @Override
291         public String toString() {
292             return &quot;Dup{&quot; +
293                     &quot;tag=&quot; + tag() +
294                     &quot;}&quot;;
295         }
296 
297         @Override
298         public int hashCode() {
<span class="line-modified">299             return tag();</span>
300         }
301 
302         @Override
303         public boolean equals(Object o) {
304             if (this == o) return true;
305             return o != null &amp;&amp; getClass() == o.getClass();
306         }
307     }
308 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.internal.foreign.abi;
 24 
 25 import jdk.incubator.foreign.MemoryLayout;
 26 
<span class="line-added"> 27 import java.util.ArrayList;</span>
<span class="line-added"> 28 import java.util.List;</span>
 29 import java.util.Objects;
 30 
<span class="line-added"> 31 /**</span>
<span class="line-added"> 32  * The binding operators defined in the Binding class can be combined into argument and return value processing &#39;recipes&#39;.</span>
<span class="line-added"> 33  *</span>
<span class="line-added"> 34  * The binding operators are interpreted using a stack-base interpreter. Operators can either consume operands from the</span>
<span class="line-added"> 35  * stack, or push them onto the stack.</span>
<span class="line-added"> 36  *</span>
<span class="line-added"> 37  * In the description of each binding we talk about &#39;boxing&#39; and &#39;unboxing&#39;.</span>
<span class="line-added"> 38  *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine</span>
<span class="line-added"> 39  *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.</span>
<span class="line-added"> 40  *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.</span>
<span class="line-added"> 41  *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.</span>
<span class="line-added"> 42  *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.</span>
<span class="line-added"> 43  * A binding operator can be interpreted differently based on whether we are boxing or unboxing a value. For example,</span>
<span class="line-added"> 44  * the CONVERT_ADDRESS operator &#39;unboxes&#39; a MemoryAddress to a long, but &#39;boxes&#39; a long to a MemoryAddress.</span>
<span class="line-added"> 45  *</span>
<span class="line-added"> 46  * Here are some examples of binding recipes derived from C declarations, and according to the Windows ABI (recipes are</span>
<span class="line-added"> 47  * ABI-specific). Note that each argument has it&#39;s own recipe, which is indicated by &#39;[number]:&#39; (though, the only</span>
<span class="line-added"> 48  * example that has multiple arguments is the one using varargs).</span>
<span class="line-added"> 49  *</span>
<span class="line-added"> 50  * --------------------</span>
<span class="line-added"> 51  *</span>
<span class="line-added"> 52  * void f(int i);</span>
<span class="line-added"> 53  *</span>
<span class="line-added"> 54  * Argument bindings:</span>
<span class="line-added"> 55  * 0: MOVE(rcx, int.class) // move an &#39;int&#39; into the RCX register</span>
<span class="line-added"> 56  *</span>
<span class="line-added"> 57  * Return bindings:</span>
<span class="line-added"> 58  * none</span>
<span class="line-added"> 59  *</span>
<span class="line-added"> 60  * --------------------</span>
<span class="line-added"> 61  *</span>
<span class="line-added"> 62  * void f(int* i);</span>
<span class="line-added"> 63  *</span>
<span class="line-added"> 64  * Argument bindings:</span>
<span class="line-added"> 65  * 0: CONVERT_ADDRESS // the &#39;MemoryAddress&#39; is converted into a &#39;long&#39;</span>
<span class="line-added"> 66  *    MOVE(rcx, long.class) // the &#39;long&#39; is moved into the RCX register</span>
<span class="line-added"> 67  *</span>
<span class="line-added"> 68  * Return bindings:</span>
<span class="line-added"> 69  * none</span>
<span class="line-added"> 70  *</span>
<span class="line-added"> 71  * --------------------</span>
<span class="line-added"> 72  *</span>
<span class="line-added"> 73  * int* f();</span>
<span class="line-added"> 74  *</span>
<span class="line-added"> 75  * Argument bindings:</span>
<span class="line-added"> 76  * none</span>
<span class="line-added"> 77  *</span>
<span class="line-added"> 78  * Return bindings:</span>
<span class="line-added"> 79  * 0: MOVE(rax, long) // load a &#39;long&#39; from the RAX register</span>
<span class="line-added"> 80  *    CONVERT_ADDRESS // convert the &#39;long&#39; into a &#39;MemoryAddress&#39;</span>
<span class="line-added"> 81  *</span>
<span class="line-added"> 82  * --------------------</span>
<span class="line-added"> 83  *</span>
<span class="line-added"> 84  * typedef struct { // fits into single register</span>
<span class="line-added"> 85  *   int x;</span>
<span class="line-added"> 86  *   int y;</span>
<span class="line-added"> 87  * } MyStruct;</span>
<span class="line-added"> 88  *</span>
<span class="line-added"> 89  * void f(MyStruct ms);</span>
<span class="line-added"> 90  *</span>
<span class="line-added"> 91  * Argument bindings:</span>
<span class="line-added"> 92  * 0: DEREFERENCE(0, long.class) // From the struct&#39;s memory region, load a &#39;long&#39; from offset &#39;0&#39;</span>
<span class="line-added"> 93  *    MOVE(rcx, long.class) // and copy that into the RCX regitster</span>
<span class="line-added"> 94  *</span>
<span class="line-added"> 95  * Return bindings:</span>
<span class="line-added"> 96  * none</span>
<span class="line-added"> 97  *</span>
<span class="line-added"> 98  * --------------------</span>
<span class="line-added"> 99  *</span>
<span class="line-added">100  * typedef struct { // does not fit into single register</span>
<span class="line-added">101  *   long long x;</span>
<span class="line-added">102  *   long long y;</span>
<span class="line-added">103  * } MyStruct;</span>
<span class="line-added">104  *</span>
<span class="line-added">105  * void f(MyStruct ms);</span>
<span class="line-added">106  *</span>
<span class="line-added">107  * For the Windows ABI:</span>
<span class="line-added">108  *</span>
<span class="line-added">109  * Argument bindings:</span>
<span class="line-added">110  * 0: COPY(16, 8) // copy the memory region containing the struct</span>
<span class="line-added">111  *    BASE_ADDRESS // take the base address of the copy</span>
<span class="line-added">112  *    CONVERT_ADDRESS // converts the base address to a &#39;long&#39;</span>
<span class="line-added">113  *    MOVE(rcx, long.class) // moves the &#39;long&#39; into the RCX register</span>
<span class="line-added">114  *</span>
<span class="line-added">115  * Return bindings:</span>
<span class="line-added">116  * none</span>
<span class="line-added">117  *</span>
<span class="line-added">118  * For the SysV ABI:</span>
<span class="line-added">119  *</span>
<span class="line-added">120  * Argument bindings:</span>
<span class="line-added">121  * 0: DUP // duplicates the MemoryRegion operand</span>
<span class="line-added">122  *    DEREFERENCE(0, long.class) // loads a &#39;long&#39; from offset &#39;0&#39;</span>
<span class="line-added">123  *    MOVE(rdx, long.class) // moves the long into the RDX register</span>
<span class="line-added">124  *    DEREFERENCE(8, long.class) // loads a &#39;long&#39; from offset &#39;8&#39;</span>
<span class="line-added">125  *    MOVE(rcx, long.class) // moves the long into the RCX register</span>
<span class="line-added">126  *</span>
<span class="line-added">127  * Return bindings:</span>
<span class="line-added">128  * none</span>
<span class="line-added">129  *</span>
<span class="line-added">130  * --------------------</span>
<span class="line-added">131  *</span>
<span class="line-added">132  * typedef struct { // fits into single register</span>
<span class="line-added">133  *   int x;</span>
<span class="line-added">134  *   int y;</span>
<span class="line-added">135  * } MyStruct;</span>
<span class="line-added">136  *</span>
<span class="line-added">137  * MyStruct f();</span>
<span class="line-added">138  *</span>
<span class="line-added">139  * Argument bindings:</span>
<span class="line-added">140  * none</span>
<span class="line-added">141  *</span>
<span class="line-added">142  * Return bindings:</span>
<span class="line-added">143  * 0: ALLOCATE(GroupLayout(C_INT, C_INT)) // allocate a buffer with the memory layout of the struct</span>
<span class="line-added">144  *    DUP // duplicate the allocated buffer</span>
<span class="line-added">145  *    MOVE(rax, long.class) // loads a &#39;long&#39; from rax</span>
<span class="line-added">146  *    DEREFERENCE(0, long.class) // stores a &#39;long&#39; at offset 0</span>
<span class="line-added">147  *</span>
<span class="line-added">148  * --------------------</span>
<span class="line-added">149  *</span>
<span class="line-added">150  * typedef struct { // does not fit into single register</span>
<span class="line-added">151  *   long long x;</span>
<span class="line-added">152  *   long long y;</span>
<span class="line-added">153  * } MyStruct;</span>
<span class="line-added">154  *</span>
<span class="line-added">155  * MyStruct f();</span>
<span class="line-added">156  *</span>
<span class="line-added">157  * !! uses synthetic argument, which is a pointer to a pre-allocated buffer</span>
<span class="line-added">158  *</span>
<span class="line-added">159  * Argument bindings:</span>
<span class="line-added">160  * 0: CONVERT_ADDRESS // unbox the MemoryAddress synthetic argument</span>
<span class="line-added">161  *    MOVE(rcx, long.class) // moves the &#39;long&#39; into the RCX register</span>
<span class="line-added">162  *</span>
<span class="line-added">163  * Return bindings:</span>
<span class="line-added">164  * none</span>
<span class="line-added">165  *</span>
<span class="line-added">166  * --------------------</span>
<span class="line-added">167  *</span>
<span class="line-added">168  * void f(int dummy, ...); // varargs</span>
<span class="line-added">169  *</span>
<span class="line-added">170  * f(0, 10f); // passing a float</span>
<span class="line-added">171  *</span>
<span class="line-added">172  * Argument bindings:</span>
<span class="line-added">173  * 0: MOVE(rcx, int.class) // moves the &#39;int dummy&#39; into the RCX register</span>
<span class="line-added">174  *</span>
<span class="line-added">175  * 1: DUP // duplicates the &#39;10f&#39; argument</span>
<span class="line-added">176  *    MOVE(rdx, float.class) // move one copy into the RDX register</span>
<span class="line-added">177  *    MOVE(xmm1, float.class) // moves the other copy into the xmm2 register</span>
<span class="line-added">178  *</span>
<span class="line-added">179  * Return bindings:</span>
<span class="line-added">180  * none</span>
<span class="line-added">181  *</span>
<span class="line-added">182  * --------------------</span>
<span class="line-added">183  */</span>
184 public abstract class Binding {
<span class="line-modified">185     enum Tag {</span>
<span class="line-modified">186         MOVE,</span>
<span class="line-modified">187         DEREFERENCE,</span>
<span class="line-modified">188         COPY_BUFFER,</span>
<span class="line-modified">189         ALLOC_BUFFER,</span>
<span class="line-modified">190         CONVERT_ADDRESS,</span>
<span class="line-modified">191         BASE_ADDRESS,</span>
<span class="line-added">192         DUP</span>
<span class="line-added">193     }</span>
194 
<span class="line-modified">195     private final Tag tag;</span>
196 
<span class="line-modified">197     private Binding(Tag tag) {</span>
198         this.tag = tag;
199     }
200 
<span class="line-modified">201     public Tag tag() {</span>
202         return tag;
203     }
204 
<span class="line-added">205     private static void checkType(Class&lt;?&gt; type) {</span>
<span class="line-added">206         if (!type.isPrimitive() || type == void.class || type == boolean.class)</span>
<span class="line-added">207             throw new IllegalArgumentException(&quot;Illegal type: &quot; + type);</span>
<span class="line-added">208     }</span>
<span class="line-added">209 </span>
<span class="line-added">210     public static Move move(VMStorage storage, Class&lt;?&gt; type) {</span>
<span class="line-added">211         checkType(type);</span>
<span class="line-added">212         return new Move(storage, type);</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     public static Dereference dereference(long offset, Class&lt;?&gt; type) {</span>
<span class="line-added">216         checkType(type);</span>
<span class="line-added">217         if (offset &lt; 0)</span>
<span class="line-added">218             throw new IllegalArgumentException(&quot;Negative offset: &quot; + offset);</span>
<span class="line-added">219         return new Dereference(offset, type);</span>
<span class="line-added">220     }</span>
<span class="line-added">221 </span>
<span class="line-added">222     public static Copy copy(MemoryLayout layout) {</span>
<span class="line-added">223         return new Copy(layout.byteSize(), layout.byteAlignment());</span>
<span class="line-added">224     }</span>
<span class="line-added">225 </span>
<span class="line-added">226     public static Allocate allocate(MemoryLayout layout) {</span>
<span class="line-added">227         return new Allocate(layout.byteSize(), layout.byteAlignment());</span>
<span class="line-added">228     }</span>
<span class="line-added">229 </span>
<span class="line-added">230     public static ConvertAddress convertAddress() {</span>
<span class="line-added">231         return ConvertAddress.INSTANCE;</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
<span class="line-added">234     public static BaseAddress baseAddress() {</span>
<span class="line-added">235         return BaseAddress.INSTANCE;</span>
<span class="line-added">236     }</span>
<span class="line-added">237 </span>
<span class="line-added">238     public static Dup dup() {</span>
<span class="line-added">239         return Dup.INSTANCE;</span>
<span class="line-added">240     }</span>
<span class="line-added">241 </span>
<span class="line-added">242 </span>
<span class="line-added">243     public static Binding.Builder builder() {</span>
<span class="line-added">244         return new Binding.Builder();</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
247     /**
<span class="line-modified">248      * A builder helper class for generating lists of Bindings</span>
<span class="line-added">249      */</span>
<span class="line-added">250     public static class Builder {</span>
<span class="line-added">251         private final List&lt;Binding&gt; bindings = new ArrayList&lt;&gt;();</span>
<span class="line-added">252 </span>
<span class="line-added">253         public Binding.Builder move(VMStorage storage, Class&lt;?&gt; type) {</span>
<span class="line-added">254             bindings.add(Binding.move(storage, type));</span>
<span class="line-added">255             return this;</span>
<span class="line-added">256         }</span>
<span class="line-added">257 </span>
<span class="line-added">258         public Binding.Builder dereference(long offset, Class&lt;?&gt; type) {</span>
<span class="line-added">259             bindings.add(Binding.dereference(offset, type));</span>
<span class="line-added">260             return this;</span>
<span class="line-added">261         }</span>
<span class="line-added">262 </span>
<span class="line-added">263         public Binding.Builder copy(MemoryLayout layout) {</span>
<span class="line-added">264             bindings.add(Binding.copy(layout));</span>
<span class="line-added">265             return this;</span>
<span class="line-added">266         }</span>
<span class="line-added">267 </span>
<span class="line-added">268         public Binding.Builder allocate(MemoryLayout layout) {</span>
<span class="line-added">269             bindings.add(Binding.allocate(layout));</span>
<span class="line-added">270             return this;</span>
<span class="line-added">271         }</span>
<span class="line-added">272 </span>
<span class="line-added">273         public Binding.Builder convertAddress() {</span>
<span class="line-added">274             bindings.add(Binding.convertAddress());</span>
<span class="line-added">275             return this;</span>
<span class="line-added">276         }</span>
<span class="line-added">277 </span>
<span class="line-added">278         public Binding.Builder baseAddress() {</span>
<span class="line-added">279             bindings.add(Binding.baseAddress());</span>
<span class="line-added">280             return this;</span>
<span class="line-added">281         }</span>
<span class="line-added">282 </span>
<span class="line-added">283         public Binding.Builder dup() {</span>
<span class="line-added">284             bindings.add(Binding.dup());</span>
<span class="line-added">285             return this;</span>
<span class="line-added">286         }</span>
<span class="line-added">287 </span>
<span class="line-added">288         public List&lt;Binding&gt; build() {</span>
<span class="line-added">289             return new ArrayList&lt;&gt;(bindings);</span>
<span class="line-added">290         }</span>
<span class="line-added">291     }</span>
<span class="line-added">292 </span>
<span class="line-added">293     /**</span>
<span class="line-added">294      * MOVE([storage location], [type])</span>
<span class="line-added">295      *   When unboxing: pops a [type] from the operand stack, and moves it to [storage location]</span>
<span class="line-added">296      *   When boxing: loads a [type] from [storage location], and pushes it onto the operand stack</span>
<span class="line-added">297      * The [type] must be one of byte, short, char, int, long, float, or double</span>
298      */
299     public static class Move extends Binding {
300         private final VMStorage storage;
301         private final Class&lt;?&gt; type;
302 
<span class="line-modified">303         private Move(VMStorage storage, Class&lt;?&gt; type) {</span>
<span class="line-modified">304             super(Tag.MOVE);</span>
305             this.storage = storage;
306             this.type = type;
307         }
308 
309         public VMStorage storage() {
310             return storage;
311         }
312 
313         public Class&lt;?&gt; type() {
314             return type;
315         }
316 
317         @Override
318         public String toString() {
319             return &quot;Move{&quot; +
320                     &quot;tag=&quot; + tag() +
321                     &quot;, storage=&quot; + storage +
322                     &quot;, type=&quot; + type +
323                     &#39;}&#39;;
324         }
325 
326         @Override
327         public boolean equals(Object o) {
328             if (this == o) return true;
329             if (o == null || getClass() != o.getClass()) return false;
330             Move move = (Move) o;
331             return storage.equals(move.storage) &amp;&amp;
332                     type.equals(move.type);
333         }
334 
335         @Override
336         public int hashCode() {
337             return Objects.hash(tag(), storage, type);
338         }
339     }
340 
341     /**
<span class="line-modified">342      * DEREFERENCE([offset into memory region], [type])</span>
<span class="line-added">343      *   When unboxing: pops a MemorySegment from the operand stack,</span>
<span class="line-added">344      *     loads a [type] from [offset into memory region] from it, and pushes it onto the operand stack</span>
<span class="line-added">345      *   When boxing: pops a [type], and then a MemorySegment from the operand stack,</span>
<span class="line-added">346      *     and then stores [type] to [offset into memory region] of the MemorySegment</span>
<span class="line-added">347      * The [type] must be one of byte, short, char, int, long, float, or double</span>
348      */
349     public static class Dereference extends Binding {
350         private final long offset;
351         private final Class&lt;?&gt; type;
352 
<span class="line-modified">353         private Dereference(long offset, Class&lt;?&gt; type) {</span>
<span class="line-modified">354             super(Tag.DEREFERENCE);</span>
355             this.offset = offset;
356             this.type = type;
357         }
358 
359         public long offset() {
360             return offset;
361         }
362 
363         public Class&lt;?&gt; type() {
364             return type;
365         }
366 
367         @Override
368         public String toString() {
369             return &quot;Dereference{&quot; +
370                     &quot;tag=&quot; + tag() +
371                     &quot;, offset=&quot; + offset +
372                     &quot;, type=&quot; + type +
373                     &#39;}&#39;;
374         }
375 
376         @Override
377         public boolean equals(Object o) {
378             if (this == o) return true;
379             if (o == null || getClass() != o.getClass()) return false;
380             Dereference that = (Dereference) o;
381             return offset == that.offset &amp;&amp;
382                     type.equals(that.type);
383         }
384 
385         @Override
386         public int hashCode() {
387             return Objects.hash(tag(), offset, type);
388         }
389     }
390 
391     /**
<span class="line-modified">392      * COPY([size], [alignment])</span>
<span class="line-added">393      *   Creates a new MemorySegment with the given [size] and [alignment],</span>
<span class="line-added">394      *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,</span>
<span class="line-added">395      *     and pushes the new buffer onto the operand stack</span>
396      */
397     public static class Copy extends Binding {
398         private final long size;
399         private final long alignment;
400 
<span class="line-modified">401         private Copy(long size, long alignment) {</span>
<span class="line-modified">402             super(Tag.COPY_BUFFER);</span>
403             this.size = size;
404             this.alignment = alignment;
405         }
406 
407         public long size() {
408             return size;
409         }
410 
411         public long alignment() {
412             return alignment;
413         }
414 
415         @Override
416         public String toString() {
417             return &quot;Copy{&quot; +
418                     &quot;tag=&quot; + tag() +
419                     &quot;, size=&quot; + size +
420                     &quot;, alignment=&quot; + alignment +
421                     &#39;}&#39;;
422         }
423 
424         @Override
425         public boolean equals(Object o) {
426             if (this == o) return true;
427             if (o == null || getClass() != o.getClass()) return false;
428             Copy copy = (Copy) o;
429             return size == copy.size &amp;&amp;
430                     alignment == copy.alignment;
431         }
432 
433         @Override
434         public int hashCode() {
435             return Objects.hash(tag(), size, alignment);
436         }
437     }
438 
439     /**
<span class="line-modified">440      * ALLOCATE([size], [alignment])</span>
<span class="line-added">441      *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.</span>
442      */
<span class="line-modified">443     public static class Allocate extends Binding {</span>
444         private final long size;
445         private final long alignment;
446 
<span class="line-modified">447         private Allocate(long size, long alignment) {</span>
<span class="line-modified">448             super(Tag.ALLOC_BUFFER);</span>
<span class="line-modified">449             this.size = size;</span>
<span class="line-modified">450             this.alignment = alignment;</span>
451         }
452 
453         public long size() {
454             return size;
455         }
456 
457         public long alignment() {
458             return alignment;
459         }
460 
461         @Override
462         public String toString() {
463             return &quot;AllocateBuffer{&quot; +
464                     &quot;tag=&quot; + tag() +
465                     &quot;size=&quot; + size +
466                     &quot;, alignment=&quot; + alignment +
467                     &#39;}&#39;;
468         }
469 
470         @Override
471         public boolean equals(Object o) {
472             if (this == o) return true;
473             if (o == null || getClass() != o.getClass()) return false;
<span class="line-modified">474             Allocate that = (Allocate) o;</span>
475             return size == that.size &amp;&amp;
476                     alignment == that.alignment;
477         }
478 
479         @Override
480         public int hashCode() {
481             return Objects.hash(tag(), size, alignment);
482         }
483     }
484 
485     /**
<span class="line-modified">486      * CONVERT_ADDRESS()</span>
<span class="line-added">487      *   When unboxing: pops a &#39;MemoryAddress&#39; from the operand stack, converts it to a &#39;long&#39;,</span>
<span class="line-added">488      *     and pushes that onto the operand stack</span>
<span class="line-added">489      *   When boxing: pops a &#39;long&#39; from the operand stack, converts it to a &#39;MemoryAddress&#39;,</span>
<span class="line-added">490      *     and pushes that onto the operand stack</span>
491      */
<span class="line-modified">492     public static class ConvertAddress extends Binding {</span>
<span class="line-modified">493         private static final ConvertAddress INSTANCE = new ConvertAddress();</span>
<span class="line-modified">494         private ConvertAddress() {</span>
<span class="line-added">495             super(Tag.CONVERT_ADDRESS);</span>
496         }
497 
498         @Override
499         public String toString() {
500             return &quot;BoxAddress{&quot; +
501                     &quot;tag=&quot; + tag() +
502                     &quot;}&quot;;
503         }
504 
505         @Override
506         public int hashCode() {
<span class="line-modified">507             return tag().hashCode();</span>
508         }
509 
510         @Override
511         public boolean equals(Object o) {
512             if (this == o) return true;
513             return o != null &amp;&amp; getClass() == o.getClass();
514         }
515     }
516 
517     /**
<span class="line-modified">518      * BASE_ADDRESS()</span>
<span class="line-added">519      *   Pops a MemorySegment from the operand stack, and takes the base address of the segment</span>
<span class="line-added">520      *   (the MemoryAddress that points to the start), and pushes that onto the operand stack</span>
521      */
522     public static class BaseAddress extends Binding {
<span class="line-modified">523         private static final BaseAddress INSTANCE = new BaseAddress();</span>
<span class="line-modified">524         private BaseAddress() {</span>
<span class="line-added">525             super(Tag.BASE_ADDRESS);</span>
526         }
527 
528         @Override
529         public String toString() {
530             return &quot;BaseAddress{&quot; +
531                     &quot;tag=&quot; + tag() +
532                     &quot;}&quot;;
533         }
534 
535         @Override
536         public int hashCode() {
<span class="line-modified">537             return tag().hashCode();</span>
538         }
539 
540         @Override
541         public boolean equals(Object o) {
542             if (this == o) return true;
543             return o != null &amp;&amp; getClass() == o.getClass();
544         }
545     }
546 
547     /**
<span class="line-modified">548      * DUP()</span>
<span class="line-added">549      *   Duplicates the value on the top of the operand stack (without popping it!),</span>
<span class="line-added">550      *   and pushes the duplicate onto the operand stack</span>
551      */
552     public static class Dup extends Binding {
<span class="line-modified">553         private static final Dup INSTANCE = new Dup();</span>
<span class="line-modified">554         private Dup() {</span>
<span class="line-added">555             super(Tag.DUP);</span>
556         }
557 
558         @Override
559         public String toString() {
560             return &quot;Dup{&quot; +
561                     &quot;tag=&quot; + tag() +
562                     &quot;}&quot;;
563         }
564 
565         @Override
566         public int hashCode() {
<span class="line-modified">567             return tag().hashCode();</span>
568         }
569 
570         @Override
571         public boolean equals(Object o) {
572             if (this == o) return true;
573             return o != null &amp;&amp; getClass() == o.getClass();
574         }
575     }
576 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BindingInterpreter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>