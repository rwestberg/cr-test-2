<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.invoke.VarHandle;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.WeakReference;
  33 import java.security.AccessController;
  34 import java.security.AccessControlContext;
  35 import java.security.PrivilegedAction;
  36 import java.security.ProtectionDomain;
  37 import java.time.Duration;
  38 import java.util.Map;
  39 import java.util.HashMap;
  40 import java.util.Objects;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.concurrent.Executor;
  44 import java.util.concurrent.ThreadFactory;
  45 import java.util.concurrent.TimeUnit;
  46 import java.util.concurrent.locks.LockSupport;
  47 
  48 import jdk.internal.misc.TerminatingThreadLocal;
  49 import jdk.internal.misc.Unsafe;
  50 import sun.nio.ch.Interruptible;
  51 import jdk.internal.reflect.CallerSensitive;
  52 import jdk.internal.reflect.Reflection;
  53 import sun.security.util.SecurityConstants;
  54 import jdk.internal.HotSpotIntrinsicCandidate;
  55 
  56 /**
  57  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  58  * virtual machine allows an application to have multiple threads of
  59  * execution running concurrently.
  60  *
  61  * &lt;p&gt; {@code Thread} supports the creation of threads that are scheduled by the
  62  * operating system. These threads are sometimes known as &lt;i&gt;kernel threads&lt;/i&gt;
  63  * or &lt;i&gt;heavyweight threads&lt;/i&gt; and will usually have a large stack and other
  64  * resources that are maintained by the operating system. Kernel threads are
  65  * suitable for executing all tasks but they are a limited resource.
  66  *
  67  * &lt;p&gt; {@code Thread} also supports the creation of &lt;i&gt;virtual threads&lt;/i&gt; that
  68  * are scheduled by the Java virtual machine rather than the operating system.
  69  * Virtual threads will typically require few resources and a single Java virtual
  70  * machine may support millions of virtual threads. Virtual threads are suitable
  71  * for executing tasks that spend most of the time blocked, often waiting for
  72  * synchronous blocking I/O operations to complete.
  73  * Virtual threads execute on a pool of &lt;i&gt;carrier threads&lt;/i&gt;, essentially
  74  * a pool of kernel threads that have been created and allocated to support the
  75  * execution of virtual threads. Locking and I/O operations are the &lt;i&gt;scheduling
  76  * points&lt;/i&gt; where a carrier thread is re-scheduled from one virtual thread to
  77  * another. Code executing in virtual threads will usually not be aware of the
  78  * underlying carrier thread, and in particular, the {@linkplain Thread#currentThread()}
  79  * method, to obtain a reference to the &lt;i&gt;current thread&lt;/i&gt;, will return the
  80  * {@code Thread} object for the virtual thread.
  81  *
  82  * &lt;p&gt; {@code Thread} defines factory methods, and a {@linkplain Builder} API,
  83  * for creating kernel or virtual threads. It also defines (for compatibility and
  84  * customization reasons) constructors for creating kernel threads. Newer code
  85  * is encouraged to use the factory methods or the builder rather than the constructors.
  86  *
  87  * &lt;p&gt; Kernel threads are designated &lt;i&gt;daemon&lt;/i&gt; or &lt;i&gt;non-daemon&lt;/i&gt; threads.
  88  * When the Java virtual machine starts up, there is usually one non-daemon
  89  * thread (the thread that typically calls the applications&#39;s {@code main} method).
  90  * The Java virtual machine terminates when all non-daemon threads have terminated.
  91  * The Java virtual machine can also be terminated by invoking the
  92  * {@linkplain Runtime#exit(int)} method, in which case it will terminate even
  93  * if there are many non-daemon threads still running. The daemon status of
  94  * virtual threads is meaningless and have no influence on when the Java virtual
  95  * machine terminates.
  96  *
  97  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a constructor
  98  * or method in this class will cause a {@link NullPointerException} to be
  99  * thrown.
 100  *
 101  * @author  unascribed
 102  * @see     Runtime#exit(int)
 103  * @since   1.0
 104  */
 105 public class Thread implements Runnable {
 106     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 107     private static native void registerNatives();
 108     static {
 109         registerNatives();
 110     }
 111 
 112     /* Reserved for exclusive use by the JVM, TBD: move to FieldHolder */
 113     private long eetop;
 114 
 115     // holds fields for kernel threads
 116     private static class FieldHolder {
 117         final ThreadGroup group;
 118         final Runnable task;
 119         final long stackSize;
 120         int priority;
 121         boolean daemon;
 122         volatile int threadStatus;
 123         boolean stillborn;
 124 
 125         FieldHolder(ThreadGroup group,
 126                     Runnable task,
 127                     long stackSize,
 128                     int priority,
 129                     boolean daemon) {
 130             this.group = group;
 131             this.task = task;
 132             this.stackSize = stackSize;
 133             this.priority = priority;
 134             this.daemon = daemon;
 135         }
 136     }
 137     private final FieldHolder holder;
 138     
 139     // interrupt status (read/written by VM)
 140     volatile boolean interrupted;
 141 
 142     // thread name
 143     private volatile String name;
 144 
 145     // thread id
 146     private final long tid;
 147 
 148     // context ClassLoader
 149     private ClassLoader contextClassLoader;
 150 
 151     // inherited AccessControlContext, TBD: move this to FieldHolder
 152     private AccessControlContext inheritedAccessControlContext;
 153 
 154     /* For autonumbering anonymous threads. */
 155     private static int threadInitNumber;
 156     private static synchronized int nextThreadNum() {
 157         return threadInitNumber++;
 158     }
 159 
 160     /* ThreadLocal values pertaining to this thread. This map is maintained
 161      * by the ThreadLocal class. */
 162     ThreadLocal.ThreadLocalMap threadLocals = null;
 163 
 164     /*
 165      * InheritableThreadLocal values pertaining to this thread. This map is
 166      * maintained by the InheritableThreadLocal class.
 167      */
 168     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 169 
 170     /**
 171      * Helper class to generate unique thread identifiers. The identifiers start
 172      * at 2 as this class cannot be used during early startup to generate the
 173      * identifier for the primordial thread.
 174      */
 175     private static class ThreadIdentifiers {
 176         private static final Unsafe U = Unsafe.getUnsafe();
 177         private static final long nextTidOffset =
 178             U.objectFieldOffset(ThreadIdentifiers.class, &quot;nextTid&quot;);
 179         private static volatile long nextTid = 2;
 180         private static long next() {
 181             return U.getAndAddLong(ThreadIdentifiers.class, nextTidOffset, 1);
 182         }
 183     }
 184 
 185     /*
 186      * Lock object for thread interrupt.
 187      */
 188     final Object interruptLock = new Object();
 189 
 190     /**
 191      * The argument supplied to the current call to
 192      * java.util.concurrent.locks.LockSupport.park.
 193      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 194      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 195      */
 196     private volatile Object parkBlocker;
 197 
 198     /* The object in which this thread is blocked in an interruptible I/O
 199      * operation, if any.  The blocker&#39;s interrupt method should be invoked
 200      * after setting this thread&#39;s interrupt status.
 201      */
 202     volatile Interruptible nioBlocker;
 203 
 204     /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
 205      * from java.nio code
 206      */
 207     static void blockedOn(Interruptible b) {
 208         Thread me = Thread.currentThread();
 209         synchronized (me.interruptLock) {
 210             me.nioBlocker = b;
 211         }
 212     }
 213 
 214     /**
 215      * The minimum priority that a thread can have.
 216      */
 217     public static final int MIN_PRIORITY = 1;
 218 
 219    /**
 220      * The default priority that is assigned to a thread.
 221      */
 222     public static final int NORM_PRIORITY = 5;
 223 
 224     /**
 225      * The maximum priority that a thread can have.
 226      */
 227     public static final int MAX_PRIORITY = 10;
 228 
 229     // current inner-most continuation
 230     private Continuation cont;
 231 
 232     // the virtual thread mounted on this thread
 233     private VirtualThread vthread;
 234 
 235     /**
 236      * Sets the virtual thread that is currently mounted on this thread.
 237      */
 238     void setVirtualThread(VirtualThread vthread) {
 239         // assert this == currentThread0();
 240         this.vthread = vthread;
 241     }
 242 
 243     /**
 244      * Returns the virtual thread that is currently mounted on this thread.
 245      */
 246     VirtualThread getVirtualThread() {
 247         // assert this == currentThread0();
 248         return vthread;
 249     }
 250 
 251     /**
 252      * Returns the Thread object for the current thread.
 253      *
 254      * @return  the current thread
 255      */
 256     public static Thread currentThread() {
 257         Thread t = currentThread0();
 258         VirtualThread vthread = t.vthread;
 259         if (vthread != null) {
 260             return vthread;
 261         } else {
 262             return t;
 263         }
 264     }
 265 
 266     /**
 267      * Returns the current carrier thread.
 268      */
 269     static Thread currentCarrierThread() {
 270         return currentThread0();
 271     }
 272 
 273     // Scoped support:
 274 
 275     /**
 276      * TBD
 277      * @return TBD
 278      */
 279     @HotSpotIntrinsicCandidate
 280     static native Object[] scopedCache();
 281 
 282     @HotSpotIntrinsicCandidate
 283     static native void setScopedCache(Object[] cache);
 284 
 285     // A simple (not very) random string of bits to use when evicting
 286     // cache entries.
 287     int victims
 288         = 0b1100_1001_0000_1111_1101_1010_1010_0010;
 289 
 290     private ScopedMap scopedMap;
 291 
 292     final ScopedMap scopedMap() {
 293         var map = scopedMap;
 294         if (map == null) {
 295             map = scopedMap = new ScopedMap();
 296         }
 297         return map;
 298     }
 299 
 300     // end Scoped support
 301 
 302     /**
 303      * TBD
 304      * @return TBD
 305      */
 306     @HotSpotIntrinsicCandidate
 307     static native Thread currentThread0();
 308 
 309     /**
 310      * A hint to the scheduler that the current thread is willing to yield
 311      * its current use of a processor. The scheduler is free to ignore this
 312      * hint.
 313      *
 314      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 315      * between threads that would otherwise over-utilise a CPU. Its use
 316      * should be combined with detailed profiling and benchmarking to
 317      * ensure that it actually has the desired effect.
 318      *
 319      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 320      * for debugging or testing purposes, where it may help to reproduce
 321      * bugs due to race conditions. It may also be useful when designing
 322      * concurrency control constructs such as the ones in the
 323      * {@link java.util.concurrent.locks} package.
 324      */
 325     public static void yield() {
 326         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 327         if (vthread != null) {
 328             vthread.tryYield();
 329         } else {
 330             yield0();
 331         }
 332     }
 333     private static native void yield0();
 334 
 335     /**
 336      * Causes the currently executing thread to sleep (temporarily cease
 337      * execution) for the specified number of milliseconds, subject to
 338      * the precision and accuracy of system timers and schedulers. The thread
 339      * does not lose ownership of any monitors.
 340      *
 341      * @param  millis
 342      *         the length of time to sleep in milliseconds
 343      *
 344      * @throws  IllegalArgumentException
 345      *          if the value of {@code millis} is negative
 346      *
 347      * @throws  InterruptedException
 348      *          if any thread has interrupted the current thread. The
 349      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 350      *          cleared when this exception is thrown.
 351      */
 352     public static void sleep(long millis) throws InterruptedException {
 353         if (millis &lt; 0) {
 354             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 355         }
 356         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 357         if (vthread != null) {
 358             vthread.sleepNanos(TimeUnit.MILLISECONDS.toNanos(millis));
 359         } else {
 360             sleep0(millis);
 361         }
 362     }
 363     private static native void sleep0(long millis) throws InterruptedException;
 364 
 365     /**
 366      * Causes the currently executing thread to sleep (temporarily cease
 367      * execution) for the specified number of milliseconds plus the specified
 368      * number of nanoseconds, subject to the precision and accuracy of system
 369      * timers and schedulers. The thread does not lose ownership of any
 370      * monitors.
 371      *
 372      * @param  millis
 373      *         the length of time to sleep in milliseconds
 374      *
 375      * @param  nanos
 376      *         {@code 0-999999} additional nanoseconds to sleep
 377      *
 378      * @throws  IllegalArgumentException
 379      *          if the value of {@code millis} is negative, or the value of
 380      *          {@code nanos} is not in the range {@code 0-999999}
 381      *
 382      * @throws  InterruptedException
 383      *          if any thread has interrupted the current thread. The
 384      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 385      *          cleared when this exception is thrown.
 386      */
 387     public static void sleep(long millis, int nanos) throws InterruptedException {
 388         if (millis &lt; 0) {
 389             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 390         }
 391 
 392         if (nanos &lt; 0 || nanos &gt; 999999) {
 393             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
 394         }
 395 
 396         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
 397             millis++;
 398         }
 399 
 400         sleep(millis);
 401     }
 402 
 403     /**
 404      * Causes the currently executing thread to sleep (temporarily cease
 405      * execution) for the specified duration, subject to the precision and
 406      * accuracy of system timers and schedulers. This method is a no-op if
 407      * the duration is less than zero.
 408      *
 409      * @param  duration
 410      *         the duration to sleep
 411      *
 412      * @throws  InterruptedException
 413      *          if the current thread is interrupted while sleeping. The
 414      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 415      *          cleared when this exception is thrown.
 416      *
 417      * @since 99
 418      */
 419     public static void sleep(Duration duration) throws InterruptedException {
 420         if (!duration.isNegative()) {
 421             // ignore nano precision for now
 422             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
 423             sleep(millis);
 424         }
 425     }
 426 
 427     /**
 428      * Indicates that the caller is momentarily unable to progress, until the
 429      * occurrence of one or more actions on the part of other activities. By
 430      * invoking this method within each iteration of a spin-wait loop construct,
 431      * the calling thread indicates to the runtime that it is busy-waiting.
 432      * The runtime may take action to improve the performance of invoking
 433      * spin-wait loop constructions.
 434      *
 435      * @apiNote
 436      * As an example consider a method in a class that spins in a loop until
 437      * some flag is set outside of that method. A call to the {@code onSpinWait}
 438      * method should be placed inside the spin loop.
 439      * &lt;pre&gt;{@code
 440      *     class EventHandler {
 441      *         volatile boolean eventNotificationNotReceived;
 442      *         void waitForEventAndHandleIt() {
 443      *             while ( eventNotificationNotReceived ) {
 444      *                 java.lang.Thread.onSpinWait();
 445      *             }
 446      *             readAndProcessEvent();
 447      *         }
 448      *
 449      *         void readAndProcessEvent() {
 450      *             // Read event from some source and process it
 451      *              . . .
 452      *         }
 453      *     }
 454      * }&lt;/pre&gt;
 455      * &lt;p&gt;
 456      * The code above would remain correct even if the {@code onSpinWait}
 457      * method was not called at all. However on some architectures the Java
 458      * Virtual Machine may issue the processor instructions to address such
 459      * code patterns in a more beneficial way.
 460      *
 461      * @since 9
 462      */
 463     @HotSpotIntrinsicCandidate
 464     public static void onSpinWait() {}
 465 
 466     /**
 467      * Returns the context class loader to inherit from the given parent thread
 468      */
 469     private static ClassLoader contextClassLoader(Thread parent) {
 470         SecurityManager sm = System.getSecurityManager();
 471         if (sm == null || isCCLOverridden(parent.getClass())) {
 472             return parent.getContextClassLoader();
 473         } else {
 474             return parent.contextClassLoader;
 475         }
 476     }
 477 
 478     /**
 479      * Initializes a kernel Thread.
 480      *
 481      * @param g the Thread group
 482      * @param name the name of the new Thread
 483      * @param characteristics thread characteristics
 484      * @param task the object whose run() method gets called
 485 
 486      * @param stackSize the desired stack size for the new thread, or
 487      *        zero to indicate that this parameter is to be ignored.
 488      * @param acc the AccessControlContext to inherit, or
 489      *            AccessController.getContext() if null
 490      * @throws IllegalArgumentException if invalid characteristics are specified
 491      */
 492     private Thread(ThreadGroup g, String name, int characteristics, Runnable task,
 493                    long stackSize, AccessControlContext acc) {
 494         if (name == null) {
 495             throw new NullPointerException(&quot;name cannot be null&quot;);
 496         }
 497         checkCharacteristics(characteristics);
 498 
 499         Thread parent = currentThread();
 500         boolean primordial = (parent == this);
 501 
 502         SecurityManager security = System.getSecurityManager();
 503         if (g == null) {
 504             /* Determine if it&#39;s an applet or not */
 505 
 506             /* If there is a security manager, ask the security manager
 507                what to do. */
 508             if (security != null) {
 509                 g = security.getThreadGroup();
 510             }
 511 
 512             /* If the security manager doesn&#39;t have a strong opinion
 513                on the matter, use the parent thread group. */
 514             if (g == null) {
 515                 g = parent.getThreadGroup();
 516             }
 517         }
 518 
 519         /* checkAccess regardless of whether or not threadgroup is
 520            explicitly passed in. */
 521         g.checkAccess();
 522 
 523         /*
 524          * Do we have the required permissions?
 525          */
 526         if (security != null) {
 527             if (isCCLOverridden(getClass())) {
 528                 security.checkPermission(
 529                         SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
 530             }
 531         }
 532 
 533         g.addUnstarted();
 534 
 535         this.name = name;
 536         this.tid = primordial ? 1 : ThreadIdentifiers.next();
 537         this.contextClassLoader = contextClassLoader(parent);
 538         this.inheritedAccessControlContext = (acc != null) ? acc : AccessController.getContext();
 539 
 540         // thread locals
 541         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 542             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 543             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 544         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 545             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 546             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 547                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 548             }
 549         }
 550 
 551         int priority;
 552         boolean daemon;
 553         if (primordial) {
 554             // primordial or attached thread
 555             priority = NORM_PRIORITY;
 556             daemon = false;
 557         } else {
 558             priority = parent.getPriority();
 559             daemon = parent.isDaemon();
 560         }
 561         this.holder = new FieldHolder(g, task, stackSize, priority, daemon);
 562     }
 563 
 564     /**
 565      * Initializes a virtual Thread.
 566      *
 567      * @param name thread name, can be null
 568      * @param characteristics thread characteristics
 569      * @throws IllegalArgumentException if invalid characteristics are specified
 570      */
 571     Thread(String name, int characteristics) {
 572         checkCharacteristics(characteristics);
 573 
 574         Thread parent = currentThread();
 575 
 576         this.name = (name != null) ? name : &quot;&lt;unnamed&gt;&quot;;
 577         this.tid = ThreadIdentifiers.next();
 578         this.contextClassLoader = contextClassLoader(parent);
 579         this.inheritedAccessControlContext = VirtualThreads.ACCESS_CONTROL_CONTEXT;
 580 
 581         // thread locals
 582         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 583             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 584             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 585         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 586             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 587             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 588                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 589             }
 590         }
 591 
 592         // no additional fields
 593         this.holder = null;
 594     }
 595 
 596     /**
 597      * Returns a builder for creating {@code Thread} or {@code ThreadFactory} objects.
 598      *
 599      * @apiNote The following are examples using the builder:
 600      *
 601      * &lt;pre&gt;{@code
 602      *   // Create a daemon thread that is scheduled by the operating system
 603      *   Thread thread = Thread.builder()
 604      *                 .name(&quot;duke&quot;)
 605      *                 .daemon(true)
 606      *                 .priority(Thread.NORM_PRIORITY)
 607      *                 .inheritThreadLocals()
 608      *                 .task(...)
 609      *                 .build();
 610      *
 611      *   // A ThreadFactory that creates daemon threads named &quot;worker-0&quot;, &quot;worker-1&quot;, ...
 612      *   ThreadFactory factory = Thread.builder().daemon(true).name(&quot;worker-&quot;, 0).factory();
 613      *
 614      *   // Create an unnamed virtual thread
 615      *   Thread thread1 = Thread.builder().virtual().task(...).build();
 616      *
 617      *   // Create a named virtual thread
 618      *   Thread thread2 = Thread.builder().virtual().name(&quot;duke&quot;).task(...).build();
 619      *
 620      *   // Create and start a virtual thread
 621      *   Thread thread = Thread.builder().virtual().task(...).start();
 622      *
 623      *   // A ThreadFactory that creates virtual threads
 624      *   ThreadFactory factory = Thread.builder().virtual().factory();
 625      *
 626      *   // A ThreadFactory that creates virtual threads and uses a custom scheduler
 627      *   Executor scheduler = ...
 628      *   ThreadFactory factory = Thread.builder().virtual(scheduler).factory();
 629      * }&lt;/pre&gt;
 630      *
 631      * @return A builder for creating {@code Thread} or {@code ThreadFactory} objects.
 632      *
 633      * @since 99
 634      */
 635     public static Builder builder() {
 636         return new BuilderImpl();
 637     }
 638 
 639     /**
 640      * A mutable builder for a {@link Thread} or {@link ThreadFactory}.
 641      *
 642      * &lt;p&gt; {@code Builder} defines methods to set the {@code Thread} characteristics
 643      * and features. Once set, a {@code Thread} or {@code ThreadFactory} can be
 644      * created with the following methods:
 645      *
 646      * &lt;ul&gt;
 647      *     &lt;li&gt; The {@linkplain #build() build} method creates an unstarted {@code Thread}.
 648      *     &lt;li&gt; The {@linkplain #start() start} method creates and starts a {@code Thread}.
 649      *     &lt;li&gt; The {@linkplain #factory() factory} method creates a {@code ThreadFactory}.
 650      * &lt;/ul&gt;
 651      *
 652      * &lt;p&gt; A {@code Builder} is not thread safe. The {@code ThreadFactory}
 653      * returned by the builder&#39;s {@code factory() method} is thread safe.
 654      *
 655      * &lt;p&gt; Unless otherwise specified, passing a null argument to a method in
 656      * this interface causes a {@code NullPointerException} to be thrown.
 657      *
 658      * @apiNote {@code Builder} checks invariants as components are added to the builder.
 659      * The rationale for this is to detect errors as early as possible and not defer
 660      * all validation to the {@code build} method.
 661      *
 662      * @see Thread#builder()
 663      * @since 99
 664      */
 665     public interface Builder {
 666 
 667         /**
 668          * Sets the thread group.
 669          *
 670          * &lt;p&gt; The thread group for threads that are scheduled by the Java virtual
 671          * machine threads does not support all features of regular thread groups.
 672          * The thread group can only be set for threads that are scheduled by
 673          * the operating system.
 674          *
 675          * @param group the thread group
 676          * @return this builder
 677          * @throws IllegalStateException if this is a builder for a virtual thread
 678          */
 679         Builder group(ThreadGroup group);
 680 
 681         /**
 682          * Sets the thread name.
 683          * @param name thread name
 684          * @return this builder
 685          */
 686         Builder name(String name);
 687 
 688         /**
 689          * Sets the thread name to be the concatenation of a string prefix and
 690          * a counter value.
 691          * @param prefix thread name prefix
 692          * @param start counter start
 693          * @return this builder
 694          * @throws IllegalArgumentException if count is negative
 695          */
 696         Builder name(String prefix, int start);
 697 
 698         /**
 699          * The thread will be scheduled by the Java virtual machine rather than
 700          * the operating system with the default scheduler.
 701          * @return this builder
 702          * @throws IllegalStateException if a thread group has been set
 703          */
 704         Builder virtual();
 705 
 706         /**
 707          * The thread will be scheduled by the Java virtual machine rather than
 708          * the operating system with the given scheduler.
 709          * @param scheduler the scheduler
 710          * @return this builder
 711          * @throws IllegalStateException if a thread group has been set
 712          */
 713         Builder virtual(Executor scheduler);
 714 
 715         /**
 716          * Disallow threads locals.
 717          * @return this builder
 718          * @throws IllegalStateException if inheritThreadLocals has already been set
 719          */
 720         Builder disallowThreadLocals();
 721 
 722         /**
 723          * Inherit threads locals. Thread locals are inherited when the {@code Thread}
 724          * is created with the {@link #build() build} method or when the thread
 725          * factory {@link ThreadFactory#newThread(Runnable) newThread} method
 726          * is invoked.
 727          * @return this builder
 728          * @throws IllegalStateException if disallowThreadLocals has already been set
 729          */
 730         Builder inheritThreadLocals();
 731 
 732         /**
 733          * Sets the daemon status.
 734          * @param on {@code true} to create daemon threads
 735          * @return this builder
 736          */
 737         Builder daemon(boolean on);
 738 
 739         /**
 740          * Sets the thread priority.
 741          * @param priority priority
 742          * @return this builder
 743          * @throws IllegalArgumentException if the priority is less than
 744          *        {@link Thread#MIN_PRIORITY} or greater than {@link Thread#MAX_PRIORITY}
 745          */
 746         Builder priority(int priority);
 747 
 748         /**
 749          * Sets the uncaught exception handler.
 750          * @param ueh uncaught exception handler
 751          * @return this builder
 752          */
 753         Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);
 754 
 755         /**
 756          * Sets the task for the thread to run.
 757          * @param task the task to run
 758          * @return this builder
 759          */
 760         Builder task(Runnable task);
 761 
 762         /**
 763          * Creates a new unstarted {@code Thread} from the current state of the
 764          * builder.
 765          *
 766          * @return a new unstarted Thread
 767          * @throws IllegalStateException if the task object to run object has not been set
 768          * @throws SecurityException if a thread group has been set and the current thread
 769          *         cannot create a thread in that thread group
 770          */
 771         Thread build();
 772 
 773         /**
 774          * Returns a {@code ThreadFactory} to create threads from the current
 775          * state of the builder. The returned thread factory is safe for use by
 776          * multiple concurrent threads.
 777          *
 778          * @return a thread factory to create threads
 779          */
 780         ThreadFactory factory();
 781 
 782         /**
 783          * Creates a new {@code Thread} from the current state of the builder
 784          * and starts it as if by invoking the {@linkplain Thread#start() start}
 785          * method.
 786          *
 787          * @implSpec The default implementation invokes {@linkplain #build() build}
 788          * to create a {@code Thread} and then invokes its {@linkplain Thread#start()
 789          * start} method to start it.
 790          *
 791          * @return The started thread
 792          * @throws IllegalStateException if the task object to run object has not been set
 793          * @throws SecurityException if a thread group has been set and the current thread
 794          *         cannot create a thread in that thread group
 795          */
 796         default Thread start() {
 797             Thread thread = build();
 798             thread.start();
 799             return thread;
 800         }
 801     }
 802 
 803     private static class BuilderImpl implements Builder {
 804         private ThreadGroup group;
 805         private Executor scheduler;
 806         private String name;
 807         private int counter;
 808         private boolean virtual;
 809         private boolean disallowThreadLocals;
 810         private boolean inheritThreadLocals;
 811         private boolean daemon;
 812         private boolean daemonChanged;
 813         private int priority;
 814         private UncaughtExceptionHandler uhe;
 815         private Runnable task;
 816 
 817         BuilderImpl() { }
 818 
 819         private int characteristics() {
 820             int characteristics = 0;
 821             if (virtual)
 822                 characteristics |= Thread.VIRTUAL;
 823             if (disallowThreadLocals)
 824                 characteristics |= Thread.NO_THREAD_LOCALS;
 825             if (inheritThreadLocals)
 826                 characteristics |= Thread.INHERIT_THREAD_LOCALS;
 827             return characteristics;
 828         }
 829 
 830         @Override
 831         public Builder group(ThreadGroup group) {
 832             Objects.requireNonNull(group);
 833             if (virtual)
 834                 throw new IllegalStateException();
 835             this.group = group;
 836             return this;
 837         }
 838 
 839         @Override
 840         public Builder name(String name) {
 841             this.name = Objects.requireNonNull(name);
 842             this.counter = -1;
 843             return this;
 844         }
 845 
 846         @Override
 847         public Builder name(String prefix, int start) {
 848             Objects.requireNonNull(prefix);
 849             if (start &lt; 0)
 850                 throw new IllegalArgumentException(&quot;&#39;start&#39; is negative&quot;);
 851             this.name = prefix;
 852             this.counter = start;
 853             return this;
 854         }
 855 
 856         @Override
 857         public Builder virtual() {
 858             if (group != null)
 859                 throw new IllegalStateException();
 860             this.virtual = true;
 861             this.scheduler = null;
 862             return this;
 863         }
 864 
 865         @Override
 866         public Builder virtual(Executor scheduler) {
 867             Objects.requireNonNull(scheduler);
 868             if (group != null)
 869                 throw new IllegalStateException();
 870             this.virtual = true;
 871             this.scheduler = scheduler;
 872             return this;
 873         }
 874 
 875         @Override
 876         public Builder disallowThreadLocals() {
 877             if (inheritThreadLocals)
 878                 throw new IllegalStateException();
 879             this.disallowThreadLocals = true;
 880             return this;
 881         }
 882 
 883         @Override
 884         public Builder inheritThreadLocals() {
 885             if (disallowThreadLocals)
 886                 throw new IllegalStateException();
 887             this.inheritThreadLocals = true;
 888             return this;
 889         }
 890 
 891         @Override
 892         public Builder daemon(boolean on) {
 893             daemon = on;
 894             daemonChanged = true;
 895             return this;
 896         }
 897 
 898         @Override
 899         public Builder priority(int priority) {
 900             if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY)
 901                 throw new IllegalArgumentException();
 902             this.priority = priority;
 903             return this;
 904         }
 905 
 906         @Override
 907         public Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
 908             this.uhe = Objects.requireNonNull(ueh);
 909             return this;
 910         }
 911 
 912         @Override
 913         public Thread build() {
 914             Runnable task = this.task;
 915             if (task == null)
 916                 throw new IllegalStateException(&quot;No task specified&quot;);
 917 
 918             int characteristics = characteristics();
 919             Thread thread;
 920             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 921                 String name = this.name;
 922                 if (name != null &amp;&amp; counter &gt;= 0) {
 923                     name = name + (counter++);
 924                 }
 925                 thread = new VirtualThread(scheduler, name, characteristics, task);
 926             } else {
 927                 String name = this.name;
 928                 if (name == null) {
 929                     name = &quot;Thread-&quot; + nextThreadNum();
 930                 } else if (counter &gt;= 0) {
 931                     name = name + (counter++);
 932                 }
 933                 thread = new Thread(group, name, characteristics, task, 0, null);
 934                 if (daemonChanged)
 935                     thread.daemon(daemon);
 936                 if (priority != 0)
 937                     thread.priority(priority);
 938             }
 939             if (uhe != null)
 940                 thread.uncaughtExceptionHandler(uhe);
 941             return thread;
 942         }
 943 
 944         @Override
 945         public Builder task(Runnable task) {
 946             this.task = Objects.requireNonNull(task);
 947             return this;
 948         }
 949 
 950         @Override
 951         public ThreadFactory factory() {
 952             int characteristics = characteristics();
 953             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 954                 return new VirtualThreadFactory(scheduler, name, counter, characteristics, uhe);
 955             } else {
 956                 return new KernelThreadFactory(group, name, counter, characteristics,
 957                                                daemon, priority, uhe);
 958             }
 959         }
 960     }
 961 
 962     private static abstract class CountingThreadFactory implements ThreadFactory {
 963         private static final VarHandle COUNT;
 964         static {
 965             try {
 966                 MethodHandles.Lookup l = MethodHandles.lookup();
 967                 COUNT = l.findVarHandle(CountingThreadFactory.class, &quot;count&quot;, int.class);
 968             } catch (Exception e) {
 969                 throw new InternalError(e);
 970             }
 971         }
 972         private volatile int count;
 973         private final boolean hasCounter;
 974 
 975         CountingThreadFactory(int start) {
 976             if (start &gt;= 0) {
 977                 count = start;
 978                 hasCounter = true;
 979             } else {
 980                 hasCounter = false;
 981             }
 982         }
 983 
 984         boolean hasCounter() {
 985             return hasCounter;
 986         }
 987 
 988         int next() {
 989             return (int) COUNT.getAndAdd(this, 1);
 990         }
 991     }
 992 
 993     private static class VirtualThreadFactory extends CountingThreadFactory {
 994         private final Executor scheduler;
 995         private String name;
 996         private final int characteristics;
 997         private final UncaughtExceptionHandler uhe;
 998 
 999         VirtualThreadFactory(Executor scheduler,
1000                              String name,
1001                              int start,
1002                              int characteristics,
1003                              UncaughtExceptionHandler uhe) {
1004             super(start);
1005             this.scheduler = scheduler;
1006             this.name = name;
1007             this.characteristics = characteristics;
1008             this.uhe = uhe;
1009         }
1010 
1011         @Override
1012         public Thread newThread(Runnable task) {
1013             Objects.requireNonNull(task);
1014             String name = this.name;
1015             if (name != null &amp;&amp; hasCounter()) {
1016                 name += next();
1017             }
1018             Thread thread = new VirtualThread(scheduler, name, characteristics, task);
1019             if (uhe != null)
1020                 thread.uncaughtExceptionHandler(uhe);
1021             return thread;
1022         }
1023     }
1024 
1025     private static class KernelThreadFactory extends CountingThreadFactory {
1026         private final ThreadGroup group;
1027         private final String name;
1028         private final int characteristics;
1029         private final boolean daemon;
1030         private final int priority;
1031         private final UncaughtExceptionHandler uhe;
1032 
1033         KernelThreadFactory(ThreadGroup group,
1034                             String name,
1035                             int start,
1036                             int characteristics,
1037                             boolean daemon,
1038                             int priority,
1039                             UncaughtExceptionHandler uhe) {
1040             super(start);
1041             this.group = group;
1042             this.name = name;
1043             this.characteristics = characteristics;
1044             this.daemon = daemon;
1045             this.priority = priority;
1046             this.uhe = uhe;
1047         }
1048 
1049         @Override
1050         public Thread newThread(Runnable task) {
1051             Objects.requireNonNull(task);
1052             String name = this.name;
1053             if (name == null) {
1054                 name = &quot;Thread-&quot; + nextThreadNum();
1055             } else if (hasCounter()) {
1056                 name += next();
1057             }
1058             Thread thread = new Thread(group, name, characteristics, task, 0, null);
1059             if (daemon)
1060                 thread.daemon(true);
1061             if (priority != 0)
1062                 thread.priority(priority);
1063             if (uhe != null)
1064                 thread.uncaughtExceptionHandler(uhe);
1065             return thread;
1066         }
1067     }
1068 
1069     /**
1070      * Throws CloneNotSupportedException as a Thread can not be meaningfully
1071      * cloned. Construct a new Thread instead.
1072      *
1073      * @throws  CloneNotSupportedException
1074      *          always
1075      */
1076     @Override
1077     protected Object clone() throws CloneNotSupportedException {
1078         throw new CloneNotSupportedException();
1079     }
1080 
1081     /**
1082      * Allocates a new {@code Thread} object. This constructor has the same
1083      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1084      * {@code (null, null, gname)}, where {@code gname} is a newly generated
1085      * name. Automatically generated names are of the form
1086      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1087      */
1088     public Thread() {
1089         this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
1090     }
1091 
1092     /**
1093      * Allocates a new {@code Thread} object. This constructor has the same
1094      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1095      * {@code (null, task, gname)}, where {@code gname} is a newly generated
1096      * name. Automatically generated names are of the form
1097      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1098      *
1099      * @param  task
1100      *         the object whose {@code run} method is invoked when this thread
1101      *         is started. If {@code null}, this classes {@code run} method does
1102      *         nothing.
1103      */
1104     public Thread(Runnable task) {
1105         this(null, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1106     }
1107 
1108     /**
1109      * Creates a new Thread that inherits the given AccessControlContext
1110      * but thread-local variables are not inherited.
1111      * This is not a public constructor.
1112      */
1113     Thread(Runnable task, AccessControlContext acc) {
1114         this(null, &quot;Thread-&quot; + nextThreadNum(), 0, task, 0, acc);
1115     }
1116 
1117     /**
1118      * Allocates a new {@code Thread} object. This constructor has the same
1119      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1120      * {@code (group, task, gname)} ,where {@code gname} is a newly generated
1121      * name. Automatically generated names are of the form
1122      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1123      *
1124      * @param  group
1125      *         the thread group. If {@code null} and there is a security
1126      *         manager, the group is determined by {@linkplain
1127      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1128      *         If there is not a security manager or {@code
1129      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1130      *         is set to the current thread&#39;s thread group.
1131      *
1132      * @param  task
1133      *         the object whose {@code run} method is invoked when this thread
1134      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1135      *
1136      * @throws  SecurityException
1137      *          if the current thread cannot create a thread in the specified
1138      *          thread group
1139      */
1140     public Thread(ThreadGroup group, Runnable task) {
1141         this(group, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1142     }
1143 
1144     /**
1145      * Allocates a new {@code Thread} object. This constructor has the same
1146      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1147      * {@code (null, null, name)}.
1148      *
1149      * @param   name
1150      *          the name of the new thread
1151      */
1152     public Thread(String name) {
1153         this(null, null, name, 0);
1154     }
1155 
1156     /**
1157      * Allocates a new {@code Thread} object. This constructor has the same
1158      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1159      * {@code (group, null, name)}.
1160      *
1161      * @param  group
1162      *         the thread group. If {@code null} and there is a security
1163      *         manager, the group is determined by {@linkplain
1164      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1165      *         If there is not a security manager or {@code
1166      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1167      *         is set to the current thread&#39;s thread group.
1168      *
1169      * @param  name
1170      *         the name of the new thread
1171      *
1172      * @throws  SecurityException
1173      *          if the current thread cannot create a thread in the specified
1174      *          thread group
1175      */
1176     public Thread(ThreadGroup group, String name) {
1177         this(group, null, name, 0);
1178     }
1179 
1180     /**
1181      * Allocates a new {@code Thread} object. This constructor has the same
1182      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1183      * {@code (null, task, name)}.
1184      *
1185      * @param  task
1186      *         the object whose {@code run} method is invoked when this thread
1187      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1188      *
1189      * @param  name
1190      *         the name of the new thread
1191      */
1192     public Thread(Runnable task, String name) {
1193         this(null, task, name, 0);
1194     }
1195 
1196     /**
1197      * Allocates a new {@code Thread} object so that it has {@code task}
1198      * as its run object, has the specified {@code name} as its name,
1199      * and belongs to the thread group referred to by {@code group}.
1200      *
1201      * &lt;p&gt;If there is a security manager, its
1202      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
1203      * method is invoked with the ThreadGroup as its argument.
1204      *
1205      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
1206      * the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}
1207      * permission when invoked directly or indirectly by the constructor
1208      * of a subclass which overrides the {@code getContextClassLoader}
1209      * or {@code setContextClassLoader} methods.
1210      *
1211      * &lt;p&gt;The priority of the newly created thread is set equal to the
1212      * priority of the thread creating it, that is, the currently running
1213      * thread. The method {@linkplain #setPriority setPriority} may be
1214      * used to change the priority to a new value.
1215      *
1216      * &lt;p&gt;The newly created thread is initially marked as being a daemon
1217      * thread if and only if the thread creating it is currently marked
1218      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
1219      * may be used to change whether or not a thread is a daemon.
1220      *
1221      * @param  group
1222      *         the thread group. If {@code null} and there is a security
1223      *         manager, the group is determined by {@linkplain
1224      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1225      *         If there is not a security manager or {@code
1226      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1227      *         is set to the current thread&#39;s thread group.
1228      *
1229      * @param  task
1230      *         the object whose {@code run} method is invoked when this thread
1231      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1232      *
1233      * @param  name
1234      *         the name of the new thread
1235      *
1236      * @throws  SecurityException
1237      *          if the current thread cannot create a thread in the specified
1238      *          thread group or cannot override the context class loader methods.
1239      */
1240     public Thread(ThreadGroup group, Runnable task, String name) {
1241         this(group, task, name, 0);
1242     }
1243 
1244     /**
1245      * Allocates a new {@code Thread} object so that it has {@code task}
1246      * as its run object, has the specified {@code name} as its name,
1247      * and belongs to the thread group referred to by {@code group}, and has
1248      * the specified &lt;i&gt;stack size&lt;/i&gt;.
1249      *
1250      * &lt;p&gt;This constructor is identical to {@link
1251      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
1252      * that it allows the thread stack size to be specified.  The stack size
1253      * is the approximate number of bytes of address space that the virtual
1254      * machine is to allocate for this thread&#39;s stack.  &lt;b&gt;The effect of the
1255      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
1256      *
1257      * &lt;p&gt;On some platforms, specifying a higher value for the
1258      * {@code stackSize} parameter may allow a thread to achieve greater
1259      * recursion depth before throwing a {@link StackOverflowError}.
1260      * Similarly, specifying a lower value may allow a greater number of
1261      * threads to exist concurrently without throwing an {@link
1262      * OutOfMemoryError} (or other internal error).  The details of
1263      * the relationship between the value of the {@code stackSize} parameter
1264      * and the maximum recursion depth and concurrency level are
1265      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
1266      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
1267      *
1268      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
1269      * parameter as a suggestion.  If the specified value is unreasonably low
1270      * for the platform, the virtual machine may instead use some
1271      * platform-specific minimum value; if the specified value is unreasonably
1272      * high, the virtual machine may instead use some platform-specific
1273      * maximum.  Likewise, the virtual machine is free to round the specified
1274      * value up or down as it sees fit (or to ignore it completely).
1275      *
1276      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
1277      * cause this constructor to behave exactly like the
1278      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
1279      *
1280      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
1281      * constructor, extreme care should be exercised in its use.
1282      * The thread stack size necessary to perform a given computation will
1283      * likely vary from one JRE implementation to another.  In light of this
1284      * variation, careful tuning of the stack size parameter may be required,
1285      * and the tuning may need to be repeated for each JRE implementation on
1286      * which an application is to run.&lt;/i&gt;
1287      *
1288      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
1289      * document their implementation&#39;s behavior with respect to the
1290      * {@code stackSize} parameter.
1291      *
1292      *
1293      * @param  group
1294      *         the thread group. If {@code null} and there is a security
1295      *         manager, the group is determined by {@linkplain
1296      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1297      *         If there is not a security manager or {@code
1298      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1299      *         is set to the current thread&#39;s thread group.
1300      *
1301      * @param  task
1302      *         the object whose {@code run} method is invoked when this thread
1303      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1304      *
1305      * @param  name
1306      *         the name of the new thread
1307      *
1308      * @param  stackSize
1309      *         the desired stack size for the new thread, or zero to indicate
1310      *         that this parameter is to be ignored.
1311      *
1312      * @throws  SecurityException
1313      *          if the current thread cannot create a thread in the specified
1314      *          thread group
1315      *
1316      * @since 1.4
1317      */
1318     public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
1319         this(group, name, Thread.INHERIT_THREAD_LOCALS, task, stackSize, null);
1320     }
1321 
1322     /**
1323      * Allocates a new {@code Thread} object so that it has {@code task}
1324      * as its run object, has the specified {@code name} as its name,
1325      * belongs to the thread group referred to by {@code group}, has
1326      * the specified {@code stackSize}, and inherits initial values for
1327      * {@linkplain InheritableThreadLocal inheritable thread-local} variables
1328      * if {@code inheritThreadLocals} is {@code true}.
1329      *
1330      * &lt;p&gt; This constructor is identical to {@link
1331      * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
1332      * suppress, or not, the inheriting of initial values for inheritable
1333      * thread-local variables from the constructing thread. This allows for
1334      * finer grain control over inheritable thread-locals. Care must be taken
1335      * when passing a value of {@code false} for {@code inheritThreadLocals},
1336      * as it may lead to unexpected behavior if the new thread executes code
1337      * that expects a specific thread-local value to be inherited.
1338      *
1339      * &lt;p&gt; Specifying a value of {@code true} for the {@code inheritThreadLocals}
1340      * parameter will cause this constructor to behave exactly like the
1341      * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
1342      *
1343      * @param  group
1344      *         the thread group. If {@code null} and there is a security
1345      *         manager, the group is determined by {@linkplain
1346      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1347      *         If there is not a security manager or {@code
1348      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1349      *         is set to the current thread&#39;s thread group.
1350      *
1351      * @param  task
1352      *         the object whose {@code run} method is invoked when this thread
1353      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1354      *
1355      * @param  name
1356      *         the name of the new thread
1357      *
1358      * @param  stackSize
1359      *         the desired stack size for the new thread, or zero to indicate
1360      *         that this parameter is to be ignored
1361      *
1362      * @param  inheritThreadLocals
1363      *         if {@code true}, inherit initial values for inheritable
1364      *         thread-locals from the constructing thread, otherwise no initial
1365      *         values are inherited
1366      *
1367      * @throws  SecurityException
1368      *          if the current thread cannot create a thread in the specified
1369      *          thread group
1370      *
1371      * @since 9
1372      */
1373     public Thread(ThreadGroup group, Runnable task, String name,
1374                   long stackSize, boolean inheritThreadLocals) {
1375         this(group, name, (inheritThreadLocals ? Thread.INHERIT_THREAD_LOCALS : 0),
1376                 task, stackSize, null);
1377     }
1378 
1379     /**
1380      * Characteristic value signifying that the thread should be scheduled by
1381      * the Java virtual machine rather than the operating system.
1382      *
1383      * @since 99
1384      */
1385     public static final int VIRTUAL = 1 &lt;&lt; 0;
1386 
1387     /**
1388      * Characteristic value signifying that {@link ThreadLocal thread-locals}
1389      * are not supported by the thread.
1390      *
1391      * @apiNote This is for experimental purposes, a lot of existing code will
1392      * not run if thread locals are not supported.
1393      *
1394      * @since 99
1395      */
1396     public static final int NO_THREAD_LOCALS = 1 &lt;&lt; 1;
1397 
1398     /**
1399      * Characteristic value signifying that {@link InheritableThreadLocal
1400      * inheritable-thread-locals} are inherihted from the constructing thread.
1401      * This characteristic is incompatible with {@linkplain #NO_THREAD_LOCALS},
1402      * they may not be used together.
1403      *
1404      * @since 99
1405      */
1406     public static final int INHERIT_THREAD_LOCALS = 1 &lt;&lt; 2;
1407 
1408     private static int validCharacteristics() {
1409         return (VIRTUAL | NO_THREAD_LOCALS | INHERIT_THREAD_LOCALS);
1410     }
1411 
1412     private static void checkCharacteristics(int characteristics) {
1413         if (characteristics != 0) {
1414             if ((characteristics &amp; ~validCharacteristics()) != 0)
1415                 throw new IllegalArgumentException();
1416             if ((characteristics &amp; NO_THREAD_LOCALS) != 0
1417                     &amp;&amp; (characteristics &amp; INHERIT_THREAD_LOCALS) != 0)
1418                 throw new IllegalArgumentException();
1419         }
1420     }
1421 
1422     /**
1423      * Creates an unnamed thread.
1424      *
1425      * By default, the thread is scheduled by the operating system, supports
1426      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1427      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1428      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1429      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1430      * context-class-loader} are inherited from the current thread.
1431      *
1432      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1433      * used to create a thread that is scheduled by the Java virtual machine
1434      * using the default scheduler. The default in this case is to only inherit
1435      * the {@link #getContextClassLoader() context-class-loader} from the current
1436      * thread.
1437      *
1438      * @apiNote The characteristics will probably be replaced by an enum
1439      *
1440      * @param characteristics characteristics of the thread
1441      * @param task the object to run when the thread executes
1442      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1443      *         combination of characteristic is specified
1444      * @return an un-started virtual thread
1445      *
1446      * @since 99
1447      */
1448     public static Thread newThread(int characteristics, Runnable task) {
1449         if ((characteristics &amp; VIRTUAL) != 0) {
1450             return new VirtualThread(null, null, characteristics, task);
1451         } else {
1452             return new Thread(null, &quot;Thread-&quot; + nextThreadNum(), characteristics, task, 0, null);
1453         }
1454     }
1455 
1456     /**
1457      * Creates a named thread.
1458      *
1459      * By default, the thread is scheduled by the operating system, supports
1460      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1461      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1462      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1463      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1464      * context-class-loader} are inherited from the current thread.
1465      *
1466      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1467      * used to create a thread that is scheduled by the Java virtual machine
1468      * using the default scheduler. The default in this case is to only inherit
1469      * the {@link #getContextClassLoader() context-class-loader} from the current
1470      * thread.
1471      *
1472      * @apiNote The characteristics will probably be replaced by an enum
1473      *
1474      * @param name the thread name
1475      * @param characteristics characteristics of the thread
1476      * @param task the object to run when the thread executes
1477      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1478      *         combination of characteristic is specified
1479      * @return an un-started virtual thread
1480      *
1481      * @since 99
1482      */
1483     public static Thread newThread(String name, int characteristics, Runnable task) {
1484         if ((characteristics &amp; VIRTUAL) != 0) {
1485             return new VirtualThread(null, name, characteristics, task);
1486         } else {
1487             return new Thread(null, name, characteristics, task, 0, null);
1488         }
1489     }
1490 
1491     /**
1492      * Returns {@code true} if this thread scheduled by the Java virtual machine
1493      * rather than the operating system.
1494      *
1495      * &lt;p&gt; Threads that are scheduled by the Java virtual machine do not support
1496      * all features of Thread. In particular, the Thread is not an &lt;i&gt;active thread&lt;/i&gt;
1497      * in its thread group and so is not enumerated or acted on by thread group
1498      * operations. In addition it does not support the stop, suspend or resume
1499      * methods.
1500      *
1501      * @return {@code true} if this thread is scheduled by the Java virtual
1502      *         machine rather than the operating system
1503      *
1504      * @since 99
1505      */
1506     public final boolean isVirtual() {
1507         return (this instanceof VirtualThread);
1508     }
1509 
1510     /**
1511      * Schedules this thread to begin execution. The thread will execute
1512      * independently of the current thread.
1513      * &lt;p&gt;
1514      * It is never legal to start a thread more than once.
1515      * In particular, a thread may not be restarted once it has completed
1516      * execution.
1517      *
1518      * @throws     IllegalThreadStateException  if the thread was already started.
1519      * @see        #run()
1520      * @see        Builder#start()
1521      */
1522     public synchronized void start() {
1523         /**
1524          * This method is not invoked for the main method thread or &quot;system&quot;
1525          * group threads created/set up by the VM. Any new functionality added
1526          * to this method in the future may have to also be added to the VM.
1527          *
1528          * A zero status value corresponds to state &quot;NEW&quot;.
1529          */
1530         if (holder.threadStatus != 0)
1531             throw new IllegalThreadStateException();
1532 
1533         /* Notify the group that this thread is about to be started
1534          * so that it can be added to the group&#39;s list of threads
1535          * and the group&#39;s unstarted count can be decremented. */
1536         ThreadGroup group = holder.group;
1537         group.add(this);
1538 
1539         boolean started = false;
1540         try {
1541             start0();
1542             started = true;
1543         } finally {
1544             try {
1545                 if (!started) {
1546                     group.threadStartFailed(this);
1547                 }
1548             } catch (Throwable ignore) {
1549                 /* do nothing. If start0 threw a Throwable then
1550                   it will be passed up the call stack */
1551             }
1552         }
1553     }
1554 
1555     private native void start0();
1556 
1557     /**
1558      * If this thread was constructed using a separate
1559      * {@code Runnable} run object, then that
1560      * {@code Runnable} object&#39;s {@code run} method is called;
1561      * otherwise, this method does nothing and returns.
1562      * This method does nothing when invoked on a {@linkplain #isVirtual()
1563      * virtual} thread.
1564      * &lt;p&gt;
1565      * Subclasses of {@code Thread} should override this method.
1566      *
1567      * @see     #start()
1568      * @see     #Thread(ThreadGroup, Runnable, String)
1569      */
1570     @Override
1571     public void run() {
1572         if (!isVirtual()) {
1573             Runnable task = holder.task;
1574             if (task != null) {
1575                 task.run();
1576             }
1577         }
1578     }
1579 
1580     /**
1581      * This method is called by the system to give a Thread
1582      * a chance to clean up before it actually exits.
1583      */
1584     private void exit() {
1585         // assert !isVirtual();
1586         if (threadLocals != null &amp;&amp; TerminatingThreadLocal.REGISTRY.isPresent()) {
1587             TerminatingThreadLocal.threadTerminated();
1588         }
1589         ThreadGroup group = holder.group;
1590         if (group != null) {
1591             group.threadTerminated(this);
1592         }
1593         /* Aggressively null out all reference fields: see bug 4006245 */
1594         /* Speed the release of some of these resources */
1595         threadLocals = null;
1596         inheritableThreadLocals = null;
1597         inheritedAccessControlContext = null;
1598         nioBlocker = null;
1599         uncaughtExceptionHandler = null;
1600     }
1601 
1602     /**
1603      * Forces the thread to stop executing.
1604      * &lt;p&gt;
1605      * If there is a security manager installed, its {@code checkAccess}
1606      * method is called with {@code this}
1607      * as its argument. This may result in a
1608      * {@code SecurityException} being raised (in the current thread).
1609      * &lt;p&gt;
1610      * If this thread is different from the current thread (that is, the current
1611      * thread is trying to stop a thread other than itself), the
1612      * security manager&#39;s {@code checkPermission} method (with a
1613      * {@code RuntimePermission(&quot;stopThread&quot;)} argument) is called in
1614      * addition.
1615      * Again, this may result in throwing a
1616      * {@code SecurityException} (in the current thread).
1617      * &lt;p&gt;
1618      * The thread represented by this thread is forced to stop whatever
1619      * it is doing abnormally and to throw a newly created
1620      * {@code ThreadDeath} object as an exception.
1621      * &lt;p&gt;
1622      * It is permitted to stop a thread that has not yet been started.
1623      * If the thread is eventually started, it immediately terminates.
1624      * &lt;p&gt;
1625      * An application should not normally try to catch
1626      * {@code ThreadDeath} unless it must do some extraordinary
1627      * cleanup operation (note that the throwing of
1628      * {@code ThreadDeath} causes {@code finally} clauses of
1629      * {@code try} statements to be executed before the thread
1630      * officially terminates).  If a {@code catch} clause catches a
1631      * {@code ThreadDeath} object, it is important to rethrow the
1632      * object so that the thread actually terminates.
1633      * &lt;p&gt;
1634      * The top-level error handler that reacts to otherwise uncaught
1635      * exceptions does not print out a message or otherwise notify the
1636      * application if the uncaught exception is an instance of
1637      * {@code ThreadDeath}.
1638      *
1639      * @throws     SecurityException  if the current thread cannot
1640      *             modify this thread.
1641      * @throws     UnsupportedOperationException if invoked on a virtual thread
1642      * @see        #interrupt()
1643      * @see        #checkAccess()
1644      * @see        #run()
1645      * @see        #start()
1646      * @see        ThreadDeath
1647      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
1648      * @see        SecurityManager#checkAccess(Thread)
1649      * @see        SecurityManager#checkPermission
1650      * @deprecated This method is inherently unsafe.  Stopping a thread with
1651      *       Thread.stop causes it to unlock all of the monitors that it
1652      *       has locked (as a natural consequence of the unchecked
1653      *       {@code ThreadDeath} exception propagating up the stack).  If
1654      *       any of the objects previously protected by these monitors were in
1655      *       an inconsistent state, the damaged objects become visible to
1656      *       other threads, potentially resulting in arbitrary behavior.  Many
1657      *       uses of {@code stop} should be replaced by code that simply
1658      *       modifies some variable to indicate that the task thread should
1659      *       stop running.  The task thread should check this variable
1660      *       regularly, and return from its run method in an orderly fashion
1661      *       if the variable indicates that it is to stop running.  If the
1662      *       task thread waits for long periods (on a condition variable,
1663      *       for example), the {@code interrupt} method should be used to
1664      *       interrupt the wait.
1665      *       For more information, see
1666      *       &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1667      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1668      */
1669     @Deprecated(since=&quot;1.2&quot;)
1670     public final void stop() {
1671         SecurityManager security = System.getSecurityManager();
1672         if (security != null) {
1673             checkAccess();
1674             if (this != Thread.currentThread()) {
1675                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
1676             }
1677         }
1678 
1679         if (isVirtual())
1680             throw new UnsupportedOperationException();
1681 
1682         // A zero status value corresponds to &quot;NEW&quot;, it can&#39;t change to
1683         // not-NEW because we hold the lock.
1684         if (holder.threadStatus != 0) {
1685             resume(); // Wake up thread if it was suspended; no-op otherwise
1686         }
1687 
1688         // The VM can handle all thread states
1689         stop0(new ThreadDeath());
1690     }
1691 
1692     /**
1693      * Interrupts this thread.
1694      *
1695      * &lt;p&gt; Unless the current thread is interrupting itself, which is
1696      * always permitted, the {@link #checkAccess() checkAccess} method
1697      * of this thread is invoked, which may cause a {@link
1698      * SecurityException} to be thrown.
1699      *
1700      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
1701      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
1702      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
1703      * class, or of the {@link #join()}, {@link #join(long)}, {@link
1704      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
1705      * methods of this class, then its interrupt status will be cleared and it
1706      * will receive an {@link InterruptedException}.
1707      *
1708      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
1709      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
1710      * then the channel will be closed, the thread&#39;s interrupt
1711      * status will be set, and the thread will receive a {@link
1712      * java.nio.channels.ClosedByInterruptException}.
1713      *
1714      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
1715      * then the thread&#39;s interrupt status will be set and it will return
1716      * immediately from the selection operation, possibly with a non-zero
1717      * value, just as if the selector&#39;s {@link
1718      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
1719      *
1720      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
1721      * status will be set. &lt;/p&gt;
1722      *
1723      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
1724      *
1725      * @implNote In the JDK Reference Implementation, interruption of a thread
1726      * that is not alive still records that the interrupt request was made and
1727      * will report it via {@link #interrupted} and {@link #isInterrupted()}.
1728      *
1729      * @throws  SecurityException
1730      *          if the current thread cannot modify this thread
1731      *
1732      * @revised 6.0, 14
1733      * @spec JSR-51
1734      */
1735     public void interrupt() {
1736         if (this != Thread.currentThread()) {
1737             checkAccess();
1738 
1739             // thread may be blocked in an I/O operation
1740             synchronized (interruptLock) {
1741                 Interruptible b = nioBlocker;
1742                 if (b != null) {
1743                     interrupted = true;
1744                     interrupt0();  // inform VM of interrupt
1745                     b.interrupt(this);
1746                     return;
1747                 }
1748             }
1749         }
1750         interrupted = true;
1751         interrupt0();  // inform VM of interrupt
1752     }
1753 
1754     /**
1755      * Tests whether the current thread has been interrupted.  The
1756      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1757      * other words, if this method were to be called twice in succession, the
1758      * second call would return false (unless the current thread were
1759      * interrupted again, after the first call had cleared its interrupted
1760      * status and before the second call had examined it).
1761      *
1762      * @return  {@code true} if the current thread has been interrupted;
1763      *          {@code false} otherwise.
1764      * @see #isInterrupted()
1765      * @revised 6.0, 14
1766      */
1767     public static boolean interrupted() {
1768         return currentThread().getAndClearInterrupt();
1769     }
1770 
1771     /**
1772      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1773      * status&lt;/i&gt; of the thread is unaffected by this method.
1774      *
1775      * @return  {@code true} if this thread has been interrupted;
1776      *          {@code false} otherwise.
1777      * @see     #interrupted()
1778      * @revised 6.0, 14
1779      */
1780     public boolean isInterrupted() {
1781         return interrupted;
1782     }
1783 
1784     final void setInterrupt() {
1785         interrupted = true;
1786         interrupt0();  // inform VM of interrupt
1787     }
1788 
1789     final void clearInterrupt() {
1790         interrupted = false;
1791         clearInterruptEvent();
1792     }
1793 
1794     boolean getAndClearInterrupt() {
1795         boolean oldValue = interrupted;
1796         // We may have been interrupted the moment after we read the field,
1797         // so only clear the field if we saw that it was set and will return
1798         // true; otherwise we could lose an interrupt.
1799         if (oldValue) {
1800             interrupted = false;
1801             clearInterruptEvent();
1802         }
1803         return oldValue;
1804     }
1805 
1806     /**
1807      * Tests if this thread is alive. A thread is alive if it has
1808      * been started and has not yet terminated.
1809      *
1810      * @return  {@code true} if this thread is alive;
1811      *          {@code false} otherwise.
1812      */
1813     public final boolean isAlive() {
1814         if (isVirtual()) {
1815             State state = getState();
1816             return (state != State.NEW &amp;&amp; state != State.TERMINATED);
1817         } else {
1818             return isAlive0();
1819         }
1820     }
1821     private native boolean isAlive0();
1822 
1823     /**
1824      * Suspends this thread.
1825      * &lt;p&gt;
1826      * First, the {@code checkAccess} method of this thread is called
1827      * with no arguments. This may result in throwing a
1828      * {@code SecurityException }(in the current thread).
1829      * &lt;p&gt;
1830      * If the thread is alive, it is suspended and makes no further
1831      * progress unless and until it is resumed.
1832      *
1833      * @throws     SecurityException  if the current thread cannot modify
1834      *             this thread.
1835      * @throws     UnsupportedOperationException if invoked on a virtual thread
1836      * @see #checkAccess
1837      * @deprecated   This method has been deprecated, as it is
1838      *   inherently deadlock-prone.  If the task thread holds a lock on the
1839      *   monitor protecting a critical system resource when it is suspended, no
1840      *   thread can access this resource until the task thread is resumed. If
1841      *   the thread that would resume the task thread attempts to lock this
1842      *   monitor prior to calling {@code resume}, deadlock results.  Such
1843      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1844      *   For more information, see
1845      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1846      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1847      */
1848     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1849     public final void suspend() {
1850         checkAccess();
1851         if (isVirtual())
1852             throw new UnsupportedOperationException();
1853         suspend0();
1854     }
1855 
1856     void suspendThread() {
1857         suspend0();
1858     }
1859 
1860     /**
1861      * Resumes a suspended thread.
1862      * &lt;p&gt;
1863      * First, the {@code checkAccess} method of this thread is called
1864      * with no arguments. This may result in throwing a
1865      * {@code SecurityException} (in the current thread).
1866      * &lt;p&gt;
1867      * If the thread is alive but suspended, it is resumed and is
1868      * permitted to make progress in its execution.
1869      *
1870      * @throws     SecurityException  if the current thread cannot modify this
1871      *             thread.
1872      * @throws     UnsupportedOperationException if invoked on a virtual thread
1873      * @see        #checkAccess
1874      * @see        #suspend()
1875      * @deprecated This method exists solely for use with {@link #suspend},
1876      *     which has been deprecated because it is deadlock-prone.
1877      *     For more information, see
1878      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1879      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1880      */
1881     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1882     public final void resume() {
1883         checkAccess();
1884         if (isVirtual())
1885             throw new UnsupportedOperationException();
1886         resume0();
1887     }
1888 
1889     void resumeThread() {
1890         resume0();
1891     }
1892 
1893     /**
1894      * Changes the priority of this thread.
1895      * &lt;p&gt;
1896      * First the {@code checkAccess} method of this thread is called
1897      * with no arguments. This may result in throwing a {@code SecurityException}.
1898      * &lt;p&gt;
1899      * The priority of virtual-threads is always {@linkplain Thread#NORM_PRIORITY}
1900      * and is not changed by this method.
1901      * Otherwise, the priority of this thread is set to the smaller of
1902      * the specified {@code newPriority} and the maximum permitted
1903      * priority of the thread&#39;s thread group.
1904      *
1905      * @param newPriority priority to set this thread to
1906      * @throws     IllegalArgumentException  If the priority is not in the
1907      *               range {@code MIN_PRIORITY} to
1908      *               {@code MAX_PRIORITY}.
1909      * @throws     SecurityException  if the current thread cannot modify
1910      *               this thread.
1911      * @see        #getPriority
1912      * @see        #checkAccess()
1913      * @see        #getThreadGroup()
1914      * @see        #MAX_PRIORITY
1915      * @see        #MIN_PRIORITY
1916      * @see        ThreadGroup#getMaxPriority()
1917      */
1918     public final void setPriority(int newPriority) {
1919         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1920             throw new IllegalArgumentException();
1921         }
1922         checkAccess();
1923         priority(newPriority);
1924     }
1925 
1926     void priority(int newPriority) {
1927         ThreadGroup g;
1928         if (!isVirtual() &amp;&amp; (g = getThreadGroup()) != null) {
1929             if (newPriority &gt; g.getMaxPriority()) {
1930                 newPriority = g.getMaxPriority();
1931             }
1932             setPriority0(holder.priority = newPriority);
1933         }
1934     }
1935 
1936     /**
1937      * Returns this thread&#39;s priority.
1938      * The priority of a virtual thread is always {@linkplain Thread#NORM_PRIORITY}.
1939      *
1940      * @return  this thread&#39;s priority.
1941      * @see     #setPriority
1942      */
1943     public final int getPriority() {
1944         if (isVirtual()) {
1945             return Thread.NORM_PRIORITY;
1946         } else {
1947             return holder.priority;
1948         }
1949     }
1950 
1951     /**
1952      * Changes the name of this thread to be equal to the argument {@code name}.
1953      * &lt;p&gt;
1954      * First the {@code checkAccess} method of this thread is called
1955      * with no arguments. This may result in throwing a
1956      * {@code SecurityException}.
1957      *
1958      * @param      name   the new name for this thread.
1959      * @throws     SecurityException  if the current thread cannot modify this
1960      *             thread.
1961      * @see        #getName
1962      * @see        #checkAccess()
1963      */
1964     public final synchronized void setName(String name) {
1965         checkAccess();
1966         if (name == null) {
1967             throw new NullPointerException(&quot;name cannot be null&quot;);
1968         }
1969 
1970         this.name = name;
1971         if (!isVirtual() &amp;&amp; holder.threadStatus != 0) {
1972             setNativeName(name);
1973         }
1974     }
1975 
1976     /**
1977      * Returns this thread&#39;s name.
1978      *
1979      * @return  this thread&#39;s name.
1980      * @see     #setName(String)
1981      */
1982     public final String getName() {
1983         return name;
1984     }
1985 
1986     /**
1987      * Returns the thread group to which this thread belongs.
1988      * This method returns null if the thread has terminated.
1989      *
1990      * &lt;p&gt; The thread group for virtual threads does not support all features
1991      * of regular thread groups. Virtual threads are not considered &lt;i&gt;active
1992      * threads&lt;/i&gt; in the thread group and so are not enumerated or acted on by
1993      * thread group operations.
1994      *
1995      * @return  this thread&#39;s thread group.
1996      */
1997     public final ThreadGroup getThreadGroup() {
1998         if (getState() == State.TERMINATED) {
1999             return null;
2000         } else {
2001             return isVirtual() ? VirtualThreads.THREAD_GROUP : holder.group;
2002         }
2003     }
2004 
2005     /**
2006      * Returns an estimate of the number of active threads in the current
2007      * thread&#39;s {@linkplain java.lang.ThreadGroup thread group} and its
2008      * subgroups. Recursively iterates over all subgroups in the current
2009      * thread&#39;s thread group.
2010      *
2011      * &lt;p&gt; The value returned is only an estimate because the number of
2012      * threads may change dynamically while this method traverses internal
2013      * data structures, and might be affected by the presence of certain
2014      * system threads. This method is intended primarily for debugging
2015      * and monitoring purposes.
2016      *
2017      * @return  an estimate of the number of active threads in the current
2018      *          thread&#39;s thread group and in any other thread group that
2019      *          has the current thread&#39;s thread group as an ancestor
2020      */
2021     public static int activeCount() {
2022         return currentThread().getThreadGroup().activeCount();
2023     }
2024 
2025     /**
2026      * Copies into the specified array every active thread in the current
2027      * thread&#39;s thread group and its subgroups. This method simply
2028      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
2029      * method of the current thread&#39;s thread group.
2030      *
2031      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
2032      * method to get an estimate of how big the array should be, however
2033      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
2034      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
2035      * thread in the current thread&#39;s thread group and its subgroups, the
2036      * invoker should verify that the returned int value is strictly less
2037      * than the length of {@code tarray}.
2038      *
2039      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
2040      * that the method only be used for debugging and monitoring purposes.
2041      *
2042      * @param  tarray
2043      *         an array into which to put the list of threads
2044      *
2045      * @return  the number of threads put into the array
2046      *
2047      * @throws  SecurityException
2048      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
2049      *          the current thread cannot access its thread group
2050      */
2051     public static int enumerate(Thread tarray[]) {
2052         return currentThread().getThreadGroup().enumerate(tarray);
2053     }
2054 
2055     /**
2056      * Throws {@code UnsupportedOperationException}.
2057      *
2058      * @return     nothing
2059      *
2060      * @deprecated This method was originally designed to count the number of
2061      *             stack frames but the results were never well-defined and it
2062      *             depended on thread-suspension.
2063      *             This method is subject to removal in a future version of Java SE.
2064      * @see        StackWalker
2065      */
2066     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
2067     public int countStackFrames() {
2068         throw new UnsupportedOperationException();
2069     }
2070 
2071     /**
2072      * Waits at most {@code millis} milliseconds for this thread to terminate.
2073      * A timeout of {@code 0} means to wait forever.
2074      * This method returns immediately, without waiting, if the thread has not
2075      * been {@link #start() started}.
2076      *
2077      * &lt;p&gt; For non-{@linkplain #isVirtual() virtual}, this
2078      * implementation uses a loop of {@code this.wait} calls
2079      * conditioned on {@code this.isAlive}. As a thread terminates the
2080      * {@code this.notifyAll} method is invoked. It is recommended that
2081      * applications not use {@code wait}, {@code notify}, or
2082      * {@code notifyAll} on {@code Thread} instances.
2083      *
2084      * @param  millis
2085      *         the time to wait in milliseconds
2086      *
2087      * @throws  IllegalArgumentException
2088      *          if the value of {@code millis} is negative
2089      *
2090      * @throws  InterruptedException
2091      *          if any thread has interrupted the current thread. The
2092      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2093      *          cleared when this exception is thrown.
2094      */
2095     public final void join(long millis) throws InterruptedException {
2096         if (millis &lt; 0)
2097             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2098 
2099         if (isVirtual()) {
2100             if (isAlive()) {
2101                 long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
2102                 ((VirtualThread) this).joinNanos(nanos);
2103             }
2104             return;
2105         }
2106 
2107         synchronized (this) {
2108             if (millis &gt; 0) {
2109                 if (isAlive()) {
2110                     final long startTime = System.nanoTime();
2111                     long delay = millis;
2112                     do {
2113                         wait(delay);
2114                     } while (isAlive() &amp;&amp; (delay = millis -
2115                             TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; 0);
2116                 }
2117             } else if (millis == 0) {
2118                 while (isAlive()) {
2119                     wait(0);
2120                 }
2121             }
2122         }
2123     }
2124 
2125     /**
2126      * Waits at most {@code millis} milliseconds plus
2127      * {@code nanos} nanoseconds for this thread to terminate.
2128      * If both arguments are {@code 0}, it means to wait forever.
2129      * This method returns immediately, without waiting, if the thread has not
2130      * been {@link #start() started}.
2131      *
2132      * &lt;p&gt; For non-{@link #isVirtual() virtual}, this
2133      * implementation uses a loop of {@code this.wait} calls
2134      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
2135      * conditioned on {@code this.isAlive}. As a thread terminates the
2136      * {@code this.notifyAll} method is invoked. It is recommended that
2137      * applications not use {@code wait}, {@code notify}, or
2138      * {@code notifyAll} on {@code Thread} instances.
2139      *
2140      * @param  millis
2141      *         the time to wait in milliseconds
2142      *
2143      * @param  nanos
2144      *         {@code 0-999999} additional nanoseconds to wait
2145      *
2146      * @throws  IllegalArgumentException
2147      *          if the value of {@code millis} is negative, or the value
2148      *          of {@code nanos} is not in the range {@code 0-999999}
2149      *
2150      * @throws  InterruptedException
2151      *          if any thread has interrupted the current thread. The
2152      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2153      *          cleared when this exception is thrown.
2154      */
2155     public final void join(long millis, int nanos) throws InterruptedException {
2156         if (millis &lt; 0) {
2157             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2158         }
2159 
2160         if (nanos &lt; 0 || nanos &gt; 999999) {
2161             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
2162         }
2163 
2164         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
2165             millis++;
2166         }
2167 
2168         join(millis);
2169     }
2170 
2171     /**
2172      * Waits for this thread to terminate.
2173      *
2174      * &lt;p&gt; An invocation of this method behaves in exactly the same
2175      * way as the invocation
2176      *
2177      * &lt;blockquote&gt;
2178      * {@linkplain #join(long) join}{@code (0)}
2179      * &lt;/blockquote&gt;
2180      *
2181      * @throws  InterruptedException
2182      *          if any thread has interrupted the current thread. The
2183      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2184      *          cleared when this exception is thrown.
2185      */
2186     public final void join() throws InterruptedException {
2187         join(0);
2188     }
2189 
2190     /**
2191      * Waits for this thread to terminate for up to the given waiting duration.
2192      * This method does not wait if the duration to wait is less than or equal
2193      * to zero.
2194      *
2195      * @param   duration
2196      *          the maximum duration to wait
2197      *
2198      * @return  {@code true} if the thread has terminated
2199      *
2200      * @throws  InterruptedException
2201      *          if the current thread is interrupted while waiting.
2202      *          The &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is cleared
2203      *          when this exception is thrown.
2204      *
2205      * @throws  IllegalThreadStateException
2206      *          if this thread has not been started.
2207      *
2208      * @since 99
2209      */
2210     public final boolean join(Duration duration) throws InterruptedException {
2211         Objects.requireNonNull(duration);
2212 
2213         Thread.State state = getState();
2214         if (state == State.TERMINATED)
2215             return true;
2216         if (state == State.NEW)
2217             throw new IllegalThreadStateException(&quot;Thread not started&quot;);
2218         if (duration.isZero() || duration.isNegative())
2219             return false;
2220 
2221         if (isVirtual()) {
2222             long nanos = TimeUnit.NANOSECONDS.convert(duration);
2223             return ((VirtualThread) this).joinNanos(nanos);
2224         } else {
2225             // ignore nano precision for now
2226             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
2227             join(millis);
2228             return getState() == State.TERMINATED;
2229         }
2230     }
2231 
2232     /**
2233      * Prints a stack trace of the current thread to the standard error stream.
2234      * This method is useful for debugging.
2235      */
2236     public static void dumpStack() {
2237         new Exception(&quot;Stack trace&quot;).printStackTrace();
2238     }
2239 
2240     /**
2241      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
2242      * or a user thread.
2243      * The daemon status of a virtual thread is meaningless and is not
2244      * changed by this method (the {@linkplain #isDaemon() isDaemon} method
2245      * always returns {@code true}).
2246      * The Java Virtual Machine exits when the only threads running are all
2247      * daemon threads.
2248      *
2249      * &lt;p&gt; This method must be invoked before the thread is started.
2250      *
2251      * @param  on
2252      *         if {@code true}, marks this thread as a daemon thread
2253      *
2254      * @throws  IllegalThreadStateException
2255      *          if this thread is {@linkplain #isAlive alive}
2256      *
2257      * @throws  SecurityException
2258      *          if {@link #checkAccess} determines that the current
2259      *          thread cannot modify this thread
2260      */
2261     public final void setDaemon(boolean on) {
2262         checkAccess();
2263         if (isAlive())
2264             throw new IllegalThreadStateException();
2265         daemon(on);
2266     }
2267 
2268     void daemon(boolean on) {
2269         if (!isVirtual())
2270             holder.daemon = on;
2271     }
2272 
2273     /**
2274      * Tests if this thread is a daemon thread.
2275      * The daemon status of a virtual thread is meaningless, this method
2276      * returns {@code true} if this is a virtual thread.
2277      *
2278      * @return  {@code true} if this thread is a daemon thread;
2279      *          {@code false} otherwise.
2280      * @see     #setDaemon(boolean)
2281      */
2282     public final boolean isDaemon() {
2283         if (isVirtual()) {
2284             return true;
2285         } else {
2286             return holder.daemon;
2287         }
2288     }
2289 
2290     /**
2291      * Determines if the currently running thread has permission to
2292      * modify this thread.
2293      * &lt;p&gt;
2294      * If there is a security manager, its {@code checkAccess} method
2295      * is called with this thread as its argument. This may result in
2296      * throwing a {@code SecurityException}.
2297      *
2298      * @throws  SecurityException  if the current thread is not allowed to
2299      *          access this thread.
2300      * @see        SecurityManager#checkAccess(Thread)
2301      */
2302     public final void checkAccess() {
2303         SecurityManager security = System.getSecurityManager();
2304         if (security != null) {
2305             security.checkAccess(this);
2306         }
2307     }
2308 
2309     /**
2310      * Returns a string representation of this thread. The string representation
2311      * will usually include the thread&#39;s name. The default implementation
2312      * includes the thread&#39;s name, priority, and the name of the thread group.
2313      *
2314      * @return  a string representation of this thread.
2315      */
2316     public String toString() {
2317         ThreadGroup group = getThreadGroup();
2318         if (group != null) {
2319             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2320                            group.getName() + &quot;]&quot;;
2321         } else {
2322             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2323                             &quot;&quot; + &quot;]&quot;;
2324         }
2325     }
2326 
2327     /**
2328      * Returns the context {@code ClassLoader} for this thread. The context
2329      * {@code ClassLoader} is provided by the creator of the thread for use
2330      * by code running in this thread when loading classes and resources.
2331      * If not {@linkplain #setContextClassLoader set}, the default is the
2332      * {@code ClassLoader} context of the parent thread. The context
2333      * {@code ClassLoader} of the
2334      * primordial thread is typically set to the class loader used to load the
2335      * application.
2336      *
2337      *
2338      * @return  the context {@code ClassLoader} for this thread, or {@code null}
2339      *          indicating the system class loader (or, failing that, the
2340      *          bootstrap class loader)
2341      *
2342      * @throws  SecurityException
2343      *          if a security manager is present, and the caller&#39;s class loader
2344      *          is not {@code null} and is not the same as or an ancestor of the
2345      *          context class loader, and the caller does not have the
2346      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
2347      *
2348      * @since 1.2
2349      */
2350     @CallerSensitive
2351     public ClassLoader getContextClassLoader() {
2352         if (contextClassLoader == null)
2353             return null;
2354         SecurityManager sm = System.getSecurityManager();
2355         if (sm != null) {
2356             ClassLoader.checkClassLoaderPermission(contextClassLoader,
2357                                                    Reflection.getCallerClass());
2358         }
2359         return contextClassLoader;
2360     }
2361 
2362     /**
2363      * TBD
2364      */
2365     Continuation getContinuation() {
2366         return cont;
2367     }
2368 
2369     /**
2370      * TBD
2371      */
2372     void setContinuation(Continuation cont) {
2373         this.cont = cont;
2374     }
2375 
2376     /**
2377      * Sets the context ClassLoader for this Thread. The context
2378      * ClassLoader can be set when a thread is created, and allows
2379      * the creator of the thread to provide the appropriate class loader,
2380      * through {@code getContextClassLoader}, to code running in the thread
2381      * when loading classes and resources.
2382      *
2383      * &lt;p&gt;If a security manager is present, its {@link
2384      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
2385      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
2386      * (&quot;setContextClassLoader&quot;)} permission to see if setting the context
2387      * ClassLoader is permitted.
2388      *
2389      * @param  cl
2390      *         the context ClassLoader for this Thread, or null  indicating the
2391      *         system class loader (or, failing that, the bootstrap class loader)
2392      *
2393      * @throws  SecurityException
2394      *          if the current thread cannot set the context ClassLoader
2395      *
2396      * @since 1.2
2397      */
2398     public void setContextClassLoader(ClassLoader cl) {
2399         SecurityManager sm = System.getSecurityManager();
2400         if (sm != null) {
2401             sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
2402         }
2403         contextClassLoader = cl;
2404     }
2405 
2406     /**
2407      * Returns {@code true} if and only if the current thread holds the
2408      * monitor lock on the specified object.
2409      *
2410      * &lt;p&gt;This method is designed to allow a program to assert that
2411      * the current thread already holds a specified lock:
2412      * &lt;pre&gt;
2413      *     assert Thread.holdsLock(obj);
2414      * &lt;/pre&gt;
2415      *
2416      * @param  obj the object on which to test lock ownership
2417      * @throws NullPointerException if obj is {@code null}
2418      * @return {@code true} if the current thread holds the monitor lock on
2419      *         the specified object.
2420      * @since 1.4
2421      */
2422     public static native boolean holdsLock(Object obj);
2423 
2424     private static final StackTraceElement[] EMPTY_STACK_TRACE
2425         = new StackTraceElement[0];
2426 
2427     /**
2428      * Returns an array of stack trace elements representing the stack dump
2429      * of this thread.  This method will return a zero-length array if
2430      * this thread has not started, has started but has not yet been
2431      * scheduled to run by the system, or has terminated.
2432      * If the returned array is of non-zero length then the first element of
2433      * the array represents the top of the stack, which is the most recent
2434      * method invocation in the sequence.  The last element of the array
2435      * represents the bottom of the stack, which is the least recent method
2436      * invocation in the sequence.
2437      *
2438      * &lt;p&gt;If there is a security manager, and this thread is not
2439      * the current thread, then the security manager&#39;s
2440      * {@code checkPermission} method is called with a
2441      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission
2442      * to see if it&#39;s ok to get the stack trace.
2443      *
2444      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
2445      * or more stack frames from the stack trace.  In the extreme case,
2446      * a virtual machine that has no stack trace information concerning
2447      * this thread is permitted to return a zero-length array from this
2448      * method.
2449      *
2450      * @return an array of {@code StackTraceElement},
2451      * each represents one stack frame.
2452      *
2453      * @throws SecurityException
2454      *        if a security manager exists and its
2455      *        {@code checkPermission} method doesn&#39;t allow
2456      *        getting the stack trace of thread.
2457      * @see SecurityManager#checkPermission
2458      * @see RuntimePermission
2459      * @see Throwable#getStackTrace
2460      *
2461      * @since 1.5
2462      */
2463     public StackTraceElement[] getStackTrace() {
2464         if (this != Thread.currentThread()) {
2465             // check for getStackTrace permission
2466             SecurityManager security = System.getSecurityManager();
2467             if (security != null) {
2468                 security.checkPermission(
2469                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
2470             }
2471             // optimization so we do not call into the vm for threads that
2472             // have not yet started or have terminated
2473             if (!isAlive()) {
2474                 return EMPTY_STACK_TRACE;
2475             }
2476             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
2477             StackTraceElement[] stackTrace = stackTraceArray[0];
2478             // a thread that was alive during the previous isAlive call may have
2479             // since terminated, therefore not having a stacktrace.
2480             if (stackTrace == null) {
2481                 stackTrace = EMPTY_STACK_TRACE;
2482             }
2483             return stackTrace;
2484         } else {
2485             return (new Exception()).getStackTrace();
2486         }
2487     }
2488 
2489     /**
2490      * Returns a map of stack traces for all live threads. The map does not
2491      * include virtual threads.
2492      * The map keys are threads and each map value is an array of
2493      * {@code StackTraceElement} that represents the stack dump
2494      * of the corresponding {@code Thread}.
2495      * The returned stack traces are in the format specified for
2496      * the {@link #getStackTrace getStackTrace} method.
2497      *
2498      * &lt;p&gt;The threads may be executing while this method is called.
2499      * The stack trace of each thread only represents a snapshot and
2500      * each stack trace may be obtained at different time.  A zero-length
2501      * array will be returned in the map value if the virtual machine has
2502      * no stack trace information about a thread.
2503      *
2504      * &lt;p&gt;If there is a security manager, then the security manager&#39;s
2505      * {@code checkPermission} method is called with a
2506      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission as well as
2507      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission
2508      * to see if it is ok to get the stack trace of all threads.
2509      *
2510      * @return a {@code Map} from {@code Thread} to an array of
2511      * {@code StackTraceElement} that represents the stack trace of
2512      * the corresponding thread.
2513      *
2514      * @throws SecurityException
2515      *        if a security manager exists and its
2516      *        {@code checkPermission} method doesn&#39;t allow
2517      *        getting the stack trace of thread.
2518      * @see #getStackTrace
2519      * @see SecurityManager#checkPermission
2520      * @see RuntimePermission
2521      * @see Throwable#getStackTrace
2522      *
2523      * @since 1.5
2524      */
2525     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
2526         // check for getStackTrace permission
2527         SecurityManager security = System.getSecurityManager();
2528         if (security != null) {
2529             security.checkPermission(
2530                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
2531             security.checkPermission(
2532                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
2533         }
2534 
2535         // Get a snapshot of the list of all threads
2536         Thread[] threads = getThreads();
2537         StackTraceElement[][] traces = dumpThreads(threads);
2538         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
2539         for (int i = 0; i &lt; threads.length; i++) {
2540             StackTraceElement[] stackTrace = traces[i];
2541             if (stackTrace != null) {
2542                 m.put(threads[i], stackTrace);
2543             }
2544             // else terminated so we don&#39;t put it in the map
2545         }
2546         return m;
2547     }
2548 
2549     /** cache of subclass security audit results */
2550     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
2551      * release */
2552     private static class Caches {
2553         /** cache of subclass security audit results */
2554         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
2555             new ConcurrentHashMap&lt;&gt;();
2556 
2557         /** queue for WeakReferences to audited subclasses */
2558         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
2559             new ReferenceQueue&lt;&gt;();
2560     }
2561 
2562     /**
2563      * Verifies that this (possibly subclass) instance can be constructed
2564      * without violating security constraints: the subclass must not override
2565      * security-sensitive non-final methods, or else the
2566      * &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.
2567      */
2568     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
2569         if (cl == Thread.class)
2570             return false;
2571 
2572         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
2573         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
2574         Boolean result = Caches.subclassAudits.get(key);
2575         if (result == null) {
2576             result = Boolean.valueOf(auditSubclass(cl));
2577             Caches.subclassAudits.putIfAbsent(key, result);
2578         }
2579 
2580         return result.booleanValue();
2581     }
2582 
2583     /**
2584      * Performs reflective checks on given subclass to verify that it doesn&#39;t
2585      * override security-sensitive non-final methods.  Returns true if the
2586      * subclass overrides any of the methods, false otherwise.
2587      */
2588     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
2589         Boolean result = AccessController.doPrivileged(
2590             new PrivilegedAction&lt;&gt;() {
2591                 public Boolean run() {
2592                     for (Class&lt;?&gt; cl = subcl;
2593                          cl != Thread.class;
2594                          cl = cl.getSuperclass())
2595                     {
2596                         try {
2597                             cl.getDeclaredMethod(&quot;getContextClassLoader&quot;, new Class&lt;?&gt;[0]);
2598                             return Boolean.TRUE;
2599                         } catch (NoSuchMethodException ex) {
2600                         }
2601                         try {
2602                             Class&lt;?&gt;[] params = {ClassLoader.class};
2603                             cl.getDeclaredMethod(&quot;setContextClassLoader&quot;, params);
2604                             return Boolean.TRUE;
2605                         } catch (NoSuchMethodException ex) {
2606                         }
2607                     }
2608                     return Boolean.FALSE;
2609                 }
2610             }
2611         );
2612         return result.booleanValue();
2613     }
2614 
2615     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
2616     private static native Thread[] getThreads();
2617 
2618     /**
2619      * Returns the identifier of this Thread.  The thread ID is a positive
2620      * {@code long} number generated when this thread was created.
2621      * The thread ID is unique and remains unchanged during its lifetime.
2622      * When a thread is terminated, this thread ID may be reused.
2623      *
2624      * @return this thread&#39;s ID.
2625      * @since 1.5
2626      */
2627     public long getId() {
2628         return tid;
2629     }
2630 
2631     /**
2632      * A thread state.  A thread can be in one of the following states:
2633      * &lt;ul&gt;
2634      * &lt;li&gt;{@link #NEW}&lt;br&gt;
2635      *     A thread that has not yet started is in this state.
2636      *     &lt;/li&gt;
2637      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
2638      *     A thread executing in the Java virtual machine is in this state.
2639      *     &lt;/li&gt;
2640      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
2641      *     A thread that is blocked waiting for a monitor lock
2642      *     is in this state.
2643      *     &lt;/li&gt;
2644      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
2645      *     A thread that is waiting indefinitely for another thread to
2646      *     perform a particular action is in this state.
2647      *     &lt;/li&gt;
2648      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
2649      *     A thread that is waiting for another thread to perform an action
2650      *     for up to a specified waiting time is in this state.
2651      *     &lt;/li&gt;
2652      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
2653      *     A thread that has exited is in this state.
2654      *     &lt;/li&gt;
2655      * &lt;/ul&gt;
2656      *
2657      * &lt;p&gt;
2658      * A thread can be in only one state at a given point in time.
2659      * These states are virtual machine states which do not reflect
2660      * any operating system thread states.
2661      *
2662      * @since   1.5
2663      * @see #getState
2664      */
2665     public enum State {
2666         /**
2667          * Thread state for a thread which has not yet started.
2668          */
2669         NEW,
2670 
2671         /**
2672          * Thread state for a runnable thread.  A thread in the runnable
2673          * state is executing in the Java virtual machine but it may
2674          * be waiting for other resources from the operating system
2675          * such as processor.
2676          */
2677         RUNNABLE,
2678 
2679         /**
2680          * Thread state for a thread blocked waiting for a monitor lock.
2681          * A thread in the blocked state is waiting for a monitor lock
2682          * to enter a synchronized block/method or
2683          * reenter a synchronized block/method after calling
2684          * {@link Object#wait() Object.wait}.
2685          */
2686         BLOCKED,
2687 
2688         /**
2689          * Thread state for a waiting thread.
2690          * A thread is in the waiting state due to calling one of the
2691          * following methods:
2692          * &lt;ul&gt;
2693          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
2694          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
2695          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
2696          * &lt;/ul&gt;
2697          *
2698          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
2699          * perform a particular action.
2700          *
2701          * For example, a thread that has called {@code Object.wait()}
2702          * on an object is waiting for another thread to call
2703          * {@code Object.notify()} or {@code Object.notifyAll()} on
2704          * that object. A thread that has called {@code Thread.join()}
2705          * is waiting for a specified thread to terminate.
2706          */
2707         WAITING,
2708 
2709         /**
2710          * Thread state for a waiting thread with a specified waiting time.
2711          * A thread is in the timed waiting state due to calling one of
2712          * the following methods with a specified positive waiting time:
2713          * &lt;ul&gt;
2714          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
2715          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
2716          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
2717          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
2718          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
2719          * &lt;/ul&gt;
2720          */
2721         TIMED_WAITING,
2722 
2723         /**
2724          * Thread state for a terminated thread.
2725          * The thread has completed execution.
2726          */
2727         TERMINATED;
2728     }
2729 
2730     /**
2731      * Returns the state of this thread.
2732      * This method is designed for use in monitoring of the system state,
2733      * not for synchronization control.
2734      *
2735      * @return this thread&#39;s state.
2736      * @since 1.5
2737      */
2738     public State getState() {
2739         return threadState();
2740     }
2741 
2742     /**
2743      * Returns the state of this thread.
2744      *
2745      * @apiNote For VirtualThread use as getState may be overridden and run
2746      * arbitrary code.
2747      */
2748     State threadState() {
2749         return jdk.internal.misc.VM.toThreadState(holder.threadStatus);
2750     }
2751 
2752     // Added in JSR-166
2753 
2754     /**
2755      * Interface for handlers invoked when a {@code Thread} abruptly
2756      * terminates due to an uncaught exception.
2757      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
2758      * the Java Virtual Machine will query the thread for its
2759      * {@code UncaughtExceptionHandler} using
2760      * {@link #getUncaughtExceptionHandler} and will invoke the handler&#39;s
2761      * {@code uncaughtException} method, passing the thread and the
2762      * exception as arguments.
2763      * If a thread has not had its {@code UncaughtExceptionHandler}
2764      * explicitly set, then its {@code ThreadGroup} object acts as its
2765      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
2766      * has no
2767      * special requirements for dealing with the exception, it can forward
2768      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
2769      * default uncaught exception handler}.
2770      *
2771      * @see #setDefaultUncaughtExceptionHandler
2772      * @see #setUncaughtExceptionHandler
2773      * @see ThreadGroup#uncaughtException
2774      * @since 1.5
2775      */
2776     @FunctionalInterface
2777     public interface UncaughtExceptionHandler {
2778         /**
2779          * Method invoked when the given thread terminates due to the
2780          * given uncaught exception.
2781          * &lt;p&gt;Any exception thrown by this method will be ignored by the
2782          * Java Virtual Machine.
2783          * @param t the thread
2784          * @param e the exception
2785          */
2786         void uncaughtException(Thread t, Throwable e);
2787     }
2788 
2789     // null unless explicitly set
2790     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
2791 
2792     // null unless explicitly set
2793     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
2794 
2795     /**
2796      * Set the default handler invoked when a thread abruptly terminates
2797      * due to an uncaught exception, and no other handler has been defined
2798      * for that thread.
2799      *
2800      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
2801      * by the thread&#39;s {@link ThreadGroup} object and finally by the default
2802      * uncaught exception handler. If the thread does not have an explicit
2803      * uncaught exception handler set, and the thread&#39;s thread group
2804      * (including parent thread groups)  does not specialize its
2805      * {@code uncaughtException} method, then the default handler&#39;s
2806      * {@code uncaughtException} method will be invoked.
2807      * &lt;p&gt;By setting the default uncaught exception handler, an application
2808      * can change the way in which uncaught exceptions are handled (such as
2809      * logging to a specific device, or file) for those threads that would
2810      * already accept whatever &amp;quot;default&amp;quot; behavior the system
2811      * provided.
2812      *
2813      * &lt;p&gt;Note that the default uncaught exception handler should not usually
2814      * defer to the thread&#39;s {@code ThreadGroup} object, as that could cause
2815      * infinite recursion.
2816      *
2817      * @param eh the object to use as the default uncaught exception handler.
2818      * If {@code null} then there is no default handler.
2819      *
2820      * @throws SecurityException if a security manager is present and it denies
2821      *         {@link RuntimePermission}{@code (&quot;setDefaultUncaughtExceptionHandler&quot;)}
2822      *
2823      * @see #setUncaughtExceptionHandler
2824      * @see #getUncaughtExceptionHandler
2825      * @see ThreadGroup#uncaughtException
2826      * @since 1.5
2827      */
2828     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2829         SecurityManager sm = System.getSecurityManager();
2830         if (sm != null) {
2831             sm.checkPermission(
2832                 new RuntimePermission(&quot;setDefaultUncaughtExceptionHandler&quot;)
2833                     );
2834         }
2835 
2836          defaultUncaughtExceptionHandler = eh;
2837      }
2838 
2839     /**
2840      * Returns the default handler invoked when a thread abruptly terminates
2841      * due to an uncaught exception. If the returned value is {@code null},
2842      * there is no default.
2843      * @since 1.5
2844      * @see #setDefaultUncaughtExceptionHandler
2845      * @return the default uncaught exception handler for all threads
2846      */
2847     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
2848         return defaultUncaughtExceptionHandler;
2849     }
2850 
2851     /**
2852      * Returns the handler invoked when this thread abruptly terminates
2853      * due to an uncaught exception. If this thread has not had an
2854      * uncaught exception handler explicitly set then this thread&#39;s
2855      * {@code ThreadGroup} object is returned, unless this thread
2856      * has terminated, in which case {@code null} is returned.
2857      * @since 1.5
2858      * @return the uncaught exception handler for this thread
2859      */
2860     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
2861         return uncaughtExceptionHandler != null ?
2862             uncaughtExceptionHandler : getThreadGroup();
2863     }
2864 
2865     /**
2866      * Set the handler invoked when this thread abruptly terminates
2867      * due to an uncaught exception.
2868      * &lt;p&gt;A thread can take full control of how it responds to uncaught
2869      * exceptions by having its uncaught exception handler explicitly set.
2870      * If no such handler is set then the thread&#39;s {@code ThreadGroup}
2871      * object acts as its handler.
2872      * @param eh the object to use as this thread&#39;s uncaught exception
2873      * handler. If {@code null} then this thread has no explicit handler.
2874      * @throws  SecurityException  if the current thread is not allowed to
2875      *          modify this thread.
2876      * @see #setDefaultUncaughtExceptionHandler
2877      * @see ThreadGroup#uncaughtException
2878      * @since 1.5
2879      */
2880     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2881         checkAccess();
2882         uncaughtExceptionHandler(eh);
2883     }
2884 
2885     private void uncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2886         uncaughtExceptionHandler = eh;
2887     }
2888 
2889     /**
2890      * Dispatch an uncaught exception to the handler. This method is
2891      * called when a thread terminates with an exception.
2892      */
2893     void dispatchUncaughtException(Throwable e) {
2894         getUncaughtExceptionHandler().uncaughtException(this, e);
2895     }
2896 
2897     /**
2898      * Removes from the specified map any keys that have been enqueued
2899      * on the specified reference queue.
2900      */
2901     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2902                              ConcurrentMap&lt;? extends
2903                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2904     {
2905         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2906         while((ref = queue.poll()) != null) {
2907             map.remove(ref);
2908         }
2909     }
2910 
2911     /**
2912      *  Weak key for Class objects.
2913      **/
2914     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2915         /**
2916          * saved value of the referent&#39;s identity hash code, to maintain
2917          * a consistent hash code after the referent has been cleared
2918          */
2919         private final int hash;
2920 
2921         /**
2922          * Create a new WeakClassKey to the given object, registered
2923          * with a queue.
2924          */
2925         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2926             super(cl, refQueue);
2927             hash = System.identityHashCode(cl);
2928         }
2929 
2930         /**
2931          * Returns the identity hash code of the original referent.
2932          */
2933         @Override
2934         public int hashCode() {
2935             return hash;
2936         }
2937 
2938         /**
2939          * Returns true if the given object is this identical
2940          * WeakClassKey instance, or, if this object&#39;s referent has not
2941          * been cleared, if the given object is another WeakClassKey
2942          * instance with the identical non-null referent as this one.
2943          */
2944         @Override
2945         public boolean equals(Object obj) {
2946             if (obj == this)
2947                 return true;
2948 
2949             if (obj instanceof WeakClassKey) {
2950                 Object referent = get();
2951                 return (referent != null) &amp;&amp;
2952                        (referent == ((WeakClassKey) obj).get());
2953             } else {
2954                 return false;
2955             }
2956         }
2957     }
2958 
2959     private static class VirtualThreads {
2960         static final ThreadGroup THREAD_GROUP = threadGroup();
2961         static final AccessControlContext ACCESS_CONTROL_CONTEXT = accessControlContext();
2962 
2963         /**
2964          * The thread group for virtual threads.
2965          */
2966         private static ThreadGroup threadGroup() {
2967             return AccessController.doPrivileged(new PrivilegedAction&lt;ThreadGroup&gt;() {
2968                 public ThreadGroup run() {
2969                     ThreadGroup group = Thread.currentCarrierThread().getThreadGroup();
2970                     for (ThreadGroup p; (p = group.getParent()) != null; )
2971                         group = p;
2972                     var newGroup = new ThreadGroup(group, &quot;VirtualThreads&quot;, true);
2973                     newGroup.setDaemon(true);
2974                     return newGroup;
2975                 }});
2976         }
2977 
2978         /**
2979          * Return an AccessControlContext that doesn&#39;t support any permissions.
2980          */
2981         private static AccessControlContext accessControlContext() {
2982             return new AccessControlContext(new ProtectionDomain[] {
2983                 new ProtectionDomain(null, null)
2984             });
2985         }
2986     }
2987 
2988     // The following three initially uninitialized fields are exclusively
2989     // managed by class java.util.concurrent.ThreadLocalRandom. These
2990     // fields are used to build the high-performance PRNGs in the
2991     // concurrent code. Upcoming changes in the concurrent code avoid
2992     // needing to use @Contented here.
2993 
2994     /** The current seed for a ThreadLocalRandom */
2995     long threadLocalRandomSeed;
2996 
2997     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2998     int threadLocalRandomProbe;
2999 
3000     /** Secondary seed isolated from public ThreadLocalRandom sequence */
3001     int threadLocalRandomSecondarySeed;
3002 
3003     /**
3004      * TBD
3005      */
3006     public Object userObject;
3007 
3008     /* Some private helper methods */
3009     private native void setPriority0(int newPriority);
3010     private native void stop0(Object o);
3011     private native void suspend0();
3012     private native void resume0();
3013     private native void interrupt0();
3014     private static native void clearInterruptEvent();
3015     private native void setNativeName(String name);
3016 }
    </pre>
  </body>
</html>