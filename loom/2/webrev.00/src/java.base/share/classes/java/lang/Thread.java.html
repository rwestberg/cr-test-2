<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.invoke.VarHandle;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.WeakReference;
  33 import java.security.AccessController;
  34 import java.security.AccessControlContext;
  35 import java.security.PrivilegedAction;
  36 import java.security.ProtectionDomain;
  37 import java.time.Duration;
  38 import java.util.Map;
  39 import java.util.HashMap;
  40 import java.util.Objects;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.concurrent.Executor;
  44 import java.util.concurrent.ThreadFactory;
  45 import java.util.concurrent.TimeUnit;
  46 import java.util.concurrent.locks.LockSupport;
  47 
  48 import jdk.internal.misc.TerminatingThreadLocal;
  49 import jdk.internal.misc.Unsafe;
  50 import sun.nio.ch.Interruptible;
  51 import jdk.internal.reflect.CallerSensitive;
  52 import jdk.internal.reflect.Reflection;
  53 import sun.security.util.SecurityConstants;
  54 import jdk.internal.HotSpotIntrinsicCandidate;
  55 
  56 /**
  57  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  58  * virtual machine allows an application to have multiple threads of
  59  * execution running concurrently.
  60  *
  61  * &lt;p&gt; {@code Thread} supports the creation of threads that are scheduled by the
  62  * operating system. These threads are sometimes known as &lt;i&gt;kernel threads&lt;/i&gt;
  63  * or &lt;i&gt;heavyweight threads&lt;/i&gt; and will usually have a large stack and other
  64  * resources that are maintained by the operating system. Kernel threads are
  65  * suitable for executing all tasks but they are a limited resource.
  66  *
  67  * &lt;p&gt; {@code Thread} also supports the creation of &lt;i&gt;virtual threads&lt;/i&gt; that
  68  * are scheduled by the Java virtual machine rather than the operating system.
  69  * Virtual threads will typically require few resources and a single Java virtual
  70  * machine may support millions of virtual threads. Virtual threads are suitable
  71  * for executing tasks that spend most of the time blocked, often waiting for
  72  * synchronous blocking I/O operations to complete.
  73  * Virtual threads execute on a pool of &lt;i&gt;carrier threads&lt;/i&gt;, essentially
  74  * a pool of kernel threads that have been created and allocated to support the
  75  * execution of virtual threads. Locking and I/O operations are the &lt;i&gt;scheduling
  76  * points&lt;/i&gt; where a carrier thread is re-scheduled from one virtual thread to
  77  * another. Code executing in virtual threads will usually not be aware of the
  78  * underlying carrier thread, and in particular, the {@linkplain Thread#currentThread()}
  79  * method, to obtain a reference to the &lt;i&gt;current thread&lt;/i&gt;, will return the
  80  * {@code Thread} object for the virtual thread.
  81  *
  82  * &lt;p&gt; {@code Thread} defines factory methods, and a {@linkplain Builder} API,
  83  * for creating kernel or virtual threads. It also defines (for compatibility and
  84  * customization reasons) constructors for creating kernel threads. Newer code
  85  * is encouraged to use the factory methods or the builder rather than the constructors.
  86  *
  87  * &lt;p&gt; Kernel threads are designated &lt;i&gt;daemon&lt;/i&gt; or &lt;i&gt;non-daemon&lt;/i&gt; threads.
  88  * When the Java virtual machine starts up, there is usually one non-daemon
  89  * thread (the thread that typically calls the applications&#39;s {@code main} method).
  90  * The Java virtual machine terminates when all non-daemon threads have terminated.
  91  * The Java virtual machine can also be terminated by invoking the
  92  * {@linkplain Runtime#exit(int)} method, in which case it will terminate even
  93  * if there are many non-daemon threads still running. The daemon status of
  94  * virtual threads is meaningless and have no influence on when the Java virtual
  95  * machine terminates.
  96  *
  97  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a constructor
  98  * or method in this class will cause a {@link NullPointerException} to be
  99  * thrown.
 100  *
 101  * @author  unascribed
 102  * @see     Runtime#exit(int)
 103  * @since   1.0
 104  */
 105 public class Thread implements Runnable {
 106     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 107     private static native void registerNatives();
 108     static {
 109         registerNatives();
 110     }
 111 
 112     /* Reserved for exclusive use by the JVM, TBD: move to FieldHolder */
 113     private long eetop;
 114 
 115     // holds fields for kernel threads
 116     private static class FieldHolder {
 117         final ThreadGroup group;
 118         final Runnable task;
 119         final long stackSize;
 120         int priority;
 121         boolean daemon;
 122         volatile int threadStatus;
 123         boolean stillborn;
 124 
 125         FieldHolder(ThreadGroup group,
 126                     Runnable task,
 127                     long stackSize,
 128                     int priority,
 129                     boolean daemon) {
 130             this.group = group;
 131             this.task = task;
 132             this.stackSize = stackSize;
 133             this.priority = priority;
 134             this.daemon = daemon;
 135         }
 136     }
 137     private final FieldHolder holder;
 138     
 139     // interrupt status (read/written by VM)
 140     volatile boolean interrupted;
 141 
 142     // thread name
 143     private volatile String name;
 144 
 145     // thread id
 146     private final long tid;
 147 
 148     // context ClassLoader
 149     private ClassLoader contextClassLoader;
 150 
 151     // inherited AccessControlContext, TBD: move this to FieldHolder
 152     private AccessControlContext inheritedAccessControlContext;
 153 
 154     private Thread parent;
 155 
 156     /**
 157      * @return The parent thread;
 158      */
 159     Thread getParent() {
 160         return parent;
 161     }
 162 
 163     /**
 164      * @param t
 165      * Set the parent thread;
 166      */
 167     void setParent(Thread t) {
 168         parent = t;
 169     }
 170 
 171     /* For autonumbering anonymous threads. */
 172     private static int threadInitNumber;
 173     private static synchronized int nextThreadNum() {
 174         return threadInitNumber++;
 175     }
 176 
 177     /* ThreadLocal values pertaining to this thread. This map is maintained
 178      * by the ThreadLocal class. */
 179     ThreadLocal.ThreadLocalMap threadLocals = null;
 180 
 181     /*
 182      * InheritableThreadLocal values pertaining to this thread. This map is
 183      * maintained by the InheritableThreadLocal class.
 184      */
 185     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 186 
 187     /**
 188      * Helper class to generate unique thread identifiers. The identifiers start
 189      * at 2 as this class cannot be used during early startup to generate the
 190      * identifier for the primordial thread.
 191      */
 192     private static class ThreadIdentifiers {
 193         private static final Unsafe U = Unsafe.getUnsafe();
 194         private static final long nextTidOffset =
 195             U.objectFieldOffset(ThreadIdentifiers.class, &quot;nextTid&quot;);
 196         private static volatile long nextTid = 2;
 197         private static long next() {
 198             return U.getAndAddLong(ThreadIdentifiers.class, nextTidOffset, 1);
 199         }
 200     }
 201 
 202     /*
 203      * Lock object for thread interrupt.
 204      */
 205     final Object interruptLock = new Object();
 206 
 207     /**
 208      * The argument supplied to the current call to
 209      * java.util.concurrent.locks.LockSupport.park.
 210      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 211      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 212      */
 213     private volatile Object parkBlocker;
 214 
 215     /* The object in which this thread is blocked in an interruptible I/O
 216      * operation, if any.  The blocker&#39;s interrupt method should be invoked
 217      * after setting this thread&#39;s interrupt status.
 218      */
 219     volatile Interruptible nioBlocker;
 220 
 221     /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
 222      * from java.nio code
 223      */
 224     static void blockedOn(Interruptible b) {
 225         Thread me = Thread.currentThread();
 226         synchronized (me.interruptLock) {
 227             me.nioBlocker = b;
 228         }
 229     }
 230 
 231     /**
 232      * The minimum priority that a thread can have.
 233      */
 234     public static final int MIN_PRIORITY = 1;
 235 
 236    /**
 237      * The default priority that is assigned to a thread.
 238      */
 239     public static final int NORM_PRIORITY = 5;
 240 
 241     /**
 242      * The maximum priority that a thread can have.
 243      */
 244     public static final int MAX_PRIORITY = 10;
 245 
 246     // current inner-most continuation
 247     private Continuation cont;
 248 
 249     // the virtual thread mounted on this thread
 250     private VirtualThread vthread;
 251 
 252     /**
 253      * Sets the virtual thread that is currently mounted on this thread.
 254      */
 255     void setVirtualThread(VirtualThread vthread) {
 256         // assert this == currentThread0();
 257         this.vthread = vthread;
 258     }
 259 
 260     /**
 261      * Returns the virtual thread that is currently mounted on this thread.
 262      */
 263     VirtualThread getVirtualThread() {
 264         // assert this == currentThread0();
 265         return vthread;
 266     }
 267 
 268     /**
 269      * Returns the Thread object for the current thread.
 270      *
 271      * @return  the current thread
 272      */
 273     public static Thread currentThread() {
 274         Thread t = currentThread0();
 275         VirtualThread vthread = t.vthread;
 276         if (vthread != null) {
 277             return vthread;
 278         } else {
 279             return t;
 280         }
 281     }
 282 
 283     /**
 284      * Returns the current carrier thread.
 285      */
 286     static Thread currentCarrierThread() {
 287         return currentThread0();
 288     }
 289 
 290     // Scoped support:
 291 
 292     /**
 293      * TBD
 294      * @return TBD
 295      */
 296     @HotSpotIntrinsicCandidate
 297     static native Object[] scopedCache();
 298 
 299     @HotSpotIntrinsicCandidate
 300     static native void setScopedCache(Object[] cache);
 301 
 302     // A simple (not very) random string of bits to use when evicting
 303     // cache entries.
 304     int victims
 305         = 0b1100_1001_0000_1111_1101_1010_1010_0010;
 306 
 307     private ScopedMap scopedMap;
 308 
 309     final ScopedMap scopedMap() {
 310         var map = scopedMap;
 311         if (map == null) {
 312             map = scopedMap = new ScopedMap();
 313         }
 314         return map;
 315     }
 316 
 317     // end Scoped support
 318 
 319     /**
 320      * TBD
 321      * @return TBD
 322      */
 323     @HotSpotIntrinsicCandidate
 324     private static native Thread currentThread0();
 325 
 326     /**
 327      * A hint to the scheduler that the current thread is willing to yield
 328      * its current use of a processor. The scheduler is free to ignore this
 329      * hint.
 330      *
 331      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 332      * between threads that would otherwise over-utilise a CPU. Its use
 333      * should be combined with detailed profiling and benchmarking to
 334      * ensure that it actually has the desired effect.
 335      *
 336      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 337      * for debugging or testing purposes, where it may help to reproduce
 338      * bugs due to race conditions. It may also be useful when designing
 339      * concurrency control constructs such as the ones in the
 340      * {@link java.util.concurrent.locks} package.
 341      */
 342     public static void yield() {
 343         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 344         if (vthread != null) {
 345             vthread.tryYield();
 346         } else {
 347             yield0();
 348         }
 349     }
 350     private static native void yield0();
 351 
 352     /**
 353      * Causes the currently executing thread to sleep (temporarily cease
 354      * execution) for the specified number of milliseconds, subject to
 355      * the precision and accuracy of system timers and schedulers. The thread
 356      * does not lose ownership of any monitors.
 357      *
 358      * @param  millis
 359      *         the length of time to sleep in milliseconds
 360      *
 361      * @throws  IllegalArgumentException
 362      *          if the value of {@code millis} is negative
 363      *
 364      * @throws  InterruptedException
 365      *          if any thread has interrupted the current thread. The
 366      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 367      *          cleared when this exception is thrown.
 368      */
 369     public static void sleep(long millis) throws InterruptedException {
 370         if (millis &lt; 0) {
 371             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 372         }
 373         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 374         if (vthread != null) {
 375             vthread.sleepNanos(TimeUnit.MILLISECONDS.toNanos(millis));
 376         } else {
 377             sleep0(millis);
 378         }
 379     }
 380     private static native void sleep0(long millis) throws InterruptedException;
 381 
 382     /**
 383      * Causes the currently executing thread to sleep (temporarily cease
 384      * execution) for the specified number of milliseconds plus the specified
 385      * number of nanoseconds, subject to the precision and accuracy of system
 386      * timers and schedulers. The thread does not lose ownership of any
 387      * monitors.
 388      *
 389      * @param  millis
 390      *         the length of time to sleep in milliseconds
 391      *
 392      * @param  nanos
 393      *         {@code 0-999999} additional nanoseconds to sleep
 394      *
 395      * @throws  IllegalArgumentException
 396      *          if the value of {@code millis} is negative, or the value of
 397      *          {@code nanos} is not in the range {@code 0-999999}
 398      *
 399      * @throws  InterruptedException
 400      *          if any thread has interrupted the current thread. The
 401      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 402      *          cleared when this exception is thrown.
 403      */
 404     public static void sleep(long millis, int nanos) throws InterruptedException {
 405         if (millis &lt; 0) {
 406             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 407         }
 408 
 409         if (nanos &lt; 0 || nanos &gt; 999999) {
 410             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
 411         }
 412 
 413         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
 414             millis++;
 415         }
 416 
 417         sleep(millis);
 418     }
 419 
 420     /**
 421      * Causes the currently executing thread to sleep (temporarily cease
 422      * execution) for the specified duration, subject to the precision and
 423      * accuracy of system timers and schedulers. This method is a no-op if
 424      * the duration is less than zero.
 425      *
 426      * @param  duration
 427      *         the duration to sleep
 428      *
 429      * @throws  InterruptedException
 430      *          if the current thread is interrupted while sleeping. The
 431      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 432      *          cleared when this exception is thrown.
 433      *
 434      * @since 99
 435      */
 436     public static void sleep(Duration duration) throws InterruptedException {
 437         if (!duration.isNegative()) {
 438             // ignore nano precision for now
 439             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
 440             sleep(millis);
 441         }
 442     }
 443 
 444     /**
 445      * Indicates that the caller is momentarily unable to progress, until the
 446      * occurrence of one or more actions on the part of other activities. By
 447      * invoking this method within each iteration of a spin-wait loop construct,
 448      * the calling thread indicates to the runtime that it is busy-waiting.
 449      * The runtime may take action to improve the performance of invoking
 450      * spin-wait loop constructions.
 451      *
 452      * @apiNote
 453      * As an example consider a method in a class that spins in a loop until
 454      * some flag is set outside of that method. A call to the {@code onSpinWait}
 455      * method should be placed inside the spin loop.
 456      * &lt;pre&gt;{@code
 457      *     class EventHandler {
 458      *         volatile boolean eventNotificationNotReceived;
 459      *         void waitForEventAndHandleIt() {
 460      *             while ( eventNotificationNotReceived ) {
 461      *                 java.lang.Thread.onSpinWait();
 462      *             }
 463      *             readAndProcessEvent();
 464      *         }
 465      *
 466      *         void readAndProcessEvent() {
 467      *             // Read event from some source and process it
 468      *              . . .
 469      *         }
 470      *     }
 471      * }&lt;/pre&gt;
 472      * &lt;p&gt;
 473      * The code above would remain correct even if the {@code onSpinWait}
 474      * method was not called at all. However on some architectures the Java
 475      * Virtual Machine may issue the processor instructions to address such
 476      * code patterns in a more beneficial way.
 477      *
 478      * @since 9
 479      */
 480     @HotSpotIntrinsicCandidate
 481     public static void onSpinWait() {}
 482 
 483     /**
 484      * Returns the context class loader to inherit from the given parent thread
 485      */
 486     private static ClassLoader contextClassLoader(Thread parent) {
 487         SecurityManager sm = System.getSecurityManager();
 488         if (sm == null || isCCLOverridden(parent.getClass())) {
 489             return parent.getContextClassLoader();
 490         } else {
 491             return parent.contextClassLoader;
 492         }
 493     }
 494 
 495     /**
 496      * Initializes a kernel Thread.
 497      *
 498      * @param g the Thread group
 499      * @param name the name of the new Thread
 500      * @param characteristics thread characteristics
 501      * @param task the object whose run() method gets called
 502 
 503      * @param stackSize the desired stack size for the new thread, or
 504      *        zero to indicate that this parameter is to be ignored.
 505      * @param acc the AccessControlContext to inherit, or
 506      *            AccessController.getContext() if null
 507      * @throws IllegalArgumentException if invalid characteristics are specified
 508      */
 509     private Thread(ThreadGroup g, String name, int characteristics, Runnable task,
 510                    long stackSize, AccessControlContext acc) {
 511         if (name == null) {
 512             throw new NullPointerException(&quot;name cannot be null&quot;);
 513         }
 514         checkCharacteristics(characteristics);
 515 
 516         Thread parent = currentThread();
 517         boolean primordial = (parent == this);
 518 
 519         SecurityManager security = System.getSecurityManager();
 520         if (g == null) {
 521             /* Determine if it&#39;s an applet or not */
 522 
 523             /* If there is a security manager, ask the security manager
 524                what to do. */
 525             if (security != null) {
 526                 g = security.getThreadGroup();
 527             }
 528 
 529             /* If the security manager doesn&#39;t have a strong opinion
 530                on the matter, use the parent thread group. */
 531             if (g == null) {
 532                 g = parent.getThreadGroup();
 533             }
 534         }
 535 
 536         /* checkAccess regardless of whether or not threadgroup is
 537            explicitly passed in. */
 538         g.checkAccess();
 539 
 540         /*
 541          * Do we have the required permissions?
 542          */
 543         if (security != null) {
 544             if (isCCLOverridden(getClass())) {
 545                 security.checkPermission(
 546                         SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
 547             }
 548         }
 549 
 550         g.addUnstarted();
 551 
 552         this.name = name;
 553         this.tid = primordial ? 1 : ThreadIdentifiers.next();
 554         this.contextClassLoader = contextClassLoader(parent);
 555         this.inheritedAccessControlContext = (acc != null) ? acc : AccessController.getContext();
 556 
 557         // thread locals
 558         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 559             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 560             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 561         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 562             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 563             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 564                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 565             }
 566         }
 567 
 568         int priority;
 569         boolean daemon;
 570         if (primordial) {
 571             // primordial or attached thread
 572             priority = NORM_PRIORITY;
 573             daemon = false;
 574         } else {
 575             priority = parent.getPriority();
 576             daemon = parent.isDaemon();
 577         }
 578         this.holder = new FieldHolder(g, task, stackSize, priority, daemon);
 579     }
 580 
 581     /**
 582      * Initializes a virtual Thread.
 583      *
 584      * @param name thread name, can be null
 585      * @param characteristics thread characteristics
 586      * @throws IllegalArgumentException if invalid characteristics are specified
 587      */
 588     Thread(String name, int characteristics) {
 589         checkCharacteristics(characteristics);
 590 
 591         Thread parent = currentThread();
 592 
 593         this.name = (name != null) ? name : &quot;&lt;unnamed&gt;&quot;;
 594         this.tid = ThreadIdentifiers.next();
 595         this.contextClassLoader = contextClassLoader(parent);
 596         this.inheritedAccessControlContext = VirtualThreads.ACCESS_CONTROL_CONTEXT;
 597 
 598         // thread locals
 599         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 600             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 601             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 602         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 603             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 604             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 605                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 606             }
 607         }
 608 
 609         // no additional fields
 610         this.holder = null;
 611     }
 612 
 613     /**
 614      * Returns a builder for creating {@code Thread} or {@code ThreadFactory} objects.
 615      *
 616      * @apiNote The following are examples using the builder:
 617      *
 618      * &lt;pre&gt;{@code
 619      *   // Create a daemon thread that is scheduled by the operating system
 620      *   Thread thread = Thread.builder()
 621      *                 .name(&quot;duke&quot;)
 622      *                 .daemon(true)
 623      *                 .priority(Thread.NORM_PRIORITY)
 624      *                 .inheritThreadLocals()
 625      *                 .task(...)
 626      *                 .build();
 627      *
 628      *   // A ThreadFactory that creates daemon threads named &quot;worker-0&quot;, &quot;worker-1&quot;, ...
 629      *   ThreadFactory factory = Thread.builder().daemon(true).name(&quot;worker-&quot;, 0).factory();
 630      *
 631      *   // Create an unnamed virtual thread
 632      *   Thread thread1 = Thread.builder().virtual().task(...).build();
 633      *
 634      *   // Create a named virtual thread
 635      *   Thread thread2 = Thread.builder().virtual().name(&quot;duke&quot;).task(...).build();
 636      *
 637      *   // Create and start a virtual thread
 638      *   Thread thread = Thread.builder().virtual().task(...).start();
 639      *
 640      *   // A ThreadFactory that creates virtual threads
 641      *   ThreadFactory factory = Thread.builder().virtual().factory();
 642      *
 643      *   // A ThreadFactory that creates virtual threads and uses a custom scheduler
 644      *   Executor scheduler = ...
 645      *   ThreadFactory factory = Thread.builder().virtual(scheduler).factory();
 646      * }&lt;/pre&gt;
 647      *
 648      * @return A builder for creating {@code Thread} or {@code ThreadFactory} objects.
 649      *
 650      * @since 99
 651      */
 652     public static Builder builder() {
 653         return new BuilderImpl();
 654     }
 655 
 656     /**
 657      * A mutable builder for a {@link Thread} or {@link ThreadFactory}.
 658      *
 659      * &lt;p&gt; {@code Builder} defines methods to set the {@code Thread} characteristics
 660      * and features. Once set, a {@code Thread} or {@code ThreadFactory} can be
 661      * created with the following methods:
 662      *
 663      * &lt;ul&gt;
 664      *     &lt;li&gt; The {@linkplain #build() build} method creates an unstarted {@code Thread}.
 665      *     &lt;li&gt; The {@linkplain #start() start} method creates and starts a {@code Thread}.
 666      *     &lt;li&gt; The {@linkplain #factory() factory} method creates a {@code ThreadFactory}.
 667      * &lt;/ul&gt;
 668      *
 669      * &lt;p&gt; A {@code Builder} is not thread safe. The {@code ThreadFactory}
 670      * returned by the builder&#39;s {@code factory() method} is thread safe.
 671      *
 672      * &lt;p&gt; Unless otherwise specified, passing a null argument to a method in
 673      * this interface causes a {@code NullPointerException} to be thrown.
 674      *
 675      * @apiNote {@code Builder} checks invariants as components are added to the builder.
 676      * The rationale for this is to detect errors as early as possible and not defer
 677      * all validation to the {@code build} method.
 678      *
 679      * @see Thread#builder()
 680      * @since 99
 681      */
 682     public interface Builder {
 683 
 684         /**
 685          * Sets the thread group.
 686          *
 687          * &lt;p&gt; The thread group for threads that are scheduled by the Java virtual
 688          * machine threads does not support all features of regular thread groups.
 689          * The thread group can only be set for threads that are scheduled by
 690          * the operating system.
 691          *
 692          * @param group the thread group
 693          * @return this builder
 694          * @throws IllegalStateException if this is a builder for a virtual thread
 695          */
 696         Builder group(ThreadGroup group);
 697 
 698         /**
 699          * Sets the thread name.
 700          * @param name thread name
 701          * @return this builder
 702          */
 703         Builder name(String name);
 704 
 705         /**
 706          * Sets the thread name to be the concatenation of a string prefix and
 707          * a counter value.
 708          * @param prefix thread name prefix
 709          * @param start counter start
 710          * @return this builder
 711          * @throws IllegalArgumentException if count is negative
 712          */
 713         Builder name(String prefix, int start);
 714 
 715         /**
 716          * The thread will be scheduled by the Java virtual machine rather than
 717          * the operating system with the default scheduler.
 718          * @return this builder
 719          * @throws IllegalStateException if a thread group has been set
 720          */
 721         Builder virtual();
 722 
 723         /**
 724          * The thread will be scheduled by the Java virtual machine rather than
 725          * the operating system with the given scheduler.
 726          * @param scheduler the scheduler
 727          * @return this builder
 728          * @throws IllegalStateException if a thread group has been set
 729          */
 730         Builder virtual(Executor scheduler);
 731 
 732         /**
 733          * Disallow threads locals.
 734          * @return this builder
 735          * @throws IllegalStateException if inheritThreadLocals has already been set
 736          */
 737         Builder disallowThreadLocals();
 738 
 739         /**
 740          * Inherit threads locals. Thread locals are inherited when the {@code Thread}
 741          * is created with the {@link #build() build} method or when the thread
 742          * factory {@link ThreadFactory#newThread(Runnable) newThread} method
 743          * is invoked.
 744          * @return this builder
 745          * @throws IllegalStateException if disallowThreadLocals has already been set
 746          */
 747         Builder inheritThreadLocals();
 748 
 749         /**
 750          * Sets the daemon status.
 751          * @param on {@code true} to create daemon threads
 752          * @return this builder
 753          */
 754         Builder daemon(boolean on);
 755 
 756         /**
 757          * Sets the thread priority.
 758          * @param priority priority
 759          * @return this builder
 760          * @throws IllegalArgumentException if the priority is less than
 761          *        {@link Thread#MIN_PRIORITY} or greater than {@link Thread#MAX_PRIORITY}
 762          */
 763         Builder priority(int priority);
 764 
 765         /**
 766          * Sets the uncaught exception handler.
 767          * @param ueh uncaught exception handler
 768          * @return this builder
 769          */
 770         Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);
 771 
 772         /**
 773          * Sets the task for the thread to run.
 774          * @param task the task to run
 775          * @return this builder
 776          */
 777         Builder task(Runnable task);
 778 
 779         /**
 780          * Creates a new unstarted {@code Thread} from the current state of the
 781          * builder.
 782          *
 783          * @return a new unstarted Thread
 784          * @throws IllegalStateException if the task object to run object has not been set
 785          * @throws SecurityException if a thread group has been set and the current thread
 786          *         cannot create a thread in that thread group
 787          */
 788         Thread build();
 789 
 790         /**
 791          * Returns a {@code ThreadFactory} to create threads from the current
 792          * state of the builder. The returned thread factory is safe for use by
 793          * multiple concurrent threads.
 794          *
 795          * @return a thread factory to create threads
 796          */
 797         ThreadFactory factory();
 798 
 799         /**
 800          * Creates a new {@code Thread} from the current state of the builder
 801          * and starts it as if by invoking the {@linkplain Thread#start() start}
 802          * method.
 803          *
 804          * @implSpec The default implementation invokes {@linkplain #build() build}
 805          * to create a {@code Thread} and then invokes its {@linkplain Thread#start()
 806          * start} method to start it.
 807          *
 808          * @return The started thread
 809          * @throws IllegalStateException if the task object to run object has not been set
 810          * @throws SecurityException if a thread group has been set and the current thread
 811          *         cannot create a thread in that thread group
 812          */
 813         default Thread start() {
 814             Thread thread = build();
 815             thread.start();
 816             return thread;
 817         }
 818     }
 819 
 820     private static class BuilderImpl implements Builder {
 821         private ThreadGroup group;
 822         private Executor scheduler;
 823         private String name;
 824         private int counter;
 825         private boolean virtual;
 826         private boolean disallowThreadLocals;
 827         private boolean inheritThreadLocals;
 828         private boolean daemon;
 829         private boolean daemonChanged;
 830         private int priority;
 831         private UncaughtExceptionHandler uhe;
 832         private Runnable task;
 833 
 834         BuilderImpl() { }
 835 
 836         private int characteristics() {
 837             int characteristics = 0;
 838             if (virtual)
 839                 characteristics |= Thread.VIRTUAL;
 840             if (disallowThreadLocals)
 841                 characteristics |= Thread.NO_THREAD_LOCALS;
 842             if (inheritThreadLocals)
 843                 characteristics |= Thread.INHERIT_THREAD_LOCALS;
 844             return characteristics;
 845         }
 846 
 847         @Override
 848         public Builder group(ThreadGroup group) {
 849             Objects.requireNonNull(group);
 850             if (virtual)
 851                 throw new IllegalStateException();
 852             this.group = group;
 853             return this;
 854         }
 855 
 856         @Override
 857         public Builder name(String name) {
 858             this.name = Objects.requireNonNull(name);
 859             this.counter = -1;
 860             return this;
 861         }
 862 
 863         @Override
 864         public Builder name(String prefix, int start) {
 865             Objects.requireNonNull(prefix);
 866             if (start &lt; 0)
 867                 throw new IllegalArgumentException(&quot;&#39;start&#39; is negative&quot;);
 868             this.name = prefix;
 869             this.counter = start;
 870             return this;
 871         }
 872 
 873         @Override
 874         public Builder virtual() {
 875             if (group != null)
 876                 throw new IllegalStateException();
 877             this.virtual = true;
 878             this.scheduler = null;
 879             return this;
 880         }
 881 
 882         @Override
 883         public Builder virtual(Executor scheduler) {
 884             Objects.requireNonNull(scheduler);
 885             if (group != null)
 886                 throw new IllegalStateException();
 887             this.virtual = true;
 888             this.scheduler = scheduler;
 889             return this;
 890         }
 891 
 892         @Override
 893         public Builder disallowThreadLocals() {
 894             if (inheritThreadLocals)
 895                 throw new IllegalStateException();
 896             this.disallowThreadLocals = true;
 897             return this;
 898         }
 899 
 900         @Override
 901         public Builder inheritThreadLocals() {
 902             if (disallowThreadLocals)
 903                 throw new IllegalStateException();
 904             this.inheritThreadLocals = true;
 905             return this;
 906         }
 907 
 908         @Override
 909         public Builder daemon(boolean on) {
 910             daemon = on;
 911             daemonChanged = true;
 912             return this;
 913         }
 914 
 915         @Override
 916         public Builder priority(int priority) {
 917             if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY)
 918                 throw new IllegalArgumentException();
 919             this.priority = priority;
 920             return this;
 921         }
 922 
 923         @Override
 924         public Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
 925             this.uhe = Objects.requireNonNull(ueh);
 926             return this;
 927         }
 928 
 929         @Override
 930         public Thread build() {
 931             Runnable task = this.task;
 932             if (task == null)
 933                 throw new IllegalStateException(&quot;No task specified&quot;);
 934 
 935             int characteristics = characteristics();
 936             Thread thread;
 937             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 938                 String name = this.name;
 939                 if (name != null &amp;&amp; counter &gt;= 0) {
 940                     name = name + (counter++);
 941                 }
 942                 thread = new VirtualThread(scheduler, name, characteristics, task);
 943             } else {
 944                 String name = this.name;
 945                 if (name == null) {
 946                     name = &quot;Thread-&quot; + nextThreadNum();
 947                 } else if (counter &gt;= 0) {
 948                     name = name + (counter++);
 949                 }
 950                 thread = new Thread(group, name, characteristics, task, 0, null);
 951                 if (daemonChanged)
 952                     thread.daemon(daemon);
 953                 if (priority != 0)
 954                     thread.priority(priority);
 955             }
 956             if (uhe != null)
 957                 thread.uncaughtExceptionHandler(uhe);
 958             return thread;
 959         }
 960 
 961         @Override
 962         public Builder task(Runnable task) {
 963             this.task = Objects.requireNonNull(task);
 964             return this;
 965         }
 966 
 967         @Override
 968         public ThreadFactory factory() {
 969             int characteristics = characteristics();
 970             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 971                 return new VirtualThreadFactory(scheduler, name, counter, characteristics, uhe);
 972             } else {
 973                 return new KernelThreadFactory(group, name, counter, characteristics,
 974                                                daemon, priority, uhe);
 975             }
 976         }
 977     }
 978 
 979     private static abstract class CountingThreadFactory implements ThreadFactory {
 980         private static final VarHandle COUNT;
 981         static {
 982             try {
 983                 MethodHandles.Lookup l = MethodHandles.lookup();
 984                 COUNT = l.findVarHandle(CountingThreadFactory.class, &quot;count&quot;, int.class);
 985             } catch (Exception e) {
 986                 throw new InternalError(e);
 987             }
 988         }
 989         private volatile int count;
 990         private final boolean hasCounter;
 991 
 992         CountingThreadFactory(int start) {
 993             if (start &gt;= 0) {
 994                 count = start;
 995                 hasCounter = true;
 996             } else {
 997                 hasCounter = false;
 998             }
 999         }
1000 
1001         boolean hasCounter() {
1002             return hasCounter;
1003         }
1004 
1005         int next() {
1006             return (int) COUNT.getAndAdd(this, 1);
1007         }
1008     }
1009 
1010     private static class VirtualThreadFactory extends CountingThreadFactory {
1011         private final Executor scheduler;
1012         private String name;
1013         private final int characteristics;
1014         private final UncaughtExceptionHandler uhe;
1015 
1016         VirtualThreadFactory(Executor scheduler,
1017                              String name,
1018                              int start,
1019                              int characteristics,
1020                              UncaughtExceptionHandler uhe) {
1021             super(start);
1022             this.scheduler = scheduler;
1023             this.name = name;
1024             this.characteristics = characteristics;
1025             this.uhe = uhe;
1026         }
1027 
1028         @Override
1029         public Thread newThread(Runnable task) {
1030             Objects.requireNonNull(task);
1031             String name = this.name;
1032             if (name != null &amp;&amp; hasCounter()) {
1033                 name += next();
1034             }
1035             Thread thread = new VirtualThread(scheduler, name, characteristics, task);
1036             if (uhe != null)
1037                 thread.uncaughtExceptionHandler(uhe);
1038             return thread;
1039         }
1040     }
1041 
1042     private static class KernelThreadFactory extends CountingThreadFactory {
1043         private final ThreadGroup group;
1044         private final String name;
1045         private final int characteristics;
1046         private final boolean daemon;
1047         private final int priority;
1048         private final UncaughtExceptionHandler uhe;
1049 
1050         KernelThreadFactory(ThreadGroup group,
1051                             String name,
1052                             int start,
1053                             int characteristics,
1054                             boolean daemon,
1055                             int priority,
1056                             UncaughtExceptionHandler uhe) {
1057             super(start);
1058             this.group = group;
1059             this.name = name;
1060             this.characteristics = characteristics;
1061             this.daemon = daemon;
1062             this.priority = priority;
1063             this.uhe = uhe;
1064         }
1065 
1066         @Override
1067         public Thread newThread(Runnable task) {
1068             Objects.requireNonNull(task);
1069             String name = this.name;
1070             if (name == null) {
1071                 name = &quot;Thread-&quot; + nextThreadNum();
1072             } else if (hasCounter()) {
1073                 name += next();
1074             }
1075             Thread thread = new Thread(group, name, characteristics, task, 0, null);
1076             if (daemon)
1077                 thread.daemon(true);
1078             if (priority != 0)
1079                 thread.priority(priority);
1080             if (uhe != null)
1081                 thread.uncaughtExceptionHandler(uhe);
1082             return thread;
1083         }
1084     }
1085 
1086     /**
1087      * Throws CloneNotSupportedException as a Thread can not be meaningfully
1088      * cloned. Construct a new Thread instead.
1089      *
1090      * @throws  CloneNotSupportedException
1091      *          always
1092      */
1093     @Override
1094     protected Object clone() throws CloneNotSupportedException {
1095         throw new CloneNotSupportedException();
1096     }
1097 
1098     /**
1099      * Allocates a new {@code Thread} object. This constructor has the same
1100      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1101      * {@code (null, null, gname)}, where {@code gname} is a newly generated
1102      * name. Automatically generated names are of the form
1103      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1104      */
1105     public Thread() {
1106         this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
1107     }
1108 
1109     /**
1110      * Allocates a new {@code Thread} object. This constructor has the same
1111      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1112      * {@code (null, task, gname)}, where {@code gname} is a newly generated
1113      * name. Automatically generated names are of the form
1114      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1115      *
1116      * @param  task
1117      *         the object whose {@code run} method is invoked when this thread
1118      *         is started. If {@code null}, this classes {@code run} method does
1119      *         nothing.
1120      */
1121     public Thread(Runnable task) {
1122         this(null, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1123     }
1124 
1125     /**
1126      * Creates a new Thread that inherits the given AccessControlContext
1127      * but thread-local variables are not inherited.
1128      * This is not a public constructor.
1129      */
1130     Thread(Runnable task, AccessControlContext acc) {
1131         this(null, &quot;Thread-&quot; + nextThreadNum(), 0, task, 0, acc);
1132     }
1133 
1134     /**
1135      * Allocates a new {@code Thread} object. This constructor has the same
1136      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1137      * {@code (group, task, gname)} ,where {@code gname} is a newly generated
1138      * name. Automatically generated names are of the form
1139      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1140      *
1141      * @param  group
1142      *         the thread group. If {@code null} and there is a security
1143      *         manager, the group is determined by {@linkplain
1144      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1145      *         If there is not a security manager or {@code
1146      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1147      *         is set to the current thread&#39;s thread group.
1148      *
1149      * @param  task
1150      *         the object whose {@code run} method is invoked when this thread
1151      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1152      *
1153      * @throws  SecurityException
1154      *          if the current thread cannot create a thread in the specified
1155      *          thread group
1156      */
1157     public Thread(ThreadGroup group, Runnable task) {
1158         this(group, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1159     }
1160 
1161     /**
1162      * Allocates a new {@code Thread} object. This constructor has the same
1163      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1164      * {@code (null, null, name)}.
1165      *
1166      * @param   name
1167      *          the name of the new thread
1168      */
1169     public Thread(String name) {
1170         this(null, null, name, 0);
1171     }
1172 
1173     /**
1174      * Allocates a new {@code Thread} object. This constructor has the same
1175      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1176      * {@code (group, null, name)}.
1177      *
1178      * @param  group
1179      *         the thread group. If {@code null} and there is a security
1180      *         manager, the group is determined by {@linkplain
1181      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1182      *         If there is not a security manager or {@code
1183      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1184      *         is set to the current thread&#39;s thread group.
1185      *
1186      * @param  name
1187      *         the name of the new thread
1188      *
1189      * @throws  SecurityException
1190      *          if the current thread cannot create a thread in the specified
1191      *          thread group
1192      */
1193     public Thread(ThreadGroup group, String name) {
1194         this(group, null, name, 0);
1195     }
1196 
1197     /**
1198      * Allocates a new {@code Thread} object. This constructor has the same
1199      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1200      * {@code (null, task, name)}.
1201      *
1202      * @param  task
1203      *         the object whose {@code run} method is invoked when this thread
1204      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1205      *
1206      * @param  name
1207      *         the name of the new thread
1208      */
1209     public Thread(Runnable task, String name) {
1210         this(null, task, name, 0);
1211     }
1212 
1213     /**
1214      * Allocates a new {@code Thread} object so that it has {@code task}
1215      * as its run object, has the specified {@code name} as its name,
1216      * and belongs to the thread group referred to by {@code group}.
1217      *
1218      * &lt;p&gt;If there is a security manager, its
1219      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
1220      * method is invoked with the ThreadGroup as its argument.
1221      *
1222      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
1223      * the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}
1224      * permission when invoked directly or indirectly by the constructor
1225      * of a subclass which overrides the {@code getContextClassLoader}
1226      * or {@code setContextClassLoader} methods.
1227      *
1228      * &lt;p&gt;The priority of the newly created thread is set equal to the
1229      * priority of the thread creating it, that is, the currently running
1230      * thread. The method {@linkplain #setPriority setPriority} may be
1231      * used to change the priority to a new value.
1232      *
1233      * &lt;p&gt;The newly created thread is initially marked as being a daemon
1234      * thread if and only if the thread creating it is currently marked
1235      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
1236      * may be used to change whether or not a thread is a daemon.
1237      *
1238      * @param  group
1239      *         the thread group. If {@code null} and there is a security
1240      *         manager, the group is determined by {@linkplain
1241      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1242      *         If there is not a security manager or {@code
1243      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1244      *         is set to the current thread&#39;s thread group.
1245      *
1246      * @param  task
1247      *         the object whose {@code run} method is invoked when this thread
1248      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1249      *
1250      * @param  name
1251      *         the name of the new thread
1252      *
1253      * @throws  SecurityException
1254      *          if the current thread cannot create a thread in the specified
1255      *          thread group or cannot override the context class loader methods.
1256      */
1257     public Thread(ThreadGroup group, Runnable task, String name) {
1258         this(group, task, name, 0);
1259     }
1260 
1261     /**
1262      * Allocates a new {@code Thread} object so that it has {@code task}
1263      * as its run object, has the specified {@code name} as its name,
1264      * and belongs to the thread group referred to by {@code group}, and has
1265      * the specified &lt;i&gt;stack size&lt;/i&gt;.
1266      *
1267      * &lt;p&gt;This constructor is identical to {@link
1268      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
1269      * that it allows the thread stack size to be specified.  The stack size
1270      * is the approximate number of bytes of address space that the virtual
1271      * machine is to allocate for this thread&#39;s stack.  &lt;b&gt;The effect of the
1272      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
1273      *
1274      * &lt;p&gt;On some platforms, specifying a higher value for the
1275      * {@code stackSize} parameter may allow a thread to achieve greater
1276      * recursion depth before throwing a {@link StackOverflowError}.
1277      * Similarly, specifying a lower value may allow a greater number of
1278      * threads to exist concurrently without throwing an {@link
1279      * OutOfMemoryError} (or other internal error).  The details of
1280      * the relationship between the value of the {@code stackSize} parameter
1281      * and the maximum recursion depth and concurrency level are
1282      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
1283      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
1284      *
1285      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
1286      * parameter as a suggestion.  If the specified value is unreasonably low
1287      * for the platform, the virtual machine may instead use some
1288      * platform-specific minimum value; if the specified value is unreasonably
1289      * high, the virtual machine may instead use some platform-specific
1290      * maximum.  Likewise, the virtual machine is free to round the specified
1291      * value up or down as it sees fit (or to ignore it completely).
1292      *
1293      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
1294      * cause this constructor to behave exactly like the
1295      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
1296      *
1297      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
1298      * constructor, extreme care should be exercised in its use.
1299      * The thread stack size necessary to perform a given computation will
1300      * likely vary from one JRE implementation to another.  In light of this
1301      * variation, careful tuning of the stack size parameter may be required,
1302      * and the tuning may need to be repeated for each JRE implementation on
1303      * which an application is to run.&lt;/i&gt;
1304      *
1305      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
1306      * document their implementation&#39;s behavior with respect to the
1307      * {@code stackSize} parameter.
1308      *
1309      *
1310      * @param  group
1311      *         the thread group. If {@code null} and there is a security
1312      *         manager, the group is determined by {@linkplain
1313      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1314      *         If there is not a security manager or {@code
1315      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1316      *         is set to the current thread&#39;s thread group.
1317      *
1318      * @param  task
1319      *         the object whose {@code run} method is invoked when this thread
1320      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1321      *
1322      * @param  name
1323      *         the name of the new thread
1324      *
1325      * @param  stackSize
1326      *         the desired stack size for the new thread, or zero to indicate
1327      *         that this parameter is to be ignored.
1328      *
1329      * @throws  SecurityException
1330      *          if the current thread cannot create a thread in the specified
1331      *          thread group
1332      *
1333      * @since 1.4
1334      */
1335     public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
1336         this(group, name, Thread.INHERIT_THREAD_LOCALS, task, stackSize, null);
1337     }
1338 
1339     /**
1340      * Allocates a new {@code Thread} object so that it has {@code task}
1341      * as its run object, has the specified {@code name} as its name,
1342      * belongs to the thread group referred to by {@code group}, has
1343      * the specified {@code stackSize}, and inherits initial values for
1344      * {@linkplain InheritableThreadLocal inheritable thread-local} variables
1345      * if {@code inheritThreadLocals} is {@code true}.
1346      *
1347      * &lt;p&gt; This constructor is identical to {@link
1348      * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
1349      * suppress, or not, the inheriting of initial values for inheritable
1350      * thread-local variables from the constructing thread. This allows for
1351      * finer grain control over inheritable thread-locals. Care must be taken
1352      * when passing a value of {@code false} for {@code inheritThreadLocals},
1353      * as it may lead to unexpected behavior if the new thread executes code
1354      * that expects a specific thread-local value to be inherited.
1355      *
1356      * &lt;p&gt; Specifying a value of {@code true} for the {@code inheritThreadLocals}
1357      * parameter will cause this constructor to behave exactly like the
1358      * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
1359      *
1360      * @param  group
1361      *         the thread group. If {@code null} and there is a security
1362      *         manager, the group is determined by {@linkplain
1363      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1364      *         If there is not a security manager or {@code
1365      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1366      *         is set to the current thread&#39;s thread group.
1367      *
1368      * @param  task
1369      *         the object whose {@code run} method is invoked when this thread
1370      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1371      *
1372      * @param  name
1373      *         the name of the new thread
1374      *
1375      * @param  stackSize
1376      *         the desired stack size for the new thread, or zero to indicate
1377      *         that this parameter is to be ignored
1378      *
1379      * @param  inheritThreadLocals
1380      *         if {@code true}, inherit initial values for inheritable
1381      *         thread-locals from the constructing thread, otherwise no initial
1382      *         values are inherited
1383      *
1384      * @throws  SecurityException
1385      *          if the current thread cannot create a thread in the specified
1386      *          thread group
1387      *
1388      * @since 9
1389      */
1390     public Thread(ThreadGroup group, Runnable task, String name,
1391                   long stackSize, boolean inheritThreadLocals) {
1392         this(group, name, (inheritThreadLocals ? Thread.INHERIT_THREAD_LOCALS : 0),
1393                 task, stackSize, null);
1394     }
1395 
1396     /**
1397      * Characteristic value signifying that the thread should be scheduled by
1398      * the Java virtual machine rather than the operating system.
1399      *
1400      * @since 99
1401      */
1402     public static final int VIRTUAL = 1 &lt;&lt; 0;
1403 
1404     /**
1405      * Characteristic value signifying that {@link ThreadLocal thread-locals}
1406      * are not supported by the thread.
1407      *
1408      * @apiNote This is for experimental purposes, a lot of existing code will
1409      * not run if thread locals are not supported.
1410      *
1411      * @since 99
1412      */
1413     public static final int NO_THREAD_LOCALS = 1 &lt;&lt; 1;
1414 
1415     /**
1416      * Characteristic value signifying that {@link InheritableThreadLocal
1417      * inheritable-thread-locals} are inherihted from the constructing thread.
1418      * This characteristic is incompatible with {@linkplain #NO_THREAD_LOCALS},
1419      * they may not be used together.
1420      *
1421      * @since 99
1422      */
1423     public static final int INHERIT_THREAD_LOCALS = 1 &lt;&lt; 2;
1424 
1425     private static int validCharacteristics() {
1426         return (VIRTUAL | NO_THREAD_LOCALS | INHERIT_THREAD_LOCALS);
1427     }
1428 
1429     private static void checkCharacteristics(int characteristics) {
1430         if (characteristics != 0) {
1431             if ((characteristics &amp; ~validCharacteristics()) != 0)
1432                 throw new IllegalArgumentException();
1433             if ((characteristics &amp; NO_THREAD_LOCALS) != 0
1434                     &amp;&amp; (characteristics &amp; INHERIT_THREAD_LOCALS) != 0)
1435                 throw new IllegalArgumentException();
1436         }
1437     }
1438 
1439     /**
1440      * Creates an unnamed thread.
1441      *
1442      * By default, the thread is scheduled by the operating system, supports
1443      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1444      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1445      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1446      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1447      * context-class-loader} are inherited from the current thread.
1448      *
1449      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1450      * used to create a thread that is scheduled by the Java virtual machine
1451      * using the default scheduler. The default in this case is to only inherit
1452      * the {@link #getContextClassLoader() context-class-loader} from the current
1453      * thread.
1454      *
1455      * @apiNote The characteristics will probably be replaced by an enum
1456      *
1457      * @param characteristics characteristics of the thread
1458      * @param task the object to run when the thread executes
1459      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1460      *         combination of characteristic is specified
1461      * @return an un-started virtual thread
1462      *
1463      * @since 99
1464      */
1465     public static Thread newThread(int characteristics, Runnable task) {
1466         if ((characteristics &amp; VIRTUAL) != 0) {
1467             return new VirtualThread(null, null, characteristics, task);
1468         } else {
1469             return new Thread(null, &quot;Thread-&quot; + nextThreadNum(), characteristics, task, 0, null);
1470         }
1471     }
1472 
1473     /**
1474      * Creates a named thread.
1475      *
1476      * By default, the thread is scheduled by the operating system, supports
1477      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1478      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1479      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1480      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1481      * context-class-loader} are inherited from the current thread.
1482      *
1483      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1484      * used to create a thread that is scheduled by the Java virtual machine
1485      * using the default scheduler. The default in this case is to only inherit
1486      * the {@link #getContextClassLoader() context-class-loader} from the current
1487      * thread.
1488      *
1489      * @apiNote The characteristics will probably be replaced by an enum
1490      *
1491      * @param name the thread name
1492      * @param characteristics characteristics of the thread
1493      * @param task the object to run when the thread executes
1494      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1495      *         combination of characteristic is specified
1496      * @return an un-started virtual thread
1497      *
1498      * @since 99
1499      */
1500     public static Thread newThread(String name, int characteristics, Runnable task) {
1501         if ((characteristics &amp; VIRTUAL) != 0) {
1502             return new VirtualThread(null, name, characteristics, task);
1503         } else {
1504             return new Thread(null, name, characteristics, task, 0, null);
1505         }
1506     }
1507 
1508     /**
1509      * Returns {@code true} if this thread scheduled by the Java virtual machine
1510      * rather than the operating system.
1511      *
1512      * &lt;p&gt; Threads that are scheduled by the Java virtual machine do not support
1513      * all features of Thread. In particular, the Thread is not an &lt;i&gt;active thread&lt;/i&gt;
1514      * in its thread group and so is not enumerated or acted on by thread group
1515      * operations. In addition it does not support the stop, suspend or resume
1516      * methods.
1517      *
1518      * @return {@code true} if this thread is scheduled by the Java virtual
1519      *         machine rather than the operating system
1520      *
1521      * @since 99
1522      */
1523     public final boolean isVirtual() {
1524         return (this instanceof VirtualThread);
1525     }
1526 
1527     /**
1528      * Schedules this thread to begin execution. The thread will execute
1529      * independently of the current thread.
1530      * &lt;p&gt;
1531      * It is never legal to start a thread more than once.
1532      * In particular, a thread may not be restarted once it has completed
1533      * execution.
1534      *
1535      * @throws     IllegalThreadStateException  if the thread was already started.
1536      * @see        #run()
1537      * @see        Builder#start()
1538      */
1539     public synchronized void start() {
1540         /**
1541          * This method is not invoked for the main method thread or &quot;system&quot;
1542          * group threads created/set up by the VM. Any new functionality added
1543          * to this method in the future may have to also be added to the VM.
1544          *
1545          * A zero status value corresponds to state &quot;NEW&quot;.
1546          */
1547         if (holder.threadStatus != 0)
1548             throw new IllegalThreadStateException();
1549 
1550         /* Notify the group that this thread is about to be started
1551          * so that it can be added to the group&#39;s list of threads
1552          * and the group&#39;s unstarted count can be decremented. */
1553         ThreadGroup group = holder.group;
1554         group.add(this);
1555 
1556         boolean started = false;
1557         try {
1558             start0();
1559             started = true;
1560         } finally {
1561             try {
1562                 if (!started) {
1563                     group.threadStartFailed(this);
1564                 }
1565             } catch (Throwable ignore) {
1566                 /* do nothing. If start0 threw a Throwable then
1567                   it will be passed up the call stack */
1568             }
1569         }
1570     }
1571 
1572     private native void start0();
1573 
1574     /**
1575      * If this thread was constructed using a separate
1576      * {@code Runnable} run object, then that
1577      * {@code Runnable} object&#39;s {@code run} method is called;
1578      * otherwise, this method does nothing and returns.
1579      * This method does nothing when invoked on a {@linkplain #isVirtual()
1580      * virtual} thread.
1581      * &lt;p&gt;
1582      * Subclasses of {@code Thread} should override this method.
1583      *
1584      * @see     #start()
1585      * @see     #Thread(ThreadGroup, Runnable, String)
1586      */
1587     @Override
1588     public void run() {
1589         if (!isVirtual()) {
1590             Runnable task = holder.task;
1591             if (task != null) {
1592                 task.run();
1593             }
1594         }
1595     }
1596 
1597     /**
1598      * This method is called by the system to give a Thread
1599      * a chance to clean up before it actually exits.
1600      */
1601     private void exit() {
1602         // assert !isVirtual();
1603         if (threadLocals != null &amp;&amp; TerminatingThreadLocal.REGISTRY.isPresent()) {
1604             TerminatingThreadLocal.threadTerminated();
1605         }
1606         ThreadGroup group = holder.group;
1607         if (group != null) {
1608             group.threadTerminated(this);
1609         }
1610         /* Aggressively null out all reference fields: see bug 4006245 */
1611         /* Speed the release of some of these resources */
1612         threadLocals = null;
1613         inheritableThreadLocals = null;
1614         inheritedAccessControlContext = null;
1615         nioBlocker = null;
1616         uncaughtExceptionHandler = null;
1617     }
1618 
1619     /**
1620      * Forces the thread to stop executing.
1621      * &lt;p&gt;
1622      * If there is a security manager installed, its {@code checkAccess}
1623      * method is called with {@code this}
1624      * as its argument. This may result in a
1625      * {@code SecurityException} being raised (in the current thread).
1626      * &lt;p&gt;
1627      * If this thread is different from the current thread (that is, the current
1628      * thread is trying to stop a thread other than itself), the
1629      * security manager&#39;s {@code checkPermission} method (with a
1630      * {@code RuntimePermission(&quot;stopThread&quot;)} argument) is called in
1631      * addition.
1632      * Again, this may result in throwing a
1633      * {@code SecurityException} (in the current thread).
1634      * &lt;p&gt;
1635      * The thread represented by this thread is forced to stop whatever
1636      * it is doing abnormally and to throw a newly created
1637      * {@code ThreadDeath} object as an exception.
1638      * &lt;p&gt;
1639      * It is permitted to stop a thread that has not yet been started.
1640      * If the thread is eventually started, it immediately terminates.
1641      * &lt;p&gt;
1642      * An application should not normally try to catch
1643      * {@code ThreadDeath} unless it must do some extraordinary
1644      * cleanup operation (note that the throwing of
1645      * {@code ThreadDeath} causes {@code finally} clauses of
1646      * {@code try} statements to be executed before the thread
1647      * officially terminates).  If a {@code catch} clause catches a
1648      * {@code ThreadDeath} object, it is important to rethrow the
1649      * object so that the thread actually terminates.
1650      * &lt;p&gt;
1651      * The top-level error handler that reacts to otherwise uncaught
1652      * exceptions does not print out a message or otherwise notify the
1653      * application if the uncaught exception is an instance of
1654      * {@code ThreadDeath}.
1655      *
1656      * @throws     SecurityException  if the current thread cannot
1657      *             modify this thread.
1658      * @throws     UnsupportedOperationException if invoked on a virtual thread
1659      * @see        #interrupt()
1660      * @see        #checkAccess()
1661      * @see        #run()
1662      * @see        #start()
1663      * @see        ThreadDeath
1664      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
1665      * @see        SecurityManager#checkAccess(Thread)
1666      * @see        SecurityManager#checkPermission
1667      * @deprecated This method is inherently unsafe.  Stopping a thread with
1668      *       Thread.stop causes it to unlock all of the monitors that it
1669      *       has locked (as a natural consequence of the unchecked
1670      *       {@code ThreadDeath} exception propagating up the stack).  If
1671      *       any of the objects previously protected by these monitors were in
1672      *       an inconsistent state, the damaged objects become visible to
1673      *       other threads, potentially resulting in arbitrary behavior.  Many
1674      *       uses of {@code stop} should be replaced by code that simply
1675      *       modifies some variable to indicate that the task thread should
1676      *       stop running.  The task thread should check this variable
1677      *       regularly, and return from its run method in an orderly fashion
1678      *       if the variable indicates that it is to stop running.  If the
1679      *       task thread waits for long periods (on a condition variable,
1680      *       for example), the {@code interrupt} method should be used to
1681      *       interrupt the wait.
1682      *       For more information, see
1683      *       &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1684      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1685      */
1686     @Deprecated(since=&quot;1.2&quot;)
1687     public final void stop() {
1688         SecurityManager security = System.getSecurityManager();
1689         if (security != null) {
1690             checkAccess();
1691             if (this != Thread.currentThread()) {
1692                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
1693             }
1694         }
1695 
1696         if (isVirtual())
1697             throw new UnsupportedOperationException();
1698 
1699         // A zero status value corresponds to &quot;NEW&quot;, it can&#39;t change to
1700         // not-NEW because we hold the lock.
1701         if (holder.threadStatus != 0) {
1702             resume(); // Wake up thread if it was suspended; no-op otherwise
1703         }
1704 
1705         // The VM can handle all thread states
1706         stop0(new ThreadDeath());
1707     }
1708 
1709     /**
1710      * Interrupts this thread.
1711      *
1712      * &lt;p&gt; Unless the current thread is interrupting itself, which is
1713      * always permitted, the {@link #checkAccess() checkAccess} method
1714      * of this thread is invoked, which may cause a {@link
1715      * SecurityException} to be thrown.
1716      *
1717      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
1718      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
1719      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
1720      * class, or of the {@link #join()}, {@link #join(long)}, {@link
1721      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
1722      * methods of this class, then its interrupt status will be cleared and it
1723      * will receive an {@link InterruptedException}.
1724      *
1725      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
1726      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
1727      * then the channel will be closed, the thread&#39;s interrupt
1728      * status will be set, and the thread will receive a {@link
1729      * java.nio.channels.ClosedByInterruptException}.
1730      *
1731      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
1732      * then the thread&#39;s interrupt status will be set and it will return
1733      * immediately from the selection operation, possibly with a non-zero
1734      * value, just as if the selector&#39;s {@link
1735      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
1736      *
1737      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
1738      * status will be set. &lt;/p&gt;
1739      *
1740      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
1741      *
1742      * @implNote In the JDK Reference Implementation, interruption of a thread
1743      * that is not alive still records that the interrupt request was made and
1744      * will report it via {@link #interrupted} and {@link #isInterrupted()}.
1745      *
1746      * @throws  SecurityException
1747      *          if the current thread cannot modify this thread
1748      *
1749      * @revised 6.0, 14
1750      * @spec JSR-51
1751      */
1752     public void interrupt() {
1753         if (this != Thread.currentThread()) {
1754             checkAccess();
1755 
1756             // thread may be blocked in an I/O operation
1757             synchronized (interruptLock) {
1758                 Interruptible b = nioBlocker;
1759                 if (b != null) {
1760                     interrupted = true;
1761                     interrupt0();  // inform VM of interrupt
1762                     b.interrupt(this);
1763                     return;
1764                 }
1765             }
1766         }
1767         interrupted = true;
1768         interrupt0();  // inform VM of interrupt
1769     }
1770 
1771     /**
1772      * Tests whether the current thread has been interrupted.  The
1773      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1774      * other words, if this method were to be called twice in succession, the
1775      * second call would return false (unless the current thread were
1776      * interrupted again, after the first call had cleared its interrupted
1777      * status and before the second call had examined it).
1778      *
1779      * @return  {@code true} if the current thread has been interrupted;
1780      *          {@code false} otherwise.
1781      * @see #isInterrupted()
1782      * @revised 6.0, 14
1783      */
1784     public static boolean interrupted() {
1785         return currentThread().getAndClearInterrupt();
1786     }
1787 
1788     /**
1789      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1790      * status&lt;/i&gt; of the thread is unaffected by this method.
1791      *
1792      * @return  {@code true} if this thread has been interrupted;
1793      *          {@code false} otherwise.
1794      * @see     #interrupted()
1795      * @revised 6.0, 14
1796      */
1797     public boolean isInterrupted() {
1798         return interrupted;
1799     }
1800 
1801     final void setInterrupt() {
1802         interrupted = true;
1803         interrupt0();  // inform VM of interrupt
1804     }
1805 
1806     final void clearInterrupt() {
1807         interrupted = false;
1808         clearInterruptEvent();
1809     }
1810 
1811     boolean getAndClearInterrupt() {
1812         boolean oldValue = interrupted;
1813         // We may have been interrupted the moment after we read the field,
1814         // so only clear the field if we saw that it was set and will return
1815         // true; otherwise we could lose an interrupt.
1816         if (oldValue) {
1817             interrupted = false;
1818             clearInterruptEvent();
1819         }
1820         return oldValue;
1821     }
1822 
1823     /**
1824      * Tests if this thread is alive. A thread is alive if it has
1825      * been started and has not yet terminated.
1826      *
1827      * @return  {@code true} if this thread is alive;
1828      *          {@code false} otherwise.
1829      */
1830     public final boolean isAlive() {
1831         if (isVirtual()) {
1832             State state = getState();
1833             return (state != State.NEW &amp;&amp; state != State.TERMINATED);
1834         } else {
1835             return isAlive0();
1836         }
1837     }
1838     private native boolean isAlive0();
1839 
1840     /**
1841      * Suspends this thread.
1842      * &lt;p&gt;
1843      * First, the {@code checkAccess} method of this thread is called
1844      * with no arguments. This may result in throwing a
1845      * {@code SecurityException }(in the current thread).
1846      * &lt;p&gt;
1847      * If the thread is alive, it is suspended and makes no further
1848      * progress unless and until it is resumed.
1849      *
1850      * @throws     SecurityException  if the current thread cannot modify
1851      *             this thread.
1852      * @throws     UnsupportedOperationException if invoked on a virtual thread
1853      * @see #checkAccess
1854      * @deprecated   This method has been deprecated, as it is
1855      *   inherently deadlock-prone.  If the task thread holds a lock on the
1856      *   monitor protecting a critical system resource when it is suspended, no
1857      *   thread can access this resource until the task thread is resumed. If
1858      *   the thread that would resume the task thread attempts to lock this
1859      *   monitor prior to calling {@code resume}, deadlock results.  Such
1860      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1861      *   For more information, see
1862      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1863      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1864      */
1865     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1866     public final void suspend() {
1867         checkAccess();
1868         if (isVirtual())
1869             throw new UnsupportedOperationException();
1870         suspend0();
1871     }
1872 
1873     void suspendThread() {
1874         suspend0();
1875     }
1876 
1877     /**
1878      * Resumes a suspended thread.
1879      * &lt;p&gt;
1880      * First, the {@code checkAccess} method of this thread is called
1881      * with no arguments. This may result in throwing a
1882      * {@code SecurityException} (in the current thread).
1883      * &lt;p&gt;
1884      * If the thread is alive but suspended, it is resumed and is
1885      * permitted to make progress in its execution.
1886      *
1887      * @throws     SecurityException  if the current thread cannot modify this
1888      *             thread.
1889      * @throws     UnsupportedOperationException if invoked on a virtual thread
1890      * @see        #checkAccess
1891      * @see        #suspend()
1892      * @deprecated This method exists solely for use with {@link #suspend},
1893      *     which has been deprecated because it is deadlock-prone.
1894      *     For more information, see
1895      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1896      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1897      */
1898     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1899     public final void resume() {
1900         checkAccess();
1901         if (isVirtual())
1902             throw new UnsupportedOperationException();
1903         resume0();
1904     }
1905 
1906     void resumeThread() {
1907         resume0();
1908     }
1909 
1910     /**
1911      * Changes the priority of this thread.
1912      * &lt;p&gt;
1913      * First the {@code checkAccess} method of this thread is called
1914      * with no arguments. This may result in throwing a {@code SecurityException}.
1915      * &lt;p&gt;
1916      * The priority of virtual-threads is always {@linkplain Thread#NORM_PRIORITY}
1917      * and is not changed by this method.
1918      * Otherwise, the priority of this thread is set to the smaller of
1919      * the specified {@code newPriority} and the maximum permitted
1920      * priority of the thread&#39;s thread group.
1921      *
1922      * @param newPriority priority to set this thread to
1923      * @throws     IllegalArgumentException  If the priority is not in the
1924      *               range {@code MIN_PRIORITY} to
1925      *               {@code MAX_PRIORITY}.
1926      * @throws     SecurityException  if the current thread cannot modify
1927      *               this thread.
1928      * @see        #getPriority
1929      * @see        #checkAccess()
1930      * @see        #getThreadGroup()
1931      * @see        #MAX_PRIORITY
1932      * @see        #MIN_PRIORITY
1933      * @see        ThreadGroup#getMaxPriority()
1934      */
1935     public final void setPriority(int newPriority) {
1936         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1937             throw new IllegalArgumentException();
1938         }
1939         checkAccess();
1940         priority(newPriority);
1941     }
1942 
1943     void priority(int newPriority) {
1944         ThreadGroup g;
1945         if (!isVirtual() &amp;&amp; (g = getThreadGroup()) != null) {
1946             if (newPriority &gt; g.getMaxPriority()) {
1947                 newPriority = g.getMaxPriority();
1948             }
1949             setPriority0(holder.priority = newPriority);
1950         }
1951     }
1952 
1953     /**
1954      * Returns this thread&#39;s priority.
1955      * The priority of a virtual thread is always {@linkplain Thread#NORM_PRIORITY}.
1956      *
1957      * @return  this thread&#39;s priority.
1958      * @see     #setPriority
1959      */
1960     public final int getPriority() {
1961         if (isVirtual()) {
1962             return Thread.NORM_PRIORITY;
1963         } else {
1964             return holder.priority;
1965         }
1966     }
1967 
1968     /**
1969      * Changes the name of this thread to be equal to the argument {@code name}.
1970      * &lt;p&gt;
1971      * First the {@code checkAccess} method of this thread is called
1972      * with no arguments. This may result in throwing a
1973      * {@code SecurityException}.
1974      *
1975      * @param      name   the new name for this thread.
1976      * @throws     SecurityException  if the current thread cannot modify this
1977      *             thread.
1978      * @see        #getName
1979      * @see        #checkAccess()
1980      */
1981     public final synchronized void setName(String name) {
1982         checkAccess();
1983         if (name == null) {
1984             throw new NullPointerException(&quot;name cannot be null&quot;);
1985         }
1986 
1987         this.name = name;
1988         if (!isVirtual() &amp;&amp; holder.threadStatus != 0) {
1989             setNativeName(name);
1990         }
1991     }
1992 
1993     /**
1994      * Returns this thread&#39;s name.
1995      *
1996      * @return  this thread&#39;s name.
1997      * @see     #setName(String)
1998      */
1999     public final String getName() {
2000         return name;
2001     }
2002 
2003     /**
2004      * Returns the thread group to which this thread belongs.
2005      * This method returns null if the thread has terminated.
2006      *
2007      * &lt;p&gt; The thread group for virtual threads does not support all features
2008      * of regular thread groups. Virtual threads are not considered &lt;i&gt;active
2009      * threads&lt;/i&gt; in the thread group and so are not enumerated or acted on by
2010      * thread group operations.
2011      *
2012      * @return  this thread&#39;s thread group.
2013      */
2014     public final ThreadGroup getThreadGroup() {
2015         if (getState() == State.TERMINATED) {
2016             return null;
2017         } else {
2018             return isVirtual() ? VirtualThreads.THREAD_GROUP : holder.group;
2019         }
2020     }
2021 
2022     /**
2023      * Returns an estimate of the number of active threads in the current
2024      * thread&#39;s {@linkplain java.lang.ThreadGroup thread group} and its
2025      * subgroups. Recursively iterates over all subgroups in the current
2026      * thread&#39;s thread group.
2027      *
2028      * &lt;p&gt; The value returned is only an estimate because the number of
2029      * threads may change dynamically while this method traverses internal
2030      * data structures, and might be affected by the presence of certain
2031      * system threads. This method is intended primarily for debugging
2032      * and monitoring purposes.
2033      *
2034      * @return  an estimate of the number of active threads in the current
2035      *          thread&#39;s thread group and in any other thread group that
2036      *          has the current thread&#39;s thread group as an ancestor
2037      */
2038     public static int activeCount() {
2039         return currentThread().getThreadGroup().activeCount();
2040     }
2041 
2042     /**
2043      * Copies into the specified array every active thread in the current
2044      * thread&#39;s thread group and its subgroups. This method simply
2045      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
2046      * method of the current thread&#39;s thread group.
2047      *
2048      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
2049      * method to get an estimate of how big the array should be, however
2050      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
2051      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
2052      * thread in the current thread&#39;s thread group and its subgroups, the
2053      * invoker should verify that the returned int value is strictly less
2054      * than the length of {@code tarray}.
2055      *
2056      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
2057      * that the method only be used for debugging and monitoring purposes.
2058      *
2059      * @param  tarray
2060      *         an array into which to put the list of threads
2061      *
2062      * @return  the number of threads put into the array
2063      *
2064      * @throws  SecurityException
2065      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
2066      *          the current thread cannot access its thread group
2067      */
2068     public static int enumerate(Thread tarray[]) {
2069         return currentThread().getThreadGroup().enumerate(tarray);
2070     }
2071 
2072     /**
2073      * Throws {@code UnsupportedOperationException}.
2074      *
2075      * @return     nothing
2076      *
2077      * @deprecated This method was originally designed to count the number of
2078      *             stack frames but the results were never well-defined and it
2079      *             depended on thread-suspension.
2080      *             This method is subject to removal in a future version of Java SE.
2081      * @see        StackWalker
2082      */
2083     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
2084     public int countStackFrames() {
2085         throw new UnsupportedOperationException();
2086     }
2087 
2088     /**
2089      * Waits at most {@code millis} milliseconds for this thread to terminate.
2090      * A timeout of {@code 0} means to wait forever.
2091      * This method returns immediately, without waiting, if the thread has not
2092      * been {@link #start() started}.
2093      *
2094      * &lt;p&gt; For non-{@linkplain #isVirtual() virtual}, this
2095      * implementation uses a loop of {@code this.wait} calls
2096      * conditioned on {@code this.isAlive}. As a thread terminates the
2097      * {@code this.notifyAll} method is invoked. It is recommended that
2098      * applications not use {@code wait}, {@code notify}, or
2099      * {@code notifyAll} on {@code Thread} instances.
2100      *
2101      * @param  millis
2102      *         the time to wait in milliseconds
2103      *
2104      * @throws  IllegalArgumentException
2105      *          if the value of {@code millis} is negative
2106      *
2107      * @throws  InterruptedException
2108      *          if any thread has interrupted the current thread. The
2109      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2110      *          cleared when this exception is thrown.
2111      */
2112     public final void join(long millis) throws InterruptedException {
2113         if (millis &lt; 0)
2114             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2115 
2116         if (isVirtual()) {
2117             if (isAlive()) {
2118                 long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
2119                 ((VirtualThread) this).joinNanos(nanos);
2120             }
2121             return;
2122         }
2123 
2124         synchronized (this) {
2125             if (millis &gt; 0) {
2126                 if (isAlive()) {
2127                     final long startTime = System.nanoTime();
2128                     long delay = millis;
2129                     do {
2130                         wait(delay);
2131                     } while (isAlive() &amp;&amp; (delay = millis -
2132                             TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; 0);
2133                 }
2134             } else if (millis == 0) {
2135                 while (isAlive()) {
2136                     wait(0);
2137                 }
2138             }
2139         }
2140     }
2141 
2142     /**
2143      * Waits at most {@code millis} milliseconds plus
2144      * {@code nanos} nanoseconds for this thread to terminate.
2145      * If both arguments are {@code 0}, it means to wait forever.
2146      * This method returns immediately, without waiting, if the thread has not
2147      * been {@link #start() started}.
2148      *
2149      * &lt;p&gt; For non-{@link #isVirtual() virtual}, this
2150      * implementation uses a loop of {@code this.wait} calls
2151      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
2152      * conditioned on {@code this.isAlive}. As a thread terminates the
2153      * {@code this.notifyAll} method is invoked. It is recommended that
2154      * applications not use {@code wait}, {@code notify}, or
2155      * {@code notifyAll} on {@code Thread} instances.
2156      *
2157      * @param  millis
2158      *         the time to wait in milliseconds
2159      *
2160      * @param  nanos
2161      *         {@code 0-999999} additional nanoseconds to wait
2162      *
2163      * @throws  IllegalArgumentException
2164      *          if the value of {@code millis} is negative, or the value
2165      *          of {@code nanos} is not in the range {@code 0-999999}
2166      *
2167      * @throws  InterruptedException
2168      *          if any thread has interrupted the current thread. The
2169      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2170      *          cleared when this exception is thrown.
2171      */
2172     public final void join(long millis, int nanos) throws InterruptedException {
2173         if (millis &lt; 0) {
2174             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2175         }
2176 
2177         if (nanos &lt; 0 || nanos &gt; 999999) {
2178             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
2179         }
2180 
2181         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
2182             millis++;
2183         }
2184 
2185         join(millis);
2186     }
2187 
2188     /**
2189      * Waits for this thread to terminate.
2190      *
2191      * &lt;p&gt; An invocation of this method behaves in exactly the same
2192      * way as the invocation
2193      *
2194      * &lt;blockquote&gt;
2195      * {@linkplain #join(long) join}{@code (0)}
2196      * &lt;/blockquote&gt;
2197      *
2198      * @throws  InterruptedException
2199      *          if any thread has interrupted the current thread. The
2200      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2201      *          cleared when this exception is thrown.
2202      */
2203     public final void join() throws InterruptedException {
2204         join(0);
2205     }
2206 
2207     /**
2208      * Waits for this thread to terminate for up to the given waiting duration.
2209      * This method does not wait if the duration to wait is less than or equal
2210      * to zero.
2211      *
2212      * @param   duration
2213      *          the maximum duration to wait
2214      *
2215      * @return  {@code true} if the thread has terminated
2216      *
2217      * @throws  InterruptedException
2218      *          if the current thread is interrupted while waiting.
2219      *          The &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is cleared
2220      *          when this exception is thrown.
2221      *
2222      * @throws  IllegalThreadStateException
2223      *          if this thread has not been started.
2224      *
2225      * @since 99
2226      */
2227     public final boolean join(Duration duration) throws InterruptedException {
2228         Objects.requireNonNull(duration);
2229 
2230         Thread.State state = getState();
2231         if (state == State.TERMINATED)
2232             return true;
2233         if (state == State.NEW)
2234             throw new IllegalThreadStateException(&quot;Thread not started&quot;);
2235         if (duration.isZero() || duration.isNegative())
2236             return false;
2237 
2238         if (isVirtual()) {
2239             long nanos = TimeUnit.NANOSECONDS.convert(duration);
2240             return ((VirtualThread) this).joinNanos(nanos);
2241         } else {
2242             // ignore nano precision for now
2243             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
2244             join(millis);
2245             return getState() == State.TERMINATED;
2246         }
2247     }
2248 
2249     /**
2250      * Prints a stack trace of the current thread to the standard error stream.
2251      * This method is useful for debugging.
2252      */
2253     public static void dumpStack() {
2254         new Exception(&quot;Stack trace&quot;).printStackTrace();
2255     }
2256 
2257     /**
2258      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
2259      * or a user thread.
2260      * The daemon status of a virtual thread is meaningless and is not
2261      * changed by this method (the {@linkplain #isDaemon() isDaemon} method
2262      * always returns {@code true}).
2263      * The Java Virtual Machine exits when the only threads running are all
2264      * daemon threads.
2265      *
2266      * &lt;p&gt; This method must be invoked before the thread is started.
2267      *
2268      * @param  on
2269      *         if {@code true}, marks this thread as a daemon thread
2270      *
2271      * @throws  IllegalThreadStateException
2272      *          if this thread is {@linkplain #isAlive alive}
2273      *
2274      * @throws  SecurityException
2275      *          if {@link #checkAccess} determines that the current
2276      *          thread cannot modify this thread
2277      */
2278     public final void setDaemon(boolean on) {
2279         checkAccess();
2280         if (isAlive())
2281             throw new IllegalThreadStateException();
2282         daemon(on);
2283     }
2284 
2285     void daemon(boolean on) {
2286         if (!isVirtual())
2287             holder.daemon = on;
2288     }
2289 
2290     /**
2291      * Tests if this thread is a daemon thread.
2292      * The daemon status of a virtual thread is meaningless, this method
2293      * returns {@code true} if this is a virtual thread.
2294      *
2295      * @return  {@code true} if this thread is a daemon thread;
2296      *          {@code false} otherwise.
2297      * @see     #setDaemon(boolean)
2298      */
2299     public final boolean isDaemon() {
2300         if (isVirtual()) {
2301             return true;
2302         } else {
2303             return holder.daemon;
2304         }
2305     }
2306 
2307     /**
2308      * Determines if the currently running thread has permission to
2309      * modify this thread.
2310      * &lt;p&gt;
2311      * If there is a security manager, its {@code checkAccess} method
2312      * is called with this thread as its argument. This may result in
2313      * throwing a {@code SecurityException}.
2314      *
2315      * @throws  SecurityException  if the current thread is not allowed to
2316      *          access this thread.
2317      * @see        SecurityManager#checkAccess(Thread)
2318      */
2319     public final void checkAccess() {
2320         SecurityManager security = System.getSecurityManager();
2321         if (security != null) {
2322             security.checkAccess(this);
2323         }
2324     }
2325 
2326     /**
2327      * Returns a string representation of this thread. The string representation
2328      * will usually include the thread&#39;s name. The default implementation
2329      * includes the thread&#39;s name, priority, and the name of the thread group.
2330      *
2331      * @return  a string representation of this thread.
2332      */
2333     public String toString() {
2334         ThreadGroup group = getThreadGroup();
2335         if (group != null) {
2336             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2337                            group.getName() + &quot;]&quot;;
2338         } else {
2339             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2340                             &quot;&quot; + &quot;]&quot;;
2341         }
2342     }
2343 
2344     /**
2345      * Returns the context {@code ClassLoader} for this thread. The context
2346      * {@code ClassLoader} is provided by the creator of the thread for use
2347      * by code running in this thread when loading classes and resources.
2348      * If not {@linkplain #setContextClassLoader set}, the default is the
2349      * {@code ClassLoader} context of the parent thread. The context
2350      * {@code ClassLoader} of the
2351      * primordial thread is typically set to the class loader used to load the
2352      * application.
2353      *
2354      *
2355      * @return  the context {@code ClassLoader} for this thread, or {@code null}
2356      *          indicating the system class loader (or, failing that, the
2357      *          bootstrap class loader)
2358      *
2359      * @throws  SecurityException
2360      *          if a security manager is present, and the caller&#39;s class loader
2361      *          is not {@code null} and is not the same as or an ancestor of the
2362      *          context class loader, and the caller does not have the
2363      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
2364      *
2365      * @since 1.2
2366      */
2367     @CallerSensitive
2368     public ClassLoader getContextClassLoader() {
2369         if (contextClassLoader == null)
2370             return null;
2371         SecurityManager sm = System.getSecurityManager();
2372         if (sm != null) {
2373             ClassLoader.checkClassLoaderPermission(contextClassLoader,
2374                                                    Reflection.getCallerClass());
2375         }
2376         return contextClassLoader;
2377     }
2378 
2379     /**
2380      * TBD
2381      */
2382     Continuation getContinuation() {
2383         return cont;
2384     }
2385 
2386     /**
2387      * TBD
2388      */
2389     void setContinuation(Continuation cont) {
2390         this.cont = cont;
2391     }
2392 
2393     /**
2394      * Sets the context ClassLoader for this Thread. The context
2395      * ClassLoader can be set when a thread is created, and allows
2396      * the creator of the thread to provide the appropriate class loader,
2397      * through {@code getContextClassLoader}, to code running in the thread
2398      * when loading classes and resources.
2399      *
2400      * &lt;p&gt;If a security manager is present, its {@link
2401      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
2402      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
2403      * (&quot;setContextClassLoader&quot;)} permission to see if setting the context
2404      * ClassLoader is permitted.
2405      *
2406      * @param  cl
2407      *         the context ClassLoader for this Thread, or null  indicating the
2408      *         system class loader (or, failing that, the bootstrap class loader)
2409      *
2410      * @throws  SecurityException
2411      *          if the current thread cannot set the context ClassLoader
2412      *
2413      * @since 1.2
2414      */
2415     public void setContextClassLoader(ClassLoader cl) {
2416         SecurityManager sm = System.getSecurityManager();
2417         if (sm != null) {
2418             sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
2419         }
2420         contextClassLoader = cl;
2421     }
2422 
2423     /**
2424      * Returns {@code true} if and only if the current thread holds the
2425      * monitor lock on the specified object.
2426      *
2427      * &lt;p&gt;This method is designed to allow a program to assert that
2428      * the current thread already holds a specified lock:
2429      * &lt;pre&gt;
2430      *     assert Thread.holdsLock(obj);
2431      * &lt;/pre&gt;
2432      *
2433      * @param  obj the object on which to test lock ownership
2434      * @throws NullPointerException if obj is {@code null}
2435      * @return {@code true} if the current thread holds the monitor lock on
2436      *         the specified object.
2437      * @since 1.4
2438      */
2439     public static native boolean holdsLock(Object obj);
2440 
2441     private static final StackTraceElement[] EMPTY_STACK_TRACE
2442         = new StackTraceElement[0];
2443 
2444     /**
2445      * Returns an array of stack trace elements representing the stack dump
2446      * of this thread.  This method will return a zero-length array if
2447      * this thread has not started, has started but has not yet been
2448      * scheduled to run by the system, or has terminated.
2449      * If the returned array is of non-zero length then the first element of
2450      * the array represents the top of the stack, which is the most recent
2451      * method invocation in the sequence.  The last element of the array
2452      * represents the bottom of the stack, which is the least recent method
2453      * invocation in the sequence.
2454      *
2455      * &lt;p&gt;If there is a security manager, and this thread is not
2456      * the current thread, then the security manager&#39;s
2457      * {@code checkPermission} method is called with a
2458      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission
2459      * to see if it&#39;s ok to get the stack trace.
2460      *
2461      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
2462      * or more stack frames from the stack trace.  In the extreme case,
2463      * a virtual machine that has no stack trace information concerning
2464      * this thread is permitted to return a zero-length array from this
2465      * method.
2466      *
2467      * @return an array of {@code StackTraceElement},
2468      * each represents one stack frame.
2469      *
2470      * @throws SecurityException
2471      *        if a security manager exists and its
2472      *        {@code checkPermission} method doesn&#39;t allow
2473      *        getting the stack trace of thread.
2474      * @see SecurityManager#checkPermission
2475      * @see RuntimePermission
2476      * @see Throwable#getStackTrace
2477      *
2478      * @since 1.5
2479      */
2480     public StackTraceElement[] getStackTrace() {
2481         if (this != Thread.currentThread()) {
2482             // check for getStackTrace permission
2483             SecurityManager security = System.getSecurityManager();
2484             if (security != null) {
2485                 security.checkPermission(
2486                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
2487             }
2488             // optimization so we do not call into the vm for threads that
2489             // have not yet started or have terminated
2490             if (!isAlive()) {
2491                 return EMPTY_STACK_TRACE;
2492             }
2493             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
2494             StackTraceElement[] stackTrace = stackTraceArray[0];
2495             // a thread that was alive during the previous isAlive call may have
2496             // since terminated, therefore not having a stacktrace.
2497             if (stackTrace == null) {
2498                 stackTrace = EMPTY_STACK_TRACE;
2499             }
2500             return stackTrace;
2501         } else {
2502             return (new Exception()).getStackTrace();
2503         }
2504     }
2505 
2506     /**
2507      * Returns a map of stack traces for all live threads. The map does not
2508      * include virtual threads.
2509      * The map keys are threads and each map value is an array of
2510      * {@code StackTraceElement} that represents the stack dump
2511      * of the corresponding {@code Thread}.
2512      * The returned stack traces are in the format specified for
2513      * the {@link #getStackTrace getStackTrace} method.
2514      *
2515      * &lt;p&gt;The threads may be executing while this method is called.
2516      * The stack trace of each thread only represents a snapshot and
2517      * each stack trace may be obtained at different time.  A zero-length
2518      * array will be returned in the map value if the virtual machine has
2519      * no stack trace information about a thread.
2520      *
2521      * &lt;p&gt;If there is a security manager, then the security manager&#39;s
2522      * {@code checkPermission} method is called with a
2523      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission as well as
2524      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission
2525      * to see if it is ok to get the stack trace of all threads.
2526      *
2527      * @return a {@code Map} from {@code Thread} to an array of
2528      * {@code StackTraceElement} that represents the stack trace of
2529      * the corresponding thread.
2530      *
2531      * @throws SecurityException
2532      *        if a security manager exists and its
2533      *        {@code checkPermission} method doesn&#39;t allow
2534      *        getting the stack trace of thread.
2535      * @see #getStackTrace
2536      * @see SecurityManager#checkPermission
2537      * @see RuntimePermission
2538      * @see Throwable#getStackTrace
2539      *
2540      * @since 1.5
2541      */
2542     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
2543         // check for getStackTrace permission
2544         SecurityManager security = System.getSecurityManager();
2545         if (security != null) {
2546             security.checkPermission(
2547                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
2548             security.checkPermission(
2549                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
2550         }
2551 
2552         // Get a snapshot of the list of all threads
2553         Thread[] threads = getThreads();
2554         StackTraceElement[][] traces = dumpThreads(threads);
2555         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
2556         for (int i = 0; i &lt; threads.length; i++) {
2557             StackTraceElement[] stackTrace = traces[i];
2558             if (stackTrace != null) {
2559                 m.put(threads[i], stackTrace);
2560             }
2561             // else terminated so we don&#39;t put it in the map
2562         }
2563         return m;
2564     }
2565 
2566     /** cache of subclass security audit results */
2567     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
2568      * release */
2569     private static class Caches {
2570         /** cache of subclass security audit results */
2571         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
2572             new ConcurrentHashMap&lt;&gt;();
2573 
2574         /** queue for WeakReferences to audited subclasses */
2575         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
2576             new ReferenceQueue&lt;&gt;();
2577     }
2578 
2579     /**
2580      * Verifies that this (possibly subclass) instance can be constructed
2581      * without violating security constraints: the subclass must not override
2582      * security-sensitive non-final methods, or else the
2583      * &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.
2584      */
2585     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
2586         if (cl == Thread.class)
2587             return false;
2588 
2589         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
2590         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
2591         Boolean result = Caches.subclassAudits.get(key);
2592         if (result == null) {
2593             result = Boolean.valueOf(auditSubclass(cl));
2594             Caches.subclassAudits.putIfAbsent(key, result);
2595         }
2596 
2597         return result.booleanValue();
2598     }
2599 
2600     /**
2601      * Performs reflective checks on given subclass to verify that it doesn&#39;t
2602      * override security-sensitive non-final methods.  Returns true if the
2603      * subclass overrides any of the methods, false otherwise.
2604      */
2605     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
2606         Boolean result = AccessController.doPrivileged(
2607             new PrivilegedAction&lt;&gt;() {
2608                 public Boolean run() {
2609                     for (Class&lt;?&gt; cl = subcl;
2610                          cl != Thread.class;
2611                          cl = cl.getSuperclass())
2612                     {
2613                         try {
2614                             cl.getDeclaredMethod(&quot;getContextClassLoader&quot;, new Class&lt;?&gt;[0]);
2615                             return Boolean.TRUE;
2616                         } catch (NoSuchMethodException ex) {
2617                         }
2618                         try {
2619                             Class&lt;?&gt;[] params = {ClassLoader.class};
2620                             cl.getDeclaredMethod(&quot;setContextClassLoader&quot;, params);
2621                             return Boolean.TRUE;
2622                         } catch (NoSuchMethodException ex) {
2623                         }
2624                     }
2625                     return Boolean.FALSE;
2626                 }
2627             }
2628         );
2629         return result.booleanValue();
2630     }
2631 
2632     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
2633     private static native Thread[] getThreads();
2634 
2635     /**
2636      * Returns the identifier of this Thread.  The thread ID is a positive
2637      * {@code long} number generated when this thread was created.
2638      * The thread ID is unique and remains unchanged during its lifetime.
2639      * When a thread is terminated, this thread ID may be reused.
2640      *
2641      * @return this thread&#39;s ID.
2642      * @since 1.5
2643      */
2644     public long getId() {
2645         return tid;
2646     }
2647 
2648     /**
2649      * A thread state.  A thread can be in one of the following states:
2650      * &lt;ul&gt;
2651      * &lt;li&gt;{@link #NEW}&lt;br&gt;
2652      *     A thread that has not yet started is in this state.
2653      *     &lt;/li&gt;
2654      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
2655      *     A thread executing in the Java virtual machine is in this state.
2656      *     &lt;/li&gt;
2657      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
2658      *     A thread that is blocked waiting for a monitor lock
2659      *     is in this state.
2660      *     &lt;/li&gt;
2661      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
2662      *     A thread that is waiting indefinitely for another thread to
2663      *     perform a particular action is in this state.
2664      *     &lt;/li&gt;
2665      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
2666      *     A thread that is waiting for another thread to perform an action
2667      *     for up to a specified waiting time is in this state.
2668      *     &lt;/li&gt;
2669      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
2670      *     A thread that has exited is in this state.
2671      *     &lt;/li&gt;
2672      * &lt;/ul&gt;
2673      *
2674      * &lt;p&gt;
2675      * A thread can be in only one state at a given point in time.
2676      * These states are virtual machine states which do not reflect
2677      * any operating system thread states.
2678      *
2679      * @since   1.5
2680      * @see #getState
2681      */
2682     public enum State {
2683         /**
2684          * Thread state for a thread which has not yet started.
2685          */
2686         NEW,
2687 
2688         /**
2689          * Thread state for a runnable thread.  A thread in the runnable
2690          * state is executing in the Java virtual machine but it may
2691          * be waiting for other resources from the operating system
2692          * such as processor.
2693          */
2694         RUNNABLE,
2695 
2696         /**
2697          * Thread state for a thread blocked waiting for a monitor lock.
2698          * A thread in the blocked state is waiting for a monitor lock
2699          * to enter a synchronized block/method or
2700          * reenter a synchronized block/method after calling
2701          * {@link Object#wait() Object.wait}.
2702          */
2703         BLOCKED,
2704 
2705         /**
2706          * Thread state for a waiting thread.
2707          * A thread is in the waiting state due to calling one of the
2708          * following methods:
2709          * &lt;ul&gt;
2710          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
2711          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
2712          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
2713          * &lt;/ul&gt;
2714          *
2715          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
2716          * perform a particular action.
2717          *
2718          * For example, a thread that has called {@code Object.wait()}
2719          * on an object is waiting for another thread to call
2720          * {@code Object.notify()} or {@code Object.notifyAll()} on
2721          * that object. A thread that has called {@code Thread.join()}
2722          * is waiting for a specified thread to terminate.
2723          */
2724         WAITING,
2725 
2726         /**
2727          * Thread state for a waiting thread with a specified waiting time.
2728          * A thread is in the timed waiting state due to calling one of
2729          * the following methods with a specified positive waiting time:
2730          * &lt;ul&gt;
2731          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
2732          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
2733          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
2734          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
2735          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
2736          * &lt;/ul&gt;
2737          */
2738         TIMED_WAITING,
2739 
2740         /**
2741          * Thread state for a terminated thread.
2742          * The thread has completed execution.
2743          */
2744         TERMINATED;
2745     }
2746 
2747     /**
2748      * Returns the state of this thread.
2749      * This method is designed for use in monitoring of the system state,
2750      * not for synchronization control.
2751      *
2752      * @return this thread&#39;s state.
2753      * @since 1.5
2754      */
2755     public State getState() {
2756         return threadState();
2757     }
2758 
2759     /**
2760      * Returns the state of this thread.
2761      *
2762      * @apiNote For VirtualThread use as getState may be overridden and run
2763      * arbitrary code.
2764      */
2765     State threadState() {
2766         return jdk.internal.misc.VM.toThreadState(holder.threadStatus);
2767     }
2768 
2769     // Added in JSR-166
2770 
2771     /**
2772      * Interface for handlers invoked when a {@code Thread} abruptly
2773      * terminates due to an uncaught exception.
2774      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
2775      * the Java Virtual Machine will query the thread for its
2776      * {@code UncaughtExceptionHandler} using
2777      * {@link #getUncaughtExceptionHandler} and will invoke the handler&#39;s
2778      * {@code uncaughtException} method, passing the thread and the
2779      * exception as arguments.
2780      * If a thread has not had its {@code UncaughtExceptionHandler}
2781      * explicitly set, then its {@code ThreadGroup} object acts as its
2782      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
2783      * has no
2784      * special requirements for dealing with the exception, it can forward
2785      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
2786      * default uncaught exception handler}.
2787      *
2788      * @see #setDefaultUncaughtExceptionHandler
2789      * @see #setUncaughtExceptionHandler
2790      * @see ThreadGroup#uncaughtException
2791      * @since 1.5
2792      */
2793     @FunctionalInterface
2794     public interface UncaughtExceptionHandler {
2795         /**
2796          * Method invoked when the given thread terminates due to the
2797          * given uncaught exception.
2798          * &lt;p&gt;Any exception thrown by this method will be ignored by the
2799          * Java Virtual Machine.
2800          * @param t the thread
2801          * @param e the exception
2802          */
2803         void uncaughtException(Thread t, Throwable e);
2804     }
2805 
2806     // null unless explicitly set
2807     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
2808 
2809     // null unless explicitly set
2810     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
2811 
2812     /**
2813      * Set the default handler invoked when a thread abruptly terminates
2814      * due to an uncaught exception, and no other handler has been defined
2815      * for that thread.
2816      *
2817      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
2818      * by the thread&#39;s {@link ThreadGroup} object and finally by the default
2819      * uncaught exception handler. If the thread does not have an explicit
2820      * uncaught exception handler set, and the thread&#39;s thread group
2821      * (including parent thread groups)  does not specialize its
2822      * {@code uncaughtException} method, then the default handler&#39;s
2823      * {@code uncaughtException} method will be invoked.
2824      * &lt;p&gt;By setting the default uncaught exception handler, an application
2825      * can change the way in which uncaught exceptions are handled (such as
2826      * logging to a specific device, or file) for those threads that would
2827      * already accept whatever &amp;quot;default&amp;quot; behavior the system
2828      * provided.
2829      *
2830      * &lt;p&gt;Note that the default uncaught exception handler should not usually
2831      * defer to the thread&#39;s {@code ThreadGroup} object, as that could cause
2832      * infinite recursion.
2833      *
2834      * @param eh the object to use as the default uncaught exception handler.
2835      * If {@code null} then there is no default handler.
2836      *
2837      * @throws SecurityException if a security manager is present and it denies
2838      *         {@link RuntimePermission}{@code (&quot;setDefaultUncaughtExceptionHandler&quot;)}
2839      *
2840      * @see #setUncaughtExceptionHandler
2841      * @see #getUncaughtExceptionHandler
2842      * @see ThreadGroup#uncaughtException
2843      * @since 1.5
2844      */
2845     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2846         SecurityManager sm = System.getSecurityManager();
2847         if (sm != null) {
2848             sm.checkPermission(
2849                 new RuntimePermission(&quot;setDefaultUncaughtExceptionHandler&quot;)
2850                     );
2851         }
2852 
2853          defaultUncaughtExceptionHandler = eh;
2854      }
2855 
2856     /**
2857      * Returns the default handler invoked when a thread abruptly terminates
2858      * due to an uncaught exception. If the returned value is {@code null},
2859      * there is no default.
2860      * @since 1.5
2861      * @see #setDefaultUncaughtExceptionHandler
2862      * @return the default uncaught exception handler for all threads
2863      */
2864     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
2865         return defaultUncaughtExceptionHandler;
2866     }
2867 
2868     /**
2869      * Returns the handler invoked when this thread abruptly terminates
2870      * due to an uncaught exception. If this thread has not had an
2871      * uncaught exception handler explicitly set then this thread&#39;s
2872      * {@code ThreadGroup} object is returned, unless this thread
2873      * has terminated, in which case {@code null} is returned.
2874      * @since 1.5
2875      * @return the uncaught exception handler for this thread
2876      */
2877     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
2878         return uncaughtExceptionHandler != null ?
2879             uncaughtExceptionHandler : getThreadGroup();
2880     }
2881 
2882     /**
2883      * Set the handler invoked when this thread abruptly terminates
2884      * due to an uncaught exception.
2885      * &lt;p&gt;A thread can take full control of how it responds to uncaught
2886      * exceptions by having its uncaught exception handler explicitly set.
2887      * If no such handler is set then the thread&#39;s {@code ThreadGroup}
2888      * object acts as its handler.
2889      * @param eh the object to use as this thread&#39;s uncaught exception
2890      * handler. If {@code null} then this thread has no explicit handler.
2891      * @throws  SecurityException  if the current thread is not allowed to
2892      *          modify this thread.
2893      * @see #setDefaultUncaughtExceptionHandler
2894      * @see ThreadGroup#uncaughtException
2895      * @since 1.5
2896      */
2897     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2898         checkAccess();
2899         uncaughtExceptionHandler(eh);
2900     }
2901 
2902     private void uncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2903         uncaughtExceptionHandler = eh;
2904     }
2905 
2906     /**
2907      * Dispatch an uncaught exception to the handler. This method is
2908      * called when a thread terminates with an exception.
2909      */
2910     void dispatchUncaughtException(Throwable e) {
2911         getUncaughtExceptionHandler().uncaughtException(this, e);
2912     }
2913 
2914     /**
2915      * Removes from the specified map any keys that have been enqueued
2916      * on the specified reference queue.
2917      */
2918     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2919                              ConcurrentMap&lt;? extends
2920                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2921     {
2922         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2923         while((ref = queue.poll()) != null) {
2924             map.remove(ref);
2925         }
2926     }
2927 
2928     /**
2929      *  Weak key for Class objects.
2930      **/
2931     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2932         /**
2933          * saved value of the referent&#39;s identity hash code, to maintain
2934          * a consistent hash code after the referent has been cleared
2935          */
2936         private final int hash;
2937 
2938         /**
2939          * Create a new WeakClassKey to the given object, registered
2940          * with a queue.
2941          */
2942         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2943             super(cl, refQueue);
2944             hash = System.identityHashCode(cl);
2945         }
2946 
2947         /**
2948          * Returns the identity hash code of the original referent.
2949          */
2950         @Override
2951         public int hashCode() {
2952             return hash;
2953         }
2954 
2955         /**
2956          * Returns true if the given object is this identical
2957          * WeakClassKey instance, or, if this object&#39;s referent has not
2958          * been cleared, if the given object is another WeakClassKey
2959          * instance with the identical non-null referent as this one.
2960          */
2961         @Override
2962         public boolean equals(Object obj) {
2963             if (obj == this)
2964                 return true;
2965 
2966             if (obj instanceof WeakClassKey) {
2967                 Object referent = get();
2968                 return (referent != null) &amp;&amp;
2969                        (referent == ((WeakClassKey) obj).get());
2970             } else {
2971                 return false;
2972             }
2973         }
2974     }
2975 
2976     private static class VirtualThreads {
2977         static final ThreadGroup THREAD_GROUP = threadGroup();
2978         static final AccessControlContext ACCESS_CONTROL_CONTEXT = accessControlContext();
2979 
2980         /**
2981          * The thread group for virtual threads.
2982          */
2983         private static ThreadGroup threadGroup() {
2984             return AccessController.doPrivileged(new PrivilegedAction&lt;ThreadGroup&gt;() {
2985                 public ThreadGroup run() {
2986                     ThreadGroup group = Thread.currentCarrierThread().getThreadGroup();
2987                     for (ThreadGroup p; (p = group.getParent()) != null; )
2988                         group = p;
2989                     var newGroup = new ThreadGroup(group, &quot;VirtualThreads&quot;, true);
2990                     newGroup.setDaemon(true);
2991                     return newGroup;
2992                 }});
2993         }
2994 
2995         /**
2996          * Return an AccessControlContext that doesn&#39;t support any permissions.
2997          */
2998         private static AccessControlContext accessControlContext() {
2999             return new AccessControlContext(new ProtectionDomain[] {
3000                 new ProtectionDomain(null, null)
3001             });
3002         }
3003     }
3004 
3005     // The following three initially uninitialized fields are exclusively
3006     // managed by class java.util.concurrent.ThreadLocalRandom. These
3007     // fields are used to build the high-performance PRNGs in the
3008     // concurrent code. Upcoming changes in the concurrent code avoid
3009     // needing to use @Contented here.
3010 
3011     /** The current seed for a ThreadLocalRandom */
3012     long threadLocalRandomSeed;
3013 
3014     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
3015     int threadLocalRandomProbe;
3016 
3017     /** Secondary seed isolated from public ThreadLocalRandom sequence */
3018     int threadLocalRandomSecondarySeed;
3019 
3020     /* Some private helper methods */
3021     private native void setPriority0(int newPriority);
3022     private native void stop0(Object o);
3023     private native void suspend0();
3024     private native void resume0();
3025     private native void interrupt0();
3026     private static native void clearInterruptEvent();
3027     private native void setNativeName(String name);
3028 }
    </pre>
  </body>
</html>