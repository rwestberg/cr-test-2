<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.invoke.VarHandle;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.WeakReference;
  33 import java.security.AccessController;
  34 import java.security.AccessControlContext;
  35 import java.security.PrivilegedAction;
  36 import java.security.ProtectionDomain;
  37 import java.time.Duration;
  38 import java.util.Map;
  39 import java.util.HashMap;
  40 import java.util.Objects;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.concurrent.Executor;
  44 import java.util.concurrent.ThreadFactory;
  45 import java.util.concurrent.TimeUnit;
  46 import java.util.concurrent.locks.LockSupport;
  47 
  48 import jdk.internal.misc.TerminatingThreadLocal;
  49 import jdk.internal.misc.Unsafe;
  50 import sun.nio.ch.Interruptible;
  51 import jdk.internal.reflect.CallerSensitive;
  52 import jdk.internal.reflect.Reflection;
  53 import sun.security.util.SecurityConstants;
  54 import jdk.internal.HotSpotIntrinsicCandidate;
  55 
  56 /**
  57  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  58  * virtual machine allows an application to have multiple threads of
  59  * execution running concurrently.
  60  *
  61  * &lt;p&gt; {@code Thread} supports the creation of threads that are scheduled by the
  62  * operating system. These threads are sometimes known as &lt;i&gt;kernel threads&lt;/i&gt;
  63  * or &lt;i&gt;heavyweight threads&lt;/i&gt; and will usually have a large stack and other
  64  * resources that are maintained by the operating system. Kernel threads are
  65  * suitable for executing all tasks but they are a limited resource.
  66  *
  67  * &lt;p&gt; {@code Thread} also supports the creation of &lt;i&gt;virtual threads&lt;/i&gt; that
  68  * are scheduled by the Java virtual machine rather than the operating system.
  69  * Virtual threads will typically require few resources and a single Java virtual
  70  * machine may support millions of virtual threads. Virtual threads are suitable
  71  * for executing tasks that spend most of the time blocked, often waiting for
  72  * synchronous blocking I/O operations to complete.
  73  * Virtual threads execute on a pool of &lt;i&gt;carrier threads&lt;/i&gt;, essentially
  74  * a pool of kernel threads that have been created and allocated to support the
  75  * execution of virtual threads. Locking and I/O operations are the &lt;i&gt;scheduling
  76  * points&lt;/i&gt; where a carrier thread is re-scheduled from one virtual thread to
  77  * another. Code executing in virtual threads will usually not be aware of the
  78  * underlying carrier thread, and in particular, the {@linkplain Thread#currentThread()}
  79  * method, to obtain a reference to the &lt;i&gt;current thread&lt;/i&gt;, will return the
  80  * {@code Thread} object for the virtual thread.
  81  *
  82  * &lt;p&gt; {@code Thread} defines factory methods, and a {@linkplain Builder} API,
  83  * for creating kernel or virtual threads. It also defines (for compatibility and
  84  * customization reasons) constructors for creating kernel threads. Newer code
  85  * is encouraged to use the factory methods or the builder rather than the constructors.
  86  *
  87  * &lt;p&gt; Kernel threads are designated &lt;i&gt;daemon&lt;/i&gt; or &lt;i&gt;non-daemon&lt;/i&gt; threads.
  88  * When the Java virtual machine starts up, there is usually one non-daemon
  89  * thread (the thread that typically calls the applications&#39;s {@code main} method).
  90  * The Java virtual machine terminates when all non-daemon threads have terminated.
  91  * The Java virtual machine can also be terminated by invoking the
  92  * {@linkplain Runtime#exit(int)} method, in which case it will terminate even
  93  * if there are many non-daemon threads still running. The daemon status of
  94  * virtual threads is meaningless and have no influence on when the Java virtual
  95  * machine terminates.
  96  *
  97  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a constructor
  98  * or method in this class will cause a {@link NullPointerException} to be
  99  * thrown.
 100  *
 101  * @author  unascribed
 102  * @see     Runtime#exit(int)
 103  * @since   1.0
 104  */
 105 public class Thread implements Runnable {
 106     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 107     private static native void registerNatives();
 108     static {
 109         registerNatives();
 110     }
 111 
 112     /* Reserved for exclusive use by the JVM, TBD: move to FieldHolder */
 113     private long eetop;
 114 
 115     // holds fields for kernel threads
 116     private static class FieldHolder {
 117         final ThreadGroup group;
 118         final Runnable task;
 119         final long stackSize;
 120         int priority;
 121         boolean daemon;
 122         volatile int threadStatus;
 123         boolean stillborn;
 124 
 125         FieldHolder(ThreadGroup group,
 126                     Runnable task,
 127                     long stackSize,
 128                     int priority,
 129                     boolean daemon) {
 130             this.group = group;
 131             this.task = task;
 132             this.stackSize = stackSize;
 133             this.priority = priority;
 134             this.daemon = daemon;
 135         }
 136     }
 137     private final FieldHolder holder;
 138     
 139     // interrupt status (read/written by VM)
 140     volatile boolean interrupted;
 141 
 142     // thread name
 143     private volatile String name;
 144 
 145     // thread id
 146     private final long tid;
 147 
 148     // context ClassLoader
 149     private ClassLoader contextClassLoader;
 150 
 151     // inherited AccessControlContext, TBD: move this to FieldHolder
 152     private AccessControlContext inheritedAccessControlContext;
 153 
 154     /* For autonumbering anonymous threads. */
 155     private static int threadInitNumber;
 156     private static synchronized int nextThreadNum() {
 157         return threadInitNumber++;
 158     }
 159 
 160     /* ThreadLocal values pertaining to this thread. This map is maintained
 161      * by the ThreadLocal class. */
 162     ThreadLocal.ThreadLocalMap threadLocals = null;
 163 
 164     /*
 165      * InheritableThreadLocal values pertaining to this thread. This map is
 166      * maintained by the InheritableThreadLocal class.
 167      */
 168     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 169 
 170     /**
 171      * Helper class to generate unique thread identifiers. The identifiers start
 172      * at 2 as this class cannot be used during early startup to generate the
 173      * identifier for the primordial thread.
 174      */
 175     private static class ThreadIdentifiers {
 176         private static final Unsafe U = Unsafe.getUnsafe();
 177         private static final long nextTidOffset =
 178             U.objectFieldOffset(ThreadIdentifiers.class, &quot;nextTid&quot;);
 179         private static volatile long nextTid = 2;
 180         private static long next() {
 181             return U.getAndAddLong(ThreadIdentifiers.class, nextTidOffset, 1);
 182         }
 183     }
 184 
 185     /*
 186      * Lock object for thread interrupt.
 187      */
 188     final Object interruptLock = new Object();
 189 
 190     /**
 191      * The argument supplied to the current call to
 192      * java.util.concurrent.locks.LockSupport.park.
 193      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 194      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 195      */
 196     private volatile Object parkBlocker;
 197 
 198     /* The object in which this thread is blocked in an interruptible I/O
 199      * operation, if any.  The blocker&#39;s interrupt method should be invoked
 200      * after setting this thread&#39;s interrupt status.
 201      */
 202     volatile Interruptible nioBlocker;
 203 
 204     /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
 205      * from java.nio code
 206      */
 207     static void blockedOn(Interruptible b) {
 208         Thread me = Thread.currentThread();
 209         synchronized (me.interruptLock) {
 210             me.nioBlocker = b;
 211         }
 212     }
 213 
 214     /**
 215      * The minimum priority that a thread can have.
 216      */
 217     public static final int MIN_PRIORITY = 1;
 218 
 219    /**
 220      * The default priority that is assigned to a thread.
 221      */
 222     public static final int NORM_PRIORITY = 5;
 223 
 224     /**
 225      * The maximum priority that a thread can have.
 226      */
 227     public static final int MAX_PRIORITY = 10;
 228 
 229     // current inner-most continuation
 230     private Continuation cont;
 231 
 232     // the virtual thread mounted on this thread
 233     private VirtualThread vthread;
 234 
 235     /**
 236      * Sets the virtual thread that is currently mounted on this thread.
 237      */
 238     void setVirtualThread(VirtualThread vthread) {
 239         // assert this == currentThread0();
 240         this.vthread = vthread;
 241     }
 242 
 243     /**
 244      * Returns the virtual thread that is currently mounted on this thread.
 245      */
 246     VirtualThread getVirtualThread() {
 247         // assert this == currentThread0();
 248         return vthread;
 249     }
 250 
 251     /**
 252      * Returns the Thread object for the current thread.
 253      *
 254      * @return  the current thread
 255      */
 256     public static Thread currentThread() {
 257         Thread t = currentThread0();
 258         VirtualThread vthread = t.vthread;
 259         if (vthread != null) {
 260             return vthread;
 261         } else {
 262             return t;
 263         }
 264     }
 265 
 266     /**
 267      * Returns the current carrier thread.
 268      */
 269     static Thread currentCarrierThread() {
 270         return currentThread0();
 271     }
 272 
 273     @HotSpotIntrinsicCandidate
 274     private static native Thread currentThread0();
 275 
 276     /**
 277      * A hint to the scheduler that the current thread is willing to yield
 278      * its current use of a processor. The scheduler is free to ignore this
 279      * hint.
 280      *
 281      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 282      * between threads that would otherwise over-utilise a CPU. Its use
 283      * should be combined with detailed profiling and benchmarking to
 284      * ensure that it actually has the desired effect.
 285      *
 286      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 287      * for debugging or testing purposes, where it may help to reproduce
 288      * bugs due to race conditions. It may also be useful when designing
 289      * concurrency control constructs such as the ones in the
 290      * {@link java.util.concurrent.locks} package.
 291      */
 292     public static void yield() {
 293         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 294         if (vthread != null) {
 295             vthread.tryYield();
 296         } else {
 297             yield0();
 298         }
 299     }
 300     private static native void yield0();
 301 
 302     /**
 303      * Causes the currently executing thread to sleep (temporarily cease
 304      * execution) for the specified number of milliseconds, subject to
 305      * the precision and accuracy of system timers and schedulers. The thread
 306      * does not lose ownership of any monitors.
 307      *
 308      * @param  millis
 309      *         the length of time to sleep in milliseconds
 310      *
 311      * @throws  IllegalArgumentException
 312      *          if the value of {@code millis} is negative
 313      *
 314      * @throws  InterruptedException
 315      *          if any thread has interrupted the current thread. The
 316      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 317      *          cleared when this exception is thrown.
 318      */
 319     public static void sleep(long millis) throws InterruptedException {
 320         if (millis &lt; 0) {
 321             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 322         }
 323         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 324         if (vthread != null) {
 325             vthread.sleepNanos(TimeUnit.MILLISECONDS.toNanos(millis));
 326         } else {
 327             sleep0(millis);
 328         }
 329     }
 330     private static native void sleep0(long millis) throws InterruptedException;
 331 
 332     /**
 333      * Causes the currently executing thread to sleep (temporarily cease
 334      * execution) for the specified number of milliseconds plus the specified
 335      * number of nanoseconds, subject to the precision and accuracy of system
 336      * timers and schedulers. The thread does not lose ownership of any
 337      * monitors.
 338      *
 339      * @param  millis
 340      *         the length of time to sleep in milliseconds
 341      *
 342      * @param  nanos
 343      *         {@code 0-999999} additional nanoseconds to sleep
 344      *
 345      * @throws  IllegalArgumentException
 346      *          if the value of {@code millis} is negative, or the value of
 347      *          {@code nanos} is not in the range {@code 0-999999}
 348      *
 349      * @throws  InterruptedException
 350      *          if any thread has interrupted the current thread. The
 351      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 352      *          cleared when this exception is thrown.
 353      */
 354     public static void sleep(long millis, int nanos) throws InterruptedException {
 355         if (millis &lt; 0) {
 356             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 357         }
 358 
 359         if (nanos &lt; 0 || nanos &gt; 999999) {
 360             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
 361         }
 362 
 363         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
 364             millis++;
 365         }
 366 
 367         sleep(millis);
 368     }
 369 
 370     /**
 371      * Causes the currently executing thread to sleep (temporarily cease
 372      * execution) for the specified duration, subject to the precision and
 373      * accuracy of system timers and schedulers. This method is a no-op if
 374      * the duration is less than zero.
 375      *
 376      * @param  duration
 377      *         the duration to sleep
 378      *
 379      * @throws  InterruptedException
 380      *          if the current thread is interrupted while sleeping. The
 381      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 382      *          cleared when this exception is thrown.
 383      *
 384      * @since 99
 385      */
 386     public static void sleep(Duration duration) throws InterruptedException {
 387         if (!duration.isNegative()) {
 388             // ignore nano precision for now
 389             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
 390             sleep(millis);
 391         }
 392     }
 393 
 394     /**
 395      * Indicates that the caller is momentarily unable to progress, until the
 396      * occurrence of one or more actions on the part of other activities. By
 397      * invoking this method within each iteration of a spin-wait loop construct,
 398      * the calling thread indicates to the runtime that it is busy-waiting.
 399      * The runtime may take action to improve the performance of invoking
 400      * spin-wait loop constructions.
 401      *
 402      * @apiNote
 403      * As an example consider a method in a class that spins in a loop until
 404      * some flag is set outside of that method. A call to the {@code onSpinWait}
 405      * method should be placed inside the spin loop.
 406      * &lt;pre&gt;{@code
 407      *     class EventHandler {
 408      *         volatile boolean eventNotificationNotReceived;
 409      *         void waitForEventAndHandleIt() {
 410      *             while ( eventNotificationNotReceived ) {
 411      *                 java.lang.Thread.onSpinWait();
 412      *             }
 413      *             readAndProcessEvent();
 414      *         }
 415      *
 416      *         void readAndProcessEvent() {
 417      *             // Read event from some source and process it
 418      *              . . .
 419      *         }
 420      *     }
 421      * }&lt;/pre&gt;
 422      * &lt;p&gt;
 423      * The code above would remain correct even if the {@code onSpinWait}
 424      * method was not called at all. However on some architectures the Java
 425      * Virtual Machine may issue the processor instructions to address such
 426      * code patterns in a more beneficial way.
 427      *
 428      * @since 9
 429      */
 430     @HotSpotIntrinsicCandidate
 431     public static void onSpinWait() {}
 432 
 433     /**
 434      * Returns the context class loader to inherit from the given parent thread
 435      */
 436     private static ClassLoader contextClassLoader(Thread parent) {
 437         SecurityManager sm = System.getSecurityManager();
 438         if (sm == null || isCCLOverridden(parent.getClass())) {
 439             return parent.getContextClassLoader();
 440         } else {
 441             return parent.contextClassLoader;
 442         }
 443     }
 444 
 445     /**
 446      * Initializes a kernel Thread.
 447      *
 448      * @param g the Thread group
 449      * @param name the name of the new Thread
 450      * @param characteristics thread characteristics
 451      * @param task the object whose run() method gets called
 452 
 453      * @param stackSize the desired stack size for the new thread, or
 454      *        zero to indicate that this parameter is to be ignored.
 455      * @param acc the AccessControlContext to inherit, or
 456      *            AccessController.getContext() if null
 457      * @throws IllegalArgumentException if invalid characteristics are specified
 458      */
 459     private Thread(ThreadGroup g, String name, int characteristics, Runnable task,
 460                    long stackSize, AccessControlContext acc) {
 461         if (name == null) {
 462             throw new NullPointerException(&quot;name cannot be null&quot;);
 463         }
 464         checkCharacteristics(characteristics);
 465 
 466         Thread parent = currentThread();
 467         boolean primordial = (parent == this);
 468 
 469         SecurityManager security = System.getSecurityManager();
 470         if (g == null) {
 471             /* Determine if it&#39;s an applet or not */
 472 
 473             /* If there is a security manager, ask the security manager
 474                what to do. */
 475             if (security != null) {
 476                 g = security.getThreadGroup();
 477             }
 478 
 479             /* If the security manager doesn&#39;t have a strong opinion
 480                on the matter, use the parent thread group. */
 481             if (g == null) {
 482                 g = parent.getThreadGroup();
 483             }
 484         }
 485 
 486         /* checkAccess regardless of whether or not threadgroup is
 487            explicitly passed in. */
 488         g.checkAccess();
 489 
 490         /*
 491          * Do we have the required permissions?
 492          */
 493         if (security != null) {
 494             if (isCCLOverridden(getClass())) {
 495                 security.checkPermission(
 496                         SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
 497             }
 498         }
 499 
 500         g.addUnstarted();
 501 
 502         this.name = name;
 503         this.tid = primordial ? 1 : ThreadIdentifiers.next();
 504         this.contextClassLoader = contextClassLoader(parent);
 505         this.inheritedAccessControlContext = (acc != null) ? acc : AccessController.getContext();
 506 
 507         // thread locals
 508         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 509             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 510             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 511         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 512             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 513             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 514                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 515             }
 516         }
 517 
 518         int priority;
 519         boolean daemon;
 520         if (primordial) {
 521             // primordial or attached thread
 522             priority = NORM_PRIORITY;
 523             daemon = false;
 524         } else {
 525             priority = parent.getPriority();
 526             daemon = parent.isDaemon();
 527         }
 528         this.holder = new FieldHolder(g, task, stackSize, priority, daemon);
 529     }
 530 
 531     /**
 532      * Initializes a virtual Thread.
 533      *
 534      * @param name thread name, can be null
 535      * @param characteristics thread characteristics
 536      * @throws IllegalArgumentException if invalid characteristics are specified
 537      */
 538     Thread(String name, int characteristics) {
 539         checkCharacteristics(characteristics);
 540 
 541         Thread parent = currentThread();
 542 
 543         this.name = (name != null) ? name : &quot;&lt;unnamed&gt;&quot;;
 544         this.tid = ThreadIdentifiers.next();
 545         this.contextClassLoader = contextClassLoader(parent);
 546         this.inheritedAccessControlContext = VirtualThreads.ACCESS_CONTROL_CONTEXT;
 547 
 548         // thread locals
 549         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 550             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 551             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 552         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 553             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 554             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 555                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 556             }
 557         }
 558 
 559         // no additional fields
 560         this.holder = null;
 561     }
 562 
 563     /**
 564      * Returns a builder for creating {@code Thread} or {@code ThreadFactory} objects.
 565      *
 566      * @apiNote The following are examples using the builder:
 567      *
 568      * &lt;pre&gt;{@code
 569      *   // Create a daemon thread that is scheduled by the operating system
 570      *   Thread thread = Thread.builder()
 571      *                 .name(&quot;duke&quot;)
 572      *                 .daemon(true)
 573      *                 .priority(Thread.NORM_PRIORITY)
 574      *                 .inheritThreadLocals()
 575      *                 .task(...)
 576      *                 .build();
 577      *
 578      *   // A ThreadFactory that creates daemon threads named &quot;worker-0&quot;, &quot;worker-1&quot;, ...
 579      *   ThreadFactory factory = Thread.builder().daemon(true).name(&quot;worker-&quot;, 0).factory();
 580      *
 581      *   // Create an unnamed virtual thread
 582      *   Thread thread1 = Thread.builder().virtual().task(...).build();
 583      *
 584      *   // Create a named virtual thread
 585      *   Thread thread2 = Thread.builder().virtual().name(&quot;duke&quot;).task(...).build();
 586      *
 587      *   // Create and start a virtual thread
 588      *   Thread thread = Thread.builder().virtual().task(...).start();
 589      *
 590      *   // A ThreadFactory that creates virtual threads
 591      *   ThreadFactory factory = Thread.builder().virtual().factory();
 592      *
 593      *   // A ThreadFactory that creates virtual threads and uses a custom scheduler
 594      *   Executor scheduler = ...
 595      *   ThreadFactory factory = Thread.builder().virtual(scheduler).factory();
 596      * }&lt;/pre&gt;
 597      *
 598      * @return A builder for creating {@code Thread} or {@code ThreadFactory} objects.
 599      *
 600      * @since 99
 601      */
 602     public static Builder builder() {
 603         return new BuilderImpl();
 604     }
 605 
 606     /**
 607      * A mutable builder for a {@link Thread} or {@link ThreadFactory}.
 608      *
 609      * &lt;p&gt; {@code Builder} defines methods to set the {@code Thread} characteristics
 610      * and features. Once set, a {@code Thread} or {@code ThreadFactory} can be
 611      * created with the following methods:
 612      *
 613      * &lt;ul&gt;
 614      *     &lt;li&gt; The {@linkplain #build() build} method creates an unstarted {@code Thread}.
 615      *     &lt;li&gt; The {@linkplain #start() start} method creates and starts a {@code Thread}.
 616      *     &lt;li&gt; The {@linkplain #factory() factory} method creates a {@code ThreadFactory}.
 617      * &lt;/ul&gt;
 618      *
 619      * &lt;p&gt; A {@code Builder} is not thread safe. The {@code ThreadFactory}
 620      * returned by the builder&#39;s {@code factory() method} is thread safe.
 621      *
 622      * &lt;p&gt; Unless otherwise specified, passing a null argument to a method in
 623      * this interface causes a {@code NullPointerException} to be thrown.
 624      *
 625      * @apiNote {@code Builder} checks invariants as components are added to the builder.
 626      * The rationale for this is to detect errors as early as possible and not defer
 627      * all validation to the {@code build} method.
 628      *
 629      * @see Thread#builder()
 630      * @since 99
 631      */
 632     public interface Builder {
 633 
 634         /**
 635          * Sets the thread group.
 636          *
 637          * &lt;p&gt; The thread group for threads that are scheduled by the Java virtual
 638          * machine threads does not support all features of regular thread groups.
 639          * The thread group can only be set for threads that are scheduled by
 640          * the operating system.
 641          *
 642          * @param group the thread group
 643          * @return this builder
 644          * @throws IllegalStateException if this is a builder for a virtual thread
 645          */
 646         Builder group(ThreadGroup group);
 647 
 648         /**
 649          * Sets the thread name.
 650          * @param name thread name
 651          * @return this builder
 652          */
 653         Builder name(String name);
 654 
 655         /**
 656          * Sets the thread name to be the concatenation of a string prefix and
 657          * a counter value.
 658          * @param prefix thread name prefix
 659          * @param start counter start
 660          * @return this builder
 661          * @throws IllegalArgumentException if count is negative
 662          */
 663         Builder name(String prefix, int start);
 664 
 665         /**
 666          * The thread will be scheduled by the Java virtual machine rather than
 667          * the operating system with the default scheduler.
 668          * @return this builder
 669          * @throws IllegalStateException if a thread group has been set
 670          */
 671         Builder virtual();
 672 
 673         /**
 674          * The thread will be scheduled by the Java virtual machine rather than
 675          * the operating system with the given scheduler.
 676          * @param scheduler the scheduler
 677          * @return this builder
 678          * @throws IllegalStateException if a thread group has been set
 679          */
 680         Builder virtual(Executor scheduler);
 681 
 682         /**
 683          * Disallow threads locals.
 684          * @return this builder
 685          * @throws IllegalStateException if inheritThreadLocals has already been set
 686          */
 687         Builder disallowThreadLocals();
 688 
 689         /**
 690          * Inherit threads locals. Thread locals are inherited when the {@code Thread}
 691          * is created with the {@link #build() build} method or when the thread
 692          * factory {@link ThreadFactory#newThread(Runnable) newThread} method
 693          * is invoked.
 694          * @return this builder
 695          * @throws IllegalStateException if disallowThreadLocals has already been set
 696          */
 697         Builder inheritThreadLocals();
 698 
 699         /**
 700          * Sets the daemon status.
 701          * @param on {@code true} to create daemon threads
 702          * @return this builder
 703          */
 704         Builder daemon(boolean on);
 705 
 706         /**
 707          * Sets the thread priority.
 708          * @param priority priority
 709          * @return this builder
 710          * @throws IllegalArgumentException if the priority is less than
 711          *        {@link Thread#MIN_PRIORITY} or greater than {@link Thread#MAX_PRIORITY}
 712          */
 713         Builder priority(int priority);
 714 
 715         /**
 716          * Sets the uncaught exception handler.
 717          * @param ueh uncaught exception handler
 718          * @return this builder
 719          */
 720         Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);
 721 
 722         /**
 723          * The thread is &lt;em&gt;managed&lt;/em&gt;.
 724          * @return this builder
 725          */
 726         Builder managed();
 727 
 728         /**
 729          * Sets the task for the thread to run.
 730          * @param task the task to run
 731          * @return this builder
 732          */
 733         Builder task(Runnable task);
 734 
 735         /**
 736          * Creates a new unstarted {@code Thread} from the current state of the
 737          * builder.
 738          *
 739          * @return a new unstarted Thread
 740          * @throws IllegalStateException if the task object to run object has not been set
 741          * @throws SecurityException if a thread group has been set and the current thread
 742          *         cannot create a thread in that thread group
 743          */
 744         Thread build();
 745 
 746         /**
 747          * Returns a {@code ThreadFactory} to create threads from the current
 748          * state of the builder. The returned thread factory is safe for use by
 749          * multiple concurrent threads.
 750          *
 751          * @return a thread factory to create threads
 752          */
 753         ThreadFactory factory();
 754 
 755         /**
 756          * Creates a new {@code Thread} from the current state of the builder
 757          * and starts it as if by invoking the {@linkplain Thread#start() start}
 758          * method.
 759          *
 760          * @implSpec The default implementation invokes {@linkplain #build() build}
 761          * to create a {@code Thread} and then invokes its {@linkplain Thread#start()
 762          * start} method to start it.
 763          *
 764          * @return The started thread
 765          * @throws IllegalStateException if the task object to run object has not been set
 766          * @throws SecurityException if a thread group has been set and the current thread
 767          *         cannot create a thread in that thread group
 768          */
 769         default Thread start() {
 770             Thread thread = build();
 771             thread.start();
 772             return thread;
 773         }
 774     }
 775 
 776     private static class BuilderImpl implements Builder {
 777         private ThreadGroup group;
 778         private Executor scheduler;
 779         private String name;
 780         private int counter;
 781         private boolean virtual;
 782         private boolean disallowThreadLocals;
 783         private boolean inheritThreadLocals;
 784         private boolean daemon;
 785         private boolean daemonChanged;
 786         private int priority;
 787         private UncaughtExceptionHandler uhe;
 788         private Runnable task;
 789 
 790         BuilderImpl() { }
 791 
 792         private int characteristics() {
 793             int characteristics = 0;
 794             if (virtual)
 795                 characteristics |= Thread.VIRTUAL;
 796             if (disallowThreadLocals)
 797                 characteristics |= Thread.NO_THREAD_LOCALS;
 798             if (inheritThreadLocals)
 799                 characteristics |= Thread.INHERIT_THREAD_LOCALS;
 800             return characteristics;
 801         }
 802 
 803         @Override
 804         public Builder group(ThreadGroup group) {
 805             Objects.requireNonNull(group);
 806             if (virtual)
 807                 throw new IllegalStateException();
 808             this.group = group;
 809             return this;
 810         }
 811 
 812         @Override
 813         public Builder name(String name) {
 814             this.name = Objects.requireNonNull(name);
 815             this.counter = -1;
 816             return this;
 817         }
 818 
 819         @Override
 820         public Builder name(String prefix, int start) {
 821             Objects.requireNonNull(prefix);
 822             if (start &lt; 0)
 823                 throw new IllegalArgumentException(&quot;&#39;start&#39; is negative&quot;);
 824             this.name = prefix;
 825             this.counter = start;
 826             return this;
 827         }
 828 
 829         @Override
 830         public Builder virtual() {
 831             if (group != null)
 832                 throw new IllegalStateException();
 833             this.virtual = true;
 834             this.scheduler = null;
 835             return this;
 836         }
 837 
 838         @Override
 839         public Builder virtual(Executor scheduler) {
 840             Objects.requireNonNull(scheduler);
 841             if (group != null)
 842                 throw new IllegalStateException();
 843             this.virtual = true;
 844             this.scheduler = scheduler;
 845             return this;
 846         }
 847 
 848         @Override
 849         public Builder disallowThreadLocals() {
 850             if (inheritThreadLocals)
 851                 throw new IllegalStateException();
 852             this.disallowThreadLocals = true;
 853             return this;
 854         }
 855 
 856         @Override
 857         public Builder inheritThreadLocals() {
 858             if (disallowThreadLocals)
 859                 throw new IllegalStateException();
 860             this.inheritThreadLocals = true;
 861             return this;
 862         }
 863 
 864         @Override
 865         public Builder daemon(boolean on) {
 866             daemon = on;
 867             daemonChanged = true;
 868             return this;
 869         }
 870 
 871         @Override
 872         public Builder priority(int priority) {
 873             if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY)
 874                 throw new IllegalArgumentException();
 875             this.priority = priority;
 876             return this;
 877         }
 878 
 879         @Override
 880         public Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
 881             this.uhe = Objects.requireNonNull(ueh);
 882             return this;
 883         }
 884 
 885         @Override
 886         public Builder managed() {
 887             // TDB
 888             return this;
 889         }
 890 
 891         @Override
 892         public Thread build() {
 893             Runnable task = this.task;
 894             if (task == null)
 895                 throw new IllegalStateException(&quot;No task specified&quot;);
 896 
 897             int characteristics = characteristics();
 898             Thread thread;
 899             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 900                 String name = this.name;
 901                 if (name != null &amp;&amp; counter &gt;= 0) {
 902                     name = name + (counter++);
 903                 }
 904                 thread = new VirtualThread(scheduler, name, characteristics, task);
 905             } else {
 906                 String name = this.name;
 907                 if (name == null) {
 908                     name = &quot;Thread-&quot; + nextThreadNum();
 909                 } else if (counter &gt;= 0) {
 910                     name = name + (counter++);
 911                 }
 912                 thread = new Thread(group, name, characteristics, task, 0, null);
 913                 if (daemonChanged)
 914                     thread.daemon(daemon);
 915                 if (priority != 0)
 916                     thread.priority(priority);
 917             }
 918             if (uhe != null)
 919                 thread.uncaughtExceptionHandler(uhe);
 920             return thread;
 921         }
 922 
 923         @Override
 924         public Builder task(Runnable task) {
 925             this.task = Objects.requireNonNull(task);
 926             return this;
 927         }
 928 
 929         @Override
 930         public ThreadFactory factory() {
 931             int characteristics = characteristics();
 932             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 933                 return new VirtualThreadFactory(scheduler, name, counter, characteristics, uhe);
 934             } else {
 935                 return new KernelThreadFactory(group, name, counter, characteristics,
 936                                                daemon, priority, uhe);
 937             }
 938         }
 939     }
 940 
 941     private static abstract class CountingThreadFactory implements ThreadFactory {
 942         private static final VarHandle COUNT;
 943         static {
 944             try {
 945                 MethodHandles.Lookup l = MethodHandles.lookup();
 946                 COUNT = l.findVarHandle(CountingThreadFactory.class, &quot;count&quot;, int.class);
 947             } catch (Exception e) {
 948                 throw new InternalError(e);
 949             }
 950         }
 951         private volatile int count;
 952         private final boolean hasCounter;
 953 
 954         CountingThreadFactory(int start) {
 955             if (start &gt;= 0) {
 956                 count = start;
 957                 hasCounter = true;
 958             } else {
 959                 hasCounter = false;
 960             }
 961         }
 962 
 963         boolean hasCounter() {
 964             return hasCounter;
 965         }
 966 
 967         int next() {
 968             return (int) COUNT.getAndAdd(this, 1);
 969         }
 970     }
 971 
 972     private static class VirtualThreadFactory extends CountingThreadFactory {
 973         private final Executor scheduler;
 974         private String name;
 975         private final int characteristics;
 976         private final UncaughtExceptionHandler uhe;
 977 
 978         VirtualThreadFactory(Executor scheduler,
 979                              String name,
 980                              int start,
 981                              int characteristics,
 982                              UncaughtExceptionHandler uhe) {
 983             super(start);
 984             this.scheduler = scheduler;
 985             this.name = name;
 986             this.characteristics = characteristics;
 987             this.uhe = uhe;
 988         }
 989 
 990         @Override
 991         public Thread newThread(Runnable task) {
 992             Objects.requireNonNull(task);
 993             String name = this.name;
 994             if (name != null &amp;&amp; hasCounter()) {
 995                 name += next();
 996             }
 997             Thread thread = new VirtualThread(scheduler, name, characteristics, task);
 998             if (uhe != null)
 999                 thread.uncaughtExceptionHandler(uhe);
1000             return thread;
1001         }
1002     }
1003 
1004     private static class KernelThreadFactory extends CountingThreadFactory {
1005         private final ThreadGroup group;
1006         private final String name;
1007         private final int characteristics;
1008         private final boolean daemon;
1009         private final int priority;
1010         private final UncaughtExceptionHandler uhe;
1011 
1012         KernelThreadFactory(ThreadGroup group,
1013                             String name,
1014                             int start,
1015                             int characteristics,
1016                             boolean daemon,
1017                             int priority,
1018                             UncaughtExceptionHandler uhe) {
1019             super(start);
1020             this.group = group;
1021             this.name = name;
1022             this.characteristics = characteristics;
1023             this.daemon = daemon;
1024             this.priority = priority;
1025             this.uhe = uhe;
1026         }
1027 
1028         @Override
1029         public Thread newThread(Runnable task) {
1030             Objects.requireNonNull(task);
1031             String name = this.name;
1032             if (name == null) {
1033                 name = &quot;Thread-&quot; + nextThreadNum();
1034             } else if (hasCounter()) {
1035                 name += next();
1036             }
1037             Thread thread = new Thread(group, name, characteristics, task, 0, null);
1038             if (daemon)
1039                 thread.daemon(true);
1040             if (priority != 0)
1041                 thread.priority(priority);
1042             if (uhe != null)
1043                 thread.uncaughtExceptionHandler(uhe);
1044             return thread;
1045         }
1046     }
1047 
1048     /**
1049      * Throws CloneNotSupportedException as a Thread can not be meaningfully
1050      * cloned. Construct a new Thread instead.
1051      *
1052      * @throws  CloneNotSupportedException
1053      *          always
1054      */
1055     @Override
1056     protected Object clone() throws CloneNotSupportedException {
1057         throw new CloneNotSupportedException();
1058     }
1059 
1060     /**
1061      * Allocates a new {@code Thread} object. This constructor has the same
1062      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1063      * {@code (null, null, gname)}, where {@code gname} is a newly generated
1064      * name. Automatically generated names are of the form
1065      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1066      */
1067     public Thread() {
1068         this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
1069     }
1070 
1071     /**
1072      * Allocates a new {@code Thread} object. This constructor has the same
1073      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1074      * {@code (null, task, gname)}, where {@code gname} is a newly generated
1075      * name. Automatically generated names are of the form
1076      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1077      *
1078      * @param  task
1079      *         the object whose {@code run} method is invoked when this thread
1080      *         is started. If {@code null}, this classes {@code run} method does
1081      *         nothing.
1082      */
1083     public Thread(Runnable task) {
1084         this(null, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1085     }
1086 
1087     /**
1088      * Creates a new Thread that inherits the given AccessControlContext
1089      * but thread-local variables are not inherited.
1090      * This is not a public constructor.
1091      */
1092     Thread(Runnable task, AccessControlContext acc) {
1093         this(null, &quot;Thread-&quot; + nextThreadNum(), 0, task, 0, acc);
1094     }
1095 
1096     /**
1097      * Allocates a new {@code Thread} object. This constructor has the same
1098      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1099      * {@code (group, task, gname)} ,where {@code gname} is a newly generated
1100      * name. Automatically generated names are of the form
1101      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1102      *
1103      * @param  group
1104      *         the thread group. If {@code null} and there is a security
1105      *         manager, the group is determined by {@linkplain
1106      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1107      *         If there is not a security manager or {@code
1108      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1109      *         is set to the current thread&#39;s thread group.
1110      *
1111      * @param  task
1112      *         the object whose {@code run} method is invoked when this thread
1113      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1114      *
1115      * @throws  SecurityException
1116      *          if the current thread cannot create a thread in the specified
1117      *          thread group
1118      */
1119     public Thread(ThreadGroup group, Runnable task) {
1120         this(group, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1121     }
1122 
1123     /**
1124      * Allocates a new {@code Thread} object. This constructor has the same
1125      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1126      * {@code (null, null, name)}.
1127      *
1128      * @param   name
1129      *          the name of the new thread
1130      */
1131     public Thread(String name) {
1132         this(null, null, name, 0);
1133     }
1134 
1135     /**
1136      * Allocates a new {@code Thread} object. This constructor has the same
1137      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1138      * {@code (group, null, name)}.
1139      *
1140      * @param  group
1141      *         the thread group. If {@code null} and there is a security
1142      *         manager, the group is determined by {@linkplain
1143      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1144      *         If there is not a security manager or {@code
1145      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1146      *         is set to the current thread&#39;s thread group.
1147      *
1148      * @param  name
1149      *         the name of the new thread
1150      *
1151      * @throws  SecurityException
1152      *          if the current thread cannot create a thread in the specified
1153      *          thread group
1154      */
1155     public Thread(ThreadGroup group, String name) {
1156         this(group, null, name, 0);
1157     }
1158 
1159     /**
1160      * Allocates a new {@code Thread} object. This constructor has the same
1161      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1162      * {@code (null, task, name)}.
1163      *
1164      * @param  task
1165      *         the object whose {@code run} method is invoked when this thread
1166      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1167      *
1168      * @param  name
1169      *         the name of the new thread
1170      */
1171     public Thread(Runnable task, String name) {
1172         this(null, task, name, 0);
1173     }
1174 
1175     /**
1176      * Allocates a new {@code Thread} object so that it has {@code task}
1177      * as its run object, has the specified {@code name} as its name,
1178      * and belongs to the thread group referred to by {@code group}.
1179      *
1180      * &lt;p&gt;If there is a security manager, its
1181      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
1182      * method is invoked with the ThreadGroup as its argument.
1183      *
1184      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
1185      * the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}
1186      * permission when invoked directly or indirectly by the constructor
1187      * of a subclass which overrides the {@code getContextClassLoader}
1188      * or {@code setContextClassLoader} methods.
1189      *
1190      * &lt;p&gt;The priority of the newly created thread is set equal to the
1191      * priority of the thread creating it, that is, the currently running
1192      * thread. The method {@linkplain #setPriority setPriority} may be
1193      * used to change the priority to a new value.
1194      *
1195      * &lt;p&gt;The newly created thread is initially marked as being a daemon
1196      * thread if and only if the thread creating it is currently marked
1197      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
1198      * may be used to change whether or not a thread is a daemon.
1199      *
1200      * @param  group
1201      *         the thread group. If {@code null} and there is a security
1202      *         manager, the group is determined by {@linkplain
1203      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1204      *         If there is not a security manager or {@code
1205      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1206      *         is set to the current thread&#39;s thread group.
1207      *
1208      * @param  task
1209      *         the object whose {@code run} method is invoked when this thread
1210      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1211      *
1212      * @param  name
1213      *         the name of the new thread
1214      *
1215      * @throws  SecurityException
1216      *          if the current thread cannot create a thread in the specified
1217      *          thread group or cannot override the context class loader methods.
1218      */
1219     public Thread(ThreadGroup group, Runnable task, String name) {
1220         this(group, task, name, 0);
1221     }
1222 
1223     /**
1224      * Allocates a new {@code Thread} object so that it has {@code task}
1225      * as its run object, has the specified {@code name} as its name,
1226      * and belongs to the thread group referred to by {@code group}, and has
1227      * the specified &lt;i&gt;stack size&lt;/i&gt;.
1228      *
1229      * &lt;p&gt;This constructor is identical to {@link
1230      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
1231      * that it allows the thread stack size to be specified.  The stack size
1232      * is the approximate number of bytes of address space that the virtual
1233      * machine is to allocate for this thread&#39;s stack.  &lt;b&gt;The effect of the
1234      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
1235      *
1236      * &lt;p&gt;On some platforms, specifying a higher value for the
1237      * {@code stackSize} parameter may allow a thread to achieve greater
1238      * recursion depth before throwing a {@link StackOverflowError}.
1239      * Similarly, specifying a lower value may allow a greater number of
1240      * threads to exist concurrently without throwing an {@link
1241      * OutOfMemoryError} (or other internal error).  The details of
1242      * the relationship between the value of the {@code stackSize} parameter
1243      * and the maximum recursion depth and concurrency level are
1244      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
1245      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
1246      *
1247      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
1248      * parameter as a suggestion.  If the specified value is unreasonably low
1249      * for the platform, the virtual machine may instead use some
1250      * platform-specific minimum value; if the specified value is unreasonably
1251      * high, the virtual machine may instead use some platform-specific
1252      * maximum.  Likewise, the virtual machine is free to round the specified
1253      * value up or down as it sees fit (or to ignore it completely).
1254      *
1255      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
1256      * cause this constructor to behave exactly like the
1257      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
1258      *
1259      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
1260      * constructor, extreme care should be exercised in its use.
1261      * The thread stack size necessary to perform a given computation will
1262      * likely vary from one JRE implementation to another.  In light of this
1263      * variation, careful tuning of the stack size parameter may be required,
1264      * and the tuning may need to be repeated for each JRE implementation on
1265      * which an application is to run.&lt;/i&gt;
1266      *
1267      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
1268      * document their implementation&#39;s behavior with respect to the
1269      * {@code stackSize} parameter.
1270      *
1271      *
1272      * @param  group
1273      *         the thread group. If {@code null} and there is a security
1274      *         manager, the group is determined by {@linkplain
1275      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1276      *         If there is not a security manager or {@code
1277      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1278      *         is set to the current thread&#39;s thread group.
1279      *
1280      * @param  task
1281      *         the object whose {@code run} method is invoked when this thread
1282      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1283      *
1284      * @param  name
1285      *         the name of the new thread
1286      *
1287      * @param  stackSize
1288      *         the desired stack size for the new thread, or zero to indicate
1289      *         that this parameter is to be ignored.
1290      *
1291      * @throws  SecurityException
1292      *          if the current thread cannot create a thread in the specified
1293      *          thread group
1294      *
1295      * @since 1.4
1296      */
1297     public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
1298         this(group, name, Thread.INHERIT_THREAD_LOCALS, task, stackSize, null);
1299     }
1300 
1301     /**
1302      * Allocates a new {@code Thread} object so that it has {@code task}
1303      * as its run object, has the specified {@code name} as its name,
1304      * belongs to the thread group referred to by {@code group}, has
1305      * the specified {@code stackSize}, and inherits initial values for
1306      * {@linkplain InheritableThreadLocal inheritable thread-local} variables
1307      * if {@code inheritThreadLocals} is {@code true}.
1308      *
1309      * &lt;p&gt; This constructor is identical to {@link
1310      * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
1311      * suppress, or not, the inheriting of initial values for inheritable
1312      * thread-local variables from the constructing thread. This allows for
1313      * finer grain control over inheritable thread-locals. Care must be taken
1314      * when passing a value of {@code false} for {@code inheritThreadLocals},
1315      * as it may lead to unexpected behavior if the new thread executes code
1316      * that expects a specific thread-local value to be inherited.
1317      *
1318      * &lt;p&gt; Specifying a value of {@code true} for the {@code inheritThreadLocals}
1319      * parameter will cause this constructor to behave exactly like the
1320      * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
1321      *
1322      * @param  group
1323      *         the thread group. If {@code null} and there is a security
1324      *         manager, the group is determined by {@linkplain
1325      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1326      *         If there is not a security manager or {@code
1327      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1328      *         is set to the current thread&#39;s thread group.
1329      *
1330      * @param  task
1331      *         the object whose {@code run} method is invoked when this thread
1332      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1333      *
1334      * @param  name
1335      *         the name of the new thread
1336      *
1337      * @param  stackSize
1338      *         the desired stack size for the new thread, or zero to indicate
1339      *         that this parameter is to be ignored
1340      *
1341      * @param  inheritThreadLocals
1342      *         if {@code true}, inherit initial values for inheritable
1343      *         thread-locals from the constructing thread, otherwise no initial
1344      *         values are inherited
1345      *
1346      * @throws  SecurityException
1347      *          if the current thread cannot create a thread in the specified
1348      *          thread group
1349      *
1350      * @since 9
1351      */
1352     public Thread(ThreadGroup group, Runnable task, String name,
1353                   long stackSize, boolean inheritThreadLocals) {
1354         this(group, name, (inheritThreadLocals ? Thread.INHERIT_THREAD_LOCALS : 0),
1355                 task, stackSize, null);
1356     }
1357 
1358     /**
1359      * Characteristic value signifying that the thread should be scheduled by
1360      * the Java virtual machine rather than the operating system.
1361      *
1362      * @since 99
1363      */
1364     public static final int VIRTUAL = 1 &lt;&lt; 0;
1365 
1366     /**
1367      * Characteristic value signifying that {@link ThreadLocal thread-locals}
1368      * are not supported by the thread.
1369      *
1370      * @apiNote This is for experimental purposes, a lot of existing code will
1371      * not run if thread locals are not supported.
1372      *
1373      * @since 99
1374      */
1375     public static final int NO_THREAD_LOCALS = 1 &lt;&lt; 1;
1376 
1377     /**
1378      * Characteristic value signifying that {@link InheritableThreadLocal
1379      * inheritable-thread-locals} are inherihted from the constructing thread.
1380      * This characteristic is incompatible with {@linkplain #NO_THREAD_LOCALS},
1381      * they may not be used together.
1382      *
1383      * @since 99
1384      */
1385     public static final int INHERIT_THREAD_LOCALS = 1 &lt;&lt; 2;
1386 
1387     /**
1388      * Characteristic value signifying that the thread is &lt;em&gt;managed.&lt;/em&gt;
1389      *
1390      * @since 99
1391      */
1392     public static final int MANAGED = 1 &lt;&lt; 3;
1393 
1394     private static int validCharacteristics() {
1395         return (VIRTUAL | NO_THREAD_LOCALS | INHERIT_THREAD_LOCALS | MANAGED);
1396     }
1397 
1398     private static void checkCharacteristics(int characteristics) {
1399         if (characteristics != 0) {
1400             if ((characteristics &amp; ~validCharacteristics()) != 0)
1401                 throw new IllegalArgumentException();
1402             if ((characteristics &amp; NO_THREAD_LOCALS) != 0
1403                     &amp;&amp; (characteristics &amp; INHERIT_THREAD_LOCALS) != 0)
1404                 throw new IllegalArgumentException();
1405         }
1406     }
1407 
1408     /**
1409      * Creates an unnamed thread.
1410      *
1411      * By default, the thread is scheduled by the operating system, supports
1412      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1413      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1414      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1415      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1416      * context-class-loader} are inherited from the current thread.
1417      *
1418      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1419      * used to create a thread that is scheduled by the Java virtual machine
1420      * using the default scheduler. The default in this case is to only inherit
1421      * the {@link #getContextClassLoader() context-class-loader} from the current
1422      * thread.
1423      *
1424      * @apiNote The characteristics will probably be replaced by an enum
1425      *
1426      * @param characteristics characteristics of the thread
1427      * @param task the object to run when the thread executes
1428      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1429      *         combination of characteristic is specified
1430      * @return an un-started virtual thread
1431      *
1432      * @since 99
1433      */
1434     public static Thread newThread(int characteristics, Runnable task) {
1435         if ((characteristics &amp; VIRTUAL) != 0) {
1436             return new VirtualThread(null, null, characteristics, task);
1437         } else {
1438             return new Thread(null, &quot;Thread-&quot; + nextThreadNum(), characteristics, task, 0, null);
1439         }
1440     }
1441 
1442     /**
1443      * Creates a named thread.
1444      *
1445      * By default, the thread is scheduled by the operating system, supports
1446      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1447      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1448      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1449      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1450      * context-class-loader} are inherited from the current thread.
1451      *
1452      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1453      * used to create a thread that is scheduled by the Java virtual machine
1454      * using the default scheduler. The default in this case is to only inherit
1455      * the {@link #getContextClassLoader() context-class-loader} from the current
1456      * thread.
1457      *
1458      * @apiNote The characteristics will probably be replaced by an enum
1459      *
1460      * @param name the thread name
1461      * @param characteristics characteristics of the thread
1462      * @param task the object to run when the thread executes
1463      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1464      *         combination of characteristic is specified
1465      * @return an un-started virtual thread
1466      *
1467      * @since 99
1468      */
1469     public static Thread newThread(String name, int characteristics, Runnable task) {
1470         if ((characteristics &amp; VIRTUAL) != 0) {
1471             return new VirtualThread(null, name, characteristics, task);
1472         } else {
1473             return new Thread(null, name, characteristics, task, 0, null);
1474         }
1475     }
1476 
1477     /**
1478      * Returns {@code true} if this thread scheduled by the Java virtual machine
1479      * rather than the operating system.
1480      *
1481      * &lt;p&gt; Threads that are scheduled by the Java virtual machine do not support
1482      * all features of Thread. In particular, the Thread is not an &lt;i&gt;active thread&lt;/i&gt;
1483      * in its thread group and so is not enumerated or acted on by thread group
1484      * operations. In addition it does not support the stop, suspend or resume
1485      * methods.
1486      *
1487      * @return {@code true} if this thread is scheduled by the Java virtual
1488      *         machine rather than the operating system
1489      *
1490      * @since 99
1491      */
1492     public final boolean isVirtual() {
1493         return (this instanceof VirtualThread);
1494     }
1495 
1496     /**
1497      * Schedules this thread to begin execution. The thread will execute
1498      * independently of the current thread.
1499      * &lt;p&gt;
1500      * It is never legal to start a thread more than once.
1501      * In particular, a thread may not be restarted once it has completed
1502      * execution.
1503      *
1504      * @throws     IllegalThreadStateException  if the thread was already started.
1505      * @see        #run()
1506      * @see        Builder#start()
1507      */
1508     public synchronized void start() {
1509         /**
1510          * This method is not invoked for the main method thread or &quot;system&quot;
1511          * group threads created/set up by the VM. Any new functionality added
1512          * to this method in the future may have to also be added to the VM.
1513          *
1514          * A zero status value corresponds to state &quot;NEW&quot;.
1515          */
1516         if (holder.threadStatus != 0)
1517             throw new IllegalThreadStateException();
1518 
1519         /* Notify the group that this thread is about to be started
1520          * so that it can be added to the group&#39;s list of threads
1521          * and the group&#39;s unstarted count can be decremented. */
1522         ThreadGroup group = holder.group;
1523         group.add(this);
1524 
1525         boolean started = false;
1526         try {
1527             start0();
1528             started = true;
1529         } finally {
1530             try {
1531                 if (!started) {
1532                     group.threadStartFailed(this);
1533                 }
1534             } catch (Throwable ignore) {
1535                 /* do nothing. If start0 threw a Throwable then
1536                   it will be passed up the call stack */
1537             }
1538         }
1539     }
1540 
1541     private native void start0();
1542 
1543     /**
1544      * If this thread was constructed using a separate
1545      * {@code Runnable} run object, then that
1546      * {@code Runnable} object&#39;s {@code run} method is called;
1547      * otherwise, this method does nothing and returns.
1548      * This method does nothing when invoked on a {@linkplain #isVirtual()
1549      * virtual} thread.
1550      * &lt;p&gt;
1551      * Subclasses of {@code Thread} should override this method.
1552      *
1553      * @see     #start()
1554      * @see     #Thread(ThreadGroup, Runnable, String)
1555      */
1556     @Override
1557     public void run() {
1558         if (!isVirtual()) {
1559             Runnable task = holder.task;
1560             if (task != null) {
1561                 task.run();
1562             }
1563         }
1564     }
1565 
1566     /**
1567      * This method is called by the system to give a Thread
1568      * a chance to clean up before it actually exits.
1569      */
1570     private void exit() {
1571         // assert !isVirtual();
1572         if (threadLocals != null &amp;&amp; TerminatingThreadLocal.REGISTRY.isPresent()) {
1573             TerminatingThreadLocal.threadTerminated();
1574         }
1575         ThreadGroup group = holder.group;
1576         if (group != null) {
1577             group.threadTerminated(this);
1578         }
1579         /* Aggressively null out all reference fields: see bug 4006245 */
1580         /* Speed the release of some of these resources */
1581         threadLocals = null;
1582         inheritableThreadLocals = null;
1583         inheritedAccessControlContext = null;
1584         nioBlocker = null;
1585         uncaughtExceptionHandler = null;
1586     }
1587 
1588     /**
1589      * Forces the thread to stop executing.
1590      * &lt;p&gt;
1591      * If there is a security manager installed, its {@code checkAccess}
1592      * method is called with {@code this}
1593      * as its argument. This may result in a
1594      * {@code SecurityException} being raised (in the current thread).
1595      * &lt;p&gt;
1596      * If this thread is different from the current thread (that is, the current
1597      * thread is trying to stop a thread other than itself), the
1598      * security manager&#39;s {@code checkPermission} method (with a
1599      * {@code RuntimePermission(&quot;stopThread&quot;)} argument) is called in
1600      * addition.
1601      * Again, this may result in throwing a
1602      * {@code SecurityException} (in the current thread).
1603      * &lt;p&gt;
1604      * The thread represented by this thread is forced to stop whatever
1605      * it is doing abnormally and to throw a newly created
1606      * {@code ThreadDeath} object as an exception.
1607      * &lt;p&gt;
1608      * It is permitted to stop a thread that has not yet been started.
1609      * If the thread is eventually started, it immediately terminates.
1610      * &lt;p&gt;
1611      * An application should not normally try to catch
1612      * {@code ThreadDeath} unless it must do some extraordinary
1613      * cleanup operation (note that the throwing of
1614      * {@code ThreadDeath} causes {@code finally} clauses of
1615      * {@code try} statements to be executed before the thread
1616      * officially terminates).  If a {@code catch} clause catches a
1617      * {@code ThreadDeath} object, it is important to rethrow the
1618      * object so that the thread actually terminates.
1619      * &lt;p&gt;
1620      * The top-level error handler that reacts to otherwise uncaught
1621      * exceptions does not print out a message or otherwise notify the
1622      * application if the uncaught exception is an instance of
1623      * {@code ThreadDeath}.
1624      *
1625      * @throws     SecurityException  if the current thread cannot
1626      *             modify this thread.
1627      * @throws     UnsupportedOperationException if invoked on a virtual thread
1628      * @see        #interrupt()
1629      * @see        #checkAccess()
1630      * @see        #run()
1631      * @see        #start()
1632      * @see        ThreadDeath
1633      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
1634      * @see        SecurityManager#checkAccess(Thread)
1635      * @see        SecurityManager#checkPermission
1636      * @deprecated This method is inherently unsafe.  Stopping a thread with
1637      *       Thread.stop causes it to unlock all of the monitors that it
1638      *       has locked (as a natural consequence of the unchecked
1639      *       {@code ThreadDeath} exception propagating up the stack).  If
1640      *       any of the objects previously protected by these monitors were in
1641      *       an inconsistent state, the damaged objects become visible to
1642      *       other threads, potentially resulting in arbitrary behavior.  Many
1643      *       uses of {@code stop} should be replaced by code that simply
1644      *       modifies some variable to indicate that the task thread should
1645      *       stop running.  The task thread should check this variable
1646      *       regularly, and return from its run method in an orderly fashion
1647      *       if the variable indicates that it is to stop running.  If the
1648      *       task thread waits for long periods (on a condition variable,
1649      *       for example), the {@code interrupt} method should be used to
1650      *       interrupt the wait.
1651      *       For more information, see
1652      *       &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1653      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1654      */
1655     @Deprecated(since=&quot;1.2&quot;)
1656     public final void stop() {
1657         SecurityManager security = System.getSecurityManager();
1658         if (security != null) {
1659             checkAccess();
1660             if (this != Thread.currentThread()) {
1661                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
1662             }
1663         }
1664 
1665         if (isVirtual())
1666             throw new UnsupportedOperationException();
1667 
1668         // A zero status value corresponds to &quot;NEW&quot;, it can&#39;t change to
1669         // not-NEW because we hold the lock.
1670         if (holder.threadStatus != 0) {
1671             resume(); // Wake up thread if it was suspended; no-op otherwise
1672         }
1673 
1674         // The VM can handle all thread states
1675         stop0(new ThreadDeath());
1676     }
1677 
1678     /**
1679      * Interrupts this thread.
1680      *
1681      * &lt;p&gt; Unless the current thread is interrupting itself, which is
1682      * always permitted, the {@link #checkAccess() checkAccess} method
1683      * of this thread is invoked, which may cause a {@link
1684      * SecurityException} to be thrown.
1685      *
1686      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
1687      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
1688      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
1689      * class, or of the {@link #join()}, {@link #join(long)}, {@link
1690      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
1691      * methods of this class, then its interrupt status will be cleared and it
1692      * will receive an {@link InterruptedException}.
1693      *
1694      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
1695      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
1696      * then the channel will be closed, the thread&#39;s interrupt
1697      * status will be set, and the thread will receive a {@link
1698      * java.nio.channels.ClosedByInterruptException}.
1699      *
1700      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
1701      * then the thread&#39;s interrupt status will be set and it will return
1702      * immediately from the selection operation, possibly with a non-zero
1703      * value, just as if the selector&#39;s {@link
1704      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
1705      *
1706      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
1707      * status will be set. &lt;/p&gt;
1708      *
1709      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
1710      *
1711      * @implNote In the JDK Reference Implementation, interruption of a thread
1712      * that is not alive still records that the interrupt request was made and
1713      * will report it via {@link #interrupted} and {@link #isInterrupted()}.
1714      *
1715      * @throws  SecurityException
1716      *          if the current thread cannot modify this thread
1717      *
1718      * @revised 6.0, 14
1719      * @spec JSR-51
1720      */
1721     public void interrupt() {
1722         if (this != Thread.currentThread()) {
1723             checkAccess();
1724 
1725             // thread may be blocked in an I/O operation
1726             synchronized (interruptLock) {
1727                 Interruptible b = nioBlocker;
1728                 if (b != null) {
1729                     interrupted = true;
1730                     interrupt0();  // inform VM of interrupt
1731                     b.interrupt(this);
1732                     return;
1733                 }
1734             }
1735         }
1736         interrupted = true;
1737         interrupt0();  // inform VM of interrupt
1738     }
1739 
1740     /**
1741      * Tests whether the current thread has been interrupted.  The
1742      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1743      * other words, if this method were to be called twice in succession, the
1744      * second call would return false (unless the current thread were
1745      * interrupted again, after the first call had cleared its interrupted
1746      * status and before the second call had examined it).
1747      *
1748      * @return  {@code true} if the current thread has been interrupted;
1749      *          {@code false} otherwise.
1750      * @see #isInterrupted()
1751      * @revised 6.0, 14
1752      */
1753     public static boolean interrupted() {
1754         return currentThread().getAndClearInterrupt();
1755     }
1756 
1757     /**
1758      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1759      * status&lt;/i&gt; of the thread is unaffected by this method.
1760      *
1761      * @return  {@code true} if this thread has been interrupted;
1762      *          {@code false} otherwise.
1763      * @see     #interrupted()
1764      * @revised 6.0, 14
1765      */
1766     public boolean isInterrupted() {
1767         return interrupted;
1768     }
1769 
1770     final void setInterrupt() {
1771         interrupted = true;
1772         interrupt0();  // inform VM of interrupt
1773     }
1774 
1775     final void clearInterrupt() {
1776         interrupted = false;
1777         clearInterruptEvent();
1778     }
1779 
1780     boolean getAndClearInterrupt() {
1781         boolean oldValue = interrupted;
1782         // We may have been interrupted the moment after we read the field,
1783         // so only clear the field if we saw that it was set and will return
1784         // true; otherwise we could lose an interrupt.
1785         if (oldValue) {
1786             interrupted = false;
1787             clearInterruptEvent();
1788         }
1789         return oldValue;
1790     }
1791 
1792     /**
1793      * Tests if this thread is alive. A thread is alive if it has
1794      * been started and has not yet terminated.
1795      *
1796      * @return  {@code true} if this thread is alive;
1797      *          {@code false} otherwise.
1798      */
1799     public final boolean isAlive() {
1800         if (isVirtual()) {
1801             State state = getState();
1802             return (state != State.NEW &amp;&amp; state != State.TERMINATED);
1803         } else {
1804             return isAlive0();
1805         }
1806     }
1807     private native boolean isAlive0();
1808 
1809     /**
1810      * Suspends this thread.
1811      * &lt;p&gt;
1812      * First, the {@code checkAccess} method of this thread is called
1813      * with no arguments. This may result in throwing a
1814      * {@code SecurityException }(in the current thread).
1815      * &lt;p&gt;
1816      * If the thread is alive, it is suspended and makes no further
1817      * progress unless and until it is resumed.
1818      *
1819      * @throws     SecurityException  if the current thread cannot modify
1820      *             this thread.
1821      * @throws     UnsupportedOperationException if invoked on a virtual thread
1822      * @see #checkAccess
1823      * @deprecated   This method has been deprecated, as it is
1824      *   inherently deadlock-prone.  If the task thread holds a lock on the
1825      *   monitor protecting a critical system resource when it is suspended, no
1826      *   thread can access this resource until the task thread is resumed. If
1827      *   the thread that would resume the task thread attempts to lock this
1828      *   monitor prior to calling {@code resume}, deadlock results.  Such
1829      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1830      *   For more information, see
1831      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1832      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1833      */
1834     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1835     public final void suspend() {
1836         checkAccess();
1837         if (isVirtual())
1838             throw new UnsupportedOperationException();
1839         suspend0();
1840     }
1841 
1842     void suspendThread() {
1843         suspend0();
1844     }
1845 
1846     /**
1847      * Resumes a suspended thread.
1848      * &lt;p&gt;
1849      * First, the {@code checkAccess} method of this thread is called
1850      * with no arguments. This may result in throwing a
1851      * {@code SecurityException} (in the current thread).
1852      * &lt;p&gt;
1853      * If the thread is alive but suspended, it is resumed and is
1854      * permitted to make progress in its execution.
1855      *
1856      * @throws     SecurityException  if the current thread cannot modify this
1857      *             thread.
1858      * @throws     UnsupportedOperationException if invoked on a virtual thread
1859      * @see        #checkAccess
1860      * @see        #suspend()
1861      * @deprecated This method exists solely for use with {@link #suspend},
1862      *     which has been deprecated because it is deadlock-prone.
1863      *     For more information, see
1864      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1865      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1866      */
1867     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1868     public final void resume() {
1869         checkAccess();
1870         if (isVirtual())
1871             throw new UnsupportedOperationException();
1872         resume0();
1873     }
1874 
1875     void resumeThread() {
1876         resume0();
1877     }
1878 
1879     /**
1880      * Changes the priority of this thread.
1881      * &lt;p&gt;
1882      * First the {@code checkAccess} method of this thread is called
1883      * with no arguments. This may result in throwing a {@code SecurityException}.
1884      * &lt;p&gt;
1885      * The priority of virtual-threads is always {@linkplain Thread#NORM_PRIORITY}
1886      * and is not changed by this method.
1887      * Otherwise, the priority of this thread is set to the smaller of
1888      * the specified {@code newPriority} and the maximum permitted
1889      * priority of the thread&#39;s thread group.
1890      *
1891      * @param newPriority priority to set this thread to
1892      * @throws     IllegalArgumentException  If the priority is not in the
1893      *               range {@code MIN_PRIORITY} to
1894      *               {@code MAX_PRIORITY}.
1895      * @throws     SecurityException  if the current thread cannot modify
1896      *               this thread.
1897      * @see        #getPriority
1898      * @see        #checkAccess()
1899      * @see        #getThreadGroup()
1900      * @see        #MAX_PRIORITY
1901      * @see        #MIN_PRIORITY
1902      * @see        ThreadGroup#getMaxPriority()
1903      */
1904     public final void setPriority(int newPriority) {
1905         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1906             throw new IllegalArgumentException();
1907         }
1908         checkAccess();
1909         priority(newPriority);
1910     }
1911 
1912     void priority(int newPriority) {
1913         ThreadGroup g;
1914         if (!isVirtual() &amp;&amp; (g = getThreadGroup()) != null) {
1915             if (newPriority &gt; g.getMaxPriority()) {
1916                 newPriority = g.getMaxPriority();
1917             }
1918             setPriority0(holder.priority = newPriority);
1919         }
1920     }
1921 
1922     /**
1923      * Returns this thread&#39;s priority.
1924      * The priority of a virtual thread is always {@linkplain Thread#NORM_PRIORITY}.
1925      *
1926      * @return  this thread&#39;s priority.
1927      * @see     #setPriority
1928      */
1929     public final int getPriority() {
1930         if (isVirtual()) {
1931             return Thread.NORM_PRIORITY;
1932         } else {
1933             return holder.priority;
1934         }
1935     }
1936 
1937     /**
1938      * Changes the name of this thread to be equal to the argument {@code name}.
1939      * &lt;p&gt;
1940      * First the {@code checkAccess} method of this thread is called
1941      * with no arguments. This may result in throwing a
1942      * {@code SecurityException}.
1943      *
1944      * @param      name   the new name for this thread.
1945      * @throws     SecurityException  if the current thread cannot modify this
1946      *             thread.
1947      * @see        #getName
1948      * @see        #checkAccess()
1949      */
1950     public final synchronized void setName(String name) {
1951         checkAccess();
1952         if (name == null) {
1953             throw new NullPointerException(&quot;name cannot be null&quot;);
1954         }
1955 
1956         this.name = name;
1957         if (!isVirtual() &amp;&amp; holder.threadStatus != 0) {
1958             setNativeName(name);
1959         }
1960     }
1961 
1962     /**
1963      * Returns this thread&#39;s name.
1964      *
1965      * @return  this thread&#39;s name.
1966      * @see     #setName(String)
1967      */
1968     public final String getName() {
1969         return name;
1970     }
1971 
1972     /**
1973      * Returns the thread group to which this thread belongs.
1974      * This method returns null if the thread has terminated.
1975      *
1976      * &lt;p&gt; The thread group for virtual threads does not support all features
1977      * of regular thread groups. Virtual threads are not considered &lt;i&gt;active
1978      * threads&lt;/i&gt; in the thread group and so are not enumerated or acted on by
1979      * thread group operations.
1980      *
1981      * @return  this thread&#39;s thread group.
1982      */
1983     public final ThreadGroup getThreadGroup() {
1984         if (getState() == State.TERMINATED) {
1985             return null;
1986         } else {
1987             return isVirtual() ? VirtualThreads.THREAD_GROUP : holder.group;
1988         }
1989     }
1990 
1991     /**
1992      * Returns an estimate of the number of active threads in the current
1993      * thread&#39;s {@linkplain java.lang.ThreadGroup thread group} and its
1994      * subgroups. Recursively iterates over all subgroups in the current
1995      * thread&#39;s thread group.
1996      *
1997      * &lt;p&gt; The value returned is only an estimate because the number of
1998      * threads may change dynamically while this method traverses internal
1999      * data structures, and might be affected by the presence of certain
2000      * system threads. This method is intended primarily for debugging
2001      * and monitoring purposes.
2002      *
2003      * @return  an estimate of the number of active threads in the current
2004      *          thread&#39;s thread group and in any other thread group that
2005      *          has the current thread&#39;s thread group as an ancestor
2006      */
2007     public static int activeCount() {
2008         return currentThread().getThreadGroup().activeCount();
2009     }
2010 
2011     /**
2012      * Copies into the specified array every active thread in the current
2013      * thread&#39;s thread group and its subgroups. This method simply
2014      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
2015      * method of the current thread&#39;s thread group.
2016      *
2017      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
2018      * method to get an estimate of how big the array should be, however
2019      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
2020      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
2021      * thread in the current thread&#39;s thread group and its subgroups, the
2022      * invoker should verify that the returned int value is strictly less
2023      * than the length of {@code tarray}.
2024      *
2025      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
2026      * that the method only be used for debugging and monitoring purposes.
2027      *
2028      * @param  tarray
2029      *         an array into which to put the list of threads
2030      *
2031      * @return  the number of threads put into the array
2032      *
2033      * @throws  SecurityException
2034      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
2035      *          the current thread cannot access its thread group
2036      */
2037     public static int enumerate(Thread tarray[]) {
2038         return currentThread().getThreadGroup().enumerate(tarray);
2039     }
2040 
2041     /**
2042      * Throws {@code UnsupportedOperationException}.
2043      *
2044      * @return     nothing
2045      *
2046      * @deprecated This method was originally designed to count the number of
2047      *             stack frames but the results were never well-defined and it
2048      *             depended on thread-suspension.
2049      *             This method is subject to removal in a future version of Java SE.
2050      * @see        StackWalker
2051      */
2052     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
2053     public int countStackFrames() {
2054         throw new UnsupportedOperationException();
2055     }
2056 
2057     /**
2058      * Waits at most {@code millis} milliseconds for this thread to terminate.
2059      * A timeout of {@code 0} means to wait forever.
2060      * This method returns immediately, without waiting, if the thread has not
2061      * been {@link #start() started}.
2062      *
2063      * &lt;p&gt; For non-{@linkplain #isVirtual() virtual}, this
2064      * implementation uses a loop of {@code this.wait} calls
2065      * conditioned on {@code this.isAlive}. As a thread terminates the
2066      * {@code this.notifyAll} method is invoked. It is recommended that
2067      * applications not use {@code wait}, {@code notify}, or
2068      * {@code notifyAll} on {@code Thread} instances.
2069      *
2070      * @param  millis
2071      *         the time to wait in milliseconds
2072      *
2073      * @throws  IllegalArgumentException
2074      *          if the value of {@code millis} is negative
2075      *
2076      * @throws  InterruptedException
2077      *          if any thread has interrupted the current thread. The
2078      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2079      *          cleared when this exception is thrown.
2080      */
2081     public final void join(long millis) throws InterruptedException {
2082         if (millis &lt; 0)
2083             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2084 
2085         if (isVirtual()) {
2086             if (isAlive()) {
2087                 long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
2088                 ((VirtualThread) this).joinNanos(nanos);
2089             }
2090             return;
2091         }
2092 
2093         synchronized (this) {
2094             if (millis &gt; 0) {
2095                 if (isAlive()) {
2096                     final long startTime = System.nanoTime();
2097                     long delay = millis;
2098                     do {
2099                         wait(delay);
2100                     } while (isAlive() &amp;&amp; (delay = millis -
2101                             TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; 0);
2102                 }
2103             } else if (millis == 0) {
2104                 while (isAlive()) {
2105                     wait(0);
2106                 }
2107             }
2108         }
2109     }
2110 
2111     /**
2112      * Waits at most {@code millis} milliseconds plus
2113      * {@code nanos} nanoseconds for this thread to terminate.
2114      * If both arguments are {@code 0}, it means to wait forever.
2115      * This method returns immediately, without waiting, if the thread has not
2116      * been {@link #start() started}.
2117      *
2118      * &lt;p&gt; For non-{@link #isVirtual() virtual}, this
2119      * implementation uses a loop of {@code this.wait} calls
2120      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
2121      * conditioned on {@code this.isAlive}. As a thread terminates the
2122      * {@code this.notifyAll} method is invoked. It is recommended that
2123      * applications not use {@code wait}, {@code notify}, or
2124      * {@code notifyAll} on {@code Thread} instances.
2125      *
2126      * @param  millis
2127      *         the time to wait in milliseconds
2128      *
2129      * @param  nanos
2130      *         {@code 0-999999} additional nanoseconds to wait
2131      *
2132      * @throws  IllegalArgumentException
2133      *          if the value of {@code millis} is negative, or the value
2134      *          of {@code nanos} is not in the range {@code 0-999999}
2135      *
2136      * @throws  InterruptedException
2137      *          if any thread has interrupted the current thread. The
2138      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2139      *          cleared when this exception is thrown.
2140      */
2141     public final void join(long millis, int nanos) throws InterruptedException {
2142         if (millis &lt; 0) {
2143             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2144         }
2145 
2146         if (nanos &lt; 0 || nanos &gt; 999999) {
2147             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
2148         }
2149 
2150         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
2151             millis++;
2152         }
2153 
2154         join(millis);
2155     }
2156 
2157     /**
2158      * Waits for this thread to terminate.
2159      *
2160      * &lt;p&gt; An invocation of this method behaves in exactly the same
2161      * way as the invocation
2162      *
2163      * &lt;blockquote&gt;
2164      * {@linkplain #join(long) join}{@code (0)}
2165      * &lt;/blockquote&gt;
2166      *
2167      * @throws  InterruptedException
2168      *          if any thread has interrupted the current thread. The
2169      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2170      *          cleared when this exception is thrown.
2171      */
2172     public final void join() throws InterruptedException {
2173         join(0);
2174     }
2175 
2176     /**
2177      * Waits for this thread to terminate for up to the given waiting duration.
2178      * This method does not wait if the duration to wait is less than or equal
2179      * to zero.
2180      *
2181      * @param   duration
2182      *          the maximum duration to wait
2183      *
2184      * @return  {@code true} if the thread has terminated
2185      *
2186      * @throws  InterruptedException
2187      *          if the current thread is interrupted while waiting.
2188      *          The &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is cleared
2189      *          when this exception is thrown.
2190      *
2191      * @throws  IllegalThreadStateException
2192      *          if this thread has not been started.
2193      *
2194      * @since 99
2195      */
2196     public final boolean join(Duration duration) throws InterruptedException {
2197         Objects.requireNonNull(duration);
2198 
2199         Thread.State state = getState();
2200         if (state == State.TERMINATED)
2201             return true;
2202         if (state == State.NEW)
2203             throw new IllegalThreadStateException(&quot;Thread not started&quot;);
2204         if (duration.isZero() || duration.isNegative())
2205             return false;
2206 
2207         if (isVirtual()) {
2208             long nanos = TimeUnit.NANOSECONDS.convert(duration);
2209             return ((VirtualThread) this).joinNanos(nanos);
2210         } else {
2211             // ignore nano precision for now
2212             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
2213             join(millis);
2214             return getState() == State.TERMINATED;
2215         }
2216     }
2217 
2218     /**
2219      * Prints a stack trace of the current thread to the standard error stream.
2220      * This method is useful for debugging.
2221      */
2222     public static void dumpStack() {
2223         new Exception(&quot;Stack trace&quot;).printStackTrace();
2224     }
2225 
2226     /**
2227      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
2228      * or a user thread.
2229      * The daemon status of a virtual thread is meaningless and is not
2230      * changed by this method (the {@linkplain #isDaemon() isDaemon} method
2231      * always returns {@code true}).
2232      * The Java Virtual Machine exits when the only threads running are all
2233      * daemon threads.
2234      *
2235      * &lt;p&gt; This method must be invoked before the thread is started.
2236      *
2237      * @param  on
2238      *         if {@code true}, marks this thread as a daemon thread
2239      *
2240      * @throws  IllegalThreadStateException
2241      *          if this thread is {@linkplain #isAlive alive}
2242      *
2243      * @throws  SecurityException
2244      *          if {@link #checkAccess} determines that the current
2245      *          thread cannot modify this thread
2246      */
2247     public final void setDaemon(boolean on) {
2248         checkAccess();
2249         if (isAlive())
2250             throw new IllegalThreadStateException();
2251         daemon(on);
2252     }
2253 
2254     void daemon(boolean on) {
2255         if (!isVirtual())
2256             holder.daemon = on;
2257     }
2258 
2259     /**
2260      * Tests if this thread is a daemon thread.
2261      * The daemon status of a virtual thread is meaningless, this method
2262      * returns {@code true} if this is a virtual thread.
2263      *
2264      * @return  {@code true} if this thread is a daemon thread;
2265      *          {@code false} otherwise.
2266      * @see     #setDaemon(boolean)
2267      */
2268     public final boolean isDaemon() {
2269         if (isVirtual()) {
2270             return true;
2271         } else {
2272             return holder.daemon;
2273         }
2274     }
2275 
2276     /**
2277      * Determines if the currently running thread has permission to
2278      * modify this thread.
2279      * &lt;p&gt;
2280      * If there is a security manager, its {@code checkAccess} method
2281      * is called with this thread as its argument. This may result in
2282      * throwing a {@code SecurityException}.
2283      *
2284      * @throws  SecurityException  if the current thread is not allowed to
2285      *          access this thread.
2286      * @see        SecurityManager#checkAccess(Thread)
2287      */
2288     public final void checkAccess() {
2289         SecurityManager security = System.getSecurityManager();
2290         if (security != null) {
2291             security.checkAccess(this);
2292         }
2293     }
2294 
2295     /**
2296      * Returns a string representation of this thread. The string representation
2297      * will usually include the thread&#39;s name. The default implementation
2298      * includes the thread&#39;s name, priority, and the name of the thread group.
2299      *
2300      * @return  a string representation of this thread.
2301      */
2302     public String toString() {
2303         ThreadGroup group = getThreadGroup();
2304         if (group != null) {
2305             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2306                            group.getName() + &quot;]&quot;;
2307         } else {
2308             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2309                             &quot;&quot; + &quot;]&quot;;
2310         }
2311     }
2312 
2313     /**
2314      * Returns the context {@code ClassLoader} for this thread. The context
2315      * {@code ClassLoader} is provided by the creator of the thread for use
2316      * by code running in this thread when loading classes and resources.
2317      * If not {@linkplain #setContextClassLoader set}, the default is the
2318      * {@code ClassLoader} context of the parent thread. The context
2319      * {@code ClassLoader} of the
2320      * primordial thread is typically set to the class loader used to load the
2321      * application.
2322      *
2323      *
2324      * @return  the context {@code ClassLoader} for this thread, or {@code null}
2325      *          indicating the system class loader (or, failing that, the
2326      *          bootstrap class loader)
2327      *
2328      * @throws  SecurityException
2329      *          if a security manager is present, and the caller&#39;s class loader
2330      *          is not {@code null} and is not the same as or an ancestor of the
2331      *          context class loader, and the caller does not have the
2332      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
2333      *
2334      * @since 1.2
2335      */
2336     @CallerSensitive
2337     public ClassLoader getContextClassLoader() {
2338         if (contextClassLoader == null)
2339             return null;
2340         SecurityManager sm = System.getSecurityManager();
2341         if (sm != null) {
2342             ClassLoader.checkClassLoaderPermission(contextClassLoader,
2343                                                    Reflection.getCallerClass());
2344         }
2345         return contextClassLoader;
2346     }
2347 
2348     /**
2349      * TBD
2350      */
2351     Continuation getContinuation() {
2352         return cont;
2353     }
2354 
2355     /**
2356      * TBD
2357      */
2358     void setContinuation(Continuation cont) {
2359         this.cont = cont;
2360     }
2361 
2362     /**
2363      * Sets the context ClassLoader for this Thread. The context
2364      * ClassLoader can be set when a thread is created, and allows
2365      * the creator of the thread to provide the appropriate class loader,
2366      * through {@code getContextClassLoader}, to code running in the thread
2367      * when loading classes and resources.
2368      *
2369      * &lt;p&gt;If a security manager is present, its {@link
2370      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
2371      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
2372      * (&quot;setContextClassLoader&quot;)} permission to see if setting the context
2373      * ClassLoader is permitted.
2374      *
2375      * @param  cl
2376      *         the context ClassLoader for this Thread, or null  indicating the
2377      *         system class loader (or, failing that, the bootstrap class loader)
2378      *
2379      * @throws  SecurityException
2380      *          if the current thread cannot set the context ClassLoader
2381      *
2382      * @since 1.2
2383      */
2384     public void setContextClassLoader(ClassLoader cl) {
2385         SecurityManager sm = System.getSecurityManager();
2386         if (sm != null) {
2387             sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
2388         }
2389         contextClassLoader = cl;
2390     }
2391 
2392     /**
2393      * Returns {@code true} if and only if the current thread holds the
2394      * monitor lock on the specified object.
2395      *
2396      * &lt;p&gt;This method is designed to allow a program to assert that
2397      * the current thread already holds a specified lock:
2398      * &lt;pre&gt;
2399      *     assert Thread.holdsLock(obj);
2400      * &lt;/pre&gt;
2401      *
2402      * @param  obj the object on which to test lock ownership
2403      * @throws NullPointerException if obj is {@code null}
2404      * @return {@code true} if the current thread holds the monitor lock on
2405      *         the specified object.
2406      * @since 1.4
2407      */
2408     public static native boolean holdsLock(Object obj);
2409 
2410     private static final StackTraceElement[] EMPTY_STACK_TRACE
2411         = new StackTraceElement[0];
2412 
2413     /**
2414      * Returns an array of stack trace elements representing the stack dump
2415      * of this thread.  This method will return a zero-length array if
2416      * this thread has not started, has started but has not yet been
2417      * scheduled to run by the system, or has terminated.
2418      * If the returned array is of non-zero length then the first element of
2419      * the array represents the top of the stack, which is the most recent
2420      * method invocation in the sequence.  The last element of the array
2421      * represents the bottom of the stack, which is the least recent method
2422      * invocation in the sequence.
2423      *
2424      * &lt;p&gt;If there is a security manager, and this thread is not
2425      * the current thread, then the security manager&#39;s
2426      * {@code checkPermission} method is called with a
2427      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission
2428      * to see if it&#39;s ok to get the stack trace.
2429      *
2430      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
2431      * or more stack frames from the stack trace.  In the extreme case,
2432      * a virtual machine that has no stack trace information concerning
2433      * this thread is permitted to return a zero-length array from this
2434      * method.
2435      *
2436      * @return an array of {@code StackTraceElement},
2437      * each represents one stack frame.
2438      *
2439      * @throws SecurityException
2440      *        if a security manager exists and its
2441      *        {@code checkPermission} method doesn&#39;t allow
2442      *        getting the stack trace of thread.
2443      * @see SecurityManager#checkPermission
2444      * @see RuntimePermission
2445      * @see Throwable#getStackTrace
2446      *
2447      * @since 1.5
2448      */
2449     public StackTraceElement[] getStackTrace() {
2450         if (this != Thread.currentThread()) {
2451             // check for getStackTrace permission
2452             SecurityManager security = System.getSecurityManager();
2453             if (security != null) {
2454                 security.checkPermission(
2455                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
2456             }
2457             // optimization so we do not call into the vm for threads that
2458             // have not yet started or have terminated
2459             if (!isAlive()) {
2460                 return EMPTY_STACK_TRACE;
2461             }
2462             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
2463             StackTraceElement[] stackTrace = stackTraceArray[0];
2464             // a thread that was alive during the previous isAlive call may have
2465             // since terminated, therefore not having a stacktrace.
2466             if (stackTrace == null) {
2467                 stackTrace = EMPTY_STACK_TRACE;
2468             }
2469             return stackTrace;
2470         } else {
2471             return (new Exception()).getStackTrace();
2472         }
2473     }
2474 
2475     /**
2476      * Returns a map of stack traces for all live threads. The map does not
2477      * include virtual threads.
2478      * The map keys are threads and each map value is an array of
2479      * {@code StackTraceElement} that represents the stack dump
2480      * of the corresponding {@code Thread}.
2481      * The returned stack traces are in the format specified for
2482      * the {@link #getStackTrace getStackTrace} method.
2483      *
2484      * &lt;p&gt;The threads may be executing while this method is called.
2485      * The stack trace of each thread only represents a snapshot and
2486      * each stack trace may be obtained at different time.  A zero-length
2487      * array will be returned in the map value if the virtual machine has
2488      * no stack trace information about a thread.
2489      *
2490      * &lt;p&gt;If there is a security manager, then the security manager&#39;s
2491      * {@code checkPermission} method is called with a
2492      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission as well as
2493      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission
2494      * to see if it is ok to get the stack trace of all threads.
2495      *
2496      * @return a {@code Map} from {@code Thread} to an array of
2497      * {@code StackTraceElement} that represents the stack trace of
2498      * the corresponding thread.
2499      *
2500      * @throws SecurityException
2501      *        if a security manager exists and its
2502      *        {@code checkPermission} method doesn&#39;t allow
2503      *        getting the stack trace of thread.
2504      * @see #getStackTrace
2505      * @see SecurityManager#checkPermission
2506      * @see RuntimePermission
2507      * @see Throwable#getStackTrace
2508      *
2509      * @since 1.5
2510      */
2511     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
2512         // check for getStackTrace permission
2513         SecurityManager security = System.getSecurityManager();
2514         if (security != null) {
2515             security.checkPermission(
2516                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
2517             security.checkPermission(
2518                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
2519         }
2520 
2521         // Get a snapshot of the list of all threads
2522         Thread[] threads = getThreads();
2523         StackTraceElement[][] traces = dumpThreads(threads);
2524         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
2525         for (int i = 0; i &lt; threads.length; i++) {
2526             StackTraceElement[] stackTrace = traces[i];
2527             if (stackTrace != null) {
2528                 m.put(threads[i], stackTrace);
2529             }
2530             // else terminated so we don&#39;t put it in the map
2531         }
2532         return m;
2533     }
2534 
2535     /** cache of subclass security audit results */
2536     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
2537      * release */
2538     private static class Caches {
2539         /** cache of subclass security audit results */
2540         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
2541             new ConcurrentHashMap&lt;&gt;();
2542 
2543         /** queue for WeakReferences to audited subclasses */
2544         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
2545             new ReferenceQueue&lt;&gt;();
2546     }
2547 
2548     /**
2549      * Verifies that this (possibly subclass) instance can be constructed
2550      * without violating security constraints: the subclass must not override
2551      * security-sensitive non-final methods, or else the
2552      * &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.
2553      */
2554     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
2555         if (cl == Thread.class)
2556             return false;
2557 
2558         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
2559         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
2560         Boolean result = Caches.subclassAudits.get(key);
2561         if (result == null) {
2562             result = Boolean.valueOf(auditSubclass(cl));
2563             Caches.subclassAudits.putIfAbsent(key, result);
2564         }
2565 
2566         return result.booleanValue();
2567     }
2568 
2569     /**
2570      * Performs reflective checks on given subclass to verify that it doesn&#39;t
2571      * override security-sensitive non-final methods.  Returns true if the
2572      * subclass overrides any of the methods, false otherwise.
2573      */
2574     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
2575         Boolean result = AccessController.doPrivileged(
2576             new PrivilegedAction&lt;&gt;() {
2577                 public Boolean run() {
2578                     for (Class&lt;?&gt; cl = subcl;
2579                          cl != Thread.class;
2580                          cl = cl.getSuperclass())
2581                     {
2582                         try {
2583                             cl.getDeclaredMethod(&quot;getContextClassLoader&quot;, new Class&lt;?&gt;[0]);
2584                             return Boolean.TRUE;
2585                         } catch (NoSuchMethodException ex) {
2586                         }
2587                         try {
2588                             Class&lt;?&gt;[] params = {ClassLoader.class};
2589                             cl.getDeclaredMethod(&quot;setContextClassLoader&quot;, params);
2590                             return Boolean.TRUE;
2591                         } catch (NoSuchMethodException ex) {
2592                         }
2593                     }
2594                     return Boolean.FALSE;
2595                 }
2596             }
2597         );
2598         return result.booleanValue();
2599     }
2600 
2601     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
2602     private static native Thread[] getThreads();
2603 
2604     /**
2605      * Returns the identifier of this Thread.  The thread ID is a positive
2606      * {@code long} number generated when this thread was created.
2607      * The thread ID is unique and remains unchanged during its lifetime.
2608      * When a thread is terminated, this thread ID may be reused.
2609      *
2610      * @return this thread&#39;s ID.
2611      * @since 1.5
2612      */
2613     public long getId() {
2614         return tid;
2615     }
2616 
2617     /**
2618      * A thread state.  A thread can be in one of the following states:
2619      * &lt;ul&gt;
2620      * &lt;li&gt;{@link #NEW}&lt;br&gt;
2621      *     A thread that has not yet started is in this state.
2622      *     &lt;/li&gt;
2623      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
2624      *     A thread executing in the Java virtual machine is in this state.
2625      *     &lt;/li&gt;
2626      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
2627      *     A thread that is blocked waiting for a monitor lock
2628      *     is in this state.
2629      *     &lt;/li&gt;
2630      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
2631      *     A thread that is waiting indefinitely for another thread to
2632      *     perform a particular action is in this state.
2633      *     &lt;/li&gt;
2634      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
2635      *     A thread that is waiting for another thread to perform an action
2636      *     for up to a specified waiting time is in this state.
2637      *     &lt;/li&gt;
2638      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
2639      *     A thread that has exited is in this state.
2640      *     &lt;/li&gt;
2641      * &lt;/ul&gt;
2642      *
2643      * &lt;p&gt;
2644      * A thread can be in only one state at a given point in time.
2645      * These states are virtual machine states which do not reflect
2646      * any operating system thread states.
2647      *
2648      * @since   1.5
2649      * @see #getState
2650      */
2651     public enum State {
2652         /**
2653          * Thread state for a thread which has not yet started.
2654          */
2655         NEW,
2656 
2657         /**
2658          * Thread state for a runnable thread.  A thread in the runnable
2659          * state is executing in the Java virtual machine but it may
2660          * be waiting for other resources from the operating system
2661          * such as processor.
2662          */
2663         RUNNABLE,
2664 
2665         /**
2666          * Thread state for a thread blocked waiting for a monitor lock.
2667          * A thread in the blocked state is waiting for a monitor lock
2668          * to enter a synchronized block/method or
2669          * reenter a synchronized block/method after calling
2670          * {@link Object#wait() Object.wait}.
2671          */
2672         BLOCKED,
2673 
2674         /**
2675          * Thread state for a waiting thread.
2676          * A thread is in the waiting state due to calling one of the
2677          * following methods:
2678          * &lt;ul&gt;
2679          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
2680          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
2681          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
2682          * &lt;/ul&gt;
2683          *
2684          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
2685          * perform a particular action.
2686          *
2687          * For example, a thread that has called {@code Object.wait()}
2688          * on an object is waiting for another thread to call
2689          * {@code Object.notify()} or {@code Object.notifyAll()} on
2690          * that object. A thread that has called {@code Thread.join()}
2691          * is waiting for a specified thread to terminate.
2692          */
2693         WAITING,
2694 
2695         /**
2696          * Thread state for a waiting thread with a specified waiting time.
2697          * A thread is in the timed waiting state due to calling one of
2698          * the following methods with a specified positive waiting time:
2699          * &lt;ul&gt;
2700          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
2701          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
2702          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
2703          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
2704          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
2705          * &lt;/ul&gt;
2706          */
2707         TIMED_WAITING,
2708 
2709         /**
2710          * Thread state for a terminated thread.
2711          * The thread has completed execution.
2712          */
2713         TERMINATED;
2714     }
2715 
2716     /**
2717      * Returns the state of this thread.
2718      * This method is designed for use in monitoring of the system state,
2719      * not for synchronization control.
2720      *
2721      * @return this thread&#39;s state.
2722      * @since 1.5
2723      */
2724     public State getState() {
2725         return threadState();
2726     }
2727 
2728     /**
2729      * Returns the state of this thread.
2730      *
2731      * @apiNote For VirtualThread use as getState may be overridden and run
2732      * arbitrary code.
2733      */
2734     State threadState() {
2735         return jdk.internal.misc.VM.toThreadState(holder.threadStatus);
2736     }
2737 
2738     // Added in JSR-166
2739 
2740     /**
2741      * Interface for handlers invoked when a {@code Thread} abruptly
2742      * terminates due to an uncaught exception.
2743      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
2744      * the Java Virtual Machine will query the thread for its
2745      * {@code UncaughtExceptionHandler} using
2746      * {@link #getUncaughtExceptionHandler} and will invoke the handler&#39;s
2747      * {@code uncaughtException} method, passing the thread and the
2748      * exception as arguments.
2749      * If a thread has not had its {@code UncaughtExceptionHandler}
2750      * explicitly set, then its {@code ThreadGroup} object acts as its
2751      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
2752      * has no
2753      * special requirements for dealing with the exception, it can forward
2754      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
2755      * default uncaught exception handler}.
2756      *
2757      * @see #setDefaultUncaughtExceptionHandler
2758      * @see #setUncaughtExceptionHandler
2759      * @see ThreadGroup#uncaughtException
2760      * @since 1.5
2761      */
2762     @FunctionalInterface
2763     public interface UncaughtExceptionHandler {
2764         /**
2765          * Method invoked when the given thread terminates due to the
2766          * given uncaught exception.
2767          * &lt;p&gt;Any exception thrown by this method will be ignored by the
2768          * Java Virtual Machine.
2769          * @param t the thread
2770          * @param e the exception
2771          */
2772         void uncaughtException(Thread t, Throwable e);
2773     }
2774 
2775     // null unless explicitly set
2776     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
2777 
2778     // null unless explicitly set
2779     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
2780 
2781     /**
2782      * Set the default handler invoked when a thread abruptly terminates
2783      * due to an uncaught exception, and no other handler has been defined
2784      * for that thread.
2785      *
2786      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
2787      * by the thread&#39;s {@link ThreadGroup} object and finally by the default
2788      * uncaught exception handler. If the thread does not have an explicit
2789      * uncaught exception handler set, and the thread&#39;s thread group
2790      * (including parent thread groups)  does not specialize its
2791      * {@code uncaughtException} method, then the default handler&#39;s
2792      * {@code uncaughtException} method will be invoked.
2793      * &lt;p&gt;By setting the default uncaught exception handler, an application
2794      * can change the way in which uncaught exceptions are handled (such as
2795      * logging to a specific device, or file) for those threads that would
2796      * already accept whatever &amp;quot;default&amp;quot; behavior the system
2797      * provided.
2798      *
2799      * &lt;p&gt;Note that the default uncaught exception handler should not usually
2800      * defer to the thread&#39;s {@code ThreadGroup} object, as that could cause
2801      * infinite recursion.
2802      *
2803      * @param eh the object to use as the default uncaught exception handler.
2804      * If {@code null} then there is no default handler.
2805      *
2806      * @throws SecurityException if a security manager is present and it denies
2807      *         {@link RuntimePermission}{@code (&quot;setDefaultUncaughtExceptionHandler&quot;)}
2808      *
2809      * @see #setUncaughtExceptionHandler
2810      * @see #getUncaughtExceptionHandler
2811      * @see ThreadGroup#uncaughtException
2812      * @since 1.5
2813      */
2814     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2815         SecurityManager sm = System.getSecurityManager();
2816         if (sm != null) {
2817             sm.checkPermission(
2818                 new RuntimePermission(&quot;setDefaultUncaughtExceptionHandler&quot;)
2819                     );
2820         }
2821 
2822          defaultUncaughtExceptionHandler = eh;
2823      }
2824 
2825     /**
2826      * Returns the default handler invoked when a thread abruptly terminates
2827      * due to an uncaught exception. If the returned value is {@code null},
2828      * there is no default.
2829      * @since 1.5
2830      * @see #setDefaultUncaughtExceptionHandler
2831      * @return the default uncaught exception handler for all threads
2832      */
2833     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
2834         return defaultUncaughtExceptionHandler;
2835     }
2836 
2837     /**
2838      * Returns the handler invoked when this thread abruptly terminates
2839      * due to an uncaught exception. If this thread has not had an
2840      * uncaught exception handler explicitly set then this thread&#39;s
2841      * {@code ThreadGroup} object is returned, unless this thread
2842      * has terminated, in which case {@code null} is returned.
2843      * @since 1.5
2844      * @return the uncaught exception handler for this thread
2845      */
2846     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
2847         return uncaughtExceptionHandler != null ?
2848             uncaughtExceptionHandler : getThreadGroup();
2849     }
2850 
2851     /**
2852      * Set the handler invoked when this thread abruptly terminates
2853      * due to an uncaught exception.
2854      * &lt;p&gt;A thread can take full control of how it responds to uncaught
2855      * exceptions by having its uncaught exception handler explicitly set.
2856      * If no such handler is set then the thread&#39;s {@code ThreadGroup}
2857      * object acts as its handler.
2858      * @param eh the object to use as this thread&#39;s uncaught exception
2859      * handler. If {@code null} then this thread has no explicit handler.
2860      * @throws  SecurityException  if the current thread is not allowed to
2861      *          modify this thread.
2862      * @see #setDefaultUncaughtExceptionHandler
2863      * @see ThreadGroup#uncaughtException
2864      * @since 1.5
2865      */
2866     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2867         checkAccess();
2868         uncaughtExceptionHandler(eh);
2869     }
2870 
2871     private void uncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2872         uncaughtExceptionHandler = eh;
2873     }
2874 
2875     /**
2876      * Dispatch an uncaught exception to the handler. This method is
2877      * called when a thread terminates with an exception.
2878      */
2879     void dispatchUncaughtException(Throwable e) {
2880         getUncaughtExceptionHandler().uncaughtException(this, e);
2881     }
2882 
2883     /**
2884      * Removes from the specified map any keys that have been enqueued
2885      * on the specified reference queue.
2886      */
2887     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2888                              ConcurrentMap&lt;? extends
2889                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2890     {
2891         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2892         while((ref = queue.poll()) != null) {
2893             map.remove(ref);
2894         }
2895     }
2896 
2897     /**
2898      *  Weak key for Class objects.
2899      **/
2900     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2901         /**
2902          * saved value of the referent&#39;s identity hash code, to maintain
2903          * a consistent hash code after the referent has been cleared
2904          */
2905         private final int hash;
2906 
2907         /**
2908          * Create a new WeakClassKey to the given object, registered
2909          * with a queue.
2910          */
2911         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2912             super(cl, refQueue);
2913             hash = System.identityHashCode(cl);
2914         }
2915 
2916         /**
2917          * Returns the identity hash code of the original referent.
2918          */
2919         @Override
2920         public int hashCode() {
2921             return hash;
2922         }
2923 
2924         /**
2925          * Returns true if the given object is this identical
2926          * WeakClassKey instance, or, if this object&#39;s referent has not
2927          * been cleared, if the given object is another WeakClassKey
2928          * instance with the identical non-null referent as this one.
2929          */
2930         @Override
2931         public boolean equals(Object obj) {
2932             if (obj == this)
2933                 return true;
2934 
2935             if (obj instanceof WeakClassKey) {
2936                 Object referent = get();
2937                 return (referent != null) &amp;&amp;
2938                        (referent == ((WeakClassKey) obj).get());
2939             } else {
2940                 return false;
2941             }
2942         }
2943     }
2944 
2945     private static class VirtualThreads {
2946         static final ThreadGroup THREAD_GROUP = threadGroup();
2947         static final AccessControlContext ACCESS_CONTROL_CONTEXT = accessControlContext();
2948 
2949         /**
2950          * The thread group for virtual threads.
2951          */
2952         private static ThreadGroup threadGroup() {
2953             return AccessController.doPrivileged(new PrivilegedAction&lt;ThreadGroup&gt;() {
2954                 public ThreadGroup run() {
2955                     ThreadGroup group = Thread.currentCarrierThread().getThreadGroup();
2956                     for (ThreadGroup p; (p = group.getParent()) != null; )
2957                         group = p;
2958                     var newGroup = new ThreadGroup(group, &quot;VirtualThreads&quot;, true);
2959                     newGroup.setDaemon(true);
2960                     return newGroup;
2961                 }});
2962         }
2963 
2964         /**
2965          * Return an AccessControlContext that doesn&#39;t support any permissions.
2966          */
2967         private static AccessControlContext accessControlContext() {
2968             return new AccessControlContext(new ProtectionDomain[] {
2969                 new ProtectionDomain(null, null)
2970             });
2971         }
2972     }
2973 
2974     // The following three initially uninitialized fields are exclusively
2975     // managed by class java.util.concurrent.ThreadLocalRandom. These
2976     // fields are used to build the high-performance PRNGs in the
2977     // concurrent code. Upcoming changes in the concurrent code avoid
2978     // needing to use @Contented here.
2979 
2980     /** The current seed for a ThreadLocalRandom */
2981     long threadLocalRandomSeed;
2982 
2983     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2984     int threadLocalRandomProbe;
2985 
2986     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2987     int threadLocalRandomSecondarySeed;
2988 
2989     /* Some private helper methods */
2990     private native void setPriority0(int newPriority);
2991     private native void stop0(Object o);
2992     private native void suspend0();
2993     private native void resume0();
2994     private native void interrupt0();
2995     private static native void clearInterruptEvent();
2996     private native void setNativeName(String name);
2997 }
    </pre>
  </body>
</html>