<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.invoke.VarHandle;
  30 import java.lang.ref.Reference;
  31 import java.lang.ref.ReferenceQueue;
  32 import java.lang.ref.WeakReference;
  33 import java.security.AccessController;
  34 import java.security.AccessControlContext;
  35 import java.security.PrivilegedAction;
  36 import java.security.ProtectionDomain;
  37 import java.time.Duration;
  38 import java.util.Map;
  39 import java.util.HashMap;
  40 import java.util.Objects;
  41 import java.util.concurrent.ConcurrentHashMap;
  42 import java.util.concurrent.ConcurrentMap;
  43 import java.util.concurrent.Executor;
  44 import java.util.concurrent.ThreadFactory;
  45 import java.util.concurrent.TimeUnit;
  46 import java.util.concurrent.locks.LockSupport;
  47 
  48 import jdk.internal.misc.TerminatingThreadLocal;
  49 import jdk.internal.misc.Unsafe;
  50 import sun.nio.ch.Interruptible;
  51 import jdk.internal.reflect.CallerSensitive;
  52 import jdk.internal.reflect.Reflection;
  53 import sun.security.util.SecurityConstants;
  54 import jdk.internal.HotSpotIntrinsicCandidate;
  55 
  56 /**
  57  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  58  * virtual machine allows an application to have multiple threads of
  59  * execution running concurrently.
  60  *
  61  * &lt;p&gt; {@code Thread} supports the creation of threads that are scheduled by the
  62  * operating system. These threads are sometimes known as &lt;i&gt;kernel threads&lt;/i&gt;
  63  * or &lt;i&gt;heavyweight threads&lt;/i&gt; and will usually have a large stack and other
  64  * resources that are maintained by the operating system. Kernel threads are
  65  * suitable for executing all tasks but they are a limited resource.
  66  *
  67  * &lt;p&gt; {@code Thread} also supports the creation of &lt;i&gt;virtual threads&lt;/i&gt; that
  68  * are scheduled by the Java virtual machine rather than the operating system.
  69  * Virtual threads will typically require few resources and a single Java virtual
  70  * machine may support millions of virtual threads. Virtual threads are suitable
  71  * for executing tasks that spend most of the time blocked, often waiting for
  72  * synchronous blocking I/O operations to complete.
  73  * Virtual threads execute on a pool of &lt;i&gt;carrier threads&lt;/i&gt;, essentially
  74  * a pool of kernel threads that have been created and allocated to support the
  75  * execution of virtual threads. Locking and I/O operations are the &lt;i&gt;scheduling
  76  * points&lt;/i&gt; where a carrier thread is re-scheduled from one virtual thread to
  77  * another. Code executing in virtual threads will usually not be aware of the
  78  * underlying carrier thread, and in particular, the {@linkplain Thread#currentThread()}
  79  * method, to obtain a reference to the &lt;i&gt;current thread&lt;/i&gt;, will return the
  80  * {@code Thread} object for the virtual thread.
  81  *
  82  * &lt;p&gt; {@code Thread} defines factory methods, and a {@linkplain Builder} API,
  83  * for creating kernel or virtual threads. It also defines (for compatibility and
  84  * customization reasons) constructors for creating kernel threads. Newer code
  85  * is encouraged to use the factory methods or the builder rather than the constructors.
  86  *
  87  * &lt;p&gt; Kernel threads are designated &lt;i&gt;daemon&lt;/i&gt; or &lt;i&gt;non-daemon&lt;/i&gt; threads.
  88  * When the Java virtual machine starts up, there is usually one non-daemon
  89  * thread (the thread that typically calls the applications&#39;s {@code main} method).
  90  * The Java virtual machine terminates when all non-daemon threads have terminated.
  91  * The Java virtual machine can also be terminated by invoking the
  92  * {@linkplain Runtime#exit(int)} method, in which case it will terminate even
  93  * if there are many non-daemon threads still running. The daemon status of
  94  * virtual threads is meaningless and have no influence on when the Java virtual
  95  * machine terminates.
  96  *
  97  * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to a constructor
  98  * or method in this class will cause a {@link NullPointerException} to be
  99  * thrown.
 100  *
 101  * @author  unascribed
 102  * @see     Runtime#exit(int)
 103  * @since   1.0
 104  */
 105 public class Thread implements Runnable {
 106     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 107     private static native void registerNatives();
 108     static {
 109         registerNatives();
 110     }
 111 
 112     /* Reserved for exclusive use by the JVM, TBD: move to FieldHolder */
 113     private long eetop;
 114 
 115     // holds fields for kernel threads
 116     private static class FieldHolder {
 117         final ThreadGroup group;
 118         final Runnable task;
 119         final long stackSize;
 120         int priority;
 121         boolean daemon;
 122         volatile int threadStatus;
 123         boolean stillborn;
 124 
 125         FieldHolder(ThreadGroup group,
 126                     Runnable task,
 127                     long stackSize,
 128                     int priority,
 129                     boolean daemon) {
 130             this.group = group;
 131             this.task = task;
 132             this.stackSize = stackSize;
 133             this.priority = priority;
 134             this.daemon = daemon;
 135         }
 136     }
 137     private final FieldHolder holder;
 138     
 139     // interrupt status (read/written by VM)
 140     volatile boolean interrupted;
 141 
 142     // thread name
 143     private volatile String name;
 144 
 145     // thread id
 146     private final long tid;
 147 
 148     // context ClassLoader
 149     private ClassLoader contextClassLoader;
 150 
 151     // inherited AccessControlContext, TBD: move this to FieldHolder
 152     private AccessControlContext inheritedAccessControlContext;
 153 
 154     /* For autonumbering anonymous threads. */
 155     private static int threadInitNumber;
 156     private static synchronized int nextThreadNum() {
 157         return threadInitNumber++;
 158     }
 159 
 160     /* ThreadLocal values pertaining to this thread. This map is maintained
 161      * by the ThreadLocal class. */
 162     ThreadLocal.ThreadLocalMap threadLocals = null;
 163 
 164     /*
 165      * InheritableThreadLocal values pertaining to this thread. This map is
 166      * maintained by the InheritableThreadLocal class.
 167      */
 168     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 169 
 170     /**
 171      * Helper class to generate unique thread identifiers. The identifiers start
 172      * at 2 as this class cannot be used during early startup to generate the
 173      * identifier for the primordial thread.
 174      */
 175     private static class ThreadIdentifiers {
 176         private static final Unsafe U = Unsafe.getUnsafe();
 177         private static final long nextTidOffset =
 178             U.objectFieldOffset(ThreadIdentifiers.class, &quot;nextTid&quot;);
 179         private static volatile long nextTid = 2;
 180         private static long next() {
 181             return U.getAndAddLong(ThreadIdentifiers.class, nextTidOffset, 1);
 182         }
 183     }
 184 
 185     /*
 186      * Lock object for thread interrupt.
 187      */
 188     final Object interruptLock = new Object();
 189 
 190     /**
 191      * The argument supplied to the current call to
 192      * java.util.concurrent.locks.LockSupport.park.
 193      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 194      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 195      */
 196     private volatile Object parkBlocker;
 197 
 198     /* The object in which this thread is blocked in an interruptible I/O
 199      * operation, if any.  The blocker&#39;s interrupt method should be invoked
 200      * after setting this thread&#39;s interrupt status.
 201      */
 202     volatile Interruptible nioBlocker;
 203 
 204     /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
 205      * from java.nio code
 206      */
 207     static void blockedOn(Interruptible b) {
 208         Thread me = Thread.currentThread();
 209         synchronized (me.interruptLock) {
 210             me.nioBlocker = b;
 211         }
 212     }
 213 
 214     /**
 215      * The minimum priority that a thread can have.
 216      */
 217     public static final int MIN_PRIORITY = 1;
 218 
 219    /**
 220      * The default priority that is assigned to a thread.
 221      */
 222     public static final int NORM_PRIORITY = 5;
 223 
 224     /**
 225      * The maximum priority that a thread can have.
 226      */
 227     public static final int MAX_PRIORITY = 10;
 228 
 229     // current inner-most continuation
 230     private Continuation cont;
 231 
 232     // the virtual thread mounted on this thread
 233     private VirtualThread vthread;
 234 
 235     /**
 236      * Sets the virtual thread that is currently mounted on this thread.
 237      */
 238     void setVirtualThread(VirtualThread vthread) {
 239         // assert this == currentThread0();
 240         this.vthread = vthread;
 241     }
 242 
 243     /**
 244      * Returns the virtual thread that is currently mounted on this thread.
 245      */
 246     VirtualThread getVirtualThread() {
 247         // assert this == currentThread0();
 248         return vthread;
 249     }
 250 
 251     /**
 252      * Returns the Thread object for the current thread.
 253      *
 254      * @return  the current thread
 255      */
 256     public static Thread currentThread() {
 257         Thread t = currentThread0();
 258         VirtualThread vthread = t.vthread;
 259         if (vthread != null) {
 260             return vthread;
 261         } else {
 262             return t;
 263         }
 264     }
 265 
 266     /**
 267      * Returns the current carrier thread.
 268      */
 269     static Thread currentCarrierThread() {
 270         return currentThread0();
 271     }
 272 
 273     // Scoped support:
 274 
 275     /**
 276      * TBD
 277      * @return TBD
 278      */
 279     @HotSpotIntrinsicCandidate
 280     static native Object[] scopedCache();
 281 
 282     @HotSpotIntrinsicCandidate
 283     static native void setScopedCache(Object[] cache);
 284 
 285     // A simple (not very) random string of bits to use when evicting
 286     // cache entries.
 287     int victims
 288         = 0b1100_1001_0000_1111_1101_1010_1010_0010;
 289 
 290     private ScopedMap scopedMap;
 291 
 292     final ScopedMap scopedMap() {
 293         var map = scopedMap;
 294         if (map == null) {
 295             map = scopedMap = new ScopedMap();
 296         }
 297         return map;
 298     }
 299 
 300     // end Scoped support
 301 
 302     /**
 303      * TBD
 304      * @return TBD
 305      */
 306     @HotSpotIntrinsicCandidate
 307     static native Thread currentThread0();
 308 
 309     /**
 310      * A hint to the scheduler that the current thread is willing to yield
 311      * its current use of a processor. The scheduler is free to ignore this
 312      * hint.
 313      *
 314      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 315      * between threads that would otherwise over-utilise a CPU. Its use
 316      * should be combined with detailed profiling and benchmarking to
 317      * ensure that it actually has the desired effect.
 318      *
 319      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 320      * for debugging or testing purposes, where it may help to reproduce
 321      * bugs due to race conditions. It may also be useful when designing
 322      * concurrency control constructs such as the ones in the
 323      * {@link java.util.concurrent.locks} package.
 324      */
 325     public static void yield() {
 326         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 327         if (vthread != null) {
 328             vthread.tryYield();
 329         } else {
 330             yield0();
 331         }
 332     }
 333     private static native void yield0();
 334 
 335     /**
 336      * Causes the currently executing thread to sleep (temporarily cease
 337      * execution) for the specified number of milliseconds, subject to
 338      * the precision and accuracy of system timers and schedulers. The thread
 339      * does not lose ownership of any monitors.
 340      *
 341      * @param  millis
 342      *         the length of time to sleep in milliseconds
 343      *
 344      * @throws  IllegalArgumentException
 345      *          if the value of {@code millis} is negative
 346      *
 347      * @throws  InterruptedException
 348      *          if any thread has interrupted the current thread. The
 349      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 350      *          cleared when this exception is thrown.
 351      */
 352     public static void sleep(long millis) throws InterruptedException {
 353         if (millis &lt; 0) {
 354             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 355         }
 356         VirtualThread vthread = currentCarrierThread().getVirtualThread();
 357         if (vthread != null) {
 358             vthread.sleepNanos(TimeUnit.MILLISECONDS.toNanos(millis));
 359         } else {
 360             sleep0(millis);
 361         }
 362     }
 363     private static native void sleep0(long millis) throws InterruptedException;
 364 
 365     /**
 366      * Causes the currently executing thread to sleep (temporarily cease
 367      * execution) for the specified number of milliseconds plus the specified
 368      * number of nanoseconds, subject to the precision and accuracy of system
 369      * timers and schedulers. The thread does not lose ownership of any
 370      * monitors.
 371      *
 372      * @param  millis
 373      *         the length of time to sleep in milliseconds
 374      *
 375      * @param  nanos
 376      *         {@code 0-999999} additional nanoseconds to sleep
 377      *
 378      * @throws  IllegalArgumentException
 379      *          if the value of {@code millis} is negative, or the value of
 380      *          {@code nanos} is not in the range {@code 0-999999}
 381      *
 382      * @throws  InterruptedException
 383      *          if any thread has interrupted the current thread. The
 384      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 385      *          cleared when this exception is thrown.
 386      */
 387     public static void sleep(long millis, int nanos) throws InterruptedException {
 388         if (millis &lt; 0) {
 389             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 390         }
 391 
 392         if (nanos &lt; 0 || nanos &gt; 999999) {
 393             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
 394         }
 395 
 396         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
 397             millis++;
 398         }
 399 
 400         sleep(millis);
 401     }
 402 
 403     /**
 404      * Causes the currently executing thread to sleep (temporarily cease
 405      * execution) for the specified duration, subject to the precision and
 406      * accuracy of system timers and schedulers. This method is a no-op if
 407      * the duration is less than zero.
 408      *
 409      * @param  duration
 410      *         the duration to sleep
 411      *
 412      * @throws  InterruptedException
 413      *          if the current thread is interrupted while sleeping. The
 414      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 415      *          cleared when this exception is thrown.
 416      *
 417      * @since 99
 418      */
 419     public static void sleep(Duration duration) throws InterruptedException {
 420         if (!duration.isNegative()) {
 421             // ignore nano precision for now
 422             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
 423             sleep(millis);
 424         }
 425     }
 426 
 427     /**
 428      * Indicates that the caller is momentarily unable to progress, until the
 429      * occurrence of one or more actions on the part of other activities. By
 430      * invoking this method within each iteration of a spin-wait loop construct,
 431      * the calling thread indicates to the runtime that it is busy-waiting.
 432      * The runtime may take action to improve the performance of invoking
 433      * spin-wait loop constructions.
 434      *
 435      * @apiNote
 436      * As an example consider a method in a class that spins in a loop until
 437      * some flag is set outside of that method. A call to the {@code onSpinWait}
 438      * method should be placed inside the spin loop.
 439      * &lt;pre&gt;{@code
 440      *     class EventHandler {
 441      *         volatile boolean eventNotificationNotReceived;
 442      *         void waitForEventAndHandleIt() {
 443      *             while ( eventNotificationNotReceived ) {
 444      *                 java.lang.Thread.onSpinWait();
 445      *             }
 446      *             readAndProcessEvent();
 447      *         }
 448      *
 449      *         void readAndProcessEvent() {
 450      *             // Read event from some source and process it
 451      *              . . .
 452      *         }
 453      *     }
 454      * }&lt;/pre&gt;
 455      * &lt;p&gt;
 456      * The code above would remain correct even if the {@code onSpinWait}
 457      * method was not called at all. However on some architectures the Java
 458      * Virtual Machine may issue the processor instructions to address such
 459      * code patterns in a more beneficial way.
 460      *
 461      * @since 9
 462      */
 463     @HotSpotIntrinsicCandidate
 464     public static void onSpinWait() {}
 465 
 466     /**
 467      * Returns the context class loader to inherit from the given parent thread
 468      */
 469     private static ClassLoader contextClassLoader(Thread parent) {
 470         SecurityManager sm = System.getSecurityManager();
 471         if (sm == null || isCCLOverridden(parent.getClass())) {
 472             return parent.getContextClassLoader();
 473         } else {
 474             return parent.contextClassLoader;
 475         }
 476     }
 477 
 478     /**
 479      * Initializes a kernel Thread.
 480      *
 481      * @param g the Thread group
 482      * @param name the name of the new Thread
 483      * @param characteristics thread characteristics
 484      * @param task the object whose run() method gets called
 485 
 486      * @param stackSize the desired stack size for the new thread, or
 487      *        zero to indicate that this parameter is to be ignored.
 488      * @param acc the AccessControlContext to inherit, or
 489      *            AccessController.getContext() if null
 490      * @throws IllegalArgumentException if invalid characteristics are specified
 491      */
 492     private Thread(ThreadGroup g, String name, int characteristics, Runnable task,
 493                    long stackSize, AccessControlContext acc) {
 494         if (name == null) {
 495             throw new NullPointerException(&quot;name cannot be null&quot;);
 496         }
 497         checkCharacteristics(characteristics);
 498 
 499         Thread parent = currentThread();
 500         boolean primordial = (parent == this);
 501 
 502         SecurityManager security = System.getSecurityManager();
 503         if (g == null) {
 504             /* Determine if it&#39;s an applet or not */
 505 
 506             /* If there is a security manager, ask the security manager
 507                what to do. */
 508             if (security != null) {
 509                 g = security.getThreadGroup();
 510             }
 511 
 512             /* If the security manager doesn&#39;t have a strong opinion
 513                on the matter, use the parent thread group. */
 514             if (g == null) {
 515                 g = parent.getThreadGroup();
 516             }
 517         }
 518 
 519         /* checkAccess regardless of whether or not threadgroup is
 520            explicitly passed in. */
 521         g.checkAccess();
 522 
 523         /*
 524          * Do we have the required permissions?
 525          */
 526         if (security != null) {
 527             if (isCCLOverridden(getClass())) {
 528                 security.checkPermission(
 529                         SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
 530             }
 531         }
 532 
 533         g.addUnstarted();
 534 
 535         this.name = name;
 536         this.tid = primordial ? 1 : ThreadIdentifiers.next();
 537         this.contextClassLoader = contextClassLoader(parent);
 538         this.inheritedAccessControlContext = (acc != null) ? acc : AccessController.getContext();
 539 
 540         // thread locals
 541         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 542             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 543             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 544         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 545             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 546             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 547                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 548             }
 549         }
 550 
 551         int priority;
 552         boolean daemon;
 553         if (primordial) {
 554             // primordial or attached thread
 555             priority = NORM_PRIORITY;
 556             daemon = false;
 557         } else {
 558             priority = parent.getPriority();
 559             daemon = parent.isDaemon();
 560         }
 561         this.holder = new FieldHolder(g, task, stackSize, priority, daemon);
 562     }
 563 
 564     /**
 565      * Initializes a virtual Thread.
 566      *
 567      * @param name thread name, can be null
 568      * @param characteristics thread characteristics
 569      * @throws IllegalArgumentException if invalid characteristics are specified
 570      */
 571     Thread(String name, int characteristics) {
 572         checkCharacteristics(characteristics);
 573 
 574         Thread parent = currentThread();
 575 
 576         this.name = (name != null) ? name : &quot;&lt;unnamed&gt;&quot;;
 577         this.tid = ThreadIdentifiers.next();
 578         this.contextClassLoader = contextClassLoader(parent);
 579         this.inheritedAccessControlContext = VirtualThreads.ACCESS_CONTROL_CONTEXT;
 580 
 581         // thread locals
 582         if ((characteristics &amp; NO_THREAD_LOCALS) != 0) {
 583             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 584             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
 585         } else if ((characteristics &amp; INHERIT_THREAD_LOCALS) != 0) {
 586             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
 587             if (parentMap != null &amp;&amp; parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
 588                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
 589             }
 590         }
 591 
 592         // no additional fields
 593         this.holder = null;
 594     }
 595 
 596     /**
 597      * Returns a builder for creating {@code Thread} or {@code ThreadFactory} objects.
 598      *
 599      * @apiNote The following are examples using the builder:
 600      *
 601      * &lt;pre&gt;{@code
 602      *   // Create a daemon thread that is scheduled by the operating system
 603      *   Thread thread = Thread.builder()
 604      *                 .name(&quot;duke&quot;)
 605      *                 .daemon(true)
 606      *                 .priority(Thread.NORM_PRIORITY)
 607      *                 .inheritThreadLocals()
 608      *                 .task(...)
 609      *                 .build();
 610      *
 611      *   // A ThreadFactory that creates daemon threads named &quot;worker-0&quot;, &quot;worker-1&quot;, ...
 612      *   ThreadFactory factory = Thread.builder().daemon(true).name(&quot;worker-&quot;, 0).factory();
 613      *
 614      *   // Create an unnamed virtual thread
 615      *   Thread thread1 = Thread.builder().virtual().task(...).build();
 616      *
 617      *   // Create a named virtual thread
 618      *   Thread thread2 = Thread.builder().virtual().name(&quot;duke&quot;).task(...).build();
 619      *
 620      *   // Create and start a virtual thread
 621      *   Thread thread = Thread.builder().virtual().task(...).start();
 622      *
 623      *   // A ThreadFactory that creates virtual threads
 624      *   ThreadFactory factory = Thread.builder().virtual().factory();
 625      *
 626      *   // A ThreadFactory that creates virtual threads and uses a custom scheduler
 627      *   Executor scheduler = ...
 628      *   ThreadFactory factory = Thread.builder().virtual(scheduler).factory();
 629      * }&lt;/pre&gt;
 630      *
 631      * @return A builder for creating {@code Thread} or {@code ThreadFactory} objects.
 632      *
 633      * @since 99
 634      */
 635     public static Builder builder() {
 636         return new BuilderImpl();
 637     }
 638 
 639     /**
 640      * A mutable builder for a {@link Thread} or {@link ThreadFactory}.
 641      *
 642      * &lt;p&gt; {@code Builder} defines methods to set the {@code Thread} characteristics
 643      * and features. Once set, a {@code Thread} or {@code ThreadFactory} can be
 644      * created with the following methods:
 645      *
 646      * &lt;ul&gt;
 647      *     &lt;li&gt; The {@linkplain #build() build} method creates an unstarted {@code Thread}.
 648      *     &lt;li&gt; The {@linkplain #start() start} method creates and starts a {@code Thread}.
 649      *     &lt;li&gt; The {@linkplain #factory() factory} method creates a {@code ThreadFactory}.
 650      * &lt;/ul&gt;
 651      *
 652      * &lt;p&gt; A {@code Builder} is not thread safe. The {@code ThreadFactory}
 653      * returned by the builder&#39;s {@code factory() method} is thread safe.
 654      *
 655      * &lt;p&gt; Unless otherwise specified, passing a null argument to a method in
 656      * this interface causes a {@code NullPointerException} to be thrown.
 657      *
 658      * @apiNote {@code Builder} checks invariants as components are added to the builder.
 659      * The rationale for this is to detect errors as early as possible and not defer
 660      * all validation to the {@code build} method.
 661      *
 662      * @see Thread#builder()
 663      * @since 99
 664      */
 665     public interface Builder {
 666 
 667         /**
 668          * Sets the thread group.
 669          *
 670          * &lt;p&gt; The thread group for threads that are scheduled by the Java virtual
 671          * machine threads does not support all features of regular thread groups.
 672          * The thread group can only be set for threads that are scheduled by
 673          * the operating system.
 674          *
 675          * @param group the thread group
 676          * @return this builder
 677          * @throws IllegalStateException if this is a builder for a virtual thread
 678          */
 679         Builder group(ThreadGroup group);
 680 
 681         /**
 682          * Sets the thread name.
 683          * @param name thread name
 684          * @return this builder
 685          */
 686         Builder name(String name);
 687 
 688         /**
 689          * Sets the thread name to be the concatenation of a string prefix and
 690          * a counter value.
 691          * @param prefix thread name prefix
 692          * @param start counter start
 693          * @return this builder
 694          * @throws IllegalArgumentException if count is negative
 695          */
 696         Builder name(String prefix, int start);
 697 
 698         /**
 699          * The thread will be scheduled by the Java virtual machine rather than
 700          * the operating system with the default scheduler.
 701          * @return this builder
 702          * @throws IllegalStateException if a thread group has been set
 703          */
 704         Builder virtual();
 705 
 706         /**
 707          * The thread will be scheduled by the Java virtual machine rather than
 708          * the operating system with the given scheduler.
 709          * @param scheduler the scheduler
 710          * @return this builder
 711          * @throws IllegalStateException if a thread group has been set
 712          */
 713         Builder virtual(Executor scheduler);
 714 
 715         /**
 716          * Disallow threads locals.
 717          * @return this builder
 718          * @throws IllegalStateException if inheritThreadLocals has already been set
 719          */
 720         Builder disallowThreadLocals();
 721 
 722         /**
 723          * Inherit threads locals. Thread locals are inherited when the {@code Thread}
 724          * is created with the {@link #build() build} method or when the thread
 725          * factory {@link ThreadFactory#newThread(Runnable) newThread} method
 726          * is invoked.
 727          * @return this builder
 728          * @throws IllegalStateException if disallowThreadLocals has already been set
 729          */
 730         Builder inheritThreadLocals();
 731 
 732         /**
 733          * Sets the daemon status.
 734          * @param on {@code true} to create daemon threads
 735          * @return this builder
 736          */
 737         Builder daemon(boolean on);
 738 
 739         /**
 740          * Sets the thread priority.
 741          * @param priority priority
 742          * @return this builder
 743          * @throws IllegalArgumentException if the priority is less than
 744          *        {@link Thread#MIN_PRIORITY} or greater than {@link Thread#MAX_PRIORITY}
 745          */
 746         Builder priority(int priority);
 747 
 748         /**
 749          * Sets the uncaught exception handler.
 750          * @param ueh uncaught exception handler
 751          * @return this builder
 752          */
 753         Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);
 754 
 755         /**
 756          * The thread is &lt;em&gt;managed&lt;/em&gt;.
 757          * @return this builder
 758          */
 759         Builder managed();
 760 
 761         /**
 762          * Sets the task for the thread to run.
 763          * @param task the task to run
 764          * @return this builder
 765          */
 766         Builder task(Runnable task);
 767 
 768         /**
 769          * Creates a new unstarted {@code Thread} from the current state of the
 770          * builder.
 771          *
 772          * @return a new unstarted Thread
 773          * @throws IllegalStateException if the task object to run object has not been set
 774          * @throws SecurityException if a thread group has been set and the current thread
 775          *         cannot create a thread in that thread group
 776          */
 777         Thread build();
 778 
 779         /**
 780          * Returns a {@code ThreadFactory} to create threads from the current
 781          * state of the builder. The returned thread factory is safe for use by
 782          * multiple concurrent threads.
 783          *
 784          * @return a thread factory to create threads
 785          */
 786         ThreadFactory factory();
 787 
 788         /**
 789          * Creates a new {@code Thread} from the current state of the builder
 790          * and starts it as if by invoking the {@linkplain Thread#start() start}
 791          * method.
 792          *
 793          * @implSpec The default implementation invokes {@linkplain #build() build}
 794          * to create a {@code Thread} and then invokes its {@linkplain Thread#start()
 795          * start} method to start it.
 796          *
 797          * @return The started thread
 798          * @throws IllegalStateException if the task object to run object has not been set
 799          * @throws SecurityException if a thread group has been set and the current thread
 800          *         cannot create a thread in that thread group
 801          */
 802         default Thread start() {
 803             Thread thread = build();
 804             thread.start();
 805             return thread;
 806         }
 807     }
 808 
 809     private static class BuilderImpl implements Builder {
 810         private ThreadGroup group;
 811         private Executor scheduler;
 812         private String name;
 813         private int counter;
 814         private boolean virtual;
 815         private boolean disallowThreadLocals;
 816         private boolean inheritThreadLocals;
 817         private boolean daemon;
 818         private boolean daemonChanged;
 819         private int priority;
 820         private UncaughtExceptionHandler uhe;
 821         private Runnable task;
 822 
 823         BuilderImpl() { }
 824 
 825         private int characteristics() {
 826             int characteristics = 0;
 827             if (virtual)
 828                 characteristics |= Thread.VIRTUAL;
 829             if (disallowThreadLocals)
 830                 characteristics |= Thread.NO_THREAD_LOCALS;
 831             if (inheritThreadLocals)
 832                 characteristics |= Thread.INHERIT_THREAD_LOCALS;
 833             return characteristics;
 834         }
 835 
 836         @Override
 837         public Builder group(ThreadGroup group) {
 838             Objects.requireNonNull(group);
 839             if (virtual)
 840                 throw new IllegalStateException();
 841             this.group = group;
 842             return this;
 843         }
 844 
 845         @Override
 846         public Builder name(String name) {
 847             this.name = Objects.requireNonNull(name);
 848             this.counter = -1;
 849             return this;
 850         }
 851 
 852         @Override
 853         public Builder name(String prefix, int start) {
 854             Objects.requireNonNull(prefix);
 855             if (start &lt; 0)
 856                 throw new IllegalArgumentException(&quot;&#39;start&#39; is negative&quot;);
 857             this.name = prefix;
 858             this.counter = start;
 859             return this;
 860         }
 861 
 862         @Override
 863         public Builder virtual() {
 864             if (group != null)
 865                 throw new IllegalStateException();
 866             this.virtual = true;
 867             this.scheduler = null;
 868             return this;
 869         }
 870 
 871         @Override
 872         public Builder virtual(Executor scheduler) {
 873             Objects.requireNonNull(scheduler);
 874             if (group != null)
 875                 throw new IllegalStateException();
 876             this.virtual = true;
 877             this.scheduler = scheduler;
 878             return this;
 879         }
 880 
 881         @Override
 882         public Builder disallowThreadLocals() {
 883             if (inheritThreadLocals)
 884                 throw new IllegalStateException();
 885             this.disallowThreadLocals = true;
 886             return this;
 887         }
 888 
 889         @Override
 890         public Builder inheritThreadLocals() {
 891             if (disallowThreadLocals)
 892                 throw new IllegalStateException();
 893             this.inheritThreadLocals = true;
 894             return this;
 895         }
 896 
 897         @Override
 898         public Builder daemon(boolean on) {
 899             daemon = on;
 900             daemonChanged = true;
 901             return this;
 902         }
 903 
 904         @Override
 905         public Builder priority(int priority) {
 906             if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY)
 907                 throw new IllegalArgumentException();
 908             this.priority = priority;
 909             return this;
 910         }
 911 
 912         @Override
 913         public Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
 914             this.uhe = Objects.requireNonNull(ueh);
 915             return this;
 916         }
 917 
 918         @Override
 919         public Builder managed() {
 920             // TDB
 921             return this;
 922         }
 923 
 924         @Override
 925         public Thread build() {
 926             Runnable task = this.task;
 927             if (task == null)
 928                 throw new IllegalStateException(&quot;No task specified&quot;);
 929 
 930             int characteristics = characteristics();
 931             Thread thread;
 932             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 933                 String name = this.name;
 934                 if (name != null &amp;&amp; counter &gt;= 0) {
 935                     name = name + (counter++);
 936                 }
 937                 thread = new VirtualThread(scheduler, name, characteristics, task);
 938             } else {
 939                 String name = this.name;
 940                 if (name == null) {
 941                     name = &quot;Thread-&quot; + nextThreadNum();
 942                 } else if (counter &gt;= 0) {
 943                     name = name + (counter++);
 944                 }
 945                 thread = new Thread(group, name, characteristics, task, 0, null);
 946                 if (daemonChanged)
 947                     thread.daemon(daemon);
 948                 if (priority != 0)
 949                     thread.priority(priority);
 950             }
 951             if (uhe != null)
 952                 thread.uncaughtExceptionHandler(uhe);
 953             return thread;
 954         }
 955 
 956         @Override
 957         public Builder task(Runnable task) {
 958             this.task = Objects.requireNonNull(task);
 959             return this;
 960         }
 961 
 962         @Override
 963         public ThreadFactory factory() {
 964             int characteristics = characteristics();
 965             if ((characteristics &amp; Thread.VIRTUAL) != 0) {
 966                 return new VirtualThreadFactory(scheduler, name, counter, characteristics, uhe);
 967             } else {
 968                 return new KernelThreadFactory(group, name, counter, characteristics,
 969                                                daemon, priority, uhe);
 970             }
 971         }
 972     }
 973 
 974     private static abstract class CountingThreadFactory implements ThreadFactory {
 975         private static final VarHandle COUNT;
 976         static {
 977             try {
 978                 MethodHandles.Lookup l = MethodHandles.lookup();
 979                 COUNT = l.findVarHandle(CountingThreadFactory.class, &quot;count&quot;, int.class);
 980             } catch (Exception e) {
 981                 throw new InternalError(e);
 982             }
 983         }
 984         private volatile int count;
 985         private final boolean hasCounter;
 986 
 987         CountingThreadFactory(int start) {
 988             if (start &gt;= 0) {
 989                 count = start;
 990                 hasCounter = true;
 991             } else {
 992                 hasCounter = false;
 993             }
 994         }
 995 
 996         boolean hasCounter() {
 997             return hasCounter;
 998         }
 999 
1000         int next() {
1001             return (int) COUNT.getAndAdd(this, 1);
1002         }
1003     }
1004 
1005     private static class VirtualThreadFactory extends CountingThreadFactory {
1006         private final Executor scheduler;
1007         private String name;
1008         private final int characteristics;
1009         private final UncaughtExceptionHandler uhe;
1010 
1011         VirtualThreadFactory(Executor scheduler,
1012                              String name,
1013                              int start,
1014                              int characteristics,
1015                              UncaughtExceptionHandler uhe) {
1016             super(start);
1017             this.scheduler = scheduler;
1018             this.name = name;
1019             this.characteristics = characteristics;
1020             this.uhe = uhe;
1021         }
1022 
1023         @Override
1024         public Thread newThread(Runnable task) {
1025             Objects.requireNonNull(task);
1026             String name = this.name;
1027             if (name != null &amp;&amp; hasCounter()) {
1028                 name += next();
1029             }
1030             Thread thread = new VirtualThread(scheduler, name, characteristics, task);
1031             if (uhe != null)
1032                 thread.uncaughtExceptionHandler(uhe);
1033             return thread;
1034         }
1035     }
1036 
1037     private static class KernelThreadFactory extends CountingThreadFactory {
1038         private final ThreadGroup group;
1039         private final String name;
1040         private final int characteristics;
1041         private final boolean daemon;
1042         private final int priority;
1043         private final UncaughtExceptionHandler uhe;
1044 
1045         KernelThreadFactory(ThreadGroup group,
1046                             String name,
1047                             int start,
1048                             int characteristics,
1049                             boolean daemon,
1050                             int priority,
1051                             UncaughtExceptionHandler uhe) {
1052             super(start);
1053             this.group = group;
1054             this.name = name;
1055             this.characteristics = characteristics;
1056             this.daemon = daemon;
1057             this.priority = priority;
1058             this.uhe = uhe;
1059         }
1060 
1061         @Override
1062         public Thread newThread(Runnable task) {
1063             Objects.requireNonNull(task);
1064             String name = this.name;
1065             if (name == null) {
1066                 name = &quot;Thread-&quot; + nextThreadNum();
1067             } else if (hasCounter()) {
1068                 name += next();
1069             }
1070             Thread thread = new Thread(group, name, characteristics, task, 0, null);
1071             if (daemon)
1072                 thread.daemon(true);
1073             if (priority != 0)
1074                 thread.priority(priority);
1075             if (uhe != null)
1076                 thread.uncaughtExceptionHandler(uhe);
1077             return thread;
1078         }
1079     }
1080 
1081     /**
1082      * Throws CloneNotSupportedException as a Thread can not be meaningfully
1083      * cloned. Construct a new Thread instead.
1084      *
1085      * @throws  CloneNotSupportedException
1086      *          always
1087      */
1088     @Override
1089     protected Object clone() throws CloneNotSupportedException {
1090         throw new CloneNotSupportedException();
1091     }
1092 
1093     /**
1094      * Allocates a new {@code Thread} object. This constructor has the same
1095      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1096      * {@code (null, null, gname)}, where {@code gname} is a newly generated
1097      * name. Automatically generated names are of the form
1098      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1099      */
1100     public Thread() {
1101         this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
1102     }
1103 
1104     /**
1105      * Allocates a new {@code Thread} object. This constructor has the same
1106      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1107      * {@code (null, task, gname)}, where {@code gname} is a newly generated
1108      * name. Automatically generated names are of the form
1109      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1110      *
1111      * @param  task
1112      *         the object whose {@code run} method is invoked when this thread
1113      *         is started. If {@code null}, this classes {@code run} method does
1114      *         nothing.
1115      */
1116     public Thread(Runnable task) {
1117         this(null, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1118     }
1119 
1120     /**
1121      * Creates a new Thread that inherits the given AccessControlContext
1122      * but thread-local variables are not inherited.
1123      * This is not a public constructor.
1124      */
1125     Thread(Runnable task, AccessControlContext acc) {
1126         this(null, &quot;Thread-&quot; + nextThreadNum(), 0, task, 0, acc);
1127     }
1128 
1129     /**
1130      * Allocates a new {@code Thread} object. This constructor has the same
1131      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1132      * {@code (group, task, gname)} ,where {@code gname} is a newly generated
1133      * name. Automatically generated names are of the form
1134      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
1135      *
1136      * @param  group
1137      *         the thread group. If {@code null} and there is a security
1138      *         manager, the group is determined by {@linkplain
1139      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1140      *         If there is not a security manager or {@code
1141      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1142      *         is set to the current thread&#39;s thread group.
1143      *
1144      * @param  task
1145      *         the object whose {@code run} method is invoked when this thread
1146      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1147      *
1148      * @throws  SecurityException
1149      *          if the current thread cannot create a thread in the specified
1150      *          thread group
1151      */
1152     public Thread(ThreadGroup group, Runnable task) {
1153         this(group, task, &quot;Thread-&quot; + nextThreadNum(), 0);
1154     }
1155 
1156     /**
1157      * Allocates a new {@code Thread} object. This constructor has the same
1158      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1159      * {@code (null, null, name)}.
1160      *
1161      * @param   name
1162      *          the name of the new thread
1163      */
1164     public Thread(String name) {
1165         this(null, null, name, 0);
1166     }
1167 
1168     /**
1169      * Allocates a new {@code Thread} object. This constructor has the same
1170      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1171      * {@code (group, null, name)}.
1172      *
1173      * @param  group
1174      *         the thread group. If {@code null} and there is a security
1175      *         manager, the group is determined by {@linkplain
1176      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1177      *         If there is not a security manager or {@code
1178      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1179      *         is set to the current thread&#39;s thread group.
1180      *
1181      * @param  name
1182      *         the name of the new thread
1183      *
1184      * @throws  SecurityException
1185      *          if the current thread cannot create a thread in the specified
1186      *          thread group
1187      */
1188     public Thread(ThreadGroup group, String name) {
1189         this(group, null, name, 0);
1190     }
1191 
1192     /**
1193      * Allocates a new {@code Thread} object. This constructor has the same
1194      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
1195      * {@code (null, task, name)}.
1196      *
1197      * @param  task
1198      *         the object whose {@code run} method is invoked when this thread
1199      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1200      *
1201      * @param  name
1202      *         the name of the new thread
1203      */
1204     public Thread(Runnable task, String name) {
1205         this(null, task, name, 0);
1206     }
1207 
1208     /**
1209      * Allocates a new {@code Thread} object so that it has {@code task}
1210      * as its run object, has the specified {@code name} as its name,
1211      * and belongs to the thread group referred to by {@code group}.
1212      *
1213      * &lt;p&gt;If there is a security manager, its
1214      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
1215      * method is invoked with the ThreadGroup as its argument.
1216      *
1217      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
1218      * the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}
1219      * permission when invoked directly or indirectly by the constructor
1220      * of a subclass which overrides the {@code getContextClassLoader}
1221      * or {@code setContextClassLoader} methods.
1222      *
1223      * &lt;p&gt;The priority of the newly created thread is set equal to the
1224      * priority of the thread creating it, that is, the currently running
1225      * thread. The method {@linkplain #setPriority setPriority} may be
1226      * used to change the priority to a new value.
1227      *
1228      * &lt;p&gt;The newly created thread is initially marked as being a daemon
1229      * thread if and only if the thread creating it is currently marked
1230      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
1231      * may be used to change whether or not a thread is a daemon.
1232      *
1233      * @param  group
1234      *         the thread group. If {@code null} and there is a security
1235      *         manager, the group is determined by {@linkplain
1236      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1237      *         If there is not a security manager or {@code
1238      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1239      *         is set to the current thread&#39;s thread group.
1240      *
1241      * @param  task
1242      *         the object whose {@code run} method is invoked when this thread
1243      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1244      *
1245      * @param  name
1246      *         the name of the new thread
1247      *
1248      * @throws  SecurityException
1249      *          if the current thread cannot create a thread in the specified
1250      *          thread group or cannot override the context class loader methods.
1251      */
1252     public Thread(ThreadGroup group, Runnable task, String name) {
1253         this(group, task, name, 0);
1254     }
1255 
1256     /**
1257      * Allocates a new {@code Thread} object so that it has {@code task}
1258      * as its run object, has the specified {@code name} as its name,
1259      * and belongs to the thread group referred to by {@code group}, and has
1260      * the specified &lt;i&gt;stack size&lt;/i&gt;.
1261      *
1262      * &lt;p&gt;This constructor is identical to {@link
1263      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
1264      * that it allows the thread stack size to be specified.  The stack size
1265      * is the approximate number of bytes of address space that the virtual
1266      * machine is to allocate for this thread&#39;s stack.  &lt;b&gt;The effect of the
1267      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
1268      *
1269      * &lt;p&gt;On some platforms, specifying a higher value for the
1270      * {@code stackSize} parameter may allow a thread to achieve greater
1271      * recursion depth before throwing a {@link StackOverflowError}.
1272      * Similarly, specifying a lower value may allow a greater number of
1273      * threads to exist concurrently without throwing an {@link
1274      * OutOfMemoryError} (or other internal error).  The details of
1275      * the relationship between the value of the {@code stackSize} parameter
1276      * and the maximum recursion depth and concurrency level are
1277      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
1278      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
1279      *
1280      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
1281      * parameter as a suggestion.  If the specified value is unreasonably low
1282      * for the platform, the virtual machine may instead use some
1283      * platform-specific minimum value; if the specified value is unreasonably
1284      * high, the virtual machine may instead use some platform-specific
1285      * maximum.  Likewise, the virtual machine is free to round the specified
1286      * value up or down as it sees fit (or to ignore it completely).
1287      *
1288      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
1289      * cause this constructor to behave exactly like the
1290      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
1291      *
1292      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
1293      * constructor, extreme care should be exercised in its use.
1294      * The thread stack size necessary to perform a given computation will
1295      * likely vary from one JRE implementation to another.  In light of this
1296      * variation, careful tuning of the stack size parameter may be required,
1297      * and the tuning may need to be repeated for each JRE implementation on
1298      * which an application is to run.&lt;/i&gt;
1299      *
1300      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
1301      * document their implementation&#39;s behavior with respect to the
1302      * {@code stackSize} parameter.
1303      *
1304      *
1305      * @param  group
1306      *         the thread group. If {@code null} and there is a security
1307      *         manager, the group is determined by {@linkplain
1308      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1309      *         If there is not a security manager or {@code
1310      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1311      *         is set to the current thread&#39;s thread group.
1312      *
1313      * @param  task
1314      *         the object whose {@code run} method is invoked when this thread
1315      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1316      *
1317      * @param  name
1318      *         the name of the new thread
1319      *
1320      * @param  stackSize
1321      *         the desired stack size for the new thread, or zero to indicate
1322      *         that this parameter is to be ignored.
1323      *
1324      * @throws  SecurityException
1325      *          if the current thread cannot create a thread in the specified
1326      *          thread group
1327      *
1328      * @since 1.4
1329      */
1330     public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
1331         this(group, name, Thread.INHERIT_THREAD_LOCALS, task, stackSize, null);
1332     }
1333 
1334     /**
1335      * Allocates a new {@code Thread} object so that it has {@code task}
1336      * as its run object, has the specified {@code name} as its name,
1337      * belongs to the thread group referred to by {@code group}, has
1338      * the specified {@code stackSize}, and inherits initial values for
1339      * {@linkplain InheritableThreadLocal inheritable thread-local} variables
1340      * if {@code inheritThreadLocals} is {@code true}.
1341      *
1342      * &lt;p&gt; This constructor is identical to {@link
1343      * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
1344      * suppress, or not, the inheriting of initial values for inheritable
1345      * thread-local variables from the constructing thread. This allows for
1346      * finer grain control over inheritable thread-locals. Care must be taken
1347      * when passing a value of {@code false} for {@code inheritThreadLocals},
1348      * as it may lead to unexpected behavior if the new thread executes code
1349      * that expects a specific thread-local value to be inherited.
1350      *
1351      * &lt;p&gt; Specifying a value of {@code true} for the {@code inheritThreadLocals}
1352      * parameter will cause this constructor to behave exactly like the
1353      * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
1354      *
1355      * @param  group
1356      *         the thread group. If {@code null} and there is a security
1357      *         manager, the group is determined by {@linkplain
1358      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
1359      *         If there is not a security manager or {@code
1360      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
1361      *         is set to the current thread&#39;s thread group.
1362      *
1363      * @param  task
1364      *         the object whose {@code run} method is invoked when this thread
1365      *         is started. If {@code null}, this thread&#39;s run method is invoked.
1366      *
1367      * @param  name
1368      *         the name of the new thread
1369      *
1370      * @param  stackSize
1371      *         the desired stack size for the new thread, or zero to indicate
1372      *         that this parameter is to be ignored
1373      *
1374      * @param  inheritThreadLocals
1375      *         if {@code true}, inherit initial values for inheritable
1376      *         thread-locals from the constructing thread, otherwise no initial
1377      *         values are inherited
1378      *
1379      * @throws  SecurityException
1380      *          if the current thread cannot create a thread in the specified
1381      *          thread group
1382      *
1383      * @since 9
1384      */
1385     public Thread(ThreadGroup group, Runnable task, String name,
1386                   long stackSize, boolean inheritThreadLocals) {
1387         this(group, name, (inheritThreadLocals ? Thread.INHERIT_THREAD_LOCALS : 0),
1388                 task, stackSize, null);
1389     }
1390 
1391     /**
1392      * Characteristic value signifying that the thread should be scheduled by
1393      * the Java virtual machine rather than the operating system.
1394      *
1395      * @since 99
1396      */
1397     public static final int VIRTUAL = 1 &lt;&lt; 0;
1398 
1399     /**
1400      * Characteristic value signifying that {@link ThreadLocal thread-locals}
1401      * are not supported by the thread.
1402      *
1403      * @apiNote This is for experimental purposes, a lot of existing code will
1404      * not run if thread locals are not supported.
1405      *
1406      * @since 99
1407      */
1408     public static final int NO_THREAD_LOCALS = 1 &lt;&lt; 1;
1409 
1410     /**
1411      * Characteristic value signifying that {@link InheritableThreadLocal
1412      * inheritable-thread-locals} are inherihted from the constructing thread.
1413      * This characteristic is incompatible with {@linkplain #NO_THREAD_LOCALS},
1414      * they may not be used together.
1415      *
1416      * @since 99
1417      */
1418     public static final int INHERIT_THREAD_LOCALS = 1 &lt;&lt; 2;
1419 
1420     /**
1421      * Characteristic value signifying that the thread is &lt;em&gt;managed.&lt;/em&gt;
1422      *
1423      * @since 99
1424      */
1425     public static final int MANAGED = 1 &lt;&lt; 3;
1426 
1427     private static int validCharacteristics() {
1428         return (VIRTUAL | NO_THREAD_LOCALS | INHERIT_THREAD_LOCALS | MANAGED);
1429     }
1430 
1431     private static void checkCharacteristics(int characteristics) {
1432         if (characteristics != 0) {
1433             if ((characteristics &amp; ~validCharacteristics()) != 0)
1434                 throw new IllegalArgumentException();
1435             if ((characteristics &amp; NO_THREAD_LOCALS) != 0
1436                     &amp;&amp; (characteristics &amp; INHERIT_THREAD_LOCALS) != 0)
1437                 throw new IllegalArgumentException();
1438         }
1439     }
1440 
1441     /**
1442      * Creates an unnamed thread.
1443      *
1444      * By default, the thread is scheduled by the operating system, supports
1445      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1446      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1447      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1448      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1449      * context-class-loader} are inherited from the current thread.
1450      *
1451      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1452      * used to create a thread that is scheduled by the Java virtual machine
1453      * using the default scheduler. The default in this case is to only inherit
1454      * the {@link #getContextClassLoader() context-class-loader} from the current
1455      * thread.
1456      *
1457      * @apiNote The characteristics will probably be replaced by an enum
1458      *
1459      * @param characteristics characteristics of the thread
1460      * @param task the object to run when the thread executes
1461      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1462      *         combination of characteristic is specified
1463      * @return an un-started virtual thread
1464      *
1465      * @since 99
1466      */
1467     public static Thread newThread(int characteristics, Runnable task) {
1468         if ((characteristics &amp; VIRTUAL) != 0) {
1469             return new VirtualThread(null, null, characteristics, task);
1470         } else {
1471             return new Thread(null, &quot;Thread-&quot; + nextThreadNum(), characteristics, task, 0, null);
1472         }
1473     }
1474 
1475     /**
1476      * Creates a named thread.
1477      *
1478      * By default, the thread is scheduled by the operating system, supports
1479      * {@link ThreadLocal thread-locals}, and does not inherit any initial values
1480      * for {@link InheritableThreadLocal inheritable-thread-locals}.
1481      * The {@link ThreadGroup ThreadGroup}, {@link #isDaemon() daemon status},
1482      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
1483      * context-class-loader} are inherited from the current thread.
1484      *
1485      * &lt;p&gt; The characteristic {@linkplain Thread#VIRTUAL VIRTUAL} is
1486      * used to create a thread that is scheduled by the Java virtual machine
1487      * using the default scheduler. The default in this case is to only inherit
1488      * the {@link #getContextClassLoader() context-class-loader} from the current
1489      * thread.
1490      *
1491      * @apiNote The characteristics will probably be replaced by an enum
1492      *
1493      * @param name the thread name
1494      * @param characteristics characteristics of the thread
1495      * @param task the object to run when the thread executes
1496      * @throws IllegalArgumentException if an unknown characteristic or an invalid
1497      *         combination of characteristic is specified
1498      * @return an un-started virtual thread
1499      *
1500      * @since 99
1501      */
1502     public static Thread newThread(String name, int characteristics, Runnable task) {
1503         if ((characteristics &amp; VIRTUAL) != 0) {
1504             return new VirtualThread(null, name, characteristics, task);
1505         } else {
1506             return new Thread(null, name, characteristics, task, 0, null);
1507         }
1508     }
1509 
1510     /**
1511      * Returns {@code true} if this thread scheduled by the Java virtual machine
1512      * rather than the operating system.
1513      *
1514      * &lt;p&gt; Threads that are scheduled by the Java virtual machine do not support
1515      * all features of Thread. In particular, the Thread is not an &lt;i&gt;active thread&lt;/i&gt;
1516      * in its thread group and so is not enumerated or acted on by thread group
1517      * operations. In addition it does not support the stop, suspend or resume
1518      * methods.
1519      *
1520      * @return {@code true} if this thread is scheduled by the Java virtual
1521      *         machine rather than the operating system
1522      *
1523      * @since 99
1524      */
1525     public final boolean isVirtual() {
1526         return (this instanceof VirtualThread);
1527     }
1528 
1529     /**
1530      * Schedules this thread to begin execution. The thread will execute
1531      * independently of the current thread.
1532      * &lt;p&gt;
1533      * It is never legal to start a thread more than once.
1534      * In particular, a thread may not be restarted once it has completed
1535      * execution.
1536      *
1537      * @throws     IllegalThreadStateException  if the thread was already started.
1538      * @see        #run()
1539      * @see        Builder#start()
1540      */
1541     public synchronized void start() {
1542         /**
1543          * This method is not invoked for the main method thread or &quot;system&quot;
1544          * group threads created/set up by the VM. Any new functionality added
1545          * to this method in the future may have to also be added to the VM.
1546          *
1547          * A zero status value corresponds to state &quot;NEW&quot;.
1548          */
1549         if (holder.threadStatus != 0)
1550             throw new IllegalThreadStateException();
1551 
1552         /* Notify the group that this thread is about to be started
1553          * so that it can be added to the group&#39;s list of threads
1554          * and the group&#39;s unstarted count can be decremented. */
1555         ThreadGroup group = holder.group;
1556         group.add(this);
1557 
1558         boolean started = false;
1559         try {
1560             start0();
1561             started = true;
1562         } finally {
1563             try {
1564                 if (!started) {
1565                     group.threadStartFailed(this);
1566                 }
1567             } catch (Throwable ignore) {
1568                 /* do nothing. If start0 threw a Throwable then
1569                   it will be passed up the call stack */
1570             }
1571         }
1572     }
1573 
1574     private native void start0();
1575 
1576     /**
1577      * If this thread was constructed using a separate
1578      * {@code Runnable} run object, then that
1579      * {@code Runnable} object&#39;s {@code run} method is called;
1580      * otherwise, this method does nothing and returns.
1581      * This method does nothing when invoked on a {@linkplain #isVirtual()
1582      * virtual} thread.
1583      * &lt;p&gt;
1584      * Subclasses of {@code Thread} should override this method.
1585      *
1586      * @see     #start()
1587      * @see     #Thread(ThreadGroup, Runnable, String)
1588      */
1589     @Override
1590     public void run() {
1591         if (!isVirtual()) {
1592             Runnable task = holder.task;
1593             if (task != null) {
1594                 task.run();
1595             }
1596         }
1597     }
1598 
1599     /**
1600      * This method is called by the system to give a Thread
1601      * a chance to clean up before it actually exits.
1602      */
1603     private void exit() {
1604         // assert !isVirtual();
1605         if (threadLocals != null &amp;&amp; TerminatingThreadLocal.REGISTRY.isPresent()) {
1606             TerminatingThreadLocal.threadTerminated();
1607         }
1608         ThreadGroup group = holder.group;
1609         if (group != null) {
1610             group.threadTerminated(this);
1611         }
1612         /* Aggressively null out all reference fields: see bug 4006245 */
1613         /* Speed the release of some of these resources */
1614         threadLocals = null;
1615         inheritableThreadLocals = null;
1616         inheritedAccessControlContext = null;
1617         nioBlocker = null;
1618         uncaughtExceptionHandler = null;
1619     }
1620 
1621     /**
1622      * Forces the thread to stop executing.
1623      * &lt;p&gt;
1624      * If there is a security manager installed, its {@code checkAccess}
1625      * method is called with {@code this}
1626      * as its argument. This may result in a
1627      * {@code SecurityException} being raised (in the current thread).
1628      * &lt;p&gt;
1629      * If this thread is different from the current thread (that is, the current
1630      * thread is trying to stop a thread other than itself), the
1631      * security manager&#39;s {@code checkPermission} method (with a
1632      * {@code RuntimePermission(&quot;stopThread&quot;)} argument) is called in
1633      * addition.
1634      * Again, this may result in throwing a
1635      * {@code SecurityException} (in the current thread).
1636      * &lt;p&gt;
1637      * The thread represented by this thread is forced to stop whatever
1638      * it is doing abnormally and to throw a newly created
1639      * {@code ThreadDeath} object as an exception.
1640      * &lt;p&gt;
1641      * It is permitted to stop a thread that has not yet been started.
1642      * If the thread is eventually started, it immediately terminates.
1643      * &lt;p&gt;
1644      * An application should not normally try to catch
1645      * {@code ThreadDeath} unless it must do some extraordinary
1646      * cleanup operation (note that the throwing of
1647      * {@code ThreadDeath} causes {@code finally} clauses of
1648      * {@code try} statements to be executed before the thread
1649      * officially terminates).  If a {@code catch} clause catches a
1650      * {@code ThreadDeath} object, it is important to rethrow the
1651      * object so that the thread actually terminates.
1652      * &lt;p&gt;
1653      * The top-level error handler that reacts to otherwise uncaught
1654      * exceptions does not print out a message or otherwise notify the
1655      * application if the uncaught exception is an instance of
1656      * {@code ThreadDeath}.
1657      *
1658      * @throws     SecurityException  if the current thread cannot
1659      *             modify this thread.
1660      * @throws     UnsupportedOperationException if invoked on a virtual thread
1661      * @see        #interrupt()
1662      * @see        #checkAccess()
1663      * @see        #run()
1664      * @see        #start()
1665      * @see        ThreadDeath
1666      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
1667      * @see        SecurityManager#checkAccess(Thread)
1668      * @see        SecurityManager#checkPermission
1669      * @deprecated This method is inherently unsafe.  Stopping a thread with
1670      *       Thread.stop causes it to unlock all of the monitors that it
1671      *       has locked (as a natural consequence of the unchecked
1672      *       {@code ThreadDeath} exception propagating up the stack).  If
1673      *       any of the objects previously protected by these monitors were in
1674      *       an inconsistent state, the damaged objects become visible to
1675      *       other threads, potentially resulting in arbitrary behavior.  Many
1676      *       uses of {@code stop} should be replaced by code that simply
1677      *       modifies some variable to indicate that the task thread should
1678      *       stop running.  The task thread should check this variable
1679      *       regularly, and return from its run method in an orderly fashion
1680      *       if the variable indicates that it is to stop running.  If the
1681      *       task thread waits for long periods (on a condition variable,
1682      *       for example), the {@code interrupt} method should be used to
1683      *       interrupt the wait.
1684      *       For more information, see
1685      *       &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1686      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1687      */
1688     @Deprecated(since=&quot;1.2&quot;)
1689     public final void stop() {
1690         SecurityManager security = System.getSecurityManager();
1691         if (security != null) {
1692             checkAccess();
1693             if (this != Thread.currentThread()) {
1694                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
1695             }
1696         }
1697 
1698         if (isVirtual())
1699             throw new UnsupportedOperationException();
1700 
1701         // A zero status value corresponds to &quot;NEW&quot;, it can&#39;t change to
1702         // not-NEW because we hold the lock.
1703         if (holder.threadStatus != 0) {
1704             resume(); // Wake up thread if it was suspended; no-op otherwise
1705         }
1706 
1707         // The VM can handle all thread states
1708         stop0(new ThreadDeath());
1709     }
1710 
1711     /**
1712      * Interrupts this thread.
1713      *
1714      * &lt;p&gt; Unless the current thread is interrupting itself, which is
1715      * always permitted, the {@link #checkAccess() checkAccess} method
1716      * of this thread is invoked, which may cause a {@link
1717      * SecurityException} to be thrown.
1718      *
1719      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
1720      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
1721      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
1722      * class, or of the {@link #join()}, {@link #join(long)}, {@link
1723      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
1724      * methods of this class, then its interrupt status will be cleared and it
1725      * will receive an {@link InterruptedException}.
1726      *
1727      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
1728      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
1729      * then the channel will be closed, the thread&#39;s interrupt
1730      * status will be set, and the thread will receive a {@link
1731      * java.nio.channels.ClosedByInterruptException}.
1732      *
1733      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
1734      * then the thread&#39;s interrupt status will be set and it will return
1735      * immediately from the selection operation, possibly with a non-zero
1736      * value, just as if the selector&#39;s {@link
1737      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
1738      *
1739      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
1740      * status will be set. &lt;/p&gt;
1741      *
1742      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
1743      *
1744      * @implNote In the JDK Reference Implementation, interruption of a thread
1745      * that is not alive still records that the interrupt request was made and
1746      * will report it via {@link #interrupted} and {@link #isInterrupted()}.
1747      *
1748      * @throws  SecurityException
1749      *          if the current thread cannot modify this thread
1750      *
1751      * @revised 6.0, 14
1752      * @spec JSR-51
1753      */
1754     public void interrupt() {
1755         if (this != Thread.currentThread()) {
1756             checkAccess();
1757 
1758             // thread may be blocked in an I/O operation
1759             synchronized (interruptLock) {
1760                 Interruptible b = nioBlocker;
1761                 if (b != null) {
1762                     interrupted = true;
1763                     interrupt0();  // inform VM of interrupt
1764                     b.interrupt(this);
1765                     return;
1766                 }
1767             }
1768         }
1769         interrupted = true;
1770         interrupt0();  // inform VM of interrupt
1771     }
1772 
1773     /**
1774      * Tests whether the current thread has been interrupted.  The
1775      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1776      * other words, if this method were to be called twice in succession, the
1777      * second call would return false (unless the current thread were
1778      * interrupted again, after the first call had cleared its interrupted
1779      * status and before the second call had examined it).
1780      *
1781      * @return  {@code true} if the current thread has been interrupted;
1782      *          {@code false} otherwise.
1783      * @see #isInterrupted()
1784      * @revised 6.0, 14
1785      */
1786     public static boolean interrupted() {
1787         return currentThread().getAndClearInterrupt();
1788     }
1789 
1790     /**
1791      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1792      * status&lt;/i&gt; of the thread is unaffected by this method.
1793      *
1794      * @return  {@code true} if this thread has been interrupted;
1795      *          {@code false} otherwise.
1796      * @see     #interrupted()
1797      * @revised 6.0, 14
1798      */
1799     public boolean isInterrupted() {
1800         return interrupted;
1801     }
1802 
1803     final void setInterrupt() {
1804         interrupted = true;
1805         interrupt0();  // inform VM of interrupt
1806     }
1807 
1808     final void clearInterrupt() {
1809         interrupted = false;
1810         clearInterruptEvent();
1811     }
1812 
1813     boolean getAndClearInterrupt() {
1814         boolean oldValue = interrupted;
1815         // We may have been interrupted the moment after we read the field,
1816         // so only clear the field if we saw that it was set and will return
1817         // true; otherwise we could lose an interrupt.
1818         if (oldValue) {
1819             interrupted = false;
1820             clearInterruptEvent();
1821         }
1822         return oldValue;
1823     }
1824 
1825     /**
1826      * Tests if this thread is alive. A thread is alive if it has
1827      * been started and has not yet terminated.
1828      *
1829      * @return  {@code true} if this thread is alive;
1830      *          {@code false} otherwise.
1831      */
1832     public final boolean isAlive() {
1833         if (isVirtual()) {
1834             State state = getState();
1835             return (state != State.NEW &amp;&amp; state != State.TERMINATED);
1836         } else {
1837             return isAlive0();
1838         }
1839     }
1840     private native boolean isAlive0();
1841 
1842     /**
1843      * Suspends this thread.
1844      * &lt;p&gt;
1845      * First, the {@code checkAccess} method of this thread is called
1846      * with no arguments. This may result in throwing a
1847      * {@code SecurityException }(in the current thread).
1848      * &lt;p&gt;
1849      * If the thread is alive, it is suspended and makes no further
1850      * progress unless and until it is resumed.
1851      *
1852      * @throws     SecurityException  if the current thread cannot modify
1853      *             this thread.
1854      * @throws     UnsupportedOperationException if invoked on a virtual thread
1855      * @see #checkAccess
1856      * @deprecated   This method has been deprecated, as it is
1857      *   inherently deadlock-prone.  If the task thread holds a lock on the
1858      *   monitor protecting a critical system resource when it is suspended, no
1859      *   thread can access this resource until the task thread is resumed. If
1860      *   the thread that would resume the task thread attempts to lock this
1861      *   monitor prior to calling {@code resume}, deadlock results.  Such
1862      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1863      *   For more information, see
1864      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1865      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1866      */
1867     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1868     public final void suspend() {
1869         checkAccess();
1870         if (isVirtual())
1871             throw new UnsupportedOperationException();
1872         suspend0();
1873     }
1874 
1875     void suspendThread() {
1876         suspend0();
1877     }
1878 
1879     /**
1880      * Resumes a suspended thread.
1881      * &lt;p&gt;
1882      * First, the {@code checkAccess} method of this thread is called
1883      * with no arguments. This may result in throwing a
1884      * {@code SecurityException} (in the current thread).
1885      * &lt;p&gt;
1886      * If the thread is alive but suspended, it is resumed and is
1887      * permitted to make progress in its execution.
1888      *
1889      * @throws     SecurityException  if the current thread cannot modify this
1890      *             thread.
1891      * @throws     UnsupportedOperationException if invoked on a virtual thread
1892      * @see        #checkAccess
1893      * @see        #suspend()
1894      * @deprecated This method exists solely for use with {@link #suspend},
1895      *     which has been deprecated because it is deadlock-prone.
1896      *     For more information, see
1897      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1898      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1899      */
1900     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1901     public final void resume() {
1902         checkAccess();
1903         if (isVirtual())
1904             throw new UnsupportedOperationException();
1905         resume0();
1906     }
1907 
1908     void resumeThread() {
1909         resume0();
1910     }
1911 
1912     /**
1913      * Changes the priority of this thread.
1914      * &lt;p&gt;
1915      * First the {@code checkAccess} method of this thread is called
1916      * with no arguments. This may result in throwing a {@code SecurityException}.
1917      * &lt;p&gt;
1918      * The priority of virtual-threads is always {@linkplain Thread#NORM_PRIORITY}
1919      * and is not changed by this method.
1920      * Otherwise, the priority of this thread is set to the smaller of
1921      * the specified {@code newPriority} and the maximum permitted
1922      * priority of the thread&#39;s thread group.
1923      *
1924      * @param newPriority priority to set this thread to
1925      * @throws     IllegalArgumentException  If the priority is not in the
1926      *               range {@code MIN_PRIORITY} to
1927      *               {@code MAX_PRIORITY}.
1928      * @throws     SecurityException  if the current thread cannot modify
1929      *               this thread.
1930      * @see        #getPriority
1931      * @see        #checkAccess()
1932      * @see        #getThreadGroup()
1933      * @see        #MAX_PRIORITY
1934      * @see        #MIN_PRIORITY
1935      * @see        ThreadGroup#getMaxPriority()
1936      */
1937     public final void setPriority(int newPriority) {
1938         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1939             throw new IllegalArgumentException();
1940         }
1941         checkAccess();
1942         priority(newPriority);
1943     }
1944 
1945     void priority(int newPriority) {
1946         ThreadGroup g;
1947         if (!isVirtual() &amp;&amp; (g = getThreadGroup()) != null) {
1948             if (newPriority &gt; g.getMaxPriority()) {
1949                 newPriority = g.getMaxPriority();
1950             }
1951             setPriority0(holder.priority = newPriority);
1952         }
1953     }
1954 
1955     /**
1956      * Returns this thread&#39;s priority.
1957      * The priority of a virtual thread is always {@linkplain Thread#NORM_PRIORITY}.
1958      *
1959      * @return  this thread&#39;s priority.
1960      * @see     #setPriority
1961      */
1962     public final int getPriority() {
1963         if (isVirtual()) {
1964             return Thread.NORM_PRIORITY;
1965         } else {
1966             return holder.priority;
1967         }
1968     }
1969 
1970     /**
1971      * Changes the name of this thread to be equal to the argument {@code name}.
1972      * &lt;p&gt;
1973      * First the {@code checkAccess} method of this thread is called
1974      * with no arguments. This may result in throwing a
1975      * {@code SecurityException}.
1976      *
1977      * @param      name   the new name for this thread.
1978      * @throws     SecurityException  if the current thread cannot modify this
1979      *             thread.
1980      * @see        #getName
1981      * @see        #checkAccess()
1982      */
1983     public final synchronized void setName(String name) {
1984         checkAccess();
1985         if (name == null) {
1986             throw new NullPointerException(&quot;name cannot be null&quot;);
1987         }
1988 
1989         this.name = name;
1990         if (!isVirtual() &amp;&amp; holder.threadStatus != 0) {
1991             setNativeName(name);
1992         }
1993     }
1994 
1995     /**
1996      * Returns this thread&#39;s name.
1997      *
1998      * @return  this thread&#39;s name.
1999      * @see     #setName(String)
2000      */
2001     public final String getName() {
2002         return name;
2003     }
2004 
2005     /**
2006      * Returns the thread group to which this thread belongs.
2007      * This method returns null if the thread has terminated.
2008      *
2009      * &lt;p&gt; The thread group for virtual threads does not support all features
2010      * of regular thread groups. Virtual threads are not considered &lt;i&gt;active
2011      * threads&lt;/i&gt; in the thread group and so are not enumerated or acted on by
2012      * thread group operations.
2013      *
2014      * @return  this thread&#39;s thread group.
2015      */
2016     public final ThreadGroup getThreadGroup() {
2017         if (getState() == State.TERMINATED) {
2018             return null;
2019         } else {
2020             return isVirtual() ? VirtualThreads.THREAD_GROUP : holder.group;
2021         }
2022     }
2023 
2024     /**
2025      * Returns an estimate of the number of active threads in the current
2026      * thread&#39;s {@linkplain java.lang.ThreadGroup thread group} and its
2027      * subgroups. Recursively iterates over all subgroups in the current
2028      * thread&#39;s thread group.
2029      *
2030      * &lt;p&gt; The value returned is only an estimate because the number of
2031      * threads may change dynamically while this method traverses internal
2032      * data structures, and might be affected by the presence of certain
2033      * system threads. This method is intended primarily for debugging
2034      * and monitoring purposes.
2035      *
2036      * @return  an estimate of the number of active threads in the current
2037      *          thread&#39;s thread group and in any other thread group that
2038      *          has the current thread&#39;s thread group as an ancestor
2039      */
2040     public static int activeCount() {
2041         return currentThread().getThreadGroup().activeCount();
2042     }
2043 
2044     /**
2045      * Copies into the specified array every active thread in the current
2046      * thread&#39;s thread group and its subgroups. This method simply
2047      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
2048      * method of the current thread&#39;s thread group.
2049      *
2050      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
2051      * method to get an estimate of how big the array should be, however
2052      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
2053      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
2054      * thread in the current thread&#39;s thread group and its subgroups, the
2055      * invoker should verify that the returned int value is strictly less
2056      * than the length of {@code tarray}.
2057      *
2058      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
2059      * that the method only be used for debugging and monitoring purposes.
2060      *
2061      * @param  tarray
2062      *         an array into which to put the list of threads
2063      *
2064      * @return  the number of threads put into the array
2065      *
2066      * @throws  SecurityException
2067      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
2068      *          the current thread cannot access its thread group
2069      */
2070     public static int enumerate(Thread tarray[]) {
2071         return currentThread().getThreadGroup().enumerate(tarray);
2072     }
2073 
2074     /**
2075      * Throws {@code UnsupportedOperationException}.
2076      *
2077      * @return     nothing
2078      *
2079      * @deprecated This method was originally designed to count the number of
2080      *             stack frames but the results were never well-defined and it
2081      *             depended on thread-suspension.
2082      *             This method is subject to removal in a future version of Java SE.
2083      * @see        StackWalker
2084      */
2085     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
2086     public int countStackFrames() {
2087         throw new UnsupportedOperationException();
2088     }
2089 
2090     /**
2091      * Waits at most {@code millis} milliseconds for this thread to terminate.
2092      * A timeout of {@code 0} means to wait forever.
2093      * This method returns immediately, without waiting, if the thread has not
2094      * been {@link #start() started}.
2095      *
2096      * &lt;p&gt; For non-{@linkplain #isVirtual() virtual}, this
2097      * implementation uses a loop of {@code this.wait} calls
2098      * conditioned on {@code this.isAlive}. As a thread terminates the
2099      * {@code this.notifyAll} method is invoked. It is recommended that
2100      * applications not use {@code wait}, {@code notify}, or
2101      * {@code notifyAll} on {@code Thread} instances.
2102      *
2103      * @param  millis
2104      *         the time to wait in milliseconds
2105      *
2106      * @throws  IllegalArgumentException
2107      *          if the value of {@code millis} is negative
2108      *
2109      * @throws  InterruptedException
2110      *          if any thread has interrupted the current thread. The
2111      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2112      *          cleared when this exception is thrown.
2113      */
2114     public final void join(long millis) throws InterruptedException {
2115         if (millis &lt; 0)
2116             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2117 
2118         if (isVirtual()) {
2119             if (isAlive()) {
2120                 long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
2121                 ((VirtualThread) this).joinNanos(nanos);
2122             }
2123             return;
2124         }
2125 
2126         synchronized (this) {
2127             if (millis &gt; 0) {
2128                 if (isAlive()) {
2129                     final long startTime = System.nanoTime();
2130                     long delay = millis;
2131                     do {
2132                         wait(delay);
2133                     } while (isAlive() &amp;&amp; (delay = millis -
2134                             TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; 0);
2135                 }
2136             } else if (millis == 0) {
2137                 while (isAlive()) {
2138                     wait(0);
2139                 }
2140             }
2141         }
2142     }
2143 
2144     /**
2145      * Waits at most {@code millis} milliseconds plus
2146      * {@code nanos} nanoseconds for this thread to terminate.
2147      * If both arguments are {@code 0}, it means to wait forever.
2148      * This method returns immediately, without waiting, if the thread has not
2149      * been {@link #start() started}.
2150      *
2151      * &lt;p&gt; For non-{@link #isVirtual() virtual}, this
2152      * implementation uses a loop of {@code this.wait} calls
2153      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
2154      * conditioned on {@code this.isAlive}. As a thread terminates the
2155      * {@code this.notifyAll} method is invoked. It is recommended that
2156      * applications not use {@code wait}, {@code notify}, or
2157      * {@code notifyAll} on {@code Thread} instances.
2158      *
2159      * @param  millis
2160      *         the time to wait in milliseconds
2161      *
2162      * @param  nanos
2163      *         {@code 0-999999} additional nanoseconds to wait
2164      *
2165      * @throws  IllegalArgumentException
2166      *          if the value of {@code millis} is negative, or the value
2167      *          of {@code nanos} is not in the range {@code 0-999999}
2168      *
2169      * @throws  InterruptedException
2170      *          if any thread has interrupted the current thread. The
2171      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2172      *          cleared when this exception is thrown.
2173      */
2174     public final void join(long millis, int nanos) throws InterruptedException {
2175         if (millis &lt; 0) {
2176             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
2177         }
2178 
2179         if (nanos &lt; 0 || nanos &gt; 999999) {
2180             throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);
2181         }
2182 
2183         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
2184             millis++;
2185         }
2186 
2187         join(millis);
2188     }
2189 
2190     /**
2191      * Waits for this thread to terminate.
2192      *
2193      * &lt;p&gt; An invocation of this method behaves in exactly the same
2194      * way as the invocation
2195      *
2196      * &lt;blockquote&gt;
2197      * {@linkplain #join(long) join}{@code (0)}
2198      * &lt;/blockquote&gt;
2199      *
2200      * @throws  InterruptedException
2201      *          if any thread has interrupted the current thread. The
2202      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
2203      *          cleared when this exception is thrown.
2204      */
2205     public final void join() throws InterruptedException {
2206         join(0);
2207     }
2208 
2209     /**
2210      * Waits for this thread to terminate for up to the given waiting duration.
2211      * This method does not wait if the duration to wait is less than or equal
2212      * to zero.
2213      *
2214      * @param   duration
2215      *          the maximum duration to wait
2216      *
2217      * @return  {@code true} if the thread has terminated
2218      *
2219      * @throws  InterruptedException
2220      *          if the current thread is interrupted while waiting.
2221      *          The &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is cleared
2222      *          when this exception is thrown.
2223      *
2224      * @throws  IllegalThreadStateException
2225      *          if this thread has not been started.
2226      *
2227      * @since 99
2228      */
2229     public final boolean join(Duration duration) throws InterruptedException {
2230         Objects.requireNonNull(duration);
2231 
2232         Thread.State state = getState();
2233         if (state == State.TERMINATED)
2234             return true;
2235         if (state == State.NEW)
2236             throw new IllegalThreadStateException(&quot;Thread not started&quot;);
2237         if (duration.isZero() || duration.isNegative())
2238             return false;
2239 
2240         if (isVirtual()) {
2241             long nanos = TimeUnit.NANOSECONDS.convert(duration);
2242             return ((VirtualThread) this).joinNanos(nanos);
2243         } else {
2244             // ignore nano precision for now
2245             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
2246             join(millis);
2247             return getState() == State.TERMINATED;
2248         }
2249     }
2250 
2251     /**
2252      * Prints a stack trace of the current thread to the standard error stream.
2253      * This method is useful for debugging.
2254      */
2255     public static void dumpStack() {
2256         new Exception(&quot;Stack trace&quot;).printStackTrace();
2257     }
2258 
2259     /**
2260      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
2261      * or a user thread.
2262      * The daemon status of a virtual thread is meaningless and is not
2263      * changed by this method (the {@linkplain #isDaemon() isDaemon} method
2264      * always returns {@code true}).
2265      * The Java Virtual Machine exits when the only threads running are all
2266      * daemon threads.
2267      *
2268      * &lt;p&gt; This method must be invoked before the thread is started.
2269      *
2270      * @param  on
2271      *         if {@code true}, marks this thread as a daemon thread
2272      *
2273      * @throws  IllegalThreadStateException
2274      *          if this thread is {@linkplain #isAlive alive}
2275      *
2276      * @throws  SecurityException
2277      *          if {@link #checkAccess} determines that the current
2278      *          thread cannot modify this thread
2279      */
2280     public final void setDaemon(boolean on) {
2281         checkAccess();
2282         if (isAlive())
2283             throw new IllegalThreadStateException();
2284         daemon(on);
2285     }
2286 
2287     void daemon(boolean on) {
2288         if (!isVirtual())
2289             holder.daemon = on;
2290     }
2291 
2292     /**
2293      * Tests if this thread is a daemon thread.
2294      * The daemon status of a virtual thread is meaningless, this method
2295      * returns {@code true} if this is a virtual thread.
2296      *
2297      * @return  {@code true} if this thread is a daemon thread;
2298      *          {@code false} otherwise.
2299      * @see     #setDaemon(boolean)
2300      */
2301     public final boolean isDaemon() {
2302         if (isVirtual()) {
2303             return true;
2304         } else {
2305             return holder.daemon;
2306         }
2307     }
2308 
2309     /**
2310      * Determines if the currently running thread has permission to
2311      * modify this thread.
2312      * &lt;p&gt;
2313      * If there is a security manager, its {@code checkAccess} method
2314      * is called with this thread as its argument. This may result in
2315      * throwing a {@code SecurityException}.
2316      *
2317      * @throws  SecurityException  if the current thread is not allowed to
2318      *          access this thread.
2319      * @see        SecurityManager#checkAccess(Thread)
2320      */
2321     public final void checkAccess() {
2322         SecurityManager security = System.getSecurityManager();
2323         if (security != null) {
2324             security.checkAccess(this);
2325         }
2326     }
2327 
2328     /**
2329      * Returns a string representation of this thread. The string representation
2330      * will usually include the thread&#39;s name. The default implementation
2331      * includes the thread&#39;s name, priority, and the name of the thread group.
2332      *
2333      * @return  a string representation of this thread.
2334      */
2335     public String toString() {
2336         ThreadGroup group = getThreadGroup();
2337         if (group != null) {
2338             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2339                            group.getName() + &quot;]&quot;;
2340         } else {
2341             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
2342                             &quot;&quot; + &quot;]&quot;;
2343         }
2344     }
2345 
2346     /**
2347      * Returns the context {@code ClassLoader} for this thread. The context
2348      * {@code ClassLoader} is provided by the creator of the thread for use
2349      * by code running in this thread when loading classes and resources.
2350      * If not {@linkplain #setContextClassLoader set}, the default is the
2351      * {@code ClassLoader} context of the parent thread. The context
2352      * {@code ClassLoader} of the
2353      * primordial thread is typically set to the class loader used to load the
2354      * application.
2355      *
2356      *
2357      * @return  the context {@code ClassLoader} for this thread, or {@code null}
2358      *          indicating the system class loader (or, failing that, the
2359      *          bootstrap class loader)
2360      *
2361      * @throws  SecurityException
2362      *          if a security manager is present, and the caller&#39;s class loader
2363      *          is not {@code null} and is not the same as or an ancestor of the
2364      *          context class loader, and the caller does not have the
2365      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
2366      *
2367      * @since 1.2
2368      */
2369     @CallerSensitive
2370     public ClassLoader getContextClassLoader() {
2371         if (contextClassLoader == null)
2372             return null;
2373         SecurityManager sm = System.getSecurityManager();
2374         if (sm != null) {
2375             ClassLoader.checkClassLoaderPermission(contextClassLoader,
2376                                                    Reflection.getCallerClass());
2377         }
2378         return contextClassLoader;
2379     }
2380 
2381     /**
2382      * TBD
2383      */
2384     Continuation getContinuation() {
2385         return cont;
2386     }
2387 
2388     /**
2389      * TBD
2390      */
2391     void setContinuation(Continuation cont) {
2392         this.cont = cont;
2393     }
2394 
2395     /**
2396      * Sets the context ClassLoader for this Thread. The context
2397      * ClassLoader can be set when a thread is created, and allows
2398      * the creator of the thread to provide the appropriate class loader,
2399      * through {@code getContextClassLoader}, to code running in the thread
2400      * when loading classes and resources.
2401      *
2402      * &lt;p&gt;If a security manager is present, its {@link
2403      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
2404      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
2405      * (&quot;setContextClassLoader&quot;)} permission to see if setting the context
2406      * ClassLoader is permitted.
2407      *
2408      * @param  cl
2409      *         the context ClassLoader for this Thread, or null  indicating the
2410      *         system class loader (or, failing that, the bootstrap class loader)
2411      *
2412      * @throws  SecurityException
2413      *          if the current thread cannot set the context ClassLoader
2414      *
2415      * @since 1.2
2416      */
2417     public void setContextClassLoader(ClassLoader cl) {
2418         SecurityManager sm = System.getSecurityManager();
2419         if (sm != null) {
2420             sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
2421         }
2422         contextClassLoader = cl;
2423     }
2424 
2425     /**
2426      * Returns {@code true} if and only if the current thread holds the
2427      * monitor lock on the specified object.
2428      *
2429      * &lt;p&gt;This method is designed to allow a program to assert that
2430      * the current thread already holds a specified lock:
2431      * &lt;pre&gt;
2432      *     assert Thread.holdsLock(obj);
2433      * &lt;/pre&gt;
2434      *
2435      * @param  obj the object on which to test lock ownership
2436      * @throws NullPointerException if obj is {@code null}
2437      * @return {@code true} if the current thread holds the monitor lock on
2438      *         the specified object.
2439      * @since 1.4
2440      */
2441     public static native boolean holdsLock(Object obj);
2442 
2443     private static final StackTraceElement[] EMPTY_STACK_TRACE
2444         = new StackTraceElement[0];
2445 
2446     /**
2447      * Returns an array of stack trace elements representing the stack dump
2448      * of this thread.  This method will return a zero-length array if
2449      * this thread has not started, has started but has not yet been
2450      * scheduled to run by the system, or has terminated.
2451      * If the returned array is of non-zero length then the first element of
2452      * the array represents the top of the stack, which is the most recent
2453      * method invocation in the sequence.  The last element of the array
2454      * represents the bottom of the stack, which is the least recent method
2455      * invocation in the sequence.
2456      *
2457      * &lt;p&gt;If there is a security manager, and this thread is not
2458      * the current thread, then the security manager&#39;s
2459      * {@code checkPermission} method is called with a
2460      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission
2461      * to see if it&#39;s ok to get the stack trace.
2462      *
2463      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
2464      * or more stack frames from the stack trace.  In the extreme case,
2465      * a virtual machine that has no stack trace information concerning
2466      * this thread is permitted to return a zero-length array from this
2467      * method.
2468      *
2469      * @return an array of {@code StackTraceElement},
2470      * each represents one stack frame.
2471      *
2472      * @throws SecurityException
2473      *        if a security manager exists and its
2474      *        {@code checkPermission} method doesn&#39;t allow
2475      *        getting the stack trace of thread.
2476      * @see SecurityManager#checkPermission
2477      * @see RuntimePermission
2478      * @see Throwable#getStackTrace
2479      *
2480      * @since 1.5
2481      */
2482     public StackTraceElement[] getStackTrace() {
2483         if (this != Thread.currentThread()) {
2484             // check for getStackTrace permission
2485             SecurityManager security = System.getSecurityManager();
2486             if (security != null) {
2487                 security.checkPermission(
2488                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
2489             }
2490             // optimization so we do not call into the vm for threads that
2491             // have not yet started or have terminated
2492             if (!isAlive()) {
2493                 return EMPTY_STACK_TRACE;
2494             }
2495             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
2496             StackTraceElement[] stackTrace = stackTraceArray[0];
2497             // a thread that was alive during the previous isAlive call may have
2498             // since terminated, therefore not having a stacktrace.
2499             if (stackTrace == null) {
2500                 stackTrace = EMPTY_STACK_TRACE;
2501             }
2502             return stackTrace;
2503         } else {
2504             return (new Exception()).getStackTrace();
2505         }
2506     }
2507 
2508     /**
2509      * Returns a map of stack traces for all live threads. The map does not
2510      * include virtual threads.
2511      * The map keys are threads and each map value is an array of
2512      * {@code StackTraceElement} that represents the stack dump
2513      * of the corresponding {@code Thread}.
2514      * The returned stack traces are in the format specified for
2515      * the {@link #getStackTrace getStackTrace} method.
2516      *
2517      * &lt;p&gt;The threads may be executing while this method is called.
2518      * The stack trace of each thread only represents a snapshot and
2519      * each stack trace may be obtained at different time.  A zero-length
2520      * array will be returned in the map value if the virtual machine has
2521      * no stack trace information about a thread.
2522      *
2523      * &lt;p&gt;If there is a security manager, then the security manager&#39;s
2524      * {@code checkPermission} method is called with a
2525      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission as well as
2526      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission
2527      * to see if it is ok to get the stack trace of all threads.
2528      *
2529      * @return a {@code Map} from {@code Thread} to an array of
2530      * {@code StackTraceElement} that represents the stack trace of
2531      * the corresponding thread.
2532      *
2533      * @throws SecurityException
2534      *        if a security manager exists and its
2535      *        {@code checkPermission} method doesn&#39;t allow
2536      *        getting the stack trace of thread.
2537      * @see #getStackTrace
2538      * @see SecurityManager#checkPermission
2539      * @see RuntimePermission
2540      * @see Throwable#getStackTrace
2541      *
2542      * @since 1.5
2543      */
2544     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
2545         // check for getStackTrace permission
2546         SecurityManager security = System.getSecurityManager();
2547         if (security != null) {
2548             security.checkPermission(
2549                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
2550             security.checkPermission(
2551                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
2552         }
2553 
2554         // Get a snapshot of the list of all threads
2555         Thread[] threads = getThreads();
2556         StackTraceElement[][] traces = dumpThreads(threads);
2557         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
2558         for (int i = 0; i &lt; threads.length; i++) {
2559             StackTraceElement[] stackTrace = traces[i];
2560             if (stackTrace != null) {
2561                 m.put(threads[i], stackTrace);
2562             }
2563             // else terminated so we don&#39;t put it in the map
2564         }
2565         return m;
2566     }
2567 
2568     /** cache of subclass security audit results */
2569     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
2570      * release */
2571     private static class Caches {
2572         /** cache of subclass security audit results */
2573         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
2574             new ConcurrentHashMap&lt;&gt;();
2575 
2576         /** queue for WeakReferences to audited subclasses */
2577         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
2578             new ReferenceQueue&lt;&gt;();
2579     }
2580 
2581     /**
2582      * Verifies that this (possibly subclass) instance can be constructed
2583      * without violating security constraints: the subclass must not override
2584      * security-sensitive non-final methods, or else the
2585      * &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.
2586      */
2587     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
2588         if (cl == Thread.class)
2589             return false;
2590 
2591         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
2592         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
2593         Boolean result = Caches.subclassAudits.get(key);
2594         if (result == null) {
2595             result = Boolean.valueOf(auditSubclass(cl));
2596             Caches.subclassAudits.putIfAbsent(key, result);
2597         }
2598 
2599         return result.booleanValue();
2600     }
2601 
2602     /**
2603      * Performs reflective checks on given subclass to verify that it doesn&#39;t
2604      * override security-sensitive non-final methods.  Returns true if the
2605      * subclass overrides any of the methods, false otherwise.
2606      */
2607     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
2608         Boolean result = AccessController.doPrivileged(
2609             new PrivilegedAction&lt;&gt;() {
2610                 public Boolean run() {
2611                     for (Class&lt;?&gt; cl = subcl;
2612                          cl != Thread.class;
2613                          cl = cl.getSuperclass())
2614                     {
2615                         try {
2616                             cl.getDeclaredMethod(&quot;getContextClassLoader&quot;, new Class&lt;?&gt;[0]);
2617                             return Boolean.TRUE;
2618                         } catch (NoSuchMethodException ex) {
2619                         }
2620                         try {
2621                             Class&lt;?&gt;[] params = {ClassLoader.class};
2622                             cl.getDeclaredMethod(&quot;setContextClassLoader&quot;, params);
2623                             return Boolean.TRUE;
2624                         } catch (NoSuchMethodException ex) {
2625                         }
2626                     }
2627                     return Boolean.FALSE;
2628                 }
2629             }
2630         );
2631         return result.booleanValue();
2632     }
2633 
2634     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
2635     private static native Thread[] getThreads();
2636 
2637     /**
2638      * Returns the identifier of this Thread.  The thread ID is a positive
2639      * {@code long} number generated when this thread was created.
2640      * The thread ID is unique and remains unchanged during its lifetime.
2641      * When a thread is terminated, this thread ID may be reused.
2642      *
2643      * @return this thread&#39;s ID.
2644      * @since 1.5
2645      */
2646     public long getId() {
2647         return tid;
2648     }
2649 
2650     /**
2651      * A thread state.  A thread can be in one of the following states:
2652      * &lt;ul&gt;
2653      * &lt;li&gt;{@link #NEW}&lt;br&gt;
2654      *     A thread that has not yet started is in this state.
2655      *     &lt;/li&gt;
2656      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
2657      *     A thread executing in the Java virtual machine is in this state.
2658      *     &lt;/li&gt;
2659      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
2660      *     A thread that is blocked waiting for a monitor lock
2661      *     is in this state.
2662      *     &lt;/li&gt;
2663      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
2664      *     A thread that is waiting indefinitely for another thread to
2665      *     perform a particular action is in this state.
2666      *     &lt;/li&gt;
2667      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
2668      *     A thread that is waiting for another thread to perform an action
2669      *     for up to a specified waiting time is in this state.
2670      *     &lt;/li&gt;
2671      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
2672      *     A thread that has exited is in this state.
2673      *     &lt;/li&gt;
2674      * &lt;/ul&gt;
2675      *
2676      * &lt;p&gt;
2677      * A thread can be in only one state at a given point in time.
2678      * These states are virtual machine states which do not reflect
2679      * any operating system thread states.
2680      *
2681      * @since   1.5
2682      * @see #getState
2683      */
2684     public enum State {
2685         /**
2686          * Thread state for a thread which has not yet started.
2687          */
2688         NEW,
2689 
2690         /**
2691          * Thread state for a runnable thread.  A thread in the runnable
2692          * state is executing in the Java virtual machine but it may
2693          * be waiting for other resources from the operating system
2694          * such as processor.
2695          */
2696         RUNNABLE,
2697 
2698         /**
2699          * Thread state for a thread blocked waiting for a monitor lock.
2700          * A thread in the blocked state is waiting for a monitor lock
2701          * to enter a synchronized block/method or
2702          * reenter a synchronized block/method after calling
2703          * {@link Object#wait() Object.wait}.
2704          */
2705         BLOCKED,
2706 
2707         /**
2708          * Thread state for a waiting thread.
2709          * A thread is in the waiting state due to calling one of the
2710          * following methods:
2711          * &lt;ul&gt;
2712          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
2713          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
2714          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
2715          * &lt;/ul&gt;
2716          *
2717          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
2718          * perform a particular action.
2719          *
2720          * For example, a thread that has called {@code Object.wait()}
2721          * on an object is waiting for another thread to call
2722          * {@code Object.notify()} or {@code Object.notifyAll()} on
2723          * that object. A thread that has called {@code Thread.join()}
2724          * is waiting for a specified thread to terminate.
2725          */
2726         WAITING,
2727 
2728         /**
2729          * Thread state for a waiting thread with a specified waiting time.
2730          * A thread is in the timed waiting state due to calling one of
2731          * the following methods with a specified positive waiting time:
2732          * &lt;ul&gt;
2733          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
2734          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
2735          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
2736          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
2737          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
2738          * &lt;/ul&gt;
2739          */
2740         TIMED_WAITING,
2741 
2742         /**
2743          * Thread state for a terminated thread.
2744          * The thread has completed execution.
2745          */
2746         TERMINATED;
2747     }
2748 
2749     /**
2750      * Returns the state of this thread.
2751      * This method is designed for use in monitoring of the system state,
2752      * not for synchronization control.
2753      *
2754      * @return this thread&#39;s state.
2755      * @since 1.5
2756      */
2757     public State getState() {
2758         return threadState();
2759     }
2760 
2761     /**
2762      * Returns the state of this thread.
2763      *
2764      * @apiNote For VirtualThread use as getState may be overridden and run
2765      * arbitrary code.
2766      */
2767     State threadState() {
2768         return jdk.internal.misc.VM.toThreadState(holder.threadStatus);
2769     }
2770 
2771     // Added in JSR-166
2772 
2773     /**
2774      * Interface for handlers invoked when a {@code Thread} abruptly
2775      * terminates due to an uncaught exception.
2776      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
2777      * the Java Virtual Machine will query the thread for its
2778      * {@code UncaughtExceptionHandler} using
2779      * {@link #getUncaughtExceptionHandler} and will invoke the handler&#39;s
2780      * {@code uncaughtException} method, passing the thread and the
2781      * exception as arguments.
2782      * If a thread has not had its {@code UncaughtExceptionHandler}
2783      * explicitly set, then its {@code ThreadGroup} object acts as its
2784      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
2785      * has no
2786      * special requirements for dealing with the exception, it can forward
2787      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
2788      * default uncaught exception handler}.
2789      *
2790      * @see #setDefaultUncaughtExceptionHandler
2791      * @see #setUncaughtExceptionHandler
2792      * @see ThreadGroup#uncaughtException
2793      * @since 1.5
2794      */
2795     @FunctionalInterface
2796     public interface UncaughtExceptionHandler {
2797         /**
2798          * Method invoked when the given thread terminates due to the
2799          * given uncaught exception.
2800          * &lt;p&gt;Any exception thrown by this method will be ignored by the
2801          * Java Virtual Machine.
2802          * @param t the thread
2803          * @param e the exception
2804          */
2805         void uncaughtException(Thread t, Throwable e);
2806     }
2807 
2808     // null unless explicitly set
2809     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
2810 
2811     // null unless explicitly set
2812     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
2813 
2814     /**
2815      * Set the default handler invoked when a thread abruptly terminates
2816      * due to an uncaught exception, and no other handler has been defined
2817      * for that thread.
2818      *
2819      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
2820      * by the thread&#39;s {@link ThreadGroup} object and finally by the default
2821      * uncaught exception handler. If the thread does not have an explicit
2822      * uncaught exception handler set, and the thread&#39;s thread group
2823      * (including parent thread groups)  does not specialize its
2824      * {@code uncaughtException} method, then the default handler&#39;s
2825      * {@code uncaughtException} method will be invoked.
2826      * &lt;p&gt;By setting the default uncaught exception handler, an application
2827      * can change the way in which uncaught exceptions are handled (such as
2828      * logging to a specific device, or file) for those threads that would
2829      * already accept whatever &amp;quot;default&amp;quot; behavior the system
2830      * provided.
2831      *
2832      * &lt;p&gt;Note that the default uncaught exception handler should not usually
2833      * defer to the thread&#39;s {@code ThreadGroup} object, as that could cause
2834      * infinite recursion.
2835      *
2836      * @param eh the object to use as the default uncaught exception handler.
2837      * If {@code null} then there is no default handler.
2838      *
2839      * @throws SecurityException if a security manager is present and it denies
2840      *         {@link RuntimePermission}{@code (&quot;setDefaultUncaughtExceptionHandler&quot;)}
2841      *
2842      * @see #setUncaughtExceptionHandler
2843      * @see #getUncaughtExceptionHandler
2844      * @see ThreadGroup#uncaughtException
2845      * @since 1.5
2846      */
2847     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2848         SecurityManager sm = System.getSecurityManager();
2849         if (sm != null) {
2850             sm.checkPermission(
2851                 new RuntimePermission(&quot;setDefaultUncaughtExceptionHandler&quot;)
2852                     );
2853         }
2854 
2855          defaultUncaughtExceptionHandler = eh;
2856      }
2857 
2858     /**
2859      * Returns the default handler invoked when a thread abruptly terminates
2860      * due to an uncaught exception. If the returned value is {@code null},
2861      * there is no default.
2862      * @since 1.5
2863      * @see #setDefaultUncaughtExceptionHandler
2864      * @return the default uncaught exception handler for all threads
2865      */
2866     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
2867         return defaultUncaughtExceptionHandler;
2868     }
2869 
2870     /**
2871      * Returns the handler invoked when this thread abruptly terminates
2872      * due to an uncaught exception. If this thread has not had an
2873      * uncaught exception handler explicitly set then this thread&#39;s
2874      * {@code ThreadGroup} object is returned, unless this thread
2875      * has terminated, in which case {@code null} is returned.
2876      * @since 1.5
2877      * @return the uncaught exception handler for this thread
2878      */
2879     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
2880         return uncaughtExceptionHandler != null ?
2881             uncaughtExceptionHandler : getThreadGroup();
2882     }
2883 
2884     /**
2885      * Set the handler invoked when this thread abruptly terminates
2886      * due to an uncaught exception.
2887      * &lt;p&gt;A thread can take full control of how it responds to uncaught
2888      * exceptions by having its uncaught exception handler explicitly set.
2889      * If no such handler is set then the thread&#39;s {@code ThreadGroup}
2890      * object acts as its handler.
2891      * @param eh the object to use as this thread&#39;s uncaught exception
2892      * handler. If {@code null} then this thread has no explicit handler.
2893      * @throws  SecurityException  if the current thread is not allowed to
2894      *          modify this thread.
2895      * @see #setDefaultUncaughtExceptionHandler
2896      * @see ThreadGroup#uncaughtException
2897      * @since 1.5
2898      */
2899     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2900         checkAccess();
2901         uncaughtExceptionHandler(eh);
2902     }
2903 
2904     private void uncaughtExceptionHandler(UncaughtExceptionHandler eh) {
2905         uncaughtExceptionHandler = eh;
2906     }
2907 
2908     /**
2909      * Dispatch an uncaught exception to the handler. This method is
2910      * called when a thread terminates with an exception.
2911      */
2912     void dispatchUncaughtException(Throwable e) {
2913         getUncaughtExceptionHandler().uncaughtException(this, e);
2914     }
2915 
2916     /**
2917      * Removes from the specified map any keys that have been enqueued
2918      * on the specified reference queue.
2919      */
2920     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2921                              ConcurrentMap&lt;? extends
2922                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2923     {
2924         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2925         while((ref = queue.poll()) != null) {
2926             map.remove(ref);
2927         }
2928     }
2929 
2930     /**
2931      *  Weak key for Class objects.
2932      **/
2933     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2934         /**
2935          * saved value of the referent&#39;s identity hash code, to maintain
2936          * a consistent hash code after the referent has been cleared
2937          */
2938         private final int hash;
2939 
2940         /**
2941          * Create a new WeakClassKey to the given object, registered
2942          * with a queue.
2943          */
2944         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2945             super(cl, refQueue);
2946             hash = System.identityHashCode(cl);
2947         }
2948 
2949         /**
2950          * Returns the identity hash code of the original referent.
2951          */
2952         @Override
2953         public int hashCode() {
2954             return hash;
2955         }
2956 
2957         /**
2958          * Returns true if the given object is this identical
2959          * WeakClassKey instance, or, if this object&#39;s referent has not
2960          * been cleared, if the given object is another WeakClassKey
2961          * instance with the identical non-null referent as this one.
2962          */
2963         @Override
2964         public boolean equals(Object obj) {
2965             if (obj == this)
2966                 return true;
2967 
2968             if (obj instanceof WeakClassKey) {
2969                 Object referent = get();
2970                 return (referent != null) &amp;&amp;
2971                        (referent == ((WeakClassKey) obj).get());
2972             } else {
2973                 return false;
2974             }
2975         }
2976     }
2977 
2978     private static class VirtualThreads {
2979         static final ThreadGroup THREAD_GROUP = threadGroup();
2980         static final AccessControlContext ACCESS_CONTROL_CONTEXT = accessControlContext();
2981 
2982         /**
2983          * The thread group for virtual threads.
2984          */
2985         private static ThreadGroup threadGroup() {
2986             return AccessController.doPrivileged(new PrivilegedAction&lt;ThreadGroup&gt;() {
2987                 public ThreadGroup run() {
2988                     ThreadGroup group = Thread.currentCarrierThread().getThreadGroup();
2989                     for (ThreadGroup p; (p = group.getParent()) != null; )
2990                         group = p;
2991                     var newGroup = new ThreadGroup(group, &quot;VirtualThreads&quot;, true);
2992                     newGroup.setDaemon(true);
2993                     return newGroup;
2994                 }});
2995         }
2996 
2997         /**
2998          * Return an AccessControlContext that doesn&#39;t support any permissions.
2999          */
3000         private static AccessControlContext accessControlContext() {
3001             return new AccessControlContext(new ProtectionDomain[] {
3002                 new ProtectionDomain(null, null)
3003             });
3004         }
3005     }
3006 
3007     // The following three initially uninitialized fields are exclusively
3008     // managed by class java.util.concurrent.ThreadLocalRandom. These
3009     // fields are used to build the high-performance PRNGs in the
3010     // concurrent code. Upcoming changes in the concurrent code avoid
3011     // needing to use @Contented here.
3012 
3013     /** The current seed for a ThreadLocalRandom */
3014     long threadLocalRandomSeed;
3015 
3016     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
3017     int threadLocalRandomProbe;
3018 
3019     /** Secondary seed isolated from public ThreadLocalRandom sequence */
3020     int threadLocalRandomSecondarySeed;
3021 
3022     /**
3023      * TBD
3024      */
3025     public Object userObject;
3026 
3027     /* Some private helper methods */
3028     private native void setPriority0(int newPriority);
3029     private native void stop0(Object o);
3030     private native void suspend0();
3031     private native void resume0();
3032     private native void interrupt0();
3033     private static native void clearInterruptEvent();
3034     private native void setNativeName(String name);
3035 }
    </pre>
  </body>
</html>