<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;opto/addnode.hpp&quot;
  38 #include &quot;opto/arraycopynode.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callGenerator.hpp&quot;
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/intrinsicnode.hpp&quot;
  46 #include &quot;opto/idealKit.hpp&quot;
  47 #include &quot;opto/mathexactnode.hpp&quot;
  48 #include &quot;opto/movenode.hpp&quot;
  49 #include &quot;opto/mulnode.hpp&quot;
  50 #include &quot;opto/narrowptrnode.hpp&quot;
  51 #include &quot;opto/opaquenode.hpp&quot;
  52 #include &quot;opto/parse.hpp&quot;
  53 #include &quot;opto/runtime.hpp&quot;
  54 #include &quot;opto/rootnode.hpp&quot;
  55 #include &quot;opto/subnode.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;prims/unsafe.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
  61 
  62 
  63 class LibraryIntrinsic : public InlineCallGenerator {
  64   // Extend the set of intrinsics known to the runtime:
  65  public:
  66  private:
  67   bool             _is_virtual;
  68   bool             _does_virtual_dispatch;
  69   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  70   int8_t           _last_predicate; // Last generated predicate
  71   vmIntrinsics::ID _intrinsic_id;
  72 
  73  public:
  74   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  75     : InlineCallGenerator(m),
  76       _is_virtual(is_virtual),
  77       _does_virtual_dispatch(does_virtual_dispatch),
  78       _predicates_count((int8_t)predicates_count),
  79       _last_predicate((int8_t)-1),
  80       _intrinsic_id(id)
  81   {
  82   }
  83   virtual bool is_intrinsic() const { return true; }
  84   virtual bool is_virtual()   const { return _is_virtual; }
  85   virtual bool is_predicated() const { return _predicates_count &gt; 0; }
  86   virtual int  predicates_count() const { return _predicates_count; }
  87   virtual bool does_virtual_dispatch()   const { return _does_virtual_dispatch; }
  88   virtual JVMState* generate(JVMState* jvms);
  89   virtual Node* generate_predicate(JVMState* jvms, int predicate);
  90   vmIntrinsics::ID intrinsic_id() const { return _intrinsic_id; }
  91 };
  92 
  93 
  94 // Local helper class for LibraryIntrinsic:
  95 class LibraryCallKit : public GraphKit {
  96  private:
  97   LibraryIntrinsic* _intrinsic;     // the library intrinsic being called
  98   Node*             _result;        // the result node, if any
  99   int               _reexecute_sp;  // the stack pointer when bytecode needs to be reexecuted
 100 
 101   const TypeOopPtr* sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type);
 102 
 103  public:
 104   LibraryCallKit(JVMState* jvms, LibraryIntrinsic* intrinsic)
 105     : GraphKit(jvms),
 106       _intrinsic(intrinsic),
 107       _result(NULL)
 108   {
 109     // Check if this is a root compile.  In that case we don&#39;t have a caller.
 110     if (!jvms-&gt;has_method()) {
 111       _reexecute_sp = sp();
 112     } else {
 113       // Find out how many arguments the interpreter needs when deoptimizing
 114       // and save the stack pointer value so it can used by uncommon_trap.
 115       // We find the argument count by looking at the declared signature.
 116       bool ignored_will_link;
 117       ciSignature* declared_signature = NULL;
 118       ciMethod* ignored_callee = caller()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
 119       const int nargs = declared_signature-&gt;arg_size_for_bc(caller()-&gt;java_code_at_bci(bci()));
 120       _reexecute_sp = sp() + nargs;  // &quot;push&quot; arguments back on stack
 121     }
 122   }
 123 
 124   virtual LibraryCallKit* is_LibraryCallKit() const { return (LibraryCallKit*)this; }
 125 
 126   ciMethod*         caller()    const    { return jvms()-&gt;method(); }
 127   int               bci()       const    { return jvms()-&gt;bci(); }
 128   LibraryIntrinsic* intrinsic() const    { return _intrinsic; }
 129   vmIntrinsics::ID  intrinsic_id() const { return _intrinsic-&gt;intrinsic_id(); }
 130   ciMethod*         callee()    const    { return _intrinsic-&gt;method(); }
 131 
 132   bool  try_to_inline(int predicate);
 133   Node* try_to_predicate(int predicate);
 134 
 135   void push_result() {
 136     // Push the result onto the stack.
 137     if (!stopped() &amp;&amp; result() != NULL) {
 138       BasicType bt = result()-&gt;bottom_type()-&gt;basic_type();
 139       push_node(bt, result());
 140     }
 141   }
 142 
 143  private:
 144   void fatal_unexpected_iid(vmIntrinsics::ID iid) {
 145     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
 146   }
 147 
 148   void  set_result(Node* n) { assert(_result == NULL, &quot;only set once&quot;); _result = n; }
 149   void  set_result(RegionNode* region, PhiNode* value);
 150   Node*     result() { return _result; }
 151 
 152   virtual int reexecute_sp() { return _reexecute_sp; }
 153 
 154   // Helper functions to inline natives
 155   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 156   Node* generate_slow_guard(Node* test, RegionNode* region);
 157   Node* generate_fair_guard(Node* test, RegionNode* region);
 158   Node* generate_negative_guard(Node* index, RegionNode* region,
 159                                 // resulting CastII of index:
 160                                 Node* *pos_index = NULL);
 161   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 162                              Node* array_length,
 163                              RegionNode* region);
 164   void  generate_string_range_check(Node* array, Node* offset,
 165                                     Node* length, bool char_count);
 166   Node* generate_current_thread(Node* &amp;tls_output);
 167   Node* load_mirror_from_klass(Node* klass);
 168   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 169                                       RegionNode* region, int null_path,
 170                                       int offset);
 171   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 172                                RegionNode* region, int null_path) {
 173     int offset = java_lang_Class::klass_offset_in_bytes();
 174     return load_klass_from_mirror_common(mirror, never_see_null,
 175                                          region, null_path,
 176                                          offset);
 177   }
 178   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 179                                      RegionNode* region, int null_path) {
 180     int offset = java_lang_Class::array_klass_offset_in_bytes();
 181     return load_klass_from_mirror_common(mirror, never_see_null,
 182                                          region, null_path,
 183                                          offset);
 184   }
 185   Node* generate_access_flags_guard(Node* kls,
 186                                     int modifier_mask, int modifier_bits,
 187                                     RegionNode* region);
 188   Node* generate_interface_guard(Node* kls, RegionNode* region);
 189   Node* generate_array_guard(Node* kls, RegionNode* region) {
 190     return generate_array_guard_common(kls, region, false, false);
 191   }
 192   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 193     return generate_array_guard_common(kls, region, false, true);
 194   }
 195   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 196     return generate_array_guard_common(kls, region, true, false);
 197   }
 198   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 199     return generate_array_guard_common(kls, region, true, true);
 200   }
 201   Node* generate_array_guard_common(Node* kls, RegionNode* region,
 202                                     bool obj_array, bool not_array);
 203   Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
 204   CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
 205                                      bool is_virtual = false, bool is_static = false);
 206   CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {
 207     return generate_method_call(method_id, false, true);
 208   }
 209   CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {
 210     return generate_method_call(method_id, true, false);
 211   }
 212   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 213   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 214 
 215   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 216   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 217   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 218   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 219   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 220                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 221   bool inline_string_indexOfChar();
 222   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 223   bool inline_string_toBytesU();
 224   bool inline_string_getCharsU();
 225   bool inline_string_copy(bool compress);
 226   bool inline_string_char_access(bool is_store);
 227   Node* round_double_node(Node* n);
 228   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 229   bool inline_math_native(vmIntrinsics::ID id);
 230   bool inline_math(vmIntrinsics::ID id);
 231   bool inline_double_math(vmIntrinsics::ID id);
 232   template &lt;typename OverflowOp&gt;
 233   bool inline_math_overflow(Node* arg1, Node* arg2);
 234   void inline_math_mathExact(Node* math, Node* test);
 235   bool inline_math_addExactI(bool is_increment);
 236   bool inline_math_addExactL(bool is_increment);
 237   bool inline_math_multiplyExactI();
 238   bool inline_math_multiplyExactL();
 239   bool inline_math_multiplyHigh();
 240   bool inline_math_negateExactI();
 241   bool inline_math_negateExactL();
 242   bool inline_math_subtractExactI(bool is_decrement);
 243   bool inline_math_subtractExactL(bool is_decrement);
 244   bool inline_min_max(vmIntrinsics::ID id);
 245   bool inline_notify(vmIntrinsics::ID id);
 246   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 247   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 248   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 249   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 250 
 251   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 252   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 253   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 254   static bool klass_needs_init_guard(Node* kls);
 255   bool inline_unsafe_allocate();
 256   bool inline_unsafe_newArray(bool uninitialized);
 257   bool inline_unsafe_writeback0();
 258   bool inline_unsafe_writebackSync0(bool is_pre);
 259   bool inline_unsafe_copyMemory();
 260   bool inline_native_currentThread();
 261   bool inline_native_scopedCache();
 262   bool inline_native_setScopedCache();
 263 
 264   bool inline_native_time_funcs(address method, const char* funcName);
 265 #ifdef JFR_HAVE_INTRINSICS
 266   bool inline_native_classID();
 267   // bool inline_native_getEventWriter();
 268 #endif
 269   bool inline_native_Class_query(vmIntrinsics::ID id);
 270   bool inline_native_subtype_check();
 271   bool inline_native_getLength();
 272   bool inline_array_copyOf(bool is_copyOfRange);
 273   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 274   bool inline_preconditions_checkIndex();
 275   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 276   bool inline_native_clone(bool is_virtual);
 277   bool inline_native_Reflection_getCallerClass();
 278   // Helper function for inlining native object hash method
 279   bool inline_native_hashcode(bool is_virtual, bool is_static);
 280   bool inline_native_getClass();
 281 
 282   // Helper functions for inlining arraycopy
 283   bool inline_arraycopy();
 284   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 285                                                 RegionNode* slow_region);
 286   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 287   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 288                                       uint new_idx);
 289 
 290   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 291   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 292   bool inline_unsafe_fence(vmIntrinsics::ID id);
 293   bool inline_onspinwait();
 294   bool inline_fp_conversions(vmIntrinsics::ID id);
 295   bool inline_number_methods(vmIntrinsics::ID id);
 296   bool inline_reference_get();
 297   bool inline_Class_cast();
 298   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 299   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 300   bool inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id);
 301   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 302   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 303   Node* inline_electronicCodeBook_AESCrypt_predicate(bool decrypting);
 304   Node* inline_counterMode_AESCrypt_predicate();
 305   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 306   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 307   bool inline_ghash_processBlocks();
 308   bool inline_base64_encodeBlock();
 309   bool inline_sha_implCompress(vmIntrinsics::ID id);
 310   bool inline_digestBase_implCompressMB(int predicate);
 311   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 312                                  bool long_state, address stubAddr, const char *stubName,
 313                                  Node* src_start, Node* ofs, Node* limit);
 314   Node* get_state_from_sha_object(Node *sha_object);
 315   Node* get_state_from_sha5_object(Node *sha_object);
 316   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 317   bool inline_encodeISOArray();
 318   bool inline_updateCRC32();
 319   bool inline_updateBytesCRC32();
 320   bool inline_updateByteBufferCRC32();
 321   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 322   bool inline_updateBytesCRC32C();
 323   bool inline_updateDirectByteBufferCRC32C();
 324   bool inline_updateBytesAdler32();
 325   bool inline_updateByteBufferAdler32();
 326   bool inline_multiplyToLen();
 327   bool inline_hasNegatives();
 328   bool inline_squareToLen();
 329   bool inline_mulAdd();
 330   bool inline_montgomeryMultiply();
 331   bool inline_montgomerySquare();
 332   bool inline_bigIntegerShift(bool isRightShift);
 333   bool inline_vectorizedMismatch();
 334   bool inline_fma(vmIntrinsics::ID id);
 335   bool inline_character_compare(vmIntrinsics::ID id);
 336   bool inline_fp_min_max(vmIntrinsics::ID id);
 337 
 338   bool inline_profileBoolean();
 339   bool inline_isCompileConstant();
 340   bool inline_continuation(vmIntrinsics::ID id);
 341   bool inline_continuation_do_yield();
 342   bool inline_continuation_jump();
 343   bool inline_continuation_runLevel();
 344   bool inline_continuation_do_continue();
 345   void clear_upper_avx() {
 346 #ifdef X86
 347     if (UseAVX &gt;= 2) {
 348       C-&gt;set_clear_upper_avx(true);
 349     }
 350 #endif
 351   }
 352 };
 353 
 354 //---------------------------make_vm_intrinsic----------------------------
 355 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 356   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 357   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 358 
 359   if (!m-&gt;is_loaded()) {
 360     // Do not attempt to inline unloaded methods.
 361     return NULL;
 362   }
 363 
 364   C2Compiler* compiler = (C2Compiler*)CompileBroker::compiler(CompLevel_full_optimization);
 365   bool is_available = false;
 366 
 367   {
 368     // For calling is_intrinsic_supported and is_intrinsic_disabled_by_flag
 369     // the compiler must transition to &#39;_thread_in_vm&#39; state because both
 370     // methods access VM-internal data.
 371     VM_ENTRY_MARK;
 372     methodHandle mh(THREAD, m-&gt;get_Method());
 373     is_available = compiler != NULL &amp;&amp; compiler-&gt;is_intrinsic_supported(mh, is_virtual) &amp;&amp;
 374                    !C-&gt;directive()-&gt;is_intrinsic_disabled(mh) &amp;&amp;
 375                    !vmIntrinsics::is_disabled_by_flags(mh);
 376 
 377   }
 378 
 379   if (is_available) {
 380     assert(id &lt;= vmIntrinsics::LAST_COMPILER_INLINE, &quot;caller responsibility&quot;);
 381     assert(id != vmIntrinsics::_Object_init &amp;&amp; id != vmIntrinsics::_invoke, &quot;enum out of order?&quot;);
 382     return new LibraryIntrinsic(m, is_virtual,
 383                                 vmIntrinsics::predicates_needed(id),
 384                                 vmIntrinsics::does_virtual_dispatch(id),
 385                                 (vmIntrinsics::ID) id);
 386   } else {
 387     return NULL;
 388   }
 389 }
 390 
 391 //----------------------register_library_intrinsics-----------------------
 392 // Initialize this file&#39;s data structures, for each Compile instance.
 393 void Compile::register_library_intrinsics() {
 394   // Nothing to do here.
 395 }
 396 
 397 JVMState* LibraryIntrinsic::generate(JVMState* jvms) {
 398   LibraryCallKit kit(jvms, this);
 399   Compile* C = kit.C;
 400   int nodes = C-&gt;unique();
 401 #ifndef PRODUCT
 402   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 403     char buf[1000];
 404     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 405     tty-&gt;print_cr(&quot;Intrinsic %s&quot;, str);
 406   }
 407 #endif
 408   ciMethod* callee = kit.callee();
 409   const int bci    = kit.bci();
 410 
 411   // Try to inline the intrinsic.
 412   if ((CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true) &amp;&amp;
 413       kit.try_to_inline(_last_predicate)) {
 414     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual)&quot;
 415                                           : &quot;(intrinsic)&quot;;
 416     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 417     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 418       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 419     }
 420     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 421     if (C-&gt;log()) {
 422       C-&gt;log()-&gt;elem(&quot;intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 423                      vmIntrinsics::name_at(intrinsic_id()),
 424                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 425                      C-&gt;unique() - nodes);
 426     }
 427     // Push the result from the inlined method onto the stack.
 428     kit.push_result();
 429     C-&gt;print_inlining_update(this);
 430     return kit.transfer_exceptions_into_jvms();
 431   }
 432 
 433   // The intrinsic bailed out
 434   if (jvms-&gt;has_method()) {
 435     // Not a root compile.
 436     const char* msg;
 437     if (callee-&gt;intrinsic_candidate()) {
 438       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual)&quot; : &quot;failed to inline (intrinsic)&quot;;
 439     } else {
 440       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual), method not annotated&quot;
 441                          : &quot;failed to inline (intrinsic), method not annotated&quot;;
 442     }
 443     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, msg);
 444     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 445       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, msg);
 446     }
 447   } else {
 448     // Root compile
 449     ResourceMark rm;
 450     stringStream msg_stream;
 451     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 452                      vmIntrinsics::name_at(intrinsic_id()),
 453                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 454     const char *msg = msg_stream.as_string();
 455     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 456     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 457       tty-&gt;print(&quot;%s&quot;, msg);
 458     }
 459   }
 460   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 461   C-&gt;print_inlining_update(this);
 462   return NULL;
 463 }
 464 
 465 Node* LibraryIntrinsic::generate_predicate(JVMState* jvms, int predicate) {
 466   LibraryCallKit kit(jvms, this);
 467   Compile* C = kit.C;
 468   int nodes = C-&gt;unique();
 469   _last_predicate = predicate;
 470 #ifndef PRODUCT
 471   assert(is_predicated() &amp;&amp; predicate &lt; predicates_count(), &quot;sanity&quot;);
 472   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 473     char buf[1000];
 474     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 475     tty-&gt;print_cr(&quot;Predicate for intrinsic %s&quot;, str);
 476   }
 477 #endif
 478   ciMethod* callee = kit.callee();
 479   const int bci    = kit.bci();
 480 
 481   Node* slow_ctl = kit.try_to_predicate(predicate);
 482   if (!kit.failing()) {
 483     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual, predicate)&quot;
 484                                           : &quot;(intrinsic, predicate)&quot;;
 485     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 486     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 487       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 488     }
 489     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 490     if (C-&gt;log()) {
 491       C-&gt;log()-&gt;elem(&quot;predicate_intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 492                      vmIntrinsics::name_at(intrinsic_id()),
 493                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 494                      C-&gt;unique() - nodes);
 495     }
 496     return slow_ctl; // Could be NULL if the check folds.
 497   }
 498 
 499   // The intrinsic bailed out
 500   if (jvms-&gt;has_method()) {
 501     // Not a root compile.
 502     const char* msg = &quot;failed to generate predicate for intrinsic&quot;;
 503     CompileTask::print_inlining_ul(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 504     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 505       C-&gt;print_inlining(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 506     }
 507   } else {
 508     // Root compile
 509     ResourceMark rm;
 510     stringStream msg_stream;
 511     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 512                      vmIntrinsics::name_at(intrinsic_id()),
 513                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 514     const char *msg = msg_stream.as_string();
 515     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 516     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 517       C-&gt;print_inlining_stream()-&gt;print(&quot;%s&quot;, msg);
 518     }
 519   }
 520   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 521   return NULL;
 522 }
 523 
 524 bool LibraryCallKit::try_to_inline(int predicate) {
 525   // Handle symbolic names for otherwise undistinguished boolean switches:
 526   const bool is_store       = true;
 527   const bool is_compress    = true;
 528   const bool is_static      = true;
 529   const bool is_volatile    = true;
 530 
 531   if (!jvms()-&gt;has_method()) {
 532     // Root JVMState has a null method.
 533     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 534     // Insert the memory aliasing node
 535     set_all_memory(reset_memory());
 536   }
 537   assert(merged_memory(), &quot;&quot;);
 538 
 539 
 540   switch (intrinsic_id()) {
 541   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 542   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 543   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 544 
 545   case vmIntrinsics::_ceil:
 546   case vmIntrinsics::_floor:
 547   case vmIntrinsics::_rint:
 548   case vmIntrinsics::_dsin:
 549   case vmIntrinsics::_dcos:
 550   case vmIntrinsics::_dtan:
 551   case vmIntrinsics::_dabs:
 552   case vmIntrinsics::_fabs:
 553   case vmIntrinsics::_iabs:
 554   case vmIntrinsics::_labs:
 555   case vmIntrinsics::_datan2:
 556   case vmIntrinsics::_dsqrt:
 557   case vmIntrinsics::_dexp:
 558   case vmIntrinsics::_dlog:
 559   case vmIntrinsics::_dlog10:
 560   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 561 
 562   case vmIntrinsics::_min:
 563   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 564 
 565   case vmIntrinsics::_notify:
 566   case vmIntrinsics::_notifyAll:
 567     return inline_notify(intrinsic_id());
 568 
 569   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 570   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 571   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 572   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 573   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 574   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
 575   case vmIntrinsics::_multiplyExactI:           return inline_math_multiplyExactI();
 576   case vmIntrinsics::_multiplyExactL:           return inline_math_multiplyExactL();
 577   case vmIntrinsics::_multiplyHigh:             return inline_math_multiplyHigh();
 578   case vmIntrinsics::_negateExactI:             return inline_math_negateExactI();
 579   case vmIntrinsics::_negateExactL:             return inline_math_negateExactL();
 580   case vmIntrinsics::_subtractExactI:           return inline_math_subtractExactI(false /* subtract */);
 581   case vmIntrinsics::_subtractExactL:           return inline_math_subtractExactL(false /* subtract */);
 582 
 583   case vmIntrinsics::_arraycopy:                return inline_arraycopy();
 584 
 585   case vmIntrinsics::_compareToL:               return inline_string_compareTo(StrIntrinsicNode::LL);
 586   case vmIntrinsics::_compareToU:               return inline_string_compareTo(StrIntrinsicNode::UU);
 587   case vmIntrinsics::_compareToLU:              return inline_string_compareTo(StrIntrinsicNode::LU);
 588   case vmIntrinsics::_compareToUL:              return inline_string_compareTo(StrIntrinsicNode::UL);
 589 
 590   case vmIntrinsics::_indexOfL:                 return inline_string_indexOf(StrIntrinsicNode::LL);
 591   case vmIntrinsics::_indexOfU:                 return inline_string_indexOf(StrIntrinsicNode::UU);
 592   case vmIntrinsics::_indexOfUL:                return inline_string_indexOf(StrIntrinsicNode::UL);
 593   case vmIntrinsics::_indexOfIL:                return inline_string_indexOfI(StrIntrinsicNode::LL);
 594   case vmIntrinsics::_indexOfIU:                return inline_string_indexOfI(StrIntrinsicNode::UU);
 595   case vmIntrinsics::_indexOfIUL:               return inline_string_indexOfI(StrIntrinsicNode::UL);
 596   case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();
 597 
 598   case vmIntrinsics::_equalsL:                  return inline_string_equals(StrIntrinsicNode::LL);
 599   case vmIntrinsics::_equalsU:                  return inline_string_equals(StrIntrinsicNode::UU);
 600 
 601   case vmIntrinsics::_toBytesStringU:           return inline_string_toBytesU();
 602   case vmIntrinsics::_getCharsStringU:          return inline_string_getCharsU();
 603   case vmIntrinsics::_getCharStringU:           return inline_string_char_access(!is_store);
 604   case vmIntrinsics::_putCharStringU:           return inline_string_char_access( is_store);
 605 
 606   case vmIntrinsics::_compressStringC:
 607   case vmIntrinsics::_compressStringB:          return inline_string_copy( is_compress);
 608   case vmIntrinsics::_inflateStringC:
 609   case vmIntrinsics::_inflateStringB:           return inline_string_copy(!is_compress);
 610 
 611   case vmIntrinsics::_getReference:             return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false);
 612   case vmIntrinsics::_getBoolean:               return inline_unsafe_access(!is_store, T_BOOLEAN,  Relaxed, false);
 613   case vmIntrinsics::_getByte:                  return inline_unsafe_access(!is_store, T_BYTE,     Relaxed, false);
 614   case vmIntrinsics::_getShort:                 return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, false);
 615   case vmIntrinsics::_getChar:                  return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, false);
 616   case vmIntrinsics::_getInt:                   return inline_unsafe_access(!is_store, T_INT,      Relaxed, false);
 617   case vmIntrinsics::_getLong:                  return inline_unsafe_access(!is_store, T_LONG,     Relaxed, false);
 618   case vmIntrinsics::_getFloat:                 return inline_unsafe_access(!is_store, T_FLOAT,    Relaxed, false);
 619   case vmIntrinsics::_getDouble:                return inline_unsafe_access(!is_store, T_DOUBLE,   Relaxed, false);
 620 
 621   case vmIntrinsics::_putReference:             return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false);
 622   case vmIntrinsics::_putBoolean:               return inline_unsafe_access( is_store, T_BOOLEAN,  Relaxed, false);
 623   case vmIntrinsics::_putByte:                  return inline_unsafe_access( is_store, T_BYTE,     Relaxed, false);
 624   case vmIntrinsics::_putShort:                 return inline_unsafe_access( is_store, T_SHORT,    Relaxed, false);
 625   case vmIntrinsics::_putChar:                  return inline_unsafe_access( is_store, T_CHAR,     Relaxed, false);
 626   case vmIntrinsics::_putInt:                   return inline_unsafe_access( is_store, T_INT,      Relaxed, false);
 627   case vmIntrinsics::_putLong:                  return inline_unsafe_access( is_store, T_LONG,     Relaxed, false);
 628   case vmIntrinsics::_putFloat:                 return inline_unsafe_access( is_store, T_FLOAT,    Relaxed, false);
 629   case vmIntrinsics::_putDouble:                return inline_unsafe_access( is_store, T_DOUBLE,   Relaxed, false);
 630 
 631   case vmIntrinsics::_getReferenceVolatile:     return inline_unsafe_access(!is_store, T_OBJECT,   Volatile, false);
 632   case vmIntrinsics::_getBooleanVolatile:       return inline_unsafe_access(!is_store, T_BOOLEAN,  Volatile, false);
 633   case vmIntrinsics::_getByteVolatile:          return inline_unsafe_access(!is_store, T_BYTE,     Volatile, false);
 634   case vmIntrinsics::_getShortVolatile:         return inline_unsafe_access(!is_store, T_SHORT,    Volatile, false);
 635   case vmIntrinsics::_getCharVolatile:          return inline_unsafe_access(!is_store, T_CHAR,     Volatile, false);
 636   case vmIntrinsics::_getIntVolatile:           return inline_unsafe_access(!is_store, T_INT,      Volatile, false);
 637   case vmIntrinsics::_getLongVolatile:          return inline_unsafe_access(!is_store, T_LONG,     Volatile, false);
 638   case vmIntrinsics::_getFloatVolatile:         return inline_unsafe_access(!is_store, T_FLOAT,    Volatile, false);
 639   case vmIntrinsics::_getDoubleVolatile:        return inline_unsafe_access(!is_store, T_DOUBLE,   Volatile, false);
 640 
 641   case vmIntrinsics::_putReferenceVolatile:     return inline_unsafe_access( is_store, T_OBJECT,   Volatile, false);
 642   case vmIntrinsics::_putBooleanVolatile:       return inline_unsafe_access( is_store, T_BOOLEAN,  Volatile, false);
 643   case vmIntrinsics::_putByteVolatile:          return inline_unsafe_access( is_store, T_BYTE,     Volatile, false);
 644   case vmIntrinsics::_putShortVolatile:         return inline_unsafe_access( is_store, T_SHORT,    Volatile, false);
 645   case vmIntrinsics::_putCharVolatile:          return inline_unsafe_access( is_store, T_CHAR,     Volatile, false);
 646   case vmIntrinsics::_putIntVolatile:           return inline_unsafe_access( is_store, T_INT,      Volatile, false);
 647   case vmIntrinsics::_putLongVolatile:          return inline_unsafe_access( is_store, T_LONG,     Volatile, false);
 648   case vmIntrinsics::_putFloatVolatile:         return inline_unsafe_access( is_store, T_FLOAT,    Volatile, false);
 649   case vmIntrinsics::_putDoubleVolatile:        return inline_unsafe_access( is_store, T_DOUBLE,   Volatile, false);
 650 
 651   case vmIntrinsics::_getShortUnaligned:        return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, true);
 652   case vmIntrinsics::_getCharUnaligned:         return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, true);
 653   case vmIntrinsics::_getIntUnaligned:          return inline_unsafe_access(!is_store, T_INT,      Relaxed, true);
 654   case vmIntrinsics::_getLongUnaligned:         return inline_unsafe_access(!is_store, T_LONG,     Relaxed, true);
 655 
 656   case vmIntrinsics::_putShortUnaligned:        return inline_unsafe_access( is_store, T_SHORT,    Relaxed, true);
 657   case vmIntrinsics::_putCharUnaligned:         return inline_unsafe_access( is_store, T_CHAR,     Relaxed, true);
 658   case vmIntrinsics::_putIntUnaligned:          return inline_unsafe_access( is_store, T_INT,      Relaxed, true);
 659   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access( is_store, T_LONG,     Relaxed, true);
 660 
 661   case vmIntrinsics::_getReferenceAcquire:      return inline_unsafe_access(!is_store, T_OBJECT,   Acquire, false);
 662   case vmIntrinsics::_getBooleanAcquire:        return inline_unsafe_access(!is_store, T_BOOLEAN,  Acquire, false);
 663   case vmIntrinsics::_getByteAcquire:           return inline_unsafe_access(!is_store, T_BYTE,     Acquire, false);
 664   case vmIntrinsics::_getShortAcquire:          return inline_unsafe_access(!is_store, T_SHORT,    Acquire, false);
 665   case vmIntrinsics::_getCharAcquire:           return inline_unsafe_access(!is_store, T_CHAR,     Acquire, false);
 666   case vmIntrinsics::_getIntAcquire:            return inline_unsafe_access(!is_store, T_INT,      Acquire, false);
 667   case vmIntrinsics::_getLongAcquire:           return inline_unsafe_access(!is_store, T_LONG,     Acquire, false);
 668   case vmIntrinsics::_getFloatAcquire:          return inline_unsafe_access(!is_store, T_FLOAT,    Acquire, false);
 669   case vmIntrinsics::_getDoubleAcquire:         return inline_unsafe_access(!is_store, T_DOUBLE,   Acquire, false);
 670 
 671   case vmIntrinsics::_putReferenceRelease:      return inline_unsafe_access( is_store, T_OBJECT,   Release, false);
 672   case vmIntrinsics::_putBooleanRelease:        return inline_unsafe_access( is_store, T_BOOLEAN,  Release, false);
 673   case vmIntrinsics::_putByteRelease:           return inline_unsafe_access( is_store, T_BYTE,     Release, false);
 674   case vmIntrinsics::_putShortRelease:          return inline_unsafe_access( is_store, T_SHORT,    Release, false);
 675   case vmIntrinsics::_putCharRelease:           return inline_unsafe_access( is_store, T_CHAR,     Release, false);
 676   case vmIntrinsics::_putIntRelease:            return inline_unsafe_access( is_store, T_INT,      Release, false);
 677   case vmIntrinsics::_putLongRelease:           return inline_unsafe_access( is_store, T_LONG,     Release, false);
 678   case vmIntrinsics::_putFloatRelease:          return inline_unsafe_access( is_store, T_FLOAT,    Release, false);
 679   case vmIntrinsics::_putDoubleRelease:         return inline_unsafe_access( is_store, T_DOUBLE,   Release, false);
 680 
 681   case vmIntrinsics::_getReferenceOpaque:       return inline_unsafe_access(!is_store, T_OBJECT,   Opaque, false);
 682   case vmIntrinsics::_getBooleanOpaque:         return inline_unsafe_access(!is_store, T_BOOLEAN,  Opaque, false);
 683   case vmIntrinsics::_getByteOpaque:            return inline_unsafe_access(!is_store, T_BYTE,     Opaque, false);
 684   case vmIntrinsics::_getShortOpaque:           return inline_unsafe_access(!is_store, T_SHORT,    Opaque, false);
 685   case vmIntrinsics::_getCharOpaque:            return inline_unsafe_access(!is_store, T_CHAR,     Opaque, false);
 686   case vmIntrinsics::_getIntOpaque:             return inline_unsafe_access(!is_store, T_INT,      Opaque, false);
 687   case vmIntrinsics::_getLongOpaque:            return inline_unsafe_access(!is_store, T_LONG,     Opaque, false);
 688   case vmIntrinsics::_getFloatOpaque:           return inline_unsafe_access(!is_store, T_FLOAT,    Opaque, false);
 689   case vmIntrinsics::_getDoubleOpaque:          return inline_unsafe_access(!is_store, T_DOUBLE,   Opaque, false);
 690 
 691   case vmIntrinsics::_putReferenceOpaque:       return inline_unsafe_access( is_store, T_OBJECT,   Opaque, false);
 692   case vmIntrinsics::_putBooleanOpaque:         return inline_unsafe_access( is_store, T_BOOLEAN,  Opaque, false);
 693   case vmIntrinsics::_putByteOpaque:            return inline_unsafe_access( is_store, T_BYTE,     Opaque, false);
 694   case vmIntrinsics::_putShortOpaque:           return inline_unsafe_access( is_store, T_SHORT,    Opaque, false);
 695   case vmIntrinsics::_putCharOpaque:            return inline_unsafe_access( is_store, T_CHAR,     Opaque, false);
 696   case vmIntrinsics::_putIntOpaque:             return inline_unsafe_access( is_store, T_INT,      Opaque, false);
 697   case vmIntrinsics::_putLongOpaque:            return inline_unsafe_access( is_store, T_LONG,     Opaque, false);
 698   case vmIntrinsics::_putFloatOpaque:           return inline_unsafe_access( is_store, T_FLOAT,    Opaque, false);
 699   case vmIntrinsics::_putDoubleOpaque:          return inline_unsafe_access( is_store, T_DOUBLE,   Opaque, false);
 700 
 701   case vmIntrinsics::_compareAndSetReference:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap,      Volatile);
 702   case vmIntrinsics::_compareAndSetByte:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap,      Volatile);
 703   case vmIntrinsics::_compareAndSetShort:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap,      Volatile);
 704   case vmIntrinsics::_compareAndSetInt:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap,      Volatile);
 705   case vmIntrinsics::_compareAndSetLong:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap,      Volatile);
 706 
 707   case vmIntrinsics::_weakCompareAndSetReferencePlain:     return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Relaxed);
 708   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Acquire);
 709   case vmIntrinsics::_weakCompareAndSetReferenceRelease:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Release);
 710   case vmIntrinsics::_weakCompareAndSetReference:          return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Volatile);
 711   case vmIntrinsics::_weakCompareAndSetBytePlain:          return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Relaxed);
 712   case vmIntrinsics::_weakCompareAndSetByteAcquire:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Acquire);
 713   case vmIntrinsics::_weakCompareAndSetByteRelease:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Release);
 714   case vmIntrinsics::_weakCompareAndSetByte:               return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Volatile);
 715   case vmIntrinsics::_weakCompareAndSetShortPlain:         return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Relaxed);
 716   case vmIntrinsics::_weakCompareAndSetShortAcquire:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Acquire);
 717   case vmIntrinsics::_weakCompareAndSetShortRelease:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Release);
 718   case vmIntrinsics::_weakCompareAndSetShort:              return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Volatile);
 719   case vmIntrinsics::_weakCompareAndSetIntPlain:           return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Relaxed);
 720   case vmIntrinsics::_weakCompareAndSetIntAcquire:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Acquire);
 721   case vmIntrinsics::_weakCompareAndSetIntRelease:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Release);
 722   case vmIntrinsics::_weakCompareAndSetInt:                return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Volatile);
 723   case vmIntrinsics::_weakCompareAndSetLongPlain:          return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Relaxed);
 724   case vmIntrinsics::_weakCompareAndSetLongAcquire:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Acquire);
 725   case vmIntrinsics::_weakCompareAndSetLongRelease:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Release);
 726   case vmIntrinsics::_weakCompareAndSetLong:               return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Volatile);
 727 
 728   case vmIntrinsics::_compareAndExchangeReference:         return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Volatile);
 729   case vmIntrinsics::_compareAndExchangeReferenceAcquire:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Acquire);
 730   case vmIntrinsics::_compareAndExchangeReferenceRelease:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Release);
 731   case vmIntrinsics::_compareAndExchangeByte:              return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Volatile);
 732   case vmIntrinsics::_compareAndExchangeByteAcquire:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Acquire);
 733   case vmIntrinsics::_compareAndExchangeByteRelease:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Release);
 734   case vmIntrinsics::_compareAndExchangeShort:             return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Volatile);
 735   case vmIntrinsics::_compareAndExchangeShortAcquire:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Acquire);
 736   case vmIntrinsics::_compareAndExchangeShortRelease:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Release);
 737   case vmIntrinsics::_compareAndExchangeInt:               return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Volatile);
 738   case vmIntrinsics::_compareAndExchangeIntAcquire:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Acquire);
 739   case vmIntrinsics::_compareAndExchangeIntRelease:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Release);
 740   case vmIntrinsics::_compareAndExchangeLong:              return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Volatile);
 741   case vmIntrinsics::_compareAndExchangeLongAcquire:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Acquire);
 742   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 743 
 744   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 745   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 746   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 747   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 748 
 749   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 750   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 751   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 752   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 753   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 754 
 755   case vmIntrinsics::_loadFence:
 756   case vmIntrinsics::_storeFence:
 757   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 758 
 759   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 760 
 761   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 762 
 763   case vmIntrinsics::_scopedCache:              return inline_native_scopedCache();
 764   case vmIntrinsics::_setScopedCache:           return inline_native_setScopedCache();
 765 
 766 #ifdef JFR_HAVE_INTRINSICS
 767   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 768   case vmIntrinsics::_getClassId:               return inline_native_classID();
 769   // case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 770 #endif
 771   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 772   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
 773   case vmIntrinsics::_writeback0:               return inline_unsafe_writeback0();
 774   case vmIntrinsics::_writebackPreSync0:        return inline_unsafe_writebackSync0(true);
 775   case vmIntrinsics::_writebackPostSync0:       return inline_unsafe_writebackSync0(false);
 776   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 777   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 778   case vmIntrinsics::_getLength:                return inline_native_getLength();
 779   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 780   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 781   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 782   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 783   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 784   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 785 
 786   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 787   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 788 
 789   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 790 
 791   case vmIntrinsics::_isInstance:
 792   case vmIntrinsics::_getModifiers:
 793   case vmIntrinsics::_isInterface:
 794   case vmIntrinsics::_isArray:
 795   case vmIntrinsics::_isPrimitive:
 796   case vmIntrinsics::_getSuperclass:
 797   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 798 
 799   case vmIntrinsics::_floatToRawIntBits:
 800   case vmIntrinsics::_floatToIntBits:
 801   case vmIntrinsics::_intBitsToFloat:
 802   case vmIntrinsics::_doubleToRawLongBits:
 803   case vmIntrinsics::_doubleToLongBits:
 804   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 805 
 806   case vmIntrinsics::_numberOfLeadingZeros_i:
 807   case vmIntrinsics::_numberOfLeadingZeros_l:
 808   case vmIntrinsics::_numberOfTrailingZeros_i:
 809   case vmIntrinsics::_numberOfTrailingZeros_l:
 810   case vmIntrinsics::_bitCount_i:
 811   case vmIntrinsics::_bitCount_l:
 812   case vmIntrinsics::_reverseBytes_i:
 813   case vmIntrinsics::_reverseBytes_l:
 814   case vmIntrinsics::_reverseBytes_s:
 815   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 816 
 817   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 818 
 819   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 820 
 821   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 822 
 823   case vmIntrinsics::_aescrypt_encryptBlock:
 824   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 825 
 826   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 827   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 828     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 829 
 830   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 831   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 832     return inline_electronicCodeBook_AESCrypt(intrinsic_id());
 833 
 834   case vmIntrinsics::_counterMode_AESCrypt:
 835     return inline_counterMode_AESCrypt(intrinsic_id());
 836 
 837   case vmIntrinsics::_sha_implCompress:
 838   case vmIntrinsics::_sha2_implCompress:
 839   case vmIntrinsics::_sha5_implCompress:
 840     return inline_sha_implCompress(intrinsic_id());
 841 
 842   case vmIntrinsics::_digestBase_implCompressMB:
 843     return inline_digestBase_implCompressMB(predicate);
 844 
 845   case vmIntrinsics::_multiplyToLen:
 846     return inline_multiplyToLen();
 847 
 848   case vmIntrinsics::_squareToLen:
 849     return inline_squareToLen();
 850 
 851   case vmIntrinsics::_mulAdd:
 852     return inline_mulAdd();
 853 
 854   case vmIntrinsics::_montgomeryMultiply:
 855     return inline_montgomeryMultiply();
 856   case vmIntrinsics::_montgomerySquare:
 857     return inline_montgomerySquare();
 858 
 859   case vmIntrinsics::_bigIntegerRightShiftWorker:
 860     return inline_bigIntegerShift(true);
 861   case vmIntrinsics::_bigIntegerLeftShiftWorker:
 862     return inline_bigIntegerShift(false);
 863 
 864   case vmIntrinsics::_vectorizedMismatch:
 865     return inline_vectorizedMismatch();
 866 
 867   case vmIntrinsics::_ghash_processBlocks:
 868     return inline_ghash_processBlocks();
 869   case vmIntrinsics::_base64_encodeBlock:
 870     return inline_base64_encodeBlock();
 871 
 872   case vmIntrinsics::_encodeISOArray:
 873   case vmIntrinsics::_encodeByteISOArray:
 874     return inline_encodeISOArray();
 875 
 876   case vmIntrinsics::_updateCRC32:
 877     return inline_updateCRC32();
 878   case vmIntrinsics::_updateBytesCRC32:
 879     return inline_updateBytesCRC32();
 880   case vmIntrinsics::_updateByteBufferCRC32:
 881     return inline_updateByteBufferCRC32();
 882 
 883   case vmIntrinsics::_updateBytesCRC32C:
 884     return inline_updateBytesCRC32C();
 885   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 886     return inline_updateDirectByteBufferCRC32C();
 887 
 888   case vmIntrinsics::_updateBytesAdler32:
 889     return inline_updateBytesAdler32();
 890   case vmIntrinsics::_updateByteBufferAdler32:
 891     return inline_updateByteBufferAdler32();
 892 
 893   case vmIntrinsics::_profileBoolean:
 894     return inline_profileBoolean();
 895   case vmIntrinsics::_isCompileConstant:
 896     return inline_isCompileConstant();
 897 
 898   case vmIntrinsics::_hasNegatives:
 899     return inline_hasNegatives();
 900 
 901   case vmIntrinsics::_fmaD:
 902   case vmIntrinsics::_fmaF:
 903     return inline_fma(intrinsic_id());
 904 
 905   case vmIntrinsics::_Continuation_getSP:
 906   case vmIntrinsics::_Continuation_getPC:
 907     return inline_continuation(intrinsic_id());
 908   case vmIntrinsics::_Continuation_doContinue:
 909     return inline_continuation_do_continue();
 910   case vmIntrinsics::_Continuation_doYield:
 911     return inline_continuation_do_yield();
 912   case vmIntrinsics::_Continuation_jump:
 913     return inline_continuation_jump();
 914   case vmIntrinsics::_Continuation_runLevel:
 915     return inline_continuation_runLevel();
 916 
 917   case vmIntrinsics::_isDigit:
 918   case vmIntrinsics::_isLowerCase:
 919   case vmIntrinsics::_isUpperCase:
 920   case vmIntrinsics::_isWhitespace:
 921     return inline_character_compare(intrinsic_id());
 922 
 923   case vmIntrinsics::_maxF:
 924   case vmIntrinsics::_minF:
 925   case vmIntrinsics::_maxD:
 926   case vmIntrinsics::_minD:
 927     return inline_fp_min_max(intrinsic_id());
 928 
 929   default:
 930     // If you get here, it may be that someone has added a new intrinsic
 931     // to the list in vmSymbols.hpp without implementing it here.
 932 #ifndef PRODUCT
 933     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 934       tty-&gt;print_cr(&quot;*** Warning: Unimplemented intrinsic %s(%d)&quot;,
 935                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 936     }
 937 #endif
 938     return false;
 939   }
 940 }
 941 
 942 Node* LibraryCallKit::try_to_predicate(int predicate) {
 943   if (!jvms()-&gt;has_method()) {
 944     // Root JVMState has a null method.
 945     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 946     // Insert the memory aliasing node
 947     set_all_memory(reset_memory());
 948   }
 949   assert(merged_memory(), &quot;&quot;);
 950 
 951   switch (intrinsic_id()) {
 952   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 953     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 954   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 955     return inline_cipherBlockChaining_AESCrypt_predicate(true);
 956   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 957     return inline_electronicCodeBook_AESCrypt_predicate(false);
 958   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 959     return inline_electronicCodeBook_AESCrypt_predicate(true);
 960   case vmIntrinsics::_counterMode_AESCrypt:
 961     return inline_counterMode_AESCrypt_predicate();
 962   case vmIntrinsics::_digestBase_implCompressMB:
 963     return inline_digestBase_implCompressMB_predicate(predicate);
 964 
 965   default:
 966     // If you get here, it may be that someone has added a new intrinsic
 967     // to the list in vmSymbols.hpp without implementing it here.
 968 #ifndef PRODUCT
 969     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 970       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 971                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 972     }
 973 #endif
 974     Node* slow_ctl = control();
 975     set_control(top()); // No fast path instrinsic
 976     return slow_ctl;
 977   }
 978 }
 979 
 980 //------------------------------set_result-------------------------------
 981 // Helper function for finishing intrinsics.
 982 void LibraryCallKit::set_result(RegionNode* region, PhiNode* value) {
 983   record_for_igvn(region);
 984   set_control(_gvn.transform(region));
 985   set_result( _gvn.transform(value));
 986   assert(value-&gt;type()-&gt;basic_type() == result()-&gt;bottom_type()-&gt;basic_type(), &quot;sanity&quot;);
 987 }
 988 
 989 //------------------------------generate_guard---------------------------
 990 // Helper function for generating guarded fast-slow graph structures.
 991 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
 992 // then a fast path can be taken.  (We generally hope it fails.)
 993 // In all cases, GraphKit::control() is updated to the fast path.
 994 // The returned value represents the control for the slow path.
 995 // The return value is never &#39;top&#39;; it is either a valid control
 996 // or NULL if it is obvious that the slow path can never be taken.
 997 // Also, if region and the slow control are not NULL, the slow edge
 998 // is appended to the region.
 999 Node* LibraryCallKit::generate_guard(Node* test, RegionNode* region, float true_prob) {
1000   if (stopped()) {
1001     // Already short circuited.
1002     return NULL;
1003   }
1004 
1005   // Build an if node and its projections.
1006   // If test is true we take the slow path, which we assume is uncommon.
1007   if (_gvn.type(test) == TypeInt::ZERO) {
1008     // The slow branch is never taken.  No need to build this guard.
1009     return NULL;
1010   }
1011 
1012   IfNode* iff = create_and_map_if(control(), test, true_prob, COUNT_UNKNOWN);
1013 
1014   Node* if_slow = _gvn.transform(new IfTrueNode(iff));
1015   if (if_slow == top()) {
1016     // The slow branch is never taken.  No need to build this guard.
1017     return NULL;
1018   }
1019 
1020   if (region != NULL)
1021     region-&gt;add_req(if_slow);
1022 
1023   Node* if_fast = _gvn.transform(new IfFalseNode(iff));
1024   set_control(if_fast);
1025 
1026   return if_slow;
1027 }
1028 
1029 inline Node* LibraryCallKit::generate_slow_guard(Node* test, RegionNode* region) {
1030   return generate_guard(test, region, PROB_UNLIKELY_MAG(3));
1031 }
1032 inline Node* LibraryCallKit::generate_fair_guard(Node* test, RegionNode* region) {
1033   return generate_guard(test, region, PROB_FAIR);
1034 }
1035 
1036 inline Node* LibraryCallKit::generate_negative_guard(Node* index, RegionNode* region,
1037                                                      Node* *pos_index) {
1038   if (stopped())
1039     return NULL;                // already stopped
1040   if (_gvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
1041     return NULL;                // index is already adequately typed
1042   Node* cmp_lt = _gvn.transform(new CmpINode(index, intcon(0)));
1043   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1044   Node* is_neg = generate_guard(bol_lt, region, PROB_MIN);
1045   if (is_neg != NULL &amp;&amp; pos_index != NULL) {
1046     // Emulate effect of Parse::adjust_map_after_if.
1047     Node* ccast = new CastIINode(index, TypeInt::POS);
1048     ccast-&gt;set_req(0, control());
1049     (*pos_index) = _gvn.transform(ccast);
1050   }
1051   return is_neg;
1052 }
1053 
1054 // Make sure that &#39;position&#39; is a valid limit index, in [0..length].
1055 // There are two equivalent plans for checking this:
1056 //   A. (offset + copyLength)  unsigned&lt;=  arrayLength
1057 //   B. offset  &lt;=  (arrayLength - copyLength)
1058 // We require that all of the values above, except for the sum and
1059 // difference, are already known to be non-negative.
1060 // Plan A is robust in the face of overflow, if offset and copyLength
1061 // are both hugely positive.
1062 //
1063 // Plan B is less direct and intuitive, but it does not overflow at
1064 // all, since the difference of two non-negatives is always
1065 // representable.  Whenever Java methods must perform the equivalent
1066 // check they generally use Plan B instead of Plan A.
1067 // For the moment we use Plan A.
1068 inline Node* LibraryCallKit::generate_limit_guard(Node* offset,
1069                                                   Node* subseq_length,
1070                                                   Node* array_length,
1071                                                   RegionNode* region) {
1072   if (stopped())
1073     return NULL;                // already stopped
1074   bool zero_offset = _gvn.type(offset) == TypeInt::ZERO;
1075   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
1076     return NULL;                // common case of whole-array copy
1077   Node* last = subseq_length;
1078   if (!zero_offset)             // last += offset
1079     last = _gvn.transform(new AddINode(last, offset));
1080   Node* cmp_lt = _gvn.transform(new CmpUNode(array_length, last));
1081   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1082   Node* is_over = generate_guard(bol_lt, region, PROB_MIN);
1083   return is_over;
1084 }
1085 
1086 // Emit range checks for the given String.value byte array
1087 void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {
1088   if (stopped()) {
1089     return; // already stopped
1090   }
1091   RegionNode* bailout = new RegionNode(1);
1092   record_for_igvn(bailout);
1093   if (char_count) {
1094     // Convert char count to byte count
1095     count = _gvn.transform(new LShiftINode(count, intcon(1)));
1096   }
1097 
1098   // Offset and count must not be negative
1099   generate_negative_guard(offset, bailout);
1100   generate_negative_guard(count, bailout);
1101   // Offset + count must not exceed length of array
1102   generate_limit_guard(offset, count, load_array_length(array), bailout);
1103 
1104   if (bailout-&gt;req() &gt; 1) {
1105     PreserveJVMState pjvms(this);
1106     set_control(_gvn.transform(bailout));
1107     uncommon_trap(Deoptimization::Reason_intrinsic,
1108                   Deoptimization::Action_maybe_recompile);
1109   }
1110 }
1111 
1112 //--------------------------generate_current_thread--------------------
1113 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1114   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1115   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1116   Node* thread = _gvn.transform(new ThreadLocalNode());
1117   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
1118   //Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p-&gt;bottom_type()-&gt;is_ptr(), thread_type, T_OBJECT, MemNode::unordered));
1119   Node* threadObj = make_load(NULL, p, thread_type, T_OBJECT, MemNode::unordered);
1120   tls_output = thread;
1121   return threadObj;
1122 }
1123 
1124 
1125 //------------------------------make_string_method_node------------------------
1126 // Helper method for String intrinsic functions. This version is called with
1127 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1128 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1129 // containing the lengths of str1 and str2.
1130 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1131   Node* result = NULL;
1132   switch (opcode) {
1133   case Op_StrIndexOf:
1134     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1135                                 str1_start, cnt1, str2_start, cnt2, ae);
1136     break;
1137   case Op_StrComp:
1138     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1139                              str1_start, cnt1, str2_start, cnt2, ae);
1140     break;
1141   case Op_StrEquals:
1142     // We already know that cnt1 == cnt2 here (checked in &#39;inline_string_equals&#39;).
1143     // Use the constant length if there is one because optimized match rule may exist.
1144     result = new StrEqualsNode(control(), memory(TypeAryPtr::BYTES),
1145                                str1_start, str2_start, cnt2-&gt;is_Con() ? cnt2 : cnt1, ae);
1146     break;
1147   default:
1148     ShouldNotReachHere();
1149     return NULL;
1150   }
1151 
1152   // All these intrinsics have checks.
1153   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1154   clear_upper_avx();
1155 
1156   return _gvn.transform(result);
1157 }
1158 
1159 //------------------------------inline_string_compareTo------------------------
1160 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1161   Node* arg1 = argument(0);
1162   Node* arg2 = argument(1);
1163 
1164   arg1 = must_be_not_null(arg1, true);
1165   arg2 = must_be_not_null(arg2, true);
1166 
1167   // Get start addr and length of first argument
1168   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1169   Node* arg1_cnt    = load_array_length(arg1);
1170 
1171   // Get start addr and length of second argument
1172   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1173   Node* arg2_cnt    = load_array_length(arg2);
1174 
1175   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1176   set_result(result);
1177   return true;
1178 }
1179 
1180 //------------------------------inline_string_equals------------------------
1181 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1182   Node* arg1 = argument(0);
1183   Node* arg2 = argument(1);
1184 
1185   // paths (plus control) merge
1186   RegionNode* region = new RegionNode(3);
1187   Node* phi = new PhiNode(region, TypeInt::BOOL);
1188 
1189   if (!stopped()) {
1190 
1191     arg1 = must_be_not_null(arg1, true);
1192     arg2 = must_be_not_null(arg2, true);
1193 
1194     // Get start addr and length of first argument
1195     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1196     Node* arg1_cnt    = load_array_length(arg1);
1197 
1198     // Get start addr and length of second argument
1199     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1200     Node* arg2_cnt    = load_array_length(arg2);
1201 
1202     // Check for arg1_cnt != arg2_cnt
1203     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1204     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1205     Node* if_ne = generate_slow_guard(bol, NULL);
1206     if (if_ne != NULL) {
1207       phi-&gt;init_req(2, intcon(0));
1208       region-&gt;init_req(2, if_ne);
1209     }
1210 
1211     // Check for count == 0 is done by assembler code for StrEquals.
1212 
1213     if (!stopped()) {
1214       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1215       phi-&gt;init_req(1, equals);
1216       region-&gt;init_req(1, control());
1217     }
1218   }
1219 
1220   // post merge
1221   set_control(_gvn.transform(region));
1222   record_for_igvn(region);
1223 
1224   set_result(_gvn.transform(phi));
1225   return true;
1226 }
1227 
1228 //------------------------------inline_array_equals----------------------------
1229 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1230   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1231   Node* arg1 = argument(0);
1232   Node* arg2 = argument(1);
1233 
1234   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1235   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1236   clear_upper_avx();
1237 
1238   return true;
1239 }
1240 
1241 //------------------------------inline_hasNegatives------------------------------
1242 bool LibraryCallKit::inline_hasNegatives() {
1243   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1244     return false;
1245   }
1246 
1247   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1248   // no receiver since it is static method
1249   Node* ba         = argument(0);
1250   Node* offset     = argument(1);
1251   Node* len        = argument(2);
1252 
1253   ba = must_be_not_null(ba, true);
1254 
1255   // Range checks
1256   generate_string_range_check(ba, offset, len, false);
1257   if (stopped()) {
1258     return true;
1259   }
1260   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1261   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1262   set_result(_gvn.transform(result));
1263   return true;
1264 }
1265 
1266 bool LibraryCallKit::inline_preconditions_checkIndex() {
1267   Node* index = argument(0);
1268   Node* length = argument(1);
1269   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1270     return false;
1271   }
1272 
1273   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1274   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1275 
1276   {
1277     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1278     uncommon_trap(Deoptimization::Reason_intrinsic,
1279                   Deoptimization::Action_make_not_entrant);
1280   }
1281 
1282   if (stopped()) {
1283     return false;
1284   }
1285 
1286   Node* rc_cmp = _gvn.transform(new CmpUNode(index, length));
1287   BoolTest::mask btest = BoolTest::lt;
1288   Node* rc_bool = _gvn.transform(new BoolNode(rc_cmp, btest));
1289   RangeCheckNode* rc = new RangeCheckNode(control(), rc_bool, PROB_MAX, COUNT_UNKNOWN);
1290   _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
1291   if (!rc_bool-&gt;is_Con()) {
1292     record_for_igvn(rc);
1293   }
1294   set_control(_gvn.transform(new IfTrueNode(rc)));
1295   {
1296     PreserveJVMState pjvms(this);
1297     set_control(_gvn.transform(new IfFalseNode(rc)));
1298     uncommon_trap(Deoptimization::Reason_range_check,
1299                   Deoptimization::Action_make_not_entrant);
1300   }
1301 
1302   if (stopped()) {
1303     return false;
1304   }
1305 
1306   Node* result = new CastIINode(index, TypeInt::make(0, _gvn.type(length)-&gt;is_int()-&gt;_hi, Type::WidenMax));
1307   result-&gt;set_req(0, control());
1308   result = _gvn.transform(result);
1309   set_result(result);
1310   replace_in_map(index, result);
1311   clear_upper_avx();
1312   return true;
1313 }
1314 
1315 //------------------------------inline_string_indexOf------------------------
1316 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1317   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1318     return false;
1319   }
1320   Node* src = argument(0);
1321   Node* tgt = argument(1);
1322 
1323   // Make the merge point
1324   RegionNode* result_rgn = new RegionNode(4);
1325   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1326 
1327   src = must_be_not_null(src, true);
1328   tgt = must_be_not_null(tgt, true);
1329 
1330   // Get start addr and length of source string
1331   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1332   Node* src_count = load_array_length(src);
1333 
1334   // Get start addr and length of substring
1335   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1336   Node* tgt_count = load_array_length(tgt);
1337 
1338   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1339     // Divide src size by 2 if String is UTF16 encoded
1340     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1341   }
1342   if (ae == StrIntrinsicNode::UU) {
1343     // Divide substring size by 2 if String is UTF16 encoded
1344     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1345   }
1346 
1347   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1348   if (result != NULL) {
1349     result_phi-&gt;init_req(3, result);
1350     result_rgn-&gt;init_req(3, control());
1351   }
1352   set_control(_gvn.transform(result_rgn));
1353   record_for_igvn(result_rgn);
1354   set_result(_gvn.transform(result_phi));
1355 
1356   return true;
1357 }
1358 
1359 //-----------------------------inline_string_indexOf-----------------------
1360 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1361   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1362     return false;
1363   }
1364   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1365     return false;
1366   }
1367   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1368   Node* src         = argument(0); // byte[]
1369   Node* src_count   = argument(1); // char count
1370   Node* tgt         = argument(2); // byte[]
1371   Node* tgt_count   = argument(3); // char count
1372   Node* from_index  = argument(4); // char index
1373 
1374   src = must_be_not_null(src, true);
1375   tgt = must_be_not_null(tgt, true);
1376 
1377   // Multiply byte array index by 2 if String is UTF16 encoded
1378   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1379   src_count = _gvn.transform(new SubINode(src_count, from_index));
1380   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1381   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1382 
1383   // Range checks
1384   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1385   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1386   if (stopped()) {
1387     return true;
1388   }
1389 
1390   RegionNode* region = new RegionNode(5);
1391   Node* phi = new PhiNode(region, TypeInt::INT);
1392 
1393   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1394   if (result != NULL) {
1395     // The result is index relative to from_index if substring was found, -1 otherwise.
1396     // Generate code which will fold into cmove.
1397     Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1398     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1399 
1400     Node* if_lt = generate_slow_guard(bol, NULL);
1401     if (if_lt != NULL) {
1402       // result == -1
1403       phi-&gt;init_req(3, result);
1404       region-&gt;init_req(3, if_lt);
1405     }
1406     if (!stopped()) {
1407       result = _gvn.transform(new AddINode(result, from_index));
1408       phi-&gt;init_req(4, result);
1409       region-&gt;init_req(4, control());
1410     }
1411   }
1412 
1413   set_control(_gvn.transform(region));
1414   record_for_igvn(region);
1415   set_result(_gvn.transform(phi));
1416   clear_upper_avx();
1417 
1418   return true;
1419 }
1420 
1421 // Create StrIndexOfNode with fast path checks
1422 Node* LibraryCallKit::make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
1423                                         RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae) {
1424   // Check for substr count &gt; string count
1425   Node* cmp = _gvn.transform(new CmpINode(tgt_count, src_count));
1426   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::gt));
1427   Node* if_gt = generate_slow_guard(bol, NULL);
1428   if (if_gt != NULL) {
1429     phi-&gt;init_req(1, intcon(-1));
1430     region-&gt;init_req(1, if_gt);
1431   }
1432   if (!stopped()) {
1433     // Check for substr count == 0
1434     cmp = _gvn.transform(new CmpINode(tgt_count, intcon(0)));
1435     bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
1436     Node* if_zero = generate_slow_guard(bol, NULL);
1437     if (if_zero != NULL) {
1438       phi-&gt;init_req(2, intcon(0));
1439       region-&gt;init_req(2, if_zero);
1440     }
1441   }
1442   if (!stopped()) {
1443     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1444   }
1445   return NULL;
1446 }
1447 
1448 //-----------------------------inline_string_indexOfChar-----------------------
1449 bool LibraryCallKit::inline_string_indexOfChar() {
1450   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1451     return false;
1452   }
1453   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1454     return false;
1455   }
1456   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1457   Node* src         = argument(0); // byte[]
1458   Node* tgt         = argument(1); // tgt is int ch
1459   Node* from_index  = argument(2);
1460   Node* max         = argument(3);
1461 
1462   src = must_be_not_null(src, true);
1463 
1464   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1465   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1466   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1467 
1468   // Range checks
1469   generate_string_range_check(src, src_offset, src_count, true);
1470   if (stopped()) {
1471     return true;
1472   }
1473 
1474   RegionNode* region = new RegionNode(3);
1475   Node* phi = new PhiNode(region, TypeInt::INT);
1476 
1477   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1478   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1479   _gvn.transform(result);
1480 
1481   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1482   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1483 
1484   Node* if_lt = generate_slow_guard(bol, NULL);
1485   if (if_lt != NULL) {
1486     // result == -1
1487     phi-&gt;init_req(2, result);
1488     region-&gt;init_req(2, if_lt);
1489   }
1490   if (!stopped()) {
1491     result = _gvn.transform(new AddINode(result, from_index));
1492     phi-&gt;init_req(1, result);
1493     region-&gt;init_req(1, control());
1494   }
1495   set_control(_gvn.transform(region));
1496   record_for_igvn(region);
1497   set_result(_gvn.transform(phi));
1498 
1499   return true;
1500 }
1501 //---------------------------inline_string_copy---------------------
1502 // compressIt == true --&gt; generate a compressed copy operation (compress char[]/byte[] to byte[])
1503 //   int StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)
1504 //   int StringUTF16.compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1505 // compressIt == false --&gt; generate an inflated copy operation (inflate byte[] to char[]/byte[])
1506 //   void StringLatin1.inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)
1507 //   void StringLatin1.inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1508 bool LibraryCallKit::inline_string_copy(bool compress) {
1509   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1510     return false;
1511   }
1512   int nargs = 5;  // 2 oops, 3 ints
1513   assert(callee()-&gt;signature()-&gt;size() == nargs, &quot;string copy has 5 arguments&quot;);
1514 
1515   Node* src         = argument(0);
1516   Node* src_offset  = argument(1);
1517   Node* dst         = argument(2);
1518   Node* dst_offset  = argument(3);
1519   Node* length      = argument(4);
1520 
1521   // Check for allocation before we add nodes that would confuse
1522   // tightly_coupled_allocation()
1523   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1524 
1525   // Figure out the size and type of the elements we will be copying.
1526   const Type* src_type = src-&gt;Value(&amp;_gvn);
1527   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
1528   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1529   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1530   assert((compress &amp;&amp; dst_elem == T_BYTE &amp;&amp; (src_elem == T_BYTE || src_elem == T_CHAR)) ||
1531          (!compress &amp;&amp; src_elem == T_BYTE &amp;&amp; (dst_elem == T_BYTE || dst_elem == T_CHAR)),
1532          &quot;Unsupported array types for inline_string_copy&quot;);
1533 
1534   src = must_be_not_null(src, true);
1535   dst = must_be_not_null(dst, true);
1536 
1537   // Convert char[] offsets to byte[] offsets
1538   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1539   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1540   if (convert_src) {
1541     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1542   } else if (convert_dst) {
1543     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1544   }
1545 
1546   // Range checks
1547   generate_string_range_check(src, src_offset, length, convert_src);
1548   generate_string_range_check(dst, dst_offset, length, convert_dst);
1549   if (stopped()) {
1550     return true;
1551   }
1552 
1553   Node* src_start = array_element_address(src, src_offset, src_elem);
1554   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1555   // &#39;src_start&#39; points to src array + scaled offset
1556   // &#39;dst_start&#39; points to dst array + scaled offset
1557   Node* count = NULL;
1558   if (compress) {
1559     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1560   } else {
1561     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1562   }
1563 
1564   if (alloc != NULL) {
1565     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1566       // &quot;You break it, you buy it.&quot;
1567       InitializeNode* init = alloc-&gt;initialization();
1568       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1569       init-&gt;set_complete_with_arraycopy();
1570       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1571       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1572     }
1573     // Do not let stores that initialize this object be reordered with
1574     // a subsequent store that would make this object accessible by
1575     // other threads.
1576     // Record what AllocateNode this StoreStore protects so that
1577     // escape analysis can go from the MemBarStoreStoreNode to the
1578     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1579     // based on the escape status of the AllocateNode.
1580     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1581   }
1582   if (compress) {
1583     set_result(_gvn.transform(count));
1584   }
1585   clear_upper_avx();
1586 
1587   return true;
1588 }
1589 
1590 #ifdef _LP64
1591 #define XTOP ,top() /*additional argument*/
1592 #else  //_LP64
1593 #define XTOP        /*no additional argument*/
1594 #endif //_LP64
1595 
1596 //------------------------inline_string_toBytesU--------------------------
1597 // public static byte[] StringUTF16.toBytes(char[] value, int off, int len)
1598 bool LibraryCallKit::inline_string_toBytesU() {
1599   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1600     return false;
1601   }
1602   // Get the arguments.
1603   Node* value     = argument(0);
1604   Node* offset    = argument(1);
1605   Node* length    = argument(2);
1606 
1607   Node* newcopy = NULL;
1608 
1609   // Set the original stack and the reexecute bit for the interpreter to reexecute
1610   // the bytecode that invokes StringUTF16.toBytes() if deoptimization happens.
1611   { PreserveReexecuteState preexecs(this);
1612     jvms()-&gt;set_should_reexecute(true);
1613 
1614     // Check if a null path was taken unconditionally.
1615     value = null_check(value);
1616 
1617     RegionNode* bailout = new RegionNode(1);
1618     record_for_igvn(bailout);
1619 
1620     // Range checks
1621     generate_negative_guard(offset, bailout);
1622     generate_negative_guard(length, bailout);
1623     generate_limit_guard(offset, length, load_array_length(value), bailout);
1624     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1625     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1626 
1627     if (bailout-&gt;req() &gt; 1) {
1628       PreserveJVMState pjvms(this);
1629       set_control(_gvn.transform(bailout));
1630       uncommon_trap(Deoptimization::Reason_intrinsic,
1631                     Deoptimization::Action_maybe_recompile);
1632     }
1633     if (stopped()) {
1634       return true;
1635     }
1636 
1637     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1638     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1639     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1640     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1641 
1642     // Calculate starting addresses.
1643     Node* src_start = array_element_address(value, offset, T_CHAR);
1644     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1645 
1646     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1647     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1648     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1649 
1650     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1651     const char* copyfunc_name = &quot;arraycopy&quot;;
1652     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1653     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1654                       OptoRuntime::fast_arraycopy_Type(),
1655                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1656                       src_start, dst_start, ConvI2X(length) XTOP);
1657     // Do not let reads from the cloned object float above the arraycopy.
1658     if (alloc != NULL) {
1659       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1660         // &quot;You break it, you buy it.&quot;
1661         InitializeNode* init = alloc-&gt;initialization();
1662         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1663         init-&gt;set_complete_with_arraycopy();
1664         assert(newcopy-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1665         assert(newcopy-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1666       }
1667       // Do not let stores that initialize this object be reordered with
1668       // a subsequent store that would make this object accessible by
1669       // other threads.
1670       // Record what AllocateNode this StoreStore protects so that
1671       // escape analysis can go from the MemBarStoreStoreNode to the
1672       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1673       // based on the escape status of the AllocateNode.
1674       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1675     } else {
1676       insert_mem_bar(Op_MemBarCPUOrder);
1677     }
1678   } // original reexecute is set back here
1679 
1680   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1681   if (!stopped()) {
1682     set_result(newcopy);
1683   }
1684   clear_upper_avx();
1685 
1686   return true;
1687 }
1688 
1689 //------------------------inline_string_getCharsU--------------------------
1690 // public void StringUTF16.getChars(byte[] src, int srcBegin, int srcEnd, char dst[], int dstBegin)
1691 bool LibraryCallKit::inline_string_getCharsU() {
1692   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1693     return false;
1694   }
1695 
1696   // Get the arguments.
1697   Node* src       = argument(0);
1698   Node* src_begin = argument(1);
1699   Node* src_end   = argument(2); // exclusive offset (i &lt; src_end)
1700   Node* dst       = argument(3);
1701   Node* dst_begin = argument(4);
1702 
1703   // Check for allocation before we add nodes that would confuse
1704   // tightly_coupled_allocation()
1705   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1706 
1707   // Check if a null path was taken unconditionally.
1708   src = null_check(src);
1709   dst = null_check(dst);
1710   if (stopped()) {
1711     return true;
1712   }
1713 
1714   // Get length and convert char[] offset to byte[] offset
1715   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1716   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1717 
1718   // Range checks
1719   generate_string_range_check(src, src_begin, length, true);
1720   generate_string_range_check(dst, dst_begin, length, false);
1721   if (stopped()) {
1722     return true;
1723   }
1724 
1725   if (!stopped()) {
1726     // Calculate starting addresses.
1727     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1728     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1729 
1730     // Check if array addresses are aligned to HeapWordSize
1731     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1732     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1733     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1734                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1735 
1736     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1737     const char* copyfunc_name = &quot;arraycopy&quot;;
1738     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1739     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1740                       OptoRuntime::fast_arraycopy_Type(),
1741                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1742                       src_start, dst_start, ConvI2X(length) XTOP);
1743     // Do not let reads from the cloned object float above the arraycopy.
1744     if (alloc != NULL) {
1745       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1746         // &quot;You break it, you buy it.&quot;
1747         InitializeNode* init = alloc-&gt;initialization();
1748         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1749         init-&gt;set_complete_with_arraycopy();
1750         assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1751         assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1752       }
1753       // Do not let stores that initialize this object be reordered with
1754       // a subsequent store that would make this object accessible by
1755       // other threads.
1756       // Record what AllocateNode this StoreStore protects so that
1757       // escape analysis can go from the MemBarStoreStoreNode to the
1758       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1759       // based on the escape status of the AllocateNode.
1760       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1761     } else {
1762       insert_mem_bar(Op_MemBarCPUOrder);
1763     }
1764   }
1765 
1766   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1767   return true;
1768 }
1769 
1770 //----------------------inline_string_char_access----------------------------
1771 // Store/Load char to/from byte[] array.
1772 // static void StringUTF16.putChar(byte[] val, int index, int c)
1773 // static char StringUTF16.getChar(byte[] val, int index)
1774 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1775   Node* value  = argument(0);
1776   Node* index  = argument(1);
1777   Node* ch = is_store ? argument(2) : NULL;
1778 
1779   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1780   // correctly requires matched array shapes.
1781   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1782           &quot;sanity: byte[] and char[] bases agree&quot;);
1783   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1784           &quot;sanity: byte[] and char[] scales agree&quot;);
1785 
1786   // Bail when getChar over constants is requested: constant folding would
1787   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1788   // Java method would constant fold nicely instead.
1789   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1790     return false;
1791   }
1792 
1793   value = must_be_not_null(value, true);
1794 
1795   Node* adr = array_element_address(value, index, T_CHAR);
1796   if (adr-&gt;is_top()) {
1797     return false;
1798   }
1799   if (is_store) {
1800     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1801   } else {
1802     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1803     set_result(ch);
1804   }
1805   return true;
1806 }
1807 
1808 //--------------------------round_double_node--------------------------------
1809 // Round a double node if necessary.
1810 Node* LibraryCallKit::round_double_node(Node* n) {
1811   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt;= 1)
1812     n = _gvn.transform(new RoundDoubleNode(0, n));
1813   return n;
1814 }
1815 
1816 //------------------------------inline_math-----------------------------------
1817 // public static double Math.abs(double)
1818 // public static double Math.sqrt(double)
1819 // public static double Math.log(double)
1820 // public static double Math.log10(double)
1821 bool LibraryCallKit::inline_double_math(vmIntrinsics::ID id) {
1822   Node* arg = round_double_node(argument(0));
1823   Node* n = NULL;
1824   switch (id) {
1825   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1826   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
1827   case vmIntrinsics::_ceil:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_ceil); break;
1828   case vmIntrinsics::_floor:  n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_floor); break;
1829   case vmIntrinsics::_rint:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_rint); break;
1830   default:  fatal_unexpected_iid(id);  break;
1831   }
1832   set_result(_gvn.transform(n));
1833   return true;
1834 }
1835 
1836 //------------------------------inline_math-----------------------------------
1837 // public static float Math.abs(float)
1838 // public static int Math.abs(int)
1839 // public static long Math.abs(long)
1840 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {
1841   Node* arg = argument(0);
1842   Node* n = NULL;
1843   switch (id) {
1844   case vmIntrinsics::_fabs:   n = new AbsFNode(                arg);  break;
1845   case vmIntrinsics::_iabs:   n = new AbsINode(                arg);  break;
1846   case vmIntrinsics::_labs:   n = new AbsLNode(                arg);  break;
1847   default:  fatal_unexpected_iid(id);  break;
1848   }
1849   set_result(_gvn.transform(n));
1850   return true;
1851 }
1852 
1853 //------------------------------runtime_math-----------------------------
1854 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1855   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1856          &quot;must be (DD)D or (D)D type&quot;);
1857 
1858   // Inputs
1859   Node* a = round_double_node(argument(0));
1860   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1861 
1862   const TypePtr* no_memory_effects = NULL;
1863   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1864                                  no_memory_effects,
1865                                  a, top(), b, b ? top() : NULL);
1866   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
1867 #ifdef ASSERT
1868   Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));
1869   assert(value_top == top(), &quot;second value must be top&quot;);
1870 #endif
1871 
1872   set_result(value);
1873   return true;
1874 }
1875 
1876 //------------------------------inline_math_native-----------------------------
1877 bool LibraryCallKit::inline_math_native(vmIntrinsics::ID id) {
1878 #define FN_PTR(f) CAST_FROM_FN_PTR(address, f)
1879   switch (id) {
1880     // These intrinsics are not properly supported on all hardware
1881   case vmIntrinsics::_dsin:
1882     return StubRoutines::dsin() != NULL ?
1883       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1884       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1885   case vmIntrinsics::_dcos:
1886     return StubRoutines::dcos() != NULL ?
1887       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1888       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1889   case vmIntrinsics::_dtan:
1890     return StubRoutines::dtan() != NULL ?
1891       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1892       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1893   case vmIntrinsics::_dlog:
1894     return StubRoutines::dlog() != NULL ?
1895       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1896       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1897   case vmIntrinsics::_dlog10:
1898     return StubRoutines::dlog10() != NULL ?
1899       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1900       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1901 
1902     // These intrinsics are supported on all hardware
1903   case vmIntrinsics::_ceil:
1904   case vmIntrinsics::_floor:
1905   case vmIntrinsics::_rint:   return Matcher::match_rule_supported(Op_RoundDoubleMode) ? inline_double_math(id) : false;
1906   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_double_math(id) : false;
1907   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_double_math(id) : false;
1908   case vmIntrinsics::_fabs:   return Matcher::match_rule_supported(Op_AbsF)   ? inline_math(id) : false;
1909   case vmIntrinsics::_iabs:   return Matcher::match_rule_supported(Op_AbsI)   ? inline_math(id) : false;
1910   case vmIntrinsics::_labs:   return Matcher::match_rule_supported(Op_AbsL)   ? inline_math(id) : false;
1911 
1912   case vmIntrinsics::_dexp:
1913     return StubRoutines::dexp() != NULL ?
1914       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1915       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1916   case vmIntrinsics::_dpow: {
1917     Node* exp = round_double_node(argument(2));
1918     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1919     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1920       // Special case: pow(x, 2.0) =&gt; x * x
1921       Node* base = round_double_node(argument(0));
1922       set_result(_gvn.transform(new MulDNode(base, base)));
1923       return true;
1924     }
1925     return StubRoutines::dpow() != NULL ?
1926       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1927       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1928   }
1929 #undef FN_PTR
1930 
1931    // These intrinsics are not yet correctly implemented
1932   case vmIntrinsics::_datan2:
1933     return false;
1934 
1935   default:
1936     fatal_unexpected_iid(id);
1937     return false;
1938   }
1939 }
1940 
1941 static bool is_simple_name(Node* n) {
1942   return (n-&gt;req() == 1         // constant
1943           || (n-&gt;is_Type() &amp;&amp; n-&gt;as_Type()-&gt;type()-&gt;singleton())
1944           || n-&gt;is_Proj()       // parameter or return value
1945           || n-&gt;is_Phi()        // local of some sort
1946           );
1947 }
1948 
1949 //----------------------------inline_notify-----------------------------------*
1950 bool LibraryCallKit::inline_notify(vmIntrinsics::ID id) {
1951   const TypeFunc* ftype = OptoRuntime::monitor_notify_Type();
1952   address func;
1953   if (id == vmIntrinsics::_notify) {
1954     func = OptoRuntime::monitor_notify_Java();
1955   } else {
1956     func = OptoRuntime::monitor_notifyAll_Java();
1957   }
1958   Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));
1959   make_slow_call_ex(call, env()-&gt;Throwable_klass(), false);
1960   return true;
1961 }
1962 
1963 
1964 //----------------------------inline_min_max-----------------------------------
1965 bool LibraryCallKit::inline_min_max(vmIntrinsics::ID id) {
1966   set_result(generate_min_max(id, argument(0), argument(1)));
1967   return true;
1968 }
1969 
1970 void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {
1971   Node* bol = _gvn.transform( new BoolNode(test, BoolTest::overflow) );
1972   IfNode* check = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);
1973   Node* fast_path = _gvn.transform( new IfFalseNode(check));
1974   Node* slow_path = _gvn.transform( new IfTrueNode(check) );
1975 
1976   {
1977     PreserveJVMState pjvms(this);
1978     PreserveReexecuteState preexecs(this);
1979     jvms()-&gt;set_should_reexecute(true);
1980 
1981     set_control(slow_path);
1982     set_i_o(i_o());
1983 
1984     uncommon_trap(Deoptimization::Reason_intrinsic,
1985                   Deoptimization::Action_none);
1986   }
1987 
1988   set_control(fast_path);
1989   set_result(math);
1990 }
1991 
1992 template &lt;typename OverflowOp&gt;
1993 bool LibraryCallKit::inline_math_overflow(Node* arg1, Node* arg2) {
1994   typedef typename OverflowOp::MathOp MathOp;
1995 
1996   MathOp* mathOp = new MathOp(arg1, arg2);
1997   Node* operation = _gvn.transform( mathOp );
1998   Node* ofcheck = _gvn.transform( new OverflowOp(arg1, arg2) );
1999   inline_math_mathExact(operation, ofcheck);
2000   return true;
2001 }
2002 
2003 bool LibraryCallKit::inline_math_addExactI(bool is_increment) {
2004   return inline_math_overflow&lt;OverflowAddINode&gt;(argument(0), is_increment ? intcon(1) : argument(1));
2005 }
2006 
2007 bool LibraryCallKit::inline_math_addExactL(bool is_increment) {
2008   return inline_math_overflow&lt;OverflowAddLNode&gt;(argument(0), is_increment ? longcon(1) : argument(2));
2009 }
2010 
2011 bool LibraryCallKit::inline_math_subtractExactI(bool is_decrement) {
2012   return inline_math_overflow&lt;OverflowSubINode&gt;(argument(0), is_decrement ? intcon(1) : argument(1));
2013 }
2014 
2015 bool LibraryCallKit::inline_math_subtractExactL(bool is_decrement) {
2016   return inline_math_overflow&lt;OverflowSubLNode&gt;(argument(0), is_decrement ? longcon(1) : argument(2));
2017 }
2018 
2019 bool LibraryCallKit::inline_math_negateExactI() {
2020   return inline_math_overflow&lt;OverflowSubINode&gt;(intcon(0), argument(0));
2021 }
2022 
2023 bool LibraryCallKit::inline_math_negateExactL() {
2024   return inline_math_overflow&lt;OverflowSubLNode&gt;(longcon(0), argument(0));
2025 }
2026 
2027 bool LibraryCallKit::inline_math_multiplyExactI() {
2028   return inline_math_overflow&lt;OverflowMulINode&gt;(argument(0), argument(1));
2029 }
2030 
2031 bool LibraryCallKit::inline_math_multiplyExactL() {
2032   return inline_math_overflow&lt;OverflowMulLNode&gt;(argument(0), argument(2));
2033 }
2034 
2035 bool LibraryCallKit::inline_math_multiplyHigh() {
2036   set_result(_gvn.transform(new MulHiLNode(argument(0), argument(2))));
2037   return true;
2038 }
2039 
2040 Node*
2041 LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {
2042   // These are the candidate return value:
2043   Node* xvalue = x0;
2044   Node* yvalue = y0;
2045 
2046   if (xvalue == yvalue) {
2047     return xvalue;
2048   }
2049 
2050   bool want_max = (id == vmIntrinsics::_max);
2051 
2052   const TypeInt* txvalue = _gvn.type(xvalue)-&gt;isa_int();
2053   const TypeInt* tyvalue = _gvn.type(yvalue)-&gt;isa_int();
2054   if (txvalue == NULL || tyvalue == NULL)  return top();
2055   // This is not really necessary, but it is consistent with a
2056   // hypothetical MaxINode::Value method:
2057   int widen = MAX2(txvalue-&gt;_widen, tyvalue-&gt;_widen);
2058 
2059   // %%% This folding logic should (ideally) be in a different place.
2060   // Some should be inside IfNode, and there to be a more reliable
2061   // transformation of ?: style patterns into cmoves.  We also want
2062   // more powerful optimizations around cmove and min/max.
2063 
2064   // Try to find a dominating comparison of these guys.
2065   // It can simplify the index computation for Arrays.copyOf
2066   // and similar uses of System.arraycopy.
2067   // First, compute the normalized version of CmpI(x, y).
2068   int   cmp_op = Op_CmpI;
2069   Node* xkey = xvalue;
2070   Node* ykey = yvalue;
2071   Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));
2072   if (ideal_cmpxy-&gt;is_Cmp()) {
2073     // E.g., if we have CmpI(length - offset, count),
2074     // it might idealize to CmpI(length, count + offset)
2075     cmp_op = ideal_cmpxy-&gt;Opcode();
2076     xkey = ideal_cmpxy-&gt;in(1);
2077     ykey = ideal_cmpxy-&gt;in(2);
2078   }
2079 
2080   // Start by locating any relevant comparisons.
2081   Node* start_from = (xkey-&gt;outcnt() &lt; ykey-&gt;outcnt()) ? xkey : ykey;
2082   Node* cmpxy = NULL;
2083   Node* cmpyx = NULL;
2084   for (DUIterator_Fast kmax, k = start_from-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2085     Node* cmp = start_from-&gt;fast_out(k);
2086     if (cmp-&gt;outcnt() &gt; 0 &amp;&amp;            // must have prior uses
2087         cmp-&gt;in(0) == NULL &amp;&amp;           // must be context-independent
2088         cmp-&gt;Opcode() == cmp_op) {      // right kind of compare
2089       if (cmp-&gt;in(1) == xkey &amp;&amp; cmp-&gt;in(2) == ykey)  cmpxy = cmp;
2090       if (cmp-&gt;in(1) == ykey &amp;&amp; cmp-&gt;in(2) == xkey)  cmpyx = cmp;
2091     }
2092   }
2093 
2094   const int NCMPS = 2;
2095   Node* cmps[NCMPS] = { cmpxy, cmpyx };
2096   int cmpn;
2097   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2098     if (cmps[cmpn] != NULL)  break;     // find a result
2099   }
2100   if (cmpn &lt; NCMPS) {
2101     // Look for a dominating test that tells us the min and max.
2102     int depth = 0;                // Limit search depth for speed
2103     Node* dom = control();
2104     for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {
2105       if (++depth &gt;= 100)  break;
2106       Node* ifproj = dom;
2107       if (!ifproj-&gt;is_Proj())  continue;
2108       Node* iff = ifproj-&gt;in(0);
2109       if (!iff-&gt;is_If())  continue;
2110       Node* bol = iff-&gt;in(1);
2111       if (!bol-&gt;is_Bool())  continue;
2112       Node* cmp = bol-&gt;in(1);
2113       if (cmp == NULL)  continue;
2114       for (cmpn = 0; cmpn &lt; NCMPS; cmpn++)
2115         if (cmps[cmpn] == cmp)  break;
2116       if (cmpn == NCMPS)  continue;
2117       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2118       if (ifproj-&gt;is_IfFalse())  btest = BoolTest(btest).negate();
2119       if (cmp-&gt;in(1) == ykey)    btest = BoolTest(btest).commute();
2120       // At this point, we know that &#39;x btest y&#39; is true.
2121       switch (btest) {
2122       case BoolTest::eq:
2123         // They are proven equal, so we can collapse the min/max.
2124         // Either value is the answer.  Choose the simpler.
2125         if (is_simple_name(yvalue) &amp;&amp; !is_simple_name(xvalue))
2126           return yvalue;
2127         return xvalue;
2128       case BoolTest::lt:          // x &lt; y
2129       case BoolTest::le:          // x &lt;= y
2130         return (want_max ? yvalue : xvalue);
2131       case BoolTest::gt:          // x &gt; y
2132       case BoolTest::ge:          // x &gt;= y
2133         return (want_max ? xvalue : yvalue);
2134       default:
2135         break;
2136       }
2137     }
2138   }
2139 
2140   // We failed to find a dominating test.
2141   // Let&#39;s pick a test that might GVN with prior tests.
2142   Node*          best_bol   = NULL;
2143   BoolTest::mask best_btest = BoolTest::illegal;
2144   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2145     Node* cmp = cmps[cmpn];
2146     if (cmp == NULL)  continue;
2147     for (DUIterator_Fast jmax, j = cmp-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2148       Node* bol = cmp-&gt;fast_out(j);
2149       if (!bol-&gt;is_Bool())  continue;
2150       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2151       if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;
2152       if (cmp-&gt;in(1) == ykey)   btest = BoolTest(btest).commute();
2153       if (bol-&gt;outcnt() &gt; (best_bol == NULL ? 0 : best_bol-&gt;outcnt())) {
2154         best_bol   = bol-&gt;as_Bool();
2155         best_btest = btest;
2156       }
2157     }
2158   }
2159 
2160   Node* answer_if_true  = NULL;
2161   Node* answer_if_false = NULL;
2162   switch (best_btest) {
2163   default:
2164     if (cmpxy == NULL)
2165       cmpxy = ideal_cmpxy;
2166     best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));
2167     // and fall through:
2168   case BoolTest::lt:          // x &lt; y
2169   case BoolTest::le:          // x &lt;= y
2170     answer_if_true  = (want_max ? yvalue : xvalue);
2171     answer_if_false = (want_max ? xvalue : yvalue);
2172     break;
2173   case BoolTest::gt:          // x &gt; y
2174   case BoolTest::ge:          // x &gt;= y
2175     answer_if_true  = (want_max ? xvalue : yvalue);
2176     answer_if_false = (want_max ? yvalue : xvalue);
2177     break;
2178   }
2179 
2180   jint hi, lo;
2181   if (want_max) {
2182     // We can sharpen the minimum.
2183     hi = MAX2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2184     lo = MAX2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2185   } else {
2186     // We can sharpen the maximum.
2187     hi = MIN2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2188     lo = MIN2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2189   }
2190 
2191   // Use a flow-free graph structure, to avoid creating excess control edges
2192   // which could hinder other optimizations.
2193   // Since Math.min/max is often used with arraycopy, we want
2194   // tightly_coupled_allocation to be able to see beyond min/max expressions.
2195   Node* cmov = CMoveNode::make(NULL, best_bol,
2196                                answer_if_false, answer_if_true,
2197                                TypeInt::make(lo, hi, widen));
2198 
2199   return _gvn.transform(cmov);
2200 
2201   /*
2202   // This is not as desirable as it may seem, since Min and Max
2203   // nodes do not have a full set of optimizations.
2204   // And they would interfere, anyway, with &#39;if&#39; optimizations
2205   // and with CMoveI canonical forms.
2206   switch (id) {
2207   case vmIntrinsics::_min:
2208     result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;
2209   case vmIntrinsics::_max:
2210     result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;
2211   default:
2212     ShouldNotReachHere();
2213   }
2214   */
2215 }
2216 
2217 inline int
2218 LibraryCallKit::classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type) {
2219   const TypePtr* base_type = TypePtr::NULL_PTR;
2220   if (base != NULL)  base_type = _gvn.type(base)-&gt;isa_ptr();
2221   if (base_type == NULL) {
2222     // Unknown type.
2223     return Type::AnyPtr;
2224   } else if (base_type == TypePtr::NULL_PTR) {
2225     // Since this is a NULL+long form, we have to switch to a rawptr.
2226     base   = _gvn.transform(new CastX2PNode(offset));
2227     offset = MakeConX(0);
2228     return Type::RawPtr;
2229   } else if (base_type-&gt;base() == Type::RawPtr) {
2230     return Type::RawPtr;
2231   } else if (base_type-&gt;isa_oopptr()) {
2232     // Base is never null =&gt; always a heap address.
2233     if (!TypePtr::NULL_PTR-&gt;higher_equal(base_type)) {
2234       return Type::OopPtr;
2235     }
2236     // Offset is small =&gt; always a heap address.
2237     const TypeX* offset_type = _gvn.type(offset)-&gt;isa_intptr_t();
2238     if (offset_type != NULL &amp;&amp;
2239         base_type-&gt;offset() == 0 &amp;&amp;     // (should always be?)
2240         offset_type-&gt;_lo &gt;= 0 &amp;&amp;
2241         !MacroAssembler::needs_explicit_null_check(offset_type-&gt;_hi)) {
2242       return Type::OopPtr;
2243     } else if (type == T_OBJECT) {
2244       // off heap access to an oop doesn&#39;t make any sense. Has to be on
2245       // heap.
2246       return Type::OopPtr;
2247     }
2248     // Otherwise, it might either be oop+off or NULL+addr.
2249     return Type::AnyPtr;
2250   } else {
2251     // No information:
2252     return Type::AnyPtr;
2253   }
2254 }
2255 
2256 inline Node* LibraryCallKit::make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {
2257   Node* uncasted_base = base;
2258   int kind = classify_unsafe_addr(uncasted_base, offset, type);
2259   if (kind == Type::RawPtr) {
2260     return basic_plus_adr(top(), uncasted_base, offset);
2261   } else if (kind == Type::AnyPtr) {
2262     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2263     if (can_cast) {
2264       if (!_gvn.type(base)-&gt;speculative_maybe_null() &amp;&amp;
2265           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2266         // According to profiling, this access is always on
2267         // heap. Casting the base to not null and thus avoiding membars
2268         // around the access should allow better optimizations
2269         Node* null_ctl = top();
2270         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2271         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2272         return basic_plus_adr(base, offset);
2273       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2274                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2275         // According to profiling, this access is always off
2276         // heap.
2277         base = null_assert(base);
2278         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2279         offset = MakeConX(0);
2280         return basic_plus_adr(top(), raw_base, offset);
2281       }
2282     }
2283     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2284     // to raw memory access.
2285     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2286     return basic_plus_adr(top(), raw, offset);
2287   } else {
2288     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2289     // We know it&#39;s an on heap access so base can&#39;t be null
2290     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2291       base = must_be_not_null(base, true);
2292     }
2293     return basic_plus_adr(base, offset);
2294   }
2295 }
2296 
2297 //--------------------------inline_number_methods-----------------------------
2298 // inline int     Integer.numberOfLeadingZeros(int)
2299 // inline int        Long.numberOfLeadingZeros(long)
2300 //
2301 // inline int     Integer.numberOfTrailingZeros(int)
2302 // inline int        Long.numberOfTrailingZeros(long)
2303 //
2304 // inline int     Integer.bitCount(int)
2305 // inline int        Long.bitCount(long)
2306 //
2307 // inline char  Character.reverseBytes(char)
2308 // inline short     Short.reverseBytes(short)
2309 // inline int     Integer.reverseBytes(int)
2310 // inline long       Long.reverseBytes(long)
2311 bool LibraryCallKit::inline_number_methods(vmIntrinsics::ID id) {
2312   Node* arg = argument(0);
2313   Node* n = NULL;
2314   switch (id) {
2315   case vmIntrinsics::_numberOfLeadingZeros_i:   n = new CountLeadingZerosINode( arg);  break;
2316   case vmIntrinsics::_numberOfLeadingZeros_l:   n = new CountLeadingZerosLNode( arg);  break;
2317   case vmIntrinsics::_numberOfTrailingZeros_i:  n = new CountTrailingZerosINode(arg);  break;
2318   case vmIntrinsics::_numberOfTrailingZeros_l:  n = new CountTrailingZerosLNode(arg);  break;
2319   case vmIntrinsics::_bitCount_i:               n = new PopCountINode(          arg);  break;
2320   case vmIntrinsics::_bitCount_l:               n = new PopCountLNode(          arg);  break;
2321   case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;
2322   case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;
2323   case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;
2324   case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;
2325   default:  fatal_unexpected_iid(id);  break;
2326   }
2327   set_result(_gvn.transform(n));
2328   return true;
2329 }
2330 
2331 //----------------------------inline_unsafe_access----------------------------
2332 
2333 const TypeOopPtr* LibraryCallKit::sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type) {
2334   // Attempt to infer a sharper value type from the offset and base type.
2335   ciKlass* sharpened_klass = NULL;
2336 
2337   // See if it is an instance field, with an object type.
2338   if (alias_type-&gt;field() != NULL) {
2339     if (alias_type-&gt;field()-&gt;type()-&gt;is_klass()) {
2340       sharpened_klass = alias_type-&gt;field()-&gt;type()-&gt;as_klass();
2341     }
2342   }
2343 
2344   // See if it is a narrow oop array.
2345   if (adr_type-&gt;isa_aryptr()) {
2346     if (adr_type-&gt;offset() &gt;= objArrayOopDesc::base_offset_in_bytes()) {
2347       const TypeOopPtr *elem_type = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_oopptr();
2348       if (elem_type != NULL) {
2349         sharpened_klass = elem_type-&gt;klass();
2350       }
2351     }
2352   }
2353 
2354   // The sharpened class might be unloaded if there is no class loader
2355   // contraint in place.
2356   if (sharpened_klass != NULL &amp;&amp; sharpened_klass-&gt;is_loaded()) {
2357     const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);
2358 
2359 #ifndef PRODUCT
2360     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
2361       tty-&gt;print(&quot;  from base type:  &quot;);  adr_type-&gt;dump(); tty-&gt;cr();
2362       tty-&gt;print(&quot;  sharpened value: &quot;);  tjp-&gt;dump();      tty-&gt;cr();
2363     }
2364 #endif
2365     // Sharpen the value type.
2366     return tjp;
2367   }
2368   return NULL;
2369 }
2370 
2371 DecoratorSet LibraryCallKit::mo_decorator_for_access_kind(AccessKind kind) {
2372   switch (kind) {
2373       case Relaxed:
2374         return MO_UNORDERED;
2375       case Opaque:
2376         return MO_RELAXED;
2377       case Acquire:
2378         return MO_ACQUIRE;
2379       case Release:
2380         return MO_RELEASE;
2381       case Volatile:
2382         return MO_SEQ_CST;
2383       default:
2384         ShouldNotReachHere();
2385         return 0;
2386   }
2387 }
2388 
2389 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2390   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2391   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2392   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2393   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2394   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2395 
2396   if (is_reference_type(type)) {
2397     decorators |= ON_UNKNOWN_OOP_REF;
2398   }
2399 
2400   if (unaligned) {
2401     decorators |= C2_UNALIGNED;
2402   }
2403 
2404 #ifndef PRODUCT
2405   {
2406     ResourceMark rm;
2407     // Check the signatures.
2408     ciSignature* sig = callee()-&gt;signature();
2409 #ifdef ASSERT
2410     if (!is_store) {
2411       // Object getReference(Object base, int/long offset), etc.
2412       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2413       assert(rtype == type, &quot;getter must return the expected value&quot;);
2414       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);
2415       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2416       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
2417     } else {
2418       // void putReference(Object base, int/long offset, Object x), etc.
2419       assert(sig-&gt;return_type()-&gt;basic_type() == T_VOID, &quot;putter must not return a value&quot;);
2420       assert(sig-&gt;count() == 3, &quot;oop putter has 3 arguments&quot;);
2421       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;putter base is object&quot;);
2422       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;putter offset is correct&quot;);
2423       BasicType vtype = sig-&gt;type_at(sig-&gt;count()-1)-&gt;basic_type();
2424       assert(vtype == type, &quot;putter must accept the expected value&quot;);
2425     }
2426 #endif // ASSERT
2427  }
2428 #endif //PRODUCT
2429 
2430   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2431 
2432   Node* receiver = argument(0);  // type: oop
2433 
2434   // Build address expression.
2435   Node* adr;
2436   Node* heap_base_oop = top();
2437   Node* offset = top();
2438   Node* val;
2439 
2440   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2441   Node* base = argument(1);  // type: oop
2442   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2443   offset = argument(2);  // type: long
2444   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2445   // to be plain byte offsets, which are also the same as those accepted
2446   // by oopDesc::field_addr.
2447   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2448          &quot;fieldOffset must be byte-scaled&quot;);
2449   // 32-bit machines ignore the high half!
2450   offset = ConvL2X(offset);
2451   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2452 
2453   if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {
2454     if (type != T_OBJECT) {
2455       decorators |= IN_NATIVE; // off-heap primitive access
2456     } else {
2457       return false; // off-heap oop accesses are not supported
2458     }
2459   } else {
2460     heap_base_oop = base; // on-heap or mixed access
2461   }
2462 
2463   // Can base be NULL? Otherwise, always on-heap access.
2464   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base));
2465 
2466   if (!can_access_non_heap) {
2467     decorators |= IN_HEAP;
2468   }
2469 
2470   val = is_store ? argument(4) : NULL;
2471 
2472   const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();
2473   if (adr_type == TypePtr::NULL_PTR) {
2474     return false; // off-heap access with zero address
2475   }
2476 
2477   // Try to categorize the address.
2478   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2479   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2480 
2481   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2482       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2483     return false; // not supported
2484   }
2485 
2486   bool mismatched = false;
2487   BasicType bt = alias_type-&gt;basic_type();
2488   if (bt != T_ILLEGAL) {
2489     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2490     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2491       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2492       // Use address type to get the element type.
2493       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2494     }
2495     if (bt == T_ARRAY || bt == T_NARROWOOP) {
2496       // accessing an array field with getReference is not a mismatch
2497       bt = T_OBJECT;
2498     }
2499     if ((bt == T_OBJECT) != (type == T_OBJECT)) {
2500       // Don&#39;t intrinsify mismatched object accesses
2501       return false;
2502     }
2503     mismatched = (bt != type);
2504   } else if (alias_type-&gt;adr_type()-&gt;isa_oopptr()) {
2505     mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
2506   }
2507 
2508   assert(!mismatched || alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;off-heap access can&#39;t be mismatched&quot;);
2509 
2510   if (mismatched) {
2511     decorators |= C2_MISMATCHED;
2512   }
2513 
2514   // First guess at the value type.
2515   const Type *value_type = Type::get_const_basic_type(type);
2516 
2517   // Figure out the memory ordering.
2518   decorators |= mo_decorator_for_access_kind(kind);
2519 
2520   if (!is_store &amp;&amp; type == T_OBJECT) {
2521     const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2522     if (tjp != NULL) {
2523       value_type = tjp;
2524     }
2525   }
2526 
2527   receiver = null_check(receiver);
2528   if (stopped()) {
2529     return true;
2530   }
2531   // Heap pointers get a null-check from the interpreter,
2532   // as a courtesy.  However, this is not guaranteed by Unsafe,
2533   // and it is not possible to fully distinguish unintended nulls
2534   // from intended ones in this API.
2535 
2536   if (!is_store) {
2537     Node* p = NULL;
2538     // Try to constant fold a load from a constant field
2539     ciField* field = alias_type-&gt;field();
2540     if (heap_base_oop != top() &amp;&amp; field != NULL &amp;&amp; field-&gt;is_constant() &amp;&amp; !mismatched) {
2541       // final or stable field
2542       p = make_constant_from_field(field, heap_base_oop);
2543     }
2544 
2545     if (p == NULL) { // Could not constant fold the load
2546       p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);
2547       // Normalize the value returned by getBoolean in the following cases
2548       if (type == T_BOOLEAN &amp;&amp;
2549           (mismatched ||
2550            heap_base_oop == top() ||                  // - heap_base_oop is NULL or
2551            (can_access_non_heap &amp;&amp; field == NULL))    // - heap_base_oop is potentially NULL
2552                                                       //   and the unsafe access is made to large offset
2553                                                       //   (i.e., larger than the maximum offset necessary for any
2554                                                       //   field access)
2555             ) {
2556           IdealKit ideal = IdealKit(this);
2557 #define __ ideal.
2558           IdealVariable normalized_result(ideal);
2559           __ declarations_done();
2560           __ set(normalized_result, p);
2561           __ if_then(p, BoolTest::ne, ideal.ConI(0));
2562           __ set(normalized_result, ideal.ConI(1));
2563           ideal.end_if();
2564           final_sync(ideal);
2565           p = __ value(normalized_result);
2566 #undef __
2567       }
2568     }
2569     if (type == T_ADDRESS) {
2570       p = gvn().transform(new CastP2XNode(NULL, p));
2571       p = ConvX2UL(p);
2572     }
2573     // The load node has the control of the preceding MemBarCPUOrder.  All
2574     // following nodes will have the control of the MemBarCPUOrder inserted at
2575     // the end of this method.  So, pushing the load onto the stack at a later
2576     // point is fine.
2577     set_result(p);
2578   } else {
2579     if (bt == T_ADDRESS) {
2580       // Repackage the long as a pointer.
2581       val = ConvL2X(val);
2582       val = gvn().transform(new CastX2PNode(val));
2583     }
2584     access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);
2585   }
2586 
2587   return true;
2588 }
2589 
2590 //----------------------------inline_unsafe_load_store----------------------------
2591 // This method serves a couple of different customers (depending on LoadStoreKind):
2592 //
2593 // LS_cmp_swap:
2594 //
2595 //   boolean compareAndSetReference(Object o, long offset, Object expected, Object x);
2596 //   boolean compareAndSetInt(   Object o, long offset, int    expected, int    x);
2597 //   boolean compareAndSetLong(  Object o, long offset, long   expected, long   x);
2598 //
2599 // LS_cmp_swap_weak:
2600 //
2601 //   boolean weakCompareAndSetReference(       Object o, long offset, Object expected, Object x);
2602 //   boolean weakCompareAndSetReferencePlain(  Object o, long offset, Object expected, Object x);
2603 //   boolean weakCompareAndSetReferenceAcquire(Object o, long offset, Object expected, Object x);
2604 //   boolean weakCompareAndSetReferenceRelease(Object o, long offset, Object expected, Object x);
2605 //
2606 //   boolean weakCompareAndSetInt(          Object o, long offset, int    expected, int    x);
2607 //   boolean weakCompareAndSetIntPlain(     Object o, long offset, int    expected, int    x);
2608 //   boolean weakCompareAndSetIntAcquire(   Object o, long offset, int    expected, int    x);
2609 //   boolean weakCompareAndSetIntRelease(   Object o, long offset, int    expected, int    x);
2610 //
2611 //   boolean weakCompareAndSetLong(         Object o, long offset, long   expected, long   x);
2612 //   boolean weakCompareAndSetLongPlain(    Object o, long offset, long   expected, long   x);
2613 //   boolean weakCompareAndSetLongAcquire(  Object o, long offset, long   expected, long   x);
2614 //   boolean weakCompareAndSetLongRelease(  Object o, long offset, long   expected, long   x);
2615 //
2616 // LS_cmp_exchange:
2617 //
2618 //   Object compareAndExchangeReferenceVolatile(Object o, long offset, Object expected, Object x);
2619 //   Object compareAndExchangeReferenceAcquire( Object o, long offset, Object expected, Object x);
2620 //   Object compareAndExchangeReferenceRelease( Object o, long offset, Object expected, Object x);
2621 //
2622 //   Object compareAndExchangeIntVolatile(   Object o, long offset, Object expected, Object x);
2623 //   Object compareAndExchangeIntAcquire(    Object o, long offset, Object expected, Object x);
2624 //   Object compareAndExchangeIntRelease(    Object o, long offset, Object expected, Object x);
2625 //
2626 //   Object compareAndExchangeLongVolatile(  Object o, long offset, Object expected, Object x);
2627 //   Object compareAndExchangeLongAcquire(   Object o, long offset, Object expected, Object x);
2628 //   Object compareAndExchangeLongRelease(   Object o, long offset, Object expected, Object x);
2629 //
2630 // LS_get_add:
2631 //
2632 //   int  getAndAddInt( Object o, long offset, int  delta)
2633 //   long getAndAddLong(Object o, long offset, long delta)
2634 //
2635 // LS_get_set:
2636 //
2637 //   int    getAndSet(Object o, long offset, int    newValue)
2638 //   long   getAndSet(Object o, long offset, long   newValue)
2639 //   Object getAndSet(Object o, long offset, Object newValue)
2640 //
2641 bool LibraryCallKit::inline_unsafe_load_store(const BasicType type, const LoadStoreKind kind, const AccessKind access_kind) {
2642   // This basic scheme here is the same as inline_unsafe_access, but
2643   // differs in enough details that combining them would make the code
2644   // overly confusing.  (This is a true fact! I originally combined
2645   // them, but even I was confused by it!) As much code/comments as
2646   // possible are retained from inline_unsafe_access though to make
2647   // the correspondences clearer. - dl
2648 
2649   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2650 
2651   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2652   decorators |= mo_decorator_for_access_kind(access_kind);
2653 
2654 #ifndef PRODUCT
2655   BasicType rtype;
2656   {
2657     ResourceMark rm;
2658     // Check the signatures.
2659     ciSignature* sig = callee()-&gt;signature();
2660     rtype = sig-&gt;return_type()-&gt;basic_type();
2661     switch(kind) {
2662       case LS_get_add:
2663       case LS_get_set: {
2664       // Check the signatures.
2665 #ifdef ASSERT
2666       assert(rtype == type, &quot;get and set must return the expected type&quot;);
2667       assert(sig-&gt;count() == 3, &quot;get and set has 3 arguments&quot;);
2668       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;get and set base is object&quot;);
2669       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;get and set offset is long&quot;);
2670       assert(sig-&gt;type_at(2)-&gt;basic_type() == type, &quot;get and set must take expected type as new value/delta&quot;);
2671       assert(access_kind == Volatile, &quot;mo is not passed to intrinsic nodes in current implementation&quot;);
2672 #endif // ASSERT
2673         break;
2674       }
2675       case LS_cmp_swap:
2676       case LS_cmp_swap_weak: {
2677       // Check the signatures.
2678 #ifdef ASSERT
2679       assert(rtype == T_BOOLEAN, &quot;CAS must return boolean&quot;);
2680       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2681       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2682       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2683 #endif // ASSERT
2684         break;
2685       }
2686       case LS_cmp_exchange: {
2687       // Check the signatures.
2688 #ifdef ASSERT
2689       assert(rtype == type, &quot;CAS must return the expected type&quot;);
2690       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2691       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2692       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2693 #endif // ASSERT
2694         break;
2695       }
2696       default:
2697         ShouldNotReachHere();
2698     }
2699   }
2700 #endif //PRODUCT
2701 
2702   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2703 
2704   // Get arguments:
2705   Node* receiver = NULL;
2706   Node* base     = NULL;
2707   Node* offset   = NULL;
2708   Node* oldval   = NULL;
2709   Node* newval   = NULL;
2710   switch(kind) {
2711     case LS_cmp_swap:
2712     case LS_cmp_swap_weak:
2713     case LS_cmp_exchange: {
2714       const bool two_slot_type = type2size[type] == 2;
2715       receiver = argument(0);  // type: oop
2716       base     = argument(1);  // type: oop
2717       offset   = argument(2);  // type: long
2718       oldval   = argument(4);  // type: oop, int, or long
2719       newval   = argument(two_slot_type ? 6 : 5);  // type: oop, int, or long
2720       break;
2721     }
2722     case LS_get_add:
2723     case LS_get_set: {
2724       receiver = argument(0);  // type: oop
2725       base     = argument(1);  // type: oop
2726       offset   = argument(2);  // type: long
2727       oldval   = NULL;
2728       newval   = argument(4);  // type: oop, int, or long
2729       break;
2730     }
2731     default:
2732       ShouldNotReachHere();
2733   }
2734 
2735   // Build field offset expression.
2736   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2737   // to be plain byte offsets, which are also the same as those accepted
2738   // by oopDesc::field_addr.
2739   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2740   // 32-bit machines ignore the high half of long offsets
2741   offset = ConvL2X(offset);
2742   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2743   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2744 
2745   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2746   BasicType bt = alias_type-&gt;basic_type();
2747   if (bt != T_ILLEGAL &amp;&amp;
2748       (is_reference_type(bt) != (type == T_OBJECT))) {
2749     // Don&#39;t intrinsify mismatched object accesses.
2750     return false;
2751   }
2752 
2753   // For CAS, unlike inline_unsafe_access, there seems no point in
2754   // trying to refine types. Just use the coarse types here.
2755   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2756   const Type *value_type = Type::get_const_basic_type(type);
2757 
2758   switch (kind) {
2759     case LS_get_set:
2760     case LS_cmp_exchange: {
2761       if (type == T_OBJECT) {
2762         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2763         if (tjp != NULL) {
2764           value_type = tjp;
2765         }
2766       }
2767       break;
2768     }
2769     case LS_cmp_swap:
2770     case LS_cmp_swap_weak:
2771     case LS_get_add:
2772       break;
2773     default:
2774       ShouldNotReachHere();
2775   }
2776 
2777   // Null check receiver.
2778   receiver = null_check(receiver);
2779   if (stopped()) {
2780     return true;
2781   }
2782 
2783   int alias_idx = C-&gt;get_alias_index(adr_type);
2784 
2785   if (is_reference_type(type)) {
2786     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2787 
2788     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2789     // could be delayed during Parse (for example, in adjust_map_after_if()).
2790     // Execute transformation here to avoid barrier generation in such case.
2791     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2792       newval = _gvn.makecon(TypePtr::NULL_PTR);
2793 
2794     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2795       // Refine the value to a null constant, when it is known to be null
2796       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2797     }
2798   }
2799 
2800   Node* result = NULL;
2801   switch (kind) {
2802     case LS_cmp_exchange: {
2803       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
2804                                             oldval, newval, value_type, type, decorators);
2805       break;
2806     }
2807     case LS_cmp_swap_weak:
2808       decorators |= C2_WEAK_CMPXCHG;
2809     case LS_cmp_swap: {
2810       result = access_atomic_cmpxchg_bool_at(base, adr, adr_type, alias_idx,
2811                                              oldval, newval, value_type, type, decorators);
2812       break;
2813     }
2814     case LS_get_set: {
2815       result = access_atomic_xchg_at(base, adr, adr_type, alias_idx,
2816                                      newval, value_type, type, decorators);
2817       break;
2818     }
2819     case LS_get_add: {
2820       result = access_atomic_add_at(base, adr, adr_type, alias_idx,
2821                                     newval, value_type, type, decorators);
2822       break;
2823     }
2824     default:
2825       ShouldNotReachHere();
2826   }
2827 
2828   assert(type2size[result-&gt;bottom_type()-&gt;basic_type()] == type2size[rtype], &quot;result type should match&quot;);
2829   set_result(result);
2830   return true;
2831 }
2832 
2833 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
2834   // Regardless of form, don&#39;t allow previous ld/st to move down,
2835   // then issue acquire, release, or volatile mem_bar.
2836   insert_mem_bar(Op_MemBarCPUOrder);
2837   switch(id) {
2838     case vmIntrinsics::_loadFence:
2839       insert_mem_bar(Op_LoadFence);
2840       return true;
2841     case vmIntrinsics::_storeFence:
2842       insert_mem_bar(Op_StoreFence);
2843       return true;
2844     case vmIntrinsics::_fullFence:
2845       insert_mem_bar(Op_MemBarVolatile);
2846       return true;
2847     default:
2848       fatal_unexpected_iid(id);
2849       return false;
2850   }
2851 }
2852 
2853 bool LibraryCallKit::inline_onspinwait() {
2854   insert_mem_bar(Op_OnSpinWait);
2855   return true;
2856 }
2857 
2858 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2859   if (!kls-&gt;is_Con()) {
2860     return true;
2861   }
2862   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2863   if (klsptr == NULL) {
2864     return true;
2865   }
2866   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2867   // don&#39;t need a guard for a klass that is already initialized
2868   return !ik-&gt;is_initialized();
2869 }
2870 
2871 //----------------------------inline_unsafe_writeback0-------------------------
2872 // public native void Unsafe.writeback0(long address)
2873 bool LibraryCallKit::inline_unsafe_writeback0() {
2874   if (!Matcher::has_match_rule(Op_CacheWB)) {
2875     return false;
2876   }
2877 #ifndef PRODUCT
2878   assert(Matcher::has_match_rule(Op_CacheWBPreSync), &quot;found match rule for CacheWB but not CacheWBPreSync&quot;);
2879   assert(Matcher::has_match_rule(Op_CacheWBPostSync), &quot;found match rule for CacheWB but not CacheWBPostSync&quot;);
2880   ciSignature* sig = callee()-&gt;signature();
2881   assert(sig-&gt;type_at(0)-&gt;basic_type() == T_LONG, &quot;Unsafe_writeback0 address is long!&quot;);
2882 #endif
2883   null_check_receiver();  // null-check, then ignore
2884   Node *addr = argument(1);
2885   addr = new CastX2PNode(addr);
2886   addr = _gvn.transform(addr);
2887   Node *flush = new CacheWBNode(control(), memory(TypeRawPtr::BOTTOM), addr);
2888   flush = _gvn.transform(flush);
2889   set_memory(flush, TypeRawPtr::BOTTOM);
2890   return true;
2891 }
2892 
2893 //----------------------------inline_unsafe_writeback0-------------------------
2894 // public native void Unsafe.writeback0(long address)
2895 bool LibraryCallKit::inline_unsafe_writebackSync0(bool is_pre) {
2896   if (is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPreSync)) {
2897     return false;
2898   }
2899   if (!is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPostSync)) {
2900     return false;
2901   }
2902 #ifndef PRODUCT
2903   assert(Matcher::has_match_rule(Op_CacheWB),
2904          (is_pre ? &quot;found match rule for CacheWBPreSync but not CacheWB&quot;
2905                 : &quot;found match rule for CacheWBPostSync but not CacheWB&quot;));
2906 
2907 #endif
2908   null_check_receiver();  // null-check, then ignore
2909   Node *sync;
2910   if (is_pre) {
2911     sync = new CacheWBPreSyncNode(control(), memory(TypeRawPtr::BOTTOM));
2912   } else {
2913     sync = new CacheWBPostSyncNode(control(), memory(TypeRawPtr::BOTTOM));
2914   }
2915   sync = _gvn.transform(sync);
2916   set_memory(sync, TypeRawPtr::BOTTOM);
2917   return true;
2918 }
2919 
2920 //----------------------------inline_unsafe_allocate---------------------------
2921 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
2922 bool LibraryCallKit::inline_unsafe_allocate() {
2923   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2924 
2925   null_check_receiver();  // null-check, then ignore
2926   Node* cls = null_check(argument(1));
2927   if (stopped())  return true;
2928 
2929   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2930   kls = null_check(kls);
2931   if (stopped())  return true;  // argument was like int.class
2932 
2933   Node* test = NULL;
2934   if (LibraryCallKit::klass_needs_init_guard(kls)) {
2935     // Note:  The argument might still be an illegal value like
2936     // Serializable.class or Object[].class.   The runtime will handle it.
2937     // But we must make an explicit check for initialization.
2938     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
2939     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
2940     // can generate code to load it as unsigned byte.
2941     Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);
2942     Node* bits = intcon(InstanceKlass::fully_initialized);
2943     test = _gvn.transform(new SubINode(inst, bits));
2944     // The &#39;test&#39; is non-zero if we need to take a slow path.
2945   }
2946 
2947   Node* obj = new_instance(kls, test);
2948   set_result(obj);
2949   return true;
2950 }
2951 
2952 //------------------------inline_native_time_funcs--------------
2953 // inline code for System.currentTimeMillis() and System.nanoTime()
2954 // these have the same type and signature
2955 bool LibraryCallKit::inline_native_time_funcs(address funcAddr, const char* funcName) {
2956   const TypeFunc* tf = OptoRuntime::void_long_Type();
2957   const TypePtr* no_memory_effects = NULL;
2958   Node* time = make_runtime_call(RC_LEAF, tf, funcAddr, funcName, no_memory_effects);
2959   Node* value = _gvn.transform(new ProjNode(time, TypeFunc::Parms+0));
2960 #ifdef ASSERT
2961   Node* value_top = _gvn.transform(new ProjNode(time, TypeFunc::Parms+1));
2962   assert(value_top == top(), &quot;second value must be top&quot;);
2963 #endif
2964   set_result(value);
2965   return true;
2966 }
2967 
2968 #ifdef JFR_HAVE_INTRINSICS
2969 
2970 /*
2971 * oop -&gt; myklass
2972 * myklass-&gt;trace_id |= USED
2973 * return myklass-&gt;trace_id &amp; ~0x3
2974 */
2975 bool LibraryCallKit::inline_native_classID() {
2976   Node* cls = null_check(argument(0), T_OBJECT);
2977   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2978   kls = null_check(kls, T_OBJECT);
2979 
2980   ByteSize offset = KLASS_TRACE_ID_OFFSET;
2981   Node* insp = basic_plus_adr(kls, in_bytes(offset));
2982   Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);
2983 
2984   Node* clsused = longcon(0x01l); // set the class bit
2985   Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));
2986   const TypePtr *adr_type = _gvn.type(insp)-&gt;isa_ptr();
2987   store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);
2988 
2989 #ifdef TRACE_ID_META_BITS
2990   Node* mbits = longcon(~TRACE_ID_META_BITS);
2991   tvalue = _gvn.transform(new AndLNode(tvalue, mbits));
2992 #endif
2993 #ifdef TRACE_ID_SHIFT
2994   Node* cbits = intcon(TRACE_ID_SHIFT);
2995   tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));
2996 #endif
2997 
2998   set_result(tvalue);
2999   return true;
3000 
3001 }
3002 
3003 /*
3004 
3005 bool LibraryCallKit::inline_native_getEventWriter() {
3006   Node* tls_ptr = _gvn.transform(new ThreadLocalNode());
3007 
3008   Node* jobj_ptr = basic_plus_adr(top(), tls_ptr,
3009                                   in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR));
3010 
3011   Node* jobj = make_load(control(), jobj_ptr, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);
3012 
3013   Node* jobj_cmp_null = _gvn.transform( new CmpPNode(jobj, null()) );
3014   Node* test_jobj_eq_null  = _gvn.transform( new BoolNode(jobj_cmp_null, BoolTest::eq) );
3015 
3016   IfNode* iff_jobj_null =
3017     create_and_map_if(control(), test_jobj_eq_null, PROB_MIN, COUNT_UNKNOWN);
3018 
3019   enum { _normal_path = 1,
3020          _null_path = 2,
3021          PATH_LIMIT };
3022 
3023   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);
3024   PhiNode*    result_val = new PhiNode(result_rgn, TypeInstPtr::BOTTOM);
3025 
3026   Node* jobj_is_null = _gvn.transform(new IfTrueNode(iff_jobj_null));
3027   result_rgn-&gt;init_req(_null_path, jobj_is_null);
3028   result_val-&gt;init_req(_null_path, null());
3029 
3030   Node* jobj_is_not_null = _gvn.transform(new IfFalseNode(iff_jobj_null));
3031   set_control(jobj_is_not_null);
3032   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
3033                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
3034   result_rgn-&gt;init_req(_normal_path, control());
3035   result_val-&gt;init_req(_normal_path, res);
3036 
3037   set_result(result_rgn, result_val);
3038 
3039   return true;
3040 }
3041 
3042 */
3043 
3044 #endif // JFR_HAVE_INTRINSICS
3045 
3046 //------------------------inline_native_currentThread------------------
3047 bool LibraryCallKit::inline_native_currentThread() {
3048   Node* junk = NULL;
3049   set_result(generate_current_thread(junk));
3050   return true;
3051 }
3052 
3053 //------------------------inline_native_scopedCache------------------
3054 bool LibraryCallKit::inline_native_scopedCache() {
3055   ciKlass *objects_klass = ciObjArrayKlass::make(env()-&gt;Object_klass());
3056   const TypeOopPtr *etype = TypeOopPtr::make_from_klass(env()-&gt;Object_klass());
3057 
3058   // It might be nice to eliminate the bounds check on the cache array
3059   // by replacing TypeInt::POS here with
3060   // TypeInt::make(ScopedCacheSize*2), but this causes a performance
3061   // regression in some test cases.
3062   const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3063   bool xk = etype-&gt;klass_is_exact();
3064 
3065   // Because we create the scoped cache lazily we have to make the
3066   // type of the result BotPTR.
3067   const Type* objects_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, objects_klass, xk, 0);
3068   Node* thread = _gvn.transform(new ThreadLocalNode());
3069   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::scopedCache_offset()));
3070   Node* threadObj = make_load(NULL, p, objects_type, T_OBJECT, MemNode::unordered);
3071   set_result(threadObj);
3072 
3073   return true;
3074 }
3075 
3076 //------------------------inline_native_setScopedCache------------------
3077 bool LibraryCallKit::inline_native_setScopedCache() {
3078   Node* arr = argument(0);
3079   Node* thread = _gvn.transform(new ThreadLocalNode());
3080   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::scopedCache_offset()));
3081   const TypePtr *adr_type = _gvn.type(p)-&gt;isa_ptr();
3082   store_to_memory(control(), p, arr, T_OBJECT, adr_type, MemNode::unordered);
3083 
3084   return true;
3085 }
3086 
3087 //---------------------------load_mirror_from_klass----------------------------
3088 // Given a klass oop, load its java mirror (a java.lang.Class oop).
3089 Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
3090   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
3091   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3092   // mirror = ((OopHandle)mirror)-&gt;resolve();
3093   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);
3094 }
3095 
3096 //-----------------------load_klass_from_mirror_common-------------------------
3097 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3098 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3099 // and branch to the given path on the region.
3100 // If never_see_null, take an uncommon trap on null, so we can optimistically
3101 // compile for the non-null case.
3102 // If the region is NULL, force never_see_null = true.
3103 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3104                                                     bool never_see_null,
3105                                                     RegionNode* region,
3106                                                     int null_path,
3107                                                     int offset) {
3108   if (region == NULL)  never_see_null = true;
3109   Node* p = basic_plus_adr(mirror, offset);
3110   const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3111   Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));
3112   Node* null_ctl = top();
3113   kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3114   if (region != NULL) {
3115     // Set region-&gt;in(null_path) if the mirror is a primitive (e.g, int.class).
3116     region-&gt;init_req(null_path, null_ctl);
3117   } else {
3118     assert(null_ctl == top(), &quot;no loose ends&quot;);
3119   }
3120   return kls;
3121 }
3122 
3123 //--------------------(inline_native_Class_query helpers)---------------------
3124 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3125 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3126 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3127   // Branch around if the given klass has the given modifier bit set.
3128   // Like generate_guard, adds a new path onto the region.
3129   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3130   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3131   Node* mask = intcon(modifier_mask);
3132   Node* bits = intcon(modifier_bits);
3133   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3134   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3135   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3136   return generate_fair_guard(bol, region);
3137 }
3138 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3139   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3140 }
3141 
3142 //-------------------------inline_native_Class_query-------------------
3143 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3144   const Type* return_type = TypeInt::BOOL;
3145   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3146   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3147   bool expect_prim = false;     // most of these guys expect to work on refs
3148 
3149   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3150 
3151   Node* mirror = argument(0);
3152   Node* obj    = top();
3153 
3154   switch (id) {
3155   case vmIntrinsics::_isInstance:
3156     // nothing is an instance of a primitive type
3157     prim_return_value = intcon(0);
3158     obj = argument(1);
3159     break;
3160   case vmIntrinsics::_getModifiers:
3161     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3162     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3163     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3164     break;
3165   case vmIntrinsics::_isInterface:
3166     prim_return_value = intcon(0);
3167     break;
3168   case vmIntrinsics::_isArray:
3169     prim_return_value = intcon(0);
3170     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3171     break;
3172   case vmIntrinsics::_isPrimitive:
3173     prim_return_value = intcon(1);
3174     expect_prim = true;  // obviously
3175     break;
3176   case vmIntrinsics::_getSuperclass:
3177     prim_return_value = null();
3178     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3179     break;
3180   case vmIntrinsics::_getClassAccessFlags:
3181     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3182     return_type = TypeInt::INT;  // not bool!  6297094
3183     break;
3184   default:
3185     fatal_unexpected_iid(id);
3186     break;
3187   }
3188 
3189   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3190   if (mirror_con == NULL)  return false;  // cannot happen?
3191 
3192 #ifndef PRODUCT
3193   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3194     ciType* k = mirror_con-&gt;java_mirror_type();
3195     if (k) {
3196       tty-&gt;print(&quot;Inlining %s on constant Class &quot;, vmIntrinsics::name_at(intrinsic_id()));
3197       k-&gt;print_name();
3198       tty-&gt;cr();
3199     }
3200   }
3201 #endif
3202 
3203   // Null-check the mirror, and the mirror&#39;s klass ptr (in case it is a primitive).
3204   RegionNode* region = new RegionNode(PATH_LIMIT);
3205   record_for_igvn(region);
3206   PhiNode* phi = new PhiNode(region, return_type);
3207 
3208   // The mirror will never be null of Reflection.getClassAccessFlags, however
3209   // it may be null for Class.isInstance or Class.getModifiers. Throw a NPE
3210   // if it is. See bug 4774291.
3211 
3212   // For Reflection.getClassAccessFlags(), the null check occurs in
3213   // the wrong place; see inline_unsafe_access(), above, for a similar
3214   // situation.
3215   mirror = null_check(mirror);
3216   // If mirror or obj is dead, only null-path is taken.
3217   if (stopped())  return true;
3218 
3219   if (expect_prim)  never_see_null = false;  // expect nulls (meaning prims)
3220 
3221   // Now load the mirror&#39;s klass metaobject, and null-check it.
3222   // Side-effects region with the control path if the klass is null.
3223   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3224   // If kls is null, we have a primitive mirror.
3225   phi-&gt;init_req(_prim_path, prim_return_value);
3226   if (stopped()) { set_result(region, phi); return true; }
3227   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3228 
3229   Node* p;  // handy temp
3230   Node* null_ctl;
3231 
3232   // Now that we have the non-null klass, we can perform the real query.
3233   // For constant classes, the query will constant-fold in LoadNode::Value.
3234   Node* query_value = top();
3235   switch (id) {
3236   case vmIntrinsics::_isInstance:
3237     // nothing is an instance of a primitive type
3238     query_value = gen_instanceof(obj, kls, safe_for_replace);
3239     break;
3240 
3241   case vmIntrinsics::_getModifiers:
3242     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3243     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3244     break;
3245 
3246   case vmIntrinsics::_isInterface:
3247     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3248     if (generate_interface_guard(kls, region) != NULL)
3249       // A guard was added.  If the guard is taken, it was an interface.
3250       phi-&gt;add_req(intcon(1));
3251     // If we fall through, it&#39;s a plain class.
3252     query_value = intcon(0);
3253     break;
3254 
3255   case vmIntrinsics::_isArray:
3256     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3257     if (generate_array_guard(kls, region) != NULL)
3258       // A guard was added.  If the guard is taken, it was an array.
3259       phi-&gt;add_req(intcon(1));
3260     // If we fall through, it&#39;s a plain class.
3261     query_value = intcon(0);
3262     break;
3263 
3264   case vmIntrinsics::_isPrimitive:
3265     query_value = intcon(0); // &quot;normal&quot; path produces false
3266     break;
3267 
3268   case vmIntrinsics::_getSuperclass:
3269     // The rules here are somewhat unfortunate, but we can still do better
3270     // with random logic than with a JNI call.
3271     // Interfaces store null or Object as _super, but must report null.
3272     // Arrays store an intermediate super as _super, but must report Object.
3273     // Other types can report the actual _super.
3274     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3275     if (generate_interface_guard(kls, region) != NULL)
3276       // A guard was added.  If the guard is taken, it was an interface.
3277       phi-&gt;add_req(null());
3278     if (generate_array_guard(kls, region) != NULL)
3279       // A guard was added.  If the guard is taken, it was an array.
3280       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3281     // If we fall through, it&#39;s a plain class.  Get its _super.
3282     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3283     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3284     null_ctl = top();
3285     kls = null_check_oop(kls, &amp;null_ctl);
3286     if (null_ctl != top()) {
3287       // If the guard is taken, Object.superClass is null (both klass and mirror).
3288       region-&gt;add_req(null_ctl);
3289       phi   -&gt;add_req(null());
3290     }
3291     if (!stopped()) {
3292       query_value = load_mirror_from_klass(kls);
3293     }
3294     break;
3295 
3296   case vmIntrinsics::_getClassAccessFlags:
3297     p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3298     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3299     break;
3300 
3301   default:
3302     fatal_unexpected_iid(id);
3303     break;
3304   }
3305 
3306   // Fall-through is the normal case of a query to a real class.
3307   phi-&gt;init_req(1, query_value);
3308   region-&gt;init_req(1, control());
3309 
3310   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3311   set_result(region, phi);
3312   return true;
3313 }
3314 
3315 //-------------------------inline_Class_cast-------------------
3316 bool LibraryCallKit::inline_Class_cast() {
3317   Node* mirror = argument(0); // Class
3318   Node* obj    = argument(1);
3319   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3320   if (mirror_con == NULL) {
3321     return false;  // dead path (mirror-&gt;is_top()).
3322   }
3323   if (obj == NULL || obj-&gt;is_top()) {
3324     return false;  // dead path
3325   }
3326   const TypeOopPtr* tp = _gvn.type(obj)-&gt;isa_oopptr();
3327 
3328   // First, see if Class.cast() can be folded statically.
3329   // java_mirror_type() returns non-null for compile-time Class constants.
3330   ciType* tm = mirror_con-&gt;java_mirror_type();
3331   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp;
3332       tp != NULL &amp;&amp; tp-&gt;klass() != NULL) {
3333     if (!tp-&gt;klass()-&gt;is_loaded()) {
3334       // Don&#39;t use intrinsic when class is not loaded.
3335       return false;
3336     } else {
3337       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), tp-&gt;klass());
3338       if (static_res == Compile::SSC_always_true) {
3339         // isInstance() is true - fold the code.
3340         set_result(obj);
3341         return true;
3342       } else if (static_res == Compile::SSC_always_false) {
3343         // Don&#39;t use intrinsic, have to throw ClassCastException.
3344         // If the reference is null, the non-intrinsic bytecode will
3345         // be optimized appropriately.
3346         return false;
3347       }
3348     }
3349   }
3350 
3351   // Bailout intrinsic and do normal inlining if exception path is frequent.
3352   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
3353     return false;
3354   }
3355 
3356   // Generate dynamic checks.
3357   // Class.cast() is java implementation of _checkcast bytecode.
3358   // Do checkcast (Parse::do_checkcast()) optimizations here.
3359 
3360   mirror = null_check(mirror);
3361   // If mirror is dead, only null-path is taken.
3362   if (stopped()) {
3363     return true;
3364   }
3365 
3366   // Not-subtype or the mirror&#39;s klass ptr is NULL (in case it is a primitive).
3367   enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };
3368   RegionNode* region = new RegionNode(PATH_LIMIT);
3369   record_for_igvn(region);
3370 
3371   // Now load the mirror&#39;s klass metaobject, and null-check it.
3372   // If kls is null, we have a primitive mirror and
3373   // nothing is an instance of a primitive type.
3374   Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
3375 
3376   Node* res = top();
3377   if (!stopped()) {
3378     Node* bad_type_ctrl = top();
3379     // Do checkcast optimizations.
3380     res = gen_checkcast(obj, kls, &amp;bad_type_ctrl);
3381     region-&gt;init_req(_bad_type_path, bad_type_ctrl);
3382   }
3383   if (region-&gt;in(_prim_path) != top() ||
3384       region-&gt;in(_bad_type_path) != top()) {
3385     // Let Interpreter throw ClassCastException.
3386     PreserveJVMState pjvms(this);
3387     set_control(_gvn.transform(region));
3388     uncommon_trap(Deoptimization::Reason_intrinsic,
3389                   Deoptimization::Action_maybe_recompile);
3390   }
3391   if (!stopped()) {
3392     set_result(res);
3393   }
3394   return true;
3395 }
3396 
3397 
3398 //--------------------------inline_native_subtype_check------------------------
3399 // This intrinsic takes the JNI calls out of the heart of
3400 // UnsafeFieldAccessorImpl.set, which improves Field.set, readObject, etc.
3401 bool LibraryCallKit::inline_native_subtype_check() {
3402   // Pull both arguments off the stack.
3403   Node* args[2];                // two java.lang.Class mirrors: superc, subc
3404   args[0] = argument(0);
3405   args[1] = argument(1);
3406   Node* klasses[2];             // corresponding Klasses: superk, subk
3407   klasses[0] = klasses[1] = top();
3408 
3409   enum {
3410     // A full decision tree on {superc is prim, subc is prim}:
3411     _prim_0_path = 1,           // {P,N} =&gt; false
3412                                 // {P,P} &amp; superc!=subc =&gt; false
3413     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3414     _prim_1_path,               // {N,P} =&gt; false
3415     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3416     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3417     PATH_LIMIT
3418   };
3419 
3420   RegionNode* region = new RegionNode(PATH_LIMIT);
3421   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3422   record_for_igvn(region);
3423 
3424   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3425   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3426   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();
3427 
3428   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3429   int which_arg;
3430   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3431     Node* arg = args[which_arg];
3432     arg = null_check(arg);
3433     if (stopped())  break;
3434     args[which_arg] = arg;
3435 
3436     Node* p = basic_plus_adr(arg, class_klass_offset);
3437     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3438     klasses[which_arg] = _gvn.transform(kls);
3439   }
3440 
3441   // Having loaded both klasses, test each for null.
3442   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3443   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3444     Node* kls = klasses[which_arg];
3445     Node* null_ctl = top();
3446     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3447     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);
3448     region-&gt;init_req(prim_path, null_ctl);
3449     if (stopped())  break;
3450     klasses[which_arg] = kls;
3451   }
3452 
3453   if (!stopped()) {
3454     // now we have two reference types, in klasses[0..1]
3455     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3456     Node* superk = klasses[0];  // the receiver
3457     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3458     // now we have a successful reference subtype check
3459     region-&gt;set_req(_ref_subtype_path, control());
3460   }
3461 
3462   // If both operands are primitive (both klasses null), then
3463   // we must return true when they are identical primitives.
3464   // It is convenient to test this after the first null klass check.
3465   set_control(region-&gt;in(_prim_0_path)); // go back to first null check
3466   if (!stopped()) {
3467     // Since superc is primitive, make a guard for the superc==subc case.
3468     Node* cmp_eq = _gvn.transform(new CmpPNode(args[0], args[1]));
3469     Node* bol_eq = _gvn.transform(new BoolNode(cmp_eq, BoolTest::eq));
3470     generate_guard(bol_eq, region, PROB_FAIR);
3471     if (region-&gt;req() == PATH_LIMIT+1) {
3472       // A guard was added.  If the added guard is taken, superc==subc.
3473       region-&gt;swap_edges(PATH_LIMIT, _prim_same_path);
3474       region-&gt;del_req(PATH_LIMIT);
3475     }
3476     region-&gt;set_req(_prim_0_path, control()); // Not equal after all.
3477   }
3478 
3479   // these are the only paths that produce &#39;true&#39;:
3480   phi-&gt;set_req(_prim_same_path,   intcon(1));
3481   phi-&gt;set_req(_ref_subtype_path, intcon(1));
3482 
3483   // pull together the cases:
3484   assert(region-&gt;req() == PATH_LIMIT, &quot;sane region&quot;);
3485   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3486     Node* ctl = region-&gt;in(i);
3487     if (ctl == NULL || ctl == top()) {
3488       region-&gt;set_req(i, top());
3489       phi   -&gt;set_req(i, top());
3490     } else if (phi-&gt;in(i) == NULL) {
3491       phi-&gt;set_req(i, intcon(0)); // all other paths produce &#39;false&#39;
3492     }
3493   }
3494 
3495   set_control(_gvn.transform(region));
3496   set_result(_gvn.transform(phi));
3497   return true;
3498 }
3499 
3500 //---------------------generate_array_guard_common------------------------
3501 Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,
3502                                                   bool obj_array, bool not_array) {
3503 
3504   if (stopped()) {
3505     return NULL;
3506   }
3507 
3508   // If obj_array/non_array==false/false:
3509   // Branch around if the given klass is in fact an array (either obj or prim).
3510   // If obj_array/non_array==false/true:
3511   // Branch around if the given klass is not an array klass of any kind.
3512   // If obj_array/non_array==true/true:
3513   // Branch around if the kls is not an oop array (kls is int[], String, etc.)
3514   // If obj_array/non_array==true/false:
3515   // Branch around if the kls is an oop array (Object[] or subtype)
3516   //
3517   // Like generate_guard, adds a new path onto the region.
3518   jint  layout_con = 0;
3519   Node* layout_val = get_layout_helper(kls, layout_con);
3520   if (layout_val == NULL) {
3521     bool query = (obj_array
3522                   ? Klass::layout_helper_is_objArray(layout_con)
3523                   : Klass::layout_helper_is_array(layout_con));
3524     if (query == not_array) {
3525       return NULL;                       // never a branch
3526     } else {                             // always a branch
3527       Node* always_branch = control();
3528       if (region != NULL)
3529         region-&gt;add_req(always_branch);
3530       set_control(top());
3531       return always_branch;
3532     }
3533   }
3534   // Now test the correct condition.
3535   jint  nval = (obj_array
3536                 ? (jint)(Klass::_lh_array_tag_type_value
3537                    &lt;&lt;    Klass::_lh_array_tag_shift)
3538                 : Klass::_lh_neutral_value);
3539   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
3540   BoolTest::mask btest = BoolTest::lt;  // correct for testing is_[obj]array
3541   // invert the test if we are looking for a non-array
3542   if (not_array)  btest = BoolTest(btest).negate();
3543   Node* bol = _gvn.transform(new BoolNode(cmp, btest));
3544   return generate_fair_guard(bol, region);
3545 }
3546 
3547 
3548 //-----------------------inline_native_newArray--------------------------
3549 // private static native Object java.lang.reflect.newArray(Class&lt;?&gt; componentType, int length);
3550 // private        native Object Unsafe.allocateUninitializedArray0(Class&lt;?&gt; cls, int size);
3551 bool LibraryCallKit::inline_unsafe_newArray(bool uninitialized) {
3552   Node* mirror;
3553   Node* count_val;
3554   if (uninitialized) {
3555     mirror    = argument(1);
3556     count_val = argument(2);
3557   } else {
3558     mirror    = argument(0);
3559     count_val = argument(1);
3560   }
3561 
3562   mirror = null_check(mirror);
3563   // If mirror or obj is dead, only null-path is taken.
3564   if (stopped())  return true;
3565 
3566   enum { _normal_path = 1, _slow_path = 2, PATH_LIMIT };
3567   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3568   PhiNode*    result_val = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
3569   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3570   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3571 
3572   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3573   Node* klass_node = load_array_klass_from_mirror(mirror, never_see_null,
3574                                                   result_reg, _slow_path);
3575   Node* normal_ctl   = control();
3576   Node* no_array_ctl = result_reg-&gt;in(_slow_path);
3577 
3578   // Generate code for the slow case.  We make a call to newArray().
3579   set_control(no_array_ctl);
3580   if (!stopped()) {
3581     // Either the input type is void.class, or else the
3582     // array klass has not yet been cached.  Either the
3583     // ensuing call will throw an exception, or else it
3584     // will cache the array klass for next time.
3585     PreserveJVMState pjvms(this);
3586     CallJavaNode* slow_call = generate_method_call_static(vmIntrinsics::_newArray);
3587     Node* slow_result = set_results_for_java_call(slow_call);
3588     // this-&gt;control() comes from set_results_for_java_call
3589     result_reg-&gt;set_req(_slow_path, control());
3590     result_val-&gt;set_req(_slow_path, slow_result);
3591     result_io -&gt;set_req(_slow_path, i_o());
3592     result_mem-&gt;set_req(_slow_path, reset_memory());
3593   }
3594 
3595   set_control(normal_ctl);
3596   if (!stopped()) {
3597     // Normal case:  The array type has been cached in the java.lang.Class.
3598     // The following call works fine even if the array type is polymorphic.
3599     // It could be a dynamic mix of int[], boolean[], Object[], etc.
3600     Node* obj = new_array(klass_node, count_val, 0);  // no arguments to push
3601     result_reg-&gt;init_req(_normal_path, control());
3602     result_val-&gt;init_req(_normal_path, obj);
3603     result_io -&gt;init_req(_normal_path, i_o());
3604     result_mem-&gt;init_req(_normal_path, reset_memory());
3605 
3606     if (uninitialized) {
3607       // Mark the allocation so that zeroing is skipped
3608       AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &amp;_gvn);
3609       alloc-&gt;maybe_set_complete(&amp;_gvn);
3610     }
3611   }
3612 
3613   // Return the combined state.
3614   set_i_o(        _gvn.transform(result_io)  );
3615   set_all_memory( _gvn.transform(result_mem));
3616 
3617   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3618   set_result(result_reg, result_val);
3619   return true;
3620 }
3621 
3622 //----------------------inline_native_getLength--------------------------
3623 // public static native int java.lang.reflect.Array.getLength(Object array);
3624 bool LibraryCallKit::inline_native_getLength() {
3625   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3626 
3627   Node* array = null_check(argument(0));
3628   // If array is dead, only null-path is taken.
3629   if (stopped())  return true;
3630 
3631   // Deoptimize if it is a non-array.
3632   Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);
3633 
3634   if (non_array != NULL) {
3635     PreserveJVMState pjvms(this);
3636     set_control(non_array);
3637     uncommon_trap(Deoptimization::Reason_intrinsic,
3638                   Deoptimization::Action_maybe_recompile);
3639   }
3640 
3641   // If control is dead, only non-array-path is taken.
3642   if (stopped())  return true;
3643 
3644   // The works fine even if the array type is polymorphic.
3645   // It could be a dynamic mix of int[], boolean[], Object[], etc.
3646   Node* result = load_array_length(array);
3647 
3648   C-&gt;set_has_split_ifs(true);  // Has chance for split-if optimization
3649   set_result(result);
3650   return true;
3651 }
3652 
3653 //------------------------inline_array_copyOf----------------------------
3654 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOf(     U[] original, int newLength,         Class&lt;? extends T[]&gt; newType);
3655 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOfRange(U[] original, int from,      int to, Class&lt;? extends T[]&gt; newType);
3656 bool LibraryCallKit::inline_array_copyOf(bool is_copyOfRange) {
3657   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3658 
3659   // Get the arguments.
3660   Node* original          = argument(0);
3661   Node* start             = is_copyOfRange? argument(1): intcon(0);
3662   Node* end               = is_copyOfRange? argument(2): argument(1);
3663   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
3664 
3665   Node* newcopy = NULL;
3666 
3667   // Set the original stack and the reexecute bit for the interpreter to reexecute
3668   // the bytecode that invokes Arrays.copyOf if deoptimization happens.
3669   { PreserveReexecuteState preexecs(this);
3670     jvms()-&gt;set_should_reexecute(true);
3671 
3672     array_type_mirror = null_check(array_type_mirror);
3673     original          = null_check(original);
3674 
3675     // Check if a null path was taken unconditionally.
3676     if (stopped())  return true;
3677 
3678     Node* orig_length = load_array_length(original);
3679 
3680     Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);
3681     klass_node = null_check(klass_node);
3682 
3683     RegionNode* bailout = new RegionNode(1);
3684     record_for_igvn(bailout);
3685 
3686     // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
3687     // Bail out if that is so.
3688     Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);
3689     if (not_objArray != NULL) {
3690       // Improve the klass node&#39;s type from the new optimistic assumption:
3691       ciKlass* ak = ciArrayKlass::make(env()-&gt;Object_klass());
3692       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0/*offset*/);
3693       Node* cast = new CastPPNode(klass_node, akls);
3694       cast-&gt;init_req(0, control());
3695       klass_node = _gvn.transform(cast);
3696     }
3697 
3698     // Bail out if either start or end is negative.
3699     generate_negative_guard(start, bailout, &amp;start);
3700     generate_negative_guard(end,   bailout, &amp;end);
3701 
3702     Node* length = end;
3703     if (_gvn.type(start) != TypeInt::ZERO) {
3704       length = _gvn.transform(new SubINode(end, start));
3705     }
3706 
3707     // Bail out if length is negative.
3708     // Without this the new_array would throw
3709     // NegativeArraySizeException but IllegalArgumentException is what
3710     // should be thrown
3711     generate_negative_guard(length, bailout, &amp;length);
3712 
3713     if (bailout-&gt;req() &gt; 1) {
3714       PreserveJVMState pjvms(this);
3715       set_control(_gvn.transform(bailout));
3716       uncommon_trap(Deoptimization::Reason_intrinsic,
3717                     Deoptimization::Action_maybe_recompile);
3718     }
3719 
3720     if (!stopped()) {
3721       // How many elements will we copy from the original?
3722       // The answer is MinI(orig_length - start, length).
3723       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3724       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3725 
3726       // Generate a direct call to the right arraycopy function(s).
3727       // We know the copy is disjoint but we might not know if the
3728       // oop stores need checking.
3729       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
3730       // This will fail a store-check if x contains any non-nulls.
3731 
3732       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3733       // loads/stores but it is legal only if we&#39;re sure the
3734       // Arrays.copyOf would succeed. So we need all input arguments
3735       // to the copyOf to be validated, including that the copy to the
3736       // new array won&#39;t trigger an ArrayStoreException. That subtype
3737       // check can be optimized if we know something on the type of
3738       // the input array from type speculation.
3739       if (_gvn.type(klass_node)-&gt;singleton()) {
3740         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3741         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3742 
3743         int test = C-&gt;static_subtype_check(superk, subk);
3744         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3745           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3746           if (t_original-&gt;speculative_type() != NULL) {
3747             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3748           }
3749         }
3750       }
3751 
3752       bool validated = false;
3753       // Reason_class_check rather than Reason_intrinsic because we
3754       // want to intrinsify even if this traps.
3755       if (!too_many_traps(Deoptimization::Reason_class_check)) {
3756         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),
3757                                                    klass_node);
3758 
3759         if (not_subtype_ctrl != top()) {
3760           PreserveJVMState pjvms(this);
3761           set_control(not_subtype_ctrl);
3762           uncommon_trap(Deoptimization::Reason_class_check,
3763                         Deoptimization::Action_make_not_entrant);
3764           assert(stopped(), &quot;Should be stopped&quot;);
3765         }
3766         validated = true;
3767       }
3768 
3769       if (!stopped()) {
3770         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3771 
3772         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3773                                                 load_object_klass(original), klass_node);
3774         if (!is_copyOfRange) {
3775           ac-&gt;set_copyof(validated);
3776         } else {
3777           ac-&gt;set_copyofrange(validated);
3778         }
3779         Node* n = _gvn.transform(ac);
3780         if (n == ac) {
3781           ac-&gt;connect_outputs(this);
3782         } else {
3783           assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
3784           set_all_memory(n);
3785         }
3786       }
3787     }
3788   } // original reexecute is set back here
3789 
3790   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3791   if (!stopped()) {
3792     set_result(newcopy);
3793   }
3794   return true;
3795 }
3796 
3797 
3798 //----------------------generate_virtual_guard---------------------------
3799 // Helper for hashCode and clone.  Peeks inside the vtable to avoid a call.
3800 Node* LibraryCallKit::generate_virtual_guard(Node* obj_klass,
3801                                              RegionNode* slow_region) {
3802   ciMethod* method = callee();
3803   int vtable_index = method-&gt;vtable_index();
3804   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3805          &quot;bad index %d&quot;, vtable_index);
3806   // Get the Method* out of the appropriate vtable entry.
3807   int entry_offset  = in_bytes(Klass::vtable_start_offset()) +
3808                      vtable_index*vtableEntry::size_in_bytes() +
3809                      vtableEntry::method_offset_in_bytes();
3810   Node* entry_addr  = basic_plus_adr(obj_klass, entry_offset);
3811   Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3812 
3813   // Compare the target method with the expected method (e.g., Object.hashCode).
3814   const TypePtr* native_call_addr = TypeMetadataPtr::make(method);
3815 
3816   Node* native_call = makecon(native_call_addr);
3817   Node* chk_native  = _gvn.transform(new CmpPNode(target_call, native_call));
3818   Node* test_native = _gvn.transform(new BoolNode(chk_native, BoolTest::ne));
3819 
3820   return generate_slow_guard(test_native, slow_region);
3821 }
3822 
3823 //-----------------------generate_method_call----------------------------
3824 // Use generate_method_call to make a slow-call to the real
3825 // method if the fast path fails.  An alternative would be to
3826 // use a stub like OptoRuntime::slow_arraycopy_Java.
3827 // This only works for expanding the current library call,
3828 // not another intrinsic.  (E.g., don&#39;t use this for making an
3829 // arraycopy call inside of the copyOf intrinsic.)
3830 CallJavaNode*
3831 LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {
3832   // When compiling the intrinsic method itself, do not use this technique.
3833   guarantee(callee() != C-&gt;method(), &quot;cannot make slow-call to self&quot;);
3834 
3835   ciMethod* method = callee();
3836   // ensure the JVMS we have will be correct for this call
3837   guarantee(method_id == method-&gt;intrinsic_id(), &quot;must match&quot;);
3838 
3839   const TypeFunc* tf = TypeFunc::make(method);
3840   CallJavaNode* slow_call;
3841   if (is_static) {
3842     assert(!is_virtual, &quot;&quot;);
3843     slow_call = new CallStaticJavaNode(C, tf,
3844                            SharedRuntime::get_resolve_static_call_stub(),
3845                            method, bci());
3846   } else if (is_virtual) {
3847     null_check_receiver();
3848     int vtable_index = Method::invalid_vtable_index;
3849     if (UseInlineCaches) {
3850       // Suppress the vtable call
3851     } else {
3852       // hashCode and clone are not a miranda methods,
3853       // so the vtable index is fixed.
3854       // No need to use the linkResolver to get it.
3855        vtable_index = method-&gt;vtable_index();
3856        assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3857               &quot;bad index %d&quot;, vtable_index);
3858     }
3859     slow_call = new CallDynamicJavaNode(tf,
3860                           SharedRuntime::get_resolve_virtual_call_stub(),
3861                           method, vtable_index, bci());
3862   } else {  // neither virtual nor static:  opt_virtual
3863     null_check_receiver();
3864     slow_call = new CallStaticJavaNode(C, tf,
3865                                 SharedRuntime::get_resolve_opt_virtual_call_stub(),
3866                                 method, bci());
3867     slow_call-&gt;set_optimized_virtual(true);
3868   }
3869   if (CallGenerator::is_inlined_method_handle_intrinsic(this-&gt;method(), bci(), callee())) {
3870     // To be able to issue a direct call (optimized virtual or virtual)
3871     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
3872     // about the method being invoked should be attached to the call site to
3873     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
3874     slow_call-&gt;set_override_symbolic_info(true);
3875   }
3876   set_arguments_for_java_call(slow_call);
3877   set_edges_for_java_call(slow_call);
3878   return slow_call;
3879 }
3880 
3881 
3882 /**
3883  * Build special case code for calls to hashCode on an object. This call may
3884  * be virtual (invokevirtual) or bound (invokespecial). For each case we generate
3885  * slightly different code.
3886  */
3887 bool LibraryCallKit::inline_native_hashcode(bool is_virtual, bool is_static) {
3888   assert(is_static == callee()-&gt;is_static(), &quot;correct intrinsic selection&quot;);
3889   assert(!(is_virtual &amp;&amp; is_static), &quot;either virtual, special, or static&quot;);
3890 
3891   enum { _slow_path = 1, _fast_path, _null_path, PATH_LIMIT };
3892 
3893   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3894   PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
3895   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3896   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3897   Node* obj = NULL;
3898   if (!is_static) {
3899     // Check for hashing null object
3900     obj = null_check_receiver();
3901     if (stopped())  return true;        // unconditionally null
3902     result_reg-&gt;init_req(_null_path, top());
3903     result_val-&gt;init_req(_null_path, top());
3904   } else {
3905     // Do a null check, and return zero if null.
3906     // System.identityHashCode(null) == 0
3907     obj = argument(0);
3908     Node* null_ctl = top();
3909     obj = null_check_oop(obj, &amp;null_ctl);
3910     result_reg-&gt;init_req(_null_path, null_ctl);
3911     result_val-&gt;init_req(_null_path, _gvn.intcon(0));
3912   }
3913 
3914   // Unconditionally null?  Then return right away.
3915   if (stopped()) {
3916     set_control( result_reg-&gt;in(_null_path));
3917     if (!stopped())
3918       set_result(result_val-&gt;in(_null_path));
3919     return true;
3920   }
3921 
3922   // We only go to the fast case code if we pass a number of guards.  The
3923   // paths which do not pass are accumulated in the slow_region.
3924   RegionNode* slow_region = new RegionNode(1);
3925   record_for_igvn(slow_region);
3926 
3927   // If this is a virtual call, we generate a funny guard.  We pull out
3928   // the vtable entry corresponding to hashCode() from the target object.
3929   // If the target method which we are calling happens to be the native
3930   // Object hashCode() method, we pass the guard.  We do not need this
3931   // guard for non-virtual calls -- the caller is known to be the native
3932   // Object hashCode().
3933   if (is_virtual) {
3934     // After null check, get the object&#39;s klass.
3935     Node* obj_klass = load_object_klass(obj);
3936     generate_virtual_guard(obj_klass, slow_region);
3937   }
3938 
3939   // Get the header out of the object, use LoadMarkNode when available
3940   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3941   // The control of the load must be NULL. Otherwise, the load can move before
3942   // the null check after castPP removal.
3943   Node* no_ctrl = NULL;
3944   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3945 
3946   // Test the header to see if it is unlocked.
3947   Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);
3948   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
3949   Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);
3950   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
3951   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
3952 
3953   generate_slow_guard(test_unlocked, slow_region);
3954 
3955   // Get the hash value and check to see that it has been properly assigned.
3956   // We depend on hash_mask being at most 32 bits and avoid the use of
3957   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
3958   // vm: see markWord.hpp.
3959   Node *hash_mask      = _gvn.intcon(markWord::hash_mask);
3960   Node *hash_shift     = _gvn.intcon(markWord::hash_shift);
3961   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
3962   // This hack lets the hash bits live anywhere in the mark object now, as long
3963   // as the shift drops the relevant bits into the low 32 bits.  Note that
3964   // Java spec says that HashCode is an int so there&#39;s no point in capturing
3965   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
3966   hshifted_header      = ConvX2I(hshifted_header);
3967   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
3968 
3969   Node *no_hash_val    = _gvn.intcon(markWord::no_hash);
3970   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
3971   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
3972 
3973   generate_slow_guard(test_assigned, slow_region);
3974 
3975   Node* init_mem = reset_memory();
3976   // fill in the rest of the null path:
3977   result_io -&gt;init_req(_null_path, i_o());
3978   result_mem-&gt;init_req(_null_path, init_mem);
3979 
3980   result_val-&gt;init_req(_fast_path, hash_val);
3981   result_reg-&gt;init_req(_fast_path, control());
3982   result_io -&gt;init_req(_fast_path, i_o());
3983   result_mem-&gt;init_req(_fast_path, init_mem);
3984 
3985   // Generate code for the slow case.  We make a call to hashCode().
3986   set_control(_gvn.transform(slow_region));
3987   if (!stopped()) {
3988     // No need for PreserveJVMState, because we&#39;re using up the present state.
3989     set_all_memory(init_mem);
3990     vmIntrinsics::ID hashCode_id = is_static ? vmIntrinsics::_identityHashCode : vmIntrinsics::_hashCode;
3991     CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);
3992     Node* slow_result = set_results_for_java_call(slow_call);
3993     // this-&gt;control() comes from set_results_for_java_call
3994     result_reg-&gt;init_req(_slow_path, control());
3995     result_val-&gt;init_req(_slow_path, slow_result);
3996     result_io  -&gt;set_req(_slow_path, i_o());
3997     result_mem -&gt;set_req(_slow_path, reset_memory());
3998   }
3999 
4000   // Return the combined state.
4001   set_i_o(        _gvn.transform(result_io)  );
4002   set_all_memory( _gvn.transform(result_mem));
4003 
4004   set_result(result_reg, result_val);
4005   return true;
4006 }
4007 
4008 //---------------------------inline_native_getClass----------------------------
4009 // public final native Class&lt;?&gt; java.lang.Object.getClass();
4010 //
4011 // Build special case code for calls to getClass on an object.
4012 bool LibraryCallKit::inline_native_getClass() {
4013   Node* obj = null_check_receiver();
4014   if (stopped())  return true;
4015   set_result(load_mirror_from_klass(load_object_klass(obj)));
4016   return true;
4017 }
4018 
4019 //-----------------inline_native_Reflection_getCallerClass---------------------
4020 // public static native Class&lt;?&gt; sun.reflect.Reflection.getCallerClass();
4021 //
4022 // In the presence of deep enough inlining, getCallerClass() becomes a no-op.
4023 //
4024 // NOTE: This code must perform the same logic as JVM_GetCallerClass
4025 // in that it must skip particular security frames and checks for
4026 // caller sensitive methods.
4027 bool LibraryCallKit::inline_native_Reflection_getCallerClass() {
4028 #ifndef PRODUCT
4029   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4030     tty-&gt;print_cr(&quot;Attempting to inline sun.reflect.Reflection.getCallerClass&quot;);
4031   }
4032 #endif
4033 
4034   if (!jvms()-&gt;has_method()) {
4035 #ifndef PRODUCT
4036     if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4037       tty-&gt;print_cr(&quot;  Bailing out because intrinsic was inlined at top level&quot;);
4038     }
4039 #endif
4040     return false;
4041   }
4042 
4043   // Walk back up the JVM state to find the caller at the required
4044   // depth.
4045   JVMState* caller_jvms = jvms();
4046 
4047   // Cf. JVM_GetCallerClass
4048   // NOTE: Start the loop at depth 1 because the current JVM state does
4049   // not include the Reflection.getCallerClass() frame.
4050   for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms-&gt;caller(), n++) {
4051     ciMethod* m = caller_jvms-&gt;method();
4052     switch (n) {
4053     case 0:
4054       fatal(&quot;current JVM state does not include the Reflection.getCallerClass frame&quot;);
4055       break;
4056     case 1:
4057       // Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
4058       if (!m-&gt;caller_sensitive()) {
4059 #ifndef PRODUCT
4060         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4061           tty-&gt;print_cr(&quot;  Bailing out: CallerSensitive annotation expected at frame %d&quot;, n);
4062         }
4063 #endif
4064         return false;  // bail-out; let JVM_GetCallerClass do the work
4065       }
4066       break;
4067     default:
4068       if (!m-&gt;is_ignored_by_security_stack_walk()) {
4069         // We have reached the desired frame; return the holder class.
4070         // Acquire method holder as java.lang.Class and push as constant.
4071         ciInstanceKlass* caller_klass = caller_jvms-&gt;method()-&gt;holder();
4072         ciInstance* caller_mirror = caller_klass-&gt;java_mirror();
4073         set_result(makecon(TypeInstPtr::make(caller_mirror)));
4074 
4075 #ifndef PRODUCT
4076         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4077           tty-&gt;print_cr(&quot;  Succeeded: caller = %d) %s.%s, JVMS depth = %d&quot;, n, caller_klass-&gt;name()-&gt;as_utf8(), caller_jvms-&gt;method()-&gt;name()-&gt;as_utf8(), jvms()-&gt;depth());
4078           tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4079           for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4080             ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4081             tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4082           }
4083         }
4084 #endif
4085         return true;
4086       }
4087       break;
4088     }
4089   }
4090 
4091 #ifndef PRODUCT
4092   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4093     tty-&gt;print_cr(&quot;  Bailing out because caller depth exceeded inlining depth = %d&quot;, jvms()-&gt;depth());
4094     tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4095     for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4096       ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4097       tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4098     }
4099   }
4100 #endif
4101 
4102   return false;  // bail-out; let JVM_GetCallerClass do the work
4103 }
4104 
4105 bool LibraryCallKit::inline_fp_conversions(vmIntrinsics::ID id) {
4106   Node* arg = argument(0);
4107   Node* result = NULL;
4108 
4109   switch (id) {
4110   case vmIntrinsics::_floatToRawIntBits:    result = new MoveF2INode(arg);  break;
4111   case vmIntrinsics::_intBitsToFloat:       result = new MoveI2FNode(arg);  break;
4112   case vmIntrinsics::_doubleToRawLongBits:  result = new MoveD2LNode(arg);  break;
4113   case vmIntrinsics::_longBitsToDouble:     result = new MoveL2DNode(arg);  break;
4114 
4115   case vmIntrinsics::_doubleToLongBits: {
4116     // two paths (plus control) merge in a wood
4117     RegionNode *r = new RegionNode(3);
4118     Node *phi = new PhiNode(r, TypeLong::LONG);
4119 
4120     Node *cmpisnan = _gvn.transform(new CmpDNode(arg, arg));
4121     // Build the boolean node
4122     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4123 
4124     // Branch either way.
4125     // NaN case is less traveled, which makes all the difference.
4126     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4127     Node *opt_isnan = _gvn.transform(ifisnan);
4128     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4129     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4130     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4131 
4132     set_control(iftrue);
4133 
4134     static const jlong nan_bits = CONST64(0x7ff8000000000000);
4135     Node *slow_result = longcon(nan_bits); // return NaN
4136     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4137     r-&gt;init_req(1, iftrue);
4138 
4139     // Else fall through
4140     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4141     set_control(iffalse);
4142 
4143     phi-&gt;init_req(2, _gvn.transform(new MoveD2LNode(arg)));
4144     r-&gt;init_req(2, iffalse);
4145 
4146     // Post merge
4147     set_control(_gvn.transform(r));
4148     record_for_igvn(r);
4149 
4150     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4151     result = phi;
4152     assert(result-&gt;bottom_type()-&gt;isa_long(), &quot;must be&quot;);
4153     break;
4154   }
4155 
4156   case vmIntrinsics::_floatToIntBits: {
4157     // two paths (plus control) merge in a wood
4158     RegionNode *r = new RegionNode(3);
4159     Node *phi = new PhiNode(r, TypeInt::INT);
4160 
4161     Node *cmpisnan = _gvn.transform(new CmpFNode(arg, arg));
4162     // Build the boolean node
4163     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4164 
4165     // Branch either way.
4166     // NaN case is less traveled, which makes all the difference.
4167     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4168     Node *opt_isnan = _gvn.transform(ifisnan);
4169     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4170     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4171     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4172 
4173     set_control(iftrue);
4174 
4175     static const jint nan_bits = 0x7fc00000;
4176     Node *slow_result = makecon(TypeInt::make(nan_bits)); // return NaN
4177     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4178     r-&gt;init_req(1, iftrue);
4179 
4180     // Else fall through
4181     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4182     set_control(iffalse);
4183 
4184     phi-&gt;init_req(2, _gvn.transform(new MoveF2INode(arg)));
4185     r-&gt;init_req(2, iffalse);
4186 
4187     // Post merge
4188     set_control(_gvn.transform(r));
4189     record_for_igvn(r);
4190 
4191     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4192     result = phi;
4193     assert(result-&gt;bottom_type()-&gt;isa_int(), &quot;must be&quot;);
4194     break;
4195   }
4196 
4197   default:
4198     fatal_unexpected_iid(id);
4199     break;
4200   }
4201   set_result(_gvn.transform(result));
4202   return true;
4203 }
4204 
4205 //----------------------inline_unsafe_copyMemory-------------------------
4206 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4207 bool LibraryCallKit::inline_unsafe_copyMemory() {
4208   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4209   null_check_receiver();  // null-check receiver
4210   if (stopped())  return true;
4211 
4212   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4213 
4214   Node* src_ptr =         argument(1);   // type: oop
4215   Node* src_off = ConvL2X(argument(2));  // type: long
4216   Node* dst_ptr =         argument(4);   // type: oop
4217   Node* dst_off = ConvL2X(argument(5));  // type: long
4218   Node* size    = ConvL2X(argument(7));  // type: long
4219 
4220   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4221          &quot;fieldOffset must be byte-scaled&quot;);
4222 
4223   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4224   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4225 
4226   // Conservatively insert a memory barrier on all memory slices.
4227   // Do not let writes of the copy source or destination float below the copy.
4228   insert_mem_bar(Op_MemBarCPUOrder);
4229 
4230   Node* thread = _gvn.transform(new ThreadLocalNode());
4231   Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));
4232   BasicType doing_unsafe_access_bt = T_BYTE;
4233   assert((sizeof(bool) * CHAR_BIT) == 8, &quot;not implemented&quot;);
4234 
4235   // update volatile field
4236   store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4237 
4238   // Call it.  Note that the length argument is not scaled.
4239   make_runtime_call(RC_LEAF|RC_NO_FP,
4240                     OptoRuntime::fast_arraycopy_Type(),
4241                     StubRoutines::unsafe_arraycopy(),
4242                     &quot;unsafe_arraycopy&quot;,
4243                     TypeRawPtr::BOTTOM,
4244                     src, dst, size XTOP);
4245 
4246   store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4247 
4248   // Do not let reads of the copy destination float above the copy.
4249   insert_mem_bar(Op_MemBarCPUOrder);
4250 
4251   return true;
4252 }
4253 
4254 //------------------------clone_coping-----------------------------------
4255 // Helper function for inline_native_clone.
4256 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4257   assert(obj_size != NULL, &quot;&quot;);
4258   Node* raw_obj = alloc_obj-&gt;in(1);
4259   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4260 
4261   AllocateNode* alloc = NULL;
4262   if (ReduceBulkZeroing) {
4263     // We will be completely responsible for initializing this object -
4264     // mark Initialize node as complete.
4265     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4266     // The object was just allocated - there should be no any stores!
4267     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4268     // Mark as complete_with_arraycopy so that on AllocateNode
4269     // expansion, we know this AllocateNode is initialized by an array
4270     // copy and a StoreStore barrier exists after the array copy.
4271     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4272   }
4273 
4274   Node* size = _gvn.transform(obj_size);
4275   access_clone(obj, alloc_obj, size, is_array);
4276 
4277   // Do not let reads from the cloned object float above the arraycopy.
4278   if (alloc != NULL) {
4279     // Do not let stores that initialize this object be reordered with
4280     // a subsequent store that would make this object accessible by
4281     // other threads.
4282     // Record what AllocateNode this StoreStore protects so that
4283     // escape analysis can go from the MemBarStoreStoreNode to the
4284     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4285     // based on the escape status of the AllocateNode.
4286     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4287   } else {
4288     insert_mem_bar(Op_MemBarCPUOrder);
4289   }
4290 }
4291 
4292 //------------------------inline_native_clone----------------------------
4293 // protected native Object java.lang.Object.clone();
4294 //
4295 // Here are the simple edge cases:
4296 //  null receiver =&gt; normal trap
4297 //  virtual and clone was overridden =&gt; slow path to out-of-line clone
4298 //  not cloneable or finalizer =&gt; slow path to out-of-line Object.clone
4299 //
4300 // The general case has two steps, allocation and copying.
4301 // Allocation has two cases, and uses GraphKit::new_instance or new_array.
4302 //
4303 // Copying also has two cases, oop arrays and everything else.
4304 // Oop arrays use arrayof_oop_arraycopy (same as System.arraycopy).
4305 // Everything else uses the tight inline loop supplied by CopyArrayNode.
4306 //
4307 // These steps fold up nicely if and when the cloned object&#39;s klass
4308 // can be sharply typed as an object array, a type array, or an instance.
4309 //
4310 bool LibraryCallKit::inline_native_clone(bool is_virtual) {
4311   PhiNode* result_val;
4312 
4313   // Set the reexecute bit for the interpreter to reexecute
4314   // the bytecode that invokes Object.clone if deoptimization happens.
4315   { PreserveReexecuteState preexecs(this);
4316     jvms()-&gt;set_should_reexecute(true);
4317 
4318     Node* obj = null_check_receiver();
4319     if (stopped())  return true;
4320 
4321     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4322 
4323     // If we are going to clone an instance, we need its exact type to
4324     // know the number and types of fields to convert the clone to
4325     // loads/stores. Maybe a speculative type can help us.
4326     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4327         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4328         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {
4329       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4330       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4331           !spec_ik-&gt;has_injected_fields()) {
4332         ciKlass* k = obj_type-&gt;klass();
4333         if (!k-&gt;is_instance_klass() ||
4334             k-&gt;as_instance_klass()-&gt;is_interface() ||
4335             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4336           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4337         }
4338       }
4339     }
4340 
4341     // Conservatively insert a memory barrier on all memory slices.
4342     // Do not let writes into the original float below the clone.
4343     insert_mem_bar(Op_MemBarCPUOrder);
4344 
4345     // paths into result_reg:
4346     enum {
4347       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4348       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4349       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4350       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4351       PATH_LIMIT
4352     };
4353     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4354     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4355     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4356     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4357     record_for_igvn(result_reg);
4358 
4359     Node* obj_klass = load_object_klass(obj);
4360     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4361     if (array_ctl != NULL) {
4362       // It&#39;s an array.
4363       PreserveJVMState pjvms(this);
4364       set_control(array_ctl);
4365       Node* obj_length = load_array_length(obj);
4366       Node* obj_size  = NULL;
4367       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size);  // no arguments to push
4368 
4369       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4370       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4371         // If it is an oop array, it requires very special treatment,
4372         // because gc barriers are required when accessing the array.
4373         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4374         if (is_obja != NULL) {
4375           PreserveJVMState pjvms2(this);
4376           set_control(is_obja);
4377           // Generate a direct call to the right arraycopy function(s).
4378           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4379           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
4380           ac-&gt;set_clone_oop_array();
4381           Node* n = _gvn.transform(ac);
4382           assert(n == ac, &quot;cannot disappear&quot;);
4383           ac-&gt;connect_outputs(this);
4384 
4385           result_reg-&gt;init_req(_objArray_path, control());
4386           result_val-&gt;init_req(_objArray_path, alloc_obj);
4387           result_i_o -&gt;set_req(_objArray_path, i_o());
4388           result_mem -&gt;set_req(_objArray_path, reset_memory());
4389         }
4390       }
4391       // Otherwise, there are no barriers to worry about.
4392       // (We can dispense with card marks if we know the allocation
4393       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4394       //  causes the non-eden paths to take compensating steps to
4395       //  simulate a fresh allocation, so that no further
4396       //  card marks are required in compiled code to initialize
4397       //  the object.)
4398 
4399       if (!stopped()) {
4400         copy_to_clone(obj, alloc_obj, obj_size, true);
4401 
4402         // Present the results of the copy.
4403         result_reg-&gt;init_req(_array_path, control());
4404         result_val-&gt;init_req(_array_path, alloc_obj);
4405         result_i_o -&gt;set_req(_array_path, i_o());
4406         result_mem -&gt;set_req(_array_path, reset_memory());
4407       }
4408     }
4409 
4410     // We only go to the instance fast case code if we pass a number of guards.
4411     // The paths which do not pass are accumulated in the slow_region.
4412     RegionNode* slow_region = new RegionNode(1);
4413     record_for_igvn(slow_region);
4414     if (!stopped()) {
4415       // It&#39;s an instance (we did array above).  Make the slow-path tests.
4416       // If this is a virtual call, we generate a funny guard.  We grab
4417       // the vtable entry corresponding to clone() from the target object.
4418       // If the target method which we are calling happens to be the
4419       // Object clone() method, we pass the guard.  We do not need this
4420       // guard for non-virtual calls; the caller is known to be the native
4421       // Object clone().
4422       if (is_virtual) {
4423         generate_virtual_guard(obj_klass, slow_region);
4424       }
4425 
4426       // The object must be easily cloneable and must not have a finalizer.
4427       // Both of these conditions may be checked in a single test.
4428       // We could optimize the test further, but we don&#39;t care.
4429       generate_access_flags_guard(obj_klass,
4430                                   // Test both conditions:
4431                                   JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,
4432                                   // Must be cloneable but not finalizer:
4433                                   JVM_ACC_IS_CLONEABLE_FAST,
4434                                   slow_region);
4435     }
4436 
4437     if (!stopped()) {
4438       // It&#39;s an instance, and it passed the slow-path tests.
4439       PreserveJVMState pjvms(this);
4440       Node* obj_size  = NULL;
4441       // Need to deoptimize on exception from allocation since Object.clone intrinsic
4442       // is reexecuted if deoptimization occurs and there could be problems when merging
4443       // exception state between multiple Object.clone versions (reexecute=true vs reexecute=false).
4444       Node* alloc_obj = new_instance(obj_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
4445 
4446       copy_to_clone(obj, alloc_obj, obj_size, false);
4447 
4448       // Present the results of the slow call.
4449       result_reg-&gt;init_req(_instance_path, control());
4450       result_val-&gt;init_req(_instance_path, alloc_obj);
4451       result_i_o -&gt;set_req(_instance_path, i_o());
4452       result_mem -&gt;set_req(_instance_path, reset_memory());
4453     }
4454 
4455     // Generate code for the slow case.  We make a call to clone().
4456     set_control(_gvn.transform(slow_region));
4457     if (!stopped()) {
4458       PreserveJVMState pjvms(this);
4459       CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);
4460       // We need to deoptimize on exception (see comment above)
4461       Node* slow_result = set_results_for_java_call(slow_call, false, /* deoptimize */ true);
4462       // this-&gt;control() comes from set_results_for_java_call
4463       result_reg-&gt;init_req(_slow_path, control());
4464       result_val-&gt;init_req(_slow_path, slow_result);
4465       result_i_o -&gt;set_req(_slow_path, i_o());
4466       result_mem -&gt;set_req(_slow_path, reset_memory());
4467     }
4468 
4469     // Return the combined state.
4470     set_control(    _gvn.transform(result_reg));
4471     set_i_o(        _gvn.transform(result_i_o));
4472     set_all_memory( _gvn.transform(result_mem));
4473   } // original reexecute is set back here
4474 
4475   set_result(_gvn.transform(result_val));
4476   return true;
4477 }
4478 
4479 // If we have a tightly coupled allocation, the arraycopy may take care
4480 // of the array initialization. If one of the guards we insert between
4481 // the allocation and the arraycopy causes a deoptimization, an
4482 // unitialized array will escape the compiled method. To prevent that
4483 // we set the JVM state for uncommon traps between the allocation and
4484 // the arraycopy to the state before the allocation so, in case of
4485 // deoptimization, we&#39;ll reexecute the allocation and the
4486 // initialization.
4487 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4488   if (alloc != NULL) {
4489     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4490     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4491 
4492     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4493         !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {
4494       // Make sure there&#39;s no store between the allocation and the
4495       // arraycopy otherwise visible side effects could be rexecuted
4496       // in case of deoptimization and cause incorrect execution.
4497       bool no_interfering_store = true;
4498       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4499       if (mem-&gt;is_MergeMem()) {
4500         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4501           Node* n = mms.memory();
4502           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4503             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4504             no_interfering_store = false;
4505             break;
4506           }
4507         }
4508       } else {
4509         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4510           Node* n = mms.memory();
4511           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4512             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4513             no_interfering_store = false;
4514             break;
4515           }
4516         }
4517       }
4518 
4519       if (no_interfering_store) {
4520         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4521         uint size = alloc-&gt;req();
4522         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4523         old_jvms-&gt;set_map(sfpt);
4524         for (uint i = 0; i &lt; size; i++) {
4525           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4526         }
4527         // re-push array length for deoptimization
4528         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4529         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4530         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4531         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4532         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
4533         old_jvms-&gt;set_should_reexecute(true);
4534 
4535         sfpt-&gt;set_i_o(map()-&gt;i_o());
4536         sfpt-&gt;set_memory(map()-&gt;memory());
4537         sfpt-&gt;set_control(map()-&gt;control());
4538 
4539         JVMState* saved_jvms = jvms();
4540         saved_reexecute_sp = _reexecute_sp;
4541 
4542         set_jvms(sfpt-&gt;jvms());
4543         _reexecute_sp = jvms()-&gt;sp();
4544 
4545         return saved_jvms;
4546       }
4547     }
4548   }
4549   return NULL;
4550 }
4551 
4552 // In case of a deoptimization, we restart execution at the
4553 // allocation, allocating a new array. We would leave an uninitialized
4554 // array in the heap that GCs wouldn&#39;t expect. Move the allocation
4555 // after the traps so we don&#39;t allocate the array if we
4556 // deoptimize. This is possible because tightly_coupled_allocation()
4557 // guarantees there&#39;s no observer of the allocated array at this point
4558 // and the control flow is simple enough.
4559 void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,
4560                                                     int saved_reexecute_sp, uint new_idx) {
4561   if (saved_jvms != NULL &amp;&amp; !stopped()) {
4562     assert(alloc != NULL, &quot;only with a tightly coupled allocation&quot;);
4563     // restore JVM state to the state at the arraycopy
4564     saved_jvms-&gt;map()-&gt;set_control(map()-&gt;control());
4565     assert(saved_jvms-&gt;map()-&gt;memory() == map()-&gt;memory(), &quot;memory state changed?&quot;);
4566     assert(saved_jvms-&gt;map()-&gt;i_o() == map()-&gt;i_o(), &quot;IO state changed?&quot;);
4567     // If we&#39;ve improved the types of some nodes (null check) while
4568     // emitting the guards, propagate them to the current state
4569     map()-&gt;replaced_nodes().apply(saved_jvms-&gt;map(), new_idx);
4570     set_jvms(saved_jvms);
4571     _reexecute_sp = saved_reexecute_sp;
4572 
4573     // Remove the allocation from above the guards
4574     CallProjections callprojs;
4575     alloc-&gt;extract_projections(&amp;callprojs, true);
4576     InitializeNode* init = alloc-&gt;initialization();
4577     Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
4578     C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));
4579     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Memory), alloc_mem);
4580     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Control), alloc-&gt;in(0));
4581 
4582     // move the allocation here (after the guards)
4583     _gvn.hash_delete(alloc);
4584     alloc-&gt;set_req(TypeFunc::Control, control());
4585     alloc-&gt;set_req(TypeFunc::I_O, i_o());
4586     Node *mem = reset_memory();
4587     set_all_memory(mem);
4588     alloc-&gt;set_req(TypeFunc::Memory, mem);
4589     set_control(init-&gt;proj_out_or_null(TypeFunc::Control));
4590     set_i_o(callprojs.fallthrough_ioproj);
4591 
4592     // Update memory as done in GraphKit::set_output_for_allocation()
4593     const TypeInt* length_type = _gvn.find_int_type(alloc-&gt;in(AllocateNode::ALength));
4594     const TypeOopPtr* ary_type = _gvn.type(alloc-&gt;in(AllocateNode::KlassNode))-&gt;is_klassptr()-&gt;as_instance_type();
4595     if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4596       ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4597     }
4598     const TypePtr* telemref = ary_type-&gt;add_offset(Type::OffsetBot);
4599     int            elemidx  = C-&gt;get_alias_index(telemref);
4600     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);
4601     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), elemidx);
4602 
4603     Node* allocx = _gvn.transform(alloc);
4604     assert(allocx == alloc, &quot;where has the allocation gone?&quot;);
4605     assert(dest-&gt;is_CheckCastPP(), &quot;not an allocation result?&quot;);
4606 
4607     _gvn.hash_delete(dest);
4608     dest-&gt;set_req(0, control());
4609     Node* destx = _gvn.transform(dest);
4610     assert(destx == dest, &quot;where has the allocation result gone?&quot;);
4611   }
4612 }
4613 
4614 
4615 //------------------------------inline_arraycopy-----------------------
4616 // public static native void java.lang.System.arraycopy(Object src,  int  srcPos,
4617 //                                                      Object dest, int destPos,
4618 //                                                      int length);
4619 bool LibraryCallKit::inline_arraycopy() {
4620   // Get the arguments.
4621   Node* src         = argument(0);  // type: oop
4622   Node* src_offset  = argument(1);  // type: int
4623   Node* dest        = argument(2);  // type: oop
4624   Node* dest_offset = argument(3);  // type: int
4625   Node* length      = argument(4);  // type: int
4626 
4627   uint new_idx = C-&gt;unique();
4628 
4629   // Check for allocation before we add nodes that would confuse
4630   // tightly_coupled_allocation()
4631   AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);
4632 
4633   int saved_reexecute_sp = -1;
4634   JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);
4635   // See arraycopy_restore_alloc_state() comment
4636   // if alloc == NULL we don&#39;t have to worry about a tightly coupled allocation so we can emit all needed guards
4637   // if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation
4638   // if saved_jvms == NULL and alloc != NULL, we can&#39;t emit any guards
4639   bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);
4640 
4641   // The following tests must be performed
4642   // (1) src and dest are arrays.
4643   // (2) src and dest arrays must have elements of the same BasicType
4644   // (3) src and dest must not be null.
4645   // (4) src_offset must not be negative.
4646   // (5) dest_offset must not be negative.
4647   // (6) length must not be negative.
4648   // (7) src_offset + length must not exceed length of src.
4649   // (8) dest_offset + length must not exceed length of dest.
4650   // (9) each element of an oop array must be assignable
4651 
4652   // (3) src and dest must not be null.
4653   // always do this here because we need the JVM state for uncommon traps
4654   Node* null_ctl = top();
4655   src  = saved_jvms != NULL ? null_check_oop(src, &amp;null_ctl, true, true) : null_check(src,  T_ARRAY);
4656   assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
4657   dest = null_check(dest, T_ARRAY);
4658 
4659   if (!can_emit_guards) {
4660     // if saved_jvms == NULL and alloc != NULL, we don&#39;t emit any
4661     // guards but the arraycopy node could still take advantage of a
4662     // tightly allocated allocation. tightly_coupled_allocation() is
4663     // called again to make sure it takes the null check above into
4664     // account: the null check is mandatory and if it caused an
4665     // uncommon trap to be emitted then the allocation can&#39;t be
4666     // considered tightly coupled in this context.
4667     alloc = tightly_coupled_allocation(dest, NULL);
4668   }
4669 
4670   bool validated = false;
4671 
4672   const Type* src_type  = _gvn.type(src);
4673   const Type* dest_type = _gvn.type(dest);
4674   const TypeAryPtr* top_src  = src_type-&gt;isa_aryptr();
4675   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
4676 
4677   // Do we have the type of src?
4678   bool has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4679   // Do we have the type of dest?
4680   bool has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4681   // Is the type for src from speculation?
4682   bool src_spec = false;
4683   // Is the type for dest from speculation?
4684   bool dest_spec = false;
4685 
4686   if ((!has_src || !has_dest) &amp;&amp; can_emit_guards) {
4687     // We don&#39;t have sufficient type information, let&#39;s see if
4688     // speculative types can help. We need to have types for both src
4689     // and dest so that it pays off.
4690 
4691     // Do we already have or could we have type information for src
4692     bool could_have_src = has_src;
4693     // Do we already have or could we have type information for dest
4694     bool could_have_dest = has_dest;
4695 
4696     ciKlass* src_k = NULL;
4697     if (!has_src) {
4698       src_k = src_type-&gt;speculative_type_not_null();
4699       if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4700         could_have_src = true;
4701       }
4702     }
4703 
4704     ciKlass* dest_k = NULL;
4705     if (!has_dest) {
4706       dest_k = dest_type-&gt;speculative_type_not_null();
4707       if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4708         could_have_dest = true;
4709       }
4710     }
4711 
4712     if (could_have_src &amp;&amp; could_have_dest) {
4713       // This is going to pay off so emit the required guards
4714       if (!has_src) {
4715         src = maybe_cast_profiled_obj(src, src_k, true);
4716         src_type  = _gvn.type(src);
4717         top_src  = src_type-&gt;isa_aryptr();
4718         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4719         src_spec = true;
4720       }
4721       if (!has_dest) {
4722         dest = maybe_cast_profiled_obj(dest, dest_k, true);
4723         dest_type  = _gvn.type(dest);
4724         top_dest  = dest_type-&gt;isa_aryptr();
4725         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4726         dest_spec = true;
4727       }
4728     }
4729   }
4730 
4731   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
4732     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4733     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4734     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;
4735     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;
4736 
4737     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
4738       // If both arrays are object arrays then having the exact types
4739       // for both will remove the need for a subtype check at runtime
4740       // before the call and may make it possible to pick a faster copy
4741       // routine (without a subtype check on every element)
4742       // Do we have the exact type of src?
4743       bool could_have_src = src_spec;
4744       // Do we have the exact type of dest?
4745       bool could_have_dest = dest_spec;
4746       ciKlass* src_k = top_src-&gt;klass();
4747       ciKlass* dest_k = top_dest-&gt;klass();
4748       if (!src_spec) {
4749         src_k = src_type-&gt;speculative_type_not_null();
4750         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4751           could_have_src = true;
4752         }
4753       }
4754       if (!dest_spec) {
4755         dest_k = dest_type-&gt;speculative_type_not_null();
4756         if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4757           could_have_dest = true;
4758         }
4759       }
4760       if (could_have_src &amp;&amp; could_have_dest) {
4761         // If we can have both exact types, emit the missing guards
4762         if (could_have_src &amp;&amp; !src_spec) {
4763           src = maybe_cast_profiled_obj(src, src_k, true);
4764         }
4765         if (could_have_dest &amp;&amp; !dest_spec) {
4766           dest = maybe_cast_profiled_obj(dest, dest_k, true);
4767         }
4768       }
4769     }
4770   }
4771 
4772   ciMethod* trap_method = method();
4773   int trap_bci = bci();
4774   if (saved_jvms != NULL) {
4775     trap_method = alloc-&gt;jvms()-&gt;method();
4776     trap_bci = alloc-&gt;jvms()-&gt;bci();
4777   }
4778 
4779   bool negative_length_guard_generated = false;
4780 
4781   if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4782       can_emit_guards &amp;&amp;
4783       !src-&gt;is_top() &amp;&amp; !dest-&gt;is_top()) {
4784     // validate arguments: enables transformation the ArrayCopyNode
4785     validated = true;
4786 
4787     RegionNode* slow_region = new RegionNode(1);
4788     record_for_igvn(slow_region);
4789 
4790     // (1) src and dest are arrays.
4791     generate_non_array_guard(load_object_klass(src), slow_region);
4792     generate_non_array_guard(load_object_klass(dest), slow_region);
4793 
4794     // (2) src and dest arrays must have elements of the same BasicType
4795     // done at macro expansion or at Ideal transformation time
4796 
4797     // (4) src_offset must not be negative.
4798     generate_negative_guard(src_offset, slow_region);
4799 
4800     // (5) dest_offset must not be negative.
4801     generate_negative_guard(dest_offset, slow_region);
4802 
4803     // (7) src_offset + length must not exceed length of src.
4804     generate_limit_guard(src_offset, length,
4805                          load_array_length(src),
4806                          slow_region);
4807 
4808     // (8) dest_offset + length must not exceed length of dest.
4809     generate_limit_guard(dest_offset, length,
4810                          load_array_length(dest),
4811                          slow_region);
4812 
4813     // (6) length must not be negative.
4814     // This is also checked in generate_arraycopy() during macro expansion, but
4815     // we also have to check it here for the case where the ArrayCopyNode will
4816     // be eliminated by Escape Analysis.
4817     if (EliminateAllocations) {
4818       generate_negative_guard(length, slow_region);
4819       negative_length_guard_generated = true;
4820     }
4821 
4822     // (9) each element of an oop array must be assignable
4823     Node* src_klass  = load_object_klass(src);
4824     Node* dest_klass = load_object_klass(dest);
4825     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);
4826 
4827     if (not_subtype_ctrl != top()) {
4828       PreserveJVMState pjvms(this);
4829       set_control(not_subtype_ctrl);
4830       uncommon_trap(Deoptimization::Reason_intrinsic,
4831                     Deoptimization::Action_make_not_entrant);
4832       assert(stopped(), &quot;Should be stopped&quot;);
4833     }
4834     {
4835       PreserveJVMState pjvms(this);
4836       set_control(_gvn.transform(slow_region));
4837       uncommon_trap(Deoptimization::Reason_intrinsic,
4838                     Deoptimization::Action_make_not_entrant);
4839       assert(stopped(), &quot;Should be stopped&quot;);
4840     }
4841 
4842     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4843     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4844     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4845   }
4846 
4847   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4848 
4849   if (stopped()) {
4850     return true;
4851   }
4852 
4853   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,
4854                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
4855                                           // so the compiler has a chance to eliminate them: during macro expansion,
4856                                           // we have to set their control (CastPP nodes are eliminated).
4857                                           load_object_klass(src), load_object_klass(dest),
4858                                           load_array_length(src), load_array_length(dest));
4859 
4860   ac-&gt;set_arraycopy(validated);
4861 
4862   Node* n = _gvn.transform(ac);
4863   if (n == ac) {
4864     ac-&gt;connect_outputs(this);
4865   } else {
4866     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4867     set_all_memory(n);
4868   }
4869   clear_upper_avx();
4870 
4871 
4872   return true;
4873 }
4874 
4875 
4876 // Helper function which determines if an arraycopy immediately follows
4877 // an allocation, with no intervening tests or other escapes for the object.
4878 AllocateArrayNode*
4879 LibraryCallKit::tightly_coupled_allocation(Node* ptr,
4880                                            RegionNode* slow_region) {
4881   if (stopped())             return NULL;  // no fast path
4882   if (C-&gt;AliasLevel() == 0)  return NULL;  // no MergeMems around
4883 
4884   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &amp;_gvn);
4885   if (alloc == NULL)  return NULL;
4886 
4887   Node* rawmem = memory(Compile::AliasIdxRaw);
4888   // Is the allocation&#39;s memory state untouched?
4889   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
4890     // Bail out if there have been raw-memory effects since the allocation.
4891     // (Example:  There might have been a call or safepoint.)
4892     return NULL;
4893   }
4894   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
4895   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
4896     return NULL;
4897   }
4898 
4899   // There must be no unexpected observers of this allocation.
4900   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
4901     Node* obs = ptr-&gt;fast_out(i);
4902     if (obs != this-&gt;map()) {
4903       return NULL;
4904     }
4905   }
4906 
4907   // This arraycopy must unconditionally follow the allocation of the ptr.
4908   Node* alloc_ctl = ptr-&gt;in(0);
4909   assert(just_allocated_object(alloc_ctl) == ptr, &quot;most recent allo&quot;);
4910 
4911   Node* ctl = control();
4912   while (ctl != alloc_ctl) {
4913     // There may be guards which feed into the slow_region.
4914     // Any other control flow means that we might not get a chance
4915     // to finish initializing the allocated object.
4916     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
4917       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
4918       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
4919       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
4920       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
4921         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
4922         continue;
4923       }
4924       // One more try:  Various low-level checks bottom out in
4925       // uncommon traps.  If the debug-info of the trap omits
4926       // any reference to the allocation, as we&#39;ve already
4927       // observed, then there can be no objection to the trap.
4928       bool found_trap = false;
4929       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4930         Node* obs = not_ctl-&gt;fast_out(j);
4931         if (obs-&gt;in(0) == not_ctl &amp;&amp; obs-&gt;is_Call() &amp;&amp;
4932             (obs-&gt;as_Call()-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point())) {
4933           found_trap = true; break;
4934         }
4935       }
4936       if (found_trap) {
4937         ctl = iff-&gt;in(0);       // This test feeds a harmless uncommon trap.
4938         continue;
4939       }
4940     }
4941     return NULL;
4942   }
4943 
4944   // If we get this far, we have an allocation which immediately
4945   // precedes the arraycopy, and we can take over zeroing the new object.
4946   // The arraycopy will finish the initialization, and provide
4947   // a new control state to which we will anchor the destination pointer.
4948 
4949   return alloc;
4950 }
4951 
4952 //-------------inline_encodeISOArray-----------------------------------
4953 // encode char[] to byte[] in ISO_8859_1
4954 bool LibraryCallKit::inline_encodeISOArray() {
4955   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
4956   // no receiver since it is static method
4957   Node *src         = argument(0);
4958   Node *src_offset  = argument(1);
4959   Node *dst         = argument(2);
4960   Node *dst_offset  = argument(3);
4961   Node *length      = argument(4);
4962 
4963   src = must_be_not_null(src, true);
4964   dst = must_be_not_null(dst, true);
4965 
4966   const Type* src_type = src-&gt;Value(&amp;_gvn);
4967   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
4968   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
4969   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
4970   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
4971       top_dest == NULL || top_dest-&gt;klass() == NULL) {
4972     // failed array check
4973     return false;
4974   }
4975 
4976   // Figure out the size and type of the elements we will be copying.
4977   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4978   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4979   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
4980     return false;
4981   }
4982 
4983   Node* src_start = array_element_address(src, src_offset, T_CHAR);
4984   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
4985   // &#39;src_start&#39; points to src array + scaled offset
4986   // &#39;dst_start&#39; points to dst array + scaled offset
4987 
4988   const TypeAryPtr* mtype = TypeAryPtr::BYTES;
4989   Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);
4990   enc = _gvn.transform(enc);
4991   Node* res_mem = _gvn.transform(new SCMemProjNode(enc));
4992   set_memory(res_mem, mtype);
4993   set_result(enc);
4994   clear_upper_avx();
4995 
4996   return true;
4997 }
4998 
4999 //-------------inline_multiplyToLen-----------------------------------
5000 bool LibraryCallKit::inline_multiplyToLen() {
5001   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
5002 
5003   address stubAddr = StubRoutines::multiplyToLen();
5004   if (stubAddr == NULL) {
5005     return false; // Intrinsic&#39;s stub is not implemented on this platform
5006   }
5007   const char* stubName = &quot;multiplyToLen&quot;;
5008 
5009   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
5010 
5011   // no receiver because it is a static method
5012   Node* x    = argument(0);
5013   Node* xlen = argument(1);
5014   Node* y    = argument(2);
5015   Node* ylen = argument(3);
5016   Node* z    = argument(4);
5017 
5018   x = must_be_not_null(x, true);
5019   y = must_be_not_null(y, true);
5020 
5021   const Type* x_type = x-&gt;Value(&amp;_gvn);
5022   const Type* y_type = y-&gt;Value(&amp;_gvn);
5023   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5024   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
5025   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5026       top_y == NULL || top_y-&gt;klass() == NULL) {
5027     // failed array check
5028     return false;
5029   }
5030 
5031   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5032   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5033   if (x_elem != T_INT || y_elem != T_INT) {
5034     return false;
5035   }
5036 
5037   // Set the original stack and the reexecute bit for the interpreter to reexecute
5038   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
5039   // on the return from z array allocation in runtime.
5040   { PreserveReexecuteState preexecs(this);
5041     jvms()-&gt;set_should_reexecute(true);
5042 
5043     Node* x_start = array_element_address(x, intcon(0), x_elem);
5044     Node* y_start = array_element_address(y, intcon(0), y_elem);
5045     // &#39;x_start&#39; points to x array + scaled xlen
5046     // &#39;y_start&#39; points to y array + scaled ylen
5047 
5048     // Allocate the result array
5049     Node* zlen = _gvn.transform(new AddINode(xlen, ylen));
5050     ciKlass* klass = ciTypeArrayKlass::make(T_INT);
5051     Node* klass_node = makecon(TypeKlassPtr::make(klass));
5052 
5053     IdealKit ideal(this);
5054 
5055 #define __ ideal.
5056      Node* one = __ ConI(1);
5057      Node* zero = __ ConI(0);
5058      IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();
5059      __ set(need_alloc, zero);
5060      __ set(z_alloc, z);
5061      __ if_then(z, BoolTest::eq, null()); {
5062        __ increment (need_alloc, one);
5063      } __ else_(); {
5064        // Update graphKit memory and control from IdealKit.
5065        sync_kit(ideal);
5066        Node *cast = new CastPPNode(z, TypePtr::NOTNULL);
5067        cast-&gt;init_req(0, control());
5068        _gvn.set_type(cast, cast-&gt;bottom_type());
5069        C-&gt;record_for_igvn(cast);
5070 
5071        Node* zlen_arg = load_array_length(cast);
5072        // Update IdealKit memory and control from graphKit.
5073        __ sync_kit(this);
5074        __ if_then(zlen_arg, BoolTest::lt, zlen); {
5075          __ increment (need_alloc, one);
5076        } __ end_if();
5077      } __ end_if();
5078 
5079      __ if_then(__ value(need_alloc), BoolTest::ne, zero); {
5080        // Update graphKit memory and control from IdealKit.
5081        sync_kit(ideal);
5082        Node * narr = new_array(klass_node, zlen, 1);
5083        // Update IdealKit memory and control from graphKit.
5084        __ sync_kit(this);
5085        __ set(z_alloc, narr);
5086      } __ end_if();
5087 
5088      sync_kit(ideal);
5089      z = __ value(z_alloc);
5090      // Can&#39;t use TypeAryPtr::INTS which uses Bottom offset.
5091      _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));
5092      // Final sync IdealKit and GraphKit.
5093      final_sync(ideal);
5094 #undef __
5095 
5096     Node* z_start = array_element_address(z, intcon(0), T_INT);
5097 
5098     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
5099                                    OptoRuntime::multiplyToLen_Type(),
5100                                    stubAddr, stubName, TypePtr::BOTTOM,
5101                                    x_start, xlen, y_start, ylen, z_start, zlen);
5102   } // original reexecute is set back here
5103 
5104   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
5105   set_result(z);
5106   return true;
5107 }
5108 
5109 //-------------inline_squareToLen------------------------------------
5110 bool LibraryCallKit::inline_squareToLen() {
5111   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5112 
5113   address stubAddr = StubRoutines::squareToLen();
5114   if (stubAddr == NULL) {
5115     return false; // Intrinsic&#39;s stub is not implemented on this platform
5116   }
5117   const char* stubName = &quot;squareToLen&quot;;
5118 
5119   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5120 
5121   Node* x    = argument(0);
5122   Node* len  = argument(1);
5123   Node* z    = argument(2);
5124   Node* zlen = argument(3);
5125 
5126   x = must_be_not_null(x, true);
5127   z = must_be_not_null(z, true);
5128 
5129   const Type* x_type = x-&gt;Value(&amp;_gvn);
5130   const Type* z_type = z-&gt;Value(&amp;_gvn);
5131   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5132   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5133   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5134       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5135     // failed array check
5136     return false;
5137   }
5138 
5139   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5140   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5141   if (x_elem != T_INT || z_elem != T_INT) {
5142     return false;
5143   }
5144 
5145 
5146   Node* x_start = array_element_address(x, intcon(0), x_elem);
5147   Node* z_start = array_element_address(z, intcon(0), z_elem);
5148 
5149   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5150                                   OptoRuntime::squareToLen_Type(),
5151                                   stubAddr, stubName, TypePtr::BOTTOM,
5152                                   x_start, len, z_start, zlen);
5153 
5154   set_result(z);
5155   return true;
5156 }
5157 
5158 //-------------inline_mulAdd------------------------------------------
5159 bool LibraryCallKit::inline_mulAdd() {
5160   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5161 
5162   address stubAddr = StubRoutines::mulAdd();
5163   if (stubAddr == NULL) {
5164     return false; // Intrinsic&#39;s stub is not implemented on this platform
5165   }
5166   const char* stubName = &quot;mulAdd&quot;;
5167 
5168   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5169 
5170   Node* out      = argument(0);
5171   Node* in       = argument(1);
5172   Node* offset   = argument(2);
5173   Node* len      = argument(3);
5174   Node* k        = argument(4);
5175 
5176   out = must_be_not_null(out, true);
5177 
5178   const Type* out_type = out-&gt;Value(&amp;_gvn);
5179   const Type* in_type = in-&gt;Value(&amp;_gvn);
5180   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5181   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5182   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5183       top_in == NULL || top_in-&gt;klass() == NULL) {
5184     // failed array check
5185     return false;
5186   }
5187 
5188   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5189   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5190   if (out_elem != T_INT || in_elem != T_INT) {
5191     return false;
5192   }
5193 
5194   Node* outlen = load_array_length(out);
5195   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5196   Node* out_start = array_element_address(out, intcon(0), out_elem);
5197   Node* in_start = array_element_address(in, intcon(0), in_elem);
5198 
5199   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5200                                   OptoRuntime::mulAdd_Type(),
5201                                   stubAddr, stubName, TypePtr::BOTTOM,
5202                                   out_start,in_start, new_offset, len, k);
5203   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5204   set_result(result);
5205   return true;
5206 }
5207 
5208 //-------------inline_montgomeryMultiply-----------------------------------
5209 bool LibraryCallKit::inline_montgomeryMultiply() {
5210   address stubAddr = StubRoutines::montgomeryMultiply();
5211   if (stubAddr == NULL) {
5212     return false; // Intrinsic&#39;s stub is not implemented on this platform
5213   }
5214 
5215   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5216   const char* stubName = &quot;montgomery_multiply&quot;;
5217 
5218   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5219 
5220   Node* a    = argument(0);
5221   Node* b    = argument(1);
5222   Node* n    = argument(2);
5223   Node* len  = argument(3);
5224   Node* inv  = argument(4);
5225   Node* m    = argument(6);
5226 
5227   const Type* a_type = a-&gt;Value(&amp;_gvn);
5228   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5229   const Type* b_type = b-&gt;Value(&amp;_gvn);
5230   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5231   const Type* n_type = a-&gt;Value(&amp;_gvn);
5232   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5233   const Type* m_type = a-&gt;Value(&amp;_gvn);
5234   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5235   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5236       top_b == NULL || top_b-&gt;klass()  == NULL ||
5237       top_n == NULL || top_n-&gt;klass()  == NULL ||
5238       top_m == NULL || top_m-&gt;klass()  == NULL) {
5239     // failed array check
5240     return false;
5241   }
5242 
5243   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5244   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5245   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5246   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5247   if (a_elem != T_INT || b_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5248     return false;
5249   }
5250 
5251   // Make the call
5252   {
5253     Node* a_start = array_element_address(a, intcon(0), a_elem);
5254     Node* b_start = array_element_address(b, intcon(0), b_elem);
5255     Node* n_start = array_element_address(n, intcon(0), n_elem);
5256     Node* m_start = array_element_address(m, intcon(0), m_elem);
5257 
5258     Node* call = make_runtime_call(RC_LEAF,
5259                                    OptoRuntime::montgomeryMultiply_Type(),
5260                                    stubAddr, stubName, TypePtr::BOTTOM,
5261                                    a_start, b_start, n_start, len, inv, top(),
5262                                    m_start);
5263     set_result(m);
5264   }
5265 
5266   return true;
5267 }
5268 
5269 bool LibraryCallKit::inline_montgomerySquare() {
5270   address stubAddr = StubRoutines::montgomerySquare();
5271   if (stubAddr == NULL) {
5272     return false; // Intrinsic&#39;s stub is not implemented on this platform
5273   }
5274 
5275   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5276   const char* stubName = &quot;montgomery_square&quot;;
5277 
5278   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5279 
5280   Node* a    = argument(0);
5281   Node* n    = argument(1);
5282   Node* len  = argument(2);
5283   Node* inv  = argument(3);
5284   Node* m    = argument(5);
5285 
5286   const Type* a_type = a-&gt;Value(&amp;_gvn);
5287   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5288   const Type* n_type = a-&gt;Value(&amp;_gvn);
5289   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5290   const Type* m_type = a-&gt;Value(&amp;_gvn);
5291   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5292   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5293       top_n == NULL || top_n-&gt;klass()  == NULL ||
5294       top_m == NULL || top_m-&gt;klass()  == NULL) {
5295     // failed array check
5296     return false;
5297   }
5298 
5299   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5300   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5301   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5302   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5303     return false;
5304   }
5305 
5306   // Make the call
5307   {
5308     Node* a_start = array_element_address(a, intcon(0), a_elem);
5309     Node* n_start = array_element_address(n, intcon(0), n_elem);
5310     Node* m_start = array_element_address(m, intcon(0), m_elem);
5311 
5312     Node* call = make_runtime_call(RC_LEAF,
5313                                    OptoRuntime::montgomerySquare_Type(),
5314                                    stubAddr, stubName, TypePtr::BOTTOM,
5315                                    a_start, n_start, len, inv, top(),
5316                                    m_start);
5317     set_result(m);
5318   }
5319 
5320   return true;
5321 }
5322 
5323 bool LibraryCallKit::inline_bigIntegerShift(bool isRightShift) {
5324   address stubAddr = NULL;
5325   const char* stubName = NULL;
5326 
5327   stubAddr = isRightShift? StubRoutines::bigIntegerRightShift(): StubRoutines::bigIntegerLeftShift();
5328   if (stubAddr == NULL) {
5329     return false; // Intrinsic&#39;s stub is not implemented on this platform
5330   }
5331 
5332   stubName = isRightShift? &quot;bigIntegerRightShiftWorker&quot; : &quot;bigIntegerLeftShiftWorker&quot;;
5333 
5334   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;expected 5 arguments&quot;);
5335 
5336   Node* newArr = argument(0);
5337   Node* oldArr = argument(1);
5338   Node* newIdx = argument(2);
5339   Node* shiftCount = argument(3);
5340   Node* numIter = argument(4);
5341 
5342   const Type* newArr_type = newArr-&gt;Value(&amp;_gvn);
5343   const TypeAryPtr* top_newArr = newArr_type-&gt;isa_aryptr();
5344   const Type* oldArr_type = oldArr-&gt;Value(&amp;_gvn);
5345   const TypeAryPtr* top_oldArr = oldArr_type-&gt;isa_aryptr();
5346   if (top_newArr == NULL || top_newArr-&gt;klass() == NULL || top_oldArr == NULL
5347       || top_oldArr-&gt;klass() == NULL) {
5348     return false;
5349   }
5350 
5351   BasicType newArr_elem = newArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5352   BasicType oldArr_elem = oldArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5353   if (newArr_elem != T_INT || oldArr_elem != T_INT) {
5354     return false;
5355   }
5356 
5357   // Make the call
5358   {
5359     Node* newArr_start = array_element_address(newArr, intcon(0), newArr_elem);
5360     Node* oldArr_start = array_element_address(oldArr, intcon(0), oldArr_elem);
5361 
5362     Node* call = make_runtime_call(RC_LEAF,
5363                                    OptoRuntime::bigIntegerShift_Type(),
5364                                    stubAddr,
5365                                    stubName,
5366                                    TypePtr::BOTTOM,
5367                                    newArr_start,
5368                                    oldArr_start,
5369                                    newIdx,
5370                                    shiftCount,
5371                                    numIter);
5372   }
5373 
5374   return true;
5375 }
5376 
5377 //-------------inline_vectorizedMismatch------------------------------
5378 bool LibraryCallKit::inline_vectorizedMismatch() {
5379   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5380 
5381   address stubAddr = StubRoutines::vectorizedMismatch();
5382   if (stubAddr == NULL) {
5383     return false; // Intrinsic&#39;s stub is not implemented on this platform
5384   }
5385   const char* stubName = &quot;vectorizedMismatch&quot;;
5386   int size_l = callee()-&gt;signature()-&gt;size();
5387   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5388 
5389   Node* obja = argument(0);
5390   Node* aoffset = argument(1);
5391   Node* objb = argument(3);
5392   Node* boffset = argument(4);
5393   Node* length = argument(6);
5394   Node* scale = argument(7);
5395 
5396   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5397   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5398   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5399   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5400   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5401     top_b == NULL || top_b-&gt;klass() == NULL) {
5402     // failed array check
5403     return false;
5404   }
5405 
5406   Node* call;
5407   jvms()-&gt;set_should_reexecute(true);
5408 
5409   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5410   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5411 
5412   call = make_runtime_call(RC_LEAF,
5413     OptoRuntime::vectorizedMismatch_Type(),
5414     stubAddr, stubName, TypePtr::BOTTOM,
5415     obja_adr, objb_adr, length, scale);
5416 
5417   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5418   set_result(result);
5419   return true;
5420 }
5421 
5422 /**
5423  * Calculate CRC32 for byte.
5424  * int java.util.zip.CRC32.update(int crc, int b)
5425  */
5426 bool LibraryCallKit::inline_updateCRC32() {
5427   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5428   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
5429   // no receiver since it is static method
5430   Node* crc  = argument(0); // type: int
5431   Node* b    = argument(1); // type: int
5432 
5433   /*
5434    *    int c = ~ crc;
5435    *    b = timesXtoThe32[(b ^ c) &amp; 0xFF];
5436    *    b = b ^ (c &gt;&gt;&gt; 8);
5437    *    crc = ~b;
5438    */
5439 
5440   Node* M1 = intcon(-1);
5441   crc = _gvn.transform(new XorINode(crc, M1));
5442   Node* result = _gvn.transform(new XorINode(crc, b));
5443   result = _gvn.transform(new AndINode(result, intcon(0xFF)));
5444 
5445   Node* base = makecon(TypeRawPtr::make(StubRoutines::crc_table_addr()));
5446   Node* offset = _gvn.transform(new LShiftINode(result, intcon(0x2)));
5447   Node* adr = basic_plus_adr(top(), base, ConvI2X(offset));
5448   result = make_load(control(), adr, TypeInt::INT, T_INT, MemNode::unordered);
5449 
5450   crc = _gvn.transform(new URShiftINode(crc, intcon(8)));
5451   result = _gvn.transform(new XorINode(crc, result));
5452   result = _gvn.transform(new XorINode(result, M1));
5453   set_result(result);
5454   return true;
5455 }
5456 
5457 /**
5458  * Calculate CRC32 for byte[] array.
5459  * int java.util.zip.CRC32.updateBytes(int crc, byte[] buf, int off, int len)
5460  */
5461 bool LibraryCallKit::inline_updateBytesCRC32() {
5462   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5463   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5464   // no receiver since it is static method
5465   Node* crc     = argument(0); // type: int
5466   Node* src     = argument(1); // type: oop
5467   Node* offset  = argument(2); // type: int
5468   Node* length  = argument(3); // type: int
5469 
5470   const Type* src_type = src-&gt;Value(&amp;_gvn);
5471   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5472   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5473     // failed array check
5474     return false;
5475   }
5476 
5477   // Figure out the size and type of the elements we will be copying.
5478   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5479   if (src_elem != T_BYTE) {
5480     return false;
5481   }
5482 
5483   // &#39;src_start&#39; points to src array + scaled offset
5484   src = must_be_not_null(src, true);
5485   Node* src_start = array_element_address(src, offset, src_elem);
5486 
5487   // We assume that range check is done by caller.
5488   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5489 
5490   // Call the stub.
5491   address stubAddr = StubRoutines::updateBytesCRC32();
5492   const char *stubName = &quot;updateBytesCRC32&quot;;
5493 
5494   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5495                                  stubAddr, stubName, TypePtr::BOTTOM,
5496                                  crc, src_start, length);
5497   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5498   set_result(result);
5499   return true;
5500 }
5501 
5502 /**
5503  * Calculate CRC32 for ByteBuffer.
5504  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
5505  */
5506 bool LibraryCallKit::inline_updateByteBufferCRC32() {
5507   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5508   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5509   // no receiver since it is static method
5510   Node* crc     = argument(0); // type: int
5511   Node* src     = argument(1); // type: long
5512   Node* offset  = argument(3); // type: int
5513   Node* length  = argument(4); // type: int
5514 
5515   src = ConvL2X(src);  // adjust Java long to machine word
5516   Node* base = _gvn.transform(new CastX2PNode(src));
5517   offset = ConvI2X(offset);
5518 
5519   // &#39;src_start&#39; points to src array + scaled offset
5520   Node* src_start = basic_plus_adr(top(), base, offset);
5521 
5522   // Call the stub.
5523   address stubAddr = StubRoutines::updateBytesCRC32();
5524   const char *stubName = &quot;updateBytesCRC32&quot;;
5525 
5526   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5527                                  stubAddr, stubName, TypePtr::BOTTOM,
5528                                  crc, src_start, length);
5529   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5530   set_result(result);
5531   return true;
5532 }
5533 
5534 //------------------------------get_table_from_crc32c_class-----------------------
5535 Node * LibraryCallKit::get_table_from_crc32c_class(ciInstanceKlass *crc32c_class) {
5536   Node* table = load_field_from_object(NULL, &quot;byteTable&quot;, &quot;[I&quot;, /*is_exact*/ false, /*is_static*/ true, crc32c_class);
5537   assert (table != NULL, &quot;wrong version of java.util.zip.CRC32C&quot;);
5538 
5539   return table;
5540 }
5541 
5542 //------------------------------inline_updateBytesCRC32C-----------------------
5543 //
5544 // Calculate CRC32C for byte[] array.
5545 // int java.util.zip.CRC32C.updateBytes(int crc, byte[] buf, int off, int end)
5546 //
5547 bool LibraryCallKit::inline_updateBytesCRC32C() {
5548   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5549   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5550   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5551   // no receiver since it is a static method
5552   Node* crc     = argument(0); // type: int
5553   Node* src     = argument(1); // type: oop
5554   Node* offset  = argument(2); // type: int
5555   Node* end     = argument(3); // type: int
5556 
5557   Node* length = _gvn.transform(new SubINode(end, offset));
5558 
5559   const Type* src_type = src-&gt;Value(&amp;_gvn);
5560   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5561   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5562     // failed array check
5563     return false;
5564   }
5565 
5566   // Figure out the size and type of the elements we will be copying.
5567   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5568   if (src_elem != T_BYTE) {
5569     return false;
5570   }
5571 
5572   // &#39;src_start&#39; points to src array + scaled offset
5573   src = must_be_not_null(src, true);
5574   Node* src_start = array_element_address(src, offset, src_elem);
5575 
5576   // static final int[] byteTable in class CRC32C
5577   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5578   table = must_be_not_null(table, true);
5579   Node* table_start = array_element_address(table, intcon(0), T_INT);
5580 
5581   // We assume that range check is done by caller.
5582   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5583 
5584   // Call the stub.
5585   address stubAddr = StubRoutines::updateBytesCRC32C();
5586   const char *stubName = &quot;updateBytesCRC32C&quot;;
5587 
5588   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5589                                  stubAddr, stubName, TypePtr::BOTTOM,
5590                                  crc, src_start, length, table_start);
5591   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5592   set_result(result);
5593   return true;
5594 }
5595 
5596 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5597 //
5598 // Calculate CRC32C for DirectByteBuffer.
5599 // int java.util.zip.CRC32C.updateDirectByteBuffer(int crc, long buf, int off, int end)
5600 //
5601 bool LibraryCallKit::inline_updateDirectByteBufferCRC32C() {
5602   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5603   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5604   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5605   // no receiver since it is a static method
5606   Node* crc     = argument(0); // type: int
5607   Node* src     = argument(1); // type: long
5608   Node* offset  = argument(3); // type: int
5609   Node* end     = argument(4); // type: int
5610 
5611   Node* length = _gvn.transform(new SubINode(end, offset));
5612 
5613   src = ConvL2X(src);  // adjust Java long to machine word
5614   Node* base = _gvn.transform(new CastX2PNode(src));
5615   offset = ConvI2X(offset);
5616 
5617   // &#39;src_start&#39; points to src array + scaled offset
5618   Node* src_start = basic_plus_adr(top(), base, offset);
5619 
5620   // static final int[] byteTable in class CRC32C
5621   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5622   table = must_be_not_null(table, true);
5623   Node* table_start = array_element_address(table, intcon(0), T_INT);
5624 
5625   // Call the stub.
5626   address stubAddr = StubRoutines::updateBytesCRC32C();
5627   const char *stubName = &quot;updateBytesCRC32C&quot;;
5628 
5629   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5630                                  stubAddr, stubName, TypePtr::BOTTOM,
5631                                  crc, src_start, length, table_start);
5632   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5633   set_result(result);
5634   return true;
5635 }
5636 
5637 //------------------------------inline_updateBytesAdler32----------------------
5638 //
5639 // Calculate Adler32 checksum for byte[] array.
5640 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5641 //
5642 bool LibraryCallKit::inline_updateBytesAdler32() {
5643   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5644   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5645   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5646   // no receiver since it is static method
5647   Node* crc     = argument(0); // type: int
5648   Node* src     = argument(1); // type: oop
5649   Node* offset  = argument(2); // type: int
5650   Node* length  = argument(3); // type: int
5651 
5652   const Type* src_type = src-&gt;Value(&amp;_gvn);
5653   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5654   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5655     // failed array check
5656     return false;
5657   }
5658 
5659   // Figure out the size and type of the elements we will be copying.
5660   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5661   if (src_elem != T_BYTE) {
5662     return false;
5663   }
5664 
5665   // &#39;src_start&#39; points to src array + scaled offset
5666   Node* src_start = array_element_address(src, offset, src_elem);
5667 
5668   // We assume that range check is done by caller.
5669   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5670 
5671   // Call the stub.
5672   address stubAddr = StubRoutines::updateBytesAdler32();
5673   const char *stubName = &quot;updateBytesAdler32&quot;;
5674 
5675   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5676                                  stubAddr, stubName, TypePtr::BOTTOM,
5677                                  crc, src_start, length);
5678   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5679   set_result(result);
5680   return true;
5681 }
5682 
5683 //------------------------------inline_updateByteBufferAdler32---------------
5684 //
5685 // Calculate Adler32 checksum for DirectByteBuffer.
5686 // int java.util.zip.Adler32.updateByteBuffer(int crc, long buf, int off, int len)
5687 //
5688 bool LibraryCallKit::inline_updateByteBufferAdler32() {
5689   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5690   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5691   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5692   // no receiver since it is static method
5693   Node* crc     = argument(0); // type: int
5694   Node* src     = argument(1); // type: long
5695   Node* offset  = argument(3); // type: int
5696   Node* length  = argument(4); // type: int
5697 
5698   src = ConvL2X(src);  // adjust Java long to machine word
5699   Node* base = _gvn.transform(new CastX2PNode(src));
5700   offset = ConvI2X(offset);
5701 
5702   // &#39;src_start&#39; points to src array + scaled offset
5703   Node* src_start = basic_plus_adr(top(), base, offset);
5704 
5705   // Call the stub.
5706   address stubAddr = StubRoutines::updateBytesAdler32();
5707   const char *stubName = &quot;updateBytesAdler32&quot;;
5708 
5709   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5710                                  stubAddr, stubName, TypePtr::BOTTOM,
5711                                  crc, src_start, length);
5712 
5713   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5714   set_result(result);
5715   return true;
5716 }
5717 
5718 //----------------------------inline_reference_get----------------------------
5719 // public T java.lang.ref.Reference.get();
5720 bool LibraryCallKit::inline_reference_get() {
5721   const int referent_offset = java_lang_ref_Reference::referent_offset;
5722   guarantee(referent_offset &gt; 0, &quot;should have already been set&quot;);
5723 
5724   // Get the argument:
5725   Node* reference_obj = null_check_receiver();
5726   if (stopped()) return true;
5727 
5728   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
5729   assert(tinst != NULL, &quot;obj is null&quot;);
5730   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5731   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
5732   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
5733                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
5734                                                      false);
5735   assert (field != NULL, &quot;undefined field&quot;);
5736 
5737   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
5738   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5739 
5740   ciInstanceKlass* klass = env()-&gt;Object_klass();
5741   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
5742 
5743   DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;
5744   Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);
5745   // Add memory barrier to prevent commoning reads from this field
5746   // across safepoint since GC can change its value.
5747   insert_mem_bar(Op_MemBarCPUOrder);
5748 
5749   set_result(result);
5750   return true;
5751 }
5752 
5753 
5754 Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5755                                               bool is_exact=true, bool is_static=false,
5756                                               ciInstanceKlass * fromKls=NULL) {
5757   if (fromKls == NULL) {
5758     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5759     assert(tinst != NULL, &quot;obj is null&quot;);
5760     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5761     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5762     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5763   } else {
5764     assert(is_static, &quot;only for static field access&quot;);
5765   }
5766   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5767                                               ciSymbol::make(fieldTypeString),
5768                                               is_static);
5769 
5770   assert (field != NULL, &quot;undefined field&quot;);
5771   if (field == NULL) return (Node *) NULL;
5772 
5773   if (is_static) {
5774     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5775     fromObj = makecon(tip);
5776   }
5777 
5778   // Next code  copied from Parse::do_get_xxx():
5779 
5780   // Compute address and memory type.
5781   int offset  = field-&gt;offset_in_bytes();
5782   bool is_vol = field-&gt;is_volatile();
5783   ciType* field_klass = field-&gt;type();
5784   assert(field_klass-&gt;is_loaded(), &quot;should be loaded&quot;);
5785   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5786   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5787   BasicType bt = field-&gt;layout_type();
5788 
5789   // Build the resultant type of the load
5790   const Type *type;
5791   if (bt == T_OBJECT) {
5792     type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
5793   } else {
5794     type = Type::get_const_basic_type(bt);
5795   }
5796 
5797   DecoratorSet decorators = IN_HEAP;
5798 
5799   if (is_vol) {
5800     decorators |= MO_SEQ_CST;
5801   }
5802 
5803   return access_load_at(fromObj, adr, adr_type, type, bt, decorators);
5804 }
5805 
5806 Node * LibraryCallKit::field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5807                                                  bool is_exact = true, bool is_static = false,
5808                                                  ciInstanceKlass * fromKls = NULL) {
5809   if (fromKls == NULL) {
5810     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5811     assert(tinst != NULL, &quot;obj is null&quot;);
5812     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5813     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5814     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5815   }
5816   else {
5817     assert(is_static, &quot;only for static field access&quot;);
5818   }
5819   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5820     ciSymbol::make(fieldTypeString),
5821     is_static);
5822 
5823   assert(field != NULL, &quot;undefined field&quot;);
5824   assert(!field-&gt;is_volatile(), &quot;not defined for volatile fields&quot;);
5825 
5826   if (is_static) {
5827     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5828     fromObj = makecon(tip);
5829   }
5830 
5831   // Next code  copied from Parse::do_get_xxx():
5832 
5833   // Compute address and memory type.
5834   int offset = field-&gt;offset_in_bytes();
5835   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5836 
5837   return adr;
5838 }
5839 
5840 //------------------------------inline_aescrypt_Block-----------------------
5841 bool LibraryCallKit::inline_aescrypt_Block(vmIntrinsics::ID id) {
5842   address stubAddr = NULL;
5843   const char *stubName;
5844   assert(UseAES, &quot;need AES instruction support&quot;);
5845 
5846   switch(id) {
5847   case vmIntrinsics::_aescrypt_encryptBlock:
5848     stubAddr = StubRoutines::aescrypt_encryptBlock();
5849     stubName = &quot;aescrypt_encryptBlock&quot;;
5850     break;
5851   case vmIntrinsics::_aescrypt_decryptBlock:
5852     stubAddr = StubRoutines::aescrypt_decryptBlock();
5853     stubName = &quot;aescrypt_decryptBlock&quot;;
5854     break;
5855   default:
5856     break;
5857   }
5858   if (stubAddr == NULL) return false;
5859 
5860   Node* aescrypt_object = argument(0);
5861   Node* src             = argument(1);
5862   Node* src_offset      = argument(2);
5863   Node* dest            = argument(3);
5864   Node* dest_offset     = argument(4);
5865 
5866   src = must_be_not_null(src, true);
5867   dest = must_be_not_null(dest, true);
5868 
5869   // (1) src and dest are arrays.
5870   const Type* src_type = src-&gt;Value(&amp;_gvn);
5871   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5872   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5873   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5874   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5875 
5876   // for the quick and dirty code we will skip all the checks.
5877   // we are just trying to get the call to be generated.
5878   Node* src_start  = src;
5879   Node* dest_start = dest;
5880   if (src_offset != NULL || dest_offset != NULL) {
5881     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5882     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5883     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5884   }
5885 
5886   // now need to get the start of its expanded key array
5887   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5888   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5889   if (k_start == NULL) return false;
5890 
5891   if (Matcher::pass_original_key_for_aes()) {
5892     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5893     // compatibility issues between Java key expansion and SPARC crypto instructions
5894     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5895     if (original_k_start == NULL) return false;
5896 
5897     // Call the stub.
5898     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5899                       stubAddr, stubName, TypePtr::BOTTOM,
5900                       src_start, dest_start, k_start, original_k_start);
5901   } else {
5902     // Call the stub.
5903     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5904                       stubAddr, stubName, TypePtr::BOTTOM,
5905                       src_start, dest_start, k_start);
5906   }
5907 
5908   return true;
5909 }
5910 
5911 //------------------------------inline_cipherBlockChaining_AESCrypt-----------------------
5912 bool LibraryCallKit::inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id) {
5913   address stubAddr = NULL;
5914   const char *stubName = NULL;
5915 
5916   assert(UseAES, &quot;need AES instruction support&quot;);
5917 
5918   switch(id) {
5919   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
5920     stubAddr = StubRoutines::cipherBlockChaining_encryptAESCrypt();
5921     stubName = &quot;cipherBlockChaining_encryptAESCrypt&quot;;
5922     break;
5923   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
5924     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
5925     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
5926     break;
5927   default:
5928     break;
5929   }
5930   if (stubAddr == NULL) return false;
5931 
5932   Node* cipherBlockChaining_object = argument(0);
5933   Node* src                        = argument(1);
5934   Node* src_offset                 = argument(2);
5935   Node* len                        = argument(3);
5936   Node* dest                       = argument(4);
5937   Node* dest_offset                = argument(5);
5938 
5939   src = must_be_not_null(src, false);
5940   dest = must_be_not_null(dest, false);
5941 
5942   // (1) src and dest are arrays.
5943   const Type* src_type = src-&gt;Value(&amp;_gvn);
5944   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5945   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5946   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5947   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
5948           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5949 
5950   // checks are the responsibility of the caller
5951   Node* src_start  = src;
5952   Node* dest_start = dest;
5953   if (src_offset != NULL || dest_offset != NULL) {
5954     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5955     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5956     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5957   }
5958 
5959   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
5960   // (because of the predicated logic executed earlier).
5961   // so we cast it here safely.
5962   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5963 
5964   Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
5965   if (embeddedCipherObj == NULL) return false;
5966 
5967   // cast it to what we know it will be at runtime
5968   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
5969   assert(tinst != NULL, &quot;CBC obj is null&quot;);
5970   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
5971   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
5972   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
5973 
5974   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
5975   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
5976   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
5977   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
5978   aescrypt_object = _gvn.transform(aescrypt_object);
5979 
5980   // we need to get the start of the aescrypt_object&#39;s expanded key array
5981   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5982   if (k_start == NULL) return false;
5983 
5984   // similarly, get the start address of the r vector
5985   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
5986   if (objRvec == NULL) return false;
5987   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
5988 
5989   Node* cbcCrypt;
5990   if (Matcher::pass_original_key_for_aes()) {
5991     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5992     // compatibility issues between Java key expansion and SPARC crypto instructions
5993     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5994     if (original_k_start == NULL) return false;
5995 
5996     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
5997     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5998                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5999                                  stubAddr, stubName, TypePtr::BOTTOM,
6000                                  src_start, dest_start, k_start, r_start, len, original_k_start);
6001   } else {
6002     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6003     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6004                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
6005                                  stubAddr, stubName, TypePtr::BOTTOM,
6006                                  src_start, dest_start, k_start, r_start, len);
6007   }
6008 
6009   // return cipher length (int)
6010   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
6011   set_result(retvalue);
6012   return true;
6013 }
6014 
6015 //------------------------------inline_electronicCodeBook_AESCrypt-----------------------
6016 bool LibraryCallKit::inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id) {
6017   address stubAddr = NULL;
6018   const char *stubName = NULL;
6019 
6020   assert(UseAES, &quot;need AES instruction support&quot;);
6021 
6022   switch (id) {
6023   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
6024     stubAddr = StubRoutines::electronicCodeBook_encryptAESCrypt();
6025     stubName = &quot;electronicCodeBook_encryptAESCrypt&quot;;
6026     break;
6027   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
6028     stubAddr = StubRoutines::electronicCodeBook_decryptAESCrypt();
6029     stubName = &quot;electronicCodeBook_decryptAESCrypt&quot;;
6030     break;
6031   default:
6032     break;
6033   }
6034 
6035   if (stubAddr == NULL) return false;
6036 
6037   Node* electronicCodeBook_object = argument(0);
6038   Node* src                       = argument(1);
6039   Node* src_offset                = argument(2);
6040   Node* len                       = argument(3);
6041   Node* dest                      = argument(4);
6042   Node* dest_offset               = argument(5);
6043 
6044   // (1) src and dest are arrays.
6045   const Type* src_type = src-&gt;Value(&amp;_gvn);
6046   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6047   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6048   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6049   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL
6050          &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6051 
6052   // checks are the responsibility of the caller
6053   Node* src_start = src;
6054   Node* dest_start = dest;
6055   if (src_offset != NULL || dest_offset != NULL) {
6056     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6057     src_start = array_element_address(src, src_offset, T_BYTE);
6058     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6059   }
6060 
6061   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6062   // (because of the predicated logic executed earlier).
6063   // so we cast it here safely.
6064   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6065 
6066   Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6067   if (embeddedCipherObj == NULL) return false;
6068 
6069   // cast it to what we know it will be at runtime
6070   const TypeInstPtr* tinst = _gvn.type(electronicCodeBook_object)-&gt;isa_instptr();
6071   assert(tinst != NULL, &quot;ECB obj is null&quot;);
6072   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECB obj is not loaded&quot;);
6073   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6074   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6075 
6076   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6077   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6078   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6079   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6080   aescrypt_object = _gvn.transform(aescrypt_object);
6081 
6082   // we need to get the start of the aescrypt_object&#39;s expanded key array
6083   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6084   if (k_start == NULL) return false;
6085 
6086   Node* ecbCrypt;
6087   if (Matcher::pass_original_key_for_aes()) {
6088     // no SPARC version for AES/ECB intrinsics now.
6089     return false;
6090   }
6091   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6092   ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,
6093                                OptoRuntime::electronicCodeBook_aescrypt_Type(),
6094                                stubAddr, stubName, TypePtr::BOTTOM,
6095                                src_start, dest_start, k_start, len);
6096 
6097   // return cipher length (int)
6098   Node* retvalue = _gvn.transform(new ProjNode(ecbCrypt, TypeFunc::Parms));
6099   set_result(retvalue);
6100   return true;
6101 }
6102 
6103 //------------------------------inline_counterMode_AESCrypt-----------------------
6104 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
6105   assert(UseAES, &quot;need AES instruction support&quot;);
6106   if (!UseAESCTRIntrinsics) return false;
6107 
6108   address stubAddr = NULL;
6109   const char *stubName = NULL;
6110   if (id == vmIntrinsics::_counterMode_AESCrypt) {
6111     stubAddr = StubRoutines::counterMode_AESCrypt();
6112     stubName = &quot;counterMode_AESCrypt&quot;;
6113   }
6114   if (stubAddr == NULL) return false;
6115 
6116   Node* counterMode_object = argument(0);
6117   Node* src = argument(1);
6118   Node* src_offset = argument(2);
6119   Node* len = argument(3);
6120   Node* dest = argument(4);
6121   Node* dest_offset = argument(5);
6122 
6123   // (1) src and dest are arrays.
6124   const Type* src_type = src-&gt;Value(&amp;_gvn);
6125   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6126   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6127   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6128   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6129          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6130 
6131   // checks are the responsibility of the caller
6132   Node* src_start = src;
6133   Node* dest_start = dest;
6134   if (src_offset != NULL || dest_offset != NULL) {
6135     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6136     src_start = array_element_address(src, src_offset, T_BYTE);
6137     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6138   }
6139 
6140   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6141   // (because of the predicated logic executed earlier).
6142   // so we cast it here safely.
6143   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6144   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6145   if (embeddedCipherObj == NULL) return false;
6146   // cast it to what we know it will be at runtime
6147   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6148   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6149   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6150   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6151   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6152   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6153   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6154   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6155   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6156   aescrypt_object = _gvn.transform(aescrypt_object);
6157   // we need to get the start of the aescrypt_object&#39;s expanded key array
6158   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6159   if (k_start == NULL) return false;
6160   // similarly, get the start address of the r vector
6161   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6162   if (obj_counter == NULL) return false;
6163   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6164 
6165   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6166   if (saved_encCounter == NULL) return false;
6167   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6168   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6169 
6170   Node* ctrCrypt;
6171   if (Matcher::pass_original_key_for_aes()) {
6172     // no SPARC version for AES/CTR intrinsics now.
6173     return false;
6174   }
6175   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6176   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6177                                OptoRuntime::counterMode_aescrypt_Type(),
6178                                stubAddr, stubName, TypePtr::BOTTOM,
6179                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6180 
6181   // return cipher length (int)
6182   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6183   set_result(retvalue);
6184   return true;
6185 }
6186 
6187 //------------------------------get_key_start_from_aescrypt_object-----------------------
6188 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6189 #if defined(PPC64) || defined(S390)
6190   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6191   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6192   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6193   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6194   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6195   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6196   if (objSessionK == NULL) {
6197     return (Node *) NULL;
6198   }
6199   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6200 #else
6201   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6202 #endif // PPC64
6203   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6204   if (objAESCryptKey == NULL) return (Node *) NULL;
6205 
6206   // now have the array, need to get the start address of the K array
6207   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6208   return k_start;
6209 }
6210 
6211 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6212 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6213   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6214   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6215   if (objAESCryptKey == NULL) return (Node *) NULL;
6216 
6217   // now have the array, need to get the start address of the lastKey array
6218   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6219   return original_k_start;
6220 }
6221 
6222 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6223 // Return node representing slow path of predicate check.
6224 // the pseudo code we want to emulate with this predicate is:
6225 // for encryption:
6226 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6227 // for decryption:
6228 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6229 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6230 //
6231 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6232   // The receiver was checked for NULL already.
6233   Node* objCBC = argument(0);
6234 
6235   Node* src = argument(1);
6236   Node* dest = argument(4);
6237 
6238   // Load embeddedCipher field of CipherBlockChaining object.
6239   Node* embeddedCipherObj = load_field_from_object(objCBC, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6240 
6241   // get AESCrypt klass for instanceOf check
6242   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6243   // will have same classloader as CipherBlockChaining object
6244   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6245   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6246   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6247 
6248   // we want to do an instanceof comparison against the AESCrypt class
6249   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6250   if (!klass_AESCrypt-&gt;is_loaded()) {
6251     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6252     Node* ctrl = control();
6253     set_control(top()); // no regular fast path
6254     return ctrl;
6255   }
6256 
6257   src = must_be_not_null(src, true);
6258   dest = must_be_not_null(dest, true);
6259 
6260   // Resolve oops to stable for CmpP below.
6261   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6262 
6263   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6264   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6265   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6266 
6267   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6268 
6269   // for encryption, we are done
6270   if (!decrypting)
6271     return instof_false;  // even if it is NULL
6272 
6273   // for decryption, we need to add a further check to avoid
6274   // taking the intrinsic path when cipher and plain are the same
6275   // see the original java code for why.
6276   RegionNode* region = new RegionNode(3);
6277   region-&gt;init_req(1, instof_false);
6278 
6279   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6280   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6281   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6282   region-&gt;init_req(2, src_dest_conjoint);
6283 
6284   record_for_igvn(region);
6285   return _gvn.transform(region);
6286 }
6287 
6288 //----------------------------inline_electronicCodeBook_AESCrypt_predicate----------------------------
6289 // Return node representing slow path of predicate check.
6290 // the pseudo code we want to emulate with this predicate is:
6291 // for encryption:
6292 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6293 // for decryption:
6294 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6295 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6296 //
6297 Node* LibraryCallKit::inline_electronicCodeBook_AESCrypt_predicate(bool decrypting) {
6298   // The receiver was checked for NULL already.
6299   Node* objECB = argument(0);
6300 
6301   // Load embeddedCipher field of ElectronicCodeBook object.
6302   Node* embeddedCipherObj = load_field_from_object(objECB, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6303 
6304   // get AESCrypt klass for instanceOf check
6305   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6306   // will have same classloader as ElectronicCodeBook object
6307   const TypeInstPtr* tinst = _gvn.type(objECB)-&gt;isa_instptr();
6308   assert(tinst != NULL, &quot;ECBobj is null&quot;);
6309   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECBobj is not loaded&quot;);
6310 
6311   // we want to do an instanceof comparison against the AESCrypt class
6312   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6313   if (!klass_AESCrypt-&gt;is_loaded()) {
6314     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6315     Node* ctrl = control();
6316     set_control(top()); // no regular fast path
6317     return ctrl;
6318   }
6319   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6320 
6321   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6322   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6323   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6324 
6325   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6326 
6327   // for encryption, we are done
6328   if (!decrypting)
6329     return instof_false;  // even if it is NULL
6330 
6331   // for decryption, we need to add a further check to avoid
6332   // taking the intrinsic path when cipher and plain are the same
6333   // see the original java code for why.
6334   RegionNode* region = new RegionNode(3);
6335   region-&gt;init_req(1, instof_false);
6336   Node* src = argument(1);
6337   Node* dest = argument(4);
6338   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6339   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6340   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6341   region-&gt;init_req(2, src_dest_conjoint);
6342 
6343   record_for_igvn(region);
6344   return _gvn.transform(region);
6345 }
6346 
6347 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6348 // Return node representing slow path of predicate check.
6349 // the pseudo code we want to emulate with this predicate is:
6350 // for encryption:
6351 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6352 // for decryption:
6353 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6354 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6355 //
6356 
6357 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6358   // The receiver was checked for NULL already.
6359   Node* objCTR = argument(0);
6360 
6361   // Load embeddedCipher field of CipherBlockChaining object.
6362   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6363 
6364   // get AESCrypt klass for instanceOf check
6365   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6366   // will have same classloader as CipherBlockChaining object
6367   const TypeInstPtr* tinst = _gvn.type(objCTR)-&gt;isa_instptr();
6368   assert(tinst != NULL, &quot;CTRobj is null&quot;);
6369   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTRobj is not loaded&quot;);
6370 
6371   // we want to do an instanceof comparison against the AESCrypt class
6372   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6373   if (!klass_AESCrypt-&gt;is_loaded()) {
6374     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6375     Node* ctrl = control();
6376     set_control(top()); // no regular fast path
6377     return ctrl;
6378   }
6379 
6380   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6381   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6382   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6383   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6384   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6385 
6386   return instof_false; // even if it is NULL
6387 }
6388 
6389 //------------------------------inline_ghash_processBlocks
6390 bool LibraryCallKit::inline_ghash_processBlocks() {
6391   address stubAddr;
6392   const char *stubName;
6393   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6394 
6395   stubAddr = StubRoutines::ghash_processBlocks();
6396   stubName = &quot;ghash_processBlocks&quot;;
6397 
6398   Node* data           = argument(0);
6399   Node* offset         = argument(1);
6400   Node* len            = argument(2);
6401   Node* state          = argument(3);
6402   Node* subkeyH        = argument(4);
6403 
6404   state = must_be_not_null(state, true);
6405   subkeyH = must_be_not_null(subkeyH, true);
6406   data = must_be_not_null(data, true);
6407 
6408   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6409   assert(state_start, &quot;state is NULL&quot;);
6410   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6411   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6412   Node* data_start  = array_element_address(data, offset, T_BYTE);
6413   assert(data_start, &quot;data is NULL&quot;);
6414 
6415   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6416                                   OptoRuntime::ghash_processBlocks_Type(),
6417                                   stubAddr, stubName, TypePtr::BOTTOM,
6418                                   state_start, subkeyH_start, data_start, len);
6419   return true;
6420 }
6421 
6422 bool LibraryCallKit::inline_base64_encodeBlock() {
6423   address stubAddr;
6424   const char *stubName;
6425   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6426   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6427   stubAddr = StubRoutines::base64_encodeBlock();
6428   stubName = &quot;encodeBlock&quot;;
6429 
6430   if (!stubAddr) return false;
6431   Node* base64obj = argument(0);
6432   Node* src = argument(1);
6433   Node* offset = argument(2);
6434   Node* len = argument(3);
6435   Node* dest = argument(4);
6436   Node* dp = argument(5);
6437   Node* isURL = argument(6);
6438 
6439   src = must_be_not_null(src, true);
6440   dest = must_be_not_null(dest, true);
6441 
6442   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6443   assert(src_start, &quot;source array is NULL&quot;);
6444   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6445   assert(dest_start, &quot;destination array is NULL&quot;);
6446 
6447   Node* base64 = make_runtime_call(RC_LEAF,
6448                                    OptoRuntime::base64_encodeBlock_Type(),
6449                                    stubAddr, stubName, TypePtr::BOTTOM,
6450                                    src_start, offset, len, dest_start, dp, isURL);
6451   return true;
6452 }
6453 
6454 //------------------------------inline_sha_implCompress-----------------------
6455 //
6456 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6457 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6458 //
6459 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6460 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
6461 //
6462 // Calculate SHA5 (i.e., SHA-384 or SHA-512) for single-block byte[] array.
6463 // void com.sun.security.provider.SHA5.implCompress(byte[] buf, int ofs)
6464 //
6465 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6466   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6467 
6468   Node* sha_obj = argument(0);
6469   Node* src     = argument(1); // type oop
6470   Node* ofs     = argument(2); // type int
6471 
6472   const Type* src_type = src-&gt;Value(&amp;_gvn);
6473   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6474   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6475     // failed array check
6476     return false;
6477   }
6478   // Figure out the size and type of the elements we will be copying.
6479   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6480   if (src_elem != T_BYTE) {
6481     return false;
6482   }
6483   // &#39;src_start&#39; points to src array + offset
6484   src = must_be_not_null(src, true);
6485   Node* src_start = array_element_address(src, ofs, src_elem);
6486   Node* state = NULL;
6487   address stubAddr;
6488   const char *stubName;
6489 
6490   switch(id) {
6491   case vmIntrinsics::_sha_implCompress:
6492     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6493     state = get_state_from_sha_object(sha_obj);
6494     stubAddr = StubRoutines::sha1_implCompress();
6495     stubName = &quot;sha1_implCompress&quot;;
6496     break;
6497   case vmIntrinsics::_sha2_implCompress:
6498     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6499     state = get_state_from_sha_object(sha_obj);
6500     stubAddr = StubRoutines::sha256_implCompress();
6501     stubName = &quot;sha256_implCompress&quot;;
6502     break;
6503   case vmIntrinsics::_sha5_implCompress:
6504     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6505     state = get_state_from_sha5_object(sha_obj);
6506     stubAddr = StubRoutines::sha512_implCompress();
6507     stubName = &quot;sha512_implCompress&quot;;
6508     break;
6509   default:
6510     fatal_unexpected_iid(id);
6511     return false;
6512   }
6513   if (state == NULL) return false;
6514 
6515   assert(stubAddr != NULL, &quot;Stub is generated&quot;);
6516   if (stubAddr == NULL) return false;
6517 
6518   // Call the stub.
6519   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6520                                  stubAddr, stubName, TypePtr::BOTTOM,
6521                                  src_start, state);
6522 
6523   return true;
6524 }
6525 
6526 //------------------------------inline_digestBase_implCompressMB-----------------------
6527 //
6528 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6529 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6530 //
6531 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6532   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6533          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6534   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6535   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6536 
6537   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6538   Node* src            = argument(1); // byte[] array
6539   Node* ofs            = argument(2); // type int
6540   Node* limit          = argument(3); // type int
6541 
6542   const Type* src_type = src-&gt;Value(&amp;_gvn);
6543   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6544   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6545     // failed array check
6546     return false;
6547   }
6548   // Figure out the size and type of the elements we will be copying.
6549   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6550   if (src_elem != T_BYTE) {
6551     return false;
6552   }
6553   // &#39;src_start&#39; points to src array + offset
6554   src = must_be_not_null(src, false);
6555   Node* src_start = array_element_address(src, ofs, src_elem);
6556 
6557   const char* klass_SHA_name = NULL;
6558   const char* stub_name = NULL;
6559   address     stub_addr = NULL;
6560   bool        long_state = false;
6561 
6562   switch (predicate) {
6563   case 0:
6564     if (UseSHA1Intrinsics) {
6565       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6566       stub_name = &quot;sha1_implCompressMB&quot;;
6567       stub_addr = StubRoutines::sha1_implCompressMB();
6568     }
6569     break;
6570   case 1:
6571     if (UseSHA256Intrinsics) {
6572       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6573       stub_name = &quot;sha256_implCompressMB&quot;;
6574       stub_addr = StubRoutines::sha256_implCompressMB();
6575     }
6576     break;
6577   case 2:
6578     if (UseSHA512Intrinsics) {
6579       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6580       stub_name = &quot;sha512_implCompressMB&quot;;
6581       stub_addr = StubRoutines::sha512_implCompressMB();
6582       long_state = true;
6583     }
6584     break;
6585   default:
6586     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6587   }
6588   if (klass_SHA_name != NULL) {
6589     assert(stub_addr != NULL, &quot;Stub is generated&quot;);
6590     if (stub_addr == NULL) return false;
6591 
6592     // get DigestBase klass to lookup for SHA klass
6593     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6594     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6595     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6596 
6597     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6598     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6599     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6600     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6601   }
6602   return false;
6603 }
6604 //------------------------------inline_sha_implCompressMB-----------------------
6605 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6606                                                bool long_state, address stubAddr, const char *stubName,
6607                                                Node* src_start, Node* ofs, Node* limit) {
6608   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6609   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6610   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6611   sha_obj = _gvn.transform(sha_obj);
6612 
6613   Node* state;
6614   if (long_state) {
6615     state = get_state_from_sha5_object(sha_obj);
6616   } else {
6617     state = get_state_from_sha_object(sha_obj);
6618   }
6619   if (state == NULL) return false;
6620 
6621   // Call the stub.
6622   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6623                                  OptoRuntime::digestBase_implCompressMB_Type(),
6624                                  stubAddr, stubName, TypePtr::BOTTOM,
6625                                  src_start, state, ofs, limit);
6626   // return ofs (int)
6627   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6628   set_result(result);
6629 
6630   return true;
6631 }
6632 
6633 //------------------------------get_state_from_sha_object-----------------------
6634 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6635   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6636   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6637   if (sha_state == NULL) return (Node *) NULL;
6638 
6639   // now have the array, need to get the start address of the state array
6640   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6641   return state;
6642 }
6643 
6644 //------------------------------get_state_from_sha5_object-----------------------
6645 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6646   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6647   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6648   if (sha_state == NULL) return (Node *) NULL;
6649 
6650   // now have the array, need to get the start address of the state array
6651   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6652   return state;
6653 }
6654 
6655 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6656 // Return node representing slow path of predicate check.
6657 // the pseudo code we want to emulate with this predicate is:
6658 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6659 //
6660 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6661   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6662          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6663   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6664 
6665   // The receiver was checked for NULL already.
6666   Node* digestBaseObj = argument(0);
6667 
6668   // get DigestBase klass for instanceOf check
6669   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6670   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
6671   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6672 
6673   const char* klass_SHA_name = NULL;
6674   switch (predicate) {
6675   case 0:
6676     if (UseSHA1Intrinsics) {
6677       // we want to do an instanceof comparison against the SHA class
6678       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6679     }
6680     break;
6681   case 1:
6682     if (UseSHA256Intrinsics) {
6683       // we want to do an instanceof comparison against the SHA2 class
6684       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6685     }
6686     break;
6687   case 2:
6688     if (UseSHA512Intrinsics) {
6689       // we want to do an instanceof comparison against the SHA5 class
6690       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6691     }
6692     break;
6693   default:
6694     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6695   }
6696 
6697   ciKlass* klass_SHA = NULL;
6698   if (klass_SHA_name != NULL) {
6699     klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6700   }
6701   if ((klass_SHA == NULL) || !klass_SHA-&gt;is_loaded()) {
6702     // if none of SHA/SHA2/SHA5 is loaded, we never take the intrinsic fast path
6703     Node* ctrl = control();
6704     set_control(top()); // no intrinsic path
6705     return ctrl;
6706   }
6707   ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6708 
6709   Node* instofSHA = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass_SHA)));
6710   Node* cmp_instof = _gvn.transform(new CmpINode(instofSHA, intcon(1)));
6711   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6712   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6713 
6714   return instof_false;  // even if it is NULL
6715 }
6716 
6717 bool LibraryCallKit::inline_continuation(vmIntrinsics::ID id) {
6718   address call_addr = NULL;
6719   const char *name = NULL;
6720 
6721   switch (id) {
6722     case vmIntrinsics::_Continuation_getSP: call_addr = StubRoutines::cont_getSP(); name = &quot;getSP&quot;; break;
6723     case vmIntrinsics::_Continuation_getPC: call_addr = StubRoutines::cont_getPC(); name = &quot;getPC&quot;; break;
6724     default: fatal(&quot;error&quot;); return false;
6725   }
6726 
6727   const TypeFunc* tf = OptoRuntime::void_long_Type();
6728   const TypePtr* no_memory_effects = NULL;
6729   Node* call = make_runtime_call(RC_LEAF, tf, call_addr, name, no_memory_effects);
6730   Node* value = _gvn.transform(new ProjNode(call, TypeFunc::Parms+0));
6731 #ifdef ASSERT
6732   Node* value_top = _gvn.transform(new ProjNode(call, TypeFunc::Parms+1));
6733   assert(value_top == top(), &quot;second value must be top&quot;);
6734 #endif
6735   set_result(value);
6736   return true;
6737 }
6738 
6739 bool LibraryCallKit::inline_continuation_runLevel() {
6740   set_result(intcon(2));
6741   return true;
6742 }
6743 
6744 bool LibraryCallKit::inline_continuation_do_continue() {
6745   address call_addr = StubRoutines::cont_thaw();
6746   const TypeFunc* tf = OptoRuntime::void_void_Type();
6747   Node* call = make_runtime_call(RC_NO_LEAF, tf, call_addr, &quot;doContinue&quot;, TypeRawPtr::BOTTOM);
6748   assert (call-&gt;is_CallJava(), &quot;&quot;);
6749   Node* result = set_results_for_java_call((CallJavaNode*)call, false, /* deoptimize */ false);
6750   return true;
6751 }
6752 
6753 bool LibraryCallKit::inline_continuation_do_yield() {
6754   address call_addr = StubRoutines::cont_doYield();
6755   // Node* arg0 = argument(0); // type int - scopes
6756   Node* arg0 = intcon(0); // type int - from interpreter
6757   const TypeFunc* tf = OptoRuntime::continuation_doYield_Type();
6758   Node* call = make_runtime_call(RC_NO_LEAF, tf, call_addr, &quot;doYield&quot;, TypeRawPtr::BOTTOM, arg0);
6759   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6760   set_result(result);
6761   return true;
6762 }
6763 
6764 bool LibraryCallKit::inline_continuation_jump() {
6765   address call_addr = StubRoutines::cont_jump();
6766   Node* sp = argument(0); // type long
6767   Node* fp = argument(2); // type long
6768   Node* pc = argument(4); // type long
6769   const TypeFunc* tf = OptoRuntime::continuation_jump_Type();
6770   Node* call = make_runtime_call(RC_LEAF, tf, call_addr, &quot;jump&quot;, TypeRawPtr::BOTTOM, sp, fp, pc);
6771   return true;
6772 }
6773 
6774 //-------------inline_fma-----------------------------------
6775 bool LibraryCallKit::inline_fma(vmIntrinsics::ID id) {
6776   Node *a = NULL;
6777   Node *b = NULL;
6778   Node *c = NULL;
6779   Node* result = NULL;
6780   switch (id) {
6781   case vmIntrinsics::_fmaD:
6782     assert(callee()-&gt;signature()-&gt;size() == 6, &quot;fma has 3 parameters of size 2 each.&quot;);
6783     // no receiver since it is static method
6784     a = round_double_node(argument(0));
6785     b = round_double_node(argument(2));
6786     c = round_double_node(argument(4));
6787     result = _gvn.transform(new FmaDNode(control(), a, b, c));
6788     break;
6789   case vmIntrinsics::_fmaF:
6790     assert(callee()-&gt;signature()-&gt;size() == 3, &quot;fma has 3 parameters of size 1 each.&quot;);
6791     a = argument(0);
6792     b = argument(1);
6793     c = argument(2);
6794     result = _gvn.transform(new FmaFNode(control(), a, b, c));
6795     break;
6796   default:
6797     fatal_unexpected_iid(id);  break;
6798   }
6799   set_result(result);
6800   return true;
6801 }
6802 
6803 bool LibraryCallKit::inline_character_compare(vmIntrinsics::ID id) {
6804   // argument(0) is receiver
6805   Node* codePoint = argument(1);
6806   Node* n = NULL;
6807 
6808   switch (id) {
6809     case vmIntrinsics::_isDigit :
6810       n = new DigitNode(control(), codePoint);
6811       break;
6812     case vmIntrinsics::_isLowerCase :
6813       n = new LowerCaseNode(control(), codePoint);
6814       break;
6815     case vmIntrinsics::_isUpperCase :
6816       n = new UpperCaseNode(control(), codePoint);
6817       break;
6818     case vmIntrinsics::_isWhitespace :
6819       n = new WhitespaceNode(control(), codePoint);
6820       break;
6821     default:
6822       fatal_unexpected_iid(id);
6823   }
6824 
6825   set_result(_gvn.transform(n));
6826   return true;
6827 }
6828 
6829 //------------------------------inline_fp_min_max------------------------------
6830 bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {
6831 /* DISABLED BECAUSE METHOD DATA ISN&#39;T COLLECTED PER CALL-SITE, SEE JDK-8015416.
6832 
6833   // The intrinsic should be used only when the API branches aren&#39;t predictable,
6834   // the last one performing the most important comparison. The following heuristic
6835   // uses the branch statistics to eventually bail out if necessary.
6836 
6837   ciMethodData *md = callee()-&gt;method_data();
6838 
6839   if ( md != NULL &amp;&amp; md-&gt;is_mature() &amp;&amp; md-&gt;invocation_count() &gt; 0 ) {
6840     ciCallProfile cp = caller()-&gt;call_profile_at_bci(bci());
6841 
6842     if ( ((double)cp.count()) / ((double)md-&gt;invocation_count()) &lt; 0.8 ) {
6843       // Bail out if the call-site didn&#39;t contribute enough to the statistics.
6844       return false;
6845     }
6846 
6847     uint taken = 0, not_taken = 0;
6848 
6849     for (ciProfileData *p = md-&gt;first_data(); md-&gt;is_valid(p); p = md-&gt;next_data(p)) {
6850       if (p-&gt;is_BranchData()) {
6851         taken = ((ciBranchData*)p)-&gt;taken();
6852         not_taken = ((ciBranchData*)p)-&gt;not_taken();
6853       }
6854     }
6855 
6856     double balance = (((double)taken) - ((double)not_taken)) / ((double)md-&gt;invocation_count());
6857     balance = balance &lt; 0 ? -balance : balance;
6858     if ( balance &gt; 0.2 ) {
6859       // Bail out if the most important branch is predictable enough.
6860       return false;
6861     }
6862   }
6863 */
6864 
6865   Node *a = NULL;
6866   Node *b = NULL;
6867   Node *n = NULL;
6868   switch (id) {
6869   case vmIntrinsics::_maxF:
6870   case vmIntrinsics::_minF:
6871     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
6872     a = argument(0);
6873     b = argument(1);
6874     break;
6875   case vmIntrinsics::_maxD:
6876   case vmIntrinsics::_minD:
6877     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
6878     a = round_double_node(argument(0));
6879     b = round_double_node(argument(2));
6880     break;
6881   default:
6882     fatal_unexpected_iid(id);
6883     break;
6884   }
6885   switch (id) {
6886   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
6887   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
6888   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
6889   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
6890   default:  fatal_unexpected_iid(id);  break;
6891   }
6892   set_result(_gvn.transform(n));
6893   return true;
6894 }
6895 
6896 bool LibraryCallKit::inline_profileBoolean() {
6897   Node* counts = argument(1);
6898   const TypeAryPtr* ary = NULL;
6899   ciArray* aobj = NULL;
6900   if (counts-&gt;is_Con()
6901       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
6902       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
6903       &amp;&amp; (aobj-&gt;length() == 2)) {
6904     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
6905     jint false_cnt = aobj-&gt;element_value(0).as_int();
6906     jint  true_cnt = aobj-&gt;element_value(1).as_int();
6907 
6908     if (C-&gt;log() != NULL) {
6909       C-&gt;log()-&gt;elem(&quot;observe source=&#39;profileBoolean&#39; false=&#39;%d&#39; true=&#39;%d&#39;&quot;,
6910                      false_cnt, true_cnt);
6911     }
6912 
6913     if (false_cnt + true_cnt == 0) {
6914       // According to profile, never executed.
6915       uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6916                           Deoptimization::Action_reinterpret);
6917       return true;
6918     }
6919 
6920     // result is a boolean (0 or 1) and its profile (false_cnt &amp; true_cnt)
6921     // is a number of each value occurrences.
6922     Node* result = argument(0);
6923     if (false_cnt == 0 || true_cnt == 0) {
6924       // According to profile, one value has been never seen.
6925       int expected_val = (false_cnt == 0) ? 1 : 0;
6926 
6927       Node* cmp  = _gvn.transform(new CmpINode(result, intcon(expected_val)));
6928       Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
6929 
6930       IfNode* check = create_and_map_if(control(), test, PROB_ALWAYS, COUNT_UNKNOWN);
6931       Node* fast_path = _gvn.transform(new IfTrueNode(check));
6932       Node* slow_path = _gvn.transform(new IfFalseNode(check));
6933 
6934       { // Slow path: uncommon trap for never seen value and then reexecute
6935         // MethodHandleImpl::profileBoolean() to bump the count, so JIT knows
6936         // the value has been seen at least once.
6937         PreserveJVMState pjvms(this);
6938         PreserveReexecuteState preexecs(this);
6939         jvms()-&gt;set_should_reexecute(true);
6940 
6941         set_control(slow_path);
6942         set_i_o(i_o());
6943 
6944         uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6945                             Deoptimization::Action_reinterpret);
6946       }
6947       // The guard for never seen value enables sharpening of the result and
6948       // returning a constant. It allows to eliminate branches on the same value
6949       // later on.
6950       set_control(fast_path);
6951       result = intcon(expected_val);
6952     }
6953     // Stop profiling.
6954     // MethodHandleImpl::profileBoolean() has profiling logic in its bytecode.
6955     // By replacing method body with profile data (represented as ProfileBooleanNode
6956     // on IR level) we effectively disable profiling.
6957     // It enables full speed execution once optimized code is generated.
6958     Node* profile = _gvn.transform(new ProfileBooleanNode(result, false_cnt, true_cnt));
6959     C-&gt;record_for_igvn(profile);
6960     set_result(profile);
6961     return true;
6962   } else {
6963     // Continue profiling.
6964     // Profile data isn&#39;t available at the moment. So, execute method&#39;s bytecode version.
6965     // Usually, when GWT LambdaForms are profiled it means that a stand-alone nmethod
6966     // is compiled and counters aren&#39;t available since corresponding MethodHandle
6967     // isn&#39;t a compile-time constant.
6968     return false;
6969   }
6970 }
6971 
6972 bool LibraryCallKit::inline_isCompileConstant() {
6973   Node* n = argument(0);
6974   set_result(n-&gt;is_Con() ? intcon(1) : intcon(0));
6975   return true;
6976 }
    </pre>
  </body>
</html>