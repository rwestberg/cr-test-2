<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;ci/ciUtilities.inline.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;classfile/vmSymbols.hpp&quot;
  30 #include &quot;compiler/compileBroker.hpp&quot;
  31 #include &quot;compiler/compileLog.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;opto/addnode.hpp&quot;
  38 #include &quot;opto/arraycopynode.hpp&quot;
  39 #include &quot;opto/c2compiler.hpp&quot;
  40 #include &quot;opto/callGenerator.hpp&quot;
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/intrinsicnode.hpp&quot;
  46 #include &quot;opto/idealKit.hpp&quot;
  47 #include &quot;opto/mathexactnode.hpp&quot;
  48 #include &quot;opto/movenode.hpp&quot;
  49 #include &quot;opto/mulnode.hpp&quot;
  50 #include &quot;opto/narrowptrnode.hpp&quot;
  51 #include &quot;opto/opaquenode.hpp&quot;
  52 #include &quot;opto/parse.hpp&quot;
  53 #include &quot;opto/runtime.hpp&quot;
  54 #include &quot;opto/rootnode.hpp&quot;
  55 #include &quot;opto/subnode.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;prims/unsafe.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
  61 
  62 
  63 class LibraryIntrinsic : public InlineCallGenerator {
  64   // Extend the set of intrinsics known to the runtime:
  65  public:
  66  private:
  67   bool             _is_virtual;
  68   bool             _does_virtual_dispatch;
  69   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  70   int8_t           _last_predicate; // Last generated predicate
  71   vmIntrinsics::ID _intrinsic_id;
  72 
  73  public:
  74   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  75     : InlineCallGenerator(m),
  76       _is_virtual(is_virtual),
  77       _does_virtual_dispatch(does_virtual_dispatch),
  78       _predicates_count((int8_t)predicates_count),
  79       _last_predicate((int8_t)-1),
  80       _intrinsic_id(id)
  81   {
  82   }
  83   virtual bool is_intrinsic() const { return true; }
  84   virtual bool is_virtual()   const { return _is_virtual; }
  85   virtual bool is_predicated() const { return _predicates_count &gt; 0; }
  86   virtual int  predicates_count() const { return _predicates_count; }
  87   virtual bool does_virtual_dispatch()   const { return _does_virtual_dispatch; }
  88   virtual JVMState* generate(JVMState* jvms);
  89   virtual Node* generate_predicate(JVMState* jvms, int predicate);
  90   vmIntrinsics::ID intrinsic_id() const { return _intrinsic_id; }
  91 };
  92 
  93 
  94 // Local helper class for LibraryIntrinsic:
  95 class LibraryCallKit : public GraphKit {
  96  private:
  97   LibraryIntrinsic* _intrinsic;     // the library intrinsic being called
  98   Node*             _result;        // the result node, if any
  99   int               _reexecute_sp;  // the stack pointer when bytecode needs to be reexecuted
 100 
 101   const TypeOopPtr* sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type);
 102 
 103  public:
 104   LibraryCallKit(JVMState* jvms, LibraryIntrinsic* intrinsic)
 105     : GraphKit(jvms),
 106       _intrinsic(intrinsic),
 107       _result(NULL)
 108   {
 109     // Check if this is a root compile.  In that case we don&#39;t have a caller.
 110     if (!jvms-&gt;has_method()) {
 111       _reexecute_sp = sp();
 112     } else {
 113       // Find out how many arguments the interpreter needs when deoptimizing
 114       // and save the stack pointer value so it can used by uncommon_trap.
 115       // We find the argument count by looking at the declared signature.
 116       bool ignored_will_link;
 117       ciSignature* declared_signature = NULL;
 118       ciMethod* ignored_callee = caller()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
 119       const int nargs = declared_signature-&gt;arg_size_for_bc(caller()-&gt;java_code_at_bci(bci()));
 120       _reexecute_sp = sp() + nargs;  // &quot;push&quot; arguments back on stack
 121     }
 122   }
 123 
 124   virtual LibraryCallKit* is_LibraryCallKit() const { return (LibraryCallKit*)this; }
 125 
 126   ciMethod*         caller()    const    { return jvms()-&gt;method(); }
 127   int               bci()       const    { return jvms()-&gt;bci(); }
 128   LibraryIntrinsic* intrinsic() const    { return _intrinsic; }
 129   vmIntrinsics::ID  intrinsic_id() const { return _intrinsic-&gt;intrinsic_id(); }
 130   ciMethod*         callee()    const    { return _intrinsic-&gt;method(); }
 131 
 132   bool  try_to_inline(int predicate);
 133   Node* try_to_predicate(int predicate);
 134 
 135   void push_result() {
 136     // Push the result onto the stack.
 137     if (!stopped() &amp;&amp; result() != NULL) {
 138       BasicType bt = result()-&gt;bottom_type()-&gt;basic_type();
 139       push_node(bt, result());
 140     }
 141   }
 142 
 143  private:
 144   void fatal_unexpected_iid(vmIntrinsics::ID iid) {
 145     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
 146   }
 147 
 148   void  set_result(Node* n) { assert(_result == NULL, &quot;only set once&quot;); _result = n; }
 149   void  set_result(RegionNode* region, PhiNode* value);
 150   Node*     result() { return _result; }
 151 
 152   virtual int reexecute_sp() { return _reexecute_sp; }
 153 
 154   // Helper functions to inline natives
 155   Node* generate_guard(Node* test, RegionNode* region, float true_prob);
 156   Node* generate_slow_guard(Node* test, RegionNode* region);
 157   Node* generate_fair_guard(Node* test, RegionNode* region);
 158   Node* generate_negative_guard(Node* index, RegionNode* region,
 159                                 // resulting CastII of index:
 160                                 Node* *pos_index = NULL);
 161   Node* generate_limit_guard(Node* offset, Node* subseq_length,
 162                              Node* array_length,
 163                              RegionNode* region);
 164   void  generate_string_range_check(Node* array, Node* offset,
 165                                     Node* length, bool char_count);
 166   Node* generate_current_thread(Node* &amp;tls_output);
 167   Node* load_mirror_from_klass(Node* klass);
 168   Node* load_klass_from_mirror_common(Node* mirror, bool never_see_null,
 169                                       RegionNode* region, int null_path,
 170                                       int offset);
 171   Node* load_klass_from_mirror(Node* mirror, bool never_see_null,
 172                                RegionNode* region, int null_path) {
 173     int offset = java_lang_Class::klass_offset_in_bytes();
 174     return load_klass_from_mirror_common(mirror, never_see_null,
 175                                          region, null_path,
 176                                          offset);
 177   }
 178   Node* load_array_klass_from_mirror(Node* mirror, bool never_see_null,
 179                                      RegionNode* region, int null_path) {
 180     int offset = java_lang_Class::array_klass_offset_in_bytes();
 181     return load_klass_from_mirror_common(mirror, never_see_null,
 182                                          region, null_path,
 183                                          offset);
 184   }
 185   Node* generate_access_flags_guard(Node* kls,
 186                                     int modifier_mask, int modifier_bits,
 187                                     RegionNode* region);
 188   Node* generate_interface_guard(Node* kls, RegionNode* region);
 189   Node* generate_array_guard(Node* kls, RegionNode* region) {
 190     return generate_array_guard_common(kls, region, false, false);
 191   }
 192   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 193     return generate_array_guard_common(kls, region, false, true);
 194   }
 195   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 196     return generate_array_guard_common(kls, region, true, false);
 197   }
 198   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 199     return generate_array_guard_common(kls, region, true, true);
 200   }
 201   Node* generate_array_guard_common(Node* kls, RegionNode* region,
 202                                     bool obj_array, bool not_array);
 203   Node* generate_virtual_guard(Node* obj_klass, RegionNode* slow_region);
 204   CallJavaNode* generate_method_call(vmIntrinsics::ID method_id,
 205                                      bool is_virtual = false, bool is_static = false);
 206   CallJavaNode* generate_method_call_static(vmIntrinsics::ID method_id) {
 207     return generate_method_call(method_id, false, true);
 208   }
 209   CallJavaNode* generate_method_call_virtual(vmIntrinsics::ID method_id) {
 210     return generate_method_call(method_id, true, false);
 211   }
 212   Node * load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 213   Node * field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString, bool is_exact, bool is_static, ciInstanceKlass * fromKls);
 214 
 215   Node* make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae);
 216   bool inline_string_compareTo(StrIntrinsicNode::ArgEnc ae);
 217   bool inline_string_indexOf(StrIntrinsicNode::ArgEnc ae);
 218   bool inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae);
 219   Node* make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
 220                           RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae);
 221   bool inline_string_indexOfChar();
 222   bool inline_string_equals(StrIntrinsicNode::ArgEnc ae);
 223   bool inline_string_toBytesU();
 224   bool inline_string_getCharsU();
 225   bool inline_string_copy(bool compress);
 226   bool inline_string_char_access(bool is_store);
 227   Node* round_double_node(Node* n);
 228   bool runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName);
 229   bool inline_math_native(vmIntrinsics::ID id);
 230   bool inline_math(vmIntrinsics::ID id);
 231   bool inline_double_math(vmIntrinsics::ID id);
 232   template &lt;typename OverflowOp&gt;
 233   bool inline_math_overflow(Node* arg1, Node* arg2);
 234   void inline_math_mathExact(Node* math, Node* test);
 235   bool inline_math_addExactI(bool is_increment);
 236   bool inline_math_addExactL(bool is_increment);
 237   bool inline_math_multiplyExactI();
 238   bool inline_math_multiplyExactL();
 239   bool inline_math_multiplyHigh();
 240   bool inline_math_negateExactI();
 241   bool inline_math_negateExactL();
 242   bool inline_math_subtractExactI(bool is_decrement);
 243   bool inline_math_subtractExactL(bool is_decrement);
 244   bool inline_min_max(vmIntrinsics::ID id);
 245   bool inline_notify(vmIntrinsics::ID id);
 246   Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);
 247   // This returns Type::AnyPtr, RawPtr, or OopPtr.
 248   int classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type);
 249   Node* make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type = T_ILLEGAL, bool can_cast = false);
 250 
 251   typedef enum { Relaxed, Opaque, Volatile, Acquire, Release } AccessKind;
 252   DecoratorSet mo_decorator_for_access_kind(AccessKind kind);
 253   bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);
 254   static bool klass_needs_init_guard(Node* kls);
 255   bool inline_unsafe_allocate();
 256   bool inline_unsafe_newArray(bool uninitialized);
 257   bool inline_unsafe_writeback0();
 258   bool inline_unsafe_writebackSync0(bool is_pre);
 259   bool inline_unsafe_copyMemory();
 260   bool inline_native_currentThread();
<a name="1" id="anc1"></a>

 261 
 262   bool inline_native_time_funcs(address method, const char* funcName);
 263 #ifdef JFR_HAVE_INTRINSICS
 264   bool inline_native_classID();
 265   // bool inline_native_getEventWriter();
 266 #endif
 267   bool inline_native_Class_query(vmIntrinsics::ID id);
 268   bool inline_native_subtype_check();
 269   bool inline_native_getLength();
 270   bool inline_array_copyOf(bool is_copyOfRange);
 271   bool inline_array_equals(StrIntrinsicNode::ArgEnc ae);
 272   bool inline_preconditions_checkIndex();
 273   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array);
 274   bool inline_native_clone(bool is_virtual);
 275   bool inline_native_Reflection_getCallerClass();
 276   // Helper function for inlining native object hash method
 277   bool inline_native_hashcode(bool is_virtual, bool is_static);
 278   bool inline_native_getClass();
 279 
 280   // Helper functions for inlining arraycopy
 281   bool inline_arraycopy();
 282   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 283                                                 RegionNode* slow_region);
 284   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 285   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,
 286                                       uint new_idx);
 287 
 288   typedef enum { LS_get_add, LS_get_set, LS_cmp_swap, LS_cmp_swap_weak, LS_cmp_exchange } LoadStoreKind;
 289   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind, AccessKind access_kind);
 290   bool inline_unsafe_fence(vmIntrinsics::ID id);
 291   bool inline_onspinwait();
 292   bool inline_fp_conversions(vmIntrinsics::ID id);
 293   bool inline_number_methods(vmIntrinsics::ID id);
 294   bool inline_reference_get();
 295   bool inline_Class_cast();
 296   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 297   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 298   bool inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id);
 299   bool inline_counterMode_AESCrypt(vmIntrinsics::ID id);
 300   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 301   Node* inline_electronicCodeBook_AESCrypt_predicate(bool decrypting);
 302   Node* inline_counterMode_AESCrypt_predicate();
 303   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 304   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 305   bool inline_ghash_processBlocks();
 306   bool inline_base64_encodeBlock();
 307   bool inline_sha_implCompress(vmIntrinsics::ID id);
 308   bool inline_digestBase_implCompressMB(int predicate);
 309   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 310                                  bool long_state, address stubAddr, const char *stubName,
 311                                  Node* src_start, Node* ofs, Node* limit);
 312   Node* get_state_from_sha_object(Node *sha_object);
 313   Node* get_state_from_sha5_object(Node *sha_object);
 314   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 315   bool inline_encodeISOArray();
 316   bool inline_updateCRC32();
 317   bool inline_updateBytesCRC32();
 318   bool inline_updateByteBufferCRC32();
 319   Node* get_table_from_crc32c_class(ciInstanceKlass *crc32c_class);
 320   bool inline_updateBytesCRC32C();
 321   bool inline_updateDirectByteBufferCRC32C();
 322   bool inline_updateBytesAdler32();
 323   bool inline_updateByteBufferAdler32();
 324   bool inline_multiplyToLen();
 325   bool inline_hasNegatives();
 326   bool inline_squareToLen();
 327   bool inline_mulAdd();
 328   bool inline_montgomeryMultiply();
 329   bool inline_montgomerySquare();
 330   bool inline_bigIntegerShift(bool isRightShift);
 331   bool inline_vectorizedMismatch();
 332   bool inline_fma(vmIntrinsics::ID id);
 333   bool inline_character_compare(vmIntrinsics::ID id);
 334   bool inline_fp_min_max(vmIntrinsics::ID id);
 335 
 336   bool inline_profileBoolean();
 337   bool inline_isCompileConstant();
 338   bool inline_continuation(vmIntrinsics::ID id);
 339   bool inline_continuation_do_yield();
 340   bool inline_continuation_jump();
 341   bool inline_continuation_runLevel();
 342   bool inline_continuation_do_continue();
 343   void clear_upper_avx() {
 344 #ifdef X86
 345     if (UseAVX &gt;= 2) {
 346       C-&gt;set_clear_upper_avx(true);
 347     }
 348 #endif
 349   }
 350 };
 351 
 352 //---------------------------make_vm_intrinsic----------------------------
 353 CallGenerator* Compile::make_vm_intrinsic(ciMethod* m, bool is_virtual) {
 354   vmIntrinsics::ID id = m-&gt;intrinsic_id();
 355   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 356 
 357   if (!m-&gt;is_loaded()) {
 358     // Do not attempt to inline unloaded methods.
 359     return NULL;
 360   }
 361 
 362   C2Compiler* compiler = (C2Compiler*)CompileBroker::compiler(CompLevel_full_optimization);
 363   bool is_available = false;
 364 
 365   {
 366     // For calling is_intrinsic_supported and is_intrinsic_disabled_by_flag
 367     // the compiler must transition to &#39;_thread_in_vm&#39; state because both
 368     // methods access VM-internal data.
 369     VM_ENTRY_MARK;
 370     methodHandle mh(THREAD, m-&gt;get_Method());
 371     is_available = compiler != NULL &amp;&amp; compiler-&gt;is_intrinsic_supported(mh, is_virtual) &amp;&amp;
 372                    !C-&gt;directive()-&gt;is_intrinsic_disabled(mh) &amp;&amp;
 373                    !vmIntrinsics::is_disabled_by_flags(mh);
 374 
 375   }
 376 
 377   if (is_available) {
 378     assert(id &lt;= vmIntrinsics::LAST_COMPILER_INLINE, &quot;caller responsibility&quot;);
 379     assert(id != vmIntrinsics::_Object_init &amp;&amp; id != vmIntrinsics::_invoke, &quot;enum out of order?&quot;);
 380     return new LibraryIntrinsic(m, is_virtual,
 381                                 vmIntrinsics::predicates_needed(id),
 382                                 vmIntrinsics::does_virtual_dispatch(id),
 383                                 (vmIntrinsics::ID) id);
 384   } else {
 385     return NULL;
 386   }
 387 }
 388 
 389 //----------------------register_library_intrinsics-----------------------
 390 // Initialize this file&#39;s data structures, for each Compile instance.
 391 void Compile::register_library_intrinsics() {
 392   // Nothing to do here.
 393 }
 394 
 395 JVMState* LibraryIntrinsic::generate(JVMState* jvms) {
 396   LibraryCallKit kit(jvms, this);
 397   Compile* C = kit.C;
 398   int nodes = C-&gt;unique();
 399 #ifndef PRODUCT
 400   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 401     char buf[1000];
 402     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 403     tty-&gt;print_cr(&quot;Intrinsic %s&quot;, str);
 404   }
 405 #endif
 406   ciMethod* callee = kit.callee();
 407   const int bci    = kit.bci();
 408 
 409   // Try to inline the intrinsic.
 410   if ((CheckIntrinsics ? callee-&gt;intrinsic_candidate() : true) &amp;&amp;
 411       kit.try_to_inline(_last_predicate)) {
 412     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual)&quot;
 413                                           : &quot;(intrinsic)&quot;;
 414     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 415     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 416       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 417     }
 418     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 419     if (C-&gt;log()) {
 420       C-&gt;log()-&gt;elem(&quot;intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 421                      vmIntrinsics::name_at(intrinsic_id()),
 422                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 423                      C-&gt;unique() - nodes);
 424     }
 425     // Push the result from the inlined method onto the stack.
 426     kit.push_result();
 427     C-&gt;print_inlining_update(this);
 428     return kit.transfer_exceptions_into_jvms();
 429   }
 430 
 431   // The intrinsic bailed out
 432   if (jvms-&gt;has_method()) {
 433     // Not a root compile.
 434     const char* msg;
 435     if (callee-&gt;intrinsic_candidate()) {
 436       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual)&quot; : &quot;failed to inline (intrinsic)&quot;;
 437     } else {
 438       msg = is_virtual() ? &quot;failed to inline (intrinsic, virtual), method not annotated&quot;
 439                          : &quot;failed to inline (intrinsic), method not annotated&quot;;
 440     }
 441     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, msg);
 442     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 443       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, msg);
 444     }
 445   } else {
 446     // Root compile
 447     ResourceMark rm;
 448     stringStream msg_stream;
 449     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 450                      vmIntrinsics::name_at(intrinsic_id()),
 451                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 452     const char *msg = msg_stream.as_string();
 453     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 454     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 455       tty-&gt;print(&quot;%s&quot;, msg);
 456     }
 457   }
 458   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 459   C-&gt;print_inlining_update(this);
 460   return NULL;
 461 }
 462 
 463 Node* LibraryIntrinsic::generate_predicate(JVMState* jvms, int predicate) {
 464   LibraryCallKit kit(jvms, this);
 465   Compile* C = kit.C;
 466   int nodes = C-&gt;unique();
 467   _last_predicate = predicate;
 468 #ifndef PRODUCT
 469   assert(is_predicated() &amp;&amp; predicate &lt; predicates_count(), &quot;sanity&quot;);
 470   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
 471     char buf[1000];
 472     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
 473     tty-&gt;print_cr(&quot;Predicate for intrinsic %s&quot;, str);
 474   }
 475 #endif
 476   ciMethod* callee = kit.callee();
 477   const int bci    = kit.bci();
 478 
 479   Node* slow_ctl = kit.try_to_predicate(predicate);
 480   if (!kit.failing()) {
 481     const char *inline_msg = is_virtual() ? &quot;(intrinsic, virtual, predicate)&quot;
 482                                           : &quot;(intrinsic, predicate)&quot;;
 483     CompileTask::print_inlining_ul(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 484     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 485       C-&gt;print_inlining(callee, jvms-&gt;depth() - 1, bci, inline_msg);
 486     }
 487     C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
 488     if (C-&gt;log()) {
 489       C-&gt;log()-&gt;elem(&quot;predicate_intrinsic id=&#39;%s&#39;%s nodes=&#39;%d&#39;&quot;,
 490                      vmIntrinsics::name_at(intrinsic_id()),
 491                      (is_virtual() ? &quot; virtual=&#39;1&#39;&quot; : &quot;&quot;),
 492                      C-&gt;unique() - nodes);
 493     }
 494     return slow_ctl; // Could be NULL if the check folds.
 495   }
 496 
 497   // The intrinsic bailed out
 498   if (jvms-&gt;has_method()) {
 499     // Not a root compile.
 500     const char* msg = &quot;failed to generate predicate for intrinsic&quot;;
 501     CompileTask::print_inlining_ul(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 502     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 503       C-&gt;print_inlining(kit.callee(), jvms-&gt;depth() - 1, bci, msg);
 504     }
 505   } else {
 506     // Root compile
 507     ResourceMark rm;
 508     stringStream msg_stream;
 509     msg_stream.print(&quot;Did not generate intrinsic %s%s at bci:%d in&quot;,
 510                      vmIntrinsics::name_at(intrinsic_id()),
 511                      is_virtual() ? &quot; (virtual)&quot; : &quot;&quot;, bci);
 512     const char *msg = msg_stream.as_string();
 513     log_debug(jit, inlining)(&quot;%s&quot;, msg);
 514     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
 515       C-&gt;print_inlining_stream()-&gt;print(&quot;%s&quot;, msg);
 516     }
 517   }
 518   C-&gt;gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_failed);
 519   return NULL;
 520 }
 521 
 522 bool LibraryCallKit::try_to_inline(int predicate) {
 523   // Handle symbolic names for otherwise undistinguished boolean switches:
 524   const bool is_store       = true;
 525   const bool is_compress    = true;
 526   const bool is_static      = true;
 527   const bool is_volatile    = true;
 528 
 529   if (!jvms()-&gt;has_method()) {
 530     // Root JVMState has a null method.
 531     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 532     // Insert the memory aliasing node
 533     set_all_memory(reset_memory());
 534   }
 535   assert(merged_memory(), &quot;&quot;);
 536 
 537 
 538   switch (intrinsic_id()) {
 539   case vmIntrinsics::_hashCode:                 return inline_native_hashcode(intrinsic()-&gt;is_virtual(), !is_static);
 540   case vmIntrinsics::_identityHashCode:         return inline_native_hashcode(/*!virtual*/ false,         is_static);
 541   case vmIntrinsics::_getClass:                 return inline_native_getClass();
 542 
 543   case vmIntrinsics::_ceil:
 544   case vmIntrinsics::_floor:
 545   case vmIntrinsics::_rint:
 546   case vmIntrinsics::_dsin:
 547   case vmIntrinsics::_dcos:
 548   case vmIntrinsics::_dtan:
 549   case vmIntrinsics::_dabs:
 550   case vmIntrinsics::_fabs:
 551   case vmIntrinsics::_iabs:
 552   case vmIntrinsics::_labs:
 553   case vmIntrinsics::_datan2:
 554   case vmIntrinsics::_dsqrt:
 555   case vmIntrinsics::_dexp:
 556   case vmIntrinsics::_dlog:
 557   case vmIntrinsics::_dlog10:
 558   case vmIntrinsics::_dpow:                     return inline_math_native(intrinsic_id());
 559 
 560   case vmIntrinsics::_min:
 561   case vmIntrinsics::_max:                      return inline_min_max(intrinsic_id());
 562 
 563   case vmIntrinsics::_notify:
 564   case vmIntrinsics::_notifyAll:
 565     return inline_notify(intrinsic_id());
 566 
 567   case vmIntrinsics::_addExactI:                return inline_math_addExactI(false /* add */);
 568   case vmIntrinsics::_addExactL:                return inline_math_addExactL(false /* add */);
 569   case vmIntrinsics::_decrementExactI:          return inline_math_subtractExactI(true /* decrement */);
 570   case vmIntrinsics::_decrementExactL:          return inline_math_subtractExactL(true /* decrement */);
 571   case vmIntrinsics::_incrementExactI:          return inline_math_addExactI(true /* increment */);
 572   case vmIntrinsics::_incrementExactL:          return inline_math_addExactL(true /* increment */);
 573   case vmIntrinsics::_multiplyExactI:           return inline_math_multiplyExactI();
 574   case vmIntrinsics::_multiplyExactL:           return inline_math_multiplyExactL();
 575   case vmIntrinsics::_multiplyHigh:             return inline_math_multiplyHigh();
 576   case vmIntrinsics::_negateExactI:             return inline_math_negateExactI();
 577   case vmIntrinsics::_negateExactL:             return inline_math_negateExactL();
 578   case vmIntrinsics::_subtractExactI:           return inline_math_subtractExactI(false /* subtract */);
 579   case vmIntrinsics::_subtractExactL:           return inline_math_subtractExactL(false /* subtract */);
 580 
 581   case vmIntrinsics::_arraycopy:                return inline_arraycopy();
 582 
 583   case vmIntrinsics::_compareToL:               return inline_string_compareTo(StrIntrinsicNode::LL);
 584   case vmIntrinsics::_compareToU:               return inline_string_compareTo(StrIntrinsicNode::UU);
 585   case vmIntrinsics::_compareToLU:              return inline_string_compareTo(StrIntrinsicNode::LU);
 586   case vmIntrinsics::_compareToUL:              return inline_string_compareTo(StrIntrinsicNode::UL);
 587 
 588   case vmIntrinsics::_indexOfL:                 return inline_string_indexOf(StrIntrinsicNode::LL);
 589   case vmIntrinsics::_indexOfU:                 return inline_string_indexOf(StrIntrinsicNode::UU);
 590   case vmIntrinsics::_indexOfUL:                return inline_string_indexOf(StrIntrinsicNode::UL);
 591   case vmIntrinsics::_indexOfIL:                return inline_string_indexOfI(StrIntrinsicNode::LL);
 592   case vmIntrinsics::_indexOfIU:                return inline_string_indexOfI(StrIntrinsicNode::UU);
 593   case vmIntrinsics::_indexOfIUL:               return inline_string_indexOfI(StrIntrinsicNode::UL);
 594   case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();
 595 
 596   case vmIntrinsics::_equalsL:                  return inline_string_equals(StrIntrinsicNode::LL);
 597   case vmIntrinsics::_equalsU:                  return inline_string_equals(StrIntrinsicNode::UU);
 598 
 599   case vmIntrinsics::_toBytesStringU:           return inline_string_toBytesU();
 600   case vmIntrinsics::_getCharsStringU:          return inline_string_getCharsU();
 601   case vmIntrinsics::_getCharStringU:           return inline_string_char_access(!is_store);
 602   case vmIntrinsics::_putCharStringU:           return inline_string_char_access( is_store);
 603 
 604   case vmIntrinsics::_compressStringC:
 605   case vmIntrinsics::_compressStringB:          return inline_string_copy( is_compress);
 606   case vmIntrinsics::_inflateStringC:
 607   case vmIntrinsics::_inflateStringB:           return inline_string_copy(!is_compress);
 608 
 609   case vmIntrinsics::_getReference:             return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false);
 610   case vmIntrinsics::_getBoolean:               return inline_unsafe_access(!is_store, T_BOOLEAN,  Relaxed, false);
 611   case vmIntrinsics::_getByte:                  return inline_unsafe_access(!is_store, T_BYTE,     Relaxed, false);
 612   case vmIntrinsics::_getShort:                 return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, false);
 613   case vmIntrinsics::_getChar:                  return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, false);
 614   case vmIntrinsics::_getInt:                   return inline_unsafe_access(!is_store, T_INT,      Relaxed, false);
 615   case vmIntrinsics::_getLong:                  return inline_unsafe_access(!is_store, T_LONG,     Relaxed, false);
 616   case vmIntrinsics::_getFloat:                 return inline_unsafe_access(!is_store, T_FLOAT,    Relaxed, false);
 617   case vmIntrinsics::_getDouble:                return inline_unsafe_access(!is_store, T_DOUBLE,   Relaxed, false);
 618 
 619   case vmIntrinsics::_putReference:             return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false);
 620   case vmIntrinsics::_putBoolean:               return inline_unsafe_access( is_store, T_BOOLEAN,  Relaxed, false);
 621   case vmIntrinsics::_putByte:                  return inline_unsafe_access( is_store, T_BYTE,     Relaxed, false);
 622   case vmIntrinsics::_putShort:                 return inline_unsafe_access( is_store, T_SHORT,    Relaxed, false);
 623   case vmIntrinsics::_putChar:                  return inline_unsafe_access( is_store, T_CHAR,     Relaxed, false);
 624   case vmIntrinsics::_putInt:                   return inline_unsafe_access( is_store, T_INT,      Relaxed, false);
 625   case vmIntrinsics::_putLong:                  return inline_unsafe_access( is_store, T_LONG,     Relaxed, false);
 626   case vmIntrinsics::_putFloat:                 return inline_unsafe_access( is_store, T_FLOAT,    Relaxed, false);
 627   case vmIntrinsics::_putDouble:                return inline_unsafe_access( is_store, T_DOUBLE,   Relaxed, false);
 628 
 629   case vmIntrinsics::_getReferenceVolatile:     return inline_unsafe_access(!is_store, T_OBJECT,   Volatile, false);
 630   case vmIntrinsics::_getBooleanVolatile:       return inline_unsafe_access(!is_store, T_BOOLEAN,  Volatile, false);
 631   case vmIntrinsics::_getByteVolatile:          return inline_unsafe_access(!is_store, T_BYTE,     Volatile, false);
 632   case vmIntrinsics::_getShortVolatile:         return inline_unsafe_access(!is_store, T_SHORT,    Volatile, false);
 633   case vmIntrinsics::_getCharVolatile:          return inline_unsafe_access(!is_store, T_CHAR,     Volatile, false);
 634   case vmIntrinsics::_getIntVolatile:           return inline_unsafe_access(!is_store, T_INT,      Volatile, false);
 635   case vmIntrinsics::_getLongVolatile:          return inline_unsafe_access(!is_store, T_LONG,     Volatile, false);
 636   case vmIntrinsics::_getFloatVolatile:         return inline_unsafe_access(!is_store, T_FLOAT,    Volatile, false);
 637   case vmIntrinsics::_getDoubleVolatile:        return inline_unsafe_access(!is_store, T_DOUBLE,   Volatile, false);
 638 
 639   case vmIntrinsics::_putReferenceVolatile:     return inline_unsafe_access( is_store, T_OBJECT,   Volatile, false);
 640   case vmIntrinsics::_putBooleanVolatile:       return inline_unsafe_access( is_store, T_BOOLEAN,  Volatile, false);
 641   case vmIntrinsics::_putByteVolatile:          return inline_unsafe_access( is_store, T_BYTE,     Volatile, false);
 642   case vmIntrinsics::_putShortVolatile:         return inline_unsafe_access( is_store, T_SHORT,    Volatile, false);
 643   case vmIntrinsics::_putCharVolatile:          return inline_unsafe_access( is_store, T_CHAR,     Volatile, false);
 644   case vmIntrinsics::_putIntVolatile:           return inline_unsafe_access( is_store, T_INT,      Volatile, false);
 645   case vmIntrinsics::_putLongVolatile:          return inline_unsafe_access( is_store, T_LONG,     Volatile, false);
 646   case vmIntrinsics::_putFloatVolatile:         return inline_unsafe_access( is_store, T_FLOAT,    Volatile, false);
 647   case vmIntrinsics::_putDoubleVolatile:        return inline_unsafe_access( is_store, T_DOUBLE,   Volatile, false);
 648 
 649   case vmIntrinsics::_getShortUnaligned:        return inline_unsafe_access(!is_store, T_SHORT,    Relaxed, true);
 650   case vmIntrinsics::_getCharUnaligned:         return inline_unsafe_access(!is_store, T_CHAR,     Relaxed, true);
 651   case vmIntrinsics::_getIntUnaligned:          return inline_unsafe_access(!is_store, T_INT,      Relaxed, true);
 652   case vmIntrinsics::_getLongUnaligned:         return inline_unsafe_access(!is_store, T_LONG,     Relaxed, true);
 653 
 654   case vmIntrinsics::_putShortUnaligned:        return inline_unsafe_access( is_store, T_SHORT,    Relaxed, true);
 655   case vmIntrinsics::_putCharUnaligned:         return inline_unsafe_access( is_store, T_CHAR,     Relaxed, true);
 656   case vmIntrinsics::_putIntUnaligned:          return inline_unsafe_access( is_store, T_INT,      Relaxed, true);
 657   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access( is_store, T_LONG,     Relaxed, true);
 658 
 659   case vmIntrinsics::_getReferenceAcquire:      return inline_unsafe_access(!is_store, T_OBJECT,   Acquire, false);
 660   case vmIntrinsics::_getBooleanAcquire:        return inline_unsafe_access(!is_store, T_BOOLEAN,  Acquire, false);
 661   case vmIntrinsics::_getByteAcquire:           return inline_unsafe_access(!is_store, T_BYTE,     Acquire, false);
 662   case vmIntrinsics::_getShortAcquire:          return inline_unsafe_access(!is_store, T_SHORT,    Acquire, false);
 663   case vmIntrinsics::_getCharAcquire:           return inline_unsafe_access(!is_store, T_CHAR,     Acquire, false);
 664   case vmIntrinsics::_getIntAcquire:            return inline_unsafe_access(!is_store, T_INT,      Acquire, false);
 665   case vmIntrinsics::_getLongAcquire:           return inline_unsafe_access(!is_store, T_LONG,     Acquire, false);
 666   case vmIntrinsics::_getFloatAcquire:          return inline_unsafe_access(!is_store, T_FLOAT,    Acquire, false);
 667   case vmIntrinsics::_getDoubleAcquire:         return inline_unsafe_access(!is_store, T_DOUBLE,   Acquire, false);
 668 
 669   case vmIntrinsics::_putReferenceRelease:      return inline_unsafe_access( is_store, T_OBJECT,   Release, false);
 670   case vmIntrinsics::_putBooleanRelease:        return inline_unsafe_access( is_store, T_BOOLEAN,  Release, false);
 671   case vmIntrinsics::_putByteRelease:           return inline_unsafe_access( is_store, T_BYTE,     Release, false);
 672   case vmIntrinsics::_putShortRelease:          return inline_unsafe_access( is_store, T_SHORT,    Release, false);
 673   case vmIntrinsics::_putCharRelease:           return inline_unsafe_access( is_store, T_CHAR,     Release, false);
 674   case vmIntrinsics::_putIntRelease:            return inline_unsafe_access( is_store, T_INT,      Release, false);
 675   case vmIntrinsics::_putLongRelease:           return inline_unsafe_access( is_store, T_LONG,     Release, false);
 676   case vmIntrinsics::_putFloatRelease:          return inline_unsafe_access( is_store, T_FLOAT,    Release, false);
 677   case vmIntrinsics::_putDoubleRelease:         return inline_unsafe_access( is_store, T_DOUBLE,   Release, false);
 678 
 679   case vmIntrinsics::_getReferenceOpaque:       return inline_unsafe_access(!is_store, T_OBJECT,   Opaque, false);
 680   case vmIntrinsics::_getBooleanOpaque:         return inline_unsafe_access(!is_store, T_BOOLEAN,  Opaque, false);
 681   case vmIntrinsics::_getByteOpaque:            return inline_unsafe_access(!is_store, T_BYTE,     Opaque, false);
 682   case vmIntrinsics::_getShortOpaque:           return inline_unsafe_access(!is_store, T_SHORT,    Opaque, false);
 683   case vmIntrinsics::_getCharOpaque:            return inline_unsafe_access(!is_store, T_CHAR,     Opaque, false);
 684   case vmIntrinsics::_getIntOpaque:             return inline_unsafe_access(!is_store, T_INT,      Opaque, false);
 685   case vmIntrinsics::_getLongOpaque:            return inline_unsafe_access(!is_store, T_LONG,     Opaque, false);
 686   case vmIntrinsics::_getFloatOpaque:           return inline_unsafe_access(!is_store, T_FLOAT,    Opaque, false);
 687   case vmIntrinsics::_getDoubleOpaque:          return inline_unsafe_access(!is_store, T_DOUBLE,   Opaque, false);
 688 
 689   case vmIntrinsics::_putReferenceOpaque:       return inline_unsafe_access( is_store, T_OBJECT,   Opaque, false);
 690   case vmIntrinsics::_putBooleanOpaque:         return inline_unsafe_access( is_store, T_BOOLEAN,  Opaque, false);
 691   case vmIntrinsics::_putByteOpaque:            return inline_unsafe_access( is_store, T_BYTE,     Opaque, false);
 692   case vmIntrinsics::_putShortOpaque:           return inline_unsafe_access( is_store, T_SHORT,    Opaque, false);
 693   case vmIntrinsics::_putCharOpaque:            return inline_unsafe_access( is_store, T_CHAR,     Opaque, false);
 694   case vmIntrinsics::_putIntOpaque:             return inline_unsafe_access( is_store, T_INT,      Opaque, false);
 695   case vmIntrinsics::_putLongOpaque:            return inline_unsafe_access( is_store, T_LONG,     Opaque, false);
 696   case vmIntrinsics::_putFloatOpaque:           return inline_unsafe_access( is_store, T_FLOAT,    Opaque, false);
 697   case vmIntrinsics::_putDoubleOpaque:          return inline_unsafe_access( is_store, T_DOUBLE,   Opaque, false);
 698 
 699   case vmIntrinsics::_compareAndSetReference:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap,      Volatile);
 700   case vmIntrinsics::_compareAndSetByte:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap,      Volatile);
 701   case vmIntrinsics::_compareAndSetShort:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap,      Volatile);
 702   case vmIntrinsics::_compareAndSetInt:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap,      Volatile);
 703   case vmIntrinsics::_compareAndSetLong:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap,      Volatile);
 704 
 705   case vmIntrinsics::_weakCompareAndSetReferencePlain:     return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Relaxed);
 706   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Acquire);
 707   case vmIntrinsics::_weakCompareAndSetReferenceRelease:   return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Release);
 708   case vmIntrinsics::_weakCompareAndSetReference:          return inline_unsafe_load_store(T_OBJECT, LS_cmp_swap_weak, Volatile);
 709   case vmIntrinsics::_weakCompareAndSetBytePlain:          return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Relaxed);
 710   case vmIntrinsics::_weakCompareAndSetByteAcquire:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Acquire);
 711   case vmIntrinsics::_weakCompareAndSetByteRelease:        return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Release);
 712   case vmIntrinsics::_weakCompareAndSetByte:               return inline_unsafe_load_store(T_BYTE,   LS_cmp_swap_weak, Volatile);
 713   case vmIntrinsics::_weakCompareAndSetShortPlain:         return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Relaxed);
 714   case vmIntrinsics::_weakCompareAndSetShortAcquire:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Acquire);
 715   case vmIntrinsics::_weakCompareAndSetShortRelease:       return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Release);
 716   case vmIntrinsics::_weakCompareAndSetShort:              return inline_unsafe_load_store(T_SHORT,  LS_cmp_swap_weak, Volatile);
 717   case vmIntrinsics::_weakCompareAndSetIntPlain:           return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Relaxed);
 718   case vmIntrinsics::_weakCompareAndSetIntAcquire:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Acquire);
 719   case vmIntrinsics::_weakCompareAndSetIntRelease:         return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Release);
 720   case vmIntrinsics::_weakCompareAndSetInt:                return inline_unsafe_load_store(T_INT,    LS_cmp_swap_weak, Volatile);
 721   case vmIntrinsics::_weakCompareAndSetLongPlain:          return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Relaxed);
 722   case vmIntrinsics::_weakCompareAndSetLongAcquire:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Acquire);
 723   case vmIntrinsics::_weakCompareAndSetLongRelease:        return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Release);
 724   case vmIntrinsics::_weakCompareAndSetLong:               return inline_unsafe_load_store(T_LONG,   LS_cmp_swap_weak, Volatile);
 725 
 726   case vmIntrinsics::_compareAndExchangeReference:         return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Volatile);
 727   case vmIntrinsics::_compareAndExchangeReferenceAcquire:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Acquire);
 728   case vmIntrinsics::_compareAndExchangeReferenceRelease:  return inline_unsafe_load_store(T_OBJECT, LS_cmp_exchange,  Release);
 729   case vmIntrinsics::_compareAndExchangeByte:              return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Volatile);
 730   case vmIntrinsics::_compareAndExchangeByteAcquire:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Acquire);
 731   case vmIntrinsics::_compareAndExchangeByteRelease:       return inline_unsafe_load_store(T_BYTE,   LS_cmp_exchange,  Release);
 732   case vmIntrinsics::_compareAndExchangeShort:             return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Volatile);
 733   case vmIntrinsics::_compareAndExchangeShortAcquire:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Acquire);
 734   case vmIntrinsics::_compareAndExchangeShortRelease:      return inline_unsafe_load_store(T_SHORT,  LS_cmp_exchange,  Release);
 735   case vmIntrinsics::_compareAndExchangeInt:               return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Volatile);
 736   case vmIntrinsics::_compareAndExchangeIntAcquire:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Acquire);
 737   case vmIntrinsics::_compareAndExchangeIntRelease:        return inline_unsafe_load_store(T_INT,    LS_cmp_exchange,  Release);
 738   case vmIntrinsics::_compareAndExchangeLong:              return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Volatile);
 739   case vmIntrinsics::_compareAndExchangeLongAcquire:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Acquire);
 740   case vmIntrinsics::_compareAndExchangeLongRelease:       return inline_unsafe_load_store(T_LONG,   LS_cmp_exchange,  Release);
 741 
 742   case vmIntrinsics::_getAndAddByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_add,       Volatile);
 743   case vmIntrinsics::_getAndAddShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_add,       Volatile);
 744   case vmIntrinsics::_getAndAddInt:                     return inline_unsafe_load_store(T_INT,    LS_get_add,       Volatile);
 745   case vmIntrinsics::_getAndAddLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_add,       Volatile);
 746 
 747   case vmIntrinsics::_getAndSetByte:                    return inline_unsafe_load_store(T_BYTE,   LS_get_set,       Volatile);
 748   case vmIntrinsics::_getAndSetShort:                   return inline_unsafe_load_store(T_SHORT,  LS_get_set,       Volatile);
 749   case vmIntrinsics::_getAndSetInt:                     return inline_unsafe_load_store(T_INT,    LS_get_set,       Volatile);
 750   case vmIntrinsics::_getAndSetLong:                    return inline_unsafe_load_store(T_LONG,   LS_get_set,       Volatile);
 751   case vmIntrinsics::_getAndSetReference:               return inline_unsafe_load_store(T_OBJECT, LS_get_set,       Volatile);
 752 
 753   case vmIntrinsics::_loadFence:
 754   case vmIntrinsics::_storeFence:
 755   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 756 
 757   case vmIntrinsics::_onSpinWait:               return inline_onspinwait();
 758 
 759   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 760 
<a name="2" id="anc2"></a>


 761 #ifdef JFR_HAVE_INTRINSICS
 762   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, JFR_TIME_FUNCTION), &quot;counterTime&quot;);
 763   case vmIntrinsics::_getClassId:               return inline_native_classID();
 764   // case vmIntrinsics::_getEventWriter:           return inline_native_getEventWriter();
 765 #endif
 766   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), &quot;currentTimeMillis&quot;);
 767   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), &quot;nanoTime&quot;);
 768   case vmIntrinsics::_writeback0:               return inline_unsafe_writeback0();
 769   case vmIntrinsics::_writebackPreSync0:        return inline_unsafe_writebackSync0(true);
 770   case vmIntrinsics::_writebackPostSync0:       return inline_unsafe_writebackSync0(false);
 771   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 772   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 773   case vmIntrinsics::_getLength:                return inline_native_getLength();
 774   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 775   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 776   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 777   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 778   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 779   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 780 
 781   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 782   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 783 
 784   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 785 
 786   case vmIntrinsics::_isInstance:
 787   case vmIntrinsics::_getModifiers:
 788   case vmIntrinsics::_isInterface:
 789   case vmIntrinsics::_isArray:
 790   case vmIntrinsics::_isPrimitive:
 791   case vmIntrinsics::_getSuperclass:
 792   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 793 
 794   case vmIntrinsics::_floatToRawIntBits:
 795   case vmIntrinsics::_floatToIntBits:
 796   case vmIntrinsics::_intBitsToFloat:
 797   case vmIntrinsics::_doubleToRawLongBits:
 798   case vmIntrinsics::_doubleToLongBits:
 799   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 800 
 801   case vmIntrinsics::_numberOfLeadingZeros_i:
 802   case vmIntrinsics::_numberOfLeadingZeros_l:
 803   case vmIntrinsics::_numberOfTrailingZeros_i:
 804   case vmIntrinsics::_numberOfTrailingZeros_l:
 805   case vmIntrinsics::_bitCount_i:
 806   case vmIntrinsics::_bitCount_l:
 807   case vmIntrinsics::_reverseBytes_i:
 808   case vmIntrinsics::_reverseBytes_l:
 809   case vmIntrinsics::_reverseBytes_s:
 810   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
 811 
 812   case vmIntrinsics::_getCallerClass:           return inline_native_Reflection_getCallerClass();
 813 
 814   case vmIntrinsics::_Reference_get:            return inline_reference_get();
 815 
 816   case vmIntrinsics::_Class_cast:               return inline_Class_cast();
 817 
 818   case vmIntrinsics::_aescrypt_encryptBlock:
 819   case vmIntrinsics::_aescrypt_decryptBlock:    return inline_aescrypt_Block(intrinsic_id());
 820 
 821   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 822   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 823     return inline_cipherBlockChaining_AESCrypt(intrinsic_id());
 824 
 825   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 826   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 827     return inline_electronicCodeBook_AESCrypt(intrinsic_id());
 828 
 829   case vmIntrinsics::_counterMode_AESCrypt:
 830     return inline_counterMode_AESCrypt(intrinsic_id());
 831 
 832   case vmIntrinsics::_sha_implCompress:
 833   case vmIntrinsics::_sha2_implCompress:
 834   case vmIntrinsics::_sha5_implCompress:
 835     return inline_sha_implCompress(intrinsic_id());
 836 
 837   case vmIntrinsics::_digestBase_implCompressMB:
 838     return inline_digestBase_implCompressMB(predicate);
 839 
 840   case vmIntrinsics::_multiplyToLen:
 841     return inline_multiplyToLen();
 842 
 843   case vmIntrinsics::_squareToLen:
 844     return inline_squareToLen();
 845 
 846   case vmIntrinsics::_mulAdd:
 847     return inline_mulAdd();
 848 
 849   case vmIntrinsics::_montgomeryMultiply:
 850     return inline_montgomeryMultiply();
 851   case vmIntrinsics::_montgomerySquare:
 852     return inline_montgomerySquare();
 853 
 854   case vmIntrinsics::_bigIntegerRightShiftWorker:
 855     return inline_bigIntegerShift(true);
 856   case vmIntrinsics::_bigIntegerLeftShiftWorker:
 857     return inline_bigIntegerShift(false);
 858 
 859   case vmIntrinsics::_vectorizedMismatch:
 860     return inline_vectorizedMismatch();
 861 
 862   case vmIntrinsics::_ghash_processBlocks:
 863     return inline_ghash_processBlocks();
 864   case vmIntrinsics::_base64_encodeBlock:
 865     return inline_base64_encodeBlock();
 866 
 867   case vmIntrinsics::_encodeISOArray:
 868   case vmIntrinsics::_encodeByteISOArray:
 869     return inline_encodeISOArray();
 870 
 871   case vmIntrinsics::_updateCRC32:
 872     return inline_updateCRC32();
 873   case vmIntrinsics::_updateBytesCRC32:
 874     return inline_updateBytesCRC32();
 875   case vmIntrinsics::_updateByteBufferCRC32:
 876     return inline_updateByteBufferCRC32();
 877 
 878   case vmIntrinsics::_updateBytesCRC32C:
 879     return inline_updateBytesCRC32C();
 880   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 881     return inline_updateDirectByteBufferCRC32C();
 882 
 883   case vmIntrinsics::_updateBytesAdler32:
 884     return inline_updateBytesAdler32();
 885   case vmIntrinsics::_updateByteBufferAdler32:
 886     return inline_updateByteBufferAdler32();
 887 
 888   case vmIntrinsics::_profileBoolean:
 889     return inline_profileBoolean();
 890   case vmIntrinsics::_isCompileConstant:
 891     return inline_isCompileConstant();
 892 
 893   case vmIntrinsics::_hasNegatives:
 894     return inline_hasNegatives();
 895 
 896   case vmIntrinsics::_fmaD:
 897   case vmIntrinsics::_fmaF:
 898     return inline_fma(intrinsic_id());
 899 
 900   case vmIntrinsics::_Continuation_getSP:
 901   case vmIntrinsics::_Continuation_getPC:
 902     return inline_continuation(intrinsic_id());
 903   case vmIntrinsics::_Continuation_doContinue:
 904     return inline_continuation_do_continue();
 905   case vmIntrinsics::_Continuation_doYield:
 906     return inline_continuation_do_yield();
 907   case vmIntrinsics::_Continuation_jump:
 908     return inline_continuation_jump();
 909   case vmIntrinsics::_Continuation_runLevel:
 910     return inline_continuation_runLevel();
 911 
 912   case vmIntrinsics::_isDigit:
 913   case vmIntrinsics::_isLowerCase:
 914   case vmIntrinsics::_isUpperCase:
 915   case vmIntrinsics::_isWhitespace:
 916     return inline_character_compare(intrinsic_id());
 917 
 918   case vmIntrinsics::_maxF:
 919   case vmIntrinsics::_minF:
 920   case vmIntrinsics::_maxD:
 921   case vmIntrinsics::_minD:
 922     return inline_fp_min_max(intrinsic_id());
 923 
 924   default:
 925     // If you get here, it may be that someone has added a new intrinsic
 926     // to the list in vmSymbols.hpp without implementing it here.
 927 #ifndef PRODUCT
 928     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 929       tty-&gt;print_cr(&quot;*** Warning: Unimplemented intrinsic %s(%d)&quot;,
 930                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 931     }
 932 #endif
 933     return false;
 934   }
 935 }
 936 
 937 Node* LibraryCallKit::try_to_predicate(int predicate) {
 938   if (!jvms()-&gt;has_method()) {
 939     // Root JVMState has a null method.
 940     assert(map()-&gt;memory()-&gt;Opcode() == Op_Parm, &quot;&quot;);
 941     // Insert the memory aliasing node
 942     set_all_memory(reset_memory());
 943   }
 944   assert(merged_memory(), &quot;&quot;);
 945 
 946   switch (intrinsic_id()) {
 947   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 948     return inline_cipherBlockChaining_AESCrypt_predicate(false);
 949   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 950     return inline_cipherBlockChaining_AESCrypt_predicate(true);
 951   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 952     return inline_electronicCodeBook_AESCrypt_predicate(false);
 953   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 954     return inline_electronicCodeBook_AESCrypt_predicate(true);
 955   case vmIntrinsics::_counterMode_AESCrypt:
 956     return inline_counterMode_AESCrypt_predicate();
 957   case vmIntrinsics::_digestBase_implCompressMB:
 958     return inline_digestBase_implCompressMB_predicate(predicate);
 959 
 960   default:
 961     // If you get here, it may be that someone has added a new intrinsic
 962     // to the list in vmSymbols.hpp without implementing it here.
 963 #ifndef PRODUCT
 964     if ((PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) || PrintOpto) {
 965       tty-&gt;print_cr(&quot;*** Warning: Unimplemented predicate for intrinsic %s(%d)&quot;,
 966                     vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());
 967     }
 968 #endif
 969     Node* slow_ctl = control();
 970     set_control(top()); // No fast path instrinsic
 971     return slow_ctl;
 972   }
 973 }
 974 
 975 //------------------------------set_result-------------------------------
 976 // Helper function for finishing intrinsics.
 977 void LibraryCallKit::set_result(RegionNode* region, PhiNode* value) {
 978   record_for_igvn(region);
 979   set_control(_gvn.transform(region));
 980   set_result( _gvn.transform(value));
 981   assert(value-&gt;type()-&gt;basic_type() == result()-&gt;bottom_type()-&gt;basic_type(), &quot;sanity&quot;);
 982 }
 983 
 984 //------------------------------generate_guard---------------------------
 985 // Helper function for generating guarded fast-slow graph structures.
 986 // The given &#39;test&#39;, if true, guards a slow path.  If the test fails
 987 // then a fast path can be taken.  (We generally hope it fails.)
 988 // In all cases, GraphKit::control() is updated to the fast path.
 989 // The returned value represents the control for the slow path.
 990 // The return value is never &#39;top&#39;; it is either a valid control
 991 // or NULL if it is obvious that the slow path can never be taken.
 992 // Also, if region and the slow control are not NULL, the slow edge
 993 // is appended to the region.
 994 Node* LibraryCallKit::generate_guard(Node* test, RegionNode* region, float true_prob) {
 995   if (stopped()) {
 996     // Already short circuited.
 997     return NULL;
 998   }
 999 
1000   // Build an if node and its projections.
1001   // If test is true we take the slow path, which we assume is uncommon.
1002   if (_gvn.type(test) == TypeInt::ZERO) {
1003     // The slow branch is never taken.  No need to build this guard.
1004     return NULL;
1005   }
1006 
1007   IfNode* iff = create_and_map_if(control(), test, true_prob, COUNT_UNKNOWN);
1008 
1009   Node* if_slow = _gvn.transform(new IfTrueNode(iff));
1010   if (if_slow == top()) {
1011     // The slow branch is never taken.  No need to build this guard.
1012     return NULL;
1013   }
1014 
1015   if (region != NULL)
1016     region-&gt;add_req(if_slow);
1017 
1018   Node* if_fast = _gvn.transform(new IfFalseNode(iff));
1019   set_control(if_fast);
1020 
1021   return if_slow;
1022 }
1023 
1024 inline Node* LibraryCallKit::generate_slow_guard(Node* test, RegionNode* region) {
1025   return generate_guard(test, region, PROB_UNLIKELY_MAG(3));
1026 }
1027 inline Node* LibraryCallKit::generate_fair_guard(Node* test, RegionNode* region) {
1028   return generate_guard(test, region, PROB_FAIR);
1029 }
1030 
1031 inline Node* LibraryCallKit::generate_negative_guard(Node* index, RegionNode* region,
1032                                                      Node* *pos_index) {
1033   if (stopped())
1034     return NULL;                // already stopped
1035   if (_gvn.type(index)-&gt;higher_equal(TypeInt::POS)) // [0,maxint]
1036     return NULL;                // index is already adequately typed
1037   Node* cmp_lt = _gvn.transform(new CmpINode(index, intcon(0)));
1038   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1039   Node* is_neg = generate_guard(bol_lt, region, PROB_MIN);
1040   if (is_neg != NULL &amp;&amp; pos_index != NULL) {
1041     // Emulate effect of Parse::adjust_map_after_if.
1042     Node* ccast = new CastIINode(index, TypeInt::POS);
1043     ccast-&gt;set_req(0, control());
1044     (*pos_index) = _gvn.transform(ccast);
1045   }
1046   return is_neg;
1047 }
1048 
1049 // Make sure that &#39;position&#39; is a valid limit index, in [0..length].
1050 // There are two equivalent plans for checking this:
1051 //   A. (offset + copyLength)  unsigned&lt;=  arrayLength
1052 //   B. offset  &lt;=  (arrayLength - copyLength)
1053 // We require that all of the values above, except for the sum and
1054 // difference, are already known to be non-negative.
1055 // Plan A is robust in the face of overflow, if offset and copyLength
1056 // are both hugely positive.
1057 //
1058 // Plan B is less direct and intuitive, but it does not overflow at
1059 // all, since the difference of two non-negatives is always
1060 // representable.  Whenever Java methods must perform the equivalent
1061 // check they generally use Plan B instead of Plan A.
1062 // For the moment we use Plan A.
1063 inline Node* LibraryCallKit::generate_limit_guard(Node* offset,
1064                                                   Node* subseq_length,
1065                                                   Node* array_length,
1066                                                   RegionNode* region) {
1067   if (stopped())
1068     return NULL;                // already stopped
1069   bool zero_offset = _gvn.type(offset) == TypeInt::ZERO;
1070   if (zero_offset &amp;&amp; subseq_length-&gt;eqv_uncast(array_length))
1071     return NULL;                // common case of whole-array copy
1072   Node* last = subseq_length;
1073   if (!zero_offset)             // last += offset
1074     last = _gvn.transform(new AddINode(last, offset));
1075   Node* cmp_lt = _gvn.transform(new CmpUNode(array_length, last));
1076   Node* bol_lt = _gvn.transform(new BoolNode(cmp_lt, BoolTest::lt));
1077   Node* is_over = generate_guard(bol_lt, region, PROB_MIN);
1078   return is_over;
1079 }
1080 
1081 // Emit range checks for the given String.value byte array
1082 void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {
1083   if (stopped()) {
1084     return; // already stopped
1085   }
1086   RegionNode* bailout = new RegionNode(1);
1087   record_for_igvn(bailout);
1088   if (char_count) {
1089     // Convert char count to byte count
1090     count = _gvn.transform(new LShiftINode(count, intcon(1)));
1091   }
1092 
1093   // Offset and count must not be negative
1094   generate_negative_guard(offset, bailout);
1095   generate_negative_guard(count, bailout);
1096   // Offset + count must not exceed length of array
1097   generate_limit_guard(offset, count, load_array_length(array), bailout);
1098 
1099   if (bailout-&gt;req() &gt; 1) {
1100     PreserveJVMState pjvms(this);
1101     set_control(_gvn.transform(bailout));
1102     uncommon_trap(Deoptimization::Reason_intrinsic,
1103                   Deoptimization::Action_maybe_recompile);
1104   }
1105 }
1106 
1107 //--------------------------generate_current_thread--------------------
1108 Node* LibraryCallKit::generate_current_thread(Node* &amp;tls_output) {
1109   ciKlass*    thread_klass = env()-&gt;Thread_klass();
1110   const Type* thread_type  = TypeOopPtr::make_from_klass(thread_klass)-&gt;cast_to_ptr_type(TypePtr::NotNull);
1111   Node* thread = _gvn.transform(new ThreadLocalNode());
1112   Node* p = basic_plus_adr(top()/*!oop*/, thread, in_bytes(JavaThread::threadObj_offset()));
1113   //Node* threadObj = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p-&gt;bottom_type()-&gt;is_ptr(), thread_type, T_OBJECT, MemNode::unordered));
1114   Node* threadObj = make_load(NULL, p, thread_type, T_OBJECT, MemNode::unordered);
1115   tls_output = thread;
1116   return threadObj;
1117 }
1118 
1119 
1120 //------------------------------make_string_method_node------------------------
1121 // Helper method for String intrinsic functions. This version is called with
1122 // str1 and str2 pointing to byte[] nodes containing Latin1 or UTF16 encoded
1123 // characters (depending on &#39;is_byte&#39;). cnt1 and cnt2 are pointing to Int nodes
1124 // containing the lengths of str1 and str2.
1125 Node* LibraryCallKit::make_string_method_node(int opcode, Node* str1_start, Node* cnt1, Node* str2_start, Node* cnt2, StrIntrinsicNode::ArgEnc ae) {
1126   Node* result = NULL;
1127   switch (opcode) {
1128   case Op_StrIndexOf:
1129     result = new StrIndexOfNode(control(), memory(TypeAryPtr::BYTES),
1130                                 str1_start, cnt1, str2_start, cnt2, ae);
1131     break;
1132   case Op_StrComp:
1133     result = new StrCompNode(control(), memory(TypeAryPtr::BYTES),
1134                              str1_start, cnt1, str2_start, cnt2, ae);
1135     break;
1136   case Op_StrEquals:
1137     // We already know that cnt1 == cnt2 here (checked in &#39;inline_string_equals&#39;).
1138     // Use the constant length if there is one because optimized match rule may exist.
1139     result = new StrEqualsNode(control(), memory(TypeAryPtr::BYTES),
1140                                str1_start, str2_start, cnt2-&gt;is_Con() ? cnt2 : cnt1, ae);
1141     break;
1142   default:
1143     ShouldNotReachHere();
1144     return NULL;
1145   }
1146 
1147   // All these intrinsics have checks.
1148   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1149   clear_upper_avx();
1150 
1151   return _gvn.transform(result);
1152 }
1153 
1154 //------------------------------inline_string_compareTo------------------------
1155 bool LibraryCallKit::inline_string_compareTo(StrIntrinsicNode::ArgEnc ae) {
1156   Node* arg1 = argument(0);
1157   Node* arg2 = argument(1);
1158 
1159   arg1 = must_be_not_null(arg1, true);
1160   arg2 = must_be_not_null(arg2, true);
1161 
1162   // Get start addr and length of first argument
1163   Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1164   Node* arg1_cnt    = load_array_length(arg1);
1165 
1166   // Get start addr and length of second argument
1167   Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1168   Node* arg2_cnt    = load_array_length(arg2);
1169 
1170   Node* result = make_string_method_node(Op_StrComp, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1171   set_result(result);
1172   return true;
1173 }
1174 
1175 //------------------------------inline_string_equals------------------------
1176 bool LibraryCallKit::inline_string_equals(StrIntrinsicNode::ArgEnc ae) {
1177   Node* arg1 = argument(0);
1178   Node* arg2 = argument(1);
1179 
1180   // paths (plus control) merge
1181   RegionNode* region = new RegionNode(3);
1182   Node* phi = new PhiNode(region, TypeInt::BOOL);
1183 
1184   if (!stopped()) {
1185 
1186     arg1 = must_be_not_null(arg1, true);
1187     arg2 = must_be_not_null(arg2, true);
1188 
1189     // Get start addr and length of first argument
1190     Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);
1191     Node* arg1_cnt    = load_array_length(arg1);
1192 
1193     // Get start addr and length of second argument
1194     Node* arg2_start  = array_element_address(arg2, intcon(0), T_BYTE);
1195     Node* arg2_cnt    = load_array_length(arg2);
1196 
1197     // Check for arg1_cnt != arg2_cnt
1198     Node* cmp = _gvn.transform(new CmpINode(arg1_cnt, arg2_cnt));
1199     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
1200     Node* if_ne = generate_slow_guard(bol, NULL);
1201     if (if_ne != NULL) {
1202       phi-&gt;init_req(2, intcon(0));
1203       region-&gt;init_req(2, if_ne);
1204     }
1205 
1206     // Check for count == 0 is done by assembler code for StrEquals.
1207 
1208     if (!stopped()) {
1209       Node* equals = make_string_method_node(Op_StrEquals, arg1_start, arg1_cnt, arg2_start, arg2_cnt, ae);
1210       phi-&gt;init_req(1, equals);
1211       region-&gt;init_req(1, control());
1212     }
1213   }
1214 
1215   // post merge
1216   set_control(_gvn.transform(region));
1217   record_for_igvn(region);
1218 
1219   set_result(_gvn.transform(phi));
1220   return true;
1221 }
1222 
1223 //------------------------------inline_array_equals----------------------------
1224 bool LibraryCallKit::inline_array_equals(StrIntrinsicNode::ArgEnc ae) {
1225   assert(ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::LL, &quot;unsupported array types&quot;);
1226   Node* arg1 = argument(0);
1227   Node* arg2 = argument(1);
1228 
1229   const TypeAryPtr* mtype = (ae == StrIntrinsicNode::UU) ? TypeAryPtr::CHARS : TypeAryPtr::BYTES;
1230   set_result(_gvn.transform(new AryEqNode(control(), memory(mtype), arg1, arg2, ae)));
1231   clear_upper_avx();
1232 
1233   return true;
1234 }
1235 
1236 //------------------------------inline_hasNegatives------------------------------
1237 bool LibraryCallKit::inline_hasNegatives() {
1238   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1239     return false;
1240   }
1241 
1242   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;hasNegatives has 3 parameters&quot;);
1243   // no receiver since it is static method
1244   Node* ba         = argument(0);
1245   Node* offset     = argument(1);
1246   Node* len        = argument(2);
1247 
1248   ba = must_be_not_null(ba, true);
1249 
1250   // Range checks
1251   generate_string_range_check(ba, offset, len, false);
1252   if (stopped()) {
1253     return true;
1254   }
1255   Node* ba_start = array_element_address(ba, offset, T_BYTE);
1256   Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);
1257   set_result(_gvn.transform(result));
1258   return true;
1259 }
1260 
1261 bool LibraryCallKit::inline_preconditions_checkIndex() {
1262   Node* index = argument(0);
1263   Node* length = argument(1);
1264   if (too_many_traps(Deoptimization::Reason_intrinsic) || too_many_traps(Deoptimization::Reason_range_check)) {
1265     return false;
1266   }
1267 
1268   Node* len_pos_cmp = _gvn.transform(new CmpINode(length, intcon(0)));
1269   Node* len_pos_bol = _gvn.transform(new BoolNode(len_pos_cmp, BoolTest::ge));
1270 
1271   {
1272     BuildCutout unless(this, len_pos_bol, PROB_MAX);
1273     uncommon_trap(Deoptimization::Reason_intrinsic,
1274                   Deoptimization::Action_make_not_entrant);
1275   }
1276 
1277   if (stopped()) {
1278     return false;
1279   }
1280 
1281   Node* rc_cmp = _gvn.transform(new CmpUNode(index, length));
1282   BoolTest::mask btest = BoolTest::lt;
1283   Node* rc_bool = _gvn.transform(new BoolNode(rc_cmp, btest));
1284   RangeCheckNode* rc = new RangeCheckNode(control(), rc_bool, PROB_MAX, COUNT_UNKNOWN);
1285   _gvn.set_type(rc, rc-&gt;Value(&amp;_gvn));
1286   if (!rc_bool-&gt;is_Con()) {
1287     record_for_igvn(rc);
1288   }
1289   set_control(_gvn.transform(new IfTrueNode(rc)));
1290   {
1291     PreserveJVMState pjvms(this);
1292     set_control(_gvn.transform(new IfFalseNode(rc)));
1293     uncommon_trap(Deoptimization::Reason_range_check,
1294                   Deoptimization::Action_make_not_entrant);
1295   }
1296 
1297   if (stopped()) {
1298     return false;
1299   }
1300 
1301   Node* result = new CastIINode(index, TypeInt::make(0, _gvn.type(length)-&gt;is_int()-&gt;_hi, Type::WidenMax));
1302   result-&gt;set_req(0, control());
1303   result = _gvn.transform(result);
1304   set_result(result);
1305   replace_in_map(index, result);
1306   clear_upper_avx();
1307   return true;
1308 }
1309 
1310 //------------------------------inline_string_indexOf------------------------
1311 bool LibraryCallKit::inline_string_indexOf(StrIntrinsicNode::ArgEnc ae) {
1312   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1313     return false;
1314   }
1315   Node* src = argument(0);
1316   Node* tgt = argument(1);
1317 
1318   // Make the merge point
1319   RegionNode* result_rgn = new RegionNode(4);
1320   Node*       result_phi = new PhiNode(result_rgn, TypeInt::INT);
1321 
1322   src = must_be_not_null(src, true);
1323   tgt = must_be_not_null(tgt, true);
1324 
1325   // Get start addr and length of source string
1326   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
1327   Node* src_count = load_array_length(src);
1328 
1329   // Get start addr and length of substring
1330   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1331   Node* tgt_count = load_array_length(tgt);
1332 
1333   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
1334     // Divide src size by 2 if String is UTF16 encoded
1335     src_count = _gvn.transform(new RShiftINode(src_count, intcon(1)));
1336   }
1337   if (ae == StrIntrinsicNode::UU) {
1338     // Divide substring size by 2 if String is UTF16 encoded
1339     tgt_count = _gvn.transform(new RShiftINode(tgt_count, intcon(1)));
1340   }
1341 
1342   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, result_rgn, result_phi, ae);
1343   if (result != NULL) {
1344     result_phi-&gt;init_req(3, result);
1345     result_rgn-&gt;init_req(3, control());
1346   }
1347   set_control(_gvn.transform(result_rgn));
1348   record_for_igvn(result_rgn);
1349   set_result(_gvn.transform(result_phi));
1350 
1351   return true;
1352 }
1353 
1354 //-----------------------------inline_string_indexOf-----------------------
1355 bool LibraryCallKit::inline_string_indexOfI(StrIntrinsicNode::ArgEnc ae) {
1356   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1357     return false;
1358   }
1359   if (!Matcher::match_rule_supported(Op_StrIndexOf)) {
1360     return false;
1361   }
1362   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;String.indexOf() has 5 arguments&quot;);
1363   Node* src         = argument(0); // byte[]
1364   Node* src_count   = argument(1); // char count
1365   Node* tgt         = argument(2); // byte[]
1366   Node* tgt_count   = argument(3); // char count
1367   Node* from_index  = argument(4); // char index
1368 
1369   src = must_be_not_null(src, true);
1370   tgt = must_be_not_null(tgt, true);
1371 
1372   // Multiply byte array index by 2 if String is UTF16 encoded
1373   Node* src_offset = (ae == StrIntrinsicNode::LL) ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));
1374   src_count = _gvn.transform(new SubINode(src_count, from_index));
1375   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1376   Node* tgt_start = array_element_address(tgt, intcon(0), T_BYTE);
1377 
1378   // Range checks
1379   generate_string_range_check(src, src_offset, src_count, ae != StrIntrinsicNode::LL);
1380   generate_string_range_check(tgt, intcon(0), tgt_count, ae == StrIntrinsicNode::UU);
1381   if (stopped()) {
1382     return true;
1383   }
1384 
1385   RegionNode* region = new RegionNode(5);
1386   Node* phi = new PhiNode(region, TypeInt::INT);
1387 
1388   Node* result = make_indexOf_node(src_start, src_count, tgt_start, tgt_count, region, phi, ae);
1389   if (result != NULL) {
1390     // The result is index relative to from_index if substring was found, -1 otherwise.
1391     // Generate code which will fold into cmove.
1392     Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1393     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1394 
1395     Node* if_lt = generate_slow_guard(bol, NULL);
1396     if (if_lt != NULL) {
1397       // result == -1
1398       phi-&gt;init_req(3, result);
1399       region-&gt;init_req(3, if_lt);
1400     }
1401     if (!stopped()) {
1402       result = _gvn.transform(new AddINode(result, from_index));
1403       phi-&gt;init_req(4, result);
1404       region-&gt;init_req(4, control());
1405     }
1406   }
1407 
1408   set_control(_gvn.transform(region));
1409   record_for_igvn(region);
1410   set_result(_gvn.transform(phi));
1411   clear_upper_avx();
1412 
1413   return true;
1414 }
1415 
1416 // Create StrIndexOfNode with fast path checks
1417 Node* LibraryCallKit::make_indexOf_node(Node* src_start, Node* src_count, Node* tgt_start, Node* tgt_count,
1418                                         RegionNode* region, Node* phi, StrIntrinsicNode::ArgEnc ae) {
1419   // Check for substr count &gt; string count
1420   Node* cmp = _gvn.transform(new CmpINode(tgt_count, src_count));
1421   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::gt));
1422   Node* if_gt = generate_slow_guard(bol, NULL);
1423   if (if_gt != NULL) {
1424     phi-&gt;init_req(1, intcon(-1));
1425     region-&gt;init_req(1, if_gt);
1426   }
1427   if (!stopped()) {
1428     // Check for substr count == 0
1429     cmp = _gvn.transform(new CmpINode(tgt_count, intcon(0)));
1430     bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
1431     Node* if_zero = generate_slow_guard(bol, NULL);
1432     if (if_zero != NULL) {
1433       phi-&gt;init_req(2, intcon(0));
1434       region-&gt;init_req(2, if_zero);
1435     }
1436   }
1437   if (!stopped()) {
1438     return make_string_method_node(Op_StrIndexOf, src_start, src_count, tgt_start, tgt_count, ae);
1439   }
1440   return NULL;
1441 }
1442 
1443 //-----------------------------inline_string_indexOfChar-----------------------
1444 bool LibraryCallKit::inline_string_indexOfChar() {
1445   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1446     return false;
1447   }
1448   if (!Matcher::match_rule_supported(Op_StrIndexOfChar)) {
1449     return false;
1450   }
1451   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;String.indexOfChar() has 4 arguments&quot;);
1452   Node* src         = argument(0); // byte[]
1453   Node* tgt         = argument(1); // tgt is int ch
1454   Node* from_index  = argument(2);
1455   Node* max         = argument(3);
1456 
1457   src = must_be_not_null(src, true);
1458 
1459   Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));
1460   Node* src_start = array_element_address(src, src_offset, T_BYTE);
1461   Node* src_count = _gvn.transform(new SubINode(max, from_index));
1462 
1463   // Range checks
1464   generate_string_range_check(src, src_offset, src_count, true);
1465   if (stopped()) {
1466     return true;
1467   }
1468 
1469   RegionNode* region = new RegionNode(3);
1470   Node* phi = new PhiNode(region, TypeInt::INT);
1471 
1472   Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);
1473   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1474   _gvn.transform(result);
1475 
1476   Node* cmp = _gvn.transform(new CmpINode(result, intcon(0)));
1477   Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::lt));
1478 
1479   Node* if_lt = generate_slow_guard(bol, NULL);
1480   if (if_lt != NULL) {
1481     // result == -1
1482     phi-&gt;init_req(2, result);
1483     region-&gt;init_req(2, if_lt);
1484   }
1485   if (!stopped()) {
1486     result = _gvn.transform(new AddINode(result, from_index));
1487     phi-&gt;init_req(1, result);
1488     region-&gt;init_req(1, control());
1489   }
1490   set_control(_gvn.transform(region));
1491   record_for_igvn(region);
1492   set_result(_gvn.transform(phi));
1493 
1494   return true;
1495 }
1496 //---------------------------inline_string_copy---------------------
1497 // compressIt == true --&gt; generate a compressed copy operation (compress char[]/byte[] to byte[])
1498 //   int StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)
1499 //   int StringUTF16.compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1500 // compressIt == false --&gt; generate an inflated copy operation (inflate byte[] to char[]/byte[])
1501 //   void StringLatin1.inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len)
1502 //   void StringLatin1.inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len)
1503 bool LibraryCallKit::inline_string_copy(bool compress) {
1504   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1505     return false;
1506   }
1507   int nargs = 5;  // 2 oops, 3 ints
1508   assert(callee()-&gt;signature()-&gt;size() == nargs, &quot;string copy has 5 arguments&quot;);
1509 
1510   Node* src         = argument(0);
1511   Node* src_offset  = argument(1);
1512   Node* dst         = argument(2);
1513   Node* dst_offset  = argument(3);
1514   Node* length      = argument(4);
1515 
1516   // Check for allocation before we add nodes that would confuse
1517   // tightly_coupled_allocation()
1518   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1519 
1520   // Figure out the size and type of the elements we will be copying.
1521   const Type* src_type = src-&gt;Value(&amp;_gvn);
1522   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
1523   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1524   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
1525   assert((compress &amp;&amp; dst_elem == T_BYTE &amp;&amp; (src_elem == T_BYTE || src_elem == T_CHAR)) ||
1526          (!compress &amp;&amp; src_elem == T_BYTE &amp;&amp; (dst_elem == T_BYTE || dst_elem == T_CHAR)),
1527          &quot;Unsupported array types for inline_string_copy&quot;);
1528 
1529   src = must_be_not_null(src, true);
1530   dst = must_be_not_null(dst, true);
1531 
1532   // Convert char[] offsets to byte[] offsets
1533   bool convert_src = (compress &amp;&amp; src_elem == T_BYTE);
1534   bool convert_dst = (!compress &amp;&amp; dst_elem == T_BYTE);
1535   if (convert_src) {
1536     src_offset = _gvn.transform(new LShiftINode(src_offset, intcon(1)));
1537   } else if (convert_dst) {
1538     dst_offset = _gvn.transform(new LShiftINode(dst_offset, intcon(1)));
1539   }
1540 
1541   // Range checks
1542   generate_string_range_check(src, src_offset, length, convert_src);
1543   generate_string_range_check(dst, dst_offset, length, convert_dst);
1544   if (stopped()) {
1545     return true;
1546   }
1547 
1548   Node* src_start = array_element_address(src, src_offset, src_elem);
1549   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
1550   // &#39;src_start&#39; points to src array + scaled offset
1551   // &#39;dst_start&#39; points to dst array + scaled offset
1552   Node* count = NULL;
1553   if (compress) {
1554     count = compress_string(src_start, TypeAryPtr::get_array_body_type(src_elem), dst_start, length);
1555   } else {
1556     inflate_string(src_start, dst_start, TypeAryPtr::get_array_body_type(dst_elem), length);
1557   }
1558 
1559   if (alloc != NULL) {
1560     if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1561       // &quot;You break it, you buy it.&quot;
1562       InitializeNode* init = alloc-&gt;initialization();
1563       assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1564       init-&gt;set_complete_with_arraycopy();
1565       assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1566       assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1567     }
1568     // Do not let stores that initialize this object be reordered with
1569     // a subsequent store that would make this object accessible by
1570     // other threads.
1571     // Record what AllocateNode this StoreStore protects so that
1572     // escape analysis can go from the MemBarStoreStoreNode to the
1573     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1574     // based on the escape status of the AllocateNode.
1575     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1576   }
1577   if (compress) {
1578     set_result(_gvn.transform(count));
1579   }
1580   clear_upper_avx();
1581 
1582   return true;
1583 }
1584 
1585 #ifdef _LP64
1586 #define XTOP ,top() /*additional argument*/
1587 #else  //_LP64
1588 #define XTOP        /*no additional argument*/
1589 #endif //_LP64
1590 
1591 //------------------------inline_string_toBytesU--------------------------
1592 // public static byte[] StringUTF16.toBytes(char[] value, int off, int len)
1593 bool LibraryCallKit::inline_string_toBytesU() {
1594   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1595     return false;
1596   }
1597   // Get the arguments.
1598   Node* value     = argument(0);
1599   Node* offset    = argument(1);
1600   Node* length    = argument(2);
1601 
1602   Node* newcopy = NULL;
1603 
1604   // Set the original stack and the reexecute bit for the interpreter to reexecute
1605   // the bytecode that invokes StringUTF16.toBytes() if deoptimization happens.
1606   { PreserveReexecuteState preexecs(this);
1607     jvms()-&gt;set_should_reexecute(true);
1608 
1609     // Check if a null path was taken unconditionally.
1610     value = null_check(value);
1611 
1612     RegionNode* bailout = new RegionNode(1);
1613     record_for_igvn(bailout);
1614 
1615     // Range checks
1616     generate_negative_guard(offset, bailout);
1617     generate_negative_guard(length, bailout);
1618     generate_limit_guard(offset, length, load_array_length(value), bailout);
1619     // Make sure that resulting byte[] length does not overflow Integer.MAX_VALUE
1620     generate_limit_guard(length, intcon(0), intcon(max_jint/2), bailout);
1621 
1622     if (bailout-&gt;req() &gt; 1) {
1623       PreserveJVMState pjvms(this);
1624       set_control(_gvn.transform(bailout));
1625       uncommon_trap(Deoptimization::Reason_intrinsic,
1626                     Deoptimization::Action_maybe_recompile);
1627     }
1628     if (stopped()) {
1629       return true;
1630     }
1631 
1632     Node* size = _gvn.transform(new LShiftINode(length, intcon(1)));
1633     Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_BYTE)));
1634     newcopy = new_array(klass_node, size, 0);  // no arguments to push
1635     AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);
1636 
1637     // Calculate starting addresses.
1638     Node* src_start = array_element_address(value, offset, T_CHAR);
1639     Node* dst_start = basic_plus_adr(newcopy, arrayOopDesc::base_offset_in_bytes(T_BYTE));
1640 
1641     // Check if src array address is aligned to HeapWordSize (dst is always aligned)
1642     const TypeInt* toffset = gvn().type(offset)-&gt;is_int();
1643     bool aligned = toffset-&gt;is_con() &amp;&amp; ((toffset-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1644 
1645     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1646     const char* copyfunc_name = &quot;arraycopy&quot;;
1647     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1648     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1649                       OptoRuntime::fast_arraycopy_Type(),
1650                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1651                       src_start, dst_start, ConvI2X(length) XTOP);
1652     // Do not let reads from the cloned object float above the arraycopy.
1653     if (alloc != NULL) {
1654       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1655         // &quot;You break it, you buy it.&quot;
1656         InitializeNode* init = alloc-&gt;initialization();
1657         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1658         init-&gt;set_complete_with_arraycopy();
1659         assert(newcopy-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1660         assert(newcopy-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1661       }
1662       // Do not let stores that initialize this object be reordered with
1663       // a subsequent store that would make this object accessible by
1664       // other threads.
1665       // Record what AllocateNode this StoreStore protects so that
1666       // escape analysis can go from the MemBarStoreStoreNode to the
1667       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1668       // based on the escape status of the AllocateNode.
1669       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1670     } else {
1671       insert_mem_bar(Op_MemBarCPUOrder);
1672     }
1673   } // original reexecute is set back here
1674 
1675   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1676   if (!stopped()) {
1677     set_result(newcopy);
1678   }
1679   clear_upper_avx();
1680 
1681   return true;
1682 }
1683 
1684 //------------------------inline_string_getCharsU--------------------------
1685 // public void StringUTF16.getChars(byte[] src, int srcBegin, int srcEnd, char dst[], int dstBegin)
1686 bool LibraryCallKit::inline_string_getCharsU() {
1687   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
1688     return false;
1689   }
1690 
1691   // Get the arguments.
1692   Node* src       = argument(0);
1693   Node* src_begin = argument(1);
1694   Node* src_end   = argument(2); // exclusive offset (i &lt; src_end)
1695   Node* dst       = argument(3);
1696   Node* dst_begin = argument(4);
1697 
1698   // Check for allocation before we add nodes that would confuse
1699   // tightly_coupled_allocation()
1700   AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);
1701 
1702   // Check if a null path was taken unconditionally.
1703   src = null_check(src);
1704   dst = null_check(dst);
1705   if (stopped()) {
1706     return true;
1707   }
1708 
1709   // Get length and convert char[] offset to byte[] offset
1710   Node* length = _gvn.transform(new SubINode(src_end, src_begin));
1711   src_begin = _gvn.transform(new LShiftINode(src_begin, intcon(1)));
1712 
1713   // Range checks
1714   generate_string_range_check(src, src_begin, length, true);
1715   generate_string_range_check(dst, dst_begin, length, false);
1716   if (stopped()) {
1717     return true;
1718   }
1719 
1720   if (!stopped()) {
1721     // Calculate starting addresses.
1722     Node* src_start = array_element_address(src, src_begin, T_BYTE);
1723     Node* dst_start = array_element_address(dst, dst_begin, T_CHAR);
1724 
1725     // Check if array addresses are aligned to HeapWordSize
1726     const TypeInt* tsrc = gvn().type(src_begin)-&gt;is_int();
1727     const TypeInt* tdst = gvn().type(dst_begin)-&gt;is_int();
1728     bool aligned = tsrc-&gt;is_con() &amp;&amp; ((tsrc-&gt;get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &amp;&amp;
1729                    tdst-&gt;is_con() &amp;&amp; ((tdst-&gt;get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);
1730 
1731     // Figure out which arraycopy runtime method to call (disjoint, uninitialized).
1732     const char* copyfunc_name = &quot;arraycopy&quot;;
1733     address     copyfunc_addr = StubRoutines::select_arraycopy_function(T_CHAR, aligned, true, copyfunc_name, true);
1734     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
1735                       OptoRuntime::fast_arraycopy_Type(),
1736                       copyfunc_addr, copyfunc_name, TypeRawPtr::BOTTOM,
1737                       src_start, dst_start, ConvI2X(length) XTOP);
1738     // Do not let reads from the cloned object float above the arraycopy.
1739     if (alloc != NULL) {
1740       if (alloc-&gt;maybe_set_complete(&amp;_gvn)) {
1741         // &quot;You break it, you buy it.&quot;
1742         InitializeNode* init = alloc-&gt;initialization();
1743         assert(init-&gt;is_complete(), &quot;we just did this&quot;);
1744         init-&gt;set_complete_with_arraycopy();
1745         assert(dst-&gt;is_CheckCastPP(), &quot;sanity&quot;);
1746         assert(dst-&gt;in(0)-&gt;in(0) == init, &quot;dest pinned&quot;);
1747       }
1748       // Do not let stores that initialize this object be reordered with
1749       // a subsequent store that would make this object accessible by
1750       // other threads.
1751       // Record what AllocateNode this StoreStore protects so that
1752       // escape analysis can go from the MemBarStoreStoreNode to the
1753       // AllocateNode and eliminate the MemBarStoreStoreNode if possible
1754       // based on the escape status of the AllocateNode.
1755       insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
1756     } else {
1757       insert_mem_bar(Op_MemBarCPUOrder);
1758     }
1759   }
1760 
1761   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1762   return true;
1763 }
1764 
1765 //----------------------inline_string_char_access----------------------------
1766 // Store/Load char to/from byte[] array.
1767 // static void StringUTF16.putChar(byte[] val, int index, int c)
1768 // static char StringUTF16.getChar(byte[] val, int index)
1769 bool LibraryCallKit::inline_string_char_access(bool is_store) {
1770   Node* value  = argument(0);
1771   Node* index  = argument(1);
1772   Node* ch = is_store ? argument(2) : NULL;
1773 
1774   // This intrinsic accesses byte[] array as char[] array. Computing the offsets
1775   // correctly requires matched array shapes.
1776   assert (arrayOopDesc::base_offset_in_bytes(T_CHAR) == arrayOopDesc::base_offset_in_bytes(T_BYTE),
1777           &quot;sanity: byte[] and char[] bases agree&quot;);
1778   assert (type2aelembytes(T_CHAR) == type2aelembytes(T_BYTE)*2,
1779           &quot;sanity: byte[] and char[] scales agree&quot;);
1780 
1781   // Bail when getChar over constants is requested: constant folding would
1782   // reject folding mismatched char access over byte[]. A normal inlining for getChar
1783   // Java method would constant fold nicely instead.
1784   if (!is_store &amp;&amp; value-&gt;is_Con() &amp;&amp; index-&gt;is_Con()) {
1785     return false;
1786   }
1787 
1788   value = must_be_not_null(value, true);
1789 
1790   Node* adr = array_element_address(value, index, T_CHAR);
1791   if (adr-&gt;is_top()) {
1792     return false;
1793   }
1794   if (is_store) {
1795     access_store_at(value, adr, TypeAryPtr::BYTES, ch, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED);
1796   } else {
1797     ch = access_load_at(value, adr, TypeAryPtr::BYTES, TypeInt::CHAR, T_CHAR, IN_HEAP | MO_UNORDERED | C2_MISMATCHED | C2_CONTROL_DEPENDENT_LOAD);
1798     set_result(ch);
1799   }
1800   return true;
1801 }
1802 
1803 //--------------------------round_double_node--------------------------------
1804 // Round a double node if necessary.
1805 Node* LibraryCallKit::round_double_node(Node* n) {
1806   if (Matcher::strict_fp_requires_explicit_rounding &amp;&amp; UseSSE &lt;= 1)
1807     n = _gvn.transform(new RoundDoubleNode(0, n));
1808   return n;
1809 }
1810 
1811 //------------------------------inline_math-----------------------------------
1812 // public static double Math.abs(double)
1813 // public static double Math.sqrt(double)
1814 // public static double Math.log(double)
1815 // public static double Math.log10(double)
1816 bool LibraryCallKit::inline_double_math(vmIntrinsics::ID id) {
1817   Node* arg = round_double_node(argument(0));
1818   Node* n = NULL;
1819   switch (id) {
1820   case vmIntrinsics::_dabs:   n = new AbsDNode(                arg);  break;
1821   case vmIntrinsics::_dsqrt:  n = new SqrtDNode(C, control(),  arg);  break;
1822   case vmIntrinsics::_ceil:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_ceil); break;
1823   case vmIntrinsics::_floor:  n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_floor); break;
1824   case vmIntrinsics::_rint:   n = RoundDoubleModeNode::make(_gvn, arg, RoundDoubleModeNode::rmode_rint); break;
1825   default:  fatal_unexpected_iid(id);  break;
1826   }
1827   set_result(_gvn.transform(n));
1828   return true;
1829 }
1830 
1831 //------------------------------inline_math-----------------------------------
1832 // public static float Math.abs(float)
1833 // public static int Math.abs(int)
1834 // public static long Math.abs(long)
1835 bool LibraryCallKit::inline_math(vmIntrinsics::ID id) {
1836   Node* arg = argument(0);
1837   Node* n = NULL;
1838   switch (id) {
1839   case vmIntrinsics::_fabs:   n = new AbsFNode(                arg);  break;
1840   case vmIntrinsics::_iabs:   n = new AbsINode(                arg);  break;
1841   case vmIntrinsics::_labs:   n = new AbsLNode(                arg);  break;
1842   default:  fatal_unexpected_iid(id);  break;
1843   }
1844   set_result(_gvn.transform(n));
1845   return true;
1846 }
1847 
1848 //------------------------------runtime_math-----------------------------
1849 bool LibraryCallKit::runtime_math(const TypeFunc* call_type, address funcAddr, const char* funcName) {
1850   assert(call_type == OptoRuntime::Math_DD_D_Type() || call_type == OptoRuntime::Math_D_D_Type(),
1851          &quot;must be (DD)D or (D)D type&quot;);
1852 
1853   // Inputs
1854   Node* a = round_double_node(argument(0));
1855   Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : NULL;
1856 
1857   const TypePtr* no_memory_effects = NULL;
1858   Node* trig = make_runtime_call(RC_LEAF, call_type, funcAddr, funcName,
1859                                  no_memory_effects,
1860                                  a, top(), b, b ? top() : NULL);
1861   Node* value = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+0));
1862 #ifdef ASSERT
1863   Node* value_top = _gvn.transform(new ProjNode(trig, TypeFunc::Parms+1));
1864   assert(value_top == top(), &quot;second value must be top&quot;);
1865 #endif
1866 
1867   set_result(value);
1868   return true;
1869 }
1870 
1871 //------------------------------inline_math_native-----------------------------
1872 bool LibraryCallKit::inline_math_native(vmIntrinsics::ID id) {
1873 #define FN_PTR(f) CAST_FROM_FN_PTR(address, f)
1874   switch (id) {
1875     // These intrinsics are not properly supported on all hardware
1876   case vmIntrinsics::_dsin:
1877     return StubRoutines::dsin() != NULL ?
1878       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dsin(), &quot;dsin&quot;) :
1879       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dsin),   &quot;SIN&quot;);
1880   case vmIntrinsics::_dcos:
1881     return StubRoutines::dcos() != NULL ?
1882       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcos(), &quot;dcos&quot;) :
1883       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dcos),   &quot;COS&quot;);
1884   case vmIntrinsics::_dtan:
1885     return StubRoutines::dtan() != NULL ?
1886       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtan(), &quot;dtan&quot;) :
1887       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dtan), &quot;TAN&quot;);
1888   case vmIntrinsics::_dlog:
1889     return StubRoutines::dlog() != NULL ?
1890       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog(), &quot;dlog&quot;) :
1891       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog),   &quot;LOG&quot;);
1892   case vmIntrinsics::_dlog10:
1893     return StubRoutines::dlog10() != NULL ?
1894       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dlog10(), &quot;dlog10&quot;) :
1895       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dlog10), &quot;LOG10&quot;);
1896 
1897     // These intrinsics are supported on all hardware
1898   case vmIntrinsics::_ceil:
1899   case vmIntrinsics::_floor:
1900   case vmIntrinsics::_rint:   return Matcher::match_rule_supported(Op_RoundDoubleMode) ? inline_double_math(id) : false;
1901   case vmIntrinsics::_dsqrt:  return Matcher::match_rule_supported(Op_SqrtD) ? inline_double_math(id) : false;
1902   case vmIntrinsics::_dabs:   return Matcher::has_match_rule(Op_AbsD)   ? inline_double_math(id) : false;
1903   case vmIntrinsics::_fabs:   return Matcher::match_rule_supported(Op_AbsF)   ? inline_math(id) : false;
1904   case vmIntrinsics::_iabs:   return Matcher::match_rule_supported(Op_AbsI)   ? inline_math(id) : false;
1905   case vmIntrinsics::_labs:   return Matcher::match_rule_supported(Op_AbsL)   ? inline_math(id) : false;
1906 
1907   case vmIntrinsics::_dexp:
1908     return StubRoutines::dexp() != NULL ?
1909       runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dexp(),  &quot;dexp&quot;) :
1910       runtime_math(OptoRuntime::Math_D_D_Type(), FN_PTR(SharedRuntime::dexp),  &quot;EXP&quot;);
1911   case vmIntrinsics::_dpow: {
1912     Node* exp = round_double_node(argument(2));
1913     const TypeD* d = _gvn.type(exp)-&gt;isa_double_constant();
1914     if (d != NULL &amp;&amp; d-&gt;getd() == 2.0) {
1915       // Special case: pow(x, 2.0) =&gt; x * x
1916       Node* base = round_double_node(argument(0));
1917       set_result(_gvn.transform(new MulDNode(base, base)));
1918       return true;
1919     }
1920     return StubRoutines::dpow() != NULL ?
1921       runtime_math(OptoRuntime::Math_DD_D_Type(), StubRoutines::dpow(),  &quot;dpow&quot;) :
1922       runtime_math(OptoRuntime::Math_DD_D_Type(), FN_PTR(SharedRuntime::dpow),  &quot;POW&quot;);
1923   }
1924 #undef FN_PTR
1925 
1926    // These intrinsics are not yet correctly implemented
1927   case vmIntrinsics::_datan2:
1928     return false;
1929 
1930   default:
1931     fatal_unexpected_iid(id);
1932     return false;
1933   }
1934 }
1935 
1936 static bool is_simple_name(Node* n) {
1937   return (n-&gt;req() == 1         // constant
1938           || (n-&gt;is_Type() &amp;&amp; n-&gt;as_Type()-&gt;type()-&gt;singleton())
1939           || n-&gt;is_Proj()       // parameter or return value
1940           || n-&gt;is_Phi()        // local of some sort
1941           );
1942 }
1943 
1944 //----------------------------inline_notify-----------------------------------*
1945 bool LibraryCallKit::inline_notify(vmIntrinsics::ID id) {
1946   const TypeFunc* ftype = OptoRuntime::monitor_notify_Type();
1947   address func;
1948   if (id == vmIntrinsics::_notify) {
1949     func = OptoRuntime::monitor_notify_Java();
1950   } else {
1951     func = OptoRuntime::monitor_notifyAll_Java();
1952   }
1953   Node* call = make_runtime_call(RC_NO_LEAF, ftype, func, NULL, TypeRawPtr::BOTTOM, argument(0));
1954   make_slow_call_ex(call, env()-&gt;Throwable_klass(), false);
1955   return true;
1956 }
1957 
1958 
1959 //----------------------------inline_min_max-----------------------------------
1960 bool LibraryCallKit::inline_min_max(vmIntrinsics::ID id) {
1961   set_result(generate_min_max(id, argument(0), argument(1)));
1962   return true;
1963 }
1964 
1965 void LibraryCallKit::inline_math_mathExact(Node* math, Node *test) {
1966   Node* bol = _gvn.transform( new BoolNode(test, BoolTest::overflow) );
1967   IfNode* check = create_and_map_if(control(), bol, PROB_UNLIKELY_MAG(3), COUNT_UNKNOWN);
1968   Node* fast_path = _gvn.transform( new IfFalseNode(check));
1969   Node* slow_path = _gvn.transform( new IfTrueNode(check) );
1970 
1971   {
1972     PreserveJVMState pjvms(this);
1973     PreserveReexecuteState preexecs(this);
1974     jvms()-&gt;set_should_reexecute(true);
1975 
1976     set_control(slow_path);
1977     set_i_o(i_o());
1978 
1979     uncommon_trap(Deoptimization::Reason_intrinsic,
1980                   Deoptimization::Action_none);
1981   }
1982 
1983   set_control(fast_path);
1984   set_result(math);
1985 }
1986 
1987 template &lt;typename OverflowOp&gt;
1988 bool LibraryCallKit::inline_math_overflow(Node* arg1, Node* arg2) {
1989   typedef typename OverflowOp::MathOp MathOp;
1990 
1991   MathOp* mathOp = new MathOp(arg1, arg2);
1992   Node* operation = _gvn.transform( mathOp );
1993   Node* ofcheck = _gvn.transform( new OverflowOp(arg1, arg2) );
1994   inline_math_mathExact(operation, ofcheck);
1995   return true;
1996 }
1997 
1998 bool LibraryCallKit::inline_math_addExactI(bool is_increment) {
1999   return inline_math_overflow&lt;OverflowAddINode&gt;(argument(0), is_increment ? intcon(1) : argument(1));
2000 }
2001 
2002 bool LibraryCallKit::inline_math_addExactL(bool is_increment) {
2003   return inline_math_overflow&lt;OverflowAddLNode&gt;(argument(0), is_increment ? longcon(1) : argument(2));
2004 }
2005 
2006 bool LibraryCallKit::inline_math_subtractExactI(bool is_decrement) {
2007   return inline_math_overflow&lt;OverflowSubINode&gt;(argument(0), is_decrement ? intcon(1) : argument(1));
2008 }
2009 
2010 bool LibraryCallKit::inline_math_subtractExactL(bool is_decrement) {
2011   return inline_math_overflow&lt;OverflowSubLNode&gt;(argument(0), is_decrement ? longcon(1) : argument(2));
2012 }
2013 
2014 bool LibraryCallKit::inline_math_negateExactI() {
2015   return inline_math_overflow&lt;OverflowSubINode&gt;(intcon(0), argument(0));
2016 }
2017 
2018 bool LibraryCallKit::inline_math_negateExactL() {
2019   return inline_math_overflow&lt;OverflowSubLNode&gt;(longcon(0), argument(0));
2020 }
2021 
2022 bool LibraryCallKit::inline_math_multiplyExactI() {
2023   return inline_math_overflow&lt;OverflowMulINode&gt;(argument(0), argument(1));
2024 }
2025 
2026 bool LibraryCallKit::inline_math_multiplyExactL() {
2027   return inline_math_overflow&lt;OverflowMulLNode&gt;(argument(0), argument(2));
2028 }
2029 
2030 bool LibraryCallKit::inline_math_multiplyHigh() {
2031   set_result(_gvn.transform(new MulHiLNode(argument(0), argument(2))));
2032   return true;
2033 }
2034 
2035 Node*
2036 LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {
2037   // These are the candidate return value:
2038   Node* xvalue = x0;
2039   Node* yvalue = y0;
2040 
2041   if (xvalue == yvalue) {
2042     return xvalue;
2043   }
2044 
2045   bool want_max = (id == vmIntrinsics::_max);
2046 
2047   const TypeInt* txvalue = _gvn.type(xvalue)-&gt;isa_int();
2048   const TypeInt* tyvalue = _gvn.type(yvalue)-&gt;isa_int();
2049   if (txvalue == NULL || tyvalue == NULL)  return top();
2050   // This is not really necessary, but it is consistent with a
2051   // hypothetical MaxINode::Value method:
2052   int widen = MAX2(txvalue-&gt;_widen, tyvalue-&gt;_widen);
2053 
2054   // %%% This folding logic should (ideally) be in a different place.
2055   // Some should be inside IfNode, and there to be a more reliable
2056   // transformation of ?: style patterns into cmoves.  We also want
2057   // more powerful optimizations around cmove and min/max.
2058 
2059   // Try to find a dominating comparison of these guys.
2060   // It can simplify the index computation for Arrays.copyOf
2061   // and similar uses of System.arraycopy.
2062   // First, compute the normalized version of CmpI(x, y).
2063   int   cmp_op = Op_CmpI;
2064   Node* xkey = xvalue;
2065   Node* ykey = yvalue;
2066   Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));
2067   if (ideal_cmpxy-&gt;is_Cmp()) {
2068     // E.g., if we have CmpI(length - offset, count),
2069     // it might idealize to CmpI(length, count + offset)
2070     cmp_op = ideal_cmpxy-&gt;Opcode();
2071     xkey = ideal_cmpxy-&gt;in(1);
2072     ykey = ideal_cmpxy-&gt;in(2);
2073   }
2074 
2075   // Start by locating any relevant comparisons.
2076   Node* start_from = (xkey-&gt;outcnt() &lt; ykey-&gt;outcnt()) ? xkey : ykey;
2077   Node* cmpxy = NULL;
2078   Node* cmpyx = NULL;
2079   for (DUIterator_Fast kmax, k = start_from-&gt;fast_outs(kmax); k &lt; kmax; k++) {
2080     Node* cmp = start_from-&gt;fast_out(k);
2081     if (cmp-&gt;outcnt() &gt; 0 &amp;&amp;            // must have prior uses
2082         cmp-&gt;in(0) == NULL &amp;&amp;           // must be context-independent
2083         cmp-&gt;Opcode() == cmp_op) {      // right kind of compare
2084       if (cmp-&gt;in(1) == xkey &amp;&amp; cmp-&gt;in(2) == ykey)  cmpxy = cmp;
2085       if (cmp-&gt;in(1) == ykey &amp;&amp; cmp-&gt;in(2) == xkey)  cmpyx = cmp;
2086     }
2087   }
2088 
2089   const int NCMPS = 2;
2090   Node* cmps[NCMPS] = { cmpxy, cmpyx };
2091   int cmpn;
2092   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2093     if (cmps[cmpn] != NULL)  break;     // find a result
2094   }
2095   if (cmpn &lt; NCMPS) {
2096     // Look for a dominating test that tells us the min and max.
2097     int depth = 0;                // Limit search depth for speed
2098     Node* dom = control();
2099     for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {
2100       if (++depth &gt;= 100)  break;
2101       Node* ifproj = dom;
2102       if (!ifproj-&gt;is_Proj())  continue;
2103       Node* iff = ifproj-&gt;in(0);
2104       if (!iff-&gt;is_If())  continue;
2105       Node* bol = iff-&gt;in(1);
2106       if (!bol-&gt;is_Bool())  continue;
2107       Node* cmp = bol-&gt;in(1);
2108       if (cmp == NULL)  continue;
2109       for (cmpn = 0; cmpn &lt; NCMPS; cmpn++)
2110         if (cmps[cmpn] == cmp)  break;
2111       if (cmpn == NCMPS)  continue;
2112       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2113       if (ifproj-&gt;is_IfFalse())  btest = BoolTest(btest).negate();
2114       if (cmp-&gt;in(1) == ykey)    btest = BoolTest(btest).commute();
2115       // At this point, we know that &#39;x btest y&#39; is true.
2116       switch (btest) {
2117       case BoolTest::eq:
2118         // They are proven equal, so we can collapse the min/max.
2119         // Either value is the answer.  Choose the simpler.
2120         if (is_simple_name(yvalue) &amp;&amp; !is_simple_name(xvalue))
2121           return yvalue;
2122         return xvalue;
2123       case BoolTest::lt:          // x &lt; y
2124       case BoolTest::le:          // x &lt;= y
2125         return (want_max ? yvalue : xvalue);
2126       case BoolTest::gt:          // x &gt; y
2127       case BoolTest::ge:          // x &gt;= y
2128         return (want_max ? xvalue : yvalue);
2129       default:
2130         break;
2131       }
2132     }
2133   }
2134 
2135   // We failed to find a dominating test.
2136   // Let&#39;s pick a test that might GVN with prior tests.
2137   Node*          best_bol   = NULL;
2138   BoolTest::mask best_btest = BoolTest::illegal;
2139   for (cmpn = 0; cmpn &lt; NCMPS; cmpn++) {
2140     Node* cmp = cmps[cmpn];
2141     if (cmp == NULL)  continue;
2142     for (DUIterator_Fast jmax, j = cmp-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2143       Node* bol = cmp-&gt;fast_out(j);
2144       if (!bol-&gt;is_Bool())  continue;
2145       BoolTest::mask btest = bol-&gt;as_Bool()-&gt;_test._test;
2146       if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;
2147       if (cmp-&gt;in(1) == ykey)   btest = BoolTest(btest).commute();
2148       if (bol-&gt;outcnt() &gt; (best_bol == NULL ? 0 : best_bol-&gt;outcnt())) {
2149         best_bol   = bol-&gt;as_Bool();
2150         best_btest = btest;
2151       }
2152     }
2153   }
2154 
2155   Node* answer_if_true  = NULL;
2156   Node* answer_if_false = NULL;
2157   switch (best_btest) {
2158   default:
2159     if (cmpxy == NULL)
2160       cmpxy = ideal_cmpxy;
2161     best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));
2162     // and fall through:
2163   case BoolTest::lt:          // x &lt; y
2164   case BoolTest::le:          // x &lt;= y
2165     answer_if_true  = (want_max ? yvalue : xvalue);
2166     answer_if_false = (want_max ? xvalue : yvalue);
2167     break;
2168   case BoolTest::gt:          // x &gt; y
2169   case BoolTest::ge:          // x &gt;= y
2170     answer_if_true  = (want_max ? xvalue : yvalue);
2171     answer_if_false = (want_max ? yvalue : xvalue);
2172     break;
2173   }
2174 
2175   jint hi, lo;
2176   if (want_max) {
2177     // We can sharpen the minimum.
2178     hi = MAX2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2179     lo = MAX2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2180   } else {
2181     // We can sharpen the maximum.
2182     hi = MIN2(txvalue-&gt;_hi, tyvalue-&gt;_hi);
2183     lo = MIN2(txvalue-&gt;_lo, tyvalue-&gt;_lo);
2184   }
2185 
2186   // Use a flow-free graph structure, to avoid creating excess control edges
2187   // which could hinder other optimizations.
2188   // Since Math.min/max is often used with arraycopy, we want
2189   // tightly_coupled_allocation to be able to see beyond min/max expressions.
2190   Node* cmov = CMoveNode::make(NULL, best_bol,
2191                                answer_if_false, answer_if_true,
2192                                TypeInt::make(lo, hi, widen));
2193 
2194   return _gvn.transform(cmov);
2195 
2196   /*
2197   // This is not as desirable as it may seem, since Min and Max
2198   // nodes do not have a full set of optimizations.
2199   // And they would interfere, anyway, with &#39;if&#39; optimizations
2200   // and with CMoveI canonical forms.
2201   switch (id) {
2202   case vmIntrinsics::_min:
2203     result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;
2204   case vmIntrinsics::_max:
2205     result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;
2206   default:
2207     ShouldNotReachHere();
2208   }
2209   */
2210 }
2211 
2212 inline int
2213 LibraryCallKit::classify_unsafe_addr(Node* &amp;base, Node* &amp;offset, BasicType type) {
2214   const TypePtr* base_type = TypePtr::NULL_PTR;
2215   if (base != NULL)  base_type = _gvn.type(base)-&gt;isa_ptr();
2216   if (base_type == NULL) {
2217     // Unknown type.
2218     return Type::AnyPtr;
2219   } else if (base_type == TypePtr::NULL_PTR) {
2220     // Since this is a NULL+long form, we have to switch to a rawptr.
2221     base   = _gvn.transform(new CastX2PNode(offset));
2222     offset = MakeConX(0);
2223     return Type::RawPtr;
2224   } else if (base_type-&gt;base() == Type::RawPtr) {
2225     return Type::RawPtr;
2226   } else if (base_type-&gt;isa_oopptr()) {
2227     // Base is never null =&gt; always a heap address.
2228     if (!TypePtr::NULL_PTR-&gt;higher_equal(base_type)) {
2229       return Type::OopPtr;
2230     }
2231     // Offset is small =&gt; always a heap address.
2232     const TypeX* offset_type = _gvn.type(offset)-&gt;isa_intptr_t();
2233     if (offset_type != NULL &amp;&amp;
2234         base_type-&gt;offset() == 0 &amp;&amp;     // (should always be?)
2235         offset_type-&gt;_lo &gt;= 0 &amp;&amp;
2236         !MacroAssembler::needs_explicit_null_check(offset_type-&gt;_hi)) {
2237       return Type::OopPtr;
2238     } else if (type == T_OBJECT) {
2239       // off heap access to an oop doesn&#39;t make any sense. Has to be on
2240       // heap.
2241       return Type::OopPtr;
2242     }
2243     // Otherwise, it might either be oop+off or NULL+addr.
2244     return Type::AnyPtr;
2245   } else {
2246     // No information:
2247     return Type::AnyPtr;
2248   }
2249 }
2250 
2251 inline Node* LibraryCallKit::make_unsafe_address(Node*&amp; base, Node* offset, DecoratorSet decorators, BasicType type, bool can_cast) {
2252   Node* uncasted_base = base;
2253   int kind = classify_unsafe_addr(uncasted_base, offset, type);
2254   if (kind == Type::RawPtr) {
2255     return basic_plus_adr(top(), uncasted_base, offset);
2256   } else if (kind == Type::AnyPtr) {
2257     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2258     if (can_cast) {
2259       if (!_gvn.type(base)-&gt;speculative_maybe_null() &amp;&amp;
2260           !too_many_traps(Deoptimization::Reason_speculate_null_check)) {
2261         // According to profiling, this access is always on
2262         // heap. Casting the base to not null and thus avoiding membars
2263         // around the access should allow better optimizations
2264         Node* null_ctl = top();
2265         base = null_check_oop(base, &amp;null_ctl, true, true, true);
2266         assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
2267         return basic_plus_adr(base, offset);
2268       } else if (_gvn.type(base)-&gt;speculative_always_null() &amp;&amp;
2269                  !too_many_traps(Deoptimization::Reason_speculate_null_assert)) {
2270         // According to profiling, this access is always off
2271         // heap.
2272         base = null_assert(base);
2273         Node* raw_base = _gvn.transform(new CastX2PNode(offset));
2274         offset = MakeConX(0);
2275         return basic_plus_adr(top(), raw_base, offset);
2276       }
2277     }
2278     // We don&#39;t know if it&#39;s an on heap or off heap access. Fall back
2279     // to raw memory access.
2280     Node* raw = _gvn.transform(new CheckCastPPNode(control(), base, TypeRawPtr::BOTTOM));
2281     return basic_plus_adr(top(), raw, offset);
2282   } else {
2283     assert(base == uncasted_base, &quot;unexpected base change&quot;);
2284     // We know it&#39;s an on heap access so base can&#39;t be null
2285     if (TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base))) {
2286       base = must_be_not_null(base, true);
2287     }
2288     return basic_plus_adr(base, offset);
2289   }
2290 }
2291 
2292 //--------------------------inline_number_methods-----------------------------
2293 // inline int     Integer.numberOfLeadingZeros(int)
2294 // inline int        Long.numberOfLeadingZeros(long)
2295 //
2296 // inline int     Integer.numberOfTrailingZeros(int)
2297 // inline int        Long.numberOfTrailingZeros(long)
2298 //
2299 // inline int     Integer.bitCount(int)
2300 // inline int        Long.bitCount(long)
2301 //
2302 // inline char  Character.reverseBytes(char)
2303 // inline short     Short.reverseBytes(short)
2304 // inline int     Integer.reverseBytes(int)
2305 // inline long       Long.reverseBytes(long)
2306 bool LibraryCallKit::inline_number_methods(vmIntrinsics::ID id) {
2307   Node* arg = argument(0);
2308   Node* n = NULL;
2309   switch (id) {
2310   case vmIntrinsics::_numberOfLeadingZeros_i:   n = new CountLeadingZerosINode( arg);  break;
2311   case vmIntrinsics::_numberOfLeadingZeros_l:   n = new CountLeadingZerosLNode( arg);  break;
2312   case vmIntrinsics::_numberOfTrailingZeros_i:  n = new CountTrailingZerosINode(arg);  break;
2313   case vmIntrinsics::_numberOfTrailingZeros_l:  n = new CountTrailingZerosLNode(arg);  break;
2314   case vmIntrinsics::_bitCount_i:               n = new PopCountINode(          arg);  break;
2315   case vmIntrinsics::_bitCount_l:               n = new PopCountLNode(          arg);  break;
2316   case vmIntrinsics::_reverseBytes_c:           n = new ReverseBytesUSNode(0,   arg);  break;
2317   case vmIntrinsics::_reverseBytes_s:           n = new ReverseBytesSNode( 0,   arg);  break;
2318   case vmIntrinsics::_reverseBytes_i:           n = new ReverseBytesINode( 0,   arg);  break;
2319   case vmIntrinsics::_reverseBytes_l:           n = new ReverseBytesLNode( 0,   arg);  break;
2320   default:  fatal_unexpected_iid(id);  break;
2321   }
2322   set_result(_gvn.transform(n));
2323   return true;
2324 }
2325 
2326 //----------------------------inline_unsafe_access----------------------------
2327 
2328 const TypeOopPtr* LibraryCallKit::sharpen_unsafe_type(Compile::AliasType* alias_type, const TypePtr *adr_type) {
2329   // Attempt to infer a sharper value type from the offset and base type.
2330   ciKlass* sharpened_klass = NULL;
2331 
2332   // See if it is an instance field, with an object type.
2333   if (alias_type-&gt;field() != NULL) {
2334     if (alias_type-&gt;field()-&gt;type()-&gt;is_klass()) {
2335       sharpened_klass = alias_type-&gt;field()-&gt;type()-&gt;as_klass();
2336     }
2337   }
2338 
2339   // See if it is a narrow oop array.
2340   if (adr_type-&gt;isa_aryptr()) {
2341     if (adr_type-&gt;offset() &gt;= objArrayOopDesc::base_offset_in_bytes()) {
2342       const TypeOopPtr *elem_type = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;isa_oopptr();
2343       if (elem_type != NULL) {
2344         sharpened_klass = elem_type-&gt;klass();
2345       }
2346     }
2347   }
2348 
2349   // The sharpened class might be unloaded if there is no class loader
2350   // contraint in place.
2351   if (sharpened_klass != NULL &amp;&amp; sharpened_klass-&gt;is_loaded()) {
2352     const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);
2353 
2354 #ifndef PRODUCT
2355     if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
2356       tty-&gt;print(&quot;  from base type:  &quot;);  adr_type-&gt;dump(); tty-&gt;cr();
2357       tty-&gt;print(&quot;  sharpened value: &quot;);  tjp-&gt;dump();      tty-&gt;cr();
2358     }
2359 #endif
2360     // Sharpen the value type.
2361     return tjp;
2362   }
2363   return NULL;
2364 }
2365 
2366 DecoratorSet LibraryCallKit::mo_decorator_for_access_kind(AccessKind kind) {
2367   switch (kind) {
2368       case Relaxed:
2369         return MO_UNORDERED;
2370       case Opaque:
2371         return MO_RELAXED;
2372       case Acquire:
2373         return MO_ACQUIRE;
2374       case Release:
2375         return MO_RELEASE;
2376       case Volatile:
2377         return MO_SEQ_CST;
2378       default:
2379         ShouldNotReachHere();
2380         return 0;
2381   }
2382 }
2383 
2384 bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {
2385   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2386   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2387   guarantee(!is_store || kind != Acquire, &quot;Acquire accesses can be produced only for loads&quot;);
2388   guarantee( is_store || kind != Release, &quot;Release accesses can be produced only for stores&quot;);
2389   assert(type != T_OBJECT || !unaligned, &quot;unaligned access not supported with object type&quot;);
2390 
2391   if (is_reference_type(type)) {
2392     decorators |= ON_UNKNOWN_OOP_REF;
2393   }
2394 
2395   if (unaligned) {
2396     decorators |= C2_UNALIGNED;
2397   }
2398 
2399 #ifndef PRODUCT
2400   {
2401     ResourceMark rm;
2402     // Check the signatures.
2403     ciSignature* sig = callee()-&gt;signature();
2404 #ifdef ASSERT
2405     if (!is_store) {
2406       // Object getReference(Object base, int/long offset), etc.
2407       BasicType rtype = sig-&gt;return_type()-&gt;basic_type();
2408       assert(rtype == type, &quot;getter must return the expected value&quot;);
2409       assert(sig-&gt;count() == 2, &quot;oop getter has 2 arguments&quot;);
2410       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;getter base is object&quot;);
2411       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;getter offset is correct&quot;);
2412     } else {
2413       // void putReference(Object base, int/long offset, Object x), etc.
2414       assert(sig-&gt;return_type()-&gt;basic_type() == T_VOID, &quot;putter must not return a value&quot;);
2415       assert(sig-&gt;count() == 3, &quot;oop putter has 3 arguments&quot;);
2416       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;putter base is object&quot;);
2417       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;putter offset is correct&quot;);
2418       BasicType vtype = sig-&gt;type_at(sig-&gt;count()-1)-&gt;basic_type();
2419       assert(vtype == type, &quot;putter must accept the expected value&quot;);
2420     }
2421 #endif // ASSERT
2422  }
2423 #endif //PRODUCT
2424 
2425   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2426 
2427   Node* receiver = argument(0);  // type: oop
2428 
2429   // Build address expression.
2430   Node* adr;
2431   Node* heap_base_oop = top();
2432   Node* offset = top();
2433   Node* val;
2434 
2435   // The base is either a Java object or a value produced by Unsafe.staticFieldBase
2436   Node* base = argument(1);  // type: oop
2437   // The offset is a value produced by Unsafe.staticFieldOffset or Unsafe.objectFieldOffset
2438   offset = argument(2);  // type: long
2439   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2440   // to be plain byte offsets, which are also the same as those accepted
2441   // by oopDesc::field_addr.
2442   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
2443          &quot;fieldOffset must be byte-scaled&quot;);
2444   // 32-bit machines ignore the high half!
2445   offset = ConvL2X(offset);
2446   adr = make_unsafe_address(base, offset, is_store ? ACCESS_WRITE : ACCESS_READ, type, kind == Relaxed);
2447 
2448   if (_gvn.type(base)-&gt;isa_ptr() == TypePtr::NULL_PTR) {
2449     if (type != T_OBJECT) {
2450       decorators |= IN_NATIVE; // off-heap primitive access
2451     } else {
2452       return false; // off-heap oop accesses are not supported
2453     }
2454   } else {
2455     heap_base_oop = base; // on-heap or mixed access
2456   }
2457 
2458   // Can base be NULL? Otherwise, always on-heap access.
2459   bool can_access_non_heap = TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(base));
2460 
2461   if (!can_access_non_heap) {
2462     decorators |= IN_HEAP;
2463   }
2464 
2465   val = is_store ? argument(4) : NULL;
2466 
2467   const TypePtr* adr_type = _gvn.type(adr)-&gt;isa_ptr();
2468   if (adr_type == TypePtr::NULL_PTR) {
2469     return false; // off-heap access with zero address
2470   }
2471 
2472   // Try to categorize the address.
2473   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2474   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2475 
2476   if (alias_type-&gt;adr_type() == TypeInstPtr::KLASS ||
2477       alias_type-&gt;adr_type() == TypeAryPtr::RANGE) {
2478     return false; // not supported
2479   }
2480 
2481   bool mismatched = false;
2482   BasicType bt = alias_type-&gt;basic_type();
2483   if (bt != T_ILLEGAL) {
2484     assert(alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;should be on-heap access&quot;);
2485     if (bt == T_BYTE &amp;&amp; adr_type-&gt;isa_aryptr()) {
2486       // Alias type doesn&#39;t differentiate between byte[] and boolean[]).
2487       // Use address type to get the element type.
2488       bt = adr_type-&gt;is_aryptr()-&gt;elem()-&gt;array_element_basic_type();
2489     }
2490     if (bt == T_ARRAY || bt == T_NARROWOOP) {
2491       // accessing an array field with getReference is not a mismatch
2492       bt = T_OBJECT;
2493     }
2494     if ((bt == T_OBJECT) != (type == T_OBJECT)) {
2495       // Don&#39;t intrinsify mismatched object accesses
2496       return false;
2497     }
2498     mismatched = (bt != type);
2499   } else if (alias_type-&gt;adr_type()-&gt;isa_oopptr()) {
2500     mismatched = true; // conservatively mark all &quot;wide&quot; on-heap accesses as mismatched
2501   }
2502 
2503   assert(!mismatched || alias_type-&gt;adr_type()-&gt;is_oopptr(), &quot;off-heap access can&#39;t be mismatched&quot;);
2504 
2505   if (mismatched) {
2506     decorators |= C2_MISMATCHED;
2507   }
2508 
2509   // First guess at the value type.
2510   const Type *value_type = Type::get_const_basic_type(type);
2511 
2512   // Figure out the memory ordering.
2513   decorators |= mo_decorator_for_access_kind(kind);
2514 
2515   if (!is_store &amp;&amp; type == T_OBJECT) {
2516     const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2517     if (tjp != NULL) {
2518       value_type = tjp;
2519     }
2520   }
2521 
2522   receiver = null_check(receiver);
2523   if (stopped()) {
2524     return true;
2525   }
2526   // Heap pointers get a null-check from the interpreter,
2527   // as a courtesy.  However, this is not guaranteed by Unsafe,
2528   // and it is not possible to fully distinguish unintended nulls
2529   // from intended ones in this API.
2530 
2531   if (!is_store) {
2532     Node* p = NULL;
2533     // Try to constant fold a load from a constant field
2534     ciField* field = alias_type-&gt;field();
2535     if (heap_base_oop != top() &amp;&amp; field != NULL &amp;&amp; field-&gt;is_constant() &amp;&amp; !mismatched) {
2536       // final or stable field
2537       p = make_constant_from_field(field, heap_base_oop);
2538     }
2539 
2540     if (p == NULL) { // Could not constant fold the load
2541       p = access_load_at(heap_base_oop, adr, adr_type, value_type, type, decorators);
2542       // Normalize the value returned by getBoolean in the following cases
2543       if (type == T_BOOLEAN &amp;&amp;
2544           (mismatched ||
2545            heap_base_oop == top() ||                  // - heap_base_oop is NULL or
2546            (can_access_non_heap &amp;&amp; field == NULL))    // - heap_base_oop is potentially NULL
2547                                                       //   and the unsafe access is made to large offset
2548                                                       //   (i.e., larger than the maximum offset necessary for any
2549                                                       //   field access)
2550             ) {
2551           IdealKit ideal = IdealKit(this);
2552 #define __ ideal.
2553           IdealVariable normalized_result(ideal);
2554           __ declarations_done();
2555           __ set(normalized_result, p);
2556           __ if_then(p, BoolTest::ne, ideal.ConI(0));
2557           __ set(normalized_result, ideal.ConI(1));
2558           ideal.end_if();
2559           final_sync(ideal);
2560           p = __ value(normalized_result);
2561 #undef __
2562       }
2563     }
2564     if (type == T_ADDRESS) {
2565       p = gvn().transform(new CastP2XNode(NULL, p));
2566       p = ConvX2UL(p);
2567     }
2568     // The load node has the control of the preceding MemBarCPUOrder.  All
2569     // following nodes will have the control of the MemBarCPUOrder inserted at
2570     // the end of this method.  So, pushing the load onto the stack at a later
2571     // point is fine.
2572     set_result(p);
2573   } else {
2574     if (bt == T_ADDRESS) {
2575       // Repackage the long as a pointer.
2576       val = ConvL2X(val);
2577       val = gvn().transform(new CastX2PNode(val));
2578     }
2579     access_store_at(heap_base_oop, adr, adr_type, val, value_type, type, decorators);
2580   }
2581 
2582   return true;
2583 }
2584 
2585 //----------------------------inline_unsafe_load_store----------------------------
2586 // This method serves a couple of different customers (depending on LoadStoreKind):
2587 //
2588 // LS_cmp_swap:
2589 //
2590 //   boolean compareAndSetReference(Object o, long offset, Object expected, Object x);
2591 //   boolean compareAndSetInt(   Object o, long offset, int    expected, int    x);
2592 //   boolean compareAndSetLong(  Object o, long offset, long   expected, long   x);
2593 //
2594 // LS_cmp_swap_weak:
2595 //
2596 //   boolean weakCompareAndSetReference(       Object o, long offset, Object expected, Object x);
2597 //   boolean weakCompareAndSetReferencePlain(  Object o, long offset, Object expected, Object x);
2598 //   boolean weakCompareAndSetReferenceAcquire(Object o, long offset, Object expected, Object x);
2599 //   boolean weakCompareAndSetReferenceRelease(Object o, long offset, Object expected, Object x);
2600 //
2601 //   boolean weakCompareAndSetInt(          Object o, long offset, int    expected, int    x);
2602 //   boolean weakCompareAndSetIntPlain(     Object o, long offset, int    expected, int    x);
2603 //   boolean weakCompareAndSetIntAcquire(   Object o, long offset, int    expected, int    x);
2604 //   boolean weakCompareAndSetIntRelease(   Object o, long offset, int    expected, int    x);
2605 //
2606 //   boolean weakCompareAndSetLong(         Object o, long offset, long   expected, long   x);
2607 //   boolean weakCompareAndSetLongPlain(    Object o, long offset, long   expected, long   x);
2608 //   boolean weakCompareAndSetLongAcquire(  Object o, long offset, long   expected, long   x);
2609 //   boolean weakCompareAndSetLongRelease(  Object o, long offset, long   expected, long   x);
2610 //
2611 // LS_cmp_exchange:
2612 //
2613 //   Object compareAndExchangeReferenceVolatile(Object o, long offset, Object expected, Object x);
2614 //   Object compareAndExchangeReferenceAcquire( Object o, long offset, Object expected, Object x);
2615 //   Object compareAndExchangeReferenceRelease( Object o, long offset, Object expected, Object x);
2616 //
2617 //   Object compareAndExchangeIntVolatile(   Object o, long offset, Object expected, Object x);
2618 //   Object compareAndExchangeIntAcquire(    Object o, long offset, Object expected, Object x);
2619 //   Object compareAndExchangeIntRelease(    Object o, long offset, Object expected, Object x);
2620 //
2621 //   Object compareAndExchangeLongVolatile(  Object o, long offset, Object expected, Object x);
2622 //   Object compareAndExchangeLongAcquire(   Object o, long offset, Object expected, Object x);
2623 //   Object compareAndExchangeLongRelease(   Object o, long offset, Object expected, Object x);
2624 //
2625 // LS_get_add:
2626 //
2627 //   int  getAndAddInt( Object o, long offset, int  delta)
2628 //   long getAndAddLong(Object o, long offset, long delta)
2629 //
2630 // LS_get_set:
2631 //
2632 //   int    getAndSet(Object o, long offset, int    newValue)
2633 //   long   getAndSet(Object o, long offset, long   newValue)
2634 //   Object getAndSet(Object o, long offset, Object newValue)
2635 //
2636 bool LibraryCallKit::inline_unsafe_load_store(const BasicType type, const LoadStoreKind kind, const AccessKind access_kind) {
2637   // This basic scheme here is the same as inline_unsafe_access, but
2638   // differs in enough details that combining them would make the code
2639   // overly confusing.  (This is a true fact! I originally combined
2640   // them, but even I was confused by it!) As much code/comments as
2641   // possible are retained from inline_unsafe_access though to make
2642   // the correspondences clearer. - dl
2643 
2644   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2645 
2646   DecoratorSet decorators = C2_UNSAFE_ACCESS;
2647   decorators |= mo_decorator_for_access_kind(access_kind);
2648 
2649 #ifndef PRODUCT
2650   BasicType rtype;
2651   {
2652     ResourceMark rm;
2653     // Check the signatures.
2654     ciSignature* sig = callee()-&gt;signature();
2655     rtype = sig-&gt;return_type()-&gt;basic_type();
2656     switch(kind) {
2657       case LS_get_add:
2658       case LS_get_set: {
2659       // Check the signatures.
2660 #ifdef ASSERT
2661       assert(rtype == type, &quot;get and set must return the expected type&quot;);
2662       assert(sig-&gt;count() == 3, &quot;get and set has 3 arguments&quot;);
2663       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;get and set base is object&quot;);
2664       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;get and set offset is long&quot;);
2665       assert(sig-&gt;type_at(2)-&gt;basic_type() == type, &quot;get and set must take expected type as new value/delta&quot;);
2666       assert(access_kind == Volatile, &quot;mo is not passed to intrinsic nodes in current implementation&quot;);
2667 #endif // ASSERT
2668         break;
2669       }
2670       case LS_cmp_swap:
2671       case LS_cmp_swap_weak: {
2672       // Check the signatures.
2673 #ifdef ASSERT
2674       assert(rtype == T_BOOLEAN, &quot;CAS must return boolean&quot;);
2675       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2676       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2677       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2678 #endif // ASSERT
2679         break;
2680       }
2681       case LS_cmp_exchange: {
2682       // Check the signatures.
2683 #ifdef ASSERT
2684       assert(rtype == type, &quot;CAS must return the expected type&quot;);
2685       assert(sig-&gt;count() == 4, &quot;CAS has 4 arguments&quot;);
2686       assert(sig-&gt;type_at(0)-&gt;basic_type() == T_OBJECT, &quot;CAS base is object&quot;);
2687       assert(sig-&gt;type_at(1)-&gt;basic_type() == T_LONG, &quot;CAS offset is long&quot;);
2688 #endif // ASSERT
2689         break;
2690       }
2691       default:
2692         ShouldNotReachHere();
2693     }
2694   }
2695 #endif //PRODUCT
2696 
2697   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
2698 
2699   // Get arguments:
2700   Node* receiver = NULL;
2701   Node* base     = NULL;
2702   Node* offset   = NULL;
2703   Node* oldval   = NULL;
2704   Node* newval   = NULL;
2705   switch(kind) {
2706     case LS_cmp_swap:
2707     case LS_cmp_swap_weak:
2708     case LS_cmp_exchange: {
2709       const bool two_slot_type = type2size[type] == 2;
2710       receiver = argument(0);  // type: oop
2711       base     = argument(1);  // type: oop
2712       offset   = argument(2);  // type: long
2713       oldval   = argument(4);  // type: oop, int, or long
2714       newval   = argument(two_slot_type ? 6 : 5);  // type: oop, int, or long
2715       break;
2716     }
2717     case LS_get_add:
2718     case LS_get_set: {
2719       receiver = argument(0);  // type: oop
2720       base     = argument(1);  // type: oop
2721       offset   = argument(2);  // type: long
2722       oldval   = NULL;
2723       newval   = argument(4);  // type: oop, int, or long
2724       break;
2725     }
2726     default:
2727       ShouldNotReachHere();
2728   }
2729 
2730   // Build field offset expression.
2731   // We currently rely on the cookies produced by Unsafe.xxxFieldOffset
2732   // to be plain byte offsets, which are also the same as those accepted
2733   // by oopDesc::field_addr.
2734   assert(Unsafe_field_offset_to_byte_offset(11) == 11, &quot;fieldOffset must be byte-scaled&quot;);
2735   // 32-bit machines ignore the high half of long offsets
2736   offset = ConvL2X(offset);
2737   Node* adr = make_unsafe_address(base, offset, ACCESS_WRITE | ACCESS_READ, type, false);
2738   const TypePtr *adr_type = _gvn.type(adr)-&gt;isa_ptr();
2739 
2740   Compile::AliasType* alias_type = C-&gt;alias_type(adr_type);
2741   BasicType bt = alias_type-&gt;basic_type();
2742   if (bt != T_ILLEGAL &amp;&amp;
2743       (is_reference_type(bt) != (type == T_OBJECT))) {
2744     // Don&#39;t intrinsify mismatched object accesses.
2745     return false;
2746   }
2747 
2748   // For CAS, unlike inline_unsafe_access, there seems no point in
2749   // trying to refine types. Just use the coarse types here.
2750   assert(alias_type-&gt;index() != Compile::AliasIdxBot, &quot;no bare pointers here&quot;);
2751   const Type *value_type = Type::get_const_basic_type(type);
2752 
2753   switch (kind) {
2754     case LS_get_set:
2755     case LS_cmp_exchange: {
2756       if (type == T_OBJECT) {
2757         const TypeOopPtr* tjp = sharpen_unsafe_type(alias_type, adr_type);
2758         if (tjp != NULL) {
2759           value_type = tjp;
2760         }
2761       }
2762       break;
2763     }
2764     case LS_cmp_swap:
2765     case LS_cmp_swap_weak:
2766     case LS_get_add:
2767       break;
2768     default:
2769       ShouldNotReachHere();
2770   }
2771 
2772   // Null check receiver.
2773   receiver = null_check(receiver);
2774   if (stopped()) {
2775     return true;
2776   }
2777 
2778   int alias_idx = C-&gt;get_alias_index(adr_type);
2779 
2780   if (is_reference_type(type)) {
2781     decorators |= IN_HEAP | ON_UNKNOWN_OOP_REF;
2782 
2783     // Transformation of a value which could be NULL pointer (CastPP #NULL)
2784     // could be delayed during Parse (for example, in adjust_map_after_if()).
2785     // Execute transformation here to avoid barrier generation in such case.
2786     if (_gvn.type(newval) == TypePtr::NULL_PTR)
2787       newval = _gvn.makecon(TypePtr::NULL_PTR);
2788 
2789     if (oldval != NULL &amp;&amp; _gvn.type(oldval) == TypePtr::NULL_PTR) {
2790       // Refine the value to a null constant, when it is known to be null
2791       oldval = _gvn.makecon(TypePtr::NULL_PTR);
2792     }
2793   }
2794 
2795   Node* result = NULL;
2796   switch (kind) {
2797     case LS_cmp_exchange: {
2798       result = access_atomic_cmpxchg_val_at(base, adr, adr_type, alias_idx,
2799                                             oldval, newval, value_type, type, decorators);
2800       break;
2801     }
2802     case LS_cmp_swap_weak:
2803       decorators |= C2_WEAK_CMPXCHG;
2804     case LS_cmp_swap: {
2805       result = access_atomic_cmpxchg_bool_at(base, adr, adr_type, alias_idx,
2806                                              oldval, newval, value_type, type, decorators);
2807       break;
2808     }
2809     case LS_get_set: {
2810       result = access_atomic_xchg_at(base, adr, adr_type, alias_idx,
2811                                      newval, value_type, type, decorators);
2812       break;
2813     }
2814     case LS_get_add: {
2815       result = access_atomic_add_at(base, adr, adr_type, alias_idx,
2816                                     newval, value_type, type, decorators);
2817       break;
2818     }
2819     default:
2820       ShouldNotReachHere();
2821   }
2822 
2823   assert(type2size[result-&gt;bottom_type()-&gt;basic_type()] == type2size[rtype], &quot;result type should match&quot;);
2824   set_result(result);
2825   return true;
2826 }
2827 
2828 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
2829   // Regardless of form, don&#39;t allow previous ld/st to move down,
2830   // then issue acquire, release, or volatile mem_bar.
2831   insert_mem_bar(Op_MemBarCPUOrder);
2832   switch(id) {
2833     case vmIntrinsics::_loadFence:
2834       insert_mem_bar(Op_LoadFence);
2835       return true;
2836     case vmIntrinsics::_storeFence:
2837       insert_mem_bar(Op_StoreFence);
2838       return true;
2839     case vmIntrinsics::_fullFence:
2840       insert_mem_bar(Op_MemBarVolatile);
2841       return true;
2842     default:
2843       fatal_unexpected_iid(id);
2844       return false;
2845   }
2846 }
2847 
2848 bool LibraryCallKit::inline_onspinwait() {
2849   insert_mem_bar(Op_OnSpinWait);
2850   return true;
2851 }
2852 
2853 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2854   if (!kls-&gt;is_Con()) {
2855     return true;
2856   }
2857   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2858   if (klsptr == NULL) {
2859     return true;
2860   }
2861   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2862   // don&#39;t need a guard for a klass that is already initialized
2863   return !ik-&gt;is_initialized();
2864 }
2865 
2866 //----------------------------inline_unsafe_writeback0-------------------------
2867 // public native void Unsafe.writeback0(long address)
2868 bool LibraryCallKit::inline_unsafe_writeback0() {
2869   if (!Matcher::has_match_rule(Op_CacheWB)) {
2870     return false;
2871   }
2872 #ifndef PRODUCT
2873   assert(Matcher::has_match_rule(Op_CacheWBPreSync), &quot;found match rule for CacheWB but not CacheWBPreSync&quot;);
2874   assert(Matcher::has_match_rule(Op_CacheWBPostSync), &quot;found match rule for CacheWB but not CacheWBPostSync&quot;);
2875   ciSignature* sig = callee()-&gt;signature();
2876   assert(sig-&gt;type_at(0)-&gt;basic_type() == T_LONG, &quot;Unsafe_writeback0 address is long!&quot;);
2877 #endif
2878   null_check_receiver();  // null-check, then ignore
2879   Node *addr = argument(1);
2880   addr = new CastX2PNode(addr);
2881   addr = _gvn.transform(addr);
2882   Node *flush = new CacheWBNode(control(), memory(TypeRawPtr::BOTTOM), addr);
2883   flush = _gvn.transform(flush);
2884   set_memory(flush, TypeRawPtr::BOTTOM);
2885   return true;
2886 }
2887 
2888 //----------------------------inline_unsafe_writeback0-------------------------
2889 // public native void Unsafe.writeback0(long address)
2890 bool LibraryCallKit::inline_unsafe_writebackSync0(bool is_pre) {
2891   if (is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPreSync)) {
2892     return false;
2893   }
2894   if (!is_pre &amp;&amp; !Matcher::has_match_rule(Op_CacheWBPostSync)) {
2895     return false;
2896   }
2897 #ifndef PRODUCT
2898   assert(Matcher::has_match_rule(Op_CacheWB),
2899          (is_pre ? &quot;found match rule for CacheWBPreSync but not CacheWB&quot;
2900                 : &quot;found match rule for CacheWBPostSync but not CacheWB&quot;));
2901 
2902 #endif
2903   null_check_receiver();  // null-check, then ignore
2904   Node *sync;
2905   if (is_pre) {
2906     sync = new CacheWBPreSyncNode(control(), memory(TypeRawPtr::BOTTOM));
2907   } else {
2908     sync = new CacheWBPostSyncNode(control(), memory(TypeRawPtr::BOTTOM));
2909   }
2910   sync = _gvn.transform(sync);
2911   set_memory(sync, TypeRawPtr::BOTTOM);
2912   return true;
2913 }
2914 
2915 //----------------------------inline_unsafe_allocate---------------------------
2916 // public native Object Unsafe.allocateInstance(Class&lt;?&gt; cls);
2917 bool LibraryCallKit::inline_unsafe_allocate() {
2918   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2919 
2920   null_check_receiver();  // null-check, then ignore
2921   Node* cls = null_check(argument(1));
2922   if (stopped())  return true;
2923 
2924   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2925   kls = null_check(kls);
2926   if (stopped())  return true;  // argument was like int.class
2927 
2928   Node* test = NULL;
2929   if (LibraryCallKit::klass_needs_init_guard(kls)) {
2930     // Note:  The argument might still be an illegal value like
2931     // Serializable.class or Object[].class.   The runtime will handle it.
2932     // But we must make an explicit check for initialization.
2933     Node* insp = basic_plus_adr(kls, in_bytes(InstanceKlass::init_state_offset()));
2934     // Use T_BOOLEAN for InstanceKlass::_init_state so the compiler
2935     // can generate code to load it as unsigned byte.
2936     Node* inst = make_load(NULL, insp, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);
2937     Node* bits = intcon(InstanceKlass::fully_initialized);
2938     test = _gvn.transform(new SubINode(inst, bits));
2939     // The &#39;test&#39; is non-zero if we need to take a slow path.
2940   }
2941 
2942   Node* obj = new_instance(kls, test);
2943   set_result(obj);
2944   return true;
2945 }
2946 
2947 //------------------------inline_native_time_funcs--------------
2948 // inline code for System.currentTimeMillis() and System.nanoTime()
2949 // these have the same type and signature
2950 bool LibraryCallKit::inline_native_time_funcs(address funcAddr, const char* funcName) {
2951   const TypeFunc* tf = OptoRuntime::void_long_Type();
2952   const TypePtr* no_memory_effects = NULL;
2953   Node* time = make_runtime_call(RC_LEAF, tf, funcAddr, funcName, no_memory_effects);
2954   Node* value = _gvn.transform(new ProjNode(time, TypeFunc::Parms+0));
2955 #ifdef ASSERT
2956   Node* value_top = _gvn.transform(new ProjNode(time, TypeFunc::Parms+1));
2957   assert(value_top == top(), &quot;second value must be top&quot;);
2958 #endif
2959   set_result(value);
2960   return true;
2961 }
2962 
2963 #ifdef JFR_HAVE_INTRINSICS
2964 
2965 /*
2966 * oop -&gt; myklass
2967 * myklass-&gt;trace_id |= USED
2968 * return myklass-&gt;trace_id &amp; ~0x3
2969 */
2970 bool LibraryCallKit::inline_native_classID() {
2971   Node* cls = null_check(argument(0), T_OBJECT);
2972   Node* kls = load_klass_from_mirror(cls, false, NULL, 0);
2973   kls = null_check(kls, T_OBJECT);
2974 
2975   ByteSize offset = KLASS_TRACE_ID_OFFSET;
2976   Node* insp = basic_plus_adr(kls, in_bytes(offset));
2977   Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);
2978 
2979   Node* clsused = longcon(0x01l); // set the class bit
2980   Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));
2981   const TypePtr *adr_type = _gvn.type(insp)-&gt;isa_ptr();
2982   store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);
2983 
2984 #ifdef TRACE_ID_META_BITS
2985   Node* mbits = longcon(~TRACE_ID_META_BITS);
2986   tvalue = _gvn.transform(new AndLNode(tvalue, mbits));
2987 #endif
2988 #ifdef TRACE_ID_SHIFT
2989   Node* cbits = intcon(TRACE_ID_SHIFT);
2990   tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));
2991 #endif
2992 
2993   set_result(tvalue);
2994   return true;
2995 
2996 }
2997 
2998 /*
2999 
3000 bool LibraryCallKit::inline_native_getEventWriter() {
3001   Node* tls_ptr = _gvn.transform(new ThreadLocalNode());
3002 
3003   Node* jobj_ptr = basic_plus_adr(top(), tls_ptr,
3004                                   in_bytes(THREAD_LOCAL_WRITER_OFFSET_JFR));
3005 
3006   Node* jobj = make_load(control(), jobj_ptr, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);
3007 
3008   Node* jobj_cmp_null = _gvn.transform( new CmpPNode(jobj, null()) );
3009   Node* test_jobj_eq_null  = _gvn.transform( new BoolNode(jobj_cmp_null, BoolTest::eq) );
3010 
3011   IfNode* iff_jobj_null =
3012     create_and_map_if(control(), test_jobj_eq_null, PROB_MIN, COUNT_UNKNOWN);
3013 
3014   enum { _normal_path = 1,
3015          _null_path = 2,
3016          PATH_LIMIT };
3017 
3018   RegionNode* result_rgn = new RegionNode(PATH_LIMIT);
3019   PhiNode*    result_val = new PhiNode(result_rgn, TypeInstPtr::BOTTOM);
3020 
3021   Node* jobj_is_null = _gvn.transform(new IfTrueNode(iff_jobj_null));
3022   result_rgn-&gt;init_req(_null_path, jobj_is_null);
3023   result_val-&gt;init_req(_null_path, null());
3024 
3025   Node* jobj_is_not_null = _gvn.transform(new IfFalseNode(iff_jobj_null));
3026   set_control(jobj_is_not_null);
3027   Node* res = access_load(jobj, TypeInstPtr::NOTNULL, T_OBJECT,
3028                           IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);
3029   result_rgn-&gt;init_req(_normal_path, control());
3030   result_val-&gt;init_req(_normal_path, res);
3031 
3032   set_result(result_rgn, result_val);
3033 
3034   return true;
3035 }
3036 
3037 */
3038 
3039 #endif // JFR_HAVE_INTRINSICS
3040 
3041 //------------------------inline_native_currentThread------------------
3042 bool LibraryCallKit::inline_native_currentThread() {
3043   Node* junk = NULL;
3044   set_result(generate_current_thread(junk));
3045   return true;
3046 }
3047 
<a name="3" id="anc3"></a>

































3048 //---------------------------load_mirror_from_klass----------------------------
3049 // Given a klass oop, load its java mirror (a java.lang.Class oop).
3050 Node* LibraryCallKit::load_mirror_from_klass(Node* klass) {
3051   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));
3052   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3053   // mirror = ((OopHandle)mirror)-&gt;resolve();
3054   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);
3055 }
3056 
3057 //-----------------------load_klass_from_mirror_common-------------------------
3058 // Given a java mirror (a java.lang.Class oop), load its corresponding klass oop.
3059 // Test the klass oop for null (signifying a primitive Class like Integer.TYPE),
3060 // and branch to the given path on the region.
3061 // If never_see_null, take an uncommon trap on null, so we can optimistically
3062 // compile for the non-null case.
3063 // If the region is NULL, force never_see_null = true.
3064 Node* LibraryCallKit::load_klass_from_mirror_common(Node* mirror,
3065                                                     bool never_see_null,
3066                                                     RegionNode* region,
3067                                                     int null_path,
3068                                                     int offset) {
3069   if (region == NULL)  never_see_null = true;
3070   Node* p = basic_plus_adr(mirror, offset);
3071   const TypeKlassPtr*  kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3072   Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));
3073   Node* null_ctl = top();
3074   kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3075   if (region != NULL) {
3076     // Set region-&gt;in(null_path) if the mirror is a primitive (e.g, int.class).
3077     region-&gt;init_req(null_path, null_ctl);
3078   } else {
3079     assert(null_ctl == top(), &quot;no loose ends&quot;);
3080   }
3081   return kls;
3082 }
3083 
3084 //--------------------(inline_native_Class_query helpers)---------------------
3085 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3086 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3087 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3088   // Branch around if the given klass has the given modifier bit set.
3089   // Like generate_guard, adds a new path onto the region.
3090   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3091   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3092   Node* mask = intcon(modifier_mask);
3093   Node* bits = intcon(modifier_bits);
3094   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3095   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3096   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3097   return generate_fair_guard(bol, region);
3098 }
3099 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3100   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3101 }
3102 
3103 //-------------------------inline_native_Class_query-------------------
3104 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3105   const Type* return_type = TypeInt::BOOL;
3106   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3107   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3108   bool expect_prim = false;     // most of these guys expect to work on refs
3109 
3110   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3111 
3112   Node* mirror = argument(0);
3113   Node* obj    = top();
3114 
3115   switch (id) {
3116   case vmIntrinsics::_isInstance:
3117     // nothing is an instance of a primitive type
3118     prim_return_value = intcon(0);
3119     obj = argument(1);
3120     break;
3121   case vmIntrinsics::_getModifiers:
3122     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3123     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3124     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3125     break;
3126   case vmIntrinsics::_isInterface:
3127     prim_return_value = intcon(0);
3128     break;
3129   case vmIntrinsics::_isArray:
3130     prim_return_value = intcon(0);
3131     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3132     break;
3133   case vmIntrinsics::_isPrimitive:
3134     prim_return_value = intcon(1);
3135     expect_prim = true;  // obviously
3136     break;
3137   case vmIntrinsics::_getSuperclass:
3138     prim_return_value = null();
3139     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3140     break;
3141   case vmIntrinsics::_getClassAccessFlags:
3142     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3143     return_type = TypeInt::INT;  // not bool!  6297094
3144     break;
3145   default:
3146     fatal_unexpected_iid(id);
3147     break;
3148   }
3149 
3150   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3151   if (mirror_con == NULL)  return false;  // cannot happen?
3152 
3153 #ifndef PRODUCT
3154   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3155     ciType* k = mirror_con-&gt;java_mirror_type();
3156     if (k) {
3157       tty-&gt;print(&quot;Inlining %s on constant Class &quot;, vmIntrinsics::name_at(intrinsic_id()));
3158       k-&gt;print_name();
3159       tty-&gt;cr();
3160     }
3161   }
3162 #endif
3163 
3164   // Null-check the mirror, and the mirror&#39;s klass ptr (in case it is a primitive).
3165   RegionNode* region = new RegionNode(PATH_LIMIT);
3166   record_for_igvn(region);
3167   PhiNode* phi = new PhiNode(region, return_type);
3168 
3169   // The mirror will never be null of Reflection.getClassAccessFlags, however
3170   // it may be null for Class.isInstance or Class.getModifiers. Throw a NPE
3171   // if it is. See bug 4774291.
3172 
3173   // For Reflection.getClassAccessFlags(), the null check occurs in
3174   // the wrong place; see inline_unsafe_access(), above, for a similar
3175   // situation.
3176   mirror = null_check(mirror);
3177   // If mirror or obj is dead, only null-path is taken.
3178   if (stopped())  return true;
3179 
3180   if (expect_prim)  never_see_null = false;  // expect nulls (meaning prims)
3181 
3182   // Now load the mirror&#39;s klass metaobject, and null-check it.
3183   // Side-effects region with the control path if the klass is null.
3184   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3185   // If kls is null, we have a primitive mirror.
3186   phi-&gt;init_req(_prim_path, prim_return_value);
3187   if (stopped()) { set_result(region, phi); return true; }
3188   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3189 
3190   Node* p;  // handy temp
3191   Node* null_ctl;
3192 
3193   // Now that we have the non-null klass, we can perform the real query.
3194   // For constant classes, the query will constant-fold in LoadNode::Value.
3195   Node* query_value = top();
3196   switch (id) {
3197   case vmIntrinsics::_isInstance:
3198     // nothing is an instance of a primitive type
3199     query_value = gen_instanceof(obj, kls, safe_for_replace);
3200     break;
3201 
3202   case vmIntrinsics::_getModifiers:
3203     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3204     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3205     break;
3206 
3207   case vmIntrinsics::_isInterface:
3208     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3209     if (generate_interface_guard(kls, region) != NULL)
3210       // A guard was added.  If the guard is taken, it was an interface.
3211       phi-&gt;add_req(intcon(1));
3212     // If we fall through, it&#39;s a plain class.
3213     query_value = intcon(0);
3214     break;
3215 
3216   case vmIntrinsics::_isArray:
3217     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3218     if (generate_array_guard(kls, region) != NULL)
3219       // A guard was added.  If the guard is taken, it was an array.
3220       phi-&gt;add_req(intcon(1));
3221     // If we fall through, it&#39;s a plain class.
3222     query_value = intcon(0);
3223     break;
3224 
3225   case vmIntrinsics::_isPrimitive:
3226     query_value = intcon(0); // &quot;normal&quot; path produces false
3227     break;
3228 
3229   case vmIntrinsics::_getSuperclass:
3230     // The rules here are somewhat unfortunate, but we can still do better
3231     // with random logic than with a JNI call.
3232     // Interfaces store null or Object as _super, but must report null.
3233     // Arrays store an intermediate super as _super, but must report Object.
3234     // Other types can report the actual _super.
3235     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3236     if (generate_interface_guard(kls, region) != NULL)
3237       // A guard was added.  If the guard is taken, it was an interface.
3238       phi-&gt;add_req(null());
3239     if (generate_array_guard(kls, region) != NULL)
3240       // A guard was added.  If the guard is taken, it was an array.
3241       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3242     // If we fall through, it&#39;s a plain class.  Get its _super.
3243     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3244     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3245     null_ctl = top();
3246     kls = null_check_oop(kls, &amp;null_ctl);
3247     if (null_ctl != top()) {
3248       // If the guard is taken, Object.superClass is null (both klass and mirror).
3249       region-&gt;add_req(null_ctl);
3250       phi   -&gt;add_req(null());
3251     }
3252     if (!stopped()) {
3253       query_value = load_mirror_from_klass(kls);
3254     }
3255     break;
3256 
3257   case vmIntrinsics::_getClassAccessFlags:
3258     p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3259     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3260     break;
3261 
3262   default:
3263     fatal_unexpected_iid(id);
3264     break;
3265   }
3266 
3267   // Fall-through is the normal case of a query to a real class.
3268   phi-&gt;init_req(1, query_value);
3269   region-&gt;init_req(1, control());
3270 
3271   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3272   set_result(region, phi);
3273   return true;
3274 }
3275 
3276 //-------------------------inline_Class_cast-------------------
3277 bool LibraryCallKit::inline_Class_cast() {
3278   Node* mirror = argument(0); // Class
3279   Node* obj    = argument(1);
3280   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3281   if (mirror_con == NULL) {
3282     return false;  // dead path (mirror-&gt;is_top()).
3283   }
3284   if (obj == NULL || obj-&gt;is_top()) {
3285     return false;  // dead path
3286   }
3287   const TypeOopPtr* tp = _gvn.type(obj)-&gt;isa_oopptr();
3288 
3289   // First, see if Class.cast() can be folded statically.
3290   // java_mirror_type() returns non-null for compile-time Class constants.
3291   ciType* tm = mirror_con-&gt;java_mirror_type();
3292   if (tm != NULL &amp;&amp; tm-&gt;is_klass() &amp;&amp;
3293       tp != NULL &amp;&amp; tp-&gt;klass() != NULL) {
3294     if (!tp-&gt;klass()-&gt;is_loaded()) {
3295       // Don&#39;t use intrinsic when class is not loaded.
3296       return false;
3297     } else {
3298       int static_res = C-&gt;static_subtype_check(tm-&gt;as_klass(), tp-&gt;klass());
3299       if (static_res == Compile::SSC_always_true) {
3300         // isInstance() is true - fold the code.
3301         set_result(obj);
3302         return true;
3303       } else if (static_res == Compile::SSC_always_false) {
3304         // Don&#39;t use intrinsic, have to throw ClassCastException.
3305         // If the reference is null, the non-intrinsic bytecode will
3306         // be optimized appropriately.
3307         return false;
3308       }
3309     }
3310   }
3311 
3312   // Bailout intrinsic and do normal inlining if exception path is frequent.
3313   if (too_many_traps(Deoptimization::Reason_intrinsic)) {
3314     return false;
3315   }
3316 
3317   // Generate dynamic checks.
3318   // Class.cast() is java implementation of _checkcast bytecode.
3319   // Do checkcast (Parse::do_checkcast()) optimizations here.
3320 
3321   mirror = null_check(mirror);
3322   // If mirror is dead, only null-path is taken.
3323   if (stopped()) {
3324     return true;
3325   }
3326 
3327   // Not-subtype or the mirror&#39;s klass ptr is NULL (in case it is a primitive).
3328   enum { _bad_type_path = 1, _prim_path = 2, PATH_LIMIT };
3329   RegionNode* region = new RegionNode(PATH_LIMIT);
3330   record_for_igvn(region);
3331 
3332   // Now load the mirror&#39;s klass metaobject, and null-check it.
3333   // If kls is null, we have a primitive mirror and
3334   // nothing is an instance of a primitive type.
3335   Node* kls = load_klass_from_mirror(mirror, false, region, _prim_path);
3336 
3337   Node* res = top();
3338   if (!stopped()) {
3339     Node* bad_type_ctrl = top();
3340     // Do checkcast optimizations.
3341     res = gen_checkcast(obj, kls, &amp;bad_type_ctrl);
3342     region-&gt;init_req(_bad_type_path, bad_type_ctrl);
3343   }
3344   if (region-&gt;in(_prim_path) != top() ||
3345       region-&gt;in(_bad_type_path) != top()) {
3346     // Let Interpreter throw ClassCastException.
3347     PreserveJVMState pjvms(this);
3348     set_control(_gvn.transform(region));
3349     uncommon_trap(Deoptimization::Reason_intrinsic,
3350                   Deoptimization::Action_maybe_recompile);
3351   }
3352   if (!stopped()) {
3353     set_result(res);
3354   }
3355   return true;
3356 }
3357 
3358 
3359 //--------------------------inline_native_subtype_check------------------------
3360 // This intrinsic takes the JNI calls out of the heart of
3361 // UnsafeFieldAccessorImpl.set, which improves Field.set, readObject, etc.
3362 bool LibraryCallKit::inline_native_subtype_check() {
3363   // Pull both arguments off the stack.
3364   Node* args[2];                // two java.lang.Class mirrors: superc, subc
3365   args[0] = argument(0);
3366   args[1] = argument(1);
3367   Node* klasses[2];             // corresponding Klasses: superk, subk
3368   klasses[0] = klasses[1] = top();
3369 
3370   enum {
3371     // A full decision tree on {superc is prim, subc is prim}:
3372     _prim_0_path = 1,           // {P,N} =&gt; false
3373                                 // {P,P} &amp; superc!=subc =&gt; false
3374     _prim_same_path,            // {P,P} &amp; superc==subc =&gt; true
3375     _prim_1_path,               // {N,P} =&gt; false
3376     _ref_subtype_path,          // {N,N} &amp; subtype check wins =&gt; true
3377     _both_ref_path,             // {N,N} &amp; subtype check loses =&gt; false
3378     PATH_LIMIT
3379   };
3380 
3381   RegionNode* region = new RegionNode(PATH_LIMIT);
3382   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3383   record_for_igvn(region);
3384 
3385   const TypePtr* adr_type = TypeRawPtr::BOTTOM;   // memory type of loads
3386   const TypeKlassPtr* kls_type = TypeKlassPtr::OBJECT_OR_NULL;
3387   int class_klass_offset = java_lang_Class::klass_offset_in_bytes();
3388 
3389   // First null-check both mirrors and load each mirror&#39;s klass metaobject.
3390   int which_arg;
3391   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3392     Node* arg = args[which_arg];
3393     arg = null_check(arg);
3394     if (stopped())  break;
3395     args[which_arg] = arg;
3396 
3397     Node* p = basic_plus_adr(arg, class_klass_offset);
3398     Node* kls = LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, adr_type, kls_type);
3399     klasses[which_arg] = _gvn.transform(kls);
3400   }
3401 
3402   // Having loaded both klasses, test each for null.
3403   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3404   for (which_arg = 0; which_arg &lt;= 1; which_arg++) {
3405     Node* kls = klasses[which_arg];
3406     Node* null_ctl = top();
3407     kls = null_check_oop(kls, &amp;null_ctl, never_see_null);
3408     int prim_path = (which_arg == 0 ? _prim_0_path : _prim_1_path);
3409     region-&gt;init_req(prim_path, null_ctl);
3410     if (stopped())  break;
3411     klasses[which_arg] = kls;
3412   }
3413 
3414   if (!stopped()) {
3415     // now we have two reference types, in klasses[0..1]
3416     Node* subk   = klasses[1];  // the argument to isAssignableFrom
3417     Node* superk = klasses[0];  // the receiver
3418     region-&gt;set_req(_both_ref_path, gen_subtype_check(subk, superk));
3419     // now we have a successful reference subtype check
3420     region-&gt;set_req(_ref_subtype_path, control());
3421   }
3422 
3423   // If both operands are primitive (both klasses null), then
3424   // we must return true when they are identical primitives.
3425   // It is convenient to test this after the first null klass check.
3426   set_control(region-&gt;in(_prim_0_path)); // go back to first null check
3427   if (!stopped()) {
3428     // Since superc is primitive, make a guard for the superc==subc case.
3429     Node* cmp_eq = _gvn.transform(new CmpPNode(args[0], args[1]));
3430     Node* bol_eq = _gvn.transform(new BoolNode(cmp_eq, BoolTest::eq));
3431     generate_guard(bol_eq, region, PROB_FAIR);
3432     if (region-&gt;req() == PATH_LIMIT+1) {
3433       // A guard was added.  If the added guard is taken, superc==subc.
3434       region-&gt;swap_edges(PATH_LIMIT, _prim_same_path);
3435       region-&gt;del_req(PATH_LIMIT);
3436     }
3437     region-&gt;set_req(_prim_0_path, control()); // Not equal after all.
3438   }
3439 
3440   // these are the only paths that produce &#39;true&#39;:
3441   phi-&gt;set_req(_prim_same_path,   intcon(1));
3442   phi-&gt;set_req(_ref_subtype_path, intcon(1));
3443 
3444   // pull together the cases:
3445   assert(region-&gt;req() == PATH_LIMIT, &quot;sane region&quot;);
3446   for (uint i = 1; i &lt; region-&gt;req(); i++) {
3447     Node* ctl = region-&gt;in(i);
3448     if (ctl == NULL || ctl == top()) {
3449       region-&gt;set_req(i, top());
3450       phi   -&gt;set_req(i, top());
3451     } else if (phi-&gt;in(i) == NULL) {
3452       phi-&gt;set_req(i, intcon(0)); // all other paths produce &#39;false&#39;
3453     }
3454   }
3455 
3456   set_control(_gvn.transform(region));
3457   set_result(_gvn.transform(phi));
3458   return true;
3459 }
3460 
3461 //---------------------generate_array_guard_common------------------------
3462 Node* LibraryCallKit::generate_array_guard_common(Node* kls, RegionNode* region,
3463                                                   bool obj_array, bool not_array) {
3464 
3465   if (stopped()) {
3466     return NULL;
3467   }
3468 
3469   // If obj_array/non_array==false/false:
3470   // Branch around if the given klass is in fact an array (either obj or prim).
3471   // If obj_array/non_array==false/true:
3472   // Branch around if the given klass is not an array klass of any kind.
3473   // If obj_array/non_array==true/true:
3474   // Branch around if the kls is not an oop array (kls is int[], String, etc.)
3475   // If obj_array/non_array==true/false:
3476   // Branch around if the kls is an oop array (Object[] or subtype)
3477   //
3478   // Like generate_guard, adds a new path onto the region.
3479   jint  layout_con = 0;
3480   Node* layout_val = get_layout_helper(kls, layout_con);
3481   if (layout_val == NULL) {
3482     bool query = (obj_array
3483                   ? Klass::layout_helper_is_objArray(layout_con)
3484                   : Klass::layout_helper_is_array(layout_con));
3485     if (query == not_array) {
3486       return NULL;                       // never a branch
3487     } else {                             // always a branch
3488       Node* always_branch = control();
3489       if (region != NULL)
3490         region-&gt;add_req(always_branch);
3491       set_control(top());
3492       return always_branch;
3493     }
3494   }
3495   // Now test the correct condition.
3496   jint  nval = (obj_array
3497                 ? (jint)(Klass::_lh_array_tag_type_value
3498                    &lt;&lt;    Klass::_lh_array_tag_shift)
3499                 : Klass::_lh_neutral_value);
3500   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(nval)));
3501   BoolTest::mask btest = BoolTest::lt;  // correct for testing is_[obj]array
3502   // invert the test if we are looking for a non-array
3503   if (not_array)  btest = BoolTest(btest).negate();
3504   Node* bol = _gvn.transform(new BoolNode(cmp, btest));
3505   return generate_fair_guard(bol, region);
3506 }
3507 
3508 
3509 //-----------------------inline_native_newArray--------------------------
3510 // private static native Object java.lang.reflect.newArray(Class&lt;?&gt; componentType, int length);
3511 // private        native Object Unsafe.allocateUninitializedArray0(Class&lt;?&gt; cls, int size);
3512 bool LibraryCallKit::inline_unsafe_newArray(bool uninitialized) {
3513   Node* mirror;
3514   Node* count_val;
3515   if (uninitialized) {
3516     mirror    = argument(1);
3517     count_val = argument(2);
3518   } else {
3519     mirror    = argument(0);
3520     count_val = argument(1);
3521   }
3522 
3523   mirror = null_check(mirror);
3524   // If mirror or obj is dead, only null-path is taken.
3525   if (stopped())  return true;
3526 
3527   enum { _normal_path = 1, _slow_path = 2, PATH_LIMIT };
3528   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3529   PhiNode*    result_val = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
3530   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3531   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3532 
3533   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3534   Node* klass_node = load_array_klass_from_mirror(mirror, never_see_null,
3535                                                   result_reg, _slow_path);
3536   Node* normal_ctl   = control();
3537   Node* no_array_ctl = result_reg-&gt;in(_slow_path);
3538 
3539   // Generate code for the slow case.  We make a call to newArray().
3540   set_control(no_array_ctl);
3541   if (!stopped()) {
3542     // Either the input type is void.class, or else the
3543     // array klass has not yet been cached.  Either the
3544     // ensuing call will throw an exception, or else it
3545     // will cache the array klass for next time.
3546     PreserveJVMState pjvms(this);
3547     CallJavaNode* slow_call = generate_method_call_static(vmIntrinsics::_newArray);
3548     Node* slow_result = set_results_for_java_call(slow_call);
3549     // this-&gt;control() comes from set_results_for_java_call
3550     result_reg-&gt;set_req(_slow_path, control());
3551     result_val-&gt;set_req(_slow_path, slow_result);
3552     result_io -&gt;set_req(_slow_path, i_o());
3553     result_mem-&gt;set_req(_slow_path, reset_memory());
3554   }
3555 
3556   set_control(normal_ctl);
3557   if (!stopped()) {
3558     // Normal case:  The array type has been cached in the java.lang.Class.
3559     // The following call works fine even if the array type is polymorphic.
3560     // It could be a dynamic mix of int[], boolean[], Object[], etc.
3561     Node* obj = new_array(klass_node, count_val, 0);  // no arguments to push
3562     result_reg-&gt;init_req(_normal_path, control());
3563     result_val-&gt;init_req(_normal_path, obj);
3564     result_io -&gt;init_req(_normal_path, i_o());
3565     result_mem-&gt;init_req(_normal_path, reset_memory());
3566 
3567     if (uninitialized) {
3568       // Mark the allocation so that zeroing is skipped
3569       AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(obj, &amp;_gvn);
3570       alloc-&gt;maybe_set_complete(&amp;_gvn);
3571     }
3572   }
3573 
3574   // Return the combined state.
3575   set_i_o(        _gvn.transform(result_io)  );
3576   set_all_memory( _gvn.transform(result_mem));
3577 
3578   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3579   set_result(result_reg, result_val);
3580   return true;
3581 }
3582 
3583 //----------------------inline_native_getLength--------------------------
3584 // public static native int java.lang.reflect.Array.getLength(Object array);
3585 bool LibraryCallKit::inline_native_getLength() {
3586   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3587 
3588   Node* array = null_check(argument(0));
3589   // If array is dead, only null-path is taken.
3590   if (stopped())  return true;
3591 
3592   // Deoptimize if it is a non-array.
3593   Node* non_array = generate_non_array_guard(load_object_klass(array), NULL);
3594 
3595   if (non_array != NULL) {
3596     PreserveJVMState pjvms(this);
3597     set_control(non_array);
3598     uncommon_trap(Deoptimization::Reason_intrinsic,
3599                   Deoptimization::Action_maybe_recompile);
3600   }
3601 
3602   // If control is dead, only non-array-path is taken.
3603   if (stopped())  return true;
3604 
3605   // The works fine even if the array type is polymorphic.
3606   // It could be a dynamic mix of int[], boolean[], Object[], etc.
3607   Node* result = load_array_length(array);
3608 
3609   C-&gt;set_has_split_ifs(true);  // Has chance for split-if optimization
3610   set_result(result);
3611   return true;
3612 }
3613 
3614 //------------------------inline_array_copyOf----------------------------
3615 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOf(     U[] original, int newLength,         Class&lt;? extends T[]&gt; newType);
3616 // public static &lt;T,U&gt; T[] java.util.Arrays.copyOfRange(U[] original, int from,      int to, Class&lt;? extends T[]&gt; newType);
3617 bool LibraryCallKit::inline_array_copyOf(bool is_copyOfRange) {
3618   if (too_many_traps(Deoptimization::Reason_intrinsic))  return false;
3619 
3620   // Get the arguments.
3621   Node* original          = argument(0);
3622   Node* start             = is_copyOfRange? argument(1): intcon(0);
3623   Node* end               = is_copyOfRange? argument(2): argument(1);
3624   Node* array_type_mirror = is_copyOfRange? argument(3): argument(2);
3625 
3626   Node* newcopy = NULL;
3627 
3628   // Set the original stack and the reexecute bit for the interpreter to reexecute
3629   // the bytecode that invokes Arrays.copyOf if deoptimization happens.
3630   { PreserveReexecuteState preexecs(this);
3631     jvms()-&gt;set_should_reexecute(true);
3632 
3633     array_type_mirror = null_check(array_type_mirror);
3634     original          = null_check(original);
3635 
3636     // Check if a null path was taken unconditionally.
3637     if (stopped())  return true;
3638 
3639     Node* orig_length = load_array_length(original);
3640 
3641     Node* klass_node = load_klass_from_mirror(array_type_mirror, false, NULL, 0);
3642     klass_node = null_check(klass_node);
3643 
3644     RegionNode* bailout = new RegionNode(1);
3645     record_for_igvn(bailout);
3646 
3647     // Despite the generic type of Arrays.copyOf, the mirror might be int, int[], etc.
3648     // Bail out if that is so.
3649     Node* not_objArray = generate_non_objArray_guard(klass_node, bailout);
3650     if (not_objArray != NULL) {
3651       // Improve the klass node&#39;s type from the new optimistic assumption:
3652       ciKlass* ak = ciArrayKlass::make(env()-&gt;Object_klass());
3653       const Type* akls = TypeKlassPtr::make(TypePtr::NotNull, ak, 0/*offset*/);
3654       Node* cast = new CastPPNode(klass_node, akls);
3655       cast-&gt;init_req(0, control());
3656       klass_node = _gvn.transform(cast);
3657     }
3658 
3659     // Bail out if either start or end is negative.
3660     generate_negative_guard(start, bailout, &amp;start);
3661     generate_negative_guard(end,   bailout, &amp;end);
3662 
3663     Node* length = end;
3664     if (_gvn.type(start) != TypeInt::ZERO) {
3665       length = _gvn.transform(new SubINode(end, start));
3666     }
3667 
3668     // Bail out if length is negative.
3669     // Without this the new_array would throw
3670     // NegativeArraySizeException but IllegalArgumentException is what
3671     // should be thrown
3672     generate_negative_guard(length, bailout, &amp;length);
3673 
3674     if (bailout-&gt;req() &gt; 1) {
3675       PreserveJVMState pjvms(this);
3676       set_control(_gvn.transform(bailout));
3677       uncommon_trap(Deoptimization::Reason_intrinsic,
3678                     Deoptimization::Action_maybe_recompile);
3679     }
3680 
3681     if (!stopped()) {
3682       // How many elements will we copy from the original?
3683       // The answer is MinI(orig_length - start, length).
3684       Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));
3685       Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);
3686 
3687       // Generate a direct call to the right arraycopy function(s).
3688       // We know the copy is disjoint but we might not know if the
3689       // oop stores need checking.
3690       // Extreme case:  Arrays.copyOf((Integer[])x, 10, String[].class).
3691       // This will fail a store-check if x contains any non-nulls.
3692 
3693       // ArrayCopyNode:Ideal may transform the ArrayCopyNode to
3694       // loads/stores but it is legal only if we&#39;re sure the
3695       // Arrays.copyOf would succeed. So we need all input arguments
3696       // to the copyOf to be validated, including that the copy to the
3697       // new array won&#39;t trigger an ArrayStoreException. That subtype
3698       // check can be optimized if we know something on the type of
3699       // the input array from type speculation.
3700       if (_gvn.type(klass_node)-&gt;singleton()) {
3701         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3702         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3703 
3704         int test = C-&gt;static_subtype_check(superk, subk);
3705         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3706           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3707           if (t_original-&gt;speculative_type() != NULL) {
3708             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3709           }
3710         }
3711       }
3712 
3713       bool validated = false;
3714       // Reason_class_check rather than Reason_intrinsic because we
3715       // want to intrinsify even if this traps.
3716       if (!too_many_traps(Deoptimization::Reason_class_check)) {
3717         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),
3718                                                    klass_node);
3719 
3720         if (not_subtype_ctrl != top()) {
3721           PreserveJVMState pjvms(this);
3722           set_control(not_subtype_ctrl);
3723           uncommon_trap(Deoptimization::Reason_class_check,
3724                         Deoptimization::Action_make_not_entrant);
3725           assert(stopped(), &quot;Should be stopped&quot;);
3726         }
3727         validated = true;
3728       }
3729 
3730       if (!stopped()) {
3731         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3732 
3733         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3734                                                 load_object_klass(original), klass_node);
3735         if (!is_copyOfRange) {
3736           ac-&gt;set_copyof(validated);
3737         } else {
3738           ac-&gt;set_copyofrange(validated);
3739         }
3740         Node* n = _gvn.transform(ac);
3741         if (n == ac) {
3742           ac-&gt;connect_outputs(this);
3743         } else {
3744           assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
3745           set_all_memory(n);
3746         }
3747       }
3748     }
3749   } // original reexecute is set back here
3750 
3751   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3752   if (!stopped()) {
3753     set_result(newcopy);
3754   }
3755   return true;
3756 }
3757 
3758 
3759 //----------------------generate_virtual_guard---------------------------
3760 // Helper for hashCode and clone.  Peeks inside the vtable to avoid a call.
3761 Node* LibraryCallKit::generate_virtual_guard(Node* obj_klass,
3762                                              RegionNode* slow_region) {
3763   ciMethod* method = callee();
3764   int vtable_index = method-&gt;vtable_index();
3765   assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3766          &quot;bad index %d&quot;, vtable_index);
3767   // Get the Method* out of the appropriate vtable entry.
3768   int entry_offset  = in_bytes(Klass::vtable_start_offset()) +
3769                      vtable_index*vtableEntry::size_in_bytes() +
3770                      vtableEntry::method_offset_in_bytes();
3771   Node* entry_addr  = basic_plus_adr(obj_klass, entry_offset);
3772   Node* target_call = make_load(NULL, entry_addr, TypePtr::NOTNULL, T_ADDRESS, MemNode::unordered);
3773 
3774   // Compare the target method with the expected method (e.g., Object.hashCode).
3775   const TypePtr* native_call_addr = TypeMetadataPtr::make(method);
3776 
3777   Node* native_call = makecon(native_call_addr);
3778   Node* chk_native  = _gvn.transform(new CmpPNode(target_call, native_call));
3779   Node* test_native = _gvn.transform(new BoolNode(chk_native, BoolTest::ne));
3780 
3781   return generate_slow_guard(test_native, slow_region);
3782 }
3783 
3784 //-----------------------generate_method_call----------------------------
3785 // Use generate_method_call to make a slow-call to the real
3786 // method if the fast path fails.  An alternative would be to
3787 // use a stub like OptoRuntime::slow_arraycopy_Java.
3788 // This only works for expanding the current library call,
3789 // not another intrinsic.  (E.g., don&#39;t use this for making an
3790 // arraycopy call inside of the copyOf intrinsic.)
3791 CallJavaNode*
3792 LibraryCallKit::generate_method_call(vmIntrinsics::ID method_id, bool is_virtual, bool is_static) {
3793   // When compiling the intrinsic method itself, do not use this technique.
3794   guarantee(callee() != C-&gt;method(), &quot;cannot make slow-call to self&quot;);
3795 
3796   ciMethod* method = callee();
3797   // ensure the JVMS we have will be correct for this call
3798   guarantee(method_id == method-&gt;intrinsic_id(), &quot;must match&quot;);
3799 
3800   const TypeFunc* tf = TypeFunc::make(method);
3801   CallJavaNode* slow_call;
3802   if (is_static) {
3803     assert(!is_virtual, &quot;&quot;);
3804     slow_call = new CallStaticJavaNode(C, tf,
3805                            SharedRuntime::get_resolve_static_call_stub(),
3806                            method, bci());
3807   } else if (is_virtual) {
3808     null_check_receiver();
3809     int vtable_index = Method::invalid_vtable_index;
3810     if (UseInlineCaches) {
3811       // Suppress the vtable call
3812     } else {
3813       // hashCode and clone are not a miranda methods,
3814       // so the vtable index is fixed.
3815       // No need to use the linkResolver to get it.
3816        vtable_index = method-&gt;vtable_index();
3817        assert(vtable_index &gt;= 0 || vtable_index == Method::nonvirtual_vtable_index,
3818               &quot;bad index %d&quot;, vtable_index);
3819     }
3820     slow_call = new CallDynamicJavaNode(tf,
3821                           SharedRuntime::get_resolve_virtual_call_stub(),
3822                           method, vtable_index, bci());
3823   } else {  // neither virtual nor static:  opt_virtual
3824     null_check_receiver();
3825     slow_call = new CallStaticJavaNode(C, tf,
3826                                 SharedRuntime::get_resolve_opt_virtual_call_stub(),
3827                                 method, bci());
3828     slow_call-&gt;set_optimized_virtual(true);
3829   }
3830   if (CallGenerator::is_inlined_method_handle_intrinsic(this-&gt;method(), bci(), callee())) {
3831     // To be able to issue a direct call (optimized virtual or virtual)
3832     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
3833     // about the method being invoked should be attached to the call site to
3834     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
3835     slow_call-&gt;set_override_symbolic_info(true);
3836   }
3837   set_arguments_for_java_call(slow_call);
3838   set_edges_for_java_call(slow_call);
3839   return slow_call;
3840 }
3841 
3842 
3843 /**
3844  * Build special case code for calls to hashCode on an object. This call may
3845  * be virtual (invokevirtual) or bound (invokespecial). For each case we generate
3846  * slightly different code.
3847  */
3848 bool LibraryCallKit::inline_native_hashcode(bool is_virtual, bool is_static) {
3849   assert(is_static == callee()-&gt;is_static(), &quot;correct intrinsic selection&quot;);
3850   assert(!(is_virtual &amp;&amp; is_static), &quot;either virtual, special, or static&quot;);
3851 
3852   enum { _slow_path = 1, _fast_path, _null_path, PATH_LIMIT };
3853 
3854   RegionNode* result_reg = new RegionNode(PATH_LIMIT);
3855   PhiNode*    result_val = new PhiNode(result_reg, TypeInt::INT);
3856   PhiNode*    result_io  = new PhiNode(result_reg, Type::ABIO);
3857   PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
3858   Node* obj = NULL;
3859   if (!is_static) {
3860     // Check for hashing null object
3861     obj = null_check_receiver();
3862     if (stopped())  return true;        // unconditionally null
3863     result_reg-&gt;init_req(_null_path, top());
3864     result_val-&gt;init_req(_null_path, top());
3865   } else {
3866     // Do a null check, and return zero if null.
3867     // System.identityHashCode(null) == 0
3868     obj = argument(0);
3869     Node* null_ctl = top();
3870     obj = null_check_oop(obj, &amp;null_ctl);
3871     result_reg-&gt;init_req(_null_path, null_ctl);
3872     result_val-&gt;init_req(_null_path, _gvn.intcon(0));
3873   }
3874 
3875   // Unconditionally null?  Then return right away.
3876   if (stopped()) {
3877     set_control( result_reg-&gt;in(_null_path));
3878     if (!stopped())
3879       set_result(result_val-&gt;in(_null_path));
3880     return true;
3881   }
3882 
3883   // We only go to the fast case code if we pass a number of guards.  The
3884   // paths which do not pass are accumulated in the slow_region.
3885   RegionNode* slow_region = new RegionNode(1);
3886   record_for_igvn(slow_region);
3887 
3888   // If this is a virtual call, we generate a funny guard.  We pull out
3889   // the vtable entry corresponding to hashCode() from the target object.
3890   // If the target method which we are calling happens to be the native
3891   // Object hashCode() method, we pass the guard.  We do not need this
3892   // guard for non-virtual calls -- the caller is known to be the native
3893   // Object hashCode().
3894   if (is_virtual) {
3895     // After null check, get the object&#39;s klass.
3896     Node* obj_klass = load_object_klass(obj);
3897     generate_virtual_guard(obj_klass, slow_region);
3898   }
3899 
3900   // Get the header out of the object, use LoadMarkNode when available
3901   Node* header_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());
3902   // The control of the load must be NULL. Otherwise, the load can move before
3903   // the null check after castPP removal.
3904   Node* no_ctrl = NULL;
3905   Node* header = make_load(no_ctrl, header_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
3906 
3907   // Test the header to see if it is unlocked.
3908   Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);
3909   Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));
3910   Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);
3911   Node *chk_unlocked   = _gvn.transform(new CmpXNode( lmasked_header, unlocked_val));
3912   Node *test_unlocked  = _gvn.transform(new BoolNode( chk_unlocked, BoolTest::ne));
3913 
3914   generate_slow_guard(test_unlocked, slow_region);
3915 
3916   // Get the hash value and check to see that it has been properly assigned.
3917   // We depend on hash_mask being at most 32 bits and avoid the use of
3918   // hash_mask_in_place because it could be larger than 32 bits in a 64-bit
3919   // vm: see markWord.hpp.
3920   Node *hash_mask      = _gvn.intcon(markWord::hash_mask);
3921   Node *hash_shift     = _gvn.intcon(markWord::hash_shift);
3922   Node *hshifted_header= _gvn.transform(new URShiftXNode(header, hash_shift));
3923   // This hack lets the hash bits live anywhere in the mark object now, as long
3924   // as the shift drops the relevant bits into the low 32 bits.  Note that
3925   // Java spec says that HashCode is an int so there&#39;s no point in capturing
3926   // an &#39;X&#39;-sized hashcode (32 in 32-bit build or 64 in 64-bit build).
3927   hshifted_header      = ConvX2I(hshifted_header);
3928   Node *hash_val       = _gvn.transform(new AndINode(hshifted_header, hash_mask));
3929 
3930   Node *no_hash_val    = _gvn.intcon(markWord::no_hash);
3931   Node *chk_assigned   = _gvn.transform(new CmpINode( hash_val, no_hash_val));
3932   Node *test_assigned  = _gvn.transform(new BoolNode( chk_assigned, BoolTest::eq));
3933 
3934   generate_slow_guard(test_assigned, slow_region);
3935 
3936   Node* init_mem = reset_memory();
3937   // fill in the rest of the null path:
3938   result_io -&gt;init_req(_null_path, i_o());
3939   result_mem-&gt;init_req(_null_path, init_mem);
3940 
3941   result_val-&gt;init_req(_fast_path, hash_val);
3942   result_reg-&gt;init_req(_fast_path, control());
3943   result_io -&gt;init_req(_fast_path, i_o());
3944   result_mem-&gt;init_req(_fast_path, init_mem);
3945 
3946   // Generate code for the slow case.  We make a call to hashCode().
3947   set_control(_gvn.transform(slow_region));
3948   if (!stopped()) {
3949     // No need for PreserveJVMState, because we&#39;re using up the present state.
3950     set_all_memory(init_mem);
3951     vmIntrinsics::ID hashCode_id = is_static ? vmIntrinsics::_identityHashCode : vmIntrinsics::_hashCode;
3952     CallJavaNode* slow_call = generate_method_call(hashCode_id, is_virtual, is_static);
3953     Node* slow_result = set_results_for_java_call(slow_call);
3954     // this-&gt;control() comes from set_results_for_java_call
3955     result_reg-&gt;init_req(_slow_path, control());
3956     result_val-&gt;init_req(_slow_path, slow_result);
3957     result_io  -&gt;set_req(_slow_path, i_o());
3958     result_mem -&gt;set_req(_slow_path, reset_memory());
3959   }
3960 
3961   // Return the combined state.
3962   set_i_o(        _gvn.transform(result_io)  );
3963   set_all_memory( _gvn.transform(result_mem));
3964 
3965   set_result(result_reg, result_val);
3966   return true;
3967 }
3968 
3969 //---------------------------inline_native_getClass----------------------------
3970 // public final native Class&lt;?&gt; java.lang.Object.getClass();
3971 //
3972 // Build special case code for calls to getClass on an object.
3973 bool LibraryCallKit::inline_native_getClass() {
3974   Node* obj = null_check_receiver();
3975   if (stopped())  return true;
3976   set_result(load_mirror_from_klass(load_object_klass(obj)));
3977   return true;
3978 }
3979 
3980 //-----------------inline_native_Reflection_getCallerClass---------------------
3981 // public static native Class&lt;?&gt; sun.reflect.Reflection.getCallerClass();
3982 //
3983 // In the presence of deep enough inlining, getCallerClass() becomes a no-op.
3984 //
3985 // NOTE: This code must perform the same logic as JVM_GetCallerClass
3986 // in that it must skip particular security frames and checks for
3987 // caller sensitive methods.
3988 bool LibraryCallKit::inline_native_Reflection_getCallerClass() {
3989 #ifndef PRODUCT
3990   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
3991     tty-&gt;print_cr(&quot;Attempting to inline sun.reflect.Reflection.getCallerClass&quot;);
3992   }
3993 #endif
3994 
3995   if (!jvms()-&gt;has_method()) {
3996 #ifndef PRODUCT
3997     if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
3998       tty-&gt;print_cr(&quot;  Bailing out because intrinsic was inlined at top level&quot;);
3999     }
4000 #endif
4001     return false;
4002   }
4003 
4004   // Walk back up the JVM state to find the caller at the required
4005   // depth.
4006   JVMState* caller_jvms = jvms();
4007 
4008   // Cf. JVM_GetCallerClass
4009   // NOTE: Start the loop at depth 1 because the current JVM state does
4010   // not include the Reflection.getCallerClass() frame.
4011   for (int n = 1; caller_jvms != NULL; caller_jvms = caller_jvms-&gt;caller(), n++) {
4012     ciMethod* m = caller_jvms-&gt;method();
4013     switch (n) {
4014     case 0:
4015       fatal(&quot;current JVM state does not include the Reflection.getCallerClass frame&quot;);
4016       break;
4017     case 1:
4018       // Frame 0 and 1 must be caller sensitive (see JVM_GetCallerClass).
4019       if (!m-&gt;caller_sensitive()) {
4020 #ifndef PRODUCT
4021         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4022           tty-&gt;print_cr(&quot;  Bailing out: CallerSensitive annotation expected at frame %d&quot;, n);
4023         }
4024 #endif
4025         return false;  // bail-out; let JVM_GetCallerClass do the work
4026       }
4027       break;
4028     default:
4029       if (!m-&gt;is_ignored_by_security_stack_walk()) {
4030         // We have reached the desired frame; return the holder class.
4031         // Acquire method holder as java.lang.Class and push as constant.
4032         ciInstanceKlass* caller_klass = caller_jvms-&gt;method()-&gt;holder();
4033         ciInstance* caller_mirror = caller_klass-&gt;java_mirror();
4034         set_result(makecon(TypeInstPtr::make(caller_mirror)));
4035 
4036 #ifndef PRODUCT
4037         if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4038           tty-&gt;print_cr(&quot;  Succeeded: caller = %d) %s.%s, JVMS depth = %d&quot;, n, caller_klass-&gt;name()-&gt;as_utf8(), caller_jvms-&gt;method()-&gt;name()-&gt;as_utf8(), jvms()-&gt;depth());
4039           tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4040           for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4041             ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4042             tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4043           }
4044         }
4045 #endif
4046         return true;
4047       }
4048       break;
4049     }
4050   }
4051 
4052 #ifndef PRODUCT
4053   if ((C-&gt;print_intrinsics() || C-&gt;print_inlining()) &amp;&amp; Verbose) {
4054     tty-&gt;print_cr(&quot;  Bailing out because caller depth exceeded inlining depth = %d&quot;, jvms()-&gt;depth());
4055     tty-&gt;print_cr(&quot;  JVM state at this point:&quot;);
4056     for (int i = jvms()-&gt;depth(), n = 1; i &gt;= 1; i--, n++) {
4057       ciMethod* m = jvms()-&gt;of_depth(i)-&gt;method();
4058       tty-&gt;print_cr(&quot;   %d) %s.%s&quot;, n, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
4059     }
4060   }
4061 #endif
4062 
4063   return false;  // bail-out; let JVM_GetCallerClass do the work
4064 }
4065 
4066 bool LibraryCallKit::inline_fp_conversions(vmIntrinsics::ID id) {
4067   Node* arg = argument(0);
4068   Node* result = NULL;
4069 
4070   switch (id) {
4071   case vmIntrinsics::_floatToRawIntBits:    result = new MoveF2INode(arg);  break;
4072   case vmIntrinsics::_intBitsToFloat:       result = new MoveI2FNode(arg);  break;
4073   case vmIntrinsics::_doubleToRawLongBits:  result = new MoveD2LNode(arg);  break;
4074   case vmIntrinsics::_longBitsToDouble:     result = new MoveL2DNode(arg);  break;
4075 
4076   case vmIntrinsics::_doubleToLongBits: {
4077     // two paths (plus control) merge in a wood
4078     RegionNode *r = new RegionNode(3);
4079     Node *phi = new PhiNode(r, TypeLong::LONG);
4080 
4081     Node *cmpisnan = _gvn.transform(new CmpDNode(arg, arg));
4082     // Build the boolean node
4083     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4084 
4085     // Branch either way.
4086     // NaN case is less traveled, which makes all the difference.
4087     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4088     Node *opt_isnan = _gvn.transform(ifisnan);
4089     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4090     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4091     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4092 
4093     set_control(iftrue);
4094 
4095     static const jlong nan_bits = CONST64(0x7ff8000000000000);
4096     Node *slow_result = longcon(nan_bits); // return NaN
4097     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4098     r-&gt;init_req(1, iftrue);
4099 
4100     // Else fall through
4101     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4102     set_control(iffalse);
4103 
4104     phi-&gt;init_req(2, _gvn.transform(new MoveD2LNode(arg)));
4105     r-&gt;init_req(2, iffalse);
4106 
4107     // Post merge
4108     set_control(_gvn.transform(r));
4109     record_for_igvn(r);
4110 
4111     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4112     result = phi;
4113     assert(result-&gt;bottom_type()-&gt;isa_long(), &quot;must be&quot;);
4114     break;
4115   }
4116 
4117   case vmIntrinsics::_floatToIntBits: {
4118     // two paths (plus control) merge in a wood
4119     RegionNode *r = new RegionNode(3);
4120     Node *phi = new PhiNode(r, TypeInt::INT);
4121 
4122     Node *cmpisnan = _gvn.transform(new CmpFNode(arg, arg));
4123     // Build the boolean node
4124     Node *bolisnan = _gvn.transform(new BoolNode(cmpisnan, BoolTest::ne));
4125 
4126     // Branch either way.
4127     // NaN case is less traveled, which makes all the difference.
4128     IfNode *ifisnan = create_and_xform_if(control(), bolisnan, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
4129     Node *opt_isnan = _gvn.transform(ifisnan);
4130     assert( opt_isnan-&gt;is_If(), &quot;Expect an IfNode&quot;);
4131     IfNode *opt_ifisnan = (IfNode*)opt_isnan;
4132     Node *iftrue = _gvn.transform(new IfTrueNode(opt_ifisnan));
4133 
4134     set_control(iftrue);
4135 
4136     static const jint nan_bits = 0x7fc00000;
4137     Node *slow_result = makecon(TypeInt::make(nan_bits)); // return NaN
4138     phi-&gt;init_req(1, _gvn.transform( slow_result ));
4139     r-&gt;init_req(1, iftrue);
4140 
4141     // Else fall through
4142     Node *iffalse = _gvn.transform(new IfFalseNode(opt_ifisnan));
4143     set_control(iffalse);
4144 
4145     phi-&gt;init_req(2, _gvn.transform(new MoveF2INode(arg)));
4146     r-&gt;init_req(2, iffalse);
4147 
4148     // Post merge
4149     set_control(_gvn.transform(r));
4150     record_for_igvn(r);
4151 
4152     C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
4153     result = phi;
4154     assert(result-&gt;bottom_type()-&gt;isa_int(), &quot;must be&quot;);
4155     break;
4156   }
4157 
4158   default:
4159     fatal_unexpected_iid(id);
4160     break;
4161   }
4162   set_result(_gvn.transform(result));
4163   return true;
4164 }
4165 
4166 //----------------------inline_unsafe_copyMemory-------------------------
4167 // public native void Unsafe.copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4168 bool LibraryCallKit::inline_unsafe_copyMemory() {
4169   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
4170   null_check_receiver();  // null-check receiver
4171   if (stopped())  return true;
4172 
4173   C-&gt;set_has_unsafe_access(true);  // Mark eventual nmethod as &quot;unsafe&quot;.
4174 
4175   Node* src_ptr =         argument(1);   // type: oop
4176   Node* src_off = ConvL2X(argument(2));  // type: long
4177   Node* dst_ptr =         argument(4);   // type: oop
4178   Node* dst_off = ConvL2X(argument(5));  // type: long
4179   Node* size    = ConvL2X(argument(7));  // type: long
4180 
4181   assert(Unsafe_field_offset_to_byte_offset(11) == 11,
4182          &quot;fieldOffset must be byte-scaled&quot;);
4183 
4184   Node* src = make_unsafe_address(src_ptr, src_off, ACCESS_READ);
4185   Node* dst = make_unsafe_address(dst_ptr, dst_off, ACCESS_WRITE);
4186 
4187   // Conservatively insert a memory barrier on all memory slices.
4188   // Do not let writes of the copy source or destination float below the copy.
4189   insert_mem_bar(Op_MemBarCPUOrder);
4190 
4191   Node* thread = _gvn.transform(new ThreadLocalNode());
4192   Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));
4193   BasicType doing_unsafe_access_bt = T_BYTE;
4194   assert((sizeof(bool) * CHAR_BIT) == 8, &quot;not implemented&quot;);
4195 
4196   // update volatile field
4197   store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4198 
4199   // Call it.  Note that the length argument is not scaled.
4200   make_runtime_call(RC_LEAF|RC_NO_FP,
4201                     OptoRuntime::fast_arraycopy_Type(),
4202                     StubRoutines::unsafe_arraycopy(),
4203                     &quot;unsafe_arraycopy&quot;,
4204                     TypeRawPtr::BOTTOM,
4205                     src, dst, size XTOP);
4206 
4207   store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);
4208 
4209   // Do not let reads of the copy destination float above the copy.
4210   insert_mem_bar(Op_MemBarCPUOrder);
4211 
4212   return true;
4213 }
4214 
4215 //------------------------clone_coping-----------------------------------
4216 // Helper function for inline_native_clone.
4217 void LibraryCallKit::copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array) {
4218   assert(obj_size != NULL, &quot;&quot;);
4219   Node* raw_obj = alloc_obj-&gt;in(1);
4220   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4221 
4222   AllocateNode* alloc = NULL;
4223   if (ReduceBulkZeroing) {
4224     // We will be completely responsible for initializing this object -
4225     // mark Initialize node as complete.
4226     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4227     // The object was just allocated - there should be no any stores!
4228     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4229     // Mark as complete_with_arraycopy so that on AllocateNode
4230     // expansion, we know this AllocateNode is initialized by an array
4231     // copy and a StoreStore barrier exists after the array copy.
4232     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4233   }
4234 
4235   Node* size = _gvn.transform(obj_size);
4236   access_clone(obj, alloc_obj, size, is_array);
4237 
4238   // Do not let reads from the cloned object float above the arraycopy.
4239   if (alloc != NULL) {
4240     // Do not let stores that initialize this object be reordered with
4241     // a subsequent store that would make this object accessible by
4242     // other threads.
4243     // Record what AllocateNode this StoreStore protects so that
4244     // escape analysis can go from the MemBarStoreStoreNode to the
4245     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4246     // based on the escape status of the AllocateNode.
4247     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4248   } else {
4249     insert_mem_bar(Op_MemBarCPUOrder);
4250   }
4251 }
4252 
4253 //------------------------inline_native_clone----------------------------
4254 // protected native Object java.lang.Object.clone();
4255 //
4256 // Here are the simple edge cases:
4257 //  null receiver =&gt; normal trap
4258 //  virtual and clone was overridden =&gt; slow path to out-of-line clone
4259 //  not cloneable or finalizer =&gt; slow path to out-of-line Object.clone
4260 //
4261 // The general case has two steps, allocation and copying.
4262 // Allocation has two cases, and uses GraphKit::new_instance or new_array.
4263 //
4264 // Copying also has two cases, oop arrays and everything else.
4265 // Oop arrays use arrayof_oop_arraycopy (same as System.arraycopy).
4266 // Everything else uses the tight inline loop supplied by CopyArrayNode.
4267 //
4268 // These steps fold up nicely if and when the cloned object&#39;s klass
4269 // can be sharply typed as an object array, a type array, or an instance.
4270 //
4271 bool LibraryCallKit::inline_native_clone(bool is_virtual) {
4272   PhiNode* result_val;
4273 
4274   // Set the reexecute bit for the interpreter to reexecute
4275   // the bytecode that invokes Object.clone if deoptimization happens.
4276   { PreserveReexecuteState preexecs(this);
4277     jvms()-&gt;set_should_reexecute(true);
4278 
4279     Node* obj = null_check_receiver();
4280     if (stopped())  return true;
4281 
4282     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
4283 
4284     // If we are going to clone an instance, we need its exact type to
4285     // know the number and types of fields to convert the clone to
4286     // loads/stores. Maybe a speculative type can help us.
4287     if (!obj_type-&gt;klass_is_exact() &amp;&amp;
4288         obj_type-&gt;speculative_type() != NULL &amp;&amp;
4289         obj_type-&gt;speculative_type()-&gt;is_instance_klass()) {
4290       ciInstanceKlass* spec_ik = obj_type-&gt;speculative_type()-&gt;as_instance_klass();
4291       if (spec_ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem &amp;&amp;
4292           !spec_ik-&gt;has_injected_fields()) {
4293         ciKlass* k = obj_type-&gt;klass();
4294         if (!k-&gt;is_instance_klass() ||
4295             k-&gt;as_instance_klass()-&gt;is_interface() ||
4296             k-&gt;as_instance_klass()-&gt;has_subklass()) {
4297           obj = maybe_cast_profiled_obj(obj, obj_type-&gt;speculative_type(), false);
4298         }
4299       }
4300     }
4301 
4302     // Conservatively insert a memory barrier on all memory slices.
4303     // Do not let writes into the original float below the clone.
4304     insert_mem_bar(Op_MemBarCPUOrder);
4305 
4306     // paths into result_reg:
4307     enum {
4308       _slow_path = 1,     // out-of-line call to clone method (virtual or not)
4309       _objArray_path,     // plain array allocation, plus arrayof_oop_arraycopy
4310       _array_path,        // plain array allocation, plus arrayof_long_arraycopy
4311       _instance_path,     // plain instance allocation, plus arrayof_long_arraycopy
4312       PATH_LIMIT
4313     };
4314     RegionNode* result_reg = new RegionNode(PATH_LIMIT);
4315     result_val             = new PhiNode(result_reg, TypeInstPtr::NOTNULL);
4316     PhiNode*    result_i_o = new PhiNode(result_reg, Type::ABIO);
4317     PhiNode*    result_mem = new PhiNode(result_reg, Type::MEMORY, TypePtr::BOTTOM);
4318     record_for_igvn(result_reg);
4319 
4320     Node* obj_klass = load_object_klass(obj);
4321     Node* array_ctl = generate_array_guard(obj_klass, (RegionNode*)NULL);
4322     if (array_ctl != NULL) {
4323       // It&#39;s an array.
4324       PreserveJVMState pjvms(this);
4325       set_control(array_ctl);
4326       Node* obj_length = load_array_length(obj);
4327       Node* obj_size  = NULL;
4328       Node* alloc_obj = new_array(obj_klass, obj_length, 0, &amp;obj_size);  // no arguments to push
4329 
4330       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
4331       if (bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {
4332         // If it is an oop array, it requires very special treatment,
4333         // because gc barriers are required when accessing the array.
4334         Node* is_obja = generate_objArray_guard(obj_klass, (RegionNode*)NULL);
4335         if (is_obja != NULL) {
4336           PreserveJVMState pjvms2(this);
4337           set_control(is_obja);
4338           // Generate a direct call to the right arraycopy function(s).
4339           Node* alloc = tightly_coupled_allocation(alloc_obj, NULL);
4340           ArrayCopyNode* ac = ArrayCopyNode::make(this, true, obj, intcon(0), alloc_obj, intcon(0), obj_length, alloc != NULL, false);
4341           ac-&gt;set_clone_oop_array();
4342           Node* n = _gvn.transform(ac);
4343           assert(n == ac, &quot;cannot disappear&quot;);
4344           ac-&gt;connect_outputs(this);
4345 
4346           result_reg-&gt;init_req(_objArray_path, control());
4347           result_val-&gt;init_req(_objArray_path, alloc_obj);
4348           result_i_o -&gt;set_req(_objArray_path, i_o());
4349           result_mem -&gt;set_req(_objArray_path, reset_memory());
4350         }
4351       }
4352       // Otherwise, there are no barriers to worry about.
4353       // (We can dispense with card marks if we know the allocation
4354       //  comes out of eden (TLAB)...  In fact, ReduceInitialCardMarks
4355       //  causes the non-eden paths to take compensating steps to
4356       //  simulate a fresh allocation, so that no further
4357       //  card marks are required in compiled code to initialize
4358       //  the object.)
4359 
4360       if (!stopped()) {
4361         copy_to_clone(obj, alloc_obj, obj_size, true);
4362 
4363         // Present the results of the copy.
4364         result_reg-&gt;init_req(_array_path, control());
4365         result_val-&gt;init_req(_array_path, alloc_obj);
4366         result_i_o -&gt;set_req(_array_path, i_o());
4367         result_mem -&gt;set_req(_array_path, reset_memory());
4368       }
4369     }
4370 
4371     // We only go to the instance fast case code if we pass a number of guards.
4372     // The paths which do not pass are accumulated in the slow_region.
4373     RegionNode* slow_region = new RegionNode(1);
4374     record_for_igvn(slow_region);
4375     if (!stopped()) {
4376       // It&#39;s an instance (we did array above).  Make the slow-path tests.
4377       // If this is a virtual call, we generate a funny guard.  We grab
4378       // the vtable entry corresponding to clone() from the target object.
4379       // If the target method which we are calling happens to be the
4380       // Object clone() method, we pass the guard.  We do not need this
4381       // guard for non-virtual calls; the caller is known to be the native
4382       // Object clone().
4383       if (is_virtual) {
4384         generate_virtual_guard(obj_klass, slow_region);
4385       }
4386 
4387       // The object must be easily cloneable and must not have a finalizer.
4388       // Both of these conditions may be checked in a single test.
4389       // We could optimize the test further, but we don&#39;t care.
4390       generate_access_flags_guard(obj_klass,
4391                                   // Test both conditions:
4392                                   JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,
4393                                   // Must be cloneable but not finalizer:
4394                                   JVM_ACC_IS_CLONEABLE_FAST,
4395                                   slow_region);
4396     }
4397 
4398     if (!stopped()) {
4399       // It&#39;s an instance, and it passed the slow-path tests.
4400       PreserveJVMState pjvms(this);
4401       Node* obj_size  = NULL;
4402       // Need to deoptimize on exception from allocation since Object.clone intrinsic
4403       // is reexecuted if deoptimization occurs and there could be problems when merging
4404       // exception state between multiple Object.clone versions (reexecute=true vs reexecute=false).
4405       Node* alloc_obj = new_instance(obj_klass, NULL, &amp;obj_size, /*deoptimize_on_exception=*/true);
4406 
4407       copy_to_clone(obj, alloc_obj, obj_size, false);
4408 
4409       // Present the results of the slow call.
4410       result_reg-&gt;init_req(_instance_path, control());
4411       result_val-&gt;init_req(_instance_path, alloc_obj);
4412       result_i_o -&gt;set_req(_instance_path, i_o());
4413       result_mem -&gt;set_req(_instance_path, reset_memory());
4414     }
4415 
4416     // Generate code for the slow case.  We make a call to clone().
4417     set_control(_gvn.transform(slow_region));
4418     if (!stopped()) {
4419       PreserveJVMState pjvms(this);
4420       CallJavaNode* slow_call = generate_method_call(vmIntrinsics::_clone, is_virtual);
4421       // We need to deoptimize on exception (see comment above)
4422       Node* slow_result = set_results_for_java_call(slow_call, false, /* deoptimize */ true);
4423       // this-&gt;control() comes from set_results_for_java_call
4424       result_reg-&gt;init_req(_slow_path, control());
4425       result_val-&gt;init_req(_slow_path, slow_result);
4426       result_i_o -&gt;set_req(_slow_path, i_o());
4427       result_mem -&gt;set_req(_slow_path, reset_memory());
4428     }
4429 
4430     // Return the combined state.
4431     set_control(    _gvn.transform(result_reg));
4432     set_i_o(        _gvn.transform(result_i_o));
4433     set_all_memory( _gvn.transform(result_mem));
4434   } // original reexecute is set back here
4435 
4436   set_result(_gvn.transform(result_val));
4437   return true;
4438 }
4439 
4440 // If we have a tightly coupled allocation, the arraycopy may take care
4441 // of the array initialization. If one of the guards we insert between
4442 // the allocation and the arraycopy causes a deoptimization, an
4443 // unitialized array will escape the compiled method. To prevent that
4444 // we set the JVM state for uncommon traps between the allocation and
4445 // the arraycopy to the state before the allocation so, in case of
4446 // deoptimization, we&#39;ll reexecute the allocation and the
4447 // initialization.
4448 JVMState* LibraryCallKit::arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp) {
4449   if (alloc != NULL) {
4450     ciMethod* trap_method = alloc-&gt;jvms()-&gt;method();
4451     int trap_bci = alloc-&gt;jvms()-&gt;bci();
4452 
4453     if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4454         !C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_null_check)) {
4455       // Make sure there&#39;s no store between the allocation and the
4456       // arraycopy otherwise visible side effects could be rexecuted
4457       // in case of deoptimization and cause incorrect execution.
4458       bool no_interfering_store = true;
4459       Node* mem = alloc-&gt;in(TypeFunc::Memory);
4460       if (mem-&gt;is_MergeMem()) {
4461         for (MergeMemStream mms(merged_memory(), mem-&gt;as_MergeMem()); mms.next_non_empty2(); ) {
4462           Node* n = mms.memory();
4463           if (n != mms.memory2() &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4464             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4465             no_interfering_store = false;
4466             break;
4467           }
4468         }
4469       } else {
4470         for (MergeMemStream mms(merged_memory()); mms.next_non_empty(); ) {
4471           Node* n = mms.memory();
4472           if (n != mem &amp;&amp; !(n-&gt;is_Proj() &amp;&amp; n-&gt;in(0) == alloc-&gt;initialization())) {
4473             assert(n-&gt;is_Store(), &quot;what else?&quot;);
4474             no_interfering_store = false;
4475             break;
4476           }
4477         }
4478       }
4479 
4480       if (no_interfering_store) {
4481         JVMState* old_jvms = alloc-&gt;jvms()-&gt;clone_shallow(C);
4482         uint size = alloc-&gt;req();
4483         SafePointNode* sfpt = new SafePointNode(size, old_jvms);
4484         old_jvms-&gt;set_map(sfpt);
4485         for (uint i = 0; i &lt; size; i++) {
4486           sfpt-&gt;init_req(i, alloc-&gt;in(i));
4487         }
4488         // re-push array length for deoptimization
4489         sfpt-&gt;ins_req(old_jvms-&gt;stkoff() + old_jvms-&gt;sp(), alloc-&gt;in(AllocateNode::ALength));
4490         old_jvms-&gt;set_sp(old_jvms-&gt;sp()+1);
4491         old_jvms-&gt;set_monoff(old_jvms-&gt;monoff()+1);
4492         old_jvms-&gt;set_scloff(old_jvms-&gt;scloff()+1);
4493         old_jvms-&gt;set_endoff(old_jvms-&gt;endoff()+1);
4494         old_jvms-&gt;set_should_reexecute(true);
4495 
4496         sfpt-&gt;set_i_o(map()-&gt;i_o());
4497         sfpt-&gt;set_memory(map()-&gt;memory());
4498         sfpt-&gt;set_control(map()-&gt;control());
4499 
4500         JVMState* saved_jvms = jvms();
4501         saved_reexecute_sp = _reexecute_sp;
4502 
4503         set_jvms(sfpt-&gt;jvms());
4504         _reexecute_sp = jvms()-&gt;sp();
4505 
4506         return saved_jvms;
4507       }
4508     }
4509   }
4510   return NULL;
4511 }
4512 
4513 // In case of a deoptimization, we restart execution at the
4514 // allocation, allocating a new array. We would leave an uninitialized
4515 // array in the heap that GCs wouldn&#39;t expect. Move the allocation
4516 // after the traps so we don&#39;t allocate the array if we
4517 // deoptimize. This is possible because tightly_coupled_allocation()
4518 // guarantees there&#39;s no observer of the allocated array at this point
4519 // and the control flow is simple enough.
4520 void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,
4521                                                     int saved_reexecute_sp, uint new_idx) {
4522   if (saved_jvms != NULL &amp;&amp; !stopped()) {
4523     assert(alloc != NULL, &quot;only with a tightly coupled allocation&quot;);
4524     // restore JVM state to the state at the arraycopy
4525     saved_jvms-&gt;map()-&gt;set_control(map()-&gt;control());
4526     assert(saved_jvms-&gt;map()-&gt;memory() == map()-&gt;memory(), &quot;memory state changed?&quot;);
4527     assert(saved_jvms-&gt;map()-&gt;i_o() == map()-&gt;i_o(), &quot;IO state changed?&quot;);
4528     // If we&#39;ve improved the types of some nodes (null check) while
4529     // emitting the guards, propagate them to the current state
4530     map()-&gt;replaced_nodes().apply(saved_jvms-&gt;map(), new_idx);
4531     set_jvms(saved_jvms);
4532     _reexecute_sp = saved_reexecute_sp;
4533 
4534     // Remove the allocation from above the guards
4535     CallProjections callprojs;
4536     alloc-&gt;extract_projections(&amp;callprojs, true);
4537     InitializeNode* init = alloc-&gt;initialization();
4538     Node* alloc_mem = alloc-&gt;in(TypeFunc::Memory);
4539     C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj, alloc-&gt;in(TypeFunc::I_O));
4540     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Memory), alloc_mem);
4541     C-&gt;gvn_replace_by(init-&gt;proj_out(TypeFunc::Control), alloc-&gt;in(0));
4542 
4543     // move the allocation here (after the guards)
4544     _gvn.hash_delete(alloc);
4545     alloc-&gt;set_req(TypeFunc::Control, control());
4546     alloc-&gt;set_req(TypeFunc::I_O, i_o());
4547     Node *mem = reset_memory();
4548     set_all_memory(mem);
4549     alloc-&gt;set_req(TypeFunc::Memory, mem);
4550     set_control(init-&gt;proj_out_or_null(TypeFunc::Control));
4551     set_i_o(callprojs.fallthrough_ioproj);
4552 
4553     // Update memory as done in GraphKit::set_output_for_allocation()
4554     const TypeInt* length_type = _gvn.find_int_type(alloc-&gt;in(AllocateNode::ALength));
4555     const TypeOopPtr* ary_type = _gvn.type(alloc-&gt;in(AllocateNode::KlassNode))-&gt;is_klassptr()-&gt;as_instance_type();
4556     if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4557       ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4558     }
4559     const TypePtr* telemref = ary_type-&gt;add_offset(Type::OffsetBot);
4560     int            elemidx  = C-&gt;get_alias_index(telemref);
4561     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), Compile::AliasIdxRaw);
4562     set_memory(init-&gt;proj_out_or_null(TypeFunc::Memory), elemidx);
4563 
4564     Node* allocx = _gvn.transform(alloc);
4565     assert(allocx == alloc, &quot;where has the allocation gone?&quot;);
4566     assert(dest-&gt;is_CheckCastPP(), &quot;not an allocation result?&quot;);
4567 
4568     _gvn.hash_delete(dest);
4569     dest-&gt;set_req(0, control());
4570     Node* destx = _gvn.transform(dest);
4571     assert(destx == dest, &quot;where has the allocation result gone?&quot;);
4572   }
4573 }
4574 
4575 
4576 //------------------------------inline_arraycopy-----------------------
4577 // public static native void java.lang.System.arraycopy(Object src,  int  srcPos,
4578 //                                                      Object dest, int destPos,
4579 //                                                      int length);
4580 bool LibraryCallKit::inline_arraycopy() {
4581   // Get the arguments.
4582   Node* src         = argument(0);  // type: oop
4583   Node* src_offset  = argument(1);  // type: int
4584   Node* dest        = argument(2);  // type: oop
4585   Node* dest_offset = argument(3);  // type: int
4586   Node* length      = argument(4);  // type: int
4587 
4588   uint new_idx = C-&gt;unique();
4589 
4590   // Check for allocation before we add nodes that would confuse
4591   // tightly_coupled_allocation()
4592   AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);
4593 
4594   int saved_reexecute_sp = -1;
4595   JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);
4596   // See arraycopy_restore_alloc_state() comment
4597   // if alloc == NULL we don&#39;t have to worry about a tightly coupled allocation so we can emit all needed guards
4598   // if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation
4599   // if saved_jvms == NULL and alloc != NULL, we can&#39;t emit any guards
4600   bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);
4601 
4602   // The following tests must be performed
4603   // (1) src and dest are arrays.
4604   // (2) src and dest arrays must have elements of the same BasicType
4605   // (3) src and dest must not be null.
4606   // (4) src_offset must not be negative.
4607   // (5) dest_offset must not be negative.
4608   // (6) length must not be negative.
4609   // (7) src_offset + length must not exceed length of src.
4610   // (8) dest_offset + length must not exceed length of dest.
4611   // (9) each element of an oop array must be assignable
4612 
4613   // (3) src and dest must not be null.
4614   // always do this here because we need the JVM state for uncommon traps
4615   Node* null_ctl = top();
4616   src  = saved_jvms != NULL ? null_check_oop(src, &amp;null_ctl, true, true) : null_check(src,  T_ARRAY);
4617   assert(null_ctl-&gt;is_top(), &quot;no null control here&quot;);
4618   dest = null_check(dest, T_ARRAY);
4619 
4620   if (!can_emit_guards) {
4621     // if saved_jvms == NULL and alloc != NULL, we don&#39;t emit any
4622     // guards but the arraycopy node could still take advantage of a
4623     // tightly allocated allocation. tightly_coupled_allocation() is
4624     // called again to make sure it takes the null check above into
4625     // account: the null check is mandatory and if it caused an
4626     // uncommon trap to be emitted then the allocation can&#39;t be
4627     // considered tightly coupled in this context.
4628     alloc = tightly_coupled_allocation(dest, NULL);
4629   }
4630 
4631   bool validated = false;
4632 
4633   const Type* src_type  = _gvn.type(src);
4634   const Type* dest_type = _gvn.type(dest);
4635   const TypeAryPtr* top_src  = src_type-&gt;isa_aryptr();
4636   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
4637 
4638   // Do we have the type of src?
4639   bool has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4640   // Do we have the type of dest?
4641   bool has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4642   // Is the type for src from speculation?
4643   bool src_spec = false;
4644   // Is the type for dest from speculation?
4645   bool dest_spec = false;
4646 
4647   if ((!has_src || !has_dest) &amp;&amp; can_emit_guards) {
4648     // We don&#39;t have sufficient type information, let&#39;s see if
4649     // speculative types can help. We need to have types for both src
4650     // and dest so that it pays off.
4651 
4652     // Do we already have or could we have type information for src
4653     bool could_have_src = has_src;
4654     // Do we already have or could we have type information for dest
4655     bool could_have_dest = has_dest;
4656 
4657     ciKlass* src_k = NULL;
4658     if (!has_src) {
4659       src_k = src_type-&gt;speculative_type_not_null();
4660       if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4661         could_have_src = true;
4662       }
4663     }
4664 
4665     ciKlass* dest_k = NULL;
4666     if (!has_dest) {
4667       dest_k = dest_type-&gt;speculative_type_not_null();
4668       if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4669         could_have_dest = true;
4670       }
4671     }
4672 
4673     if (could_have_src &amp;&amp; could_have_dest) {
4674       // This is going to pay off so emit the required guards
4675       if (!has_src) {
4676         src = maybe_cast_profiled_obj(src, src_k, true);
4677         src_type  = _gvn.type(src);
4678         top_src  = src_type-&gt;isa_aryptr();
4679         has_src = (top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL);
4680         src_spec = true;
4681       }
4682       if (!has_dest) {
4683         dest = maybe_cast_profiled_obj(dest, dest_k, true);
4684         dest_type  = _gvn.type(dest);
4685         top_dest  = dest_type-&gt;isa_aryptr();
4686         has_dest = (top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL);
4687         dest_spec = true;
4688       }
4689     }
4690   }
4691 
4692   if (has_src &amp;&amp; has_dest &amp;&amp; can_emit_guards) {
4693     BasicType src_elem  = top_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4694     BasicType dest_elem = top_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4695     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;
4696     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;
4697 
4698     if (src_elem == dest_elem &amp;&amp; src_elem == T_OBJECT) {
4699       // If both arrays are object arrays then having the exact types
4700       // for both will remove the need for a subtype check at runtime
4701       // before the call and may make it possible to pick a faster copy
4702       // routine (without a subtype check on every element)
4703       // Do we have the exact type of src?
4704       bool could_have_src = src_spec;
4705       // Do we have the exact type of dest?
4706       bool could_have_dest = dest_spec;
4707       ciKlass* src_k = top_src-&gt;klass();
4708       ciKlass* dest_k = top_dest-&gt;klass();
4709       if (!src_spec) {
4710         src_k = src_type-&gt;speculative_type_not_null();
4711         if (src_k != NULL &amp;&amp; src_k-&gt;is_array_klass()) {
4712           could_have_src = true;
4713         }
4714       }
4715       if (!dest_spec) {
4716         dest_k = dest_type-&gt;speculative_type_not_null();
4717         if (dest_k != NULL &amp;&amp; dest_k-&gt;is_array_klass()) {
4718           could_have_dest = true;
4719         }
4720       }
4721       if (could_have_src &amp;&amp; could_have_dest) {
4722         // If we can have both exact types, emit the missing guards
4723         if (could_have_src &amp;&amp; !src_spec) {
4724           src = maybe_cast_profiled_obj(src, src_k, true);
4725         }
4726         if (could_have_dest &amp;&amp; !dest_spec) {
4727           dest = maybe_cast_profiled_obj(dest, dest_k, true);
4728         }
4729       }
4730     }
4731   }
4732 
4733   ciMethod* trap_method = method();
4734   int trap_bci = bci();
4735   if (saved_jvms != NULL) {
4736     trap_method = alloc-&gt;jvms()-&gt;method();
4737     trap_bci = alloc-&gt;jvms()-&gt;bci();
4738   }
4739 
4740   bool negative_length_guard_generated = false;
4741 
4742   if (!C-&gt;too_many_traps(trap_method, trap_bci, Deoptimization::Reason_intrinsic) &amp;&amp;
4743       can_emit_guards &amp;&amp;
4744       !src-&gt;is_top() &amp;&amp; !dest-&gt;is_top()) {
4745     // validate arguments: enables transformation the ArrayCopyNode
4746     validated = true;
4747 
4748     RegionNode* slow_region = new RegionNode(1);
4749     record_for_igvn(slow_region);
4750 
4751     // (1) src and dest are arrays.
4752     generate_non_array_guard(load_object_klass(src), slow_region);
4753     generate_non_array_guard(load_object_klass(dest), slow_region);
4754 
4755     // (2) src and dest arrays must have elements of the same BasicType
4756     // done at macro expansion or at Ideal transformation time
4757 
4758     // (4) src_offset must not be negative.
4759     generate_negative_guard(src_offset, slow_region);
4760 
4761     // (5) dest_offset must not be negative.
4762     generate_negative_guard(dest_offset, slow_region);
4763 
4764     // (7) src_offset + length must not exceed length of src.
4765     generate_limit_guard(src_offset, length,
4766                          load_array_length(src),
4767                          slow_region);
4768 
4769     // (8) dest_offset + length must not exceed length of dest.
4770     generate_limit_guard(dest_offset, length,
4771                          load_array_length(dest),
4772                          slow_region);
4773 
4774     // (6) length must not be negative.
4775     // This is also checked in generate_arraycopy() during macro expansion, but
4776     // we also have to check it here for the case where the ArrayCopyNode will
4777     // be eliminated by Escape Analysis.
4778     if (EliminateAllocations) {
4779       generate_negative_guard(length, slow_region);
4780       negative_length_guard_generated = true;
4781     }
4782 
4783     // (9) each element of an oop array must be assignable
4784     Node* src_klass  = load_object_klass(src);
4785     Node* dest_klass = load_object_klass(dest);
4786     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);
4787 
4788     if (not_subtype_ctrl != top()) {
4789       PreserveJVMState pjvms(this);
4790       set_control(not_subtype_ctrl);
4791       uncommon_trap(Deoptimization::Reason_intrinsic,
4792                     Deoptimization::Action_make_not_entrant);
4793       assert(stopped(), &quot;Should be stopped&quot;);
4794     }
4795     {
4796       PreserveJVMState pjvms(this);
4797       set_control(_gvn.transform(slow_region));
4798       uncommon_trap(Deoptimization::Reason_intrinsic,
4799                     Deoptimization::Action_make_not_entrant);
4800       assert(stopped(), &quot;Should be stopped&quot;);
4801     }
4802 
4803     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4804     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4805     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4806   }
4807 
4808   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4809 
4810   if (stopped()) {
4811     return true;
4812   }
4813 
4814   ArrayCopyNode* ac = ArrayCopyNode::make(this, true, src, src_offset, dest, dest_offset, length, alloc != NULL, negative_length_guard_generated,
4815                                           // Create LoadRange and LoadKlass nodes for use during macro expansion here
4816                                           // so the compiler has a chance to eliminate them: during macro expansion,
4817                                           // we have to set their control (CastPP nodes are eliminated).
4818                                           load_object_klass(src), load_object_klass(dest),
4819                                           load_array_length(src), load_array_length(dest));
4820 
4821   ac-&gt;set_arraycopy(validated);
4822 
4823   Node* n = _gvn.transform(ac);
4824   if (n == ac) {
4825     ac-&gt;connect_outputs(this);
4826   } else {
4827     assert(validated, &quot;shouldn&#39;t transform if all arguments not validated&quot;);
4828     set_all_memory(n);
4829   }
4830   clear_upper_avx();
4831 
4832 
4833   return true;
4834 }
4835 
4836 
4837 // Helper function which determines if an arraycopy immediately follows
4838 // an allocation, with no intervening tests or other escapes for the object.
4839 AllocateArrayNode*
4840 LibraryCallKit::tightly_coupled_allocation(Node* ptr,
4841                                            RegionNode* slow_region) {
4842   if (stopped())             return NULL;  // no fast path
4843   if (C-&gt;AliasLevel() == 0)  return NULL;  // no MergeMems around
4844 
4845   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(ptr, &amp;_gvn);
4846   if (alloc == NULL)  return NULL;
4847 
4848   Node* rawmem = memory(Compile::AliasIdxRaw);
4849   // Is the allocation&#39;s memory state untouched?
4850   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0)-&gt;is_Initialize())) {
4851     // Bail out if there have been raw-memory effects since the allocation.
4852     // (Example:  There might have been a call or safepoint.)
4853     return NULL;
4854   }
4855   rawmem = rawmem-&gt;in(0)-&gt;as_Initialize()-&gt;memory(Compile::AliasIdxRaw);
4856   if (!(rawmem-&gt;is_Proj() &amp;&amp; rawmem-&gt;in(0) == alloc)) {
4857     return NULL;
4858   }
4859 
4860   // There must be no unexpected observers of this allocation.
4861   for (DUIterator_Fast imax, i = ptr-&gt;fast_outs(imax); i &lt; imax; i++) {
4862     Node* obs = ptr-&gt;fast_out(i);
4863     if (obs != this-&gt;map()) {
4864       return NULL;
4865     }
4866   }
4867 
4868   // This arraycopy must unconditionally follow the allocation of the ptr.
4869   Node* alloc_ctl = ptr-&gt;in(0);
4870   assert(just_allocated_object(alloc_ctl) == ptr, &quot;most recent allo&quot;);
4871 
4872   Node* ctl = control();
4873   while (ctl != alloc_ctl) {
4874     // There may be guards which feed into the slow_region.
4875     // Any other control flow means that we might not get a chance
4876     // to finish initializing the allocated object.
4877     if ((ctl-&gt;is_IfFalse() || ctl-&gt;is_IfTrue()) &amp;&amp; ctl-&gt;in(0)-&gt;is_If()) {
4878       IfNode* iff = ctl-&gt;in(0)-&gt;as_If();
4879       Node* not_ctl = iff-&gt;proj_out_or_null(1 - ctl-&gt;as_Proj()-&gt;_con);
4880       assert(not_ctl != NULL &amp;&amp; not_ctl != ctl, &quot;found alternate&quot;);
4881       if (slow_region != NULL &amp;&amp; slow_region-&gt;find_edge(not_ctl) &gt;= 1) {
4882         ctl = iff-&gt;in(0);       // This test feeds the known slow_region.
4883         continue;
4884       }
4885       // One more try:  Various low-level checks bottom out in
4886       // uncommon traps.  If the debug-info of the trap omits
4887       // any reference to the allocation, as we&#39;ve already
4888       // observed, then there can be no objection to the trap.
4889       bool found_trap = false;
4890       for (DUIterator_Fast jmax, j = not_ctl-&gt;fast_outs(jmax); j &lt; jmax; j++) {
4891         Node* obs = not_ctl-&gt;fast_out(j);
4892         if (obs-&gt;in(0) == not_ctl &amp;&amp; obs-&gt;is_Call() &amp;&amp;
4893             (obs-&gt;as_Call()-&gt;entry_point() == SharedRuntime::uncommon_trap_blob()-&gt;entry_point())) {
4894           found_trap = true; break;
4895         }
4896       }
4897       if (found_trap) {
4898         ctl = iff-&gt;in(0);       // This test feeds a harmless uncommon trap.
4899         continue;
4900       }
4901     }
4902     return NULL;
4903   }
4904 
4905   // If we get this far, we have an allocation which immediately
4906   // precedes the arraycopy, and we can take over zeroing the new object.
4907   // The arraycopy will finish the initialization, and provide
4908   // a new control state to which we will anchor the destination pointer.
4909 
4910   return alloc;
4911 }
4912 
4913 //-------------inline_encodeISOArray-----------------------------------
4914 // encode char[] to byte[] in ISO_8859_1
4915 bool LibraryCallKit::inline_encodeISOArray() {
4916   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;encodeISOArray has 5 parameters&quot;);
4917   // no receiver since it is static method
4918   Node *src         = argument(0);
4919   Node *src_offset  = argument(1);
4920   Node *dst         = argument(2);
4921   Node *dst_offset  = argument(3);
4922   Node *length      = argument(4);
4923 
4924   src = must_be_not_null(src, true);
4925   dst = must_be_not_null(dst, true);
4926 
4927   const Type* src_type = src-&gt;Value(&amp;_gvn);
4928   const Type* dst_type = dst-&gt;Value(&amp;_gvn);
4929   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
4930   const TypeAryPtr* top_dest = dst_type-&gt;isa_aryptr();
4931   if (top_src  == NULL || top_src-&gt;klass()  == NULL ||
4932       top_dest == NULL || top_dest-&gt;klass() == NULL) {
4933     // failed array check
4934     return false;
4935   }
4936 
4937   // Figure out the size and type of the elements we will be copying.
4938   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4939   BasicType dst_elem = dst_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4940   if (!((src_elem == T_CHAR) || (src_elem== T_BYTE)) || dst_elem != T_BYTE) {
4941     return false;
4942   }
4943 
4944   Node* src_start = array_element_address(src, src_offset, T_CHAR);
4945   Node* dst_start = array_element_address(dst, dst_offset, dst_elem);
4946   // &#39;src_start&#39; points to src array + scaled offset
4947   // &#39;dst_start&#39; points to dst array + scaled offset
4948 
4949   const TypeAryPtr* mtype = TypeAryPtr::BYTES;
4950   Node* enc = new EncodeISOArrayNode(control(), memory(mtype), src_start, dst_start, length);
4951   enc = _gvn.transform(enc);
4952   Node* res_mem = _gvn.transform(new SCMemProjNode(enc));
4953   set_memory(res_mem, mtype);
4954   set_result(enc);
4955   clear_upper_avx();
4956 
4957   return true;
4958 }
4959 
4960 //-------------inline_multiplyToLen-----------------------------------
4961 bool LibraryCallKit::inline_multiplyToLen() {
4962   assert(UseMultiplyToLenIntrinsic, &quot;not implemented on this platform&quot;);
4963 
4964   address stubAddr = StubRoutines::multiplyToLen();
4965   if (stubAddr == NULL) {
4966     return false; // Intrinsic&#39;s stub is not implemented on this platform
4967   }
4968   const char* stubName = &quot;multiplyToLen&quot;;
4969 
4970   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;multiplyToLen has 5 parameters&quot;);
4971 
4972   // no receiver because it is a static method
4973   Node* x    = argument(0);
4974   Node* xlen = argument(1);
4975   Node* y    = argument(2);
4976   Node* ylen = argument(3);
4977   Node* z    = argument(4);
4978 
4979   x = must_be_not_null(x, true);
4980   y = must_be_not_null(y, true);
4981 
4982   const Type* x_type = x-&gt;Value(&amp;_gvn);
4983   const Type* y_type = y-&gt;Value(&amp;_gvn);
4984   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
4985   const TypeAryPtr* top_y = y_type-&gt;isa_aryptr();
4986   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
4987       top_y == NULL || top_y-&gt;klass() == NULL) {
4988     // failed array check
4989     return false;
4990   }
4991 
4992   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4993   BasicType y_elem = y_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
4994   if (x_elem != T_INT || y_elem != T_INT) {
4995     return false;
4996   }
4997 
4998   // Set the original stack and the reexecute bit for the interpreter to reexecute
4999   // the bytecode that invokes BigInteger.multiplyToLen() if deoptimization happens
5000   // on the return from z array allocation in runtime.
5001   { PreserveReexecuteState preexecs(this);
5002     jvms()-&gt;set_should_reexecute(true);
5003 
5004     Node* x_start = array_element_address(x, intcon(0), x_elem);
5005     Node* y_start = array_element_address(y, intcon(0), y_elem);
5006     // &#39;x_start&#39; points to x array + scaled xlen
5007     // &#39;y_start&#39; points to y array + scaled ylen
5008 
5009     // Allocate the result array
5010     Node* zlen = _gvn.transform(new AddINode(xlen, ylen));
5011     ciKlass* klass = ciTypeArrayKlass::make(T_INT);
5012     Node* klass_node = makecon(TypeKlassPtr::make(klass));
5013 
5014     IdealKit ideal(this);
5015 
5016 #define __ ideal.
5017      Node* one = __ ConI(1);
5018      Node* zero = __ ConI(0);
5019      IdealVariable need_alloc(ideal), z_alloc(ideal);  __ declarations_done();
5020      __ set(need_alloc, zero);
5021      __ set(z_alloc, z);
5022      __ if_then(z, BoolTest::eq, null()); {
5023        __ increment (need_alloc, one);
5024      } __ else_(); {
5025        // Update graphKit memory and control from IdealKit.
5026        sync_kit(ideal);
5027        Node *cast = new CastPPNode(z, TypePtr::NOTNULL);
5028        cast-&gt;init_req(0, control());
5029        _gvn.set_type(cast, cast-&gt;bottom_type());
5030        C-&gt;record_for_igvn(cast);
5031 
5032        Node* zlen_arg = load_array_length(cast);
5033        // Update IdealKit memory and control from graphKit.
5034        __ sync_kit(this);
5035        __ if_then(zlen_arg, BoolTest::lt, zlen); {
5036          __ increment (need_alloc, one);
5037        } __ end_if();
5038      } __ end_if();
5039 
5040      __ if_then(__ value(need_alloc), BoolTest::ne, zero); {
5041        // Update graphKit memory and control from IdealKit.
5042        sync_kit(ideal);
5043        Node * narr = new_array(klass_node, zlen, 1);
5044        // Update IdealKit memory and control from graphKit.
5045        __ sync_kit(this);
5046        __ set(z_alloc, narr);
5047      } __ end_if();
5048 
5049      sync_kit(ideal);
5050      z = __ value(z_alloc);
5051      // Can&#39;t use TypeAryPtr::INTS which uses Bottom offset.
5052      _gvn.set_type(z, TypeOopPtr::make_from_klass(klass));
5053      // Final sync IdealKit and GraphKit.
5054      final_sync(ideal);
5055 #undef __
5056 
5057     Node* z_start = array_element_address(z, intcon(0), T_INT);
5058 
5059     Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
5060                                    OptoRuntime::multiplyToLen_Type(),
5061                                    stubAddr, stubName, TypePtr::BOTTOM,
5062                                    x_start, xlen, y_start, ylen, z_start, zlen);
5063   } // original reexecute is set back here
5064 
5065   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
5066   set_result(z);
5067   return true;
5068 }
5069 
5070 //-------------inline_squareToLen------------------------------------
5071 bool LibraryCallKit::inline_squareToLen() {
5072   assert(UseSquareToLenIntrinsic, &quot;not implemented on this platform&quot;);
5073 
5074   address stubAddr = StubRoutines::squareToLen();
5075   if (stubAddr == NULL) {
5076     return false; // Intrinsic&#39;s stub is not implemented on this platform
5077   }
5078   const char* stubName = &quot;squareToLen&quot;;
5079 
5080   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;implSquareToLen has 4 parameters&quot;);
5081 
5082   Node* x    = argument(0);
5083   Node* len  = argument(1);
5084   Node* z    = argument(2);
5085   Node* zlen = argument(3);
5086 
5087   x = must_be_not_null(x, true);
5088   z = must_be_not_null(z, true);
5089 
5090   const Type* x_type = x-&gt;Value(&amp;_gvn);
5091   const Type* z_type = z-&gt;Value(&amp;_gvn);
5092   const TypeAryPtr* top_x = x_type-&gt;isa_aryptr();
5093   const TypeAryPtr* top_z = z_type-&gt;isa_aryptr();
5094   if (top_x  == NULL || top_x-&gt;klass()  == NULL ||
5095       top_z  == NULL || top_z-&gt;klass()  == NULL) {
5096     // failed array check
5097     return false;
5098   }
5099 
5100   BasicType x_elem = x_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5101   BasicType z_elem = z_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5102   if (x_elem != T_INT || z_elem != T_INT) {
5103     return false;
5104   }
5105 
5106 
5107   Node* x_start = array_element_address(x, intcon(0), x_elem);
5108   Node* z_start = array_element_address(z, intcon(0), z_elem);
5109 
5110   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5111                                   OptoRuntime::squareToLen_Type(),
5112                                   stubAddr, stubName, TypePtr::BOTTOM,
5113                                   x_start, len, z_start, zlen);
5114 
5115   set_result(z);
5116   return true;
5117 }
5118 
5119 //-------------inline_mulAdd------------------------------------------
5120 bool LibraryCallKit::inline_mulAdd() {
5121   assert(UseMulAddIntrinsic, &quot;not implemented on this platform&quot;);
5122 
5123   address stubAddr = StubRoutines::mulAdd();
5124   if (stubAddr == NULL) {
5125     return false; // Intrinsic&#39;s stub is not implemented on this platform
5126   }
5127   const char* stubName = &quot;mulAdd&quot;;
5128 
5129   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;mulAdd has 5 parameters&quot;);
5130 
5131   Node* out      = argument(0);
5132   Node* in       = argument(1);
5133   Node* offset   = argument(2);
5134   Node* len      = argument(3);
5135   Node* k        = argument(4);
5136 
5137   out = must_be_not_null(out, true);
5138 
5139   const Type* out_type = out-&gt;Value(&amp;_gvn);
5140   const Type* in_type = in-&gt;Value(&amp;_gvn);
5141   const TypeAryPtr* top_out = out_type-&gt;isa_aryptr();
5142   const TypeAryPtr* top_in = in_type-&gt;isa_aryptr();
5143   if (top_out  == NULL || top_out-&gt;klass()  == NULL ||
5144       top_in == NULL || top_in-&gt;klass() == NULL) {
5145     // failed array check
5146     return false;
5147   }
5148 
5149   BasicType out_elem = out_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5150   BasicType in_elem = in_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5151   if (out_elem != T_INT || in_elem != T_INT) {
5152     return false;
5153   }
5154 
5155   Node* outlen = load_array_length(out);
5156   Node* new_offset = _gvn.transform(new SubINode(outlen, offset));
5157   Node* out_start = array_element_address(out, intcon(0), out_elem);
5158   Node* in_start = array_element_address(in, intcon(0), in_elem);
5159 
5160   Node*  call = make_runtime_call(RC_LEAF|RC_NO_FP,
5161                                   OptoRuntime::mulAdd_Type(),
5162                                   stubAddr, stubName, TypePtr::BOTTOM,
5163                                   out_start,in_start, new_offset, len, k);
5164   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5165   set_result(result);
5166   return true;
5167 }
5168 
5169 //-------------inline_montgomeryMultiply-----------------------------------
5170 bool LibraryCallKit::inline_montgomeryMultiply() {
5171   address stubAddr = StubRoutines::montgomeryMultiply();
5172   if (stubAddr == NULL) {
5173     return false; // Intrinsic&#39;s stub is not implemented on this platform
5174   }
5175 
5176   assert(UseMontgomeryMultiplyIntrinsic, &quot;not implemented on this platform&quot;);
5177   const char* stubName = &quot;montgomery_multiply&quot;;
5178 
5179   assert(callee()-&gt;signature()-&gt;size() == 7, &quot;montgomeryMultiply has 7 parameters&quot;);
5180 
5181   Node* a    = argument(0);
5182   Node* b    = argument(1);
5183   Node* n    = argument(2);
5184   Node* len  = argument(3);
5185   Node* inv  = argument(4);
5186   Node* m    = argument(6);
5187 
5188   const Type* a_type = a-&gt;Value(&amp;_gvn);
5189   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5190   const Type* b_type = b-&gt;Value(&amp;_gvn);
5191   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5192   const Type* n_type = a-&gt;Value(&amp;_gvn);
5193   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5194   const Type* m_type = a-&gt;Value(&amp;_gvn);
5195   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5196   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5197       top_b == NULL || top_b-&gt;klass()  == NULL ||
5198       top_n == NULL || top_n-&gt;klass()  == NULL ||
5199       top_m == NULL || top_m-&gt;klass()  == NULL) {
5200     // failed array check
5201     return false;
5202   }
5203 
5204   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5205   BasicType b_elem = b_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5206   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5207   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5208   if (a_elem != T_INT || b_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5209     return false;
5210   }
5211 
5212   // Make the call
5213   {
5214     Node* a_start = array_element_address(a, intcon(0), a_elem);
5215     Node* b_start = array_element_address(b, intcon(0), b_elem);
5216     Node* n_start = array_element_address(n, intcon(0), n_elem);
5217     Node* m_start = array_element_address(m, intcon(0), m_elem);
5218 
5219     Node* call = make_runtime_call(RC_LEAF,
5220                                    OptoRuntime::montgomeryMultiply_Type(),
5221                                    stubAddr, stubName, TypePtr::BOTTOM,
5222                                    a_start, b_start, n_start, len, inv, top(),
5223                                    m_start);
5224     set_result(m);
5225   }
5226 
5227   return true;
5228 }
5229 
5230 bool LibraryCallKit::inline_montgomerySquare() {
5231   address stubAddr = StubRoutines::montgomerySquare();
5232   if (stubAddr == NULL) {
5233     return false; // Intrinsic&#39;s stub is not implemented on this platform
5234   }
5235 
5236   assert(UseMontgomerySquareIntrinsic, &quot;not implemented on this platform&quot;);
5237   const char* stubName = &quot;montgomery_square&quot;;
5238 
5239   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;montgomerySquare has 6 parameters&quot;);
5240 
5241   Node* a    = argument(0);
5242   Node* n    = argument(1);
5243   Node* len  = argument(2);
5244   Node* inv  = argument(3);
5245   Node* m    = argument(5);
5246 
5247   const Type* a_type = a-&gt;Value(&amp;_gvn);
5248   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5249   const Type* n_type = a-&gt;Value(&amp;_gvn);
5250   const TypeAryPtr* top_n = n_type-&gt;isa_aryptr();
5251   const Type* m_type = a-&gt;Value(&amp;_gvn);
5252   const TypeAryPtr* top_m = m_type-&gt;isa_aryptr();
5253   if (top_a  == NULL || top_a-&gt;klass()  == NULL ||
5254       top_n == NULL || top_n-&gt;klass()  == NULL ||
5255       top_m == NULL || top_m-&gt;klass()  == NULL) {
5256     // failed array check
5257     return false;
5258   }
5259 
5260   BasicType a_elem = a_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5261   BasicType n_elem = n_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5262   BasicType m_elem = m_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5263   if (a_elem != T_INT || n_elem != T_INT || m_elem != T_INT) {
5264     return false;
5265   }
5266 
5267   // Make the call
5268   {
5269     Node* a_start = array_element_address(a, intcon(0), a_elem);
5270     Node* n_start = array_element_address(n, intcon(0), n_elem);
5271     Node* m_start = array_element_address(m, intcon(0), m_elem);
5272 
5273     Node* call = make_runtime_call(RC_LEAF,
5274                                    OptoRuntime::montgomerySquare_Type(),
5275                                    stubAddr, stubName, TypePtr::BOTTOM,
5276                                    a_start, n_start, len, inv, top(),
5277                                    m_start);
5278     set_result(m);
5279   }
5280 
5281   return true;
5282 }
5283 
5284 bool LibraryCallKit::inline_bigIntegerShift(bool isRightShift) {
5285   address stubAddr = NULL;
5286   const char* stubName = NULL;
5287 
5288   stubAddr = isRightShift? StubRoutines::bigIntegerRightShift(): StubRoutines::bigIntegerLeftShift();
5289   if (stubAddr == NULL) {
5290     return false; // Intrinsic&#39;s stub is not implemented on this platform
5291   }
5292 
5293   stubName = isRightShift? &quot;bigIntegerRightShiftWorker&quot; : &quot;bigIntegerLeftShiftWorker&quot;;
5294 
5295   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;expected 5 arguments&quot;);
5296 
5297   Node* newArr = argument(0);
5298   Node* oldArr = argument(1);
5299   Node* newIdx = argument(2);
5300   Node* shiftCount = argument(3);
5301   Node* numIter = argument(4);
5302 
5303   const Type* newArr_type = newArr-&gt;Value(&amp;_gvn);
5304   const TypeAryPtr* top_newArr = newArr_type-&gt;isa_aryptr();
5305   const Type* oldArr_type = oldArr-&gt;Value(&amp;_gvn);
5306   const TypeAryPtr* top_oldArr = oldArr_type-&gt;isa_aryptr();
5307   if (top_newArr == NULL || top_newArr-&gt;klass() == NULL || top_oldArr == NULL
5308       || top_oldArr-&gt;klass() == NULL) {
5309     return false;
5310   }
5311 
5312   BasicType newArr_elem = newArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5313   BasicType oldArr_elem = oldArr_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5314   if (newArr_elem != T_INT || oldArr_elem != T_INT) {
5315     return false;
5316   }
5317 
5318   // Make the call
5319   {
5320     Node* newArr_start = array_element_address(newArr, intcon(0), newArr_elem);
5321     Node* oldArr_start = array_element_address(oldArr, intcon(0), oldArr_elem);
5322 
5323     Node* call = make_runtime_call(RC_LEAF,
5324                                    OptoRuntime::bigIntegerShift_Type(),
5325                                    stubAddr,
5326                                    stubName,
5327                                    TypePtr::BOTTOM,
5328                                    newArr_start,
5329                                    oldArr_start,
5330                                    newIdx,
5331                                    shiftCount,
5332                                    numIter);
5333   }
5334 
5335   return true;
5336 }
5337 
5338 //-------------inline_vectorizedMismatch------------------------------
5339 bool LibraryCallKit::inline_vectorizedMismatch() {
5340   assert(UseVectorizedMismatchIntrinsic, &quot;not implementated on this platform&quot;);
5341 
5342   address stubAddr = StubRoutines::vectorizedMismatch();
5343   if (stubAddr == NULL) {
5344     return false; // Intrinsic&#39;s stub is not implemented on this platform
5345   }
5346   const char* stubName = &quot;vectorizedMismatch&quot;;
5347   int size_l = callee()-&gt;signature()-&gt;size();
5348   assert(callee()-&gt;signature()-&gt;size() == 8, &quot;vectorizedMismatch has 6 parameters&quot;);
5349 
5350   Node* obja = argument(0);
5351   Node* aoffset = argument(1);
5352   Node* objb = argument(3);
5353   Node* boffset = argument(4);
5354   Node* length = argument(6);
5355   Node* scale = argument(7);
5356 
5357   const Type* a_type = obja-&gt;Value(&amp;_gvn);
5358   const Type* b_type = objb-&gt;Value(&amp;_gvn);
5359   const TypeAryPtr* top_a = a_type-&gt;isa_aryptr();
5360   const TypeAryPtr* top_b = b_type-&gt;isa_aryptr();
5361   if (top_a == NULL || top_a-&gt;klass() == NULL ||
5362     top_b == NULL || top_b-&gt;klass() == NULL) {
5363     // failed array check
5364     return false;
5365   }
5366 
5367   Node* call;
5368   jvms()-&gt;set_should_reexecute(true);
5369 
5370   Node* obja_adr = make_unsafe_address(obja, aoffset, ACCESS_READ);
5371   Node* objb_adr = make_unsafe_address(objb, boffset, ACCESS_READ);
5372 
5373   call = make_runtime_call(RC_LEAF,
5374     OptoRuntime::vectorizedMismatch_Type(),
5375     stubAddr, stubName, TypePtr::BOTTOM,
5376     obja_adr, objb_adr, length, scale);
5377 
5378   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5379   set_result(result);
5380   return true;
5381 }
5382 
5383 /**
5384  * Calculate CRC32 for byte.
5385  * int java.util.zip.CRC32.update(int crc, int b)
5386  */
5387 bool LibraryCallKit::inline_updateCRC32() {
5388   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5389   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;update has 2 parameters&quot;);
5390   // no receiver since it is static method
5391   Node* crc  = argument(0); // type: int
5392   Node* b    = argument(1); // type: int
5393 
5394   /*
5395    *    int c = ~ crc;
5396    *    b = timesXtoThe32[(b ^ c) &amp; 0xFF];
5397    *    b = b ^ (c &gt;&gt;&gt; 8);
5398    *    crc = ~b;
5399    */
5400 
5401   Node* M1 = intcon(-1);
5402   crc = _gvn.transform(new XorINode(crc, M1));
5403   Node* result = _gvn.transform(new XorINode(crc, b));
5404   result = _gvn.transform(new AndINode(result, intcon(0xFF)));
5405 
5406   Node* base = makecon(TypeRawPtr::make(StubRoutines::crc_table_addr()));
5407   Node* offset = _gvn.transform(new LShiftINode(result, intcon(0x2)));
5408   Node* adr = basic_plus_adr(top(), base, ConvI2X(offset));
5409   result = make_load(control(), adr, TypeInt::INT, T_INT, MemNode::unordered);
5410 
5411   crc = _gvn.transform(new URShiftINode(crc, intcon(8)));
5412   result = _gvn.transform(new XorINode(crc, result));
5413   result = _gvn.transform(new XorINode(result, M1));
5414   set_result(result);
5415   return true;
5416 }
5417 
5418 /**
5419  * Calculate CRC32 for byte[] array.
5420  * int java.util.zip.CRC32.updateBytes(int crc, byte[] buf, int off, int len)
5421  */
5422 bool LibraryCallKit::inline_updateBytesCRC32() {
5423   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5424   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5425   // no receiver since it is static method
5426   Node* crc     = argument(0); // type: int
5427   Node* src     = argument(1); // type: oop
5428   Node* offset  = argument(2); // type: int
5429   Node* length  = argument(3); // type: int
5430 
5431   const Type* src_type = src-&gt;Value(&amp;_gvn);
5432   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5433   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5434     // failed array check
5435     return false;
5436   }
5437 
5438   // Figure out the size and type of the elements we will be copying.
5439   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5440   if (src_elem != T_BYTE) {
5441     return false;
5442   }
5443 
5444   // &#39;src_start&#39; points to src array + scaled offset
5445   src = must_be_not_null(src, true);
5446   Node* src_start = array_element_address(src, offset, src_elem);
5447 
5448   // We assume that range check is done by caller.
5449   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5450 
5451   // Call the stub.
5452   address stubAddr = StubRoutines::updateBytesCRC32();
5453   const char *stubName = &quot;updateBytesCRC32&quot;;
5454 
5455   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5456                                  stubAddr, stubName, TypePtr::BOTTOM,
5457                                  crc, src_start, length);
5458   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5459   set_result(result);
5460   return true;
5461 }
5462 
5463 /**
5464  * Calculate CRC32 for ByteBuffer.
5465  * int java.util.zip.CRC32.updateByteBuffer(int crc, long buf, int off, int len)
5466  */
5467 bool LibraryCallKit::inline_updateByteBufferCRC32() {
5468   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
5469   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5470   // no receiver since it is static method
5471   Node* crc     = argument(0); // type: int
5472   Node* src     = argument(1); // type: long
5473   Node* offset  = argument(3); // type: int
5474   Node* length  = argument(4); // type: int
5475 
5476   src = ConvL2X(src);  // adjust Java long to machine word
5477   Node* base = _gvn.transform(new CastX2PNode(src));
5478   offset = ConvI2X(offset);
5479 
5480   // &#39;src_start&#39; points to src array + scaled offset
5481   Node* src_start = basic_plus_adr(top(), base, offset);
5482 
5483   // Call the stub.
5484   address stubAddr = StubRoutines::updateBytesCRC32();
5485   const char *stubName = &quot;updateBytesCRC32&quot;;
5486 
5487   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::updateBytesCRC32_Type(),
5488                                  stubAddr, stubName, TypePtr::BOTTOM,
5489                                  crc, src_start, length);
5490   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5491   set_result(result);
5492   return true;
5493 }
5494 
5495 //------------------------------get_table_from_crc32c_class-----------------------
5496 Node * LibraryCallKit::get_table_from_crc32c_class(ciInstanceKlass *crc32c_class) {
5497   Node* table = load_field_from_object(NULL, &quot;byteTable&quot;, &quot;[I&quot;, /*is_exact*/ false, /*is_static*/ true, crc32c_class);
5498   assert (table != NULL, &quot;wrong version of java.util.zip.CRC32C&quot;);
5499 
5500   return table;
5501 }
5502 
5503 //------------------------------inline_updateBytesCRC32C-----------------------
5504 //
5505 // Calculate CRC32C for byte[] array.
5506 // int java.util.zip.CRC32C.updateBytes(int crc, byte[] buf, int off, int end)
5507 //
5508 bool LibraryCallKit::inline_updateBytesCRC32C() {
5509   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5510   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5511   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5512   // no receiver since it is a static method
5513   Node* crc     = argument(0); // type: int
5514   Node* src     = argument(1); // type: oop
5515   Node* offset  = argument(2); // type: int
5516   Node* end     = argument(3); // type: int
5517 
5518   Node* length = _gvn.transform(new SubINode(end, offset));
5519 
5520   const Type* src_type = src-&gt;Value(&amp;_gvn);
5521   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5522   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5523     // failed array check
5524     return false;
5525   }
5526 
5527   // Figure out the size and type of the elements we will be copying.
5528   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5529   if (src_elem != T_BYTE) {
5530     return false;
5531   }
5532 
5533   // &#39;src_start&#39; points to src array + scaled offset
5534   src = must_be_not_null(src, true);
5535   Node* src_start = array_element_address(src, offset, src_elem);
5536 
5537   // static final int[] byteTable in class CRC32C
5538   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5539   table = must_be_not_null(table, true);
5540   Node* table_start = array_element_address(table, intcon(0), T_INT);
5541 
5542   // We assume that range check is done by caller.
5543   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5544 
5545   // Call the stub.
5546   address stubAddr = StubRoutines::updateBytesCRC32C();
5547   const char *stubName = &quot;updateBytesCRC32C&quot;;
5548 
5549   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5550                                  stubAddr, stubName, TypePtr::BOTTOM,
5551                                  crc, src_start, length, table_start);
5552   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5553   set_result(result);
5554   return true;
5555 }
5556 
5557 //------------------------------inline_updateDirectByteBufferCRC32C-----------------------
5558 //
5559 // Calculate CRC32C for DirectByteBuffer.
5560 // int java.util.zip.CRC32C.updateDirectByteBuffer(int crc, long buf, int off, int end)
5561 //
5562 bool LibraryCallKit::inline_updateDirectByteBufferCRC32C() {
5563   assert(UseCRC32CIntrinsics, &quot;need CRC32C instruction support&quot;);
5564   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateDirectByteBuffer has 4 parameters and one is long&quot;);
5565   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;CRC32C class must be loaded&quot;);
5566   // no receiver since it is a static method
5567   Node* crc     = argument(0); // type: int
5568   Node* src     = argument(1); // type: long
5569   Node* offset  = argument(3); // type: int
5570   Node* end     = argument(4); // type: int
5571 
5572   Node* length = _gvn.transform(new SubINode(end, offset));
5573 
5574   src = ConvL2X(src);  // adjust Java long to machine word
5575   Node* base = _gvn.transform(new CastX2PNode(src));
5576   offset = ConvI2X(offset);
5577 
5578   // &#39;src_start&#39; points to src array + scaled offset
5579   Node* src_start = basic_plus_adr(top(), base, offset);
5580 
5581   // static final int[] byteTable in class CRC32C
5582   Node* table = get_table_from_crc32c_class(callee()-&gt;holder());
5583   table = must_be_not_null(table, true);
5584   Node* table_start = array_element_address(table, intcon(0), T_INT);
5585 
5586   // Call the stub.
5587   address stubAddr = StubRoutines::updateBytesCRC32C();
5588   const char *stubName = &quot;updateBytesCRC32C&quot;;
5589 
5590   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesCRC32C_Type(),
5591                                  stubAddr, stubName, TypePtr::BOTTOM,
5592                                  crc, src_start, length, table_start);
5593   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5594   set_result(result);
5595   return true;
5596 }
5597 
5598 //------------------------------inline_updateBytesAdler32----------------------
5599 //
5600 // Calculate Adler32 checksum for byte[] array.
5601 // int java.util.zip.Adler32.updateBytes(int crc, byte[] buf, int off, int len)
5602 //
5603 bool LibraryCallKit::inline_updateBytesAdler32() {
5604   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5605   assert(callee()-&gt;signature()-&gt;size() == 4, &quot;updateBytes has 4 parameters&quot;);
5606   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5607   // no receiver since it is static method
5608   Node* crc     = argument(0); // type: int
5609   Node* src     = argument(1); // type: oop
5610   Node* offset  = argument(2); // type: int
5611   Node* length  = argument(3); // type: int
5612 
5613   const Type* src_type = src-&gt;Value(&amp;_gvn);
5614   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5615   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
5616     // failed array check
5617     return false;
5618   }
5619 
5620   // Figure out the size and type of the elements we will be copying.
5621   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
5622   if (src_elem != T_BYTE) {
5623     return false;
5624   }
5625 
5626   // &#39;src_start&#39; points to src array + scaled offset
5627   Node* src_start = array_element_address(src, offset, src_elem);
5628 
5629   // We assume that range check is done by caller.
5630   // TODO: generate range check (offset+length &lt; src.length) in debug VM.
5631 
5632   // Call the stub.
5633   address stubAddr = StubRoutines::updateBytesAdler32();
5634   const char *stubName = &quot;updateBytesAdler32&quot;;
5635 
5636   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5637                                  stubAddr, stubName, TypePtr::BOTTOM,
5638                                  crc, src_start, length);
5639   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5640   set_result(result);
5641   return true;
5642 }
5643 
5644 //------------------------------inline_updateByteBufferAdler32---------------
5645 //
5646 // Calculate Adler32 checksum for DirectByteBuffer.
5647 // int java.util.zip.Adler32.updateByteBuffer(int crc, long buf, int off, int len)
5648 //
5649 bool LibraryCallKit::inline_updateByteBufferAdler32() {
5650   assert(UseAdler32Intrinsics, &quot;Adler32 Instrinsic support need&quot;); // check if we actually need to check this flag or check a different one
5651   assert(callee()-&gt;signature()-&gt;size() == 5, &quot;updateByteBuffer has 4 parameters and one is long&quot;);
5652   assert(callee()-&gt;holder()-&gt;is_loaded(), &quot;Adler32 class must be loaded&quot;);
5653   // no receiver since it is static method
5654   Node* crc     = argument(0); // type: int
5655   Node* src     = argument(1); // type: long
5656   Node* offset  = argument(3); // type: int
5657   Node* length  = argument(4); // type: int
5658 
5659   src = ConvL2X(src);  // adjust Java long to machine word
5660   Node* base = _gvn.transform(new CastX2PNode(src));
5661   offset = ConvI2X(offset);
5662 
5663   // &#39;src_start&#39; points to src array + scaled offset
5664   Node* src_start = basic_plus_adr(top(), base, offset);
5665 
5666   // Call the stub.
5667   address stubAddr = StubRoutines::updateBytesAdler32();
5668   const char *stubName = &quot;updateBytesAdler32&quot;;
5669 
5670   Node* call = make_runtime_call(RC_LEAF, OptoRuntime::updateBytesAdler32_Type(),
5671                                  stubAddr, stubName, TypePtr::BOTTOM,
5672                                  crc, src_start, length);
5673 
5674   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
5675   set_result(result);
5676   return true;
5677 }
5678 
5679 //----------------------------inline_reference_get----------------------------
5680 // public T java.lang.ref.Reference.get();
5681 bool LibraryCallKit::inline_reference_get() {
5682   const int referent_offset = java_lang_ref_Reference::referent_offset;
5683   guarantee(referent_offset &gt; 0, &quot;should have already been set&quot;);
5684 
5685   // Get the argument:
5686   Node* reference_obj = null_check_receiver();
5687   if (stopped()) return true;
5688 
5689   const TypeInstPtr* tinst = _gvn.type(reference_obj)-&gt;isa_instptr();
5690   assert(tinst != NULL, &quot;obj is null&quot;);
5691   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5692   ciInstanceKlass* referenceKlass = tinst-&gt;klass()-&gt;as_instance_klass();
5693   ciField* field = referenceKlass-&gt;get_field_by_name(ciSymbol::make(&quot;referent&quot;),
5694                                                      ciSymbol::make(&quot;Ljava/lang/Object;&quot;),
5695                                                      false);
5696   assert (field != NULL, &quot;undefined field&quot;);
5697 
5698   Node* adr = basic_plus_adr(reference_obj, reference_obj, referent_offset);
5699   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5700 
5701   ciInstanceKlass* klass = env()-&gt;Object_klass();
5702   const TypeOopPtr* object_type = TypeOopPtr::make_from_klass(klass);
5703 
5704   DecoratorSet decorators = IN_HEAP | ON_WEAK_OOP_REF;
5705   Node* result = access_load_at(reference_obj, adr, adr_type, object_type, T_OBJECT, decorators);
5706   // Add memory barrier to prevent commoning reads from this field
5707   // across safepoint since GC can change its value.
5708   insert_mem_bar(Op_MemBarCPUOrder);
5709 
5710   set_result(result);
5711   return true;
5712 }
5713 
5714 
5715 Node * LibraryCallKit::load_field_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5716                                               bool is_exact=true, bool is_static=false,
5717                                               ciInstanceKlass * fromKls=NULL) {
5718   if (fromKls == NULL) {
5719     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5720     assert(tinst != NULL, &quot;obj is null&quot;);
5721     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5722     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5723     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5724   } else {
5725     assert(is_static, &quot;only for static field access&quot;);
5726   }
5727   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5728                                               ciSymbol::make(fieldTypeString),
5729                                               is_static);
5730 
5731   assert (field != NULL, &quot;undefined field&quot;);
5732   if (field == NULL) return (Node *) NULL;
5733 
5734   if (is_static) {
5735     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5736     fromObj = makecon(tip);
5737   }
5738 
5739   // Next code  copied from Parse::do_get_xxx():
5740 
5741   // Compute address and memory type.
5742   int offset  = field-&gt;offset_in_bytes();
5743   bool is_vol = field-&gt;is_volatile();
5744   ciType* field_klass = field-&gt;type();
5745   assert(field_klass-&gt;is_loaded(), &quot;should be loaded&quot;);
5746   const TypePtr* adr_type = C-&gt;alias_type(field)-&gt;adr_type();
5747   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5748   BasicType bt = field-&gt;layout_type();
5749 
5750   // Build the resultant type of the load
5751   const Type *type;
5752   if (bt == T_OBJECT) {
5753     type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
5754   } else {
5755     type = Type::get_const_basic_type(bt);
5756   }
5757 
5758   DecoratorSet decorators = IN_HEAP;
5759 
5760   if (is_vol) {
5761     decorators |= MO_SEQ_CST;
5762   }
5763 
5764   return access_load_at(fromObj, adr, adr_type, type, bt, decorators);
5765 }
5766 
5767 Node * LibraryCallKit::field_address_from_object(Node * fromObj, const char * fieldName, const char * fieldTypeString,
5768                                                  bool is_exact = true, bool is_static = false,
5769                                                  ciInstanceKlass * fromKls = NULL) {
5770   if (fromKls == NULL) {
5771     const TypeInstPtr* tinst = _gvn.type(fromObj)-&gt;isa_instptr();
5772     assert(tinst != NULL, &quot;obj is null&quot;);
5773     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;obj is not loaded&quot;);
5774     assert(!is_exact || tinst-&gt;klass_is_exact(), &quot;klass not exact&quot;);
5775     fromKls = tinst-&gt;klass()-&gt;as_instance_klass();
5776   }
5777   else {
5778     assert(is_static, &quot;only for static field access&quot;);
5779   }
5780   ciField* field = fromKls-&gt;get_field_by_name(ciSymbol::make(fieldName),
5781     ciSymbol::make(fieldTypeString),
5782     is_static);
5783 
5784   assert(field != NULL, &quot;undefined field&quot;);
5785   assert(!field-&gt;is_volatile(), &quot;not defined for volatile fields&quot;);
5786 
5787   if (is_static) {
5788     const TypeInstPtr* tip = TypeInstPtr::make(fromKls-&gt;java_mirror());
5789     fromObj = makecon(tip);
5790   }
5791 
5792   // Next code  copied from Parse::do_get_xxx():
5793 
5794   // Compute address and memory type.
5795   int offset = field-&gt;offset_in_bytes();
5796   Node *adr = basic_plus_adr(fromObj, fromObj, offset);
5797 
5798   return adr;
5799 }
5800 
5801 //------------------------------inline_aescrypt_Block-----------------------
5802 bool LibraryCallKit::inline_aescrypt_Block(vmIntrinsics::ID id) {
5803   address stubAddr = NULL;
5804   const char *stubName;
5805   assert(UseAES, &quot;need AES instruction support&quot;);
5806 
5807   switch(id) {
5808   case vmIntrinsics::_aescrypt_encryptBlock:
5809     stubAddr = StubRoutines::aescrypt_encryptBlock();
5810     stubName = &quot;aescrypt_encryptBlock&quot;;
5811     break;
5812   case vmIntrinsics::_aescrypt_decryptBlock:
5813     stubAddr = StubRoutines::aescrypt_decryptBlock();
5814     stubName = &quot;aescrypt_decryptBlock&quot;;
5815     break;
5816   default:
5817     break;
5818   }
5819   if (stubAddr == NULL) return false;
5820 
5821   Node* aescrypt_object = argument(0);
5822   Node* src             = argument(1);
5823   Node* src_offset      = argument(2);
5824   Node* dest            = argument(3);
5825   Node* dest_offset     = argument(4);
5826 
5827   src = must_be_not_null(src, true);
5828   dest = must_be_not_null(dest, true);
5829 
5830   // (1) src and dest are arrays.
5831   const Type* src_type = src-&gt;Value(&amp;_gvn);
5832   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5833   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5834   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5835   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5836 
5837   // for the quick and dirty code we will skip all the checks.
5838   // we are just trying to get the call to be generated.
5839   Node* src_start  = src;
5840   Node* dest_start = dest;
5841   if (src_offset != NULL || dest_offset != NULL) {
5842     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5843     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5844     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5845   }
5846 
5847   // now need to get the start of its expanded key array
5848   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5849   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5850   if (k_start == NULL) return false;
5851 
5852   if (Matcher::pass_original_key_for_aes()) {
5853     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5854     // compatibility issues between Java key expansion and SPARC crypto instructions
5855     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5856     if (original_k_start == NULL) return false;
5857 
5858     // Call the stub.
5859     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5860                       stubAddr, stubName, TypePtr::BOTTOM,
5861                       src_start, dest_start, k_start, original_k_start);
5862   } else {
5863     // Call the stub.
5864     make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),
5865                       stubAddr, stubName, TypePtr::BOTTOM,
5866                       src_start, dest_start, k_start);
5867   }
5868 
5869   return true;
5870 }
5871 
5872 //------------------------------inline_cipherBlockChaining_AESCrypt-----------------------
5873 bool LibraryCallKit::inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id) {
5874   address stubAddr = NULL;
5875   const char *stubName = NULL;
5876 
5877   assert(UseAES, &quot;need AES instruction support&quot;);
5878 
5879   switch(id) {
5880   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
5881     stubAddr = StubRoutines::cipherBlockChaining_encryptAESCrypt();
5882     stubName = &quot;cipherBlockChaining_encryptAESCrypt&quot;;
5883     break;
5884   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
5885     stubAddr = StubRoutines::cipherBlockChaining_decryptAESCrypt();
5886     stubName = &quot;cipherBlockChaining_decryptAESCrypt&quot;;
5887     break;
5888   default:
5889     break;
5890   }
5891   if (stubAddr == NULL) return false;
5892 
5893   Node* cipherBlockChaining_object = argument(0);
5894   Node* src                        = argument(1);
5895   Node* src_offset                 = argument(2);
5896   Node* len                        = argument(3);
5897   Node* dest                       = argument(4);
5898   Node* dest_offset                = argument(5);
5899 
5900   src = must_be_not_null(src, false);
5901   dest = must_be_not_null(dest, false);
5902 
5903   // (1) src and dest are arrays.
5904   const Type* src_type = src-&gt;Value(&amp;_gvn);
5905   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
5906   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
5907   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
5908   assert (top_src  != NULL &amp;&amp; top_src-&gt;klass()  != NULL
5909           &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
5910 
5911   // checks are the responsibility of the caller
5912   Node* src_start  = src;
5913   Node* dest_start = dest;
5914   if (src_offset != NULL || dest_offset != NULL) {
5915     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
5916     src_start  = array_element_address(src,  src_offset,  T_BYTE);
5917     dest_start = array_element_address(dest, dest_offset, T_BYTE);
5918   }
5919 
5920   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
5921   // (because of the predicated logic executed earlier).
5922   // so we cast it here safely.
5923   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
5924 
5925   Node* embeddedCipherObj = load_field_from_object(cipherBlockChaining_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
5926   if (embeddedCipherObj == NULL) return false;
5927 
5928   // cast it to what we know it will be at runtime
5929   const TypeInstPtr* tinst = _gvn.type(cipherBlockChaining_object)-&gt;isa_instptr();
5930   assert(tinst != NULL, &quot;CBC obj is null&quot;);
5931   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBC obj is not loaded&quot;);
5932   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
5933   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
5934 
5935   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
5936   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
5937   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
5938   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
5939   aescrypt_object = _gvn.transform(aescrypt_object);
5940 
5941   // we need to get the start of the aescrypt_object&#39;s expanded key array
5942   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
5943   if (k_start == NULL) return false;
5944 
5945   // similarly, get the start address of the r vector
5946   Node* objRvec = load_field_from_object(cipherBlockChaining_object, &quot;r&quot;, &quot;[B&quot;, /*is_exact*/ false);
5947   if (objRvec == NULL) return false;
5948   Node* r_start = array_element_address(objRvec, intcon(0), T_BYTE);
5949 
5950   Node* cbcCrypt;
5951   if (Matcher::pass_original_key_for_aes()) {
5952     // on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to
5953     // compatibility issues between Java key expansion and SPARC crypto instructions
5954     Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);
5955     if (original_k_start == NULL) return false;
5956 
5957     // Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start
5958     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5959                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5960                                  stubAddr, stubName, TypePtr::BOTTOM,
5961                                  src_start, dest_start, k_start, r_start, len, original_k_start);
5962   } else {
5963     // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
5964     cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
5965                                  OptoRuntime::cipherBlockChaining_aescrypt_Type(),
5966                                  stubAddr, stubName, TypePtr::BOTTOM,
5967                                  src_start, dest_start, k_start, r_start, len);
5968   }
5969 
5970   // return cipher length (int)
5971   Node* retvalue = _gvn.transform(new ProjNode(cbcCrypt, TypeFunc::Parms));
5972   set_result(retvalue);
5973   return true;
5974 }
5975 
5976 //------------------------------inline_electronicCodeBook_AESCrypt-----------------------
5977 bool LibraryCallKit::inline_electronicCodeBook_AESCrypt(vmIntrinsics::ID id) {
5978   address stubAddr = NULL;
5979   const char *stubName = NULL;
5980 
5981   assert(UseAES, &quot;need AES instruction support&quot;);
5982 
5983   switch (id) {
5984   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
5985     stubAddr = StubRoutines::electronicCodeBook_encryptAESCrypt();
5986     stubName = &quot;electronicCodeBook_encryptAESCrypt&quot;;
5987     break;
5988   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
5989     stubAddr = StubRoutines::electronicCodeBook_decryptAESCrypt();
5990     stubName = &quot;electronicCodeBook_decryptAESCrypt&quot;;
5991     break;
5992   default:
5993     break;
5994   }
5995 
5996   if (stubAddr == NULL) return false;
5997 
5998   Node* electronicCodeBook_object = argument(0);
5999   Node* src                       = argument(1);
6000   Node* src_offset                = argument(2);
6001   Node* len                       = argument(3);
6002   Node* dest                      = argument(4);
6003   Node* dest_offset               = argument(5);
6004 
6005   // (1) src and dest are arrays.
6006   const Type* src_type = src-&gt;Value(&amp;_gvn);
6007   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6008   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6009   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6010   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL
6011          &amp;&amp;  top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6012 
6013   // checks are the responsibility of the caller
6014   Node* src_start = src;
6015   Node* dest_start = dest;
6016   if (src_offset != NULL || dest_offset != NULL) {
6017     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6018     src_start = array_element_address(src, src_offset, T_BYTE);
6019     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6020   }
6021 
6022   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6023   // (because of the predicated logic executed earlier).
6024   // so we cast it here safely.
6025   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6026 
6027   Node* embeddedCipherObj = load_field_from_object(electronicCodeBook_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6028   if (embeddedCipherObj == NULL) return false;
6029 
6030   // cast it to what we know it will be at runtime
6031   const TypeInstPtr* tinst = _gvn.type(electronicCodeBook_object)-&gt;isa_instptr();
6032   assert(tinst != NULL, &quot;ECB obj is null&quot;);
6033   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECB obj is not loaded&quot;);
6034   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6035   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6036 
6037   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6038   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6039   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6040   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6041   aescrypt_object = _gvn.transform(aescrypt_object);
6042 
6043   // we need to get the start of the aescrypt_object&#39;s expanded key array
6044   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6045   if (k_start == NULL) return false;
6046 
6047   Node* ecbCrypt;
6048   if (Matcher::pass_original_key_for_aes()) {
6049     // no SPARC version for AES/ECB intrinsics now.
6050     return false;
6051   }
6052   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6053   ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,
6054                                OptoRuntime::electronicCodeBook_aescrypt_Type(),
6055                                stubAddr, stubName, TypePtr::BOTTOM,
6056                                src_start, dest_start, k_start, len);
6057 
6058   // return cipher length (int)
6059   Node* retvalue = _gvn.transform(new ProjNode(ecbCrypt, TypeFunc::Parms));
6060   set_result(retvalue);
6061   return true;
6062 }
6063 
6064 //------------------------------inline_counterMode_AESCrypt-----------------------
6065 bool LibraryCallKit::inline_counterMode_AESCrypt(vmIntrinsics::ID id) {
6066   assert(UseAES, &quot;need AES instruction support&quot;);
6067   if (!UseAESCTRIntrinsics) return false;
6068 
6069   address stubAddr = NULL;
6070   const char *stubName = NULL;
6071   if (id == vmIntrinsics::_counterMode_AESCrypt) {
6072     stubAddr = StubRoutines::counterMode_AESCrypt();
6073     stubName = &quot;counterMode_AESCrypt&quot;;
6074   }
6075   if (stubAddr == NULL) return false;
6076 
6077   Node* counterMode_object = argument(0);
6078   Node* src = argument(1);
6079   Node* src_offset = argument(2);
6080   Node* len = argument(3);
6081   Node* dest = argument(4);
6082   Node* dest_offset = argument(5);
6083 
6084   // (1) src and dest are arrays.
6085   const Type* src_type = src-&gt;Value(&amp;_gvn);
6086   const Type* dest_type = dest-&gt;Value(&amp;_gvn);
6087   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6088   const TypeAryPtr* top_dest = dest_type-&gt;isa_aryptr();
6089   assert(top_src != NULL &amp;&amp; top_src-&gt;klass() != NULL &amp;&amp;
6090          top_dest != NULL &amp;&amp; top_dest-&gt;klass() != NULL, &quot;args are strange&quot;);
6091 
6092   // checks are the responsibility of the caller
6093   Node* src_start = src;
6094   Node* dest_start = dest;
6095   if (src_offset != NULL || dest_offset != NULL) {
6096     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;&quot;);
6097     src_start = array_element_address(src, src_offset, T_BYTE);
6098     dest_start = array_element_address(dest, dest_offset, T_BYTE);
6099   }
6100 
6101   // if we are in this set of code, we &quot;know&quot; the embeddedCipher is an AESCrypt object
6102   // (because of the predicated logic executed earlier).
6103   // so we cast it here safely.
6104   // this requires a newer class file that has this array as littleEndian ints, otherwise we revert to java
6105   Node* embeddedCipherObj = load_field_from_object(counterMode_object, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6106   if (embeddedCipherObj == NULL) return false;
6107   // cast it to what we know it will be at runtime
6108   const TypeInstPtr* tinst = _gvn.type(counterMode_object)-&gt;isa_instptr();
6109   assert(tinst != NULL, &quot;CTR obj is null&quot;);
6110   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTR obj is not loaded&quot;);
6111   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6112   assert(klass_AESCrypt-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6113   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6114   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_AESCrypt);
6115   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6116   Node* aescrypt_object = new CheckCastPPNode(control(), embeddedCipherObj, xtype);
6117   aescrypt_object = _gvn.transform(aescrypt_object);
6118   // we need to get the start of the aescrypt_object&#39;s expanded key array
6119   Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);
6120   if (k_start == NULL) return false;
6121   // similarly, get the start address of the r vector
6122   Node* obj_counter = load_field_from_object(counterMode_object, &quot;counter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6123   if (obj_counter == NULL) return false;
6124   Node* cnt_start = array_element_address(obj_counter, intcon(0), T_BYTE);
6125 
6126   Node* saved_encCounter = load_field_from_object(counterMode_object, &quot;encryptedCounter&quot;, &quot;[B&quot;, /*is_exact*/ false);
6127   if (saved_encCounter == NULL) return false;
6128   Node* saved_encCounter_start = array_element_address(saved_encCounter, intcon(0), T_BYTE);
6129   Node* used = field_address_from_object(counterMode_object, &quot;used&quot;, &quot;I&quot;, /*is_exact*/ false);
6130 
6131   Node* ctrCrypt;
6132   if (Matcher::pass_original_key_for_aes()) {
6133     // no SPARC version for AES/CTR intrinsics now.
6134     return false;
6135   }
6136   // Call the stub, passing src_start, dest_start, k_start, r_start and src_len
6137   ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,
6138                                OptoRuntime::counterMode_aescrypt_Type(),
6139                                stubAddr, stubName, TypePtr::BOTTOM,
6140                                src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);
6141 
6142   // return cipher length (int)
6143   Node* retvalue = _gvn.transform(new ProjNode(ctrCrypt, TypeFunc::Parms));
6144   set_result(retvalue);
6145   return true;
6146 }
6147 
6148 //------------------------------get_key_start_from_aescrypt_object-----------------------
6149 Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {
6150 #if defined(PPC64) || defined(S390)
6151   // MixColumns for decryption can be reduced by preprocessing MixColumns with round keys.
6152   // Intel&#39;s extention is based on this optimization and AESCrypt generates round keys by preprocessing MixColumns.
6153   // However, ppc64 vncipher processes MixColumns and requires the same round keys with encryption.
6154   // The ppc64 stubs of encryption and decryption use the same round keys (sessionK[0]).
6155   Node* objSessionK = load_field_from_object(aescrypt_object, &quot;sessionK&quot;, &quot;[[I&quot;, /*is_exact*/ false);
6156   assert (objSessionK != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6157   if (objSessionK == NULL) {
6158     return (Node *) NULL;
6159   }
6160   Node* objAESCryptKey = load_array_element(control(), objSessionK, intcon(0), TypeAryPtr::OOPS);
6161 #else
6162   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;K&quot;, &quot;[I&quot;, /*is_exact*/ false);
6163 #endif // PPC64
6164   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6165   if (objAESCryptKey == NULL) return (Node *) NULL;
6166 
6167   // now have the array, need to get the start address of the K array
6168   Node* k_start = array_element_address(objAESCryptKey, intcon(0), T_INT);
6169   return k_start;
6170 }
6171 
6172 //------------------------------get_original_key_start_from_aescrypt_object-----------------------
6173 Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {
6174   Node* objAESCryptKey = load_field_from_object(aescrypt_object, &quot;lastKey&quot;, &quot;[B&quot;, /*is_exact*/ false);
6175   assert (objAESCryptKey != NULL, &quot;wrong version of com.sun.crypto.provider.AESCrypt&quot;);
6176   if (objAESCryptKey == NULL) return (Node *) NULL;
6177 
6178   // now have the array, need to get the start address of the lastKey array
6179   Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);
6180   return original_k_start;
6181 }
6182 
6183 //----------------------------inline_cipherBlockChaining_AESCrypt_predicate----------------------------
6184 // Return node representing slow path of predicate check.
6185 // the pseudo code we want to emulate with this predicate is:
6186 // for encryption:
6187 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6188 // for decryption:
6189 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6190 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6191 //
6192 Node* LibraryCallKit::inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting) {
6193   // The receiver was checked for NULL already.
6194   Node* objCBC = argument(0);
6195 
6196   Node* src = argument(1);
6197   Node* dest = argument(4);
6198 
6199   // Load embeddedCipher field of CipherBlockChaining object.
6200   Node* embeddedCipherObj = load_field_from_object(objCBC, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6201 
6202   // get AESCrypt klass for instanceOf check
6203   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6204   // will have same classloader as CipherBlockChaining object
6205   const TypeInstPtr* tinst = _gvn.type(objCBC)-&gt;isa_instptr();
6206   assert(tinst != NULL, &quot;CBCobj is null&quot;);
6207   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CBCobj is not loaded&quot;);
6208 
6209   // we want to do an instanceof comparison against the AESCrypt class
6210   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6211   if (!klass_AESCrypt-&gt;is_loaded()) {
6212     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6213     Node* ctrl = control();
6214     set_control(top()); // no regular fast path
6215     return ctrl;
6216   }
6217 
6218   src = must_be_not_null(src, true);
6219   dest = must_be_not_null(dest, true);
6220 
6221   // Resolve oops to stable for CmpP below.
6222   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6223 
6224   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6225   Node* cmp_instof  = _gvn.transform(new CmpINode(instof, intcon(1)));
6226   Node* bool_instof  = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6227 
6228   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6229 
6230   // for encryption, we are done
6231   if (!decrypting)
6232     return instof_false;  // even if it is NULL
6233 
6234   // for decryption, we need to add a further check to avoid
6235   // taking the intrinsic path when cipher and plain are the same
6236   // see the original java code for why.
6237   RegionNode* region = new RegionNode(3);
6238   region-&gt;init_req(1, instof_false);
6239 
6240   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6241   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6242   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6243   region-&gt;init_req(2, src_dest_conjoint);
6244 
6245   record_for_igvn(region);
6246   return _gvn.transform(region);
6247 }
6248 
6249 //----------------------------inline_electronicCodeBook_AESCrypt_predicate----------------------------
6250 // Return node representing slow path of predicate check.
6251 // the pseudo code we want to emulate with this predicate is:
6252 // for encryption:
6253 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6254 // for decryption:
6255 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6256 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6257 //
6258 Node* LibraryCallKit::inline_electronicCodeBook_AESCrypt_predicate(bool decrypting) {
6259   // The receiver was checked for NULL already.
6260   Node* objECB = argument(0);
6261 
6262   // Load embeddedCipher field of ElectronicCodeBook object.
6263   Node* embeddedCipherObj = load_field_from_object(objECB, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6264 
6265   // get AESCrypt klass for instanceOf check
6266   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6267   // will have same classloader as ElectronicCodeBook object
6268   const TypeInstPtr* tinst = _gvn.type(objECB)-&gt;isa_instptr();
6269   assert(tinst != NULL, &quot;ECBobj is null&quot;);
6270   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;ECBobj is not loaded&quot;);
6271 
6272   // we want to do an instanceof comparison against the AESCrypt class
6273   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6274   if (!klass_AESCrypt-&gt;is_loaded()) {
6275     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6276     Node* ctrl = control();
6277     set_control(top()); // no regular fast path
6278     return ctrl;
6279   }
6280   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6281 
6282   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6283   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6284   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6285 
6286   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6287 
6288   // for encryption, we are done
6289   if (!decrypting)
6290     return instof_false;  // even if it is NULL
6291 
6292   // for decryption, we need to add a further check to avoid
6293   // taking the intrinsic path when cipher and plain are the same
6294   // see the original java code for why.
6295   RegionNode* region = new RegionNode(3);
6296   region-&gt;init_req(1, instof_false);
6297   Node* src = argument(1);
6298   Node* dest = argument(4);
6299   Node* cmp_src_dest = _gvn.transform(new CmpPNode(src, dest));
6300   Node* bool_src_dest = _gvn.transform(new BoolNode(cmp_src_dest, BoolTest::eq));
6301   Node* src_dest_conjoint = generate_guard(bool_src_dest, NULL, PROB_MIN);
6302   region-&gt;init_req(2, src_dest_conjoint);
6303 
6304   record_for_igvn(region);
6305   return _gvn.transform(region);
6306 }
6307 
6308 //----------------------------inline_counterMode_AESCrypt_predicate----------------------------
6309 // Return node representing slow path of predicate check.
6310 // the pseudo code we want to emulate with this predicate is:
6311 // for encryption:
6312 //    if (embeddedCipherObj instanceof AESCrypt) do_intrinsic, else do_javapath
6313 // for decryption:
6314 //    if ((embeddedCipherObj instanceof AESCrypt) &amp;&amp; (cipher!=plain)) do_intrinsic, else do_javapath
6315 //    note cipher==plain is more conservative than the original java code but that&#39;s OK
6316 //
6317 
6318 Node* LibraryCallKit::inline_counterMode_AESCrypt_predicate() {
6319   // The receiver was checked for NULL already.
6320   Node* objCTR = argument(0);
6321 
6322   // Load embeddedCipher field of CipherBlockChaining object.
6323   Node* embeddedCipherObj = load_field_from_object(objCTR, &quot;embeddedCipher&quot;, &quot;Lcom/sun/crypto/provider/SymmetricCipher;&quot;, /*is_exact*/ false);
6324 
6325   // get AESCrypt klass for instanceOf check
6326   // AESCrypt might not be loaded yet if some other SymmetricCipher got us to this compile point
6327   // will have same classloader as CipherBlockChaining object
6328   const TypeInstPtr* tinst = _gvn.type(objCTR)-&gt;isa_instptr();
6329   assert(tinst != NULL, &quot;CTRobj is null&quot;);
6330   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;CTRobj is not loaded&quot;);
6331 
6332   // we want to do an instanceof comparison against the AESCrypt class
6333   ciKlass* klass_AESCrypt = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(&quot;com/sun/crypto/provider/AESCrypt&quot;));
6334   if (!klass_AESCrypt-&gt;is_loaded()) {
6335     // if AESCrypt is not even loaded, we never take the intrinsic fast path
6336     Node* ctrl = control();
6337     set_control(top()); // no regular fast path
6338     return ctrl;
6339   }
6340 
6341   ciInstanceKlass* instklass_AESCrypt = klass_AESCrypt-&gt;as_instance_klass();
6342   Node* instof = gen_instanceof(embeddedCipherObj, makecon(TypeKlassPtr::make(instklass_AESCrypt)));
6343   Node* cmp_instof = _gvn.transform(new CmpINode(instof, intcon(1)));
6344   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6345   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6346 
6347   return instof_false; // even if it is NULL
6348 }
6349 
6350 //------------------------------inline_ghash_processBlocks
6351 bool LibraryCallKit::inline_ghash_processBlocks() {
6352   address stubAddr;
6353   const char *stubName;
6354   assert(UseGHASHIntrinsics, &quot;need GHASH intrinsics support&quot;);
6355 
6356   stubAddr = StubRoutines::ghash_processBlocks();
6357   stubName = &quot;ghash_processBlocks&quot;;
6358 
6359   Node* data           = argument(0);
6360   Node* offset         = argument(1);
6361   Node* len            = argument(2);
6362   Node* state          = argument(3);
6363   Node* subkeyH        = argument(4);
6364 
6365   state = must_be_not_null(state, true);
6366   subkeyH = must_be_not_null(subkeyH, true);
6367   data = must_be_not_null(data, true);
6368 
6369   Node* state_start  = array_element_address(state, intcon(0), T_LONG);
6370   assert(state_start, &quot;state is NULL&quot;);
6371   Node* subkeyH_start  = array_element_address(subkeyH, intcon(0), T_LONG);
6372   assert(subkeyH_start, &quot;subkeyH is NULL&quot;);
6373   Node* data_start  = array_element_address(data, offset, T_BYTE);
6374   assert(data_start, &quot;data is NULL&quot;);
6375 
6376   Node* ghash = make_runtime_call(RC_LEAF|RC_NO_FP,
6377                                   OptoRuntime::ghash_processBlocks_Type(),
6378                                   stubAddr, stubName, TypePtr::BOTTOM,
6379                                   state_start, subkeyH_start, data_start, len);
6380   return true;
6381 }
6382 
6383 bool LibraryCallKit::inline_base64_encodeBlock() {
6384   address stubAddr;
6385   const char *stubName;
6386   assert(UseBASE64Intrinsics, &quot;need Base64 intrinsics support&quot;);
6387   assert(callee()-&gt;signature()-&gt;size() == 6, &quot;base64_encodeBlock has 6 parameters&quot;);
6388   stubAddr = StubRoutines::base64_encodeBlock();
6389   stubName = &quot;encodeBlock&quot;;
6390 
6391   if (!stubAddr) return false;
6392   Node* base64obj = argument(0);
6393   Node* src = argument(1);
6394   Node* offset = argument(2);
6395   Node* len = argument(3);
6396   Node* dest = argument(4);
6397   Node* dp = argument(5);
6398   Node* isURL = argument(6);
6399 
6400   src = must_be_not_null(src, true);
6401   dest = must_be_not_null(dest, true);
6402 
6403   Node* src_start = array_element_address(src, intcon(0), T_BYTE);
6404   assert(src_start, &quot;source array is NULL&quot;);
6405   Node* dest_start = array_element_address(dest, intcon(0), T_BYTE);
6406   assert(dest_start, &quot;destination array is NULL&quot;);
6407 
6408   Node* base64 = make_runtime_call(RC_LEAF,
6409                                    OptoRuntime::base64_encodeBlock_Type(),
6410                                    stubAddr, stubName, TypePtr::BOTTOM,
6411                                    src_start, offset, len, dest_start, dp, isURL);
6412   return true;
6413 }
6414 
6415 //------------------------------inline_sha_implCompress-----------------------
6416 //
6417 // Calculate SHA (i.e., SHA-1) for single-block byte[] array.
6418 // void com.sun.security.provider.SHA.implCompress(byte[] buf, int ofs)
6419 //
6420 // Calculate SHA2 (i.e., SHA-244 or SHA-256) for single-block byte[] array.
6421 // void com.sun.security.provider.SHA2.implCompress(byte[] buf, int ofs)
6422 //
6423 // Calculate SHA5 (i.e., SHA-384 or SHA-512) for single-block byte[] array.
6424 // void com.sun.security.provider.SHA5.implCompress(byte[] buf, int ofs)
6425 //
6426 bool LibraryCallKit::inline_sha_implCompress(vmIntrinsics::ID id) {
6427   assert(callee()-&gt;signature()-&gt;size() == 2, &quot;sha_implCompress has 2 parameters&quot;);
6428 
6429   Node* sha_obj = argument(0);
6430   Node* src     = argument(1); // type oop
6431   Node* ofs     = argument(2); // type int
6432 
6433   const Type* src_type = src-&gt;Value(&amp;_gvn);
6434   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6435   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6436     // failed array check
6437     return false;
6438   }
6439   // Figure out the size and type of the elements we will be copying.
6440   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6441   if (src_elem != T_BYTE) {
6442     return false;
6443   }
6444   // &#39;src_start&#39; points to src array + offset
6445   src = must_be_not_null(src, true);
6446   Node* src_start = array_element_address(src, ofs, src_elem);
6447   Node* state = NULL;
6448   address stubAddr;
6449   const char *stubName;
6450 
6451   switch(id) {
6452   case vmIntrinsics::_sha_implCompress:
6453     assert(UseSHA1Intrinsics, &quot;need SHA1 instruction support&quot;);
6454     state = get_state_from_sha_object(sha_obj);
6455     stubAddr = StubRoutines::sha1_implCompress();
6456     stubName = &quot;sha1_implCompress&quot;;
6457     break;
6458   case vmIntrinsics::_sha2_implCompress:
6459     assert(UseSHA256Intrinsics, &quot;need SHA256 instruction support&quot;);
6460     state = get_state_from_sha_object(sha_obj);
6461     stubAddr = StubRoutines::sha256_implCompress();
6462     stubName = &quot;sha256_implCompress&quot;;
6463     break;
6464   case vmIntrinsics::_sha5_implCompress:
6465     assert(UseSHA512Intrinsics, &quot;need SHA512 instruction support&quot;);
6466     state = get_state_from_sha5_object(sha_obj);
6467     stubAddr = StubRoutines::sha512_implCompress();
6468     stubName = &quot;sha512_implCompress&quot;;
6469     break;
6470   default:
6471     fatal_unexpected_iid(id);
6472     return false;
6473   }
6474   if (state == NULL) return false;
6475 
6476   assert(stubAddr != NULL, &quot;Stub is generated&quot;);
6477   if (stubAddr == NULL) return false;
6478 
6479   // Call the stub.
6480   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::sha_implCompress_Type(),
6481                                  stubAddr, stubName, TypePtr::BOTTOM,
6482                                  src_start, state);
6483 
6484   return true;
6485 }
6486 
6487 //------------------------------inline_digestBase_implCompressMB-----------------------
6488 //
6489 // Calculate SHA/SHA2/SHA5 for multi-block byte[] array.
6490 // int com.sun.security.provider.DigestBase.implCompressMultiBlock(byte[] b, int ofs, int limit)
6491 //
6492 bool LibraryCallKit::inline_digestBase_implCompressMB(int predicate) {
6493   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6494          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6495   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6496   assert(callee()-&gt;signature()-&gt;size() == 3, &quot;digestBase_implCompressMB has 3 parameters&quot;);
6497 
6498   Node* digestBase_obj = argument(0); // The receiver was checked for NULL already.
6499   Node* src            = argument(1); // byte[] array
6500   Node* ofs            = argument(2); // type int
6501   Node* limit          = argument(3); // type int
6502 
6503   const Type* src_type = src-&gt;Value(&amp;_gvn);
6504   const TypeAryPtr* top_src = src_type-&gt;isa_aryptr();
6505   if (top_src  == NULL || top_src-&gt;klass()  == NULL) {
6506     // failed array check
6507     return false;
6508   }
6509   // Figure out the size and type of the elements we will be copying.
6510   BasicType src_elem = src_type-&gt;isa_aryptr()-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
6511   if (src_elem != T_BYTE) {
6512     return false;
6513   }
6514   // &#39;src_start&#39; points to src array + offset
6515   src = must_be_not_null(src, false);
6516   Node* src_start = array_element_address(src, ofs, src_elem);
6517 
6518   const char* klass_SHA_name = NULL;
6519   const char* stub_name = NULL;
6520   address     stub_addr = NULL;
6521   bool        long_state = false;
6522 
6523   switch (predicate) {
6524   case 0:
6525     if (UseSHA1Intrinsics) {
6526       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6527       stub_name = &quot;sha1_implCompressMB&quot;;
6528       stub_addr = StubRoutines::sha1_implCompressMB();
6529     }
6530     break;
6531   case 1:
6532     if (UseSHA256Intrinsics) {
6533       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6534       stub_name = &quot;sha256_implCompressMB&quot;;
6535       stub_addr = StubRoutines::sha256_implCompressMB();
6536     }
6537     break;
6538   case 2:
6539     if (UseSHA512Intrinsics) {
6540       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6541       stub_name = &quot;sha512_implCompressMB&quot;;
6542       stub_addr = StubRoutines::sha512_implCompressMB();
6543       long_state = true;
6544     }
6545     break;
6546   default:
6547     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6548   }
6549   if (klass_SHA_name != NULL) {
6550     assert(stub_addr != NULL, &quot;Stub is generated&quot;);
6551     if (stub_addr == NULL) return false;
6552 
6553     // get DigestBase klass to lookup for SHA klass
6554     const TypeInstPtr* tinst = _gvn.type(digestBase_obj)-&gt;isa_instptr();
6555     assert(tinst != NULL, &quot;digestBase_obj is not instance???&quot;);
6556     assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6557 
6558     ciKlass* klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6559     assert(klass_SHA-&gt;is_loaded(), &quot;predicate checks that this class is loaded&quot;);
6560     ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6561     return inline_sha_implCompressMB(digestBase_obj, instklass_SHA, long_state, stub_addr, stub_name, src_start, ofs, limit);
6562   }
6563   return false;
6564 }
6565 //------------------------------inline_sha_implCompressMB-----------------------
6566 bool LibraryCallKit::inline_sha_implCompressMB(Node* digestBase_obj, ciInstanceKlass* instklass_SHA,
6567                                                bool long_state, address stubAddr, const char *stubName,
6568                                                Node* src_start, Node* ofs, Node* limit) {
6569   const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_SHA);
6570   const TypeOopPtr* xtype = aklass-&gt;as_instance_type();
6571   Node* sha_obj = new CheckCastPPNode(control(), digestBase_obj, xtype);
6572   sha_obj = _gvn.transform(sha_obj);
6573 
6574   Node* state;
6575   if (long_state) {
6576     state = get_state_from_sha5_object(sha_obj);
6577   } else {
6578     state = get_state_from_sha_object(sha_obj);
6579   }
6580   if (state == NULL) return false;
6581 
6582   // Call the stub.
6583   Node* call = make_runtime_call(RC_LEAF|RC_NO_FP,
6584                                  OptoRuntime::digestBase_implCompressMB_Type(),
6585                                  stubAddr, stubName, TypePtr::BOTTOM,
6586                                  src_start, state, ofs, limit);
6587   // return ofs (int)
6588   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6589   set_result(result);
6590 
6591   return true;
6592 }
6593 
6594 //------------------------------get_state_from_sha_object-----------------------
6595 Node * LibraryCallKit::get_state_from_sha_object(Node *sha_object) {
6596   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[I&quot;, /*is_exact*/ false);
6597   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA/SHA2&quot;);
6598   if (sha_state == NULL) return (Node *) NULL;
6599 
6600   // now have the array, need to get the start address of the state array
6601   Node* state = array_element_address(sha_state, intcon(0), T_INT);
6602   return state;
6603 }
6604 
6605 //------------------------------get_state_from_sha5_object-----------------------
6606 Node * LibraryCallKit::get_state_from_sha5_object(Node *sha_object) {
6607   Node* sha_state = load_field_from_object(sha_object, &quot;state&quot;, &quot;[J&quot;, /*is_exact*/ false);
6608   assert (sha_state != NULL, &quot;wrong version of sun.security.provider.SHA5&quot;);
6609   if (sha_state == NULL) return (Node *) NULL;
6610 
6611   // now have the array, need to get the start address of the state array
6612   Node* state = array_element_address(sha_state, intcon(0), T_LONG);
6613   return state;
6614 }
6615 
6616 //----------------------------inline_digestBase_implCompressMB_predicate----------------------------
6617 // Return node representing slow path of predicate check.
6618 // the pseudo code we want to emulate with this predicate is:
6619 //    if (digestBaseObj instanceof SHA/SHA2/SHA5) do_intrinsic, else do_javapath
6620 //
6621 Node* LibraryCallKit::inline_digestBase_implCompressMB_predicate(int predicate) {
6622   assert(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics,
6623          &quot;need SHA1/SHA256/SHA512 instruction support&quot;);
6624   assert((uint)predicate &lt; 3, &quot;sanity&quot;);
6625 
6626   // The receiver was checked for NULL already.
6627   Node* digestBaseObj = argument(0);
6628 
6629   // get DigestBase klass for instanceOf check
6630   const TypeInstPtr* tinst = _gvn.type(digestBaseObj)-&gt;isa_instptr();
6631   assert(tinst != NULL, &quot;digestBaseObj is null&quot;);
6632   assert(tinst-&gt;klass()-&gt;is_loaded(), &quot;DigestBase is not loaded&quot;);
6633 
6634   const char* klass_SHA_name = NULL;
6635   switch (predicate) {
6636   case 0:
6637     if (UseSHA1Intrinsics) {
6638       // we want to do an instanceof comparison against the SHA class
6639       klass_SHA_name = &quot;sun/security/provider/SHA&quot;;
6640     }
6641     break;
6642   case 1:
6643     if (UseSHA256Intrinsics) {
6644       // we want to do an instanceof comparison against the SHA2 class
6645       klass_SHA_name = &quot;sun/security/provider/SHA2&quot;;
6646     }
6647     break;
6648   case 2:
6649     if (UseSHA512Intrinsics) {
6650       // we want to do an instanceof comparison against the SHA5 class
6651       klass_SHA_name = &quot;sun/security/provider/SHA5&quot;;
6652     }
6653     break;
6654   default:
6655     fatal(&quot;unknown SHA intrinsic predicate: %d&quot;, predicate);
6656   }
6657 
6658   ciKlass* klass_SHA = NULL;
6659   if (klass_SHA_name != NULL) {
6660     klass_SHA = tinst-&gt;klass()-&gt;as_instance_klass()-&gt;find_klass(ciSymbol::make(klass_SHA_name));
6661   }
6662   if ((klass_SHA == NULL) || !klass_SHA-&gt;is_loaded()) {
6663     // if none of SHA/SHA2/SHA5 is loaded, we never take the intrinsic fast path
6664     Node* ctrl = control();
6665     set_control(top()); // no intrinsic path
6666     return ctrl;
6667   }
6668   ciInstanceKlass* instklass_SHA = klass_SHA-&gt;as_instance_klass();
6669 
6670   Node* instofSHA = gen_instanceof(digestBaseObj, makecon(TypeKlassPtr::make(instklass_SHA)));
6671   Node* cmp_instof = _gvn.transform(new CmpINode(instofSHA, intcon(1)));
6672   Node* bool_instof = _gvn.transform(new BoolNode(cmp_instof, BoolTest::ne));
6673   Node* instof_false = generate_guard(bool_instof, NULL, PROB_MIN);
6674 
6675   return instof_false;  // even if it is NULL
6676 }
6677 
6678 bool LibraryCallKit::inline_continuation(vmIntrinsics::ID id) {
6679   address call_addr = NULL;
6680   const char *name = NULL;
6681 
6682   switch (id) {
6683     case vmIntrinsics::_Continuation_getSP: call_addr = StubRoutines::cont_getSP(); name = &quot;getSP&quot;; break;
6684     case vmIntrinsics::_Continuation_getPC: call_addr = StubRoutines::cont_getPC(); name = &quot;getPC&quot;; break;
6685     default: fatal(&quot;error&quot;); return false;
6686   }
6687 
6688   const TypeFunc* tf = OptoRuntime::void_long_Type();
6689   const TypePtr* no_memory_effects = NULL;
6690   Node* call = make_runtime_call(RC_LEAF, tf, call_addr, name, no_memory_effects);
6691   Node* value = _gvn.transform(new ProjNode(call, TypeFunc::Parms+0));
6692 #ifdef ASSERT
6693   Node* value_top = _gvn.transform(new ProjNode(call, TypeFunc::Parms+1));
6694   assert(value_top == top(), &quot;second value must be top&quot;);
6695 #endif
6696   set_result(value);
6697   return true;
6698 }
6699 
6700 bool LibraryCallKit::inline_continuation_runLevel() {
6701   set_result(intcon(2));
6702   return true;
6703 }
6704 
6705 bool LibraryCallKit::inline_continuation_do_continue() {
6706   address call_addr = StubRoutines::cont_thaw();
6707   const TypeFunc* tf = OptoRuntime::void_void_Type();
6708   Node* call = make_runtime_call(RC_NO_LEAF, tf, call_addr, &quot;doContinue&quot;, TypeRawPtr::BOTTOM);
6709   assert (call-&gt;is_CallJava(), &quot;&quot;);
6710   Node* result = set_results_for_java_call((CallJavaNode*)call, false, /* deoptimize */ false);
6711   return true;
6712 }
6713 
6714 bool LibraryCallKit::inline_continuation_do_yield() {
6715   address call_addr = StubRoutines::cont_doYield();
6716   // Node* arg0 = argument(0); // type int - scopes
6717   Node* arg0 = intcon(0); // type int - from interpreter
6718   const TypeFunc* tf = OptoRuntime::continuation_doYield_Type();
6719   Node* call = make_runtime_call(RC_NO_LEAF, tf, call_addr, &quot;doYield&quot;, TypeRawPtr::BOTTOM, arg0);
6720   Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));
6721   set_result(result);
6722   return true;
6723 }
6724 
6725 bool LibraryCallKit::inline_continuation_jump() {
6726   address call_addr = StubRoutines::cont_jump();
6727   Node* sp = argument(0); // type long
6728   Node* fp = argument(2); // type long
6729   Node* pc = argument(4); // type long
6730   const TypeFunc* tf = OptoRuntime::continuation_jump_Type();
6731   Node* call = make_runtime_call(RC_LEAF, tf, call_addr, &quot;jump&quot;, TypeRawPtr::BOTTOM, sp, fp, pc);
6732   return true;
6733 }
6734 
6735 //-------------inline_fma-----------------------------------
6736 bool LibraryCallKit::inline_fma(vmIntrinsics::ID id) {
6737   Node *a = NULL;
6738   Node *b = NULL;
6739   Node *c = NULL;
6740   Node* result = NULL;
6741   switch (id) {
6742   case vmIntrinsics::_fmaD:
6743     assert(callee()-&gt;signature()-&gt;size() == 6, &quot;fma has 3 parameters of size 2 each.&quot;);
6744     // no receiver since it is static method
6745     a = round_double_node(argument(0));
6746     b = round_double_node(argument(2));
6747     c = round_double_node(argument(4));
6748     result = _gvn.transform(new FmaDNode(control(), a, b, c));
6749     break;
6750   case vmIntrinsics::_fmaF:
6751     assert(callee()-&gt;signature()-&gt;size() == 3, &quot;fma has 3 parameters of size 1 each.&quot;);
6752     a = argument(0);
6753     b = argument(1);
6754     c = argument(2);
6755     result = _gvn.transform(new FmaFNode(control(), a, b, c));
6756     break;
6757   default:
6758     fatal_unexpected_iid(id);  break;
6759   }
6760   set_result(result);
6761   return true;
6762 }
6763 
6764 bool LibraryCallKit::inline_character_compare(vmIntrinsics::ID id) {
6765   // argument(0) is receiver
6766   Node* codePoint = argument(1);
6767   Node* n = NULL;
6768 
6769   switch (id) {
6770     case vmIntrinsics::_isDigit :
6771       n = new DigitNode(control(), codePoint);
6772       break;
6773     case vmIntrinsics::_isLowerCase :
6774       n = new LowerCaseNode(control(), codePoint);
6775       break;
6776     case vmIntrinsics::_isUpperCase :
6777       n = new UpperCaseNode(control(), codePoint);
6778       break;
6779     case vmIntrinsics::_isWhitespace :
6780       n = new WhitespaceNode(control(), codePoint);
6781       break;
6782     default:
6783       fatal_unexpected_iid(id);
6784   }
6785 
6786   set_result(_gvn.transform(n));
6787   return true;
6788 }
6789 
6790 //------------------------------inline_fp_min_max------------------------------
6791 bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {
6792 /* DISABLED BECAUSE METHOD DATA ISN&#39;T COLLECTED PER CALL-SITE, SEE JDK-8015416.
6793 
6794   // The intrinsic should be used only when the API branches aren&#39;t predictable,
6795   // the last one performing the most important comparison. The following heuristic
6796   // uses the branch statistics to eventually bail out if necessary.
6797 
6798   ciMethodData *md = callee()-&gt;method_data();
6799 
6800   if ( md != NULL &amp;&amp; md-&gt;is_mature() &amp;&amp; md-&gt;invocation_count() &gt; 0 ) {
6801     ciCallProfile cp = caller()-&gt;call_profile_at_bci(bci());
6802 
6803     if ( ((double)cp.count()) / ((double)md-&gt;invocation_count()) &lt; 0.8 ) {
6804       // Bail out if the call-site didn&#39;t contribute enough to the statistics.
6805       return false;
6806     }
6807 
6808     uint taken = 0, not_taken = 0;
6809 
6810     for (ciProfileData *p = md-&gt;first_data(); md-&gt;is_valid(p); p = md-&gt;next_data(p)) {
6811       if (p-&gt;is_BranchData()) {
6812         taken = ((ciBranchData*)p)-&gt;taken();
6813         not_taken = ((ciBranchData*)p)-&gt;not_taken();
6814       }
6815     }
6816 
6817     double balance = (((double)taken) - ((double)not_taken)) / ((double)md-&gt;invocation_count());
6818     balance = balance &lt; 0 ? -balance : balance;
6819     if ( balance &gt; 0.2 ) {
6820       // Bail out if the most important branch is predictable enough.
6821       return false;
6822     }
6823   }
6824 */
6825 
6826   Node *a = NULL;
6827   Node *b = NULL;
6828   Node *n = NULL;
6829   switch (id) {
6830   case vmIntrinsics::_maxF:
6831   case vmIntrinsics::_minF:
6832     assert(callee()-&gt;signature()-&gt;size() == 2, &quot;minF/maxF has 2 parameters of size 1 each.&quot;);
6833     a = argument(0);
6834     b = argument(1);
6835     break;
6836   case vmIntrinsics::_maxD:
6837   case vmIntrinsics::_minD:
6838     assert(callee()-&gt;signature()-&gt;size() == 4, &quot;minD/maxD has 2 parameters of size 2 each.&quot;);
6839     a = round_double_node(argument(0));
6840     b = round_double_node(argument(2));
6841     break;
6842   default:
6843     fatal_unexpected_iid(id);
6844     break;
6845   }
6846   switch (id) {
6847   case vmIntrinsics::_maxF:  n = new MaxFNode(a, b);  break;
6848   case vmIntrinsics::_minF:  n = new MinFNode(a, b);  break;
6849   case vmIntrinsics::_maxD:  n = new MaxDNode(a, b);  break;
6850   case vmIntrinsics::_minD:  n = new MinDNode(a, b);  break;
6851   default:  fatal_unexpected_iid(id);  break;
6852   }
6853   set_result(_gvn.transform(n));
6854   return true;
6855 }
6856 
6857 bool LibraryCallKit::inline_profileBoolean() {
6858   Node* counts = argument(1);
6859   const TypeAryPtr* ary = NULL;
6860   ciArray* aobj = NULL;
6861   if (counts-&gt;is_Con()
6862       &amp;&amp; (ary = counts-&gt;bottom_type()-&gt;isa_aryptr()) != NULL
6863       &amp;&amp; (aobj = ary-&gt;const_oop()-&gt;as_array()) != NULL
6864       &amp;&amp; (aobj-&gt;length() == 2)) {
6865     // Profile is int[2] where [0] and [1] correspond to false and true value occurrences respectively.
6866     jint false_cnt = aobj-&gt;element_value(0).as_int();
6867     jint  true_cnt = aobj-&gt;element_value(1).as_int();
6868 
6869     if (C-&gt;log() != NULL) {
6870       C-&gt;log()-&gt;elem(&quot;observe source=&#39;profileBoolean&#39; false=&#39;%d&#39; true=&#39;%d&#39;&quot;,
6871                      false_cnt, true_cnt);
6872     }
6873 
6874     if (false_cnt + true_cnt == 0) {
6875       // According to profile, never executed.
6876       uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6877                           Deoptimization::Action_reinterpret);
6878       return true;
6879     }
6880 
6881     // result is a boolean (0 or 1) and its profile (false_cnt &amp; true_cnt)
6882     // is a number of each value occurrences.
6883     Node* result = argument(0);
6884     if (false_cnt == 0 || true_cnt == 0) {
6885       // According to profile, one value has been never seen.
6886       int expected_val = (false_cnt == 0) ? 1 : 0;
6887 
6888       Node* cmp  = _gvn.transform(new CmpINode(result, intcon(expected_val)));
6889       Node* test = _gvn.transform(new BoolNode(cmp, BoolTest::eq));
6890 
6891       IfNode* check = create_and_map_if(control(), test, PROB_ALWAYS, COUNT_UNKNOWN);
6892       Node* fast_path = _gvn.transform(new IfTrueNode(check));
6893       Node* slow_path = _gvn.transform(new IfFalseNode(check));
6894 
6895       { // Slow path: uncommon trap for never seen value and then reexecute
6896         // MethodHandleImpl::profileBoolean() to bump the count, so JIT knows
6897         // the value has been seen at least once.
6898         PreserveJVMState pjvms(this);
6899         PreserveReexecuteState preexecs(this);
6900         jvms()-&gt;set_should_reexecute(true);
6901 
6902         set_control(slow_path);
6903         set_i_o(i_o());
6904 
6905         uncommon_trap_exact(Deoptimization::Reason_intrinsic,
6906                             Deoptimization::Action_reinterpret);
6907       }
6908       // The guard for never seen value enables sharpening of the result and
6909       // returning a constant. It allows to eliminate branches on the same value
6910       // later on.
6911       set_control(fast_path);
6912       result = intcon(expected_val);
6913     }
6914     // Stop profiling.
6915     // MethodHandleImpl::profileBoolean() has profiling logic in its bytecode.
6916     // By replacing method body with profile data (represented as ProfileBooleanNode
6917     // on IR level) we effectively disable profiling.
6918     // It enables full speed execution once optimized code is generated.
6919     Node* profile = _gvn.transform(new ProfileBooleanNode(result, false_cnt, true_cnt));
6920     C-&gt;record_for_igvn(profile);
6921     set_result(profile);
6922     return true;
6923   } else {
6924     // Continue profiling.
6925     // Profile data isn&#39;t available at the moment. So, execute method&#39;s bytecode version.
6926     // Usually, when GWT LambdaForms are profiled it means that a stand-alone nmethod
6927     // is compiled and counters aren&#39;t available since corresponding MethodHandle
6928     // isn&#39;t a compile-time constant.
6929     return false;
6930   }
6931 }
6932 
6933 bool LibraryCallKit::inline_isCompileConstant() {
6934   Node* n = argument(0);
6935   set_result(n-&gt;is_Con() ? intcon(1) : intcon(0));
6936   return true;
6937 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>