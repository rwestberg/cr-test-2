<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/vmSymbols.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/symbolTable.hpp&quot;
  28 #include &quot;classfile/vmSymbols.hpp&quot;
  29 #include &quot;compiler/compilerDirectives.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/oopFactory.hpp&quot;
  32 #include &quot;memory/metaspaceClosure.hpp&quot;
  33 #include &quot;oops/oop.inline.hpp&quot;
  34 #include &quot;runtime/handles.inline.hpp&quot;
  35 #include &quot;utilities/xmlstream.hpp&quot;
  36 
  37 
  38 Symbol* vmSymbols::_symbols[vmSymbols::SID_LIMIT];
  39 
  40 Symbol* vmSymbols::_type_signatures[T_VOID+1] = { NULL /*, NULL...*/ };
  41 
  42 inline int compare_symbol(const Symbol* a, const Symbol* b) {
  43   if (a == b)  return 0;
  44   // follow the natural address order:
  45   return (address)a &gt; (address)b ? +1 : -1;
  46 }
  47 
  48 static vmSymbols::SID vm_symbol_index[vmSymbols::SID_LIMIT];
  49 extern &quot;C&quot; {
  50   static int compare_vmsymbol_sid(const void* void_a, const void* void_b) {
  51     const Symbol* a = vmSymbols::symbol_at(*((vmSymbols::SID*) void_a));
  52     const Symbol* b = vmSymbols::symbol_at(*((vmSymbols::SID*) void_b));
  53     return compare_symbol(a, b);
  54   }
  55 }
  56 
  57 #ifdef ASSERT
  58 #define VM_SYMBOL_ENUM_NAME_BODY(name, string) #name &quot;\0&quot;
  59 static const char* vm_symbol_enum_names =
  60   VM_SYMBOLS_DO(VM_SYMBOL_ENUM_NAME_BODY, VM_ALIAS_IGNORE)
  61   &quot;\0&quot;;
  62 static const char* vm_symbol_enum_name(vmSymbols::SID sid) {
  63   const char* string = &amp;vm_symbol_enum_names[0];
  64   int skip = (int)sid - (int)vmSymbols::FIRST_SID;
  65   for (; skip != 0; skip--) {
  66     size_t skiplen = strlen(string);
  67     if (skiplen == 0)  return &quot;&lt;unknown&gt;&quot;;  // overflow
  68     string += skiplen+1;
  69   }
  70   return string;
  71 }
  72 #endif //ASSERT
  73 
  74 // Put all the VM symbol strings in one place.
  75 // Makes for a more compact libjvm.
  76 #define VM_SYMBOL_BODY(name, string) string &quot;\0&quot;
  77 static const char* vm_symbol_bodies = VM_SYMBOLS_DO(VM_SYMBOL_BODY, VM_ALIAS_IGNORE);
  78 
  79 void vmSymbols::initialize(TRAPS) {
  80   assert((int)SID_LIMIT &lt;= (1&lt;&lt;log2_SID_LIMIT), &quot;must fit in this bitfield&quot;);
  81   assert((int)SID_LIMIT*5 &gt; (1&lt;&lt;log2_SID_LIMIT), &quot;make the bitfield smaller, please&quot;);
  82   assert(vmIntrinsics::FLAG_LIMIT &lt;= (1 &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT), &quot;must fit in this bitfield&quot;);
  83 
  84   if (!UseSharedSpaces) {
  85     const char* string = &amp;vm_symbol_bodies[0];
  86     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
  87       Symbol* sym = SymbolTable::new_permanent_symbol(string);
  88       _symbols[index] = sym;
  89       string += strlen(string); // skip string body
  90       string += 1;              // skip trailing null
  91     }
  92 
  93     _type_signatures[T_BYTE]    = byte_signature();
  94     _type_signatures[T_CHAR]    = char_signature();
  95     _type_signatures[T_DOUBLE]  = double_signature();
  96     _type_signatures[T_FLOAT]   = float_signature();
  97     _type_signatures[T_INT]     = int_signature();
  98     _type_signatures[T_LONG]    = long_signature();
  99     _type_signatures[T_SHORT]   = short_signature();
 100     _type_signatures[T_BOOLEAN] = bool_signature();
 101     _type_signatures[T_VOID]    = void_signature();
 102     // no single signatures for T_OBJECT or T_ARRAY
 103 #ifdef ASSERT
 104     for (int i = (int)T_BOOLEAN; i &lt; (int)T_VOID+1; i++) {
 105       Symbol* s = _type_signatures[i];
 106       if (s == NULL)  continue;
 107       BasicType st = signature_type(s);
 108       assert(st == i, &quot;&quot;);
 109     }
 110 #endif
 111   }
 112 
 113 #ifdef ASSERT
 114   // Check for duplicates:
 115   for (int i1 = (int)FIRST_SID; i1 &lt; (int)SID_LIMIT; i1++) {
 116     Symbol* sym = symbol_at((SID)i1);
 117     for (int i2 = (int)FIRST_SID; i2 &lt; i1; i2++) {
 118       if (symbol_at((SID)i2) == sym) {
 119         tty-&gt;print(&quot;*** Duplicate VM symbol SIDs %s(%d) and %s(%d): \&quot;&quot;,
 120                    vm_symbol_enum_name((SID)i2), i2,
 121                    vm_symbol_enum_name((SID)i1), i1);
 122         sym-&gt;print_symbol_on(tty);
 123         tty-&gt;print_cr(&quot;\&quot;&quot;);
 124       }
 125     }
 126   }
 127 #endif //ASSERT
 128 
 129   // Create an index for find_id:
 130   {
 131     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 132       vm_symbol_index[index] = (SID)index;
 133     }
 134     int num_sids = SID_LIMIT-FIRST_SID;
 135     qsort(&amp;vm_symbol_index[FIRST_SID], num_sids, sizeof(vm_symbol_index[0]),
 136           compare_vmsymbol_sid);
 137   }
 138 
 139 #ifdef ASSERT
 140   {
 141     // Spot-check correspondence between strings, symbols, and enums:
 142     assert(_symbols[NO_SID] == NULL, &quot;must be&quot;);
 143     const char* str = &quot;java/lang/Object&quot;;
 144     TempNewSymbol jlo = SymbolTable::new_permanent_symbol(str);
 145     assert(strncmp(str, (char*)jlo-&gt;base(), jlo-&gt;utf8_length()) == 0, &quot;&quot;);
 146     assert(jlo == java_lang_Object(), &quot;&quot;);
 147     SID sid = VM_SYMBOL_ENUM_NAME(java_lang_Object);
 148     assert(find_sid(jlo) == sid, &quot;&quot;);
 149     assert(symbol_at(sid) == jlo, &quot;&quot;);
 150 
 151     // Make sure find_sid produces the right answer in each case.
 152     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 153       Symbol* sym = symbol_at((SID)index);
 154       sid = find_sid(sym);
 155       assert(sid == (SID)index, &quot;symbol index works&quot;);
 156       // Note:  If there are duplicates, this assert will fail.
 157       // A &quot;Duplicate VM symbol&quot; message will have already been printed.
 158     }
 159 
 160     // The string &quot;format&quot; happens (at the moment) not to be a vmSymbol,
 161     // though it is a method name in java.lang.String.
 162     str = &quot;format&quot;;
 163     TempNewSymbol fmt = SymbolTable::new_permanent_symbol(str);
 164     sid = find_sid(fmt);
 165     assert(sid == NO_SID, &quot;symbol index works (negative test)&quot;);
 166   }
 167 #endif
 168 }
 169 
 170 
 171 #ifndef PRODUCT
 172 const char* vmSymbols::name_for(vmSymbols::SID sid) {
 173   if (sid == NO_SID)
 174     return &quot;NO_SID&quot;;
 175   const char* string = &amp;vm_symbol_bodies[0];
 176   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 177     if (index == (int)sid)
 178       return string;
 179     string += strlen(string); // skip string body
 180     string += 1;              // skip trailing null
 181   }
 182   return &quot;BAD_SID&quot;;
 183 }
 184 #endif
 185 
 186 
 187 
 188 void vmSymbols::symbols_do(SymbolClosure* f) {
 189   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 190     f-&gt;do_symbol(&amp;_symbols[index]);
 191   }
 192   for (int i = 0; i &lt; T_VOID+1; i++) {
 193     f-&gt;do_symbol(&amp;_type_signatures[i]);
 194   }
 195 }
 196 
 197 void vmSymbols::metaspace_pointers_do(MetaspaceClosure *it) {
 198   for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 199     it-&gt;push(&amp;_symbols[index]);
 200   }
 201   for (int i = 0; i &lt; T_VOID+1; i++) {
 202     it-&gt;push(&amp;_type_signatures[i]);
 203   }
 204 }
 205 
 206 void vmSymbols::serialize(SerializeClosure* soc) {
 207   soc-&gt;do_region((u_char*)&amp;_symbols[FIRST_SID],
 208                  (SID_LIMIT - FIRST_SID) * sizeof(_symbols[0]));
 209   soc-&gt;do_region((u_char*)_type_signatures, sizeof(_type_signatures));
 210 }
 211 
 212 
 213 BasicType vmSymbols::signature_type(const Symbol* s) {
 214   assert(s != NULL, &quot;checking&quot;);
 215   if (s-&gt;utf8_length() == 1) {
 216     BasicType result = char2type(s-&gt;char_at(0));
 217     if (is_java_primitive(result) || result == T_VOID) {
 218       assert(s == _type_signatures[result], &quot;&quot;);
 219       return result;
 220     }
 221   }
 222   return T_OBJECT;
 223 }
 224 
 225 
 226 static int mid_hint = (int)vmSymbols::FIRST_SID+1;
 227 
 228 #ifndef PRODUCT
 229 static int find_sid_calls, find_sid_probes;
 230 // (Typical counts are calls=7000 and probes=17000.)
 231 #endif
 232 
 233 vmSymbols::SID vmSymbols::find_sid(const Symbol* symbol) {
 234   // Handle the majority of misses by a bounds check.
 235   // Then, use a binary search over the index.
 236   // Expected trip count is less than log2_SID_LIMIT, about eight.
 237   // This is slow but acceptable, given that calls are not
 238   // dynamically common.  (Method*::intrinsic_id has a cache.)
 239   NOT_PRODUCT(find_sid_calls++);
 240   int min = (int)FIRST_SID, max = (int)SID_LIMIT - 1;
 241   SID sid = NO_SID, sid1;
 242   int cmp1;
 243   sid1 = vm_symbol_index[min];
 244   cmp1 = compare_symbol(symbol, symbol_at(sid1));
 245   if (cmp1 &lt;= 0) {              // before the first
 246     if (cmp1 == 0)  sid = sid1;
 247   } else {
 248     sid1 = vm_symbol_index[max];
 249     cmp1 = compare_symbol(symbol, symbol_at(sid1));
 250     if (cmp1 &gt;= 0) {            // after the last
 251       if (cmp1 == 0)  sid = sid1;
 252     } else {
 253       // After checking the extremes, do a binary search.
 254       ++min; --max;             // endpoints are done
 255       int mid = mid_hint;       // start at previous success
 256       while (max &gt;= min) {
 257         assert(mid &gt;= min &amp;&amp; mid &lt;= max, &quot;&quot;);
 258         NOT_PRODUCT(find_sid_probes++);
 259         sid1 = vm_symbol_index[mid];
 260         cmp1 = compare_symbol(symbol, symbol_at(sid1));
 261         if (cmp1 == 0) {
 262           mid_hint = mid;
 263           sid = sid1;
 264           break;
 265         }
 266         if (cmp1 &lt; 0)
 267           max = mid - 1;        // symbol &lt; symbol_at(sid)
 268         else
 269           min = mid + 1;
 270 
 271         // Pick a new probe point:
 272         mid = (max + min) / 2;
 273       }
 274     }
 275   }
 276 
 277 #ifdef ASSERT
 278   // Perform the exhaustive self-check the first 1000 calls,
 279   // and every 100 calls thereafter.
 280   static int find_sid_check_count = -2000;
 281   if ((uint)++find_sid_check_count &gt; (uint)100) {
 282     if (find_sid_check_count &gt; 0)  find_sid_check_count = 0;
 283 
 284     // Make sure this is the right answer, using linear search.
 285     // (We have already proven that there are no duplicates in the list.)
 286     SID sid2 = NO_SID;
 287     for (int index = (int)FIRST_SID; index &lt; (int)SID_LIMIT; index++) {
 288       Symbol* sym2 = symbol_at((SID)index);
 289       if (sym2 == symbol) {
 290         sid2 = (SID)index;
 291         break;
 292       }
 293     }
 294     // Unless it&#39;s a duplicate, assert that the sids are the same.
 295     if (_symbols[sid] != _symbols[sid2]) {
 296       assert(sid == sid2, &quot;binary same as linear search&quot;);
 297     }
 298   }
 299 #endif //ASSERT
 300 
 301   return sid;
 302 }
 303 
 304 vmSymbols::SID vmSymbols::find_sid(const char* symbol_name) {
 305   Symbol* symbol = SymbolTable::probe(symbol_name, (int) strlen(symbol_name));
 306   if (symbol == NULL)  return NO_SID;
 307   return find_sid(symbol);
 308 }
 309 
 310 static vmIntrinsics::ID wrapper_intrinsic(BasicType type, bool unboxing) {
 311 #define TYPE2(type, unboxing) ((int)(type)*2 + ((unboxing) ? 1 : 0))
 312   switch (TYPE2(type, unboxing)) {
 313 #define BASIC_TYPE_CASE(type, box, unbox) \
 314     case TYPE2(type, false):  return vmIntrinsics::box; \
 315     case TYPE2(type, true):   return vmIntrinsics::unbox
 316     BASIC_TYPE_CASE(T_BOOLEAN, _Boolean_valueOf,   _booleanValue);
 317     BASIC_TYPE_CASE(T_BYTE,    _Byte_valueOf,      _byteValue);
 318     BASIC_TYPE_CASE(T_CHAR,    _Character_valueOf, _charValue);
 319     BASIC_TYPE_CASE(T_SHORT,   _Short_valueOf,     _shortValue);
 320     BASIC_TYPE_CASE(T_INT,     _Integer_valueOf,   _intValue);
 321     BASIC_TYPE_CASE(T_LONG,    _Long_valueOf,      _longValue);
 322     BASIC_TYPE_CASE(T_FLOAT,   _Float_valueOf,     _floatValue);
 323     BASIC_TYPE_CASE(T_DOUBLE,  _Double_valueOf,    _doubleValue);
 324 #undef BASIC_TYPE_CASE
 325   }
 326 #undef TYPE2
 327   return vmIntrinsics::_none;
 328 }
 329 
 330 vmIntrinsics::ID vmIntrinsics::for_boxing(BasicType type) {
 331   return wrapper_intrinsic(type, false);
 332 }
 333 vmIntrinsics::ID vmIntrinsics::for_unboxing(BasicType type) {
 334   return wrapper_intrinsic(type, true);
 335 }
 336 
 337 vmIntrinsics::ID vmIntrinsics::for_raw_conversion(BasicType src, BasicType dest) {
 338 #define SRC_DEST(s,d) (((int)(s) &lt;&lt; 4) + (int)(d))
 339   switch (SRC_DEST(src, dest)) {
 340   case SRC_DEST(T_INT, T_FLOAT):   return vmIntrinsics::_intBitsToFloat;
 341   case SRC_DEST(T_FLOAT, T_INT):   return vmIntrinsics::_floatToRawIntBits;
 342 
 343   case SRC_DEST(T_LONG, T_DOUBLE): return vmIntrinsics::_longBitsToDouble;
 344   case SRC_DEST(T_DOUBLE, T_LONG): return vmIntrinsics::_doubleToRawLongBits;
 345   }
 346 #undef SRC_DEST
 347 
 348   return vmIntrinsics::_none;
 349 }
 350 
 351 bool vmIntrinsics::preserves_state(vmIntrinsics::ID id) {
 352   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 353   switch(id) {
 354 #ifdef JFR_HAVE_INTRINSICS
 355   case vmIntrinsics::_counterTime:
 356 #endif
 357   case vmIntrinsics::_currentTimeMillis:
 358   case vmIntrinsics::_nanoTime:
 359   case vmIntrinsics::_floatToRawIntBits:
 360   case vmIntrinsics::_intBitsToFloat:
 361   case vmIntrinsics::_doubleToRawLongBits:
 362   case vmIntrinsics::_longBitsToDouble:
 363   case vmIntrinsics::_getClass:
 364   case vmIntrinsics::_isInstance:
 365   case vmIntrinsics::_currentThread:
 366   case vmIntrinsics::_scopedCache:
 367   case vmIntrinsics::_setScopedCache:
 368   case vmIntrinsics::_dabs:
 369   case vmIntrinsics::_fabs:
 370   case vmIntrinsics::_iabs:
 371   case vmIntrinsics::_labs:
 372   case vmIntrinsics::_dsqrt:
 373   case vmIntrinsics::_dsin:
 374   case vmIntrinsics::_dcos:
 375   case vmIntrinsics::_dtan:
 376   case vmIntrinsics::_dlog:
 377   case vmIntrinsics::_dlog10:
 378   case vmIntrinsics::_dexp:
 379   case vmIntrinsics::_dpow:
 380   case vmIntrinsics::_checkIndex:
 381   case vmIntrinsics::_Reference_get:
 382   case vmIntrinsics::_Continuation_doContinue:
 383   case vmIntrinsics::_Continuation_doYield:
 384   case vmIntrinsics::_Continuation_jump:
 385   case vmIntrinsics::_Continuation_getSP:
 386   case vmIntrinsics::_updateCRC32:
 387   case vmIntrinsics::_updateBytesCRC32:
 388   case vmIntrinsics::_updateByteBufferCRC32:
 389   case vmIntrinsics::_vectorizedMismatch:
 390   case vmIntrinsics::_fmaD:
 391   case vmIntrinsics::_fmaF:
 392   case vmIntrinsics::_isDigit:
 393   case vmIntrinsics::_isLowerCase:
 394   case vmIntrinsics::_isUpperCase:
 395   case vmIntrinsics::_isWhitespace:
 396     return true;
 397   default:
 398     return false;
 399   }
 400 }
 401 
 402 bool vmIntrinsics::can_trap(vmIntrinsics::ID id) {
 403   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 404   switch(id) {
 405 #ifdef JFR_HAVE_INTRINSICS
 406   case vmIntrinsics::_counterTime:
 407   case vmIntrinsics::_getClassId:
 408 #endif
 409   case vmIntrinsics::_currentTimeMillis:
 410   case vmIntrinsics::_nanoTime:
 411   case vmIntrinsics::_floatToRawIntBits:
 412   case vmIntrinsics::_intBitsToFloat:
 413   case vmIntrinsics::_doubleToRawLongBits:
 414   case vmIntrinsics::_longBitsToDouble:
 415   case vmIntrinsics::_currentThread:
 416   case vmIntrinsics::_scopedCache:
 417   case vmIntrinsics::_setScopedCache:
 418   case vmIntrinsics::_dabs:
 419   case vmIntrinsics::_fabs:
 420   case vmIntrinsics::_iabs:
 421   case vmIntrinsics::_labs:
 422   case vmIntrinsics::_dsqrt:
 423   case vmIntrinsics::_dsin:
 424   case vmIntrinsics::_dcos:
 425   case vmIntrinsics::_dtan:
 426   case vmIntrinsics::_dlog:
 427   case vmIntrinsics::_dlog10:
 428   case vmIntrinsics::_dexp:
 429   case vmIntrinsics::_dpow:
 430   case vmIntrinsics::_updateCRC32:
 431   case vmIntrinsics::_updateBytesCRC32:
 432   case vmIntrinsics::_updateByteBufferCRC32:
 433   case vmIntrinsics::_vectorizedMismatch:
 434   case vmIntrinsics::_fmaD:
 435   case vmIntrinsics::_fmaF:
 436     return false;
 437   default:
 438     return true;
 439   }
 440 }
 441 
 442 // Some intrinsics produce different results if they are not pinned
 443 bool vmIntrinsics::should_be_pinned(vmIntrinsics::ID id) {
 444   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 445   switch(id) {
 446 #ifdef JFR_HAVE_INTRINSICS
 447   case vmIntrinsics::_counterTime:
 448 #endif
 449   case vmIntrinsics::_currentTimeMillis:
 450   case vmIntrinsics::_nanoTime:
 451     return true;
 452   default:
 453     return false;
 454   }
 455 }
 456 
 457 bool vmIntrinsics::does_virtual_dispatch(vmIntrinsics::ID id) {
 458   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 459   switch(id) {
 460   case vmIntrinsics::_hashCode:
 461   case vmIntrinsics::_clone:
 462     return true;
 463     break;
 464   default:
 465     return false;
 466   }
 467 }
 468 
 469 int vmIntrinsics::predicates_needed(vmIntrinsics::ID id) {
 470   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 471   switch (id) {
 472   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 473   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 474   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 475   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 476   case vmIntrinsics::_counterMode_AESCrypt:
 477     return 1;
 478   case vmIntrinsics::_digestBase_implCompressMB:
 479     return 3;
 480   default:
 481     return 0;
 482   }
 483 }
 484 
 485 bool vmIntrinsics::is_intrinsic_available(vmIntrinsics::ID id) {
 486   return !vmIntrinsics::is_intrinsic_disabled(id) &amp;&amp;
 487     !vmIntrinsics::is_disabled_by_flags(id);
 488 }
 489 
 490 bool vmIntrinsics::is_intrinsic_disabled(vmIntrinsics::ID id) {
 491   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 492 
 493   // Canonicalize DisableIntrinsic to contain only &#39;,&#39; as a separator.
 494   // Note, DirectiveSet may not be created at this point yet since this code
 495   // is called from initial stub geenration code.
 496   char* local_list = (char*)DirectiveSet::canonicalize_disableintrinsic(DisableIntrinsic);
 497   char* save_ptr;
 498   bool found = false;
 499 
 500   char* token = strtok_r(local_list, &quot;,&quot;, &amp;save_ptr);
 501   while (token != NULL) {
 502     if (strcmp(token, vmIntrinsics::name_at(id)) == 0) {
 503       found = true;
 504       break;
 505     } else {
 506       token = strtok_r(NULL, &quot;,&quot;, &amp;save_ptr);
 507     }
 508   }
 509 
 510   FREE_C_HEAP_ARRAY(char, local_list);
 511   return found;
 512 }
 513 
 514 
 515 bool vmIntrinsics::is_disabled_by_flags(const methodHandle&amp; method) {
 516   vmIntrinsics::ID id = method-&gt;intrinsic_id();
 517   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 518   return is_disabled_by_flags(id);
 519 }
 520 
 521 bool vmIntrinsics::is_disabled_by_flags(vmIntrinsics::ID id) {
 522   assert(id != vmIntrinsics::_none, &quot;must be a VM intrinsic&quot;);
 523 
 524   // -XX:-InlineNatives disables nearly all intrinsics except the ones listed in
 525   // the following switch statement.
 526   if (!InlineNatives) {
 527     switch (id) {
 528     case vmIntrinsics::_indexOfL:
 529     case vmIntrinsics::_indexOfU:
 530     case vmIntrinsics::_indexOfUL:
 531     case vmIntrinsics::_indexOfIL:
 532     case vmIntrinsics::_indexOfIU:
 533     case vmIntrinsics::_indexOfIUL:
 534     case vmIntrinsics::_indexOfU_char:
 535     case vmIntrinsics::_compareToL:
 536     case vmIntrinsics::_compareToU:
 537     case vmIntrinsics::_compareToLU:
 538     case vmIntrinsics::_compareToUL:
 539     case vmIntrinsics::_equalsL:
 540     case vmIntrinsics::_equalsU:
 541     case vmIntrinsics::_equalsC:
 542     case vmIntrinsics::_getCharStringU:
 543     case vmIntrinsics::_putCharStringU:
 544     case vmIntrinsics::_compressStringC:
 545     case vmIntrinsics::_compressStringB:
 546     case vmIntrinsics::_inflateStringC:
 547     case vmIntrinsics::_inflateStringB:
 548     case vmIntrinsics::_getAndAddInt:
 549     case vmIntrinsics::_getAndAddLong:
 550     case vmIntrinsics::_getAndSetInt:
 551     case vmIntrinsics::_getAndSetLong:
 552     case vmIntrinsics::_getAndSetReference:
 553     case vmIntrinsics::_loadFence:
 554     case vmIntrinsics::_storeFence:
 555     case vmIntrinsics::_fullFence:
 556     case vmIntrinsics::_hasNegatives:
 557     case vmIntrinsics::_Reference_get:
 558     case vmIntrinsics::_Continuation_doContinue:
 559     case vmIntrinsics::_Continuation_doYield:
 560     case vmIntrinsics::_Continuation_jump:
 561     case vmIntrinsics::_Continuation_getSP:
 562       break;
 563     default:
 564       return true;
 565     }
 566   }
 567 
 568   switch (id) {
 569   case vmIntrinsics::_isInstance:
 570   case vmIntrinsics::_isAssignableFrom:
 571   case vmIntrinsics::_getModifiers:
 572   case vmIntrinsics::_isInterface:
 573   case vmIntrinsics::_isArray:
 574   case vmIntrinsics::_isPrimitive:
 575   case vmIntrinsics::_getSuperclass:
 576   case vmIntrinsics::_Class_cast:
 577   case vmIntrinsics::_getLength:
 578   case vmIntrinsics::_newArray:
 579   case vmIntrinsics::_getClass:
 580     if (!InlineClassNatives) return true;
 581     break;
 582   case vmIntrinsics::_currentThread:
 583     if (!InlineThreadNatives) return true;
 584     break;
 585   case vmIntrinsics::_scopedCache:
 586   case vmIntrinsics::_setScopedCache:
 587   case vmIntrinsics::_floatToRawIntBits:
 588   case vmIntrinsics::_intBitsToFloat:
 589   case vmIntrinsics::_doubleToRawLongBits:
 590   case vmIntrinsics::_longBitsToDouble:
 591   case vmIntrinsics::_ceil:
 592   case vmIntrinsics::_floor:
 593   case vmIntrinsics::_rint:
 594   case vmIntrinsics::_dabs:
 595   case vmIntrinsics::_fabs:
 596   case vmIntrinsics::_iabs:
 597   case vmIntrinsics::_labs:
 598   case vmIntrinsics::_dsqrt:
 599   case vmIntrinsics::_dsin:
 600   case vmIntrinsics::_dcos:
 601   case vmIntrinsics::_dtan:
 602   case vmIntrinsics::_dlog:
 603   case vmIntrinsics::_dexp:
 604   case vmIntrinsics::_dpow:
 605   case vmIntrinsics::_dlog10:
 606   case vmIntrinsics::_datan2:
 607   case vmIntrinsics::_min:
 608   case vmIntrinsics::_max:
 609   case vmIntrinsics::_floatToIntBits:
 610   case vmIntrinsics::_doubleToLongBits:
 611   case vmIntrinsics::_maxF:
 612   case vmIntrinsics::_minF:
 613   case vmIntrinsics::_maxD:
 614   case vmIntrinsics::_minD:
 615     if (!InlineMathNatives) return true;
 616     break;
 617   case vmIntrinsics::_fmaD:
 618   case vmIntrinsics::_fmaF:
 619     if (!InlineMathNatives || !UseFMA) return true;
 620     break;
 621   case vmIntrinsics::_arraycopy:
 622     if (!InlineArrayCopy) return true;
 623     break;
 624   case vmIntrinsics::_updateCRC32:
 625   case vmIntrinsics::_updateBytesCRC32:
 626   case vmIntrinsics::_updateByteBufferCRC32:
 627     if (!UseCRC32Intrinsics) return true;
 628     break;
 629   case vmIntrinsics::_getReference:
 630   case vmIntrinsics::_getBoolean:
 631   case vmIntrinsics::_getByte:
 632   case vmIntrinsics::_getShort:
 633   case vmIntrinsics::_getChar:
 634   case vmIntrinsics::_getInt:
 635   case vmIntrinsics::_getLong:
 636   case vmIntrinsics::_getFloat:
 637   case vmIntrinsics::_getDouble:
 638   case vmIntrinsics::_putReference:
 639   case vmIntrinsics::_putBoolean:
 640   case vmIntrinsics::_putByte:
 641   case vmIntrinsics::_putShort:
 642   case vmIntrinsics::_putChar:
 643   case vmIntrinsics::_putInt:
 644   case vmIntrinsics::_putLong:
 645   case vmIntrinsics::_putFloat:
 646   case vmIntrinsics::_putDouble:
 647   case vmIntrinsics::_getReferenceVolatile:
 648   case vmIntrinsics::_getBooleanVolatile:
 649   case vmIntrinsics::_getByteVolatile:
 650   case vmIntrinsics::_getShortVolatile:
 651   case vmIntrinsics::_getCharVolatile:
 652   case vmIntrinsics::_getIntVolatile:
 653   case vmIntrinsics::_getLongVolatile:
 654   case vmIntrinsics::_getFloatVolatile:
 655   case vmIntrinsics::_getDoubleVolatile:
 656   case vmIntrinsics::_putReferenceVolatile:
 657   case vmIntrinsics::_putBooleanVolatile:
 658   case vmIntrinsics::_putByteVolatile:
 659   case vmIntrinsics::_putShortVolatile:
 660   case vmIntrinsics::_putCharVolatile:
 661   case vmIntrinsics::_putIntVolatile:
 662   case vmIntrinsics::_putLongVolatile:
 663   case vmIntrinsics::_putFloatVolatile:
 664   case vmIntrinsics::_putDoubleVolatile:
 665   case vmIntrinsics::_getReferenceAcquire:
 666   case vmIntrinsics::_getBooleanAcquire:
 667   case vmIntrinsics::_getByteAcquire:
 668   case vmIntrinsics::_getShortAcquire:
 669   case vmIntrinsics::_getCharAcquire:
 670   case vmIntrinsics::_getIntAcquire:
 671   case vmIntrinsics::_getLongAcquire:
 672   case vmIntrinsics::_getFloatAcquire:
 673   case vmIntrinsics::_getDoubleAcquire:
 674   case vmIntrinsics::_putReferenceRelease:
 675   case vmIntrinsics::_putBooleanRelease:
 676   case vmIntrinsics::_putByteRelease:
 677   case vmIntrinsics::_putShortRelease:
 678   case vmIntrinsics::_putCharRelease:
 679   case vmIntrinsics::_putIntRelease:
 680   case vmIntrinsics::_putLongRelease:
 681   case vmIntrinsics::_putFloatRelease:
 682   case vmIntrinsics::_putDoubleRelease:
 683   case vmIntrinsics::_getReferenceOpaque:
 684   case vmIntrinsics::_getBooleanOpaque:
 685   case vmIntrinsics::_getByteOpaque:
 686   case vmIntrinsics::_getShortOpaque:
 687   case vmIntrinsics::_getCharOpaque:
 688   case vmIntrinsics::_getIntOpaque:
 689   case vmIntrinsics::_getLongOpaque:
 690   case vmIntrinsics::_getFloatOpaque:
 691   case vmIntrinsics::_getDoubleOpaque:
 692   case vmIntrinsics::_putReferenceOpaque:
 693   case vmIntrinsics::_putBooleanOpaque:
 694   case vmIntrinsics::_putByteOpaque:
 695   case vmIntrinsics::_putShortOpaque:
 696   case vmIntrinsics::_putCharOpaque:
 697   case vmIntrinsics::_putIntOpaque:
 698   case vmIntrinsics::_putLongOpaque:
 699   case vmIntrinsics::_putFloatOpaque:
 700   case vmIntrinsics::_putDoubleOpaque:
 701   case vmIntrinsics::_getAndAddInt:
 702   case vmIntrinsics::_getAndAddLong:
 703   case vmIntrinsics::_getAndSetInt:
 704   case vmIntrinsics::_getAndSetLong:
 705   case vmIntrinsics::_getAndSetReference:
 706   case vmIntrinsics::_loadFence:
 707   case vmIntrinsics::_storeFence:
 708   case vmIntrinsics::_fullFence:
 709   case vmIntrinsics::_compareAndSetLong:
 710   case vmIntrinsics::_weakCompareAndSetLong:
 711   case vmIntrinsics::_weakCompareAndSetLongPlain:
 712   case vmIntrinsics::_weakCompareAndSetLongAcquire:
 713   case vmIntrinsics::_weakCompareAndSetLongRelease:
 714   case vmIntrinsics::_compareAndSetInt:
 715   case vmIntrinsics::_weakCompareAndSetInt:
 716   case vmIntrinsics::_weakCompareAndSetIntPlain:
 717   case vmIntrinsics::_weakCompareAndSetIntAcquire:
 718   case vmIntrinsics::_weakCompareAndSetIntRelease:
 719   case vmIntrinsics::_compareAndSetReference:
 720   case vmIntrinsics::_weakCompareAndSetReference:
 721   case vmIntrinsics::_weakCompareAndSetReferencePlain:
 722   case vmIntrinsics::_weakCompareAndSetReferenceAcquire:
 723   case vmIntrinsics::_weakCompareAndSetReferenceRelease:
 724   case vmIntrinsics::_compareAndExchangeInt:
 725   case vmIntrinsics::_compareAndExchangeIntAcquire:
 726   case vmIntrinsics::_compareAndExchangeIntRelease:
 727   case vmIntrinsics::_compareAndExchangeLong:
 728   case vmIntrinsics::_compareAndExchangeLongAcquire:
 729   case vmIntrinsics::_compareAndExchangeLongRelease:
 730   case vmIntrinsics::_compareAndExchangeReference:
 731   case vmIntrinsics::_compareAndExchangeReferenceAcquire:
 732   case vmIntrinsics::_compareAndExchangeReferenceRelease:
 733     if (!InlineUnsafeOps) return true;
 734     break;
 735   case vmIntrinsics::_getShortUnaligned:
 736   case vmIntrinsics::_getCharUnaligned:
 737   case vmIntrinsics::_getIntUnaligned:
 738   case vmIntrinsics::_getLongUnaligned:
 739   case vmIntrinsics::_putShortUnaligned:
 740   case vmIntrinsics::_putCharUnaligned:
 741   case vmIntrinsics::_putIntUnaligned:
 742   case vmIntrinsics::_putLongUnaligned:
 743   case vmIntrinsics::_allocateInstance:
 744     if (!InlineUnsafeOps || !UseUnalignedAccesses) return true;
 745     break;
 746   case vmIntrinsics::_hashCode:
 747     if (!InlineObjectHash) return true;
 748     break;
 749   case vmIntrinsics::_aescrypt_encryptBlock:
 750   case vmIntrinsics::_aescrypt_decryptBlock:
 751     if (!UseAESIntrinsics) return true;
 752     break;
 753   case vmIntrinsics::_cipherBlockChaining_encryptAESCrypt:
 754   case vmIntrinsics::_cipherBlockChaining_decryptAESCrypt:
 755     if (!UseAESIntrinsics) return true;
 756     break;
 757   case vmIntrinsics::_electronicCodeBook_encryptAESCrypt:
 758   case vmIntrinsics::_electronicCodeBook_decryptAESCrypt:
 759     if (!UseAESIntrinsics) return true;
 760     break;
 761   case vmIntrinsics::_counterMode_AESCrypt:
 762     if (!UseAESCTRIntrinsics) return true;
 763     break;
 764   case vmIntrinsics::_sha_implCompress:
 765     if (!UseSHA1Intrinsics) return true;
 766     break;
 767   case vmIntrinsics::_sha2_implCompress:
 768     if (!UseSHA256Intrinsics) return true;
 769     break;
 770   case vmIntrinsics::_sha5_implCompress:
 771     if (!UseSHA512Intrinsics) return true;
 772     break;
 773   case vmIntrinsics::_digestBase_implCompressMB:
 774     if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) return true;
 775     break;
 776   case vmIntrinsics::_ghash_processBlocks:
 777     if (!UseGHASHIntrinsics) return true;
 778     break;
 779   case vmIntrinsics::_base64_encodeBlock:
 780     if (!UseBASE64Intrinsics) return true;
 781     break;
 782   case vmIntrinsics::_updateBytesCRC32C:
 783   case vmIntrinsics::_updateDirectByteBufferCRC32C:
 784     if (!UseCRC32CIntrinsics) return true;
 785     break;
 786   case vmIntrinsics::_vectorizedMismatch:
 787     if (!UseVectorizedMismatchIntrinsic) return true;
 788     break;
 789   case vmIntrinsics::_updateBytesAdler32:
 790   case vmIntrinsics::_updateByteBufferAdler32:
 791     if (!UseAdler32Intrinsics) return true;
 792     break;
 793   case vmIntrinsics::_copyMemory:
 794     if (!InlineArrayCopy || !InlineUnsafeOps) return true;
 795     break;
 796 #ifdef COMPILER1
 797   case vmIntrinsics::_checkIndex:
 798     if (!InlineNIOCheckIndex) return true;
 799     break;
 800 #endif // COMPILER1
 801 #ifdef COMPILER2
 802   case vmIntrinsics::_clone:
 803   case vmIntrinsics::_copyOf:
 804   case vmIntrinsics::_copyOfRange:
 805     // These intrinsics use both the objectcopy and the arraycopy
 806     // intrinsic mechanism.
 807     if (!InlineObjectCopy || !InlineArrayCopy) return true;
 808     break;
 809   case vmIntrinsics::_compareToL:
 810   case vmIntrinsics::_compareToU:
 811   case vmIntrinsics::_compareToLU:
 812   case vmIntrinsics::_compareToUL:
 813     if (!SpecialStringCompareTo) return true;
 814     break;
 815   case vmIntrinsics::_indexOfL:
 816   case vmIntrinsics::_indexOfU:
 817   case vmIntrinsics::_indexOfUL:
 818   case vmIntrinsics::_indexOfIL:
 819   case vmIntrinsics::_indexOfIU:
 820   case vmIntrinsics::_indexOfIUL:
 821   case vmIntrinsics::_indexOfU_char:
 822     if (!SpecialStringIndexOf) return true;
 823     break;
 824   case vmIntrinsics::_equalsL:
 825   case vmIntrinsics::_equalsU:
 826     if (!SpecialStringEquals) return true;
 827     break;
 828   case vmIntrinsics::_equalsB:
 829   case vmIntrinsics::_equalsC:
 830     if (!SpecialArraysEquals) return true;
 831     break;
 832   case vmIntrinsics::_encodeISOArray:
 833   case vmIntrinsics::_encodeByteISOArray:
 834     if (!SpecialEncodeISOArray) return true;
 835     break;
 836   case vmIntrinsics::_getCallerClass:
 837     if (!InlineReflectionGetCallerClass) return true;
 838     break;
 839   case vmIntrinsics::_multiplyToLen:
 840     if (!UseMultiplyToLenIntrinsic) return true;
 841     break;
 842   case vmIntrinsics::_squareToLen:
 843     if (!UseSquareToLenIntrinsic) return true;
 844     break;
 845   case vmIntrinsics::_mulAdd:
 846     if (!UseMulAddIntrinsic) return true;
 847     break;
 848   case vmIntrinsics::_montgomeryMultiply:
 849     if (!UseMontgomeryMultiplyIntrinsic) return true;
 850     break;
 851   case vmIntrinsics::_montgomerySquare:
 852     if (!UseMontgomerySquareIntrinsic) return true;
 853     break;
 854   case vmIntrinsics::_bigIntegerRightShiftWorker:
 855   case vmIntrinsics::_bigIntegerLeftShiftWorker:
 856     break;
 857   case vmIntrinsics::_addExactI:
 858   case vmIntrinsics::_addExactL:
 859   case vmIntrinsics::_decrementExactI:
 860   case vmIntrinsics::_decrementExactL:
 861   case vmIntrinsics::_incrementExactI:
 862   case vmIntrinsics::_incrementExactL:
 863   case vmIntrinsics::_multiplyExactI:
 864   case vmIntrinsics::_multiplyExactL:
 865   case vmIntrinsics::_negateExactI:
 866   case vmIntrinsics::_negateExactL:
 867   case vmIntrinsics::_subtractExactI:
 868   case vmIntrinsics::_subtractExactL:
 869     if (!UseMathExactIntrinsics || !InlineMathNatives) return true;
 870     break;
 871   case vmIntrinsics::_isDigit:
 872   case vmIntrinsics::_isLowerCase:
 873   case vmIntrinsics::_isUpperCase:
 874   case vmIntrinsics::_isWhitespace:
 875     if (!UseCharacterCompareIntrinsics) return true;
 876     break;
 877 #endif // COMPILER2
 878   default:
 879     return false;
 880   }
 881 
 882   return false;
 883 }
 884 
 885 #define VM_INTRINSIC_INITIALIZE(id, klass, name, sig, flags) #id &quot;\0&quot;
 886 static const char* vm_intrinsic_name_bodies =
 887   VM_INTRINSICS_DO(VM_INTRINSIC_INITIALIZE,
 888                    VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
 889 
 890 static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];
 891 
 892 const char* vmIntrinsics::name_at(vmIntrinsics::ID id) {
 893   const char** nt = &amp;vm_intrinsic_name_table[0];
 894   if (nt[_none] == NULL) {
 895     char* string = (char*) &amp;vm_intrinsic_name_bodies[0];
 896     for (int index = FIRST_ID; index &lt; ID_LIMIT; index++) {
 897       nt[index] = string;
 898       string += strlen(string); // skip string body
 899       string += 1;              // skip trailing null
 900     }
 901     assert(!strcmp(nt[_hashCode], &quot;_hashCode&quot;), &quot;lined up&quot;);
 902     nt[_none] = &quot;_none&quot;;
 903   }
 904   if ((uint)id &lt; (uint)ID_LIMIT)
 905     return vm_intrinsic_name_table[(uint)id];
 906   else
 907     return &quot;(unknown intrinsic)&quot;;
 908 }
 909 
 910 // These are flag-matching functions:
 911 inline bool match_F_R(jshort flags) {
 912   const int req = 0;
 913   const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;
 914   return (flags &amp; (req | neg)) == req;
 915 }
 916 inline bool match_F_Y(jshort flags) {
 917   const int req = JVM_ACC_SYNCHRONIZED;
 918   const int neg = JVM_ACC_STATIC;
 919   return (flags &amp; (req | neg)) == req;
 920 }
 921 inline bool match_F_RN(jshort flags) {
 922   const int req = JVM_ACC_NATIVE;
 923   const int neg = JVM_ACC_STATIC | JVM_ACC_SYNCHRONIZED;
 924   return (flags &amp; (req | neg)) == req;
 925 }
 926 inline bool match_F_S(jshort flags) {
 927   const int req = JVM_ACC_STATIC;
 928   const int neg = JVM_ACC_SYNCHRONIZED;
 929   return (flags &amp; (req | neg)) == req;
 930 }
 931 inline bool match_F_SN(jshort flags) {
 932   const int req = JVM_ACC_STATIC | JVM_ACC_NATIVE;
 933   const int neg = JVM_ACC_SYNCHRONIZED;
 934   return (flags &amp; (req | neg)) == req;
 935 }
 936 inline bool match_F_RNY(jshort flags) {
 937   const int req = JVM_ACC_NATIVE | JVM_ACC_SYNCHRONIZED;
 938   const int neg = JVM_ACC_STATIC;
 939   return (flags &amp; (req | neg)) == req;
 940 }
 941 
 942 // These are for forming case labels:
 943 #define ID3(x, y, z) (( jlong)(z) +                                  \
 944                       ((jlong)(y) &lt;&lt;    vmSymbols::log2_SID_LIMIT) + \
 945                       ((jlong)(x) &lt;&lt; (2*vmSymbols::log2_SID_LIMIT))  )
 946 #define SID_ENUM(n) vmSymbols::VM_SYMBOL_ENUM_NAME(n)
 947 
 948 vmIntrinsics::ID vmIntrinsics::find_id_impl(vmSymbols::SID holder,
 949                                             vmSymbols::SID name,
 950                                             vmSymbols::SID sig,
 951                                             jshort flags) {
 952   assert((int)vmSymbols::SID_LIMIT &lt;= (1&lt;&lt;vmSymbols::log2_SID_LIMIT), &quot;must fit&quot;);
 953 
 954   // Let the C compiler build the decision tree.
 955 
 956 #define VM_INTRINSIC_CASE(id, klass, name, sig, fcode) \
 957   case ID3(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig)): \
 958     if (!match_##fcode(flags))  break; \
 959     return id;
 960 
 961   switch (ID3(holder, name, sig)) {
 962     VM_INTRINSICS_DO(VM_INTRINSIC_CASE,
 963                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
 964   }
 965   return vmIntrinsics::_none;
 966 
 967 #undef VM_INTRINSIC_CASE
 968 }
 969 
 970 
 971 const char* vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID id, char* buf, int buflen) {
 972   const char* str = name_at(id);
 973 #ifndef PRODUCT
 974   const char* kname = vmSymbols::name_for(class_for(id));
 975   const char* mname = vmSymbols::name_for(name_for(id));
 976   const char* sname = vmSymbols::name_for(signature_for(id));
 977   const char* fname = &quot;&quot;;
 978   switch (flags_for(id)) {
 979   case F_Y:  fname = &quot;synchronized &quot;;  break;
 980   case F_RN: fname = &quot;native &quot;;        break;
 981   case F_SN: fname = &quot;native static &quot;; break;
 982   case F_S:  fname = &quot;static &quot;;        break;
 983   case F_RNY:fname = &quot;native synchronized &quot;; break;
 984   default:   break;
 985   }
 986   const char* kptr = strrchr(kname, JVM_SIGNATURE_SLASH);
 987   if (kptr != NULL)  kname = kptr + 1;
 988   int len = jio_snprintf(buf, buflen, &quot;%s: %s%s.%s%s&quot;,
 989                          str, fname, kname, mname, sname);
 990   if (len &lt; buflen)
 991     str = buf;
 992 #endif //PRODUCT
 993   return str;
 994 }
 995 
 996 
 997 // These are to get information about intrinsics.
 998 
 999 #define ID4(x, y, z, f) ((ID3(x, y, z) &lt;&lt; vmIntrinsics::log2_FLAG_LIMIT) | (jlong) (f))
1000 
1001 static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {
1002 #define VM_INTRINSIC_INFO(ignore_id, klass, name, sig, fcode) \
1003   ID4(SID_ENUM(klass), SID_ENUM(name), SID_ENUM(sig), vmIntrinsics::fcode),
1004 
1005   0, VM_INTRINSICS_DO(VM_INTRINSIC_INFO,
1006                      VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)
1007     0
1008 #undef VM_INTRINSIC_INFO
1009 };
1010 
1011 inline jlong intrinsic_info(vmIntrinsics::ID id) {
1012   return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];
1013 }
1014 
1015 vmSymbols::SID vmIntrinsics::class_for(vmIntrinsics::ID id) {
1016   jlong info = intrinsic_info(id);
1017   int shift = 2*vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1018   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1021, &quot;&quot;);
1019   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1020 }
1021 
1022 vmSymbols::SID vmIntrinsics::name_for(vmIntrinsics::ID id) {
1023   jlong info = intrinsic_info(id);
1024   int shift = vmSymbols::log2_SID_LIMIT + log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1025   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1022, &quot;&quot;);
1026   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1027 }
1028 
1029 vmSymbols::SID vmIntrinsics::signature_for(vmIntrinsics::ID id) {
1030   jlong info = intrinsic_info(id);
1031   int shift = log2_FLAG_LIMIT, mask = right_n_bits(vmSymbols::log2_SID_LIMIT);
1032   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 1023, &quot;&quot;);
1033   return vmSymbols::SID( (info &gt;&gt; shift) &amp; mask );
1034 }
1035 
1036 vmIntrinsics::Flags vmIntrinsics::flags_for(vmIntrinsics::ID id) {
1037   jlong info = intrinsic_info(id);
1038   int shift = 0, mask = right_n_bits(log2_FLAG_LIMIT);
1039   assert(((ID4(1021,1022,1023,15) &gt;&gt; shift) &amp; mask) == 15, &quot;&quot;);
1040   return Flags( (info &gt;&gt; shift) &amp; mask );
1041 }
1042 
1043 
1044 #ifndef PRODUCT
1045 // verify_method performs an extra check on a matched intrinsic method
1046 
1047 static bool match_method(Method* m, Symbol* n, Symbol* s) {
1048   return (m-&gt;name() == n &amp;&amp;
1049           m-&gt;signature() == s);
1050 }
1051 
1052 static vmIntrinsics::ID match_method_with_klass(Method* m, Symbol* mk) {
1053 #define VM_INTRINSIC_MATCH(id, klassname, namepart, sigpart, flags) \
1054   { Symbol* k = vmSymbols::klassname(); \
1055     if (mk == k) { \
1056       Symbol* n = vmSymbols::namepart(); \
1057       Symbol* s = vmSymbols::sigpart(); \
1058       if (match_method(m, n, s)) \
1059         return vmIntrinsics::id; \
1060     } }
1061   VM_INTRINSICS_DO(VM_INTRINSIC_MATCH,
1062                    VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE);
1063   return vmIntrinsics::_none;
1064 #undef VM_INTRINSIC_MATCH
1065 }
1066 
1067 void vmIntrinsics::verify_method(ID actual_id, Method* m) {
1068   Symbol* mk = m-&gt;method_holder()-&gt;name();
1069   ID declared_id = match_method_with_klass(m, mk);
1070 
1071   if (declared_id == actual_id)  return; // success
1072 
1073   if (declared_id == _none &amp;&amp; actual_id != _none &amp;&amp; mk == vmSymbols::java_lang_StrictMath()) {
1074     // Here are a few special cases in StrictMath not declared in vmSymbols.hpp.
1075     switch (actual_id) {
1076     case _min:
1077     case _max:
1078     case _dsqrt:
1079       declared_id = match_method_with_klass(m, vmSymbols::java_lang_Math());
1080       if (declared_id == actual_id)  return; // acceptable alias
1081       break;
1082     default:
1083         break;
1084     }
1085   }
1086 
1087   const char* declared_name = name_at(declared_id);
1088   const char* actual_name   = name_at(actual_id);
1089   m = NULL;
1090   ttyLocker ttyl;
1091   if (xtty != NULL) {
1092     xtty-&gt;begin_elem(&quot;intrinsic_misdeclared actual=&#39;%s&#39; declared=&#39;%s&#39;&quot;,
1093                      actual_name, declared_name);
1094     xtty-&gt;method(m);
1095     xtty-&gt;end_elem(&quot;%s&quot;, &quot;&quot;);
1096   }
1097   if (PrintMiscellaneous &amp;&amp; (WizardMode || Verbose)) {
1098     tty-&gt;print_cr(&quot;*** misidentified method; %s(%d) should be %s(%d):&quot;,
1099                   declared_name, declared_id, actual_name, actual_id);
1100     m-&gt;print_short_name(tty);
1101     tty-&gt;cr();
1102   }
1103 }
1104 #endif //PRODUCT
    </pre>
  </body>
</html>